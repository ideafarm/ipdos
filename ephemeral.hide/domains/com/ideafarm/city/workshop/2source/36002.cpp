//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\1snip.1a000002.includeGenMake.base.hide.third : 1snip.1a000002.includegenmake.base.hide.third BEGIN
#define DDNAME       "1snip.1a000002.includegenmake.base.hide.third"
#define DDNUMB      (countT)0x1a000002
#define IDFILE      (countT)0x86a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.005f002.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
*/
/**/
/*1*//*this includes the base hide flavor of ipdos.h*//*1*/
#include "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\ipdos.base.hide.third.1.h"
#include "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\ipdos.base.hide.third.2.h"


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\1snip.1a000002.includeGenMake.base.hide.third : 1snip.1a000002.includegenmake.base.hide.third END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002001.etherc.etherc BEGIN
#define DDNAME       "3func.36002001.etherc.etherc"
#define DDNUMB      (countT)0x36002001
#define IDFILE      (countT)0xc2d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.1030002.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.e010104.1.1.0.html\"\>e010104:  WAKEsHOW( "example.simplest.func.1030002.etherC.etherC" )\</A\>
arguments
 idLineCtP
 idiFileCtP
 flagsModeP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010098.flTHIRDmODE!||
 flagsWatchP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010091.flWATCH!||
*/
/**/

/*1*/etherC::etherC( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const flagsT flagsModeP , const flagsT flagsWatchP , const osTextT* const postNameP )/*1*/ :
baseSoilXxxxC( tinP.pAdamGlobal1->_etherC_.postOldClassName , postName ) ,
postName( 0 ) ,
third( tinP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , flagsModeP , flagsWatchP ) ,
poop( (poopC&)(const poopC&)third ) ,
etherInit( tinP , (countT)this ) ,
bClocks( tinP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , 0 , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) ,
idLineCt( idLineCtP ) ,
idiFileCt( idiFileCtP ) ,
idTraceLevel( 0 ) ,
idTraceType( 0 ) ,
psttLog( 0 ) ,
timeBorn1( 0 ) ,
timeBorn2( 0 ) ,
timeSleep1( 0 ) ,
timeSleep2( 0 ) ,
timeSlept1( 0 ) ,
timeSlept2( 0 ) ,
//pcFunctionEntries( third.pcFunctionEntries ) ,
//pcFunctionExits( third.pcFunctionExits ) ,
//pcFunctionTime1( third.pcFunctionTime1 ) ,
//pcFunctionTime2( third.pcFunctionTime2 ) ,
//bFunctionCountersReady( third.bFunctionCountersReady ) ,
//pcRaceId( 0 ) ,
flagsMode( third.flagsMode ) ,
flagsWatch( third.flagsWatch ) ,
psttUid( 0 ) ,
cProgressDflt( 0 )
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        FV( flTHIRDmODE , flagsModeP ) ;
        FV( flWATCH     , flagsWatchP ) ;
        if( POOP ) return ;
    }

    _IO_

    if( pbBitsCtP ) thirdC::c_memcpyIF( tinP , (byteT*)pbBitsCt , (byteT*)pbBitsCtP , sizeof pbBitsCt ) ;
    else            thirdC::c_memsetIF( tinP , (byteT*)pbBitsCt , sizeof pbBitsCt ) ;

    if( postNameP )
    {
        countT costName = thirdC::c_strlenIF( tinP , postNameP ) ;
        newF( tinP , LF , *(osTextT**)&postName , 1 + costName ) ; ___( postName ) ;
        thirdC::c_memcpyIF( tinP , *(osTextT**)&postName , postNameP , 1 + costName ) ;
    }
    third.osTimeNowF( tinP , timeBorn1 , timeBorn2 ) ;
    //if( pcFunctionEntries && pcFunctionExits && pcFunctionTime1 && pcFunctionTime2 ) bFunctionCountersReady = 1 ;
    spacerSetF( tinP ) ;

    third.pEtherContainsMe = this ;

    third.pswWinFromDraw                = new( 0 , tinP , LF ) switchC( tinP , third , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) , flSTACKc_null , third.lever_swWinFromDraw                ) ; ___( third.pswWinFromDraw ) ;
    third.pswWinFromDrawDuringPaint     = new( 0 , tinP , LF ) switchC( tinP , third , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) , flSTACKc_null , third.lever_swWinFromDrawDuringPaint     ) ; ___( third.pswWinFromDrawDuringPaint ) ;
    third.pswPaintInfoFromDrawingHandle = new( 0 , tinP , LF ) switchC( tinP , third , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) , flSTACKc_null , third.lever_swPaintInfoFromDrawingHandle ) ; ___( third.pswPaintInfoFromDrawingHandle ) ;

    if( &tinP != &processGlobal3I.tinVeryVeryEarlyLateMain && tinP.pAdamGlobal1->_etherC_.pEtPrime && tinP.pAdamGlobal1->_etherC_.pSwEtThread && *tinP.pAdamGlobal1->_etherC_.pSwEtThread == (countT)this ) tinP.pEther = this ;

    if( this == tinP.pAdamGlobal1->_etherC_.pEtPrime )
    {
        if( !tinP.pcQuit ) tinP.pcQuit = &(const countT&)POOP ;

        diskGetHoverF( tinP , tinP.pAdamGlobal1->_etherC_.psttEarlyFolder ) ; ___( tinP.pAdamGlobal1->_etherC_.psttEarlyFolder ) ;
        //traceF( tinP , T("etherC::etherC [psttEarlyFolder]:    ")+T(tinP.pAdamGlobal1->_etherC_.psttEarlyFolder) ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002001.etherc.etherc END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002002.etherc.dt_etherc BEGIN
#define DDNAME       "3func.36002002.etherc.dt_etherc"
#define DDNUMB      (countT)0x36002002
#define IDFILE      (countT)0xc2e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.1030003.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f010104.1.1.0.html\"\>f010104:  WAKEsHOW( "example.simplest.func.1030003.etherC.dt_etherC" )\</A\>
*/
/**/

/*1*/etherC::~etherC( voidT )/*1*/
{
    TINSL
    const poopC& poopBefore = *tinP.pPoop ;
    SCOOP

    _IO_
    {
        ZE( boolT , bSniffingTinNotMe ) ;
        ZE( scoopC* , pScoopsSave ) ;                                                                                                                 \
        if( tinP.pAdamGlobal1->_etherC_.pEtPrime == this && POOP == ifcIDsUBtYPEpOOP_FIREDbYmONITOR )
        {
            SCOOPSnEWsPECIFIED( poopBefore )
            pScoopsSave = _pScoopsSave ;
            bSniffingTinNotMe = 1 ;
        }
    
        if( _pSwSoixlOldApiDoc ) // THIS LOOP USES tinP.pEther (subractor callback uses it)
        {
            countT cFlavors = _pSwSoixlOldApiDoc->cFlavorsF( tinP ) ;
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            {
                _psttLeverSoixlOldApi = (strokeS*)_pSwSoixlOldApiDoc->leverF( tinP , idf ) ;
                strokeS*& psttd = *(strokeS**)&(countT&)*_pSwSoixlOldApiDoc ;
                delF( tinP , psttd ) ;
            }
        }
    
        if( tinP.pEther                      == this ) tinP.pEther                      = 0 ;
        if( tinP.pAdamGlobal1->pEtThreadMain == this ) tinP.pAdamGlobal1->pEtThreadMain = 0 ;

        if( processGlobal3I.tinVeryVeryEarlyLateMain.pEther == this ) processGlobal3I.tinVeryVeryEarlyLateMain.pEther = 0 ; //U:: THIS SHOULD NOT BE NEEDED.  IT WAS NOT EFFECTIVE ANYWAY TO PAPER OVER THE BUG FOUND REGARDING tinP.pEther
    
        third.pEtherContainsMe = 0 ;
    
        if( tinP.pAdamGlobal1->_etherC_.pEtPrime == this )
        {
            delF( tinP , tinP.pAdamGlobal1->_etherC_.psttEarlyFolder ) ;

            //PSEUDODUPLICATE CODE: 1450002 12f0002 1030003 1020171
            if( tinP.pSwsRecycle )
            {
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                countT cFlavors = tinP.pSwsRecycle->cFlavorsF( tinP ) ;
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                {
                    tinP.pczl_pSwsRecycle = (countT*)tinP.pSwsRecycle->leverF( tinP , idf ) ;
    
                    while( *tinP.pSwsRecycle )
                    {
                        ZE( voidT* , pObject ) ;
                        *tinP.pSwsRecycle >> *(countT*)&pObject ;
    
                        //LOGrAWtID4( "deleting object " , (countT)pObject , " using pcz lever at " , tinP.pczl_pSwsRecycle ) ; //U::
    
                        if( tinP.pczl_pSwsRecycle && pObject )
                        {
                            switch( *tinP.pczl_pSwsRecycle )
                            {
                                case ifcIDtYPErECYCLE_soulC        : { DEL(        *(soulC**)&pObject ) ; break ; }
                                case ifcIDtYPErECYCLE_stackC       : { DEL(       *(stackC**)&pObject ) ; break ; }
                                case ifcIDtYPErECYCLE_switchC      : { DEL(      *(switchC**)&pObject ) ; break ; }
                                case ifcIDtYPErECYCLE_switchStackC : { DEL( *(switchStackC**)&pObject ) ; break ; }
                                default                            : { BLAMMO                           ; break ; }
                            }
                        }
                    }
                }
                THREADmODE1rESTORE
            }
            DEL( tinP.pSwsRecycle ) ; //TO MAKE SURE THAT etRock EXISTS WHEN THESE ARE DELETED
    
            if( tinP.pcQuit == &(const countT&)POOP ) tinP.pcQuit = 0 ;
    
            {
                etherFireImpersonateMonitorIF( tinP ) ;
                if( F(tinP.flagsThreadMode1) & flTHREADmODE1_DRIVERaDAM ) { BLAMMO ; }
                const boolT b_tmWindows = !!( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_tmWindows ) ;
                countT& cAllKidThreadsI    = thirdC::os_cAllKidThreadsI_IF( tinP ) ;
                countT& cAllOrphanThreadsI = thirdC::os_cAllOrphanThreadsI_IF( tinP ) ;
                //if( !( F(thirdC::third_flagsModeProcess1I_IF(tinP)) & flMODEpROCESS1_etThreadONmainISiMPOTENT ) )
                {
                    POOPIE
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    //OLD: while( cAllKidThreadsI + cAllOrphanThreadsI > !!b_tmWindows )
                    while( cAllKidThreadsI + cAllOrphanThreadsI ) //WANT TO WAIT TILL tmWindowsF IS GONE CAUSE windowOldC::ether MUST BE DT FOR ALL WINDOWS
                    {
                        CONoUTrAW5( "~etherC [cAllKidThreadsI,cAllOrphanThreadsI]:    " , cAllKidThreadsI , "    " , cAllOrphanThreadsI , "\r\n" ) ;
                        ++ s ;
                        thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ;
                    }
                    /* ONLY main AND tmWindowsF REMAIN, AND tmWindowsF IS BLOCKED IN WM_CLOSE AND HAS ALREADY DESTROYED ITS etThread */
                    //THE PRECEEDING COMMENT IS OBSOLETE AND FALSE
                    //THAT BLOCKAGE IN WM_CLOSE IS PERMANENTLY COMMENTED OUT; WHY WAS IT NEEDED?
                    //THIS CODE HAS BEEN ALTERED SO THAT I BLOCK UNTIL I AM ALONE (EXCEPT FOR tmHeartF)
                    if( !b_tmWindows ) thirdC::third_flagsProcessStateI_IF( tinP , flPROCESSsTATE_MAINtHREADiSaLONE , 1 ) ;
                }
            }
    
            flagsMode &= ~( F(flTHIRDmODE_QUITTER) ) ;
    
            //U:__( ifcHandoffOldF( tinP ).idPhaseF( tinP ) - ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;
    
            if( tinP.pAdamGlobal1->_etherC_.pSwDllReferences )
            {
                stackC stHandle( tinP , third , TAG( TAGiDnULL ) ) ;

                tinP.pAdamGlobal1->_etherC_.pSwDllReferences->grabF( tinP , TAG( TAGiDnULL ) ) ;
                while( !POOP )
                {
                    countT cFlavors = tinP.pAdamGlobal1->_etherC_.pSwDllReferences->cFlavorsF( tinP ) ;
                    for( countT idf = 1 ;idf <= cFlavors ; idf ++ ) stHandle << tinP.pAdamGlobal1->_etherC_.pSwDllReferences->leverF( tinP , idf ) ;
                    if( !stHandle ) break ;
                    else while( stHandle )
                    {
                        ZE( countT , osh ) ;
                        stHandle >> osh ;
                        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DLL ) ;
                        handle.osF( ifcIDtYPEhANDLE_DLL , osh ) ;
                    }
                }
                tinP.pAdamGlobal1->_etherC_.pSwDllReferences->ungrabF( tinP ) ;
            }
    
            DEL( tinP.pAdamGlobal1->_etherC_.cio_pBaton ) ; //A: ASSUME: CHANNEL IO THREAD HAS ENDED
            DEL( tinP.pAdamGlobal1->_etherC_.cio_pStkOut ) ;
        }
    
        DEL( third.pswPaintInfoFromDrawingHandle ) ;
        DEL( third.pswWinFromDraw ) ;
        DEL( third.pswWinFromDrawDuringPaint ) ;
        DEL( _pSwSoixlOldApi ) ;
        DEL( _pSwSoixlOldApiDoc ) ;
    
        //bFunctionCountersReady = 0 ;
    
    
        {
            ZE( countT , timeAge1 ) ;
            ZE( sCountT , timeAge2 ) ;
            third.osTimeNowF( tinP , timeAge1 , timeAge2 ) ;
            third.osTimeSubtractF( tinP , timeAge1 , timeAge2 , timeBorn1 , timeBorn2 ) ;
            //U: REPORT TIME AWAKE, TIME SLEPT FOR PERFORMANCE MONITORING AT OPERATIONS
    
            if( tinP.pAdamGlobal1->_etherC_.pEtPrime == this ) delF( tinP , tinP.pAdamGlobal1->_etherC_.pstt1_processParameters ) ;
    
            //U: ENABLE THIS AFTER FIND THE CULPRIT GENERATING CORRUPT DATUM ITEMS
            //U: NOTE: GENERATED DATA SUGGESTS THAT idiFileCt IS ALWAYS 0
            //#if defined( NEVERdEFINED )
    
            //{
            //    { countT pcPart[] = { idr_ETHERtIMEaGE2   , idiFileCt , idLineCt , 0 } ; ifcDatumF( tinP , flDATUM1_CLASStACHOMETER , flDATUM2_null , timeAge2   , pcPart ) ; }
            //    { countT pcPart[] = { idr_ETHERtIMEaGE1   , idiFileCt , idLineCt , 0 } ; ifcDatumF( tinP , flDATUM1_CLASStACHOMETER , flDATUM2_null , timeAge1   , pcPart ) ; }
            //    { countT pcPart[] = { idr_ETHERtIMEsLEPT2 , idiFileCt , idLineCt , 0 } ; ifcDatumF( tinP , flDATUM1_CLASStACHOMETER , flDATUM2_null , timeSlept2 , pcPart ) ; }
            //    { countT pcPart[] = { idr_ETHERtIMEsLEPT1 , idiFileCt , idLineCt , 0 } ; ifcDatumF( tinP , flDATUM1_CLASStACHOMETER , flDATUM2_null , timeSlept1 , pcPart ) ; }
            //}
    
            if( psttLog )
            {
                //U:
                static countT cInLath ;
                countT cIn = 1 + incv02AM( cInLath ) ;
    
                {
                    //ZE( strokeS* , psttw ) ;
                    //strToUrlF( tinP , psttw , psttLog ) ; ___( psttw ) ;
                    //ifcPutHostLogEntryF( tinP , psttw ) ; // U: CONDITIONALLY DO THIS ONLY IF CONNECTED TO THE INTERNET
                    //third = 0 ;
                    //delF( tinP , psttw ) ;
                }
    
                ZE( osTextT* , postLog ) ;
                countT costLog = strMakeF( tinP , LF , postLog , psttLog ) ; ___( postLog ) ;
                //if( bImpotent ){ ifcDatumF( tinP , flDATUM1_CLASSeXCEPTIONiMPOTENCE , flDATUM2_osTextT , 0 , 0 , postLog , costLog ) ; }
                //else           { ifcDatumF( tinP , flDATUM1_CLASSeXCEPTIONjOURNAL   , flDATUM2_osTextT , 0 , 0 , postLog , costLog ) ; }
                { ifcDatumF( tinP , flDATUM1_CLASSeXCEPTIONjOURNAL , flDATUM2_osTextT , 0 , 0 , postLog , costLog ) ; }
                delF( tinP , postLog ) ;
    
                delF( tinP , psttLog ) ;
            }
            etherTestF( tinP ) ;
    
            //if( pcRaceId ) ifcRaceIdF( tinP ) ;
    
            delF( tinP , psttUid ) ;
        }
    
        if( bSniffingTinNotMe )
        {
            scoopC* _pScoopsSave = pScoopsSave ;
            SCOOPSdEL
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002002.etherc.dt_etherc END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002003.etherc.operator_countt_ref BEGIN
#define DDNAME       "3func.36002003.etherc.operator_countt_ref"
#define DDNUMB      (countT)0x36002003
#define IDFILE      (countT)0xc2f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.1030004.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.0110104.1.1.0.html\"\>0110104:  WAKEsHOW( "example.simplest.func.1030004.etherC.operator_countT_ref" )\</A\>
*/
/**/

/*1*/etherC::operator const countT&( voidT )/*1*/
{
    countT c_this = (countT)this ;_WQ
    if( !c_this ) BLAMMO
    return (const poopC&)third ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002003.etherc.operator_countt_ref END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002004.etherc.operator_thirdc_ref BEGIN
#define DDNAME       "3func.36002004.etherc.operator_thirdc_ref"
#define DDNUMB      (countT)0x36002004
#define IDFILE      (countT)0xc30


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.1030005.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1110104.1.1.0.html\"\>1110104:  WAKEsHOW( "example.simplest.func.1030005.etherC.operator_thirdC_ref" )\</A\>
*/
/**/

/*1*/etherC::operator thirdC&( voidT )/*1*/
{
    return third ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002004.etherc.operator_thirdc_ref END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002005.etherc.operator_assign BEGIN
#define DDNAME       "3func.36002005.etherc.operator_assign"
#define DDNUMB      (countT)0x36002005
#define IDFILE      (countT)0xc31


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.1030007.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6110104.1.1.0.html\"\>6110104:  WAKEsHOW( "example.simplest.func.1030007.etherC.operator_assign" )\</A\>
arguments
 ecP
*/
/**/

/*1*/voidT etherC::operator =( const countT rcP )/*1*/
{
    TINSL
    SCOOP
    if( rcP && F(third.flagsMode) & flTHIRDmODE_IMPOTENCEtObLAMMO ) { BLAMMO ; }
    third = rcP ;_WQ
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002005.etherc.operator_assign END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002006.etherc.beeclickf BEGIN
#define DDNAME       "3func.36002006.etherc.beeclickf"
#define DDNUMB      (countT)0x36002006
#define IDFILE      (countT)0xc32


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$beeClickF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030008.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7110104.1.1.0.html\"\>7110104:  WAKEsHOW( "example.simplest.func.1030008.etherC.beeClickF" )\</A\>
arguments
 hzP
 timeP
*/
/**/

/*1*/voidT etherC::beeClickF( tinS& tinP , const countT hzP , const countT timeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    sleepStartF( tinP ) ;
    thirdC::dosBeepIF( tinP , hzP , timeP ) ;
    sleepEndF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002006.etherc.beeclickf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002007.etherc.beehonkf BEGIN
#define DDNAME       "3func.36002007.etherc.beehonkf"
#define DDNUMB      (countT)0x36002007
#define IDFILE      (countT)0xc33


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$beeHonkF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030009.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.8110104.1.1.0.html\"\>8110104:  WAKEsHOW( "example.simplest.func.1030009.etherC.beeHonkF" )\</A\>
arguments
 hzP
 timeP
*/
/**//*1*/voidT etherC::beeHonkF( tinS& tinP , const countT hzP , const countT timeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    sleepStartF( tinP ) ;
    thirdC::dosBeepIF( tinP , hzP , timeP ) ;
    sleepEndF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002007.etherc.beehonkf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002008.etherc.beesong1f BEGIN
#define DDNAME       "3func.36002008.etherc.beesong1f"
#define DDNUMB      (countT)0x36002008
#define IDFILE      (countT)0xc34


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$beeSong1F.0.html\"\>instances\</A\>
\<A HREF=\"5.103000a.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9110104.1.1.0.html\"\>9110104:  WAKEsHOW( "example.simplest.func.103000a.etherC.beeSong1F" )\</A\>
*/
/**//*1*/voidT etherC::beeSong1F( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    sleepStartF( tinP ) ;
    {for( measureT hz = 220             ; hz <= 880 ; hz *= 1.0833333 ) beeClickF( tinP , hz ) ;}
    for( measureT hz = 880 / 1.0833333 ; hz >= 220 ; hz /= 1.0833333 ) beeClickF( tinP , hz ) ;
    sleepEndF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002008.etherc.beesong1f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002009.etherc.batonclosef BEGIN
#define DDNAME       "3func.36002009.etherc.batonclosef"
#define DDNUMB      (countT)0x36002009
#define IDFILE      (countT)0xc35


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$batonCloseF.0.html\"\>instances\</A\>
\<A HREF=\"5.103000b.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.a110104.1.1.0.html\"\>a110104:  WAKEsHOW( "example.simplest.func.103000b.etherC.batonCloseF" )\</A\>
works even if impotent, as long as handleP is not 0
arguments
 handleP
*/
/**/

/*1*/voidT etherC::batonCloseF( tinS& tinP , handleC& handleP )/*1*/
{
    SCOOP
    //if( POOP ) return ;
    //IN_E
    third.dosCloseMutexSemIF( tinP , handleP ) ;
    //OUT
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002009.etherc.batonclosef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600200a.etherc.batongrabf BEGIN
#define DDNAME       "3func.3600200a.etherc.batongrabf"
#define DDNUMB      (countT)0x3600200a
#define IDFILE      (countT)0xc36


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$batonGrabF.0.html\"\>instances\</A\>
\<A HREF=\"5.103000c.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.b110104.1.1.0.html\"\>b110104:  WAKEsHOW( "example.simplest.func.103000c.etherC.batonGrabF" )\</A\>
works even if impotent, as long as handleP is not 0
arguments
 handleP
*/
/**/

/*1*/voidT etherC::batonGrabF( tinS& tinP , const handleC& handleP )/*1*/
{
    SCOOP
    //if( POOP ) return ;
    _IO_
    third.dosRequestMutexSemIF( tinP , handleP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600200a.etherc.batongrabf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600200b.etherc.batonletgof BEGIN
#define DDNAME       "3func.3600200b.etherc.batonletgof"
#define DDNUMB      (countT)0x3600200b
#define IDFILE      (countT)0xc37


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$batonLetGoF.0.html\"\>instances\</A\>
\<A HREF=\"5.103000d.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.c110104.1.1.0.html\"\>c110104:  WAKEsHOW( "example.simplest.func.103000d.etherC.batonLetGoF" )\</A\>
works even if impotent, as long as handleP is nonze
arguments
 handleP
*/
/**/

/*1*/voidT etherC::batonLetGoF( tinS& tinP , const handleC& handleP )/*1*/
{
    SCOOP
    //if( POOP ) return ;
    _IO_
    third.dosReleaseMutexSemIF( tinP , handleP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600200b.etherc.batonletgof END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600200c.etherc.batonopenf BEGIN
#define DDNAME       "3func.3600200c.etherc.batonopenf"
#define DDNUMB      (countT)0x3600200c
#define IDFILE      (countT)0xc38


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$batonOpenF.0.html\"\>instances\</A\>
\<A HREF=\"5.103000e.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.d110104.1.1.0.html\"\>d110104:  WAKEsHOW( "example.simplest.func.103000e.etherC.batonOpenF" )\</A\>
works even if impotent, as long as handleP is 0
arguments
 handleP
  must be 0
 fCreatorP
 psttP
  can be 0
*/
/**/

/*1*/voidT etherC::batonOpenF( tinS& tinP , handleC& handleP , boolT& fCreatorP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        //if( POOP ) return ;
        __( ~handleP ) ;
        __( fCreatorP ) ;
        //if( POOP ) return ;
    }

    //IN_E
    if( !handleP )
    {
        ZE( osTextT* , post ) ;
        if( psttP ) { strMakeF( tinP , LF , post , psttP ) ; ___( post ) ; }
        third.dosCreateMutexSemIF( tinP , handleP , fCreatorP , osFileNameC( tinP , third , post ) ) ;
        third.delF( tinP , post ) ;
    }
    //OUT
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600200c.etherc.batonopenf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600200d.etherc.strokef BEGIN
#define DDNAME       "3func.3600200d.etherc.strokef"
#define DDNUMB      (countT)0x3600200d
#define IDFILE      (countT)0xc39


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::strokeF( tinS& tinP , const strokeS* psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
    if( !pRootI )    
    {
        ZE( paperOldC* , pZe ) ;
        pZe->strokeF( tinP , psttP ) ; //A:ASSUME: paperOldC::strokeF DETECTS NULL this AND HANDLES THE CALL AS A REQUEST TO WRITE TO CONSOLE OUTPUT
    }
    else
    {
        const paperOldC& paper = pRootI->selectPaperF( tinP , ifcIDcMDpAPERsELECT_QUERYrENDER ) ;
        ((paperOldC&)paper).strokeF( tinP , psttP ) ;

        ((paperOldC&)paper).flushF( tinP ) ; //U:: WORKAROUND TO GET THE CONSOLE WORKING FOR INITIAL RELEASE OF IPDOS (TM); AT THIS TIME I HAVE NOT LOOKED AT THE GUI CODE FOR TUCKS AND AM TOTALLY UNFAMILIAR WITH IT

        pRootI->letRefF() ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600200d.etherc.strokef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600200e.etherc.diskfileordirdeletef BEGIN
#define DDNAME       "3func.3600200e.etherc.diskfileordirdeletef"
#define DDNUMB      (countT)0x3600200e
#define IDFILE      (countT)0xc3a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskFileOrDirDeleteF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030012.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1210104.1.1.0.html\"\>1210104:  WAKEsHOW( "example.simplest.func.1030012.etherC.diskFileOrDirDeleteF" )\</A\>
arguments
 psttP
  file name
   example: T("///ideafarm/ephemeral/tmp/myfile")
   example: T("///ideafarm/ephemeral/tmp/mydirectory/")
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00102d4.flFILEoRdIRdELETE!||
 cTriesP
  can be 0
   if 0 then will retry forever
   else will try cTriesP times
*/
/**//*1*/voidT etherC::diskFileOrDirDeleteF( tinS& tinP , const strokeS* const psttP , flagsT flagsP , countT cTriesP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
        __( !psttP->idAdam ) ;
        FV( flFILEoRdIRdELETE , flagsP ) ;
        if( POOP ) return ;
    }

    _IO_
    {
        ZE( strokeS* , pstt ) ;
        diskMapFileNameF( tinP , pstt , psttP ) ; ___( pstt ) ;
        ZE( osTextT* , post ) ;
        strMakeF( tinP , LF , post , pstt ) ; ___( post ) ;
        delF( tinP , pstt ) ;
        const boolT bDir = S1C('/') == psttP[ CSpREFIX - 1 + psttP->idAdam ] ;
        if( bDir )
        {
            if( F(flagsP) & flFILEoRdIRdELETE_RECURSE )
            {
                soulC soul1m( tinP , TAG( TAGiDnULL ) ) ;
                boxMenuF( tinP , soul1m , T(psttP)+T("*") ) ;
                ZE( countT , cFail ) ;
                IFsCRATCH
                {
                    FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
                    {
                        SCOOPS
                        tinP.pEtScratch->diskFileOrDirDeleteF( tinP , psttc1 , flagsP , cTriesP ) ;
                        if( POOP )
                        {
                            POOPR
                            cFail ++ ;
                        }
                    }
                    FORsTRINGSiNsPANNEDcOMBINEDtAIL1
                }
                __( cFail ) ;
            }

            third.dosDeleteDirF( tinP , osFileNameC( tinP , third , post ) , cTriesP ) ;
        }
        else third.dosDeleteIF( tinP , osFileNameC( tinP , third , post ) , cTriesP ) ;
        delF( tinP , post ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600200e.etherc.diskfileordirdeletef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600200f.etherc.diskmovefileordirf BEGIN
#define DDNAME       "3func.3600200f.etherc.diskmovefileordirf"
#define DDNUMB      (countT)0x3600200f
#define IDFILE      (countT)0xc3b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskMoveFileOrDirF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030013.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6210104.1.1.0.html\"\>6210104:  WAKEsHOW( "example.simplest.func.1030013.etherC.diskMoveFileOrDirF" )\</A\>
the string arguments can be lists
 if wo is a list, then both must be lists, and both lists must contain the same number of strings
  may also be a string of strings
   the result is as if the caller called me repeatedly
  impotence behavior depends upon whether i am *tinP.pEtScratch
   if so, then i will try all listed file names
   else i will return immediately upon impotence
arguments
 psttNewP
  file name
   example: T("///ideafarm/ephemeral/tmpnew/new")
  must be on the same device as psttOldP
   here is an example that would -not- work (on os/2 and on windows) because two devices (c : and d:) are involved
    psttOldP: T("///c" "/old")
    psttNewP: T("///d/new")
    this example -would- work, however, on Linux
 psttOldP
  file name
   example: T("///ideafarm/ephemeral/tmpold/old")
*/
/**//*1*/voidT etherC::diskMoveFileOrDirF( tinS& tinP , const strokeS* const psttNewP , const strokeS* const psttOldP , const countT cTriesP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttOldP ) ;
        __Z( psttNewP ) ;
        if( POOP ) return ;
    }

    _IO_

    boolT bStringOfStringsNew = ISsTRINGoFsTRINGS( psttNewP ) ;
    boolT bStringOfStringsOld = ISsTRINGoFsTRINGS( psttOldP ) ;
    __( bStringOfStringsNew - bStringOfStringsOld ) ;

    ZE( countT , cFail ) ;
    if( !POOP )
    {
        _IO_
        ZE( strokeS* , pstt1New ) ;
        ZE( strokeS* , pstt1Old ) ;
        if( !bStringOfStringsNew )
        {
            _IO_
            strFuseSeparateF( tinP , pstt1New , psttNewP ) ; ___( pstt1New ) ;
            strFuseSeparateF( tinP , pstt1Old , psttOldP ) ; ___( pstt1Old ) ;
        }
        else
        {
            _IO_
            pstt1New = (strokeS*)psttNewP ;
            pstt1Old = (strokeS*)psttOldP ;
        }

        ZE( countT , cStringsNew ) ;
        ZE( countT , cStringsOld ) ;
        { COUNTsTRINGSiN( cStringsNew , pstt1New ) ; }
        { COUNTsTRINGSiN( cStringsOld , pstt1Old ) ; }
        __( cStringsNew - cStringsOld ) ;

        if( !POOP )
        {
            _IO_
            ZE( countT , idNew ) ;
            FORsTRINGSiN1( pstt1New )
            {
                _IO_
                idNew ++ ;

                countT cSkip = idNew - 1 ;
                FORsTRINGSiN2( pstt1Old )
                {
                    _IO_
                    if( cSkip -- ) continue ;

                    if( this != tinP.pEtScratch )
                    {
                        _IO_
                        //CS:CODEsYNC: DUPLICATE CODE 3600200f 3600200f
                        {
                            _IO_
                            ZE( osTextT* , postNew ) ;
                            ZE( osTextT* , postOld ) ;
                            ZE( strokeS* , psttn ) ;
                            ZE( strokeS* , pstto ) ;
                            diskMapFileNameF( tinP , psttn , psttc1 ) ; ___( psttn ) ;
                            diskMapFileNameF( tinP , pstto , psttc2 ) ; ___( pstto ) ;
                            {
                                _IO_
                                boolT bDir = psttc1[ CSpREFIX - 1 + psttc1->idAdam ].idAdam == '/' ;
                                boolT bMade = diskMakeDirIfNeededF( tinP , psttn ) ;                            //U::20171120@1252: THIS IS A NONREENTRANT KLUDGE MADE NECESSARY BY THE RECENT CHANGE TO diskMakeDirIfNeededF.  THAT FUNCTION SHOULD BE CHANGED BACK TO ALWAYS IGNORE THE LEAF DIRECTORY, WHICH WILL REQUIRE REGRESSION TESTING TO LEARN WHY I MADE THE CHANGE
                                if( bDir && bMade ) diskFileOrDirDeleteF( tinP , psttc1 ) ;
                            }
                            countT costNew = strMakeF( tinP , LF , postNew , psttn ) ; ___( postNew ) ;
                            countT costOld = strMakeF( tinP , LF , postOld , pstto ) ; ___( postOld ) ;
                            delF( tinP , psttn ) ;
                            delF( tinP , pstto ) ;

                            if( postNew[ costNew - 1 ] == '/' ) postNew[ costNew - 1 ] = 0 ;
                            if( postOld[ costOld - 1 ] == '/' ) postOld[ costOld - 1 ] = 0 ;

                            third.dosMoveF( tinP , osFileNameC( tinP , *this , postNew ) , osFileNameC( tinP , *this , postOld ) , cTriesP ) ;
                            delF( tinP , postNew ) ;
                            delF( tinP , postOld ) ;
                        }

                        if( POOP ) break ;
                    }
                    else
                    {
                        _IO_
                        IFsCRATCH
                        {
                            _IO_
                            SCOOPS

                            //CS:CODEsYNC: DUPLICATE CODE 3600200f 3600200f
                            {
                                _IO_
                                ZE( osTextT* , postNew ) ;
                                ZE( osTextT* , postOld ) ;
                                ZE( strokeS* , psttn ) ;
                                ZE( strokeS* , pstto ) ;
                                diskMapFileNameF( tinP , psttn , psttc1 ) ; ___( psttn ) ;
                                diskMapFileNameF( tinP , pstto , psttc2 ) ; ___( pstto ) ;
                                {
                                    _IO_
                                    boolT bDir = psttc1[ CSpREFIX - 1 + psttc1->idAdam ].idAdam == '/' ;
                                    boolT bMade = diskMakeDirIfNeededF( tinP , psttn ) ;                            //U::20171120@1252: THIS IS A NONREENTRANT KLUDGE MADE NECESSARY BY THE RECENT CHANGE TO diskMakeDirIfNeededF.  THAT FUNCTION SHOULD BE CHANGED BACK TO ALWAYS IGNORE THE LEAF DIRECTORY, WHICH WILL REQUIRE REGRESSION TESTING TO LEARN WHY I MADE THE CHANGE
                                    if( bDir && bMade ) diskFileOrDirDeleteF( tinP , psttc1 ) ;
                                }
                                countT costNew = strMakeF( tinP , LF , postNew , psttn ) ; ___( postNew ) ;
                                countT costOld = strMakeF( tinP , LF , postOld , pstto ) ; ___( postOld ) ;
                                delF( tinP , psttn ) ;
                                delF( tinP , pstto ) ;
                                __Z( postNew ) ;
                                __Z( costNew ) ;
                                __Z( postOld ) ;
                                __Z( costOld ) ;

                                if( !POOP )
                                {
                                    if( postNew[ costNew - 1 ] == '/' ) postNew[ costNew - 1 ] = 0 ;
                                    if( postOld[ costOld - 1 ] == '/' ) postOld[ costOld - 1 ] = 0 ;
                                    third.dosMoveF( tinP , osFileNameC( tinP , *this , postNew ) , osFileNameC( tinP , *this , postOld ) , cTriesP ) ;
                                }

                                delF( tinP , postNew ) ;
                                delF( tinP , postOld ) ;
                            }

                            if( POOP )
                            {
                                _IO_
                                POOPRqUIET
                                cFail ++ ;
                            }
                        }
                    }
                }

                if( POOP ) break ;      // IMPOSSIBLE IF *this IS etScratch
            }
        }

        if( !bStringOfStringsNew )
        {
            _IO_
            delF( tinP , pstt1New ) ;
            delF( tinP , pstt1Old ) ;
        }
    }

    __( cFail ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600200f.etherc.diskmovefileordirf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002010.etherc.fileopenf BEGIN
#define DDNAME       "3func.36002010.etherc.fileopenf"
#define DDNUMB      (countT)0x36002010
#define IDFILE      (countT)0xc3c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$fileOpenF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030014.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.2210104.1.1.0.html\"\>2210104:  WAKEsHOW( "example.simplest.func.1030014.etherC.fileOpenF" )\</A\>
arguments
 handleP
 idResultP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010013.ifcOPENrESULT!||
  windows: idResultP is always set to 0
  os/2: idResultP will be set to a value that indicates what action was taken
 psttP
 idAccessP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010015.ifcOPENaCCESS!||
 idShareP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010016.ifcOPENsHARE!||
 flagsDetailsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010011.flOPENdETAILS!||
 idHowP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010014.ifcOPENhOW!||
 flagsAttributeP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010010.flFILEaTTR!||
 cbP
  windows: must be 0
  os/2: the number of bytes to allocate when creating a new file
 cTriesP
  if 0 then will retry forever
  if not 0 then will try cTriesP times
*/
/**/

/*1*/voidT etherC::fileOpenF( tinS& tinP , handleC& handleP , countT& idResultP , const strokeS* const psttP , const countT idAccessP , const countT idShareP , const flagsT flagsDetailsP , const countT idHowP , const flagsT flagsAttributeP , const countT cbP , countT cTriesP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( handleP ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    ZE( strokeS* , pstt ) ;
    diskMapFileNameF( tinP , pstt , psttP ) ; ___( pstt ) ;
    ZE( osTextT* , post ) ;
    strMakeF( tinP , LF , post , pstt ) ; ___( post ) ;
    delF( tinP , pstt ) ;
    third.dosOpenF( tinP , handleP , idResultP , osFileNameC( tinP , third , post ) , idAccessP , idShareP , flagsDetailsP | ( tinP.pEther ? 0 : flOPENdETAILS_DOnOTvALIDATE ) , idHowP , flagsAttributeP , cbP , cTriesP ) ;
    delF( tinP , post ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002010.etherc.fileopenf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002011.etherc.diskfilequeryf BEGIN
#define DDNAME       "3func.36002011.etherc.diskfilequeryf"
#define DDNUMB      (countT)0x36002011
#define IDFILE      (countT)0xc3d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskFileQueryF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030015.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.5210104.1.1.0.html\"\>5210104:  WAKEsHOW( "example.simplest.func.1030015.etherC.diskFileQueryF" )\</A\>
arguments
 pInfoFileP
 handleP
*/
/**/

/*1*/voidT etherC::diskFileQueryF( tinS& tinP , infoFileS*& pInfoFileP , const handleC& handleP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    thirdC::dosQueryFileInfoIF( tinP , pInfoFileP , handleP ) ; ___( pInfoFileP ) ;
    if( pInfoFileP && pInfoFileP->postOsName )
    {
        ifFileNameC iffn( tinP , third , pInfoFileP->postOsName ) ;
        strMakeF( tinP , LF , pInfoFileP->psttIfoName , T(iffn) ) ; ___( pInfoFileP->psttIfoName ) ;
        //delF( tinP , pInfoFileP->postOsName ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002011.etherc.diskfilequeryf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002012.etherc.filereadf BEGIN
#define DDNAME       "3func.36002012.etherc.filereadf"
#define DDNUMB      (countT)0x36002012
#define IDFILE      (countT)0xc3e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$fileReadF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030016.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.4210104.1.1.0.html\"\>4210104:  WAKEsHOW( "example.simplest.func.1030016.etherC.fileReadF" )\</A\>
arguments
 pbP
  must contain the address of cbP bytes of memory that this adam can write to
 cbP
  must not be 0
  specifies the number of bytes to read
  after evaluation, if no error occured, will contain the number of bytes actually read
  if an error occured, will be reset to its initial value
 handleP
 fStillHungryIsOkP
  if 0, will fail unless cbP bytes can be read
  else, will not fail, and cbP will be set to the number of bytes actually read
*/
/**/

/*1*/voidT etherC::fileReadF( tinS& tinP , byteT* const pbP , countT& cbP , const handleC& handleP , boolT fStillHungryIsOkP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.dosReadIF( tinP , pbP , cbP , handleP , fStillHungryIsOkP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002012.etherc.filereadf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002013.etherc.diskfilerefreshf BEGIN
#define DDNAME       "3func.36002013.etherc.diskfilerefreshf"
#define DDNUMB      (countT)0x36002013
#define IDFILE      (countT)0xc3f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskFileRefreshF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030017.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7210104.1.1.0.html\"\>7210104:  WAKEsHOW( "example.simplest.func.1030017.etherC.diskFileRefreshF" )\</A\>
it is illegal to refer to this symbol in the definition of an adam
this function can fail due to hardcoded capacity limits
 strFuseSeparateF
arguments
 pstt1NotRefreshedP
  will contain a string of strings; use FORsTRINGSiN1 to access them
 pstt1LocalP
 pstt1RemoteP
 psttRemotePrefixP
*/
/**//*1*/voidT etherC::diskFileRefreshF( tinS& tinP , strokeS*& pstt1NotRefreshedP , const strokeS* const pstt1LocalP , const strokeS* const pstt1RemoteP , const strokeS* const psttRemotePrefixP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( pstt1LocalP ) ;
        __Z( pstt1RemoteP ) ;
        __Z( psttRemotePrefixP ) ;
        if( POOP ) return ;
    }

    _IO_
    IFsCRATCH
    {
        // COUNT THE FILES
        ZE( countT , cFiles ) ;
        {
            ZE( countT , cLocal ) ;
            ZE( countT , cRemote ) ;
            { FORsTRINGSiN1( (strokeS*)pstt1LocalP  ) cLocal ++ ;  }
            { FORsTRINGSiN1( (strokeS*)pstt1RemoteP ) cRemote ++ ; }
            __( cLocal - cRemote ) ;
            if( !POOP ) cFiles = cLocal ;
        }
    
        ZE( countT* , pcRemoteFileTimes ) ;
        ZE( countT* , pcLocalFileTimes ) ;
        ZE( boolT* , pfWanted ) ;
        newF( tinP , LF , pcRemoteFileTimes , cFiles * 2 ) ; ___( pcRemoteFileTimes ) ;
        newF( tinP , LF , pcLocalFileTimes  , cFiles * 2 ) ; ___( pcLocalFileTimes ) ;
        newF( tinP , LF , pfWanted  , cFiles ) ; ___( pfWanted ) ;
        memSetF( tinP , (byteT*)pfWanted , cFiles * sizeof( boolT ) ) ;
    
        // GET THE REMOTE FILE TIMES
        if( !POOP )
        {
            TN( tTime , ".time" ) ;
            ZE( strokeS* , pstta ) ;
            strMakeF( tinP , LF , pstta , psttRemotePrefixP , ( pstt1RemoteP ? pstt1RemoteP->idAdam : 0 ) + cFiles * ( 1 + tTime.csF( tinP ) ) ) ; ___( pstta ) ;
            FORsTRINGSiN1( (strokeS*)pstt1RemoteP )
            {
                if( POOP ) break ;
                strFuseF( tinP , pstta , T(psttc1)+tTime ) ; ___( pstta ) ;
                if( psttc1 + CSpREFIX + psttc1->idAdam < pstte1 ) { strFuseF( tinP , pstta , T(" ") ) ; ___( pstta ) ; }
            }
    
            ZE( byteT* , pba ) ;
            ZE( countT , cba ) ;
            boxGetShadowF( tinP , pba , cba , pstta ) ; ___( pba ) ;
            __Z( pba ) ;
            if( cFiles == 1 ) { __( cba != cFiles * 2 * sizeof( countT ) ) ; }
            else              { __( cba != cFiles * 3 * sizeof( countT ) ) ; }
            delF( tinP , pstta ) ;
    
            if( !POOP && pba )
            {
                for( countT off = 0 ; !POOP && off < cFiles ; off ++ )
                {
                    if( cFiles == 1 )
                    {
                        pcRemoteFileTimes[ 2 * off     ] = ((countT*)pba)[ 2 * off     ] ;
                        pcRemoteFileTimes[ 2 * off + 1 ] = ((countT*)pba)[ 2 * off + 1 ] ;
                    }
                    else
                    {
                        __( ((countT*)pba)[ 3 * off ] - 2 * sizeof( countT ) ) ;
                        pcRemoteFileTimes[ 2 * off     ] = ((countT*)pba)[ 3 * off + 1 ] ;
                        pcRemoteFileTimes[ 2 * off + 1 ] = ((countT*)pba)[ 3 * off + 2 ] ;
                    }
                }
            }
            delF( tinP , pba ) ;
        }
    
        // GET THE LOCAL FILE TIMES
        if( pcLocalFileTimes )
        {
            ZE( countT , off ) ;
            FORsTRINGSiN1( (strokeS*)pstt1LocalP )
            {
                if( POOP ) break ;
                ZE( strokeS* , psttl ) ;
                strFuseF( tinP , psttl , T(psttc1)+T(".time") ) ; ___( psttl ) ;
    
                ZE( byteT* , pblt ) ;
                ZE( countT , cblt ) ;
                SCOOPSnEW
                tinP.pEtScratch->boxGetShadowF( tinP , pblt , cblt , psttl , 1 ) ; ___( pblt ) ;
                delF( tinP , psttl ) ;
                if( POOP )
                {
                    POOPR
                    SCOOPSdEL
                    __NZ( pblt ) ;
                    pcLocalFileTimes[ 2 * off     ] = 0 ;
                    pcLocalFileTimes[ 2 * off + 1 ] = 0 ;
                }
                else
                {
                    SCOOPSdEL
                    __Z( pblt ) ;
                    __( cblt - 2 * sizeof( countT ) ) ;
    
                    pcLocalFileTimes[ 2 * off     ] = ((countT*)pblt)[ 0 ] ;
                    pcLocalFileTimes[ 2 * off + 1 ] = ((countT*)pblt)[ 1 ] ;
                }
                delF( tinP , pblt ) ;
    
                off ++ ;
            }
        }
    
        // SELECT THE REMOTE FILES WANTED
        ZE( strokeS* , psttRemoteWanted ) ;
        ZE( boolT , fAggregate ) ;
        if( pcRemoteFileTimes )
        {
            ZE( countT , off ) ;
            strFuseF( tinP , psttRemoteWanted , psttRemotePrefixP , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ 2 * ( pstt1RemoteP ? pstt1RemoteP->idAdam : 0 ) ) ; ___( psttRemoteWanted ) ;
            ZE( boolT , fPrior ) ;
            FORsTRINGSiN1( (strokeS*)pstt1RemoteP )
            {
                if( POOP ) break ;
                if( memCompareF( tinP , (byteT*)&pcRemoteFileTimes[ 2 * off ] , (byteT*)&pcLocalFileTimes[ 2 * off ] , 2 * sizeof( countT ) ) )
                {
                    pfWanted[ off ] = 1 ;
                    if( fPrior ) { fAggregate = 1 ; strFuseF( tinP , psttRemoteWanted , T(" ") ) ; ___( psttRemoteWanted ) ; }
                    strFuseF( tinP , psttRemoteWanted , psttc1 ) ; ___( psttRemoteWanted ) ;
                    fPrior = 1 ;
                }
    
                off ++ ;
            }
        }
    
        delF( tinP , pcLocalFileTimes ) ;
    
        if( pcRemoteFileTimes && strCompareF( tinP , psttRemoteWanted , psttRemotePrefixP ) )
        {
            // GET THE AGGREGATE IMAGE FOR THE REMOTE FILES
            ZE( byteT* , pba ) ;
            ZE( countT , cba ) ;
            boxGetShadowF( tinP , pba , cba , psttRemoteWanted ) ; ___( pba ) ;
            __Z( pba ) ;
            __Z( cba ) ;
    
            // WRITE THE IMAGES TO THE LOCAL DISK
            ZE( countT , off ) ;
            ZE( byteT* , pbac ) ;
            pbac = pba ;
            FORsTRINGSiN1( (strokeS*)pstt1LocalP )
            {
                if( POOP ) break ;
                if( pfWanted[ off ] )
                {
                    SCOOPSnEW
                    if( fAggregate ) tinP.pEtScratch->boxPutF( tinP , psttc1 , pbac + sizeof( countT ) , pbac ? *(countT*)pbac : 0 ) ;
                    else             tinP.pEtScratch->boxPutF( tinP , psttc1 , pbac                    , cba            ) ;
                    tinP.pEtScratch->boxPutF( tinP , T(psttc1)+T(".time") , (byteT*)&pcRemoteFileTimes[ 2 * off ] , 2 * sizeof( countT ) ) ;
                    if( !POOP ) SCOOPSdEL
                    else
                    {
                        POOPR
                        SCOOPSdEL
                        strFuseSeparateF( tinP , pstt1NotRefreshedP , psttc1 , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 0x100000 ) ;
                    }
                    if( !fAggregate ) break ;
                    pbac += sizeof( countT ) + ( pbac ? *(countT*)pbac : 0 ) ;
                }
    
                off ++ ;
            }
    
            delF( tinP , pba ) ;
        }
    
        if( !pstt1NotRefreshedP ) { strFuseF( tinP , pstt1NotRefreshedP , T("") ) ; ___( pstt1NotRefreshedP ) ; }
        delF( tinP , psttRemoteWanted ) ;
        delF( tinP , pfWanted ) ;
        delF( tinP , pcRemoteFileTimes ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002013.etherc.diskfilerefreshf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002014.etherc.filewritef BEGIN
#define DDNAME       "3func.36002014.etherc.filewritef"
#define DDNUMB      (countT)0x36002014
#define IDFILE      (countT)0xc40


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$fileWriteF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030018.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.3210104.1.1.0.html\"\>3210104:  WAKEsHOW( "example.simplest.func.1030018.etherC.fileWriteF" )\</A\>
arguments
 handleP
 pbP
 cbP
*/
/**/

/*1*/voidT etherC::fileWriteF( tinS& tinP , const handleC& handleP , const byteT* const pbP , const countT cbP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.dosWriteF( tinP , handleP , pbP ,cbP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002014.etherc.filewritef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002015.etherc.paperzitsofff BEGIN
#define DDNAME       "3func.36002015.etherc.paperzitsofff"
#define DDNUMB      (countT)0x36002015
#define IDFILE      (countT)0xc41


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$paperZitsOffF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030019.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.8210104.1.1.0.html\"\>8210104:  WAKEsHOW( "example.simplest.func.1030019.etherC.paperZitsOffF" )\</A\>
*/
/**//*1*/voidT etherC::paperZitsOffF( tinS& tinP )/*1*/
{
    thirdC::dosErrorMsgBox_offIF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002015.etherc.paperzitsofff END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002016.etherc.paperzitsonf BEGIN
#define DDNAME       "3func.36002016.etherc.paperzitsonf"
#define DDNUMB      (countT)0x36002016
#define IDFILE      (countT)0xc42


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$paperZitsOnF.0.html\"\>instances\</A\>
\<A HREF=\"5.103001a.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9210104.1.1.0.html\"\>9210104:  WAKEsHOW( "example.simplest.func.103001a.etherC.paperZitsOnF" )\</A\>
*/
/**//*1*/voidT etherC::paperZitsOnF( tinS& tinP )/*1*/
{
    thirdC::dosErrorMsgBox_onIF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002016.etherc.paperzitsonf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002017.etherc.diskfindfileordiroldf BEGIN
#define DDNAME       "3func.36002017.etherc.diskfindfileordiroldf"
#define DDNUMB      (countT)0x36002017
#define IDFILE      (countT)0xc43


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskFindFileOrDirOldF.0.html\"\>instances\</A\>
\<A HREF=\"5.103001c.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.b210104.1.1.0.html\"\>b210104:  WAKEsHOW( "example.simplest.func.103001c.etherC.diskFindFileOrDirOldF" )\</A\>
evaluates to the number of files found
if a wildcard ("*" or "?") is specified for the disk, remote drives are excluded from the search
i will silently quit early if *tinP.pcQuit
 if i quit early for this reason, my results are useable but incomplete
i will not 
arguments
 pstt1FoundP
  can be 0 or not 0
  if not 0 then must be a string of strings, and my results will be appended
   a file will not be included in the append if it is already present in the list
  will contain a string of strings
   use the FORsTRINGSiN1 macro to obtain each string
  if no files are found, pstt1FoundP will be set to the null string
 psttLikeP
  must not be 0
  must not specify a root directory, e.g. T("///x/")
 csttExtraP
 cMaxP
  can be 0
  if not 0, then is the maximum number of matching files to report in pstt1FoundP
*/
/**/

//DEPRECATED.  USE diskFindFileOrDirF
#if defined( NEVERdEFINED )

/*1*/countT etherC::diskFindFileOrDirOldF( tinS& tinP , strokeS*& pstt1FoundP , const strokeS* const psttLikeP , soulC* pSoulP , grabC* pGrabP , const countT csttExtraP , const countT cMaxP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttLikeP ) ;
        if( POOP ) return 0 ;
        __( psttLikeP->idAdam < 6 ) ;
        __( psttLikeP->idCaste != sc_PREFIXlENGTH ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( countT , cItems ) ;
    IFsCRATCH
    {
        stackC stFound( tinP , third , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
        {
            ZE( strokeS* , psttLike ) ;
            if
            (
                   psttLikeP->idAdam > 5
                && psttLikeP[ CSpREFIX     ] == S1C('/')
                && psttLikeP[ CSpREFIX + 1 ] == S1C('/')
                && psttLikeP[ CSpREFIX + 2 ] == S1C('/')
                &&
                (
                    (
                          psttLikeP[ CSpREFIX + 3 ] == S1C('/')           // NETBIOS      NAME OF FORM "////netbios/d/path/short"
                       && psttLikeP[ CSpREFIX + 4 ] != S1C('/')
                    )
                    ||
                    (
                          psttLikeP[ CSpREFIX + 3 ] != S1C('/')           // LOCAL MAPPED NAME OF FORM "///d/path/short"
                       && psttLikeP[ CSpREFIX + 4 ] == S1C('/')
                    )
                )
            )
            {
                strFuseF(            tinP , psttLike , psttLikeP ) ; ___( psttLike ) ;
            }
            else { diskMapFileNameF( tinP , psttLike , psttLikeP ) ; ___( psttLike ) ; }

            if( POOP ) ;
            else if( psttLike && ( psttLike[ CSpREFIX + 3 ] == S1C('*') || psttLike[ CSpREFIX + 3 ] == S1C('?') ) )
            {
                strokeS psttDisk[ CSpREFIX + 4 ] ;
                SETpREFIX( psttDisk , 4 ,0 ) ;
                psttDisk[ CSpREFIX     ] = '/' ;
                psttDisk[ CSpREFIX + 1 ] = '/' ;
                psttDisk[ CSpREFIX + 2 ] = '/' ;
                psttDisk[ CSpREFIX + 3 ] = 0 ;
                countT cRem = cMaxP ;

                for( psttDisk[ CSpREFIX + 3 ] = S1C('c') ; psttDisk[ CSpREFIX + 3 ] <= S1C('z') ; ++ psttDisk[ CSpREFIX + 3 ] )
                {
                    ZE( infoDiskS* , pInfoDisk ) ;
                    {
                        SCOOPS
                        tinP.pEtScratch->diskInfoF( tinP , pInfoDisk , psttDisk , 1 ) ; ___( pInfoDisk ) ; //U::NOT IN HERE
                        if( POOP ) { POOPRqUIET ; }
                    }

                    if( pInfoDisk )
                    {
                        if( pInfoDisk->bLocal )
                        {
                            ZE( strokeS* , psttLike2 ) ;
                            strMakeF( tinP , LF , psttLike2 , psttDisk , psttLike ? psttLike->idAdam : 0 ) ; ___( psttLike2 ) ;
                            ZE( strokeS* , psttTmp ) ;
                            countT idf = 5 ;
                            ZE( countT , idLathI ) ;
                            strSubstringF( tinP , psttTmp , idf , idLathI , psttLike ) ; ___( psttTmp ) ;
                            strFuseF( tinP , psttLike2 , psttTmp ) ; ___( psttLike2 ) ;
                            delF( tinP , psttTmp ) ;
                            ZE( strokeS* , pstt2Found ) ;
                            countT cFoundHere = diskFindFileOrDirOldF( tinP , pstt2Found , psttLike2 , pSoulP , pGrabP , csttExtraP , cRem ) ; ___( pstt2Found ) ;
                            FORsTRINGSiN2( pstt2Found )
                            {
                                strokeS* psttv = psttOldC( tinP , *this , psttc2 ) ; ___( psttv ) ; //U::O: CONVERT THIS FUNCTION TO TAKE A stackC PARAMETER, AND WRITE AN OVERLOAD WRAPPER TO RETURN A STRING OF STRINGS
                                stFound << psttv ;
                            }
                            delF( tinP , pstt2Found ) ;
                            cRem   -= cFoundHere ;
                            delF( tinP , psttLike2 ) ;
                        }
                        DEL( pInfoDisk ) ;
                    }
                
                    if( ( tinP.pcQuit && *tinP.pcQuit ) || ( cMaxP && !cRem ) ) break ;
                }
            }
            else
            {
                handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                ZE( strokeS* , psttA ) ;
                diskFindFileOrDirOldF( tinP , psttA , handle , psttLike ) ; ___( psttA ) ;

                countT cRem = cMaxP ;
                while( psttA )
                {
                    //if( !( cRem % TUCK ) ) { CONoUTrAW( "." ) ; }
                    ZE( boolT , bDots ) ;
                    {
                        boolT bDir = psttA && psttA[ CSpREFIX - 1 + psttA->idAdam ].idAdam == '/' ;

                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                        ZE( strokeS* , psttw ) ;
                        strWordF( tinP , psttw , psttA , sttq , S1C('/') , - 1 - bDir ) ; ___( psttw ) ;

                        bDots = 
                            !strCompareF( tinP , psttw , T("..") ) ||
                            !strCompareF( tinP , psttw , T(".") )
                        ;
                        delF( tinP , psttw ) ;
                    }

                    if( !bDots )
                    {
                        stFound << psttA ; psttA = 0 ;
                        if( cRem ) cRem -- ;
                    }
                    else delF( tinP , psttA ) ;

                    if( ( tinP.pcQuit && *tinP.pcQuit ) || ( cMaxP && !cRem ) )
                    {
                        if( ~handle ) handle.closeIfF() ;
                        break ;
                    }

                    diskFindFileOrDirOldF( tinP , psttA , handle , psttLike ) ; ___( psttA ) ;
                }
            }
            delF( tinP , psttLike ) ;

            countT cstte = csttExtraP ;
            if( stFound )
            {
                boolT bWoth = 1 ;
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                do
                {
                    strokeS* psttw = (strokeS*)stFound.downF( tinP , hDown ) ;
                    if( bWoth ) bWoth = 0 ;
                    else if( psttw ) cstte += CSpREFIX + psttw->idAdam ;
                }
                while( !POOP && ~hDown ) ;
            }

            while( stFound )
            {
                ZE( strokeS* , psttw ) ;
                stFound >> psttw ;

                ZE( boolT , bDup ) ;
                if( pstt1FoundP )
                {
                    FORsTRINGSiN1( pstt1FoundP )
                    {
                        if( !strCompareF( tinP , psttc1 , psttw ) )
                        {
                            bDup = 1 ;
                            break ;
                        }
                    }
                }

                if( !bDup )
                {
                    cItems ++ ;
                    strFuseSeparateF( tinP , pstt1FoundP , psttw , 0 , 0 , pSoulP , pGrabP , cstte ) ; ___( pstt1FoundP ) ;
                }
                delF( tinP , psttw ) ;
            }

            if( !pstt1FoundP && !pGrabP ) { strFuseF( tinP , pstt1FoundP , T("") , pSoulP , pGrabP , csttExtraP ) ; ___( pstt1FoundP ) ; }
        }
    }

    return cItems ;
}

#endif

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002017.etherc.diskfindfileordiroldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002018.etherc.diskfindfileordiroldf BEGIN
#define DDNAME       "3func.36002018.etherc.diskfindfileordiroldf"
#define DDNUMB      (countT)0x36002018
#define IDFILE      (countT)0xc44


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskFindFileOrDirOldF.0.html\"\>instances\</A\>
\<A HREF=\"5.103001d.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
returns the single file that is exactly identified by psttLikeP
psttLikeP contains a string such as "///ideafarm/ephemeral/domains/com/foo/myfile"
psttLikeP must not contain wildcards
arguments
 psttNameP
 handleP
 psttLikeP
  must not be 0
  must not specify a root directory, e.g. T("///x/")
*/
/**/

//DEPRECATED.  USE diskFindFileOrDirF
#if defined( NEVERdEFINED )

//U: IMPOTENCE IF handleP BEFORE OR AFTER I OBTAIN A FILE (OR, ALLOW IT BUT CALL CLOSEEARLY)

/*1*/voidT etherC::diskFindFileOrDirOldF( tinS& tinP , strokeS*& psttNameP , handleC& handleP , const strokeS* const psttLikeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttLikeP ) ;
        if( POOP ) return ;
        __( psttLikeP->idAdam < 6 ) ;
        if( POOP ) return ;
    }

    _IO_
    {
        ZE( infoFileS* , pInfoFile ) ;
        diskFindFileOrDirOldF( tinP , pInfoFile , handleP , psttLikeP ) ; ___( pInfoFile ) ;
        if( pInfoFile )
        {
            strMakeF( tinP , LF , psttNameP , pInfoFile->psttIfoName ) ; ___( psttNameP ) ;
            DEL( pInfoFile ) ;
        }
    }
}

#endif

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002018.etherc.diskfindfileordiroldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002019.etherc.diskfindfileordiroldf BEGIN
#define DDNAME       "3func.36002019.etherc.diskfindfileordiroldf"
#define DDNUMB      (countT)0x36002019
#define IDFILE      (countT)0xc45


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskFindFileOrDirOldF.0.html\"\>instances\</A\>
\<A HREF=\"5.103001e.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.c210104.1.1.0.html\"\>c210104:  WAKEsHOW( "example.simplest.func.103001e.etherC.diskFindFileOrDirOldF" )\</A\>
call me repeatedly to search for all files whose names match psttLikeP
arguments
 pInfoFileP
  must be 0
 handleP
  must be 0 on the first call for a search
  call this function repeatedly until handleP is 0
 psttLikeP
  a file name
   example: T("///ideafarm/ephemeral/tmp/103001e.*")
  must not be 0
  must not specify a root directory, e.g. T("///x/")
*/
/**/

//DEPRECATED.  USE diskFindFileOrDirF
#if defined( NEVERdEFINED )

/*1*/voidT etherC::diskFindFileOrDirOldF( tinS& tinP , infoFileS*& pInfoFileP , handleC& handleP , const strokeS* const psttLikeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttLikeP ) ;
        if( POOP ) return ;
        __( psttLikeP->idAdam < 6 ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , psttLike ) ;
    diskMapFileNameF( tinP , psttLike , psttLikeP ) ; ___( psttLike ) ;
    __Z( psttLike ) ;

#if !defined( NEVERdEFINED )
    //if( tinP.pc Utility[ 0 ] ) //U::
    {
        fileNameC fnLike( tinP , *this , psttLike ) ;
        patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        diskFindFileOrDirF( tinP , pInfoFileP , handleP , fnLike.pathF() , &pat ) ;
    }
    //else
#else
    {
        if( !POOP )
        {
            __( psttLike->idCaste != sc_PREFIXlENGTH ) ;
            __( psttLike[ CSpREFIX     ] != S1C('/') ) ;
            __( psttLike[ CSpREFIX + 1 ] != S1C('/') ) ;
            __( psttLike[ CSpREFIX + 2 ] != S1C('/') ) ;
            if( psttLike[ CSpREFIX + 3 ] != S1C('/') )          //20190826@0844: ACCOMMODATE NETWORK FILE NAMES OF THE FORM "////netbiosname/disk/path/short"
            {
                __( psttLike[ CSpREFIX + 4 ] != S1C('/') ) ;
            }
        }    

        if( !POOP )
        {
            ZE( osTextT* , post ) ;
            strMakeF( tinP , LF , post , psttLike ) ; ___( post ) ;
            third.dosFindFileOrDirF( tinP , pInfoFileP , handleP , osFileNameC( tinP , third , post ) ) ; ___( pInfoFileP ) ;
            third.delF( tinP , post ) ;

            if( pInfoFileP )
            {
                ifFileNameC iffn( tinP , third , pInfoFileP->postOsName ) ;
                strMakeF( tinP , LF , pInfoFileP->psttIfoName , T(iffn) ) ; ___( pInfoFileP->psttIfoName ) ;
                //delF( tinP , pInfoFileP->postOsName ) ;
            }
        }
    }
#endif

    delF( tinP , psttLike ) ;
}

#endif

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002019.etherc.diskfindfileordiroldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600201a.etherc.diskchoosesitef BEGIN
#define DDNAME       "3func.3600201a.etherc.diskchoosesitef"
#define DDNUMB      (countT)0x3600201a
#define IDFILE      (countT)0xc46


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskChooseSiteF.0.html\"\>instances\</A\>
\<A HREF=\"5.103001f.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.d210104.1.1.0.html\"\>d210104:  WAKEsHOW( "example.simplest.func.103001f.etherC.diskChooseSiteF" )\</A\>
evaluates to the number of bytes of free space
arguments
 psttP
 psttKeyP
  example: T("ideafarm")
  example: T("103001f")
  must be alphanumeric or '_'
   must not contain '/' or '.'
 psttPathP
*/
/**/

/*1*/countT etherC::diskChooseSiteF( tinS& tinP , strokeS*& psttP , const strokeS* const psttKeyP , const strokeS* const psttPathP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __( !psttPathP && !psttKeyP ) ;
        __( psttPathP && psttPathP[ CSpREFIX - 1 + psttPathP->idAdam ].idAdam - '/' ) ;
        if( POOP ) return 0 ;
        __( !!psttKeyP && !psttKeyP->idAdam ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    homeS& home = homeS::homeIF() ;
    boolT bIdeafarm = !psttPathP && !strCompareF( tinP , psttKeyP , T("ideafarm") ) ;

    ZE( countT , cbFree ) ;
    if( bIdeafarm && home.postHome[ 0 ] ) { strMakeFromOsTextF( tinP , psttP , T(ifFileNameC(tinP,third,home.postHome))+T("/") ) ; ___( psttP ) ; }
    else
    {
        ZE( strokeS* , psttEnv ) ;
        //osEnvironmentVariableF( tinP , psttEnv , psttKeyP ) ; ___( psttEnv ) ;

        ZE( strokeS* , psttSetting ) ;

        //A: 20141129@2025: DISABLED TO KEEP SYNCH WITH diskFindHomeIF ; THE USE OF LITTLE SETTINGS FILES IS OBSOLETE ; IF A SETTING IS TO BE USED, QUERY THE SETTINGS bitTreeC
        //A: {
        //A:     TN( tFile , "c" ":\\ideafarm." ) ; tFile += TF1(etherC::ifc_idHomeIdisk_IF())+T(".setting.keyValue.")+T(psttKeyP) ;
        //A: 
        //A:     osTextT postValue[ 0x100 ] ;
        //A:     countT  costValue = sizeof postValue ;
        //A: 
        //A:     POOPIE
        //A:     thirdC::dosReadIF( tinP , postValue , costValue , tFile ) ;
        //A: 
        //A:     if( !POOP ) { strMakeF( tinP , LF , psttSetting , T(postValue) ) ; ___( psttSetting ) ; }
        //A:     else        POOPR
        //A: }

        if( psttSetting )
        {
            __( psttSetting[ CSpREFIX - 1 + psttSetting->idAdam ].idAdam - '/' ) ;

            fileNameC fnLike( tinP , *this , psttSetting ) ;
            patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

            ZE( strokeS* , psttb ) ;
            diskFindFileOrDirF( tinP , psttb , fnLike.pathF() , &pat ) ; ___( psttb ) ;
            if( psttb && !psttb->idAdam ) diskMakeDirF( tinP , psttSetting ) ;
            delF( tinP , psttb ) ;
            strMakeF( tinP , LF , psttP , psttSetting ) ; ___( psttP ) ;
        }
        //DEPRECATED FOR PORTABILITY: ALL "ENVIRONMENT" SETTINGS ARE PICKED UP FROM LITTLE FILES IN THE ROOT DIRECTORY "c"":\"
        //else if( psttEnv )
        //{
        //    __( psttEnv[ CSpREFIX - 1 + psttEnv->idAdam ].idAdam - '/' ) ;
        //    ZE( strokeS* , psttb ) ;
        //    diskFindFileOrDirF( tinP , psttb , psttEnv ) ; ___( psttb ) ;
        //    if( psttb && !psttb->idAdam ) diskMakeDirF( tinP , psttEnv ) ;
        //    delF( tinP , psttb ) ;
        //    strMakeF( tinP , LF , psttP , psttEnv ) ; ___( psttP ) ;
        //}
        else
        {
            const countT idHomeDisk = ifc_idHomeIdisk_IF() ;
            ZE( strokeS* , psttPath ) ;
            if( psttPathP ) { strFuseF( tinP , psttPath , psttPathP                                                 ) ; ___( psttPath ) ; }
            else
            {
                TN( tPath , "" ) ; tPath = T("///?/")+T(psttKeyP)+T(".home.")+TF2(idHomeDisk,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("/") ;
                if( strCompareF( tinP , psttKeyP , T("ideafarm") ) )
                    traceF( tinP , T("diskChooseSiteF / warning: probable configuration error (missing drive letter?): unexpected key [pattern]: ")+tPath ) ;
                strFuseF( tinP , psttPath , tPath ) ; ___( psttPath ) ;
            }

            {
                fileNameC fnLike( tinP , *this , psttPath ) ;
                patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                
                ZE( strokeS* , pstt1List ) ;
                QUITOZ diskFindFileOrDirF( tinP , pstt1List , fnLike.pathF() , &pat ) ; ___( pstt1List ) ; QUITR
                if( pstt1List && pstt1List->idAdam )
                {
                    FORsTRINGSiN1( pstt1List )
                    {
                        strMakeF( tinP , LF , psttP , psttc1 ) ; ___( psttP ) ;
                        break ;
                    }
                }
                delF( tinP , pstt1List ) ;
            }

            if( !psttP )
            {
                ZE( strokeS* , psttDiskBest ) ;
                diskFindMostFreeSpaceF( tinP , psttDiskBest ) ; ___( psttDiskBest ) ;
                if( !POOP ) psttPath[ CSpREFIX + 3 ] = psttDiskBest[ CSpREFIX + 3 ] ;
                delF( tinP , psttDiskBest ) ;
                diskMakeDirF( tinP , psttPath ) ;
                strMakeF( tinP , LF , psttP , psttPath ) ; ___( psttP ) ;
            }

            delF( tinP , psttPath ) ;
        }
        delF( tinP , psttSetting ) ;
        delF( tinP , psttEnv ) ;

        {
            ZE( infoDiskS* , pInfo ) ;
            diskInfoF( tinP , pInfo , psttP ) ; ___( pInfo ) ;
            if( pInfo ) cbFree = pInfo->cBytesPerSector * pInfo->cSectorsPerAllocationUnit * pInfo->cUnusedUnits ;
            DEL( pInfo ) ;
        }

        if( bIdeafarm && psttP )
        {
            ZE( strokeS* , psttNoSlash ) ;
            countT idf = 1 ;
            countT idl = psttP->idAdam - 1 ;
            strSubstringF( tinP , psttNoSlash , idf , idl , psttP ) ; ___( psttNoSlash ) ;

            TN( tHome , psttNoSlash ) ;
            delF( tinP , psttNoSlash ) ;

            thirdC::c_strncpyIF( tinP , home.postHome , tHome , sizeof home.postHome ) ;
        }
    }

    return cbFree ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600201a.etherc.diskchoosesitef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600201b.etherc.diskfindmostfreespacef BEGIN
#define DDNAME       "3func.3600201b.etherc.diskfindmostfreespacef"
#define DDNUMB      (countT)0x3600201b
#define IDFILE      (countT)0xc47


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskFindMostFreeSpaceF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030020.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.e210104.1.1.0.html\"\>e210104:  WAKEsHOW( "example.simplest.func.1030020.etherC.diskFindMostFreeSpaceF" )\</A\>
remote file systems will be excluded in the search
arguments
 psttDiskP
  must be 0
*/
/**/

/*1*/voidT etherC::diskFindMostFreeSpaceF( tinS& tinP , strokeS*& psttDiskP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    IFsCRATCH
    {
        strokeS psttDisk[ CSpREFIX + 4 ] ;
        strokeS psttBest[ CSpREFIX + 4 ] ;
        SETpREFIX( psttDisk , 4 , 0 ) ;
        SETpREFIX( psttBest , 4 , 0 ) ;
        psttDisk[ CSpREFIX     ] = '/' ;
        psttDisk[ CSpREFIX + 1 ] = '/' ;
        psttDisk[ CSpREFIX + 2 ] = '/' ;
        psttDisk[ CSpREFIX + 3 ] = 0 ;
        psttBest[ CSpREFIX     ] = '/' ;
        psttBest[ CSpREFIX + 1 ] = '/' ;
        psttBest[ CSpREFIX + 2 ] = '/' ;
        psttBest[ CSpREFIX + 3 ] = 0 ;
        ZE( countT , cbBest ) ;
        for( psttDisk[ CSpREFIX + 3 ] = 'c' ; psttDisk[ CSpREFIX + 3 ] <= 'z' ; ++ psttDisk[ CSpREFIX + 3 ] ) // 2011.10.24: ASCENDING NOW
        {
            ZE( infoDiskS* , pInfo ) ;
            {
                SCOOPS
                tinP.pEtScratch->diskInfoF( tinP , pInfo , psttDisk , 1 ) ; ___( pInfo ) ;
                if( POOP ) { POOPR ; }
            }

            if( pInfo )
            {
                boolT bLocal = pInfo->bLocal ;
                countT cbFree = pInfo->cBytesPerSector * pInfo->cSectorsPerAllocationUnit * pInfo->cUnusedUnits ;
                DEL( pInfo ) ;
                if( bLocal && cbBest < cbFree )
                {
                    ZE( osTextT* , postDisk ) ;
                    strMakeF( tinP , LF , postDisk , psttDisk ) ; ___( postDisk ) ;
                    if( third.c_zDiskFLongFileNamesOKF( tinP , postDisk ) )
                    {
                        cbBest = cbFree ;
                        psttBest[ CSpREFIX + 3 ] = psttDisk[ CSpREFIX + 3 ] ;
                    }
                    delF( tinP , postDisk ) ;
                }
            }
        }
        if( psttBest->idAdam > 3 ) { strMakeF( tinP , LF , psttDiskP , psttBest ) ; ___( psttDiskP ) ; }
    }
    __Z( psttDiskP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600201b.etherc.diskfindmostfreespacef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600201c.etherc.diskmakedirf BEGIN
#define DDNAME       "3func.3600201c.etherc.diskmakedirf"
#define DDNUMB      (countT)0x3600201c
#define IDFILE      (countT)0xc48


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskMakeDirF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030021.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f210104.1.1.0.html\"\>f210104:  WAKEsHOW( "example.simplest.func.1030021.etherC.diskMakeDirF" )\</A\>
makes a directory by recursively calling itself if a failure occurs, eliminating the youngest directory each time
once a success is made, the recursion unwinds, creating all of the necessary kids
arguments
 psttP
  the name of the directory to create
  must end with '/'
   directory names must end with '/'
   file names cannot end with '/'
  example: T("///ideafarm/ephemeral/1030021/d1/d11/d111/d1111/")
  example: T("///c" "/d1/d11/d111/d1111/")
   in this example, directory T("///c" "/d1/") need not exist
   it will be created if needed, along with d11 and d111 before making d1111
*/
/**/

//                                                  12345678
//                                                 "///x/tmp/foo.ttt"
//                                                 "////n/x/tmp/foo.ttt"
// 20200319@1842: EDIT TO HANDLE NAMES OF THE FORM "////factory8/x/tmp/foo.ttt"

//RULE FOR NETBIOS psttP: DON'T TRY TO MAKE THE SHARE NAME

/*1*/boolT etherC::diskMakeDirF( tinS& tinP , const strokeS* const psttP )/*1*/
{
        SCOOP
    
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttP ) ;
        if( POOP ) return 0 ;
        __( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam - '/' ) ;
        if( POOP ) return 0 ;
    }

    //LOGrAW( T("diskMakeDirF [psttP]:    \"")+T(psttP)+T("\"\r\n") ) ; //U::

    _IO_
    ZE( boolT , bExisted ) ;
    IFsCRATCH
    {
        SCOOPSnEW
        bExisted = tinP.pEtScratch->diskMakeDirStupidlyF( tinP , psttP ) ;
        if( !POOP ) SCOOPSdEL
        else
        {
            POOPR
            SCOOPSdEL

            // COULDN'T MAKE psttP SO WILL CALL MYSELF TO MAKE DAD AND THEN TRY AGAIN

            //CS:CODEsYNCH: PSEUDODUPLICATE: 3600201c 3600201d
            boolT bLan =                        //20200319@1858: EDITED TO HANDLE psttP OF THE FORM "////factory8/x/tmp/"  (4TH SLASH INDICATES NetBIOS HOST NAME FOLLOWS)
                   psttP[ 0 ] == S1C('/')
                && psttP[ 1 ] == S1C('/')
                && psttP[ 2 ] == S1C('/')
                && psttP[ 3 ] == S1C('/')
            ;

            ZE( countT , idSlashStop ) ;
            {
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                idSlashStop = strIdF( tinP , countTC( 1 ) , sttq , S1C('/') , psttP , psttP->idAdam - 1 , ( bLan ? 6 : 4 ) ) ;
            }

            ZE( countT , idSlashDad ) ;
            {
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                idSlashDad = strIdF( tinP , countTC( 1 ) , sttq , S1C('/') , psttP , psttP->idAdam - 1 , - 1 ) ;
            }

            if( idSlashDad <= idSlashStop ) // SHOULDN'T EVER BE TRUE
            {
                TN( tSay , "" ) ; tSay = T("diskMakeDirF/could not make psttP, and dad is the name of either a drive or a network share [psttP]: \"")+T(psttP)+T("\"\r\n") ;
                CONoUTrAW( tSay ) ;
                LOGrAW( tSay ) ;
                LOGcALLnEST( "diskMakeDirF" )
                __1
            }
            else
            {
                ZE( strokeS* , psttDad ) ;
                countT idf = 1 ;
                strSubstringF( tinP , psttDad , idf , idSlashDad , psttP ) ; ___( psttDad ) ;
                diskMakeDirF( tinP , psttDad ) ;
                delF( tinP , psttDad ) ;
            }

            bExisted = diskMakeDirStupidlyF( tinP , psttP ) ;
        }
    }

    return bExisted ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600201c.etherc.diskmakedirf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600201d.etherc.diskmakedirifneededf BEGIN
#define DDNAME       "3func.3600201d.etherc.diskmakedirifneededf"
#define DDNUMB      (countT)0x3600201d
#define IDFILE      (countT)0xc49


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskMakeDirIfNeededF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030022.1.0.html\"\>definition\</A\>
i make the container of psttFileOrDirP if it does not exist
examples
 simplest
  \<A HREF=\"5.0310104.1.1.0.html\"\>0310104:  WAKEsHOW( "example.simplest.func.1030022.etherC.diskMakeDirIfNeededF" )\</A\>
arguments
 psttFileOrDirP
  if this does not contain a slash '/' (other than the terminating slash if a directory) then i will silently do nothing
  example: T("///ideafarm/ephemeral/tmp/1030022/")
   i will make T("///ideafarm/ephemeral/tmp/")
  example: T("///ideafarm/ephemeral/tmp/1030022/myfile")
   i will make T("///ideafarm/ephemeral/1030022/")
  if a root directory is implied (e.g. T("///x/foo")) then i verify that the drive exists
*/
/**/

//                                                  12345678
//                                                 "///x/tmp/foo.ttt"
//                                                 "////n/x/tmp/foo.ttt"
// 20200319@1842: EDIT TO HANDLE NAMES OF THE FORM "////factory8/x/tmp/foo.ttt"

/*1*/boolT etherC::diskMakeDirIfNeededF( tinS& tinP , const strokeS* const psttFileOrDirP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    //LOGrAW( T("diskMakeDirIfNeededF [psttFileOrDirP]:    \"")+T(psttFileOrDirP)+T("\"\r\n") ) ; //U::

    _IO_
    ZE( boolT , bMade ) ;
    {
        _IO_
        //boolT bDir = psttFileOrDirP[ CSpREFIX - 1 + psttFileOrDirP->idAdam ].idAdam == '/' ;

        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        const countT idSlash = strIdF( tinP , countTC( 1 ) , sttq , S1C('/') , psttFileOrDirP , 0 , - 1 /*- bDir*/ ) ; //20170714@1243: COMMENTED OUT "- bDir" SO WILL NOW CREATE THE ENTIRE PATH SPECIFIED IN psttFileOrDirP RATHER THAN IGNORE THE LEAF DIRECTORY

        if( idSlash )
        {
            _IO_
            ZE( strokeS* , psttDir ) ;
            countT idf = 1 ;
            countT idl = idSlash ;
            strSubstringF( tinP , psttDir , idf , idl , psttFileOrDirP ) ; ___( psttDir ) ;
    
            //CS:CODEsYNCH: PSEUDODUPLICATE: 3600201c 3600201d
            boolT bLan =                        //20200319@1858: EDITED TO HANDLE psttP OF THE FORM "////factory8/x/tmp/"  (4TH SLASH INDICATES NetBIOS HOST NAME FOLLOWS)
                   psttFileOrDirP[ 0 ] == S1C('/')
                && psttFileOrDirP[ 1 ] == S1C('/')
                && psttFileOrDirP[ 2 ] == S1C('/')
                && psttFileOrDirP[ 3 ] == S1C('/')
            ;

            if( idSlash > ( bLan ? 8 : 5 ) )
            {
                _IO_
                fileNameC fnLike( tinP , *this , psttDir ) ;
                patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

                ZE( strokeS* , pstt1b ) ;
                diskFindFileOrDirF( tinP , pstt1b , fnLike.pathF() , &pat ) ; ___( pstt1b ) ;
    
                ZE( boolT , bFound ) ;
                FORsTRINGSiN1( pstt1b )
                {
                    _IO_
                    if( psttc1[ CSpREFIX - 1 + psttc1->idAdam ].idAdam == '/' ) bFound = 1 ;
                    else
                    {
                        LOGrAW( T("diskMakeDirIfNeededF / exception / collision with a nondirectory named \"")+T(psttc1)+T("\"\r\n") ) ;
                        __1
                    }
                    break ;
                }
    
                if( !bFound && !POOP )
                {
                    _IO_
                    bMade = !diskMakeDirF( tinP , psttDir ) ;
                }

                {
                    _IO_
                    delF( tinP , pstt1b ) ;
                }
            }
            else if( idSlash == 5 ) bMade = !diskMakeDirStupidlyF( tinP , psttDir ) ; //ROOT DIRECTORY SPECIFIED. THIS JUST VERIFIES THAT THE DRIVE EXISTS
            else { __( idSlash ) ; }
    
            {
                _IO_
                delF( tinP , psttDir ) ;
            }
        }
    }
    return bMade ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600201d.etherc.diskmakedirifneededf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600201e.etherc.diskmakedirstupidlyf BEGIN
#define DDNAME       "3func.3600201e.etherc.diskmakedirstupidlyf"
#define DDNUMB      (countT)0x3600201e
#define IDFILE      (countT)0xc4a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskMakeDirStupidlyF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030023.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1310104.1.1.0.html\"\>1310104:  WAKEsHOW( "example.simplest.func.1030023.etherC.diskMakeDirStupidlyF" )\</A\>
arguments
 psttP
  must end with '/'
   directory names must end with '/'
   file names cannot end with '/'
  example: T("///ideafarm/ephemeral/tmp/1030023/mydir/")
   this will succeed only if the parent directories already exist
    T("///ideafarm/ephemeral/tmp/"        ) must already exist
    T("///ideafarm/ephemeral/tmp/1030023/") must already exist
  T("///x/") (special case): nothing will be done except to verify that drive x exists
*/
/**/

/*1*/boolT etherC::diskMakeDirStupidlyF( tinS& tinP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttP ) ;
        if( POOP ) return 0 ;
        __( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam - '/' ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( boolT , bExisted ) ;
    {
        ZE( strokeS* , pstt ) ;
        diskMapFileNameF( tinP , pstt , psttP ) ; ___( pstt ) ;
        ZE( osTextT* , post ) ;
        strMakeF( tinP , LF , post , pstt ) ; ___( post ) ;
        delF( tinP , pstt ) ;
        bExisted = third.dosCreateDirF( tinP , osFileNameC( tinP , third , post ) ) ;
        third.delF( tinP , post ) ;
    }
    return bExisted ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600201e.etherc.diskmakedirstupidlyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600201f.etherc.diskmapfilenamef BEGIN
#define DDNAME       "3func.3600201f.etherc.diskmapfilenamef"
#define DDNUMB      (countT)0x3600201f
#define IDFILE      (countT)0xc4b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskMapFileNameF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030024.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.2310104.1.1.0.html\"\>2310104:  WAKEsHOW( "example.simplest.func.1030024.etherC.diskMapFileNameF" )\</A\>
arguments
 psttP
 psttRawP
  can be either a file name or a directory name
   file name: T("///ideafarm/ephemeral/foo")
   dir  name: T("///ideafarm/ephemeral/foo/")
   file name: T("///desk/foo")
   dir  name: T("///desk/foo/")
*/
/**/

/*1*/voidT etherC::diskMapFileNameF( tinS& tinP , strokeS*& psttP , const strokeS* const psttRawP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( psttRawP ) ;
        if( POOP ) return ;
        __( psttRawP->idCaste != sc_PREFIXlENGTH ) ;
        if( POOP ) return ;
    }

    _IO_
    {
        boolT bEndWithSlash = psttRawP[ CSpREFIX - 1 + psttRawP->idAdam ] == S1C('/') ;

        strMakeF( tinP , LF , psttP , T("") , psttRawP->idAdam + third.dosQuerySysInfoMaxPathLengthIF( tinP ) + 2 ) ; // THERE ARE A FEW EXTRA BYTES
        ZE( strokeS* , psttSlash ) ;
        strMakeF( tinP , LF , psttSlash , T("/") ) ; ___( psttSlash ) ;
        ZE( strokeS* , psttw ) ;
        countT idf = 1 ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        strSubstringF( tinP , psttw , idf , sttq , S1C('/') , psttRawP ) ; ___( psttw ) ;
        ZE( countT , idWord ) ;
        while( !POOP && psttw )
        {
            idWord ++ ;
            if                                                                                              // IT IS WORD 4 AND IS AN IDENTIFIER OTHER THAN A DRIVE LETTER
            (
                idWord == 4 &&
                (
                    psttw->idAdam > 1                                                       ||
                    (
                        psttw->idAdam == 1                                                  &&
                        (countT)psttw[ CSpREFIX ]                                           &&
                        !( psttw[ CSpREFIX ] >= S1C('a') && psttw[ CSpREFIX ] <= S1C('z') ) &&
                        !( psttw[ CSpREFIX ] >= S1C('A') && psttw[ CSpREFIX ] <= S1C('Z') )
                    )
                )
            )
            {
                if( !strCompareF( tinP , psttw , T("desk") ) )
                {
                    ZE( strokeS* , psttd ) ;
                    osEnvironmentVariableF( tinP , psttd , T("ALLUSERSPROFILE") ) ; ___( psttd ) ;
                    ifFileNameC iff( tinP , *this , T(psttd)+T("\\Desktop\\") ) ;
                    delF( tinP , psttd ) ;
                    delF( tinP , psttP ) ;

                    TN( tIdf , "" ) ; tIdf = T(iff) ;
                    countT idf = 1 ;
                    countT idl = tIdf.csF( tinP ) - 1 ;
                    strSubstringF( tinP , psttd , idf , idl , tIdf ) ; ___( psttd ) ;
                    strFuseF( tinP , psttP , psttd , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ psttRawP->idAdam + third.dosQuerySysInfoMaxPathLengthIF( tinP ) ) ; ___( psttP ) ;
                    delF( tinP , psttd ) ;
                }
                else
                {
                    ZE( strokeS* , psttHome ) ;
                    diskChooseSiteF( tinP , psttHome , psttw ) ; ___( psttHome ) ;
                    __Z( psttHome ) ;
                    __( psttHome && psttHome[ CSpREFIX - 1 + psttHome->idAdam ].idAdam - '/' ) ;
    
                    if( !POOP )
                    {
                        countT idf2 = 4 ;
                        countT idl2 = psttHome->idAdam - 1 ;
                        ZE( strokeS* , pstts ) ;
                        strSubstringF( tinP , pstts , idf2 , idl2 , psttHome ) ; ___( pstts ) ;
                        delF( tinP , psttHome ) ;
                        strFuseF( tinP , psttP , pstts ) ; ___( psttP ) ;
                        delF( tinP , pstts ) ;
                    }
                }
            }
            else { strFuseF( tinP , psttP , psttw ) ; ___( psttP ) ; }                                      // OTHERWISE
            delF( tinP , psttw ) ;

            if( idf || bEndWithSlash )
            {
                strFuseF( tinP , psttP , psttSlash ) ; ___( psttP ) ;
                if( idf ) { strSubstringF( tinP , psttw , idf , sttq , S1C('/') , psttRawP ) ; ___( psttw ) ; }
            }
        }
        delF( tinP , psttw ) ;
        delF( tinP , psttSlash ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600201f.etherc.diskmapfilenamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002020.etherc.diskidf BEGIN
#define DDNAME       "3func.36002020.etherc.diskidf"
#define DDNUMB      (countT)0x36002020
#define IDFILE      (countT)0xc4c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskIdF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030025.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.3310104.1.1.0.html\"\>3310104:  WAKEsHOW( "example.simplest.func.1030025.etherC.diskIdF" )\</A\>
arguments
 psttDriveNameP
  can be 0
  if 0 then returns the volume serial number of the drive containing the ideafarm home directory
   originally and for many ducks, i would return the serial number of drive "///c"
   20120322@1205: edited to return the volume serial number of the drive containing the ideafarm home directory
*/
/**/

/*1*/countT etherC::diskIdF( tinS& tinP , const strokeS* const psttDriveNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( countT , id ) ;
    {
        TN( tDisk , psttDriveNameP ) ;
        if( !psttDriveNameP )
        {
            ZE( strokeS* , psttm ) ;
            diskMapFileNameF( tinP , psttm , T("///ideafarm/") ) ; ___( psttm ) ;
            if( psttm && psttm->idAdam > 3 )
            {
                osTextT postd[] = { '/' , '/' , '/' , (osTextT)psttm[ CSpREFIX + 3 ].idAdam , 0 } ;
                tDisk = T(postd) ;
            }
            delF( tinP , psttm ) ;
        }

        strokeS* psttzDisk = tDisk ;
        ZE( infoDiskS* , pInfo ) ;
        diskInfoF( tinP , pInfo , tDisk ) ; ___( pInfo ) ;
        if( pInfo ) id = pInfo->idVolume ;
        DEL( pInfo ) ;
    }

    return id ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002020.etherc.diskidf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002021.etherc.diskinfof BEGIN
#define DDNAME       "3func.36002021.etherc.diskinfof"
#define DDNUMB      (countT)0x36002021
#define IDFILE      (countT)0xc4d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskInfoF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030026.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.4310104.1.1.0.html\"\>4310104:  WAKEsHOW( "example.simplest.func.1030026.etherC.diskInfoF" )\</A\>
arguments
 pInfoDiskP
  must be 0
 psttDriveNameP
  example: T("///c")
*/
/**/

/*1*/voidT etherC::diskInfoF( tinS& tinP , infoDiskS*& pInfoDiskP , const strokeS* const psttDriveNameP , const countT cTriesP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        if( !POOP ) __Z( psttDriveNameP ) ;
        if( POOP ) return ;
    }

    _IO_    //20200912@1843: ADDED WITHOUT ANALYSIS

    //IN_E
    ZE( infoDisk1S* , pInfoDisk1 ) ;
    ZE( osTextT* , post ) ;
    strMakeF( tinP , LF , post , psttDriveNameP ) ; ___( post ) ;
    third.dosQueryFSInfoF( tinP , pInfoDisk1 , post , cTriesP ) ; ___( pInfoDisk1 ) ;
    third.delF( tinP , post ) ;

    if( !POOP && pInfoDisk1 )
    {
        pInfoDiskP = new( 0 , tinP , LF ) infoDiskS( tinP , third ) ; ___( pInfoDiskP ) ;
        __Z( pInfoDiskP ) ;
        __( !!pInfoDiskP->psttVolumeName ) ;
    }

    if( !POOP && pInfoDisk1 && pInfoDiskP )
    {
        strMakeF( tinP , LF , pInfoDiskP->psttVolumeName , T(pInfoDisk1->postVolumeName) ) ; ___( pInfoDiskP->psttVolumeName ) ;
        if( !POOP )
        {
            *pInfoDiskP << *pInfoDisk1 ;
            pInfoDiskP->bLocal = pInfoDisk1->bLocal ;
        }
    }
    DEL( pInfoDisk1 ) ;
    //OUT
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002021.etherc.diskinfof END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002022.etherc.dllentryf BEGIN
#define DDNAME       "3func.36002022.etherc.dllentryf"
#define DDNUMB      (countT)0x36002022
#define IDFILE      (countT)0xc4e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dllEntryF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030028.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 pvP
 handleP
 psttP
*/
/**//*1*/voidT etherC::dllEntryF( tinS& tinP , voidT*& pvP , const handleC& handleP , const strokeS* psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pvP ) ;
        __Z( handleP ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    ZE( osTextT* , post ) ;
    strMakeF( tinP , LF , post , psttP ) ; ___( post ) ;
    third.dosQueryProcAddrF( tinP , pvP , handleP , post ) ;
    third.delF( tinP , post ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002022.etherc.dllentryf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002023.etherc.dllentryf BEGIN
#define DDNAME       "3func.36002023.etherc.dllentryf"
#define DDNUMB      (countT)0x36002023
#define IDFILE      (countT)0xc4f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dllEntryF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030029.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 pMainFP
 handleP
 psttP
*/
/**//*1*/voidT etherC::dllEntryF( tinS& tinP , mainFT& pMainFP , const handleC& handleP , const strokeS* psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pMainFP ) ;
        __Z( handleP ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    TN( tOs2 , "" ) ; tOs2 = T(psttP) ;
    TN( tWin , "" ) ; tWin = T("_")+T(psttP)+T("@4") ;
    TN( tLin , "" ) ; tLin = T("?") ;

    ZE( voidT* , pv ) ;
    dllEntryF( tinP , pv , handleP , TO((strokeS*)tOs2,(strokeS*)tWin,(strokeS*)tLin) ) ;
    pMainFP = (mainFT)pv ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002023.etherc.dllentryf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002024.etherc.dllnamef BEGIN
#define DDNAME       "3func.36002024.etherc.dllnamef"
#define DDNUMB      (countT)0x36002024
#define IDFILE      (countT)0xc50


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dllNameF.0.html\"\>instances\</A\>
\<A HREF=\"5.103002a.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 psttP
 handleP
*/
/**//*1*/voidT etherC::dllNameF( tinS& tinP , strokeS*& psttP , const handleC& handleP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    if( !POOP ) __NZ( psttP ) ;
    ZE( osTextT* , post ) ;
    third.dosQueryModuleNameF( tinP , post , handleP ) ; ___( post ) ;
    strMakeF( tinP , LF , psttP , T(post) ) ; ___( psttP ) ;
    third.delF( tinP , post ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002024.etherc.dllnamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002025.etherc.dllopenf BEGIN
#define DDNAME       "3func.36002025.etherc.dllopenf"
#define DDNUMB      (countT)0x36002025
#define IDFILE      (countT)0xc51


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dllOpenF.0.html\"\>instances\</A\>
\<A HREF=\"5.103002b.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
it is illegal for any ifc code to modify the master or the hover directory without grabbing: batonC batUpdate( tinP , TAG( TAGiDnULL ) , T("ifc.update") ) ;
arguments
 psttP
*/

/**//*1*/voidT etherC::dllOpenF( tinS& tinP , handleC& hDllP , const strokeS* psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( !tinP.pAdamGlobal1->_etherC_.pEtPrime ) ;
        __( !tinP.pAdamGlobal1->_etherC_.pSwDllReferences ) ;
        if( POOP ) return ;
    }

    _IO_

    {
        TELL( "dllOpen / 6" ) ; thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG: 20180525@0729
        batonC batUpdate( tinP , TAG( TAGiDnULL ) , T("ifc.update") , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) ;
        batUpdate.grabF( tinP , TAG( TAGiDnULL ) ) ;
        TELL( "dllOpen / 5" ) ; thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG: 20180525@0729

        ZE( strokeS* , psttMapped ) ;
        {
            ZE( strokeS* , psttm ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            diskMapFileNameF( tinP , psttm , psttP ) ; ___( psttm ) ;
            diskMapFileNameHoverF( tinP , psttMapped , psttm ) ; ___( psttMapped ) ;
            THREADmODE1rESTORE
            delF( tinP , psttm ) ;
        }
        TELL( "dllOpen / 4" ) ; thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG: 20180525@0729

        ZE( osTextT* , post ) ;
        strMakeF( tinP , LF , post , psttMapped ) ; ___( post ) ;
        delF( tinP , psttMapped ) ;
        ZE( osTextT* , postAnticipatedError ) ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        TELL( "dllOpen / 3" ) ; thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG: 20180525@0729
        third.dosLoadModuleF( tinP , hDllP , postAnticipatedError , osFileNameC( tinP , third , post ) , this ) ; ___( postAnticipatedError ) ;
        TELL( "dllOpen / 2" ) ; thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG: 20180525@0729
        THREADmODE1rESTORE

        TELL( "dllOpen / 1" ) ; thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG: 20180525@0729

        batUpdate.ungrabF( tinP ) ;

        TELL( "dllOpen / 0" ) ; thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG: 20180525@0729

        //U::NEEDS REWRITE NOW THAT handleC IS USED; MY CALLER WILL DT hDllP, WHICH WILL CLOSE THE OS HANDLE
        //CONJ: NO LONGER NEEDED
        // tinP.pAdamGlobal1->_etherC_.pSwDllReferences->grabF( tinP , TAG( TAGiDnULL ) ) ;
        // if( ~hDllP )
        // {
        //     tinP.pAdamGlobal1->_etherC_.oshDllLever = hDllP.osF( ifcIDtYPEhANDLE_DLL ) ;
        //     ++ ( (countT&)*tinP.pAdamGlobal1->_etherC_.pSwDllReferences ) ;
        // }
        // tinP.pAdamGlobal1->_etherC_.pSwDllReferences->ungrabF( tinP ) ;

        third.delF( tinP , post ) ;
        if( !POOP && postAnticipatedError )
        {
            strokeF( tinP , T("\r\nSometimes that doesn''t work.  Please try again after pressing Enter.") ) ;
            if( !( F(flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) ) etherPutLogF( tinP , T(postAnticipatedError) ) ;
            __1
        }
        third.delF( tinP , postAnticipatedError ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002025.etherc.dllopenf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002026.etherc.ostimeaddf BEGIN
#define DDNAME       "3func.36002026.etherc.ostimeaddf"
#define DDNUMB      (countT)0x36002026
#define IDFILE      (countT)0xc52


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osTimeAddF.0.html\"\>instances\</A\>
\<A HREF=\"5.103002c.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.5310104.1.1.0.html\"\>5310104:  WAKEsHOW( "example.simplest.func.103002c.etherC.osTimeAddF" )\</A\>
arguments
 time11P
 time12P
 time21P
 time22P
*/
/**//*1*/voidT etherC::osTimeAddF( tinS& tinP , countT& time11P , sCountT& time12P , const countT time21P , const sCountT time22P )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    thirdC::osTimeAddIF( tinP , time11P , time12P , time21P , time22P ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002026.etherc.ostimeaddf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002027.etherc.strfromprocessf BEGIN
#define DDNAME       "3func.36002027.etherc.strfromprocessf"
#define DDNUMB      (countT)0x36002027
#define IDFILE      (countT)0xc53


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFromProcessF.0.html\"\>instances\</A\>
\<A HREF=\"5.103002d.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 psttOutP
 psttErrorP
 psttExeP
 psttArgsP
 psttInP
*/
/**/

/*1*/voidT etherC::strFromProcessF( tinS& tinP , strokeS*& psttOutP , strokeS*& psttErrorP , const strokeS* const psttExeP , const strokeS* const psttArgsP , const strokeS* const psttInP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttOutP ) ;
        __NZ( psttErrorP ) ;
        __Z( psttExeP ) ;
        __NZ( psttArgsP ) ; //U: NOT SUPPORTED YET
        __NZ( psttInP ) ; //U: NOT SUPPORTED YET
        if( POOP ) return ;
    }

    _IO_
    ZE( strokeS* , psttUnique ) ;
    strUniqueF( tinP , psttUnique ) ; ___( psttUnique ) ;
    argS argOut( *this , psttUnique , psttExeP ) ;
    argS argError( *this , psttUnique , psttExeP ) ;
    signC sgnDone_tmOut( tinP , TAG( TAGiDnULL ) ) ;
    signC sgnDone_tmError( tinP , TAG( TAGiDnULL ) ) ;
    {
        { ZE( countT , tnu ) ; osThreadF( tinP , tnu , tmOutF   , &sgnDone_tmOut , flTHREADlAUNCH_null , 0 , (countT)&argOut   ) ; }
        { ZE( countT , tnu ) ; osThreadF( tinP , tnu , tmErrorF , &sgnDone_tmError , flTHREADlAUNCH_null , 0 , (countT)&argError ) ; }
        {
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            ++ s ; osSleepF( tinP , TOCK ) ; //U: IF THIS ISN''T LONG ENOUGH, THE PROCESS BOX WON''T CONSTRUCT AND WE''LL HAVE A LEAK
        }
    }

    IFsCRATCH
    {
        countT cTries = 0x10 ;
        ZE( boolT , bDone ) ;
        do
        {
            SCOOPSnEW

            boxC process( tinP , *tinP.pEtScratch , T("//process/")+T(psttUnique)+T("/")+T(psttExeP) , 0 , 0 , 0 , 1 ) ;

            if( !POOP )
            {
                SCOOPSdEL
                bDone = 1 ;
                break ;
            }
            else
            {
                POOPR
                SCOOPSdEL
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                ++ s ; osSleepF( tinP , TUCK * 0x10 ) ;
            }
        }
        while( !POOP && cTries -- ) ;
        __Z( bDone ) ;
    }

    sgnDone_tmOut.waitF( tinP ) ;
    sgnDone_tmError.waitF( tinP ) ;
    delF( tinP , psttUnique ) ;
    strMakeF( tinP , LF , psttOutP   , T(argOut.post)   ) ; // CALLER MUST TAG ___( psttOutP ) ;
    strMakeF( tinP , LF , psttErrorP , T(argError.post) ) ; // CALLER MUST TAG ___( psttErrorP ) ;
    delF( tinP , argOut.post ) ;
    delF( tinP , argError.post ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002027.etherc.strfromprocessf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002028.etherc.ifcdatumf BEGIN
#define DDNAME       "3func.36002028.etherc.ifcdatumf"
#define DDNUMB      (countT)0x36002028
#define IDFILE      (countT)0xc54


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcDatumF.0.html\"\>instances\</A\>
\<A HREF=\"5.103002e.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6310104.1.1.0.html\"\>6310104:  WAKEsHOW( "example.simplest.func.103002e.etherC.ifcDatumF" )\</A\>
arguments
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010049.flDATUM1!||
 amountP
 pcResourceIdP
 idLineP
 pbFileP
 pbP
 cbP
  can be 0
  if !pbP then must be 0
  if 0 then pbP is treated as a null terminated string of bytes and the length is calculated to include the terminating null
*/
/**//*1*/voidT etherC::ifcDatumF( tinS& tinP , const flagsT flags1P , const flagsT flags2P , countT amountP , const countT* const pcResourceIdP , const countT idLineP , const voidT* const pbFileP , const byteT* const pbP , const countT cbP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        FV( flDATUM1 , flags1P ) ;
        FV( flDATUM2 , flags2P ) ;
        __( !( F(flags1P) & flDATUM1_CLASStRACElEVEL2 || F(flags1P) & flDATUM1_CLASStRACElEVEL1 || F(flags1P) & flDATUM1_CLASStRACEaLWAYShIRE || F(flags1P) & flDATUM1_CLASStRACEaLWAYSfIRE || F(flags1P) & flDATUM1_CLASStRACEaLWAYShIREdLL || F(flags1P) & flDATUM1_CLASStRACEaLWAYSfIREdLL ) ) ;
        __NZ( pcResourceIdP ) ; //FILE AND LINE ARE USED AS THE RID.  CAN FUSE THEM WITH SPECIFIED RID IF WE EVER NEED TO DO THAT
        if( POOP ) return ;
    }

    _IO_
    countT pcPart[] = { processGlobal7I.source.idFileImmutableF( tinP , processGlobal7I.source.idFileF( tinP , (osTextT*)pbFileP ) ) , idLineP , 0 } ;
    ifcDatumF( tinP , flags1P , flags2P , amountP , pcPart , pbP , cbP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002028.etherc.ifcdatumf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002029.etherc.strevaluatef BEGIN
#define DDNAME       "3func.36002029.etherc.strevaluatef"
#define DDNUMB      (countT)0x36002029
#define IDFILE      (countT)0xc55


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strEvaluateF.0.html\"\>instances\</A\>
\<A HREF=\"5.103002f.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
evaluates to 1 iff the resulting string still contains tokens that could be evaluated
 the occurance of a raw tag does not contribute to a nonze return value
  if there is only one tag, and it is raw, then the return value is 0
 this function is not iterative
 it is usually called repeatedly until it returns 0
replaces symbols in a string
the symbols contain a key and a parameter
the key indicates the type of replacement
 raw: each line is simply prepended with T(" | ")
 kt: blanks are not trimmed
 trim: blanks are trimmed
 trim2: blanks are trimmed, except in the file comments, which are assumed to be at the base of the file
  the referenced file must contain a file comment
  strokes prior to the file comments are discarded
  the file comments are trimmed for tab and end of file marks but not for blanks
  strokes above the file comments are trimmed for blanks as well as tabs and file eofs
  strings of blanks are compressed, except in the file comments
 kt & trim: class 3 delimited substrings are assumed to be symbolic constant defines and will be formatted and appended
 kt & trim: if the file is marked "visible" then it will be appended
  the file is visible if it contains a line that consists solely of "//VISIBLE"
  such files will be appended
   each line will be prepended with a ". " so that leading blanks are preserved innocuously
the parameter is a file name
the content of the file is edited and used to replace the symbol
it is illegal for a raw tag to occur along with another tag, raw or otherwise
 if a tag is raw, then it must be the only tag
arguments
 psttP
  can be 0
  if psttOldP is 0 then psttP must not be 0
 csttExtraP
 psttOldP
  can be 0
  if psttP is 0 then psttOldP must not be 0
*/
/**//*1*/boolT etherC::strEvaluateF( tinS& tinP , strokeS*& psttP , const countT csttExtraP , const strokeS* const psttOldP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __( !psttP && !psttOldP ) ;
        __( !!psttP && !!psttOldP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( strokeS* , psttOld ) ;
    if( psttOldP ) { strFuseF( tinP , psttOld , psttOldP ) ; ___( psttOld ) ; }
    else
    {
        psttOld = psttP ;
        psttP = 0 ;
    }

    strFuseF( tinP , psttP , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ psttOld->idAdam + csttExtraP ) ; // CALLER MUST TAG
    ZE( boolT , bTagsStillExist ) ;
    countT idf = 1 ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    while( !STOP && !POOP && idf )
    {
        ZE( strokeS* , psttw ) ;

        strSubstringF( tinP , psttw , idf , sttq , T("/" "/" "|" "|" "!") , psttOld , 0 ) ; ___( psttw ) ;
        strFuseF( tinP , psttP , psttw ) ;
        delF( tinP , psttw ) ;

        if( idf )
        {
            countT idfRaw = idf ;
            strokeS sttqRaw = sttq ;
            boolT bRaw = idf == strIdF( tinP , 0 , flSTRmATCH_null , idfRaw , sttqRaw , T("raw|") , psttOld ) ;
            countT idfTrim = idf ;
            strokeS sttqTrim = sttq ;
            boolT bTrim = idf == strIdF( tinP , 0 , flSTRmATCH_null , idfTrim , sttqTrim , T("trim|") , psttOld ) ;
            countT idfTrim2 = idf ;
            strokeS sttqTrim2 = sttq ;
            boolT bTrim2 = idf == strIdF( tinP , 0 , flSTRmATCH_null , idfTrim2 , sttqTrim2 , T("trim2|") , psttOld ) ;
            strokeS sttqKt = sttq ;
            countT idfKt = idf ;
            boolT bKt   = idf == strIdF( tinP , 0 , flSTRmATCH_null , idfKt , sttqKt , T("kt|") , psttOld ) ;
            if( bRaw )            
            {
                idf = idfRaw ;
                sttq = sttqRaw ;
                strSubstringF( tinP , psttw , idf , sttq , T("!" "|" "|") , psttOld ) ; ___( psttw ) ;
                ZE( osTextT* , postKid ) ;
                ZE( countT   , costKid ) ;
                IFsCRATCH
                {
                    SCOOPS
                    tinP.pEtScratch->boxGetShadowF( tinP , postKid , costKid , psttw , 1 ) ; ___( postKid );
                    if( POOP )
                    {
                        POOPR
                        ifcSayIF( T("103002f WARNING 1: File \"")+T(psttw)+T("\" does not exist") , flSAY_APPEND | flSAY_LOG ) ;
                        costKid = strMakeF( tinP , LF , postKid , psttw ) ;
                    }
                }
                delF( tinP , psttw ) ;
                ZE( strokeS* , psttKid ) ;
                strMakeF( tinP , LF , psttKid , T(postKid) , costKid * 2 + 0x100 ) ; // 1 EXTRA FOR SYMBOLIC CONSTANTS, 1 EXTRA FOR VISIBLE, 0x100 FOR MISCELLANY
                delF( tinP , postKid ) ;

                // FORMAT AND APPEND THE SPECIFIED FILE
                {
                    ZE( strokeS* , psttv ) ;
                    strFuseF( tinP , psttv , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ psttKid ? psttKid->idAdam * 2 : 0 ) ; ___( psttv ) ;
                    ZE( boolT , bFound ) ;
                    countT idf = 1 ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    while( idf && !POOP )
                    {
                        ZE( strokeS* , psttl ) ;
                        strSubstringF( tinP , psttl , idf , sttq , T("\r\n") , psttKid ) ; ___( psttl ) ;
                        if( psttl )
                        {
                            if( !bFound ) bFound = 1 ;
                            strFuseF( tinP , psttv , T("@" "." " ")+T(psttl)+T("\r\n") ) ; ___( psttv ) ; // ASSUME: NO SOURCE LINES WILL EVER CONTAIN WITH "@" "|" " "
                            delF( tinP , psttl ) ;
                        }
                    }
                    strReplaceF( tinP , psttv , 0 , T("/" "*" "*" "/") , T("/" "@" "@" "/") ) ; ___( psttv ) ; // ASSUME: NO SOURCE LINES WILL EVER CONTAIN "/" "@" "@" "/"
                    strReplaceF( tinP , psttv , 0 , T("/" "/" "|" "|") , T("/" "/" "%" "%") ) ; ___( psttv ) ; // ASSUME: NO SOURCE LINES WILL EVER CONTAIN "/" "/" "%" "%"
                    delF( tinP , psttKid ) ;
                    strMakeF( tinP , LF , psttKid , psttv ) ; ___( psttKid ) ;
                    delF( tinP , psttv ) ;
                }

                strReverseF( tinP , psttKid , 0 , T("\r\n") ) ; ___( psttKid ) ;
                strReplaceF( tinP , psttKid , 0 , T("/" "@" "@" "/") , T("/" "*" "*" "/") ) ; ___( psttKid ) ;
                strReplaceF( tinP , psttKid , 0 , T("@" "." " ") , T(" . ") ) ; ___( psttKid ) ;
                strFuseF( tinP , psttP , psttKid ) ; ___( psttP ) ;

                delF( tinP , psttKid ) ;
            }
            else if( bTrim || bKt )            
            {
                if( bKt ) idf = idfKt ;
                else      idf = idfTrim ;
                if( bKt ) sttq = sttqKt ;
                else      sttq = sttqTrim ;
                strSubstringF( tinP , psttw , idf , sttq , T("!" "|" "|") , psttOld ) ; ___( psttw ) ;
                ZE( osTextT* , postKid ) ;
                ZE( countT   , costKid ) ;
                IFsCRATCH
                {
                    SCOOPS
                    tinP.pEtScratch->boxGetShadowF( tinP , postKid , costKid , psttw , 1 ) ; ___( postKid );
                    if( POOP )
                    {
                        POOPR
                        ifcSayIF( T("103002f WARNING 1: File \"")+T(psttw)+T("\" does not exist") , flSAY_APPEND | flSAY_LOG ) ;
                        costKid = strMakeF( tinP , LF , postKid , psttw ) ;
                    }
                }
                delF( tinP , psttw ) ;
                ZE( strokeS* , psttKid ) ;
                strMakeF( tinP , LF , psttKid , T(postKid) , costKid * 2 + 0x100 ) ; // 1 EXTRA FOR SYMBOLIC CONSTANTS, 1 EXTRA FOR VISIBLE, 0x100 FOR MISCELLANY
                delF( tinP , postKid ) ;

                // IF A LISTS OF SYMBOLIC CONSTANTS IS FOUND, FORMAT AND APPEND THEM
                {
                    countT idf = 1 ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    while( idf && !POOP )
                    {
                        ZE( countT , idClass ) ;
                        ZE( strokeS* , psttSet ) ;
                        strSubstringDelimitedF( tinP , psttSet , idClass , idf , sttq , psttKid ) ; ___( psttSet ) ;
                        if( psttSet && idClass == 3 )
                        {
                            countT idfs = 1 ;
                            strokeS sttqs( (countT)0 , sc_IGNOREqUOTES ) ;
                            while( idfs && !POOP )
                            {
                                ZE( strokeS* , psttl ) ;
                                strSubstringF( tinP , psttl , idfs , sttqs , T("\r\n") , psttSet ) ; ___( psttl ) ;
                                if( psttl )
                                {
                                    if( psttl->idAdam )
                                    {
                                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                        ZE( strokeS* , psttw ) ;
                                        strWordF( tinP , psttw , psttl , sttq , S1C(' ') , 2 ) ; ___( psttw ) ;
                                        strFuseF( tinP , psttKid , T("\r\n")+T(psttw) ) ;
                                        delF( tinP , psttw ) ;
                                    }
                                    delF( tinP , psttl ) ;
                                }
                            }
                        }
                        delF( tinP , psttSet ) ;
                        idClass = 0 ;
                    }
                }

                // IF THIS FILE IS TO BE VISIBLE, AND THERE EXISTS A DEFINITION LINK, FORMAT AND INSERT IT
                ZE( countT , idtVisible ) ; //"idt" = "ID TAG"
                {
                    countT idf = 1 ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    idtVisible = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , T("\r\n//VISIBLE\r\n") , psttKid ) ;
                }

                ZE( countT , idtInsert ) ; //"idt" = "ID TAG"
                if( idtVisible )
                {
                    TN( tLink , "" ) ; tLink = T(".1.0.html\\\"\\>definition\\</A\\>\r\n") ;
                    countT idf = 1 ;
                    idtInsert = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tLink , psttKid ) ;
                    if( idtInsert ) //MOVE CURSOR BACK TO THE BEGINNING OF THE CURRENT LINE
                    {
                        strokeS sLF( '\n' ) ;
                        while( idtInsert )
                        {
                            if( idtInsert == 1 ) idtInsert = 0 ;
                            else if( psttKid[ CSpREFIX - 2 + idtInsert ] == sLF ) break ;
                            else idtInsert -- ;
                        }
                    }
                }

                ZE( boolT , bDebug ) ; //U::
                if( idtInsert )
                {
                    bDebug = 1 ; //U::
                    ZE( strokeS* , psttv ) ;
                    strFuseF( tinP , psttv , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ psttKid ? psttKid->idAdam * 2 : 0 ) ; ___( psttv ) ;
                    ZE( boolT , bFound ) ;
                    countT idf = 1 ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    while( idf && !POOP )
                    {
                        ZE( strokeS* , psttl ) ;
                        strSubstringF( tinP , psttl , idf , sttq , T("\r\n") , psttKid ) ; ___( psttl ) ;
                        if( psttl )
                        {
                            if( !bFound ) bFound = 1 ;
                            strFuseF( tinP , psttv , T("@" "." " ")+T(psttl)+T("\r\n") ) ; ___( psttv ) ; // ASSUME: NO SOURCE LINES WILL EVER CONTAIN WITH "@" "." " "
                            delF( tinP , psttl ) ;
                        }
                    }

                    // COMMENTED OUT BECAUSE THE "definition" LINK IS NOW INSERTED INTO ALL VISIBLE SOURCE BY bf30104/listVisibleDefinitionsFlistVisibleDefinitionsF
                    //THIS WAS ENABLED IN ORDER TO FIX.  THE PRECEDING COMMENT (COMMENTED OUT BECAUSE...) APPEARS TO DOCUMENT A MISTAKE: THE FOLLOWING LINE IS NEEDED
                    //if( bFound ) { strFuseF( tinP , psttv , T("daffynition\r\n") ) ; ___( psttv ) ; }

                    strReplaceF( tinP , psttv , 0 , T("/" "*" "*" "/") , T("/" "@" "@" "/") ) ; ___( psttv ) ; // ASSUME: NO SOURCE LINES WILL EVER CONTAIN "/" "@" "@" "/"
                    strReplaceF( tinP , psttv , 0 , T("/" "/" "|" "|") , T("/" "/" "%" "%") ) ; ___( psttv ) ; // ASSUME: NO SOURCE LINES WILL EVER CONTAIN "/" "/" "%" "%"

                    TN( t1 , "" ) ; t1 = T(psttKid) ; //U::
                    boxPutF( tinP , T("///d/tmpe.1") , t1 , t1.csF( tinP ) ) ; //U::

                    strInsertF( tinP , psttKid , idtInsert , psttv ) ;
                    delF( tinP , psttv ) ;

                    TN( t2  , "" ) ; t2  = T(psttKid) ; //U::
                    boxPutF( tinP , T("///d/tmpe.2")  , t2  , t2.csF( tinP  ) ) ; //U::
                }

                strReverseF( tinP , psttKid , 0 , T("\r\n") ) ; ___( psttKid ) ;
                if( bDebug )
                {
                    TN( t3  , "" ) ; t3  = T(psttKid) ; //U::
                    boxPutF( tinP , T("///d/tmpe.3")  , t3  , t3.csF( tinP  ) ) ; //U::
                }

                strReplaceAutomaticallyF( tinP , psttKid ) ; ___( psttKid ) ;
                if( bDebug )
                {
                    TN( t4  , "" ) ; t4  = T(psttKid) ; //U::
                    boxPutF( tinP , T("///d/tmpe.4")  , t4  , t4.csF( tinP  ) ) ; //U::
                }
                strAbridgeF( tinP , psttKid , 0 , 0 ) ; ___( psttKid ) ;
                if( bDebug )
                {
                    TN( t5  , "" ) ; t5  = T(psttKid) ; //U::
                    boxPutF( tinP , T("///d/tmpe.5")  , t5  , t5.csF( tinP  ) ) ; //U::
                }
                strReplaceF( tinP , psttKid , 0 , T("/" "@" "@" "/") , T("/" "*" "*" "/") ) ; ___( psttKid ) ;
                if( bDebug )
                {
                    TN( t6  , "" ) ; t6  = T(psttKid) ; //U::
                    boxPutF( tinP , T("///d/tmpe.6")  , t6  , t6.csF( tinP  ) ) ; //U::
                }
                if( bKt ) { strTrimF( tinP , psttKid , 0 , T(TbLACKnEWlINE) , T("\t\x1a")              , strokeS() ) ; ___( psttKid ) ; }
                else      { strTrimF( tinP , psttKid , 0 , T(TbLACKnEWlINE) ) ; ___( psttKid ) ; }
                if( bDebug )
                {
                    TN( t7  , "" ) ; t7  = T(psttKid) ; //U::
                    boxPutF( tinP , T("///d/tmpe.7")  , t7  , t7.csF( tinP  ) ) ; //U::
                }
                strRemoveBlankLinesF( tinP , psttKid , 0 , 0 , T("/*") ) ; ___( psttKid ) ; // SUPPRESS THE "/*" AND "*/" LINES THAT DELIMIT THE FILE COMMENTS
                if( bDebug )
                {
                    TN( t8  , "" ) ; t8  = T(psttKid) ; //U::
                    boxPutF( tinP , T("///d/tmpe.8")  , t8  , t8.csF( tinP  ) ) ; //U::
                }
                strIndentOldF( tinP , psttKid , 1 , strokeS() , 0 , 0 ) ; ___( psttKid ) ;
                if( bDebug )
                {
                    TN( t9  , "" ) ; t9  = T(psttKid) ; //U::
                    boxPutF( tinP , T("///d/tmpe.9")  , t9  , t9.csF( tinP  ) ) ; //U::
                }
                strReplaceF( tinP , psttKid , 0 , T("@" "." " ") , T(" . ") ) ; ___( psttKid ) ;
                if( bDebug )
                {
                    TN( ta  , "" ) ; ta  = T(psttKid) ; //U::
                    boxPutF( tinP , T("///d/tmpe.a")  , ta  , ta.csF( tinP  ) ) ; //U::
                }
                strFuseF( tinP , psttP , T(" ") ) ; ___( psttP ) ;
                strFuseF( tinP , psttP , psttKid ) ; ___( psttP ) ;

                if( bDebug )
                {
                    TN( tb  , "" ) ; tb  = T(psttP) ; //U::
                    boxPutF( tinP , T("///d/tmpe.b")  , tb  , tb.csF( tinP  ) ) ; //U::
                }

                if( bKt ){ idfKt   = 1 ; sttqKt   = sttq ; bTagsStillExist |= !!strIdF( tinP , 0 , flSTRmATCH_null , idfKt   , sttqKt   , T("/" "/" "|" "|" "!") , psttKid ) ; }
                else     { idfTrim = 1 ; sttqTrim = sttq ; bTagsStillExist |= !!strIdF( tinP , 0 , flSTRmATCH_null , idfTrim , sttqTrim , T("/" "/" "|" "|" "!") , psttKid ) ; }
                delF( tinP , psttKid ) ;
            }
            else if( bTrim2 )            
            {
                idf = idfTrim2 ;
                sttq = sttqTrim2 ;
                strSubstringF( tinP , psttw , idf , sttq , T("!" "|" "|") , psttOld ) ; ___( psttw ) ;
                ZE( osTextT* , postKid ) ;
                IFsCRATCH
                {
                    SCOOPS
                    ZE( countT   , costKid ) ;
                    tinP.pEtScratch->boxGetShadowF( tinP , postKid , costKid , psttw , 1 ) ; ___( postKid );
                    if( POOP )
                    {
                        POOPR
                        ifcSayIF( T("103002f ERROR: File \"")+T(psttw)+T("\" does not exist") , flSAY_APPEND | flSAY_LOG ) ;
                        costKid = strMakeF( tinP , LF , postKid , psttw ) ;
                    }
                }
                delF( tinP , psttw ) ;
                ZE( strokeS* , psttKid ) ;
                strMakeF( tinP , LF , psttKid , T(postKid) ) ;
                delF( tinP , postKid ) ;
                strReverseF( tinP , psttKid , 0 , T("\r\n") ) ;
                strReplaceAutomaticallyF( tinP , psttKid ) ;
                strAbridgeF( tinP , psttKid , 0 , 0 ) ;

                {
                    ZE( strokeS* , psttw ) ;
                    countT idfChunk = 1 ;
                    strokeS sttqc( (countT)0 , sc_IGNOREqUOTES ) ;

                    strSubstringF( tinP , psttw , idfChunk , sttqc , T("/*") , psttKid ) ;
                    delF( tinP , psttw ) ;

                    strSubstringF( tinP , psttw , idfChunk , sttqc , T("*/") , psttKid ) ;
                    strTrimF( tinP , psttw , 0 , T(TbLACKnEWlINE) , T("\t\x1a") , strokeS() ) ;
                    strIndentOldF( tinP , psttw , 1 , strokeS() , 0 , 0 ) ;
                    strFuseF( tinP , psttP , T(" ") ) ; ___( psttP ) ;
                    strFuseF( tinP , psttP , psttw ) ;
                    strFuseF( tinP , psttP , T("\r\n") ) ; ___( psttP ) ;
                    delF( tinP , psttw ) ;

                    if( idfChunk )
                    {
                        ZE( countT , idlChunk ) ;
                        strSubstringF( tinP , psttw , idfChunk , sttqc , idlChunk , psttKid ) ;
                        strReplaceAnyF( tinP , psttw , 0 , T(" ") , T(" ") ) ;
                        strTrimF( tinP , psttw , 0 , T(TbLACKnEWlINE) ) ;
                        strIndentOldF( tinP , psttw , 1 , strokeS() , 0 , 0 ) ;
                        strFuseF( tinP , psttP , T(" ") ) ; ___( psttP ) ;
                        strFuseF( tinP , psttP , psttw ) ;
                        delF( tinP , psttw ) ;
                    }
                }

                if( !bTagsStillExist ){ idfTrim2 = 1 ; sttqTrim2 = sttq ; bTagsStillExist = !!strIdF( tinP , 0 , flSTRmATCH_null , idfTrim2 , sttqTrim2 , T("/" "/" "|" "|" "!") , psttP ) ; }
                delF( tinP , psttKid ) ;
            }
        }
    }
    __( STOP ) ;

    delF( tinP , psttOld ) ;
    return bTagsStillExist ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002029.etherc.strevaluatef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600202a.etherc.pooldelf BEGIN
#define DDNAME       "3func.3600202a.etherc.pooldelf"
#define DDNUMB      (countT)0x3600202a
#define IDFILE      (countT)0xc56


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$poolDelF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030030.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 pvP
  can be 0
  if 0 then nothing is done
*/
/**/

/*1*/voidT etherC::poolDelF( tinS& tinP , voidT* const pvP )/*1*/
{
    SCOOP
    third.poolDelF( tinP , pvP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600202a.etherc.pooldelf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600202b.etherc.memcomparef BEGIN
#define DDNAME       "3func.3600202b.etherc.memcomparef"
#define DDNUMB      (countT)0x3600202b
#define IDFILE      (countT)0xc57


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$memCompareF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030032.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.a310104.1.1.0.html\"\>a310104:  WAKEsHOW( "example.simplest.func.1030032.etherC.memCompareF" )\</A\>
arguments
 pb1P
 pb2P
 cbP
*/
/**//*1*/sCountT etherC::memCompareF( tinS& tinP , const byteT* const pb1P , const byteT* const pb2P , const countT cbP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    _IO_
    sCountT sgn =third.c_memcmpIF( tinP , pb1P , pb2P , cbP ) ;
    return sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600202b.etherc.memcomparef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600202c.etherc.memcopyf BEGIN
#define DDNAME       "3func.3600202c.etherc.memcopyf"
#define DDNUMB      (countT)0x3600202c
#define IDFILE      (countT)0xc58


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$memCopyF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030033.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.b310104.1.1.0.html\"\>b310104:  WAKEsHOW( "example.simplest.func.1030033.etherC.memCopyF" )\</A\>
arguments
 pbToP
  must point to cbP bytes of memory that this adam can write to
 pbFromP
  must point to cbP bytes of memory that this adam can read from
 cbP
*/
/**/

/*1*/voidT etherC::memCopyF( tinS& tinP , byteT* const pbToP , const byteT* const pbFromP , const countT cbP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.c_memcpyIF( tinP , pbToP , pbFromP , cbP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600202c.etherc.memcopyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600202d.etherc.memopenf BEGIN
#define DDNAME       "3func.3600202d.etherc.memopenf"
#define DDNUMB      (countT)0x3600202d
#define IDFILE      (countT)0xc59


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$memOpenF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030034.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.c310104.1.1.0.html\"\>c310104:  WAKEsHOW( "example.simplest.func.1030034.etherC.memOpenF" )\</A\>
arguments
 pvP
  must be 0
  example 1
   this example allocates 8 bytes
   ZE( byteT* , pba ) ;
   ether.memOpenF( tinP , (voidT*&)pba , 8 ) ;
  example 2
   this example allocates room for 8 countT objects
   ZE( countT* , pca ) ;
   ether.memOpenF( tinP , (voidT*&)pca , 8 * sizeof( countT ) ) ;
  example 3
   this example allocates 8 bytes
   to use this memory, pva must be cast to a type such as byteT* or countT*
   ZE( voidT* , pva ) ;
   ether.memOpenF( tinP , pva , 8 ) ;
 cbP
  must not be 0
  specify the number of bytes desired
   example: 0x1000 * sizeof( countT )
    this example specifies that the memory must be exactly large enough to hold 0x1000 countT objects
*/
/**//*1*/voidT etherC::memOpenF( tinS& tinP , voidT*& pvP , const countT cbP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pvP ) ;
        __Z( cbP ) ;
        if( POOP ) return ;
    }

    _IO_
    thirdC::dosAllocMemIF( tinP , pvP , cbP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600202d.etherc.memopenf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600202e.etherc.memclosef BEGIN
#define DDNAME       "3func.3600202e.etherc.memclosef"
#define DDNUMB      (countT)0x3600202e
#define IDFILE      (countT)0xc5a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$memCloseF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030035.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.d310104.1.1.0.html\"\>d310104:  WAKEsHOW( "example.simplest.func.1030035.etherC.memCloseF" )\</A\>
arguments
 pvP
*/
/**//*1*/voidT etherC::memCloseF( tinS& tinP , voidT*& pvP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    thirdC::dosFreeMemIF( tinP , pvP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600202e.etherc.memclosef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600202f.etherc.memsetf BEGIN
#define DDNAME       "3func.3600202f.etherc.memsetf"
#define DDNUMB      (countT)0x3600202f
#define IDFILE      (countT)0xc5b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$memSetF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030036.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.e310104.1.1.0.html\"\>e310104:  WAKEsHOW( "example.simplest.func.1030036.etherC.memSetF" )\</A\>
arguments
 pbP
 cbP
 valueP
*/
/**/

/*1*/voidT etherC::memSetF( tinS& tinP , byteT* const pbP , const countT cbP , const byteT valueP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.c_memsetIF( tinP , pbP , cbP , valueP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600202f.etherc.memsetf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002030.etherc.reportprocessnamepidf BEGIN
#define DDNAME       "3func.36002030.etherc.reportprocessnamepidf"
#define DDNUMB      (countT)0x36002030
#define IDFILE      (countT)0xc5c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$reportProcessNamePidF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030037.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 psttP
 psttPrefixP
 psttSuffixP
 psttUniqueP
*/
/**//*1*/voidT etherC::reportProcessNamePidF( tinS& tinP , strokeS*& psttP , strokeS*& psttPrefixP , strokeS*& psttSuffixP , strokeS*& psttUniqueP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    ZE( strokeS* , psttRaw ) ;
    {
        ZE( strokeS* , pstte ) ;
        strFromProcessF( tinP , psttRaw , pstte , T("///d/os2/pstat.exe") ) ; ___( psttRaw ) ; //U: ASSUME: OS/2 IS INSTALLED ON DRIVE C AND DIAGNOSTIC OPTIONS HAVE BEEN INSTALLED. ALSO, ASSUMES RUNNING ON OS/2 //U:NT
        delF( tinP , pstte ) ;
    }

    {
        ZE( boolT , fInSection ) ;
        countT idfr = 1 ;
        strokeS sttqr( (countT)0 , sc_IGNOREqUOTES ) ;
        boolT fFirst = 1 ;
        while( !POOP && idfr )
        {
            ZE( strokeS* , psttLine ) ;
            strSubstringF( tinP , psttLine , idfr , sttqr , T("\r\n") , psttRaw ) ; ___( psttLine ) ;
            if( psttLine && !psttLine->idAdam ) ;
            else if( !strCompareF( tinP , psttLine , T("  ID        ID        ID       Name       ID    Priority   Block ID   State") ) ) fInSection = 1 ;
            else if( !strCompareF( tinP , psttLine , T("                    System Semaphore Information"                           ) ) ) fInSection = 0 ;
            else if( fInSection )
            {
                // psttLine IS ETHER A PRIMARY THREAD LINE (PROCESS LINE) OR A SECONDARY THREAD LINE.  AT FIRST, WE''LL ASSUME THAT IT IS A PROCESS LINE.  THEN WE''LL CHECK
                ZE( strokeS* , psttPid ) ;
                ZE( strokeS* , psttPPid ) ;
                ZE( strokeS* , psttSid ) ;
                ZE( strokeS* , psttName ) ;
                ZE( strokeS* , psttTid ) ;
                countT idfl = 1 ;
                strokeS sttql( (countT)0 , sc_IGNOREqUOTES ) ;
                strSubstringF( tinP , psttPid  , idfl , sttql , T(" ") , psttLine , 1 ) ; ___( psttPid ) ;
                delF( tinP , psttPid ) ;
                if( idfl ) { strSubstringF( tinP , psttPid  , idfl , sttql , T(" ") , psttLine , 1 ) ; ___( psttPid ) ; }
                if( idfl ) { strSubstringF( tinP , psttPPid , idfl , sttql , T(" ") , psttLine , 1 ) ; ___( psttPPid ) ; }
                if( idfl ) { strSubstringF( tinP , psttSid  , idfl , sttql , T(" ") , psttLine , 1 ) ; ___( psttSid ) ; }
                if( idfl ) { strSubstringF( tinP , psttName , idfl , sttql , T(" ") , psttLine , 1 ) ; ___( psttName ) ; }
                if( idfl ) { strSubstringF( tinP , psttTid  , idfl , sttql , T(" ") , psttLine , 1 ) ; ___( psttTid ) ; }

                if( psttTid && !strCompareF( tinP , psttTid , T("01") ) )
                {
                    if( fFirst ) fFirst = 0 ;
                    else         { strFuseF( tinP , psttP , T("\r\n") ) ; ___( psttP ) ; }

                    ZE( osTextT* , postName ) ;
                    strMakeF( tinP , LF , postName , psttName ) ; ___( postName ) ;
                    delF( tinP , psttName ) ;
                    ifFileNameC iffn( tinP , third , postName ) ;
                    strFuseF( tinP , psttP , T(iffn)+T("\t")+T(psttPid) ) ; ___( psttP ) ;
                    delF( tinP , postName ) ;
                }

                delF( tinP , psttPid  ) ;
                delF( tinP , psttPPid ) ;
                delF( tinP , psttSid  ) ;
                delF( tinP , psttName ) ;
                delF( tinP , psttTid  ) ;
            }
            delF( tinP , psttLine ) ;
        }
    }
    delF( tinP , psttRaw ) ;

    strConvertToLowerCaseF( tinP , psttP ) ;

    strUniqueF( tinP , psttUniqueP ) ; ___( psttUniqueP ) ;
    strFuseF( tinP , psttUniqueP , T(".report.process.name.pid") ) ; ___( psttUniqueP ) ;
    strMakeF( tinP , LF , psttPrefixP , T("") ) ; ___( psttPrefixP ) ;
    strMakeF( tinP , LF , psttSuffixP , T("") ) ; ___( psttSuffixP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002030.etherc.reportprocessnamepidf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002031.etherc.osenvironmentvariablef BEGIN
#define DDNAME       "3func.36002031.etherc.osenvironmentvariablef"
#define DDNUMB      (countT)0x36002031
#define IDFILE      (countT)0xc5d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osEnvironmentVariableF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030038.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f310104.1.1.0.html\"\>f310104:  WAKEsHOW( "example.simplest.func.1030038.etherC.osEnvironmentVariableF" )\</A\>
arguments
 psttValueP
  must be 0
 psttKeyP
  must not be 0
  must not be a 0 length string
*/
/**/

/*1*/voidT etherC::osEnvironmentVariableF( tinS& tinP , strokeS*& psttValueP , const strokeS* const psttKeyP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttValueP ) ;
        __Z( psttKeyP ) ;
        if( POOP ) return ;
        __( !psttKeyP->idAdam ) ;
        if( POOP ) return ;
    }

    _IO_
    if( !POOP )
    {
        ZE( osTextT* , postKey ) ;
        ZE( osTextT* , postValue ) ;
        strMakeF( tinP , LF , postKey , psttKeyP ) ; ___( postKey ) ;
        third.dosScanEnvF( tinP , postValue , postKey ) ; ___( postValue ) ;
        if( postValue )
        {
            strMakeF( tinP , LF , psttValueP , T(postValue) ) ; ___( psttValueP ) ;
            delF( tinP , postValue ) ;
        }
        delF( tinP , postKey ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002031.etherc.osenvironmentvariablef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002032.etherc.osprocessidf BEGIN
#define DDNAME       "3func.36002032.etherc.osprocessidf"
#define DDNUMB      (countT)0x36002032
#define IDFILE      (countT)0xc5e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osProcessIdF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030039.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.0410104.1.1.0.html\"\>0410104:  WAKEsHOW( "example.simplest.func.1030039.etherC.osProcessIdF" )\</A\>
evaluates to the identifier that the local operating system uses to identify the adam
*/
/**/

/*1*/countT etherC::osProcessIdF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    _IO_
    countT idProcessOldI = dosGetInfoBlocksIdProcessIF( tinP ) ;
    return idProcessOldI ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002032.etherc.osprocessidf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002033.etherc.osthreadidf BEGIN
#define DDNAME       "3func.36002033.etherc.osthreadidf"
#define DDNUMB      (countT)0x36002033
#define IDFILE      (countT)0xc5f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osThreadIdF.0.html\"\>instances\</A\>
\<A HREF=\"5.103003a.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1410104.1.1.0.html\"\>1410104:  WAKEsHOW( "example.simplest.func.103003a.etherC.osThreadIdF" )\</A\>
*/
/**/

/*1*/countT etherC::osThreadIdF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    _IO_
    countT idThread = dosGetInfoBlocksIdThreadIF() ;
    return idThread ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002033.etherc.osthreadidf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002034.etherc.strabridgef BEGIN
#define DDNAME       "3func.36002034.etherc.strabridgef"
#define DDNUMB      (countT)0x36002034
#define IDFILE      (countT)0xc60


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strAbridgeF.0.html\"\>instances\</A\>
\<A HREF=\"5.103003c.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.b810104.1.1.0.html\"\>b810104:  WAKEsHOW( "example.simplest.func.103003c.etherC.strAbridgeF" )\</A\>
arguments
 psttP
 psttOldP
 psttDelimiterP
*/
/**//*1*/voidT etherC::strAbridgeF( tinS& tinP , strokeS*& psttP , const strokeS* const psttOldP , const strokeS* const psttDelimiterP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    ZE( strokeS* , psttDelimiter ) ;
    ZE( strokeS* , psttOld ) ;
    if( psttDelimiterP ) { strFuseF( tinP , psttDelimiter , psttDelimiterP ) ; ___( psttDelimiter ) ; }
    else                 { strMakeF( tinP , LF , psttDelimiter , T("/*" "*/")   ) ; ___( psttDelimiter ) ; }
    if( psttOldP ) { strFuseF( tinP , psttOld , psttOldP ) ; ___( psttOld ) ; }
    else
    {
        strFuseF( tinP , psttOld , psttP ) ; ___( psttOld ) ;
        delF( tinP , psttP ) ;
    }
    __NZ( psttP ) ;
    __Z( psttOld ) ;
    __Z( psttDelimiter ) ;
    if( POOP ) return ;

    _IO_
    boolT fYes = 1 ;
    countT idf = 1 ;
    boolT bWoth = 1 ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , psttw ) ;
    while( !POOP && idf )
    {
        strSubstringF( tinP , psttw , idf , sttq , psttDelimiter , psttOld , 0 ) ; ___( psttw ) ;
        if( psttw )
        {
            if( fYes )
            {
                strFuseF( tinP , psttP , psttw , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ psttOld->idAdam ) ; ___( psttP ) ;
                if( bWoth )
                {
                    bWoth = 0 ;
                }
            }
            delF( tinP , psttw ) ;
            fYes = !fYes ;
        }
        else break ;
    }

    delF( tinP , psttDelimiter ) ;
    delF( tinP , psttOld ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002034.etherc.strabridgef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002035.etherc.strresizef BEGIN
#define DDNAME       "3func.36002035.etherc.strresizef"
#define DDNUMB      (countT)0x36002035
#define IDFILE      (countT)0xc61


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strResizeF.0.html\"\>instances\</A\>
\<A HREF=\"5.103003d.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.c810104.1.1.0.html\"\>c810104:  WAKEsHOW( "example.simplest.func.103003d.etherC.strResizeF" )\</A\>
adds or removes pad strokes at one end of psttP
arguments
 psttP
  can be 0
 csP
  if > 0 then pads to this length
   the string will be truncated if it is longer than csP
  if -1 then trims all trailing (or leading if fLeadingP) occurances of sttP
  if 0 then psttP is trimmed to 0 length
  must not be less than - 1 when converted to an sCountT
 sttP
 fLeadingP
 csttExtraP
  is normally 0
*/
/**/

/*1*/voidT etherC::strResizeF( tinS& tinP , strokeS*& psttP , const countT csP , strokeS sttP , const boolT fLeadingP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( (sCountT)csP < - 1 ) ;
        if( POOP ) return ;
    }

    _IO_
    strokeS* psttd = psttP ;
    psttP = 0 ;
    if( !(countT)sttP ) sttP = S1C(' ') ;
    if( !psttd && csP ) { strMakeF( tinP , LF , psttP , T("") , csP + csttExtraP ) ; ___( psttP ) ; }
    countT csttd = psttd ? psttd->idAdam : 0 ;

    if( !csP ) strMakeF( tinP , LF , psttP , T("") , csttExtraP ) ;
    else if( csP == - 1 )
    {
        if( csttd )
        {
            // TRIMS AWAY sttP''S
            countT idf = 1 ;
            countT idl = csttd ;
            if( fLeadingP ) while( idf <= csttd && psttd[ CSpREFIX - 1 + idf ] == sttP ) idf ++ ;
            else            while( idl          && psttd[ CSpREFIX - 1 + idl ] == sttP ) idl -- ;
            if( idf <= idl ) strSubstringF( tinP , psttP , idf , idl , psttd , csttExtraP ) ;
            else             strMakeF( tinP , LF , psttP , T("") , csttExtraP ) ;
        }
    }
    else if( csP > 0 ) // PADS WITH sttP''S
    {
        sCountT csPad = csP - csttd ;
        if( csPad < 0 )
        {
            countT idf = 1 ;
            countT idl = csP ;
            strSubstringF( tinP , psttP , idf , idl , psttd , csttExtraP ) ;
        }
        else
        {
            if( psttd       ) strMakeF( tinP , LF , psttP , psttd , csPad + csttExtraP ) ;
            while( csPad -- ) strFuseF( tinP , psttP , sttP  , 0 , fLeadingP ) ;
        }
    }
    delF( tinP , psttd ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002035.etherc.strresizef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002036.etherc.strfromtimef BEGIN
#define DDNAME       "3func.36002036.etherc.strfromtimef"
#define DDNUMB      (countT)0x36002036
#define IDFILE      (countT)0xc62


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFromTimeF.0.html\"\>instances\</A\>
\<A HREF=\"5.103003e.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.d810104.1.1.0.html\"\>d810104:  WAKEsHOW( "example.simplest.func.103003e.etherC.strFromTimeF" )\</A\>
arguments
 psttP
 time1P
 time2P
 idWothP
  can be 0
  meaning depends upon format
 idLathP
  can be 0
  meaning depends upon format
 sttRadixP
 idFormatP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00103e9.ifcIDfORMATtIME!||
 flagsFormatP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001004c.flFORMAT!||
 some of these flags are ignored
*/
/**/

/*1*/voidT etherC::strFromTimeF( tinS& tinP , strokeS*& psttP , countT time1P , sCountT time2P , const countT idWothP , const countT idLathP , const strokeS sttRadixP , const strokeS* const psttDelimiterP , const countT idFormatP , const flagsT flagsFormatP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        FV(flFORMAT,flagsFormatP) ;
        if( POOP ) return ;
    }

    _IO_

    switch( idFormatP )
    {
        case ifcIDfORMATtIME_TEXT :
        {
            TIMEpARTSoFF( Foo , time1P , time2P )

            static osTextT* ppostBigit[] =
            {
                "ze" ,
                "wo" ,
                "oo" ,
                "re" ,
                "fo" ,
                "fi" ,
                "se" ,
                "ve" ,
                "ta" ,
                "ni" ,
                "ay" ,
                "be" ,
                "ce" ,
                "de" ,
                "ee" ,
                "fu" ,
            } ;

            const countT idWoth = idWothP ? idWothP : 1 ;
            const countT idLath  = idLathP  ? idLathP  : 0x14 ;

            TN( tDelimiter , " " ) ; if( psttDelimiterP ) tDelimiter = T(psttDelimiterP) ;
            strMakeF( tinP , LF , psttP , T("") , TUCK ) ; // CALLER MUST TAG
            switch( idWoth )
            {
                case 0x01 : { strFuseF( tinP , psttP , T(ppostBigit[offFooTime      ])+T("'tm" ) ) ; if( idLath == 0x01 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x02 : { strFuseF( tinP , psttP , T(ppostBigit[offFooGrain     ])+T("'gr" ) ) ; if( idLath == 0x02 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x03 : { strFuseF( tinP , psttP , T(ppostBigit[offFooTuck      ])+T("'tu" ) ) ; if( idLath == 0x03 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x04 : { strFuseF( tinP , psttP , T(ppostBigit[offFooSecond    ])+T("'sc" ) ) ; if( idLath == 0x04 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x05 : { strFuseF( tinP , psttP , T(ppostBigit[offFooTock      ])+T("'to" ) ) ; if( idLath == 0x05 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x06 : { strFuseF( tinP , psttP , T(ppostBigit[offFooMinute    ])+T("'mi" ) ) ; if( idLath == 0x06 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x07 : { strFuseF( tinP , psttP , T(ppostBigit[offFooTick      ])+T("'ti" ) ) ; if( idLath == 0x07 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x08 : { strFuseF( tinP , psttP , T(ppostBigit[offFooHour      ])+T("'ho" ) ) ; if( idLath == 0x08 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x09 : { strFuseF( tinP , psttP , T(ppostBigit[offFooDay       ])+T("'da" ) ) ; if( idLath == 0x09 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x0a : { strFuseF( tinP , psttP , T(ppostBigit[offFooStrong    ])+T("'str") ) ; if( idLath == 0x0a ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x0b :
                {
                    strFuseF( tinP , psttP , T(ppostBigit[offFooQtr])+T("'qu" ) ) ;

                    if( F(flagsFormatP) & flFORMAT_TIMEqUARTERnAME )
                    {
                        osTextT* postName[] =
                        {
                            "(the fallow)"  ,
                            "(the sowing)"  ,
                            "(the tending)" ,
                            "(the reaping)"
                        }
                        ;

                        strFuseF( tinP , psttP , tDelimiter+T(postName[offFooQtr]) ) ;
                    }

                    if( idLath == 0x0b ) break ;
                    strFuseF( tinP , psttP , tDelimiter ) ;
                }
                case 0x0c : { strFuseF( tinP , psttP , T(ppostBigit[offFooDuck      ])+T("'du" ) ) ; if( idLath == 0x0c ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x0d : { strFuseF( tinP , psttP , T(ppostBigit[offFooDuckStrong])+T("'dus") ) ; if( idLath == 0x0d ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x0e : { strFuseF( tinP , psttP , T(ppostBigit[offFooDuckQtr   ])+T("'duq") ) ; if( idLath == 0x0e ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x0f : { strFuseF( tinP , psttP , T(ppostBigit[offFooDock      ])+T("'do" ) ) ; if( idLath == 0x0f ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x10 : { strFuseF( tinP , psttP , T(ppostBigit[offFooDockStrong])+T("'dos") ) ; if( idLath == 0x10 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x11 : { strFuseF( tinP , psttP , T(ppostBigit[offFooDockQtr   ])+T("'doq") ) ; if( idLath == 0x11 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x12 : { strFuseF( tinP , psttP , T(ppostBigit[offFooDick      ])+T("'di" ) ) ; if( idLath == 0x12 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x13 : { strFuseF( tinP , psttP , T(ppostBigit[offFooDickStrong])+T("'dis") ) ; if( idLath == 0x13 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
                case 0x14 : { strFuseF( tinP , psttP , T(ppostBigit[offFooDickQtr   ])+T("'diq") ) ; if( idLath == 0x14 ) break ; strFuseF( tinP , psttP , tDelimiter ) ; }
            }

            break ;
        }
        case ifcIDfORMATtIME_NUMERIC :
        {
            strMakeF( tinP , LF , psttP , T("") , 0x18 ) ; // CALLER MUST TAG. MUST ALLOW FOR MINUS SIGN
        
            countT  time1 = time1P ;
            sCountT time2 = time2P ;
            ZE( countT , dime ) ;
        
            ZE( boolT , bNeg ) ;
            if( time2 >= 0 ) dime = time2 ;
            else
            {
                bNeg = 1 ;
                dime = - time2 ;
            }
        
            ZE( strokeS* , psttw ) ;
        
            countT time = time1 ;
            countT tuck = time / 0x100 ;
            time %= 0x100 ;
            countT tock = tuck / 0x100 ;
            tuck %= 0x100 ;
            countT tick = tock / 0x100 ;
            tock %= 0x100 ;
        
            countT dick = dime / ( 0x100 * 0x100 * 0x100 ) ;
            dime %= 0x100 * 0x100 * 0x100 ;
            countT dock = dime / ( 0x100 * 0x100 ) ;
            dime %= 0x100 * 0x100 ;
            countT duck = dime / 0x100 ;
            dime %= 0x100 ;
        
            const countT idWoth = idWothP ? idWothP : 1 ;
            const countT idLath  = idLathP  ? idLathP  : 8 ;
            
            if( F(flagsFormatP) & flFORMAT_FOREIGN ) //DEPRECATED EXCEPT WHERE CONVENIENT FOR SORTING (E.G. WITHIN FILE NAMES)
            {
                if( bNeg ) strFuseF( tinP , psttP , T("-") ) ;

                flagsT flagsFormat = flFORMAT_NObIGITvALUES | flFORMAT_UNSIGNED | flFORMAT_FILLzE | flFORMAT_FOREIGN ;
                switch( idLath )
                {
                    case 8 : { strFuseF( tinP , psttP , TF3(dick,flagsFormat,2) ) ; if( idWoth == 8 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 7 : { strFuseF( tinP , psttP , TF3(dock,flagsFormat,2) ) ; if( idWoth == 7 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 6 : { strFuseF( tinP , psttP , TF3(duck,flagsFormat,2) ) ; if( idWoth == 6 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 5 : { strFuseF( tinP , psttP , TF3(dime,flagsFormat,2) ) ; if( idWoth == 5 ) break ; if( (countT)sttRadixP      ) strFuseF( tinP , psttP , sttRadixP     ) ; }
                    case 4 : { strFuseF( tinP , psttP , TF3(tick,flagsFormat,2) ) ; if( idWoth == 4 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 3 : { strFuseF( tinP , psttP , TF3(tock,flagsFormat,2) ) ; if( idWoth == 3 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 2 : { strFuseF( tinP , psttP , TF3(tuck,flagsFormat,2) ) ; if( idWoth == 2 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 1 : { strFuseF( tinP , psttP , TF3(time,flagsFormat,2) ) ; }
                }
            
                ___( psttP ) ;
            }
            else
            {
                flagsT flagsFormat = flFORMAT_NObIGITvALUES | flFORMAT_UNSIGNED | flFORMAT_FILLzE ;
                switch( idWoth )
                {
                    case 1 : { strFuseF( tinP , psttP , TF3(time,flagsFormat,2) ) ; if( idLath == 1 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 2 : { strFuseF( tinP , psttP , TF3(tuck,flagsFormat,2) ) ; if( idLath == 2 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 3 : { strFuseF( tinP , psttP , TF3(tock,flagsFormat,2) ) ; if( idLath == 3 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 4 : { strFuseF( tinP , psttP , TF3(tick,flagsFormat,2) ) ; if( idLath == 4 ) break ; if( (countT)sttRadixP      ) strFuseF( tinP , psttP , sttRadixP     ) ; }
                    case 5 : { strFuseF( tinP , psttP , TF3(dime,flagsFormat,2) ) ; if( idLath == 5 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 6 : { strFuseF( tinP , psttP , TF3(duck,flagsFormat,2) ) ; if( idLath == 6 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 7 : { strFuseF( tinP , psttP , TF3(dock,flagsFormat,2) ) ; if( idLath == 7 ) break ; if( psttDelimiterP ) strFuseF( tinP , psttP , psttDelimiterP ) ; }
                    case 8 : { strFuseF( tinP , psttP , TF3(dick,flagsFormat,2) ) ; }
                }
            
                if( bNeg ) strFuseF( tinP , psttP , T("-") ) ;
                ___( psttP ) ;
            }

            break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002036.etherc.strfromtimef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600203c.etherc.sockf BEGIN
#define DDNAME       "3func.3600203c.etherc.sockf"
#define DDNUMB      (countT)0x3600203c
#define IDFILE      (countT)0xc63


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030044.1.0.html\"\>definition\</A\>
creates a new socket on the local host
evaluates to the handle of the new socket
*/
/**/

/*1*/voidT etherC::sockF( tinS& tinP , handleC& handleP , const boolT idTypeP , const handleC* const phContextP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.s_socketIF( tinP , handleP , idTypeP , phContextP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600203c.etherc.sockf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600203d.etherc.sockbindf BEGIN
#define DDNAME       "3func.3600203d.etherc.sockbindf"
#define DDNUMB      (countT)0x3600203d
#define IDFILE      (countT)0xc64


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockBindF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030046.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9610104.1.1.0.html\"\>9610104:  WAKEsHOW( "example.simplest.func.1030046.etherC.sockBindF" )\</A\>
arguments
 handleP
  must not be 0
 idPortP
  can be 0, in which case an idPort will be assigned
 nicNameP
  can be 0, in which case an nicName assignment to this socket might be deferred until someone connects to it
   if the host has more than one LAN adapter card, the nicName assignment might be deferred
*/
/**/

/*1*/countT etherC::sockBindF( tinS& tinP , const handleC& handleP , const countT idPortP , const nicNameC nicNameP , const countT cTriesP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( handleP ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    countT idPortActual = third.s_bindF( tinP , handleP , idPortP , nicNameP , cTriesP ) ;
    return idPortActual ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600203d.etherc.sockbindf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600203e.etherc.sockcancelf BEGIN
#define DDNAME       "3func.3600203e.etherc.sockcancelf"
#define DDNUMB      (countT)0x3600203e
#define IDFILE      (countT)0xc65


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockCancelF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030047.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.5710104.1.1.0.html\"\>5710104:  WAKEsHOW( "example.simplest.func.1030047.etherC.sockCancelF" )\</A\>
arguments
 handleP
  must not be 0
*/
/**//*1*/voidT etherC::sockCancelF( tinS& tinP , const handleC& handleP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_cancelF( tinP , handleP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600203e.etherc.sockcancelf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600203f.etherc.sockconnectf BEGIN
#define DDNAME       "3func.3600203f.etherc.sockconnectf"
#define DDNUMB      (countT)0x3600203f
#define IDFILE      (countT)0xc66


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockConnectF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030049.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.b610104.1.1.0.html\"\>b610104:  WAKEsHOW( "example.simplest.func.1030049.etherC.sockConnectF" )\</A\>
arguments
 tinP
 handleP
  must not be 0
 idPortP
  must not be 0
 nicNameP
  can be 0
  if 0 then the local host is implied
 cTriesP
 time1P
 time2P
*/
/**/

/*1*/voidT etherC::sockConnectF( tinS& tinP , handleC& handleP , const countT idPortP , const nicNameC nicNameP , countT cTriesP , const countT time1P , const sCountT time2P )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        __Z( idPortP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_connectF( tinP , handleP , idPortP , nicNameP , cTriesP , time1P , time2P ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600203f.etherc.sockconnectf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002040.etherc.socknicnamef BEGIN
#define DDNAME       "3func.36002040.etherc.socknicnamef"
#define DDNUMB      (countT)0x36002040
#define IDFILE      (countT)0xc67


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockNicNameF.0.html\"\>instances\</A\>
\<A HREF=\"5.103004a.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.2710104.1.1.0.html\"\>2710104:  WAKEsHOW( "example.simplest.func.103004a.etherC.sockNicNameF" )\</A\>
will only work if connected to the Internet (this might no longer be true)
evaluates to the host id of the specified domain name
impotence will not occur if the domain name server replies "not found"
caller must verify that my return value is not ze before using it
arguments
 psttP
  can be 0, in which case the id of the local host is returned
*/
/**/

/*1*/nicNameC etherC::sockNicNameF( tinS& tinP , const strokeS* psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __( psttP && !psttP->idAdam ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    nicNameC nicName ;
    //ZE( countT , idDisk ) ;
    //ZE( boolT  , bNormal ) ;

    // THIS COMMENTED OUT CODE CAN BE ENABLED IF DEVELOPING ON LAN THAT CANNOT SEE THE INTERNET
    // IT IS OLD CODE; IT MIGHT NEED TO BE EDITED; IT ASSUMES THAT THE IP ADDRESSES ON THE LAN ARE LIKE "1.1.1.2" ETC
    //if( psttP && !strCompareF( tinP , psttP , T(WWWiDEAFARMcOM) ) ) //U: ELIMINATE THIS
    //{
    //    ZE( strokeS* , psttv ) ;
    //    osEnvironmentVariableF( tinP , psttv , T("ifcNicNameCityCenter") ) ; ___( psttv ) ;
    //         if( psttv && !strCompareF( tinP , psttv , T("me" ) ) )                                                    nicName = third.s_nicNameF( tinP ) ;
    //    else if( psttv && !strCompareF( tinP , psttv , T("lan") ) )                                                    nicName = NICnAMEcITYcENTERlAN ;
    //    else if( ( idDisk = diskIdF( tinP , T("///c") ) , idDisk == IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 || idDisk == F ) ) nicName = NICnAMEcITYcENTERlAN ;
    //    else bNormal = 1 ;
    //    delF( tinP , psttv ) ;
    //}
    //else bNormal = 1 ;

    //if( bNormal )
    //{
        ZE( osTextT* , post ) ;
        if( psttP ) { strMakeF( tinP , LF , post , psttP ) ; ___( post ) ; }
        nicName = third.s_nicNameF( tinP , post ) ;
        third.delF( tinP , post ) ;
    //}
    return nicName ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002040.etherc.socknicnamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002041.etherc.socklistenf BEGIN
#define DDNAME       "3func.36002041.etherc.socklistenf"
#define DDNUMB      (countT)0x36002041
#define IDFILE      (countT)0xc68


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockListenF.0.html\"\>instances\</A\>
\<A HREF=\"5.103004b.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6710104.1.1.0.html\"\>6710104:  WAKEsHOW( "example.simplest.func.103004b.etherC.sockListenF" )\</A\>
arguments
 handleP
  must not be 0
*/
/**/

/*1*/voidT etherC::sockListenF( tinS& tinP , const handleC& handleP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_listenF( tinP , handleP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002041.etherc.socklistenf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002042.etherc.sockoptionlingerf BEGIN
#define DDNAME       "3func.36002042.etherc.sockoptionlingerf"
#define DDNUMB      (countT)0x36002042
#define IDFILE      (countT)0xc69


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockOptionLingerF.0.html\"\>instances\</A\>
\<A HREF=\"5.103004c.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.0710104.1.1.0.html\"\>0710104:  WAKEsHOW( "example.simplest.func.103004c.etherC.sockOptionLingerF" )\</A\>
arguments
 handleP
  must not be 0
*/
/**/

/*1*/voidT etherC::sockOptionLingerF( tinS& tinP , const handleC& handleP , const countT cSecondsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_optionLingerF( tinP , handleP , cSecondsP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002042.etherc.sockoptionlingerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002043.etherc.sockpeekf BEGIN
#define DDNAME       "3func.36002043.etherc.sockpeekf"
#define DDNUMB      (countT)0x36002043
#define IDFILE      (countT)0xc6a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockPeekF.0.html\"\>instances\</A\>
\<A HREF=\"5.103004d.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1710104.1.1.0.html\"\>1710104:  WAKEsHOW( "example.simplest.func.103004d.etherC.sockPeekF" )\</A\>
arguments
 handleP
  must not be 0
 pbP
  must not be 0
 cbP
  must not be 0
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001000f.flSOCKETc!||
*/
/**/

/*1*/countT etherC::sockPeekF( tinS& tinP , handleC& handleP , byteT* pbP , const countT cbP , const flagsT flagsP , const countT time1P , const sCountT time2P , const countT idModeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( handleP ) ;
        __Z( pbP ) ;
        __Z( cbP ) ;
        FV( flSOCKETcrEAD , flagsP ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    countT cRead = third.s_peekF( tinP , pbP , cbP , handleP , flagsP , time1P , time2P , idModeP ) ;
    return cRead ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002043.etherc.sockpeekf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002044.etherc.sockreadf BEGIN
#define DDNAME       "3func.36002044.etherc.sockreadf"
#define DDNUMB      (countT)0x36002044
#define IDFILE      (countT)0xc6b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockReadF.0.html\"\>instances\</A\>
\<A HREF=\"5.103004e.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.d610104.1.1.0.html\"\>d610104:  WAKEsHOW( "example.simplest.func.103004e.etherC.sockReadF" )\</A\>
evaluates to the number of bytes actually read
arguments
 handleP
  must not be 0
 pbP
  must not be 0
 cbP
  must not be 0
 flagsP
*/
/**/

/*1*/countT etherC::sockReadF( tinS& tinP , handleC& handleP , byteT* const pbP , const countT cbP , const flagsT flagsP , const countT time1P , const sCountT time2P , const countT idModeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( handleP ) ;
        __Z( pbP ) ;
        __Z( cbP ) ;
        FV( flSOCKETcrEAD , flagsP ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    countT cRead = third.s_readF( tinP , pbP , cbP , handleP , flagsP , time1P , time2P , idModeP ) ;
    return cRead ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002044.etherc.sockreadf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002045.etherc.socksshutdownf BEGIN
#define DDNAME       "3func.36002045.etherc.socksshutdownf"
#define DDNUMB      (countT)0x36002045
#define IDFILE      (countT)0xc6c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$socksShutdownF.0.html\"\>instances\</A\>
\<A HREF=\"5.103004f.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f610104.1.1.0.html\"\>f610104:  WAKEsHOW( "example.simplest.func.103004f.etherC.socksShutdownF" )\</A\>
*/
/**//*1*/voidT etherC::socksShutdownF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.s_shutdown1IF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002045.etherc.socksshutdownf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002046.etherc.sockssetupf BEGIN
#define DDNAME       "3func.36002046.etherc.sockssetupf"
#define DDNUMB      (countT)0x36002046
#define IDFILE      (countT)0xc6d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$socksSetupF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030050.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.e610104.1.1.0.html\"\>e610104:  WAKEsHOW( "example.simplest.func.1030050.etherC.socksSetupF" )\</A\>
*/
/**//*1*/voidT etherC::socksSetupF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.s_setupIF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002046.etherc.sockssetupf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002047.etherc.sockwritef BEGIN
#define DDNAME       "3func.36002047.etherc.sockwritef"
#define DDNUMB      (countT)0x36002047
#define IDFILE      (countT)0xc6e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockWriteF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030051.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.c610104.1.1.0.html\"\>c610104:  WAKEsHOW( "example.simplest.func.1030051.etherC.sockWriteF" )\</A\>
arguments
 handleP
  must not be 0
 pbP
  must not be 0
 cbP
  if 0 then pbP must be a null terminated string of bytes, which will be written
  the terminating null (0) will -not- be written
*/
/**/

/*1*/voidT etherC::sockWriteF( tinS& tinP , handleC& handleP , const byteT* pbP , const countT cbP , const countT idModeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        __Z( pbP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_writeF( tinP , handleP , pbP , cbP , idModeP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002047.etherc.sockwritef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002048.etherc.strfendf BEGIN
#define DDNAME       "3func.36002048.etherc.strfendf"
#define DDNUMB      (countT)0x36002048
#define IDFILE      (countT)0xc6f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFEndF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030052.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 psttP
 cnP
*/
/**//*1*/boolT etherC::strFEndF( tinS& tinP , const strokeS* const psttP , const countT cnP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttP ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_
    countT cnBingo = cnP + 1 ;_WQ
    ZE( countT , off ) ;_WQ
    ZE( boolT , bEnd ) ;_WQ
    while( !bEnd && !(countT)psttP[ off ] && off <= cnP )
    {
        if( ++ off > cnP ) bEnd = 1 ;_WQ
    }
    return bEnd ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002048.etherc.strfendf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002049.etherc.strfendf BEGIN
#define DDNAME       "3func.36002049.etherc.strfendf"
#define DDNUMB      (countT)0x36002049
#define IDFILE      (countT)0xc70


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFEndF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030053.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 postP
 cnP
*/
/**/

/*1*/boolT etherC::strFEndF( tinS& tinP , const osTextT* const postP , const countT cnP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    //INOUT NOT USED, TO AVOID BLOWING STACK DURING INOUT TRACE
    //_IO_

    countT cnBingo = cnP + 1 ;_WQ
    ZE( countT , off ) ;_WQ
    ZE( boolT , bEnd ) ;_WQ
    while( !bEnd && !postP[ off ] && off <= cnP )
    {
        if( ++ off > cnP ) bEnd = 1 ;_WQ
    }
    return bEnd ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002049.etherc.strfendf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600204a.etherc.strcomparef BEGIN
#define DDNAME       "3func.3600204a.etherc.strcomparef"
#define DDNUMB      (countT)0x3600204a
#define IDFILE      (countT)0xc71


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strCompareF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030054.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.e810104.1.1.0.html\"\>e810104:  WAKEsHOW( "example.simplest.func.1030054.etherC.strCompareF" )\</A\>
evaluates to a positive number iff pstt1P is "greater than" pstt2P
 evaluates to the difference within the first pair of distinct strokes
 if one of the strings is exhausted without finding a difference, evaluates to the difference in length of the two strings
only idAdam is inspected; the other members of strokeS are ignored
 in general, the returned value is meaningful only if the strokes are pairwise of the same caste
arguments
 pstt1P
 pstt2P
 ccMaxP
*/
/**/

/*1*/sCountT etherC::strCompareF( tinS& tinP , const strokeS* const pstt1P , const strokeS* const pstt2P , const countT csMaxP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( pstt1P ) ;_WQ
        __Z( pstt2P ) ;_WQ
        if( POOP ) return 0 ;

        if( pstt1P->idCaste - sc_PREFIXlENGTH )
        {
            //tinP.pc Utility[ 0x9 ] = (countT)pstt1P ;
            //tinP.pc Utility[ 0xa ] = pstt1P[ 0 ].idAdam ;
            //tinP.pc Utility[ 0xb ] = pstt1P[ 0 ].idCaste ;
            //tinP.pc Utility[ 0xc ] = pstt1P[ 1 ].idAdam ;
            //tinP.pc Utility[ 0xd ] = pstt1P[ 1 ].idCaste ;
            //tinP.pc Utility[ 0xe ] = pstt1P[ 2 ].idAdam ;
            //tinP.pc Utility[ 0xf ] = pstt1P[ 2 ].idCaste ;

            __( pstt1P->idCaste - sc_PREFIXlENGTH ) ;
        }

        if( pstt2P->idCaste - sc_PREFIXlENGTH )
        {
            //tinP.pc Utility[ 0x9 ] = (countT)pstt2P ;
            //tinP.pc Utility[ 0xa ] = pstt2P[ 0 ].idAdam ;
            //tinP.pc Utility[ 0xb ] = pstt2P[ 0 ].idCaste ;
            //tinP.pc Utility[ 0xc ] = pstt2P[ 1 ].idAdam ;
            //tinP.pc Utility[ 0xd ] = pstt2P[ 1 ].idCaste ;
            //tinP.pc Utility[ 0xe ] = pstt2P[ 2 ].idAdam ;
            //tinP.pc Utility[ 0xf ] = pstt2P[ 2 ].idCaste ;

            __( pstt2P->idCaste - sc_PREFIXlENGTH ) ;
        }

        if( POOP ) return 0 ;
    }

    _IO_

    const countT cs1 = pstt1P->idAdam ;_WQ
    const countT cs2 = pstt2P->idAdam ;_WQ
    countT cs  = cs1 ;_WQ
    if( cs > cs2 ) cs = cs2 ;_WQ
    ZE( boolT , bMaxIsBinding ) ;_WQ
    if( csMaxP && cs > csMaxP )
    {
        cs = csMaxP ;_WQ
        bMaxIsBinding = 1 ;_WQ
    }

    ZE( sCountT , sgn ) ;_WQ
    for( countT off = 0 ; !sgn && off < cs ; off ++ ) sgn = pstt1P[ CSpREFIX + off ] - pstt2P[ CSpREFIX + off ] ;_WQ

    if( !sgn && !bMaxIsBinding ) sgn = cs1 - cs2 ;_WQ

    return sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600204a.etherc.strcomparef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600204b.etherc.strconverttolowercasef BEGIN
#define DDNAME       "3func.3600204b.etherc.strconverttolowercasef"
#define DDNUMB      (countT)0x3600204b
#define IDFILE      (countT)0xc72


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strConvertToLowerCaseF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030055.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f810104.1.1.0.html\"\>f810104:  WAKEsHOW( "example.simplest.func.1030055.etherC.strConvertToLowerCaseF" )\</A\>
converts upper case alphabetic strokes (idCaste = 0; idAdam in ['A','Z']) to lower case ['a','z']
other idCaste = 0 strokes are copied unmodified
strokes with nonze idCaste are copied unmodified
arguments
 psttP
  can be any string of strokeS objects
*/
/**/

//ASSUME: IF THE strokeS STRING REPRESENTS MIXED 16,8 BYTE CHARS, THEN THIS FUNCTION WILL CHANGE THE MEANING AND EVEN THE NUMBER OF CHARACTERS
/*1*/voidT etherC::strConvertToLowerCaseF( tinS& tinP , strokeS* psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    countT cnt = psttP->idAdam ;
    for( countT ii = 1 ; !POOP && ii <= cnt ; ii ++ )
    {
         strConvertToLowerCaseF( tinP , psttP[ CSpREFIX - 1 + ii ] , psttP[ CSpREFIX - 1 + ii ] ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600204b.etherc.strconverttolowercasef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600204c.etherc.strconverttolowercasef BEGIN
#define DDNAME       "3func.3600204c.etherc.strconverttolowercasef"
#define DDNUMB      (countT)0x3600204c
#define IDFILE      (countT)0xc73


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strConvertToLowerCaseF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030056.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.0910104.1.1.0.html\"\>0910104:  WAKEsHOW( "example.simplest.func.1030056.etherC.strConvertToLowerCaseF" )\</A\>
if sttInP.idCaste is 0 and sttInP.idAdam is in the range ['A','Z'] then sttOut will be in the range ['a','z']
otherwise, sttOutP will be identical to sttInP
arguments
 sttOutP
  can be anything
 sttInP
  can be anything
*/
/**/

/*1*/voidT etherC::strConvertToLowerCaseF( tinS& tinP , strokeS& sttOutP , const strokeS& sttInP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    sttOutP = sttInP ;
    countT lower = (countT)sttInP - 'A' + 'a' ;
    if( ( sttInP.idCaste == sc_cALPHABET1 || sttInP.idCaste == sc_cFROMaSCII || sttInP.idCaste == scOld_CONTROLkEY ) && sttInP >= 'A' && sttInP <= 'Z' ) sttOutP = lower ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600204c.etherc.strconverttolowercasef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600204d.etherc.strdigitstoscountf BEGIN
#define DDNAME       "3func.3600204d.etherc.strdigitstoscountf"
#define DDNUMB      (countT)0x3600204d
#define IDFILE      (countT)0xc74


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strDigitsToSCountF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030057.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1910104.1.1.0.html\"\>1910104:  WAKEsHOW( "example.simplest.func.1030057.etherC.strDigitsToSCountF" )\</A\>
the number can contain leading blanks
the negative sign must be the first nonblank character
the plus sign is legal
an explicit radix overrides defaultRadixP
 a radix can be specified by appending an underscore "_" followed by a single radix 64_9 digit [0..9 a..z A..Z ? @]
  "0"       is the value 0
  "10"      is the radix 16_9 value 10
  "89abcde" is the radix 16_9 value 89abcde
  "-efef_f" is the radix 16_9 (hex) value -efef
  "-yzyz_z" is the radix 36_9 value -yzyz
  "-EFEF_F" is the radix 42_9 value -EFEF
  "-YZ?@_@" is the radix 64_9 value -YZ?@
the radix override value is always expressed in radix 64_9 (the digits are 0..9 a..z A..Z ? @)
conversion terminates with the first nonnumeric stroke
 if there is no radix override, terminates with the first stroke that is not a value radix 16 digit
 if there is a radix override but it is invalid (not a radix 64_9 digit) then impotence occurs
 if there is a valid radix override, terminates with the radix override
overflow is not detected
after an overflow, the resulting sign will still be correct
arguments
 psttP
 defaultRadixP
  can be 0, which implies radix 16_9
  if nonze, must be at least 2 and not more than 64_9
 bForeignP
  can be 0 or 1
  0: IdeaFarm " "(tm) City digit ordering (least significant digit occurs first (i.e. at left)
  1: Foreign digit ordering (most significant digit occurs first (i.e. at left)
*/
/**/

//"candy": "candidate"
#define BcANDY ( psttc->idCaste == sc_cFROMaSCII || psttc->idCaste == sc_cALPHABET1 )
#define BcANDYo(offP) ( psttc[ offP ].idCaste == sc_cFROMaSCII || psttc[ offP ].idCaste == sc_cALPHABET1 )

/*1*/sCountT etherC::strDigitsToSCountF( tinS& tinP , const strokeS* const psttP , const countT defaultRadixP , const boolT bForeignP )/*1*/
{
    SCOOP
    countT radix = defaultRadixP ;_WQ
    if( !radix ) radix = 0x10 ;_WQ

    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttP ) ;_WQ
        __( radix < 2 ) ;_WQ
        __( radix > 64 ) ;_WQ
        if( POOP ) return 0 ;
        __( psttP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return 0 ;
    }

    //U: OPTIMIZE TO ELIMINATE USE OF strReverseF BY REWRITING THIS FUNCTION
    // NOTE: THIS FUNCTION WAS CODED ASSUMING FOREIGN DIGIT ORDERING.  AFTER THE CODE WAS COMPLETED, IT WAS DECIDED TO ORDER DIGITS IN INCREASING SIGNIFICANCE WITHIN IFC

    _IO_

    ZE( sCountT , value ) ;_WQ
    if( psttP->idAdam )
    {
        ZE( strokeS* , psttd ) ;_WQ
        strMakeF( tinP , LF , psttd , psttP ) ; ___( psttd ) ;_WQ
        if( !bForeignP ) { strReverseF( tinP , psttd ) ; ___( psttd ) ; }
        __Z( psttd ) ;

        if( !POOP )
        {
            _IO_

            //U: OPTIMIZE BY MAKING THESE STATIC
            const strokeS stt_0( '0' ) ;_WQ
            const strokeS stt_1( '1' ) ;_WQ
            const strokeS stt_9( '9' ) ;_WQ
            const strokeS stt_a( 'a' ) ;_WQ
            const strokeS stt_z( 'z' ) ;_WQ
            const strokeS stt_A( 'A' ) ;_WQ
            const strokeS stt_Z( 'Z' ) ;_WQ
            const strokeS stt_bl( ' ' ) ;_WQ
            const strokeS stt_qu( '?' ) ;_WQ
            const strokeS stt_at( '@' ) ;_WQ
            const strokeS stt_mi( '-' ) ;_WQ
            const strokeS stt_pl( '+' ) ;_WQ
            const strokeS stt_un( '_' ) ;_WQ

            //GET SIGN AND RADIX OVERRIDE
            strokeS* psttc = psttd ;_WQ
            ZE( countT , cc ) ;_WQ
            ZE( boolT , fNeg ) ;_WQ
            {
                _IO_ //U:: TO FIND A BUG

                if( !POOP )
                {
                    _IO_ //U:: TO FIND A BUG
                    const strokeS* psttPrefix = psttc ;_WQ
                    countT cs = psttPrefix->idAdam ;_WQ
                    //tinP.pc Utility[ 0xf ] = cs | BM_HIGH ; //U:: TO FIND A BUG
                    psttc += CSpREFIX ;_WQ
                    while( psttc->idAdam == stt_bl.idAdam && BcANDY ) psttc ++ ;_WQ
                    fNeg = psttc->idAdam == stt_mi.idAdam && BcANDY ;_WQ
                    if( fNeg || ( psttc->idAdam == stt_pl.idAdam && BcANDY ) ) psttc ++ ;_WQ
                    cc = cs - ( psttc - psttPrefix - CSpREFIX ) ;_WQ
                    //tinP.pc Utility[ 0xe ] = cc | BM_HIGH ; //U:: TO FIND A BUG
                    //tinP.pc Utility[ 0xd ] = cc           ; //U:: TO FIND A BUG

                    {
                        _IO_ //U:: TO FIND A BUG
                        for( countT off = 1 ; off < cc ; off ++ )
                        {
                            _IO_ //U:: TO FIND A BUG
                            //tinP.pc Utility[ 0xc ] = off | BM_HIGH ; //U:: TO FIND A BUG
                            boolT bDebug1 = psttc[ off - 1 ].idAdam == stt_un.idAdam && BcANDYo( off - 1 ) ;
                            if( bDebug1 )
                            {
                                _IO_ //U:: TO FIND A BUG
                                if( BcANDYo( off ) )
                                {
                                    _IO_ //U:: TO FIND A BUG
                                    if( psttc[ off ].idCaste == sc_cALPHABET1 && ( psttc[ off ].idAdam & 0xf0000000 == sscDIGIT ) ) radix = psttc[ off ].idAdam & 0xffff ;
                                    else if( psttc[ off ].idAdam >=  stt_1.idAdam && psttc[ off ].idAdam <=  stt_9.idAdam ) radix = (countT)psttc[ off ] - '0' +  1 ;
                                    else if( psttc[ off ].idAdam >=  stt_a.idAdam && psttc[ off ].idAdam <=  stt_z.idAdam ) radix = (countT)psttc[ off ] - 'a' + 11 ;
                                    else if( psttc[ off ].idAdam >=  stt_A.idAdam && psttc[ off ].idAdam <=  stt_Z.idAdam ) radix = (countT)psttc[ off ] - 'A' + 37 ;
                                    else if( psttc[ off ].idAdam >= stt_qu.idAdam && psttc[ off ].idAdam <= stt_at.idAdam ) radix = (countT)psttc[ off ] - '?' + 63 ;
                                }
                                else { __( (countT)psttc[ off ] ) ; __1 }
                                break ;
                            }

                            {
                                _IO_ //U:: TO FIND A BUG
                                if( psttc[ off ] == stt_bl ) break ;
                            }
                        }
                    }
                }

                //GET ABSOLUTE VALUE
                {
                    _IO_ //U:: TO FIND A BUG
                    for( countT off = 0 ; !POOP && off < cc ; off ++ )
                    {
                        boolT bOk = 1 ;_WQ
                        ZE( countT , cDelta ) ;_WQ
                        {
                            if( !BcANDYo( off ) ) bOk = 0 ;
                            else if( psttc[ off ].idCaste == sc_cALPHABET1 && ( ( psttc[ off ].idAdam & 0xf0000000 ) == sscDIGIT )                                  ) cDelta = psttc[ off ].idAdam & 0xffff   ;
                            else if( psttc[ off ].idAdam >=  stt_0.idAdam && psttc[ off ].idAdam <=  stt_9.idAdam && (countT)psttc[ off ].idAdam - '0'      < radix ) cDelta = psttc[ off ].idAdam - '0'      ;
                            else if( psttc[ off ].idAdam >=  stt_a.idAdam && psttc[ off ].idAdam <=  stt_z.idAdam && (countT)psttc[ off ].idAdam - 'a' + 10 < radix ) cDelta = psttc[ off ].idAdam - 'a' + 10 ;
                            else if( psttc[ off ].idAdam >=  stt_A.idAdam && psttc[ off ].idAdam <=  stt_Z.idAdam && (countT)psttc[ off ].idAdam - 'A' + 36 < radix ) cDelta = psttc[ off ].idAdam - 'A' + 36 ;
                            else if( psttc[ off ].idAdam >= stt_qu.idAdam && psttc[ off ].idAdam <= stt_at.idAdam && (countT)psttc[ off ].idAdam - '?' + 62 < radix ) cDelta = psttc[ off ].idAdam - '?' + 62 ;
                            else                                                                                                                                      bOk = 0 ;
                        }

                        if( bOk )
                        {
                            value *= radix ;_WQ
                            value += cDelta ;_WQ
                        }
                        else break ;
                    }

                    if( fNeg ) value *= - 1 ;_WQ

                    delF( tinP , psttd ) ;_WQ
                }
            }
        }
    }

    return value ;
}

#undef BcANDY
#undef BcANDYo


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600204d.etherc.strdigitstoscountf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600204e.etherc.strfromf BEGIN
#define DDNAME       "3func.3600204e.etherc.strfromf"
#define DDNUMB      (countT)0x3600204e
#define IDFILE      (countT)0xc75


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFromF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030058.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.2910104.1.1.0.html\"\>2910104:  WAKEsHOW( "example.simplest.func.1030058.etherC.strFromF" )\</A\>
arguments
 psttP
  will be set to contain the string
 valueP
  this is the value that is to be represented as a string of digits
 flagsFormatP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001004c.flFORMAT!||
 csP
  minimum length of the final string
  if more strokes are needed to represent the number, psttP will be longer than csP
  -1 : special value that results in a string long enough to represent the maximum value of valueP, the latter depending upon whether flFORMAT_UNSIGNED is set
 radixP
  can be 0
  if 0 then 16_9 is implied
  if not 0 and  !tinP.strokeMode.idCasteDefault then must be 2 <= radixP <= 64_9
  if not 0 and !!tinP.strokeMode.idCasteDefault then must be 2 <= radixP <= 65536_9 (00001)
  example: value 2 produces binary
   this function should have been written to use value 1 for binary, i.e. to require radixP to specify the maximum value representable by a single bigit
   this would conform to the convention used for explicit radix indicators in the rendered text
   but this function was written before i thought of that, so it requires the caller to specify radixP using the foreign convention
   U:: migrate this function and all calling code to make it conform to the ifc convention for indicating radix
    the ifc convention for indicating radix is to use the symbol for the maximum value representable by a single bigit using that radix
     example: binary: radix 1
     example: hexadecimal: radix f
 csttExtraP
*/
/**/

/*1*/voidT etherC::strFromF( tinS& tinP , strokeS*& psttP , const sCountT valueP , const flagsT flagsFormatP , const countT csP , const countT radixP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;_WQ
        __( radixP && radixP < 2 ) ;_WQ
        __( !tinP.strokeMode.idCasteDefault && radixP > 64 ) ;_WQ
        __(  tinP.strokeMode.idCasteDefault && radixP > 0x10000 ) ;_WQ
        { countT cb = 4 ; __( sizeof valueP - cb ) ; }
        if( POOP ) return ;
    }

    static countT idInLath ;_WQ
    countT idIn = 1 + incv02AM( idInLath ) ;_WQ
    if( idIn == 0x1f )
    {
        countT foo = 2 ;_WQ
    }

    _IO_
    if( F(flagsFormatP) & flFORMAT_CITIZENnAME )
    {
        TN( tSuffix , "'O Ideafarm" ) ;_WQ
        strFromF( tinP , psttP , valueP , flFORMAT_DIGITnAMES | flFORMAT_UNSIGNED , 0 , 0 , tSuffix.csF( tinP ) + csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;_WQ
        strFuseF( tinP , psttP , tSuffix ) ; ___( psttP ) ;_WQ
    }
    else if( F(flagsFormatP) & flFORMAT_CITIZENeMAIL )
    {
        TN( tSuffix , "@" "ideafarm.com" ) ;_WQ
        strFromF( tinP , psttP , valueP , flFORMAT_UNSIGNED , 0 , 0 , tSuffix.csF( tinP ) + csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;_WQ
        strFuseF( tinP , psttP , tSuffix ) ; ___( psttP ) ;_WQ
    }
    else if( F(flagsFormatP) & flFORMAT_DOTTEDdECIMAL )
    {
        countT vv = valueP ;_WQ
        countT v1 = vv & 0xff ; vv >>= 8 ;_WQ
        countT v2 = vv & 0xff ; vv >>= 8 ;_WQ
        countT v3 = vv & 0xff ; vv >>= 8 ;_WQ
        countT v4 = vv & 0xff ; vv >>= 8 ;_WQ
        TN( tDot , "." ) ;_WQ
        flagsT flags = flFORMAT_NObIGITvALUES | flFORMAT_UNSIGNED | flFORMAT_FOREIGN | flFORMAT_NObASE ;_WQ
        strMakeF( tinP , LF , psttP , TF4(v4,flags,0,0xa)+tDot+TF4(v3,flags,0,0xa)+tDot+TF4(v2,flags,0,0xa)+tDot+TF4(v1,flags,0,0xa) ) ; // CALLER MUST TAG ___( psttP ) ;_WQ
    }
    else if( F(flagsFormatP) & flFORMAT_COLONEDhEX )
    {
        countT vv = valueP ;_WQ
        countT v1 = vv & 0xffff ; vv >>= 0x10 ;_WQ
        countT v2 = vv & 0xffff ; vv >>= 0x10 ;_WQ
        TN( tColon , ":" ) ;_WQ
        flagsT flags = flFORMAT_NObIGITvALUES | flFORMAT_UNSIGNED | flFORMAT_FOREIGN ;_WQ
        strMakeF( tinP , LF , psttP , TF3(v2,flags,0)+tColon+TF3(v1,flags,0) ) ; // CALLER MUST TAG ___( psttP ) ;_WQ
    }
    else
    {
        //U: OPTIMIZE: ELIMINATE THE USE OF strReverseF BY REWRITING THIS FUNCTION

        //IF RADIX IS NOT 16 THEN AN EXPLICIT RADIX INDICATOR WILL BE INCLUDED (E.G.: "12345_9" INDICATES 12345 BASE 10)
        countT radix = radixP ;_WQ
        if( !radix ) radix = 16 ;_WQ

        ZE( boolT , bPrependedSign ) ;_WQ
        {
            boolT bNeedSign = ( valueP < 0 && !( F(flagsFormatP) & flFORMAT_UNSIGNED ) ) || ( F(flagsFormatP) & flFORMAT_SHOWpLUS ) ;_WQ
            boolT bSignCols = F(flagsFormatP) & flFORMAT_SIGNcOLlEFT || F(flagsFormatP) & flFORMAT_SIGNcOLrIGHT ;_WQ
            bPrependedSign = bNeedSign && !bSignCols ;_WQ
        }

        strokeS sttSign ;_WQ
        {
                 if( valueP < 0 && !( F(flagsFormatP) & flFORMAT_UNSIGNED ) ) sttSign = S1C('-') ;
            else if( F(flagsFormatP) & flFORMAT_SHOWpLUS )                    sttSign = S1C('+') ;
            else                                                              sttSign = S1C(' ') ;
        }

        const boolT bRadixIndicator = radix != 16 && !( F(flagsFormatP) & flFORMAT_NObASE ) ;_WQ

        const boolT bForeign       = !tinP.strokeMode.idCasteDefault ;_WQ
        const boolT bNoBigitValues = F(flagsFormatP) & flFORMAT_NObIGITvALUES /* || !thirdC::p WinRootIF() */ ;_WQ

        ZE( countT , cdBits ) ; //"cDigitBits": 0-BASED: 0 MEANS 1 BIT; f MEANS 01 BITS
        {
            countT rr = 2 ;_WQ
            while( rr < radix )
            {
                cdBits ++ ;_WQ
                rr <<= 1 ;_WQ
            }
        }

        ZE( strokeS* , psttBigits ) ; // PREPENDED SIGN, DIGITS.  WILL -NOT- CONTAIN: SIGN COLUMNS, RADIX INDICATOR
        {
            countT cBigitsMax = 1 ;_WQ
            {
                countT test = F(flagsFormatP) & flFORMAT_UNSIGNED
                    ? MAXcOUNTT
                    : MAXscOUNTT
                ;_WQ

                while( test / radix )
                {
                    cBigitsMax ++ ;_WQ
                    test /= radix ;_WQ
                }

                countT cstta = cBigitsMax + bPrependedSign ;_WQ
                if( csP != - 1 && cstta < csP ) cstta = csP ;_WQ
                strMakeF( tinP , LF , psttBigits , 0 , cstta ) ; ___( psttBigits ) ;_WQ
            }

            strokeS s0 = bForeign || bNoBigitValues ? S1C( '0' ) : S2( sscDIGIT | SDBITS( cdBits ) , sc_cALPHABET1 ) ;_WQ
            if( !valueP ) { strFuseF( tinP , psttBigits , s0 ) ; ___( psttBigits ) ; }
            else
            {
                ZE( countT , value ) ;_WQ
                if( !( F(flagsFormatP) & flFORMAT_UNSIGNED ) && valueP < 0 ) value = - valueP ;
                else                                                         value =   valueP ;

                while( value )
                {
                    countT digit = value % radix ;_WQ
                    value /= radix ;_WQ
                    strokeS stt = ' ' ;_WQ

                    if( !bForeign && !bNoBigitValues ) stt = S1C(sscDIGIT|SDBITS(cdBits)|digit) ;
                    else
                    {
                             if( digit < 10 ) stt = '0' + digit ;
                        else if( digit < 36 ) stt = 'a' + digit - 10 ;
                        else if( digit < 62 ) stt = 'A' + digit - 36 ;
                        else                  stt = '?' + digit - 62 ;
                    }

                    strFuseF( tinP , psttBigits , stt , 0 , 1 ) ; ___( psttBigits ) ;_WQ
                }
            }

            strokeS sttFill = S1C(' ') ;_WQ
                 if( F(flagsFormatP) & flFORMAT_FILLzE   ) sttFill = s0      ;
            else if( F(flagsFormatP) & flFORMAT_FILLsIGN ) sttFill = sttSign ;

            if( bPrependedSign && sttFill != s0 ) { strFuseF( tinP , psttBigits , sttSign , 0 , 1 ) ; ___( psttBigits ) ; }

            if( csP )
            {
                countT csr = csP == - 1                     // THIS IS NEWLY ADDED WITHOUT MODIFYING THE CALCULATION OF csd ; I AM NOT SURE WHETHER THE RESULTING csd VALUE IS WHAT I WANT FOR ALL POSSIBLE COMBINATIONS OF FLAGS
                    ? cBigitsMax + bPrependedSign
                    : csP
                ;_WQ

                countT csd = csr /*- 2 * bRadixIndicator*/ ; // "-2 * bRadixIndicator" REMOVED TO MAKE csP == -1 WORK FOR radixP 0x24
                if( csP != - 1 )
                {
                    if( F(flagsFormatP) & flFORMAT_SIGNcOLlEFT  ) csd -- ;_WQ
                    if( F(flagsFormatP) & flFORMAT_SIGNcOLrIGHT ) csd -- ;_WQ
                    if( bPrependedSign && sttFill == s0         ) csd -- ;_WQ
                }

                if( psttBigits && psttBigits->idAdam < csd ) { strResizeF( tinP , psttBigits , csd , sttFill , 1 , 1 ) ; ___( psttBigits ) ; }
            }

            if( bPrependedSign && sttFill == s0 ) { strFuseF( tinP , psttBigits , sttSign , 0 , 1 ) ; ___( psttBigits ) ; }

            __Z( psttBigits ) ;_WQ
        }

        if( psttBigits ) { strMakeF( tinP , LF , psttP , T("") , psttBigits->idAdam + 4 + csttExtraP ) ; }

        if( F(flagsFormatP) & flFORMAT_SIGNcOLlEFT ) strFuseF( tinP , psttP , sttSign , 4 + csttExtraP ) ;_WQ

        strFuseF( tinP , psttP , psttBigits , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ 4 + csttExtraP ) ;_WQ
        delF( tinP , psttBigits ) ;_WQ

        if( bRadixIndicator )
        {
            strokeS psttBuf[ CSpREFIX + 2 ] ;_WQ
            SETpREFIX( psttBuf , 2 , 0 ) ;_WQ
            psttBuf[ CSpREFIX     ] = '_' ;_WQ
            psttBuf[ CSpREFIX + 1 ] = 0 ;_WQ

            if( !bForeign && !bNoBigitValues ) psttBuf[ CSpREFIX + 1 ] = S1C(sscDIGIT|SDBITS(cdBits)|radix-1) ;
            else
            {
                     if( radix <= 10 ) psttBuf[ CSpREFIX + 1 ] = S1C( '0' -  1 + radix      ) ;
                else if( radix <= 36 ) psttBuf[ CSpREFIX + 1 ] = S1C( 'a' -  1 + radix - 10 ) ;
                else if( radix <= 62 ) psttBuf[ CSpREFIX + 1 ] = S1C( 'A' -  1 + radix - 36 ) ;
                else                   psttBuf[ CSpREFIX + 1 ] = S1C( '?' -  1 + radix - 62 ) ;
            }

            strFuseF( tinP , psttP , psttBuf ) ; ___( psttP ) ;_WQ
        }

        if(    F(flagsFormatP) & flFORMAT_SIGNcOLrIGHT   ) {                strFuseF(    tinP , psttP , sttSign                                                 ) ; }
        if( !( F(flagsFormatP) & flFORMAT_FOREIGN      ) ) { ___( psttP ) ; strReverseF( tinP , psttP                                                           ) ; }
        if(    F(flagsFormatP) & flFORMAT_DIGITnAMES     ) { ___( psttP ) ; strReplaceF( tinP , psttP , 0 , ifcIDtYPEsTRrEPLACE_DIGITStOdIGITnAMES , csttExtraP ) ; }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600204e.etherc.strfromf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600204f.etherc.strfusef BEGIN
#define DDNAME       "3func.3600204f.etherc.strfusef"
#define DDNUMB      (countT)0x3600204f
#define IDFILE      (countT)0xc76


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFuseF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030059.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.3910104.1.1.0.html\"\>3910104:  WAKEsHOW( "example.simplest.func.1030059.etherC.strFuseF" )\</A\>
arguments
 psttOutP
  can either be 0 or point to a writeable string of strokeS objects
 psttInP
  can be 0
  normally is not 0
 csttExtraP
  meaning depends upon whether pSoulP is 0
   if pSoulP is 0 then csttExtraP specifies unused strokeS objects to will be included at the end of the allocated string, psttOutP
   else csttExtraP specifies the allocation size to use
   if pSoulP and !csttExtraP then the default allocation size CSTTsOULfUSEdEFAULT will be used
    using the default allocation size reduces memory paging and poolC administration overhead
 pSoulP
  can be 0
  if 0 then psttOutP must either be 0 or contain enough room for the result to be appended
  if not 0 then *pSoulP will be used as a fifo buffer to store the result
  the result will either be in psttOutP xor in *pSoulP
   the caller can force output to be in *pSoulP by preloading it with a null length string
 pGrabP
  can be 0
  if not 0 then *pGrabP will be grabbed when *pSoulP is being accessed
 sttEscapeP
  can be 0
  if not 0 then i will avoid splitting an assumed oo stroke escape sequence when pushing split output into *pSoulP
 psttDelimiterPairsP
  if 0 then i will just ensure that sttEscapeP is not the lath stroke in any part
  if not 0 then must point to a string whose length is even
  each pair of strokes is interpreted as a delimiter pair
  i will ensure that i do not split any occurance of sttEscapeP followed immediately by a delimited string
 csttMaxDelimiterP
  if 0 then delimited strings can be of any length and i will not split them
  if not 0 then is the maximum length, excluding the delimiters, that a delimited string can be
 csttExtraP
*/
/**/

/*1*/voidT etherC::strFuseF( tinS& tinP , strokeS*& psttOutP , const strokeS* const psttInP , soulC* pSoulP , grabC* pGrabP , const strokeS sttEscapeP , const strokeS* psttDelimiterPairsP , const countT csttMaxDelimiterP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        if( psttDelimiterPairsP ) 
        {
            __Z( psttDelimiterPairsP->idAdam ) ;_WQ
            __NZ( psttDelimiterPairsP->idAdam % 2 ) ;_WQ
        }
        if( POOP ) return ;
    }

    _IO_

    const strokeS* psttic = !psttInP  ? 0 : psttInP  + CSpREFIX ;_WQ
    const strokeS* psttie = !psttic   ? 0 : psttic              + psttInP->idAdam ;_WQ
    strokeS*       psttoc = !psttOutP ? 0 : psttOutP + CSpREFIX + psttOutP->idAdam ;_WQ
    strokeS*       psttoe = !psttoc   ? 0 : psttoc              + psttOutP[ 2 ].idAdam ;_WQ

    if( !!sttEscapeP )
    {
        countT foo = 2 ; //U;; TO FIND A BUG
    }

    do
    {
        // FILL UP THE OUTPUT STRING
        if( psttoc && psttic )
        {
            countT co = psttoe - psttoc ;_WQ
            countT ci = psttie - psttic ;_WQ
            countT cDo = ci < co
                ? ci
                : co
            ;_WQ

            if( co < ci && !!sttEscapeP )
            {
                while( cDo > 1 && psttic[ cDo - 1 ] == sttEscapeP )
                {
                    cDo -- ;_WQ
                }

                if( psttDelimiterPairsP )
                {
                    countT csttdp = psttDelimiterPairsP->idAdam ;_WQ
                    countT cMaxLook = csttMaxDelimiterP ? csttMaxDelimiterP + 2 : - 1 ;_WQ
                    if( cMaxLook > cDo - 2 ) cMaxLook = cDo - 2 ; // EXCLUDES WOTH STROKE AND THE ESCAPE CHAR, WHICH I DO NOT LOOK DIRECTLY AT
                    ZE( const strokeS* , psttFound ) ;_WQ
                    for( countT offp = 0 ; offp < csttdp ; offp += 2 )
                    {
                        const strokeS* psttLook = psttic + cDo - 1 ;_WQ
                    
                        // RECIPE
                        // 
                        // THE GOAL IS TO AVOID HAVING AN UNTERMINATED DELIMITED STRING AT THE END
                        // ASSUME: DELIMITERS CANNOT BE NESTED
                        // I INSPECT BACKWARDS FROM THE LATH STROKE
                        // IF I FIND A CLOSING DELIMITER THEN I AM OK SO I QUIT INSPECTING
                        // BUT IF I FIND AN OPENING DELIMITER THEN I REDUCE THE LENGTH TO OMIT IT AND THEN QUIT INSPECTING
                    
                        countT cLook = cMaxLook ;_WQ
                        while( cLook -- )
                        {
                            if( psttLook[ 0 ] == psttDelimiterPairsP[ CSpREFIX + offp + 1 ] ) break ;       // CLOSING DELIMITER SO AM OK FOR THIS DELIMITER PAIR
                            else if
                            (
                                psttLook[ 0 ] == psttDelimiterPairsP[ CSpREFIX + offp ]                     // LOOKING AT OPENING DELIMITER
                                &&
                                psttLook[ - 1 ] == sttEscapeP                                               // PRECEDED BY ESCAPE STROKE
                                &&
                                (
                                    !psttFound                                                              // WOTH FOUND
                                    ||
                                    psttFound > psttLook - 1                                                // BELOW PREVIOUS FIND
                                )
                            )
                            {
                                psttFound = psttLook - 1 ;_WQ
                                break ;
                            }
                    
                            psttLook -- ;_WQ
                        }
                    }
                    
                    if( psttFound ) cDo = psttFound - psttic ;_WQ
                }
            }

            psttOutP[ 2 ].idAdam -= cDo ;_WQ
            psttOutP[ 0 ].idAdam += cDo ;_WQ

            while( cDo -- ) *( psttoc ++ ) = *( psttic ++ ) ;_WQ

            //if( pSoulP && sttEscapeP.idAdam  )
            //{
            //    //U::TO FIND A BUG.  CAN'T USE traceF CAUSE WOULD RECURSE INFINITELY
            //    static osTextT postTock[ TOCK ] ;_WQ
            //    ZE( countT , offi ) ;_WQ
            //    for( offi = 0 ; offi < psttOutP->idAdam ; offi ++ ) postTock[ offi ] = (osTextT)psttOutP[ CSpREFIX + offi ].idAdam ;_WQ
            //    postTock[ offi ] = 0 ;_WQ
            //    LOGrAW( "fusePiece: >>>>" ) ; 
            //    LOGrAW( postTock ) ;_WQ
            //    LOGrAW( "<<<<\r\n" ) ; 
            //}
        }

        // MOVE OUTPUT TO FIFO SOUL
        if( psttoc && psttic && psttic < psttie ) // IF HAVE OUTPUT AND STILL HAVE MORE INPUT TO PROCESS
        {
            if( !pSoulP )
            {
                __1 ;_WQ
                break ;
            }
            else
            {
                if( pGrabP ) pGrabP->grabF( tinP , TAG( TAGiDnULL ) ) ;_WQ
                *pSoulP << psttOutP ;_WQ
                if( pGrabP ) pGrabP->ungrabF( tinP ) ;_WQ
                ___( psttOutP ) ;_WQ
                delF( tinP , psttOutP ) ;_WQ
                psttoe = psttoc = 0 ;_WQ
            }
        }

        // ALLOCATE AN OUTPUT STRING (ALWAYS DONE, EVEN IF NO INPUT
        if( !psttOutP )
        {
            countT cstta = !pSoulP
                ? psttic
                    ? psttie - psttic + csttExtraP
                    : csttExtraP
                : csttExtraP
                    ? csttExtraP
                    : CSTTsOULfUSEdEFAULT
            ;_WQ

            third.newF( tinP , LF , psttOutP , CSpREFIX + cstta ) ; //CALLER MUST TAG ___( psttOutP ) ;_WQ
            __Z( psttOutP ) ;_WQ
            if( !POOP )
            {
                SETpREFIX( psttOutP , 0 , cstta )
                psttoc = psttOutP + CSpREFIX ;_WQ
                psttoe = psttoc   + cstta    ;_WQ
            }
        }

        if( !psttic ) break ;
    }
    while( psttic < psttie ) ;_WQ

    if( pSoulP && *pSoulP ) // EVEN IF I AM NOT THE WO WHO PUSHED THE CONTENT
    {
        *pSoulP << psttOutP ;_WQ
        ___( psttOutP ) ;_WQ
        delF( tinP , psttOutP ) ;_WQ
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600204f.etherc.strfusef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002050.etherc.strfusef BEGIN
#define DDNAME       "3func.36002050.etherc.strfusef"
#define DDNUMB      (countT)0x36002050
#define IDFILE      (countT)0xc77


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFuseF.0.html\"\>instances\</A\>
\<A HREF=\"5.103005a.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6910104.1.1.0.html\"\>6910104:  WAKEsHOW( "example.simplest.func.103005a.etherC.strFuseF" )\</A\>
arguments
 psttOutP
 sttInP
  can be 0
 csttExtraP
 fLeadingP
  0 or 1
   0: sttInP is appended  to psttOutP
   1: sttInP is prepended to psttOutP
*/
/**/

/*1*/voidT etherC::strFuseF( tinS& tinP , strokeS*& psttOutP , const strokeS sttInP , const countT csttExtraP , const boolT fLeadingP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    ZE( countT , cLengthOut ) ;_WQ
    ZE( countT , cExtraOut ) ;_WQ
    if( psttOutP ) GETpREFIX( cLengthOut , cExtraOut , psttOutP ) ;_WQ

    if( !fLeadingP )
    {
        if( cExtraOut )
        {
            psttOutP[ CSpREFIX + cLengthOut ] = sttInP ;_WQ
            cExtraOut  -- ;_WQ
            cLengthOut ++ ;_WQ
            SETpREFIX( psttOutP , cLengthOut , cExtraOut ) ;_WQ
        }
        else
        {
            if( psttOutP )
            {
                _IO_
                LOGrAW3( "" , DDNUMB , " calling dosWriteStdOutBadCodeStyleF\r\n" ) ;_WQ
                third.dosWriteStdOutBadCodeStyleF( tinP ) ;_WQ
            }

            ZE( strokeS* , psttNew ) ;_WQ
            third.newF( tinP , LF , psttNew , CSpREFIX + cLengthOut + 1 + csttExtraP ) ; // CALLER MUST TAG ___( psttNew ) ;_WQ
            SETpREFIX( psttNew , cLengthOut + 1 , csttExtraP ) ;_WQ
            if( psttOutP && psttNew )
            {
                countT offEnd = CSpREFIX + cLengthOut ;_WQ
                for( countT off = CSpREFIX ; off < offEnd ; off ++ ) psttNew[ off ] = psttOutP[ off ] ;_WQ
                delF( tinP , psttOutP ) ;_WQ
            }
            if( psttNew ) psttNew[ CSpREFIX + cLengthOut ] = sttInP ;_WQ
            psttOutP = psttNew ;_WQ
        }
    }
    else
    {
        if( cExtraOut )
        {
            for( sCountT off = cLengthOut - 1 ; off >= 0 ; off -- )
                psttOutP[ CSpREFIX + off + 1 ] = psttOutP[ CSpREFIX + off ] ;_WQ
            psttOutP[ CSpREFIX ] = sttInP ;_WQ
            cExtraOut  -- ;_WQ
            cLengthOut ++ ;_WQ
            SETpREFIX( psttOutP , cLengthOut , cExtraOut ) ;_WQ
        }
        else
        {
            if( psttOutP )
            {
                _IO_
                LOGrAW3( "" , DDNUMB , " calling dosWriteStdOutBadCodeStyleF\r\n" ) ;_WQ
                third.dosWriteStdOutBadCodeStyleF( tinP ) ;_WQ
            }

            ZE( strokeS* , psttNew ) ;_WQ
            third.newF( tinP , LF , psttNew , CSpREFIX + cLengthOut + 1 + csttExtraP ) ; // CALLER MUST TAG ___( psttNew ) ;_WQ
            SETpREFIX( psttNew , cLengthOut + 1 , csttExtraP ) ;_WQ
            if( psttNew ) psttNew[ CSpREFIX ] = sttInP ;_WQ
            if( psttNew && psttOutP )
            {
                countT offEnd = CSpREFIX + cLengthOut ;_WQ
                for( countT off = CSpREFIX ; off < offEnd ; off ++ ) psttNew[ off + 1 ] = psttOutP[ off ] ;_WQ
                delF( tinP , psttOutP ) ;_WQ
            }
            psttOutP = psttNew ;_WQ
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002050.etherc.strfusef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002051.etherc.stridf BEGIN
#define DDNAME       "3func.36002051.etherc.stridf"
#define DDNUMB      (countT)0x36002051
#define IDFILE      (countT)0xc78


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strIdF.0.html\"\>instances\</A\>
\<A HREF=\"5.103005b.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7910104.1.1.0.html\"\>7910104:  WAKEsHOW( "example.simplest.func.103005b.etherC.strIdF" )\</A\>
  \<A HREF=\"5.8910104.1.1.0.html\"\>8910104:  WAKEsHOW( "example.simplest.func.103005b.etherC.strIdF" )\</A\>
arguments
 sttSmallP
  can be null
 psttBigP
*/
/**/

/*1*/countT etherC::strIdF( tinS& tinP , const strokeS& sttSmallP , const strokeS* psttBigP , sCountT idP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( idP ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_

    countT idf = 1 ;_WQ
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;_WQ
    return strIdF( tinP , idf , sttq , sttSmallP , psttBigP , 0 , idP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002051.etherc.stridf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002052.etherc.stridf BEGIN
#define DDNAME       "3func.36002052.etherc.stridf"
#define DDNUMB      (countT)0x36002052
#define IDFILE      (countT)0xc79


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strIdF.0.html\"\>instances\</A\>
\<A HREF=\"5.103005c.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9910104.1.1.0.html\"\>9910104:  WAKEsHOW( "example.simplest.func.103005c.etherC.strIdF" )\</A\>
evaluates to the id of the first match
the search begins with the idFirstP stroke
matches within quotes are ignored
after return, idFirstP will contain the id of the stroke that is immediately after the match found
initialize sttQuoteP to the quote state at idFirstP
 sttQuoteP is either 0 or contains the last quote mark encountered
 see doc for strIsInQuoteF for notes on which quote marks are recognized
 see doc for strIsInQuoteF for notes on how sttQuoteP is set at the beginning and at the end of a quote
arguments
 idFirstP
 sttQuoteP
  i will ignore quotes if sttQuoteP.idCaste == sc_IGNOREqUOTES
 sttSmallP
  this can be null
 psttBigP
 idLastP
  can be 0
  if 0 then the search is over the entire psttBigP string
  if not 0 then only the strokes between idFirstP and idLastP inclusive are inspected
*/
/**/

/*1*/countT etherC::strIdF( tinS& tinP , countT& idFirstP , strokeS& sttQuoteP , const strokeS& sttSmallP , const strokeS* psttBigP , const countT idLastP , sCountT idP )/*1*/
{
    SCOOP
    const boolT bUseQuotes = sttQuoteP.idCaste != sc_IGNOREqUOTES ;_WQ

    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttBigP ) ;_WQ
        __Z( idFirstP ) ;_WQ
        __( idFirstP == 1 && (countT)sttQuoteP && bUseQuotes ) ;_WQ
        __Z( idP ) ;_WQ
        if( POOP ) return 0 ;
        __( psttBigP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_

    STRiDrECURSE( strIdF( tinP , idf , sttQuoteP , sttSmallP , psttBigP , idLastP , 1 ) )
    {
        ZE( countT , ccBig ) ;_WQ
        if( !POOP )
        {
            ccBig = idLastP && idLastP < psttBigP->idAdam ? idLastP : psttBigP->idAdam ;_WQ
            if( idFirstP > ccBig )
            {
                __( ccBig ) ;_WQ
                __( idFirstP ) ;_WQ
            }
        }
    
        if( !POOP )
        {
            for( idHit = idFirstP ; idHit <= ccBig ; idHit ++ )
            {
                if( bUseQuotes && strIsInQuoteF( tinP , sttQuoteP , idHit , psttBigP ) ) continue ;
                if( psttBigP[ CSpREFIX - 1 + idHit ] == sttSmallP ) break ;
            }
    
            if( idHit > ccBig ) idHit = 0 ;_WQ
            if( idHit )                      idFirstP = idHit + 1 ;_WQ
            if( !idHit || idFirstP > ccBig ) idFirstP  = 0 ;_WQ
        }
    }
    return idHit ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002052.etherc.stridf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002053.etherc.stridf BEGIN
#define DDNAME       "3func.36002053.etherc.stridf"
#define DDNUMB      (countT)0x36002053
#define IDFILE      (countT)0xc7a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strIdF.0.html\"\>instances\</A\>
\<A HREF=\"5.103005d.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.a910104.1.1.0.html\"\>a910104:  WAKEsHOW( "example.simplest.func.103005d.etherC.strIdF" )\</A\>
idFirstP will point to the stroke after the one found
quoted strokes are skipped when searching for the first match
initialize sttQuoteP to the quote state at idFirstP
 sttQuoteP is either 0 or contains the last quote mark encountered
 see doc for strIsInQuoteF for notes on which quote marks are recognized
 see doc for strIsInQuoteF for notes on how sttQuoteP is set at the beginning and at the end of a quote
arguments
 idFirstP
 sttQuoteP
  i will ignore quotes if sttQuoteP.idCaste == sc_IGNOREqUOTES
 psttSmallP
  this string can include a null stroke
  this can also be null, or a null length string
   behavior is identical to that of a unit length string containing a null stroke
  if this string begins with sc_ccSSS(sa_SSSaND), i look for the idP'th occurance of the specified string pattern (regular expressions)
   U:: this is fully general, but i can be edited to support SSS specifications that do not begin in the woth position, if that is ever desired
    this should not be done unless there is a good reason to do it, because any such specification can be wrapped so that it conforms to the current requirement
 psttBigP
 idLastP
  can be 0
  if 0 then the search is over the entire psttBigP string
  if not 0 then only the strokes between idFirstP and idLastP inclusive are inspected
*/
/**/

/*1*/countT etherC::strIdF( tinS& tinP , stackC* const pstMatchP , const flagsT flagsMatchP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* psttSmallP , const strokeS* psttBigP , const countT idLastP , sCountT idP )/*1*/
{
    SCOOP
    const boolT bIgnoreQuotes = sttQuoteP.idCaste == sc_IGNOREqUOTES ;_WQ

    IFbEcAREFUL
    {
        if( POOP ) return 0 ;

        __Z( psttBigP ) ;_WQ
        __Z( idFirstP ) ;_WQ
        __( idFirstP == 1 && (countT)sttQuoteP && !bIgnoreQuotes ) ;_WQ
        __Z( idP ) ;_WQ
        if( POOP ) return 0 ;
        __( psttSmallP && psttSmallP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        __( psttBigP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( pstMatchP )
        {
            __( F( pstMatchP->flagsF( tinP ) ) & flSTACKc_FIFO ) ; // IF FIFO THEN WILL CONTAIN INCORRECT CONTENTS
        }
        //FV(flSTRmATCH,flagsMatchP) ;
        if( POOP ) return 0 ;
    }

    _IO_

    countT cPlatesWas = pstMatchP ? *pstMatchP : 0 ;

    STRiDrECURSE( strIdF( tinP , pstMatchP , flSTRmATCH_null , idf , sttQuoteP , psttSmallP , psttBigP , idLastP , 1 ) )
    {
        boolT bSSS = psttSmallP->idAdam && psttSmallP[ CSpREFIX ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX ].idAdam == sa_SSSaND ; // ENFORCE: ALL SSS MUST BE WRAPPED IN AND ; THIS IS JUST TO KEEP CODE SIMPLE

        const strokeS psttOneNull[] = { strokeS() , strokeS() , strokeS() , strokeS() } ;_WQ
        SETpREFIX( (strokeS*)psttOneNull , 1 , 0 ) ;_WQ
        const strokeS* const psttSmall = ( psttSmallP && psttSmallP->idAdam ) ? psttSmallP : psttOneNull ;_WQ
    
        if( !POOP )
        {
            countT ccBig   = idLastP && idLastP < psttBigP->idAdam ? idLastP : psttBigP->idAdam ;_WQ
            countT ccSmall = psttSmall->idAdam ;_WQ
    
            if( !bSSS && idFirstP - 1 + ccSmall > ccBig ) idFirstP = 0 ;
            else
            {
                countT idMax = bSSS ? ccBig : ccBig - ccSmall + 1 ;_WQ
                if( !POOP )
                {
                    ZE( countT , idbDo ) ;_WQ
                    for( idHit = idFirstP ; idHit <= idMax ; idHit ++ )
                    {
                        ZE( boolT , bInQuote ) ;_WQ
                        if( !bIgnoreQuotes ) bInQuote = strIsInQuoteF( tinP , sttQuoteP , idHit , psttBigP ) ;_WQ
                        if( bIgnoreQuotes || !bInQuote )
                        {
                            if( bSSS )
                            {
                                countT idsDo = 1 ;_WQ
                                idbDo = idHit ;_WQ
                                if( sssAndF( tinP , pstMatchP , flagsMatchP , psttSmallP , psttBigP , idsDo , idbDo ) ) break ;
                                else                                                                 idbDo = 0 ;
                            }
                            else if( !strComparePrivateF( psttBigP + CSpREFIX - 1 + idHit , psttSmall ) ) break ;
                        }
                    }
                    if( idHit > idMax ) idHit = 0 ;_WQ

                    if( idHit )
                    {
                        idFirstP = !bSSS

                            ? idHit + ccSmall 
                            : idbDo                 // SHOULD ALWAYS BE TRUE
                                ? idbDo + 1
                                : 0                 // SHOULD BE IMPOSSIBLE
                        ;_WQ
                    }

                    if( !idHit || idFirstP > ccBig ) idFirstP  = 0 ;_WQ
                }
            }
        }
    }

    if( pstMatchP )
    {
        if( idHit )
        {
            if( F(flagsMatchP) & flSTRmATCH_OUTERmOST )
            {
                ZE( strokeS* , psttm ) ;
                countT idf = idHit ;
                countT idl = idFirstP ? idFirstP - 1 : 0 ;
                strSubstringF( tinP , psttm , idf , idl , psttBigP ) ; ___( psttm ) ;
                *pstMatchP << psttm ; psttm = 0 ;
            }
        }
        else pstMatchP->purgeF( tinP , cPlatesWas ) ;
    }
    return idHit ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002053.etherc.stridf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002054.etherc.stridanyf BEGIN
#define DDNAME       "3func.36002054.etherc.stridanyf"
#define DDNUMB      (countT)0x36002054
#define IDFILE      (countT)0xc7b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strIdAnyF.0.html\"\>instances\</A\>
\<A HREF=\"5.103005e.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.b910104.1.1.0.html\"\>b910104:  WAKEsHOW( "example.simplest.func.103005e.etherC.strIdAnyF" )\</A\>
evaluates to the id in psttBigP of the first occurance of a stroke that is in psttSmallP
idFirstP will point to the stroke after the ones found
skips over quoted strokes when searching for the first match
initialize sttQuoteP to the quote state at idFirstP
 sttQuoteP is either 0 or contains the last quote mark encountered
 see doc for strIsInQuoteF for notes on which quote marks are recognized
 see doc for strIsInQuoteF for notes on how sttQuoteP is set at the beginning and at the end of a quote
arguments
 idFirstP
 sttQuoteP
 psttSmallP
  this string can include a null stroke
  this can also be null, or a null length string
   behavior is identical to that of a unit length string containing a null stroke
 psttBigP
 idLastP
  can be 0
  if 0 then the search is over the entire psttBigP string
  if not 0 then only the strokes between idFirstP and idLastP inclusive are inspected
*/
/**/

/*1*/countT etherC::strIdAnyF( tinS& tinP , stackC* const pstMatchP , const flagsT flagsMatchP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* psttSmallP , const strokeS* psttBigP , const countT idLastP , sCountT idP , const flagsT flagsP )/*1*/
{
    SCOOP
    const boolT bUseQuotes = sttQuoteP.idCaste != sc_IGNOREqUOTES ;_WQ

    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttBigP ) ;_WQ
        __Z( idFirstP ) ;_WQ
        __( idFirstP == 1 && (countT)sttQuoteP && bUseQuotes ) ;_WQ
        __Z( idP ) ;_WQ
        FV( flSTRiDaNY , flagsP ) ;_WQ
        if( POOP ) return 0 ;
        __( psttBigP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        __( psttSmallP && psttSmallP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( pstMatchP )
        {
            __( F( pstMatchP->flagsF( tinP ) ) & flSTACKc_FIFO ) ; // IF FIFO THEN WILL CONTAIN INCORRECT CONTENTS
        }
        if( POOP ) return 0 ;
    }

    _IO_

    const boolT bNot = F(flagsP) & flSTRiDaNY_NOT ;_WQ

    STRiDrECURSE( strIdAnyF( tinP , pstMatchP , flagsMatchP , idf , sttQuoteP , psttSmallP , psttBigP , idLastP , 1 , flagsP ) )
    {
        const strokeS psttOneNull[] = { strokeS() , strokeS() , strokeS() , strokeS() } ;_WQ
        SETpREFIX( (strokeS*)psttOneNull , 1 , 0 ) ;_WQ
        const strokeS* const psttSmall = ( psttSmallP && psttSmallP->idAdam ) ? psttSmallP : psttOneNull ;_WQ
    
        if( !POOP )
        {
            countT ccBig   = idLastP && idLastP < psttBigP->idAdam ? idLastP : psttBigP->idAdam ;_WQ
    
            if( idFirstP > ccBig ) idFirstP = 0 ;
            else
            {
                if( !POOP )
                {
                    for( idHit = idFirstP ; idHit <= ccBig ; idHit ++ )
                    {
                        ZE( boolT , bInQuote ) ;_WQ
                        if( bUseQuotes ) bInQuote = strIsInQuoteF( tinP , sttQuoteP , idHit , psttBigP ) ;_WQ

                        boolT bHit = bNot
                            ? !strIdF( tinP , psttBigP[ CSpREFIX - 1 + idHit ] , psttSmall )
                            :  strIdF( tinP , psttBigP[ CSpREFIX - 1 + idHit ] , psttSmall )
                        ;_WQ

                        if( ( !bUseQuotes || !bInQuote ) && bHit ) break ;
                    }
    
                    if( idHit > ccBig ) idHit = 0 ;
                    else if( bNot )
                    {
                        idFirstP = idHit + 1 ;_WQ
                        while( idFirstP <= ccBig && !strIdF( tinP , psttBigP[ CSpREFIX - 1 + idFirstP ] , psttSmall ) ) idFirstP ++ ;_WQ
                    }
                    else
                    {
                        idFirstP = idHit + 1 ;_WQ
                        while( idFirstP <= ccBig &&  strIdF( tinP , psttBigP[ CSpREFIX - 1 + idFirstP ] , psttSmall ) ) idFirstP ++ ;_WQ
                    }

                    if( !idHit || idFirstP > ccBig ) idFirstP  = 0 ;_WQ
                }
            }
        }
    }
    return idHit ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002054.etherc.stridanyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002055.etherc.strisinquotef BEGIN
#define DDNAME       "3func.36002055.etherc.strisinquotef"
#define DDNUMB      (countT)0x36002055
#define IDFILE      (countT)0xc7c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strIsInQuoteF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030060.1.0.html\"\>definition\</A\>
evaluates to 1 iff the stroke at idP is within a quote
updates sttQuoteP to contain either a null stroke or the most recent quote stroke encountered
must be called consecutively for idP = 1,2,3,...
do not modify sttQuoteP between calls
matches pairs of double quotes
single quotes are not treated as quote delimiters
to match, both quote marks must be of the same caste
the opening and closing quote strokes are not in the quote
unmatching quote marks within a quote are treated as literals, i.e. ignored
 this function will not check for, and cannot correctly process, nested quotes using the same quote mark
 this function will not check for, but will correctly process, nested quotes that use distinct quote marks
  nesting more than one level requires making the quote marks unique by varying idCaste
arguments
 sttQuoteP
 idP
 psttP
*/
/**/

/*1*/boolT etherC::strIsInQuoteF( tinS& tinP , strokeS& sttQuoteP , const countT idP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( idP ) ;
        __Z( psttP ) ;
        if( POOP ) return 0 ;
        __( psttP->idCaste != sc_PREFIXlENGTH ) ;
        __( psttP->idAdam < idP ) ;
        if( POOP ) return 0 ;
    }

    ZE( boolT , bLiteral ) ; //TREATS QUOTE MARK AS LITERAL IF IT IS PRECEDED BY NONLITERAL BACKSLASH
    if
    (
        psttP[ CSpREFIX - 1 + idP ] == S2( '\"' , sc_cALPHABET1 )
        ||
        psttP[ CSpREFIX - 1 + idP ] == S2( '\"' , sc_cFROMaSCII )
    )
    {
        countT idc = idP ;
        while
        (
            1 < idc
            &&
            (
                psttP[ CSpREFIX - 2 + idc ] == S2( '\"' , sc_cALPHABET1 )
                ||
                psttP[ CSpREFIX - 2 + idc ] == S2( '\"' , sc_cFROMaSCII )
                ||
                psttP[ CSpREFIX - 2 + idc ] == S2( '\\' , sc_cALPHABET1 )
                ||
                psttP[ CSpREFIX - 2 + idc ] == S2( '\\' , sc_cFROMaSCII )
            )
        )
        idc -- ;

        // idc NOW POINTS TO THE WOTH STROKE IN THE RUN OF BACKSLASHES AND DOUBLE QUOTES
        for( ; idc < idP ; idc ++ )
        {
            if( bLiteral ) bLiteral = 0 ;
            else if
            (
                psttP[ CSpREFIX - 1 + idc ] == S2( '\\' , sc_cALPHABET1 )
                ||
                psttP[ CSpREFIX - 1 + idc ] == S2( '\\' , sc_cFROMaSCII )
            )
            bLiteral = 1 ;
        }
    }

    _IO_

    boolT bInQuote = !!(countT)sttQuoteP ;

    if
    (
        !bLiteral
        &&
        (
            psttP[ CSpREFIX - 1 + idP ] == S2( '\"' , sc_cALPHABET1 ) // THERE IS A DOUBLE QUOTE
            ||
            psttP[ CSpREFIX - 1 + idP ] == S2( '\"' , sc_cFROMaSCII ) // THERE IS A DOUBLE QUOTE
        )
    )
    {
        if( !(countT)sttQuoteP ) sttQuoteP = psttP[ CSpREFIX - 1 + idP ] ;
        else
        {
            sttQuoteP = 0 ;
            bInQuote = 0 ;
        }
    }

    return bInQuote ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002055.etherc.strisinquotef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002056.etherc.strbodylengthf BEGIN
#define DDNAME       "3func.36002056.etherc.strbodylengthf"
#define DDNUMB      (countT)0x36002056
#define IDFILE      (countT)0xc7d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strBodyLengthF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030061.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.d910104.1.1.0.html\"\>d910104:  WAKEsHOW( "example.simplest.func.1030061.etherC.strBodyLengthF" )\</A\>
arguments
 postP
*/
/**/

/*1*/countT etherC::strBodyLengthF( tinS& tinP , const osTextT* postP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    //INOUT NOT USED, TO AVOID BLOWING STACK DURING INOUT TRACE
    //_IO_
    ZE( countT , cc ) ;_WQ
    if( !POOP ) __Z( postP ) ;_WQ

    if( !POOP )
    {
        while( !strFEndF( tinP , postP ) )
        {
            cc ++ ;_WQ
            postP ++ ;_WQ
        }
    }
    return cc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002056.etherc.strbodylengthf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002057.etherc.ifcraceidf BEGIN
#define DDNAME       "3func.36002057.etherc.ifcraceidf"
#define DDNUMB      (countT)0x36002057
#define IDFILE      (countT)0xc7e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcRaceIdF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030062.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
 U: write an example for this once races are supported
resets counters after writing datum containing them
to run a race, call this function twice
 first, call it with a pcRaceIdP value that you make up (not null)
 then, execute the code that you want to collect time information about
 then call this function again
  if pcRaceidP is null then the statistics will be sent to city center and no new race will be begun
  if pcRaceIdP is not null then statistics will be sent and a new race will be begun immediately
   it would not normally make sense to specify the same pcRaceIdP value in both calls
this function does not execute prolog and epilog overhead code
counter values will be inconsistent if they are being incremented while this function is being evaluated
 for max speed when updating counters, this function is not serialized w.r.t. the code that updates timing counters
the part number of the datum is { 0x1030062 , 1 , 1 + F(flagsWatch) & flWATCH_EMPLOYERS } followed by pcRaceIdP
arguments
 tinP
 pcRaceIdP
  the current race is ended by flushing race totals to city center and a new race is begun
  can be 0
  if 0 then this etherC object becomes untimed
  if not 0 then pcRaceIdP[ 0 ] must be nonze
   for maximum speed, this is not enforced
*/
/**/

/*1*/voidT etherC::ifcRaceIdF( tinS& tinP , const countT* const pcRaceIdP )/*1*/
{
    SCOOP
    BLAMMO ; //U:: REDESIGN THIS SUBSYSTEM
    if( tinP.fingerprint && pcRaceIdP ) ;

#if defined( NEVERdEFINED )

    //IFbEcAREFUL
    //{
    //    if( POOP ) return ;
    //    __( pcRaceIdP && !*pcRaceIdP ) ;
    //    if( POOP ) return ;
    //}

    //IN_E

    const countT cSourceFiles = processGlobal7I.source.cFilesF( tinP ) ;
    if( pcRaceId )
    {
        ZE( countT* , pcRace ) ;
        newF( tinP , LF , pcRace , ( 1 + cSourceFiles ) * 5 ) ; ___( pcRace ) ;
        countT* pcRaceFun = pcRace ? pcRace + 5 : 0 ;
        ZE( countT , cActive ) ;

        for( countT idFile = 1 ; idFile <= cSourceFiles ; idFile ++ )
        {
            if( !third.pcFunctionEntries[ idFile ] ) continue ;

            cActive ++ ;

            pcRaceFun[ 0 ] = idFile ;
            pcRaceFun[ 1 ] = third.pcFunctionEntries[ idFile ] ;
            pcRaceFun[ 2 ] = third.pcFunctionExits[   idFile ] ;
            pcRaceFun[ 3 ] = third.pcFunctionTime1[   idFile ] ;
            pcRaceFun[ 4 ] = third.pcFunctionTime2[   idFile ] ;

            pcRaceFun += 5 ;
        }

        pcRaceFun = pcRace ? pcRace + 5 : 0 ;
        for( countT ida = 1 ; ida <= cActive ; ida ++ ) // WE DO THIS SEPARATELY SO processGlobal7I.source.idFileImmutableF IS NOT INCLUDED IN DATA
        {
            *pcRaceFun = processGlobal7I.source.idFileImmutableF( tinP , *pcRaceFun ) ;
            pcRaceFun += 5 ;
        }

        if( cActive ) // KEEP THIS CODE IN SYNC WITH 3f30104
        {
            ZE( countT* , pcPart ) ;
            countT ccRaceId = strBodyLengthF( tinP , pcRaceId ) ;
            newF( tinP , LF , pcPart , 4 + ccRaceId ) ; ___( pcPart ) ;
            if( pcPart )
            {
                pcPart[ 0 ] = 0x2600301 ;
                pcPart[ 1 ] = 1 ;
                pcPart[ 2 ] = 1 + !!( F(flagsWatch) & flWATCH_EMPLOYERS ) ;
                memCopyF( tinP , (byteT*)( pcPart + 3 ) , (byteT*)pcRaceId , sizeof( countT ) * ( ccRaceId + 1 ) ) ;
            }

            ifcDatumF( tinP , flDATUM1_CLASStIMER , flDATUM2_countT , cActive , pcPart , (byteT*)( pcRace + 5 ) , cActive * 5 * sizeof( countT ) ) ;
            delF( tinP , pcPart ) ;
        }
        delF( tinP , pcRace ) ;
    }
    delF( tinP , pcRaceId ) ;

    if( pcRaceIdP )
    {
        countT ccRaceId = strBodyLengthF( tinP , pcRaceIdP ) ;
        newF( tinP , LF , pcRaceId , ccRaceId + 1 ) ; ___( pcRaceId ) ;
        memCopyF( tinP , (byteT*)pcRaceId , (byteT*)pcRaceIdP , sizeof( countT ) * ( ccRaceId + 1 ) ) ;

        for( countT idFile = 1 ; idFile <= cSourceFiles ; idFile ++ )
        {
            third.pcFunctionEntries[ idFile ] = 0 ;
            third.pcFunctionExits[   idFile ] = 0 ;
            third.pcFunctionTime1[   idFile ] = 0 ;
            third.pcFunctionTime2[   idFile ] = 0 ;
        }
    }

    //OUT

#endif
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002057.etherc.ifcraceidf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002058.etherc.strmakefromostextf BEGIN
#define DDNAME       "3func.36002058.etherc.strmakefromostextf"
#define DDNUMB      (countT)0x36002058
#define IDFILE      (countT)0xc7f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strMakeFromOsTextF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030063.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.4830104.1.1.0.html\"\>4830104:  WAKEsHOW( "example.simplest.func.1030063.etherC.strMakeFromOsTextF" )\</A\>
for maximum speed, this function omits some standard code
 the standard overhead code is omitted
 this function will generate an access violation exception if it cannot get an allocation from the poolOld
arguments
 psttP
 postP
  must not be 0
  points to a string that can contain nulls iff costP is not 0
  if costP is 0 then postP is treated as a pointer to a null terminated string
 costP
 csttExtraP
*/
/**/

/*1*/voidT etherC::strMakeFromOsTextF( tinS& tinP , strokeS*& psttP , const osTextT* const postP , const countT costP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;_WQ
        __Z( postP ) ;_WQ
    }

    // _IO_
    ZE( countT , csttLength ) ;_WQ
    { POOPIES csttLength = costP ? costP : thirdC::c_strlenIF( tinP , postP ) ; }
    third.newF( tinP , LF , psttP , CSpREFIX + csttLength + csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;_WQ
    if( psttP )
    {
        SETpREFIX( psttP , csttLength , csttExtraP ) ;_WQ
        for( countT off = 0 ; off < csttLength ; off ++ ) psttP[ CSpREFIX + off ] = postP[ off ] ;_WQ
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002058.etherc.strmakefromostextf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002059.etherc.strmakef BEGIN
#define DDNAME       "3func.36002059.etherc.strmakef"
#define DDNUMB      (countT)0x36002059
#define IDFILE      (countT)0xc80


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strMakeF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030064.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f910104.1.1.0.html\"\>f910104:  WAKEsHOW( "example.simplest.func.1030064.etherC.strMakeF" )\</A\>
arguments
 postP
  must be 0
 psttP
  can be 0
  is normally not 0 except when i am being called to preallocate
*/
/**/

/*1*/countT etherC::strMakeF( tinS& tinP , const countT idLineP , const countT idiFileP , osTextT*& postP , const strokeS* const psttP , const countT costExtraP , const flagsT flagsP , const countT cbPrefixExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( postP ) ;_WQ
        FV(flSTRmAKE,flagsP)
        __( F(flagsP) & flSTRmAKE_PREFIXbASErEFc && !( F(flagsP) & flSTRmAKE_INTERNALuSEoNLY ) ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( countT , cLength ) ;_WQ
    ZE( countT , cNotUsed ) ;_WQ
    boolT bLength  = !!( F(flagsP) & flSTRmAKE_PREFIXlENGTH   ) ;_WQ
    boolT bBaseRef = !!( F(flagsP) & flSTRmAKE_PREFIXbASErEFc ) ;_WQ
    if( !POOP )
    {
        if( psttP ) GETpREFIX( cLength , cNotUsed , psttP ) ;_WQ

        const countT costa = cbPrefixExtraP + ( bLength + bBaseRef ) * sizeof( countT ) + cLength + 1 + costExtraP ;_WQ
        third.newF( tinP , idLineP , idiFileP , postP , costa ) ; ___LF( postP , idLineP , idiFileP ) ;_WQ
    }

    ZE( countT , cNull ) ;_WQ
    if( postP )
    {
        osTextT* postc = postP ;_WQ

        if( cbPrefixExtraP )
        {
            thirdC::c_memsetIF( tinP , postc , cbPrefixExtraP ) ;_WQ
            postc += cbPrefixExtraP ;_WQ
        }

        if( bBaseRef ) { *(countT*)postc = 0       ; postc += sizeof( countT ) ; } //cRef OBJECT, INITIALIZED TO 0 (FORMAT A VALID refCounterC IMAGE)
        if( bLength  ) { *(countT*)postc = cLength ; postc += sizeof( countT ) ; }

        for( countT offi = 0 ; offi < cLength ; offi ++ )
        {
            osTextT bv = psttP[ CSpREFIX + offi ] ;_WQ
            if( bv ) *( postc ++ ) = bv ;
            else     cNull ++ ;_WQ
        }
        *( postc ++ ) = 0 ;_WQ
    }

    return cLength - cNull ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002059.etherc.strmakef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600205a.etherc.strmakef BEGIN
#define DDNAME       "3func.3600205a.etherc.strmakef"
#define DDNUMB      (countT)0x3600205a
#define IDFILE      (countT)0xc81


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strMakeF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030065.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.0a10104.1.1.0.html\"\>0a10104:  WAKEsHOW( "example.simplest.func.1030065.etherC.strMakeF" )\</A\>
arguments
 psttOutP
 psttInP
 csttExtraP
*/
/**/

/*1*/voidT etherC::strMakeF( tinS& tinP , const countT idLineP , const countT idiFileP , strokeS*& psttOutP , const strokeS* const psttInP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttOutP ) ;_WQ
        if( POOP ) return ;
    }

    _IO_

    ZE( countT , cLength ) ;_WQ
    ZE( countT , cNotUsed ) ;_WQ
    if( psttInP ) GETpREFIX( cLength , cNotUsed , psttInP ) ;_WQ
    third.newF( tinP , idLineP , idiFileP , psttOutP , CSpREFIX + cLength + csttExtraP ) ; ___LF( psttOutP , idLineP , idiFileP ) ;

    if( psttOutP )
    {
        SETpREFIX( psttOutP , cLength , csttExtraP ) ;_WQ
        const countT offEnd = CSpREFIX + cLength ;_WQ
        for( countT off = CSpREFIX ; off < offEnd ; off ++ ) psttOutP[ off ] = psttInP[ off ] ;_WQ
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600205a.etherc.strmakef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600205b.etherc.strsubstringf BEGIN
#define DDNAME       "3func.3600205b.etherc.strsubstringf"
#define DDNUMB      (countT)0x3600205b
#define IDFILE      (countT)0xc82


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


/*
\<A HREF=\"6.$strSubstringF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030066.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1a10104.1.1.0.html\"\>1a10104:  WAKEsHOW( "example.simplest.func.1030066.etherC.strSubstringF" )\</A\>
arguments
 psttP
  can be 0
   will be allocated from the pool
  if not 0 then result will be appended
   must have sufficient capacity
 idFirstP
  must not be ze
  this is usually set to 1 when drawing the first substring from a string
  if there aren't enough strokes in psttBigP, psttP will receive T("") and impotence will not occur
 idLastP
  can be 0
  if 0 then the end of psttBigP is implied
  if not 0 then must not be less than idFirstP
 psttBigP
 csttExtraP
*/
/**/

/*1*/voidT etherC::strSubstringF( tinS& tinP , strokeS*& psttP , countT& idFirstP , countT& idLastP , const strokeS* psttBigP , const countT csttExtraP )/*1*/
{
    SCOOP
    //ON RETURNING, idFirstP WILL POINT TO THE STROKE AFTER THE ONES FOUND
    //ON RETURNING, idLastP WILL POINT IMPLY AN EQUAL LENGTH STRING, SHORTENED IF NECESSARY TO FIT WITHIN psttBigP

    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttBigP ) ;_WQ
        __Z( idFirstP ) ;_WQ
        __( idLastP && idFirstP > idLastP ) ;_WQ
        if( POOP ) return ;
        __( psttBigP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return ;
    }

    _IO_

    countT csttBig = psttBigP->idAdam ;_WQ
    if( csttBig < idFirstP ) idFirstP = 0 ;
    else
    {
        if( !idLastP ) idLastP = csttBig ;_WQ
        __( idLastP > csttBig ) ;_WQ
        __( idFirstP > idLastP ) ;_WQ
        countT csttCopy = idLastP - idFirstP + 1 ;_WQ
    
        countT csttBefore = psttP ? psttP->idAdam : 0 ;_WQ
        if( psttP )
        {
            __( psttP[ 2 ].idAdam < csttCopy ) ;_WQ
            if( !POOP )
            {
                psttP[ 0 ].idAdam += csttCopy ;_WQ
                psttP[ 2 ].idAdam -= csttCopy ;_WQ
            }
        }
        else
        {
            countT csNew = CSpREFIX + csttCopy + csttExtraP ;_WQ
            third.newF( tinP , LF , psttP , csNew ) ; // CALLER MUST TAG ___( psttP ) ;_WQ

            if( psttP ) { SETpREFIX( psttP , csttCopy , csttExtraP ) ; }
        }
        __Z( psttP ) ;    

        if( !POOP )
        {
            for( countT offi = 0 ; offi < csttCopy ; offi ++ ) psttP[ CSpREFIX + csttBefore + offi ] = psttBigP[ CSpREFIX + idFirstP - 1 + offi ] ;_WQ
            idFirstP = idLastP + 1 ;_WQ
            if( idFirstP > csttBig ) idFirstP = idLastP = 0 ;
            else
            {
                idLastP = idFirstP - 1 + csttCopy ;_WQ
                if( idLastP > csttBig ) idLastP = csttBig ;_WQ
            }
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600205b.etherc.strsubstringf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600205c.etherc.strsubstringf BEGIN
#define DDNAME       "3func.3600205c.etherc.strsubstringf"
#define DDNUMB      (countT)0x3600205c
#define IDFILE      (countT)0xc83


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strSubstringF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030067.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.2a10104.1.1.0.html\"\>2a10104:  WAKEsHOW( "example.simplest.func.1030067.etherC.strSubstringF" )\</A\>
i evaluate to bFound, indicating whether i found a delimiter
idFirstP will be set to point to the char after the delimiter, or 0 if no delimiter is found or if the delimiter is the last char
arguments
 psttP
 idFirstP
  if there aren't enough strokes in psttBigP, psttP will receive T("") and impotence will not occur
 sttQuoteP
 sttSmallP
 psttBigP
 csttExtraP
*/
/**/

/*1*/boolT etherC::strSubstringF( tinS& tinP , strokeS*& psttP , countT& idFirstP , strokeS& sttQuoteP , const strokeS& sttSmallP , const strokeS* psttBigP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( psttP ) ;_WQ
        __Z( psttBigP ) ;_WQ
        __( !(countT)sttSmallP ) ;_WQ
        __Z( idFirstP ) ;_WQ
        if( POOP ) return 0 ;
        __( psttBigP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( boolT , bFound ) ;_WQ
    countT ccBig = psttBigP->idAdam ;_WQ
    if( ccBig < idFirstP )
    {
        strMakeF( tinP , LF , psttP , T("") ) ;_WQ
        idFirstP = 0 ;_WQ
    }
    else
    {
        countT idfSave = idFirstP ;_WQ
        countT idd = strIdF( tinP , idFirstP , sttQuoteP , sttSmallP , psttBigP ) ;_WQ
        bFound = !!idd ;_WQ
        countT idLathI = idd - 1 ;_WQ

             if( idd && idd == idfSave ) strMakeF(      tinP , LF , psttP                                , T("")    , csttExtraP ) ;
        else if( idd                   ) strSubstringF( tinP , psttP , idfSave , idLathI , psttBigP , csttExtraP ) ;
        else                             strSubstringF( tinP , psttP , idfSave , ccBig   , psttBigP , csttExtraP ) ;
    }
    return bFound ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600205c.etherc.strsubstringf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600205d.etherc.strsubstringf BEGIN
#define DDNAME       "3func.3600205d.etherc.strsubstringf"
#define DDNUMB      (countT)0x3600205d
#define IDFILE      (countT)0xc84


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strSubstringF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030068.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.3a10104.1.1.0.html\"\>3a10104:  WAKEsHOW( "example.simplest.func.1030068.etherC.strSubstringF" )\</A\>
  \<A HREF=\"5.4a10104.1.1.0.html\"\>4a10104:  WAKEsHOW( "example.simplest.func.1030068.etherC.strSubstringF" )\</A\>
i evaluate to bFound, indicating whether i found a delimiter
idFirstP will be set to point to the stroke after the delimiter string
if no delimiter is found, idFirstP will be set to 0
if the delimiter is at the end of the string, idFirstP will be set to 0
arguments
 psttP
 idFirstP
  if there aren't enough strokes in psttBigP, psttP will receive T("") and impotence will not occur
 sttQuoteP
 psttSmallP
 psttBigP
 bAnyP
 csttExtraP
*/
/**/

/*1*/boolT etherC::strSubstringF( tinS& tinP , strokeS*& psttP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* psttSmallP , const strokeS* psttBigP , const boolT bAnyP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( psttP ) ;_WQ
        __Z( psttBigP ) ;_WQ
        __Z( psttSmallP ) ;_WQ
        __Z( idFirstP ) ;_WQ
        if( POOP ) return 0 ;
        __( !psttSmallP->idAdam ) ;_WQ
        __( psttBigP->idCaste   != sc_PREFIXlENGTH ) ;_WQ
        __( psttSmallP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( boolT , bFound ) ;_WQ
    countT ccBig = psttBigP->idAdam ;_WQ
    if( ccBig < idFirstP )
    {
        strMakeF( tinP , LF , psttP , T("") ) ; // CALLER MUST TAG
        idFirstP = 0 ;_WQ
    }
    else
    {
        countT idfSave = idFirstP ;_WQ
        ZE( countT , idd ) ;_WQ
        if( bAnyP ) idd = strIdAnyF( tinP , 0 , flSTRmATCH_null , idFirstP , sttQuoteP , psttSmallP , psttBigP ) ;
        else        idd =    strIdF( tinP , 0 , flSTRmATCH_null , idFirstP , sttQuoteP , psttSmallP , psttBigP ) ;_WQ
        bFound = !!idd ;_WQ
        countT idLathI = idd - 1 ;_WQ

                  if( idd && idd == idfSave ) { strMakeF(      tinP , LF , psttP , T("")                        , csttExtraP ) ; }
             else if( idd                   ) { strSubstringF( tinP , psttP , idfSave , idLathI , psttBigP , csttExtraP ) ; }
             else                             { strSubstringF( tinP , psttP , idfSave , ccBig  , psttBigP  , csttExtraP ) ; }
    }
    return bFound ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600205d.etherc.strsubstringf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600205e.etherc.struniquef BEGIN
#define DDNAME       "3func.3600205e.etherc.struniquef"
#define DDNUMB      (countT)0x3600205e
#define IDFILE      (countT)0xc85


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strUniqueF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030069.1.0.html\"\>definition\</A\>
i produce a string that is certain to be unique on this host and is likely to be globally unique
coding style: do not assume that this string will be any particular length
examples
 simplest
  \<A HREF=\"5.5a10104.1.1.0.html\"\>5a10104:  WAKEsHOW( "example.simplest.func.1030069.etherC.strUniqueF" )\</A\>
arguments
 psttP
*/
/**/

//U: REWRITE THIS TO USE FOREIGN DIGIT ORDERING AND TO EXPLOIT ALL APPLICABLE flFORMAT FLAGS (E.G. FILLzE)

/*1*/voidT etherC::strUniqueF( tinS& tinP , strokeS*& psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , psttTime ) ;
    {
        ZE( countT , time1 ) ;
        ZE( sCountT , time2 ) ;
        osTimeNowF( tinP , time1 , time2 ) ;

        //strFromTimeF( tinP , psttTime , time1 , time2 , 1 , 8 , S1C('.') , 0 , ifcIDfORMATtIME_NUMERIC , flFORMAT_FOREIGN ) ; //U::BUG: 20150913@1627: OBSERVED TO BE NONMONOTONIC

        strMakeF( tinP , LF , psttTime , TF3((countT)time2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(".")+TF3(time1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( psttTime ) ;
    }

    countT cid = diskIdF( tinP , T("///c") ) ;
    countT pid = osProcessIdF( tinP ) ;
    countT tid = osThreadIdF( tinP ) ;

    TN( tDot , "." ) ;
    TN( tAll , "" ) ; tAll =

        T(psttTime)
        +tDot+TF3(cid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
        +tDot+TF3(pid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
        +tDot+TF3(tid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)

    ;
    delF( tinP , psttTime ) ;
    strMakeF( tinP , LF , psttP , tAll ) ; // CALLER MUST TAG ___( psttP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600205e.etherc.struniquef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600205f.etherc.strurldecodef BEGIN
#define DDNAME       "3func.3600205f.etherc.strurldecodef"
#define DDNUMB      (countT)0x3600205f
#define IDFILE      (countT)0xc86


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strUrlDecodeF.0.html\"\>instances\</A\>
\<A HREF=\"5.103006a.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
disabled.  do not use.  the definition of this function is obsolete
arguments
 psttOutP
 psttInP
*/
/**//*1*/voidT etherC::strUrlDecodeF( tinS& tinP , strokeS*& psttOutP , strokeS* psttInP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z(  psttInP ) ;
        __NZ(  psttOutP ) ;
        __( !!strFEndF( tinP , psttInP ) ) ;
        if( POOP ) return ;
    }

    _IO_

    if( !POOP )
    {
        countT csIn = psttInP->idAdam ;
        third.newF( tinP , LF , psttOutP , CSpREFIX + csIn ) ; // CALLER MUST TAG ___( psttOutP ) ;
        ZE( countT , offo ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        for( countT off = 0 ; off < csIn ; off ++ )
        {
                 if( psttInP[ CSpREFIX + off ].idCaste != sc_cFROMaSCII ) psttOutP[ CSpREFIX + offo ++ ] = psttInP[ CSpREFIX + off ] ;
            else if( psttInP[ CSpREFIX + off ].idAdam == '+'          ) psttOutP[ CSpREFIX + offo ++ ] = ' ' ;
            else if( psttInP[ CSpREFIX + off ].idAdam == '%'          )
            {
                strokeS psttHex[ CSpREFIX + 2 ] ;
                SETpREFIX( psttHex , 2 , 0 ) ;
                psttHex[ CSpREFIX     ] = psttInP[ CSpREFIX + 1 + off ] ;
                psttHex[ CSpREFIX + 1 ] = psttInP[ CSpREFIX + 2 + off ] ;
                strConvertToLowerCaseF( tinP , psttHex ) ;
                psttOutP[ CSpREFIX + offo ++ ] = strDigitsToSCountF( tinP , psttHex , 0x10 , 1 ) ;
                off += 2 ;
            }
            else                                                        psttOutP[ CSpREFIX + offo ++ ] = psttInP[ CSpREFIX + off ] ;
        }
        SETpREFIX( psttOutP , offo , 0 ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600205f.etherc.strurldecodef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002060.etherc.strurldecodef BEGIN
#define DDNAME       "3func.36002060.etherc.strurldecodef"
#define DDNUMB      (countT)0x36002060
#define IDFILE      (countT)0xc87


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strUrlDecodeF.0.html\"\>instances\</A\>
\<A HREF=\"5.103006b.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 psttP
*/
/**//*1*/voidT etherC::strUrlDecodeF( tinS& tinP , strokeS*& psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    ZE( strokeS* , psttt ) ;
    psttt = psttP ;
    psttP = 0 ;
    strUrlDecodeF( tinP , psttP , psttt ) ; // CALLER MUST TAG
    third.delF( tinP , psttt ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002060.etherc.strurldecodef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002061.etherc.strurlnamef BEGIN
#define DDNAME       "3func.36002061.etherc.strurlnamef"
#define DDNUMB      (countT)0x36002061
#define IDFILE      (countT)0xc88


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strUrlNameF.0.html\"\>instances\</A\>
\<A HREF=\"5.103006c.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 psttNameP
  must be 0
 psttUrlP
  must not be 0
*/
/**//*1*/voidT etherC::strUrlNameF( tinS& tinP , strokeS*& psttNameP , const strokeS* psttUrlP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttNameP ) ;
        __Z( psttUrlP ) ;
        if( POOP ) return ;
    }

    _IO_
    strokeS s_colon( ':' ) ;
    countT idf = 1 ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( countT , idl ) ;
    strIdF( tinP , idf , sttq , s_colon , psttUrlP ) ;
    strSubstringF( tinP , psttNameP , idf , idl , psttUrlP ) ; // CALLER MUST TAG ___( psttNameP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002061.etherc.strurlnamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002062.etherc.strurlschemef BEGIN
#define DDNAME       "3func.36002062.etherc.strurlschemef"
#define DDNUMB      (countT)0x36002062
#define IDFILE      (countT)0xc89


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strUrlSchemeF.0.html\"\>instances\</A\>
\<A HREF=\"5.103006d.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 psttSchemeP
 psttUrlP
*/
/**//*1*/voidT etherC::strUrlSchemeF( tinS& tinP , strokeS*& psttSchemeP , const strokeS* psttUrlP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    strokeS s_colon( ':' ) ;
    countT idf = 1 ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    strSubstringF( tinP , psttSchemeP , idf , sttq , s_colon , psttUrlP ) ; // CALLER MUST TAG ___( psttSchemeP ) ;
    strConvertToLowerCaseF( tinP , psttSchemeP ) ;
    strUrlDecodeF( tinP , psttSchemeP ) ; ___( psttSchemeP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002062.etherc.strurlschemef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002063.etherc.poolnewf BEGIN
#define DDNAME       "3func.36002063.etherc.poolnewf"
#define DDNUMB      (countT)0x36002063
#define IDFILE      (countT)0xc8a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$po olNewF.0.html\"\>instances\</A\>
\<A HREF=\"5.103006e.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
 it is also illegal to use this function in ifc system code
  use poolC::p oolNewF instead
arguments
 tinP
 cP
*/
/**/

/*1*/voidT etherC::poolNewF( tinS& tinP , const countT idLineNewP , const countT idiFileNewP , byteT*& pbP , const countT cbP )/*1*/
{
    _IO_
    SCOOP
    PUSE.newF( tinP , idLineNewP , idiFileNewP , pbP , cbP ) ; ___( pbP ) ;
    if( !pbP )
    {
        __( cbP ) ;
        __1
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002063.etherc.poolnewf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002064.etherc.ossleepf BEGIN
#define DDNAME       "3func.36002064.etherc.ossleepf"
#define DDNUMB      (countT)0x36002064
#define IDFILE      (countT)0xc8b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osSleepF.0.html\"\>instances\</A\>
\<A HREF=\"5.103006f.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1510104.1.1.0.html\"\>1510104:  WAKEsHOW( "example.simplest.func.103006f.etherC.osSleepF" )\</A\>
takes naps of length timeGrainP each until have napped for timeP
checks for asynchronous impotence (etPrimeIF( tinP )) after each timeGrainP nap
returns early if impotence is detected
arguments
 timeP
  can be 0
   warning: value 0 can result in locking out lower priority threads in a multithreaded adam class
 timeGrainP
  the duration of each nap, during which this thread is really sleeping  
  if ze then timeP / 10 is used
  if ( F(flagsP) & flSLEEP_TALK ) then the displayed time is updated after each timeGrainP
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001004b.flSLEEP!||
*/
/**/

/*1*/voidT etherC::osSleepF( tinS& tinP , const countT timeP , const countT timeGrainP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP && this != &etPrimeIF( tinP ) ) { BLAMMO ; }  // PREVENTS CPU PEGGING; WILL GET BLAMMO INSTEAD

        if( POOP ) return ;
        FV( flSLEEP , flagsP ) ;_WQ
        if( POOP ) return ;
    }

    _IO_
    if( !( F(flagsMode) & flTHIRDmODE_TESTaUTO ) || F(flagsP) & flSLEEP_IGNORE_flTHIRDmODE_TESTaUTO || F(flagsMode) & flTHIRDmODE_TESTaUTOdOsLEEPS )
    {
        countT timeGrain = timeGrainP ;_WQ
        if( !timeGrain ) timeGrain = timeP / 0x10 ;_WQ
        if( timeGrain > timeP ) timeGrain = timeP ;_WQ
        if( !timeGrain ) timeGrain = 1 ;_WQ
        if( timeGrain > TOCK * 2 ) timeGrain = TOCK * 2 ;_WQ
        countT time = ( timeP / timeGrain ) * timeGrain ;_WQ

        if( !time )
        {
            sleepStartF( tinP ) ;_WQ
            third.dosSleepIF( tinP , 0 ) ;_WQ
            sleepEndF( tinP ) ;_WQ
        }
        else
        {
            while( !POOP && time )
            {
                time -= timeGrain ;_WQ
                if( F(flagsP) & flSLEEP_TALK )
                {
                    ZE( strokeS* , psttw ) ;_WQ
                    strFromTimeF( tinP , psttw , time , 0 ) ; ___( psttw ) ;_WQ
                    strokeF( tinP , T("\r")+S2(0,scOld_SYSmARK)+T(psttw) ) ;_WQ
                    delF( tinP , psttw ) ;_WQ
                }
                sleepStartF( tinP ) ;_WQ
                third.dosSleepIF( tinP , timeGrain ) ;_WQ
                sleepEndF( tinP ) ;_WQ
                if( F(flagsP) & flSLEEP_TALK ) strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT) ) ;_WQ
            }
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002064.etherc.ossleepf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002065.etherc.osthreadf BEGIN
#define DDNAME       "3func.36002065.etherc.osthreadf"
#define DDNUMB      (countT)0x36002065
#define IDFILE      (countT)0xc8c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osThreadF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030070.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.0510104.1.1.0.html\"\>0510104:  WAKEsHOW( "example.simplest.func.1030070.etherC.osThreadF" )\</A\>
arguments
 tidP
 tmFP
  this symbol must be defined using the TASK macro
   example: TASK( tmF )
 pSgnDoneP
 cbStackP
 flagsP
 c1P
 c2P
 c3P
 c4P
 c5P
 c6P
 c7P
 c8P
*/
/**/

/*1*/voidT etherC::osThreadF( tinS& tinP , countT& tidP , voidT* const tmFP , signC* const pSgnDoneP , const flagsT flagsP , const countT cbStackP , const countT c1P , const countT c2P , const countT c3P , const countT c4P , const countT c5P , const countT c6P , const countT c7P , const countT c8P )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) { if( pSgnDoneP ) pSgnDoneP->giveF( tinP ) ; return ; }
        __( cbStackP && cbStackP < 1024 ) ;
        FV( flTHREADlAUNCH , flagsP ) ;
        if( POOP ) { if( pSgnDoneP ) pSgnDoneP->giveF( tinP ) ; return ; }
    }

    _IO_
    third.osThreadF( tinP , tidP , tmFP , pSgnDoneP , flagsP , cbStackP , c1P , c2P , c3P , c4P , c5P , c6P , c7P , c8P ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002065.etherc.osthreadf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002066.etherc.ostimesubtractf BEGIN
#define DDNAME       "3func.36002066.etherc.ostimesubtractf"
#define DDNUMB      (countT)0x36002066
#define IDFILE      (countT)0xc8d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osTimeSubtractF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030071.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.2510104.1.1.0.html\"\>2510104:  WAKEsHOW( "example.simplest.func.1030071.etherC.osTimeSubtractF" )\</A\>
arguments
 time11P
 time12P
 time21P
 time22P
*/

//DON'T USE _ IN HERE (WILL BLOW STACK)

/**//*1*/voidT etherC::osTimeSubtractF( tinS& tinP , countT& time11P , sCountT& time12P , const countT time21P , const sCountT time22P )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.osTimeSubtractF( tinP , time11P , time12P , time21P , time22P ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002066.etherc.ostimesubtractf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002067.etherc.diskselectf BEGIN
#define DDNAME       "3func.36002067.etherc.diskselectf"
#define DDNUMB      (countT)0x36002067
#define IDFILE      (countT)0xc8e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskSelectF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030073.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 psttDriveNameP
  this can be a drive name or a full file name
  if it is a full file name, only the drive portion is used
  example: T("///c")
  example: T("///c" "/tmp/fooey")
  example: T("///ideafarm")
  example: T("///ideafarm/ephemeral/tmp/1030073/fooey")
*/
/**//*1*/voidT etherC::diskSelectF( tinS& tinP , const strokeS* const psttDriveNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    if( !POOP ) __Z( psttDriveNameP ) ;
    ZE( strokeS* , pstt ) ;
    diskMapFileNameF( tinP , pstt , psttDriveNameP ) ; ___( pstt ) ; //U: DOES THIS MAKE SENSE TO DO?
    ZE( osTextT* , post ) ;
    strMakeF( tinP , LF , post , pstt ) ; ___( post ) ;
    third.delF( tinP , pstt ) ;
    third.dosSetDefaultDiskF( tinP , post ) ;
    third.delF( tinP , post ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002067.etherc.diskselectf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002068.etherc.diskhoverf BEGIN
#define DDNAME       "3func.36002068.etherc.diskhoverf"
#define DDNUMB      (countT)0x36002068
#define IDFILE      (countT)0xc8f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskHoverF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030074.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 psttP
*/
/**//*1*/voidT etherC::diskHoverF( tinS& tinP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
        __( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam - '/' ) ;
        __( psttP->idCaste != sc_PREFIXlENGTH ) ;
        if( POOP ) return ;
    }

    _IO_
    {
        // SET CURRENT DIRECTORY ON THE TARGET DISK
        // NOTE: ON NT THIS WILL ALSO SET THE CURRENT DISK
        ZE( strokeS* , pstt ) ;
        diskMapFileNameF( tinP , pstt , psttP ) ; ___( pstt ) ;
        diskMakeDirIfNeededF( tinP , pstt ) ;
        diskMakeDirF( tinP , pstt ) ;
        ZE( osTextT* , post ) ;
        strMakeF( tinP , LF , post , pstt ) ; ___( post ) ;
        if( !POOP )
        {
            third.dosSetCurrentDirIF( tinP , osFileNameC( tinP , third , post ) ) ;
            if( POOP )
            {
                countT ecSave = third ;
                third = 0 ; 
                countT pcPart[] = { 1 , 1 , 3 , 1 , 0 } ; 
                //U: ifcDatumF( tinP , flDATUM1_CLASSeXCEPTIONjOURNAL ,  flDATUM2_osTextT , 1 , pcPart , post ) ;
                __( ecSave ) ;
            }
        }
        third.delF( tinP , post ) ;

        #ifdef __OS2__
            if( pstt )
            {
                // SELECT THE CURRENT DISK
                __( !( pstt->idAdam > 5 ) ) ;
                if( !POOP )
                {
                    __( !( pstt[ CSpREFIX     ] == S1C('/') ) ) ;
                    __( !( pstt[ CSpREFIX + 1 ] == S1C('/') ) ) ;
                    __( !( pstt[ CSpREFIX + 2 ] == S1C('/') ) ) ;
                    __( !( pstt[ CSpREFIX + 4 ] == S1C('/') ) ) ;
                }
                if( !POOP ) pstt->idAdam = 4 ;
                diskSelectF( tinP , pstt ) ;
            }
        #endif

        third.delF( tinP , pstt ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002068.etherc.diskhoverf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002069.etherc.boxputf BEGIN
#define DDNAME       "3func.36002069.etherc.boxputf"
#define DDNUMB      (countT)0x36002069
#define IDFILE      (countT)0xc90


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxPutF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030075.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.3000104.1.1.0.html\"\>3000104:  WAKEsHOW( "example.simplest.func.1030075.etherC.boxPutF" )\</A\>
  \<A HREF=\"5.7000104.1.1.0.html\"\>7000104:  WAKEsHOW( "example.simplest.func.1030075.etherC.boxPutF" )\</A\>
  \<A HREF=\"5.7710104.1.1.0.html\"\>7710104:  WAKEsHOW( "example.simplest.func.1030075.etherC.boxPutF" )\</A\>
  \<A HREF=\"5.8710104.1.1.0.html\"\>8710104:  WAKEsHOW( "example.simplest.func.1030075.etherC.boxPutF" )\</A\>
arguments
 psttP
  must not be 0
  may also be a string of strings
   the result is as if the caller called me repeatedly
  impotence behavior depends upon whether i am *tinP.pEtScratch
   if so, then i will try all listed file names and will become impotent only if all file names fail
   else i will return immediately upon impotence
 pbP
  can be 0
  if 0 then a null length file will be created
  if 0 then cbP must also be 0
 cbP
  can be 0
  if 0 then the null terminated string of bytes at pbP will be written
  the terminating null byte will -not- be written
 cOpenTriesP
  if 0 then will retry forever
  if not 0 then will try cTriesP times
*/
/**//*1*/voidT etherC::boxPutF( tinS& tinP , const strokeS* const psttP , const byteT* const pbP , const countT cbP , countT cOpenTriesP , countT time1P , const sCountT time2P , const flagsT flagsOpenDetailsP , const flagsT flagsPutP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        __( cbP && !pbP ) ;
        if( POOP ) return ;
    }

    _IO_

    ETHERlIST1bEFOREwORK( psttP )
    boxC box( tinP , *this , psttc1 , ifcOPENaCCESS_W , ifcOPENhOW_nCeR , 0 , cOpenTriesP , time1P , time2P , flagsOpenDetailsP ) ;
    box.putF( tinP , pbP , cbP , flagsPutP ) ;
    ETHERlIST2bEFOREoPTIONALbREAK
    ETHERlIST3aFTERoPTIONALbREAK
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002069.etherc.boxputf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600206a.etherc.boxgetf BEGIN
#define DDNAME       "3func.3600206a.etherc.boxgetf"
#define DDNUMB      (countT)0x3600206a
#define IDFILE      (countT)0xc91


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxGetF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030076.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.4000104.1.1.0.html\"\>4000104:  WAKEsHOW( "example.simplest.func.1030076.etherC.boxGetF" )\</A\>
arguments
 pbP
 cbP
 psttP
  must not be 0
  may also be a string of strings
   the result is as if the caller called me repeatedly
  impotence behavior depends upon whether i am *tinP.pEtScratch
   if so, then i will try all listed file names and will become impotent only if all file names fail
   else i will return immediately upon impotence
 cOpenTriesP
  if 0 then will retry forever
  if not 0 then will try cOpenTriesP times
*/
/**//*1*/voidT etherC::boxGetF( tinS& tinP , byteT*& pbP , countT& cbP , const strokeS* const psttP , countT cOpenTriesP , const countT cZapTriesP , countT time1P , const sCountT time2P , const flagsT flagsOpenDetailsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    ETHERlIST1bEFOREwORK( psttP )
    boxC box( tinP , *this , psttc1 , 0 , 0 , 0 , cOpenTriesP , time1P , time2P , flagsOpenDetailsP ) ;
    if( !pbP ) { box.getF( tinP , pbP , cbP ) ; ___( pbP ) ; }
    box.zapF( tinP , cZapTriesP ) ;
    ETHERlIST2bEFOREoPTIONALbREAK
    ETHERlIST3aFTERoPTIONALbREAK
    __Z( pbP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600206a.etherc.boxgetf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600206b.etherc.boxgetshadowf BEGIN
#define DDNAME       "3func.3600206b.etherc.boxgetshadowf"
#define DDNUMB      (countT)0x3600206b
#define IDFILE      (countT)0xc92


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxGetShadowF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030077.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.5000104.1.1.0.html\"\>5000104:  WAKEsHOW( "example.simplest.func.1030077.etherC.boxGetShadowF" )\</A\>
  \<A HREF=\"5.8000104.1.1.0.html\"\>8000104:  WAKEsHOW( "example.simplest.func.1030077.etherC.boxGetShadowF" )\</A\>
  \<A HREF=\"5.9710104.1.1.0.html\"\>9710104:  WAKEsHOW( "example.simplest.func.1030077.etherC.boxGetShadowF" )\</A\>
arguments
 pbP
 cbP
 psttP
  must not be 0
  may also be a string of strings
   the result is as if the caller called me repeatedly
  impotence behavior depends upon whether i am *tinP.pEtScratch
   if so, then i will try all listed file names and become impotent only if all files names fail
   else i will return immediately upon impotence
 cOpenTriesP
  if 0 then will retry forever
  if not 0 then will try cOpenTriesP times
*/
/**/

/*1*/voidT etherC::boxGetShadowF( tinS& tinP , byteT*& pbP , countT& cbP , const strokeS* const psttP , countT cOpenTriesP , countT time1P , const sCountT time2P , const flagsT flagsOpenDetailsP , const flagsT flagsP , const osTextT* const postBodyP , countT costBodyP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pbP ) ;
        __NZ( cbP ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    ETHERlIST1bEFOREwORK( psttP )
    boxC box( tinP , *this , psttc1 , 0 , 0 , 0 , cOpenTriesP , time1P , time2P , flagsOpenDetailsP ) ;
    if( !pbP ) { box.getF( tinP , pbP , cbP , flagsP , postBodyP , costBodyP ) ; ___( pbP ) ; }
    ETHERlIST2bEFOREoPTIONALbREAK
    ETHERlIST3aFTERoPTIONALbREAK
    __Z( pbP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600206b.etherc.boxgetshadowf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600206c.etherc.boxputuniquef BEGIN
#define DDNAME       "3func.3600206c.etherc.boxputuniquef"
#define DDNUMB      (countT)0x3600206c
#define IDFILE      (countT)0xc93


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxPutUniqueF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030078.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.c710104.1.1.0.html\"\>c710104:  WAKEsHOW( "example.simplest.func.1030078.etherC.boxPutUniqueF" )\</A\>
arguments
 psttP
  will be set to the actual name used
  if psttLikeP is a list, then psttP will also be a list
 psttLikeP
  the prefix for the unique name
   example: T("///ideafarm/ephemeral/tmp/1030078")
  may also be a string of strings
   the result is as if the caller called me repeatedly
  impotence behavior depends upon whether i am *tinP.pEtScratch
   if so, then i will try all listed file names
   else i will return immediately upon impotence
 pbP
  must not be 0
  must point to cbP bytes of data that are to be written
 cbP
  can be 0
  0 implies that pbP points to a null terminated string of bytes, which will be written
 cOpenTriesP
  if 0 then will retry forever
  if not 0 then will try cTriesP times
*/
/**/

/*1*/voidT etherC::boxPutUniqueF( tinS& tinP , strokeS*& psttP , const strokeS* const psttLikeP , const byteT* const pbP , const countT cbP , countT cOpenTriesP , const flagsT flagsOpenDetailsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( pbP ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , psttU ) ;
    strUniqueF( tinP , psttU ) ; ___( psttU ) ;

    boolT bStringOfStrings = ISsTRINGoFsTRINGS( psttLikeP ) ;
    ZE( strokeS* , pstt1Like ) ;
    if( !bStringOfStrings ) { strFuseSeparateF( tinP , pstt1Like , psttLikeP ) ; ___( pstt1Like ) ; }
    else                    pstt1Like = (strokeS*)psttLikeP ;

    TlIST( tListUse ) ;
    {
        TN( tMark , "@1@" ) ;
        FORsTRINGSiN1( pstt1Like )
        {
            ZE( strokeS* , psttUse ) ;
            if( strIdF( tinP , tMark , psttc1 ) ) { strReplaceF( tinP , psttUse , psttc1 , tMark , psttU ) ; ___( psttUse ) ; }
            else
            {
                strMakeF( tinP , LF , psttUse , psttLikeP , ( psttU ? 1 + psttU->idAdam : 0 ) ) ; ___( psttUse ) ;
                strFuseF( tinP , psttUse , T(".") ) ; ___( psttP ) ;
                strFuseF( tinP , psttUse , psttU ) ; ___( psttP ) ;
            }

            tListUse += T(psttUse) ;
            delF( tinP , psttUse ) ;
        }
    }
    strokeS* pstt1zUse = tListUse ;

    ZE( countT , cFail ) ;
    FORsTRINGSiN1( pstt1zUse )
    {
        if( this != tinP.pEtScratch )
        {
            boxC box( tinP , *this , psttc1 , 0 , 0 , 0 , cOpenTriesP , 0 , 0 , flagsOpenDetailsP ) ;
            box.putF( tinP , pbP , cbP ) ;
            if( POOP ) break ;
        }
        else
        {
            IFsCRATCH
            {
                SCOOPS
                boxC box( tinP , *this , psttc1 , 0 , 0 , 0 , cOpenTriesP , 0 , 0 , flagsOpenDetailsP ) ;
                box.putF( tinP , pbP , cbP ) ;
                if( POOP )
                {
                    POOPRqUIET
                    cFail ++ ;
                }
            }
        }
    }

    if( !bStringOfStrings ) delF( tinP , pstt1Like ) ;
                            delF( tinP , psttU     ) ;

    __( cFail ) ;

    if( bStringOfStrings ) { strMakeF( tinP , LF , psttP , pstt1zUse ) ; ___( psttP ) ; }
    else
    {
        FORsTRINGSiN1( pstt1zUse )
        {
            strMakeF( tinP , LF , psttP , psttc1 ) ; ___( psttP ) ;
            break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600206c.etherc.boxputuniquef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600206d.etherc.boxtimef BEGIN
#define DDNAME       "3func.3600206d.etherc.boxtimef"
#define DDNUMB      (countT)0x3600206d
#define IDFILE      (countT)0xc94


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxTimeF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030079.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.d710104.1.1.0.html\"\>d710104:  WAKEsHOW( "example.simplest.func.1030079.etherC.boxTimeF" )\</A\>
arguments
 time1P
  must be 0
 time2P
  must be 0
 psttP
  must not be 0
  this is the name of the file whose time (time last written) is needed
*/
/**//*1*/voidT etherC::boxTimeF( tinS& tinP , countT& time1P , sCountT& time2P , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( time1P ) ;
        __( time2P ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    boxC box( tinP , *this , psttP ) ;
    box.timeF( tinP , time1P , time2P ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600206d.etherc.boxtimef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600206e.etherc.boxmenuf BEGIN
#define DDNAME       "3func.3600206e.etherc.boxmenuf"
#define DDNUMB      (countT)0x3600206e
#define IDFILE      (countT)0xc95


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxMenuF.0.html\"\>instances\</A\>
\<A HREF=\"5.103007a.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.e710104.1.1.0.html\"\>e710104:  WAKEsHOW( "example.simplest.func.103007a.etherC.boxMenuF" )\</A\>
evaluates to the number of matching items
arguments
 psttP
 psttLikeP
 csttEstimateP
 cMaxP
  can be 0
  if not 0 then this is the maximum nunber of items reported in pstt1P and in the returned value
*/
/**//*1*/countT etherC::boxMenuF( tinS& tinP , soulC& soulP , const strokeS* const psttLikeP , grabC* pGrabP  , const countT cMaxP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    _IO_
    boxC box( tinP , *this , psttLikeP ) ;
    countT cItems = box.menuF( tinP , soulP , pGrabP , cMaxP ) ;

    return cItems ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600206e.etherc.boxmenuf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600206f.etherc.boxgetf BEGIN
#define DDNAME       "3func.3600206f.etherc.boxgetf"
#define DDNUMB      (countT)0x3600206f
#define IDFILE      (countT)0xc96


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxGetF.0.html\"\>instances\</A\>
\<A HREF=\"5.103007b.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1810104.1.1.0.html\"\>1810104:  WAKEsHOW( "example.simplest.func.103007b.etherC.boxGetF" )\</A\>
arguments
 psttP
  must not be 0
  may also be a string of strings
   the result is as if the caller called me repeatedly
  impotence behavior depends upon whether i am *tinP.pEtScratch
   if so, then i will try all listed file names and will become impotent only if all file names fail
   else i will return immediately upon impotence
 cOpenTriesP
  if 0 then will retry forever
  if not 0 then will try cOpenTriesP times
*/
/**//*1*/voidT etherC::boxGetF( tinS& tinP , const strokeS* const psttP , countT cOpenTriesP , const countT cZapTriesP , countT time1P , const sCountT time2P , const flagsT flagsOpenDetailsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    ETHERlIST1bEFOREwORK( psttP )
    boxC box( tinP , *this , psttc1 , 0 , 0 , 0 , cOpenTriesP , time1P , time2P , flagsOpenDetailsP ) ;
    box.zapF( tinP , cZapTriesP ) ;
    ETHERlIST2bEFOREoPTIONALbREAK
    ETHERlIST3aFTERoPTIONALbREAK
    __Z( psttP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600206f.etherc.boxgetf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002070.etherc.ossessionf BEGIN
#define DDNAME       "3func.36002070.etherc.ossessionf"
#define DDNUMB      (countT)0x36002070
#define IDFILE      (countT)0xc97


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osSessionF.0.html\"\>instances\</A\>
\<A HREF=\"5.103007c.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.4510104.1.1.0.html\"\>4510104:  WAKEsHOW( "example.simplest.func.103007c.etherC.osSessionF" )\</A\>
it is illegal to refer to this symbol in the definition of an adam
on windows, the flSESSION_KID flag has no effect
 the process is a non-kid, even if the kid flag is set, because windows does not support the concept of kid processes
arguments
 tidP
  must be 0
 pidP
  must be 0
 psttExeP
 psttArgsP
 idColP
 idRowP
 cColP
 cRowP
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001000e.flSESSION!||
*/
/**/

#define osFileNameC osFileNameC

/*1*/voidT etherC::osSessionF( tinS& tinP , countT& tidP , countT& pidP , const strokeS* const psttExeP , const strokeS* const psttArgsP , const countT idColP , const countT idRowP , const countT cColP , const countT cRowP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( pidP ) ;
        FV( flSESSION , flagsP ) ;
        if( POOP ) return ;
    }

    _IO_
    /*osFileNameC*/
    #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000003.argsForOrphanProcessLaunch.h"

    third.dosStartSessionF( tinP , tidP , pidP , osf , post1Args , idColP , idRowP , cColP , cRowP , flagsP ) ;
    delF( tinP , postExe ) ;
    delF( tinP , post1Args ) ;
}

#undef osFileNameC


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002070.etherc.ossessionf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002071.etherc.ossessionf BEGIN
#define DDNAME       "3func.36002071.etherc.ossessionf"
#define DDNUMB      (countT)0x36002071
#define IDFILE      (countT)0xc98


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osSessionF.0.html\"\>instances\</A\>
\<A HREF=\"5.103007d.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.5510104.1.1.0.html\"\>5510104:  WAKEsHOW( "example.simplest.func.103007d.etherC.osSessionF" )\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 tidP
  must be 0
 pidP
  must be 0
 idAdamP
 psttArgsP
  can be 0
 idColP
 idRowP
 cColP
 cRowP
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001000e.flSESSION!||
*/
/**//*1*/voidT etherC::osSessionF( tinS& tinP , countT& tidP , countT& pidP , const countT idAdamP , const strokeS* const psttArgsP , const countT idColP , const countT idRowP , const countT cColP , const countT cRowP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( tidP ) ;
        __( pidP ) ;
        __Z( idAdamP ) ;
        FV( flSESSION , flagsP ) ;
        if( POOP ) return ;
    }

    _IO_
    osSessionF( tinP , tidP , pidP , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.41000003.ipdos-we") , TF3(idAdamP,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+(psttArgsP?T(" ")+T(psttArgsP):T("")) , idColP , idRowP , cColP , cRowP , flagsP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002071.etherc.ossessionf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002072.etherc.dllentryf BEGIN
#define DDNAME       "3func.36002072.etherc.dllentryf"
#define DDNUMB      (countT)0x36002072
#define IDFILE      (countT)0xc99


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dllEntryF.0.html\"\>instances\</A\>
\<A HREF=\"5.103007e.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 pPeekFP
 handleP
 psttP
*/
/**//*1*/voidT etherC::dllEntryF( tinS& tinP , peekFT& pPeekFP , const handleC& handleP , const strokeS* psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pPeekFP ) ;
        __Z( handleP ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    TN( tOs2 , "" ) ; tOs2 = T(psttP) ;
    TN( tWin , "" ) ; tWin = T("_")+T(psttP)+T("@4") ;
    TN( tLin , "" ) ; tLin = T("?") ;

    ZE( voidT* , pv ) ;
    dllEntryF( tinP , pv , handleP , TO((strokeS*)tOs2,(strokeS*)tWin,(strokeS*)tLin) ) ;
    pPeekFP = (peekFT)pv ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002072.etherc.dllentryf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002073.etherc.filehosecreatef BEGIN
#define DDNAME       "3func.36002073.etherc.filehosecreatef"
#define DDNUMB      (countT)0x36002073
#define IDFILE      (countT)0xc9a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$fileHoseCreateF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030080.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 handleP
 psttP
*/
/**/

/*1*/voidT etherC::fileHoseCreateF( tinS& tinP , handleC& handleP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    ZE( strokeS* , pstt ) ;
    diskMapFileNameF( tinP , pstt , psttP ) ; ___( pstt ) ;
    ZE( osTextT* , post ) ;
    strMakeF( tinP , LF , post , pstt ) ; ___( post ) ;
    delF( tinP , pstt ) ;
    // THE FOLLOWING CALL IS SUPPORTED BY OS2 AND WIN NT BUT -NOT- BY WIN 95
    third.dosCreateNPipeF( tinP , handleP , osFileNameC( tinP , third , post ) ) ;
    delF( tinP , post ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002073.etherc.filehosecreatef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002074.etherc.filehoseconnectf BEGIN
#define DDNAME       "3func.36002074.etherc.filehoseconnectf"
#define DDNUMB      (countT)0x36002074
#define IDFILE      (countT)0xc9b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$fileHoseConnectF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030081.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 handleP
*/
/**/

/*1*/voidT etherC::fileHoseConnectF( tinS& tinP , const handleC& handleP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    sleepStartF( tinP ) ;
    third.dosConnectNPipeF( tinP , handleP ) ;
    sleepEndF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002074.etherc.filehoseconnectf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002075.etherc.filehosedisconnectf BEGIN
#define DDNAME       "3func.36002075.etherc.filehosedisconnectf"
#define DDNUMB      (countT)0x36002075
#define IDFILE      (countT)0xc9c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$fileHoseDisconnectF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030082.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 handleP
*/
/**/

/*1*/voidT etherC::fileHoseDisconnectF( tinS& tinP , const handleC& handleP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.dosDisconnectNPipeF( tinP , handleP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002075.etherc.filehosedisconnectf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002076.etherc.strreplacef BEGIN
#define DDNAME       "3func.36002076.etherc.strreplacef"
#define DDNUMB      (countT)0x36002076
#define IDFILE      (countT)0xc9d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strReplaceF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030083.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6a10104.1.1.0.html\"\>6a10104:  WAKEsHOW( "example.simplest.func.1030083.etherC.strReplaceF" )\</A\>
replaces each occurance of psttOldSmallP
evaluates to the number of replacements made
if psttOldBigP is 0 then psttNewBigP will be replaced
 iow, that pointer will change, the memory at the original pointer will be d eleted, and the new memory will contain the result
if the old string cannot be deallocated then specify it as the second parameter, not the first
if the old string is a string of strings, evaluate this expression separately for each string
 the following code will do this (it replaces "aa" with "bbbb" in pstt1o, which is reallocated)
  strokeS* pstt1d = pstt1o ;
  pstt1o = 0 ;
  FORsTRINGSiN1( pstt1d )
  {
  ZE( strokeS* , psttn ) ;
  ether.strReplaceF( tinP , psttn , psttc1 , T("aa") , T("bbbb") ) ; ___( psttn ) ;
  ether.strFuseSeparateF( tinP , pstt1o , psttn , 0 , 0 , 0 , 0 , 0x100000 ) ; ___( pstt1o ) ;
  ether.delF( tinP , psttn ) ;
  }
  ether.delF( tinP , pstt1d ) ;
arguments
 psttNewBigP
  can be 0
   if 0 then psttOldBigP must not be 0
 psttOldBigP
  can be 0
   if 0 then psttNewBigP must not be 0
 psttOldSmallP
  this string can include a null stroke
  this can also be null, or a null length string
   behavior is identical to that of a unit length string containing a null stroke
 psttNewSmallP
 csttExtraP
  can be 0
  i always preserve the extra strokes that are present in the source string
  use csttExtraP to specify additional extra strokes
*/
/**/

/*1*/countT etherC::strReplaceF( tinS& tinP , strokeS*& psttNewBigP , const strokeS* psttOldBigP , const strokeS* const psttOldSmallP , const strokeS* const psttNewSmallP , const countT csttExtraP , const flagsT flagsP )/*1*/

#define BeXACT
#define STRiDf_OR_sTRiDaNYf strIdF

#include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000004.strReplaceF_strReplaceAnyF.h"

#undef  STRiDf_OR_sTRiDaNYf
#undef  BeXACT


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002076.etherc.strreplacef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002077.etherc.strfromidportnicnamef BEGIN
#define DDNAME       "3func.36002077.etherc.strfromidportnicnamef"
#define DDNUMB      (countT)0x36002077
#define IDFILE      (countT)0xc9e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFromIdPortNicNameF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030084.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7a10104.1.1.0.html\"\>7a10104:  WAKEsHOW( "example.simplest.func.1030084.etherC.strFromIdPortNicNameF" )\</A\>
arguments
 psttP
 idPortP
  can be 0
  if 0 then the format of psttP will be "1,2,3,4"
  if not 0 then the format of psttP will be "1,2,3,4,5,6"
 nicNameP
  can be 0
  if 0 then the ip address of the local host will be used
 foreign ordering is used for the resulting digits
*/
/**/

/*1*/voidT etherC::strFromIdPortNicNameF( tinS& tinP , strokeS*& psttP , const countT idPortP , const nicNameC nicNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __( third ? 0 : processGlobal1I.cb_nicNameC_ - 4 * sizeof( countT ) ) ;
        if( POOP ) return ;
    }

    _IO_
    countT  idPort = idPortP ;
    nicNameC nicName = nicNameP ;

    if( !nicName ) nicName = sockNicNameF( tinP ) ;

    strMakeF( tinP , LF , psttP , T("") , 0x37 ) ; // CALLER MUST TAG
    ZE( strokeS* , psttw ) ;

    {
        const byteT*  const pbi = (byteT*)&nicName ;
        const countT* const pci = (countT*)pbi ;
        const boolT   bOld = !pci[ 1 ] && !pci[ 2 ] && !pci[ 3 ] ;

        const countT offMax = 3 + !bOld * 8 ;
        for( sCountT off = offMax ; off >= 0 ; off -- )
        {
            strFromF( tinP , psttw , pbi[ off ] , flFORMAT_NObIGITvALUES | flFORMAT_UNSIGNED | flFORMAT_NObASE | flFORMAT_FOREIGN , 0 , 10 ) ; ___( psttw ) ;
            strFuseF( tinP , psttP , psttw ) ; ___( psttP ) ;
            delF( tinP , psttw ) ;
            if( off ) { strFuseF( tinP , psttP , T(",") ) ; ___( psttP ) ; }
        }
    }

    countT idPort2 = idPort / 256 ;
    idPort %= 256 ;
    countT idPort3 = idPort2 / 256 ;
    idPort2 %= 256 ;
    countT idPort4 = idPort3 / 256 ;
    idPort3 %= 256 ;
    __( idPort4 ) ;
    __( idPort3 ) ;

    if( idPort2 || idPort )
    {
        strFuseF( tinP , psttP , T(",") ) ; ___( psttP ) ;
        strFromF( tinP , psttw , idPort2 , flFORMAT_NObIGITvALUES | flFORMAT_UNSIGNED | flFORMAT_NObASE | flFORMAT_FOREIGN , 0 , 10 ) ; ___( psttw ) ;
        strFuseF( tinP , psttP , psttw ) ; ___( psttP ) ;
        delF( tinP , psttw ) ;

        strFuseF( tinP , psttP , T(",") ) ; ___( psttP ) ;
        strFromF( tinP , psttw , idPort , flFORMAT_NObIGITvALUES | flFORMAT_UNSIGNED | flFORMAT_NObASE | flFORMAT_FOREIGN , 0 , 10 ) ; ___( psttw ) ;
        strFuseF( tinP , psttP , psttw ) ; ___( psttP ) ;
        delF( tinP , psttw ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002077.etherc.strfromidportnicnamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002078.etherc.strreversef BEGIN
#define DDNAME       "3func.36002078.etherc.strreversef"
#define DDNUMB      (countT)0x36002078
#define IDFILE      (countT)0xc9f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strReverseF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030086.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7b10104.1.1.0.html\"\>7b10104:  WAKEsHOW( "example.simplest.func.1030086.etherC.strReverseF" )\</A\>
  \<A HREF=\"5.8a10104.1.1.0.html\"\>8a10104:  WAKEsHOW( "example.simplest.func.1030086.etherC.strReverseF" )\</A\>
  \<A HREF=\"5.8b10104.1.1.0.html\"\>8b10104:  WAKEsHOW( "example.simplest.func.1030086.etherC.strReverseF" )\</A\>
can be used reverse the order of the strokes or the lines or the delimited substrings of a string
arguments
 psttP
  can be 0
  if not 0 then must be an address in the poolOld
   the drop at this address will be d eleted and the value of psttP will be replaced with the address of a new drop
 psttOldP
  can be 0, unless psttP is 0
  if psttDelimiterP then no delimited string can be longer than CSTTsOULfUSEdEFAULT
 psttDelimiterP
  must be not longer than CSTTsOULfUSEdEFAULT
  case: T(""): reverses the order of the strokes in the string
  case: T("\r\n"): reverses the order of the lines in the string
  case: 0: same as T("")
  case: T("delimiter"): reverses the order of the delimited substrings
   example: T("1::2")
    this will reverse the order of the substrings delimited by T("1::2")
     for example, T("aaaa1::2bbbb1::2cccc") will become T("cccc1::2bbbb1::2aaaa")
 pSoulP
  can be 0
  if !psttDelimiterP then must be fifo
  else                    must be lifo
 pGrabP
 csttExtraP
  can be 0
  i always preserve the extra strokes that are present in the source string
  use csttExtraP to specify additional extra strokes
*/
/**/

/*1*/voidT etherC::strReverseF( tinS& tinP , strokeS*& psttP , const strokeS* psttOldP , const strokeS* const psttDelimiterP , soulC* pSoulP , grabC* pGrabP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( !psttP == !psttOldP ) ;
        __( psttDelimiterP && psttDelimiterP->idAdam > CSTTsOULfUSEdEFAULT ) ;
        if( POOP ) return ;
    }

    _IO_

    const boolT bDeleteOld = !psttOldP ;
    if( !psttOldP ) { psttOldP = psttP ; psttP = 0 ; }

    if( !psttDelimiterP )
    {
        if( !pSoulP )
        {
            countT cDo = psttOldP->idAdam ;
            countT cExtra = psttOldP[ 2 ].idAdam + csttExtraP ;
            soulC souli( tinP , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;
            strFuseF( tinP , souli , psttOldP ) ;
            if( bDeleteOld ) delF( tinP , *(strokeS**)&psttOldP ) ;

            strMakeF( tinP , LF , psttP , 0 , cDo + cExtra ) ; // CALLER MUST TAG ___( psttP ) ;
            SETpREFIX( psttP , cDo , cExtra ) ;

            strokeS* pstto = psttP + CSpREFIX - 1 + cDo ;
            while( souli )
            {
                ZE( strokeS* , psttp ) ;
                souli >> psttp ; ___( psttp ) ;
                strokeS* pstti = psttp + CSpREFIX ;
                countT cDoPiece = psttp->idAdam ;
                while( cDoPiece -- ) *( pstto -- ) = *( pstti ++ ) ;
                delF( tinP , psttp ) ;
            }
        }
        else
        {
            countT cDo = psttOldP->idAdam ;
            countT cExtra = psttOldP[ 2 ].idAdam + csttExtraP ;
            soulC souli( tinP , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;
            strFuseF( tinP , souli , psttOldP ) ;
            if( bDeleteOld ) delF( tinP , *(strokeS**)&psttOldP ) ;

            while( souli )
            {
                ZE( strokeS* , psttp ) ;
                souli >> psttp ; ___( psttp ) ;
                strReverseF( tinP , psttp , 0 ) ; ___( psttp ) ;
                *pSoulP << psttp ;
                delF( tinP , psttp ) ;
            }
        }
    }
    else
    {
        if( !pSoulP )
        {
            strMakeF( tinP , LF , psttP , 0 , psttOldP->idAdam ) ; ___( psttP ) ;

            soulC souli( tinP , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;
            countT idf = 1 ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( countT , idfLath ) ;
            while( idf && !POOP )
            {
                ZE( strokeS* , psttw ) ;
                idfLath = idf ;
                boolT bFound = strSubstringF( tinP , psttw , idf , sttq , psttDelimiterP , psttOldP ) ; ___( psttw ) ;
                if( psttw && psttw->idAdam )
                {
                    if( psttw->idAdam <= CSTTsOULfUSEdEFAULT ) strFuseF( tinP , souli , psttw ) ;
                    else
                    {
                        soulC soulPour( tinP , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;
                        strFuseF( tinP , soulPour , psttw ) ;
                        strPourF( tinP , souli , soulPour ) ;
                    }
                }
                delF( tinP , psttw ) ;
    
                if( bFound ) strFuseF( tinP , souli , psttDelimiterP ) ;
            }

            while( souli )
            {
                ZE( strokeS* , psttp ) ;
                souli >> psttp ; ___( psttp ) ;
                strFuseF( tinP , psttP , psttp ) ;
                delF( tinP , psttp ) ;
            }
        }
        else
        {
            countT idf = 1 ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( countT , idfLath ) ;
            while( idf && !POOP )
            {
                ZE( strokeS* , psttw ) ;
                idfLath = idf ;
                boolT bFound = strSubstringF( tinP , psttw , idf , sttq , psttDelimiterP , psttOldP ) ; ___( psttw ) ;
                if( psttw && psttw->idAdam )
                {
                    if( psttw->idAdam <= CSTTsOULfUSEdEFAULT ) strFuseF( tinP , *pSoulP , psttw ) ;
                    else
                    {
                        soulC soulPour( tinP , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;
                        strFuseF( tinP , soulPour , psttw ) ;
                        strPourF( tinP , *pSoulP , soulPour ) ;
                    }
                }
                delF( tinP , psttw ) ;
    
                if( bFound ) strFuseF( tinP , *pSoulP , psttDelimiterP ) ;
            }
        }

        if( bDeleteOld ) delF( tinP , *(strokeS**)&psttOldP ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002078.etherc.strreversef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002079.etherc.strreplaceanyf BEGIN
#define DDNAME       "3func.36002079.etherc.strreplaceanyf"
#define DDNUMB      (countT)0x36002079
#define IDFILE      (countT)0xca0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strReplaceAnyF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030087.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9a10104.1.1.0.html\"\>9a10104:  WAKEsHOW( "example.simplest.func.1030087.etherC.strReplaceAnyF" )\</A\>
replaces substrings made up entirely of the characters in psttOldSmallP with the string psttNewSmallP
evaluates to the number of replacements made
see the notes for strReplaceF
arguments
 psttNewBigP
 psttOldBigP
 psttOldSmallP
  this string can include a null stroke
  this can also be null, or a null length string
   behavior is identical to that of a unit length string containing a null stroke
 psttNewSmallP
 csttExtraP
  can be 0
  i always preserve the extra strokes that are present in the source string
  use csttExtraP to specify additional extra strokes
*/
/**/

/*1*/countT etherC::strReplaceAnyF( tinS& tinP , strokeS*& psttNewBigP , const strokeS* psttOldBigP , const strokeS* const psttOldSmallP , const strokeS* const psttNewSmallP , const countT csttExtraP , const flagsT flagsP )/*1*/

#define BaNY
#define STRiDf_OR_sTRiDaNYf strIdAnyF

#include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000004.strReplaceF_strReplaceAnyF.h"

#undef  STRiDf_OR_sTRiDaNYf
#undef  BaNY


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002079.etherc.strreplaceanyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600207a.etherc.boxmailgetf BEGIN
#define DDNAME       "3func.3600207a.etherc.boxmailgetf"
#define DDNUMB      (countT)0x3600207a
#define IDFILE      (countT)0xca1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxMailGetF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030088.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.a810104.1.1.0.html\"\>a810104:  WAKEsHOW( "example.simplest.func.1030088.etherC.boxMailGetF" )\</A\>
evaluates to the number of items actually retrieved
arguments
 psttLikeP
  must not be 0
  example: T("///ideafarm/ephemeral/tmp/1030088")
 psttBoxIP
  must not be 0
  example: T("my.isp.com//pop/my.account/my.password")
*/
/**//*1*/countT etherC::boxMailGetF( tinS& tinP , const strokeS* const psttLikeP , const strokeS* const psttBoxIP , const countT csttEstimateP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttLikeP ) ;
        __Z( psttBoxIP ) ;
        if( POOP ) return 0 ;
    }

    // THIS FUNCTION RETRIEVES ALL ITEMS FROM A POP SERVER, PLACING EACH ITEM
    // INTO A DISK FILE BEFORE DELETING THE CORRESPONDING POP BOX ITEM.

    _IO_
    boxC box( tinP , *this , psttBoxIP ) ;
    ZE( countT , cItems ) ;
    soulC soulP( tinP , TAG( TAGiDnULL ) ) ; //U::SOUL
    box.menuF( tinP , soulP ) ;
    FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soulP )
    {
        if( POOP ) break ;
        ZE( strokeS* , psttWord ) ;
        countT idf = 1 ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        strSubstringF( tinP , psttWord , idf , sttq , S1C(' ') , psttc1 ) ; ___( psttWord ) ;
        countT idItem = strDigitsToSCountF( tinP , psttWord ) ;
        ZE( osTextT* , pbItem ) ;
        box.getF( tinP , pbItem , idItem ) ; ___( pbItem ) ;
        ZE( strokeS* , psttnu ) ;
        boxPutGenerationF( tinP , psttnu , psttLikeP , csttEstimateP , pbItem ) ; ___( psttnu ) ;
        cItems ++ ;
        delF( tinP , psttnu ) ;
        delF( tinP , pbItem ) ;
        box.zapF( tinP , 0 , psttWord ) ;
        delF( tinP , psttWord ) ;
    }
    FORsTRINGSiNsPANNEDcOMBINEDtAIL1

    return cItems ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600207a.etherc.boxmailgetf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600207b.etherc.ostimenowf BEGIN
#define DDNAME       "3func.3600207b.etherc.ostimenowf"
#define DDNUMB      (countT)0x3600207b
#define IDFILE      (countT)0xca2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osTimeNowF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030089.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.3510104.1.1.0.html\"\>3510104:  WAKEsHOW( "example.simplest.func.1030089.etherC.osTimeNowF" )\</A\>
for maximum speed, this function omits some standard overhead code
arguments
 time1P
 time2P
 fRawP
*/
/**/

//DON'T USE _ IN HERE (WILL BLOW STACK)

/*1*/voidT etherC::osTimeNowF( tinS& tinP , countT& time1P , sCountT& time2P , boolT fRawP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( fRawP ) ; //DISABLE THIS PARAMETER UNTIL A CENTRALIZED TIME SYSTEM IS OPERATIONAL
        __( time1P ) ;
        __( time2P ) ;
        if( POOP ) return ;
    }

    _IO_
    third.osTimeNowF( tinP , time1P , time2P ) ;

    // THE "timeError" MEMBERS OF poolOld SideS WERE ELIMINATED DURING ELIMINATION OF poolOld SideS
    // THEY WERE USED TO APPLY AN ADJUSTMENT THAT WAS CALCULATED USING TIME VALUES OBTAINED FROM A SERVER
    // THE DESIGN OBJECTIVE WAS TO ENSURE THAT osTimeNowF RETURNED THE SAME TIME ON ALL HOSTS
    // SUCH A SUBSYSTEM SHOULD BE BASED UPON THE OO POWER EXPLOSIVE RELAY COMMUNICATION SUBSYSTEM
    // WHEN THE CENTRALIZED TIME SUBSYSTEM IS REWRITTEN, THESE ADJUSTMENT VALUES SHOULD BE MEMBERS OF homeS RATHER THAN STORED IN THE ROOT POOLoLD

    //if( !fRawP ) third.osTimeSubtractF( tinP , time1P , time2P , ((poolOld SideS&)pool Work).timeError1 , ((poolOld SideS&)pool Work).timeError2 ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600207b.etherc.ostimenowf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600207c.etherc.boxzapf BEGIN
#define DDNAME       "3func.3600207c.etherc.boxzapf"
#define DDNUMB      (countT)0x3600207c
#define IDFILE      (countT)0xca3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxZapF.0.html\"\>instances\</A\>
\<A HREF=\"5.103008a.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.0810104.1.1.0.html\"\>0810104:  WAKEsHOW( "example.simplest.func.103008a.etherC.boxZapF" )\</A\>
  \<A HREF=\"5.6000104.1.1.0.html\"\>6000104:  WAKEsHOW( "example.simplest.func.103008a.etherC.boxZapF" )\</A\>
arguments
 psttP
  may also be a string of strings
   the result is as if the caller called me repeatedly
  impotence behavior depends upon whether i am *tinP.pEtScratch
   if so, then i will try all listed file names
   else i will return immediately upon impotence
*/

/**/
/*1*/voidT etherC::boxZapF( tinS& tinP , const strokeS* const psttP , const countT cTriesP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    ETHERlIST1bEFOREwORK( psttP )
    boxC box( tinP , *this , psttc1 ) ;
    box.zapF( tinP , cTriesP ) ;
    ETHERlIST2bEFOREoPTIONALbREAK
    ETHERlIST3aFTERoPTIONALbREAK
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600207c.etherc.boxzapf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600207d.etherc.papertalkprogressf BEGIN
#define DDNAME       "3func.3600207d.etherc.papertalkprogressf"
#define DDNUMB      (countT)0x3600207d
#define IDFILE      (countT)0xca4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$paperTalkProgressF.0.html\"\>instances\</A\>
\<A HREF=\"5.103008b.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 bConsoleP
 goalP
 atP
 msSleepP
 psttPrefixP
 psttSuffixP
*/
/**//*1*/voidT etherC::paperTalkProgressF( tinS& tinP , batonC& bConsoleP , countT& goalP , countT& atP , countT msSleepP , strokeS* psttPrefixP , strokeS* psttSuffixP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    countT toDo = goalP - atP ;

    ZE( strokeS* , psttAll ) ;
    ZE( strokeS* , psttAt ) ;
    ZE( strokeS* , psttGoal ) ;
    ZE( strokeS* , psttToDo ) ;
    strFromF( tinP , psttGoal , goalP ) ; ___( psttGoal ) ;
    strFromF( tinP , psttAt , atP ) ; ___( psttAt ) ;
    strFromF( tinP , psttToDo , toDo ) ; ___( psttToDo ) ;

    if( psttPrefixP ) { strFuseF( tinP , psttAll , psttPrefixP ) ; ___( psttAll ) ; }
    strFuseF( tinP , psttAll , T("Goal=") ) ; ___( psttAll ) ;
    strFuseF( tinP , psttAll , psttGoal ) ; ___( psttAll ) ;
    strFuseF( tinP , psttAll , T("  At=") ) ; ___( psttAll ) ;
    strFuseF( tinP , psttAll , psttAt ) ; ___( psttAll ) ;
    strFuseF( tinP , psttAll , T("  ToDo=") ) ; ___( psttAll ) ;
    strFuseF( tinP , psttAll , psttToDo ) ; ___( psttAll ) ;
    if( psttSuffixP ) { strFuseF( tinP , psttAll , psttSuffixP ) ; ___( psttAll ) ; }

    bConsoleP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    strokeF( tinP , psttAll ) ;
    bConsoleP.ungrabF( tinP ) ;
    delF( tinP , psttAll ) ;
    delF( tinP , psttGoal ) ;
    delF( tinP , psttAt ) ;
    delF( tinP , psttToDo ) ;

    if( msSleepP )
    {
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        ++ s ; osSleepF( tinP , msSleepP ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600207d.etherc.papertalkprogressf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600207e.etherc.boxmenuidrangef BEGIN
#define DDNAME       "3func.3600207e.etherc.boxmenuidrangef"
#define DDNUMB      (countT)0x3600207e
#define IDFILE      (countT)0xca5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxMenuIdRangeF.0.html\"\>instances\</A\>
\<A HREF=\"5.103008c.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f710104.1.1.0.html\"\>f710104:  WAKEsHOW( "example.simplest.func.103008c.etherC.boxMenuIdRangeF" )\</A\>
converts a menu of box names into a list of countT values
 the last "word", delimited by S1C('/'), in each box name is interpreted as countT digits
 these digits are assumed to be base 16 unless an explicit base indicator is found
  examples using S1C('.') as the delimiter
   example: the file name T("///ideafarm/ephemeral/tmp/103008c.fooey.10") would be converted to the value 10
   example: the file name T("///ideafarm/ephemeral/tmp/103008c.fooey.10_9") would be converted to the value a
   example: the file name T("///ideafarm/ephemeral/tmp/103008c.fooey.cdefghi") would be converted to the value cdef
  examples using S1C('/') as the delimiter
   example: the file name T("///ideafarm/ephemeral/tmp/103008c/10.fooey") would be converted to the value 10
   example: the file name T("///ideafarm/ephemeral/tmp/103008c/10_9.fooey") would be converted to the value a
   example: the file name T("///ideafarm/ephemeral/tmp/103008c/cdefghi.fooey") would be converted to the value cdef
 U: WARNING: this function does not yet work according to these comments
  the way that it really works is a cluge
   if sttDelimiterP is S1C('/') then the last word is parsed again to get the -second- word delimited by S1C('.'), which is assumed to be a valid number
   else the last word is assumed to be a valid number in foreign digit order
   iow, if S1C('/') then a second parsing takes place
  this kluge is present because strDigitsToSCountF can no longer handle strings that begin with valid digits but also contain strokes that are not valid in numbers
   U: fix this by fixing strDigitsToSCountF (after rewriting it to use IFC digit order rather than foreign digit order)
reports the minimum and maximum value
arguments
 idMinP
  must be 0
 idMaxP
  must be 0
 psttLikeP
  any name pattern that is legal for boxC::menuF
 csttEstimateP
 sttDelimiterP
  can be 0
  if 0 then S1C('.') is used
*/

//U::REWRITE THIS TO ELIMINATE CAPACITY LIMIT

/**//*1*/voidT etherC::boxMenuIdRangeF( tinS& tinP , countT& idMinP , countT& idMaxP , const strokeS* psttLikeP , const countT csttEstimateP , strokeS sttDelimiterP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( idMinP ) ;
        __NZ( idMaxP ) ;
        __Z( psttLikeP ) ;
        if( POOP ) return ;
        __( !( psttLikeP->idCaste == sc_PREFIXlENGTH ) ) ;
        if( POOP ) return ;
    }

    _IO_
    if( !sttDelimiterP ) sttDelimiterP = S1C('.') ;

    boxC box( tinP , *this , psttLikeP ) ;
    soulC soulm( tinP , TAG( TAGiDnULL ) ) ;
    countT cItemsNU = box.menuF( tinP , soulm ) ;
    TN( tTag , "!writing" ) ;
    FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soulm )
    {
        if( POOP ) break ;

        ZE( boolT , bSkip ) ;
        {
            ZE( strokeS* , psttw ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            strWordF( tinP , psttw , psttc1 , sttq , S1C('.') , - 4 ) ; ___( psttw ) ;
            bSkip = psttw && !strCompareF( tinP , tTag , psttw ) ;
            delF( tinP , psttw ) ;
        }
        if( bSkip ) continue ;

        ZE( strokeS* , psttw ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        strWordF( tinP , psttw , psttc1 , sttq , sttDelimiterP , - 1 ) ; ___( psttw ) ;
        ZE( countT , idFile ) ;
        if( sttDelimiterP == S1C('/') )
        {
            ZE( strokeS* , psttw2 ) ;
            //sttq = ze ;
            strWordF( tinP , psttw2 , psttw , sttq , S1C('.') , 2 ) ; ___( psttw2 ) ;
            idFile = strDigitsToSCountF( tinP , psttw2 , 0 , 1 ) ;
            delF( tinP , psttw2 ) ;
        }
        else idFile = strDigitsToSCountF( tinP , psttw , 0 , 1 ) ;
        delF( tinP , psttw ) ;
        if( idMinP > idFile || !idMinP ) idMinP = idFile ;
        if( idMaxP < idFile            ) idMaxP = idFile ;
    }
    FORsTRINGSiNsPANNEDcOMBINEDtAIL1
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600207e.etherc.boxmenuidrangef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600207f.etherc.ifcdatumf BEGIN
#define DDNAME       "3func.3600207f.etherc.ifcdatumf"
#define DDNUMB      (countT)0x3600207f
#define IDFILE      (countT)0xca6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcDatumF.0.html\"\>instances\</A\>
\<A HREF=\"5.103008d.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7310104.1.1.0.html\"\>7310104:  WAKEsHOW( "example.simplest.func.103008d.etherC.ifcDatumF" )\</A\>
arguments
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010049.flDATUM1!||
 amountP
 pcResourceIdP
  this is a null terminated string of countT objects
  example: pcPart
   where pcPart is declared and initialized as: countT pcPart[] = { 1 , 3 , 5 , 7 , 0 } ;
  do not specify an adam class within this, since the adam class is automatically prepended
 pbP
 cbP
*/
/**/

/*1*/voidT etherC::ifcDatumF( tinS& tinP , const flagsT flags1P , const flagsT flags2P , countT amountP , const countT* const pcResourceIdP , const byteT* const pbP , const countT cbP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( cbP && !pbP ) ;
        //__( !POOP && processGlobal1I.cb_nicNameC_ - 4 * sizeof( countT ) ) ;
        FV( flDATUM1 , flags1P ) ;
        FV( flDATUM2 , flags2P ) ;
        if( POOP ) return ;
    }

    _IO_

    if( tinP.pEtScratch )
    {
        ZE( countT , ze ) ;
        ZE( const countT* , pcResourceId ) ;
        if( pcResourceIdP ) pcResourceId = pcResourceIdP ;
        else                pcResourceId = &ze ;
    
        countT cbd = cbP ;
        if( pbP && !cbd && F(flags2P) & flDATUM2_osTextT ) cbd = strBodyLengthF( tinP , pbP ) + 1 ;
        flagsT flags1 = flags1P ;
        flagsT flags2 = flags2P ;
    
        switch( third.osIdIF( tinP ) )
        {
            case 'o' : { flags2 |= flDATUM2_OS2       ; break ; }
            case 'w' : { flags2 |= flDATUM2_WINDOWSnT ; break ; }
            case '5' : { flags2 |= flDATUM2_WINDOWS95 ; break ; }
            default  : __1
        }
    
        //U:#if defined( NEVERdEFINED )
        ZE( boolT , bKeep ) ;
        {
            // bKeep |= F(flags1P) & flDATUM1_CLASScOMMENToNION       ;
            // bKeep |= F(flags1P) & flDATUM1_CLASScOMMENToRCHID      ;
               bKeep |= F(flags1P) & flDATUM1_CLASSeXCEPTIONiMPOTENCE ;
               bKeep |= F(flags1P) & flDATUM1_CLASSeXCEPTIONjOURNAL   ;
            // bKeep |= F(flags1P) & flDATUM1_CLASSjOURNAL            ;
            // bKeep |= F(flags1P) & flDATUM1_CLASSqUERY              ;
            // bKeep |= F(flags1P) & flDATUM1_CLASSqUESTION           ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStACHOMETER         ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStRACEaLWAYShIRE    ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStRACEaLWAYSfIRE    ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStRACEaLWAYShIREdLL ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStRACEaLWAYSfIREdLL ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStRACElEVEL1        ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStRACElEVEL2        ;
            // bKeep |= F(flags1P) & flDATUM1_CLASSwORK               ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStIMER              ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStIMECARD           ;
            // bKeep |= F(flags2P) & flDATUM2_countT                 ;
            // bKeep |= F(flags2P) & flDATUM2_NULLtERMINATED         ;
            // bKeep |= F(flags2P) & flDATUM2_osTextT                ;
            // bKeep |= F(flags2P) & flDATUM2_ScOUNT                 ;
            // bKeep |= F(flags2P) & flDATUM2_strokeS                ;
            // bKeep |= F(flags1P) & flDATUM1_ADAMlIFEtIME            ;
            // bKeep |= F(flags2P) & flDATUM2_LINUX                  ;
            // bKeep |= F(flags2P) & flDATUM2_WINDOWSnT              ;
            // bKeep |= F(flags2P) & flDATUM2_WINDOWS98              ;
            // bKeep |= F(flags2P) & flDATUM2_WINDOWS95              ;
            // bKeep |= F(flags2P) & flDATUM2_OS2                    ;
        }
        if( bKeep )
        //U:#endif
    
        {
            ZE( byteT* , pbOut ) ;
    
            //if( !psttUid ) strMakeF( tinP , LF , psttUid , T("") ) ;
            //ZE( osTextT* , postUid ) ;
            //ZE( countT , costUid ) ;
            //strMakeF( tinP , LF , postUid , psttUid ) ;
    
            const countT idCitizenHirerI = ether_idCitizenHirerI_F( tinP ) ;
            countT idComputer = diskIdF( tinP , T("///c") ) ;
            nicNameC nicName ;
            IFsCRATCH
            {
                SCOOPS
                nicName = socketC::nicNameIF( tinP , *tinP.pEtScratch ) ;
                if( POOP ) POOPR
            }
            ZE( countT , time1 ) ;
            ZE( sCountT , time2 ) ;
            third.osTimeNowF( tinP , time1 , time2 ) ;
            countT cbr = ( strBodyLengthF( tinP , pcResourceId ) + 1 ) * sizeof( countT ) ; // EXCLUDING THE idFileImmutable OF THE OWNER OF THIS etherC OBJECT
            countT cbOut = 0xb * sizeof( countT ) + processGlobal1I.cb_nicNameC_ + cbr + cbd ;
            newF( tinP , LF , pbOut , cbOut ) ; ___( pbOut ) ;
            const countT cbOutNet = cbOut - sizeof( countT ) ;
    
            // KEEP THIS IN SYNC WITH headerS IN 3f30104
                      memCopyF( tinP , pbOut                                                 , (byteT*)&cbOutNet           , sizeof(countT)   ) ; // 1
                      memCopyF( tinP , pbOut +   1 * sizeof(countT)                          , (byteT*)&idCitizenHirerI     , sizeof(countT)   ) ; // 2
                      memCopyF( tinP , pbOut +   2 * sizeof(countT)                          , (byteT*)&time1              , sizeof(countT)   ) ; // 3
                      memCopyF( tinP , pbOut +   3 * sizeof(countT)                          , (byteT*)&time2              , sizeof(countT)   ) ; // 4
                      memCopyF( tinP , pbOut +   5 * sizeof(countT)                          , (byteT*)&cbd                , sizeof(countT)   ) ; // 6
                      memCopyF( tinP , pbOut +   6 * sizeof(countT)                          , (byteT*)&amountP            , sizeof(countT)   ) ; // 7
                      memCopyF( tinP , pbOut +   7 * sizeof(countT)                          , (byteT*)&flags1             , sizeof(countT)   ) ; // 8
                      memCopyF( tinP , pbOut +   8 * sizeof(countT)                          , (byteT*)&flags2             , sizeof(countT)   ) ; // 8
                      memCopyF( tinP , pbOut +   9 * sizeof(countT)                          , (byteT*)&idComputer         , sizeof(countT)   ) ; // 9
                      memCopyF( tinP , pbOut + 0xa * sizeof(countT)                          , (byteT*)&processGlobal1I.idAdamRoot            , sizeof(countT)   ) ; // a
                      memCopyF( tinP , pbOut + 0xb * sizeof(countT)                          , (byteT*)&nicName            , processGlobal1I.cb_nicNameC_      ) ;
                      memCopyF( tinP , pbOut + 0xb * sizeof(countT) + processGlobal1I.cb_nicNameC_       , (byteT*)pcResourceId        , cbr              ) ;
            if( cbd ) memCopyF( tinP , pbOut + 0xb * sizeof(countT) + processGlobal1I.cb_nicNameC_ + cbr , pbP                         , cbd              ) ;
    
            // ENABLE THE COMMENTED OUT CODE (AND EDIT) IN ORDER TO INCLUDE THE UID IN THE DATA
            //memCopyF( tinP , pbOut + 0xb * sizeof(countT) + cbr , postUid                 , costUid        ) ;
            //if( cbd )
            //{
            //    memCopyF( tinP , pbOut + 0xb * sizeof(countT) + cbr + costUid , " \"" , 2 ) ;
            //    memCopyF( tinP , pbOut + 0xb * sizeof(countT) + cbr + costUid + 1 , pbP , cbd ) ;
            //    memCopyF( tinP , pbOut + 0xb * sizeof(countT) + cbr + costUid , "\"" , 2 ) ;
            //}
            //delF( tinP , postUid ) ;
    
            //U: REPLACE ALL Uid CODE WITH CODE THAT USES idCitizenHirerI
            //if( psttUid ) { boxPutUniqueF( tinP , psttu , tFile+T(".uid.")+T(psttUid)+T(".uid") , pbOut , cbOut ) ; ___( psttu ) ; }
            //else          { boxPutUniqueF( tinP , psttu , tFile+T(".uid.unk.uid" )                                             , pbOut , cbOut ) ; ___( psttu ) ; }
    
            ZE( boolT , bSent ) ;
            IFsCRATCH
            {
                SCOOPS
                {
                    socketC sOut( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                    sOut.connectF( tinP , ifcPORToLD1rIVERrESERVED ) ;
    
                    sOut.writeMsgF( tinP , pbOut , cbOut ) ;
                    sOut.writeMsgF( tinP , "!amDry" ) ;
                }
    
                bSent = !POOP ;
                if( POOP )
                {
                    POOPR
                    ZE( strokeS* , psttnu ) ;
                    tinP.pEtScratch->etherGetLogF( tinP , psttnu ) ;
                    delF( tinP , psttnu ) ;
                }
            }
    
            if( !bSent ) boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/city/data/out/dat.")+TF3(flags1,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".")+TF3(idCitizenHirerI,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".")+TF3(time2,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".")+TF3(time1,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".")+TF3(idComputer,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".")+TF3(tinP.monitor.idThread,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) , pbOut , cbOut ) ;
            delF( tinP , pbOut ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600207f.etherc.ifcdatumf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002080.etherc.strbodylengthf BEGIN
#define DDNAME       "3func.36002080.etherc.strbodylengthf"
#define DDNUMB      (countT)0x36002080
#define IDFILE      (countT)0xca7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strBodyLengthF.0.html\"\>instances\</A\>
\<A HREF=\"5.103008e.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.aa10104.1.1.0.html\"\>aa10104:  WAKEsHOW( "example.simplest.func.103008e.etherC.strBodyLengthF" )\</A\>
evaluates to the number of countT objects in the string, excluding the terminating null countT object
arguments
 pcP
*/
/**/

/*1*/countT etherC::strBodyLengthF( tinS& tinP , const countT* pcP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    _IO_
    countT cc = third.strBodyLengthF( tinP , pcP ) ;_WQ
    return cc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002080.etherc.strbodylengthf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002081.etherc.strfendf BEGIN
#define DDNAME       "3func.36002081.etherc.strfendf"
#define DDNUMB      (countT)0x36002081
#define IDFILE      (countT)0xca8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFEndF.0.html\"\>instances\</A\>
\<A HREF=\"5.103008f.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 pcP
  must be not 0
 cnP
*/
/**/

/*1*/boolT etherC::strFEndF( tinS& tinP , const countT* const pcP , const countT cnP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( pcP ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_
    boolT bEnd = third.strFEndF( tinP , pcP , cnP ) ;_WQ
    return bEnd ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002081.etherc.strfendf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002082.etherc.boxpourf BEGIN
#define DDNAME       "3func.36002082.etherc.boxpourf"
#define DDNUMB      (countT)0x36002082
#define IDFILE      (countT)0xca9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxPourF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030090.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
 U: provide a boxSuckerF function so adam definitions can use this
 U: avoid hardcoded capacity limits
  strFuseSeparateF
evaluates to the number of files moved
arguments
 psttHostP
 psttLikeToP
 psttLikeFromP
 csttEstimateP
 cMaxP
  can be 0
  if not 0 then this is the maximum number of files that will be poured
*/
/**//*1*/countT etherC::boxPourF( tinS& tinP , const strokeS* const psttHostP , const strokeS* const psttLikeToP , const strokeS* const psttLikeFromP , const countT csttEstimateP , const countT cMaxP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttHostP ) ;
        __Z( psttLikeToP ) ;
        __Z( psttLikeFromP ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( strokeS* , pstt1Remote ) ;
    ZE( strokeS* , pstt1Local ) ;
    ZE( countT , cFiles ) ;
    {
        soulC soul1m( tinP , TAG( TAGiDnULL ) ) ;
        cFiles = boxMenuF( tinP , soul1m , T(psttLikeFromP) + T("*") , 0 , cMaxP ) ;

        strokeS sttCut = psttLikeFromP[ CSpREFIX - 1 + psttLikeFromP->idAdam ] ;

        FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
        {
            if( POOP ) break ;

            ZE( strokeS* , pstt1w ) ;

            strFuseSeparateF( tinP , pstt1Local , psttc1 , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 0x100000 ) ; ___( pstt1w ) ;

            ZE( strokeS* , psttTo ) ;
            {
                ZE( strokeS* , psttSuffix ) ;
                ZE( countT , idl ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                countT idf = strIdF( tinP , countTC( 1 ) , sttq , sttCut , psttc1 , 0 , - 1 ) ;
                strSubstringF( tinP , psttSuffix , ++ idf , idl , psttc1 ) ; ___( psttSuffix ) ;
                strFuseF( tinP , psttTo , T(psttLikeToP)+T(psttSuffix) ) ; ___( psttTo ) ;
                delF( tinP , psttSuffix ) ;
            }

            strFuseSeparateF( tinP , pstt1Remote , psttTo , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 0x100000 ) ; ___( pstt1w ) ;
            delF( tinP , psttTo ) ;
        }
        FORsTRINGSiNsPANNEDcOMBINEDtAIL1
    }

    if( pstt1Remote )
    {
        __Z( pstt1Local ) ;
        diskFilePourF( tinP , psttHostP , pstt1Remote , pstt1Local ) ;
    }
    else __NZ( pstt1Local ) ;
    delF( tinP , pstt1Local ) ;
    delF( tinP , pstt1Remote ) ;
    return cFiles ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002082.etherc.boxpourf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002083.etherc.ifcdatumf BEGIN
#define DDNAME       "3func.36002083.etherc.ifcdatumf"
#define DDNUMB      (countT)0x36002083
#define IDFILE      (countT)0xcaa


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcDatumF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030091.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.8310104.1.1.0.html\"\>8310104:  WAKEsHOW( "example.simplest.func.1030091.etherC.ifcDatumF" )\</A\>
arguments
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010049.flDATUM1!||
 amountP
 pcResourceIdP
 psttP
*/
/**//*1*/voidT etherC::ifcDatumF( tinS& tinP , const flagsT flags1P , const flagsT flags2P , countT amountP , const countT* const pcResourceIdP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        FV( flDATUM1 , flags1P ) ;
        FV( flDATUM2 , flags2P ) ;
        if( POOP ) return ;
    }

    _IO_
    countT cb = ( 2 + psttP->idAdam ) * sizeof(strokeS) ;
    ifcDatumF( tinP , flags1P , flags2P , amountP , pcResourceIdP , (byteT*)psttP , cb ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002083.etherc.ifcdatumf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002084.etherc.osprocessf BEGIN
#define DDNAME       "3func.36002084.etherc.osprocessf"
#define DDNUMB      (countT)0x36002084
#define IDFILE      (countT)0xcab


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osProcessF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030092.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6510104.1.1.0.html\"\>6510104:  WAKEsHOW( "example.simplest.func.1030092.etherC.osProcessF" )\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 tidP
  must be 0
 pidP
  must be 0
 psttExeP
  the name of an executable
  example: T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/7use/0100002")+ether.osIdF(tinP,1)
 psttArgsP
  can be 0
  example: T("eb00104")
   this argument will work with the example value for psttExeP
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00101db.flPROCESShIRE!||
  it is illegal to set a value other than the default when calling from the definition of an adam
*/
/**/

/*1*/voidT etherC::osProcessF( tinS& tinP , countT& tidP , countT& pidP , const strokeS* const psttExeP , const strokeS* const psttArgsP , const flagsT flagsP , const handleC* phOutP , const handleC* phErrorP , const handleC* phInP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( pidP ) ;
        __Z( psttExeP ) ;
        FV( flPROCESShIRE , flagsP )                                                                                        \
        if( POOP ) return ;
    }

    _IO_
    /*osFileNameC*/
    #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000003.argsForOrphanProcessLaunch.h"

    third.dosExecPgmF( tinP , tidP , pidP , osf , post1Args , flagsP , phOutP , phErrorP , phInP ) ;
    delF( tinP , postExe ) ;
    delF( tinP , post1Args ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002084.etherc.osprocessf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002085.etherc.ethergetlogf BEGIN
#define DDNAME       "3func.36002085.etherc.ethergetlogf"
#define DDNUMB      (countT)0x36002085
#define IDFILE      (countT)0xcac


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherGetLogF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030093.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9410104.1.1.0.html\"\>9410104:  WAKEsHOW( "example.simplest.func.1030093.etherC.etherGetLogF" )\</A\>
clears the internal log for this etherC object after retrieving its contents
arguments
 psttP
  will contain the current contents of the data log for this ether object
*/
/**/

/*1*/voidT etherC::etherGetLogF( tinS& tinP , strokeS*& psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    processGlobal4I._etherC_bLog.grabF( tinP , TAG( TAGiDnULL ) ) ;
    if( psttLog )
    {
        psttP = psttLog ;
        psttLog = 0 ;
    }
    processGlobal4I._etherC_bLog.ungrabF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002085.etherc.ethergetlogf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002086.etherc.etherputlogf BEGIN
#define DDNAME       "3func.36002086.etherc.etherputlogf"
#define DDNUMB      (countT)0x36002086
#define IDFILE      (countT)0xcad


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherPutLogF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030094.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.8410104.1.1.0.html\"\>8410104:  WAKEsHOW( "example.simplest.func.1030094.etherC.etherPutLogF" )\</A\>
arguments
 psttP
  text to enter into the data log for this ether object
  example: T("hello, people at IdeaFarm " "(tm) City center!")
*/
/**/

/*1*/voidT etherC::etherPutLogF( tinS& tinP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    processGlobal4I._etherC_bLog.grabF( tinP , TAG( TAGiDnULL ) ) ;
    strFuseF( tinP , psttLog , psttP , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ CSeXTRAlOG ) ; ___( psttLog ) ;
    processGlobal4I._etherC_bLog.ungrabF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002086.etherc.etherputlogf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002087.etherc.boxgetgenerationf BEGIN
#define DDNAME       "3func.36002087.etherc.boxgetgenerationf"
#define DDNUMB      (countT)0x36002087
#define IDFILE      (countT)0xcae


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxGetGenerationF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030095.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6810104.1.1.0.html\"\>6810104:  WAKEsHOW( "example.simplest.func.1030095.etherC.boxGetGenerationF" )\</A\>
if ageP is 0, obtains the latest generation of a box
otherwise, obtains an older generation of a box
the generation that was obtained is then d eleted
if the requested generation does not exist, pbP will remain 0 and ether will remain potent
arguments
 pbP
 cbP
 psttP
 psttLikeP
 ageP
 cOpenTriesP
  if 0 then will retry forever
  if not 0 then will try cOpenTriesP times
*/
/**//*1*/voidT etherC::boxGetGenerationF( tinS& tinP , byteT*& pbP , countT& cbP , strokeS*& psttP , const strokeS* const psttLikeP , const countT csttEstimateP , const countT ageP , countT cOpenTriesP , const countT cZapTriesP , const flagsT flagsOpenDetailsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pbP ) ;
        __NZ( cbP ) ;
        __NZ( psttP ) ;
        __Z( psttLikeP ) ;
    }

    _IO_
    ZE( countT , idMax ) ;
    ZE( countT , idMin ) ;
    boxMenuIdRangeF( tinP , idMin , idMax , T(psttLikeP)+T(".*") , csttEstimateP ) ;
    sCountT idWant = idMax - ageP ;

    if( idWant && idWant >= idMin )
    {
        strFuseF( tinP , psttP , T(psttLikeP)+T(".")+TF3(idWant,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ) ; ___( psttP ) ;
        boxC box( tinP , *this , psttP , 0 , 0 , 0 , cOpenTriesP , 0 , 0 , flagsOpenDetailsP ) ;
        box.getF( tinP , pbP , cbP ) ; ___( pbP ) ;
        box.zapF( tinP , cZapTriesP ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002087.etherc.boxgetgenerationf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002088.etherc.boxputgenerationf BEGIN
#define DDNAME       "3func.36002088.etherc.boxputgenerationf"
#define DDNUMB      (countT)0x36002088
#define IDFILE      (countT)0xcaf


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxPutGenerationF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030096.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.5810104.1.1.0.html\"\>5810104:  WAKEsHOW( "example.simplest.func.1030096.etherC.boxPutGenerationF" )\</A\>
use this to write uniquely named files to an ftp server or local file
arguments
 psttP
  must be 0
  will contain the unique name used
 psttLikeP
  must not be 0
  the unique name is derived from this
 csttEstimateP
  must be large enough to hold a list of the names of all generations
 pbP
  must not be 0
 cbP
  can be 0
  if 0 then the null terminated byteT string at pbP will be written
  the terminating null will -not- be written
 cOpenTriesP
  if 0 then will retry forever
  if not 0 then will try cTriesP times
  U: this has no effect; set it to 0
*/
/**//*1*/voidT etherC::boxPutGenerationF( tinS& tinP , strokeS*& psttP , const strokeS* const psttLikeP , const countT csttEstimateP , const byteT* const pbP , const countT cbP , countT cOpenTriesP , const flagsT flagsOpenDetailsP )/*1*/
{
    SCOOP
    countT cbw = cbP ;
    if( !cbw ) cbw = strBodyLengthF( tinP , pbP ) ;

    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( psttLikeP ) ;
        __Z( pbP ) ;
        __Z( cbw ) ;
        if( POOP ) return ;
    }

    _IO_
    boxC box( tinP , *this , psttLikeP , 0 , 0 , 0 , cOpenTriesP , 0 , 0 , flagsOpenDetailsP ) ;
    box.putGenerationF( tinP , psttP , csttEstimateP , pbP , cbw ) ; ___( psttP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002088.etherc.boxputgenerationf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002089.etherc.sockmynamef BEGIN
#define DDNAME       "3func.36002089.etherc.sockmynamef"
#define DDNUMB      (countT)0x36002089
#define IDFILE      (countT)0xcb0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockMyNameF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030097.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.3710104.1.1.0.html\"\>3710104:  WAKEsHOW( "example.simplest.func.1030097.etherC.sockMyNameF" )\</A\>
obtains this socket's host id and port id
it is illegal to call me on an unconnected socket when a valid nicNameP is needed
 on an unconnected socket on a multihomed host, nicNameP is undefined on return
arguments
 idPortP
  must be 0
 nicNameP
  must be 0
 handleP
  must not be 0
*/
/**/

/*1*/voidT etherC::sockMyNameF( tinS& tinP , countT& idPortP , nicNameC& nicNameP , const handleC& handleP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( nicNameP ) ;
        __NZ( idPortP ) ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_myNameF( tinP , idPortP , nicNameP , handleP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002089.etherc.sockmynamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600208a.etherc.sockpeernamef BEGIN
#define DDNAME       "3func.3600208a.etherc.sockpeernamef"
#define DDNUMB      (countT)0x3600208a
#define IDFILE      (countT)0xcb1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockPeerNameF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030098.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.4710104.1.1.0.html\"\>4710104:  WAKEsHOW( "example.simplest.func.1030098.etherC.sockPeerNameF" )\</A\>
obtains the peer's host id and port id
the socket must be connected
arguments
 idPortP
  must be 0
 nicNameP
  must be 0
 handleP
  must not be 0
*/
/**//*1*/voidT etherC::sockPeerNameF( tinS& tinP , countT& idPortP , nicNameC& nicNameP , const handleC& handleP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( nicNameP ) ;
        __NZ( idPortP ) ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_peerNameF( tinP , idPortP , nicNameP , handleP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600208a.etherc.sockpeernamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600208b.etherc.osthreadswitchingofff BEGIN
#define DDNAME       "3func.3600208b.etherc.osthreadswitchingofff"
#define DDNUMB      (countT)0x3600208b
#define IDFILE      (countT)0xcb2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osThreadSwitchingOffF.0.html\"\>instances\</A\>
\<A HREF=\"5.103009a.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.d510104.1.1.0.html\"\>d510104:  WAKEsHOW( "example.simplest.func.103009a.etherC.osThreadSwitchingOffF" )\</A\>
disables thread context switching
it is illegal to refer to this symbol in the definition of an adam
*/
/**/

/*1*/voidT etherC::osThreadSwitchingOffF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __1
        if( POOP ) return ;
    }

    //IN, OUT ARE SUPPRESSED SO THAT THIS FUNCTION DOES NOT APPEAR IN tinP'S TRACE FOR THIS THREAD
    //OTHERWISE, I WOULD APPEAR ALL OVER THE PLACE BECAUSE IN, OUT CALL ME FOR EVERY FUNCTION
    //THESE LINES HERE CAN BE ENABLED IF NEEDED.  THEY ARE COMMENTED OUT ONLY FOR COSMETIC REASONS (TO IMPROVE THE READABILITY OF THE TRACE INFORMATION IN tinS)
    //IN
    third.dosEnterCritSecF( tinP ) ;
    //OUT
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600208b.etherc.osthreadswitchingofff END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600208c.etherc.osthreadswitchingonf BEGIN
#define DDNAME       "3func.3600208c.etherc.osthreadswitchingonf"
#define DDNUMB      (countT)0x3600208c
#define IDFILE      (countT)0xcb3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osThreadSwitchingOnF.0.html\"\>instances\</A\>
\<A HREF=\"5.103009b.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.e510104.1.1.0.html\"\>e510104:  WAKEsHOW( "example.simplest.func.103009b.etherC.osThreadSwitchingOnF" )\</A\>
enables thread context switching
it is illegal to refer to this symbol in the definition of an adam
*/
/**/

/*1*/voidT etherC::osThreadSwitchingOnF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __1
        if( POOP ) return ;
    }

    //IN, OUT ARE SUPPRESSED SO THAT THIS FUNCTION DOES NOT APPEAR IN tinP'S TRACE FOR THIS THREAD
    //OTHERWISE, I WOULD APPEAR ALL OVER THE PLACE BECAUSE IN, OUT CALL ME FOR EVERY FUNCTION
    //THESE LINES HERE CAN BE ENABLED IF NEEDED.  THEY ARE COMMENTED OUT ONLY FOR COSMETIC REASONS (TO IMPROVE THE READABILITY OF THE TRACE INFORMATION IN tinS)
    //IN_E
    third.dosExitCritSecF( tinP ) ;
    //OUT
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600208c.etherc.osthreadswitchingonf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600208d.etherc.diskfilepourf BEGIN
#define DDNAME       "3func.3600208d.etherc.diskfilepourf"
#define DDNUMB      (countT)0x3600208d
#define IDFILE      (countT)0xcb4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskFilePourF.0.html\"\>instances\</A\>
\<A HREF=\"5.103009c.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 psttHostP
 pstt1RemoteP
 pstt1LocalP
*/
/**/

// PARAMETERS 1 AND 2 ARE FILE NAMES SEPARATED BY SINGLE BLANKS

/*1*/voidT etherC::diskFilePourF( tinS& tinP , const strokeS* const psttHostP , const strokeS* const pstt1RemoteP , const strokeS* const pstt1LocalP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttHostP ) ;
        __Z( pstt1RemoteP ) ;
        __Z( pstt1LocalP ) ;
        if( POOP ) return ;
    }

    _IO_
    // COUNT THE FILES, BUILD THE LIST, COLLECT THE DATA
    ZE( strokeS* , psttList ) ;
    ZE( _1S* , p1Root ) ;
    {
        TN( tSuck , "//box.sucker/" ) ;
        strFuseF( tinP , psttList , psttHostP , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ pstt1RemoteP->idAdam + tSuck.csF( tinP ) + pstt1LocalP->idAdam ) ; ___( psttList ) ;
        strFuseF( tinP , psttList , tSuck ) ; ___( psttList ) ;
        ZE( countT , cFiles ) ;
        ZE( boolT , fPrior ) ;
        const strokeS* psttc1rp = pstt1RemoteP + CSpREFIX ;
        FORsTRINGSiN1( (strokeS*)pstt1LocalP )
        {
            if( POOP ) break ;
            cFiles ++ ;

            if( fPrior ) { strFuseF( tinP , psttList , T(" ") ) ; ___( psttList ) ; }
            else         fPrior = 1 ;
            strFuseF( tinP , psttList , psttc1rp ) ; ___( psttList ) ;

            ZE( _1S* , p1c ) ;
            if( !p1Root )
            {
                p1c = p1Root = new( 0 , tinP , LF ) _1S( tinP , *this , p1Root ) ; ___( p1Root ) ;
            }
            else
            {
                p1c = p1Root ;
                while( p1c && p1c->pR ) p1c = p1c->pR ;
                p1c->pR = new( 0 , tinP , LF ) _1S( tinP , *this , p1Root ) ; ___( p1c->pR ) ;
                p1c->pR->pL = p1c ;
                p1c = p1c->pR ;
            }

            if( p1c ) { boxGetShadowF( tinP , p1c->pbd , p1c->cbd , psttc1 ) ; ___( p1c->pbd ) ; }

            psttc1rp += CSpREFIX + psttc1rp->idAdam ;
        }
    }

    // BUILD THE AGGREGATE
    ZE( byteT* , pbAll ) ;
    ZE( countT , cbAll ) ;
    __Z( p1Root ) ;
    if( p1Root )
    {
        if( !p1Root->pR )
        {
            cbAll = p1Root->cbd ;
        }
        else
        {
            ZE( _1S* , p1c ) ;
            p1c = p1Root ;
            while( p1c )
            {
                cbAll += sizeof p1c->cbd ;
                cbAll += p1c->cbd ;
                p1c = p1c->pR ;
            }
        }
        newF( tinP , LF , pbAll , cbAll ) ; ___( pbAll ) ;

        if( !p1Root->pR )
        {
            __( cbAll - p1Root->cbd ) ;
            memCopyF( tinP , pbAll , p1Root->pbd , cbAll ) ;
        }
        else
        {
            ZE( _1S* , p1c ) ;
            p1c = p1Root ;
            ZE( byteT* , pbc ) ;
            pbc = pbAll ;
            while( p1c )
            {
                memCopyF( tinP , pbc , (byteT*)&p1c->cbd , sizeof p1c->cbd ) ;
                pbc += sizeof p1c->cbd ;

                memCopyF( tinP , pbc , p1c->pbd , p1c->cbd ) ;
                pbc += p1c->cbd ;

                p1c = p1c->pR ;
            }
        }
    }

    __Z( cbAll ) ;
    boxPutF( tinP , psttList , pbAll , cbAll ) ;
    delF( tinP , psttList ) ;
    delF( tinP , pbAll ) ;

    // DELETE THE LOCAL FILES
    {
        FORsTRINGSiN1( (strokeS*)pstt1LocalP )
        {
            if( POOP ) break ;
            boxZapF( tinP , psttc1 ) ;
        }
    }

    while( p1Root ) delete p1Root ; //DON''T USE DEL HERE
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600208d.etherc.diskfilepourf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600208e.etherc.ostimefromoldtimef BEGIN
#define DDNAME       "3func.3600208e.etherc.ostimefromoldtimef"
#define DDNUMB      (countT)0x3600208e
#define IDFILE      (countT)0xcb5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osTimeFromOldTimeF.0.html\"\>instances\</A\>
\<A HREF=\"5.103009d.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.c510104.1.1.0.html\"\>c510104:  WAKEsHOW( "example.simplest.func.103009d.etherC.osTimeFromOldTimeF" )\</A\>
calculates city time from conventional calendar time
 this function correctly accounts for leap years and leap centuries
i cannot be used to convert
do not use me to convert elapsed conventional time to elapsed IFC time
 use thirdC::timeFromSecondsIF or thirdC::timeFromMsIF
time2P will be set to the number of complete days since Jesus's conventional time of birth
time1P will be set to the remainder, in time units
a time unit is 1 / ( 256 * 256 * 256 * 256 ) of a day
all paramters are specified as ze based offsets
 yP: the number of complete years since Jesus's conventional time of birth
  set yP = 0 for a time in the first year of our lord
  set yP = -1 for a time in the last year before our lord
  example: for a time during the year 2010_9, set yP to 2009_9
  the domain of this parameter is unrestricted; any value can be specified
 mP: the number of complete months after yP since Jesus's conventional time of birth
  the domain of this parameter is [0,11]
 dP: the number of complete days after yP mP since Jesus's conventional time of birth
  the domain of this parameter is [0,30]
 hhP: the number of complete hours after yP dP since Jesus's conventional time of birth
  the domain of this parameter is [0,23]
 mmP: the number of complete minutes after yP dP hhP since Jesus's conventional time of birth
  the domain of this parameter is [0,59]
 ssP: the number of complete seconds after yP dP hhP mmP since Jesus's conventional time of birth
  the domain of this parameter is [0,59]
 msP: the number of complete milliseconds after yP dP hhP mmP ssP since Jesus's conventional time of birth
  the domain of this parameter is [0,999]
arguments
 time1P
 time2P
 yP
 mP
 dP
 hhP
 mmP
 ssP
 msP
*/
/**//*1*/voidT etherC::osTimeFromOldTimeF( tinS& tinP , countT& time1P , sCountT& time2P , sCountT yP , countT mP , countT dP , countT hhP , countT mmP , countT ssP , countT msP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        FV( flOStIMEfROMoLDtIME , flagsP ) ;
        if( POOP ) return ;
    }

    _IO_
    thirdC::osTimeFromOldTimeIF( tinP , time1P , time2P , yP , mP , dP , hhP , mmP , ssP , msP , flagsP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600208e.etherc.ostimefromoldtimef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600208f.etherc.sleepstartf BEGIN
#define DDNAME       "3func.3600208f.etherc.sleepstartf"
#define DDNUMB      (countT)0x3600208f
#define IDFILE      (countT)0xcb6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sleepStartF.0.html\"\>instances\</A\>
\<A HREF=\"5.103009e.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
*/
/**/

/*1*/voidT etherC::sleepStartF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    bClocks.grabF( tinP , TAG( TAGiDnULL ) ) ;
    if( !timeSleep2 && !timeSleep1 ) third.osTimeNowF( tinP , timeSleep1 , timeSleep2 ) ;
    bClocks.ungrabF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600208f.etherc.sleepstartf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002090.etherc.sleependf BEGIN
#define DDNAME       "3func.36002090.etherc.sleependf"
#define DDNUMB      (countT)0x36002090
#define IDFILE      (countT)0xcb7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sleepEndF.0.html\"\>instances\</A\>
\<A HREF=\"5.103009f.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
*/
/**/

/*1*/voidT etherC::sleepEndF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    bClocks.grabF( tinP , TAG( TAGiDnULL ) ) ;_WQ
    if( timeSleep2 || timeSleep1 )
    {
        ZE( countT , time1 ) ;_WQ
        ZE( sCountT , time2 ) ;_WQ
        third.osTimeNowF( tinP , time1 , time2 ) ;_WQ
        third.osTimeSubtractF( tinP , time1 , time2 , timeSleep1 , timeSleep2 ) ;_WQ
        thirdC::osTimeAddIF( tinP , timeSlept1 , timeSlept2 , time1 , time2 ) ;_WQ
    }
    bClocks.ungrabF( tinP ) ;_WQ
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002090.etherc.sleependf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002091.etherc.ostimewatchf BEGIN
#define DDNAME       "3func.36002091.etherc.ostimewatchf"
#define DDNUMB      (countT)0x36002091
#define IDFILE      (countT)0xcb8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osTimeWatchF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300a0.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.b510104.1.1.0.html\"\>b510104:  WAKEsHOW( "example.simplest.func.10300a0.etherC.osTimeWatchF" )\</A\>
maintains time1P and time2P to contain the current time
ends when fFireP is not ze
gives the sign immediately after updating time1P and time2P
arguments
 time1P
 time2P
 sgnP
 fFireP
 timeGrainP
*/
/**//*1*/voidT etherC::osTimeWatchF( tinS& tinP , countT& time1P , sCountT& time2P , signC& sgnP , boolT& fFireP , countT timeGrainP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( time1P ) ;
        __NZ( time2P ) ;
        if( POOP ) return ;
    }

    _IO_
    third.osTimeNowF( tinP , time1P , time2P ) ;
    sgnP.giveF( tinP ) ;
    countT timeHire1 = time1P ;
    sCountT timeHire2 = time2P ;

    {
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        while( !POOP && !fFireP )
        {
            ++ s ; third.dosSleepIF( tinP , timeGrainP ) ;
            time1P = time2P = 0 ;
            third.osTimeNowF( tinP , time1P , time2P ) ;
            sgnP.giveF( tinP ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002091.etherc.ostimewatchf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002092.etherc.osprocessf BEGIN
#define DDNAME       "3func.36002092.etherc.osprocessf"
#define DDNUMB      (countT)0x36002092
#define IDFILE      (countT)0xcb9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osProcessF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300a1.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9510104.1.1.0.html\"\>9510104:  WAKEsHOW( "example.simplest.func.10300a1.etherC.osProcessF" )\</A\>
it is illegal to refer to this symbol in the definition of an adam
constructs a process and waits for it to die
arguments
 valueP
  must be 0
 idDeathTypeP
  must be 0
 psttExeP
  the name of an executable
  example: T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/7use/0100002")+ether.osIdF(tinP,1)
 psttArgsP
  can be 0
  example: T("eb00104")
   this argument will work with the example value for psttExeP
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00101db.flPROCESShIRE!||
  it is illegal to set a value other than the default when calling from the definition of an adam
*/
/**/
#if !defined( osFileNameC )
    #define osFileNameC osFileNameC
#endif
/*1*/voidT etherC::osProcessF( tinS& tinP , countT& osTidP , countT& osPidP , countT& valueP , countT& idDeathTypeP , const strokeS* const psttExeP , const strokeS* const psttArgsP , const flagsT flagsP , const handleC* phOutP , const handleC* phErrorP , const handleC* phInP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( valueP ) ;
        __( idDeathTypeP ) ;
        __Z( psttExeP ) ;
        if( POOP ) return ;
    }

    _IO_
    /*osFileNameC*/
    #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000003.argsForOrphanProcessLaunch.h"

    third.dosExecPgmF( tinP , osTidP , osPidP , valueP , idDeathTypeP , osf , post1Args , flagsP , phOutP , phErrorP , phInP ) ;
    delF( tinP , postExe ) ;
    delF( tinP , post1Args ) ;
}
#undef osFileNameC


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002092.etherc.osprocessf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002093.etherc.osprocessforwardsignalstome_offf BEGIN
#define DDNAME       "3func.36002093.etherc.osprocessforwardsignalstome_offf"
#define DDNUMB      (countT)0x36002093
#define IDFILE      (countT)0xcba


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osProcessForwardSignalsToMe_offF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300a2.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
disables signal exceptions (control c) for this process
*/
/**//*1*/voidT etherC::osProcessForwardSignalsToMe_offF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.dosSetSignalExceptionFocus_offF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002093.etherc.osprocessforwardsignalstome_offf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002094.etherc.osprocessforwardsignalstome_onf BEGIN
#define DDNAME       "3func.36002094.etherc.osprocessforwardsignalstome_onf"
#define DDNUMB      (countT)0x36002094
#define IDFILE      (countT)0xcbb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osProcessForwardSignalsToMe_onF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300a3.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
enables signal exceptions (control c) for this process
*/
/**//*1*/voidT etherC::osProcessForwardSignalsToMe_onF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.dosSetSignalExceptionFocus_onF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002094.etherc.osprocessforwardsignalstome_onf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002095.etherc.strtrimf BEGIN
#define DDNAME       "3func.36002095.etherc.strtrimf"
#define DDNUMB      (countT)0x36002095
#define IDFILE      (countT)0xcbc


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strTrimF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300a4.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.ba10104.1.1.0.html\"\>ba10104:  WAKEsHOW( "example.simplest.func.10300a4.etherC.strTrimF" )\</A\>
psttOldP: can be 0
psttItemDelimiterP: delimits each line
 if 0 then T("\r\n") is used
psttDoomedListP: strokes that will be removed from the beginning and end of each line
 if 0 then T(" \t\x1a") is used
  spaces (' '), tabs ('\t'), and end of file marks ('\x1a') are removed
sttNewP: this is not used, and must be 0
arguments
 psttP
 psttOldP
 psttItemDelimiterP
 psttDoomedListP
 sttNewP
*/
/**/

//U:: 20130108@2102: THIS DOES NOT WORK.  SEE ADAM 51000675

/*1*/countT etherC::strTrimF( tinS& tinP , strokeS*& psttP , const strokeS* const psttOldP , const strokeS* const psttItemDelimiterP , const strokeS* const psttDoomedListP , const strokeS sttNewP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( sttNewP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( strokeS* , psttDoomedList ) ;
    if( psttDoomedListP ) { strFuseF( tinP , psttDoomedList , psttDoomedListP                                     ) ; ___( psttDoomedList ) ; }
    else                  { strMakeF( tinP , LF , psttDoomedList , T(psttItemDelimiterP?TbLACKeXCLUDINGnEWlINE:TbLACK) ) ; ___( psttDoomedList ) ; }

    ZE( strokeS* , psttOld ) ;
    if( psttOldP ) { strMakeF( tinP , LF , psttOld , psttOldP ) ; ___( psttOld ) ; }
    else
    {
        psttOld = psttP ;
        psttP = 0 ;
    }
    __NZ( psttP ) ;

    // REMOVE ANY TRAILING DELIMITERS
    if( psttItemDelimiterP ) while( !POOP )
    {
        countT cs = psttOld ? psttOld->idAdam : 0 ;
        countT cd = psttItemDelimiterP ? psttItemDelimiterP->idAdam : 0 ;
        if( cs < cd ) break ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT iddl = strIdF( tinP , 0 , flSTRmATCH_null , countTC( 1 ) , sttq , psttItemDelimiterP ,  psttOld , 0 , - 1 ) ;
        if( iddl != cs - cd + 1 ) break ;
        ZE( strokeS* , psttd ) ;
        psttd = psttOld ;
        psttOld = 0 ;
        countT idf = 1 ;
        iddl -- ;
        if( iddl ) { strSubstringF( tinP , psttOld , idf , iddl , psttd ) ; ___( psttOld ) ; }
        else       { strMakeF( tinP , LF , psttOld , T("") ) ; ___( psttOld ) ; }
        delF( tinP , psttd ) ;
    }

    strMakeF( tinP , LF , psttP , T("") , psttOld ? psttOld->idAdam : 0 ) ; // CALLER MUST TAG ___( psttP ) ;
    countT idf = 1 ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( countT , csttFromBeginning ) ;
    boolT bWoth = 1 ;
    while( !POOP && idf ) 
    {
        ZE( countT , idd ) ;
        if( psttItemDelimiterP ) { countT idf1 = idf ; strokeS sttq1 = sttq ; idd = strIdF( tinP , 0 , flSTRmATCH_null , idf1 , sttq1 , psttItemDelimiterP , psttOld ) ; }
        // idd: ID OF NEXT DELIMITER

        ZE( strokeS* , psttw ) ;
        if( psttItemDelimiterP ) { strSubstringF( tinP , psttw , idf , sttq , psttItemDelimiterP , psttOld , 0 ) ; ___( psttw ) ; }
        else
        {
            idf = 0 ;
            psttw = psttOld ; psttOld = 0 ;
        }
        // psttw: CURRENT LINE TO PROCESS

        ZE( strokeS* , psttw2 ) ;
        if( psttw )
        {
            strokeS sttq1 = sttq ;
            countT idf1 = strIdAnyF( tinP , 0 , flSTRmATCH_null , countTC( 1 ) , sttq1 , psttDoomedList , psttw , 0 , 1 , flSTRiDaNY_NOT ) ;

            if( !idf1 )
            {
                if( bWoth )
                {
                    bWoth = 0 ;
                    csttFromBeginning = psttw->idAdam ;
                }

                strMakeF( tinP , LF , psttw2 , T("") ) ; ___( psttw2 ) ;
            }
            else
            {
                if( bWoth )
                {
                    bWoth = 0 ;
                    csttFromBeginning = idf1 - 1 ;
                }

                strSubstringF( tinP , psttw2 , idf1 , countTC() , psttw ) ; ___( psttw2 ) ;
            }
        }
        delF( tinP , psttw ) ;
        // psttw2: LEADING DOOMED HAVE BEEN REMOVED

        ZE( strokeS* , psttTrimmed ) ;
        if( psttw2 )
        {
            countT idf1 = 1 ;
            strokeS sttq1( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( countT , cWanted ) ;
            while( !POOP )
            {
                countT idd = strIdAnyF( tinP , 0 , flSTRmATCH_null , idf1 , sttq1 , psttDoomedList , psttw2 ) ;
                if( !idd ) break ;
                if( idf1 ) continue ;
                cWanted = idd - 1 ;
                break ;
            }

            if( !cWanted ) { psttTrimmed = psttw2 ; psttw2 = 0 ; }
            else           { strSubstringF( tinP , psttTrimmed , countTC( 1 ) , cWanted , psttw2 ) ; ___( psttTrimmed ) ; }

            delF( tinP , psttw2 ) ;
        }

        if( psttTrimmed && psttTrimmed->idAdam )
        {
            strFuseF( tinP , psttP , psttTrimmed ) ; ___( psttP ) ;
            if( idd ) { strFuseF( tinP , psttP , psttItemDelimiterP ) ; ___( psttP ) ; }
        }
        delF( tinP , psttTrimmed ) ;
    }

    delF( tinP , psttOld ) ;
    delF( tinP , psttDoomedList ) ;

    return csttFromBeginning ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002095.etherc.strtrimf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002096.etherc.osprocessinterruptf BEGIN
#define DDNAME       "3func.36002096.etherc.osprocessinterruptf"
#define DDNUMB      (countT)0x36002096
#define IDFILE      (countT)0xcbd


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osProcessInterruptF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300a5.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
sends a "control c" exception to the specified process
arguments
 pidP
*/
/**//*1*/voidT etherC::osProcessInterruptF( tinS& tinP , const countT pidP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.dosSendSignalExceptionF( tinP , pidP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002096.etherc.osprocessinterruptf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002097.etherc.osprocesskillf BEGIN
#define DDNAME       "3func.36002097.etherc.osprocesskillf"
#define DDNUMB      (countT)0x36002097
#define IDFILE      (countT)0xcbe


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osProcessKillF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300a6.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 pidP
*/
/**//*1*/voidT etherC::osProcessKillF( tinS& tinP , const countT pidP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.dosKillProcessF( tinP , pidP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002097.etherc.osprocesskillf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002098.etherc.osprocesswaitf BEGIN
#define DDNAME       "3func.36002098.etherc.osprocesswaitf"
#define DDNUMB      (countT)0x36002098
#define IDFILE      (countT)0xcbf


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osProcessWaitF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300a7.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7510104.1.1.0.html\"\>7510104:  WAKEsHOW( "example.simplest.func.10300a7.etherC.osProcessWaitF" )\</A\>
waits for the specified process to die
arguments
 valueP
  must be 0
 idDeathTypeP
  must be 0
 pidP
  must not be 0
*/
/**/

/*1*/voidT etherC::osProcessWaitF( tinS& tinP , countT& valueP , countT& idDeathTypeP , countT& pidP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.dosWaitChildF( tinP , valueP , idDeathTypeP , pidP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002098.etherc.osprocesswaitf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002099.etherc.spacersetf BEGIN
#define DDNAME       "3func.36002099.etherc.spacersetf"
#define DDNUMB      (countT)0x36002099
#define IDFILE      (countT)0xcc0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$spacerSetF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300a9.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
initializes areas within this object that will be used to detect corruption
*/
/**/

/*1*/voidT etherC::spacerSetF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    SPACERsET( a )
    SPACERsET( b )
    SPACERsET( c )
    SPACERsET( d )
    SPACERsET( e )
    SPACERsET( f )
    SPACERsET( g )
    SPACERsET( h )
    SPACERsET( i )
    SPACERsET( j )
    SPACERsET( k )
    SPACERsET( l )
    SPACERsET( m )
    SPACERsET( n )
    SPACERsET( o )
    SPACERsET( p )
    SPACERsET( q )
    SPACERsET( r )
    SPACERsET( s )
    SPACERsET( t )
    SPACERsET( u )
    SPACERsET( v )
    SPACERsET( w )
    SPACERsET( x )
    SPACERsET( y )
    SPACERsET( z )
    SPACERsET( 0 )
    SPACERsET( 1 )
    SPACERsET( 2 )
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002099.etherc.spacersetf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600209a.etherc.ethertestf BEGIN
#define DDNAME       "3func.3600209a.etherc.ethertestf"
#define DDNUMB      (countT)0x3600209a
#define IDFILE      (countT)0xcc1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherTestF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300aa.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
tests the integrity of this etherC object
if corrupted, then this ether object will become impotent
*/
/**/

/*1*/voidT etherC::etherTestF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    SPACERtEST( a )
    SPACERtEST( b )
    SPACERtEST( c )
    SPACERtEST( d )
    SPACERtEST( e )
    SPACERtEST( f )
    SPACERtEST( g )
    SPACERtEST( h )
    SPACERtEST( i )
    SPACERtEST( j )
    SPACERtEST( k )
    SPACERtEST( l )
    SPACERtEST( m )
    SPACERtEST( n )
    SPACERtEST( o )
    SPACERtEST( p )
    SPACERtEST( q )
    SPACERtEST( r )
    SPACERtEST( s )
    SPACERtEST( t )
    SPACERtEST( u )
    SPACERtEST( v )
    SPACERtEST( w )
    SPACERtEST( x )
    SPACERtEST( y )
    SPACERtEST( z )
    SPACERtEST( 0 )
    SPACERtEST( 1 )
    SPACERtEST( 2 )
    third.thirdTestF( tinP ) ;

    if( POOP )
    {
        BLAMMO ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600209a.etherc.ethertestf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600209b.etherc.newdeltypeether BEGIN
#define DDNAME       "3func.3600209b.etherc.newdeltypeether"
#define DDNUMB      (countT)0x3600209b
#define IDFILE      (countT)0xcc2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.10300ab.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.b410104.1.1.0.html\"\>b410104:  WAKEsHOW( "example.simplest.func.10300ab.etherC.NEWdELtYPEeTHER" )\</A\>
example code
 |    ZE( byteT* , pba ) ;
 |    ether.newF( tinP , LF , pba , 8 ) ; ___( pba ) ;
 |    ether.delF( tinP , pba ) ;
*/
/**/

/*1*/NEWdELtYPEeTHER( byteT )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600209b.etherc.newdeltypeether END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600209c.etherc.newdeltypeether BEGIN
#define DDNAME       "3func.3600209c.etherc.newdeltypeether"
#define DDNUMB      (countT)0x3600209c
#define IDFILE      (countT)0xcc3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.10300ac.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.c410104.1.1.0.html\"\>c410104:  WAKEsHOW( "example.simplest.func.10300ac.etherC.NEWdELtYPEeTHER" )\</A\>
example code
 |    ZE( countT* , pca ) ;
 |    ether.newF( tinP , LF , pca , 8 ) ; ___( pca ) ;
 |    ether.delF( tinP , pca ) ;
*/
/**/

/*1*/NEWdELtYPEeTHER( countT )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600209c.etherc.newdeltypeether END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600209d.etherc.newdeltypeether BEGIN
#define DDNAME       "3func.3600209d.etherc.newdeltypeether"
#define DDNUMB      (countT)0x3600209d
#define IDFILE      (countT)0xcc4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.10300ad.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.d410104.1.1.0.html\"\>d410104:  WAKEsHOW( "example.simplest.func.10300ad.etherC.NEWdELtYPEeTHER" )\</A\>
example code
 |    ZE( strokeS* , pstta ) ;
 |    ether.newF( tinP , LF , pstta , 8 ) ; ___( pstta ) ;
 |    ether.delF( tinP , pstta ) ;
*/
/**/

/*1*/NEWdELtYPEeTHER( strokeS )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600209d.etherc.newdeltypeether END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600209e.etherc.boxgetshadowsettingf BEGIN
#define DDNAME       "3func.3600209e.etherc.boxgetshadowsettingf"
#define DDNUMB      (countT)0x3600209e
#define IDFILE      (countT)0xcc5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$box GetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300af.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.4810104.1.1.0.html\"\>4810104:  WAKEsHOW( "example.simplest.func.10300af.etherC.box GetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF" )\</A\>
gets a setting from a box
the default is used when the box does not exist or it contains an unlisted value
the entire contents of the box is used as the value
psttBoxIP: the name of the box
 example: T("///ideafarm/ephemeral/domains/com/my.domain/settings/ice.cream.flavor")
psttDefaultP: value to use if the box does not exist or contains an invalid value
 can be 0
  if 0 and the box does not exist, psttP will be 0
 example: T("chocolate")
psttOkListP: list of valid values
 if 0 then no value checking is performed
 example: T("vanilla\r\nchocolate\r\nstrawberry")
psttDelimiterP: the string that separates the valid values in psttOkListP
 if 0 then T("\r\n") is used
arguments
 psttP
 psttBoxIP
 psttDefaultP
 psttOkListP
 psttDelimiterP
 cOpenTriesP
  if 0 then will retry forever
  if not 0 then will try cOpenTriesP times
*/

//20141115@1950: IT IS NOW ILLEGAL TO USE THIS API ; USE THE SETTINGS keyValuePairsC INSTANCE

#if defined( NEVERdEFINED )

/**//*1*/voidT etherC::box GetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF( tinS& tinP , strokeS*& psttP , const strokeS* const psttBoxIP , const strokeS* const psttDefaultP , const strokeS* const psttOkListP , const strokeS* const psttDelimiterP , countT cOpenTriesP , const flagsT flagsOpenDetailsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( psttBoxIP ) ;
        if( POOP ) return ;
    }

    _IO_

    IFsCRATCH
    {
        ZE( strokeS* , psttDelimiter ) ;
        if( psttDelimiterP ) { strFuseF( tinP , psttDelimiter , psttDelimiterP ) ; ___( psttDelimiter ) ; }
        else                 { strFuseF( tinP , psttDelimiter , T("\r\n")      ) ; ___( psttDelimiter ) ; }
    
        ZE( osTextT* , posti ) ;
        {
            SCOOPS
            { ZE( countT   , costi ) ; tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , psttBoxIP , cOpenTriesP , flagsOpenDetailsP ) ; ___( posti ) ; }
            if( POOP )
            {
                POOPR
                if( psttDefaultP ) { strFuseF( tinP , psttP , psttDefaultP ) ; ___( psttP ) ; }
            }
        }
    
        if( posti )
        {
            __Z( posti ) ;
            ZE( strokeS* , psttOldCandidate ) ;
            strMakeF( tinP , LF , psttOldCandidate , T(posti) ) ; ___( psttOldCandidate ) ;
    
            ZE( boolT , fOk ) ;
            if( !psttOkListP ) fOk = 1 ;
            else
            {
                countT idf = 1 ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttOk ) ;
                while( idf && !fOk )
                {
                    strSubstringF( tinP , psttOk , idf , sttq , T(psttDelimiter) , psttOkListP ) ; ___( psttOk ) ;
                    fOk = psttOk && !strCompareF( tinP , psttOk , psttOldCandidate ) ;
                    delF( tinP , psttOk ) ;
                }
            }
                 if( fOk          ) { strFuseF( tinP , psttP , psttOldCandidate ) ; ___( psttP ) ; }
            else if( psttDefaultP ) { strFuseF( tinP , psttP , psttDefaultP  ) ; ___( psttP ) ; }
            else                    __1
    
            delF( tinP , psttOldCandidate ) ;
        }
        delF( tinP , posti ) ;
        delF( tinP , psttDelimiter ) ;
    }
}

#endif


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600209e.etherc.boxgetshadowsettingf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600209f.etherc.memopensharedf BEGIN
#define DDNAME       "3func.3600209f.etherc.memopensharedf"
#define DDNUMB      (countT)0x3600209f
#define IDFILE      (countT)0xcc6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$memOpenSharedF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300b1.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.3410104.1.1.0.html\"\>3410104:  WAKEsHOW( "example.simplest.func.10300b1.etherC.memOpenSharedF" )\</A\>
allows the current process to access a shared memory region
arguments
 pvP
  must be 0
 handleP
  must be 0
 flagsResultP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010207.flOPENsHAREDmEMORYrESULT!||
  must be 0
 psttP
  this is the name of the region
  must not contain slashes ('/') or backslashes ('\\')
  example: T("2410104.shared.memory")
 cbP
 idHowP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001014c.ifcOPENsHAREDmEMORYhOW!||
 cTriesP
*/
/**/

/*1*/voidT etherC::memOpenSharedF( tinS& tinP , handleC& handleP , flagsT& flagsResultP , const strokeS* const psttP , handleC* phFileP , const countT cbP , const countT idHowP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( handleP ) ;
        __( flagsResultP ) ;
        __Z( psttP ) ;
        __( strIdF( tinP , S1C('/') , psttP ) ) ;
        __( strIdF( tinP , S1C('\\') , psttP ) ) ;
        if( POOP ) return ;
    }

    _IO_
    third.dosOpenSharedMemIF( tinP , handleP , flagsResultP , T(psttP) , phFileP , cbP , idHowP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600209f.etherc.memopensharedf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a0.etherc.strindentoldf BEGIN
#define DDNAME       "3func.360020a0.etherc.strindentoldf"
#define DDNUMB      (countT)0x360020a0
#define IDFILE      (countT)0xcc7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strIndentOldF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300b3.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.ca10104.1.1.0.html\"\>ca10104:  WAKEsHOW( "example.simplest.func.10300b3.etherC.strIndentOldF" )\</A\>
indents all lines after the first
arguments
 psttP
 csttP
  can be 0
  number of columns to indent
 sttP
  stroke value to use in indentation
  if 0 then S1C(' ') is used
 psttOldP
  can be 0
 psttDelimiterP
  line delimiter
  if 0, then T("\r\n") is used
*/
/**//*1*/voidT etherC::strIndentOldF( tinS& tinP , strokeS*& psttP , const countT csttP , const strokeS sttP , const strokeS* const psttOldP , const strokeS* const psttDelimiterP )/*1*/
{
    SCOOP
    // THIS FUNCTION DOES NOT INDENT THE FIRST DELIMITED, SINCE IT IS EASY FOR THE CALLER TO DO SO

    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( csttP ) ;
        if( POOP ) return ;
    }

    _IO_

    strokeS stti = S1C(' ') ;
    if( (countT)sttP ) stti = sttP ;

    ZE( strokeS* , psttDelimiter ) ;
    if( psttDelimiterP ) { strMakeF( tinP , LF , psttDelimiter , psttDelimiterP ) ; ___( psttDelimiter ) ; }
    else                 { strMakeF( tinP , LF , psttDelimiter , T("\r\n")      ) ; ___( psttDelimiter ) ; }

    ZE( strokeS* , psttOld ) ;
    if( psttOldP ) { strFuseF( tinP , psttOld , psttOldP ) ; ___( psttOld ) ; }
    else
    {
        psttOld = psttP ;
        psttP = 0 ;
    }
    __NZ( psttP ) ;

    countT cLines = 1 ;
    if( psttOld->idAdam )
    {
        countT idf1 = 1 ;
        strokeS sttq1( (countT)0 , sc_IGNOREqUOTES ) ;
        while( idf1 && strIdF( tinP , 0 , flSTRmATCH_null , idf1 , sttq1 , psttDelimiter , psttOld ) ) cLines ++ ;
    }

    strFuseF( tinP , psttP , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ psttOld->idAdam + cLines * csttP ) ; // CALLER MUST TAG

    countT idf = 1 ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    while( !POOP && idf )
    {
        ZE( strokeS* , psttw ) ;

        if( idf != 1 )
        {
            strMakeF( tinP , LF , psttw , T("") , csttP ) ;
            strResizeF( tinP , psttw , csttP , stti , 0 ) ; ___( psttw ) ;
            strFuseF( tinP , psttP , psttw ) ; ___( psttP ) ;
            delF( tinP , psttw ) ;
        }

        ZE( countT , idd ) ;
        { countT idf1 = idf ; strokeS sttq1 = sttq ; idd = strIdF( tinP , 0 , flSTRmATCH_null , idf1 , sttq1 , psttDelimiter , psttOld ) ; }
        strSubstringF( tinP , psttw , idf , sttq , psttDelimiter , psttOld , 0 ) ; ___( psttw ) ;

        strFuseF( tinP , psttP , psttw ) ; ___( psttP ) ;
        delF( tinP , psttw ) ;

        if( idd ) { strFuseF( tinP , psttP , psttDelimiter ) ; ___( psttP ) ; }
    }

    delF( tinP , psttDelimiter ) ;
    delF( tinP , psttOld ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a0.etherc.strindentoldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a1.etherc.strevaluateformat01f BEGIN
#define DDNAME       "3func.360020a1.etherc.strevaluateformat01f"
#define DDNUMB      (countT)0x360020a1
#define IDFILE      (countT)0xcc8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strEvaluateFormat01F.0.html\"\>instances\</A\>
\<A HREF=\"5.10300b4.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9310104.1.1.0.html\"\>9310104:  WAKEsHOW( "example.simplest.func.10300b4.etherC.strEvaluateFormat01F" )\</A\>
substitutes "/" "/" "|" "|" "!" expressions
indents the substitution values to the column of the "/" "/" "|" "|" "!"
arguments
 psttP
 csttExtraP
 psttOldP
*/
/**//*1*/boolT etherC::strEvaluateFormat01F( tinS& tinP , strokeS*& psttP , const countT csttExtraP , const strokeS* const psttOldP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( strokeS* , psttOld ) ;
    if( psttOldP ) { strFuseF( tinP , psttOld , psttOldP ) ; ___( psttOld ) ; }
    else
    {
        psttOld = psttP ;
        psttP = 0 ;
    }
    __NZ( psttP ) ;

    //ifcSayIF( T("strEvaluateFormat01F: before:\r\n" USCORE79 "\r\n\r\n")+T(psttOld)+T("\r\n" USCORE79 "\r\n\r\n") , flSAY_APPEND | flSAY_LOG ) ; //U::

    strFuseF( tinP , psttP , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ ( psttOld ? psttOld->idAdam : 0 ) + csttExtraP ) ; // CALLER MUST TAG
    ZE( boolT , fTagsStillExist ) ;

    TN( crlf , "\r\n" ) ;
    TN( expr , "/" "/" "|" "|" "!" ) ;
    countT idf = 1 ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    while( !STOP && !POOP && idf )
    {
        ZE( countT , idd ) ;
        { countT idfh = idf ; strokeS sttqh = sttq ; idd = strIdF( tinP , 0 , flSTRmATCH_null , idfh , sttqh , crlf , psttOld ) ; }

        ZE( strokeS* , psttl ) ;
        strSubstringF( tinP , psttl , idf , sttq , crlf , psttOld ,0 ) ;    
        {
            countT idf1 = 1 ;
            strokeS sttq1( (countT)0 , sc_IGNOREqUOTES ) ;
            while( !STOP && !POOP && idf1 )
            {
                countT idfLine = idf1 ;
                ZE( countT , ide ) ;
                strokeS sttqe( (countT)0 , sc_IGNOREqUOTES ) ;
                { countT idfh = idf1 ; strokeS sttqh = sttq1 ; ide = strIdF( tinP , 0 , flSTRmATCH_null , idfh , sttqh , expr , psttl ) ; }

                ZE( strokeS* , psttw ) ;
                strSubstringF( tinP , psttw , idf1 , sttq1 , expr , psttl , 0 ) ; ___( psttw ) ;
                strFuseF( tinP , psttP , psttw ) ; ___( psttP ) ;
                delF( tinP , psttw ) ;

                if( idf1 )
                {
                    __Z( ide ) ;
                    countT idCol = ide + 1 - idfLine ;
                    strSubstringF( tinP , psttw , ide , sttqe , T("!" "|" "|") , psttl , 0 , 3 ) ; ___( psttw ) ;
                    strFuseF( tinP , psttw , T("!" "|" "|") ) ; ___( psttw ) ;
                    idf1 = ide ;
                    sttq1 = sttqe ;
                    //ifcSayIF( T("strEvaluateFormat01F: calling strEvaluateF for \"")+T(psttw)+T("\"\r\n") , flSAY_APPEND | flSAY_LOG ) ; //U::
                    fTagsStillExist |= strEvaluateF( tinP , psttw , csttExtraP , 0 ) ; ___( psttw ) ;
                    //ifcSayIF( T("strEvaluateFormat01F: called  strEvaluateF got \"")+T(psttw)+T("\"\r\n") , flSAY_APPEND | flSAY_LOG ) ; //U::
                    if( idCol > 1 ) { strIndentOldF( tinP , psttw , idCol - 1 , strokeS() , 0 , 0 ) ; ___( psttl ) ; }
                    strFuseF( tinP , psttP , psttw ) ; ___( psttP ) ;
                    delF( tinP , psttw ) ;
                }
                else { __( ide ) ; }
            }
            __( STOP ) ;
        }
        delF( tinP , psttl ) ;

        if( idd ) strFuseF( tinP , psttP , crlf ) ;
    }
    __( STOP ) ;
    //ifcSayIF( T("strEvaluateFormat01F: after (")+TF1(fTagsStillExist)+T("):\r\n" USCORE79 "\r\n\r\n")+T(psttP)+T("\r\n" USCORE79 "\r\n\r\n") , flSAY_APPEND | flSAY_LOG ) ; //U::

    delF( tinP , psttOld ) ;
    return fTagsStillExist ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a1.etherc.strevaluateformat01f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a2.etherc.boxputhtmlf BEGIN
#define DDNAME       "3func.360020a2.etherc.boxputhtmlf"
#define DDNUMB      (countT)0x360020a2
#define IDFILE      (countT)0xcc9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxPutHtmlF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300b5.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.8810104.1.1.0.html\"\>8810104:  WAKEsHOW( "example.simplest.func.10300b5.etherC.boxPutHtmlF" )\</A\>
constructs a set of html files
 one html file for each idea stack is constructed
arguments
 psttLikeP
  pattern for the output file names
  example: T("www.ideafarm.com///ideafarm/ephemeral/domains/my.domain/html/fooey")
 psttKnowledgeTreeP
  input string
  example: T("a\r\nb\r\n ba\r\n bb\r\n bc\r\nc")
 psttTitleP
  title for the root html file
  example: T("IdeaFarm " "(tm) City Knowledge Tree")
  this is only used for one of the output files
  titles for all other output files are taken from idea stack lines
 psttOldCopyrightP
  example: T("(c) IdeaFarm " "(tm) City")
 cOpenTriesP
  if 0 then will retry forever when writing each file
  if not 0 then will try cTriesP times
*/
/**/

// STACK: USES 0x1000 BYTES
#define IDcOLmAX 0x400

htmlS::htmlS( tinS& tinP , etherC& ether , htmlS*& pHtmlRootP ) :
ether( ether ) ,
pHtmlRoot( pHtmlRootP ) ,
pR( 0 ) ,
pL( 0 ) ,
pU( 0 ) ,
pD( 0 ) ,
psttName( 0 ) ,
postIdea( 0 )
{
    _IO_
    if( !pHtmlRoot ) pHtmlRoot = this ;
}

htmlS::~htmlS( voidT )
{
    TINSL
    ether.delF( tinP , postIdea ) ;
    ether.delF( tinP , psttName  ) ;
    if( !pL && !pD ) { __( this != pHtmlRoot ) ; }
    else if( pL )    { __NZ( pD ) ; }

    if( pU ) { DELzOMBIE( pU ) ; }
    if( pR ) { DELzOMBIE( pR ) ; }

    if( this == pHtmlRoot ) pHtmlRoot = 0 ;
    else if( !pL )          { if( pD ) pD->pU = 0 ; }
    else                    pL->pR = 0 ;
}

/*1*/voidT etherC::boxPutHtmlF( tinS& tinP , const boolT bOneFileP , const strokeS* const psttLikeLocalP , const strokeS* const psttLikeP , const strokeS* const psttTitleP , const strokeS* const psttOldCopyrightP , const strokeS* const psttKnowledgeTreeP , countT cOpenTriesP )/*1*/
{
    SCOOP
    // EXAMPLE PARAMETER VALUES:
    // psttKnowledgeTreeP: "a\r\nb\r\n ba\r\n bb\r\n  bba\r\n  bbb\r\n bc\r\n  bca\r\n  bcb\r\nc\r\nd"
    // psttLikeP:          "www.ideafarm.com///ideafarm/ephemeral/backed.up.never/gen/html/index"

    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttLikeP ) ;
        __Z( psttKnowledgeTreeP ) ;
        if( POOP ) return ;
    }

    _IO_
    ZE( countT , idColLag ) ;
    countT pcLast[ 1 + IDcOLmAX ] ;
    memSetF( tinP , (byteT*)pcLast , sizeof pcLast ) ;
    TN( crlf , "\r\n" ) ;
    TN( white , " " ) ;
    strokeS sttDot( '.' ) ;
    countT idf = 1 ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( boolT    , fPrevious ) ;
    ZE( htmlS*   , pHtmlRoot ) ;
    pHtmlRoot = new( 0 , tinP , LF ) htmlS( tinP , *this , pHtmlRoot ) ; ___( pHtmlRoot ) ;
    __Z( pHtmlRoot ) ;
    __Z( pHtmlRoot ) ;
    ZE( countT , cSons ) ;
    ZE( countT , idLine ) ;
    TN( tLog , "///d/ideafarm.log.html" ) ;
    //ifcSayIF( T("boxPutHtmlF/\"about to process each line of the kt\"") , flSAY_APPEND | flSAY_LOG ) ;
    while( !STOP && !POOP && idf )
    {
        ZE( strokeS* , psttl ) ;
        strSubstringF( tinP , psttl , idf , sttq , crlf , psttKnowledgeTreeP ) ; ___( psttl ) ;
        //IF GET "sin: indented too much" IN LOG, ENABLE THE FOLLOWING LINE
        //ifcSayIF( T("boxPutHtmlF/ktLine: \"")+T(psttl)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
        countT idCol = 1 ;
        strokeS sttqCol( (countT)0 , sc_IGNOREqUOTES ) ;
        if( 1 != strIdAnyF( tinP , 0 , flSTRmATCH_null , idCol , sttqCol , white , psttl ) ) idCol = 1 ;
        __( idCol > IDcOLmAX ) ;
        if( idCol < idColLag ) for( countT id = idCol + 1 ; id <= IDcOLmAX ; id ++ ) pcLast[ id ] = 0 ;

        strTrimF( tinP , psttl , 0 , T(TbLACKnEWlINE) ) ; ___( psttl ) ;
        if( psttl && psttl[ CSpREFIX ] == sttDot ) // IF THE WOTH NONBLANK IS A DOT, THEN I ASSUME THAT THAT DOT IS TO BE SUPPRESSED
        {
            strokeS* psttd = psttl ; psttl = 0 ;
            countT idf = 2 ;
            ZE( countT , idl ) ;
            strSubstringF( tinP , psttl , idf , idl , psttd ) ; ___( psttl ) ;
            delF( tinP , psttd ) ;
        }

        if( !POOP )
        {
            ZE( strokeS* , psttName ) ;
            strMakeF( tinP , LF , psttName , T("") , idCol * 8 + idCol - 1 ) ; ___( psttName ) ;
            for( countT idGen = 1 ; !POOP && idGen <= idCol ; idGen ++ )
            {
                ZE( strokeS* , psttSN ) ;
                if( idGen == idCol ) ++ pcLast[ idGen ] ;
                else
                {
                    strFromF( tinP , psttSN , pcLast[ idGen ] ) ; ___( psttSN ) ;
                    if( idGen > 1 ) { strFuseF( tinP , psttName , T(".") ) ; ___( psttName ) ; }
                    strFuseF( tinP , psttName , T(psttSN) ) ; ___( psttName ) ;
                    delF( tinP , psttSN ) ;
                }
            }

            newSonF( tinP , *this , pHtmlF( tinP , *this , psttName , pHtmlRoot ) , psttl , pHtmlRoot ) ;
            cSons ++ ;
            delF( tinP , psttName ) ;
        }

        idColLag = idCol ;
        delF( tinP , psttl ) ;
    }
    __( STOP ) ;

    writeHtmlFilesF( tinP , *this , bOneFileP , psttLikeLocalP , psttLikeP , psttTitleP , psttOldCopyrightP , pHtmlRoot , cSons , cOpenTriesP ) ;
    DELzOMBIE( pHtmlRoot ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a2.etherc.boxputhtmlf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a3.etherc.boxputhtmlfromknowledgetreebasef BEGIN
#define DDNAME       "3func.360020a3.etherc.boxputhtmlfromknowledgetreebasef"
#define DDNUMB      (countT)0x360020a3
#define IDFILE      (countT)0xcca


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxPutHtmlFromKnowledgeTreeBaseF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300b6.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9810104.1.1.0.html\"\>9810104:  WAKEsHOW( "example.simplest.func.10300b6.etherC.boxPutHtmlFromKnowledgeTreeBaseF" )\</A\>
constructs a set of html files
 one html file for each idea stack is constructed
 one "reference" html file, containing the entire knowledge tree, is constructed
psttFileLikeP: pattern for the output file names
 example: T("///ideafarm/ephemeral/domains/my.domain/lake/1")
  in a lake directory, 1 indicates html, 2 indicates gif, and 3 indicates jpg (U:NOT TRUE)
   the actual situation is that 1 is used for kt text, 2 is used for both the flag and the mural)
psttTitleP: title for the root html file
 example: T("IdeaFarm " "(tm) Knowledge Tree")
 this is only used for one of the output files
 titles for all other output files are taken from idea stack lines
psttFileP: name of the input file
 example: T("///ideafarm/ephemeral/domains/com/ideafarm/kt.base")
this instruction writes progress information to standard out
csttExtraP should normally be ze
 it defaults to 0x100000
 it can be raised if a warning is seen
arguments
 psttLikeP
 psttLikeLocalP
  can be 0
  if 0 then value is taken from psttLikeP, beginning with the leftmost slash ('/')
 psttTitleP
 psttOldCopyrightP
 psttFileP
 csttExtraP
 cOpenTriesP
  if 0 then will retry forever when writing each file
  if not 0 then will try cTriesP times
*/
/**//*1*/voidT etherC::boxPutHtmlFromKnowledgeTreeBaseF( tinS& tinP , const boolT bOneFileP , const strokeS* const psttLikeLocalP , const strokeS* const psttLikeP , const strokeS* const psttTitleP , const strokeS* const psttOldCopyrightP , const strokeS* const psttFileP , const countT csttExtraP , countT cOpenTriesP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttLikeP ) ;
        __Z( psttTitleP ) ;
        __Z( psttFileP ) ;
        if( POOP ) return ;
    }

    _IO_
    ZE( osTextT* , postKT ) ;                                                            // GET A RAW psttKT STRING
    ZE( countT   , costKT ) ;
    boxGetShadowF( tinP , postKT , costKT , psttFileP ) ; ___( postKT ) ;
    ZE( strokeS* , psttKT ) ;
    strMakeF( tinP , LF , psttKT , T(postKT) ) ; ___( psttKT ) ;
    delF( tinP , postKT ) ;
    strReverseF( tinP , psttKT , 0 , T("\r\n") ) ; ___( psttKT ) ;

    {
        ZE( strokeS* , psttd ) ;                                                         // ELIMINATE EOF BYTES
        psttd = psttKT ;
        psttKT = 0 ;
        strFuseF( tinP , psttKT , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ psttd ? psttd->idAdam : 0 ) ;
        countT idf = 1 ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        while( !STOP && !POOP && idf )
        {
            ZE( strokeS* , psttw ) ;
            strSubstringF( tinP , psttw , idf , sttq , S1C('\x1a') , psttd ) ; ___( psttw ) ;
            strFuseF( tinP , psttKT , psttw ) ;
            delF( tinP , psttw ) ;
        }
        __( STOP ) ;
        delF( tinP , psttd ) ;
    }

    {
        ZE( countT , idPass ) ;                                                          // EVALUATE THE psttKT STRING
        while( !STOP && strEvaluateFormat01F( tinP , psttKT , csttExtraP , 0 ) ) ;
        __( STOP ) ;
    }
    strReplaceF( tinP , psttKT , 0 , T("/" "/" "%" "%") , T("/" "/" "|" "|") ) ; ___( psttKT ) ;

    strRemoveBlankLinesF( tinP , psttKT ) ;                                                // FINAL EDITS
    strToHtmlF( tinP , psttKT ) ;
                                                                                            // WRITE FILE
    boxPutHtmlF( tinP , bOneFileP , psttLikeLocalP , psttLikeP , psttTitleP , psttOldCopyrightP , psttKT , cOpenTriesP ) ;
    delF( tinP , psttKT ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a3.etherc.boxputhtmlfromknowledgetreebasef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a4.etherc.strtohtmlf BEGIN
#define DDNAME       "3func.360020a4.etherc.strtohtmlf"
#define DDNUMB      (countT)0x360020a4
#define IDFILE      (countT)0xccb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strToHtmlF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300b8.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.ea10104.1.1.0.html\"\>ea10104:  WAKEsHOW( "example.simplest.func.10300b8.etherC.strToHtmlF" )\</A\>
encodes '&', '<', '>', '\"' in the string so that an http client can display it correctly
to prevent encoding, precede the character with a backslash ('\')
 backslashes are required, for example, when the string contains http tags
psttOldP can be 0
arguments
 psttP
  can be 0 or nonze  
  if nonze then psttOldP will be fused to it before the replacements are done
 psttOldP
*/
/**//*1*/voidT etherC::strToHtmlF( tinS& tinP , strokeS*& psttP , const strokeS* const psttOldP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( !psttP && !psttOldP ) ;
        if( POOP ) return ;
    }

    _IO_

    if( psttOldP ) strFuseF( tinP , psttP , psttOldP ) ;

    //2011.04.12: THIS SEQUENCE MIGHT FAIL NOW THAT TAGGING IS CHECKED

    strReplaceF( tinP , psttP , 0 , T("&") , T("&amp;") ) ;
    strReplaceF( tinP , psttP , 0 , T("\\&amp;") , T("&") ) ;

    strReplaceF( tinP , psttP , 0 , T("<") , T("&lt;") ) ;
    strReplaceF( tinP , psttP , 0 , T("\\&lt;") , T("<") ) ;

    strReplaceF( tinP , psttP , 0 , T(">") , T("&gt;") ) ;
    strReplaceF( tinP , psttP , 0 , T("\\&gt;") , T(">") ) ;

    strReplaceF( tinP , psttP , 0 , T("\"") , T("&quot;") ) ;
    strReplaceF( tinP , psttP , 0 , T("\\&quot;") , T("\"") ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a4.etherc.strtohtmlf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a5.etherc.osthreadswitchingdesiref BEGIN
#define DDNAME       "3func.360020a5.etherc.osthreadswitchingdesiref"
#define DDNUMB      (countT)0x360020a5
#define IDFILE      (countT)0xccc


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osThreadSwitchingDesireF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300b9.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1610104.1.1.0.html\"\>1610104:  WAKEsHOW( "example.simplest.func.10300b9.etherC.osThreadSwitchingDesireF" )\</A\>
it is illegal to refer to this symbol
 all ifc threads must run at the same priority
sets the priority of the current thread
arguments
 idP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001007f.ifcTHREADpRIORITY!||
*/
/**//*1*/countT etherC::osThreadSwitchingDesireF( tinS& tinP , const countT idP )/*1*/
{
    SCOOP

    //THIS MUST BE DONE EVEN IF IMPOTENT SO THAT GRABBING/UNGRABBING WILL WORK
    //IFbEcAREFUL
    //{
    //    if( POOP ) return 0 ;
    //}

    _IO_
    countT idOld = third.dosPriorityIF( tinP , idP ) ;

    return idOld ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a5.etherc.osthreadswitchingdesiref END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a6.etherc.boxserverf BEGIN
#define DDNAME       "3func.360020a6.etherc.boxserverf"
#define DDNUMB      (countT)0x360020a6
#define IDFILE      (countT)0xccd


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxServerF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300bd.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.2810104.1.1.0.html\"\>2810104:  WAKEsHOW( "example.simplest.func.10300bd.etherC.boxServerF" )\</A\>
it is illegal to refer to this symbol in the definition of an adam
serves boxes
fNoDeputyP must be 0 or 1; it specifies the port to use
U: defect: parent remains locked
 after hiring 7210104, windows explorer cannot d elete the ///ideafarm/ephemeral/tmp/7210104 directory
 once the process that calls boxServerF has ended, the directory can be d eleted
 this problem was observed on windows at 00.0b.21.fa@df.56.4e.d8
will only try once to read each requested file
arguments
 idPortP
  this must be 0 when boxServerF is referenced in the definition of an adam
 bTalkP
  0: do not use strokeF to report status
  1: use strokeF to report status
U: add bNarrateP to enable talking as we go
 then make all strokeF calls conditioned on bNarrateP
*/
/**/
// PROTOCOL
//   CLIENT SENDS A LINE THAT CONTAINS A FILE NAME OR FILE NAME STRING
//   IF SINGLE NAME, SERVER SENDS THE FILE BYTE COUNT, FOLLOWED BY THE FILE
//   IF STRING, SERVER SENDS COUNT FILE COUNT FILE ...
//   SYNTAX OF STRING:  "name1 name2 name3 ... nameN"
//     I.E. NAMES ARE SEPARATED BY A SINGLE BLANK

#define BLANK79 "                                                                               "

/*1*/voidT etherC::boxServerF( tinS& tinP , const countT idPortP , const boolT bTalkP )/*1*/
{
    SCOOP
    etherC& etPrime = etPrimeIF( tinP ) ;

    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( idPortP && idPortP != ifcPORToLD1bOXsERVER && idPortP != ifcPORToLD1bOXsERVERdEPUTY && idPortP != ifcPORToLD1bOXsERVERaDAM ) ;
        __( etPrime ) ;
        if( POOP ) return ;
    }

    _IO_
    const countT idPort = idPortP ? idPortP : ifcPORToLD1bOXsERVERaDAM ;

    while( !etPrime && !POOP )
    {
        socketC socket( tinP , *this , TAG( TAGiDnULL ) ) ;
        __( socket.bindF( tinP , idPort ) - idPort ) ;
        socket.listenF( tinP ) ;

        while( !etPrime && !POOP )
        {
            ZE( socketC* , pso ) ;
            nicNameC nnPeer ;
            ZE( countT , idPortPeer ) ;
            ZE( boolT , bRefuse ) ;
            socket.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ; ___( pso ) ;
            __( bRefuse ) ;
            if( etPrime || third ) { DEL( pso ) ; }
            else                                { ZE( countT , tnu ) ; osThreadF( tinP , tnu , tmServeBoxClientsF , 0 , flTHREADlAUNCH_null , 0 , (countT)pso , bTalkP ) ; }
        }
        third = 0 ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a6.etherc.boxserverf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a7.etherc.strfuseseparatef BEGIN
#define DDNAME       "3func.360020a7.etherc.strfuseseparatef"
#define DDNUMB      (countT)0x360020a7
#define IDFILE      (countT)0xcce


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFuseSeparateF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300be.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.0b10104.1.1.0.html\"\>0b10104:  WAKEsHOW( "example.simplest.func.10300be.etherC.strFuseSeparateF" )\</A\>
  \<A HREF=\"5.fa10104.1.1.0.html\"\>fa10104:  WAKEsHOW( "example.simplest.func.10300be.etherC.strFuseSeparateF" )\</A\>
like strFuseF except that the prefix at the beginning of psttInP is retained
use this to build strings of strings
any level of nesting is possible
use FORsTRINGSiN1, possibly nested, to process strings of strings
U:: NO LONGER TRUE: in the internal prefixes, cExtra = - 1
 this was causing memory overwrites, so cExtra in the internal prefixes is now 0
U: enforce the usage of csttExtraP
arguments
 psttOutP
 psttInP
 csttExtraP
 csttPrefixNullsP
  each word in pstt1P will be prefixed with this many nulls
 csttSuffixNullsP
  each word in pstt1P will be suffixed with this many nulls
 pSoulP
  can be 0
  if 0 then psttOutP must either be 0 or contain enough room for the result to be appended
  if not 0 then *pSoulP will be used as a fifo buffer to store the result
  the result will either be in psttOutP or in *pSoulP
 pGrabP
  can be 0
  if not 0 then *pGrabP will be grabbed when *pSoulP is being accessed
*/
/**/

/*1*/voidT etherC::strFuseSeparateF( tinS& tinP , strokeS*& psttOutP , const strokeS* const psttInP , countT csttPrefixNullsP , countT csttSuffixNullsP , soulC* pSoulP , grabC* pGrabP , const countT csttExtraP )/*1*/

{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    countT cToDoPrefix = CSpREFIX ;_WQ
    const countT csttBody = csttPrefixNullsP + psttInP->idAdam + csttSuffixNullsP ;_WQ

    const strokeS* psttic = !psttInP  ? 0 : psttInP  + CSpREFIX ;_WQ
    const strokeS* psttie = !psttic   ? 0 : psttic              + psttInP->idAdam ;_WQ
    strokeS*       psttoc = !psttOutP ? 0 : psttOutP + CSpREFIX + psttOutP->idAdam ;_WQ
    strokeS*       psttoe = !psttoc   ? 0 : psttoc              + psttOutP[ 2 ].idAdam ;_WQ

    strokeS sttn( (countT)0 , sc_NULL ) ;_WQ

    do
    {
        // FILL UP THE OUTPUT STRING
        if( psttoc && psttic )
        {
            // APPEND THE STRING PREFIX
            ZE( countT , csttAte ) ;_WQ
            SETpREFIXpARTIALmIDDLE( csttAte , psttoc , csttBody , 0 , psttoe - psttoc , CSpREFIX - cToDoPrefix )
            psttoc               += csttAte ;_WQ
            psttOutP->idAdam     += csttAte ;_WQ
            psttOutP[ 2 ].idAdam -= csttAte ;_WQ
            cToDoPrefix          -= csttAte ;_WQ

            // APPEND THE STRING BODY
            countT co = psttoe - psttoc ;_WQ
            countT ci = psttie - psttic + csttPrefixNullsP + csttSuffixNullsP ;_WQ
            countT cDo = ci < co
                ? ci
                : co
            ;_WQ

            psttOutP[ 2 ].idAdam -= cDo ;_WQ
            psttOutP[ 0 ].idAdam += cDo ;_WQ

            while( cDo -- )
            {
                     if( csttPrefixNullsP ) { csttPrefixNullsP -- ; *( psttoc ++ ) = sttn           ; }
                else if( psttic < psttie  )                         *( psttoc ++ ) = *( psttic ++ ) ;
                else if( csttSuffixNullsP ) { csttSuffixNullsP -- ; *( psttoc ++ ) = sttn           ; }
                else                        { __1 }
            }
        }

        // MOVE OUTPUT TO FIFO SOUL
        if                               // IF HAVE OUTPUT AND STILL HAVE MORE INPUT TO PROCESS
        (
            psttoc
            &&
            (
                csttPrefixNullsP
                ||
                ( psttic && psttic < psttie )
                ||
                csttSuffixNullsP
            )
        )
        {
            if( !pSoulP )
            {
                __1 ;_WQ
                break ;
            }
            else
            {
                if( pGrabP ) pGrabP->grabF( tinP , TAG( TAGiDnULL ) ) ;_WQ
                *pSoulP << psttOutP ;_WQ
                if( pGrabP ) pGrabP->ungrabF( tinP ) ;_WQ
                ___( psttOutP ) ;_WQ
                delF( tinP , psttOutP ) ;_WQ
                psttoe = psttoc = 0 ;_WQ
            }
        }

        // ALLOCATE AN OUTPUT STRING (ALWAYS DONE, EVEN IF NO INPUT
        if( !psttOutP )
        {
            countT cstta = !pSoulP
                ? psttic
                    ? CSpREFIX + psttie - psttic + csttPrefixNullsP + csttSuffixNullsP + csttExtraP
                    : csttExtraP
                : csttExtraP
                    ? csttExtraP
                    : CSTTsOULfUSEdEFAULT
            ;_WQ

            third.newF( tinP , LF , psttOutP , CSpREFIX + cstta ) ; //CALLER MUST TAG ___( psttOutP ) ;_WQ
            __Z( psttOutP ) ;_WQ
            if( !POOP )
            {
                SETpREFIX( psttOutP , 0 , cstta )
                psttoc = psttOutP + CSpREFIX ;_WQ
                psttoe = psttoc   + cstta    ;_WQ
            }
        }

        if( !psttic ) break ;
    }
    while( psttic < psttie ) ;_WQ

    if( pSoulP && *pSoulP ) // EVEN IF I AM NOT THE WO WHO PUSHED THE CONTENT
    {
        *pSoulP << psttOutP ;_WQ
        ___( psttOutP ) ;_WQ
        delF( tinP , psttOutP ) ;_WQ
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a7.etherc.strfuseseparatef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a8.etherc.strsubstringdelimitedf BEGIN
#define DDNAME       "3func.360020a8.etherc.strsubstringdelimitedf"
#define DDNUMB      (countT)0x360020a8
#define IDFILE      (countT)0xccf


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strSubstringDelimitedF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300bf.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1b10104.1.1.0.html\"\>1b10104:  WAKEsHOW( "example.simplest.func.10300bf.etherC.strSubstringDelimitedF" )\</A\>
extracts the first delimited substring
delimiters are of the form "/ *nnn* /" (ignore those spaces) where any number of hex digits [0-9,a-f] can be specified
idFirstP will be set to the position following the second delimiter of the first matched pair of delimiters
psttP will contain the text that was between those delimiters
delimiters can be of any length, but should be limited to 8 or fewer hex digits so that the value can be returned correctly
arguments
 psttP
  must be 0
 idClassP
  must be 0
 idFirstP
  must not be 0
 sttQuoteP
  this should normally be set to a virgin strokeS object the first time that a substring is extracted from psttBigP
   a virgin object is an object that has been constructed using its default , no argument, constructor
   example: strokeS psttq ;
 psttBigP 
  must not be 0
  must contain valid C++ code
   each occurance of "/" "*" must be followed by "*" "/"
 csttExtraP
*/
/**//*1*/voidT etherC::strSubstringDelimitedF( tinS& tinP , strokeS*& psttP , countT& idClassP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* const psttBigP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __( idClassP ) ;
        __Z( idFirstP ) ;
        __Z( psttBigP ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , psttd1 ) ;
    while( idFirstP && !psttd1 )
    {
        strSubstringF( tinP , psttd1 , idFirstP , sttQuoteP , T("/*") ,psttBigP ) ; ___( psttd1 ) ;
        delF( tinP , psttd1 ) ;
        if( idFirstP ) { strSubstringF( tinP , psttd1 , idFirstP , sttQuoteP , T("*/") ,psttBigP ) ; ___( psttd1 ) ; }
        if( !idFirstP ) delF( tinP , psttd1 ) ;

        if( psttd1 )
        {
            countT cDigits = psttd1->idAdam ;
            ZE( countT , off ) ;
            for( ; off < cDigits ; off ++ )
            {
                if( ( psttd1[ CSpREFIX + off ] >= '0' && psttd1[ CSpREFIX + off ] <= '9' ) || ( psttd1[ CSpREFIX + off ] >= 'a' && psttd1[ CSpREFIX + off ] <= 'f' ) ) continue ;
                break ;
            }
            if( !cDigits || off < cDigits ) delF( tinP , psttd1 ) ;
        }
    }
    // psttd1 NOW CONTAINS THE DELIMITER, AND idFirstP POINTS TO THE STROKE FOLLOWING ITS FIRST OCCURANCE

    if( psttd1 && idFirstP )
    {
        const countT idfs = idFirstP ;
        strSubstringF( tinP , psttP , idFirstP , sttQuoteP , T("/*")+T(psttd1)+T("*/") , psttBigP , csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;
        if( psttP && !idFirstP && psttBigP->idAdam - ( idfs - 1 ) - psttP->idAdam - 4 > psttd1->idAdam )
        {
            ___( psttP ) ;
            delF( tinP , psttP ) ;
        }
    }

    if( psttP )
    {
        idClassP = strDigitsToSCountF( tinP , psttd1 ) ;
    }

    delF( tinP , psttd1 ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a8.etherc.strsubstringdelimitedf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a9.etherc.newdeltypeether BEGIN
#define DDNAME       "3func.360020a9.etherc.newdeltypeether"
#define DDNUMB      (countT)0x360020a9
#define IDFILE      (countT)0xcd0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.10300c3.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.e410104.1.1.0.html\"\>e410104:  WAKEsHOW( "example.simplest.func.10300c3.etherC.NEWdELtYPEeTHER" )\</A\>
example code
 |    ZE( count4S* , pc4a ) ;
 |    ether.newF( tinP , LF , pc4a , 8 ) ; ___( pc4a ) ;
 |    ether.delF( tinP , pc4a ) ;
*/
/**/

/*1*/NEWdELtYPEeTHER( count2S )/*1*/
NEWdELtYPEeTHER( count3S )
NEWdELtYPEeTHER( count4S )
NEWdELtYPEeTHER( count5S )
NEWdELtYPEeTHER( count6S )
NEWdELtYPEeTHER( count7S )
NEWdELtYPEeTHER( count8S )
NEWdELtYPEeTHER( count9S )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020a9.etherc.newdeltypeether END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020aa.etherc.newdeltypeether BEGIN
#define DDNAME       "3func.360020aa.etherc.newdeltypeether"
#define DDNUMB      (countT)0x360020aa
#define IDFILE      (countT)0xcd1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.10300c4.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f410104.1.1.0.html\"\>f410104:  WAKEsHOW( "example.simplest.func.10300c4.etherC.NEWdELtYPEeTHER" )\</A\>
example code
 |    ZE( sCountT* , psca ) ;
 |    ether.newF( tinP , LF , psca , 8 ) ; ___( psca ) ;
 |    ether.delF( tinP , psca ) ;
*/
/**/

/*1*/NEWdELtYPEeTHER( sCountT )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020aa.etherc.newdeltypeether END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ab.etherc.etheremployersf BEGIN
#define DDNAME       "3func.360020ab.etherc.etheremployersf"
#define DDNUMB      (countT)0x360020ab
#define IDFILE      (countT)0xcd2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherEmployersF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300c5.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
allocates a null terminated string of employer identifiers
each identifies an immutable standard task
the information returned is only for the calling thread
the first item (at offset 0) is the standard task that hires etherEmployersF
the second item is the immediate employer of the requesting standard task
the third item is the immediate employer's employer
the fourth item is that employer's employer, etc.
evaluates to the number of id's retrieved, which is one plus the number of employers
arguments
 pcP
*/
/**/
/*1*/countT etherC::etherEmployersF( tinS& tinP , countT*& pcP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( pcP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( countT , ce ) ;
    return ce ? ce - 1 : 0 ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ab.etherc.etheremployersf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ad.etherc.strwordf BEGIN
#define DDNAME       "3func.360020ad.etherc.strwordf"
#define DDNUMB      (countT)0x360020ad
#define IDFILE      (countT)0xcd3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strWordF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300c7.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.2b10104.1.1.0.html\"\>2b10104:  WAKEsHOW( "example.simplest.func.10300c7.etherC.strWordF" )\</A\>
gets the idP'th word
if there are not idP words, then psttP is not allocated
arguments
 psttP
  must be 0
 psttBigP
  must not be 0
 sttQuoteP
 sttDelimiterP
  if 0 then S1C('/') is used
  U::CHANGE MY FUNCTION SO THAT I TAKE psttDelimitersP AND WORK THE SAME WAY AS strWordsOldF
 idP
  must not be 0
  if psttBigP ends with a run of delimiters, the last word is a null length word
   this is inconvenient for text parsing but makes sense for general token parsing
   it also reflects a fundamental of the ifc approach to parsing
    delimiters at the end of a string are not assumed to have no semantic value
    it is up to the caller to choose to decide whether terminating delimiters have semantic value
  if negative then indexes from the end of psttBigP
 csttExtraP
*/
/**//*1*/voidT etherC::strWordF( tinS& tinP , strokeS*& psttP , const strokeS* const psttBigP , strokeS& sttQuoteP , const strokeS sttDelimiterP , const sCountT idP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( psttBigP ) ;
        __Z( idP ) ;
        if( POOP ) return ;
    }

    _IO_

    strokeS sttDelimiter = (countT)sttDelimiterP ? sttDelimiterP : S1C('/') ;

    if( idP < 0 )
    {
        TN( tDelim , "" ) ; tDelim = T("")+sttDelimiter ;
        sCountT cWords = strCLinesF( tinP , psttBigP , tDelim , 1 ) ;
        if( cWords + idP >= 0 )
        {
            strWordF( tinP , psttP , psttBigP , sttQuoteP , sttDelimiterP , cWords + idP + 1 , csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;
        }
    }
    else
    {
        countT idf = 1 ;
        ZE( countT , idl ) ;
        ZE( countT , iddLeft ) ;
        ZE( countT , iddRight ) ;
        ZE( countT , cFound ) ;
        {
            // LOOK FOR DELIMITERS
            countT idf2 = 1 ;
            while( idf2 && cFound < idP )
            {
                countT idd = strIdAnyF( tinP , idf2 , sttQuoteP , sttDelimiter , psttBigP ) ;
                if( idd )
                {
                    cFound ++ ;
                         if( cFound == idP - 1 ) iddLeft  = idd ;
                    else if( cFound == idP     ) iddRight = idd ;
                }
            }
        }

        if( cFound == idP )
        {
            idf = iddLeft  + 1 ;
            idl = iddRight - 1 ;
        }
        else if( cFound == idP - 1 )
        {
            idf = iddLeft + 1 ;
        }
        else idf = 0 ;

        if( !idf ) ;
        else if( psttBigP->idAdam == idf - 1 )
        {
            strMakeF( tinP , LF , psttP , T("") , csttExtraP ) ; // CALLER MUST TAG. TRAILING BLANKS WERE SEEN AS THE LEFT DELIMITER OF THE WORD
        }
        else if( psttBigP->idAdam >= idl )
        {
            strSubstringF( tinP , psttP , idf , idl , psttBigP , csttExtraP ) ; // CALLER MUST TAG
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ad.etherc.strwordf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ae.etherc.stridanyf BEGIN
#define DDNAME       "3func.360020ae.etherc.stridanyf"
#define DDNUMB      (countT)0x360020ae
#define IDFILE      (countT)0xcd4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strIdAnyF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300c8.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.3b10104.1.1.0.html\"\>3b10104:  WAKEsHOW( "example.simplest.func.10300c8.etherC.strIdAnyF" )\</A\>
evaluates to the id in psttBigP of the first occurance of stroke sttSmall
idFirstP will point to the stroke after the ones found
skips over quoted strokes when searching for the first match
initialize sttQuoteP to the quote state at idFirstP
 sttQuoteP is either 0 or contains the last quote mark encountered
 see doc for strIsInQuoteF for notes on which quote marks are recognized
 see doc for strIsInQuoteF for notes on how sttQuoteP is set at the beginning and at the end of a quote
arguments
 idFirstP
  must not be 0
 sttQuoteP
  must be 0 if idFirstP is 1
 sttSmallP
  can be null
 psttBigP
  must not be 0
*/
/**//*1*/countT etherC::strIdAnyF( tinS& tinP , countT& idFirstP , strokeS& sttQuoteP , const strokeS sttSmallP , const strokeS* psttBigP , sCountT idP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( idFirstP ) ;_WQ
        __Z( sttSmallP ) ;_WQ
        __Z( psttBigP ) ;_WQ
        __( idFirstP == 1 && (countT)sttQuoteP && sttQuoteP.idCaste != sc_IGNOREqUOTES ) ;_WQ
        __Z( idP ) ;_WQ
        if( POOP ) return 0 ;
        __( psttBigP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_

    strokeS psttSmall[ CSpREFIX + 1 ] ;_WQ
    SETpREFIX( psttSmall , 1 , 0 ) ;_WQ
    psttSmall[ CSpREFIX ] = sttSmallP ;_WQ
    countT id = strIdAnyF( tinP , 0 , flSTRmATCH_null , idFirstP , sttQuoteP , psttSmall , psttBigP , 0 , idP ) ;_WQ
    return id ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ae.etherc.stridanyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020af.etherc.osidf BEGIN
#define DDNAME       "3func.360020af.etherc.osidf"
#define DDNUMB      (countT)0x360020af
#define IDFILE      (countT)0xcd5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osIdF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300c9.1.0.html\"\>definition\</A\>
see thirdC::osIdIF
evaluates to a textC object that contains a single (null terminated) stroke
arguments
 bFileP
*/
/**/

/*1*/textC etherC::osIdF( tinS& tinP , const boolT bFileP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) { TN( tnu , "" ) ; return tnu ; }
    }

    _IO_
    const osTextT postId[] = { third.osIdIF( tinP , bFileP ) , 0 } ;
    TN( tId , postId ) ;
    return tId ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020af.etherc.osidf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b0.etherc.oseditorf BEGIN
#define DDNAME       "3func.360020b0.etherc.oseditorf"
#define DDNUMB      (countT)0x360020b0
#define IDFILE      (countT)0xcd6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osEditorF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300ca.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f510104.1.1.0.html\"\>f510104:  WAKEsHOW( "example.simplest.func.10300ca.etherC.osEditorF" )\</A\>
all of this information is obsolete
see the function definition for new functionality as of 20140415@1859
sets psttP to the name of the standard editor for the operating system being used
 if the current user has specified an editor, and it exists, it will be used
  the current user is the last user to open the gate on this computer
 otherwise, the default editor for the current operating system will be used
  os/2:       ///X/os2/system/epm.exe
  windows nt: ///X/winnt/notepad.exe
  windows 95: ///X/windows/notepad.exe
  (where X is the identifying letter of a drive that contains the file)
arguments
 psttP
*/
/**//*1*/voidT etherC::osEditorF( tinS& tinP , strokeS*& psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    osTextT postExe[ TUCK << 1 ] ;
    countT  costaExe = sizeof postExe ;
    thirdC::exeFromFileExtensionIF( tinP , postExe , costaExe , ".txt" ) ;
    strMakeFromOsTextF( tinP , psttP , ifFileNameC( tinP , third , postExe ) ) ; ___( psttP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b0.etherc.oseditorf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b1.etherc.oseditf BEGIN
#define DDNAME       "3func.360020b1.etherc.oseditf"
#define DDNUMB      (countT)0x360020b1
#define IDFILE      (countT)0xcd7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osEditF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300cb.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.0610104.1.1.0.html\"\>0610104:  WAKEsHOW( "example.simplest.func.10300cb.etherc.osEditF" )\</A\>
uses the default editor to edit the named file
this will be an asynchronous independent session
arguments
 psttP
  specifies the name of the file to edit, or a pattern
  can be 0
  example: T("///ideafarm/ephemeral/tmp/10300cb.foo")
  example: T("///ideafarm/ephemeral/tmp/10300cb.??o")
  example: T("///ideafarm/ephemeral/tmp/10300cb.*")
  if the wildcard strokes '*' '?' are not present and the file does not exist, a file of length 0 bytes will be created
  if no matching file exists then i do nothing silently and return immediately
bAsynchP
 can be 0 or 1
 if 0 then i will not return until the operator closes the editor
 if 1 then i will return as soon as the editor is hired
*/
/**//*1*/voidT etherC::osEditF( tinS& tinP , const strokeS* const psttP , const boolT bAsynchP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , pstta ) ;
    {
        soulC soul1m( tinP , TAG( TAGiDnULL ) ) ;
        boxMenuF( tinP , soul1m , psttP , 00 /*U:, const countT cMaxP = 0*/ ) ;
        if( soul1m )
        {
            TN( tq , "\"" ) ;
            strMakeF( tinP , LF , pstta , T("") , soul1m * TUCK ) ; ___( pstta ) ; //A:ASSUME: MAX FILE NAME LENGTH IS TUCK
            if( pstta )
            {
                FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
                {
                    if( pstta->idAdam ) { strFuseF( tinP , pstta , T(" ") ) ; ___( pstta ) ; }

                    ZE( osTextT* , post ) ;
                    strMakeF( tinP , LF , post , psttc1 ) ; ___( post ) ;
                    osFileNameC osf( tinP , third , post ) ;
                    delF( tinP , post ) ;
                    strFuseF( tinP , pstta , tq+T(osf)+tq ) ; ___( pstta ) ;
                }
                FORsTRINGSiNsPANNEDcOMBINEDtAIL1
    
                if( !pstta->idAdam && !strIdF( tinP , S1C('*') , psttP ) && !strIdF( tinP , S1C('?') , psttP ) ) // SINGLE FILE THAT DOES NOT EXIST
                {
                    ZE( strokeS* , psttm ) ;
                    diskMapFileNameF( tinP , psttm , psttP ) ; ___( psttm ) ;
                    diskMakeDirIfNeededF( tinP , psttm ) ;
                    ZE( osTextT* , postm ) ;
                    strMakeF( tinP , LF , postm , psttm ) ; ___( postm ) ;
                    delF( tinP , psttm ) ;
                    osFileNameC osf( tinP , third , postm ) ;
                    delF( tinP , postm ) ;
                    { // ATOMIC EXIST? + CREATE: DONE THIS WAY TO AVOID OVERWRITING A FILE THAT IS WRITTEN BY ANOTHER PROCESS IMMEDIATELY AFTER THIS CODE TESTS FOR EXISTENCE
                        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                        third.dosOpenF( tinP , handle , countTC() , osf , ifcOPENaCCESS_R , 0 , flOPENdETAILS_FAIL , ifcOPENhOW_nCeO ) ;
                    }
                    strFuseF( tinP , pstta , T(osf) ) ; ___( pstta ) ;
                }
            }
        }
    }
    __Z( pstta ) ;

    ZE( strokeS* , psttEditor ) ;
    osEditorF( tinP , psttEditor ) ; ___( psttEditor ) ;
    if( bAsynchP ) osSessionF( tinP , countTC() , countTC() , psttEditor , pstta , 0 , 0 , 640 , 480 ) ;
    else
    {
        ZE( countT , value ) ;
        ZE( countT , idDeathType ) ;
        osSessionF( tinP , countTC() , countTC() , value , idDeathType , psttEditor , pstta , 0 , 0 , 640 , 480 ) ;
        __( idDeathType ) ;
    }
    delF( tinP , pstta ) ;
    delF( tinP , psttEditor ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b1.etherc.oseditf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b2.etherc.diskfileexistsf BEGIN
#define DDNAME       "3func.360020b2.etherc.diskfileexistsf"
#define DDNUMB      (countT)0x360020b2
#define IDFILE      (countT)0xcd8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskFileExistsF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300cc.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.5410104.1.1.0.html\"\>5410104:  WAKEsHOW( "example.simplest.func.10300cc.etherc.diskFileExistsF" )\</A\>
evaluates to the number of files found
arguments
 psttLikeP
  pattern of the names of the files to find
  example: T("///ideafarm/ephemeral/tmp/10300cc*")
  example: T("///ideafarm/ephemeral/tmp/10300cc.???")
  example: T("///ideafarm/ephemeral/tmp/10300cc.one.file")
 may also be a string of strings
  will accumulate over all strings specified
  the strings need not bear any relationship to each other
   for example, wildcards and paths may differ
  the result is as if the caller called me repeatedly and accumulated my return value
*/
/**//*1*/countT etherC::diskFileExistsF( tinS& tinP , const strokeS* const psttLikeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttLikeP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( countT , cFound ) ;

    boolT bStringOfStrings = ISsTRINGoFsTRINGS( psttLikeP ) ;
    ZE( strokeS* , pstt1u ) ;
    if( !bStringOfStrings ) { strFuseSeparateF( tinP , pstt1u , psttLikeP ) ; ___( pstt1u ) ; }
    else                    pstt1u = (strokeS*)psttLikeP ;

    FORsTRINGSiN1( pstt1u )
    {
        if
        (
            !strIdF( tinP , S1C( '*' ) , psttc1 )
            &&
            !strIdF( tinP , S1C( '?' ) , psttc1 )
        )
        {
            IFsCRATCH
            {
                SCOOPS

                THREADmODE1oN( flTHREADmODE1_QUIETiMPOTENCE ) ;
                fileC fileTest( tinP , psttc1 , ifcOPENaCCESS_R , ifcOPENsHARE_WR , flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_BUMPkEY | flOPENdETAILS_DOnOTmAKEdIRiFnEEDED , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 ) ;
                THREADmODE1rESTORE

                if( POOP )
                {
                    POOPRqUIET
                    if( fileTest.idOpenResultF( tinP ) == ifcOPENrESULT_ERRORsHARINGvIOLATION ) cFound = 1 ;
                }
                else cFound = 1 ;
            }
        }
        else
        {
            fileNameC fnLike( tinP , *this , psttc1 ) ;
            patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
            
            ZE( strokeS* , psttnu ) ;
            cFound = diskFindFileOrDirF( tinP , psttnu , fnLike.pathF() , &pat ) ; ___( psttnu ) ;
            delF( tinP , psttnu ) ;
        }
    }

    if( !bStringOfStrings ) delF( tinP , pstt1u ) ;

    return cFound ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b2.etherc.diskfileexistsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b3.etherc.strremoveblanklinesf BEGIN
#define DDNAME       "3func.360020b3.etherc.strremoveblanklinesf"
#define DDNUMB      (countT)0x360020b3
#define IDFILE      (countT)0xcd9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strRemoveBlankLinesF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300cd.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.4b10104.1.1.0.html\"\>4b10104:  WAKEsHOW( "example.simplest.func.10300cd.etherc.strRemoveBlankLinesF" )\</A\>
removes null lines and blank lines
replaces nonstandard line terminators with standard line terminators
 for example, "\n" is replaced with "\r\n"
arguments
 psttP
 psttOldP
  can be 0
 psttEndP
  cannot be of ze length
  substrings consisting only of these strokes delimit each line
  if 0 then T("\r\n") is used
  for example, T("\r\n") causes all of the substrings listed in this branch to delimit lines
  T("\r\n")
  T("\r")
  T("\n")
  T("\n\r")
  T("\r\n\n\r\n\n\n\n\r\n")
 psttBlankListP
  lines containing only these strokes will be eliminated
   if 0 then T(" \t\x1a") is used
    spaces (' '), tabs ('\t'), and end of file marks ('\x1a') are removed
*/
/**//*1*/voidT etherC::strRemoveBlankLinesF( tinS& tinP , strokeS*& psttP , const strokeS* const psttOldP , const strokeS* const psttEndP , const strokeS* const psttBlankListP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( psttEndP && !psttEndP->idAdam ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , psttBlankList ) ;
    if( psttBlankListP ) { strFuseF( tinP , psttBlankList , psttBlankListP ) ; ___( psttBlankList ) ; }
    else                 { strMakeF( tinP , LF , psttBlankList , T(" \t\x1a")   ) ; ___( psttBlankList ) ; }

    ZE( strokeS* , psttEnd ) ;
    if( psttEndP ) { strFuseF( tinP , psttEnd , psttEndP  ) ; ___( psttEnd ) ; }
    else           { strMakeF( tinP , LF , psttEnd , T("\r\n") ) ; ___( psttEnd ) ; }

    ZE( strokeS* , psttOld ) ;
    if( psttOldP ) { strMakeF( tinP , LF , psttOld , psttOldP ) ; ___( psttOld ) ; }
    else
    {
        psttOld = psttP ;
        psttP = 0 ;
    }
    __NZ( psttP ) ;

    countT cEOL = strCLinesF( tinP , psttOld , psttEnd , 1 ) ;

    strMakeF( tinP , LF , psttP , T("") , ( psttOld ? psttOld->idAdam : 0 ) + cEOL * ( psttEnd->idAdam - 1 ) ) ; // CALLER MUST TAG ___( psttP ) ;
    countT idf = 1 ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    while( !POOP && idf ) 
    {
        countT idfSave = idf ;
        strokeS sttqSave = sttq ;
        countT ide = strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , psttEnd , psttOld ) ; // FIND EOL.  NOW idf IS AT BEGINNING OF NEXT LINE

        if( !ide || ide > idfSave ) // IF THIS LINE IS NOT NULL
        {
            countT idl = ide ? ide - 1 : 0 ;
            ZE( strokeS* , psttl ) ;
            strSubstringF( tinP , psttl , idfSave , idl , psttOld ) ; ___( psttl ) ; // GET THIS LINE

            countT idfb = 1 ;
            strokeS sttqb( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , psttw ) ;
            countT idb = strIdAnyF( tinP , 0 , flSTRmATCH_null , idfb , sttqb , psttBlankList , psttl ) ; // FIND FIRST STRING OF BLANKS IN THIS LINE

            if( !idb || idb > 1 || idfb ) // IF THERE ARE EITHER LEADING OR TRAILING NONBLANKS
            {
                strFuseF( tinP , psttP , psttl ) ;
                if( ide && idf ) strFuseF( tinP , psttP , psttEnd ) ;
            }

            delF( tinP , psttl ) ;
        }
    }

    delF( tinP , psttOld ) ;
    delF( tinP , psttEnd ) ;
    delF( tinP , psttBlankList ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b3.etherc.strremoveblanklinesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b4.etherc.strreplaceautomaticallyf BEGIN
#define DDNAME       "3func.360020b4.etherc.strreplaceautomaticallyf"
#define DDNUMB      (countT)0x360020b4
#define IDFILE      (countT)0xcda


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strReplaceAutomaticallyF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300ce.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.5b10104.1.1.0.html\"\>5b10104:  WAKEsHOW( "example.simplest.func.10300ce.etherC.strReplaceAutomaticallyF" )\</A\>
scans for replacement pairs and then performs the replacement
each replacement pair is eliminated from the result
 example of a replacement pair (remove the embedded blanks): / *2* /AAAA/aaaaaa/ *2* /
  in the example, 2 is the class of the delimited substrings to interpret as replacement pairs
  in this example, AAAA will be replaced with aaaaaa
 all occurances, including the one in each replacement pair, will be replaced
 replacements are made in the order in which the pairs are encountered
 the position of the replacement pair in the source string has no effect on the result
  position does not effect either the result or the efficiency of this command
a replacement pair consists of two strings separated by a slash
there is no way to specify a slash as part of either of the two strings in the pair
arguments
 psttP
 psttOldP
 idClassP
  can be 0
  if not ze, then must be 0x1000 or greater
  if ze then class 2 will be used
 csttExtraP
  can be 0
  i always preserve the extra strokes that are present in the source string
  use csttExtraP to specify additional extra strokes
*/
/**//*1*/voidT etherC::strReplaceAutomaticallyF( tinS& tinP , strokeS*& psttP , const strokeS* const psttOldP , const countT idClassP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( !psttP && !psttOldP ) ;
        if( POOP ) return ;
    }

    _IO_

    const countT idClass = idClassP ? idClassP : 2 ;
    if( psttOldP )
    {
        strMakeF( tinP , LF , psttP , psttOldP , psttOldP[ 2 ].idAdam + csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;
    }

    ZE( strokeS* , psttDelimiter ) ;
    {
        ZE( strokeS* , psttId ) ;
        strFromF( tinP , psttId , idClass ) ; ___( psttId ) ;
        strMakeF( tinP , LF , psttDelimiter , T("/*") + T(psttId) + T("*/") ) ; ___( psttDelimiter ) ;
        delF( tinP , psttId ) ;
    }

    ZE( strokeS* , psttPair ) ;
    ZE( countT , idcFound ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    countT idf = 1 ;
    while( idf && !POOP )
    {
        idcFound = 0 ;
        strSubstringDelimitedF( tinP , psttPair , idcFound , idf , sttq , psttP ) ; ___( psttPair ) ;
        if( psttPair )
        {
            if( idcFound == idClass )
            {
                ZE( strokeS* , psttOld ) ;
                ZE( strokeS* , psttNew ) ;
                {
                    countT idfp = 1 ;
                    strokeS sttqp( (countT)0 , sc_IGNOREqUOTES ) ;
                    strSubstringF( tinP , psttOld , idfp , sttqp , S1C('/') , psttPair ) ; ___( psttOld ) ;
                    strSubstringF( tinP , psttNew , idfp , sttqp , S1C('/') , psttPair ) ; ___( psttNew ) ;
                }
                strReplaceF( tinP , psttP , 0 , T(psttDelimiter) + T(psttPair) + T(psttDelimiter) , T("") , csttExtraP ) ;
                strReplaceF( tinP , psttP , 0 , psttOld , psttNew , csttExtraP ) ;
                delF( tinP , psttOld ) ;
                delF( tinP , psttNew ) ;
                idf = 1 ; // NEED TO RESCAN FROM THE BEGINNING CAUSE HAVE MODIFIED THE STRING
            }
            delF( tinP , psttPair ) ;
        }
    }

    delF( tinP , psttDelimiter ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b4.etherc.strreplaceautomaticallyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b5.etherc.etheruidf BEGIN
#define DDNAME       "3func.360020b5.etherc.etheruidf"
#define DDNUMB      (countT)0x360020b5
#define IDFILE      (countT)0xcdb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherUidF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300cf.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 psttUidP
*/
/**/

/*1*/voidT etherC::etherUidF( tinS& tinP , const strokeS* const psttUidP )/*1*/
{
    SCOOP
IFbEcAREFUL
{
        if( POOP ) return ;
        __Z( psttUidP ) ;
        if( POOP ) return ;
}

    _IO_
    delF( tinP , psttUid ) ;
    strMakeF( tinP , LF , psttUid , psttUidP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b5.etherc.etheruidf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b6.etherc.ossleepf BEGIN
#define DDNAME       "3func.360020b6.etherc.ossleepf"
#define DDNUMB      (countT)0x360020b6
#define IDFILE      (countT)0xcdc


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osSleepF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300d0.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.a510104.1.1.0.html\"\>a510104:  WAKEsHOW( "example.simplest.func.10300d0.etherC.osSleepF" )\</A\>
multiday sleep
arguments
 time1P
 time2P
  should be >= 0
   if time2P < 0 then this function returns immediately
 timeGrain1P
  can be 0
   implies one TOCK
 timeGrain2P
  must be 0
  this parameter is present for consistency with other time commands
  this grain size restriction does not restrict the total time to sleep
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001004b.flSLEEP!||
*/
/**/
/*1*/voidT etherC::osSleepF( tinS& tinP , const countT time1P , const sCountT time2P , const countT timeGrain1P , const sCountT timeGrain2P , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP && this != &etPrimeIF( tinP ) ) { BLAMMO ; }  // PREVENTS CPU PEGGING; WILL GET BLAMMO INSTEAD

        if( POOP ) return ;
        __( timeGrain2P ) ;_WQ
        __( timeGrain2P < 0 ) ; // FOR FUTURE USE, WHEN timeGrain2P != 0 IS SUPPORTED
        FV( flSLEEP , flagsP ) ;_WQ
        if( POOP ) return ;
    }

    _IO_

    if( !( F(flagsMode) & flTHIRDmODE_TESTaUTO ) || F(flagsP) & flSLEEP_IGNORE_flTHIRDmODE_TESTaUTO || F(flagsMode) & flTHIRDmODE_TESTaUTOdOsLEEPS )
    {
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;_WQ
        countT timeGrain = timeGrain1P ;_WQ
        if( !timeGrain ) timeGrain = TOCK ;_WQ
        if( !time2P && timeGrain > time1P ) timeGrain = time1P ;_WQ
        if( timeGrain > TOCK * 2 ) timeGrain = TOCK * 2 ;_WQ

        countT  time1 = time1P ;_WQ
        sCountT time2 = time2P ;_WQ

        while( !POOP && time2 >= 0 )
        {
            osTimeSubtractF( tinP , time1 , time2 , timeGrain , 0 ) ;_WQ
            if( F(flagsP) & flSLEEP_TALK )
            {
                ZE( strokeS* , psttw ) ;_WQ
                strFromTimeF( tinP , psttw , time1 , time2 ) ; ___( psttw ) ;_WQ
                strokeF( tinP , T("")+S2(0,scOld_SYSmARK)+T(psttw) ) ;_WQ
                delF( tinP , psttw ) ;_WQ
            }
            sleepStartF( tinP ) ;_WQ
            ++ s ; third.dosSleepIF( tinP , timeGrain , timeGrain ) ;_WQ
            sleepEndF( tinP ) ;_WQ
            if( F(flagsP) & flSLEEP_TALK ) strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT) ) ;_WQ
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b6.etherc.ossleepf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b7.etherc.boxpourf BEGIN
#define DDNAME       "3func.360020b7.etherc.boxpourf"
#define DDNUMB      (countT)0x360020b7
#define IDFILE      (countT)0xcdd


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxPourF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300d1.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.3810104.1.1.0.html\"\>3810104:  WAKEsHOW( "example.simplest.func.10300d1.etherC.boxPourF" )\</A\>
  \<A HREF=\"5.5f20104.1.1.0.html\"\>5f20104:  WAKEsHOW( "example.simplest.func.10300d1.etherC.boxPourF" )\</A\>
psttLikeFromP and psttLikeToP must be on the same file system
the last stroke in each parameter must be a slash
the directory specified by psttLikeToP need not exist
 all parent directories will be created as needed
evaluates to the number of files moved
arguments
 psttLikeToP
 psttLikeFromP
 csttEstimateP
  estimated strokes needed to store all file names
 cMaxP
  can be 0
  if not 0 then this is the maximum number of files that will be poured
*/
/**//*1*/countT etherC::boxPourF( tinS& tinP , const strokeS* const psttLikeToP , const strokeS* const psttLikeFromP , const countT csttEstimateP , const countT cMaxP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttLikeToP ) ;
        __Z( psttLikeFromP ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( countT , cFiles ) ;
    {
        soulC soul1m( tinP , TAG( TAGiDnULL ) ) ;
        cFiles = boxMenuF( tinP , soul1m , T(psttLikeFromP) + T("*") , 0 , cMaxP ) ;

        strokeS sttCut = psttLikeFromP[ CSpREFIX - 1 + psttLikeFromP->idAdam ] ;
        __( sttCut != S1C('/') ) ;

        if( cFiles ) diskMakeDirIfNeededF( tinP , psttLikeToP ) ;

        FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
        {
            if( POOP ) break ;

            ZE( strokeS* , psttTo ) ;
            {
                ZE( strokeS* , psttSuffix ) ;
                ZE( countT , idl ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;

                countT idf = strIdF( tinP , countTC( 1 ) , sttq , sttCut , psttc1 , 0 , - 1 ) ;
                strSubstringF( tinP , psttSuffix , ++ idf , idl , psttc1 ) ; ___( psttSuffix ) ;
                strFuseF( tinP , psttTo , T(psttLikeToP)+T(psttSuffix) ) ; ___( psttTo ) ;
                delF( tinP , psttSuffix ) ;
            }
            diskMoveFileOrDirF( tinP , psttTo , psttc1 ) ; //U: ENHANCE: SUPPORT CASE WHERE FILES ARE ON DIFFERENT VOLUMES
            delF( tinP , psttTo ) ;
        }
        FORsTRINGSiNsPANNEDcOMBINEDtAIL1
    }

    return cFiles ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b7.etherc.boxpourf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b8.etherc.stridmatchingf BEGIN
#define DDNAME       "3func.360020b8.etherc.stridmatchingf"
#define DDNUMB      (countT)0x360020b8
#define IDFILE      (countT)0xcde


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strIdMatchingF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300d2.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6b10104.1.1.0.html\"\>6b10104:  WAKEsHOW( "example.simplest.func.10300d2.etherC.strIdMatchingF" )\</A\>
returns the id of the next stroke that matches the stroke at idFirstP
this is forward looking
 it cannot be used to match a ')' with its preceding '('
matching rules
 special matching pairs
  '(' and ')'
  '[' and ']'
  '{' and '}'
  '<' and '>'
 other strokes are matched to their next occurance
 examples
  '[' will match with ']'
  '}' will match with '{'
  'i' will match with 'i'
  'I' will match with 'I'
  '/' will match with '/'
sets idFirstP to the id of the stroke after the match found
behavior when matching the double quote stroke is undefined and subject to change
arguments
 idFirstP
  must not be 0
 sttQuoteP
 psttBigP
  must not be 0
*/
/**//*1*/countT etherC::strIdMatchingF( tinS& tinP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* const psttBigP , sCountT idP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( idFirstP ) ;_WQ
        __Z( psttBigP ) ;_WQ
        __Z( idP ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_
    STRiDrECURSE( strIdMatchingF( tinP , idf , sttQuoteP , psttBigP , 1 ) )
    {
        if( idFirstP < psttBigP->idAdam )
        {
            strokeS stt1 = psttBigP[ CSpREFIX - 1 + idFirstP ] ;_WQ
            idFirstP ++ ;_WQ
            switch( stt1 )
            {
                case '(' :
                case '[' :
                case '{' :
                case '<' :
                {
                    strokeS stt2 ;_WQ
                         if( stt1 == S1C('(') ) stt2 = S1C(')') ;
                    else if( stt1 == S1C('[') ) stt2 = S1C(']') ;
                    else if( stt1 == S1C('{') ) stt2 = S1C('}') ;
                    else if( stt1 == S1C('<') ) stt2 = S1C('>') ;
                    ZE( strokeS* , pstta ) ;_WQ
                    strFuseF( tinP , pstta , stt1 , 1 ) ; ___( pstta ) ;_WQ
                    strFuseF( tinP , pstta , stt2     ) ; ___( pstta ) ;_WQ
    
                    ZE( boolT , bFound ) ;_WQ
                    countT cOpen = 1 ;_WQ
                    while( idFirstP && !POOP && cOpen )
                    {
                        idHit = strIdAnyF( tinP , 0 , flSTRmATCH_null , idFirstP , sttQuoteP , pstta , psttBigP ) ;_WQ
                        if( idHit && idFirstP > idHit + 1 ) idFirstP = idHit + 1 ; // IF WE FIND E.G. "()((()))()()()", WE WANT TO PROCESS EACH ONE, NOT JUMP TO THE END OF THIS STRING OF PARENS
    
                        if( !idHit ) ;
                        else if( psttBigP[ CSpREFIX - 1 + idHit ] == stt1 ) cOpen ++ ;
                        else if( psttBigP[ CSpREFIX - 1 + idHit ] == stt2 ) cOpen -- ;
    
                        if( cOpen ) idHit = 0 ;_WQ
                    }
    
                    delF( tinP , pstta ) ;_WQ
                    break ;
                }
                default : { idHit = strIdF( tinP , idFirstP , sttQuoteP , psttBigP[ CSpREFIX - 2 + idFirstP ] , psttBigP ) ; break ; }
            }
        }
    }

    return idHit ;
}

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b8.etherc.stridmatchingf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b9.etherc.strsubstringexamplef BEGIN
#define DDNAME       "3func.360020b9.etherc.strsubstringexamplef"
#define DDNUMB      (countT)0x360020b9
#define IDFILE      (countT)0xcdf


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strSubstringExampleF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300d3.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9b10104.1.1.0.html\"\>9b10104:  WAKEsHOW( "example.simplest.func.10300d3.etherC.strSubstringExampleF" )\</A\>
extracts a function call from the string
arguments
 psttP
  must be 0
 idFirstP
  must not be 0
 sttQuoteP
 psttBigP
  must not be 0
 psttTokenP
  must not be 0
 sttOpen
 psttWhite
*/
/**/
/*1*/voidT etherC::strSubstringExampleF( tinS& tinP , strokeS*& psttP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* const psttBigP , const strokeS* const psttTokenP , const strokeS sttOpenP , const strokeS* const psttWhiteP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( idFirstP ) ;
        __Z( psttBigP ) ;
        __Z( psttTokenP ) ;
        if( POOP ) return ;
    }

    _IO_
    const strokeS sttOpen = (countT)sttOpenP ? sttOpenP : S1C('(') ;
    ZE( strokeS* , psttWhite ) ;
    if( psttWhiteP ) { strMakeF( tinP , LF , psttWhite , psttWhiteP    ) ; ___( psttWhite ) ; }
    else             { strMakeF( tinP , LF , psttWhite , T(TbLACK) ) ; ___( psttWhite ) ; }

    while( !psttP && idFirstP )
    {
        const countT idfTok = strIdF( tinP , 0 , flSTRmATCH_null , idFirstP , sttQuoteP , psttTokenP , psttBigP ) ;
        if( idfTok && ( idfTok == 1 || !psttBigP[ CSpREFIX - 2 + idfTok ].bOkForIdentifiersF() ) )
        {
            countT idfTrim = idfTok ;
            ZE( countT , idlTrim ) ;
            {
                strokeS sttqc = sttQuoteP ;
                countT idfc = idfTok + psttTokenP->idAdam ;

                {
                    strokeS sttqc2 = sttqc ;
                    countT idfc2 = idfc ;
                    if( idfc == strIdAnyF( tinP , 0 , flSTRmATCH_null , idfc2 , sttqc2 , psttWhite , psttBigP ) )
                    {
                        sttqc = sttqc2 ;
                        idfc = idfc2 ;
                    }
                }
                // idfc IS THE ID OF THE FIRST NONBLANK STROKE AFTER THE OCCURRANCE

                if( psttBigP[ CSpREFIX - 1 + idfc ] == sttOpen ) idlTrim = strIdMatchingF( tinP , idfc , sttqc , psttBigP ) ;
            }

            if( idfTrim && idlTrim )
            {
                strSubstringF(  tinP , psttP , idfTrim , idlTrim        , psttBigP                 ) ; // CALLER MUST TAG ___( psttP ) ;
                strReplaceAnyF( tinP , psttP , 0 , psttWhite                       , T(" ")                   ) ; // CALLER MUST TAG ___( psttP ) ;
                strReplaceF(    tinP , psttP , 0 , T(psttTokenP)+T(" ")+T(sttOpen) , T(psttTokenP)+T(sttOpen) ) ; // CALLER MUST TAG ___( psttP ) ;
            }
        }
    }

    delF( tinP , psttWhite ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020b9.etherc.strsubstringexamplef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020bb.etherc.strfromurlf BEGIN
#define DDNAME       "3func.360020bb.etherc.strfromurlf"
#define DDNUMB      (countT)0x360020bb
#define IDFILE      (countT)0xce0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFromUrlF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300d6.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
decodes a url, typically one that contains a query
 urls that contain queries typically are encoded
  each blank is represented by a "+"
  each non-alphanumeric is represented by a %xx
   xx denotes two hexadecimal digits
this function replaces occurances of "+" with " "
it replaces occurances of "%xx" with the corresponding character
 xx can be in lower or upper or mixed case
  %bc  %BC  %bC  %Bc  are treated identically
 this is an exception to the norm within IdeaFarm " "(tm) City
  normally, hexadecimal digits must be in lower case
psttOldP can be 0
arguments
 psttP
 psttOldP
*/
/**/

/*1*/voidT etherC::strFromUrlF( tinS& tinP , strokeS*& psttP , const strokeS* const psttOldP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( !psttP && !psttOldP ) ;
        if( POOP ) return ;
    }

    _IO_

    //NEW CODE
    #if !defined( NEVERdEFINED )

        ZE( const strokeS* , psttOld ) ;
        if( psttOldP ) psttOld = psttOldP ;
        else
        {
            psttOld = psttP ;
                      psttP = 0 ;
        }

        __Z( psttOld ) ;
        __NZ( psttP ) ;

        ZE( osTextT* , postOld ) ;
        countT costOld = strMakeF( tinP , LF , postOld , psttOld ) ; ___( postOld ) ;

        ZE( osTextT* , postNew ) ;
        newF( tinP , LF , postNew , costOld + 1 ) ; ___( postNew ) ;

        if( postOld && postNew )
        {
            ZE( countT , offo ) ;
            for( countT offi = 0 ; offi < costOld ; offi ++ )
            {
                switch( postOld[ offi ] )
                {
                    case '+' : { postNew[ offo ++ ] = ' ' ; break ; }
                    case '%' :
                    {
                        if( offi + 2 < costOld )
                        {
                            ZE( countT , vv ) ;
                            countT cToDo = 2 ;
                            while( cToDo -- )
                            {
                                vv <<= 4 ;
                                countT code = postOld[ ++ offi ] ;
                                     if( code >= '0' && code <= '9' ) vv +=       code - '0' ;
                                else if( code >= 'a' && code <= 'f' ) vv += 0xa + code - 'a' ;
                                else if( code >= 'A' && code <= 'F' ) vv += 0xa + code - 'A' ;
                            }
                            postNew[ offo ++ ] = (osTextT)vv ;
                        }

                        break ;
                    }
                    default  : { postNew[ offo ++ ] = postOld[ offi ] ; break ; }
                }
            }
            postNew[ offo ++ ] = 0 ;

            strMakeF( tinP , LF , psttP , T(postNew) ) ; //CALLER MUST TAG ___( psttP ) ;
        }

        delF( tinP , postNew ) ;
        delF( tinP , postOld ) ;
        if( !psttOldP ) delF( tinP , *(strokeS**)&psttOld ) ;

    //OLD CODE
    #else

        if( psttOld ) { strFuseF( tinP , psttP , psttOld ) ; ___( psttP ) ; }
    
        strReplaceF( tinP , psttP , 0 , T("+") , T(" ") ) ;
    
        // REPLACE %HH SYMBOLS WITH NON-ALPHANUMERICS
        for( countT vv = 1 ; vv <= 0x7f ; vv ++ ) // FOR EACH ASCII VALUE (7 BITS)
        {
            if
            (
                ( vv >= 'a' && vv <= 'z' ) ||
                ( vv >= 'A' && vv <= 'Z' ) ||
                ( vv >= '0' && vv <= '9' ) ||
                ( vv == ' ' )
            )
            continue ; //ASSUME: PLAIN ALPHANUMERIC VALUES ARE NOT ENCODED (THIS IS A SPEED OPTIMIZATION)
    
            const osTextT postn[] = { (osTextT)vv , 0 } ;
            TN( tNew , postn ) ;
    
            textC tOld = T("%")+TF3(vv,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,2) ;
            ZE( strokeS* , psttOld2 ) ;
            strMakeF( tinP , LF , psttOld2 , tOld ) ; ___( psttOld2 ) ;
            strConvertToUpperCaseF( tinP , psttOld2 ) ; ___( psttOld2 ) ;
    
            strReplaceF( tinP , psttP , 0 , tOld     , tNew ) ;
            strReplaceF( tinP , psttP , 0 , psttOld2 , tNew ) ;
            delF( tinP , psttOld2 ) ;
        }

    #endif
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020bb.etherc.strfromurlf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020bc.etherc.osprocessf BEGIN
#define DDNAME       "3func.360020bc.etherc.osprocessf"
#define DDNUMB      (countT)0x360020bc
#define IDFILE      (countT)0xce1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osProcessF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300d7.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 idAdamP
 pidP
  must be 0
 psttArgsP
  see the documentation for symbol MAIN for a list of the directives that can be specified
  the directives in psttArgsP are presented after (to the right of) an implicit !tinP.pAdamGlobal1->_etherC_.idCitizenHirer <idCitizen> directive
  because of this, psttArgsP can override the implicit !tinP.pAdamGlobal1->_etherC_.idCitizenHirer directive
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00101db.flPROCESShIRE!||
  it is illegal to set a value other than the default when calling from the definition of an adam
*/

/**/

/*1*/voidT etherC::osProcessF( tinS& tinP , countT& tidP , countT& pidP , const countT idAdamP , const strokeS* const psttArgsP , const flagsT flagsP , const handleC* phOutP , const handleC* phErrorP , const handleC* phInP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pidP ) ;
        __Z( idAdamP ) ;
        FV( flPROCESShIRE , flagsP )
        if( POOP ) return ;
    }

    _IO_
    osProcessF( tinP , tidP , pidP , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.41000002.ipdos-we") , TF3(idAdamP,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+(psttArgsP?T(" ")+T(psttArgsP):T("")) , flagsP , phOutP , phErrorP , phInP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020bc.etherc.osprocessf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020bd.etherc.osprocessf BEGIN
#define DDNAME       "3func.360020bd.etherc.osprocessf"
#define DDNUMB      (countT)0x360020bd
#define IDFILE      (countT)0xce2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osProcessF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300d8.1.0.html\"\>definition\</A\>
U: this function is out of date and will not work as currently defined
it is illegal to refer to this symbol in the definition of an adam
arguments
 valueP
  must be 0
 idDeathTypeP
  must be 0
 tinP
 idAdamP
 psttArgsP
  see the documentation for symbol MAIN for a list of the directives that can be specified
  the directives in psttArgsP are presented after (to the right of) an implicit !tinP.pAdamGlobal1->_etherC_.idCitizenHirer <idCitizen> directive
  because of this, psttArgsP can override the implicit !tinP.pAdamGlobal1->_etherC_.idCitizenHirer directive
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00101db.flPROCESShIRE!||
  it is illegal to set a value other than the default when calling from the definition of an adam
*/
/**//*1*/voidT etherC::osProcessF( tinS& tinP , countT& osTidP , countT& osPidP , countT& valueP , countT& idDeathTypeP , const countT idAdamP , const strokeS* const psttArgsP , const flagsT flagsP , const handleC* phOutP , const handleC* phErrorP , const handleC* phInP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( valueP ) ;
        __NZ( idDeathTypeP ) ;
        __Z( idAdamP ) ;
        if( POOP ) return ;
    }

    _IO_
    osProcessF( tinP , osTidP , osPidP , valueP , idDeathTypeP , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.41000002.ipdos-we") , TF3(idAdamP,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+(psttArgsP?T(" ")+T(psttArgsP):T("")) , flagsP , phOutP , phErrorP , phInP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020bd.etherc.osprocessf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020be.etherc.ossessionf BEGIN
#define DDNAME       "3func.360020be.etherc.ossessionf"
#define DDNUMB      (countT)0x360020be
#define IDFILE      (countT)0xce3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osSessionF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300d9.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
on windows, the flSESSION_KID flag has no effect
 the process is a non-kid, even if the kid flag is set, because windows does not support the concept of kid processes
arguments
 valueP
  must be 0
 idDeathTypeP
  must be 0
 psttExeP
 psttArgsP
  can be 0
 idColP
 idRowP
 cColP
 cRowP
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001000e.flSESSION!||
*/

/**/

/*1*/voidT etherC::osSessionF( tinS& tinP , countT& osTidP , countT& osPidP , countT& valueP , countT& idDeathTypeP , const strokeS* const psttExeP , const strokeS* const psttArgsP , const countT idColP , const countT idRowP , const countT cColP , const countT cRowP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( valueP ) ;
        __( idDeathTypeP ) ;
        FV( flSESSION , flagsP ) ;
        if( POOP ) return ;
    }

    _IO_
    /*osFileNameC*/
    #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000003.argsForOrphanProcessLaunch.h"

    third.dosStartSessionF( tinP , osTidP , osPidP , valueP , idDeathTypeP , osf , post1Args , idColP , idRowP , cColP , cRowP , flagsP ) ;
    delF( tinP , postExe ) ;
    delF( tinP , post1Args ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020be.etherc.ossessionf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020bf.etherc.ossessionf BEGIN
#define DDNAME       "3func.360020bf.etherc.ossessionf"
#define DDNUMB      (countT)0x360020bf
#define IDFILE      (countT)0xce4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osSessionF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300da.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 valueP
  must be 0
 idDeathTypeP
  must be 0
 idAdamP
 psttArgsP
  can be 0
 idColP
 idRowP
 cColP
 cRowP
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001000e.flSESSION!||
*/
/**//*1*/voidT etherC::osSessionF( tinS& tinP , countT& osTidP , countT& osPidP , countT& valueP , countT& idDeathTypeP , const countT idAdamP , const strokeS* const psttArgsP , const countT idColP , const countT idRowP , const countT cColP , const countT cRowP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( valueP ) ;
        __( idDeathTypeP ) ;
        __Z( idAdamP ) ;
        FV( flSESSION , flagsP ) ;
        if( POOP ) return ;
    }

    _IO_
    osSessionF( tinP , osTidP , osPidP , valueP , idDeathTypeP , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.41000003.ipdos-we") , TF3(idAdamP,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+(psttArgsP?T(" ")+T(psttArgsP):T("")) , idColP , idRowP , cColP , cRowP , flagsP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020bf.etherc.ossessionf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c0.etherc.strclinesf BEGIN
#define DDNAME       "3func.360020c0.etherc.strclinesf"
#define DDNUMB      (countT)0x360020c0
#define IDFILE      (countT)0xce5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strCLinesF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300db.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.0030104.1.1.0.html\"\>0030104:  WAKEsHOW( "example.simplest.func.10300db.etherC.strCLinesF" )\</A\>
returns the number of lines in psttP
arguments
 psttP
  can be 0
 psttEndP
  delimits each line
  if 0 then T("\r\n") is used
 bAnyP
  can be 0 or 1
  if 1 then every substring consisting only of the strokes in psttEndP (or T("\r\n")) will be treated as a line terminator
   for example, T("\r") , T("\n"), T("\n\r"), and T("\r\n") would all match psttEndP == T("\r\n") if bAny is 1
*/
/**/

/*1*/countT etherC::strCLinesF( tinS& tinP , const strokeS* const psttP , const strokeS* const psttEndP , const boolT bAnyP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( countT , cLines ) ;

    if( psttP->idAdam )
    {
        ZE( strokeS* , psttEnd ) ;
        if( psttEndP ) { strFuseF( tinP , psttEnd , psttEndP ) ; ___( psttEnd ) ; }
        else           { strMakeF( tinP , LF , psttEnd , T("\r\n")   ) ; ___( psttEnd ) ; }

        countT idf = 1 ;
        strokeS sttq = S2(0,sc_IGNOREqUOTES) ;
        while( !POOP && idf ) 
        {
            if( ( bAnyP ? strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , psttEnd , psttP ) : strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , psttEnd , psttP ) ) && !idf ) cLines ++ ;
            cLines ++ ;
        }
        delF( tinP , psttEnd ) ;
    }

    return cLines ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c0.etherc.strclinesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c1.etherc.strsubstringlinef BEGIN
#define DDNAME       "3func.360020c1.etherc.strsubstringlinef"
#define DDNUMB      (countT)0x360020c1
#define IDFILE      (countT)0xce6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strSubstringLineF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300dc.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.3030104.1.1.0.html\"\>3030104:  WAKEsHOW( "example.simplest.func.10300dc.etherC.strSubstringLineF" )\</A\>
retrieves the idLineP'th line in psttAllP, treating the stroke at idFirstP as in line 1
this can be evaluated repeatedly with idLineP == 1 to retrieve each line in psttAllP
if there are not enough lines, psttP will be 0 and impotence does not occur
i am more efficient than strWordsOldF
 my efficiency is that i only create a copy of wo line per call
 this copy can be d eleted by the caller before calling me for the next line
 this results in using less poolOld space
 in contrast, strWordsOldF will copy the entire input
arguments
 psttP
  must be 0
 idFirstP
  must not be 0
  normally this should be 1 when beginning to process psttAllP
 sttQuoteP
  normally, this should be 0 when beginning to process psttAllP
 psttAllP
  must not be 0
 idLineP
  must not be 0
  can be negative
  if negative then indexes from the end
   - 1 refers to the last line
 psttEndP
  delimits each line
  if 0 then T("\r\n") is used
 bAnyP
  of 0 then each occurance of psttEndP is treated as a delimiter
  if 1 then each substring that consists only of strokes in psttEndP is treated as a delimiter
 csttExtraP
*/
/**//*1*/voidT etherC::strSubstringLineF( tinS& tinP , strokeS*& psttP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* const psttAllP , const sCountT idLineP , const strokeS* const psttEndP , const boolT bAnyP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( idFirstP ) ;
        __Z( psttAllP ) ;
        __Z( idLineP ) ;
        if( POOP ) return ;
    }

    _IO_

    if( psttAllP->idAdam )
    {
        textC tEnd = psttEndP ? T(psttEndP) : T("\r\n") ;

        if( idLineP < 0 )
        {
            sCountT cWords = strCLinesF( tinP , psttAllP , tEnd , 1 ) ;
            if( cWords + idLineP >= 0 )
            {
                strSubstringLineF( tinP , psttP , idFirstP , sttQuoteP , psttAllP , cWords + idLineP + 1 , tEnd , bAnyP , csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;
            }
        }
        else
        {
            ZE( countT , idLine ) ;
            while( !POOP && idFirstP ) 
            {
                idLine ++ ;

                countT idf = idFirstP ;
                countT idl = bAnyP ? strIdAnyF( tinP , 0 , flSTRmATCH_null , idFirstP , sttQuoteP , tEnd , psttAllP ) : strIdF( tinP , 0 , flSTRmATCH_null , idFirstP , sttQuoteP , tEnd , psttAllP ) ;

                if( idLine == idLineP )
                {
                    if( idl == idf ) strMakeF( tinP , LF , psttP , T("") , csttExtraP ) ;
                    else
                    {
                        if( idl ) idl -- ;
                        strSubstringF( tinP , psttP , idf , idl , psttAllP , csttExtraP ) ;
                    }

                    break ;
                }
            }
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c1.etherc.strsubstringlinef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c2.etherc.strbadcodelinef BEGIN
#define DDNAME       "3func.360020c2.etherc.strbadcodelinef"
#define DDNUMB      (countT)0x360020c2
#define IDFILE      (countT)0xce7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strBadCodeLineF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300dd.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
sets psttP to a line triplet containing the first definition line that contains an error
if the specified adam has not yet been made, psttP will remain null
if the specified adam was made successfully, psttP will remain null
the adam class might have been made even if psttP is not null
 for "warning" errors, psttP will report the problematic line even though the adam class was made
arguments
*/
/**/

/*1*/voidT etherC::strBadCodeLineF( tinS& tinP , strokeS*& psttP , const strokeS* const psttIdAdamP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( psttIdAdamP ) ;
        if( POOP ) return ;
    }

    _IO_

    IFsCRATCH
    {
        SCOOPS
        ZE( strokeS* , psttErr ) ;
        {
            ZE( osTextT* , postErr ) ;
            ZE( countT , costErr ) ;
            tinP.pEtScratch->boxGetShadowF( tinP , postErr , costErr , T("///ideafarm/ephemeral/backed.up.never/gen/")+T(psttIdAdamP)+T("/windows/")+T(psttIdAdamP)+T(".err") , 1 ) ; ___( postErr ) ;
            tinP.pEtScratch->strMakeF( tinP , LF , psttErr , T(postErr) ) ; ___( psttErr ) ;
            tinP.pEtScratch->delF( tinP , postErr ) ;
        }

        ZE( countT , idLine ) ;
        ZE( countT , idCol ) ;
        {
            countT idf = 1 ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf2 = tinP.pEtScratch->strIdF( tinP , idf , sttq , S1C('(') , psttErr ) ;
            countT idl2 = tinP.pEtScratch->strIdF( tinP , idf , sttq , S1C(')') , psttErr ) ;
            if( idf2 && idl2 )
            {
                idf2 ++ ;
                idl2 -- ;
                ZE( strokeS* , psttw ) ;
                tinP.pEtScratch->strSubstringF( tinP , psttw , idf2 , idl2 , psttErr ) ; ___( psttw ) ;
                idLine = tinP.pEtScratch->strDigitsToSCountF( tinP , psttw , 0xa , 1 ) ;
                tinP.pEtScratch->delF( tinP , psttw ) ;

                tinP.pEtScratch->strSubstringF( tinP , psttw , idf , sttq , T("\r\n") , psttErr , 1 ) ; ___( psttw ) ;
                idf = 1 ;
                //sttq = ze ;
                idf2 = tinP.pEtScratch->strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , T("(col ") , psttw ) ;
                idl2 = tinP.pEtScratch->strIdF( tinP     , idf , sttq , S1C(')')   , psttw ) ;
                if( idf2 && idl2 )
                {
                    idf2 += 5 ; // "(col "
                    idl2 -- ;
                    ZE( strokeS* , psttw2 ) ;
                    tinP.pEtScratch->strSubstringF( tinP , psttw2 , idf2 , idl2 , psttw ) ; ___( psttw2 ) ;
                    idCol = tinP.pEtScratch->strDigitsToSCountF( tinP , psttw2 , 0xa , 1 ) ;
                    tinP.pEtScratch->delF( tinP , psttw2 ) ;
                }
                tinP.pEtScratch->delF( tinP , psttw ) ;
            }
        }
        tinP.pEtScratch->delF( tinP , psttErr ) ;

        ZE( strokeS* , psttBad ) ;
        {
            ZE( strokeS* , psttAll ) ;
            {
                ZE( osTextT* , postAll ) ;
                ZE( countT , costAll ) ;
                tinP.pEtScratch->boxGetShadowF( tinP , postAll , costAll , T("///ideafarm/ephemeral/backed.up.never/gen/")+T(psttIdAdamP)+T("/")+T(psttIdAdamP)+T(".cpp") , 1 ) ; ___( postAll ) ;
                tinP.pEtScratch->strMakeF( tinP , LF , psttAll , T(postAll) ) ; ___( psttAll ) ;
                tinP.pEtScratch->delF( tinP , postAll ) ;
            }
            countT idf = 1 ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            tinP.pEtScratch->strSubstringLineF( tinP , psttBad , idf , sttq , psttAll , idLine ) ;
            tinP.pEtScratch->delF( tinP , psttAll ) ;
        }

        if( psttBad )
        {
            if( !idCol )
            {
                tinP.pEtScratch->strMakeF( tinP , LF , psttP , psttBad ) ; //CALLER MUST TAG ___( psttP ) ;
            }
            else
            {
                ZE( strokeS* , psttp ) ;
                tinP.pEtScratch->strResizeF( tinP , psttp , idCol - 1 ) ; ___( psttp ) ;
                tinP.pEtScratch->strMakeF( tinP , LF , psttP , T(psttp)+T("@\r\n")+T(psttBad)+T("\r\n")+T(psttp)+T("@\r\n") ) ; //CALLER MUST TAG ___( psttP ) ;
                tinP.pEtScratch->delF( tinP , psttp ) ;
            }
            tinP.pEtScratch->delF( tinP , psttBad ) ;
        }

        if( POOP ) POOPR
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c2.etherc.strbadcodelinef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c3.etherc.osthreadswitchingdesiref BEGIN
#define DDNAME       "3func.360020c3.etherc.osthreadswitchingdesiref"
#define DDNUMB      (countT)0x360020c3
#define IDFILE      (countT)0xce8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osThreadSwitchingDesireF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300de.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6f20104.1.1.0.html\"\>6f20104:  WAKEsHOW( "example.simplest.func.10300de.etherC.osThreadSwitchingDesireF" )\</A\>
obtains the current priority for the current thread
return value symbols
//||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001007f.ifcTHREADpRIORITY!||
os/2: unfinished
*/
/**/

/*1*/countT etherC::osThreadSwitchingDesireF( tinS& tinP )/*1*/
{
    SCOOP

    //THIS MUST BE DONE EVEN IF IMPOTENT SO THAT GRABBING/UNGRABBING WILL WORK
    //IFbEcAREFUL
    //{
    //    if( POOP ) return 0 ;
    //}

    _IO_
    countT idDesire = third.dosPriorityIF( tinP ) ;
    return idDesire ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c3.etherc.osthreadswitchingdesiref END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c4.etherc.ifcdatumf BEGIN
#define DDNAME       "3func.360020c4.etherc.ifcdatumf"
#define DDNUMB      (countT)0x360020c4
#define IDFILE      (countT)0xce9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcDatumF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300e0.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 postFileP
 idLineP
 cLinesInDefP
*/
/**//*1*/voidT etherC::ifcDatumF( tinS& tinP , const osTextT* const postFileP , const countT idLineP , const countT cLinesInDefP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , psttf ) ;
    ZE( strokeS* , pstti ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    strWordF( tinP , pstti , T(postFileP) , sttq , S1C('.') ) ; ___( pstti ) ;
    strFromF( tinP , psttf , strDigitsToSCountF( tinP , pstti ) , flFORMAT_UNSIGNED | flFORMAT_FILLzE , 7 , 16 ) ; ___( psttf ) ;
    delF( tinP , pstti ) ;
    ZE( strokeS* , pstta ) ;
    strFuseF( tinP , pstta , T(psttf)+T("(")+TF4(/*U:5*/14+cLinesInDefP-idLineP,0,0,10)+T(")") ) ; ___( pstta ) ;
    delF( tinP , psttf ) ;
    ifcSayIF( T(pstta) , flSAY_APPEND | flSAY_LOG ) ;
    delF( tinP , pstta ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c4.etherc.ifcdatumf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c5.etherc.ostimesetf BEGIN
#define DDNAME       "3func.360020c5.etherc.ostimesetf"
#define DDNUMB      (countT)0x360020c5
#define IDFILE      (countT)0xcea


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osTimeSetF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300e1.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
sets the local host's clock by querying the united states national institute of standards
arguments
*/
/**//*1*/voidT etherC::osTimeSetF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    ZE( osTextT* , posti ) ;
    ZE( countT   , costi ) ;
    boxGetShadowF( tinP , posti , costi , T("132.163.135.130/14_9/http/index.html") ) ; ___( posti ) ;
    TN( tIn , posti ) ;
    delF( tinP , posti ) ;
    strokeF( tinP , tIn ) ;

    ZE( countT , yy ) ;
    ZE( countT , mo ) ;
    ZE( countT , dd ) ;
    ZE( countT , hh ) ;
    ZE( countT , mm ) ;
    ZE( countT , ss ) ;
    {
        ZE( strokeS* , psttYY ) ;
        ZE( strokeS* , psttMO ) ;
        ZE( strokeS* , psttDD ) ;
        ZE( strokeS* , psttHH ) ;
        ZE( strokeS* , psttMM ) ;
        ZE( strokeS* , psttSS ) ;
        {
            countT idf =  9 ; countT idl = 10 ; strSubstringF( tinP , psttYY , idf , idl , tIn ) ; ___( psttYY ) ;
                   idf = 12 ;        idl = 13 ; strSubstringF( tinP , psttMO , idf , idl , tIn ) ; ___( psttMO ) ;
                   idf = 15 ;        idl = 16 ; strSubstringF( tinP , psttDD , idf , idl , tIn ) ; ___( psttDD ) ;
                   idf = 18 ;        idl = 19 ; strSubstringF( tinP , psttHH , idf , idl , tIn ) ; ___( psttHH ) ;
                   idf = 21 ;        idl = 22 ; strSubstringF( tinP , psttMM , idf , idl , tIn ) ; ___( psttMM ) ;
                   idf = 24 ;        idl = 25 ; strSubstringF( tinP , psttSS , idf , idl , tIn ) ; ___( psttSS ) ;
        }

        yy = strDigitsToSCountF( tinP , psttYY , 10 , 1 ) ;
        mo = strDigitsToSCountF( tinP , psttMO , 10 , 1 ) ;
        dd = strDigitsToSCountF( tinP , psttDD , 10 , 1 ) ;
        hh = strDigitsToSCountF( tinP , psttHH , 10 , 1 ) ;
        mm = strDigitsToSCountF( tinP , psttMM , 10 , 1 ) ;
        ss = strDigitsToSCountF( tinP , psttSS , 10 , 1 ) ;

        delF( tinP , psttYY ) ;
        delF( tinP , psttMO ) ;
        delF( tinP , psttDD ) ;
        delF( tinP , psttHH ) ;
        delF( tinP , psttMM ) ;
        delF( tinP , psttSS ) ;
    }

    third.dosSetSystemTimeF( tinP , yy - 1 + 1900 , mo - 1 , dd - 1 , hh , mm , ss ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c5.etherc.ostimesetf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c6.etherc.filetimestampsf BEGIN
#define DDNAME       "3func.360020c6.etherc.filetimestampsf"
#define DDNUMB      (countT)0x360020c6
#define IDFILE      (countT)0xceb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$fileTimestampsF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300e2.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
i will set the window title to indicate the file that i am working on
arguments
 psttLikeP
  a file name pattern
   example (remove the space between / and *): T("///c" "/mydir/ *.html")
   example                                   : T("///c" "/mydir/?.html")
   example (remove the space between / and *): T("///ideafarm/ephemeral/tmp/fooey/ *")
*/
/**//*1*/voidT etherC::fileTimestampsF( tinS& tinP , const strokeS* const psttLikeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    soulC soul1m( tinP , TAG( TAGiDnULL ) ) ;
    boxMenuF( tinP , soul1m , psttLikeP ) ;
    FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
    {
        if( POOP ) break ;

        ZE( countT , idf ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        if
        ( 
            ( idf = 1 , strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , T("/.")   , psttc1 ) == psttc1->idAdam - 1 ) ||
            ( idf = 1 , strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , T("/..")  , psttc1 ) == psttc1->idAdam - 2 ) ||
            ( idf = 1 , strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , T(".time") , psttc1 ) )
        )
        continue ;

        {
            ZE( strokeS* , psttw ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            strWordF( tinP , psttw , psttc1 , sttq , strokeS() , - 1 ) ; ___( psttw ) ;
            winSetTitleF( tinP , psttw ) ; //U: REPLACE THIS WITH A GOOD PROGRESS INDICATOR
            delF( tinP , psttw ) ;
        }

        ZE( strokeS* , psttTag ) ;
        strFuseF( tinP , psttTag , T(psttc1)+T(".time") ) ; ___( psttTag ) ;

        ZE( countT , time1 ) ;
        ZE( sCountT , time2 ) ;
        boxTimeF( tinP , time1 , time2 , psttc1 ) ;
        countT pc2[] = { time1 , time2 } ;
        boxPutF( tinP , psttTag , (byteT*)pc2 , 2 * sizeof( countT ) ) ;

        delF( tinP , psttTag ) ;
    }
    FORsTRINGSiNsPANNEDcOMBINEDtAIL1
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c6.etherc.filetimestampsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c7.etherc.sockwritequitf BEGIN
#define DDNAME       "3func.360020c7.etherc.sockwritequitf"
#define DDNUMB      (countT)0x360020c7
#define IDFILE      (countT)0xcec


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockWriteQuitF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300e3.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 idPortP
  must not be 0
 nicNameP
  can be 0
*/
/**//*1*/voidT etherC::sockWriteQuitF( tinS& tinP , const countT idPortP , const nicNameC nicNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    {
        socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
        sock.connectF( tinP , idPortP , nicNameP ) ;
        sock.writeF( tinP , (osTextT*)T("!quit\r\n") ) ;
        osTextT pb3[] = { 0 , 0 , 0 } ;
        __( 2 - sock.readF( tinP , pb3 , 2 ) ) ;
        __( pb3[ 0 ] - 'o' ) ;
        __( pb3[ 1 ] - 'k' ) ;
    }

    {
        socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
        sock.connectF( tinP , idPortP , nicNameP ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c7.etherc.sockwritequitf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c8.etherc.sockwritequitf BEGIN
#define DDNAME       "3func.360020c8.etherc.sockwritequitf"
#define DDNUMB      (countT)0x360020c8
#define IDFILE      (countT)0xced


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockWriteQuitF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300e4.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 idPortP
  must not be 0
 psttHostP
  must not be 0
*/
/**//*1*/voidT etherC::sockWriteQuitF( tinS& tinP , const countT idPortP , const strokeS* const psttHostP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttHostP ) ;
        if( POOP ) return ;
    }

    _IO_

    sockWriteQuitF( tinP , idPortP , socketC::nicNameIF( tinP , *this , psttHostP ) ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c8.etherc.sockwritequitf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c9.etherc.strencode_01f BEGIN
#define DDNAME       "3func.360020c9.etherc.strencode_01f"
#define DDNUMB      (countT)0x360020c9
#define IDFILE      (countT)0xcee


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strEncode_01F.0.html\"\>instances\</A\>
\<A HREF=\"5.10300e5.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.4030104.1.1.0.html\"\>4030104:  WAKEsHOW( "example.simplest.func.10300e5.etherC.strEncode_01F" )\</A\>
evaluates to the length of the encoded string placed into pboP
 a terminating null byte will be placed at the end of the encoded string
 the terminating null byte is excluded from the count
arguments
 pboP
  must be 0
 pbiP
  must not be 0
 cbiP
  can be 0
   if 0 then the null terminated byte string at pbiP will be encoded
   the terminating null will -not- be encoded
*/
/**/
struct binS
{
    countT b01 : 1 ;
    countT b02 : 1 ;
    countT b03 : 1 ;
    countT b04 : 1 ;
    countT b05 : 1 ;
    countT b06 : 1 ;
    countT b07 : 1 ;
    countT b08 : 1 ;
    countT b09 : 1 ;
    countT b0a : 1 ;
    countT b0b : 1 ;
    countT b0c : 1 ;
    countT b0d : 1 ;
    countT b0e : 1 ;
    countT b0f : 1 ;
    countT b10 : 1 ;
    countT b11 : 1 ;
    countT b12 : 1 ;
    countT b13 : 1 ;
    countT b14 : 1 ;
    countT b15 : 1 ;
    countT b16 : 1 ;
    countT b17 : 1 ;
    countT b18 : 1 ;
}
;

/*1*/countT etherC::strEncode_01F( tinS& tinP , byteT*& pboP , const byteT* const pbiP , const countT cbiP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( pboP ) ;
        __Z( pbiP ) ;
        if( POOP ) return 0 ;
    }

    countT cbi = cbiP ;
    if( !cbi ) cbi = strBodyLengthF( tinP , pbiP ) ;
    ZE( countT , cbo ) ;

    if( !cbi )
    {
        newF( tinP , LF , pboP , 1 ) ; ___( pboP ) ;
        if( pboP ) *pboP = 0 ;
    }
    else
    {
        cbo = ( ( cbi - 1 ) / 3 + 1 ) * 4 ;

        newF( tinP , LF , pboP , cbo + 1 ) ; ___( pboP ) ;

        countT cbPad = 3 - cbi % 3 ;
        if( cbPad == 3 ) cbPad = 0 ;

        static const osTextT postc[] =
        {
            'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' ,
            'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' ,
            'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' ,
            'Y' , 'Z' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ,
            'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' ,
            'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' ,
            'w' , 'x' , 'y' , 'z' , '0' , '1' , '2' , '3' ,
            '4' , '5' , '6' , '7' , '8' , '9' , '+' , '/'
        }
        ;

        const byteT* const pbe = pbiP + cbi ;
        const byteT* pbc = pbiP ;
        ZE( countT , off ) ;
        while( pbc < pbe - 3 )
        {
            binS* psi = (binS*)pbc ;

            ZE( countT , v1 ) ;
            ZE( countT , v2 ) ;
            ZE( countT , v3 ) ;
            ZE( countT , v4 ) ;
            binS* pso1 = (binS*)&v1 ;
            binS* pso2 = (binS*)&v2 ;
            binS* pso3 = (binS*)&v3 ;
            binS* pso4 = (binS*)&v4 ;

            pso2->b05 = psi->b01 ;
            pso2->b06 = psi->b02 ;
            pso1->b01 = psi->b03 ;
            pso1->b02 = psi->b04 ;
            pso1->b03 = psi->b05 ;
            pso1->b04 = psi->b06 ;
            pso1->b05 = psi->b07 ;
            pso1->b06 = psi->b08 ;
            pso3->b03 = psi->b09 ;
            pso3->b04 = psi->b0a ;
            pso3->b05 = psi->b0b ;
            pso3->b06 = psi->b0c ;
            pso2->b01 = psi->b0d ;
            pso2->b02 = psi->b0e ;
            pso2->b03 = psi->b0f ;
            pso2->b04 = psi->b10 ;
            pso4->b01 = psi->b11 ;
            pso4->b02 = psi->b12 ;
            pso4->b03 = psi->b13 ;
            pso4->b04 = psi->b14 ;
            pso4->b05 = psi->b15 ;
            pso4->b06 = psi->b16 ;
            pso3->b01 = psi->b17 ;
            pso3->b02 = psi->b18 ;

            pboP[ off ++ ] = postc[ v1 ] ;
            pboP[ off ++ ] = postc[ v2 ] ;
            pboP[ off ++ ] = postc[ v3 ] ;
            pboP[ off ++ ] = postc[ v4 ] ;

            pbc += 3 ;
        }

        {
            binS* psi = (binS*)pbc ;

            ZE( countT , v1 ) ;
            ZE( countT , v2 ) ;
            ZE( countT , v3 ) ;
            ZE( countT , v4 ) ;
            binS* pso1 = (binS*)&v1 ;
            binS* pso2 = (binS*)&v2 ;
            binS* pso3 = (binS*)&v3 ;
            binS* pso4 = (binS*)&v4 ;

            pso2->b05 = psi->b01 ;
            pso2->b06 = psi->b02 ;
            pso1->b01 = psi->b03 ;
            pso1->b02 = psi->b04 ;
            pso1->b03 = psi->b05 ;
            pso1->b04 = psi->b06 ;
            pso1->b05 = psi->b07 ;
            pso1->b06 = psi->b08 ;

            if( cbPad < 2 )
            {
                pso3->b03 = psi->b09 ;
                pso3->b04 = psi->b0a ;
                pso3->b05 = psi->b0b ;
                pso3->b06 = psi->b0c ;
                pso2->b01 = psi->b0d ;
                pso2->b02 = psi->b0e ;
                pso2->b03 = psi->b0f ;
                pso2->b04 = psi->b10 ;
            }

            if( !cbPad )
            {
                pso4->b01 = psi->b11 ;
                pso4->b02 = psi->b12 ;
                pso4->b03 = psi->b13 ;
                pso4->b04 = psi->b14 ;
                pso4->b05 = psi->b15 ;
                pso4->b06 = psi->b16 ;
                pso3->b01 = psi->b17 ;
                pso3->b02 = psi->b18 ;
            }

                             pboP[ off ++ ] = postc[ v1 ] ;
                             pboP[ off ++ ] = postc[ v2 ] ;
            if( cbPad == 2 ) pboP[ off ++ ] = '=' ;
            else             pboP[ off ++ ] = postc[ v3 ] ;
            if( cbPad      ) pboP[ off ++ ] = '=' ;
            else             pboP[ off ++ ] = postc[ v4 ] ;
        }

        pboP[ off ++ ] = 0 ;
    }

    return cbo ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020c9.etherc.strencode_01f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ca.etherc.boxgetshadowgenerationf BEGIN
#define DDNAME       "3func.360020ca.etherc.boxgetshadowgenerationf"
#define DDNUMB      (countT)0x360020ca
#define IDFILE      (countT)0xcef


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxGetShadowGenerationF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300e6.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7810104.1.1.0.html\"\>7810104:  WAKEsHOW( "example.simplest.func.10300e6.etherC.boxGetShadowGenerationF" )\</A\>
if ageP is 0, obtains the latest generation of a box
otherwise, obtains an older generation of a box
if the requested generation does not exist, pbP will remain 0 and ether will remain potent
arguments
 pbP
 cbP
 psttP
 psttLikeP
 ageP
 cOpenTriesP
  if 0 then will retry forever
  if not 0 then will try cOpenTriesP times
*/
/**//*1*/voidT etherC::boxGetShadowGenerationF( tinS& tinP , byteT*& pbP , countT& cbP , strokeS*& psttP , const strokeS* const psttLikeP , const countT csttEstimateP , const countT ageP , countT cOpenTriesP , const flagsT flagsOpenDetailsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pbP ) ;
        __NZ( cbP ) ;
        __NZ( psttP ) ;
        __Z( psttLikeP ) ;
    }

    _IO_
    ZE( countT , idMax ) ;
    ZE( countT , idMin ) ;
    boxMenuIdRangeF( tinP , idMin , idMax , T(psttLikeP)+T(".*") , csttEstimateP ) ;
    sCountT idWant = idMax - ageP ;

    if( idWant && idWant >= idMin )
    {
        strFuseF( tinP , psttP , T(psttLikeP)+T(".")+TF3(idWant,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ) ; ___( psttP ) ;
        boxC box( tinP , *this , psttP , 0 , 0 , 0 , cOpenTriesP , 0 , 0 , flagsOpenDetailsP ) ;
        box.getF( tinP , pbP , cbP ) ; ___( pbP ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ca.etherc.boxgetshadowgenerationf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020cc.etherc.strrulerf BEGIN
#define DDNAME       "3func.360020cc.etherc.strrulerf"
#define DDNUMB      (countT)0x360020cc
#define IDFILE      (countT)0xcf0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strRulerF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300e9.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.2030104.1.1.0.html\"\>2030104:  WAKEsHOW( "example.simplest.func.10300e9.etherC.strRulerF" )\</A\>
arguments
 psttP
  must be 0
 csP
  can be 0
  normally, should be nonze
*/
/**//*1*/voidT etherC::strRulerF( tinS& tinP , strokeS*& psttP , const countT csP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    if( !csP )
    {
        strMakeF( tinP , LF , psttP , T("") ) ; //CALLER MUST TAG
    }
    else
    {
        strResizeF( tinP , psttP , csP ) ; //CALLER MUST TAG

        {for( countT idc = 1 ; idc <= csP ; idc ++ )
        {
            countT dig = idc % 0x10 ;
            strokeS sttd ;
            if( dig < 0xa ) sttd = S1C('0') + dig       ;
            else            sttd = S1C('a') + dig - 0xa ;
            psttP[ CSpREFIX - 1 + idc ] = sttd ;
        }}

        for( countT idc = 0x10 ; idc <= csP ; idc += 0x10 )
        {
            countT dig = idc / 0x10 ;
            strokeS sttd ;
            if( dig < 0xa ) sttd = S1C('0') + dig       ;
            else            sttd = S1C('a') + dig - 0xa ;

            psttP[ CSpREFIX - 2 + idc ] = S1C('-') ;
            psttP[ CSpREFIX - 1 + idc ] = sttd ;
            if( idc < csP ) psttP[ CSpREFIX + idc ] = S1C('-') ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020cc.etherc.strrulerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020cd.etherc.strcomparef BEGIN
#define DDNAME       "3func.360020cd.etherc.strcomparef"
#define DDNUMB      (countT)0x360020cd
#define IDFILE      (countT)0xcf1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strCompareF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300ea.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.5030104.1.1.0.html\"\>5030104:  WAKEsHOW( "example.simplest.func.10300ea.etherC.strCompareF" )\</A\>
evaluates to a positive number iff pc1P is "greater than" pc2P
 evaluates to the difference within the first pair of distinct countT objects
 if one of the strings is exhausted without finding a difference, evaluates to the difference in length, in countT objects, of the two strings
arguments
 pc1P
  can be 0
   evaluates to "less than" a string that exists
 pc2P
  can be 0
   evaluates to "less than" a string that exists
 ccP
  can be 0
   if 0 then pc1P and pc2P are assumed to point to null terminated strings of countT objects
   if not 0 then pc1P and pc2P are assumed to each point to ccP countT objects
 bReverseP
  if 0 then compares from left to right, from low address to high address
  if 1 then compares from right to left, from high address to low address
   in this case, ccP must not be 0
   use bReverseP == 1 to compare, for example, 128-bit numeric values
*/
/**/

/*1*/sCountT etherC::strCompareF( tinS& tinP , const countT* const pc1P , const countT* const pc2P , const countT ccP , const countT ccMaxP , const countT* const pcFilterP , const countT ccFilterP , const boolT bReverseP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __( bReverseP && !ccP ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( sCountT , sgn ) ;_WQ
    if( !pc1P )
    {
        if( pc2P ) sgn = - 1 ;_WQ
    }
    else if( !pc2P ) sgn = 1 ;
    else sgn = third.strCompareF( tinP , pc1P , pc2P , ccP , ccMaxP , pcFilterP , ccFilterP , bReverseP ) ;

    return sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020cd.etherc.strcomparef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ce.etherc.strinsertf BEGIN
#define DDNAME       "3func.360020ce.etherc.strinsertf"
#define DDNUMB      (countT)0x360020ce
#define IDFILE      (countT)0xcf2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strInsertF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300eb.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.0e10104.1.1.0.html\"\>0e10104:  WAKEsHOW( "example.simplest.func.10300eb.etherC.strInsertF" )\</A\>
inserts a substring into a string at position idFirstP
idFirstP will be set to point to the stroke after the inserted substring in the resulting string
this function cannot be used to append
arguments
 psttP
  must not be 0
 idFirstP
  must not be 0
  must not be greater than the length of psttP
 psttSmallP
  must not be 0
  can be 0 length, in which case nothing is done
 csttExtraP
*/
/**//*1*/voidT etherC::strInsertF( tinS& tinP , strokeS*& psttP , countT& idFirstP , const strokeS* psttSmallP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( idFirstP ) ;
        __Z( psttP ) ;
        __Z( psttSmallP ) ;
        if( POOP ) return ;
        __( !psttP->idAdam ) ;
        __( psttP->idAdam < idFirstP ) ;
        if( POOP ) return ;
    }

    _IO_
    if( psttSmallP->idAdam )
    {
        strokeS* psttd = psttP ;
        psttP = 0 ;

        ZE( countT , cso ) ;
        ZE( countT , ceo ) ;
        GETpREFIX( cso , ceo , psttd ) ;
        if( ceo < csttExtraP ) ceo = csttExtraP ;
        const countT csi = psttSmallP->idAdam ;

        newF( tinP , LF , psttP , CSpREFIX + cso + csi + ceo ) ; //CALLER MUST TAG ___( psttP ) ;
        if( psttP )
        {
            SETpREFIX( psttP , cso + csi , ceo ) ;

            {for( countT idc = 1              ; idc < idFirstP       ; idc ++ ) psttP[ CSpREFIX - 1 + idc ] = psttd[ CSpREFIX - 1 + idc ] ;}

            {for( countT idc = idFirstP       ; idc < idFirstP + csi ; idc ++ ) psttP[ CSpREFIX - 1 + idc ] = psttSmallP[ CSpREFIX + idc - idFirstP ] ;}

            {for( countT idc = idFirstP + csi ; idc <=     cso + csi ; idc ++ ) psttP[ CSpREFIX - 1 + idc ] = psttd[ CSpREFIX - 1 + idc - csi ] ;}
        }

        delF( tinP , psttd ) ;

        idFirstP += csi ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ce.etherc.strinsertf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020cf.etherc.strdeletef BEGIN
#define DDNAME       "3func.360020cf.etherc.strdeletef"
#define DDNUMB      (countT)0x360020cf
#define IDFILE      (countT)0xcf3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strDeleteF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300ec.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1e10104.1.1.0.html\"\>1e10104:  WAKEsHOW( "example.simplest.func.10300ec.etherC.strDeleteF" )\</A\>
d eletes a substring from a string
arguments
 psttP
  must not be 0
 idFirstP
  must not be 0
  must not be greater than the length of psttP
  if idLastP is not 0 then must not be greater than idLastP
 idLastP
  can be 0, which implies the length of psttP
  if not 0, then must not be less than idFirstP
  must not be greater than the length of psttP
 csttExtraP
*/
/**//*1*/voidT etherC::strDeleteF( tinS& tinP , strokeS* const psttP , const countT idFirstP , const countT idLastP )/*1*/
{
    SCOOP
    const countT idLathI = idLastP ? idLastP : ( psttP ? psttP->idAdam : 0 ) ;

    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        __Z( idFirstP ) ;
        __( idLathI < idFirstP ) ;
        if( POOP ) return ;
        __( !psttP->idAdam ) ;
        __( psttP->idAdam < idLathI ) ;
        if( POOP ) return ;
    }

    _IO_

    countT csd = idLathI - idFirstP + 1 ;

    ZE( countT , cso ) ;
    ZE( countT , ceo ) ;
    GETpREFIX( cso , ceo , psttP ) ;
    SETpREFIX( psttP , cso - csd , ceo + csd ) ;

    for( countT idc = idLathI + 1 ; idc <= cso ; idc ++ ) psttP[ CSpREFIX - 1 + idc - csd ] = psttP[ CSpREFIX - 1 + idc ] ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020cf.etherc.strdeletef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d0.etherc.strtourlf BEGIN
#define DDNAME       "3func.360020d0.etherc.strtourlf"
#define DDNUMB      (countT)0x360020d0
#define IDFILE      (countT)0xcf4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strToUrlF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300ee.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
encodes a url, typically one that contains a query
 urls that contain queries typically are encoded
  each blank is represented by a "+"
  each non-alphanumeric is represented by a %xx
   xx denotes two hexadecimal digits
this function replaces occurances of " " with "+"
it replaces non-alphanumerics with "%xx"
psttOldP can be 0
arguments
 psttP
 psttOldP
*/
/**/

/*1*/voidT etherC::strToUrlF( tinS& tinP , strokeS*& psttP , const strokeS* const psttOldP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        if( psttOldP )
        {
            strFuseF( tinP , psttP , psttOldP ) ; ___( psttP ) ;
        }
        __Z( psttP ) ;
        FV(flSTRtOuRL,flagsP) ;
        if( POOP ) return ;
    }

    _IO_

    // REPLACE NON-ALPHANUMERICS WITH %HH SYMBOLS
    for( countT vv = 1 ; vv <= 255 ; vv ++ )
    {
        if
        (
            ( vv >= 'a' && vv <= 'z'                          ) ||
            ( vv >= 'A' && vv <= 'Z'                          ) ||
            ( vv >= '0' && vv <= '9'                          ) ||
            ( vv == '%'                                       ) ||
            ( vv == ' ' && F(flagsP) & flSTRtOuRL_USEpLUSsiGN )
        )
        continue ;

        const osTextT postx[] = { (osTextT)vv , 0 } ;
        TN( tOld , postx ) ;

        textC tNew = T("%")+TF3(vv,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObIGITvALUES,2) ; //U: THIS MIGHT NEED TO BE UPPER CASE FOR SOME CLIENTS

        strReplaceF( tinP , psttP , 0 , tOld , tNew ) ; ___( psttP ) ;
    }

    if( F(flagsP) & flSTRtOuRL_USEpLUSsiGN )strReplaceF( tinP , psttP , 0 , T(" ") , T("+") ) ; // CALLER MUST TAG
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d0.etherc.strtourlf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d1.etherc.ifcputhostlogentryf BEGIN
#define DDNAME       "3func.360020d1.etherc.ifcputhostlogentryf"
#define DDNUMB      (countT)0x360020d1
#define IDFILE      (countT)0xcf5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcPutHostLogEntryF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300ef.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.af20104.1.1.0.html\"\>af20104:  WAKEsHOW( "example.simplest.func.10300ef.etherC.ifcPutHostLogEntryF" )\</A\>
arguments
 psttReplyP
  must be 0
 psttP
  must not be 0
*/
/**/

/*1*/voidT etherC::ifcPutHostLogEntryF( tinS& tinP , strokeS*& psttReplyP , const strokeS* const psttP )/*1*/
{
    SCOOP
IFbEcAREFUL
{
        if( POOP ) return ;
        __NZ( psttReplyP ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
}

    _IO_

    ZE( strokeS* , pstte ) ;
    strToUrlF( tinP , pstte , psttP ) ; ___( pstte ) ;    

    ZE( osTextT* , posti ) ;
    ZE( countT   , costi ) ;
    boxGetShadowF( tinP , posti , costi , T("www.ideafarm.com//http////ideafarm/ephemeral/domains/com/ideafarm/dynamic/host.log.html?entry=")+T(pstte) ) ; ___( posti ) ;
    delF( tinP , pstte ) ;
    strMakeF( tinP , LF , psttReplyP , T(posti) ) ; ___( psttReplyP ) ;
    delF( tinP , posti ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d1.etherc.ifcputhostlogentryf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d2.etherc.ifcputhostlogentryf BEGIN
#define DDNAME       "3func.360020d2.etherc.ifcputhostlogentryf"
#define DDNUMB      (countT)0x360020d2
#define IDFILE      (countT)0xcf6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcPutHostLogEntryF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300f0.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.bf20104.1.1.0.html\"\>bf20104:  WAKEsHOW( "example.simplest.func.10300f0.etherC.ifcPutHostLogEntryF" )\</A\>
arguments
 psttP
  must not be 0
*/
/**/

/*1*/voidT etherC::ifcPutHostLogEntryF( tinS& tinP , const strokeS* const psttP )/*1*/
{
    SCOOP
IFbEcAREFUL
{
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
}

    _IO_

    ZE( strokeS* , psttnu ) ;
    ifcPutHostLogEntryF( tinP , psttnu , psttP ) ;
    delF( tinP , psttnu ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d2.etherc.ifcputhostlogentryf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d3.etherc.strdigitstoscountf BEGIN
#define DDNAME       "3func.360020d3.etherc.strdigitstoscountf"
#define DDNUMB      (countT)0x360020d3
#define IDFILE      (countT)0xcf7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strDigitsToSCountF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300f1.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.2e10104.1.1.0.html\"\>2e10104:  WAKEsHOW( "example.simplest.func.10300f1.etherC.strDigitsToSCountF" )\</A\>
the number can contain leading blanks
the negative sign must be the first nonblank character
the plus sign is legal
an explicit radix overrides defaultRadixP
 a radix can be specified by appending an underscore "_" followed by a single radix 64 digit [0..9 a..z A..Z ? @]
 "0"       is the value 0
 "10"      is the radix 16_9 value 10
 "89abcde" is the radix 16_9 value 89abcde
 "-efef_f" is the radix 16_9 (hex) value -efef
 "-yzyz_z" is the radix 36_9 value -yzyz
 "-EFEF_F" is the radix 42_9 value -EFEF
 "-YZ?@_@" is the radix 64_9 value -YZYZ
the radix override value is always expressed in radix 64_9 (the digits are 0..9 a..z A..Z ? @)
conversion terminates with the first nonnumeric stroke
 if there is no radix override, terminates with the first stroke that is not a value radix 16_9 digit
 if there is a radix override but it is invalid (not a radix 64_9 digit) then impotence occurs
 if there is a valid radix override, terminates with the radix override
overflow is not detected
after an overflow, the resulting sign will still be correct
there is no limit to the number of digits that can be stored in valueP
do not use this overload if it is known that the value will fit into an sCountT object
 sCountC objects use significantly more computation resources
arguments
 valueP
  must be 0
 psttP
 defaultRadixP
  can be 0, which implies radix 16_9
  if nonze, must be at least 2 and not more than 64_9
 bForeignP
  can be 0 or 1
  0: IdeaFarm (tm) City digit ordering (least significant digit occurs first (i.e. at left)
  1: Foreign digit ordering (most significant digit occurs first (i.e. at left)
U::EDIT TO SUPPORT sc_cALPHABET1
*/
/**/

/*1*/voidT etherC::strDigitsToSCountF( tinS& tinP , sCountC& valueP , const strokeS* const psttP , const countT defaultRadixP , const boolT bForeignP )/*1*/
{
    SCOOP
    countT radix = defaultRadixP ;_WQ

    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( valueP != sCountC( tinP , *this ) ) ;_WQ
        if( !radix ) radix = 0x10 ;_WQ
        __Z( psttP ) ;_WQ
        __( radix < 2 ) ;_WQ
        __( radix > 64 ) ;_WQ
        if( POOP ) return ;
        __( psttP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return ;
    }

    //U: OPTIMIZE TO ELIMINATE USE OF strReverseF BY REWRITING THIS FUNCTION
    // NOTE: THIS FUNCTION WAS CODED ASSUMING FOREIGN DIGIT ORDERING.  AFTER THE CODE WAS COMPLETED, IT WAS DECIDED TO ORDER DIGITS IN INCREASING SIGNIFICANCE WITHIN IFC

    _IO_

    //U: OPTIMIZE BY MAKING THESE STATIC
    const strokeS stt_0( '0' ) ;_WQ
    const strokeS stt_1( '1' ) ;_WQ
    const strokeS stt_9( '9' ) ;_WQ
    const strokeS stt_a( 'a' ) ;_WQ
    const strokeS stt_z( 'z' ) ;_WQ
    const strokeS stt_A( 'A' ) ;_WQ
    const strokeS stt_Z( 'Z' ) ;_WQ
    const strokeS stt_bl( ' ' ) ;_WQ
    const strokeS stt_qu( '?' ) ;_WQ
    const strokeS stt_at( '@' ) ;_WQ
    const strokeS stt_mi( '-' ) ;_WQ
    const strokeS stt_pl( '+' ) ;_WQ
    const strokeS stt_un( '_' ) ;_WQ

    ZE( strokeS* , psttd ) ;_WQ
    strMakeF( tinP , LF , psttd , psttP ) ; ___( psttd ) ;_WQ
    if( !bForeignP ) { strReverseF( tinP , psttd ) ; ___( psttd ) ; }

    //GET SIGN AND RADIX OVERRIDE
    strokeS* psttc = psttd ;_WQ
    ZE( countT , cc ) ;_WQ
    ZE( boolT , fNeg ) ;_WQ
    if( !POOP )
    {
        const strokeS* psttPrefix = psttc ;_WQ
        countT cs = psttPrefix->idAdam ;_WQ
        psttc += CSpREFIX ;_WQ
        while( *psttc == stt_bl ) psttc ++ ;_WQ
        fNeg = *psttc == stt_mi ;_WQ
        if( fNeg || *psttc == stt_pl ) psttc ++ ;_WQ
        cc = cs - ( psttc - psttPrefix - CSpREFIX ) ;_WQ

        {
            for( countT off = 1 ; off < cc ; off ++ )
            {
                if( psttc[ off - 1 ] == stt_un )
                {
                         if( psttc[ off ] >= stt_1  && psttc[ off ] <= stt_9  ) radix = (countT)psttc[ off ] - '0' +  1 ;
                    else if( psttc[ off ] >= stt_a  && psttc[ off ] <= stt_z  ) radix = (countT)psttc[ off ] - 'a' + 11 ;
                    else if( psttc[ off ] >= stt_A  && psttc[ off ] <= stt_Z  ) radix = (countT)psttc[ off ] - 'A' + 37 ;
                    else if( psttc[ off ] >= stt_qu && psttc[ off ] <= stt_at ) radix = (countT)psttc[ off ] - '?' + 63 ;
                    else { __( !!psttc[ off ] ) ; __1 }
                    break ;
                }
                if( psttc[ off ] == stt_bl ) break ;
            }
        }
    }

    //GET ABSOLUTE VALUE
    for( countT off = 0 ; !POOP && off < cc ; off ++ )
    {
        boolT bOk = 1 ;_WQ
        ZE( sCountT , cDelta ) ;_WQ
        {
                 if( psttc[ off ] >= stt_0  && psttc[ off ] <= stt_9  && (countT)psttc[ off ] - '0'      < radix ) cDelta = (countT)psttc[ off ] - '0' ;
            else if( psttc[ off ] >= stt_a  && psttc[ off ] <= stt_z  && (countT)psttc[ off ] - 'a' + 10 < radix ) cDelta = (countT)psttc[ off ] - 'a' + 10 ;
            else if( psttc[ off ] >= stt_A  && psttc[ off ] <= stt_Z  && (countT)psttc[ off ] - 'A' + 36 < radix ) cDelta = (countT)psttc[ off ] - 'A' + 36 ;
            else if( psttc[ off ] >= stt_qu && psttc[ off ] <= stt_at && (countT)psttc[ off ] - '?' + 62 < radix ) cDelta = (countT)psttc[ off ] - '?' + 62 ;
            else                                                                                                   bOk = 0 ;
        }

        if( bOk )
        {
            valueP *= sCountC( tinP , *this , radix ) ;_WQ
            valueP += sCountC( tinP , *this , cDelta ) ;_WQ
        }
        else break ;
    }

    if( fNeg ) valueP *= sCountC( tinP , *this , - 1 ) ;_WQ

    delF( tinP , psttd ) ;_WQ
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d3.etherc.strdigitstoscountf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d4.etherc.strfromf BEGIN
#define DDNAME       "3func.360020d4.etherc.strfromf"
#define DDNUMB      (countT)0x360020d4
#define IDFILE      (countT)0xcf8

//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFromF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030058.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.2910104.1.1.0.html\"\>2910104:  WAKEsHOW( "example.simplest.func.1030058.etherC.strFromF" )\</A\>
arguments
 psttP
  will be set to contain the string
 valueP
  this is the value that is to be represented as a string of digits
 flagsFormatP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001004c.flFORMAT!||
 csP
  minimum length of the final string
  if more strokes are needed to represent the number, psttP will be longer than csP
  -1 : special value that results in a string long enough to represent the maximum value of valueP, the latter depending upon whether flFORMAT_UNSIGNED is set
 radixP
  can be 0
  if 0 then 16_9 is implied
  if not 0 and  !tinP.strokeMode.idCasteDefault then must be 2 <= radixP <= 64_9
  if not 0 and !!tinP.strokeMode.idCasteDefault then must be 2 <= radixP <= 65536_9 (00001)
  example: value 2 produces binary
   this function should have been written to use value 1 for binary, i.e. to require radixP to specify the maximum value representable by a single bigit
   this would conform to the convention used for explicit radix indicators in the rendered text
   but this function was written before i thought of that, so it requires the caller to specify radixP using the foreign convention
   U:: migrate this function and all calling code to make it conform to the ifc convention for indicating radix
    the ifc convention for indicating radix is to use the symbol for the maximum value representable by a single bigit using that radix
     example: binary: radix 1
     example: hexadecimal: radix f
 csttExtraP
*/
/**/

/*1*/voidT etherC::strFromF( tinS& tinP , strokeS*& psttP , const sCountC& valueP , const flagsT flagsFormatP , const countT csP , const countT radixP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;_WQ
        __( radixP && radixP < 2 ) ;_WQ
        __( !tinP.strokeMode.idCasteDefault && radixP > 64 ) ;_WQ
        __(  tinP.strokeMode.idCasteDefault && radixP > 0x10000 ) ;_WQ
        if( POOP ) return ;
    }

    static countT idInLath ;_WQ
    countT idIn = 1 + incv02AM( idInLath ) ;_WQ
    if( idIn == 0x1f )
    {
        countT foo = 2 ;_WQ
    }

    _IO_
    if( F(flagsFormatP) & flFORMAT_CITIZENnAME )
    {
        TN( tSuffix , "'O Ideafarm" ) ;_WQ
        strFromF( tinP , psttP , valueP , flFORMAT_DIGITnAMES | flFORMAT_UNSIGNED , 0 , 0 , tSuffix.csF( tinP ) + csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;_WQ
        strFuseF( tinP , psttP , tSuffix ) ; ___( psttP ) ;_WQ
    }
    else if( F(flagsFormatP) & flFORMAT_CITIZENeMAIL )
    {
        TN( tSuffix , "@" "ideafarm.com" ) ;_WQ
        strFromF( tinP , psttP , valueP , flFORMAT_UNSIGNED , 0 , 0 , tSuffix.csF( tinP ) + csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;_WQ
        strFuseF( tinP , psttP , tSuffix ) ; ___( psttP ) ;_WQ
    }
    else if( F(flagsFormatP) & flFORMAT_DOTTEDdECIMAL )
    {
        countT vv = valueP ;_WQ
        countT v1 = vv & 0xff ; vv >>= 8 ;_WQ
        countT v2 = vv & 0xff ; vv >>= 8 ;_WQ
        countT v3 = vv & 0xff ; vv >>= 8 ;_WQ
        countT v4 = vv & 0xff ; vv >>= 8 ;_WQ
        TN( tDot , "." ) ;_WQ
        flagsT flags = flFORMAT_NObIGITvALUES | flFORMAT_UNSIGNED | flFORMAT_FOREIGN | flFORMAT_NObASE ;_WQ
        strMakeF( tinP , LF , psttP , TF4(v4,flags,0,0xa)+tDot+TF4(v3,flags,0,0xa)+tDot+TF4(v2,flags,0,0xa)+tDot+TF4(v1,flags,0,0xa) ) ; // CALLER MUST TAG ___( psttP ) ;_WQ
    }
    else
    {
        sCountC bigZe( tinP , *this , 0 ) ;

        //U: OPTIMIZE: ELIMINATE THE USE OF strReverseF BY REWRITING THIS FUNCTION

        //IF RADIX IS NOT 16 THEN AN EXPLICIT RADIX INDICATOR WILL BE INCLUDED (E.G.: "12345_9" INDICATES 12345 BASE 10)
        countT radix = radixP ;_WQ
        if( !radix ) radix = 16 ;_WQ

        ZE( boolT , bPrependedSign ) ;_WQ
        {
            boolT bNeedSign = ( valueP < bigZe && !( F(flagsFormatP) & flFORMAT_UNSIGNED ) ) || ( F(flagsFormatP) & flFORMAT_SHOWpLUS ) ;_WQ
            boolT bSignCols = F(flagsFormatP) & flFORMAT_SIGNcOLlEFT || F(flagsFormatP) & flFORMAT_SIGNcOLrIGHT ;_WQ
            bPrependedSign = bNeedSign && !bSignCols ;_WQ
        }

        strokeS sttSign ;_WQ
        {
                 if( valueP < bigZe && !( F(flagsFormatP) & flFORMAT_UNSIGNED ) ) sttSign = S1C('-') ;
            else if( F(flagsFormatP) & flFORMAT_SHOWpLUS )                    sttSign = S1C('+') ;
            else                                                              sttSign = S1C(' ') ;
        }

        const boolT bRadixIndicator = radix != 16 && !( F(flagsFormatP) & flFORMAT_NObASE ) ;_WQ

        const boolT bForeign       = !tinP.strokeMode.idCasteDefault ;_WQ
        const boolT bNoBigitValues = F(flagsFormatP) & flFORMAT_NObIGITvALUES /* || !thirdC::p WinRootIF() */ ;_WQ

        ZE( countT , cdBits ) ; //"cDigitBits": 0-BASED: 0 MEANS 1 BIT; f MEANS 01 BITS
        {
            countT rr = 2 ;_WQ
            while( rr < radix )
            {
                cdBits ++ ;_WQ
                rr <<= 1 ;_WQ
            }
        }

        ZE( strokeS* , psttBigits ) ; // PREPENDED SIGN, DIGITS.  WILL -NOT- CONTAIN: SIGN COLUMNS, RADIX INDICATOR
        {
            ZE( countT , cBigitsMax ) ;_WQ
            {
                sCountC value( valueP ) ;

                while( value > SC || *(sCountT*)value )
                {
                    cBigitsMax ++ ;_WQ
                    value /= radix ;_WQ
                }

                if( !cBigitsMax ) cBigitsMax = 1 ;
                countT cstta = cBigitsMax + bPrependedSign ;_WQ
                if( csP != - 1 && cstta < csP ) cstta = csP ;_WQ
                strMakeF( tinP , LF , psttBigits , 0 , cstta ) ; ___( psttBigits ) ;_WQ
            }

            strokeS s0 = bForeign || bNoBigitValues ? S1C( '0' ) : S2( sscDIGIT | SDBITS( cdBits ) , sc_cALPHABET1 ) ;_WQ
            if( !( valueP > SC || *(sCountT*)*(sCountC*)&valueP ) ) { strFuseF( tinP , psttBigits , s0 ) ; ___( psttBigits ) ; }
            else
            {
                sCountC value( valueP ) ;

                if( !( F(flagsFormatP) & flFORMAT_UNSIGNED ) && valueP < bigZe ) value = - valueP ;
                else                                                             value =   valueP ;

                while( value > SC || *(sCountT*)*(sCountC*)&value )
                {
                    countT digit = value % (sCountT)radix ;_WQ
                    value /= radix ;_WQ
                    strokeS stt = ' ' ;_WQ

                    if( !bForeign && !bNoBigitValues ) stt = S1C(sscDIGIT|SDBITS(cdBits)|digit) ;
                    else
                    {
                             if( digit < 10 ) stt = '0' + digit ;
                        else if( digit < 36 ) stt = 'a' + digit - 10 ;
                        else if( digit < 62 ) stt = 'A' + digit - 36 ;
                        else                  stt = '?' + digit - 62 ;
                    }

                    strFuseF( tinP , psttBigits , stt , 0 , 1 ) ; ___( psttBigits ) ;_WQ
                }
            }

            strokeS sttFill = S1C(' ') ;_WQ
                 if( F(flagsFormatP) & flFORMAT_FILLzE   ) sttFill = s0      ;
            else if( F(flagsFormatP) & flFORMAT_FILLsIGN ) sttFill = sttSign ;

            if( bPrependedSign && sttFill != s0 ) { strFuseF( tinP , psttBigits , sttSign , 0 , 1 ) ; ___( psttBigits ) ; }

            if( csP )
            {
                countT csr = csP == - 1                     // THIS IS NEWLY ADDED WITHOUT MODIFYING THE CALCULATION OF csd ; I AM NOT SURE WHETHER THE RESULTING csd VALUE IS WHAT I WANT FOR ALL POSSIBLE COMBINATIONS OF FLAGS
                    ? cBigitsMax + bPrependedSign
                    : csP
                ;_WQ

                countT csd = csr /*- 2 * bRadixIndicator*/ ; // "-2 * bRadixIndicator" REMOVED TO MAKE csP == -1 WORK FOR radixP 0x24
                if( csP != - 1 )
                {
                    if( F(flagsFormatP) & flFORMAT_SIGNcOLlEFT  ) csd -- ;_WQ
                    if( F(flagsFormatP) & flFORMAT_SIGNcOLrIGHT ) csd -- ;_WQ
                    if( bPrependedSign && sttFill == s0         ) csd -- ;_WQ
                }

                if( psttBigits && psttBigits->idAdam < csd ) { strResizeF( tinP , psttBigits , csd , sttFill , 1 , 1 ) ; ___( psttBigits ) ; }
            }

            if( bPrependedSign && sttFill == s0 ) { strFuseF( tinP , psttBigits , sttSign , 0 , 1 ) ; ___( psttBigits ) ; }

            __Z( psttBigits ) ;_WQ
        }

        if( psttBigits ) { strMakeF( tinP , LF , psttP , T("") , psttBigits->idAdam + 4 + csttExtraP ) ; }

        if( F(flagsFormatP) & flFORMAT_SIGNcOLlEFT ) strFuseF( tinP , psttP , sttSign , 4 + csttExtraP ) ;_WQ

        strFuseF( tinP , psttP , psttBigits , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ 4 + csttExtraP ) ;_WQ
        delF( tinP , psttBigits ) ;_WQ

        if( bRadixIndicator )
        {
            strokeS psttBuf[ CSpREFIX + 2 ] ;_WQ
            SETpREFIX( psttBuf , 2 , 0 ) ;_WQ
            psttBuf[ CSpREFIX     ] = '_' ;_WQ
            psttBuf[ CSpREFIX + 1 ] = 0 ;_WQ

            if( !bForeign && !bNoBigitValues ) psttBuf[ CSpREFIX + 1 ] = S1C(sscDIGIT|SDBITS(cdBits)|radix-1) ;
            else
            {
                     if( radix <= 10 ) psttBuf[ CSpREFIX + 1 ] = S1C( '0' -  1 + radix      ) ;
                else if( radix <= 36 ) psttBuf[ CSpREFIX + 1 ] = S1C( 'a' -  1 + radix - 10 ) ;
                else if( radix <= 62 ) psttBuf[ CSpREFIX + 1 ] = S1C( 'A' -  1 + radix - 36 ) ;
                else                   psttBuf[ CSpREFIX + 1 ] = S1C( '?' -  1 + radix - 62 ) ;
            }

            strFuseF( tinP , psttP , psttBuf ) ; ___( psttP ) ;_WQ
        }

        if(    F(flagsFormatP) & flFORMAT_SIGNcOLrIGHT   ) {                strFuseF(    tinP , psttP , sttSign                                                 ) ; }
        if( !( F(flagsFormatP) & flFORMAT_FOREIGN      ) ) { ___( psttP ) ; strReverseF( tinP , psttP                                                           ) ; }
        if(    F(flagsFormatP) & flFORMAT_DIGITnAMES     ) { ___( psttP ) ; strReplaceF( tinP , psttP , 0 , ifcIDtYPEsTRrEPLACE_DIGITStOdIGITnAMES , csttExtraP ) ; }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d4.etherc.strfromf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d5.etherc.newdeltypeether BEGIN
#define DDNAME       "3func.360020d5.etherc.newdeltypeether"
#define DDNUMB      (countT)0x360020d5
#define IDFILE      (countT)0xcf9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.10300f3.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.ef20104.1.1.0.html\"\>ef20104:  WAKEsHOW( "example.simplest.func.10300f3.etherC.NEWdELtYPEeTHER" )\</A\>
example code
 |    ZE( measureT* , pma ) ;
 |    ether.newF( tinP , LF , pma , 8 ) ; ___( pma ) ;
 |    ether.delF( tinP , pma ) ;
*/
/**/

/*1*/NEWdELtYPEeTHER( measureT )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d5.etherc.newdeltypeether END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d6.etherc.ifcnicknamefromidcitizenf BEGIN
#define DDNAME       "3func.360020d6.etherc.ifcnicknamefromidcitizenf"
#define DDNUMB      (countT)0x360020d6
#define IDFILE      (countT)0xcfa


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcNicknameFromIdCitizenF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300f5.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9f20104.1.1.0.html\"\>9f20104:  WAKEsHOW( "example.simplest.func.10300f5.etherC.ifcNicknameFromIdCitizenF" )\</A\>
arguments
 psttP
  must be 0
  after evaluation, will point to the nickname of the specified citizen
 idP
  must not be 0
  this is the idCitizen of the person whose nickname is desired
*/
/**/

/*1*/voidT etherC::ifcNicknameFromIdCitizenF( tinS& tinP , strokeS*& psttP , const countT idP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( idP ) ;
        if( POOP ) return ;
    }

    _IO_

    socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
    sock.connectF( tinP , ifcPORToLD1nICKNAME , socketC::nicNameIF( tinP , *this , T(WWWiDEAFARMcOM) ) ) ;

    countT idCmd = idcNICKNAMEcMD_QUERYnICKfROMiD ;
    sock.writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;

    sock.writeF( tinP , (byteT*)&idP , sizeof idP ) ;

    ZE( countT , cbi ) ;
    sock.readF( tinP , (byteT*)&cbi , sizeof cbi ) ;

    if( !cbi )
    {
        __( idP ) ;
        __1
    }
    else
    {
        ZE( byteT* , pbi ) ;
        newF( tinP , LF , pbi , cbi ) ; ___( pbi ) ;
        sock.readF( tinP , pbi , cbi ) ;

        strokeS* psttn = (strokeS*)pbi ;
        strMakeF( tinP , LF , psttP , psttn ) ;    

        delF( tinP , pbi ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d6.etherc.ifcnicknamefromidcitizenf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d7.etherc.ifcexternalemailfromidcitizenf BEGIN
#define DDNAME       "3func.360020d7.etherc.ifcexternalemailfromidcitizenf"
#define DDNUMB      (countT)0x360020d7
#define IDFILE      (countT)0xcfb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcExternalEmailFromIdCitizenF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300f6.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.cf20104.1.1.0.html\"\>cf20104:  WAKEsHOW( "example.simplest.func.10300f6.etherC.ifcExternalEmailFromIdCitizenF" )\</A\>
arguments
 psttP
  must be 0
  after evaluation, will point to the external email address of the specified citizen
  if no email address is on record, will be 0 and impotence will not occur
 idP
  must not be 0
  this is the idCitizen of the person whose external email is desired
*/
/**/

/*1*/voidT etherC::ifcExternalEmailFromIdCitizenF( tinS& tinP , strokeS*& psttP , const countT idP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( idP ) ;
        if( POOP ) return ;
    }

    _IO_

    socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
    sock.connectF( tinP , ifcPORToLD1nICKNAME , socketC::nicNameIF( tinP , *this , T(WWWiDEAFARMcOM) ) ) ;

    countT idCmd = idcNICKNAMEcMD_QUERYeXTERNALeMAILfROMiD ;
    sock.writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;

    sock.writeF( tinP , (byteT*)&idP , sizeof idP ) ;

    ZE( countT , cbi ) ;
    sock.readF( tinP , (byteT*)&cbi , sizeof cbi ) ;

    if( cbi )
    {
        ZE( byteT* , pbi ) ;
        newF( tinP , LF , pbi , cbi ) ; ___( pbi ) ;
        sock.readF( tinP , pbi , cbi ) ;

        strokeS* psttn = (strokeS*)pbi ;
        strMakeF( tinP , LF , psttP , psttn ) ;    

        delF( tinP , pbi ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d7.etherc.ifcexternalemailfromidcitizenf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d8.etherc.sockpstthostf BEGIN
#define DDNAME       "3func.360020d8.etherc.sockpstthostf"
#define DDNUMB      (countT)0x360020d8
#define IDFILE      (countT)0xcfc


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockPsttHostF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300f7.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.ff20104.1.1.0.html\"\>ff20104:  WAKEsHOW( "example.simplest.func.10300f7.etherC.sockPsttHostF" )\</A\>
obtains the domain name of the specified host (reverse DNS lookup)
if there is no name, psttP will remain 0 and impotence will -not- occur
arguments
 tinP
 psttP
  must be 0
 nicNameP
  can be 0
  if 0 then psttP will contain the domain name of the local host
*/
/**/

/*1*/voidT etherC::sockPsttHostF( tinS& tinP , strokeS*& psttP , const nicNameC nicNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( osTextT* , posth ) ;
    third.s_postHostF( tinP , posth , nicNameP ) ; ___( posth ) ;
    if( posth )
    {
        strMakeF( tinP , LF , psttP , T(posth) ) ; ___( psttP ) ;
        delF( tinP , posth ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d8.etherc.sockpstthostf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d9.etherc.strasciicodetablef BEGIN
#define DDNAME       "3func.360020d9.etherc.strasciicodetablef"
#define DDNUMB      (countT)0x360020d9
#define IDFILE      (countT)0xcfd


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strAsciiCodeTableF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300f8.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1030104.1.1.0.html\"\>1030104:  WAKEsHOW( "example.simplest.func.10300f8.etherC.strAsciiCodeTableF" )\</A\>
appends a nicely formatted table of the ASCII codes to psttP
arguments
 tinP
 psttP
  can be 0
  if not 0, must have enough extra strokes to hold the entire table
*/
/**/

/*1*/voidT etherC::strAsciiCodeTableF( tinS& tinP , strokeS*& psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    if( !psttP )
    {
        strMakeF( tinP , LF , psttP , T("") , 0x56f ) ; // CALLER MUST TAG ___( psttP ) ;
    }

    for( countT ii = 0 ; ii <= 0xff ; ii ++ )
    {
        countT idr = 1 + ii / 0x10 ;
        countT idc = 1 + ii % 0x10 ;

        if( idr == 1 && idc == 1 ) { strFuseF( tinP , psttP , T(" ____________________________________________________\r\n|   |                                                  |\r\n|   |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  |\r\n|___|__________________________________________________|\r\n|   |                                                  |\r\n|   |                                                  |\r\n") ) ; ___( psttP ) ; }

        if( idc == 1 ) { strFuseF( tinP , psttP , T("| ")+TF1(idr-1)+T(" |  ") ) ; ___( psttP ) ; }

        switch( ii )
        {
            case 0x0 :
            case 0x7 :
            case 0x8 :
            case 0x9 :
            case 0xa :
            case 0xc :
            case 0xd :
            case 0xf : { strFuseF( tinP , psttP , S1C(' ') ) ; ___( psttP ) ; break ; }
            default  : { strFuseF( tinP , psttP , S1C(ii)  ) ; ___( psttP ) ; break ; }
        }

        if( ii % 0x10 == 0xf ) { strFuseF( tinP , psttP , T("  |\r\n") ) ; ___( psttP ) ; }
        else                   { strFuseF( tinP , psttP , T("  ")      ) ; ___( psttP ) ; }
    }

    strFuseF( tinP , psttP , T("|   |                                                  |\r\n|___|__________________________________________________|\r\n") ) ; ___( psttP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020d9.etherc.strasciicodetablef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020da.etherc.strfromf BEGIN
#define DDNAME       "3func.360020da.etherc.strfromf"
#define DDNUMB      (countT)0x360020da
#define IDFILE      (countT)0xcfe


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFromF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300f9.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6030104.1.1.0.html\"\>6030104:  WAKEsHOW( "example.simplest.func.10300f9.etherC.strFromF" )\</A\>
this function never does rounding
it always renders the exact value stored in the measureT object valueP
if you want rounding, you must do it explicitly, in code, to valueP, before calling me
arguments
 tinP
 psttP
  will be set to contain the string
 valueP
  this is the value that is to be represented as a string of bigits
 flagsFormatP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001004c.flFORMAT!||
 csP
  can be 0
  pad if necessary to this length
  the resulting string can be longer but will never be shorter than csP strokes
 idcPointP
  use this to align radix points vertically in a column of numbers
  can be 0
  if not 0, then is the minimum position for the radix point
  if more strokes are needed to represent the integer part, the radix point will be at a position greater than idcPointP
 cPrecisionP
  this is the minimum number of fractional digits that is to appear
  if more digits are required to fully represent the fractional part, the fractional part will be longer than cPrecisionP
  U::edit to truncate to cPrecisionP fractional bigits
  can be 0
  if 0 and the fractional part is 0 , the radix point and fractional part will not appear
  use this to set the precision desired for the fractional part
 radixP
  can be 0
  if 0 then 16_9 is implied
  if not 0 then must be 2, 4, 8, 0x10 , 0x20, or 0x40 (2_, 4_, 8_, 16_, 32_, 64_)
 csttExtraP
*/
/**/

/*1*/voidT etherC::strFromF( tinS& tinP , strokeS*& psttP , const measureT valueP , const flagsT flagsFormatP , const countT csP , const countT idcPointP , const countT cPrecisionP , const countT radixP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;_WQ
        __( radixP && radixP < 2 ) ;_WQ
        __( !tinP.strokeMode.idCasteDefault && radixP > 64 ) ;_WQ
        __(  tinP.strokeMode.idCasteDefault && radixP > 0x10000 ) ;_WQ
        __( radixP && !cbpdF( radixP ) ) ;_WQ
        { countT cb = 4 ; __( sizeof valueP - cb ) ; }
        if( POOP ) return ;
    }

    const flagsT flFormatDigit = F(flagsFormatP) & flFORMAT_NObIGITvALUES ?  flFORMAT_NObASE | flFORMAT_NObIGITvALUES : flFORMAT_NObASE ;_WQ
    //U: OPTIMIZE TO ELIMINATE USE OF strReverseF BY REWRITING THIS FUNCTION

    //IF RADIX IS NOT 16 THEN AN EXPLICIT RADIX INDICATOR WILL BE INCLUDED (E.G.: "12345_7" INDICATES 12345 BASE 8)
    _IO_
    countT radix = radixP ;_WQ
    if( !radix ) radix = 16 ;_WQ

    ZE( boolT , bPrependedSign ) ;_WQ
    {
        boolT bNeedSign = ( valueP < 0 && !( F(flagsFormatP) & flFORMAT_UNSIGNED ) ) || ( F(flagsFormatP) & flFORMAT_SHOWpLUS ) ;_WQ
        boolT bSignCols = F(flagsFormatP) & flFORMAT_SIGNcOLlEFT || F(flagsFormatP) & flFORMAT_SIGNcOLrIGHT ;_WQ
        bPrependedSign = bNeedSign && !bSignCols ;_WQ
    }

    strokeS sttSign ;_WQ
    {
             if( valueP < 0 && !( F(flagsFormatP) & flFORMAT_UNSIGNED ) ) sttSign = S1C('-') ;
        else if( F(flagsFormatP) & flFORMAT_SHOWpLUS )                    sttSign = S1C('+') ;
        else                                                           sttSign = S1C(' ') ;
    }

    const boolT bRadixIndicator = radix != 16 && !( F(flagsFormatP) & flFORMAT_NObASE ) ;_WQ

    ZE( strokeS* , psttDigits ) ; // PREPENDED SIGN, DIGITS.  WILL -NOT- CONTAIN: SIGN COLUMNS, RADIX INDICATOR
    {
        strMakeF( tinP , LF , psttDigits , T("") , 0x100 ) ; ___( psttDigits ) ; // MUST ACCOUNT FOR, IN BINARY, MAXIMUM IMPLICIT DIGITS PLUS ALL STORED DIGITS PLUS FORMATTING STROKES

        {
            countT image = *(countT*)&valueP ;_WQ

            const countT cbpd = cbpdF( radix ) ;_WQ
            boolT  bNeg     = image & 0x80000000 ;_WQ
            countT exponent = ( image >> 0x17 ) & 0xff ;_WQ
            countT fraction = image  & 0x7fffff ;_WQ
                 if( !exponent && !fraction ) exponent = 0x7f ;
            else if( !exponent              ) exponent = 1 ;
            else                              fraction |= 0x800000 ;
            // NOW fraction USES 24_9 BITS AND exponent IS GUARANTEED TO BE NONZE

            if( F(flagsFormatP) & flFORMAT_EXPONENT )
            {
                // NORMALIZE EXPONENT SO THAT IT IS A MULTIPLE OF THE NUMBER OF BITS PER DIGIT
                {
                    countT cOdd = ( exponent - 0x7e ) % cbpd ;_WQ
                    if( cOdd )
                    {
                        exponent  += cbpd - cOdd ;_WQ
                        fraction >>= cbpd - cOdd ;_WQ
                    }
                }

                sCountT shiftRight = 0x7e - exponent ;_WQ
                sCountT shiftLeft  = - shiftRight ;_WQ

                ZE( boolT , bFirstFractionalDigitDone ) ;_WQ
                strFuseF( tinP , psttDigits , T(".") ) ; ___( psttDigits ) ;_WQ

                countT cbfRemaining = 0x18 ;_WQ
                while( cbfRemaining >= cbpd )
                {
                    ZE( countT , digit ) ;_WQ
                    highDigitF( tinP , *this , digit , fraction , radix , cbpd ) ;_WQ
                    strFuseF( tinP , psttDigits , TF4(digit,flFormatDigit,0,radix) ) ; ___( psttDigits ) ;_WQ
                    cbfRemaining -= cbpd ;_WQ
                    if( !bFirstFractionalDigitDone ) bFirstFractionalDigitDone = 1 ;_WQ
                    if( bFirstFractionalDigitDone && !fraction ) break ;
                }

                if( cbfRemaining && ( !bFirstFractionalDigitDone || fraction ) )
                {
                    ZE( countT , digit ) ;_WQ
                    highDigitF( tinP , *this , digit , fraction , radix , cbfRemaining , 1 ) ;_WQ
                    strFuseF( tinP , psttDigits , TF4(digit,flFormatDigit,0,radix) ) ; ___( psttDigits ) ;_WQ
                    if( !bFirstFractionalDigitDone ) bFirstFractionalDigitDone = 1 ;_WQ
                }

                if( cPrecisionP && psttDigits )
                {
                    countT idcPoint = strIdF( tinP , S1C('.') , psttDigits ) ;_WQ
                    countT cPrecisionOld = psttDigits->idAdam - idcPoint ;_WQ
                    sCountT scPad = cPrecisionP - cPrecisionOld ;_WQ
                    if( scPad > 0 ) { strResizeF( tinP , psttDigits , scPad + psttDigits->idAdam , S1C('0') , 0 , 6 ) ; ___( psttDigits ) ; }
                }

                strFuseF( tinP , psttDigits , T("^")+TF4(shiftLeft/(sCountT)cbpd,flFormatDigit|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_SHOWpLUS,4,radix) ) ; ___( psttDigits ) ;_WQ
            }
            else
            {
                sCountT shiftRight = 0x7e - exponent ;_WQ
                sCountT shiftLeft  = - shiftRight ;_WQ

                ZE( boolT , bFirstFractionalDigitDone ) ;_WQ
                if( shiftRight >= 0 ) // THERE IS NO INTEGER PART
                {
                    strFuseF( tinP , psttDigits , T("0.") ) ; ___( psttDigits ) ;_WQ

                    while( shiftRight >= cbpd )
                    {
                        shiftRight -= cbpd ;_WQ
                        strFuseF( tinP , psttDigits , T("0") ) ; ___( psttDigits ) ;_WQ
                        if( !bFirstFractionalDigitDone ) bFirstFractionalDigitDone = 1 ;_WQ
                        if( bFirstFractionalDigitDone && !fraction ) break ;
                    }

                    if( shiftRight && ( !bFirstFractionalDigitDone || fraction ) )
                    {
                        ZE( countT , digit ) ;_WQ
                        highDigitF( tinP , *this , digit , fraction , radix , cbpd - shiftRight ) ;_WQ
                        strFuseF( tinP , psttDigits , TF4(digit,flFormatDigit,0,radix) ) ; ___( psttDigits ) ;_WQ
                        if( !bFirstFractionalDigitDone ) bFirstFractionalDigitDone = 1 ;_WQ
                    }

                    while( !bFirstFractionalDigitDone || fraction )
                    {
                        ZE( countT , digit ) ;_WQ
                        highDigitF( tinP , *this , digit , fraction , radix , cbpd ) ;_WQ
                        strFuseF( tinP , psttDigits , TF4(digit,flFormatDigit,0,radix) ) ; ___( psttDigits ) ;_WQ
                        if( !bFirstFractionalDigitDone ) bFirstFractionalDigitDone = 1 ;_WQ
                    }
                }
                else
                {
                    countT cbHighestDigit = shiftLeft % cbpd ;_WQ
                    if( cbHighestDigit )
                    {
                        ZE( countT , digit ) ;_WQ
                        highDigitF( tinP , *this , digit , fraction , radix , cbHighestDigit ) ;_WQ
                        strFuseF( tinP , psttDigits , TF4(digit,flFormatDigit,0,radix) ) ; ___( psttDigits ) ;_WQ

                        shiftLeft -= cbHighestDigit ;_WQ
                        if( !shiftLeft ) { strFuseF( tinP , psttDigits , T(".") ) ; ___( psttDigits ) ; }
                    }

                    countT cbfRemaining = 0x18 - cbHighestDigit ;_WQ
                    while( cbfRemaining >= cbpd )
                    {
                        ZE( countT , digit ) ;_WQ
                        highDigitF( tinP , *this , digit , fraction , radix , cbpd ) ;_WQ
                        strFuseF( tinP , psttDigits , TF4(digit,flFormatDigit,0,radix) ) ; ___( psttDigits ) ;_WQ
                        cbfRemaining -= cbpd ;_WQ
                        if( !shiftLeft && !bFirstFractionalDigitDone ) bFirstFractionalDigitDone = 1 ;_WQ

                        shiftLeft -= cbpd ;_WQ
                        if( !shiftLeft ) { strFuseF( tinP , psttDigits , T(".") ) ; ___( psttDigits ) ; }

                        if( bFirstFractionalDigitDone && !fraction ) break ;
                    }

                    if( cbfRemaining && ( !bFirstFractionalDigitDone || fraction ) )
                    {
                        ZE( countT , digit ) ;_WQ
                        highDigitF( tinP , *this , digit , fraction , radix , cbfRemaining , 1 ) ;_WQ
                        strFuseF( tinP , psttDigits , TF4(digit,flFormatDigit,0,radix) ) ; ___( psttDigits ) ;_WQ
                        if( !shiftLeft && !bFirstFractionalDigitDone ) bFirstFractionalDigitDone = 1 ;_WQ

                        shiftLeft -= cbpd ;_WQ
                        if( !shiftLeft ) { strFuseF( tinP , psttDigits , T(".") ) ; ___( psttDigits ) ; }
                    }

                    if( shiftLeft > 0 )
                    {
                        while( shiftLeft > 0 )
                        {
                            shiftLeft -= cbpd ;_WQ
                            strFuseF( tinP , psttDigits , T("0") ) ; ___( psttDigits ) ;_WQ
                        }
                        strFuseF( tinP , psttDigits , T(".0") ) ; ___( psttDigits ) ;_WQ
                    }
                    else if( !bFirstFractionalDigitDone ) { strFuseF( tinP , psttDigits , T("0") ) ; ___( psttDigits ) ; }
                }
            }
        }

        strokeS sttFill = S1C(' ') ;_WQ
             if( F(flagsFormatP) & flFORMAT_FILLzE ) sttFill = S1C('0') ;
        else if( F(flagsFormatP) & flFORMAT_FILLsIGN ) sttFill = sttSign ;

        if( bPrependedSign && sttFill != S1C('0') ) strFuseF( tinP , psttDigits , sttSign , 0 , 1 ) ;_WQ

        if( idcPointP && psttDigits )
        {
            countT idcPointOld = strIdF( tinP , S1C('.') , psttDigits ) ;_WQ
            if( bPrependedSign && sttFill == S1C('0') ) idcPointOld ++ ;_WQ
            sCountT scPad = idcPointP - idcPointOld ;_WQ
            if( scPad > 0 ) { strResizeF( tinP , psttDigits , scPad + psttDigits->idAdam , sttFill , 1 ) ; ___( psttDigits ) ; }
        }

        if( !cPrecisionP )
        {
            countT idf = 1 ;_WQ
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;_WQ
            TN( tz , "." ) ; tz += TF2(0,flFormatDigit) ; //U: DO THIS KIND OF THING WHEREVER NEEDED; (SEE THE WAY THAT ALPHABET1 ENCODES T('0') VS TF1(0))
            countT idcDotZe = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tz , psttDigits ) ;_WQ
            if( psttDigits && idcDotZe == psttDigits->idAdam - 1 )
            {
                strReplaceF( tinP , psttDigits , 0 , tz , T("") ) ; ___( psttDigits ) ;_WQ
            }
            //U::if( psttDigits && idcDotZe == psttDigits->idAdam - 1 ) { strReplaceF( tinP , psttDigits , 0 , tz , T("") ) ; ___( psttDigits ) ; }
        }
        else if( psttDigits )
        {
            countT idcPoint = strIdF( tinP , S1C('.') , psttDigits ) ;_WQ
            countT cPrecisionOld = psttDigits->idAdam - idcPoint ;_WQ
            sCountT scPad = cPrecisionP - cPrecisionOld ;_WQ
            if( scPad > 0 ) { strResizeF( tinP , psttDigits , scPad + psttDigits->idAdam , sttFill ) ; ___( psttDigits ) ; }
        }

        if( bPrependedSign && sttFill == S1C('0') ) strFuseF( tinP , psttDigits , sttSign , 0 , 1 ) ;_WQ

        __Z( psttDigits ) ;_WQ
    }

    if( psttDigits )
    {
        countT cstta = psttDigits->idAdam + 4 ;_WQ
        if( cstta < csP ) cstta = csP ;_WQ
        strMakeF( tinP , LF , psttP , T("") , cstta + csttExtraP ) ; //CALLER MUST TAG ___( psttP ) ;_WQ
    }

    if( F(flagsFormatP) & flFORMAT_SIGNcOLlEFT ) strFuseF( tinP , psttP , sttSign , 4 + csP + csttExtraP ) ;_WQ

    strFuseF( tinP , psttP , psttDigits , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ 4 + csP + csttExtraP ) ; //CALLER MUST TAG ___( psttP ) ;_WQ
    delF( tinP , psttDigits ) ;_WQ

    if( bRadixIndicator )
    {
        strokeS psttBuf[ CSpREFIX + 2 ] ;_WQ
        SETpREFIX( psttBuf , 2 , 0 ) ;_WQ
        psttBuf[ CSpREFIX     ] = '_' ;_WQ
        psttBuf[ CSpREFIX + 1 ] = 0 ;_WQ
             if( radix <= 10 ) psttBuf[ CSpREFIX + 1 ] = S1C( '0' -  1 + radix      ) ;
        else if( radix <= 36 ) psttBuf[ CSpREFIX + 1 ] = S1C( 'a' -  1 + radix - 10 ) ;
        else if( radix <= 62 ) psttBuf[ CSpREFIX + 1 ] = S1C( 'A' -  1 + radix - 36 ) ;
        else                   psttBuf[ CSpREFIX + 1 ] = S1C( '?' -  1 + radix - 62 ) ;
        strFuseF( tinP , psttP , psttBuf ) ; ___( psttP ) ;_WQ
    }

    if( F(flagsFormatP) & flFORMAT_SIGNcOLrIGHT ) strFuseF( tinP , psttP , sttSign ) ;_WQ

    if( !( F(flagsFormatP) & flFORMAT_FOREIGN    ) ) { ___( psttP ) ; strReverseF( tinP , psttP                                              ) ; }
    if(    F(flagsFormatP) & flFORMAT_DIGITnAMES   ) { ___( psttP ) ; strReplaceF( tinP , psttP , 0 , ifcIDtYPEsTRrEPLACE_DIGITStOdIGITnAMES ) ; }

    if( csP && psttP )
    {
        TN( tb , " " ) ;_WQ
        while( psttP->idAdam < csP ) strFuseF( tinP , psttP , tb ) ;_WQ
    }

}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020da.etherc.strfromf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020db.etherc.strfromf BEGIN
#define DDNAME       "3func.360020db.etherc.strfromf"
#define DDNUMB      (countT)0x360020db
#define IDFILE      (countT)0xcff


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFromF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300fa.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7030104.1.1.0.html\"\>7030104:  WAKEsHOW( "example.simplest.func.10300fa.etherC.strFromF" )\</A\>
arguments
 psttP
  will be set to contain the string
 valueP
  this is the value that is to be represented as a string of digits
 flagsFormatP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001004c.flFORMAT!||
 csP
  minimum length of the final string
  if more strokes are needed to represent the number, psttP will be longer than csP
 radixP
  can be 0
  if 0 then 16_9 is implied
  if not 0 then must be 2 <= radixP <= 64_9
 csttExtraP
*/
/**/

/*1*/voidT etherC::strFromF( tinS& tinP , strokeS*& psttP , const countT valueP , const flagsT flagsFormatP , const countT csP , const countT radixP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;_WQ
        __( radixP && radixP < 2 ) ;_WQ
        __( !tinP.strokeMode.idCasteDefault && radixP > 64 ) ;_WQ
        __(  tinP.strokeMode.idCasteDefault && radixP > 0x10000 ) ;_WQ
        { countT cb = 4 ; __( sizeof valueP - cb ) ; }
        if( POOP ) return ;
    }

    _IO_
    strFromF( tinP , psttP , (sCountT)valueP , flagsFormatP | flFORMAT_UNSIGNED , csP , radixP , csttExtraP ) ; // CALLER MUST TAG
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020db.etherc.strfromf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020dc.etherc.strclockoldf BEGIN
#define DDNAME       "3func.360020dc.etherc.strclockoldf"
#define DDNUMB      (countT)0x360020dc
#define IDFILE      (countT)0xd00


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strClockOldF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300fb.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.d130104.1.1.0.html\"\>d130104:  WAKEsHOW( "example.simplest.func.10300fb.etherC.strClockOldF" )\</A\>
appends a nicely formatted clock face, modeling the current time, to psttP
arguments
 tinP
 psttP
  can be 0
  if not 0, must have enough extra strokes to hold the entire table
*/
/**/

/*1*/voidT etherC::strClockOldF( tinS& tinP , strokeS*& psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    if( !psttP )
    {
        strMakeF( tinP , LF , psttP , T("") , 0x56f ) ; //CALLER MUST TAG ___( psttP ) ; } //U: 0x56f --> CORRECT VALUE
    }

    ZE( countT , time1 ) ;
    ZE( sCountT , time2 ) ;
    osTimeNowF( tinP , time1 , time2 ) ;

    countT offDick   = offDICK(   time2 ) ;
    countT offDock   = offDOCK(   time2 ) ;
    countT offDuck   = offDUCK(   time2 ) ;
    countT offDay    = offDAY(    time2 ) ;
    countT offTick   = offTICK(   time1 ) ;
    countT offTock   = offTOCK(   time1 ) ;
    countT offTuck   = offTUCK(   time1 ) ;
    countT offTime   = offTIME(   time1 ) ;
    countT offQtr    = offQTR(    time2 ) ;
    countT offStrong = offSTRONG( time2 ) ;
    countT offHour   = offHOUR(   time1 ) ;

    strFuseF( tinP , psttP ,

        T("dick    ")+TF3(offDick  ,0,2)+T("  ")+TPS("",offDick  /0x10,S1C('-'))+T("*")+TPS("",0xf-(offDick/0x10),S1C('-'))+T("\r\n")+
        T("dock    ")+TF3(offDock  ,0,2)+T("  ")+TPS("",offDock  /0x10,S1C('-'))+T("*")+TPS("",0xf-(offDock/0x10),S1C('-'))+T("\r\n")+
        T("duck    ")+TF3(offDuck  ,0,2)+T("  ")+TPS("",offDuck  /0x10,S1C('-'))+T("*")+TPS("",0xf-(offDuck/0x10),S1C('-'))+T("\r\n")+
        T("day     ")+TF3(offDay   ,0,2)+T("  ")+TPS("",offDay   /0x10,S1C('-'))+T("*")+TPS("",0xf-(offDay /0x10),S1C('-'))+T("\r\n")+
        T("tick    ")+TF3(offTick  ,0,2)+T("  ")+TPS("",offTick  /0x10,S1C('-'))+T("*")+TPS("",0xf-(offTick/0x10),S1C('-'))+T("\r\n")+
        T("tock    ")+TF3(offTock  ,0,2)+T("  ")+TPS("",offTock  /0x10,S1C('-'))+T("*")+TPS("",0xf-(offTock/0x10),S1C('-'))+T("\r\n")+
        T("tuck    ")+TF3(offTuck  ,0,2)+T("  ")+TPS("",offTuck  /0x10,S1C('-'))+T("*")+TPS("",0xf-(offTuck/0x10),S1C('-'))+T("\r\n")+
        T("time    ")+TF3(offTime  ,0,2)+T("  ")+TPS("",offTime  /0x10,S1C('-'))+T("*")+TPS("",0xf-(offTime/0x10),S1C('-'))+T("\r\n")+
        TPS("",0x1c,S1C('_'))+T("\r\n\r\n")

    ) ;

    {
        ZE( countT , cTries ) ;

        strFuseF( tinP , psttP , T("qtr     ")+TF3(offQtr   ,0,2)+T("  ") ) ;
        cTries = offQtr ; while( cTries -- ) { strFuseF( tinP , psttP , T("----") ) ; ___( psttP ) ; }
        strFuseF( tinP , psttP , T("****")+TPS("",0xc-(offQtr*0x04),S1C('-'))+T("\r\n") ) ;

        strFuseF( tinP , psttP , T("strong  ")+TF3(offStrong,0,2)+T("  ") ) ;
        cTries = offStrong ; while( cTries -- ) { strFuseF( tinP , psttP , T("--") ) ; ___( psttP ) ; }
        strFuseF( tinP , psttP , T("**")+TPS("",0xe-(offStrong*0x02),S1C('-'))+T("\r\n") ) ;

        strFuseF( tinP , psttP , T("hour    ")+TF3(offHour,0,2)+T("  ")+TPS("",offHour,S1C('-'))+T("*")+TPS("",0xf-(offHour),S1C('-'))+T("\r\n") ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020dc.etherc.strclockoldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020dd.etherc.osdonothingf BEGIN
#define DDNAME       "3func.360020dd.etherc.osdonothingf"
#define DDNUMB      (countT)0x360020dd
#define IDFILE      (countT)0xd01


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osDoNothingF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300fc.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.a230104.1.1.0.html\"\>a230104:  WAKEsHOW( "example.simplest.func.10300fc.etherC.osDoNothingF" )\</A\>
this function executes the standard overhead processing designed into the etherC and thirdC classes
 (countT)third is evaluated and, if nonze, this function returns
 _IO_ is executed
 third.osDoNothingF( tinP ) is called
 OUT is executed
the processing time required by this function equals the overhead added by wrapping an operating system call in a thirdC member function and then in an etherC member function
*/
/**//*1*/voidT etherC::osDoNothingF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.osDoNothingIF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020dd.etherc.osdonothingf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020de.etherc.etherrptoverheadcostsf BEGIN
#define DDNAME       "3func.360020de.etherc.etherrptoverheadcostsf"
#define DDNUMB      (countT)0x360020de
#define IDFILE      (countT)0xd02


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherRptOverheadCostsF.0.html\"\>instances\</A\>
\<A HREF=\"5.10300fd.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 tinP
 pcP
  must be 0
  after evaluation, will point to a 1-indexed null terminated string of countT values
   pcP[ 0 ] will always be 0
   pcP[ 1 ] will be the cost of the first step
   pcP[ n ] will be the cost of the n-th step
   if n is the number of steps, then pcP[ n+1 ] will be ze
  each countT value is the cost of one step in IN ct and then dt
   _IO_ is the standard entry overhead of an etherC member function
   OUT is the standard exit overhead of an etherC member function
   there are other overhead costs associated with an etherC member function
    the cost of copying argument values to the stack for the thread
    the cost of evaluating (countT)third, which is done twice (only once if no parameter is validated)
    the cost of calling "__( condition )" to validate each parameter
    the cost of copying a return value to the stack for the thread (rare)
  the caller must d elete pcP
   use etherC::delF
*/
/**/

// "_T" IS FOR "TAG" AS IN "TAG BASE IN A BASEBALL GAME"
//#define _T pcTagTime[ ++ cSteps ] = third.osTimeTicksSinceBootIF() ;
#define _T pcTagTime[ ++ cSteps ] = thirdC::osClockIF( tinP ) ;
#define CAPACITY 0x80
#define CtRIES 0x10

/*1*/voidT etherC::etherRptOverheadCostsF( tinS& tinP , countT*& pcP )/*1*/
{
    SCOOP
    BLAMMO ; //U::REDESIGN AND REWRITE THIS SUBSYSTEM
    if( tinP.fingerprint && pcP ) ;

#if defined( NEVERdEFINED )

    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pcP ) ;
        if( POOP ) return ;
    }

    _IO_
    newF( tinP , LF , pcP , 1 + CAPACITY + 1 ) ; ___( pcP ) ; // ASSUME: LESS THAN "CAPACITY" CALLS TO _T IN THIS FUNCTION DEFINITION
    memSetF( tinP , (byteT*)pcP , sizeof( countT ) * ( 1 + CAPACITY + 1 ) ) ;

    // TAKE SOME SAMPLE RUNS THROUGH THE STEPS
    ZE( countT , cSteps ) ;
    {
        countT cTries = CtRIES ;
        while( cTries -- )
        {
            cSteps = 0 ;
            ZE( countT* , pcTagTime ) ;
            newF( tinP , LF , pcTagTime , 1 + CAPACITY + 1 ) ; ___( pcTagTime ) ; // ASSUME: LESS THAN "CAPACITY" CALLS TO _T IN THIS FUNCTION DEFINITION
            memSetF( tinP , (byteT*)pcTagTime , sizeof( countT ) * ( 1 + CAPACITY + 1 ) ) ;

            {
                _T static countT idFile = processGlobal7I.source.idFileF( tinP , DDNAME ) ;
                _T ZE(  countT , timeIn1 ) ;
                _T ZE( sCountT , timeIn2 ) ;
                _T if( third.flagsWatch )
                {
                    _T if( F(third.flagsWatch) & flWATCH_SAY )
                    {
                        _T third.dosWriteStdOutIF( tinP , "\r\n+" ) ;
                        _T third.dosWriteStdOutIF( tinP , DDNAME ) ;
                        _T 
                    }
                    //_T if( F(third.flagsWatch) & flWATCH_TIME && !POOP && third.bFunctionCountersReady )
                    //{
                    //    _T third.pcFunctionEntries[ idFile ] ++ ;
                    //    _T third.osTimeNowF( tinP , timeIn1 , timeIn2 ) ;
                    //    _T 
                    //}
                    _T 
                }
                _T if( F(third.flagsWatch) )
                {
                    _T ZE(  countT , time1 ) ;
                    _T ZE( sCountT , time2 ) ;
                    //_T if( F(third.flagsWatch) & flWATCH_TIME && !POOP && third.bFunctionCountersReady )
                    //{
                    //    _T ((thirdC&)third).osTimeNowF( tinP , time1 , time2 ) ;
                    //    _T ((thirdC&)third).osTimeSubtractF( tinP , time1 , time2 , timeIn1 , timeIn2 ) ;
                    //    _T ((thirdC&)third).osTimeAddF( tinP , third.pcFunctionTime1[ idFile ] , third.pcFunctionTime2[ idFile ] , time1 , time2 ) ;
                    //    _T third.pcFunctionExits[ idFile ] ++ ;
                    //    _T 
                    //}
                    _T if( F(third.flagsWatch) & flWATCH_SAY )
                    {
                        _T third.dosWriteStdOutIF( tinP , "\r\n-" ) ;
                        _T third.dosWriteStdOutIF( tinP , DDNAME ) ;
                        _T 
                    }
                    _T 
                }
                _T 
            }

            for( countT ids = 2 ; ids <= cSteps ; ids ++ ) pcP[ ids ] += pcTagTime[ ids ] - pcTagTime[ ids - 1 ] ;

            delF( tinP , pcTagTime ) ;
        }
    }

    for( countT ids = 2 ; ids <= cSteps ; ids ++ ) pcP[ ids ] /= CtRIES ;

#endif
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020de.etherc.etherrptoverheadcostsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020df.etherc.ether_pstt1_processparameters_f BEGIN
#define DDNAME       "3func.360020df.etherc.ether_pstt1_processparameters_f"
#define DDNUMB      (countT)0x360020df
#define IDFILE      (countT)0xd03


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ether_pstt1_processParametersI_F.0.html\"\>instances\</A\>
\<A HREF=\"5.1030100.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
this function must be used to refer to the tinP.pAdamGlobal1->_etherC_.pstt1_processParameters static member of etherC
 it is illegal to refer to tinP.pAdamGlobal1->_etherC_.pstt1_processParameters directly in the definition of an adam
*/
/**/

/*1*/strokeS*& etherC::ether_pstt1_processParametersI_F( tinS& tinP )/*1*/
{
    SCOOP
    _IO_

    return tinP.pAdamGlobal1->_etherC_.pstt1_processParameters ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020df.etherc.ether_pstt1_processparameters_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e0.etherc.ether_idcitizenhirer_f BEGIN
#define DDNAME       "3func.360020e0.etherc.ether_idcitizenhirer_f"
#define DDNUMB      (countT)0x360020e0
#define IDFILE      (countT)0xd04


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ether_idCitizenHirerI_F.0.html\"\>instances\</A\>
\<A HREF=\"5.1030101.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
this function must be used to refer to the idCitizenHirerI static member of etherC
it is illegal to refer to etherC::idCitizenHirerI directly in the definition of an adam
*/
/**/

/*1*/countT& etherC::ether_idCitizenHirerI_F( tinS& tinP )/*1*/
{
    SCOOP
    _IO_

    return tinP.pAdamGlobal1->_etherC_.idCitizenHirer ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e0.etherc.ether_idcitizenhirer_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e1.etherc.strconverttouppercasef BEGIN
#define DDNAME       "3func.360020e1.etherc.strconverttouppercasef"
#define DDNUMB      (countT)0x360020e1
#define IDFILE      (countT)0xd05


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strConvertToUpperCaseF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030103.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f630104.1.1.0.html\"\>f630104:  WAKEsHOW( "example.simplest.func.1030103.etherC.strConvertToUpperCaseF" )\</A\>
converts lower case alphabetic strokes (idCaste = 0; idAdam in ['a','z']) to upper case ['A','Z']
other idCaste = 0 strokes are copied unmodified
strokes with nonze idCaste are copied unmodified
arguments
 psttP
  can be any string of strokeS objects
*/
/**/

//ASSUME: IF THE strokeS STRING REPRESENTS MIXED 16,8 BYTE CHARS, THEN THIS FUNCTION WILL CHANGE THE MEANING AND EVEN THE NUMBER OF CHARACTERS
/*1*/voidT etherC::strConvertToUpperCaseF( tinS& tinP , strokeS* psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    countT cnt = psttP->idAdam ;
    for( countT ii = 1 ; !POOP && ii <= cnt ; ii ++ )
    {
         strConvertToUpperCaseF( tinP , psttP[ CSpREFIX - 1 + ii ] , psttP[ CSpREFIX - 1 + ii ] ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e1.etherc.strconverttouppercasef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e2.etherc.strconverttouppercasef BEGIN
#define DDNAME       "3func.360020e2.etherc.strconverttouppercasef"
#define DDNUMB      (countT)0x360020e2
#define IDFILE      (countT)0xd06


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strConvertToUpperCaseF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030104.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.5c20104.1.1.0.html\"\>5c20104:  WAKEsHOW( "example.simplest.func.1030104.etherC.strConvertToUpperCaseF" )\</A\>
if sttInP.idCaste is 0 and sttInP.idAdam is in the range ['a','z'] then sttOut will be in the range ['A','Z']
otherwise, sttOutP will be identical to sttInP
arguments
 sttOutP
  can be anything
 sttInP
  can be anything
*/
/**/

/*1*/voidT etherC::strConvertToUpperCaseF( tinS& tinP , strokeS& sttOutP , const strokeS& sttInP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    sttOutP = sttInP ;
    countT upper = (countT)sttInP - 'a' + 'A' ;
    if( ( sttInP.idCaste == sc_cALPHABET1 ||  sttInP.idCaste == sc_cFROMaSCII ) && sttInP >= 'a' && sttInP <= 'z' ) sttOutP = upper ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e2.etherc.strconverttouppercasef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e3.etherc.strsubstringmimeheaderf BEGIN
#define DDNAME       "3func.360020e3.etherc.strsubstringmimeheaderf"
#define DDNUMB      (countT)0x360020e3
#define IDFILE      (countT)0xd07


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strSubstringMimeHeaderF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030105.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6430104.1.1.0.html\"\>6430104:  WAKEsHOW( "example.simplest.func.1030105.etherC.strSubstringMimeHeaderF" )\</A\>
finds the value of the specified MIME header line
 MIME text consists of header lines followed by a null length line, followed by body lines
 a header line of MIME text contains a key and a value, separated by a colon (':')
 there might be white space immediately before and/or after the colon
 this function searches header lines for a line beginning with the specified key
 if found, psttP is filled with the value that is to the right of the colon
 the value is trimmed
 the key is matched case insensitively
if not found, psttP will be null and impotence will -not- occur
if the colon is at the end of the line, psttP will be set to a null length value
arguments
 psttP
  must be 0
 psttAllP
  must not be 0
  should be the string returned by strGetMimeHeaderF, which unwraps key:value pairs that occupy multiple lines
 psttKeyP
  must not be 0
  must not contain a blank or other white space stroke
   see the TbLACK symbolic constant
 csttExtraP
*/
/**//*1*/voidT etherC::strSubstringMimeHeaderF( tinS& tinP , strokeS*& psttP , const strokeS* const psttAllP , const strokeS* const psttKeyP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( psttAllP ) ;
        __Z( psttKeyP ) ;
        if( POOP ) return ;
        {
            countT idf = 1 ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            __( strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , T(TbLACK) , psttKeyP ) ) ;
        }
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , psttKey ) ;
    strConvertToLowerCaseF( tinP , psttKey , psttKeyP ) ; ___( psttKey ) ;

    countT idf = 1 ;
    boolT bWoth = 1 ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    while( !POOP && idf && !psttP )
    {
        ZE( strokeS* , psttl ) ;
        strSubstringLineF( tinP , psttl , idf , sttq , psttAllP , 1 ) ; ___( psttl ) ;
        if( !psttl ) break ;
        else if( !psttl->idAdam )
        {
            delF( tinP , psttl ) ;
            break ;
        }

        countT idf2 = 1 ;
        strokeS sttq2( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , psttk ) ;
        strSubstringF( tinP , psttk , idf2 , sttq2 , S1C(':') , psttl ) ; ___( psttk ) ;

        if( psttk && psttk->idAdam < psttl->idAdam ) // IF A COLON WAS FOUND
        {
            strConvertToLowerCaseF( tinP , psttk ) ; ___( psttk ) ;
            if( !strCompareF( tinP , psttk , psttKey ) )
            {
                if( !idf2 ) { strMakeF( tinP , LF , psttP , T("") ) ; ___( psttP ) ; }
                else
                {
                    ZE( countT , idl2 ) ;
                    strSubstringF( tinP , psttP , idf2 , idl2 , psttl , csttExtraP ) ; ___( psttP ) ;
                }

                if( bWoth ) bWoth = 0 ;
            }
        }

        delF( tinP , psttk ) ;
        delF( tinP , psttl ) ;
    }

    delF( tinP , psttKey ) ;
    if( psttP ) { strTrimF( tinP , psttP ) ; ___( psttP ) ; }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e3.etherc.strsubstringmimeheaderf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e4.etherc.strconverttolowercasef BEGIN
#define DDNAME       "3func.360020e4.etherc.strconverttolowercasef"
#define DDNUMB      (countT)0x360020e4
#define IDFILE      (countT)0xd08


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strConvertToLowerCaseF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030106.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.4430104.1.1.0.html\"\>4430104:  WAKEsHOW( "example.simplest.func.1030106.etherC.strConvertToLowerCaseF" )\</A\>
converts upper case alphabetic strokes (idCaste = 0; idAdam in ['A','Z']) to lower case ['a','z']
other idCaste = 0 strokes are copied unmodified
strokes with nonze idCaste are copied unmodified
arguments
 psttFromP
  must not be null
  can be any string of strokeS objects
 psttP
  must be null
*/
/**/

//ASSUME: IF THE strokeS STRING REPRESENTS MIXED 16,8 BYTE CHARS, THEN THIS FUNCTION WILL CHANGE THE MEANING AND EVEN THE NUMBER OF CHARACTERS
/*1*/voidT etherC::strConvertToLowerCaseF( tinS& tinP , strokeS*& psttP , const strokeS* const psttFromP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( psttFromP ) ;
        if( POOP ) return ;
    }

    _IO_

    strMakeF( tinP , LF , psttP , psttFromP ) ; // CALLER MUST TAG ___( psttP ) ;
    strConvertToLowerCaseF( tinP , psttP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e4.etherc.strconverttolowercasef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e5.etherc.strconverttouppercasef BEGIN
#define DDNAME       "3func.360020e5.etherc.strconverttouppercasef"
#define DDNUMB      (countT)0x360020e5
#define IDFILE      (countT)0xd09


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strConvertToUpperCaseF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030107.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.5430104.1.1.0.html\"\>5430104:  WAKEsHOW( "example.simplest.func.1030107.etherC.strConvertToUpperCaseF" )\</A\>
converts lower case alphabetic strokes (idCaste = 0; idAdam in ['a','z']) to upper case ['A','Z']
other idCaste =  strokes are copied unmodified
strokes with nonze idCaste are copied unmodified
arguments
 psttFromP
  must not be null
  can be any string of strokeS objects
 psttP
  must be null
*/
/**/

//ASSUME: IF THE strokeS STRING REPRESENTS MIXED 16,8 BYTE CHARS, THEN THIS FUNCTION WILL CHANGE THE MEANING AND EVEN THE NUMBER OF CHARACTERS
/*1*/voidT etherC::strConvertToUpperCaseF( tinS& tinP , strokeS*& psttP , const strokeS* const psttFromP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( psttFromP ) ;
        if( POOP ) return ;
    }

    _IO_

    strMakeF( tinP , LF , psttP , psttFromP ) ; //CALLER MUST TAG ___( psttP ) ;
    strConvertToUpperCaseF( tinP , psttP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e5.etherc.strconverttouppercasef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e6.etherc.sockrelayf BEGIN
#define DDNAME       "3func.360020e6.etherc.sockrelayf"
#define DDNUMB      (countT)0x360020e6
#define IDFILE      (countT)0xd0a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockRelayF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030109.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9430104.1.1.0.html\"\>9430104:  WAKEsHOW( "example.simplest.func.1030109.etherC.sockRelayF" )\</A\>
reads from sInP and writes to sOutP
several threads can feed into sOutP simultaneously
this function will never write a length prefix with value 0 to sOutP
 to close sOutP, you must explicitly send a length prefix with value 0 after all sockRelayF calls that feed into it return
the input streams must be length prefixed
 both input streams are assumed to consist of a stream of length prefixed byte records
 each record consists of a countT value containing the number of bytes which follow, followed by that many bytes
this function will not return until the peer either writes a length prefix with value 0 or closes its socket
this function writes to sOutP exactly what it reads from sInP, excluding the terminating length value of 0
arguments
 tinP
 sOutP
  must be connected and ready to write
 sInP
  must be connected and ready to read
 pBatonOutP
  can be 0
  if not 0 then will be grabbed befor writing each length prefix and released after writing each data string
 cbEstimateP
  can be 0
  specifies the initial size of the internal buffer
  the internal buffer is reallocated whenever it is too small to handle the next item
*/
/**/

/*1*/voidT etherC::sockRelayF( tinS& tinP , socketC& sOutP , socketC& sInP , batonC* const pBatonOutP , const countT cbEstimateP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    ZE( countT , cbb ) ;
    ZE( byteT* , pbb ) ;
    ZE( countT , cbi ) ;

    __( sizeof cbi - sInP.readF( tinP , (byteT*)&cbi , sizeof cbi ) ) ;
    cbb = cbi ;
    if( cbb < cbEstimateP ) cbb = cbEstimateP ;
    if( !cbb ) cbb ++ ;
    newF( tinP , LF , pbb , cbb ) ; ___( pbb ) ;

    while( !POOP && cbi )
    {
        if( cbb < cbi )
        {
            delF( tinP , pbb ) ;
            cbb = cbi ;
            newF( tinP , LF , pbb , cbb ) ; ___( pbb ) ;
        }

        __( cbi - sInP.readF( tinP , pbb , cbi ) ) ;

        if( pBatonOutP ) pBatonOutP->grabF( tinP , TAG( TAGiDnULL ) ) ;
        sOutP.writeF( tinP , (byteT*)&cbi , sizeof cbi ) ;
        sOutP.writeF( tinP , pbb , cbi ) ;
        if( pBatonOutP ) pBatonOutP->ungrabF( tinP ) ;

        __( sizeof cbi - sInP.readF( tinP , (byteT*)&cbi , sizeof cbi ) ) ;
    }
    delF( tinP , pbb ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e6.etherc.sockrelayf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e7.etherc.strcleanf BEGIN
#define DDNAME       "3func.360020e7.etherc.strcleanf"
#define DDNUMB      (countT)0x360020e7
#define IDFILE      (countT)0xd0b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strCleanF.0.html\"\>instances\</A\>
\<A HREF=\"5.103010a.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f430104.1.1.0.html\"\>f430104:  WAKEsHOW( "example.simplest.func.103010a.etherC.strCleanF" )\</A\>
the replacement is done in place
the presence or value of extra strokes is not affected
arguments
 tinP
 psttP
  must not be 0
  points to the string to be edited
  all strokes other than the prefix must be of idCaste sc_cFROMaSCII
 sttP
  can be 0
  contains the stroke value that is to overwrite unprintable strokes
*/
/**/

//U:: MIGRATE TO USE FLAGS RATHER THAN idTypeKeepP

/*1*/voidT etherC::strCleanF( tinS& tinP , strokeS* const psttP , strokeS sttP , const countT idTypeKeepP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    const countT offb = CSpREFIX ;
    const countT offe = CSpREFIX + psttP->idAdam ;

    switch( idTypeKeepP )
    {
        case ifcIDtYPEsTROKEcLEAN_PRINTABLES :
        {
            for( countT off = offb ; off < offe ; off ++ )
            {
                if
                (
                    psttP[ off ].idCaste != sc_cFROMaSCII
                    ||
                    psttP[ off ].idAdam < 0x20
                    ||
                    psttP[ off ].idAdam > 0x7e
                )
                psttP[ off ] = sttP ;
            }
            break ;
        }
        case ifcIDtYPEsTROKEcLEAN_CnAMES :
        {
            for( countT off = offb ; off < offe ; off ++ )
            {
                if
                (
                    !
                    (
                        ( 'a' <= psttP[ off ].idAdam && psttP[ off ].idAdam <= 'z' )            //LOWER CASE
                        ||
                        ( 'A' <= psttP[ off ].idAdam && psttP[ off ].idAdam <= 'Z' )            //UPPER CASE
                        ||
                        ( '0' <= psttP[ off ].idAdam && psttP[ off ].idAdam <= '9' )            //DIGIT
                        ||
                        ( '_' == psttP[ off ].idAdam                               )            //ALLOWED _
                    )
                )
                psttP[ off ] = sttP ;
            }
            break ;
        }
        case ifcIDtYPEsTROKEcLEAN_CnAMESoRbLANK :
        {
            for( countT off = offb ; off < offe ; off ++ )
            {
                if
                (
                    !
                    (
                        ( 'a' <= psttP[ off ].idAdam && psttP[ off ].idAdam <= 'z' )            //LOWER CASE
                        ||
                        ( 'A' <= psttP[ off ].idAdam && psttP[ off ].idAdam <= 'Z' )            //UPPER CASE
                        ||
                        ( '0' <= psttP[ off ].idAdam && psttP[ off ].idAdam <= '9' )            //DIGIT
                        ||
                        ( '_' == psttP[ off ].idAdam                               )            //ALLOWED _
                        ||
                        ( ' ' == psttP[ off ].idAdam                               )            //ALLOWED BLANK
                    )
                )
                psttP[ off ] = sttP ;
            }
            break ;
        }
        case ifcIDtYPEsTROKEcLEAN_CnAMESoRaT :
        {
            for( countT off = offb ; off < offe ; off ++ )
            {
                if
                (
                    !
                    (
                        ( 'a' <= psttP[ off ].idAdam && psttP[ off ].idAdam <= 'z' )            //LOWER CASE
                        ||
                        ( 'A' <= psttP[ off ].idAdam && psttP[ off ].idAdam <= 'Z' )            //UPPER CASE
                        ||
                        ( '0' <= psttP[ off ].idAdam && psttP[ off ].idAdam <= '9' )            //DIGIT
                        ||
                        ( '_' == psttP[ off ].idAdam                               )            //ALLOWED _
                        ||
                        ( '@' == psttP[ off ].idAdam                               )            //ALLOWED BLANK
                    )
                )
                psttP[ off ] = sttP ;
            }
            break ;
        }
        case ifcIDtYPEsTROKEcLEAN_CnAMESoRbLANKoRpUNCTUATION :
        {
            for( countT off = offb ; off < offe ; off ++ )
            {
                if
                (
                    !
                    (
                        ( 'a' <= psttP[ off ].idAdam && psttP[ off ].idAdam <= 'z' )            //LOWER CASE
                        ||
                        ( 'A' <= psttP[ off ].idAdam && psttP[ off ].idAdam <= 'Z' )            //UPPER CASE
                        ||
                        ( '0' <= psttP[ off ].idAdam && psttP[ off ].idAdam <= '9' )            //DIGIT
                        ||
                        ( '_' == psttP[ off ].idAdam                               )            //ALLOWED _
                        ||
                        ( ' ' == psttP[ off ].idAdam                               )            //ALLOWED BLANK
                        ||
                        ( '(' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( ')' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '[' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( ']' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '{' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '}' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '<' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '>' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( ',' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '.' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '/' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '?' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( ';' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '\'' == psttP[ off ].idAdam                              )            //ALLOWED PUNCTUATION
                        ||
                        ( '"' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( ':' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '\\' == psttP[ off ].idAdam                              )            //ALLOWED PUNCTUATION
                        ||
                        ( '|' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '=' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '+' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '-' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '*' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '&' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '^' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '%' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '$' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '#' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '@' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '!' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '`' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                        ||
                        ( '~' == psttP[ off ].idAdam                               )            //ALLOWED PUNCTUATION
                    )
                )
                psttP[ off ] = sttP ;
            }
            break ;
        }
        default :
        {
            __( idTypeKeepP ) ;
            __1 ;
            break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e7.etherc.strcleanf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e8.etherc.strfromf BEGIN
#define DDNAME       "3func.360020e8.etherc.strfromf"
#define DDNUMB      (countT)0x360020e8
#define IDFILE      (countT)0xd0c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFromF.0.html\"\>instances\</A\>
\<A HREF=\"5.103010b.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.5830104.1.1.0.html\"\>5830104:  WAKEsHOW( "example.simplest.func.103010b.etherC.strFromF" )\</A\>
arguments
 psttP
  must be 0
  will be set to contain the string
 pcValueP
  this is a pointer to the values that are to be represented as a string of digits
  must be a null terminated string of countT values
 flagsFormatP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001004c.flFORMAT!||
  these format flags are used when rendering each of the countT values in pcValueP
 csP
  minimum length of the final string
  if more strokes are needed to represent the number, psttP will be longer than csP
  this is used when rendering each of the countT values in pcValueP
 radixP
  can be 0
  if 0 then 16_9 is implied
  if not 0 then must be 2 <= radixP <= 64_9
  this is used when rendering each of the countT values in pcValueP
 psttSeparatorP
  this string is inserted between each rendering, i.e. between each rendered countT value
  can be 0
  if 0 then T("/") is used
 csttExtraP
*/
/**/

/*1*/voidT etherC::strFromF( tinS& tinP , strokeS*& psttP , const countT* const pcValueP , const flagsT flagsFormatP , const countT csP , const countT radixP , const strokeS* const psttSeparatorP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
            if( POOP ) return ;
            __NZ( psttP ) ;_WQ
            __( radixP && radixP < 2 ) ;_WQ
            __( !tinP.strokeMode.idCasteDefault && radixP > 64 ) ;_WQ
            __(  tinP.strokeMode.idCasteDefault && radixP > 0x10000 ) ;_WQ
            if( POOP ) return ;
    }

    _IO_

    TN( tSeparator , "/" ) ;_WQ
    const strokeS* const psttSeparator = psttSeparatorP ? psttSeparatorP : tSeparator ;_WQ

    stackC stEach( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;_WQ
    if( pcValueP )
    {
        countT offi = !!( F(flagsFormatP) & flFORMAT_PREFIXED ) ;_WQ
        countT cToDo = offi
            ? *pcValueP
            : thirdC::c_strlenIF( tinP , pcValueP )
        ;_WQ

        while( cToDo -- )
        {
            ZE( strokeS* , psttw ) ;_WQ
            strFromF( tinP , psttw , pcValueP[ offi ++ ] , flagsFormatP , csP , radixP ) ; ___( psttw ) ;_WQ
            stEach << psttw ;_WQ
        }
    }

    countT csAll = csttExtraP ;_WQ
    if( stEach )
    {
        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;_WQ
        do
        {
            strokeS* psttw = (strokeS*)stEach.downF( tinP , handle ) ;_WQ
            if( psttw ) csAll += psttw->idAdam + ( ~handle ? psttSeparator->idAdam : 0 ) ;_WQ
        }
        while( ~handle ) ;_WQ
    }

    strMakeF( tinP , LF , psttP , T("") , csAll ) ; //CALLER MUST TAG ___( psttP ) ;_WQ
    while( stEach )
    {
        ZE( strokeS* , psttw ) ;_WQ
        stEach >> psttw ;_WQ
        strFuseF( tinP , psttP , psttw ) ; ___( psttP ) ;_WQ
        delF( tinP , psttw ) ;_WQ
        if( stEach ) { strFuseF( tinP , psttP , psttSeparator ) ; ___( psttP ) ; }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e8.etherc.strfromf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e9.etherc.beesingdigitsf BEGIN
#define DDNAME       "3func.360020e9.etherc.beesingdigitsf"
#define DDNUMB      (countT)0x360020e9
#define IDFILE      (countT)0xd0d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$beeSingDigitsF.0.html\"\>instances\</A\>
\<A HREF=\"5.103010c.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6830104.1.1.0.html\"\>6830104:  WAKEsHOW( "example.simplest.func.103010c.etherC.beeSingDigitsF" )\</A\>
uses audible tones to communicate the value of cP
the code is simple
 a double low tone begins the sequence
 a single medium tone delimits each digit
 the digits are toned from least significant to most significant
  left to right, in IFC digit ordering
 for each digit, 0 or more (up to 15) high tones occur
 a pause occurs after each group of 4 high tones
  this pause has no meaning
  it is used only to make it easier for a human to count the high tones correctly
 a triple low tone ends the sequence
*/
/**//*1*/voidT etherC::beeSingDigitsF( tinS& tinP , const countT cP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    sleepStartF( tinP ) ;
    third.dosBeepSingDigitsIF( tinP , cP ) ;
    sleepEndF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020e9.etherc.beesingdigitsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ea.etherc.newdeltypeether BEGIN
#define DDNAME       "3func.360020ea.etherc.newdeltypeether"
#define DDNUMB      (countT)0x360020ea
#define IDFILE      (countT)0xd0e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.103010d.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7830104.1.1.0.html\"\>7830104:  WAKEsHOW( "example.simplest.func.103010d.etherC.NEWdELtYPEeTHER" )\</A\>
*/
/**/

/*1*/NEWdELtYPEeTHER( count01T )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ea.etherc.newdeltypeether END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020eb.etherc.strmakef BEGIN
#define DDNAME       "3func.360020eb.etherc.strmakef"
#define DDNUMB      (countT)0x360020eb
#define IDFILE      (countT)0xd0f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strMakeF.0.html\"\>instances\</A\>
\<A HREF=\"5.103010e.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.8830104.1.1.0.html\"\>8830104:  WAKEsHOW( "example.simplest.func.103010e.etherC.strMakeF" )\</A\>
arguments
 puntP
 psttP
*/
/**/

/*1*/countT etherC::strMakeF( tinS& tinP , const countT idLineP , const countT idiFileP , unTextT*& puntP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( puntP ) ;_WQ
        __Z( psttP ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( countT , cLength ) ;_WQ
    ZE( countT , cNotUsed ) ;_WQ
    if( !POOP )
    {
        GETpREFIX( cLength , cNotUsed , psttP ) ;_WQ
        third.newF( tinP , idLineP , idiFileP , puntP , cLength + 1 ) ; ___LF( puntP , idLineP , idiFileP ) ;_WQ
    }

    ZE( countT , cNull ) ;_WQ
    if( puntP )
    {
        unTextT* puntc = puntP ;_WQ

        for( countT offi = 0 ; offi < cLength ; offi ++ )
        {
            osTextT bv = psttP[ CSpREFIX + offi ] ;_WQ
            if( bv ) *( puntc ++ ) = bv ;
            else     cNull ++ ;
        }

        *puntc = 0 ;_WQ
    }

    return cLength - cNull ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020eb.etherc.strmakef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ec.etherc.etherbeimpotentf BEGIN
#define DDNAME       "3func.360020ec.etherc.etherbeimpotentf"
#define DDNUMB      (countT)0x360020ec
#define IDFILE      (countT)0xd10


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherBeImpotentF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030110.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7730104.1.1.0.html\"\>7730104:  WAKEsHOW( "example.simplest.func.1030110.etherC.etherBeImpotentF" )\</A\>
this function causes the etherC object to become impotent
arguments
 tinP
 codeP
  can be 0
  if 0 then the value 1234567 is used
*/
/**/

/*1*/voidT etherC::etherBeImpotentF( tinS& tinP , const countT codeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.osBeImpotentF( tinP , codeP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ec.etherc.etherbeimpotentf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ee.etherc.papertitlef BEGIN
#define DDNAME       "3func.360020ee.etherc.papertitlef"
#define DDNUMB      (countT)0x360020ee
#define IDFILE      (countT)0xd11


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$paperTitleF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030114.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 tinP
 psttP
  must not be 0
  must not be of 0 length
*/
/**/

//U::CONJ: THIS IS OBSOLETED BY etherC::winSetTitleF

/*1*/voidT etherC::paperTitleF( tinS& tinP , const strokeS* const psttP )/*1*/
{
    SCOOP
    if( POOP ) return ;
    __Z( psttP ) ;
    if( POOP ) return ;
    __( !psttP->idAdam ) ;
    if( POOP ) return ;

    _IO_
    third.winSetTitleF( tinP , T(psttP) ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ee.etherc.papertitlef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ef.etherc.ifcidcitizenfromexternalemailf BEGIN
#define DDNAME       "3func.360020ef.etherc.ifcidcitizenfromexternalemailf"
#define DDNUMB      (countT)0x360020ef
#define IDFILE      (countT)0xd12


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcIdCitizenFromExternalEmailF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030116.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.d830104.1.1.0.html\"\>d830104:  WAKEsHOW( "example.simplest.func.1030116.etherC.ifcIdCitizenFromExternalEmailF" )\</A\>
evaluates to the idCitizen associated with psttP
 0 if there is no idCitizen with that email address
 if the address is not recognized, impotence will -not- occur
arguments
 tinP
 psttP
  must not be 0
*/
/**/

/*1*/countT etherC::ifcIdCitizenFromExternalEmailF( tinS& tinP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    countT idCmd = idcNICKNAMEcMD_QUERYiDfROMeXTERNALeMAIL ;
    {
        socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
        sock.connectF( tinP , ifcPORToLD1nICKNAME , socketC::nicNameIF( tinP , *this , T(WWWiDEAFARMcOM) ) ) ;

        sock.writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;

        idCmd = sizeof( strokeS ) * ( CSpREFIX + psttP->idAdam ) ;
        sock.writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;

        sock.writeF( tinP , psttP ) ;

        sock.readF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;
    }
    return idCmd ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020ef.etherc.ifcidcitizenfromexternalemailf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f0.etherc.strcalendarf BEGIN
#define DDNAME       "3func.360020f0.etherc.strcalendarf"
#define DDNUMB      (countT)0x360020f0
#define IDFILE      (countT)0xd13


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strCalendarF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030117.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7b30104.1.1.0.html\"\>7b30104:  WAKEsHOW( "example.simplest.func.1030117.etherC.strCalendarF" )\</A\>
arguments
 tinP
 psttP
  can be null
  if null then will be allocated
  if not null then must contain enough extra strokes to completely hold the calendar
 time2P
  the day to highlight on the calendar
  the calendar will depict the quarter that contains this day
 cColP
  must be at least 6 if cRowP is 2, and at least b otherwise
 cRowP
  must be at least 2
  if 2 then the foreign date is not displayed
 csttExtraP
  is used when psttP is null
  must be 0 if psttP is not null
*/
/**/

/*1*/voidT etherC::strCalendarF( tinS& tinP , strokeS*& psttP , const sCountT time2P , const countT cColP , const countT cRowP , const countT csttIndentP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( csttExtraP && psttP ) ;
        __( cRowP < 2 ) ;
        if( POOP ) return ;
        __( cColP < ( cRowP == 2 ? 0x6 : 0xb ) ) ;
        if( POOP ) return ;
    }

    _IO_

    if( !psttP )
    {
        countT cRowsAlloc   =               cRowP * 8 + 3 ;
        countT cColsAlloc   = csttIndentP + cColP * 8 + 0xa ;
        countT csttEstimate = cRowsAlloc * cColsAlloc ;
        strFuseF( tinP , psttP , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ csttEstimate + csttExtraP ) ; //CALLER MUST TAG ___( psttP ) ;
    }

    countT oDay  = offDAY( time2P ) ;
    countT oStrong = offSTRONG( time2P ) ;
    countT oQtr  = offQTR( time2P ) ;

    strokeS* ppsttSOQ[ 8 ] ;
    {for( countT off = 0 ; off < sizeof ppsttSOQ / sizeof ppsttSOQ[ 0 ] ; off ++ ) ppsttSOQ[ off ] = 0 ;}
    strMakeF( tinP , LF , ppsttSOQ[ 0 ] , T("ze'str") ) ; ___( ppsttSOQ[ 0 ] ) ;
    strMakeF( tinP , LF , ppsttSOQ[ 1 ] , T("wo'str") ) ; ___( ppsttSOQ[ 1 ] ) ;
    strMakeF( tinP , LF , ppsttSOQ[ 2 ] , T("oo'str") ) ; ___( ppsttSOQ[ 2 ] ) ;
    strMakeF( tinP , LF , ppsttSOQ[ 3 ] , T("re'str") ) ; ___( ppsttSOQ[ 3 ] ) ;
    strMakeF( tinP , LF , ppsttSOQ[ 4 ] , T("fo'str") ) ; ___( ppsttSOQ[ 4 ] ) ;
    strMakeF( tinP , LF , ppsttSOQ[ 5 ] , T("fi'str") ) ; ___( ppsttSOQ[ 5 ] ) ;
    strMakeF( tinP , LF , ppsttSOQ[ 6 ] , T("se'str") ) ; ___( ppsttSOQ[ 6 ] ) ;
    strMakeF( tinP , LF , ppsttSOQ[ 7 ] , T("ve'str") ) ; ___( ppsttSOQ[ 7 ] ) ;

    strokeS* ppsttDOS[ 8 ] ;
    {for( countT off = 0 ; off < sizeof ppsttDOS / sizeof ppsttDOS[ 0 ] ; off ++ ) ppsttDOS[ off ] = 0 ;}
    strMakeF( tinP , LF , ppsttDOS[ 0 ] , T("ze'da") ) ; ___( ppsttDOS[ 0 ] ) ;
    strMakeF( tinP , LF , ppsttDOS[ 1 ] , T("wo'da") ) ; ___( ppsttDOS[ 1 ] ) ;
    strMakeF( tinP , LF , ppsttDOS[ 2 ] , T("oo'da") ) ; ___( ppsttDOS[ 2 ] ) ;
    strMakeF( tinP , LF , ppsttDOS[ 3 ] , T("re'da") ) ; ___( ppsttDOS[ 3 ] ) ;
    strMakeF( tinP , LF , ppsttDOS[ 4 ] , T("fo'da") ) ; ___( ppsttDOS[ 4 ] ) ;
    strMakeF( tinP , LF , ppsttDOS[ 5 ] , T("fi'da") ) ; ___( ppsttDOS[ 5 ] ) ;
    strMakeF( tinP , LF , ppsttDOS[ 6 ] , T("se'da") ) ; ___( ppsttDOS[ 6 ] ) ;
    strMakeF( tinP , LF , ppsttDOS[ 7 ] , T("ve'da") ) ; ___( ppsttDOS[ 7 ] ) ;

    strokeS* ppsttQOD[ 4 ] ;
    {for( countT off = 0 ; off < sizeof ppsttQOD / sizeof ppsttQOD[ 0 ] ; off ++ ) ppsttQOD[ off ] = 0 ;}
    strMakeF( tinP , LF , ppsttQOD[ 0 ] , T("ze'qu (the fallow)") ) ; ___( ppsttQOD[ 0 ] ) ;
    strMakeF( tinP , LF , ppsttQOD[ 1 ] , T("wo'qu (the sowing)") ) ; ___( ppsttQOD[ 1 ] ) ;
    strMakeF( tinP , LF , ppsttQOD[ 2 ] , T("oo'qu (the tending)") ) ; ___( ppsttQOD[ 2 ] ) ;
    strMakeF( tinP , LF , ppsttQOD[ 3 ] , T("re'qu (the reaping)") ) ; ___( ppsttQOD[ 3 ] ) ;

    strokeS* ppsttMonth[ 12 ] ;
    {for( countT off = 0 ; off < sizeof ppsttMonth / sizeof ppsttMonth[ 0 ] ; off ++ ) ppsttMonth[ off ] = 0 ;}
    strMakeF( tinP , LF , ppsttMonth[ 0x0 ] , T("jan") ) ; ___( ppsttMonth[ 0x0 ] ) ;
    strMakeF( tinP , LF , ppsttMonth[ 0x1 ] , T("feb") ) ; ___( ppsttMonth[ 0x1 ] ) ;
    strMakeF( tinP , LF , ppsttMonth[ 0x2 ] , T("mar") ) ; ___( ppsttMonth[ 0x2 ] ) ;
    strMakeF( tinP , LF , ppsttMonth[ 0x3 ] , T("apr") ) ; ___( ppsttMonth[ 0x3 ] ) ;
    strMakeF( tinP , LF , ppsttMonth[ 0x4 ] , T("may") ) ; ___( ppsttMonth[ 0x4 ] ) ;
    strMakeF( tinP , LF , ppsttMonth[ 0x5 ] , T("jun") ) ; ___( ppsttMonth[ 0x5 ] ) ;
    strMakeF( tinP , LF , ppsttMonth[ 0x6 ] , T("jul") ) ; ___( ppsttMonth[ 0x6 ] ) ;
    strMakeF( tinP , LF , ppsttMonth[ 0x7 ] , T("aug") ) ; ___( ppsttMonth[ 0x7 ] ) ;
    strMakeF( tinP , LF , ppsttMonth[ 0x8 ] , T("sep") ) ; ___( ppsttMonth[ 0x8 ] ) ;
    strMakeF( tinP , LF , ppsttMonth[ 0x9 ] , T("oct") ) ; ___( ppsttMonth[ 0x9 ] ) ;
    strMakeF( tinP , LF , ppsttMonth[ 0xa ] , T("nov") ) ; ___( ppsttMonth[ 0xa ] ) ;
    strMakeF( tinP , LF , ppsttMonth[ 0xb ] , T("dec") ) ; ___( ppsttMonth[ 0xb ] ) ;

    strokeS* ppsttDayOfWeek[ 7 ] ;
    {for( countT off = 0 ; off < sizeof ppsttDayOfWeek / sizeof ppsttDayOfWeek[ 0 ] ; off ++ ) ppsttDayOfWeek[ off ] = 0 ;}
    strMakeF( tinP , LF , ppsttDayOfWeek[ 0x0 ] , T("sun") ) ; ___( ppsttDayOfWeek[ 0x0 ] ) ;
    strMakeF( tinP , LF , ppsttDayOfWeek[ 0x1 ] , T("mon") ) ; ___( ppsttDayOfWeek[ 0x1 ] ) ;
    strMakeF( tinP , LF , ppsttDayOfWeek[ 0x2 ] , T("tue") ) ; ___( ppsttDayOfWeek[ 0x2 ] ) ;
    strMakeF( tinP , LF , ppsttDayOfWeek[ 0x3 ] , T("wed") ) ; ___( ppsttDayOfWeek[ 0x3 ] ) ;
    strMakeF( tinP , LF , ppsttDayOfWeek[ 0x4 ] , T("thu") ) ; ___( ppsttDayOfWeek[ 0x4 ] ) ;
    strMakeF( tinP , LF , ppsttDayOfWeek[ 0x5 ] , T("fri") ) ; ___( ppsttDayOfWeek[ 0x5 ] ) ;
    strMakeF( tinP , LF , ppsttDayOfWeek[ 0x6 ] , T("sat") ) ; ___( ppsttDayOfWeek[ 0x6 ] ) ;

    TN( ti , "" ) ;
    TN( tcr     , "\r\n" ) ;
    TN( tcrAt   , "@\r\n" ) ;
    TN( tcrBar  , "|\r\n" ) ;
    TN( tcrPlus , "+\r\n" ) ;
    if( csttIndentP )
    {
        ti      += TP("",csttIndentP) ;
        tcr     += ti ;
        tcrAt   += ti ;
        tcrBar  += ti ;
        tcrPlus += ti ;
    }

    { ZE( countT , time1 ) ; strFuseF( tinP , psttP , ti+(time2P<0?T(""):T("+"))+TT(time1,time2P)+(time2P<0?T(""):T("+"))+TP("",8*cColP-0x1e)+T(ppsttQOD[oQtr])+tcr ) ; ___( psttP ) ; }

    countT cScan = cRowP * 8 ;
    for( sCountT oScan = cScan ; oScan >= 0 ; oScan -- )
    {
        for( countT oCol = 0 ; oCol < 8 ; oCol ++ )
        {
            countT od = 0x40 * oQtr + ( oScan / cRowP ) * 8 + oCol ;

            cellScanCalendarF( tinP , *this , psttP , oScan % cRowP , od , oDay , cColP , time2P , ppsttDayOfWeek , ppsttMonth ) ;
        }

        if( oScan / cRowP == oStrong && oDay % 8 == 7 )
        {
            if( oScan % cRowP == cRowP / 2 ) { strFuseF( tinP , psttP , T("@ ")+T(ppsttSOQ[oScan/cRowP])+tcr ) ; ___( psttP ) ; }
            else if( oScan % cRowP )         { strFuseF( tinP , psttP , tcrAt ) ; ___( psttP ) ; }
            else                             { strFuseF( tinP , psttP , tcrAt ) ; ___( psttP ) ; }
        }
        else if( oScan / cRowP == oStrong + 1 && oDay % 8 == 7 )
        {
            if( oScan % cRowP == cRowP / 2 ) { strFuseF( tinP , psttP , T("| ")+T(ppsttSOQ[oScan/cRowP])+tcr ) ; ___( psttP ) ; }
            else if( oScan % cRowP )         { strFuseF( tinP , psttP , tcrBar ) ; ___( psttP ) ; }
            else                             { strFuseF( tinP , psttP , tcrAt  ) ; ___( psttP ) ; }
        }
        else
        {
            if( oScan % cRowP == cRowP / 2 ) { strFuseF( tinP , psttP , T("| ")+T(ppsttSOQ[oScan/cRowP])+tcr ) ; ___( psttP ) ; }
            else if( oScan % cRowP )         { strFuseF( tinP , psttP , tcrBar  ) ; ___( psttP ) ; }
            else                             { strFuseF( tinP , psttP , tcrPlus ) ; ___( psttP ) ; }
        }
    }

    {
        countT cPad = cColP - 5 ;
        countT cPadL = cPad / 2 ;
        countT cPadR = cPad - cPadL ;

        for( countT off = 0 ; off < sizeof ppsttDOS / sizeof ppsttDOS[ 0 ] ; off ++ )
        {
            strFuseF( tinP , psttP , TP("",cPadL)+T(ppsttDOS[off])+TP("",cPadR) ) ; ___( psttP ) ;
        }
        //FORCE APPLICATION CODE TO DO THIS IF IT WANTS IT: strFuseF( tinP , psttP , tcr ) ; ___( psttP ) ;
    }

    {for( countT off = 0 ; off < sizeof ppsttSOQ       / sizeof ppsttSOQ[       0 ] ; off ++ ) delF( tinP , ppsttSOQ[       off ] ) ;}
    {for( countT off = 0 ; off < sizeof ppsttDOS       / sizeof ppsttDOS[       0 ] ; off ++ ) delF( tinP , ppsttDOS[       off ] ) ;}
    {for( countT off = 0 ; off < sizeof ppsttQOD       / sizeof ppsttQOD[       0 ] ; off ++ ) delF( tinP , ppsttQOD[       off ] ) ;}
    {for( countT off = 0 ; off < sizeof ppsttMonth     / sizeof ppsttMonth[     0 ] ; off ++ ) delF( tinP , ppsttMonth[     off ] ) ;}
    {for( countT off = 0 ; off < sizeof ppsttDayOfWeek / sizeof ppsttDayOfWeek[ 0 ] ; off ++ ) delF( tinP , ppsttDayOfWeek[ off ] ) ;}
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f0.etherc.strcalendarf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f1.etherc.strclockoldf BEGIN
#define DDNAME       "3func.360020f1.etherc.strclockoldf"
#define DDNUMB      (countT)0x360020f1
#define IDFILE      (countT)0xd14


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strClockOldF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030118.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.8b30104.1.1.0.html\"\>8b30104:  WAKEsHOW( "example.simplest.func.1030118.etherC.strClockOldF" )\</A\>
arguments
 tinP
 psttP
  can be null
  if null then will be allocated
  if not null then must contain enough extra strokes to completely hold the clock
 time1P
  the time of day to highlight on the clock
 cColP
  must be at least 5
  must be at least 6 to look good
 cRowP
  must be at least 2
 csttExtraP
  is used when psttP is null
  must be 0 if psttP is not null
*/
/**/

/*1*/voidT etherC::strClockOldF( tinS& tinP , strokeS*& psttP , const countT time1P , const countT cColP , const countT cRowP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( csttExtraP && psttP ) ;
        __( cColP < 5 ) ;
        __( cRowP < 2 ) ;
        if( POOP ) return ;
    }

    _IO_

    if( !psttP )
    {
        countT csttEstimate = 0x10000 + ( cColP * 8 + 3 ) * ( cRowP * 8 + 3 ) + 3 * 0x10 * cRowP + 0x11 * 0x10 ;
        strFuseF( tinP , psttP , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ csttEstimate + csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;
    }

    countT oTickNow  = offTICK( time1P ) ;
    countT oHourNow = offHOUR( time1P ) ;

    strokeS* ppsttHOD[ 0x10 ] ;
    {for( countT off = 0 ; off < sizeof ppsttHOD / sizeof ppsttHOD[ 0 ] ; off ++ ) ppsttHOD[ off ] = 0 ;}
    strMakeF( tinP , LF , ppsttHOD[ 0x0 ] , T("wo'ho") ) ; ___( ppsttHOD[ 0x0 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x1 ] , T("oo'ho") ) ; ___( ppsttHOD[ 0x1 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x2 ] , T("re'ho") ) ; ___( ppsttHOD[ 0x2 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x3 ] , T("fo'ho") ) ; ___( ppsttHOD[ 0x3 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x4 ] , T("fi'ho") ) ; ___( ppsttHOD[ 0x4 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x5 ] , T("se'ho") ) ; ___( ppsttHOD[ 0x5 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x6 ] , T("ve'ho") ) ; ___( ppsttHOD[ 0x6 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x7 ] , T("ta'ho") ) ; ___( ppsttHOD[ 0x7 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x8 ] , T("ta'ho") ) ; ___( ppsttHOD[ 0x8 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x9 ] , T("ni'ho") ) ; ___( ppsttHOD[ 0x9 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0xa ] , T("ay'ho") ) ; ___( ppsttHOD[ 0xa ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0xb ] , T("be'ho") ) ; ___( ppsttHOD[ 0xb ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0xc ] , T("ce'ho") ) ; ___( ppsttHOD[ 0xc ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0xd ] , T("de'ho") ) ; ___( ppsttHOD[ 0xd ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0xe ] , T("ee'ho") ) ; ___( ppsttHOD[ 0xe ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0xf ] , T("fa'ho") ) ; ___( ppsttHOD[ 0xf ] ) ;

    strokeS* ppsttTOH[ 0x10 ] ;
    {for( countT off = 0 ; off < sizeof ppsttTOH / sizeof ppsttTOH[ 0 ] ; off ++ ) ppsttTOH[ off ] = 0 ;}
    strMakeF( tinP , LF , ppsttTOH[ 0x0 ] , T("wo'ti") ) ; ___( ppsttTOH[ 0x0 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x1 ] , T("oo'ti") ) ; ___( ppsttTOH[ 0x1 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x2 ] , T("re'ti") ) ; ___( ppsttTOH[ 0x2 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x3 ] , T("fo'ti") ) ; ___( ppsttTOH[ 0x3 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x4 ] , T("fi'ti") ) ; ___( ppsttTOH[ 0x4 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x5 ] , T("se'ti") ) ; ___( ppsttTOH[ 0x5 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x6 ] , T("ve'ti") ) ; ___( ppsttTOH[ 0x6 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x7 ] , T("ta'ti") ) ; ___( ppsttTOH[ 0x7 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x8 ] , T("ta'ti") ) ; ___( ppsttTOH[ 0x8 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x9 ] , T("ni'ti") ) ; ___( ppsttTOH[ 0x9 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0xa ] , T("ay'ti") ) ; ___( ppsttTOH[ 0xa ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0xb ] , T("be'ti") ) ; ___( ppsttTOH[ 0xb ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0xc ] , T("ce'ti") ) ; ___( ppsttTOH[ 0xc ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0xd ] , T("de'ti") ) ; ___( ppsttTOH[ 0xd ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0xe ] , T("ee'ti") ) ; ___( ppsttTOH[ 0xe ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0xf ] , T("fa'ti") ) ; ___( ppsttTOH[ 0xf ] ) ;

    { ZE( sCountT , time2 ) ; strFuseF( tinP , psttP , TT(time1P,time2)+T("\r\n") ) ; ___( psttP ) ; }

    countT cScan = cRowP * 0x10 ;
    for( sCountT oScan = cScan ; oScan >= 0 ; oScan -- )
    {
        for( countT oCol = 0 ; oCol < 0x10 ; oCol ++ )
        {
            countT od = ( oScan / cRowP ) * 0x10 + oCol ;

            cellScanClockF( tinP , *this , psttP , oScan % cRowP , od , oTickNow , cColP ) ;
        }

        if( oScan / cRowP == oHourNow && oTickNow % 0x10 == 0xf )
        {
            if( oScan % cRowP == cRowP / 2 ) { strFuseF( tinP , psttP , T("@ ")+TP(ppsttHOD[oScan/cRowP],0x10)+T("\r\n") ) ; ___( psttP ) ; }
            else if( oScan % cRowP )         { strFuseF( tinP , psttP , T("@\r\n") ) ; ___( psttP ) ; }
            else                             { strFuseF( tinP , psttP , T("@\r\n") ) ; ___( psttP ) ; }
        }
        else if( oScan / cRowP == oHourNow + 1 && oTickNow % 0x10 == 0xf )
        {
            if( oScan % cRowP == cRowP / 2 ) { strFuseF( tinP , psttP , T("| ")+TP(ppsttHOD[oScan/cRowP],0x10)+T("\r\n") ) ; ___( psttP ) ; }
            else if( oScan % cRowP )         { strFuseF( tinP , psttP , T("|\r\n") ) ; ___( psttP ) ; }
            else                             { strFuseF( tinP , psttP , T("@\r\n") ) ; ___( psttP ) ; }
        }
        else
        {
            if( oScan % cRowP == cRowP / 2 ) { strFuseF( tinP , psttP , T("| ")+TP(ppsttHOD[oScan/cRowP],0x10)+T("\r\n") ) ; ___( psttP ) ; }
            else if( oScan % cRowP )         { strFuseF( tinP , psttP , T("|\r\n") ) ; ___( psttP ) ; }
            else                             { strFuseF( tinP , psttP , T("+\r\n") ) ; ___( psttP ) ; }
        }
    }

    {
        countT cPad = cColP - 5 ;
        countT cPadL = cPad / 2 ;
        countT cPadR = cPad - cPadL ;

        strFuseF( tinP , psttP , T(" ") ) ; ___( psttP ) ;
        for( countT off = 0 ; off < sizeof ppsttTOH / sizeof ppsttTOH[ 0 ] ; off ++ )
        {
            strFuseF( tinP , psttP , TP("",cPadL)+T(ppsttTOH[off])+TP("",cPadR) ) ; ___( psttP ) ;
        }
        strFuseF( tinP , psttP , T("\r\n") ) ; ___( psttP ) ;
    }

    {for( countT off = 0 ; off < sizeof ppsttTOH / sizeof ppsttTOH[ 0 ] ; off ++ ) delF( tinP , ppsttTOH[ off ] ) ;}
    {for( countT off = 0 ; off < sizeof ppsttHOD / sizeof ppsttHOD[ 0 ] ; off ++ ) delF( tinP , ppsttHOD[ off ] ) ;}
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f1.etherc.strclockoldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f2.etherc.ostimetooldtimef BEGIN
#define DDNAME       "3func.360020f2.etherc.ostimetooldtimef"
#define DDNUMB      (countT)0x360020f2
#define IDFILE      (countT)0xd15


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osTimeToOldTimeF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030119.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9b30104.1.1.0.html\"\>9b30104:  WAKEsHOW( "example.simplest.func.1030119.etherC.osTimeToOldTimeF" )\</A\>
calculates conventional calendar time from city time
 this function correctly accounts for leap years and leap centuries
all returned arguments are ze based offsets
 msP: the number of complete milliseconds after yP dP hhP mmP ssP since Jesus's conventional time of birth
  the domain of this parameter is [0,999]
 ssP: the number of complete seconds after yP dP hhP mmP since Jesus's conventional time of birth
  the domain of this parameter is [0,59]
 mmP: the number of complete minutes after yP dP hhP since Jesus's conventional time of birth
  the domain of this parameter is [0,59]
 hhP: the number of complete hours after yP dP since Jesus's conventional time of birth
  the domain of this parameter is [0,23]
 dP: the number of complete days after yP mP since Jesus's conventional time of birth
  the domain of this parameter is [0,30]
 mP: the number of complete months after yP since Jesus's conventional time of birth
  the domain of this parameter is [0,11]
 yP: the number of complete years since Jesus's conventional time of birth
  sets yP = 0 for a time in the first year of our lord
  sets yP = -1 for a time in the last year before our lord
  the domain of this parameter is unrestricted; any value can be specified
 dowP: the day of the week
  the domain of this parameter is [0-6]
arguments
 msP
 ssP
 mmP
 hhP
 dP
 mP
 yP
 dowP
 time1P
 time2P
*/
/**//*1*/voidT etherC::osTimeToOldTimeF( tinS& tinP , countT& msP , countT& ssP , countT& mmP , countT& hhP , countT& dP , countT& mP , sCountT& yP , countT& dowP , const countT time1P , const sCountT time2P , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.osTimeToOldTimeF( tinP , msP , ssP , mmP , hhP , dP , mP , yP , dowP , time1P , time2P , flagsP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f2.etherc.ostimetooldtimef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f3.etherc.strwordsoldf BEGIN
#define DDNAME       "3func.360020f3.etherc.strwordsoldf"
#define DDNUMB      (countT)0x360020f3
#define IDFILE      (countT)0xd16


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strWordsOldF.0.html\"\>instances\</A\>
\<A HREF=\"5.103011a.1.0.html\"\>definition\</A\>
parses psttP into separate strings
evaluates to the number of separate strings
delimiters within quotes are not used as delimiters
a single leading and trailing pair of double quotes, if present, is trimmed from each string
backslash quote pairs are replaced with a quote stroke
arguments
 tinP
 pstt1P
  must be 0
  after evaluation, will be allocated with exactly the number of strokes needed to store the result, plus csttExtraP
 psttP
  must not be 0
 sttQuoteP
 psttDelimitersP
  can be 0
  if 0 then T(TbLACK) is used
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00103cf.flSTRwORDS!||
 csttExtraP
 csttPrefixNullsP
  each word in pstt1P will be prefixed with this many nulls
 csttSuffixNullsP
  each word in pstt1P will be suffixed with this many nulls
*/
/**/

/*1*/countT etherC::strWordsOldF( tinS& tinP , strokeS*& pstt1P , const strokeS* const psttP , strokeS& sttQuoteP , const strokeS* psttDelimitersP , const flagsT flagsP , const countT csttExtraP , const countT csttPrefixNullsP , const countT csttSuffixNullsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( pstt1P ) ;_WQ
        FV( flSTRwORDS , flagsP )
        __Z( psttP ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_

    boolT bDelimiters = !!( F(flagsP) & flSTRwORDS_DELIMITERS ) ;_WQ
    const strokeS sttqSave = sttQuoteP ;_WQ
    TN( tWhite , TbLACK ) ;_WQ
    const strokeS* psttDelimiters = psttDelimitersP ? psttDelimitersP : (strokeS*)tWhite ;_WQ

    //if( tinP.pc Utility[ 0 ] )
    //{
    //    ZE( strokeS* , psttd ) ;_WQ
    //    etherC::strDumpStrokesIF( tinP , psttd , psttP ) ; ___( psttd ) ;_WQ
    //    LOGrAW( T(USCORE79 "\r\n\r\n")+T(tinP.monitor.idThread)+T("|psttP| ")+T(psttd)+T("\r\n") ) ;_WQ
    //    PUSE( tinP , *(byteT**)&psttd ) ;_WQ
    //}

    countT cTries = 2 ;_WQ
    ZE( countT , csNeeded ) ;_WQ
    ZE( countT , cWords ) ;_WQ
    while( cTries -- )
    {
        if( !cTries )
        {
            strMakeF( tinP , LF , pstt1P , T("") , csNeeded + csttExtraP ) ; //CALLER MUST TAG ___( pstt1P ) ;_WQ
        }

        countT idf = 1 ;_WQ
        while( !POOP && idf )
        {
            countT idfSave = idf ;_WQ
            sttQuoteP = sttqSave ; //NEEDED WHEN INPUT CONTAINS AN UNPAIRED QUOTE
            countT idw = strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttQuoteP , psttDelimiters , psttP ) ;_WQ

            countT idfDelim = idw ;_WQ
            countT idlDelim = !idfDelim
                ? 0
                : idf
                    ? idf - 1
                    : psttP->idAdam ;_WQ
            ;_WQ

            //if( tinP.pc Utility[ 0 ] ) LOGrAW5( "[idfDelim,idlDelim]: " , idfDelim , " " , idlDelim , "\r\n" ) ;_WQ

            if( idfSave <= psttP->idAdam && !strIdF( tinP , psttP[ CSpREFIX - 1 + idfSave ] , psttDelimiters ) )
            {
                if( idw > idfSave ) idw -- ;_WQ
                ZE( strokeS* , psttw2 ) ;_WQ
                strSubstringF( tinP , psttw2 , idfSave , idw , psttP ) ; ___( psttw2 ) ;_WQ
                ZE( strokeS* , psttw3 ) ;_WQ
                strokeS sttd = S1C(0x22) ; //0x22 is a double quote
                if( sttQuoteP.idCaste != sc_IGNOREqUOTES && psttw2->idAdam > 1 && psttw2[ CSpREFIX ] == sttd && psttw2[ CSpREFIX - 1 + psttw2->idAdam ] == sttd )
                {
                    if( psttw2->idAdam == 2 ) { strMakeF( tinP , LF , psttw3 , T("") ) ; ___( psttw3 ) ; }
                    else
                    {
                        countT idf3 = 2 ;_WQ
                        countT idl3 = psttw2->idAdam - 1 ;_WQ
                        strSubstringF( tinP , psttw3 , idf3 , idl3 , psttw2 ) ; ___( psttw3 ) ;_WQ
                    }
                }
                else { strMakeF( tinP , LF , psttw3 , psttw2 ) ; ___( psttw3 ) ; }
                delF( tinP , psttw2 ) ;_WQ

                if( cTries ) csNeeded += CSpREFIX + psttw3->idAdam + csttPrefixNullsP + csttSuffixNullsP ;
                else
                {
                    strReplaceF( tinP , psttw3 , 0 , T("\\\"") , T("\"") , 0 , flSTRrEPLACE_IGNOREqUOTES ) ;_WQ
                    strFuseSeparateF( tinP , pstt1P , psttw3 , csttPrefixNullsP , csttSuffixNullsP ) ; ___( pstt1P ) ;_WQ
                    cWords ++ ;_WQ
                }

                delF( tinP , psttw3 ) ;_WQ
            }

            if( bDelimiters && idfDelim )
            {
                if( cTries ) csNeeded += CSpREFIX + idlDelim - idfDelim + 1 + csttPrefixNullsP + csttSuffixNullsP ;
                else
                {
                    ZE( strokeS* , psttd ) ;_WQ
                    strSubstringF( tinP , psttd , idfDelim , idlDelim , psttP ) ; ___( psttd ) ;_WQ
                    strFuseSeparateF( tinP , pstt1P , psttd , csttPrefixNullsP , csttSuffixNullsP ) ;_WQ
                    delF( tinP , psttd ) ;_WQ
                    cWords ++ ;_WQ
                }
            }
        }
    }

    return cWords ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f3.etherc.strwordsoldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f4.etherc.strbycastef BEGIN
#define DDNAME       "3func.360020f4.etherc.strbycastef"
#define DDNUMB      (countT)0x360020f4
#define IDFILE      (countT)0xd17


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strByCasteF.0.html\"\>instances\</A\>
\<A HREF=\"5.103011b.1.0.html\"\>definition\</A\>
parses a string into separate strings, each of homogeneous caste
 a new string is begun whenever the caste of the current stroke is not equal to the caste of the preceding stroke
arguments
 tinP
 pstt1P
 psttP
 pczIdCasteIncludeP
  if not 0 then points to a null terminated list of the idCaste values that will be allowed
 pczIdCasteExcludeP
  if not 0 then points to a null terminated list of the idCaste values that will be excluded
  this filter is applied to the results of the include filter
*/
/**/

/*1*/voidT etherC::strByCasteF( tinS& tinP , strokeS*& pstt1P , const strokeS* const psttP , const countT* const pczIdCasteIncludeP , const countT* const pczIdCasteExcludeP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pstt1P ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
        __( psttP->idAdam && !psttP[ CSpREFIX ].idCaste ) ;
        if( POOP ) return ;
    }

    _IO_

    const countT cInclude = pczIdCasteIncludeP ? thirdC::c_strlenIF( tinP , pczIdCasteIncludeP ) : 0 ;
    const countT cExclude = pczIdCasteExcludeP ? thirdC::c_strlenIF( tinP , pczIdCasteExcludeP ) : 0 ;

    ZE( countT , cString ) ;
    {
        ZE( countT , idCasteLag ) ;
        for( countT off = 0 ; off < psttP->idAdam ; off ++ )
        {
            if( idCasteLag != psttP[ CSpREFIX + off ].idCaste )
            {
                idCasteLag = psttP[ CSpREFIX + off ].idCaste ;
                SETwANTcASTE( psttP[ CSpREFIX + off ].idCaste )
                if( _bWantCaste ) cString ++ ;
            }
        }
    }

    strMakeF( tinP , LF , pstt1P , T("") , psttP->idAdam + CSpREFIX * cString + csttExtraP ) ; // CALLER MUST TAG ___( pstt1P ) ;

    {
        ZE( countT , offWoth ) ;
        ZE( countT , idCasteLag ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( countT , off ) ;
        for( ; off < psttP->idAdam ; off ++ )
        {
            if( idCasteLag != psttP[ CSpREFIX + off ].idCaste )
            {
                SETwANTcASTE( idCasteLag )
                idCasteLag = psttP[ CSpREFIX + off ].idCaste ;

                if( _bWantCaste )
                {
                    countT idf = 1 + offWoth ;
                    countT idl = off ;
                    ZE( strokeS* , psttw ) ;
                    strSubstringF( tinP , psttw , idf , idl , psttP ) ; ___( psttw ) ;
                    strFuseSeparateF( tinP , pstt1P , psttw ) ; ___( pstt1P ) ;
                    delF( tinP , psttw ) ;
                }

                offWoth = off ;
            }
        }

        SETwANTcASTE( idCasteLag )
        if( _bWantCaste )
        {
            countT idf = 1 + offWoth ;
            countT idl = off ;
            ZE( strokeS* , psttw ) ;
            strSubstringF( tinP , psttw , idf , idl , psttP ) ; ___( psttw ) ;
            strFuseSeparateF( tinP , pstt1P , psttw ) ; ___( pstt1P ) ;
            delF( tinP , psttw ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f4.etherc.strbycastef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f5.etherc.strbycastef BEGIN
#define DDNAME       "3func.360020f5.etherc.strbycastef"
#define DDNUMB      (countT)0x360020f5
#define IDFILE      (countT)0xd18


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strByCasteF.0.html\"\>instances\</A\>
\<A HREF=\"5.103011c.1.0.html\"\>definition\</A\>
this function concatenates all strings in st_psttP and then passes the resulting string to its overload
st_psttP is not emptied
arguments
 tinP
 pstt1P
  must be 0
 st_psttP
  idType must be set to ifcSTACKtYPE_PTR_strokeS
  contains ze or more strings of strokes
  strings of strings are illegal
*/
/**/

/*1*/voidT etherC::strByCasteF( tinS& tinP , strokeS*& pstt1P , stackC& st_psttP , const flagsT flConcatenateP , const countT* const pczIdCasteIncludeP , const countT* const pczIdCasteExcludeP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pstt1P ) ;
        __( st_psttP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_strokeS ) ;
        FV( flSTRcONCATENATE , flConcatenateP ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , pstta ) ;
    strConcatenateF( tinP , pstta , st_psttP , 0 , flConcatenateP , pczIdCasteIncludeP , pczIdCasteExcludeP , csttExtraP ) ; ___( pstta ) ;
    strByCasteF( tinP , pstt1P , pstta , pczIdCasteIncludeP , pczIdCasteExcludeP , csttExtraP ) ; ___( pstt1P ) ;
    delF( tinP , pstta ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f5.etherc.strbycastef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f6.etherc.sockftpserverf BEGIN
#define DDNAME       "3func.360020f6.etherc.sockftpserverf"
#define DDNUMB      (countT)0x360020f6
#define IDFILE      (countT)0xd19


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockFtpServerF.0.html\"\>instances\</A\>
\<A HREF=\"5.103011d.1.0.html\"\>definition\</A\>
i obey tinP.pcQuit
*/
/**/

/*1*/voidT etherC::sockFtpServerF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , psttLever ) ;
    switchC swImage( tinP , third , TAG( TAGiDnULL ) , flSTACKc_null , psttLever ) ;
    ZE( const countT , cQuitNU ) ;
    ZE( countT , idClient ) ;
    ZE( countT , cDone ) ;
    batonC batQuota( tinP , TAG( TAGiDnULL ) ) ;
    timeS timeTouch ;
    osTimeNowF( tinP , timeTouch.time1 , timeTouch.time2 ) ;
    while( !tinP.pcQuit || !*tinP.pcQuit )
    {
        while( ( !tinP.pcQuit || !*tinP.pcQuit ) && !POOP )
        {
            socketC socket( tinP , *this , TAG( TAGiDnULL ) ) ;
            socket.bindF( tinP , ifcPORToLD1fTP ) ;
            socket.listenF( tinP ) ;

            while( ( !tinP.pcQuit || !*tinP.pcQuit ) && !POOP )
            {
                ZE( socketC* , pso ) ;
                nicNameC nnPeer ;
                ZE( countT , idPortPeer ) ;
                ZE( boolT , bRefuse ) ;
                socket.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ; ___( pso ) ;
                __( bRefuse ) ;
                if( POOP ) { DEL( pso ) ; }
                else        { ZE( countT , tnu ) ; osThreadF( TaRG1( tmFtpServeF ) , (countT)pso , ++ idClient , (countT)&cDone , (countT)&psttLever , (countT)&swImage , (countT)&batQuota , (countT)&timeTouch ) ; }
            }
        }
        third = 0 ;
    }

    {
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        ZE( countT , ecz ) ;
        POOPIES
        while( cDone < idClient ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
    }

    countT cFlavors = swImage.cFlavorsF( tinP ) ;
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    {
        psttLever = (strokeS*)swImage.leverF( tinP , idf ) ;
        count2S*& pc2pbcb = *(count2S**)&(countT&)swImage ;
        if( pc2pbcb )
        {
            third.delF( tinP , *(byteT**)&pc2pbcb->c1 ) ;
            third.delF( tinP , pc2pbcb ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f6.etherc.sockftpserverf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f7.etherc.filesetptrf BEGIN
#define DDNAME       "3func.360020f7.etherc.filesetptrf"
#define DDNUMB      (countT)0x360020f7
#define IDFILE      (countT)0xd1a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$fileSetPtrF.0.html\"\>instances\</A\>
\<A HREF=\"5.103011e.1.0.html\"\>definition\</A\>
arguments
 tinP
 handleP
  must not be 0
 flagsP
 c2P
  normally, set both elements to 0
  this results in the pointer being set to the position specified by the flags
*/
/**/

/*1*/voidT etherC::fileSetPtrF( tinS& tinP , const handleC& handleP , const flagsT flagsP , count2S& c2P )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        FV( flSETfILEpTR , flagsP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.dosSetFilePtrF( tinP , handleP , flagsP , c2P ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f7.etherc.filesetptrf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f8.etherc.winpostmessageafternapf BEGIN
#define DDNAME       "3func.360020f8.etherc.winpostmessageafternapf"
#define DDNUMB      (countT)0x360020f8
#define IDFILE      (countT)0xd1b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$winPostMessageAfterNapF.0.html\"\>instances\</A\>
\<A HREF=\"5.103011f.1.0.html\"\>definition\</A\>
it is illegal to use this symbol in the definition of an adam
it is illegal to use this symbol in system code except in winMessageHandlerWorkF to work around shitting MS Windows bugs
this function always uses etPrime
 etPrime is guaranteed to exist until all kid threads have ended
arguments
 tinP
 time1P
  must not be 0
 hWindowP
  must not be 0
 idCmdP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00100ed.idcWIN!||
  must not be 0
  can be either an ifc code or a base operating system code
 arg1P
 arg2P
*/
/**/

/*1*/voidT etherC::winPostMessageAfterNapF( tinS& tinP , const countT time1P , const handleC& hWindowP , const countT idCmdP , const countT arg1P , const countT arg2P )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return  ;
        __Z( time1P ) ;
        __Z( hWindowP ) ;
        __Z( idCmdP ) ;
        __( !tinP.pAdamGlobal1->_etherC_.pEtPrime ) ;
        if( POOP ) return  ;
    }

    _IO_

    //CODEsYNC: DUPLICATE CODE 10200B7 103011f
    //ZE( countT , idCmd ) ;
    //if( idCmdP < WM_USER ) idCmd = idCmdP ;
    //else
    //{
    //    switch( idCmdP )
    //    {
    //        #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000008.idcWINcASES.h"
    //    }
    //}
    //__Z( idCmd ) ;

    { ZE( countT , tid ) ; osThreadF( tinP , tid , tmNapF , 0 , flTHREADlAUNCH_null , 0 , time1P , hWindowP.osF( ifcIDtYPEhANDLE_WINDOW ) , idCmdP , arg1P , arg2P ) ; }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f8.etherc.winpostmessageafternapf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f9.etherc.strconcatenatef BEGIN
#define DDNAME       "3func.360020f9.etherc.strconcatenatef"
#define DDNUMB      (countT)0x360020f9
#define IDFILE      (countT)0xd1c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strConcatenateF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030120.1.0.html\"\>definition\</A\>
concatenates all strings in st_psttP into a single string
i evaluate to the number of markers inserted
 each delimiter is tallied
 each exclusion mark is tallied
arguments
 tinP
 psttP
  must be 0
 st_psttP
  type must be ifcSTACKtYPE_PTR_strokeS
 psttDelimiterP
  can be 0
  if not 0 then can be 0 length
  will be inserted between each snippet in st_psttP
  ignored if st_psttP is of type blob (each plate is a single strokeS image)
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001029e.flSTRcONCATENATE!||
 pczIdCasteIncludeP
  ignored if st_psttP is of type blob (each plate is a single strokeS image)
 pczIdCasteExcludeP
  ignored if st_psttP is of type blob (each plate is a single strokeS image)
 csttExtraP
*/
/**/

/*1*/countT etherC::strConcatenateF( tinS& tinP , strokeS*& psttP , stackC& st_psttP , const strokeS* const psttDelimiterP , const flagsT flagsP , const countT* const pczIdCasteIncludeP , const countT* const pczIdCasteExcludeP , const countT csttExtraP )/*1*/
{
    SCOOP
    const countT idType = st_psttP.idTypeF( tinP ) ;
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( psttP ) ;
        __( idType != ifcSTACKtYPE_PTR_strokeS && ( idType != ifcSTACKtYPE_BLOB || st_psttP.cbDataF( tinP ) != sizeof( strokeS ) ) ) ;
        if( idType != ifcSTACKtYPE_PTR_strokeS && psttDelimiterP )
        FV( flSTRcONCATENATE , flagsP )
        if( POOP ) return 0 ;
    }

    _IO_

    const boolT  bSingles  = idType != ifcSTACKtYPE_PTR_strokeS ;
    const boolT  bSeparate = !bSingles && !!( F(flagsP) & flSTRcONCATENATE_SEPARATE ) ;
    const countT cInclude  = pczIdCasteIncludeP ? thirdC::c_strlenIF( tinP , pczIdCasteIncludeP ) : 0 ;
    const countT cExclude  = pczIdCasteExcludeP ? thirdC::c_strlenIF( tinP , pczIdCasteExcludeP ) : 0 ;
    const boolT  bCopy     = !!( F(flagsP) & flSTRcONCATENATE_COPY     ) ;
    const boolT  bUp       = !!( F(flagsP) & flSTRcONCATENATE_REVERSE  ) ; //DOES NOT REVERSE THE ORDER OF STROKES WITHIN EACH SNIPPET

    ZE( countT , cMarks ) ;
    st_psttP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    countT cstta = csttExtraP + ( psttDelimiterP && st_psttP ? psttDelimiterP->idAdam * ( st_psttP - 1 ) : 0 ) ;
    if( st_psttP )
    {
        if( bSingles ) cstta += st_psttP ;
        else
        {
            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            do
            {
                strokeS* psttw = (strokeS*)st_psttP.downF( tinP , handle ) ;
                if( psttw ) cstta += psttw->idAdam + bSeparate * CSpREFIX ;
                else        __1
            }
            while( !POOP && ~handle ) ;
        }
    }

    strMakeF( tinP , LF , psttP , T("") , cstta ) ; // CALLER MUST TAG ___( psttP ) ;

    if( st_psttP )
    {
        TN( tNull , "" ) ; tNull = T("") + S2( (countT)0 , sc_NULL ) ;
        ZE( boolT , bNullLag ) ;
        if( bUp || bCopy )
        {
            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            do
            {
                if( bSingles )
                {
                    strokeS& sttWo = *(strokeS*)&( bUp ? st_psttP.upF( tinP , handle ) : st_psttP.downF( tinP , handle ) ) ;
                    strFuseF( tinP , psttP , sttWo ) ; ___( psttP ) ;
                }
                else
                {
                    strokeS* psttc1 = (strokeS*)( bUp ? st_psttP.upF( tinP , handle ) : st_psttP.downF( tinP , handle ) ) ; //NAMED THIS FOR CONVENIENCE OF OTHER OVERLOAD
                    #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000010.strConcatenateF_woSnip.h"
                    if( psttDelimiterP && ~handle )
                    {
                        strFuseF( tinP , psttP , psttDelimiterP ) ; ___( psttP ) ;
                        cMarks ++ ;
                    }
                }
            }
            while( !POOP && ~handle ) ;

            if( !bCopy )
            {
                if( !bSingles ) st_psttP.purgeF( tinP ) ;
                else
                {
                    while( st_psttP ) //PURGE DONE THIS WAY TO DEREGISTER sc_cADAM INSTANCES
                    {
                        strokeS sttWo ;
                        byteT* pb_sttWo = (byteT*)&sttWo ;
                        st_psttP >> pb_sttWo ;
                    }
                }
            }
        }
        else while( st_psttP )
        {
            if( bSingles )
            {
                strokeS sttWo ;
                byteT* pb_sttWo = (byteT*)&sttWo ;
                st_psttP >> pb_sttWo ;
                strFuseF( tinP , psttP , sttWo ) ; ___( psttP ) ;
            }
            else
            {
                ZE( strokeS* , psttc1 ) ; //NAMED THIS FOR CONVENIENCE OF OTHER OVERLOAD
                st_psttP >> psttc1 ;
                #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000010.strConcatenateF_woSnip.h"
                if( psttDelimiterP && st_psttP )
                {
                    strFuseF( tinP , psttP , psttDelimiterP ) ; ___( psttP ) ;
                    cMarks ++ ;
                }
                delF( tinP , psttc1 ) ;
            }
        }
    }
    st_psttP.ungrabF( tinP ) ;
    return cMarks ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020f9.etherc.strconcatenatef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020fa.etherc.ifcportauthorityf BEGIN
#define DDNAME       "3func.360020fa.etherc.ifcportauthorityf"
#define DDNUMB      (countT)0x360020fa
#define IDFILE      (countT)0xd1d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcPortAuthorityF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030121.1.0.html\"\>definition\</A\>
this function will launch a port authority thread and will then return immediately
the launched thread will remain active until the app is quitting
only one port authority can exist on a host
*/
/**/

/*1*/voidT etherC::ifcPortAuthorityF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    { ZE( countT , tnu ) ; osThreadF( tinP , tnu , tmPortAuthorityF ) ; }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020fa.etherc.ifcportauthorityf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020fb.etherc.ifcportnewf BEGIN
#define DDNAME       "3func.360020fb.etherc.ifcportnewf"
#define DDNUMB      (countT)0x360020fb
#define IDFILE      (countT)0xd1e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcPortNewF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030122.1.0.html\"\>definition\</A\>
evaluates to the idiClass actually registered
 if idiClassP is not 0 then it is used
arguments
 tinP
 idPortP
  must not be 0
 idiClassP
  can be 0
  if 0 then the owner of this etherC object is used
*/
/**/
/*1*/countT etherC::ifcPortNewF( tinS& tinP , const countT idPortP , const countT idiClassP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __( tinP.pAdamGlobal1->_etherC_.idPortFace ) ;
        __Z( idPortP ) ;
        __( !tinP.pAdamGlobal1->_etherC_.idProcessOld ) ;
        __( !tinP.pAdamGlobal1->_etherC_.pEtPrime ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    count4S c4o ;
    c4o.c1 = ifcCMDpORTaUTHORITY_NEW ;
    c4o.c2 = tinP.pAdamGlobal1->_etherC_.idProcessOld ;
    c4o.c3 = idiClassP ? idiClassP : processGlobal1I.idAdamRoot ;
    c4o.c4 = idPortP ;

    {
        socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
        sock.connectF( tinP , ifcPORToLD1pORTaUTHORITY ) ;

        tinP.pAdamGlobal1->_etherC_.idPortFace = idPortP ;
        { ZE( countT , idp ) ; sock.myNameF( tinP , idp , tinP.pAdamGlobal1->_etherC_.nicNamePaper ) ; }

        sock.writeF( tinP , (byteT*)&c4o , sizeof c4o ) ;

        ZE( countT , idAck ) ;
        sock.readF( tinP , (byteT*)&idAck , sizeof idAck ) ;
        __( idAck - ifcREPLY_ACK ) ;
    }

    return c4o.c2 ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020fb.etherc.ifcportnewf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020fc.etherc.ifcportdelf BEGIN
#define DDNAME       "3func.360020fc.etherc.ifcportdelf"
#define DDNUMB      (countT)0x360020fc
#define IDFILE      (countT)0xd1f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcPortDelF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030123.1.0.html\"\>definition\</A\>
arguments
 tinP
*/
/**/
/*1*/voidT etherC::ifcPortDelF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( !tinP.pAdamGlobal1->_etherC_.idProcessOld ) ;
        if( POOP ) return ;
    }

    _IO_

    count2S c2o ;
    c2o.c1 = ifcCMDpORTaUTHORITY_DELETE ;
    c2o.c2 = tinP.pAdamGlobal1->_etherC_.idProcessOld ;

    {
        socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
        sock.connectF( tinP , ifcPORToLD1pORTaUTHORITY ) ;
        sock.writeF( tinP , (byteT*)&c2o , sizeof c2o ) ;

        ZE( countT , idAck ) ;
        sock.readF( tinP , (byteT*)&idAck , sizeof idAck ) ;
        __( idAck - ifcREPLY_ACK ) ;
    }

    tinP.pAdamGlobal1->_etherC_.nicNamePaper = tinP.pAdamGlobal1->_etherC_.idPortFace = 0 ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020fc.etherc.ifcportdelf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020fd.etherc.ifcportqueryf BEGIN
#define DDNAME       "3func.360020fd.etherc.ifcportqueryf"
#define DDNUMB      (countT)0x360020fd
#define IDFILE      (countT)0xd20


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcPortQueryF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030124.1.0.html\"\>definition\</A\>
arguments
 tinP
 stIdPortP
  must be empty
  must be able to accept countT values
 nicNameP
  can be 0
  if 0 then the local host is queried
 idiClassP
  can be 0
*/
/**/
/*1*/voidT etherC::ifcPortQueryF( tinS& tinP , stackC& stIdPortP , const nicNameC nicNameP , const countT idiClassP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( stIdPortP ) ;
        __( !tinP.pAdamGlobal1->_etherC_.pEtPrime ) ;
        if( POOP ) return ;
    }

    _IO_

    count2S c2o ;
    c2o.c1 = ifcCMDpORTaUTHORITY_QUERY ;
    c2o.c2 = idiClassP ? idiClassP : processGlobal1I.idAdamRoot ;

    {
        socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
        sock.connectF( tinP , ifcPORToLD1pORTaUTHORITY , nicNameP ) ;
        sock.writeF( tinP , (byteT*)&c2o , sizeof c2o ) ;

        ZE( countT , cPorts ) ;
        sock.readF( tinP , (byteT*)&cPorts , sizeof cPorts ) ;
        if( cPorts )
        {
            ZE( countT* , pcp ) ;
            newF( tinP , LF , pcp , cPorts ) ; ___( pcp ) ;
            if( pcp )
            {
                sock.readF( tinP , (byteT*)pcp , sizeof( countT ) * cPorts ) ;
                for( countT off = 0 ; off < cPorts ; off ++ ) stIdPortP << pcp[ off ] ;
            }
            delF( tinP , pcp ) ;
        }

        ZE( countT , idAck ) ;
        sock.readF( tinP , (byteT*)&idAck , sizeof idAck ) ;
        __( idAck - ifcREPLY_ACK ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020fd.etherc.ifcportqueryf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020fe.etherc.ifcportqueryf BEGIN
#define DDNAME       "3func.360020fe.etherc.ifcportqueryf"
#define DDNUMB      (countT)0x360020fe
#define IDFILE      (countT)0xd21


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcPortQueryF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030125.1.0.html\"\>definition\</A\>
arguments
 tinP
 swsIdPortP
  must be empty
  must be able to accept countT values
 leverP
  must be 0
 nicNameP
  can be 0
  if 0 then the local host is queried
*/
/**/
/*1*/voidT etherC::ifcPortQueryF( tinS& tinP , switchStackC& swsIdPortP , countT& leverP , const nicNameC nicNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( swsIdPortP ) ;
        __( leverP ) ;
        if( POOP ) return ;
    }

    _IO_

    countT idCmd = ifcCMDpORTaUTHORITY_QUERYaLL ;

    {
        socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
        sock.connectF( tinP , ifcPORToLD1pORTaUTHORITY , nicNameP ) ;
        sock.writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;

        ZE( countT , cPorts ) ;
        sock.readF( tinP , (byteT*)&cPorts , sizeof cPorts ) ;

        if( cPorts )
        {
            ZE( count2S* , pc2cp ) ;
            newF( tinP , LF , pc2cp , cPorts ) ; ___( pc2cp ) ;
            if( pc2cp )
            {
                sock.readF( tinP , (byteT*)pc2cp , sizeof( count2S ) * cPorts ) ;

                for( countT off = 0 ; off < cPorts ; off ++ )
                {
                    __( !pc2cp[ off ].c1 ) ;
                    __( !pc2cp[ off ].c2 ) ;
                    if( !POOP )
                    {
                        if( leverP != pc2cp[ off ].c1 ) leverP = pc2cp[ off ].c1 ;
                        swsIdPortP << pc2cp[ off ].c2 ;
                    }
                }
            }
            delF( tinP , pc2cp ) ;
        }

        ZE( countT , idAck ) ;
        sock.readF( tinP , (byteT*)&idAck , sizeof idAck ) ;
        __( idAck - ifcREPLY_ACK ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360020fe.etherc.ifcportqueryf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002101.etherc.sockstkacceptorsf BEGIN
#define DDNAME       "3func.36002101.etherc.sockstkacceptorsf"
#define DDNUMB      (countT)0x36002101
#define IDFILE      (countT)0xd22


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockStkAcceptorsF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030131.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/stackC& etherC::sockStkAcceptorsF( tinS& tinP )/*1*/
{
    if( tinP.fingerprint ) ;
    if( !tinP.pAdamGlobal1->_etherC_.pStkAcceptors ) ;//TELLsYSc1( ifcIDtYPEtELLsYS_ERRORpsTaCCEPTORSiS0 )
    return *tinP.pAdamGlobal1->_etherC_.pStkAcceptors ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002101.etherc.sockstkacceptorsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002102.etherc.winsettitlef BEGIN
#define DDNAME       "3func.36002102.etherc.winsettitlef"
#define DDNUMB      (countT)0x36002102
#define IDFILE      (countT)0xd23


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$winSetTitleF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030135.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/boolT etherC::winSetTitleF( tinS& tinP , const strokeS* const psttP , const handleC& hWindowP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttP ) ;
        __( !tinP.pAdamGlobal1->_etherC_.pEtPrime ) ;
        if( POOP ) return 0 ;
        __( !tinP.pAdamGlobal1->_etherC_.pBatWinTitle ) ;
        __( !tinP.pAdamGlobal1->_etherC_.pTxtWinTitle ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    tinP.pAdamGlobal1->_etherC_.pBatWinTitle->grabF( tinP , TAG( TAGiDnULL ) ) ;
    *tinP.pAdamGlobal1->_etherC_.pTxtWinTitle = T(psttP) ;
    boolT bOk = third.winSetTitleF( tinP , *tinP.pAdamGlobal1->_etherC_.pTxtWinTitle , hWindowP ) ;
    tinP.pAdamGlobal1->_etherC_.pBatWinTitle->ungrabF( tinP ) ;
    return bOk ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002102.etherc.winsettitlef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002103.etherc.winappendtitlef BEGIN
#define DDNAME       "3func.36002103.etherc.winappendtitlef"
#define DDNUMB      (countT)0x36002103
#define IDFILE      (countT)0xd24


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$winAppendTitleF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030136.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::winAppendTitleF( tinS& tinP , const strokeS* const psttP , const handleC& hWindowP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        __( !tinP.pAdamGlobal1->_etherC_.pEtPrime ) ;
        if( POOP ) return ;
        __( !tinP.pAdamGlobal1->_etherC_.pBatWinTitle ) ;
        __( !tinP.pAdamGlobal1->_etherC_.pTxtWinTitle ) ;
        if( POOP ) return ;
    }

    _IO_
    tinP.pAdamGlobal1->_etherC_.pBatWinTitle->grabF( tinP , TAG( TAGiDnULL ) ) ;
    *tinP.pAdamGlobal1->_etherC_.pTxtWinTitle += T(psttP) ;
    third.winSetTitleF( tinP , *tinP.pAdamGlobal1->_etherC_.pTxtWinTitle , hWindowP ) ;
    tinP.pAdamGlobal1->_etherC_.pBatWinTitle->ungrabF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002103.etherc.winappendtitlef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002106.etherc.ifcportnewprocessf BEGIN
#define DDNAME       "3func.36002106.etherc.ifcportnewprocessf"
#define DDNUMB      (countT)0x36002106
#define IDFILE      (countT)0xd25


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcPortNewProcessF.0.html\"\>instances\</A\>
\<A HREF=\"5.103013b.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
only the first call has effect
 subsequent calls have no effect and do not cause impotence
arguments
 tinP
*/
/**/
/*1*/voidT etherC::ifcPortNewProcessF( tinS& tinP )/*1*/
{
    SCOOP
    static countT cIn ;
    cIn ++ ;
    if( cIn == 1 )
    {
        IFbEcAREFUL
        {
            if( POOP ) return ;
            __( tinP.pAdamGlobal1->_etherC_.idProcessOld ) ;
            if( POOP ) return ;
        }

        _IO_

        countT idCmd = ifcCMDpORTaUTHORITY_NEWpROCESS ;

        {
            socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
            sock.connectF( tinP , ifcPORToLD1pORTaUTHORITY ) ;
            sock.writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;

            sock.readF( tinP , (byteT*)&tinP.pAdamGlobal1->_etherC_.idProcessOld , sizeof tinP.pAdamGlobal1->_etherC_.idProcessOld ) ;
            __( !tinP.pAdamGlobal1->_etherC_.idProcessOld ) ;

            ZE( countT , idAck ) ;
            sock.readF( tinP , (byteT*)&idAck , sizeof idAck ) ;
            __( idAck - ifcREPLY_ACK ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002106.etherc.ifcportnewprocessf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002107.etherc.etherscanprocessparametersf BEGIN
#define DDNAME       "3func.36002107.etherc.etherscanprocessparametersf"
#define DDNUMB      (countT)0x36002107
#define IDFILE      (countT)0xd26


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherScanProcessParametersF.0.html\"\>instances\</A\>
\<A HREF=\"5.103013c.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 tinP
*/
/**/

/*1*/voidT etherC::etherScanProcessParametersF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    ZE( countT , idArg ) ;
    FORsTRINGSiN1( tinP.pAdamGlobal1->_etherC_.pstt1_processParameters )
    {
        if( idArg )
        {
            switch( idArg )
            {
                case 1 : { idArg = 0 ; __(   tinP.pAdamGlobal1->_etherC_.idPortFaceDad ) ; tinP.pAdamGlobal1->_etherC_.idPortFaceDad = strDigitsToSCountF( tinP , psttc1 ) ; __( !tinP.pAdamGlobal1->_etherC_.idPortFaceDad ) ; break ; }
                case 2 : { idArg = 0 ; __( !!tinP.pAdamGlobal1->_etherC_.nicNamePaperDad ) ; tinP.pAdamGlobal1->_etherC_.nicNamePaperDad = strDigitsToNicNameF( tinP , psttc1 ) ; __( !tinP.pAdamGlobal1->_etherC_.nicNamePaperDad ) ; break ; }
                case 3 : { idArg = 0 ; __(   tinP.pAdamGlobal1->_etherC_.idKid         ) ; tinP.pAdamGlobal1->_etherC_.idKid         = strDigitsToSCountF( tinP , psttc1 ) ; __( !tinP.pAdamGlobal1->_etherC_.idKid         ) ; break ; }
            }
        }
        else if( !strCompareF( tinP , psttc1 , T("!tinP.pAdamGlobal1->_etherC_.idPortFaceDad" ) ) ) { idArg = 1 ; }
        else if( !strCompareF( tinP , psttc1 , T("!nicNamePaperDadI" ) ) ) { idArg = 2 ; }
        else if( !strCompareF( tinP , psttc1 , T("!idKidI"         ) ) ) { idArg = 3 ; }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002107.etherc.etherscanprocessparametersf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002108.etherc.ifcportnewidmiscf BEGIN
#define DDNAME       "3func.36002108.etherc.ifcportnewidmiscf"
#define DDNUMB      (countT)0x36002108
#define IDFILE      (countT)0xd27


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcPortNewIdMiscF.0.html\"\>instances\</A\>
\<A HREF=\"5.103013e.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 tinP
*/
/**/
/*1*/countT etherC::ifcPortNewIdMiscF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    _IO_

    countT idCmd = ifcCMDpORTaUTHORITY_NEWiDmISC ;

    ZE( countT , idMisc ) ;
    {
        socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
        sock.connectF( tinP , ifcPORToLD1pORTaUTHORITY ) ;
        sock.writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;

        sock.readF( tinP , (byteT*)&idMisc , sizeof idMisc ) ;
        __Z( idMisc ) ;

        ZE( countT , idAck ) ;
        sock.readF( tinP , (byteT*)&idAck , sizeof idAck ) ;
        __( idAck - ifcREPLY_ACK ) ;
    }
    return idMisc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002108.etherc.ifcportnewidmiscf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002109.etherc.etheridportpaperf BEGIN
#define DDNAME       "3func.36002109.etherc.etheridportpaperf"
#define DDNUMB      (countT)0x36002109
#define IDFILE      (countT)0xd28


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherIdPortPaperF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030140.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/countT etherC::etherIdPortPaperF( tinS& tinP )/*1*/
{
    return tinP.pAdamGlobal1->_etherC_.idPortFace ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002109.etherc.etheridportpaperf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600210a.etherc.ethernicnamepaperf BEGIN
#define DDNAME       "3func.3600210a.etherc.ethernicnamepaperf"
#define DDNUMB      (countT)0x3600210a
#define IDFILE      (countT)0xd29


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherNicNamePaperF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030141.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/nicNameC etherC::etherNicNamePaperF( tinS& tinP )/*1*/
{
    return tinP.pAdamGlobal1->_etherC_.nicNamePaper ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600210a.etherc.ethernicnamepaperf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600210b.etherc.newdeltypeether BEGIN
#define DDNAME       "3func.3600210b.etherc.newdeltypeether"
#define DDNUMB      (countT)0x3600210b
#define IDFILE      (countT)0xd2a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.1030144.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/NEWdELtYPEeTHER( nicNameC )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600210b.etherc.newdeltypeether END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600210c.etherc.strfromf BEGIN
#define DDNAME       "3func.3600210c.etherc.strfromf"
#define DDNUMB      (countT)0x3600210c
#define IDFILE      (countT)0xd2b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFromF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030145.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::strFromF( tinS& tinP , strokeS*& psttP , const nicNameC& nicNameP , const flagsT flFormatP , const countT csP , const countT radixP , const strokeS* const psttSeparatorP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
            if( POOP ) return ;
            __NZ( psttP ) ;_WQ
            __( radixP && radixP < 2 ) ;_WQ
            __( !tinP.strokeMode.idCasteDefault && radixP > 64 ) ;_WQ
            __(  tinP.strokeMode.idCasteDefault && radixP > 0x10000 ) ;_WQ
            __( !POOP && processGlobal1I.cb_nicNameC_ - 4 * sizeof( countT ) ) ;_WQ
            if( POOP ) return ;
    }

    _IO_

    TN( tSeparator , ":" ) ; //CHANGED FROM "/" TO "." ON 2003JUNE9 ; CHANGED FROM "." TO ":" AT 20210223@1106
    const strokeS* const psttSeparator = psttSeparatorP ? psttSeparatorP : tSeparator ;_WQ

    flagsT flFormatShort = F(flFormatP) ? flFormatP : flFORMAT_DOTTEDdECIMAL ;_WQ
    flagsT flFormatLong  = F(flFormatP) ? flFormatP : flFORMAT_COLONEDhEX    ;_WQ

    ZE( boolT , bLong ) ;_WQ
    stackC stEach( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;_WQ
    {
        countT* pcv = (countT*)&nicNameP ;_WQ
        for( countT off = 3 ; off ; off -- )
        {
            if( pcv[ off ] )
            {
                if( !bLong && off == 1 && pcv[ off ] == 0xffff ) break ;

                bLong = 1 ;_WQ
                break ;
            }
        }

        for( sCountT off = 3 ; off >= 0 ; off -- )
        {
            if( !bLong && off ) continue ;

            ZE( strokeS* , psttw ) ;_WQ
            strFromF( tinP , psttw , pcv[ off ] , bLong ? flFormatLong : flFormatShort , /*csP*/8 , radixP ) ; ___( psttw ) ;_WQ
            stEach << psttw ;_WQ
        }
    }

    countT csAll = csttExtraP ;_WQ
    {
        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;_WQ
        do
        {
            strokeS* psttw = (strokeS*)stEach.downF( tinP , handle ) ;_WQ
            if( psttw ) csAll += psttw->idAdam + ( ~handle ? psttSeparator->idAdam : 0 ) ;_WQ
        }
        while( ~handle ) ;_WQ
    }

    strMakeF( tinP , LF , psttP , T("") , csAll ) ; //CALLER MUST TAG ___( psttP ) ;_WQ
    while( stEach )
    {
        ZE( strokeS* , psttw ) ;_WQ
        stEach >> psttw ;_WQ
        strFuseF( tinP , psttP , psttw ) ; ___( psttP ) ;_WQ
        delF( tinP , psttw ) ;_WQ
        if( !bLong ) break ;
        if( stEach ) { strFuseF( tinP , psttP , psttSeparator ) ; ___( psttP ) ; }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600210c.etherc.strfromf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600210d.etherc.strdigitstonicnamef BEGIN
#define DDNAME       "3func.3600210d.etherc.strdigitstonicnamef"
#define DDNUMB      (countT)0x3600210d
#define IDFILE      (countT)0xd2c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strDigitsToNicNameF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030146.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/nicNameC etherC::strDigitsToNicNameF( tinS& tinP , const strokeS* const psttP , const countT defaultRadixP , const boolT bForeignP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return nicNameC() ;
        __Z( psttP ) ;
        if( POOP ) return nicNameC() ;
    }

    _IO_

    ZE( strokeS* , pstt1w ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    strWordsOldF( tinP , pstt1w , psttP , sttq , T("/") ) ; ___( pstt1w ) ;

    ZE( countT , idw ) ;
    countT pca[ 5 ] ; //ASSUME: nicNameC CONSISTS OF 4 countT'S
    memSetF( tinP , (byteT*)pca , sizeof pca ) ;
    FORsTRINGSiN1( pstt1w )
    {
        pca[ ++ idw ] = strDigitsToSCountF( tinP , psttc1 , defaultRadixP , bForeignP ) ;
        if( idw == 4 ) break ;
    }
    delF( tinP , pstt1w ) ;
    return nicNameC( pca[ 1 ] , pca[ 2 ] , pca[ 3 ] , pca[ 4 ] ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600210d.etherc.strdigitstonicnamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600210e.etherc.strfromf BEGIN
#define DDNAME       "3func.3600210e.etherc.strfromf"
#define DDNUMB      (countT)0x3600210e
#define IDFILE      (countT)0xd2d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strFromF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030147.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::strFromF( tinS& tinP , strokeS*& psttP , const byteT* const pbBlobP , const countT cbBlobP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;_WQ
        __( !pbBlobP &&  cbBlobP ) ;_WQ
        if( POOP ) return ;
    }

    _IO_

    const countT csBlob = ( cbBlobP + sizeof( strokeS ) - 1 ) / sizeof( strokeS ) ; // INCL PADDING
    strMakeF( tinP , LF , psttP , T("")+S2(cbBlobP,scOld_BLOB) , csBlob + csttExtraP ) ; //CALLER MUST TAG ___( psttP ) ;_WQ
    if( psttP && csBlob )
    {
        byteT* const pbTo = (byteT*)( psttP + CSpREFIX + 1 ) ;_WQ

        memCopyF( tinP , pbTo , pbBlobP , cbBlobP ) ;_WQ

        countT cbPad = sizeof( strokeS ) * csBlob - cbBlobP ;_WQ
        if( cbPad ) memSetF( tinP , (byteT*)( pbTo + cbBlobP ) , cbPad ) ;_WQ
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600210e.etherc.strfromf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600210f.etherc.strisdigitsf BEGIN
#define DDNAME       "3func.3600210f.etherc.strisdigitsf"
#define DDNUMB      (countT)0x3600210f
#define IDFILE      (countT)0xd2e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strIsDigitsF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030148.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/boolT etherC::strIsDigitsF( tinS& tinP , const strokeS* const psttP , const countT radixP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    boolT bDigits = 1 ;
    const strokeS* psttc = psttP + CSpREFIX ;
    countT cToDo = psttP->idAdam ;
    while( cToDo -- )
    {
        if( !( psttc ++ )->bDigitF( radixP ) )
        {
            bDigits = 0 ;
            break ;
        }
    }
    return bDigits ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600210f.etherc.strisdigitsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002110.etherc.memreplacef BEGIN
#define DDNAME       "3func.36002110.etherc.memreplacef"
#define DDNUMB      (countT)0x36002110
#define IDFILE      (countT)0xd2f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$memReplaceF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030149.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.8530104.1.1.0.html\"\>8530104:  WAKEsHOW( "example.simplest.func.1030149.etherC.memReplaceF" )\</A\>
replaces, in place, occurances of pbSmallOldP with pbSmallNewP
evaluates to the number of replacements made
arguments
 tinP
 pbBigP
  must not be 0
  must point to cbBigP bytesP of memory that the current process can write to and read from
 cbBigP
  can be 0
  if 0 then nothing is done
   a ze value here does -not- cause pbBigP to be analyzed for length
 pbSmallOldP
  must not be 0
  can include null bytes if cbSmallP is not 0
  if cbSmallP is 0 then pbSmallOldP will be treated as a null terminated string and inspected to determine cbSmall
 pbSmallNewP
  must not be 0
  can contain null bytes, regardless of whether cbSmallP is 0 or not
  occurances in pbBigP of pbSmallOldP will be replaced with bytes taken from pbSmallNewP, byte for byte
 cbSmallP
  can be 0
  if 0 then pbSmallOldP is analyzed as a null terminated string to determine cbSmall
  if cbSmall, however determined, is 0 then nothing is done
  if cbSmall, however determined, is larger than cbBigP then nothing is done
*/
/**/

/*1*/countT etherC::memReplaceF( tinS& tinP , byteT* const pbBigP , const countT cbBigP , const byteT* const pbSmallOldP , const byteT* const pbSmallNewP , const countT cbSmallP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( pbBigP ) ;
        __Z( pbSmallOldP ) ;
        __Z( pbSmallNewP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    const countT cbSmall = cbSmallP ? cbSmallP : third.c_strlenIF( tinP , pbSmallOldP ) ;

    ZE( countT , cFound ) ;
    if( cbSmall && cbSmall <= cbBigP )
    {
        byteT* pbc = pbBigP ;
        byteT* pbe = pbBigP + cbBigP ;

        ZE( countT , offMatch ) ;
        while( !POOP && pbc < pbe )
        {
            if( *pbc == pbSmallOldP[ offMatch ] ) offMatch ++ ;
            else if( offMatch )                   offMatch = 0 ;

            if( offMatch == cbSmall )
            {
                offMatch = 0 ;
                cFound ++ ;

                for( countT off = 0 ; off < cbSmall ; off ++ )
                {
                    pbc[ off + 1 - cbSmall ] = pbSmallNewP[ off ] ;
                }
            }

            pbc ++ ;
        }
    }

    return cFound ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002110.etherc.memreplacef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002111.etherc.osmakehoverfilef BEGIN
#define DDNAME       "3func.36002111.etherc.osmakehoverfilef"
#define DDNUMB      (countT)0x36002111
#define IDFILE      (countT)0xd30


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osMakeHoverFileF.0.html\"\>instances\</A\>
\<A HREF=\"5.103014a.1.0.html\"\>definition\</A\>
U:for the specified master file, makes a hover file of wo of oo types
 the ze'st type is named using the idCopy value and its use list refers to idCopy names
 U: the wo'st type is named using the raw master name and its use list refers to raw master names
*/
/**/

/*1*/voidT etherC::osMakeHoverFileF( tinS& tinP , const countT cNameP , const boolT bRawNameP )/*1*/
{
    traceF( tinP , T("+") ) ;
    SCOOP
    IFbEcAREFUL
    {
        traceF( tinP , T("X") ) ;
        if( POOP ) return ;
        __Z( cNameP ) ;
        __NZ( bRawNameP ) ; //U:NOT YET SUPPORTED
        if( POOP ) return ;
        traceF( tinP , T("W") ) ;
    }

    _IO_

    traceF( tinP , T("osMakeHoverFileF /+") ) ;

    {
        traceF( tinP , T("V") ) ;
        batonC batUpdate( tinP , TAG( TAGiDnULL ) , T("ifc.update") , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) ;
        traceF( tinP , T("U") ) ;
        batUpdate.grabF( tinP , TAG( TAGiDnULL ) ) ;
        traceF( tinP , T("T") ) ;

        ZE( countT , cName ) ;
        traceF( tinP , T("S") ) ;
        switchC swIdCopy( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_null , cName ) ;
        traceF( tinP , T("R") ) ;
        batonC b_cName( tinP , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) ;
        traceF( tinP , T("Q") ) ;
        {
            traceF( tinP , T("P") ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            {
                traceF( tinP , T("O") ) ;
                //tinP.pc Utility[ 0 ] ++ ; //U:: TO FIND A BUG
                masterOldC master( tinP , *this , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) ) ;
                //tinP.pc Utility[ 0 ] -- ; //U:: TO FIND A BUG
                traceF( tinP , T("N") ) ;
                master.idCopyF( tinP , swIdCopy , cName , b_cName ) ;
                traceF( tinP , T("M") ) ;
            }
            THREADmODE1rESTORE
            traceF( tinP , T("L") ) ;
        }

        traceF( tinP , T("K") ) ;
        TN( tMaster , "" ) ; tMaster = T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/master/ideafarm.")+TF3(cNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(".ipdos-wm") ;

        ZE( byteT* , pbm ) ;
        ZE( countT , cbm ) ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        traceF( tinP , T("I") ) ;
        traceF( tinP , T("osMakeHoverFileF / reading master into memory [tMaster]:") ) ;
        traceF( tinP , tMaster ) ;
        {
            boxGetShadowF( tinP , pbm , cbm , tMaster , 1 ) ; ___( pbm ) ;
        }
        traceF( tinP , T("osMakeHoverFileF / read    master into memory [cbm]: ")+TF2(cbm,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        traceF( tinP , T("H") ) ;
        THREADmODE1rESTORE

        if( !POOP )
        {
            ZE( boolT , bModified ) ;
            ZE( imageExeDllC* , pInfo ) ;
            traceF( tinP , T("G") ) ;
            traceF( tinP , T("osMakeHoverFileF / getting image information") ) ;
            third.imageExeDllF( tinP , pInfo , pbm ) ; ___( pInfo ) ;
            traceF( tinP , T("osMakeHoverFileF / got     image information") ) ;
            traceF( tinP , T("F") ) ;
            if( pInfo )
            {
                traceF( tinP , T("E") ) ;
                if( pInfo->pSt_postDllUsed && *pInfo->pSt_postDllUsed )
                {
                    traceF( tinP , T("D") ) ;
                    TN( teMas , ".ipdos-wm" ) ;
                    handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    do
                    {
                        traceF( tinP , T("osMakeHoverFileF / looping to get dll names") ) ;
                        traceF( tinP , T("C") ) ;
                        osTextT* postMas = (osTextT*)pInfo->pSt_postDllUsed->downF( tinP , handle ) ;
                        TN( tMas , postMas ) ;

                        traceF( tinP , T("B") ) ;
                        countT idf = 1 ;
                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                        if( 0x12 == strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , teMas , tMas ) )
                        {
                            traceF( tinP , T("A") ) ;
                            countT idf = 0xa ;
                            countT idl = 0x11 ;
                            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                            ZE( strokeS* , psttw ) ;
                            strSubstringF( tinP , psttw , idf , idl , tMas ) ; ___( psttw ) ;
                            if( strIsDigitsF( tinP , psttw ) )
                            {
                                traceF( tinP , T("z") ) ;
                                cName = strDigitsToSCountF( tinP , psttw , 0 , 1 ) ;
                                if( cName )
                                {
                                    traceF( tinP , T("y") ) ;
                                    countT idCopy = swIdCopy ;
                                    if( idCopy )
                                    {
                                        traceF( tinP , T("x") ) ;
                                        ZE( strokeS* , psttw2 ) ;
                                        strMakeF( tinP , LF , psttw2 , T("ideafarm.")+TF3(idCopy,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(".ipdos-wd") ) ; ___( psttw2 ) ;
                                        ZE( osTextT* , postDll ) ;
                                        countT costDll = strMakeF( tinP , LF , postDll , psttw2 ) ; ___( postDll ) ;
                                        delF( tinP , psttw2 ) ;
                                        memCopyF( tinP , postMas , postDll , costDll ) ;
                                        delF( tinP , postDll ) ;
                                        traceF( tinP , T("w") ) ;
                                    }
                                }
                            }
                            delF( tinP , psttw ) ;
                        }
                    }
                    while( !POOP && ~handle ) ;
                }

                traceF( tinP , T("osMakeHoverFileF / inspecting !idCopy value in description") ) ;
                traceF( tinP , T("v") ) ;
                {
                    traceF( tinP , T("u") ) ;
                    osTextT postTag[] = "!idCopy" ;

                    traceF( tinP , T("t") ) ;
                    byteT* postPatch = thirdC::c_strstrIF( tinP , pInfo->postDescription , postTag ) ;
                    if( postPatch )
                    {
                        traceF( tinP , T("s") ) ;
                        postPatch += sizeof postTag ;

                        traceF( tinP , T("r") ) ;
                        if( !thirdC::c_memcmpIF( tinP , postPatch , "00000000000000000000000000000000" , sizeof( countT ) * 2 ) ) //A:ASSUME: sizeof( countT ) IS NOT GREATER THAN 01 BYTES
                        {
                            traceF( tinP , T("q1") ) ;
                            batonC bCopyLath( tinP , TAG( TAGiDnULL ) , "bCopyLath" ) ;
                            bCopyLath.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            traceF( tinP , T("q0") ) ;
                            //CS:CODEsYNC: DUPLICATE 33002111 33002134
                            TN( tLath , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/idCopyLath" ) ;
                            ZE( countT , idCopyLath ) ;
                            IFsCRATCH
                            {
                                traceF( tinP , T("p") ) ;
                                SCOOPS

                                ZE( byteT* , pbi ) ;
                                ZE( countT , cbi ) ;
                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                traceF( tinP , T("o") ) ;
                                tinP.pEtScratch->boxGetShadowF( tinP , pbi , cbi , tLath , 1 ) ; ___( pbi ) ;
                                traceF( tinP , T("n") ) ;
                                THREADmODE1rESTORE
                                traceF( tinP , T("m") ) ;
                                if( POOP ) { POOPR ; }
                                else if( cbi >= sizeof( countT ) ) idCopyLath = *(countT*)pbi ;
                                traceF( tinP , T("l") ) ;
                                delF( tinP , pbi ) ;
                                traceF( tinP , T("k") ) ;
                            }
                            idCopyLath ++ ;
                            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                            boxPutF( tinP , tLath , (byteT*)&idCopyLath , sizeof idCopyLath ) ;
                            THREADmODE1rESTORE
                            bCopyLath.ungrabF( tinP ) ;

                            thirdC::c_itoaIF( postPatch , idCopyLath , '0' ) ; //U::VERIFY THAT WILL DO UNSIGNED I.E. WILL WORK WHEN HIGH ORDER BIT IS USED
                            bModified = 1 ;
                        }
                    }
                }

                traceF( tinP , T("osMakeHoverFileF / setting idCopy") ) ;
                traceF( tinP , T("j") ) ;
                ZE( countT , idCopy ) ;
                {
                    traceF( tinP , T("i") ) ;
                    __( !pInfo->postDescription ) ;
                    ZE( strokeS* , pstt1w ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    strWordsOldF( tinP , pstt1w , T(pInfo->postDescription) , sttq ) ; ___( pstt1w ) ;
                    ZE( boolT , bNext ) ;
                    TN( tTag , "!idCopy" ) ;
                    traceF( tinP , T("h") ) ;
                    FORsTRINGSiN2( pstt1w )
                    {
                        if( bNext )
                        {
                            idCopy = strDigitsToSCountF( tinP , psttc2 ) ;
                            break ;
                        }
                        else if( !strCompareF( tinP , psttc2 , tTag ) ) bNext = 1 ;
                    }
                    traceF( tinP , T("g") ) ;
                    delF( tinP , pstt1w ) ;
                    traceF( tinP , T("f") ) ;
                }

                traceF( tinP , T("e") ) ;
                if( idCopy )
                {
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 8") ) ;
                    TN( tName , "" ) ;
                    tName = T("ideafarm.")+TF3(idCopy,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) + ( pInfo->bDll?T(".ipdos-wd") : T(".ipdos-we") ) ;
                    if( pInfo->postImageName ) memCopyF( tinP , pInfo->postImageName , tName , tName.csF( tinP ) ) ; //U::WHY IS THIS 0 STARTING TODAY? 2002.12.26

                    //THIS SMUDGING OF MessageBoxExA DATES BACK TO THE MID 1990'S SO MIGHT NOT BE NEEDED ANY LONGER
                    //IT ALSO PREDATES THE EXCEPTION HANDLING CODE WITHIN IPDOS (tm), WHICH MIGHT RENDER THE SMUDGING UNNECESSARY
                    //SMUDGE "\x00MessageBoxExA\x00Application Error:\x00" TO PREVENT WATCOM'S CODE FROM EMITTING A POPUP WHEN AN EXCEPTION OCCURS
                    //THIS REALLY ONLY NEEDS TO BE DONE FOR 0100002 0100003 (THE HOVER EXE FILES)

                    traceF( tinP , T("c") ) ;
                    byteT pbSmall1[] = { 'x' , 'M' , 'e' , 's' , 's' , 'a' , 'g' , 'e' , 'B' , 'o' , 'x' , 'E' , 'x' , 'A' , 0 } ;
                    //byteT pbSmall1[] = { 0 , 'M' , 'e' , 's' , 's' , 'a' , 'g' , 'e' , 'B' , 'o' , 'x' , 'E' , 'x' , 'A' , 0 , 'A' , 'p' , 'p' , 'l' , 'i' , 'c' , 'a' , 't' , 'i' , 'o' , 'n' , ' ' , 'E' , 'r' , 'r' , 'o' , 'r' , ':' , ' ' , 0 } ;
                    byteT pbSmall2[] = { 't' , 'h' , 'e' , ' ' , 'i' , 'n' , 's' , 't' , 'r' , 'u' , 'c' , 't' , 'i' , 'o' , 'n' , ' ' , 'a' , 't' , ' ' , '%' , '0' , '8' , 'l' , 'x' , ' ' , 'r' , 'e' , 'f' , 'e' , 'r' , 'e' , 'n' , 'c' , 'e' , 'd' , ' ' , 'm' , 'e' , 'm' , 'o' , 'r' , 'y' , ' ' , 'a' , 't' , ' ' , '%' , '0' , '8' , 'l' , 'x' } ;
                    byteT pbSmall3[] = { 't' , 'h' , 'e' , ' ' , 'p' , 'r' , 'o' , 'g' , 'r' , 'a' , 'm' , ' ' , 'e' , 'n' , 'c' , 'o' , 'u' , 'n' , 't' , 'e' , 'r' , 'e' , 'd' , ' ' , 'a' , ' ' , 'p' , 'r' , 'o' , 'b' , 'l' , 'e' , 'm' , ' ' , 'a' , 't' , ' ' , 'a' , 'd' , 'd' , 'r' , 'e' , 's' , 's' , ' ' , '%' , '0' , '8' , 'l' , 'x' , ' ' , 'a' , 'n' , 'd' , ' ' , 'c' , 'a' , 'n' , 'n' , 'o' , 't' , ' ' , 'c' , 'o' , 'n' , 't' , 'i' , 'n' , 'u' , 'e' } ;
                    byteT pbSmall4[] = ".:\\ideafarm.work\\backed.up.never\\gen\\" ;
                    byteT pbSmall5[] = ".:\\ideafarm.work\\backed.up.never\\gen\\" ;
                    byteT pbSmall6[] = "!postBaseName:ideafarm..1000001.ipdos-wm" ;
                    byteT pbSmall7[] = ".he instruction at %08lx referenced memory at %08lx\x0aThe memory could not be %s" ;
                    byteT pbSmall8[] = ".he program encountered a problem at address %08lx and cannot continue" ;
                    
                    *pbSmall1 = 0 ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall3 = *pbSmall2 = 'T' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall4 = 'D' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall5 = 'd' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    pbSmall6[ 0x17 ] = '8' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall7 = 'T' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall8 = 'T' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    
                    byteT* const pbe = pbm + cbm ;
                    
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 7") ) ;
                    traceF( tinP , T("b") ) ;
                    byteT* pbc = pbm ;
                    //traceF( tinP , T("\r\n") ) ;
                    while( pbc < pbe )
                    {
                        //CONoUTrAW3( "\r             \r3    " , pbe - pbc , "\r") ) ;
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall1 , sizeof pbSmall1 ) ;
                        if( pbc < pbe )
                        {
                            thirdC::c_memsetIF( tinP , pbc + 1 , sizeof pbSmall1 - 2 , FILLbYTE_HOVERfILEsMUDGE ) ;
                            pbc += sizeof pbSmall1 ;
                        }
                    }
                    //traceF( tinP , T("\r\n") ) ;
                    
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 6") ) ;
                    traceF( tinP , T("a") ) ;
                    pbc = pbm ;
                    while( pbc < pbe )
                    {
                        //CONoUTrAW3( "\r        \r2    " , pbe - pbc , "\r") ) ;
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall6 , sizeof pbSmall6 ) ;
                        if( pbc < pbe )
                        {
                            thirdC::c_memcpyIF( tinP , pbc + 0xe , tName , tName.csF( tinP ) ) ;
                            pbc += sizeof pbSmall6 ;
                        }
                    }
                    //traceF( tinP , T("\r\n") ) ;
                    
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 5") ) ;
                    traceF( tinP , T("9") ) ;
                    pbc = pbm ;
                    while( pbc < pbe )
                    {
                        //CONoUTrAW3( "\r        \r1    " , pbe - pbc , "\r") ) ;
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall7 , sizeof pbSmall7 ) ;
                        if( pbc < pbe )
                        {
                            *pbc = (byteT)0 ;
                            pbc += sizeof pbSmall7 ;
                        }
                    }
                    //traceF( tinP , T("\r\n") ) ;
                    
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 4") ) ;
                    traceF( tinP , T("8") ) ;
                    pbc = pbm ;
                    while( pbc < pbe )
                    {
                        //CONoUTrAW3( "\r        \r0    " , pbe - pbc , "\r") ) ;
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall8 , sizeof pbSmall8 ) ;
                        if( pbc < pbe )
                        {
                            *pbc = (byteT)0 ;
                            pbc += sizeof pbSmall8 ;
                        }
                    }
                    //traceF( tinP , T("\r\n") ) ;
                    
                    //U::
                    #if defined( NEVERdEFINED )
                    
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 3") ) ;
                    traceF( tinP , T("") ) ;
                    pbc = pbm ;
                    while( pbc < pbe )
                    {
                        //CONoUTrAW3( "\r        \r    " , pbe - pbc , "\r") ) ;
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall2 , sizeof pbSmall2 ) ;
                        if( pbc < pbe )
                        {
                            *pbc = 0 ;
                            pbc += sizeof pbSmall2 ;
                        }
                    }
                    //traceF( tinP , T("\r\n") ) ;
                    
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 2") ) ;
                    traceF( tinP , T("") ) ;
                    pbc = pbm ;
                    while( pbc < pbe )
                    {
                        //CONoUTrAW3( "\r        \r    " , pbe - pbc , "\r") ) ;
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall3 , sizeof pbSmall3 ) ;
                        if( pbc < pbe )
                        {
                            *pbc = 0 ;
                            pbc += sizeof pbSmall3 ;
                        }
                    }
                    //traceF( tinP , T("\r\n") ) ;
                    
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 1") ) ;
                    traceF( tinP , T("") ) ;
                    pbc = pbm ;
                    while( pbc < pbe )
                    {
                        //CONoUTrAW3( "\r        \r    " , pbe - pbc , "\r") ) ;
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall4 , sizeof pbSmall4 ) ;
                        if( pbc < pbe )
                        {
                            *pbc = 'C' ;
                            pbc += sizeof pbSmall4 ;
                        }
                    }
                    //traceF( tinP , T("\r\n") ) ;
                    
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 0") ) ;
                    traceF( tinP , T("") ) ;
                    pbc = pbm ;
                    while( pbc < pbe )
                    {
                        //CONoUTrAW3( "\r        \r    " , pbe - pbc , "\r") ) ;
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall5 , sizeof pbSmall5 ) ;
                        if( pbc < pbe )
                        {
                            *pbc = 'c' ;
                            pbc += sizeof pbSmall5 ;
                        }
                    }
                    //traceF( tinP , T("\r\n") ) ;

                    //U::
                    #endif

                    traceF( tinP , T("osMakeHoverFileF / writing hover file") ) ;
                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                    traceF( tinP , T("7") ) ;
                    TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/")+tName ;
                    traceF( tinP , T("osMakeHoverFileF / putting hover file [name]:    ")+tName ) ;
                    if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DEBUG ) )  //U:: "if(...)" TO FIND A BUG (STUDY WHY SOMETIMES BUILDING HOVERFILE OF MASTER DLL TAKES SO LONG)
                    {
                        boxPutF( tinP , tFile , pbm , cbm ) ;
                    }
                    traceF( tinP , T("osMakeHoverFileF / put     hover file [name]:    ")+tName ) ;
                    traceF( tinP , T("6") ) ;
                    traceF( tinP , T("osMakeHoverFileF / wrote hover file") ) ;
                    THREADmODE1rESTORE
                }
            }
            traceF( tinP , T("5") ) ;
            DEL( pInfo ) ;

            traceF( tinP , T("4") ) ;
            if( bModified )
            {
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                traceF( tinP , T("osMakeHoverFileF / writing master file") ) ;
                traceF( tinP , T("3") ) ;
                boxPutF( tinP , tMaster , pbm , cbm ) ;
                traceF( tinP , T("osMakeHoverFileF / wrote master file") ) ;
                traceF( tinP , T("2") ) ;
                THREADmODE1rESTORE
            }
        }

        traceF( tinP , T("1") ) ;
        delF( tinP , pbm ) ;

        traceF( tinP , T("0") ) ;
        batUpdate.ungrabF( tinP ) ;
    }

    traceF( tinP , T("osMakeHoverFileF /-") ) ;
    traceF( tinP , T("-") ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002111.etherc.osmakehoverfilef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002112.etherc.diskmapfilenamehoverf BEGIN
#define DDNAME       "3func.36002112.etherc.diskmapfilenamehoverf"
#define DDNUMB      (countT)0x36002112
#define IDFILE      (countT)0xd31


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskMapFileNameHoverF.0.html\"\>instances\</A\>
\<A HREF=\"5.103014b.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::diskMapFileNameHoverF( tinS& tinP , strokeS*& psttP , const strokeS* const psttRawP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( psttRawP ) ;
        if( POOP ) return ;
        __( psttRawP->idCaste != sc_PREFIXlENGTH ) ;
        if( POOP ) return ;
    }

    _IO_
    {
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;
        countT idh = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , T("/hover/ideafarm.") , psttRawP ) ;     // idf -> 01000020.ipdos-wm
        if( !idh ) { strMakeF( tinP , LF , psttP , psttRawP ) ; ___( psttP ) ; }
        else                                               //0              1
        {                                                  //123456789abcdef0123456789a
            //A:ASSUME: FILE NAME IS OF THIS FORM (EXAMPLE): ideafarm.51000fff.ipdos-wm
            const countT idlPart1 = idf - 1 ;
            const countT idfPart3 = idf + 8 ;
            const countT idlPart3 = idfPart3 + 8 ;

            ZE( countT , idCopy ) ;
            {
                countT idl = idf + 7 ;
                ZE( strokeS* , psttn ) ;
                strSubstringF( tinP , psttn , idf , idl , psttRawP ) ; ___( psttn ) ;
                countT cName = strDigitsToSCountF( tinP , psttn , 0 , 1 ) ;
                delF( tinP , psttn ) ;

                if( cName ) idCopy = ifcIdCopyF( tinP , cName ) ;
                else __1
            }

            idf = 1 ;
            countT idl = idlPart1 ;
            //sttq = ze ;
            ZE( strokeS* , psttw1 ) ;
            ZE( strokeS* , psttw3 ) ;
            strSubstringF( tinP , psttw1 , idf , idl , psttRawP ) ; ___( psttw1 ) ;
            idf = idfPart3 ;
            idl = idlPart3 ;
            strSubstringF( tinP , psttw3 , idf , idl , psttRawP ) ; ___( psttw3 ) ;

            strFuseF( tinP , psttP , T(psttw1)+TF3(idCopy,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(psttw3) ) ; ___( psttP ) ;

            delF( tinP , psttw1 ) ;
            delF( tinP , psttw3 ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002112.etherc.diskmapfilenamehoverf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002113.etherc.sockoptionbroadcastf BEGIN
#define DDNAME       "3func.36002113.etherc.sockoptionbroadcastf"
#define DDNUMB      (countT)0x36002113
#define IDFILE      (countT)0xd32


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockOptionBroadcastF.0.html\"\>instances\</A\>
\<A HREF=\"5.103014c.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::sockOptionBroadcastF( tinS& tinP , const handleC& handleP , const boolT bAllowP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_optionBroadcastF( tinP , handleP , bAllowP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002113.etherc.sockoptionbroadcastf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002114.etherc.sockoptionreuseaddressf BEGIN
#define DDNAME       "3func.36002114.etherc.sockoptionreuseaddressf"
#define DDNUMB      (countT)0x36002114
#define IDFILE      (countT)0xd33


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockOptionReuseAddressF.0.html\"\>instances\</A\>
\<A HREF=\"5.103014d.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::sockOptionReuseAddressF( tinS& tinP , const handleC& handleP , const boolT bAllowP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_optionReuseAddressF( tinP , handleP , bAllowP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002114.etherc.sockoptionreuseaddressf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002115.etherc.sockoptionsendnowf BEGIN
#define DDNAME       "3func.36002115.etherc.sockoptionsendnowf"
#define DDNUMB      (countT)0x36002115
#define IDFILE      (countT)0xd34


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockOptionSendNowF.0.html\"\>instances\</A\>
\<A HREF=\"5.103014e.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::sockOptionSendNowF( tinS& tinP , const handleC& handleP , const boolT bEnableP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_optionSendNowF( tinP , handleP , bEnableP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002115.etherc.sockoptionsendnowf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002116.etherc.sockwritef BEGIN
#define DDNAME       "3func.36002116.etherc.sockwritef"
#define DDNUMB      (countT)0x36002116
#define IDFILE      (countT)0xd35


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockWriteF.0.html\"\>instances\</A\>
\<A HREF=\"5.103014f.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::sockWriteF( tinS& tinP , handleC& handleP , const countT idPortP , const nicNameC nicNameP , const byteT* pbP , const countT cbP , const countT idModeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        __Z( pbP ) ;
        __( cbP > tinP.pAdamGlobal1->_thirdC_.cbDatagramMax ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_writeF( tinP , handleP , idPortP , nicNameP , pbP , cbP , idModeP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002116.etherc.sockwritef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002117.etherc.sockreadf BEGIN
#define DDNAME       "3func.36002117.etherc.sockreadf"
#define DDNUMB      (countT)0x36002117
#define IDFILE      (countT)0xd36


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockReadF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030150.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::sockReadF( tinS& tinP , byteT*& pbP , countT& cbP , countT& idPortP , nicNameC& nicNameP , handleC& handleP , const countT time1P , const sCountT time2P )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pbP ) ;
        __( cbP ) ;
        __( idPortP ) ;
        __( nicNameP ) ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_readF( tinP , pbP , cbP , idPortP , nicNameP , handleP , time1P , time2P ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002117.etherc.sockreadf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002118.etherc.sockstkcatchersf BEGIN
#define DDNAME       "3func.36002118.etherc.sockstkcatchersf"
#define DDNUMB      (countT)0x36002118
#define IDFILE      (countT)0xd37


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockStkCatchersF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030151.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/stackC& etherC::sockStkCatchersF( tinS& tinP )/*1*/
{
    if( tinP.fingerprint ) ;
    if( !tinP.pAdamGlobal1->_etherC_.pStkCatchers ) ;//TELLsYSc1( ifcIDtYPEtELLsYS_ERRORpsTcATCHERSiS0 )
    return *tinP.pAdamGlobal1->_etherC_.pStkCatchers ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002118.etherc.sockstkcatchersf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002119.etherc.sockacceptf BEGIN
#define DDNAME       "3func.36002119.etherc.sockacceptf"
#define DDNUMB      (countT)0x36002119
#define IDFILE      (countT)0xd38


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockAcceptF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030152.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::sockAcceptF( tinS& tinP , handleC& hClientP , countT& idPortP , nicNameC& nicNameP , const handleC& handleP , boolT& bRefuseP , const handleC* const phContextP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    sleepStartF( tinP ) ;
    third.s_acceptF( tinP , hClientP , idPortP , nicNameP , handleP , bRefuseP , phContextP ) ;
    sleepEndF( tinP ) ;

}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002119.etherc.sockacceptf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600211a.etherc.socknicnamef BEGIN
#define DDNAME       "3func.3600211a.etherc.socknicnamef"
#define DDNUMB      (countT)0x3600211a
#define IDFILE      (countT)0xd39


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockNicNameF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030153.1.0.html\"\>definition\</A\>
impotence will not occur if the domain name server replies "not found"
caller must verify that pNicNameP and cNicNameP are not ze before using pNicNameP
 only wo of these need be tested
*/
/**/

/*1*/voidT etherC::sockNicNameF( tinS& tinP , nicNameC*& pNicNameP , countT& cNicNameP , const strokeS* psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pNicNameP ) ;
        __( cNicNameP ) ;
        __( psttP && !psttP->idAdam ) ;
        if( POOP ) return ;
    }

    _IO_
    ZE( countT , idDisk ) ;
    ZE( boolT  , bNormal ) ;

    if( psttP && !strCompareF( tinP , psttP , T(WWWiDEAFARMcOM) ) ) //U: ELIMINATE THIS
    {
        nicNameC nicName ;
        ZE( strokeS* , psttv ) ;
        osEnvironmentVariableF( tinP , psttv , T("ifcNicNameCityCenter") ) ; ___( psttv ) ;
             if( psttv && !strCompareF( tinP , psttv , T("me" ) ) )                                     nicName = third.s_nicNameF( tinP ) ;
        else if( psttv && !strCompareF( tinP , psttv , T("lan") ) )                                     nicName = NICnAMEcITYcENTERlAN ;
        else if( ( idDisk = diskIdF( tinP , T("///c") ) , idDisk == IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 ) ) nicName = NICnAMEcITYcENTERlAN ;
        else bNormal = 1 ;
        delF( tinP , psttv ) ;

        if( !bNormal )
        {
            newF( tinP , LF , pNicNameP ) ; ___( pNicNameP ) ;
            if( pNicNameP )
            {
                *pNicNameP = nicName ;
                cNicNameP = 1 ;
            }
        }
    }
    else bNormal = 1 ;

    if( bNormal )
    {
        ZE( osTextT* , post ) ;
        if( psttP ) { strMakeF( tinP , LF , post , psttP ) ; ___( post ) ; }
        third.s_nicNameF( tinP , pNicNameP , cNicNameP , post ) ;
        third.delF( tinP , post ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600211a.etherc.socknicnamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600211b.etherc.filereadf BEGIN
#define DDNAME       "3func.3600211b.etherc.filereadf"
#define DDNUMB      (countT)0x3600211b
#define IDFILE      (countT)0xd3a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$fileReadF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030154.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::fileReadF( tinS& tinP , soulC& soulP , const handleC& handleP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.dosReadF( tinP , soulP , handleP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600211b.etherc.filereadf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600211c.etherc.filewritef BEGIN
#define DDNAME       "3func.3600211c.etherc.filewritef"
#define DDNUMB      (countT)0x3600211c
#define IDFILE      (countT)0xd3b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$fileWriteF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030155.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::fileWriteF( tinS& tinP , const handleC& handleP , soulC& soulP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.dosWriteF( tinP , handleP , soulP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600211c.etherc.filewritef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600211d.etherc.sockreadf BEGIN
#define DDNAME       "3func.3600211d.etherc.sockreadf"
#define DDNUMB      (countT)0x3600211d
#define IDFILE      (countT)0xd3c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockReadF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030156.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::sockReadF( tinS& tinP , soulC& soulP , handleC& handleP , const countT time1P , const sCountT time2P , const countT idModeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_readF( tinP , soulP , handleP , time1P , time2P , idModeP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600211d.etherc.sockreadf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600211e.etherc.sockwritef BEGIN
#define DDNAME       "3func.3600211e.etherc.sockwritef"
#define DDNUMB      (countT)0x3600211e
#define IDFILE      (countT)0xd3d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockWriteF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030157.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::sockWriteF( tinS& tinP , handleC& handleP , soulC& soulP , const countT idModeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_writeF( tinP , handleP , soulP , idModeP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600211e.etherc.sockwritef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002120.etherc.boxgetf BEGIN
#define DDNAME       "3func.36002120.etherc.boxgetf"
#define DDNUMB      (countT)0x36002120
#define IDFILE      (countT)0xd3e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
arguments
 psttP
  must not be 0
  may also be a string of strings
   the result is as if the caller called me repeatedly
  impotence behavior depends upon whether i am *tinP.pEtScratch
   if so, then i will try all listed file names and become impotent only if all file names fail
   else i will return immediately upon impotence
*/
/**//*1*/voidT etherC::boxGetF( tinS& tinP , soulC& soulP , const strokeS* const psttP , countT cOpenTriesP , const countT cZapTriesP , countT time1P , const sCountT time2P , const flagsT flagsOpenDetailsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    ETHERlIST1bEFOREwORK( psttP )
    boxC box( tinP , *this , psttc1 , 0 , 0 , 0 , cOpenTriesP , time1P , time2P , flagsOpenDetailsP ) ;
    if( !soulP.cFieldsF() ) box.getF( tinP , soulP ) ;
    box.zapF( tinP , cZapTriesP ) ;
    ETHERlIST2bEFOREoPTIONALbREAK
    ETHERlIST3aFTERoPTIONALbREAK
    __Z( soulP.cFieldsF() ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002120.etherc.boxgetf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002121.etherc.boxgetshadowf BEGIN
#define DDNAME       "3func.36002121.etherc.boxgetshadowf"
#define DDNUMB      (countT)0x36002121
#define IDFILE      (countT)0xd3f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
arguments
 psttP
  must not be 0
  may also be a string of strings
   the result is as if the caller called me repeatedly
  impotence behavior depends upon whether i am *tinP.pEtScratch
   if so, then i will try all listed file names and will become impotent only if all names fail
   else i will return immediately upon impotence
*/
/**/

/*1*/voidT etherC::boxGetShadowF( tinS& tinP , soulC& soulP , const strokeS* const psttP , countT cOpenTriesP , countT time1P , const sCountT time2P , const flagsT flagsOpenDetailsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    ETHERlIST1bEFOREwORK( psttP )
    boxC box( tinP , *this , psttc1 , 0 , 0 , 0 , cOpenTriesP , time1P , time2P , flagsOpenDetailsP ) ;
    if( !soulP.cFieldsF() ) box.getF( tinP , soulP ) ;
    ETHERlIST2bEFOREoPTIONALbREAK
    ETHERlIST3aFTERoPTIONALbREAK
    __Z( soulP.cFieldsF() ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002121.etherc.boxgetshadowf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002122.etherc.boxputf BEGIN
#define DDNAME       "3func.36002122.etherc.boxputf"
#define DDNUMB      (countT)0x36002122
#define IDFILE      (countT)0xd40


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
arguments
 psttP
  must not be 0
  may also be a string of strings
   the result is as if the caller called me repeatedly
  impotence behavior depends upon whether i am *tinP.pEtScratch
   if so, then i will try all listed file names and will become impotent only if all file names fail
   else i will return immediately upon impotence
*/
/**//*1*/voidT etherC::boxPutF( tinS& tinP , const strokeS* const psttP , soulC& soulP , countT cOpenTriesP , countT time1P , const sCountT time2P , const flagsT flagsOpenDetailsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    ETHERlIST1bEFOREwORK( psttP )
    boxC box( tinP , *this , psttc1 , ifcOPENaCCESS_W , ifcOPENhOW_nCeR , 0 , cOpenTriesP , time1P , time2P , flagsOpenDetailsP ) ;
    box.putF( tinP , soulP ) ;
    ETHERlIST2bEFOREoPTIONALbREAK
    ETHERlIST3aFTERoPTIONALbREAK
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002122.etherc.boxputf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002123.etherc.osclipboardreadf BEGIN
#define DDNAME       "3func.36002123.etherc.osclipboardreadf"
#define DDNUMB      (countT)0x36002123
#define IDFILE      (countT)0xd41


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osClipboardReadF.0.html\"\>instances\</A\>
\<A HREF=\"5.103015c.1.0.html\"\>definition\</A\>
queries the contents of the system clipboard
evaluates to the length of the returned string, excluding the null terminator
if no text is available on the clipboard, psttP remains 0, i evaluate to 0, and impotence does not occur
arguments
 tinP
 psttP
  must be 0
*/
/**/

/*1*/voidT etherC::osClipboardReadF( tinS& tinP , strokeS*& psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL    
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    ZE( osTextT* , posti ) ;
    third.osClipboardReadF( tinP , posti ) ; ___( posti ) ;
    if( posti ) { strMakeFromOsTextF( tinP , psttP , posti ) ; ___( psttP ) ; }
    delF( tinP , posti ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002123.etherc.osclipboardreadf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002124.etherc.osclipboardwritef BEGIN
#define DDNAME       "3func.36002124.etherc.osclipboardwritef"
#define DDNUMB      (countT)0x36002124
#define IDFILE      (countT)0xd42


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osClipboardWriteF.0.html\"\>instances\</A\>
\<A HREF=\"5.103015d.1.0.html\"\>definition\</A\>
replaces the contents of the system clipboard
arguments
 tinP
 psttP
  must not be 0
*/
/**/

/*1*/voidT etherC::osClipboardWriteF( tinS& tinP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL    
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    ZE( osTextT* , postx ) ;
    strMakeF( tinP , LF , postx , psttP ) ; ___( postx ) ;
    third.osClipboardWriteF( tinP , postx ) ;
    delF( tinP , postx ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002124.etherc.osclipboardwritef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002125.etherc.osclipboardflavorsf BEGIN
#define DDNAME       "3func.36002125.etherc.osclipboardflavorsf"
#define DDNUMB      (countT)0x36002125
#define IDFILE      (countT)0xd43


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osClipboardFlavorsF.0.html\"\>instances\</A\>
\<A HREF=\"5.103015e.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/countT etherC::osClipboardFlavorsF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL    
    {
        if( POOP ) return 0 ;
    }

    _IO_
    countT cFlavors = third.osClipboardFlavorsF( tinP ) ;

    return cFlavors ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002125.etherc.osclipboardflavorsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002126.etherc.osclipboardgrabf BEGIN
#define DDNAME       "3func.36002126.etherc.osclipboardgrabf"
#define DDNUMB      (countT)0x36002126
#define IDFILE      (countT)0xd44


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osClipboardGrabF.0.html\"\>instances\</A\>
\<A HREF=\"5.103015f.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::osClipboardGrabF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL    
    {
        if( POOP ) return ;
    }

    _IO_
    third.osClipboardGrabF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002126.etherc.osclipboardgrabf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002127.etherc.osclipboardletgof BEGIN
#define DDNAME       "3func.36002127.etherc.osclipboardletgof"
#define DDNUMB      (countT)0x36002127
#define IDFILE      (countT)0xd45


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osClipboardLetGoF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030160.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::osClipboardLetGoF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL    
    {
        if( POOP ) return ;
    }

    _IO_
    third.osClipboardLetGoF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002127.etherc.osclipboardletgof END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002128.etherc.operator_tins_ref BEGIN
#define DDNAME       "3func.36002128.etherc.operator_tins_ref"
#define DDNUMB      (countT)0x36002128
#define IDFILE      (countT)0xd46


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.1030163.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/etherC::operator tinS&( voidT )/*1*/
{
    //TINSL
    return thirdC::third_tinS_ref_IF() ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002128.etherc.operator_tins_ref END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002129.etherc.osdriverf BEGIN
#define DDNAME       "3func.36002129.etherc.osdriverf"
#define DDNUMB      (countT)0x36002129
#define IDFILE      (countT)0xd47


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osDriverF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030164.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
this function is not thread safe
it is illegal to call me more than 1 time per process
pseudocode
 get the service name, either from idAdamP or from homeS::homeIF
 if command line says to fire (and possibly remove) the service, then do so
 else do normal function
  gets status of the named driver
  if unknown: register; then do stopped
  if stopping: sleep till stopped; then do stopped
  if stopped: hire the driver; return
  if starting: attach to service control manager; return
  if started: return
arguments
 tinP
 idAdamP
  must not be 0
*/

/**/
/*1*/voidT etherC::osDriverF( tinS& tinP , const countT idAdamP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( idAdamP ) ;
        if( POOP ) return ;
    }

    _IO_

    TN( tDriverName , "" ) ;
    TN( tDriverDisplayName , "IdeaFarm " "(tm) City" ) ; //THIS DOES NOT WORK; WINDOWS CANNOT HANDLE NONUNIQUE DISPLAY NAMES
    TN( tDescription , postIPDOSsHORTlONG " <> http://ideafarm.com" ) ;
    ZE( strokeS* , psttExe ) ;
    ZE( boolT    , bFire ) ;
    ZE( boolT    , bRemove ) ;
    {
        ZE( strokeS* , psttDriverName ) ;
        TN( tFire   , "!fire" ) ;
        TN( tRemove , "!remove" ) ;
        TN( tName , "!name" ) ;
        
        ZE( countT , idArg ) ;
        FORsTRINGSiN1( ether_pstt1_processParametersI_F( tinP ) )
        {
            if( idArg )
            {
                switch( idArg )
                {
                    case 1 : { idArg = 0 ; strMakeF( tinP , LF , psttDriverName , psttc1 ) ; ___( psttc1 ) ; break ; }
                }
            }
            else if( !psttExe )                                { strConvertToLowerCaseF( tinP , psttExe , psttc1 ) ; ___( psttExe ) ; }
            else if( !strCompareF( tinP , psttc1 , tRemove ) ) bRemove = bFire = 1 ;
            else if( !strCompareF( tinP , psttc1 , tFire   ) )           bFire = 1 ;
            else if( !strCompareF( tinP , psttc1 , tName   ) )           idArg = 1 ;
        }

        if( !psttDriverName ) { osDriverNameFromMasterF( tinP , psttDriverName , idAdamP ) ; ___( psttDriverName ) ; }
        tDriverName = T(psttDriverName) ;
        delF( tinP , psttDriverName ) ;
    }

    etherC etp( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ; //U::MIGRATE THIS TO USING tinP.pEtScratch
    thirdC& thp = etp ;
    if( bFire )
    {
        thp.osDriverFireF( tinP , tDriverName ) ;
        thp = 0 ;
        if( bRemove )
        {
            thp.osDriverUnregisterF( tinP , tDriverName ) ;
            thp = 0 ;
        }
    }
    else
    {
        countT idState = third.osDriverStatusF( tinP , tDriverName ) ;

        ZE( boolT , bDispatch ) ;
        switch( idState )
        {
            case ifcDRIVERsTATUS_STARTED :
            {
                thp.osDriverUnregisterF( tinP , tDriverName ) ; //DONE WOTH BECAUSE FIRING MIGHT TIME OUT
                thp = 0 ;
                thp.osDriverFireF( tinP , tDriverName ) ;
                if( thp )
                {
                    thp = 0 ;
                    POPUP( T("Service ")+tDriverName+T(" installation could not be completed because the service is currently started and took too long to go away when I fired it.  Please wait a few seconds and try again.  See http://ideafarm.com .") ) ;
                    
                    break ;
                }

                //INTENTIONAL FALLTHROUGH
            }
            case ifcDRIVERsTATUS_UNKNOWN :
            {
                //DUPLICATE CODE: 1030164 1030164
                thp.osDriverRegisterF( tinP , tDriverName , tDriverName , tDescription , T(psttExe) ) ;
                if( thp )
                {
                    thp = 0 ;
                    thp.osDriverUnregisterF( tinP , tDriverName ) ;
                    POPUP( T("Service ")+tDriverName+T(" could not be installed.  Please see http://www.ideafarm.com .") ) ;
                    thp = 0 ;
                    __1
                    break ;
                }

                //INTENTIONAL FALLTHROUGH
            }
            case ifcDRIVERsTATUS_STOPPING :
            {
                if( idState == ifcDRIVERsTATUS_STOPPING )
                {
                    {
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        do
                        {
                            ++ s ; third.dosSleepIF( tinP , TUCK * 0x80 ) ;
                            idState = third.osDriverStatusF( tinP , tDriverName ) ;
                        }
                        while( !POOP && !third && idState == ifcDRIVERsTATUS_STOPPING ) ;
                    }
                    __( idState - ifcDRIVERsTATUS_STOPPED ) ;
                }

                //INTENTIONAL FALLTHROUGH
            }
            case ifcDRIVERsTATUS_STOPPED :
            {
                thp.osDriverHireF( tinP , tDriverName ) ;
                if( thp )
                {
                    thp = 0 ;
                    thp.osDriverUnregisterF( tinP , tDriverName ) ;
                    thp = 0 ;
                    POPUP( T("Service ")+tDriverName+T(" could not be hired.  It has been removed.  Please see http://www.ideafarm.com .") ) ;
                    //__1
                }
                break ;
            }
            case ifcDRIVERsTATUS_STARTING :
            {
                third.osDriverF( tinP , tDriverName ) ;
                break ;
            }
            default :
            {
                __( idState ) ;
                __1
                break ;
            }
        }
    }
    delF( tinP , psttExe ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002129.etherc.osdriverf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600212a.etherc.osdriverremoveoldf BEGIN
#define DDNAME       "3func.3600212a.etherc.osdriverremoveoldf"
#define DDNUMB      (countT)0x3600212a
#define IDFILE      (countT)0xd48


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//



/*
\<A HREF=\"6.$osDriverRemoveOldF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030165.1.0.html\"\>definition\</A\>
i evaluate to 1 iff i removed a currently working driver
it is illegal to refer to this symbol except in the definition of adam f040104
it is illegal to refer to this symbol except in the definition of the driver that is being fired
my purpose is to allow a new instance of a driver to fire the currently hired instance
after firing the old instance, and unregistering it, i store my driver's name in homeS::homeIF()
*/
/**/

/*1*/boolT etherC::osDriverRemoveOldF( tinS& tinP , const countT idAdamP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __( idAdamP != ifcIDaDAM_KERNEL2MONITOR && idAdamP != ifcIDaDAM_KERNEL1DRIVER ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( strokeS* , psttDriverName ) ;
    osDriverNameFromMasterF( tinP , psttDriverName , idAdamP ) ; ___( psttDriverName ) ;
    __( psttDriverName && CSdRIVERnAMEmAX < psttDriverName->idAdam ) ;

    ZE( boolT , bOldRemoved ) ;
    {
        homeS& home = homeS::homeIF() ;
        {
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            while( *home.postDriverNameOld ) { ++ s ; osSleepF( tinP , TUCK * 0x40 ) ; }
        }
        thirdC::c_strncpyIF( tinP , home.postDriverNameOld , home.postDriverNameNew , sizeof home.postDriverNameOld ) ;
        if( !POOP ) *home.postDriverNameNew = 0 ;

        if( *home.postDriverNameOld )
        {
            ZE( countT , idHomeOld ) ;
            ZE( countT , idAdamOld ) ;
            ZE( countT , idVersionOld ) ;
            osDriverParseNameF( tinP , idHomeOld , idAdamOld , idVersionOld , T(home.postDriverNameOld) ) ;

            ZE( countT , idHomeNew ) ;
            ZE( countT , idAdamNew ) ;
            ZE( countT , idVersionNew ) ;
            osDriverParseNameF( tinP , idHomeNew , idAdamNew , idVersionNew , psttDriverName ) ;

            if( idAdamOld == idAdamNew && idVersionOld != idVersionNew )
            {
                bOldRemoved = 1 ;
                thirdC thp( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ;
                thp.osDriverFireF(       tinP , home.postDriverNameOld ) ;
                thp = 0 ;
                thp.osDriverUnregisterF( tinP , home.postDriverNameOld ) ;
            }
        }

        if( !POOP ) *home.postDriverNameOld = 0 ;
        thirdC::c_strncpyIF( tinP , home.postDriverNameNew , T(psttDriverName) , sizeof home.postDriverNameNew ) ;
    }
    delF( tinP , psttDriverName ) ;
    return bOldRemoved ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600212a.etherc.osdriverremoveoldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600212b.etherc.strtof BEGIN
#define DDNAME       "3func.3600212b.etherc.strtof"
#define DDNUMB      (countT)0x3600212b
#define IDFILE      (countT)0xd49


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strToF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030166.1.0.html\"\>definition\</A\>
arguments
 tinP
 pcNameP
  must be 0
 psttNameP
  must not be 0
*/
/**/

/*1*/countT etherC::strToF( tinS& tinP , countT*& pcNameP , const strokeS* const psttNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( pcNameP ) ;
        __Z( psttNameP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    __( !psttNameP->idAdam ) ;
    ZE( countT , cWords ) ;
    if( !POOP )
    {
        boolT bOk = 1 ;
        countT offe = CSpREFIX + psttNameP->idAdam ;
        strokeS sDot = S1C('.') ;
        for( countT off = CSpREFIX ; off < offe ; off ++ )
        {
            if( !psttNameP[ off ].bDigitF() && psttNameP[ off ] != sDot )
            {
                bOk = 0 ;
                break ;
            }
        }

        if( bOk )
        {
            ZE( strokeS* , pstt1w ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            cWords = strWordsOldF( tinP , pstt1w , psttNameP , sttq , T(".") ) ;
            newF( tinP , LF , pcNameP , cWords + 1 ) ; ___( pcNameP ) ;
            if( pcNameP )
            {
                ZE( countT , off ) ;
                FORsTRINGSiN1( pstt1w )
                {
                    pcNameP[ off ++ ] = strDigitsToSCountF( tinP , psttc1 ) ;
                }
                pcNameP[ off ] = 0 ;
            }
        }
    }
    return cWords ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600212b.etherc.strtof END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600212d.etherc.ifcdrivenserverf BEGIN
#define DDNAME       "3func.3600212d.etherc.ifcdrivenserverf"
#define DDNUMB      (countT)0x3600212d
#define IDFILE      (countT)0xd4a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcDrivenServerF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030168.1.0.html\"\>definition\</A\>
provide me with a task definition and i will use it to serve the specified port
i do not return control to the calling thread until all sessions have ended
call me on the main thread, with bStateP true, to serve a port
before calling me on the main thread, launch other threads that call me with bStateP false, to serve ancillary ports
 example
  main thread serves port X, which is the primary duty of the calling adam
  thread 2 serves a private chat port, so that the calling adam can accept chat connections to receive commands and report results
arguments
 tinP
 pbdVaryingP
  must be 0
  during the execution of a tmFP thread, can be either 0 or nonze
   normally pbdVaryingP will be nonze and will point to cbdVaryingP bytes of state that the caller can use to record its current state
   during termination, pbStateP will be 0 and the caller must not attempt to access its state information
    during termination, state is frozen, handed off, and saved
    just before state is frozen, b_pbdVaryingP is grabbed and pbdVaryingP is reset to 0
  the protocol for accessing state is to grab the baton, test whether pbdVaryingP is 0, if not 0 access pbdVaryingP, and ungrab the baton
   0 indicates that the current process no longer "owns" the state of its adam class
   if 0 then the current process must not do anything that implies a change in the state of its adam class
   in other words, during termination a client session can continue to be served, but it must be "crippled" to prevent transactions that modify state
 pBat_pbdVaryingP
 bHandedOffP
  see stateC::stateC
 sgnIdPortReplacedP
  given each time that the value of idPortP changes, including its initial assignment and its final reset to 0
  is not given until immediately after a socket bound to the new idPort is set to listening mode
 tmFP
  must not be 0
  must conform to the current argument requirements (see adam.0140104 or another adam class that uses me)
  must be defined using the TASKdRIVENsERVER symbol
 idPortP
  must be 0
  will be set to the idPort assigned, which is guaranteed to initially be idPortHintP if the latter is not 0
  will be revised each time, if any, that the socket is replaced
  will be reset to 0 when i stop listening
 idPortHintP
  can be 0
  if 0 then a port will be assigned
 cSessionMaxP
  can be 0
  if 0 then connections will be refused (closed immediately after acceptance) if there are CsESSIONmAXdFLTiFCdRIVENsERVER sessions
 cArgP
  can be 0
  passed to tmFP and to translateStateFP
  i do not look at the value of cArgP
 time1graceP
  time after asynchronous impotence is detected before all client connections are aborted
  can be 0
  if -1 then i wait forever for client connections to close on their own
  else i wait time1graceP and then abort any connections that still exist
  this value, if not -1, is floored before use to the greatest nonupper multiple of TUCK * 04
  the new server, if any, is not told to start until all connections are gone
  when asynchronous impotence occurs, and for a short time afterward until my replacement starts, an attempted connection might fail or might be accepted and then canceled
 bStateP
  defaults to 1
  can be 0
  if not 0 then i will construct a stateC object
  if 0 then the remaining parameters must default
  only wo instance of me with bStateP can be called per process
 cbdVaryingP
 translateStateFP
  can be 0
  it is illegal for the definition of translateStateFP to store its pbToVaryingP parameter for later use by the caller
   see pbdVaryingP for a description of how the caller must access its state information
 psttSuffixP
  suffix for the state backing image
  normally should be 0
  used to give a distinct name so that multiple instances of the calling adam can coexist
   example: T("6a40104")
 stateBeginFP
  can be 0
  normally is 0
  if not 0 then is called immediately after stateC object is constructed
 stateEndFP
  can be 0
  normally is 0
  if not 0 then is called immediately before stateC object is destroyed
 recommended protocol
  server
   on asynch impotence, cancel all current sessions immediately by specifying time1graceP = 0
   if a hardcoded port is being served, use TASKdRIVENsERVERnEWsOCKET to switch each session to a new socket (bound to a dynamically allocated port)
    this will allow sessions started with an old instance to coexist with a new instance that has taken over service of the hardcoded port
    in this scenario, when a new instance is hired, it immediately becomes the listener for the hardcoded port
    the old instance continues to work until all of its client sessions have ended
  client
  clients
   retry connection establishment forever, or at least 01 times
   treat the session as a transaction
    do not commit results to permanent storage until the transaction has completed
    if the transaction fails, discard all uncommitted results, reconnect, and retry the connection at least 01 times, sleeping at least 04 tucks between each try
    let transaction failure data be captured, i.e. do not specify flTHIRDmODE_IMPOTENCEeXPECTED
   use multiple concurrent sessions whenever possible
*/
/**/

/*1*/voidT etherC::ifcDrivenServerF( tinS& tinP , serverInfo1S& info1P , serverInfo2S& info2P )/*1*/
{
    SCOOP

    IFbEcAREFUL
    {
        if( POOP ) return ;

        __(    F(tinP.flagsThreadMode2) & flTHREADmODE2_ADAMmAINtHREAD   &&    F(flagsMode) & flTHIRDmODE_TINoWNER   ) ; // THESE 2 CHECKS ENSURE etThread IS BEING USED (THIS LINE WILL DETECT THE USE OF etPrimeF() BUT WILL FAIL TO DETECT THE USE OF AN etherC OBJECT OTHER THAN ether AND etThread ON THREAD 1)
        __( !( F(tinP.flagsThreadMode2) & flTHREADmODE2_ADAMmAINtHREAD ) && !( F(flagsMode) & flTHIRDmODE_TINoWNER ) ) ; // THESE 2 CHECKS ENSURE etThread IS BEING USED

        __( F(flagsMode) & flTHIRDmODE_QUITTER ) ;
        __( F(flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) ;
        __( info1P.ppbdVarying && !!*info1P.ppbdVarying ) ;
        __( !info1P.tmF ) ;
        __( info1P.idPort ) ;
        __(  info2P.bState && tinP.pAdamGlobal1->_etherC_.cInServer ++ ) ;
        __( !info2P.bState && info2P.cbdVarying ) ;
        __( !info2P.bState && !!info2P.translateStateF ) ;
        __( !info2P.bState && !!info2P.psttSuffix ) ;
        if( POOP ) return ;
    }

    {
        _IO_

        const boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;
        const boolT bHttp    = info2P.idPortHint == ifcIDpORT_HTTP ;

        TELL( "server: setting up" )
        byteT pbSessions[ sizeof( sessionsC ) ] ;
        ZE( boolT , bDeleteSessions ) ;
        if( !info2P.pSessions )
        {
            new( 0 , tinP , pbSessions , sizeof pbSessions ) sessionsC( tinP , *this , TAG( TAGiDnULL ) ) ;
            bDeleteSessions = 1 ;
        }

        sessionsC& sessions = info2P.pSessions ? *info2P.pSessions : *(sessionsC*)pbSessions ;

        if( !info2P.cSessionMax ) info2P.cSessionMax = CsESSIONmAXdFLTiFCdRIVENsERVER ;
        //traceF( tinP , T("ifcDrivenServerF [cSessionMax]:    ")+TF2(info2P.cSessionMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        ZE( countT , cSession ) ;

        ZE( countT , lever_idSession ) ;
        switchC sw_pso( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , lever_idSession ) ;

        nicNameC lever_nnPeer ;
        switchC sw_cSessionWithPeer( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , lever_nnPeer ) ;

        stackC stJob( tinP , third , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_BLOB | flSTACKc_ALLOWzE | flSTACKc_GIVEsIGNnEWpLATE , sizeof( taskDrivenServerJobS ) , ifcIDgRABlAYER_7BASEmISC1 ) ;

        const countT cWorkersSave = info2P.cWorkers ;

        if( cWorkersSave )
        {
            countT cDo = cWorkersSave ;

            if( cDo == - 1 ) cDo = thirdC::osProcessorsIF( tinP ) ; //U:: DISTINCT BEHAVIOR FOR -1 -2 -3 ...

            traceF( tinP , T("ifcDrivenServerF / launching workers [cWorkers]:    ")+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            while( cDo -- )
            {
                ZE( countT , tid ) ;
                osThreadF( tinP , tid , info1P.tmF , 0 , flTHREADlAUNCH_SHOWpONY , 0 , (countT)&stJob ) ;
            }
        }

        ZE( countT , cNicNameMe ) ;
        ZE( nicNameC* , pNicNameMe ) ;
        IFsCRATCH
        {
            SCOOPS
            socketC::nicNameIF( tinP , *tinP.pEtScratch , pNicNameMe , cNicNameMe , 0/*T(postCRAFTWORKfACTORY".ideafarm.com")*/ ) ; ___( pNicNameMe ) ;
            __Z( pNicNameMe ) ;
            __Z( cNicNameMe ) ;
            if( POOP )
            {
                POOPRqUIET
                traceF( tinP , T("ifcDrivenServerF / i could not obtain my nicNameC's") ) ;
            }
        }
        __Z( cNicNameMe ) ;

        homeS& home = homeS::homeIF() ;

        TN( tb4 , "    " ) ;
        if( !POOP )
        {
            ZE( countT , idSessionLath ) ;
            //A: ZE( stateC* , pState ) ;
            if( info2P.bState )
            {
                //A: 20141130@1135: COMMENTED OUT AS PART OF ELIMINATION OF stateC
                //A:  TELL( "server: constructing state" )
                //A:  tinP.pAdamGlobal1->pTranslateStateCallerCBF = info2P.translateStateF ;
                //A:  pState = new( 0 , tinP , LF ) stateC( tinP , *this , info1P.bHandedOff , 0 , info2P.cbdVarying , translateStateDrivenServerF , info2P.cArg , info2P.psttSuffix ) ; ___( pState ) ;
                //A:  if( pState )
                //A:  {
                //A:      if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->grabF( tinP , TAG( TAGiDnULL ) ) ;
                //A:      info1P.ppbdVarying = (byteT**)&pState->pbdVarying ; //COMPILERbUG: WATCOM BARFS WITHOUT THE CAST
                //A:      if( info2P.stateBeginF ) (*info2P.stateBeginF)( tinP , *this , *info1P.ppbdVarying , info2P.cbdVarying , info2P.cArg ) ;
                //A:      if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->ungrabF( tinP ) ;
                //A:  }
            }

            //DUPLICATE CODE: 1030168 2540104
            TELL( "server: continuing to set up" )
            batonC b_pnnSilent( tinP , TAG( TAGiDnULL ) ) ;
            ZE( nicNameC* , pnnSilent ) ;
            ZE( countT    , cnnSilent ) ;

            ZE( count8S* , pc8tp ) ;
            newF( tinP , LF , pc8tp ) ; ___( pc8tp ) ;
            if( pc8tp )
            {
                pc8tp->c1 = (countT)&b_pnnSilent ;
                pc8tp->c2 = (countT)&pnnSilent ;
                pc8tp->c3 = (countT)&cnnSilent ;
                countT cArg_tmLoadSilent = (countT)pc8tp ;

                TELL( "server: launching thread tmLoadSilentF" )
                threadC th( tinP , *this , TAG( TAGiDnULL ) , tmLoadSilentF , cArg_tmLoadSilent , flTHREADlAUNCH_SHOWpONY ) ;
                ZE( countT , idAccept ) ;
                while( !info1P.bQuit )
                {
                    SCOOPS
                    TELL( "server: constructing listener socket" )

                    ZE( strokeS* , psttPemCertificates ) ;
                    ZE( strokeS* , psttPemPrivateKey   ) ;
                    if( F(info2P.flagsSocket) & flSOCKETc_CRYPTfOREIGNsSL )
                    {
                        // ACCESS WILL BE DENIED IF NOT RUN ELEVATED
                        strMakeF( tinP , LF , psttPemCertificates , T("///c/Certbot/live/ideafarm.com/fullchain.pem") ) ; ___( psttPemCertificates ) ;
                        strMakeF( tinP , LF , psttPemPrivateKey   , T("///c/Certbot/live/ideafarm.com/privkey.pem")   ) ; ___( psttPemPrivateKey   ) ;
                    }

                    ZE( socketC* , psoListen ) ;
                    IFsCRATCH
                    {
                        SCOOPS
                        psoListen = new( 0 , tinP , LF ) socketC( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , info2P.flagsSocket , &info1P.time1idleTimeoutRead , &info1P.time1idleTimeoutWrite , 0 , psttPemCertificates , psttPemPrivateKey ) ; ___( psoListen ) ;
                        if( POOP )
                        {
                            POOPRqUIET
                            DEL( psoListen ) ;
                            POOPRqUIET
                            traceF( tinP , T("ifcDrivenServerF / could not ct listener socket") ) ;
                        }
                    }
                    delF( tinP , psttPemCertificates ) ;
                    delF( tinP , psttPemPrivateKey   ) ;

                    if( psoListen )
                    {
                        IFsCRATCH
                        {
                            SCOOPS
                            if( info2P.psttName ) psoListen->nameF( tinP , info2P.psttName ) ;

                            if( !info1P.bQuit )
                            {
                                info1P.idPort = psoListen->bindF( tinP , info2P.idPortHint ) ;
                                psoListen->listenF( tinP ) ;
                                info1P.sgnIdPortReplaced.giveF( tinP ) ;
                            }   

                            if( !POOP ) traceF( tinP , T("ifcDrivenServerF / listener socket has been bound [idPort]:    ")+TF2(info1P.idPort,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            else
                            {
                                POOPRqUIET
                                DEL( psoListen ) ;
                                POOPRqUIET
                                traceF( tinP , T("ifcDrivenServerF / could not configure (name, bind, listen) listener socket") ) ;
                            }
                        }
                        //LOGrAW3( "listener socket has been bound to port [idPort]: " , info1P.idPort , "\r\n" ) ;

                        if( psoListen )
                        {
                            //THREADmODE4oN( flTHREADmODE4_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY )
                            ZE( countT , cAccepted ) ;
                            ZE( countT , cRefused ) ;
                            while( !info1P.bQuit && !POOP )
                            {
                                TELL( "server: beginning loop" )
                                ZE( socketC* , pso ) ;
                                //traceF( tinP , T("ifcDrivenServerF / inspecting [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                boolT bRefuse = info2P.cSessionMax <= cSession ;
                                bRefuse = 0 ; //U:: 20200907@1413 DISABLE ALL ATTACK DETECTION, WHICH WILL BE REWRITTEN AFTER STUDYING LOGS
                                if( bRefuse )
                                {
                                    ZE( countT  , timeN1 ) ;
                                    ZE( sCountT , timeN2 ) ;
                                    osTimeNowF( tinP , timeN1 , timeN2 ) ;
                                    TN( tSay , "" ) ; tSay = TT(timeN1,timeN2)+T("| ifcDrivenServerF/too many sessions, so will refuse the next connection attempt\r\n") ;
                                    LOGrAW( tSay ) ;

                                    //CS:CODEsYNC: 360021f7 3600212d
                                    traceF( tinP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                    traceF( tinP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                    traceF( tinP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                    traceF( tinP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                    traceF( tinP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                    traceF( tinP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                }

                                ZE( countT , idpPeer ) ;
                                nicNameC nnPeer ;
                                ZE( countT  , timeAccepted1 ) ;
                                ZE( sCountT , timeAccepted2 ) ;
                                ZE( countT , idPortWatchHttpDeadman1Snap ) ;
                                ZE( countT , idPortWatchHttpDeadman2Snap ) ;
                                TELL( "server: waiting for a client to connect" )
                                //traceF( tinP , T("ifcDrivenServerF / waiting for a client to connect") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                idAccept ++ ;
                                IFsCRATCH
                                {
                                    SCOOPS
                                    psoListen->acceptF( tinP , pso , idpPeer , nnPeer , bRefuse ) ; //IF ALL SESSIONS END WHILE BLOCKED HERE, WILL STILL REFUSE WO SESSION; THIS CAN BE FIXED BY FRESHING bRefuse AT END OF EACH SESSION THREAD IN DONEtMsERVER
                                    osTimeNowF( tinP , timeAccepted1 , timeAccepted2 ) ;
                                    //CONoUTrAW( "." ) ; //U:: TO FIND A BUG

                                    idPortWatchHttpDeadman1Snap = home.idPortWatchHttpDeadman1 ;
                                    idPortWatchHttpDeadman2Snap = home.idPortWatchHttpDeadman2 ;
                                    if( POOP )
                                    {
                                        POOPRqUIET
                                        DEL( psoListen ) ;
                                        POOPRqUIET

                                        traceF( tinP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                        //CS:CODEsYNC: 360021f7 3600212d
                                        traceF( tinP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                        traceF( tinP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                        traceF( tinP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                        traceF( tinP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                        traceF( tinP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                        traceF( tinP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;

                                        break ;
                                    }
                                }

                                boolT bLoopback = nnPeer.isLoopbackF() ;

                                ZE( boolT , bHeIsMe ) ;
                                for( countT offMe = 0 ; offMe < cNicNameMe ; offMe ++ )
                                {
                                    if( pNicNameMe[ offMe ] == nnPeer )
                                    {
                                        bHeIsMe = 1 ;
                                        break ;
                                    }
                                }

                                boolT bHeIsWatchDeadman1 = bHeIsMe && idpPeer == idPortWatchHttpDeadman1Snap ;
                                boolT bHeIsWatchDeadman2 = bHeIsMe && idpPeer == idPortWatchHttpDeadman2Snap ;

                                boolT bHeIsSpoofingMe = bHeIsMe && !bHeIsWatchDeadman1 && !bHeIsWatchDeadman2 ;

                                     if(  bHeIsSpoofingMe    ) traceF( tinP , T("ifcDrivenServerF / accepted i am being spoofed [idAccept,idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                else if(  bHeIsWatchDeadman1 ) traceF( tinP , T("ifcDrivenServerF / accepted from watch deadman1 [idAccept]:    "                                                                 )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                                                                                                                                                                                                                      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                else if(  bHeIsWatchDeadman2 ) traceF( tinP , T("ifcDrivenServerF / accepted from watch deadman2 [idAccept]:    "                                                                 )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                                                                                                                                                                                                                      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                else if(  bHeIsMe            ) traceF( tinP , T("ifcDrivenServerF / accepted from me host [idAccept]:    "                                                                        )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                                                                                                                                                                                                                      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                else if(  bLoopback          ) traceF( tinP , T("ifcDrivenServerF / accepted from loopback [idAccept]:    "                                                                       )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                                                                                                                                                                                                                      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                else                           traceF( tinP , T("ifcDrivenServerF / accepted from a host other than me [idAccept,nnPeer]:    "                                                    )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnPeer)                                                                                                                                                                                                        , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                if( bHeIsSpoofingMe )
                                {
                                    //CS:CODEsYNC: 360021f7 3600212d
                                    traceF( tinP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_2 ) ;
                                    traceF( tinP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_3 ) ;
                                    traceF( tinP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_4 ) ;
                                    traceF( tinP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_5 ) ;
                                    traceF( tinP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_6 ) ;
                                    traceF( tinP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_7 ) ;
                                }

                                if( bHeIsWatchDeadman1 ) traceF( tinP , T("ifcDrivenServerF / a client has connected"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                //traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / a client has connected") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                TELL( "server: a client has connected" )
                                ___( pso ) ;
                                //if( 0x401043a == processGlobal1I.idAdamRoot ) ifcSayIF( T("acceptF returned (1); nnPeer: ")+T(nnPeer)+T("; bRefuse: ")+TF1(bRefuse) , flSAY_APPEND | flSAY_LOG ) ;

                                boolT bSilent = bHeIsSpoofingMe ;
                                if( !bHeIsMe && !bSilent )
                                {
                                    b_pnnSilent.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                    for( countT off = 0 ; off < cnnSilent ; off ++ )
                                    {
                                        if( nnPeer == pnnSilent[ off ] )
                                        {
                                            bSilent = 1 ;

                                            //CS:CODEsYNC: 360021f7 3600212d
                                            traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                            traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                            traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                            traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                            traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                            traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;

                                            LOGrAW3( "peer is on the silence list [nnPeer]: " , nnPeer , "\r\n" ) ;
                                            break ;
                                        }
                                    }
                                    b_pnnSilent.ungrabF( tinP ) ;
                                }
                                //if( 0x401043a == processGlobal1I.idAdamRoot ) ifcSayIF( T("acceptF returned (2); bSilent: ")+TF1(bSilent) , flSAY_APPEND | flSAY_LOG ) ;

     //U:: 20200907@1413 DISABLE ALL ATTACK DETECTION, WHICH WILL BE REWRITTEN AFTER STUDYING LOGS
#if defined( NEVERdEFINED )
                                if( !bSilent )
                                {
                                    TlIST( tListHuman ) ;
                                    tListHuman += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(nnPeer) ;
                                    tListHuman += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(nnPeer) ;
                                    tListHuman += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(nnPeer) ;

                                    TlIST( tListAllowWoMore ) ;
                                    tListAllowWoMore += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(nnPeer) ;
                                    tListAllowWoMore += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(nnPeer) ;
                                    tListAllowWoMore += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(nnPeer) ;

                                    TlIST( tListBlock ) ;
                                    tListBlock += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(nnPeer) ;
                                    tListBlock += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(nnPeer) ;
                                    tListBlock += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(nnPeer) ;

                                    TlIST( tListWhite ) ;
                                    tListWhite += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(nnPeer) ;
                                    tListWhite += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(nnPeer) ;
                                    tListWhite += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(nnPeer) ;

                                    boolT bHuman = diskFileExistsF( tinP , tListHuman ) ;
                                    boolT bWhite = diskFileExistsF( tinP , tListWhite ) ;

                                    if( bHuman || bWhite )
                                    {
                                        IFsCRATCH
                                        {
                                            SCOOPS
                                            tinP.pEtScratch->boxZapF( tinP , tListAllowWoMore , 1 ) ; if( POOP ) { POOPR }
                                            tinP.pEtScratch->boxZapF( tinP , tListBlock       , 1 ) ; if( POOP ) { POOPR }
                                        }
                                    }
                                    else
                                    {
                                        bSilent = diskFileExistsF( tinP , tListBlock ) ;

                                        if( !bSilent )
                                        {
                                            IFsCRATCH
                                            {
                                                SCOOPS
                                                tinP.pEtScratch->diskMoveFileOrDirF( tinP , tListBlock , tListAllowWoMore , 1 ) ;
                                                if( POOP ) { POOPR }
                                            }
                                        }
                                    }
                                }
#endif

                                bRefuse = 0 ; //U:: 20200907@1413 DISABLE ALL ATTACK DETECTION, WHICH WILL BE REWRITTEN AFTER STUDYING LOGS
                                if( bRefuse ) { LOGrAW( "refusing a client\r\n" ) ; }
                                ( bRefuse || bSilent ? cRefused : cAccepted ) ++ ;

                                //U::EXCLUDE ZOMBIE SESSIONS FROM THE COUNT, SO HTTP CLIENT CAN INITIATE AN ARBITRARILY LONG BURST OF SESSIONS TO GET E.G. ALL IMAGES FOR A PAGE
                                TELL( "server: detecting dos attack client" )
                                sw_cSessionWithPeer.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                lever_nnPeer = nnPeer ;

                                {
                                    countT cSession = sw_cSessionWithPeer ;
                                    if( bHeIsWatchDeadman1 ) traceF( tinP , T("ifcDrivenServerF / checking session count with this nnPeer [cSessionMax,cSession]:    ")+TF2(info2P.cSessionMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                    if( 0x10 < cSession )
                                    {
                                        if( bHeIsWatchDeadman1 ) traceF( tinP , T("ifcDrivenServerF / setting bSilent (too many sessions with this nnPeer)"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                        bSilent |= 1 ; //TO PREVENT WO PEER FROM OPENING MANY SESSIONS TO DOS ATTACK
                                    }
                                }

                                sw_cSessionWithPeer.ungrabF( tinP ) ;

                                if( info1P.bQuit || third || bSilent || POOP )
                                {
                                    if( bHeIsWatchDeadman1 ) traceF( tinP , T("ifcDrivenServerF / deleting accepted socket without serving it"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                    //CS:CODEsYNC: 360021f7 3600212d
                                    traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / deleting accepted socket without serving it (bQuit | third | bSilent | POOP)") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_2 ) ;
                                    traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / deleting accepted socket without serving it (bQuit | third | bSilent | POOP)") , flTRACE_null     , ifcIDtRACEdIVERT_3 ) ;
                                    traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / deleting accepted socket without serving it (bQuit | third | bSilent | POOP)") , flTRACE_null     , ifcIDtRACEdIVERT_4 ) ;
                                    traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / deleting accepted socket without serving it (bQuit | third | bSilent | POOP)") , flTRACE_null     , ifcIDtRACEdIVERT_5 ) ;
                                    traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / deleting accepted socket without serving it (bQuit | third | bSilent | POOP)") , flTRACE_null     , ifcIDtRACEdIVERT_6 ) ;
                                    traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / deleting accepted socket without serving it (bQuit | third | bSilent | POOP)") , flTRACE_null     , ifcIDtRACEdIVERT_7 ) ;

                                    TELL( "server: deleting the accepted socket without serving it" )
                                    DEL( pso ) ;
                                }
                                else if( pso )
                                {
                                    if( bHeIsWatchDeadman1 ) traceF( tinP , T("ifcDrivenServerF / counting this new session"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                    //traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / preparing to serve this client") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                    TELL( "server: preparing to serve the accepted socket" )
                                    sw_pso.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                    lever_idSession = ++ idSessionLath ;
                                    sw_pso = (countT)pso ;
                                    sw_pso.ungrabF( tinP ) ;

                                    sw_cSessionWithPeer.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                    if( sw_cSessionWithPeer.cFlavorsF( tinP ) > TUCK ) sw_cSessionWithPeer.freeAllF( tinP ) ;
                                    lever_nnPeer = nnPeer ;
                                    ++ sw_cSessionWithPeer ;
                                    sw_cSessionWithPeer.ungrabF( tinP ) ;

                                    //if( 0x401043a == processGlobal1I.idAdamRoot ) ifcSayIF( T("about to launch service thread: third is ")+T(third?"IMPOTENT":"potent") , flSAY_APPEND | flSAY_LOG ) ;
                                    if( !POOP ) inc02AM( cSession ) ;

                                    ZE( countT  , timeJobCreated1 ) ;
                                    ZE( sCountT , timeJobCreated2 ) ;
                                    osTimeNowF( tinP , timeJobCreated1 , timeJobCreated2 ) ;

                                    if( cWorkersSave )
                                    {
                                        if( bHeIsWatchDeadman1 ) traceF( tinP , T("ifcDrivenServerF / pushing a job"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                        //taskDrivenServerJobS fooDebug1( idSessionLath , pso , lever_idSession , sw_pso , cSession , info2P.cArg , lever_nnPeer , sw_cSessionWithPeer , sessions , nnPeer ) ;

                                        stJob.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                        stJob << (byteT*)0 ;
                                        new( 0 , tinP , (byteT*)&(countT&)stJob[ - 1 ] , sizeof( taskDrivenServerJobS ) ) taskDrivenServerJobS( idSessionLath , lever_idSession , sw_pso , cSession , info2P.cArg , lever_nnPeer , sw_cSessionWithPeer , sessions , nnPeer , timeAccepted1 , timeAccepted2 , timeJobCreated1 , timeJobCreated2 ) ;

                                        //taskDrivenServerJobS jobCopy = *(taskDrivenServerJobS*)&(countT&)stJob[ - 1 ] ; //U:: TO FIND A BUG
                                        //traceF( tinP , T("ifcDrivenServerF pushed a job [jobCopy[2]]:    ")+TF2(((countT*)&jobCopy)[2],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                        //byteT* pbTop = (byteT*)&(countT&)stJob[ 1 ] ;
                                        //new( 0 , tinP , pbTop , sizeof( taskDrivenServerJobS ) ) taskDrivenServerJobS( idSessionLath , pso , lever_idSession , sw_pso , cSession , info2P.cArg , lever_nnPeer , sw_cSessionWithPeer , sessions , nnPeer ) ;
                                        //taskDrivenServerJobS& fooDebug2 = *(taskDrivenServerJobS*)pbTop ;

                                        //taskDrivenServerJobS& jobMe = *(taskDrivenServerJobS*)&(countT&)stJob[ 1 ] ; //U:: TO FIND A BUG

                                        stJob.ungrabF( tinP ) ;
                                    }
                                    else
                                    {
                                        if( bHeIsWatchDeadman1 ) traceF( tinP , T("ifcDrivenServerF / launching a job thread"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                        taskDrivenServerJobS* pJob = new( 0 , tinP , LF ) taskDrivenServerJobS( idSessionLath , lever_idSession , sw_pso , cSession , info2P.cArg , lever_nnPeer , sw_cSessionWithPeer , sessions , nnPeer , timeAccepted1 , timeAccepted2 , timeJobCreated1 , timeJobCreated2 ) ; ___( pJob ) ;

                                        if( pJob )
                                        {
                                            TELL( "server: launching server thread for this client" )
                                            //traceF( tinP , T(nnPeer)+T("    ifcDrivenServerF / launching server thread for this client") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                            ZE( countT , tid ) ; tinP.pEtScratch->osThreadF( tinP , tid , info1P.tmF , 0 , flTHREADlAUNCH_SHOWpONY , 0 , (countT)&stJob , (countT)pJob ) ;

                                            if( POOP )
                                            {
                                                POOPR

                                                //CS:CODEsYNC: 360021f7 3600212d
                                                traceF( tinP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                traceF( tinP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                traceF( tinP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                traceF( tinP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                traceF( tinP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                traceF( tinP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                            }
                                            else
                                            {
                                                //CS:CODEsYNC: 360021f7 3600212d
                                                //traceF( tinP , T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                //traceF( tinP , T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                //traceF( tinP , T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                //traceF( tinP , T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                //traceF( tinP , T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                //traceF( tinP , T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                            }
                                        }
                                        else
                                        {
                                            //CS:CODEsYNC: 360021f7 3600212d
                                            traceF( tinP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                            traceF( tinP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                            traceF( tinP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                            traceF( tinP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                            traceF( tinP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                            traceF( tinP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                        }
                                    }
                                }
                            }
                            //THREADmODE4rESTORE
                        }
                    }

                    info1P.idPort = 0 ;
                    TELL( "server: destroying listener socket" )
                    IFsCRATCH
                    {
                        SCOOPS
                        DEL( psoListen ) ;
                        if( POOP )
                        {
                            POOPRqUIET
                            traceF( tinP , T("ifcDrivenServerF / could not dt listener socket") ) ;
                        }
                    }
                }

                TELL( "server: cleaning up" )
                info1P.sgnIdPortReplaced.giveF( tinP ) ;
            }

            //if( pState )
            {
                //A: 20141130@1135: COMMENTED OUT AS PART OF ELIMINATION OF stateC
                //A:  if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->grabF( tinP , TAG( TAGiDnULL ) ) ;
                //A:  if( info2P.stateEndF ) (*info2P.stateEndF)( tinP , *this , *info1P.ppbdVarying , info2P.cbdVarying , info2P.cArg ) ;
                //A:  *info1P.ppbdVarying = 0 ; //U::BUG: MIGRATED FROM pbdVarying WITHOUT ADEQUATE STUDY; THIS FUNCTION COULD CONTAIN A BUG IN CODE HANDLING THIS MEMBER
                //A:  info1P.ppbdVarying = 0 ;
                //A:  THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                //A:  DEL( pState ) ;
                //A:  THREADmODE1rESTORE
            }

            if( info2P.bState ) if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->ungrabF( tinP ) ;

            if( info2P.time1grace == - 1 )
            {
                TELL( "server: will wait forever until cSession is 0" )
                {
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    while( cSession ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
                }
            }
            else if( info2P.time1grace )
            {
                countT cTries = 0x10 ;
                countT time1nap = info2P.time1grace / cTries ;
                while( time1nap < TUCK * 0x40 && cTries > 1 )
                {
                    cTries >>= 1 ;
                    time1nap = info2P.time1grace / cTries ;
                }

                TELL( "server: will wait for a while to see cSession = 0" )
                {
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    while( cSession && cTries -- ) { ++ s ; thirdC::dosSleepIF( tinP , time1nap ) ; }
                }
            }

            sw_pso.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
                countT cFlavors = sw_pso.cFlavorsF( tinP ) ;
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                {
                    lever_idSession = sw_pso.leverF( tinP , idf ) ;
                    socketC*& pso = (socketC*&)(countT&)sw_pso ;
                    if( pso )
                    {
                        TELL( "server: canceling a client session" )
                        const handleC& hSoc = pso->handleF( tinP ) ;
                        //{
                        //    const osTextT poste[] = "ifcDrivenServerF: canceling a client session because i am quitting" ;
                        //    thirdC::dosTellMonitorIF( tinP , tellC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEtELLsYS_LOG , poste , sizeof poste ) , ifcIDbOOKStELL_SYS ) ;
                        //}
                        SCOOPS
                        tinP.pEtScratch->sockCancelF( tinP , hSoc ) ;
                        if( POOP ) POOPR
                    }
                }
            }
            sw_pso.ungrabF( tinP ) ;

            TELL( "server: final wait (forever) for all sessions to end" )
            {
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                while( cSession ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
            }

            if( bDeleteSessions )
            {
                sessionsC* pzSessions = (sessionsC*)pbSessions ;
                DELzOMBIE( pzSessions ) ;
            }
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600212d.etherc.ifcdrivenserverf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600212e.etherc.osfiref BEGIN
#define DDNAME       "3func.3600212e.etherc.osfiref"
#define DDNUMB      (countT)0x3600212e
#define IDFILE      (countT)0xd4b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osFireF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030169.1.0.html\"\>definition\</A\>
*/
/**//*1*/voidT etherC::osFireF( tinS& tinP , const boolT bDoNotComeBackP , const nicNameC nicNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    if( nicNameP == nicNameC() ) third.osFireIF( tinP , bDoNotComeBackP ) ;
    else
    {
        ZE( countT , idPortChat2 ) ;
        {
            soulC soulo( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_NEWsOCKET ) ;

            socketC sChat( tinP , *this , TAG( TAGiDnULL ) ) ;
            sChat.connectF( tinP , ifcPORToLD2_CHAT , nicNameP ) ;
            sChat.writeF( tinP , soulo ) ;

            soulC souli( tinP , TAG( TAGiDnULL ) ) ;
            sChat.readF( tinP , souli ) ;
            ZE( countT , idReply ) ;
            souli >> idReply ;
            __( idReply - ifcIDcMDsESSION_NEWsOCKETrEPLY ) ;
            souli >> idPortChat2 ;
        }

        socketC sChat2( tinP , *this , TAG( TAGiDnULL ) ) ;
        sChat2.connectF( tinP , idPortChat2 , nicNameP ) ;

        soulC soulo2( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_REBOOT ) ;
        sChat2.writeF( tinP , soulo2 ) ;

        soulC souli2( tinP , TAG( TAGiDnULL ) ) ;
        sChat2.readF( tinP , souli2 ) ;

        ZE( countT , idReply ) ;
        souli2 >> idReply ;
        __( idReply - ifcIDcMDsESSION_REBOOTrEPLY ) ;

        soulC soulb( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_BYE ) ;
        sChat2.writeF( tinP , soulb ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600212e.etherc.osfiref END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600212f.etherc.osmessageboxf BEGIN
#define DDNAME       "3func.3600212f.etherc.osmessageboxf"
#define DDNUMB      (countT)0x3600212f
#define IDFILE      (countT)0xd4c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osMessageBoxF.0.html\"\>instances\</A\>
\<A HREF=\"5.103016a.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/countT etherC::osMessageBoxF( tinS& tinP , const strokeS* const psttP , const strokeS* const psttTitleP , const flagsT flagsButtonsP , const flagsT flagButtonSelectedP )/*1*/
{
    SCOOP
    _IO_
    countT rc = third.osMessageBoxIF( tinP , T(psttP) , T(psttTitleP) , flagsButtonsP , flagButtonSelectedP ) ;
    return rc ;
}

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600212f.etherc.osmessageboxf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002130.etherc.osdrivernamefrommasterf BEGIN
#define DDNAME       "3func.36002130.etherc.osdrivernamefrommasterf"
#define DDNUMB      (countT)0x36002130
#define IDFILE      (countT)0xd4d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osDriverNameFromMasterF.0.html\"\>instances\</A\>
\<A HREF=\"5.103016d.1.0.html\"\>definition\</A\>
arguments
 tinP
 psttP
  must be 0
 idAdamP
  must not be 0
*/
/**/

/*1*/voidT etherC::osDriverNameFromMasterF( tinS& tinP , strokeS*& psttP , const countT idAdamP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( idAdamP ) ;
        if( POOP ) return ;
    }

    _IO_

    IFsCRATCH
    {
        ZE( countT , idCopy ) ;
        {
            SCOOPS
            {
                masterOldC master( tinP , *tinP.pEtScratch , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) ) ;
                idCopy = master.idCopyF( tinP , idAdamP ) ;
            }
            if( POOP ) POOPR

            if( !idCopy )
            {
                masterOldC master( tinP , *tinP.pEtScratch , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) , 0 , 1 ) ;
                idCopy = master.idCopyF( tinP , idAdamP ) ;
            }
            if( POOP ) POOPR
        }
        if( !idCopy ) { __( idAdamP ) ; __1 }
    
        const countT idHomeDisk = ifc_idHomeIdisk_IF() ;
        strFuseF( tinP , psttP , T("IdeaFarm.H")+TF1(idHomeDisk)+T(".A")+TF1(idAdamP)+T(".V")+TF1(idCopy) ) ; ___( psttP ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002130.etherc.osdrivernamefrommasterf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002131.etherc.ifchiref BEGIN
#define DDNAME       "3func.36002131.etherc.ifchiref"
#define DDNUMB      (countT)0x36002131
#define IDFILE      (countT)0xd4e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcHireF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030170.1.0.html\"\>definition\</A\>
arguments
 tinP
 psttOldCommentP
  must not be 0 and must not be null length
  should be an informative short title for the current job
  can be made unique by including time
  place the most unique and important words woth, as reports will truncate
  this title or comment is intended to facilitate debugging of ifc chat and can appear on ifc chat logs and console displays
 idAdamP
  must not be 0
 psttArgsP
  can be 0
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010160.flHIRE!||
 time1LimitP
 time2LimitP
 cTriesP
 nicNameP
  defaults to nicNameC(), which implies the local host
*/
/**/

/*1*/countT etherC::ifcHireF( tinS& tinP , const strokeS* const psttOldCommentP , const countT idAdamP , const strokeS* const psttArgsP , flagsT flagsP , const countT time1LimitP , const sCountT time2LimitP , const countT cTriesP , nicNameC nicNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( idAdamP ) ;
        __Z( psttOldCommentP ) ;
        FV( flHIRE , flagsP ) ;
        if( POOP ) return 0 ;
        __( !psttOldCommentP->idAdam ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    //flagsP |= flHIRE_DEBUG ; //TO FIND A BUG

    ZE( countT , idDeathType ) ;
    //U:: TO FIND A BUG: if( !( F(thirdC::third_flagsModeProcess2I_IF( tinP )) & flMODEpROCESS2_DEBUG ) )
    {
        if( idAdamP == ifcIDaDAM_SMUDGEsOIXLoLDdEFS ) //U:: REMOVE AFTER TESTING FULL BUILD
        {
            CONoUTrAW( "I am trying to hire ifcIDaDAM_SMUDGEsOIXLoLDdEFS!" ) ;
            POPUP( "I am trying to hire ifcIDaDAM_SMUDGEsOIXLoLDdEFS!" ) ;
        }

        if( /*tinP.pAdamGlobal1->idSerialAdam == 1 &&*/ !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DOnOThIREaDAMS ) ) // SUPPRESSED FOR IN PROCESS KID ADAMS IN ORDER TO MAKE IT EASY TO SWITCH A SYSTEM'S RECONFIGURATON FROM SINGLEPROCESS TO MULTIPROCESS
        {
            handleC hDll( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DLL ) ; //LEAVE THIS OPEN UNTIL AFTER osSessionF/osProcessF RETURNS, SO BASE OS DOES NOT LOAD IT 2 TIMES
        
            if( F(flagsP) & flHIRE_DISPLAYaUTO )
            {
                flagsP &= flHIRE_WAIT ;
                TN( tDebug , "" ) ;
                TN( tDisplay , "" ) ;
                dllOpenF( tinP , hDll , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.")+TF3(idAdamP,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(".ipdos-wd") ) ;
                ZE( peekFT , pPeekF ) ;
                dllEntryF( tinP , pPeekF , hDll , T("peekF") ) ;
                __Z( pPeekF ) ;
                if( pPeekF )
                {
                    peekS info1( tinP , *this , T("!debug") ) ;
                    peekS info2( tinP , *this , T("!display") ) ;
        
                    (*pPeekF)( &info1 ) ;
                    (*pPeekF)( &info2 ) ;
                    tDebug   = T(info1.psttDirectivesReplied) ;
                    tDisplay = T(info2.psttDirectivesReplied) ;
        
                         if( !strCompareF( tinP , tDebug   , T("yes"    ) ) ) flagsP |= flHIRE_DEBUG           ;
                         if( !strCompareF( tinP , tDisplay , T("strokes") ) ) flagsP |= flHIRE_DISPLAYgRAPHICS ;
                    else if( !strCompareF( tinP , tDisplay , T("text"   ) ) ) flagsP |= flHIRE_DISPLAYtEXT     ;
                    else if( !strCompareF( tinP , tDisplay , T("none"   ) ) ) flagsP |= flHIRE_DISPLAYnONE     ;
        
                    //flagsP |= flHIRE_DEBUG ;            // DISABLE IN PRODUCTION.  ENABLE TO ALWAYS HIRE USING wdw
        
                    if
                    (
                        ( F(flagsP) & flHIRE_DEBUG )
                        &&
                        (
                            !( processGlobal1I.idHome & 0xff000000 )
                            // ||
                            // (
                            //     idAdamP == ifcIDaDAM_SUPERrANDOMnUMBERS
                            //     &&
                            //     ( processGlobal1I.idHome & 0x00ffffff ) != 2
                            // )
                        )
                    )
                    flagsP &= ~( F(flHIRE_DEBUG) ) ;
                }
            }
        
            flagsT flProcessHire = F(flagsP) & flHIRE_DISPLAYnONE ? flPROCESShIRE_null : flPROCESShIRE_VISIBLE ;
        
            //if( idAdamP == ifcIDaDAM_KERNEL3BANG   && processGlobal1I.idHome != 2 && processGlobal1I.idHome != 3 ) flProcessHire &= ~( F(flPROCESShIRE_VISIBLE) ) ;
            //if( idAdamP == ifcIDaDAM_SECRETsERVICE                 && processGlobal1I.idHome != 3 ) flProcessHire &= ~( F(flPROCESShIRE_VISIBLE) ) ;
        
            TN( tPostscript , "" ) ; //NORMALLY NULL STRING; CONVENIENT FOR DEBUGGING
            if( F(flagsP) & flHIRE_DEBUG )
            {
                ZE( strokeS* , psttMapped ) ;
                {
                    ZE( strokeS* , psttm ) ;
                    if( F(flagsP) & flHIRE_DISPLAYgRAPHICS ) { diskMapFileNameF( tinP , psttm , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.41000003.ipdos-we") ) ; ___( psttm ) ; }
                    else                                     { diskMapFileNameF( tinP , psttm , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.41000002.ipdos-we") ) ; ___( psttm ) ; }
                    diskMapFileNameHoverF( tinP , psttMapped , psttm ) ; ___( psttMapped ) ;
                    delF( tinP , psttm ) ;
                }
                osFileNameC osfn( tinP , *this , T(psttMapped) ) ;
                osProcessF( tinP , countTC() , countTC() , T("wdw") , T(osfn)+T(" ")+TF3(idAdamP,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+(psttArgsP?T(" ")+T(psttArgsP):T(""))+T(" !debug !idHome ")+TF1(processGlobal1I.idHome)+tPostscript , flProcessHire ) ;
                delF( tinP , psttMapped ) ;
            }
            else if( F(flagsP) & flHIRE_WAIT )
            {
                if( F(flagsP) & flHIRE_DISPLAYgRAPHICS ) osSessionF( tinP , countTC() , countTC() , countTC() , idDeathType , idAdamP , T(psttArgsP)+T(" !idHome ")+TF1(processGlobal1I.idHome) , 0 , 0 , 0 , 0 , /*flSESSION_MAXIMIZE*/flSESSION_MINIMIZE ) ;
                else                                     osProcessF( tinP , countTC() , countTC() , countTC() , idDeathType , idAdamP , (F(flProcessHire)&flPROCESShIRE_VISIBLE?T(psttArgsP):T("!quietConsole ")+T(psttArgsP))+T(" !idHome ")+TF1(processGlobal1I.idHome)+tPostscript , flProcessHire ) ;
            }
            else
            {
                if( F(flagsP) & flHIRE_DISPLAYgRAPHICS ) osSessionF( tinP , countTC() , countTC() , idAdamP , T(psttArgsP)+T(" !idHome ")+TF1(processGlobal1I.idHome) , 0 , 0 , 0 , 0 , /*flSESSION_MAXIMIZE*/flSESSION_MINIMIZE ) ;
                else                                     osProcessF( tinP , countTC() , countTC() , idAdamP , (F(flProcessHire)&flPROCESShIRE_VISIBLE?T(psttArgsP):T("!quietConsole ")+T(psttArgsP))+T(" !idHome ")+TF1(processGlobal1I.idHome)+tPostscript , flProcessHire ) ;
            }

            #if defined( NEVERdEFINED )
        
                //THIS CODE IS OBSOLETE NOW THAT 6a4 IS NOT USED
                if( !third.ifc CellIsWorkingIF( tinP , ifcIDaDAM_KERNEL2MONITOR , ".monitored" ) )
                else
                {
                    stackC stCourses( tinP , third , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                    soulC sOrder( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDjOBoRDER_CONSTRUCTlOCALcELL ) ;
                    sOrder << idAdamP ;
                    sOrder << psttArgsP ;
                    sOrder << flagsP ;
                    sOrder << time1LimitP ;
                    sOrder << (countT)time2LimitP ;
                    stackC stOrders( tinP , third , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                    stOrders << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                
                    if( !nicNameP ) nicNameP = socketC::nicNameIF( tinP , *this ) ;
                    //ifcSayIF( T("hiring a ")+TF1(idAdamP)+T(" cell on ")+T(nicNameP) , flSAY_APPEND | flSAY_LOG ) ;
                    ifcJobF( tinP , stCourses , ifcIDaDAM_KERNEL2MONITOR , sOrder , stOrders , psttOldCommentP , cTriesP , nicNameP ) ;
                }
        
            #endif
        }
    }

    return idDeathType ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002131.etherc.ifchiref END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002132.etherc.diskgethoverf BEGIN
#define DDNAME       "3func.36002132.etherc.diskgethoverf"
#define DDNUMB      (countT)0x36002132
#define IDFILE      (countT)0xd4f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskGetHoverF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030173.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 psttP
  must be 0
*/
/**//*1*/voidT etherC::diskGetHoverF( tinS& tinP , strokeS*& psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    ZE( osTextT* , postOs ) ;
    third.dosGetCurrentDirF( tinP , postOs ) ; ___( postOs ) ;
    ifFileNameC iffn( tinP , third , postOs ) ;

    TN( tOut , iffn ) ;
    if( tOut.csF( tinP ) > 5 ) tOut += T("/") ;     // BASE OS (WINDOWS 10) IS INCONSISTENT IN THAT IT WILL RETURN NAMES OF FORM "x:\" OR "x:\foo".  I.E. THE NAME INCLUDES A TRAILING BACKSLASH IF AND ONLY IF THE NAME IS TO THE ROOT FOLDER OF A DRIVE

    strMakeF( tinP , LF , psttP , tOut ) ; ___( psttP ) ;
    delF( tinP , postOs ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002132.etherc.diskgethoverf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002133.etherc.strreplacef BEGIN
#define DDNAME       "3func.36002133.etherc.strreplacef"
#define DDNUMB      (countT)0x36002133
#define IDFILE      (countT)0xd50


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strReplaceF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030174.1.0.html\"\>definition\</A\>
i do a set of replacements that are specified by setting flag bits
arguments
 tinP
 psttNewBigP
 psttOldBigP
  can be 0
  if 0 then psttNewBigP will be replaced
  if not 0 then psttNewBigP must be 0
 idTypeP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010156.ifcIDtYPEsTRrEPLACE!||
  if i am exporting then i assume that the soulC objects referenced are not volatile
 csttExtraP
  can be 0
  i always preserve the extra strokes that are present in the source string
  use csttExtraP to specify additional extra strokes
 flagsP 
*/
/**/

/*1*/countT etherC::strReplaceF( tinS& tinP , strokeS*& psttNewBigP , const strokeS* const psttOldBigP , const countT idTypeP , const countT csttExtraP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __( !psttNewBigP == !psttOldBigP ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( countT , cReplacements ) ;
    ZE( const strokeS* , psttOldBig ) ;
    ZE( boolT , bDeleteOldBig ) ;
    if( psttOldBigP ) psttOldBig = psttOldBigP ;
    else
    {
        psttOldBig = psttNewBigP ;
        psttNewBigP = 0 ;
        bDeleteOldBig = 1 ;
    }

    static const osTextT ppostNam[ 0x10 ][ 2 ] = { 'Z' , 'e' , 'W' , 'o' , 'O' , 'o' , 'R' , 'e' , 'F' , 'o' , 'F' , 'i' , 'S' , 'e' , 'V' , 'e' , 'T' , 'a' , 'N' , 'i' , 'A' , 'y' , 'B' , 'e' , 'C' , 'e' , 'D' , 'e' , 'E' , 'e' , 'F' , 'e' } ;
    switch( idTypeP )
    {
        case ifcIDtYPEsTRrEPLACE_REMOVEaSCIIlOWhIGH :
        {
            strMakeF( tinP , LF , psttNewBigP , psttOldBigP ) ; //CALLER MUST TAG
            if( psttNewBigP )
            {
                for( countT idr = 1 ; idr <= psttNewBigP->idAdam ; idr ++ )
                {
                    strokeS& sttc = psttNewBigP[ CSpREFIX - 1 + idr ] ;
                    if( sttc.idCaste == sc_cFROMaSCII && ( sttc.idAdam < 0x20 || sttc.idAdam > 0x7f ) ) sttc.idAdam = '.' ;
                }
            }
            break ;
        }
        case ifcIDtYPEsTRrEPLACE_DIGITStOdIGITnAMES :
        {
            strMakeF( tinP , LF , psttNewBigP , T("") , psttOldBig->idAdam * 2 + csttExtraP ) ; //CALLER MUST TAG
            if( psttNewBigP )
            {
                ZE( boolT , bInQuote ) ;

                ZE( countT , offn ) ;
                for( countT ido = 1 ; ido <= psttOldBig->idAdam ; ido ++ )
                {
                    countT bCopy = 1 ;

                    if( psttOldBig[ CSpREFIX - 1 + ido ].idCaste == sc_cFROMaSCII )
                    {
                        countT idAdam = psttOldBig[ CSpREFIX - 1 + ido ].idAdam ;
                        countT offt = - 1 ;
                        if( idAdam == '"' ) bInQuote = !bInQuote ;
                        else if( !bInQuote || F(flagsP) & flSTRrEPLACE_IGNOREqUOTES )
                        {
                                 if( idAdam >= '0' && idAdam <= '9' ) offt = idAdam - '0' ;
                            else if( idAdam >= 'a' && idAdam <= 'f' ) offt = idAdam - 'a' + 0xa ;
                        }

                        if( offt != - 1 )
                        {
                            bCopy = 0 ;
                            psttNewBigP[ CSpREFIX + offn ++ ] = S1C(ppostNam[offt][0]) ;
                            psttNewBigP[ CSpREFIX + offn ++ ] = S1C(ppostNam[offt][1]) ;
                        }
                    }

                    if( bCopy ) psttNewBigP[ CSpREFIX + offn ++ ] = psttOldBig[ CSpREFIX - 1 + ido ] ;
                    else        cReplacements ++ ;
                }
                psttNewBigP[ 0 ].idAdam += offn ;
                psttNewBigP[ 2 ].idAdam -= offn ;
            }
            break ;
        }
        case ifcIDtYPEsTRrEPLACE_DIGITnAMEStOdIGITS :
        {
            strMakeF( tinP , LF , psttNewBigP , T("") , psttOldBig->idAdam + csttExtraP ) ; //CALLER MUST TAG
            if( psttNewBigP )
            {
                ZE( boolT , bInQuote ) ;

                ZE( countT , offn ) ;
                for( countT ido = 1 ; ido <= psttOldBig->idAdam ; ido ++ )
                {
                    countT bCopy = 1 ;

                    if( psttOldBig[ CSpREFIX - 1 + ido ].idCaste == sc_cFROMaSCII )
                    {
                        countT idAdamA = psttOldBig[ CSpREFIX - 1 + ido ].idAdam ;
                        countT idAdamB = psttOldBig[ CSpREFIX     + ido ].idAdam ;
                        countT offt = - 1 ;
                        if( idAdamA == '"' ) bInQuote = !bInQuote ;
                        else if( !bInQuote || F(flagsP) & flSTRrEPLACE_IGNOREqUOTES )
                        {
                            offt = 0 ;
                            while( offt < 0x10 )
                            {
                                if( idAdamA == ppostNam[ offt ][ 0 ] && idAdamB == ppostNam[ offt ][ 1 ] ) break ;
                                offt ++ ;
                            }
                        }

                        if( offt < 0x10 )
                        {
                            bCopy = 0 ;
                            psttNewBigP[ CSpREFIX + offn ++ ] = S1C(offt<0xa?'0'+offt:'a'+offt-0xa) ;
                            ido ++ ;
                        }
                    }

                    if( bCopy ) psttNewBigP[ CSpREFIX + offn ++ ] = psttOldBig[ CSpREFIX - 1 + ido ] ;
                    else        cReplacements ++ ;
                }
                psttNewBigP[ 0 ].idAdam += offn ;
                psttNewBigP[ 2 ].idAdam -= offn ;
            }
            break ;
        }
        case ifcIDtYPEsTRrEPLACE_MAKEeXPORT :
        {
            ZE( countT , csDelta ) ;
            for( countT ids = 1 ; ids <= psttOldBig->idAdam ; ids ++ )
            {
                if( psttOldBig[ CSpREFIX - 1 + ids ].idCaste == sc_cADAM )
                {
                    ZE( soulC* , psf ) ;
                    psttOldBig[ CSpREFIX - 1 + ids ].featuresF( tinP , psf ) ; ___( psf ) ;

                    __Z( psf ) ;
                    if( !POOP )
                    {
                        const byteT* pbi = *psf ;
                        __( getNegAM( *(const countT*)pbi ) - FINGERnEG_SOULc ) ; pbi += sizeof( countT ) ;
                        __( *(const countT*)pbi - 1                 ) ; pbi += sizeof( countT ) ;

                        countT cbImage = 3 * sizeof( countT ) + *(const countT*)pbi ;
                        countT cbPad = sizeof( strokeS ) - 1 - ( cbImage + sizeof( strokeS ) - 1 ) % sizeof( strokeS ) ;
                        countT csDeltaThis = ( cbImage + cbPad ) / sizeof( strokeS ) ;
                        csDelta += csDeltaThis ;
                    }
                    (*this)( tinP , psf ) ;
                }
            }
    
            if( POOP ) ;
            else if( !csDelta )
            {
                strMakeF( tinP , LF , psttNewBigP , psttOldBig , csttExtraP ) ; //CALLER MUST TAG
            }
            else
            {
                strMakeF( tinP , LF , psttNewBigP , T("") , psttOldBig->idAdam + csDelta + csttExtraP ) ; // CALLER MUST TAG

                for( countT ids = 1 ; ids <= psttOldBig->idAdam ; ids ++ )
                {
                    if( psttOldBig[ CSpREFIX - 1 + ids ].idCaste == sc_cADAM )
                    {
                        ZE( soulC* , psf ) ;
                        psttOldBig[ CSpREFIX - 1 + ids ].featuresF( tinP , psf ) ; ___( psf ) ;

                        __Z( psf ) ;
                        if( !POOP )
                        {
                            // FOR DEBUGGING ONLY
                            //{
                            //    ZE( strokeS* , psttd ) ;
                            //    soulC::dumpIF( tinP , psttd , *psf ) ; ___( psttd ) ;
                            //    LOGrAW( T("export: \"")+T(psttd)+T("\"\r\n") ) ;
                            //    delF( tinP , psttd ) ;
                            //}

                            const byteT* pbi = *psf ;
                            __( getNegAM( *(const countT*)pbi ) - FINGERnEG_SOULc ) ; pbi += sizeof( countT ) ;
                            __( *(const countT*)pbi - 1                             ) ; pbi += sizeof( countT ) ;

                            if( !POOP )
                            {
                                countT cbImage = 3 * sizeof( countT ) + *(const countT*)pbi ;
                                countT cbPad = sizeof( strokeS ) - 1 - ( cbImage + sizeof( strokeS ) - 1 ) % sizeof( strokeS ) ;
                                countT csDeltaThis = ( cbImage + cbPad ) / sizeof( strokeS ) ;
        
                                strokeS stt0 ;
                                strFuseF( tinP , psttNewBigP , stt0 ) ;
                                psttNewBigP[ CSpREFIX - 1 + psttNewBigP->idAdam ].idCaste = sc_cADAMeXPORT ;
                                psttNewBigP[ CSpREFIX - 1 + psttNewBigP->idAdam ].idAdam  = csDeltaThis ;
    
                                byteT* pbTo = (byteT*)( psttNewBigP + CSpREFIX + psttNewBigP->idAdam ) ;
                                while( csDeltaThis -- ) strFuseF( tinP , psttNewBigP , stt0 ) ; //DONE THIS WAY CAUSE SAFER; IF WANT SPEED THEN DEFINE A NEW OVERLOAD OF strFuseF TO DO THIS JOB FASTER; DON'T KLUDGE IT WITH A MEMCPY
                                    
                                thirdC::c_memcpyIF( tinP , pbTo , *psf , cbImage ) ;
                                cReplacements ++ ;
                            }
                        }

                        (*this)( tinP , psf ) ;
                    }
                    else strFuseF( tinP , psttNewBigP , psttOldBig[ CSpREFIX - 1 + ids ] ) ;
                }
            }

            break ;
        }
        case ifcIDtYPEsTRrEPLACE_MAKEiMPORT :
        {
            ZE( countT , csDelta ) ;
            for( countT ids = 1 ; ids <= psttOldBig->idAdam ; ids ++ )
            {
                if( psttOldBig[ CSpREFIX - 1 + ids ].idCaste == sc_cADAMeXPORT )
                {
                    countT csDeltaThis = psttOldBig[ CSpREFIX - 1 + ids ].idAdam ;
                    csDelta += csDeltaThis ;
                    ids     += csDeltaThis ;
                }
            }
    
            if( !csDelta )
            {
                strMakeF( tinP , LF , psttNewBigP , psttOldBig , csttExtraP ) ; //CALLER MUST TAG
            }
            else
            {
                strMakeF( tinP , LF , psttNewBigP , T("") , psttOldBig->idAdam - csDelta + csttExtraP ) ;

                ZE( countT , csDeltaThis ) ; //SEMANTICS: "bArmed": IF NOT ZE THEN I AM AT THE BEGINNING OF A soulC IMAGE
                for( countT ids = 1 ; ids <= psttOldBig->idAdam ; ids ++ )
                {
                    if( csDeltaThis )
                    {
                        ZE( soulC* , psf ) ;
                        (*this)( tinP , psf , TAG( TAGiDnULL ) ) ;
                        const byteT* pbi = (const byteT*)( psttOldBig + CSpREFIX - 1 + ids ) ;
                        __( getNegAM( ((const countT*)pbi)[ 0 ] ) - FINGERnEG_SOULc ) ;
                        __( ((const countT*)pbi)[ 1 ] - 1                             ) ;
                        if( POOP ) break ;
                        
                        psf->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbi , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;

                        // FOR DEBUGGING ONLY
                        //{
                        //    ZE( strokeS* , psttd ) ;
                        //    soulC::dumpIF( tinP , psttd , *psf ) ; ___( psttd ) ;
                        //    LOGrAW( T("import: \"")+T(psttd)+T("\"\r\n") ) ;
                        //    thirdC::dosExitProcessIF( 1 ) ;
                        //    delF( tinP , psttd ) ;
                        //}

                        strokeS stta( FINGERnEG_SADAMsTROKEcT , psf ) ;
                        strFuseF( tinP , psttNewBigP , stta ) ;

                        ids += csDeltaThis - 1 ;
                        csDeltaThis = 0 ;
                        cReplacements ++ ;
                    }
                    else if( psttOldBig[ CSpREFIX - 1 + ids ].idCaste == sc_cADAMeXPORT ) csDeltaThis = psttOldBig[ CSpREFIX - 1 + ids ].idAdam ;
                    else strFuseF( tinP , psttNewBigP , psttOldBig[ CSpREFIX - 1 + ids ] ) ;
                }
            }

            break ;
        }
    }

    if( bDeleteOldBig ) delF( tinP , *(strokeS**)&psttOldBig ) ;

    return cReplacements ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002133.etherc.strreplacef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002134.etherc.osmakef BEGIN
#define DDNAME       "3func.36002134.etherc.osmakef"
#define DDNUMB      (countT)0x36002134
#define IDFILE      (countT)0xd51


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osMakeF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030175.1.0.html\"\>definition\</A\>
i prepare the final source code, compile and link it, and report errors, if any
impotence does not occur when i cannot compile or link
the caller can assume that compile and link completed aok if stErrorsP has no plates
arguments
 tinP
 stErrorsP
  must be of type ifcSTACKtYPE_PTR_soulC
  must be empty
  after i return, each soulC object (if any) on stErrorsP contains the following elements
   countT idLine
    might be 0, but will usually be nonze
   countT idColumn
    might be 0, but will usually be nonze
   strokeS* psttLine
    might be 0, but will usually be nonze
   strokeS* psttNote
    is guaranteed to be nonze
  after i return, the caller can process stErrorsP in wo of these ways
   alt: just inspect the number of plates without removing any plates from stErrorsP
    in this case, the soulC objects will be d eleted when stErrorsP is destroyed
   alt: remove some or all plates
    in this case, the caller must explicitly d elete all removed soulC objects
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001015f.flMAKE!||
*/
/**/

/*1*/voidT etherC::osMakeF( tinS& tinP , stackC& stErrorsP , const countT idAdamP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( stErrorsP ) ;
        __Z( idAdamP ) ;
        FV( flMAKE , flagsP ) ;
        if( POOP ) return ;
    }

    _IO_

    traceF( tinP , T("osMakeF / +") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
    ZE( strokeS* , psttHome ) ;
    diskMapFileNameF( tinP , psttHome , T("///ideafarm/") ) ; //THIS LINE "HARDCODES" psttHome SO THAT I CAN BE RUN ON ifc21 USING THE DEFINITION FILES ON ifc11

    traceF( tinP , T("osMakeF / a") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
    TN( tDot , "."   ) ;
    TN( tH   , "h"   ) ;
    TN( tCpp , "cpp" ) ;
    TN( tIdi        , "" ) ; tIdi        = TF3(idAdamP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE                 ,8) ;
    TN( tIdiForeign , "" ) ; tIdiForeign = TF3(idAdamP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ;

    traceF( tinP , T("osMakeF / 9") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
    batonC bHost( tinP , TAG( TAGiDnULL ) , T("masterOldC") , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_GRABBED | flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) ; // A HOST BATON WITH THE SAME NAME IS ALSO USED BY masterOldC
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

    traceF( tinP , T("osMakeF / 8") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
    // MAKE THE SOURCE FILES
    stackC st_psttIdModule( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO|flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
    {
        soulC soul1m( tinP , TAG( TAGiDnULL ) ) ;
        traceF( tinP , T("osMakeF / 7") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        boxMenuF( tinP , soul1m , T(psttHome)+T("precious/domains/com/ideafarm/city/library/dictionary/5adam.")+tIdiForeign+T(".*") ) ;
        traceF( tinP , T("osMakeF / 6") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
        {
            traceF( tinP , T("osMakeF / 5") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
            TN( tDefBody , "" ) ;
            {
                ZE( osTextT* , postd ) ;
                ZE( countT   , costd ) ;
                boxGetShadowF( tinP , postd , costd , psttc1 ) ; ___( postd ) ;
                tDefBody = T(postd) ;
                delF( tinP , postd ) ;
            }
    
            ZE( strokeS* , psttIdModule ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            strWordF( tinP , psttIdModule , psttc1 , sttq , strokeS('.') , - 1 ) ; ___( psttIdModule ) ;

            ZE( strokeS* , psttRev ) ;
            soulC soulr( tinP , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;
            strReverseF( tinP , psttRev , tDefBody , T("\r\n") , &soulr ) ; ___( psttRev ) ;
            __NZ( psttRev ) ;
    
            TN( tSrc , "" ) ;
            if( !strCompareF( tinP , psttIdModule , tH ) )
            {
                delF( tinP , psttIdModule ) ;

                tSrc = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/workshop/2source/")+tIdiForeign+T(".h") ;
                handleC hFile1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;                                                                                          \
                fileOpenF( tinP , hFile1 , countTC() , tSrc , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

                while( soulr )
                {
                    ZE( strokeS* , psttp ) ;
                    soulr >> psttp ; ___( psttp ) ;

                    ZE( osTextT* , postp ) ;
                    countT costp = strMakeF( tinP , LF , postp , psttp ) ; ___( postp ) ;
                    delF( tinP , psttp ) ;

                    fileWriteF( tinP , hFile1 , postp , costp ) ;
                    delF( tinP , postp ) ;
                }
            }
            else
            {
                TN( tIdModule , "" ) ; tIdModule = T(psttIdModule) ;
                st_psttIdModule << psttIdModule ; psttIdModule = 0 ;
    
                tSrc = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/workshop/2source/")+tIdiForeign+tDot+tIdModule+T(".cpp") ;
                if( diskFileExistsF( tinP , tSrc ) ) diskFileOrDirDeleteF( tinP , tSrc ) ;
                handleC hFile1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;                                                                                          \
                fileOpenF( tinP , hFile1 , countTC() , tSrc , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

                TN( tHead , "" ) ; tHead = T(

                    "//SOURCE: 5adam.")+tIdiForeign+tDot+tIdModule+T(" BEGIN\r\n"
                    "#define DDNAME \"5adam.")+tIdiForeign+tDot+tIdModule+T("\"\r\n"
                    "#define DDNUMB 0x")+tIdiForeign+T("\r\n"
                    "#define IDFILE (countT)0x0\r\n"
                    "#define postHEADER \"")+tIdiForeign+T(".h\"\r\n"

                ) ;

                TN( tTail , "" ) ; tTail = T(

                    "\r\n"
                    "#undef DDNUMB\r\n"
                    "#undef DDNAME\r\n"
                    "#undef IDFILE\r\n"
                    "#undef postHEADER\r\n"

                ) ;

                if( F(flagsP) & flMAKE_ENABLEtHIRDpARTIES )
                {
                    tHead += T("#define ifcENABLEtHIRDpARTIES\r\n#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.adam.show.third.1.h\"\r\n#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.adam.show.third.2.h\"\r\n") ;
                    tTail += T("#undef ifcENABLEtHIRDpARTIES\r\n") ;
                }
                else tHead += T("#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.adam.hide.third.1.h\"\r\n#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.adam.hide.third.2.h\"\r\n") ;

                tHead += T(
                    
                    "#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\1snip.")+tIdiForeign+tDot+tIdModule+T(".ClINESiNdEF\"\r\n"

                ) ;

                tTail += T("//SOURCE: 5adam.")+tIdiForeign+tDot+tIdModule+T(" END\r\n") ;

                {
                    ZE( osTextT* , postp ) ;
                    countT costp = strMakeF( tinP , LF , postp , tHead ) ; ___( postp ) ;
                    //LOGrAW( "\r\n-------- BEGIN ------------------\r\n" ) ;
                    //LOGrAW( postp ) ;
                    //LOGrAW( "\r\n-------- END ------------------\r\n" ) ;
                    fileWriteF( tinP , hFile1 , postp , costp ) ;
                    delF( tinP , postp ) ;
                }

                while( soulr )
                {
                    ZE( strokeS* , psttp ) ;
                    soulr >> psttp ; ___( psttp ) ;

                    ZE( osTextT* , postp ) ;
                    countT costp = strMakeF( tinP , LF , postp , psttp ) ; ___( postp ) ;
                    delF( tinP , psttp ) ;

                    fileWriteF( tinP , hFile1 , postp , costp ) ;
                    delF( tinP , postp ) ;
                }

                {
                    ZE( osTextT* , postp ) ;
                    countT costp = strMakeF( tinP , LF , postp , tTail ) ; ___( postp ) ;
                    fileWriteF( tinP , hFile1 , postp , costp ) ;
                    delF( tinP , postp ) ;
                }
    
                writeLineSnipF( tinP , *this , tIdiForeign , tIdModule , tDefBody ) ;
            }
        }
        FORsTRINGSiNsPANNEDcOMBINEDtAIL1
    }

    // MAKE THE OBJECT MODULES
    ZE( boolT , bErrorsAll ) ;
    while( st_psttIdModule )
    {
        traceF( tinP , T("osMakeF / 4") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        TN( tIdModule , "" ) ;
        {
            ZE( strokeS* , psttIdModule ) ;
            st_psttIdModule >> psttIdModule ;
            tIdModule = T(psttIdModule) ;
            delF( tinP , psttIdModule ) ;
        }
    
        TN( tSrc , "" ) ; tSrc = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/workshop/2source/")+tIdiForeign+tDot+tIdModule+T(".cpp") ;
        TN( tObj , "" ) ; tObj = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/workshop/3object/")+tIdiForeign+tDot+tIdModule+T(".obj") ;
        TN( tErr , "" ) ; tErr = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/workshop/4report/")+tIdiForeign+tDot+tIdModule+T(".err") ;

        diskMakeDirIfNeededF( tinP , tObj ) ;
        diskMakeDirIfNeededF( tinP , tErr ) ;
        if( diskFileExistsF( tinP , tObj ) ) diskFileOrDirDeleteF( tinP , tObj ) ;
        if( diskFileExistsF( tinP , tErr ) ) diskFileOrDirDeleteF( tinP , tErr ) ;

        ZE( boolT , bErrors ) ;
        third.osCompileF( tinP , bErrors , osFileNameC( tinP , third , tObj ) , osFileNameC( tinP , third , tErr ) , osFileNameC( tinP , third , tSrc ) , flagsP ) ;

        if( bErrors )
        {
            bErrorsAll |= 1 ;

            TN( tSrcBody , "" ) ;
            TN( tErrBody , "" ) ;
            {
                ZE( osTextT* , poste ) ;
                ZE( countT   , coste ) ;
                boxGetShadowF( tinP , poste , coste , tErr , 1 ) ; ___( poste ) ;
                tErrBody = T(poste) ;
                delF( tinP , poste ) ;
    
                ZE( osTextT* , posti ) ;
                ZE( countT   , costi ) ;
                boxGetShadowF( tinP , posti , costi , tSrc ) ; ___( posti ) ;
                tSrcBody = T(posti) ;
                delF( tinP , posti ) ;
            }
    
            countT idf = 1 ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , psttl ) ;
            TN( tFile , "File: " ) ;
            TN( tColon , ": " ) ;
            while( !POOP && idf )
            {
                strSubstringLineF( tinP , psttl , idf , sttq , tErrBody ) ; ___( psttl ) ;
                if( !psttl ) break ;
    
                countT idf2 = 1 ;
                ZE( countT , idl2 ) ;
                strokeS sttq2( (countT)0 , sc_IGNOREqUOTES ) ;
                if( 1 != strIdF( tinP , 0 , flSTRmATCH_null , idf2 , sttq2 , tFile , psttl ) )
                {
                    idf2 = 1 ;
                    //sttq2 = ze ;
                    if( 1 == strIdF( tinP , idf2 , sttq2 , S1C('(') , psttl ) )
                    {
                        soulC* ps = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( ps ) ;
                        if( ps )
                        {
                            ZE( countT , idLine ) ;
                            ZE( countT , idColumn ) ;
                            ZE( strokeS* , psttLine ) ;
                            ZE( strokeS* , psttNote ) ;
                            ZE( strokeS* , psttw ) ;
    
                            idf2 = 2 ;
                            //sttq2 = ze ;
                            strSubstringF( tinP , psttw , idf2 , sttq2 , S1C(',') , psttl ) ; ___( psttw ) ;
                            if( psttw ) idLine = strDigitsToSCountF( tinP , psttw , 0xa , 1 ) ;
                            delF( tinP , psttw ) ;
    
                            strSubstringF( tinP , psttw , idf2 , sttq2 , S1C(')') , psttl ) ; ___( psttw ) ;
                            if( psttw ) idColumn = strDigitsToSCountF( tinP , psttw , 0xa , 1 ) ;
                            delF( tinP , psttw ) ;
    
                            if( idLine )
                            {
                                idf2 = 1 ;
                                //sttq2 = ze ;
                                strSubstringLineF( tinP , psttLine , idf2 , sttq2 , tSrcBody , idLine ) ; ___( psttLine ) ;
                            }
    
                            idf2 = 1 ;
                            idl2 = 0 ;
                            //sttq2 = ze ;
                            strIdF( tinP , 0 , flSTRmATCH_null , idf2 , sttq2 , tColon , psttl ) ;
                            if( idf2      ) { strIdF( tinP , 0 , flSTRmATCH_null , idf2 , sttq2 , tColon , psttl ) ; }
                            if( idf2      ) { strSubstringF( tinP , psttNote , idf2 , idl2 , psttl ) ; ___( psttNote ) ; }
                            if( !psttNote ) { strMakeF( tinP , LF , psttNote , psttl ) ; ___( psttNote ) ; }
    
                            *ps << idLine ;
                            *ps << idColumn ;
                            *ps << psttLine ;
                            *ps << psttNote ;
                            delF( tinP , psttLine ) ;
                            delF( tinP , psttNote ) ;
    
                            stErrorsP << ps ;
                        }
                    }
                }
                delF( tinP , psttl ) ;
            }
    
            if( !stErrorsP )
            {
                soulC* ps = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( ps ) ;
                if( ps )
                {
                    *ps << 0U ;
                    *ps << 0U ;
                    *ps << (strokeS*)0 ;
                    *ps << (strokeS*)T("compilation failed, but the compiler did not identify an offending code line") ;
                    stErrorsP << ps ;
                }
            }

            break ;
        }
        traceF( tinP , T("osMakeF / 3") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
    }

    // MAKE THE DLL
    if( !bErrorsAll )
    {
        traceF( tinP , T("osMakeF / 2") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        TN( tDll , "" ) ; tDll = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/park/exedll/1/master/ideafarm.")+tIdiForeign+T(".ipdos-wm") ;
        diskMakeDirIfNeededF( tinP , tDll ) ;
        if( diskFileExistsF( tinP , tDll ) ) diskFileOrDirDeleteF( tinP , tDll ) ;

        //CS:CODEsYNC: DUPLICATE 33002111 33002134
        ZE( countT , idCopyLath ) ;
        {
            TN( tLath , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/idCopyLath" ) ;
            IFsCRATCH
            {
                SCOOPS
    
                ZE( byteT* , pbi ) ;
                ZE( countT , cbi ) ;
                tinP.pEtScratch->boxGetShadowF( tinP , pbi , cbi , tLath , 1 ) ; ___( pbi ) ;
                if( POOP ) { POOPR ; }
                else if( cbi >= sizeof( countT ) ) idCopyLath = *(countT*)pbi ;
                delF( tinP , pbi ) ;
            }

            {
                masterOldC mm( tinP , *this , TAG( TAGiDnULL ) ) ;
                countT idCopyHW = mm.idCopyHighWaterF() ;
                if( idCopyLath < idCopyHW ) idCopyLath = idCopyHW ;
            }
            idCopyLath ++ ;

            boxPutF( tinP , tLath , (byteT*)&idCopyLath , sizeof idCopyLath ) ;
        }

        ZE( osTextT* , postDescription ) ;
        strMakeF( tinP , LF , postDescription , T("?ifcExeDllDescBegin !cName ")+tIdi+T(" !idCopy ")+TF3(idCopyLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(" !contact http://ideafarm.com IdeaFarm " "(tm) Piggyback Distributed Operating System (c) Wo Of Ideafarm all rights reserved !ifcExeDllDescEnd") ) ; ___( postDescription ) ;
        postDescription[ 0 ] = '!' ;

        TN( tObjLike , "" ) ; tObjLike = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/workshop/3object/")+tIdiForeign+T(".*.obj") ;
        TN( tLib , "" ) ; tLib = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/park/exedll/1/master/ideafarm.81000001.ipdos-wl") ;
        third.osLinkF( tinP , osFileNameC( tinP , third , tDll ) , osFileNameC( tinP , third , tObjLike ) , flagsP , osFileNameC( tinP , third , tLib ) , postDescription ) ;
        delF( tinP , postDescription ) ;
        {
            soulC soul1m( tinP , TAG( TAGiDnULL ) ) ;
            boxMenuF( tinP , soul1m , tObjLike ) ;
            FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
            {
                diskFileOrDirDeleteF( tinP , psttc1 ) ;
            }
            FORsTRINGSiNsPANNEDcOMBINEDtAIL1
        }
        traceF( tinP , T("osMakeF / 1") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        osMakeHoverFileF( tinP , idAdamP ) ;
        traceF( tinP , T("osMakeF / 0") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
    }

    THREADmODE1rESTORE
    bHost.ungrabF( tinP ) ;
    delF( tinP , psttHome ) ;
    traceF( tinP , T("osMakeF / -") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002134.etherc.osmakef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002135.etherc.stridf BEGIN
#define DDNAME       "3func.36002135.etherc.stridf"
#define DDNUMB      (countT)0x36002135
#define IDFILE      (countT)0xd52


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strIdF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030176.1.0.html\"\>definition\</A\>
i evaluate to the id of the stroke at which the first match is found
arguments
 tinP
 idFirstP
 sttQuoteP
 st_psttSmallP
  idType must be ifcSTACKtYPE_PTR_strokeS
  must contain at least wo plate
  should normally be a fifo stack
  should normally push values into it with psttOldC temporary objects
  for best speed, be sure that the most frequently encountered strings are at the top of this stackC object
 idSlotP
  must be 0
  will be set to the id of the plate in st_psttSmallP that matched
 psttBigP
 flagsP
  bAnyP (U::edit to update for migration from boolT to flagsT)
   can be 0 or nonze
   if 0 then i look for an occurance of wo of the substrings in st_psttSmallP
   if 1 then i look for an occurance of wo of the strokeS values in wo of the substrings in st_psttSmallP
*/

/**/
/*1*/countT etherC::strIdF( tinS& tinP , countT& idFirstP , strokeS& sttQuoteP , stackC& st_psttSmallP , countT& idSlotP , const strokeS* psttBigP , const flagsT flagsP , sCountT idP )/*1*/
{
    SCOOP
    const boolT bUseQuotes = sttQuoteP.idCaste != sc_IGNOREqUOTES ;_WQ

    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttBigP ) ;_WQ
        __Z( idFirstP ) ;_WQ
        __( idFirstP == 1 && (countT)sttQuoteP && bUseQuotes ) ;_WQ
        __( st_psttSmallP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_strokeS ) ;_WQ
        __Z( st_psttSmallP ) ;_WQ
        __( idSlotP ) ;_WQ
        FV( flSTRiD , flagsP ) ;_WQ
        __Z( idP ) ;_WQ
        if( POOP ) return 0 ;
        __( psttBigP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_

    STRiDrECURSE( strIdF( tinP , idf , sttQuoteP , st_psttSmallP , idSlotP , psttBigP , F(flagsP) & flSTRiD_ANY , 1 ) )
    {
        ZE( countT , idfMin ) ;_WQ
        strokeS sttqMin( (countT)0 , sc_IGNOREqUOTES ) ;_WQ
        ZE( countT , idSlotMin ) ;_WQ

        ZE( countT , idSlot ) ;_WQ
        st_psttSmallP.grabF( tinP , TAG( TAGiDnULL ) ) ;_WQ
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;_WQ
        do
        {
            strokeS* pstts = (strokeS*)st_psttSmallP.downF( tinP , hDown ) ;_WQ
            countT idf = idFirstP ;_WQ
            strokeS sttq = sttQuoteP ;_WQ
            countT idt = F(flagsP) & flSTRiD_ANY
                ? strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , pstts , psttBigP , idHit )
                : strIdF(    tinP , 0 , flSTRmATCH_null , idf , sttq , pstts , psttBigP , idHit )
            ;_WQ

            if( !( idSlot ++ ) )
            {                        //DONE THIS WAY TO ENSURE THAT WHEN THERE IS WO PLATE, THE RESULT, INCLUDING SIDE EFFECTS, IS EXACTLY AS IF THE strokeS* OVERLOAD HAD BEEN CALLED
                idHit = idt ;_WQ
                idfMin = idf ;_WQ
                sttqMin = sttq ;_WQ
                if( idt ) idSlotMin = idSlot ;_WQ
            }
            else if( idt && ( !idHit || idt < idHit ) ) //MODIFIES THE RESULTS AND SIDE EFFECTS IFF ANOTHER HIT IS FOUND AND THAT HIT IS PREFERRED
            {
                idHit = idt ;_WQ
                idfMin = idf ;_WQ
                sttqMin = sttq ;_WQ
                idSlotMin = idSlot ;_WQ
            }
        }
        while( !POOP && !st_psttSmallP.third && ~hDown ) ;_WQ
        st_psttSmallP.ungrabF( tinP ) ;_WQ

        idFirstP = idfMin ;_WQ
        sttQuoteP = sttqMin ;_WQ
        idSlotP = idSlotMin ;_WQ
    }
    return idHit ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002135.etherc.stridf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002136.etherc.strsubstringf BEGIN
#define DDNAME       "3func.36002136.etherc.strsubstringf"
#define DDNUMB      (countT)0x36002136
#define IDFILE      (countT)0xd53


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strSubstringF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030177.1.0.html\"\>definition\</A\>
idFirstP will be set to point to the stroke after the delimiter string
if no delimiter is found, idFirstP will be set to 0
if th delimiter is at the end of the string, idFirstP will be set to 0
to test whether a delimiter is found, test idSlotP nonze
arguments
 psttP
 idFirstP
  if there aren't enough strokes in psttBigP, psttP will receive T("") and impotence will not occur
 sttQuoteP
 st_psttSmallP
  idType must be ifcSTACKtYPE_PTR_strokeS
  must contain at least wo plate
  should normally be a fifo stack
  should normally push values into it with psttOldC temporary objects
  for best speed, be sure that the most frequently encountered strings are at the top of this stackC object
 idSlotP
  must be 0
  will be set to the id of the plate in st_psttSmallP that matched
 psttBigP
 bAnyP
  can be 0 or nonze
  if 0 then i look for an occurance of wo of the substrings in st_psttSmallP
  if 1 then i look for an occurance of wo of the strokeS values in wo of the substrings in st_psttSmallP
 csttExtraP
*/
/**/
/*1*/voidT etherC::strSubstringF( tinS& tinP , strokeS*& psttP , countT& idFirstP , strokeS& sttQuoteP , stackC& st_psttSmallP , countT& idSlotP , const strokeS* psttBigP , const boolT bAnyP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;_WQ
        __Z( psttBigP ) ;_WQ
        __( st_psttSmallP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_strokeS ) ;_WQ
        __Z( st_psttSmallP ) ;_WQ
        __Z( idFirstP ) ;_WQ
        if( POOP ) return ;
        __( psttBigP->idCaste   != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return ;
    }

    _IO_
    countT ccBig = psttBigP->idAdam ;_WQ
    if( ccBig < idFirstP )
    {
        strMakeF( tinP , LF , psttP , T("") ) ; //CALLER MUST TAG
        idFirstP = 0 ;_WQ
    }
    else
    {
        countT idfSave = idFirstP ;_WQ
        countT idd = strIdF( tinP , idFirstP , sttQuoteP , st_psttSmallP , idSlotP , psttBigP , bAnyP ? flSTRiD_ANY : flSTRiD_null ) ;_WQ
        countT idLathI = idd - 1 ;_WQ

             if( idd && idd == idfSave ) { strMakeF( tinP , LF , psttP , T("") , csttExtraP ) ; ___( psttP ) ; }
        else if( idd ) { strSubstringF( tinP , psttP , idfSave , idLathI , psttBigP , csttExtraP ) ; ___( psttP ) ; }
        else           { strSubstringF( tinP , psttP , idfSave , ccBig  , psttBigP , csttExtraP ) ; ___( psttP ) ; }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002136.etherc.strsubstringf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002137.etherc.sockwritef BEGIN
#define DDNAME       "3func.36002137.etherc.sockwritef"
#define DDNUMB      (countT)0x36002137
#define IDFILE      (countT)0xd54


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockWriteF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030178.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::sockWriteF( tinS& tinP , handleC& handleP , const countT idPortP , const nicNameC nicNameP , soulC& soulP , const countT idModeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_writeF( tinP , handleP , idPortP , nicNameP , soulP , idModeP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002137.etherc.sockwritef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002138.etherc.ostimetestf BEGIN
#define DDNAME       "3func.36002138.etherc.ostimetestf"
#define DDNUMB      (countT)0x36002138
#define IDFILE      (countT)0xd55


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osTimeTestF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030179.1.0.html\"\>definition\</A\>
i evaluate to 1 iff the current time is not less than the sum of the oo specified times
the timeA parameters will be updated to the current time iff i evaluate to 1
usage: use timeA to specify the last time that some Action was taken
usage: use timeD to specify the Delta time that is to elapse before the action is taken again
arguments
 tinP
 timeA1P
  can be 0
 timeA2P
  can be 0
 timeD1P
  can be 0
 timeD2P
  can be 0
*/
/**/

/*1*/boolT etherC::osTimeTestF( tinS& tinP , countT& timeA1P , sCountT& timeA2P , const countT timeD1P , const sCountT timeD2P )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( countT  , timeN1 ) ;
    ZE( sCountT , timeN2 ) ;
    third.osTimeNowF( tinP , timeN1 , timeN2 ) ;

    ZE( boolT , bAct ) ;
    {
        countT  timeT1 = timeN1 ;
        sCountT timeT2 = timeN2 ;
        third.osTimeSubtractF( tinP , timeT1 , timeT2 , timeA1P , timeA2P ) ;
        third.osTimeSubtractF( tinP , timeT1 , timeT2 , timeD1P , timeD2P ) ;
        bAct = timeT2 >= 0 ;
    }

    if( bAct )
    {
        timeA1P = timeN1 ;
        timeA2P = timeN2 ;
    }

    return bAct ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002138.etherc.ostimetestf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002139.etherc.ifcchatf BEGIN
#define DDNAME       "3func.36002139.etherc.ifcchatf"
#define DDNUMB      (countT)0x36002139
#define IDFILE      (countT)0xd56


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


/*
\<A HREF=\"6.$ifcChatF.0.html\"\>instances\</A\>
\<A HREF=\"5.103017a.1.0.html\"\>definition\</A\>
i do not return until the port that i am listening on is listening and is registered
i can only be called wo time in the definition of an adam
call me to launch a thread that accepts chat connections on an os selected idPort that will be registered with the local chat server
code notes
 sJob and sProduct are soulC objects
 sJob
  this contains a job definition
  item 1 must be a countT object with value ifcIDcMDsESSION_JOB
  item 2 must be a countT object with value DDNUMB
  item 3 must be a boolT  object with value 0
  items 4+ are arbitrarily defined for each adam
   recommend: item 4: idTypeJob
 sProduct
  this contains the job deliverables
  it is free format
   each adam definition can specify arbitrary contents
my protocol
 reads an sJob
 when i accept the job
  connect to the local chat server
  write a relay package addressed to an idAdam, containing an sJob
  read and reply sTrays until read an empty sTray (which is not replied)
 when i do a job
  replies sTrays until i have written an sTray containing an empty sCourse
  replies an empty sTray
arguments
 tinP
 chatHandlerFP
  must not be 0
  should check *tinP.pEtScratch for impotence after each access to pso
  pso not 0 is guaranteed
   use "__Z( pso ) ;" at the beginning; this is guaranteed to never be triggered, even for a misbehaving client
 cArgP
  a reference to cArgP is passed to chatHandlerFP
  the value of cArgP is opaque to me
   i do not see or use its value
 idAdamHandlingP
  must not be 0
  will be passed into handler
   the handler can use this value, for example, to decide whether to accept or reject jobs chatted to it
*/
/**/

//---- THE CODE ABOVE THIS LINE ONLY APPLIES IF THE DEFAULT HANDLER (A JOB HANDLER) IS USED


//---- THE CODE BELOW THIS LINE ONLY APPLIES IF THE DEFAULT HANDLER (A JOB HANDLER) IS USED

/*1*/voidT etherC::ifcChatF( tinS& tinP , const countT cArgP , const countT idAdamHandlingP , chatHandlerFT chatHandlerFP , const countT idPortHintP , jobFillCourseFT jobFillCourseFP , jobHearOrderFT jobHearOrderFP )/*1*/
{
    SCOOP
    static countT cIn ;
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( idAdamHandlingP ) ;
        __( cIn ++ ) ;
        if( POOP ) return ;
    }
    
    _IO_
    
    signC sgnRegistered( tinP , TAG( TAGiDnULL ) ) ;
    osThreadF(  tinP , countTC() , tmChatF , 0 , flTHREADlAUNCH_null , 0 , (countT)&sgnRegistered , cArgP , idAdamHandlingP , (countT)chatHandlerFP , idPortHintP , (countT)jobFillCourseFP , (countT)jobHearOrderFP ) ;
    sgnRegistered.waitF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002139.etherc.ifcchatf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600213a.etherc.ifcchatrelaypackagef BEGIN
#define DDNAME       "3func.3600213a.etherc.ifcchatrelaypackagef"
#define DDNUMB      (countT)0x3600213a
#define IDFILE      (countT)0xd57


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


/*
\<A HREF=\"6.$ifcChatRelayPackageF.0.html\"\>instances\</A\>
\<A HREF=\"5.103017b.1.0.html\"\>definition\</A\>
i package sSmallOutP so that it will be carried via relay to a local or remote adam who is listening for chat connections
my only function is to fill sBigOutP
i do not use sockets
after i return, sBigOutP will be ready to write to the local (or a remote) ifcCHAT port server
normally sBigOutP should be written to the local chat server
it is bad style to write sBigOutP directly to a remote chat server unless performance considerations require it
 this is because this creates multiple virtual circuits between the same oo hosts
arguments
 tinP
 sBigOutP
  must be empty
 sSmallOutP
  can be empty
  normally will not be empty
 idAdamP
  can be 0 unless idPortP is also 0
  normally is not ze
 psttOldCommentP
  specify a meaningful, specific, and thoughtful comment to communicate the purpose, objective, and identity of this particular relay chat session
  the value of this field is used to mark log entries to assist in tracking and debugging the progress and completion of related relay chat sessions
  although length is not currently limited, please be concise and state the most important information wo'th
   for some reporting purposes a truncation of this value might, and may, be used
   completeness is more important than conciseness
    use as much length as you need in order to include all relevant information
  must not be 0
  must not be of length 0
  must not contain CRLF "\r\n" or other control characters
   this is not currently enforced, but might be enforced in the future
 cTriesP
  can be 0
  all chat relay servers will use this value when connecting upward as the connection spline is established
  specify 0 if the application wants to block until the entire connection spline is in place
  specify 1 if the application wants to see a failure event if the entire connection spline cannot be established immediately
  specify a value greater than 1 if the application wants to imply a timeout value for the establishment of the connection spline
   the standard sleep interval between tries is TUCK * 0x40
   a calculation based on this value will underestimate the time that will elapse before timeout
    the actual elapsed time will also include time spent establishing the partial connection spline and then unwinding it
 idPortP
  can be 0
  normally is 0 unless idAdamP is 0
 nicNameP
  can be 0
   if 0 and idPortP is not 0 then the local host is implied
   if 0 and idAdamP is not 0 then a cell will be chosen randomly by the chat server
  normally is 0
 bDirectP
  can be 0 or 1
  normally should be 0 unless there is definitely no firewall blocking direct access to idPortP of nicNameP
  if 0 then a receiving chat server will relay to a remote chat server unless nicNameP is local
  if 1 then a receiving chat server will relay the payload directly to idPortP of nicNameP
  setting bDirectP is bad style unless performance considerations require it
   this is because firewalls will break applications that set bDirectP
*/
/**/

/*1*/voidT etherC::ifcChatRelayPackageF( tinS& tinP , soulC& sBigOutP , soulC& sSmallOutP , const countT idAdamP , const strokeS* const psttOldCommentP , const countT cTriesP , const countT idPortP , const nicNameC& nicNameP , const boolT bDirectP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( !idAdamP && !idPortP ) ;
        __( sBigOutP ) ;
        __Z( psttOldCommentP ) ;
        if( POOP ) return ;
        __( !psttOldCommentP->idAdam ) ;
        if( POOP ) return ;
    }

    _IO_

    sBigOutP << (countT)ifcIDcMDsESSION_RELAYcHAT ;     // 1
    sBigOutP << sSmallOutP ;                            // 2 PAYLOAD
    sBigOutP << idAdamP ;                               // 3 TARGET SENTIENT
    sBigOutP << idPortP ;                               // 4 NORMALLY 0: PORT ON WHICH THE TARGET SENTIENT IS LISTENING FOR CHAT CONNECTION REQUESTS
    nicNameP >> sBigOutP ;                              // 5 NORMALLY 0: HOST ON WHICH THE TARGET CELL RESIDES
    sBigOutP << cTriesP ;                               // 6 NORMALLY 0: CONTROLS connectF CALLS WHILE ESTABLISHING THE CONNECTION SPLINE
    sBigOutP << bDirectP ;                              // 7 NORMALLY 0: SETTING THIS CAUSES THE CHAT RELAY (1140104) ON THE TARGET HOST TO BE BYPASSED
    sBigOutP << (countT)0 ;                             // 8 cRelays: WILL BE INCREMENTED BY EACH CHAT SERVER (1140104) TO TOUCH ME

    sBigOutP << processGlobal1I.idAdamRoot ;               // 9
    sBigOutP << psttOldCommentP ;                          // a
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600213a.etherc.ifcchatrelaypackagef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600213b.etherc.ifccellhostsf BEGIN
#define DDNAME       "3func.3600213b.etherc.ifccellhostsf"
#define DDNUMB      (countT)0x3600213b
#define IDFILE      (countT)0xd58


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


/*
\<A HREF=\"6.$ifcCellHostsF.0.html\"\>instances\</A\>
\<A HREF=\"5.103017c.1.0.html\"\>definition\</A\>
arguments
 cut and paste code snippet
  most of this snippet is required
   the only part that is not required is the 2 "!tbl" lines, which log the contents of the tables
  | 
  | ZE( countT , idaLever ) ;
  | batonC b_idaLever( tinP , TAG( TAGiDnULL ) ) ;
  | switchStackC swsNicName( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idaLever , ifcSTACKtYPE_PTR_nicNameC ) ;
  | 
  | nicNameC idhLever ;
  | batonC b_idhLever( tinP , TAG( TAGiDnULL ) ) ;
  | switchStackC swsIdAdam( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idhLever ) ;
  | 
  | tableC tblCells( tinP , etThread , T("cells") ) ;
  | tableC tblHosts( tinP , etThread , T("hosts") ) ;
  | 
  | stackC stDelete_strokeS_ptr( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
  | stackC stDelete_nicNameC_ptr( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_nicNameC ) ;
  | stackC stDelete_stackC_ptr(  tinP , etThread , TAG( TAGiDnULL ) ) ;
  | 
  | etThread.ifcCellHostsF( tinP , swsNicName , idaLever , b_idaLever , swsIdAdam , idhLever , b_idhLever , tblCells , tblHosts , stDelete_strokeS_ptr , stDelete_nicNameC_ptr , stDelete_stackC_ptr ) ;
  | 
  | !tblCells ;
  | !tblHosts ;
  | 
  | while( stDelete_stackC_ptr )
  | {
  |     ZE( stackC* , pStk ) ;
  |     stDelete_stackC_ptr >> pStk ;
  |     DEL( pStk ) ;
  | }
  | 
 tinP
 swsNicNameP
  must be empty
  must be of type ifcSTACKtYPE_PTR_nicNameC
  must use a countT idAdam lever
 idaLeverP
 b_idaLeverP
 swsIdAdamP
  must be empty
  must be of type ifcSTACKtYPE_countT
  must use an nicNameC lever
 idhLeverP
 b_idhLeverP
 tblCellsP
  recommended internal name: T("cells")
  columns must not yet be defined
  must be empty
 tblHostsP
  recommended internal name: T("hosts")
  columns must not yet be defined
  must be empty
 stDelete_strokeS_ptrP
  must not be destructed before tblHostsP
  need not be explicitly purged
 stDelete_nicNameC_ptrP
  must not be destructed before tblHostsP
  need not be explicitly purged
 stDelete_stackC_ptrP
  must be explicitly purged by calling DEL( pStack ) for each value
 cTriesP
  can be 0
  if 0 then will retry forever until asynch impotence occurs
  if -1 then will retry forever even after asynch impotence occurs
  if > 0 then i will retry this many times and impotence will -not- occur if i cannot get the information
*/
/**/

/*1*/voidT etherC::ifcCellHostsF( tinS& tinP , switchStackC& swsNicNameP , countT& idaLeverP , batonC& b_idaLeverP , switchStackC& swsIdAdamP , nicNameC& idhLeverP , batonC& b_idhLeverP , tableC& tblCellsP , tableC& tblHostsP , stackC& stDelete_strokeS_ptrP , stackC& stDelete_nicNameC_ptrP , stackC& stDelete_stackC_ptrP , countT cTriesP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( swsNicNameP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_nicNameC ) ;
        __( swsNicNameP.cFlavorsF( tinP ) ) ;
        __( swsIdAdamP.idTypeF( tinP ) - ifcSTACKtYPE_countT ) ;
        __( swsIdAdamP.cFlavorsF( tinP ) ) ;
        __( stDelete_strokeS_ptrP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_strokeS ) ;
        __( stDelete_nicNameC_ptrP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_nicNameC ) ;
        __( tblCellsP.cRowsF( tinP ) ) ;
        __( tblHostsP.cRowsF( tinP ) ) ;
        //U: VERIFY THAT IS IN INITIAL PHASE AND THAT NO COLS HAVE YET BEEN DEFINED
        if( POOP ) return ;
    }

    _IO_

    tblCellsP.newColF( tinP , T("idAdam") ) ;
    tblCellsP.newColF( tinP , T("nicName") ) ;

    tblHostsP.newColF( tinP , T("idComputer") ) ;
    tblHostsP.newColF( tinP , T("emailOwner") ) ;
    tblHostsP.newColF( tinP , T("nameUsedByOwner") ) ;
    tblHostsP.newColF( tinP , T("nameUsedByIFC") ) ;
    tblHostsP.newColF( tinP , T("nameUsedByInternet") ) ;
    tblHostsP.newColF( tinP , T("commentUsedByOwner") ) ;
    tblHostsP.newColF( tinP , T("commentUsedByIFC") ) ;
    tblHostsP.newColF( tinP , T("nicNameRegistrand") ) ;
    tblHostsP.newColF( tinP , T("nicNameAll") ) ;

    etherC& etPrime = etPrimeIF( tinP ) ;
    boolT bNoQuit = cTriesP == - 1 ;
    boolT bFail = 1 ;
    IFsCRATCH
    {
        SCOOPS
        do
        {
            ZE( boolT , bOk ) ;
    
            nicNameC idhIfc = socketC::nicNameIF( tinP , *tinP.pEtScratch , T(WWWiDEAFARMcOM) ) ;
            ZE( countT , idPort2 ) ;
            {
                socketC sChat( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                sChat.connectF( tinP , ifcPORToLD2_CHAT , idhIfc ) ;
    
                soulC soulo( tinP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcIDcMDsESSION_NEWsOCKET ) ;
                sChat.writeF( tinP , soulo ) ;
    
                soulC souli( tinP , TAG( TAGiDnULL ) ) ;
                sChat.readF( tinP , souli ) ;
                ZE( countT , idReply ) ;
                souli >> idReply ;
                __( idReply - ifcIDcMDsESSION_NEWsOCKETrEPLY ) ;
                souli >> idPort2 ;
            }
    
            socketC sChat2( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
            sChat2.connectF( tinP , idPort2 , idhIfc ) ;
    
            soulC sIn1( tinP , TAG( TAGiDnULL ) ) ;
            soulC sOut1( tinP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcIDcMDsESSION_QUERYnICnAME ) ;
            sChat2.writeF( tinP , sOut1 ) ;
            sChat2.readF( tinP , sIn1 ) ;
    
            ZE( countT , idReply ) ;
            sIn1 >> idReply ;
            __( idReply - ifcIDcMDsESSION_QUERYnICnAMErEPLY ) ;
    
            ZE( countT , cHosts ) ;
            sIn1 >> cHosts ;
    
            while( cHosts -- )
            {
                ZE( nicNameC* , pNicNameRegistrand ) ;
                tinP.pEtScratch->newF( tinP , LF , pNicNameRegistrand ) ; ___( pNicNameRegistrand ) ;
                stackC* pStk_pNicName = new( 0 , tinP , LF ) stackC( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_nicNameC ) ; ___( pStk_pNicName ) ;
    
                if( pNicNameRegistrand && pStk_pNicName )
                {
                    stDelete_nicNameC_ptrP << pNicNameRegistrand ;
                    stDelete_stackC_ptrP << (countT)pStk_pNicName ;
                    *pNicNameRegistrand = 0 ;
    
                    ZE( countT   , idComputer             ) ;
                    ZE( strokeS* , psttEmailOwner         ) ;
                    ZE( strokeS* , psttNameUsedByOwner    ) ;
                    ZE( strokeS* , psttNameUsedByIFC      ) ;
                    ZE( strokeS* , psttNameUsedByInternet ) ;
                    ZE( strokeS* , psttOldCommentUsedByOwner ) ;
                    ZE( strokeS* , psttOldCommentUsedByIFC   ) ;
    
                    sIn1 >> idComputer             ;
                    sIn1 >> psttEmailOwner         ; ___( psttEmailOwner         ) ;
                    sIn1 >> psttNameUsedByOwner    ; ___( psttNameUsedByOwner    ) ;
                    sIn1 >> psttNameUsedByIFC      ; ___( psttNameUsedByIFC      ) ;
                    sIn1 >> psttNameUsedByInternet ; ___( psttNameUsedByInternet ) ;
                    sIn1 >> psttOldCommentUsedByOwner ; ___( psttOldCommentUsedByOwner ) ;
                    sIn1 >> psttOldCommentUsedByIFC   ; ___( psttOldCommentUsedByIFC   ) ;
                    *pNicNameRegistrand << sIn1    ;
    
                    tblHostsP.newEventF( tinP ) ;
                    tblHostsP.newObjectF( tinP , idComputer             ) ;
                    tblHostsP.newObjectF( tinP , psttEmailOwner         ) ; stDelete_strokeS_ptrP << psttEmailOwner         ;
                    tblHostsP.newObjectF( tinP , psttNameUsedByOwner    ) ; stDelete_strokeS_ptrP << psttNameUsedByOwner    ;
                    tblHostsP.newObjectF( tinP , psttNameUsedByIFC      ) ; stDelete_strokeS_ptrP << psttNameUsedByIFC      ;
                    tblHostsP.newObjectF( tinP , psttNameUsedByInternet ) ; stDelete_strokeS_ptrP << psttNameUsedByInternet ;
                    tblHostsP.newObjectF( tinP , psttOldCommentUsedByOwner ) ; stDelete_strokeS_ptrP << psttOldCommentUsedByOwner ;
                    tblHostsP.newObjectF( tinP , psttOldCommentUsedByIFC   ) ; stDelete_strokeS_ptrP << psttOldCommentUsedByIFC   ;
                    tblHostsP.newObjectF( tinP , *pNicNameRegistrand     ) ;
    
                    ZE( countT , cNicName ) ;
                    sIn1 >> cNicName ;
                    while( cNicName -- )
                    {
                        ZE( nicNameC* , pNicName ) ;
                        tinP.pEtScratch->newF( tinP , LF , pNicName ) ; ___( pNicName ) ;
                        if( pNicName )
                        {
                            //(pNicName WILL BE DELETED WHEN pStk_pNicName IS DELETED) stDelete_nicNameC_ptrP << pNicName ;
                            *pNicName = 0 ;
                            *pNicName << sIn1 ;
                            *pStk_pNicName << pNicName ;
                        }
                    }
                    tblHostsP.newObjectF( tinP , *pStk_pNicName ) ;
                }
            }
    
            soulC sIn2( tinP , TAG( TAGiDnULL ) ) ;
            soulC sOut2( tinP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcIDcMDsESSION_QUERYaDAMS ) ;
            sChat2.writeF( tinP , sOut2 ) ;
            sChat2.readF( tinP , sIn2 ) ;
    
            idReply = 0 ;
            sIn2 >> idReply ;
            __( idReply - ifcIDcMDsESSION_QUERYaDAMSrEPLY ) ;
    
            {
                ZE( countT , cFlavors ) ;
                sIn2 >> cFlavors ;
    
                b_idaLeverP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                b_idhLeverP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                while( cFlavors -- )
                {
                    idhLeverP = 0 ;
                    idhLeverP << sIn2 ;
    
                    ZE( countT , cAdams ) ;
                    sIn2 >> cAdams ;
    
                    while( cAdams -- )
                    {
                        idaLeverP = 0 ;
                        sIn2 >> idaLeverP ;
                        swsIdAdamP << idaLeverP ;
    
                        ZE( nicNameC* , pNicName  ) ;
                        ZE( nicNameC* , pNicName2 ) ;
                        tinP.pEtScratch->newF( tinP , LF , pNicName  ) ; ___( pNicName  ) ;
                        tinP.pEtScratch->newF( tinP , LF , pNicName2 ) ; ___( pNicName2 ) ;
                        if( pNicName && pNicName2 )
                        {
                            *pNicName2 = *pNicName = idhLeverP ;
                            swsNicNameP << pNicName2 ;
    
                            stDelete_nicNameC_ptrP << pNicName ;
                            tblCellsP.newEventF( tinP ) ;
                            tblCellsP.newObjectF( tinP , idaLeverP   ) ;
                            tblCellsP.newObjectF( tinP , *pNicName ) ;
                        }
                    }
                }
                b_idhLeverP.ungrabF( tinP ) ;
                b_idaLeverP.ungrabF( tinP ) ;
            }
    
            soulC sOut3( tinP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcIDcMDsESSION_BYE ) ;
            sChat2.writeF( tinP , sOut3 ) ;

            if( POOP ) POOPR
            else       bFail = 0 ;

            if( bFail )
            {
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                ++ s ; ( bNoQuit ? (etherC&)*tinP.pEtScratch : etPrime ).osSleepF( tinP , TOCK * 0x10 ) ;
            }
        }
        while( bFail && ( bNoQuit || ( !cTriesP && !etPrime ) || ( cTriesP && -- cTriesP ) ) ) ;
    }
    __( bFail ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600213b.etherc.ifccellhostsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600213c.etherc.ifccellhostsf BEGIN
#define DDNAME       "3func.3600213c.etherc.ifccellhostsf"
#define DDNUMB      (countT)0x3600213c
#define IDFILE      (countT)0xd59


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcCellHostsF.0.html\"\>instances\</A\>
\<A HREF=\"5.103017d.1.0.html\"\>definition\</A\>
arguments
 tinP
 pNicNameP
  must be 0
  after i return, will point to a null terminated array list of each host that is registered as currently hosting a cell of idAdamP
 cNicNameP
  must be 0
  after i return, will contain the number of nicNameC values that pNicNameP points to
*/
/**/

/*1*/voidT etherC::ifcCellHostsF( tinS& tinP , nicNameC*& pNicNameP , countT& cNicNameP , const countT idAdamP , countT cTriesP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pNicNameP ) ;
        __( cNicNameP ) ;
        __Z( idAdamP ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( countT , idaLever ) ;
    switchStackC swsNicName( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_null , idaLever , flSTACKc_null , ifcSTACKtYPE_PTR_nicNameC ) ;
    {
        batonC b_idaLever( tinP , TAG( TAGiDnULL ) ) ;

        nicNameC idhLever ;
        batonC b_idhLever( tinP , TAG( TAGiDnULL ) ) ;
        switchStackC swsIdAdam( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_null , idhLever ) ;

        tableC tblCells( tinP , *this , T("cells") ) ;
        tableC tblHosts( tinP , *this , T("hosts") ) ;

        stackC stDelete_strokeS_ptr( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
        stackC stDelete_nicNameC_ptr( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_nicNameC ) ;
        stackC stDelete_stackC_ptr(  tinP , *this , TAG( TAGiDnULL ) ) ;

        ifcCellHostsF( tinP , swsNicName , idaLever , b_idaLever , swsIdAdam , idhLever , b_idhLever , tblCells , tblHosts , stDelete_strokeS_ptr , stDelete_nicNameC_ptr , stDelete_stackC_ptr , cTriesP ) ;

        while( stDelete_stackC_ptr )
        {
            ZE( stackC* , pStk ) ;
            stDelete_stackC_ptr >> *(countT*)&pStk ;
            DEL( pStk ) ;
        }
    }

    idaLever = idAdamP ;
    cNicNameP = swsNicName ;
    newF( tinP , LF , pNicNameP , cNicNameP + 1 ) ; ___( pNicNameP ) ;
    if( pNicNameP )
    {
        ZE( countT , off ) ;
        for( ; off < cNicNameP ; off ++ )
        {
            ZE( nicNameC* , pNicName ) ;
            swsNicName >> pNicName ;
            if( pNicName ) pNicNameP[ off ] = *pNicName ;
            delF( tinP , pNicName ) ;
        }
        pNicNameP[ off ] = 0 ;
        __( swsNicName ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600213c.etherc.ifccellhostsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600213d.etherc.ifccellhostsf BEGIN
#define DDNAME       "3func.3600213d.etherc.ifccellhostsf"
#define DDNUMB      (countT)0x3600213d
#define IDFILE      (countT)0xd5a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcCellHostsF.0.html\"\>instances\</A\>
\<A HREF=\"5.103017e.1.0.html\"\>definition\</A\>
i evaluate to the address of a randomly chosen cell host for idAdamP
arguments
 tinP
 idAdamP
  must not be 0
 cTriesP
  if 0 then i will retry until a nonze value is obtained
   cTriesP will be made to successfully obtain a list of cell hosts
   if the list is null, or if randomly selecting a list item produces a null value, then cTriesP will also dictate retrying new lists
    if 0 then new lists will be obtained forever until a nonnull value is drawn from a list
  if 1 then 1 attempt will be made to obtain a list, and whatever is drawn from that list will be returned
*/
/**/

/*1*/nicNameC etherC::ifcCellHostsF( tinS& tinP , const countT idAdamP , countT cTriesP )/*1*/
{
    SCOOP
    nicNameC idhnu ;

    IFbEcAREFUL
    {
        if( POOP ) return idhnu ;
        __Z( idAdamP ) ;
        if( POOP ) return idhnu ;
    }

    _IO_

    nicNameC idhr ;
    IFsCRATCH
    {
        etherC& etPrime = etPrimeIF( tinP ) ;
        boolT bNoQuit = cTriesP == - 1 ;
        ranUniC ruSeed( tinP , 0xffffffff ) ;
        boolT bFail = 1 ;
        {
            SCOOPS
            do
            {
                {
                    ZE( nicNameC* , pNicName ) ;
                    ZE( countT   , cNicName ) ;
                    tinP.pEtScratch->ifcCellHostsF( tinP , pNicName , cNicName , idAdamP , cTriesP ) ; ___( pNicName ) ;
                    if( cNicName )
                    {
                        ranUniC ru( tinP , cNicName , ruSeed ) ;
                        idhr = pNicName ? pNicName[ ru ] : idhnu ;
                    }
                    delF( tinP , pNicName ) ;
        
                    __Z( idhr ) ;
                    if( !POOP ) bFail = 0 ;
                    else
                    {
                        POOPR
                        {
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                            ++ s ; ( bNoQuit ? (etherC&)*tinP.pEtScratch : etPrime ).osSleepF( tinP , TOCK * 0x10 ) ;
                        }
                    }
                }
            }
            while( bFail && ( bNoQuit || ( !cTriesP && !etPrime ) || ( cTriesP && -- cTriesP ) ) ) ;
        }
        __( bFail ) ;
    }
    return idhr ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600213d.etherc.ifccellhostsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600213e.etherc.ifcjobf BEGIN
#define DDNAME       "3func.3600213e.etherc.ifcjobf"
#define DDNUMB      (countT)0x3600213e
#define IDFILE      (countT)0xd5b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcJobF.0.html\"\>instances\</A\>
\<A HREF=\"5.103017f.1.0.html\"\>definition\</A\>
U: these comments might be obsolete; review them vis the actual code
i initiate an IdeaFarm " "(tm) City job and block until the job has been done
while the job is being done, other threads of the caller can communicate with the adam cell that is doing the work
if a failure occurs while establishing the connection spline, i will retry
if a failure occurs after the connection spline is established, i will retry with a new connection spline
requirements for the adam class
 acceptor cell and worker cell
  state changes must not be committed until job is done
   job is not done until client's null order has been received
   client must not send a null order until it has received a notice of pending commit
   a notice of pending commit
 U: edit the protocol to implement a state commit dialog
usage models
 unattended operation
  caller places all orders for the job onto stOrdersP before calling me
  the la'th order placed onto stOrdersP must be empty
  i return when the job is complete
  then the caller can obtain all of the courses produced by emptying stCoursesP
 attended operation
  caller places at least the wo'th order for the job onto stOrdersP
  caller launches a thread to monitor the contents of stCoursesP
   this thread -must- eventually place an empty order onto stOrdersP
   this thread can either traverse stCoursesP or empty it as courses are placed onto it
    it -must- serialize properly
   this thread can put an interrupt style cancel order onto stOrdersP to tell the server to cancel the job
    the contents of such an order would be defined by the particular idAdam
   this thread can end at any time during job processing as long as it has put an empty order onto stOrdersP
  when all courses have been put onto stCoursesP, i will return
  the caller can then remove all courses that have not already been removed by its attendant thread
protocol
 connect to idAdamP via relay chat
 remove the wo'th order, wrap it into the relay package, and write it
 launch a thread to receive courses into stCoursesP
  protocol for this thread
   forever
    read a tray
    if the tray is empty then break
    extract the course from the tray
    if the course is not empty, stack it
 forever
  wait for a new item to be placed onto stOrdersP
  remove all items in stOrdersP, writing each
 until an empty order has been sent
 wait for the course receiving thread to end
arguments
 stCoursesP
  must be flSTACKc_GIVEsIGNnEWpLATE
  must be flSTACKc_FIFO
  must be empty
 tinP
 idAdamP
 sOrderPrimaryP
  this is the order that defines the job
  normally this will contain all information needed for the job, and stOrdersP will be empty
 stOrdersP
  must be flSTACKc_GIVEsIGNnEWpLATE
  must be flSTACKc_FIFO
  can be empty
  contains all orders other than the primary order
  the caller and the job doer cell can, but need not, dialog in full duplex while the job is in progress
  for such dialogs, the caller puts outgoing orders onto stOrdersP and monitors stCoursesP for incoming results
 nicNameP
  can be 0
  normally should be 0
  specify a nonze value if the cell at the specified host is to handle the job
  it is bad style to specify a nonze value
   nonze values are supported to facilitate debugging
*/
/**/

/*1*/voidT etherC::ifcJobF( stackC& stCoursesP , tinS& tinP , const countT idAdamP , soulC& sOrderPrimaryP , stackC& stOrdersP , const strokeS* const psttOldCommentP , const nicNameC nicNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __(  stCoursesP ) ;
        __(  !( F(stCoursesP.flagsF(tinP)) & flSTACKc_FIFO ) ) ;
        __(  !( F(stCoursesP.flagsF(tinP)) & flSTACKc_GIVEsIGNnEWpLATE ) ) ;
        __(  stCoursesP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_soulC ) ;
        __(  !( F(stOrdersP.flagsF(tinP)) & flSTACKc_FIFO ) ) ;
        __(  !( F(stOrdersP.flagsF(tinP)) & flSTACKc_GIVEsIGNnEWpLATE ) ) ;
        __(  stOrdersP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_soulC ) ;
        __Z( idAdamP ) ;
        if( POOP ) return ;
    }

    _IO_
    {
        TN( tBar , "| " ) ;
        //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/setting up") , flSAY_APPEND | flSAY_LOG ) ;
        soulC sRelay( tinP , TAG( TAGiDnULL ) ) ;
        {
            soulC sJob( tinP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcIDcMDsESSION_JOB ) ;
            sJob << idAdamP ;
            nicNameP >> sJob ;
            sJob << (boolT)0 ; // bAccepted
            sJob << sOrderPrimaryP ;
    
            ifcChatRelayPackageF( tinP , sRelay , sJob , idAdamP , T(psttOldCommentP)+T(" (ifcJobF/inner)") , 1 , 0 , nicNameP ) ;
        }
    
        //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/connecting to local chat server") , flSAY_APPEND | flSAY_LOG ) ;
        {
            socketC soUp( tinP , *this , TAG( TAGiDnULL ) ) ;
            soUp.connectF( tinP , 0 , nicNameC() , 1 ) ;
            //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/writing relay package soulC") , flSAY_APPEND | flSAY_LOG ) ;
            soUp.writeF( tinP , sRelay ) ;

            {
                signC sgnReadTested( tinP , TAG( TAGiDnULL ) ) ;
                {
                    signC sgnDone_tmStackCourses( tinP , TAG( TAGiDnULL ) ) ;
                    osThreadF( tinP , countTC() , tmStackCoursesF , &sgnDone_tmStackCourses , flTHREADlAUNCH_null , 0 , (countT)this , (countT)&stCoursesP , (countT)&soUp , (countT)&sgnReadTested , (countT)&stOrdersP , (countT)(strokeS*)psttOldC( tinP , *this , psttOldCommentP ) ) ;
                    //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/waiting for sgnReadTested") , flSAY_APPEND | flSAY_LOG ) ;
                    if( !POOP ) sgnReadTested.waitF( tinP ) ;
                    //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/returned from waiting on sgnReadTested") , flSAY_APPEND | flSAY_LOG ) ;
                
                    ZE( boolT , bEmpty ) ;
                    while( !POOP && !bEmpty )
                    {
                        //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/waiting for an order to be pushed into stOrdersP") , flSAY_APPEND | flSAY_LOG ) ;
                        stOrdersP.waitF( tinP ) ;
                        //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/grabbing stOrdersP") , flSAY_APPEND | flSAY_LOG ) ;
                        stOrdersP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/emptying stOrdersP") , flSAY_APPEND | flSAY_LOG ) ;
                        while( !POOP && stOrdersP && !bEmpty )
                        {
                            ZE( soulC* , psOrder ) ;
                            stOrdersP >> psOrder ;
                            if( psOrder )
                            {
                                if( !*psOrder ) bEmpty = 1 ;
                                else            soUp.writeF( tinP , *psOrder ) ;
                            }
                            DEL( psOrder ) ;
                        }
                        stOrdersP.ungrabF( tinP ) ;
                    }
                    //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/waiting for tmStackCourses to end") , flSAY_APPEND | flSAY_LOG ) ;
                    sgnDone_tmStackCourses.waitF( tinP ) ;
                    //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/destroying sgnDone_tmStackCourses") , flSAY_APPEND | flSAY_LOG ) ;
                }
                //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/destroying sgnReadTested") , flSAY_APPEND | flSAY_LOG ) ;
            }
            //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/disconnecting from local chat server") , flSAY_APPEND | flSAY_LOG ) ;
        }
        //ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/cleaning up") , flSAY_APPEND | flSAY_LOG ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600213e.etherc.ifcjobf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600213f.etherc.ifcchatf BEGIN
#define DDNAME       "3func.3600213f.etherc.ifcchatf"
#define DDNUMB      (countT)0x3600213f
#define IDFILE      (countT)0xd5c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcChatF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030180.1.0.html\"\>definition\</A\>
a standard adam is an adam that calls me
by calling me, the adam declares that it is a multicellular sentient being ready to do jobs and interact with clients
this is a minimal wrapper to eliminate oo arguments that would always be 0 when making this declaration
*/
/**/

/*1*/voidT etherC::ifcChatF( tinS& tinP , const countT cArgP , const countT idAdamHandlingP , jobFillCourseFT jobFillCourseFP , jobHearOrderFT jobHearOrderFP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    /*U:: if( processGlobal1I.idAdamRoot == ifcIDaDAM_KERNEL2MONITOR || third.ifc CellIsWorkingIF( tinP , ifcIDaDAM_KERNEL2MONITOR , ".monitored" ) ) */ ifcChatF( tinP , cArgP , idAdamHandlingP , 0 , 0 , jobFillCourseFP , jobHearOrderFP ) ;
    //U::else { CONoUT("ifcChatF: ERROR: DID NOT CALL MY OVERLOAD\r\n") ; }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600213f.etherc.ifcchatf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002140.etherc.stridf BEGIN
#define DDNAME       "3func.36002140.etherc.stridf"
#define DDNUMB      (countT)0x36002140
#define IDFILE      (countT)0xd5d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strIdF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030181.1.0.html\"\>definition\</A\>
arguments
 psttSmallP
 psttBigP
*/
/**/

/*1*/countT etherC::strIdF( tinS& tinP , const strokeS* const psttSmallP , const strokeS* psttBigP , sCountT idP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( idP ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_

    countT idf = 1 ;_WQ
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;_WQ
    return strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , psttSmallP , psttBigP , 0 , idP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002140.etherc.stridf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002141.etherc.ifcjobf BEGIN
#define DDNAME       "3func.36002141.etherc.ifcjobf"
#define DDNUMB      (countT)0x36002141
#define IDFILE      (countT)0xd5e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcJobF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030184.1.0.html\"\>definition\</A\>
i initiate an IdeaFarm " "(tm) City job and block until the job has been done successfully
while the job is being done, other threads of the caller can communicate with the adam cell that is doing the work
if a failure occurs while establishing the connection spline, i will retry
if a failure occurs after the connection spline is established, i will retry with a new connection spline
requirements for the adam class
 acceptor cell and worker cell
  state changes must not be committed until job is done
   job is not done until client's null order has been received
   client must not send a null order until it has received a notice of pending commit
   a notice of pending commit
 U: edit the protocol to implement a state commit dialog
usage models
 unattended operation
  caller places all orders for the job onto stOrdersP before calling me
  the la'th order placed onto stOrdersP must be empty
  i return when the job is complete
  then the caller can obtain all of the courses produced by emptying stCoursesP
 attended operation
  caller places at least the wo'th order for the job onto stOrdersP
  caller launches a thread to monitor the contents of stCoursesP
   this thread -must- eventually place an empty order onto stOrdersP
   this thread can either traverse stCoursesP or empty it as courses are placed onto it
    it -must- serialize properly
   this thread can put an interrupt style cancel order onto stOrdersP to tell the server to cancel the job
    the contents of such an order would be defined by the particular idAdam
   this thread can end at any time during job processing as long as it has put an empty order onto stOrdersP
  when all courses have been put onto stCoursesP, i will return
  the caller can then remove all courses that have not already been removed by its attendant thread
protocol
 connect to idAdamP via relay chat
 remove the wo'th order, wrap it into the relay package, and write it
 launch a thread to receive courses into stCoursesP
  protocol for this thread
   forever
    read a tray
    if the tray is empty then break
    extract the course from the tray
    if the course is not empty, stack it
 forever
  wait for a new item to be placed onto stOrdersP
  remove all items in stOrdersP, writing each
 until an empty order has been sent
 wait for the course receiving thread to end
arguments
 tinP
 stCoursesP
  must be empty
 idAdamP
 sOrderPrimaryP
  this is the order that defines the job
  normally this will contain all information needed for the job, and stOrdersP will be empty
 stOrdersP
  can be empty
  contains all orders other than the primary order
  the caller and the job doer cell can, but need not, dialog in full duplex while the job is in progress
  for such dialogs, the caller puts outgoing orders onto stOrdersP and monitors stCoursesP for incoming results
 psttOldCommentP
  must not be 0
  must not be null length
  this string will be attached to this job as it traverses the relay chat spline
  any value is legal, but please use a concise description of the job that is unique to the current job
   recommend: concatenate: "description of job" "current time"
 cTriesP
 nicNameP
  can be nicNameC()
  normally should be nicNameC()
  specify another value if the cell at the specified host is to handle the job
  it is bad style to specify a value other than nicNameC()
   nicNameC() values are supported mainly to facilitate debugging
   ifcHireF specifies the local host in order to construct a local cell
*/
/**/

/*1*/voidT etherC::ifcJobF( tinS& tinP , stackC& stCoursesP , const countT idAdamP , soulC& sOrderPrimaryP , stackC& stOrdersP , const strokeS* const psttOldCommentP , countT cTriesP , const nicNameC nicNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __(  stCoursesP ) ;
        __(  !( F(stCoursesP.flagsF(tinP)) & flSTACKc_FIFO ) ) ;
        __(  stCoursesP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_soulC ) ;
        __(  !( F(stOrdersP.flagsF(tinP)) & flSTACKc_FIFO ) ) ;
        __(  stOrdersP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_soulC ) ;
        __Z( psttOldCommentP ) ;
        if( POOP ) return ;
        __( !psttOldCommentP->idAdam ) ;
        __Z( idAdamP ) ;
        if( POOP ) return ;
    }

    _IO_

    TN( tBar , "| " ) ;
    etherC& etPrime = etPrimeIF( tinP ) ;
    boolT bNoQuit = cTriesP == - 1 ;
    boolT bNoQuitEarly = !cTriesP ;
    boolT bFail = 1 ;
    ZE( countT , idTry ) ;
    boolT bWoth = 1 ;
    do
    {
        if( bWoth ) bWoth = 0 ;
        else
        {
            //CONoUT( "etherC::ifcJobF/outer/napping 8 tocks before trying again" )
            
            {
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                ++ s ; ( bNoQuit ? *this : etPrime ).osSleepF( tinP , TOCK * 8 ) ;
            }
        }

        if( bNoQuit || !etPrime )
        {
            //CONoUT( "etherC::ifcJobF/outer/calling my overload to try again" )

            IFsCRATCH
            {
                SCOOPS
                {
                    stackC stOrdersCopy( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , stOrdersP.flagsF( tinP ) , stOrdersP.idTypeF( tinP ) ) ;
                    if( stOrdersP )
                    {
                        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        do
                        {
                            soulC* psMaster = (soulC*)stOrdersP.downF( tinP , hDown ) ;
                            __Z( psMaster ) ;
                            if( psMaster )
                            {
                                soulC* psCopy = new( 0 , tinP , LF ) soulC( *psMaster ) ;
                                __Z( psCopy ) ;
                                stOrdersCopy << psCopy ;
                            }
                        }
                        while( !POOP && ~hDown ) ;
                    }
                    tinP.pEtScratch->ifcJobF( stCoursesP , tinP , idAdamP , sOrderPrimaryP , stOrdersCopy , T(psttOldCommentP)+T(" (try ")+TF1(++idTry)+T(")") , nicNameP ) ;
                }
    
                if( POOP )
                {
                    //CONoUT( "etherC::ifcJobF/outer/logging the failure of my overload" )
                    POOPR
                    ifcSayIF( TP("",9)+T(psttOldCommentP)+tBar+T("adam ")+TF1(idAdamP)+T(" failed to do a job for thread \"")+T(tinP.postThreadName)+T("\" of the local cell of adam ")+TF1(processGlobal1I.idAdamRoot) , flSAY_APPEND | flSAY_LOG ) ;
                    //CONoUT( "etherC::ifcJobF/outer/finished logging the failure of my overload" )
    
                    stCoursesP.purgeF( tinP ) ;
                }
                else bFail = 0 ;
            }
        }
    }
    while( bFail && !POOP && ( bNoQuit || ( bNoQuitEarly && !etPrime ) || ( cTriesP && -- cTriesP ) ) ) ;
    //CONoUT( "etherC::ifcJobF/outer/cleaning up" )
    __( bFail ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002141.etherc.ifcjobf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002142.etherc.strconcatenatef BEGIN
#define DDNAME       "3func.36002142.etherc.strconcatenatef"
#define DDNUMB      (countT)0x36002142
#define IDFILE      (countT)0xd5f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strConcatenateF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030185.1.0.html\"\>definition\</A\>
concatenates all strings in pstt1P into a single string
i must be called repeatedly if nested concatenations are required
i evaluate to 1 iff the resulting psttP is (still) a string of strings
if psttP is a simple string then i just copy the string
arguments
 tinP
 psttP
  must be 0
 pstt1P
  can be 0
   if 0 then psttP is replaced
  can be a simple string
  normally is a string of strings
  can be a string of strings of strings
  can be a string of strings of strings of strings, etc
 psttDelimiterP
  can be 0
  if not 0 then can be 0 length
  will be inserted between each snippet in st_psttP
 csttExtraP
  can be 0
*/
/**/

/*1*/boolT etherC::strConcatenateF( tinS& tinP , strokeS*& psttP , const strokeS* pstt1P , const strokeS* const psttDelimiterP , const flagsT flagsP , const countT* const pczIdCasteIncludeP , const countT* const pczIdCasteExcludeP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __( !!psttP == !!pstt1P ) ;
        FV( flSTRcONCATENATE , flagsP )                                                                                        \
        __( F(flagsP) & flSTRcONCATENATE_COPY ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    const countT cInclude = pczIdCasteIncludeP ? thirdC::c_strlenIF( tinP , pczIdCasteIncludeP ) : 0 ;
    const countT cExclude = pczIdCasteExcludeP ? thirdC::c_strlenIF( tinP , pczIdCasteExcludeP ) : 0 ;
    const boolT  bSeparate = !!( F(flagsP) & flSTRcONCATENATE_SEPARATE ) ;

    ZE( boolT , bDelete ) ;
    if( !pstt1P )
    {
        pstt1P = psttP ;
        psttP = 0 ;
        bDelete = 1 ;
    }

    ZE( boolT , bSOS ) ;
    ZE( countT , cMarks ) ; //NOT RETURNED IN THIS OVERLOAD (U::THE HIGH ORDER BIT COULD BE USED FOR bSOS, OR A countT& PARAMETER)
    if( !pstt1P->idAdam || pstt1P[ CSpREFIX ].idCaste != sc_PREFIXlENGTH )
    {
        strMakeF( tinP , LF , psttP , pstt1P , csttExtraP ) ; //CALLER MUST TAG ___( psttP ) ;
    }
    else
    {
        ZE( countT , csttValue ) ;
        ZE( countT , cIn ) ;
        {
            ZE( countT , csttSnips ) ;
            FORsTRINGSiN1( (strokeS*)pstt1P )
            {
                cIn ++ ;
                csttSnips += psttc1->idAdam ;
            }
            csttValue = csttSnips ;
            if( psttDelimiterP ) csttValue += ( cIn - 1 ) * psttDelimiterP->idAdam ;
        }

        strMakeF( tinP , LF , psttP , T("") , csttValue + csttExtraP ) ; //CALLER MUST TAG ___( psttP ) ;
        TN( tNull , "" ) ; tNull = T("") + S2( (countT)0 , sc_NULL ) ;
        ZE( boolT , bNullLag ) ;
        FORsTRINGSiN1( (strokeS*)pstt1P )
        {
            #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000010.strConcatenateF_woSnip.h"
            if( psttDelimiterP && -- cIn ) strFuseF( tinP , psttP , psttDelimiterP ) ;
        }
    }
    if( bDelete ) delF( tinP , (strokeS*&)pstt1P ) ;

    if( psttP && psttP->idAdam && psttP[ CSpREFIX ].idCaste == sc_PREFIXlENGTH ) bSOS = 1 ;
    return bSOS ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002142.etherc.strconcatenatef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002143.etherc.dnsformatqueryf BEGIN
#define DDNAME       "3func.36002143.etherc.dnsformatqueryf"
#define DDNUMB      (countT)0x36002143
#define IDFILE      (countT)0xd60


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dnsFormatQueryF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030187.1.0.html\"\>definition\</A\>
i build the image of the specified query
arguments
 tinP
 pbP
 cbP
 psttDomainP
 idTypeP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00101aa.ifcIDtYPEdNSqUERY!||
*/
/**/

/*1*/voidT etherC::dnsFormatQueryF( tinS& tinP , byteT*& pbP , countT& cbP , const strokeS* const psttDomainP , const countT idTypeP )/*1*/
{
    SCOOP
    strokeS sttBlank(' ') ;

    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pbP ) ;
        __( cbP ) ;
        __Z( psttDomainP ) ;
        __( strIdF( tinP , sttBlank , psttDomainP ) ) ;
        if( POOP ) return ;
        __( !psttDomainP->idAdam ) ;
        if( POOP ) return ;
    }

    ZE( strokeS* , pstt1w ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    strWordsOldF( tinP , pstt1w , psttDomainP , sttq , T(".") ) ; ___( pstt1w ) ;

    countT costName = 1 ; // TRAILING NULL
    FORsTRINGSiN1( pstt1w )
    {
        __( !psttc1->idAdam ) ;
        __( psttc1->idAdam > 0x3f ) ; // RFC1035/3/1
        costName += 1 + psttc1->idAdam ;
    }
    __( costName > 0x100 ) ; // RFC1035/3/1

    dnsMsgHeaderS header( tinP ) ;
    cbP = sizeof header + costName + 2 * sizeof( count01T ) ;
    newF( tinP , LF , pbP , cbP ) ; ___( pbP ) ;
    if( pbP )
    {
        byteT* pbc = pbP ;

        header.swabF() ;
        memCopyF( tinP , pbc , (byteT*)&header , sizeof header ) ; pbc += sizeof header ;

        FORsTRINGSiN1( pstt1w )
        {
            TN( tw , "" ) ; tw = T(psttc1) ;
            countT cbw = tw.csF( tinP ) ;

            *pbc = (byteT)cbw                           ; pbc ++     ;
            memCopyF( tinP , pbc , (osTextT*)tw , cbw ) ; pbc += cbw ;
        }
        *pbc = 0 ;                                                    pbc ++     ;
        *(count01T*)pbc = SWABnET2( (count01T)idTypeP ) ;           pbc += sizeof( count01T ) ;
        *(count01T*)pbc = SWABnET2( (count01T)1       ) ;           pbc += sizeof( count01T ) ; //CODE FOR THE "INTERNET" CLASS (REFERENCED BUT NOT SPECIFIED IN RFC1035)

        __( pbc - pbP - cbP ) ;
    }
    delF( tinP , pstt1w ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002143.etherc.dnsformatqueryf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002144.etherc.dnsskiplabelsf BEGIN
#define DDNAME       "3func.36002144.etherc.dnsskiplabelsf"
#define DDNUMB      (countT)0x36002144
#define IDFILE      (countT)0xd61


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dnsSkipLabelsF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030188.1.0.html\"\>definition\</A\>
arguments
 pbP
  must point to the beginning of the label
  will point to the end of the label
*/
/**/
/*1*/voidT etherC::dnsSkipLabelsF( tinS& tinP , const byteT*& pbP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( pbP ) ;
        if( POOP ) return ;
    }

    _IO_

    for(;;)
    {
        if( ( *pbP & 0xc0 ) == 0xc0 )
        {
            pbP += 2 ;
            break ;
        }
        else if( *pbP & 0xc0 ) ;//TELLsYSc1( ifcIDtYPEtELLsYS_ERRORlABELtOOlONG )
        else
        {
            pbP += 1 + *pbP ;
            if( !*pbP )
            {
                pbP ++ ;
                break ;
            }
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002144.etherc.dnsskiplabelsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002145.etherc.dnsnicnamesf BEGIN
#define DDNAME       "3func.36002145.etherc.dnsnicnamesf"
#define DDNUMB      (countT)0x36002145
#define IDFILE      (countT)0xd62


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dnsNicNamesF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030189.1.0.html\"\>definition\</A\>
i obtain the names of the mail servers for a domain
if no server name is available, impotence does not occur
 i just push the value of psttDomainP
*/
/**/

/*1*/voidT etherC::dnsNicNamesF( tinS& tinP , stackC& st_psttServerP , const strokeS* const psttDomainP , const countT idTypeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        __( st_psttServerP ) ;
        __( st_psttServerP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_strokeS ) ;
        __Z( psttDomainP ) ;
        __Z( idTypeP ) ;
    }

    _IO_

    stackC stSoul( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_soulC ) ;
    dnsQueryF( tinP , stSoul , psttDomainP , idTypeP ) ;

    while( !POOP && stSoul )
    {
        ZE( soulC* , ps ) ;
        stSoul >> ps ;
        if( ps )
        {
            soulC& soul = *ps ;

            ZE( countT , idTypeAnswer ) ;
            soul >> idTypeAnswer ;

            {
                ZE( strokeS* , psttw ) ;
                soul >> psttw ; ___( psttw ) ;
                delF( tinP , psttw ) ;
            }

            ZE( countT , idTypeInfo ) ;
            soul >> idTypeInfo ;

            ZE( countT , idClass ) ;
            soul >> idClass ;

            {
                ZE( countT  , time1 ) ;
                ZE( sCountT , time2 ) ;
                soul >> time1 ;
                soul >> (countT&)time2 ;
            }

            switch( idTypeInfo )
            {
                case ifcIDtYPEdNSqUERY_MX :
                {
                    ZE( countT , cRank ) ;
                    soul >> cRank ;

                    ZE( strokeS* , psttw ) ;
                    soul >> psttw ; ___( psttw ) ;
                    if( idTypeAnswer == ifcIDtYPEdNSrEPLY_ANSWER ) st_psttServerP << psttw ;
                    else                                           delF( tinP , psttw ) ;

                    break ;
                }
                default:
                {
                    if( idTypeAnswer == ifcIDtYPEdNSrEPLY_ANSWER )
                    {
                        __( idTypeInfo ) ;
                        __1
                    }
                }
            }
        }
        DEL( ps ) ;
    }

    if( !st_psttServerP ) st_psttServerP << psttOldC( tinP , *this , psttDomainP ) ; // PER CLARIFICATION RFC ON DNS; THIS WAS REALLY NEEDED (AS I RECALL THE ABSENCE OF THIS LINE CAUSED A FAILURE THAT THIS LINE CORRECTED)
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002145.etherc.dnsnicnamesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002146.etherc.dnsnicnamesf BEGIN
#define DDNAME       "3func.36002146.etherc.dnsnicnamesf"
#define DDNUMB      (countT)0x36002146
#define IDFILE      (countT)0xd63


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dnsNicNamesF.0.html\"\>instances\</A\>
\<A HREF=\"5.103018a.1.0.html\"\>definition\</A\>
*/
/**/
/*1*/voidT etherC::dnsNicNamesF( tinS& tinP , strokeS*& psttServerP , const strokeS* const psttDomainP , const countT idTypeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        __NZ( psttServerP ) ;
        __Z( psttDomainP ) ;
        __Z( idTypeP ) ;
    }

    _IO_
    stackC st_psttServer( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    dnsNicNamesF( tinP , st_psttServer , psttDomainP , idTypeP ) ;
    if( st_psttServer ) st_psttServer >> psttServerP ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002146.etherc.dnsnicnamesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002147.etherc.dnsqueryf BEGIN
#define DDNAME       "3func.36002147.etherc.dnsqueryf"
#define DDNUMB      (countT)0x36002147
#define IDFILE      (countT)0xd64


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dnsQueryF.0.html\"\>instances\</A\>
\<A HREF=\"5.103018b.1.0.html\"\>definition\</A\>
impotence will -not- occur if i do not receive a reply
 this can occur due to asynch impotence or due to timeout
the caller must test whether stsRepliesP contains any plates to determine whether i failed to receive an answer
if time1P and time2P are 0 then i will block until i either receive a reply or asynch impotence occurs
arguments
 tinP
 stsRepliesP
 psttDomainP
 idTypeP
 time1P
 time2P
*/
/**/

/*1*/voidT etherC::dnsQueryF( tinS& tinP , stackC& stsRepliesP , const strokeS* const psttDomainP , const countT idTypeP , const countT time1P , const sCountT time2P )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        __( stsRepliesP ) ;
        __( stsRepliesP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_soulC ) ;
        __Z( psttDomainP ) ;
        __Z( idTypeP ) ;
    }

    _IO_

    ZE( byteT* , pbReply ) ;
    ZE( countT , cbReply ) ;
    dnsQueryF( tinP , pbReply , cbReply , psttDomainP , idTypeP , time1P , time2P ) ; ___( pbReply ) ;

    ZE( byteT* , pbnu ) ;
    ZE( countT , cbnu ) ;
    stackC stsQueriesNU( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_soulC ) ;
    if( pbReply ) dnsParseF( tinP , pbnu , cbnu , stsQueriesNU , stsRepliesP , pbReply , cbReply ) ;
    delF( tinP , pbnu ) ;
    delF( tinP , pbReply ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002147.etherc.dnsqueryf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002148.etherc.dnsreplyf BEGIN
#define DDNAME       "3func.36002148.etherc.dnsreplyf"
#define DDNUMB      (countT)0x36002148
#define IDFILE      (countT)0xd65


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dnsReplyF.0.html\"\>instances\</A\>
\<A HREF=\"5.103018c.1.0.html\"\>definition\</A\>
the caller must verify cbP <= 002 if pbP will be sent using a datagram
 if the caller is to send a truncated record via datagram, be sure to patch pbP to set the bTruncated bit in the header
arguments
 tinP
 pbP
 cbP
 pbQueryP
 stsRepliesP
 bAuthoritativeP
 idErrorP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00101b4.ifcIDeRRORdNS!||
*/
/**/

/*1*/voidT etherC::dnsReplyF( tinS& tinP , byteT*& pbP , countT& cbP , const byteT* const pbQueryP , stackC& stsRepliesP , const boolT bAuthoritativeP , const countT idErrorP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        __NZ( pbP ) ;
        __( cbP ) ;
        __Z( pbQueryP ) ;
        __( bAuthoritativeP > 1 ) ;
    }

    _IO_

    stackC stSnip( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_count2S ) ; // [ pb , cb ]

    ZE( countT , offo ) ; //WHERE I AM IN THE OUTPUT IMAGE; THIS NEEDS TO BE KNOWN TO CALCULATE LABEL COMPRESSION WHILE MAKING THE SNIPPETS
    ZE( strokeS* , psttl ) ;
    switchC swOff( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttl ) ;

    // STEP 1: MAKE THE UNEDITED HEADER/QUERY SNIPPET (THIS SNIPPET WILL NEED TO BE EDITED BEFORE USE)
    {
        ZE( const byteT* , pbe ) ;
        {
            dnsMsgHeaderS header = *(dnsMsgHeaderS*)pbQueryP ;  //U::BUG: SHOULD THIS BE A REFERENCE RATHER THAN A COPY?
            pbe = pbQueryP + sizeof( dnsMsgHeaderS ) ; // QNAME
            header.swabF() ;
            countT cq = header.cQuerys ;
            header.swabF() ;
            while( cq -- )
            {
                countT offl = pbe - pbQueryP ;
                dnsLabelsF( tinP , psttl , pbe , (dnsMsgHeaderS*)pbQueryP ) ; ___( psttl ) ;
                //ifcSayIF( T("label at offset ")+TF1(offl)+T(": \"")+T(psttl)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
                swOff = offl ;
                delF( tinP , psttl ) ;

                pbe += 2 * sizeof( count01T ) ;
            }
        }

        ZE( count2S* , pc2s ) ;
        newF( tinP , LF , pc2s ) ; ___( pc2s ) ;
        if( pc2s )
        {
            pc2s->c1 = 0 ;
            pc2s->c2 = pbe - pbQueryP ;
            newF(     tinP , LF , (byteT*&)pc2s->c1            , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
            memCopyF( tinP      , (byteT*&)pc2s->c1 , pbQueryP , pc2s->c2 ) ;
            stSnip << pc2s ;
            offo += pc2s->c2 ;
        }
    }

    // STEP 2: MAKE EACH REMAINING SNIPPET THAT IS TO APPEAR IN THE FINAL IMAGE
    // DNS COMPRESSION IS -NOT- USED; EACH NAME IS WRITTEN IN FULL
    // RATIONALE: (1) NO BENEFIT UNLESS EXCEED DATAGRAM SIZE (2) IFC NAMES WILL BE SHORT, AND REPLIES WILL BE FEW (3) CAN EDIT THIS CODE TO USE COMPRESSION LATER, IF IT IS NEEDED
    ZE( countT , cAnsw ) ;
    ZE( countT , cAuth ) ;
    ZE( countT , cNote ) ;
    TN( tDot , "." ) ;
    while( !POOP && stsRepliesP ) // EACH soulC OBJECT DEFINES A SINGLE RR (RESOURCE RECORD)
    {
        ZE( soulC* , pSoul ) ;
        stsRepliesP >> pSoul ;
        if( pSoul )
        {
            soulC& soul = *pSoul ;

            ZE( countT , idTypeAnswer ) ; // ACCUMULATE COUNTERS FOR LATER INSERTION INTO HEADER
            soul >> idTypeAnswer ;
            switch( idTypeAnswer )
            {
                case ifcIDtYPEdNSrEPLY_ANSWER    : { cAnsw ++ ; break ; }
                case ifcIDtYPEdNSrEPLY_AUTHORITY : { cAuth ++ ; break ; }
                case ifcIDtYPEdNSrEPLY_NOTE      : { cNote ++ ; break ; }
                default:
                {
                    __( idTypeAnswer ) ;
                    __1
                }
            }

            ZE( strokeS* , psttw1 ) ;
            ZE( count2S* , pc2s ) ;

            { ZE( count01T , cnu ) ; pushLabelsF( tinP , *this , stSnip , offo , cnu , soul , swOff , psttl ) ; }

            ZE( countT , idType ) ; // THE MIDDLE OF THE RR
            soul >> idType ;
            ZE( countT , idClass ) ;
            soul >> idClass ;
            ZE( countT , time1 ) ;
            soul >> time1 ;
            ZE( sCountT , time2 ) ;
            soul >> (countT&)time2 ;

            ZE( count01T* , p_cbData ) ;
            newF( tinP , LF , pc2s ) ; ___( pc2s ) ;
            if( pc2s )
            {
                pc2s->c1 = 0 ;
                pc2s->c2 = sizeof( dnsResourceMiddleS ) ;
                newF( tinP , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                if( pc2s->c1 )
                {
                    dnsResourceMiddleS& rMiddle = *(dnsResourceMiddleS*)pc2s->c1 ;
                    rMiddle.idType        = (count01T)idType ;
                    rMiddle.idClass       = (count01T)idClass ;
                    rMiddle.secondsToLive = third.secondsFromTimeIF( tinP , time1 , time2 ) ;
                    rMiddle.cbData        = 0 ; //WILL BE ACCUMULATED AND THEN SWABBED
                    rMiddle.swabF() ;
                    p_cbData = &rMiddle.cbData ;
                }
                stSnip << pc2s ;
                offo += pc2s->c2 ;
                pc2s = 0 ;
            }

            if( p_cbData )
            {
                count01T& cbData = *p_cbData ;

                switch( idType )
                {
                    case ifcIDtYPEdNSqUERY_OPTION :
                    {
                        //U:ECHO BACK THE OPTION INFORMATION
                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_A :
                    {
                        nicNameC nicName ;
                        nicName << soul ;
                        newF( tinP , LF , pc2s ) ; ___( pc2s ) ;
                        if( pc2s )
                        {
                            pc2s->c1 = 0 ;
                            pc2s->c2 = sizeof( count02T ) ;
                            newF( tinP , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                            if( pc2s->c1 ) *(count02T*)pc2s->c1 = SWABnET4( (count02T)*(const countT*)nicName ) ;
                            stSnip << pc2s ;
                            offo += pc2s->c2 ;
                            cbData += (count01T)pc2s->c2 ;
                            pc2s = 0 ;
                        }
                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_MINFO :
                    {
                        pushLabelsF( tinP , *this , stSnip , offo , cbData , soul , swOff , psttl ) ; // INTENTIONAL FALLTHROUGH
                    }
                    case ifcIDtYPEdNSqUERY_NS :
                    case ifcIDtYPEdNSqUERY_CNAME :
                    case ifcIDtYPEdNSqUERY_MB :
                    case ifcIDtYPEdNSqUERY_MG :
                    case ifcIDtYPEdNSqUERY_MR :
                    case ifcIDtYPEdNSqUERY_PTR :
                    {
                        pushLabelsF( tinP , *this , stSnip , offo , cbData , soul , swOff , psttl ) ;
                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_HINFO :
                    case ifcIDtYPEdNSqUERY_TXT :
                    {
                        ZE( countT , cText ) ;
                        soul >> cText ;

                        while( cText -- )
                        {
                            ZE( strokeS* , psttw ) ;
                            soul >> psttw ; ___( psttw ) ;
                            if( psttw )
                            {
                                newF( tinP , LF , pc2s ) ; ___( pc2s ) ;
                                if( pc2s )
                                {
                                    pc2s->c1 = 0 ;
                                    pc2s->c2 = 1 + psttw->idAdam ;
                                    newF( tinP , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                                    if( pc2s->c1 )
                                    {
                                        byteT* pbc = (byteT*)pc2s->c1 ;
                                        *( pbc ++ ) = (byteT)psttw->idAdam ;
                                        for( countT ids = 1 ; ids <= psttw->idAdam ; ids ++ ) *( pbc ++ ) = (byteT)psttw[ CSpREFIX - 1 + ids ].idAdam ;
                                    }
                                    stSnip << pc2s ;
                                    offo += pc2s->c2 ;
                                    cbData += (count01T)pc2s->c2 ;
                                    pc2s = 0 ;
                                }
                            }
                            delF( tinP , psttw ) ;
                        }

                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_MX :
                    {
                        ZE( countT , cRank ) ;
                        soul >> cRank ;

                        newF( tinP , LF , pc2s ) ; ___( pc2s ) ;
                        if( pc2s )
                        {
                            pc2s->c1 = 0 ;
                            pc2s->c2 = sizeof( count01T ) ;
                            newF( tinP , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                            if( pc2s->c1 ) *(count01T*)pc2s->c1 = SWABnET2( (count01T)cRank ) ;
                            stSnip << pc2s ;
                            offo += pc2s->c2 ;
                            cbData += (count01T)pc2s->c2 ;
                            pc2s = 0 ;
                        }

                        pushLabelsF( tinP , *this , stSnip , offo , cbData , soul , swOff , psttl ) ;

                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_NULL :
                    {
                        __1 //U:
                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_SOA :
                    {
                        pushLabelsF( tinP , *this , stSnip , offo , cbData , soul , swOff , psttl ) ;
                        pushLabelsF( tinP , *this , stSnip , offo , cbData , soul , swOff , psttl ) ;

                        ZE( countT , cSerial ) ;
                        soul >> cSerial ;

                        newF( tinP , LF , pc2s ) ; ___( pc2s ) ;
                        if( pc2s )
                        {
                            pc2s->c1 = 0 ;
                            pc2s->c2 = sizeof( count02T ) ;
                            newF( tinP , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                            if( pc2s->c1 ) *(count02T*)pc2s->c1 = SWABnET4( (count02T)cSerial ) ;
                            stSnip << pc2s ;
                            offo += pc2s->c2 ;
                            cbData += (count01T)pc2s->c2 ;
                            pc2s = 0 ;
                        }

                        countT cTries = 4 ; // REFRESH RETRY EXPIRE MINIMUM
                        while( cTries -- )
                        {
                            ZE( countT  , time1 ) ;
                            ZE( sCountT , time2 ) ;
                            soul >> time1 ;
                            soul >> (countT&)time2 ;
                            count02T ss = third.secondsFromTimeIF( tinP , time1 , time2 ) ;

                            newF( tinP , LF , pc2s ) ; ___( pc2s ) ;
                            if( pc2s )
                            {
                                pc2s->c1 = 0 ;
                                pc2s->c2 = sizeof( count02T ) ;
                                newF( tinP , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                                if( pc2s->c1 ) *(count02T*)pc2s->c1 = SWABnET4( ss ) ;
                                stSnip << pc2s ;
                                offo += pc2s->c2 ;
                                cbData += (count01T)pc2s->c2 ;
                                pc2s = 0 ;
                            }
                        }

                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_WKS :
                    {
                        {
                            nicNameC nicName ;
                            nicName << soul ;
                            newF( tinP , LF , pc2s ) ; ___( pc2s ) ;
                            if( pc2s )
                            {
                                pc2s->c1 = 0 ;
                                pc2s->c2 = sizeof( count02T ) ;
                                newF( tinP , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                                if( pc2s->c1 ) *(count02T*)pc2s->c1 = SWABnET4( (count02T)*(const countT*)nicName ) ;
                                stSnip << pc2s ;
                                offo += pc2s->c2 ;
                                cbData += (count01T)pc2s->c2 ;
                                pc2s = 0 ;
                            }
                        }

                        {
                            ZE( countT , cProtocol ) ;
                            soul >> cProtocol ;

                            newF( tinP , LF , pc2s ) ; ___( pc2s ) ;
                            if( pc2s )
                            {
                                pc2s->c1 = 0 ;
                                pc2s->c2 = 1 ;
                                newF( tinP , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                                if( pc2s->c1 ) *(byteT*)pc2s->c1 = (byteT)cProtocol ;
                                stSnip << pc2s ;
                                offo += pc2s->c2 ;
                                cbData += (count01T)pc2s->c2 ;
                                pc2s = 0 ;
                            }
                        }

                        {
                            newF( tinP , LF , pc2s ) ; ___( pc2s ) ;
                            if( pc2s )
                            {
                                pc2s->c2 = pc2s->c1 = 0 ;
                                soul.shiftRightF( tinP , (byteT*&)pc2s->c1 , pc2s->c2 , ifcIDtYPEsOULiTEM_byteTptr ) ; ___( (byteT*&)pc2s->c1 ) ;
                                stSnip << pc2s ;
                                offo += pc2s->c2 ;
                                cbData += (count01T)pc2s->c2 ;
                                pc2s = 0 ;
                            }
                        }

                        break ;
                    }
                    default :
                    {
                        __( idType ) ;
                        __1
                        break ;
                    }
                }
                cbData = SWABnET2( cbData ) ;
            }
        }
        DEL( pSoul ) ;
    }

    //DEBUGGING
    //{
    //    countT cFlavors = swOff.cFlavorsF( tinP ) ;
    //    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    //    {
    //        psttl = (strokeS*)swOff.leverF( tinP , idf ) ;
    //        ifcSayIF( T("label registered at offset ")+TF1(swOff)+T(": \"")+T(psttl)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
    //    }
    //}

    ZE( countT , cba ) ; // STEP 3: MAKE THE FINAL IMAGE BY CONCATENATING THE SNIPPETS
    if( stSnip )
    {
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        do
        {
            count2S* pc2s = (count2S*)stSnip.downF( tinP , hDown ) ;
            if( pc2s ) cba += pc2s->c2 ;
        }
        while( !POOP && ~hDown ) ;

        newF( tinP , LF , pbP , cba + 1 ) ; ___( pbP ) ;
        if( pbP )
        {
            pbP[ cba ] = 0 ;

            byteT*       pbc = pbP ;
            byteT* const pbe = pbc + cba ;
            while( stSnip && !POOP )
            {
                ZE( count2S* , pc2s ) ;
                stSnip >> pc2s ;
                if( pc2s )
                {
                    __( pbc            >= pbe ) ;
                    __( pbc + pc2s->c2 >  pbe ) ;

                    memCopyF( tinP , pbc , (byteT*)pc2s->c1 , pc2s->c2 ) ;

                    if( pbc == pbP )
                    {
                        dnsMsgHeaderS& header = *(dnsMsgHeaderS*)pbc ;
                        header.swabF() ;

                        header.bReply          = 1 ;
                        header.bAuthoritative  = (byteT)bAuthoritativeP ;
                        header.bTruncated      = 0 ;
                        header.bCanRecurse     = 0 ;
                        header.reserved1       = 0 ;
                        header.cAnswers        = (count01T)cAnsw ;
                        header.cAuthorities    = (count01T)cAuth ;
                        header.cNotes          = (count01T)cNote ;

                        switch( idErrorP )
                        {
                            case ifcIDeRRORdNS_AOK               : { header.idError = (byteT)0 ; break ; }
                            case ifcIDeRRORdNS_CANNOTpARSEqUERY  : { header.idError = (byteT)1 ; break ; }
                            case ifcIDeRRORdNS_TRYaGAINlATER     : { header.idError = (byteT)2 ; break ; }
                            case ifcIDeRRORdNS_NAMEnOTdEFINED    : { header.idError = (byteT)3 ; break ; }
                            case ifcIDeRRORdNS_QUERYnOTsUPPORTED : { header.idError = (byteT)4 ; break ; }
                            case ifcIDeRRORdNS_QUERYrEFUSED      : { header.idError = (byteT)5 ; break ; }
                            default:
                            {
                                __( idErrorP ) ;
                                __1
                            }
                        }

                        header.swabF() ;
                    }

                    pbc += pc2s->c2 ;
                    delF( tinP , (byteT*&)pc2s->c1 ) ;
                }
                delF( tinP , pc2s ) ;
            }
            __( pbc - pbe ) ;
        }
        cbP = cba ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002148.etherc.dnsreplyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002149.etherc.dnslabelsf BEGIN
#define DDNAME       "3func.36002149.etherc.dnslabelsf"
#define DDNUMB      (countT)0x36002149
#define IDFILE      (countT)0xd66


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dnsLabelsF.0.html\"\>instances\</A\>
\<A HREF=\"5.103018d.1.0.html\"\>definition\</A\>
i compress if an entire earlier name is contained within psttP
*/
/**/

/*1*/voidT etherC::dnsLabelsF( tinS& tinP , byteT*& pbP , countT& cbP , const strokeS* const psttP , switchC& swOffP , strokeS*& psttLeverP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pbP ) ;
        __( cbP ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( countT , offBest ) ;
    ZE( strokeS* , psttBest ) ;
    {
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT cFlavors = swOffP.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            psttLeverP = (strokeS*)swOffP.leverF( tinP , idf ) ;
            //ifcSayIF( T("looking for portions of \"")+T(psttLeverP)+T("\", registered at ")+TF1(swOffP)+T(", in \"")+T(psttP)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
            countT idc = 1 ;
            while( idc )
            {
                ZE( strokeS* , pstts ) ;
                strSubstringF( tinP , pstts , countTC( idc ) , countTC() , psttLeverP ) ; ___( pstts ) ;
                //ifcSayIF( T("looking for \"")+T(pstts)+T("\" in \"")+T(psttP)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
    
                countT ida = strIdF( tinP , pstts , psttP ) ;
                if( ida && ( ( ida == 1 && idc == 1 ) || psttP[ CSpREFIX - 3 + ida + idc ] == S1C('.') ) )
                {
                    ZE( strokeS* , psttn ) ;
                    if( ida + idc >= 3 ) { strSubstringF( tinP , psttn , countTC( 1 ) , countTC( ida + idc - 3 ) , psttP ) ; ___( psttn ) ; }
    
                    //ifcSayIF(psttn ? T("bingo: the new portion is: \"")+T(psttn)+T("\"") : T("bingo: an exact repeat (no new prefix)") , flSAY_APPEND | flSAY_LOG ) ;
                    if( !psttBest || !psttn || psttn->idAdam < psttBest->idAdam )
                    {
                        delF( tinP , psttBest ) ;
                        psttBest = psttn ;
                        offBest = swOffP ;
                    }
                    else delF( tinP , psttn ) ;
                    delF( tinP , pstts ) ;
                    break ;
                }
                else
                {
                    countT idp = strIdF( tinP , T(".") , pstts ) ;
                    if( !idp ) idc = 0 ;
                    else       idc += idp + 1 ;
                    delF( tinP , pstts ) ;
                }
            }
        }
    }

    if( !offBest ) // THERE CANNOT BE A LABEL AT OFFSET 0
    {
        if( !psttBest ) psttBest = (strokeS*)psttP ;
        else            __1
    }

    countT cba = offBest ? 2 : 1 ; // FOR TERMINATING NULL OR TERMINATING REFERENCE
    ZE( strokeS* , pstt1w ) ;
    if( psttBest )
    {
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        strWordsOldF( tinP , pstt1w , psttBest , sttq , T(".") ) ; ___( pstt1w ) ;
        if( psttBest != psttP ) delF( tinP , psttBest ) ;
        FORsTRINGSiN1( pstt1w )
        {
            __( !psttc1->idAdam ) ;
            __( psttc1->idAdam > 0x3f ) ; //RFC1035/2/3/4
            cba += 1 + psttc1->idAdam ;
        }
        __( cba > 0xff ) ; //RFC1035/2/3/4
    }

    newF( tinP , LF , pbP , cba ) ; ___( pbP ) ;
    if( pbP )
    {
        byteT* pbc = pbP ;
        if( pstt1w )
        {
            FORsTRINGSiN1( pstt1w )
            {
                *( pbc ++ ) = (byteT)psttc1->idAdam ;
                for( countT ids = 1 ; ids <= psttc1->idAdam ; ids ++ ) *( pbc ++ ) = (byteT)psttc1[ CSpREFIX - 1 + ids ].idAdam ;
            }
        }
        if( offBest )
        {
            *(count01T*)pbc = (count01T)( SWABnET2( offBest | 0xc000 ) ) ;
            pbc += 2 ;
        }
        else *( pbc ++ ) = 0 ;

        __( pbc - pbP - cba ) ;    

        cbP = cba ;
    }
    delF( tinP , pstt1w ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002149.etherc.dnslabelsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600214a.etherc.dnsparsef BEGIN
#define DDNAME       "3func.3600214a.etherc.dnsparsef"
#define DDNUMB      (countT)0x3600214a
#define IDFILE      (countT)0xd67


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dnsParseF.0.html\"\>instances\</A\>
\<A HREF=\"5.103018e.1.0.html\"\>definition\</A\>
i obtain information by parsing the dns reply at headerP
 20130918@0900: U:: i should be edited to refer to the input as a "dns message" rather than a "dns reply"
arguments
 tinP
 pbHeaderAndQueriesP
  must be 0
  i will allocate this and copy the header and queries portion of the data at pbReplyP into it
 cbHeaderAndQueriesP
  must be 0
  i will set it to the length of the data that i put into pbHeaderAndQueriesP
 stsQueriesP
  each soul is a query
   psttName
   idType
   idClass
 stsRepliesP
  must be empty
  i will put a soulC object onto this stack for each resource record at pbReplyP
  the soulC object will contain the resource information from wo resource record
 pbReplyP  
  must not be 0
  must contain the address of a full dns reply
   a dnsMsgHeaderS followed by the number of queries, answers, authorities, and notes indicated in that header
 cbReplyP
  the length of the data at pbReplyP
*/
/**/

/*1*/voidT etherC::dnsParseF( tinS& tinP , byteT*& pbHeaderAndQueriesP , countT& cbHeaderAndQueriesP , stackC& stsQueriesP , stackC& stsRepliesP , const byteT* const pbReplyP , const countT cbReplyP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pbHeaderAndQueriesP ) ;
        __( cbHeaderAndQueriesP ) ;
        __( stsQueriesP ) ;
        __( stsQueriesP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_soulC ) ;
        __( stsRepliesP ) ;
        __( stsRepliesP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_soulC ) ;
        __Z( pbReplyP ) ;
        __( cbReplyP <= sizeof( dnsMsgHeaderS ) ) ;
        if( POOP ) return ;
    }

    _IO_

    dnsMsgHeaderS& header = *(dnsMsgHeaderS*)pbReplyP ;
    header.swabF() ;
    const byteT* pbc = pbReplyP + sizeof( dnsMsgHeaderS ) ; // QNAME
    const byteT* const pbe = pbReplyP + cbReplyP ;

    // LOAD stsQueriesP AND SET pbc TO THE END OF THE QUERIES PORTION OF pbReplyP
    {
        countT cq = header.cQuerys ;
        while( pbc < pbe && cq -- )
        {
            ZE( strokeS* , psttName ) ;
            header.nameF( tinP , *this , psttName , pbc , pbe - pbc ) ; ___( psttName ) ;

            if( pbc + 2 * sizeof( count01T ) > pbe )
            {
                delF( tinP , psttName ) ;
                __1
                break ;
            }
            else
            {
                countT v1 = SWABnET2( *(count01T*)pbc ) ; pbc += sizeof( count01T ) ;
                countT v2 = SWABnET2( *(count01T*)pbc ) ; pbc += sizeof( count01T ) ;

                soulC* pSoul = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( pSoul ) ;
                if( !pSoul )
                {
                    delF( tinP , psttName ) ;
                    __1
                    break ;
                }
                else
                {
                    soulC& soul = *pSoul ;

                    soul << psttName ;
                    delF( tinP , psttName ) ;
                    soul << v1 ;
                    soul << v2 ;

                    stsQueriesP << pSoul ;
                }
            }
        }
    }

    if( !POOP )
    {
        cbHeaderAndQueriesP = pbc - pbReplyP ;
        newF( tinP , LF , pbHeaderAndQueriesP , cbHeaderAndQueriesP ) ; ___( pbHeaderAndQueriesP ) ;
        memCopyF( tinP , pbHeaderAndQueriesP , pbReplyP , cbHeaderAndQueriesP ) ;

        countT cResources = header.cAnswers + header.cAuthorities + header.cNotes ;
        countT cAnsw = header.cAnswers     ;
        countT cAuth = header.cAuthorities ;
        countT cNote = header.cNotes       ;

        while( pbc < pbe && cResources -- && !POOP )
        {
            ZE( countT , idTypeAnswer ) ;
                 if( cAnsw && cAnsw -- ) idTypeAnswer = ifcIDtYPEdNSrEPLY_ANSWER ;
            else if( cAuth && cAuth -- ) idTypeAnswer = ifcIDtYPEdNSrEPLY_AUTHORITY ;
            else if( cNote && cNote -- ) idTypeAnswer = ifcIDtYPEdNSrEPLY_NOTE ;
            else                         __1

            soulC* pSoul = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) , flSOUL_null , idTypeAnswer ) ; ___( pSoul ) ;
            if( pSoul )
            {
                soulC& soul = *pSoul ;
                {
                    ZE( strokeS* , psttName ) ;
                    header.nameF( tinP , *this , psttName , pbc , pbe - pbc ) ; ___( psttName ) ;
                    soul << psttName ;
                    delF( tinP , psttName ) ;
                }

                dnsResourceMiddleS& rMiddle = *(dnsResourceMiddleS*)pbc ;
                if( pbe - pbc < sizeof rMiddle )
                {
                    DEL( pSoul ) ;
                    __1
                    break ;
                }
                else
                {
                    rMiddle.swabF() ;
                    soul << (countT)rMiddle.idType ;
                    soul << (countT)rMiddle.idClass ;
                    {
                        ZE( countT  , time1 ) ;
                        ZE( sCountT , time2 ) ;
                        third.timeFromSecondsIF( tinP , time1 , time2 , rMiddle.secondsToLive ) ;
                        soul << time1 ;
                        soul << (countT&)time2 ;
                        time2 = time1 = 0 ;
                    }

                    pbc += sizeof rMiddle ;
                }

                if( pbc + rMiddle.cbData > pbe )
                {
                    __1
                    break ;
                }

                const byteT* pbData = pbc ; // TO AVOID SIDE EFFECTS THAT WOULD CHANGE pbc
                switch( rMiddle.idType )
                {
                    case ifcIDtYPEdNSqUERY_A :
                    {
                        __( rMiddle.cbData < sizeof( countT ) )

                        if( !POOP )
                        {
                            nicNameC nn( SWABnET4( *(countT*)pbData ) ) ;
                            nn >> soul ;
                        }

                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_MINFO :
                    {
                        ZE( strokeS* , psttName ) ;
                        header.nameF( tinP , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                        soul << psttName ;
                        delF( tinP , psttName ) ; // INTENTIONAL FALLTHROUGH
                    }
                    case ifcIDtYPEdNSqUERY_NS :
                    case ifcIDtYPEdNSqUERY_CNAME :
                    case ifcIDtYPEdNSqUERY_MB :
                    case ifcIDtYPEdNSqUERY_MG :
                    case ifcIDtYPEdNSqUERY_MR :
                    case ifcIDtYPEdNSqUERY_PTR :
                    {
                        ZE( strokeS* , psttName ) ;
                        header.nameF( tinP , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                        soul << psttName ;
                        delF( tinP , psttName ) ;
                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_HINFO :
                    case ifcIDtYPEdNSqUERY_TXT :
                    {
                        ZE( countT , cText ) ;
                        {
                            const byteT* pbdSave = pbData ;
                            while( pbData < pbc + rMiddle.cbData )
                            {
                                cText ++ ;
                                pbData += 1 + *pbData ;
                            }
                            pbData = pbdSave ;
                            soul << cText ;
                        }

                        while( pbData < pbc + rMiddle.cbData )
                        {
                            cText -- ;
                            byteT  postb[ 0x100 ] ;
                            memCopyF( tinP , postb , pbData + 1 , *pbData ) ;
                            postb[ *pbData ] = 0 ;
                            TN( td , postb ) ;
                            soul << (strokeS*)td ;
                            pbData += 1 + *pbData ;
                        }
                        __( cText ) ;

                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_MX :
                    {
                        __( rMiddle.cbData < sizeof( count01T ) )

                        if( !POOP )
                        {
                            soul << (countT)*(count01T*)pbData ; // cRank
                            pbData += sizeof( count01T ) ;

                            ZE( strokeS* , psttName ) ;
                            header.nameF( tinP , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                            soul << psttName ;
                            delF( tinP , psttName ) ;
                        }

                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_NULL :
                    case ifcIDtYPEdNSqUERY_OPTION :
                    {
                        soul.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_byteTptr , pbData , rMiddle.cbData ) ;
                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_SOA :
                    {
                        ZE( strokeS* , psttName ) ;
                        header.nameF( tinP , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                        soul << psttName ;
                        delF( tinP , psttName ) ;

                        header.nameF( tinP , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                        soul << psttName ;
                        delF( tinP , psttName ) ;

                        __( pbe - pbData < 5 * sizeof( count02T ) )

                        if( !POOP )
                        {
                            soul << (countT)SWABnET4( *(count02T*)pbData ) ; pbData += sizeof( count02T ) ; // SERIAL

                            ZE( countT  , time1 ) ;
                            ZE( sCountT , time2 ) ;
                            countT cTries = 4 ; // REFRESH RETRY EXPIRE MINIMUM
                            while( cTries -- )
                            {
                                third.timeFromSecondsIF( tinP , time1 , time2 , SWABnET4( *(count02T*)pbData ) ) ; pbData += sizeof( count02T ) ;
                                soul << time1 ;
                                soul << (countT&)time2 ;
                                time2 = time1 = 0 ;
                            }
                        }

                        break ;
                    }
                    case ifcIDtYPEdNSqUERY_WKS :
                    {
                        __( rMiddle.cbData < 5 ) ;

                        if( !POOP )
                        {
                            nicNameC nn( SWABnET4( *(count02T*)pbData ) ) ; pbData += sizeof( count02T ) ;                                          // ADDRESS
                            nn >> soul ;
                            soul << (countT)*pbData ; pbData += 1 ;                                                                                 // PROTOCOL
                            if( 5 < rMiddle.cbData ) soul.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_byteTptr , pbData , rMiddle.cbData - 5 ) ;           // BIT MAP
                        }

                        break ;
                    }
                    default :
                    {
                        ifcSayIF( T("unrecognized rMiddle.idType: ")+TF1(rMiddle.idType) , flSAY_APPEND | flSAY_LOG ) ;
                        break ;
                    }
                }
                stsRepliesP << pSoul ;
                pbc += rMiddle.cbData ;
                rMiddle.swabF() ;
            }
        }
    }
    header.swabF() ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600214a.etherc.dnsparsef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600214b.etherc.dnsqueryf BEGIN
#define DDNAME       "3func.3600214b.etherc.dnsqueryf"
#define DDNUMB      (countT)0x3600214b
#define IDFILE      (countT)0xd68


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dnsQueryF.0.html\"\>instances\</A\>
\<A HREF=\"5.103018f.1.0.html\"\>definition\</A\>
if {time1P,time2P} is ze then i will block until i receive a recognized reply or until asynch impotence occurs
else i will return if the specified time elapses without obtaining the information
impotence will -not- occur if i do not receive a valid reply
the caller must test whether pbP is 0 to determine whether a reply was received
arguments
 tinP
 pbP
 cbP
 psttDomainP
 idTypeP
 time1P
  can be 0
 time2P
  can be 0
*/
/**/

/*1*/voidT etherC::dnsQueryF( tinS& tinP , byteT*& pbP , countT& cbP , const strokeS* const psttDomainP , const countT idTypeP , const countT time1P , const sCountT time2P )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        __NZ( pbP ) ;
        __( cbP ) ;
        __Z( psttDomainP ) ;
        __Z( idTypeP ) ;
    }

    _IO_

    {
        socketC sockd( tinP , *this , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
        countT idPortMe = sockd.bindF( tinP ) ;

        ZE( byteT* , pbQuery ) ;
        ZE( countT , cbQuery ) ;
        dnsFormatQueryF( tinP , pbQuery , cbQuery , psttDomainP , idTypeP ) ; ___( pbQuery ) ;
        ZE( boolT , bGoItIt ) ;
        ZE( boolT , bTimeout ) ;
        signC sgnDone_tmAsk( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmTimeout( tinP , TAG( TAGiDnULL ) ) ;
        osThreadF( tinP , countTC() , tmAskDnsF , &sgnDone_tmAsk , flTHREADlAUNCH_null , 0 , (countT)&sockd , (countT)&bGoItIt , (countT)&bTimeout , (countT)pbQuery , cbQuery ) ;
        if( time1P || time2P ) osThreadF( tinP , countTC() , tmTimeoutF , &sgnDone_tmTimeout , flTHREADlAUNCH_null , 0 , (countT)&sockd , (countT)&bGoItIt , (countT)&bTimeout , time1P , time2P , idPortMe ) ;

        etherC& etPrime = etPrimeIF( tinP ) ;
        while( !POOP && !bGoItIt && !etPrime && !bTimeout )
        {
            ZE( countT , idPort ) ;
            nicNameC nicName ;
            sockd.readF( tinP , pbP , cbP , idPort , nicName ) ; ___( pbP ) ;
            if( pbP && cbP >= cbQuery ) bGoItIt = *(count01T*)pbP == *(count01T*)pbQuery ; // TEST FOR EQUALITY OF THE idQuery VALUES
            else
            {
                delF( tinP , pbP ) ;
                cbP = 0 ;
            }
        }

        sgnDone_tmAsk.waitF( tinP ) ;
        if( time1P || time2P ) sgnDone_tmTimeout.waitF( tinP ) ;
        delF( tinP , pbQuery ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600214b.etherc.dnsqueryf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600214c.etherc.dnslabelsf BEGIN
#define DDNAME       "3func.3600214c.etherc.dnslabelsf"
#define DDNUMB      (countT)0x3600214c
#define IDFILE      (countT)0xd69


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dnsLabelsF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030190.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::dnsLabelsF( tinS& tinP , strokeS*& psttP , const byteT*& pbP , dnsMsgHeaderS* const pHeaderP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( pbP ) ;
        __Z( pHeaderP ) ;
        if( POOP ) return ;
    }

    _IO_

    OStEXT( ostox , 0x100 )

    const byteT* pbi = pbP ;
    ZE( const byteT* , pbiSave ) ;
    for(;;)                                     // ASSUME: *pbc IS INITIALLY NOT 0. CODE STRUCTURE REFLECTS NONCOMPRESSED, NULL TERMINATED FORMAT. COMPRESSION CODE ASSUMED TO ONLY OCCUR AT END (PER RFC SPEC)
    {
        if( ( *pbi & 0xc0 ) == 0xc0 )
        {
            pbiSave = pbi + 2 ;
            pbi = (const byteT*)pHeaderP + ( SWABnET2( *(count01T*)pbi ) & ~0xc000 ) ;
            continue ;
        }
        else if( *pbi & 0xc0 ) ;//TELLsYSc1( ifcIDtYPEtELLsYS_ERRORlABELtOOlONG )
        else
        {
            countT         cbLabel = *pbi ; pbi += 1 ;
            const osTextT* pbLabel =  pbi ; pbi += cbLabel ;

            OStEXTAL( ostox , pbLabel , cbLabel )
            if( *pbi ) { OStEXTAK( ostox , "." ) }
            else
            {
                pbi ++ ;
                break ;
            }
        }

    }

    strMakeF( tinP , LF , psttP , T(ostox) ) ; ___( psttP ) ;
    pbP = pbiSave ? pbiSave : pbi ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600214c.etherc.dnslabelsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600214d.etherc.ifcisspammerf BEGIN
#define DDNAME       "3func.3600214d.etherc.ifcisspammerf"
#define DDNUMB      (countT)0x3600214d
#define IDFILE      (countT)0xd6a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcIsSpammerF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030191.1.0.html\"\>definition\</A\>
i evaluate to 1 iff nicNameP is known to be a spammer
arguments
 psttP
  must be 0
  will point to text suitable for display as error text
   this text contains a reference to a URL at which a user can view spam information associated with nicNameP
 nicNameP
  must not be 0
*/
/**/

/*1*/boolT etherC::ifcIsSpammerF( tinS& tinP , strokeS*& psttP , const nicNameC& nicNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( psttP ) ;
        __Z( nicNameP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( strokeS* , psttDomain ) ;
    {
        TN( tSuffix , ".blackholes.mail-abuse.org" ) ;
        strFromF( tinP , psttDomain , nicNameP ) ; ___( psttDomain ) ;
        ZE( strokeS* , psttw ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        strWordF( tinP , psttw , psttDomain , sttq , strokeS('/') , 1 ) ; ___( psttw ) ;
        delF( tinP , psttDomain ) ;
        strReverseF( tinP , psttDomain , psttw , T(".") , 0 , 0 , tSuffix.csF( tinP ) ) ; ___( psttDomain ) ;
        delF( tinP , psttw ) ;
        strFuseF( tinP , psttDomain , tSuffix ) ; ___( psttDomain ) ;
    }

    stackC stsReplies( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_soulC ) ;
    dnsQueryF( tinP , stsReplies , psttDomain , ifcIDtYPEdNSqUERY_ALL ) ;
    delF( tinP , psttDomain ) ;

    ZE( boolT , bSpammer ) ;
    while( stsReplies )
    {
        ZE( soulC* , ps ) ;
        stsReplies >> ps ;
        if( ps )
        {
            soulC& soul = *ps ;
    
            ZE( countT , idTypeAnswer ) ;
            ZE( strokeS* , pstto ) ; // "OWNER"
            ZE( countT , idType ) ;
            ZE( countT , idClass ) ;
            ZE( countT  , time1 ) ;
            ZE( sCountT , time2 ) ;
            soul >> idTypeAnswer ;
            soul >> pstto ; ___( pstto ) ;
            soul >> idType ;
            soul >> idClass ;
            soul >> time1 ;
            soul >> (countT&)time2 ;
    
            if( idTypeAnswer == ifcIDtYPEdNSrEPLY_ANSWER ) switch( idType )
            {
                case ifcIDtYPEdNSqUERY_A :
                {
                    nicNameC nn ;
                    nn << soul ;
                    bSpammer = 1 ;
                    break ;
                }
                case ifcIDtYPEdNSqUERY_TXT :
                {
                    ZE( countT , cText ) ;
                    soul >> cText ;
                    if( cText ) { soul >> psttP ; ___( psttP ) ; }
                    break ;
                }
                default  : { break ; }
            }
            delF( tinP , pstto ) ;
        }
        DEL( ps ) ;
    }
    return bSpammer ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600214d.etherc.ifcisspammerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600214e.etherc.ifcisspammerf BEGIN
#define DDNAME       "3func.3600214e.etherc.ifcisspammerf"
#define DDNUMB      (countT)0x3600214e
#define IDFILE      (countT)0xd6b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcIsSpammerF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030192.1.0.html\"\>definition\</A\>
i evaluate to 1 iff nicNameP is known to be a spammer
arguments
 nicNameP
  must not be 0
*/
/**/

/*1*/boolT etherC::ifcIsSpammerF( tinS& tinP , const nicNameC& nicNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( nicNameP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( strokeS* , psttnu ) ;
    boolT bSpammer = ifcIsSpammerF( tinP , psttnu , nicNameP ) ; ___( psttnu ) ;
    delF( tinP , psttnu ) ;

    return bSpammer ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600214e.etherc.ifcisspammerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600214f.etherc.sockstkquittersf BEGIN
#define DDNAME       "3func.3600214f.etherc.sockstkquittersf"
#define DDNUMB      (countT)0x3600214f
#define IDFILE      (countT)0xd6c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockStkQuittersF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030193.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/stackC& etherC::sockStkQuittersF( tinS& tinP )/*1*/
{
    if( tinP.fingerprint ) ;
    if( !tinP.pAdamGlobal1->_etherC_.pStkQuitters ) ;//TELLsYSc1( ifcIDtYPEtELLsYS_ERRORpsTqUITTERSiS0 )
    return *tinP.pAdamGlobal1->_etherC_.pStkQuitters ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600214f.etherc.sockstkquittersf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002150.etherc.diskfilequeryattrf BEGIN
#define DDNAME       "3func.36002150.etherc.diskfilequeryattrf"
#define DDNUMB      (countT)0x36002150
#define IDFILE      (countT)0xd6d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskFileQueryAttrF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030194.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/flagsT etherC::diskFileQueryAttrF( tinS& tinP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttP ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( strokeS* , pstt ) ;
    diskMapFileNameF( tinP , pstt , psttP ) ; ___( pstt ) ;
    ZE( osTextT* , post ) ;
    strMakeF( tinP , LF , post , pstt ) ; ___( post ) ;
    delF( tinP , pstt ) ;
    flagsT flags = third.dosQueryFileAttrF( tinP , osFileNameC( tinP , third , post ) ) ;
    delF( tinP , post ) ;

    return flags ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002150.etherc.diskfilequeryattrf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002151.etherc.diskfilesetattrf BEGIN
#define DDNAME       "3func.36002151.etherc.diskfilesetattrf"
#define DDNUMB      (countT)0x36002151
#define IDFILE      (countT)0xd6e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskFileSetAttrF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030195.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::diskFileSetAttrF( tinS& tinP , const strokeS* const psttP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        FV( flFILEaTTR , flagsP ) ;
        if( POOP ) return ;
    }

    _IO_
    ZE( strokeS* , pstt ) ;
    diskMapFileNameF( tinP , pstt , psttP ) ; ___( pstt ) ;
    ZE( osTextT* , post ) ;
    strMakeF( tinP , LF , post , pstt ) ; ___( post ) ;
    delF( tinP , pstt ) ;
    third.dosSetFileAttrF( tinP , osFileNameC( tinP , third , post ) , flagsP ) ;
    delF( tinP , post ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002151.etherc.diskfilesetattrf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002152.etherc.etherparameterf BEGIN
#define DDNAME       "3func.36002152.etherc.etherparameterf"
#define DDNUMB      (countT)0x36002152
#define IDFILE      (countT)0xd6f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherParameterF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030196.1.0.html\"\>definition\</A\>
arguments
 tinP
 psttP
  must not be 0
  i will return 1 iff this string matches wo of the process parameters (command line arguments)
*/
/**/

/*1*/boolT etherC::etherParameterF( tinS& tinP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttP ) ;
        if( POOP ) return 0 ;
    }

    ZE( boolT , bFound ) ;
    FORsTRINGSiN1( (strokeS*)tinP.pAdamGlobal1->_etherC_.pstt1_processParameters )
    {
        if( !strCompareF( tinP , psttc1 , psttP ) )
        {
            bFound = 1 ;
            break ;
        }
    }

    return bFound ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002152.etherc.etherparameterf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002153.etherc.osdonothingloopf BEGIN
#define DDNAME       "3func.36002153.etherc.osdonothingloopf"
#define DDNUMB      (countT)0x36002153
#define IDFILE      (countT)0xd70


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osDoNothingLoopF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030197.1.0.html\"\>definition\</A\>
arguments
 tinP
 cToDoP
 msSleepP
*/
/**//*1*/voidT etherC::osDoNothingLoopF( tinS& tinP , countT cToDoP , const countT msSleepP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.osDoNothingLoopIF( tinP , cToDoP , msSleepP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002153.etherc.osdonothingloopf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002154.etherc.ether_preff BEGIN
#define DDNAME       "3func.36002154.etherc.ether_preff"
#define DDNUMB      (countT)0x36002154
#define IDFILE      (countT)0xd71


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ether_pMainRefsIF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030198.1.0.html\"\>definition\</A\>
*/
/**//*1*/mainRefsS*& etherC::ether_pMainRefsIF( tinS& tinP )/*1*/ // tinP IS NOT A PARAM BECAUSE tmWindowsF USES ME TO GET tinS& tinP
{
    return tinP.pAdamGlobal1->_etherC_.pMainRefs ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002154.etherc.ether_preff END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002155.etherc.ether_pbatwindowdeletion_f BEGIN
#define DDNAME       "3func.36002155.etherc.ether_pbatwindowdeletion_f"
#define DDNUMB      (countT)0x36002155
#define IDFILE      (countT)0xd72


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ether_pBatWindowDeletionI_F.0.html\"\>instances\</A\>
\<A HREF=\"5.1030199.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/batonC*& etherC::ether_pBatWindowDeletionI_F( tinS& tinP )/*1*/
{
    if( tinP.fingerprint ) ;
    return tinP.pAdamGlobal1->_etherC_.pBatWindowDeletion ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002155.etherc.ether_pbatwindowdeletion_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002156.etherc.strclockf BEGIN
#define DDNAME       "3func.36002156.etherc.strclockf"
#define DDNUMB      (countT)0x36002156
#define IDFILE      (countT)0xd73


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strClockF.0.html\"\>instances\</A\>
\<A HREF=\"5.103019d.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::strClockF( tinS& tinP , strokeS*& psttP , countT cP , const countT idColP , const countT idRowP , const countT cColP , const countT cRowP , const countT idStyleP , const countT idFirstP , const countT idLastP , const strokeS* const psttNoteP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __( idStyleP - 1 ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( countT , timeBorn ) ;
    ZE( countT , timeDeath ) ;
    {
        ZE( countT , timeB1 ) ;
        ZE( sCountT , timeB2 ) ;
        osTimeFromOldTimeF( tinP , timeB1 , timeB2 , 1953 , 9 , 7 ) ;
        timeBorn = timeB1 >> 0x10 | ( timeB2 << 0x10 ) ;
        timeB1 = timeB2 = 0 ;
        osTimeFromOldTimeF( tinP , timeB1 , timeB2 , 2036 , 9 , 7 ) ;
        timeDeath = timeB1 >> 0x10 | ( timeB2 << 0x10 ) ;
    }

    ZE( countT , idcIn1born ) ;
    ZE( countT , idrIn1born ) ;
    ZE( countT , idcOut1born ) ;
    ZE( countT , idrOut1born ) ;
    ZE( countT , idcIn1death ) ;
    ZE( countT , idrIn1death ) ;
    ZE( countT , idcOut1death ) ;
    ZE( countT , idrOut1death ) ;
    ZE( countT , idcIn1 ) ;
    ZE( countT , idrIn1 ) ;
    ZE( countT , idcOut1 ) ;
    ZE( countT , idrOut1 ) ;
    ZE( countT , idcIn2 ) ;
    ZE( countT , idrIn2 ) ;
    ZE( countT , idcOut2 ) ;
    ZE( countT , idrOut2 ) ;
    ZE( countT , idcIn3 ) ;
    ZE( countT , idrIn3 ) ;
    ZE( countT , idcOut3 ) ;
    ZE( countT , idrOut3 ) ;
    ZE( countT , idcIn4 ) ;
    ZE( countT , idrIn4 ) ;
    ZE( countT , idcOut4 ) ;
    ZE( countT , idrOut4 ) ;
    ZE( countT , idcIn5 ) ;
    ZE( countT , idrIn5 ) ;
    ZE( countT , idcOut5 ) ;
    ZE( countT , idrOut5 ) ;
    ZE( countT , idcIn6 ) ;
    ZE( countT , idrIn6 ) ;
    ZE( countT , idcOut6 ) ;
    ZE( countT , idrOut6 ) ;
    ZE( countT , idcIn7 ) ;
    ZE( countT , idrIn7 ) ;
    ZE( countT , idcOut7 ) ;
    ZE( countT , idrOut7 ) ;
    ZE( countT , idcIn8 ) ;
    ZE( countT , idrIn8 ) ;
    ZE( countT , idcOut8 ) ;
    ZE( countT , idrOut8 ) ;
    const countT idFirst = idFirstP ? idFirstP : 1 ;
    const countT idLathI  = idLastP  ? idLastP  : 8 ;
    const countT cHand = idLathI - idFirst + 1 ;
    ZE( countT , idHandLast ) ;
    switch( idLathI )
    {
        case 8 : { endsF( tinP , *this , idcIn8 , idrIn8 , idcOut8 , idrOut8 , cP << 0x00 , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 8 ) break ; }
        case 7 : { endsF( tinP , *this , idcIn7 , idrIn7 , idcOut7 , idrOut7 , cP << 0x04 , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 7 ) break ; }
        case 6 : { endsF( tinP , *this , idcIn6 , idrIn6 , idcOut6 , idrOut6 , cP << 0x08 , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 6 ) break ; }
        case 5 : { endsF( tinP , *this , idcIn5 , idrIn5 , idcOut5 , idrOut5 , cP << 0x0c , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 5 ) break ; }
        case 4 : { endsF( tinP , *this , idcIn4 , idrIn4 , idcOut4 , idrOut4 , cP << 0x10 , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 4 ) break ; }
        case 3 : { endsF( tinP , *this , idcIn3 , idrIn3 , idcOut3 , idrOut3 , cP << 0x14 , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 3 ) break ; }
        case 2 : { endsF( tinP , *this , idcIn2 , idrIn2 , idcOut2 , idrOut2 , cP << 0x18 , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 2 ) break ; }
        case 1 : { endsF( tinP , *this , idcIn1 , idrIn1 , idcOut1 , idrOut1 , cP << 0x1c , idColP , idRowP , cColP , cRowP , cHand , ++ idHandLast ) ; if( idFirst == 1 ) break ; }
    }
    switch( idLathI )
    {
        case 8 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x00 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 7 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x04 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 6 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x08 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 5 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x0c , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 4 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x10 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 3 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x14 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 2 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x18 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 1 : { endsF( tinP , *this , idcIn1born , idrIn1born , idcOut1born , idrOut1born , timeBorn << 0x1c , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
    }
    switch( idLathI )
    {
        case 8 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x00 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 7 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x04 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 6 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x08 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 5 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x0c , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 4 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x10 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 3 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x14 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 2 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x18 , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
        case 1 : { endsF( tinP , *this , idcIn1death , idrIn1death , idcOut1death , idrOut1death , timeDeath << 0x1c , idColP , idRowP , cColP , cRowP , cHand , 1 ) ; break ; }
    }

    ORIGIN
    TN( tNull , "" ) ;
    strMakeF( tinP , LF , psttP , tNull , 0x200 ) ; // CALLER MUST TAG ___( psttP ) . GENEROUS

    strFuseF( tinP , psttP ,

        tNull +

        S2(0x808080,scOld_cPUSHcOLOR) +
        OLDmOVEtO( mIdco-mCc*4/8+0.5 , mIdro-mCr*4/8+0.5 ) +   // PERIMETER RECTANGLE
        OLDlINEtO( mIdco-mCc*4/8+0.5 , mIdro+mCr*4/8+0.5 ) +
        OLDlINEtO( mIdco+mCc*4/8+0.5 , mIdro+mCr*4/8+0.5 ) +
        OLDlINEtO( mIdco+mCc*4/8+0.5 , mIdro-mCr*4/8+0.5 ) +
        OLDlINEtO( mIdco-mCc*4/8+0.5 , mIdro-mCr*4/8+0.5 ) +

        OLDmOVEtO( mIdco-mCc*4/8 + 1.5 , (sCountT)mIdro-mCr*4/8 + 1.5 ) +
        T(psttNoteP) +

        tNull

    ) ; ___( psttP ) ;

    for( countT idHand = 2 ; idHand < cHand ; idHand +=2 )
    {
        measureT mHand = (measureT)idHand / (measureT)cHand ;
        strFuseF( tinP , psttP ,
    
            tNull +
    
            OLDmOVEtO( mIdco - mCc/2 * mHand + 0.5 , mIdro - mCr/2 * mHand + 0.5 ) +   // COSMETIC RECTANGLE
            OLDlINEtO( mIdco - mCc/2 * mHand + 0.5 , mIdro + mCr/2 * mHand + 0.5 ) +
            OLDlINEtO( mIdco + mCc/2 * mHand + 0.5 , mIdro + mCr/2 * mHand + 0.5 ) +
            OLDlINEtO( mIdco + mCc/2 * mHand + 0.5 , mIdro - mCr/2 * mHand + 0.5 ) +
            OLDlINEtO( mIdco - mCc/2 * mHand + 0.5 , mIdro - mCr/2 * mHand + 0.5 )
    
        ) ;
    }

    strFuseF( tinP , psttP ,

        tNull +

        OLDmOVEtO( mIdco + 0.5 , mIdro         + 0.5 ) +   // TICKS
        OLDlINEtO( mIdco + 0.5 , mIdro-mCr*4/8 + 0.5 ) +

        S2(0,scOld_POPcOLOR)

    ) ; ___( psttP ) ;

    strFuseF( tinP , psttP , tNull+S2(0x00ff00,scOld_cPUSHcOLOR)+OLDmOVEtO(idcIn1born,idrIn1born)+OLDlINEtO(idcOut1born,idrOut1born)+S2(0,scOld_POPcOLOR) ) ; ___( psttP ) ;
    strFuseF( tinP , psttP , tNull+S2(0x0000ff,scOld_cPUSHcOLOR)+OLDmOVEtO(idcIn1death,idrIn1death)+OLDlINEtO(idcOut1death,idrOut1death)+S2(0,scOld_POPcOLOR) ) ; ___( psttP ) ;

    //HANDS
    switch( idLathI )
    {
        case 8 : { strFuseF( tinP , psttP , tNull+S2(0x00ff3f,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn8,idrIn8)+OLDlINEtO(idcOut8,idrOut8) ) ; ___( psttP ) ; if( idFirst == 8 ) break ; }
        case 7 : { strFuseF( tinP , psttP , tNull+S2(0x00ff7f,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn7,idrIn7)+OLDlINEtO(idcOut7,idrOut7) ) ; ___( psttP ) ; if( idFirst == 7 ) break ; }
        case 6 : { strFuseF( tinP , psttP , tNull+S2(0x00ffbf,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn6,idrIn6)+OLDlINEtO(idcOut6,idrOut6) ) ; ___( psttP ) ; if( idFirst == 6 ) break ; }
        case 5 : { strFuseF( tinP , psttP , tNull+S2(0x00ffff,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn5,idrIn5)+OLDlINEtO(idcOut5,idrOut5) ) ; ___( psttP ) ; if( idFirst == 5 ) break ; }
        case 4 : { strFuseF( tinP , psttP , tNull+S2(0x3fff00,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn4,idrIn4)+OLDlINEtO(idcOut4,idrOut4) ) ; ___( psttP ) ; if( idFirst == 4 ) break ; }
        case 3 : { strFuseF( tinP , psttP , tNull+S2(0x7fff00,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn3,idrIn3)+OLDlINEtO(idcOut3,idrOut3) ) ; ___( psttP ) ; if( idFirst == 3 ) break ; }
        case 2 : { strFuseF( tinP , psttP , tNull+S2(0xbfff00,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn2,idrIn2)+OLDlINEtO(idcOut2,idrOut2) ) ; ___( psttP ) ; if( idFirst == 2 ) break ; }
        case 1 : { strFuseF( tinP , psttP , tNull+S2(0xffff00,scOld_cPUSHcOLOR) ) ; strFuseF( tinP , psttP , tNull+OLDmOVEtO(idcIn1,idrIn1)+OLDlINEtO(idcOut1,idrOut1) ) ; ___( psttP ) ; if( idFirst == 1 ) break ; }
    }
    countT idl = idLathI ;
    while( idl -- ) { strFuseF( tinP , psttP , tNull+S2(0,scOld_POPcOLOR) ) ; ___( psttP ) ; }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002156.etherc.strclockf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002157.etherc.strkttrimf BEGIN
#define DDNAME       "3func.36002157.etherc.strkttrimf"
#define DDNUMB      (countT)0x36002157
#define IDFILE      (countT)0xd74


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strKTTrimF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301a0.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/countT etherC::strKTTrimF( tinS& tinP , strokeS*& psttNewP , const strokeS* const psttOldP , const countT cKeepP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __( !psttNewP == !psttOldP ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( countT , cDiscarded ) ;
    ZE( const strokeS* , psttOld ) ;
    ZE( boolT , bDeleteOld ) ;
    if( psttOldP ) psttOld = psttOldP ;
    else
    {
        psttOld = psttNewP ;
        psttNewP = 0 ;
        bDeleteOld = 1 ;
    }

    //CONCEPTS
    //
    // THERE IS WO LEVEL 1 BRANCH
    // THE WOTH ATTACH MUST BE "UP"
    // EACH SUBSEQUENT BRANCH BEGINS WITH ITS ATTACH STROKE
    // MY JOB IS TO ELIMINATE EARLY BRANCHES SO THAT THERE ARE NO MORE THAN cKeepP BRANCHES AT LEVEL 2

    countT idLevel = 1 ;
    ZE( countT , cTotalAt2 ) ;
    for( countT ids = 1 ; ids <= psttOld->idAdam ; ids ++ )
    {
        const strokeS& sttc = psttOld[ CSpREFIX - 1 + ids ] ;

        if( sttc.idCaste == scOld_KTaTTACH )
        {
            switch( sttc.idAdam )
            {
                case saOLD_KTaTTACHuP   : { idLevel ++ ; break ; }
                case saOLD_KTaTTACHdOWN : { idLevel -- ; break ; }
            }

            if( idLevel == 2 ) cTotalAt2 ++ ;
        }
    }
    countT cToDiscard = cTotalAt2 > cKeepP ? cTotalAt2 - cKeepP : 0 ;

    if( !cToDiscard )
    {
        if( bDeleteOld ) psttNewP = (strokeS*)psttOld ;
        else
        {
            strMakeF( tinP , LF , psttNewP , psttOld , csttExtraP ) ; //CALLER MUST TAG ___( psttNewP ) ;
        }
    }
    else
    {
        strMakeF( tinP , LF , psttNewP , T("") , psttOld->idAdam + csttExtraP ) ; //CALLER MUST TAG
        idLevel = 1 ;
        ZE( boolT , bSkip ) ;
        strokeS sttAttach ;
        for( countT ids = 1 ; ids <= psttOld->idAdam ; ids ++ )
        {
            const strokeS& sttc = psttOld[ CSpREFIX - 1 + ids ] ;
    
            if( sttc.idCaste == scOld_KTaTTACH )
            {
                switch( sttc.idAdam )
                {
                    case saOLD_KTaTTACHuP   : { idLevel ++ ; break ; }
                    case saOLD_KTaTTACHdOWN : { idLevel -- ; break ; }
                }
    
                if( idLevel == 2 )
                {
                    if( !bSkip )
                    {
                        if( cToDiscard ) sttAttach = sttc ;
                    }
                    else
                    {
                        __Z( cToDiscard ) ;
                        cToDiscard -- ;
                    }
                    bSkip = !!cToDiscard ;
                }
            }

            if( !bSkip )
            {
                if( (countT)sttAttach )
                {
                    __( sttc.idCaste - scOld_KTaTTACH ) ;
                    strFuseF( tinP , psttNewP , sttAttach ) ;
                    sttAttach = 0 ;
                }
                else strFuseF( tinP , psttNewP , sttc ) ;
            }
        }
        
        if( bDeleteOld ) delF( tinP , (strokeS*&)psttOld ) ;
    }

    return cDiscarded ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002157.etherc.strkttrimf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002159.etherc.homeosdrivernamef BEGIN
#define DDNAME       "3func.36002159.etherc.homeosdrivernamef"
#define DDNUMB      (countT)0x36002159
#define IDFILE      (countT)0xd75


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$homeOsDriverNameF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301a3.1.0.html\"\>definition\</A\>
if there is no name stored in the po olSide then psttP will remain 0 and impotence will not occur
arguments
 tinP
 psttP
  must be 0
*/
/**/

/*1*/voidT etherC::homeOsDriverNameF( tinS& tinP , strokeS*& psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    ZE( strokeS* , psttw ) ;
    strFuseF( tinP , psttw , T(homeS::homeIF().postDriverNameNew) ) ; ___( psttw ) ;
    if( psttw && !psttw->idAdam ) delF( tinP , psttw ) ;
    else                          psttP = psttw ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002159.etherc.homeosdrivernamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600215a.etherc.ifcmonitorqueryoldf BEGIN
#define DDNAME       "3func.3600215a.etherc.ifcmonitorqueryoldf"
#define DDNUMB      (countT)0x3600215a
#define IDFILE      (countT)0xd76


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcMonitorQueryOldF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301a4.1.0.html\"\>definition\</A\>
see flMONITORqUERYoLD
*/
/**/

// THIS FUNCTION ALWAYS ALLOCATES A 0x10000 BYTE BUFFER TO RECEIVE THE REPLY AND THEN COPIES THE REPLY INTO A PROPERLY SIZED DROP
//U: ENHANCE poolC TO ALLOW CODE SUCH AS ME TO FREE UNNEEDED BYTES AT THE END OF A DROP

//EMITS STRING IN THE FORM: "monitorQuery/idaReplyBuffer/cbReplyBuffer/postQuery/postQuery/.../postQuery"
//THE ENTIRE REPLY FROM THE MONITOR, INCLUDING monitorReplyOldS HEADER(S), IS PLACED INTO cbP BYTES AT pbP
//THE FORMAT OF A SIMPLE REPLY (TO A SINGLE QUERY) IS monitorReplyOldS FOLLOWED BY DATA
//IF MULTIPLE QUERIES WERE SPECIFIED, pbP WILL POINT TO A monitorReplyOldS OBJECT THAT DESCRIBES THE AGGREGATE REPLY THAT FOLLOWS IT
//THE AGGREGATE REPLY WILL CONTAIN PAIRS OF [monitorReplyOldS,data] BLOBS
//EXAMPLE REPY TO SINGLE QUERY: monitorReplyOldS , data
//EXAMPLE REPLY TO MULTI QUERY: monitorReplyOldS , monitorReplyOldS , data , monitorReplyOldS , data , monitorReplyOldS , data
//A REPLY TO A MULTI QUERY CAN BE RECOGNIZED BY TESTING THE flags FIELD IN THE WOTH monitorReplyOldS OBJECT

#define CBcATCH 0x10000

//U::REWRITE THIS FUNCTION TO LET THE MONITOR TELL ME HOW MANY BYTES TO ALLOCATE

/*1*/voidT etherC::ifcMonitorQueryOldF( tinS& tinP , byteT*& pbP , countT& cbP , const countT idP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pbP ) ;
        __( cbP ) ;
        __Z( idP ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( byteT* , pbCatch ) ;
    tinP.pAdamGlobal1->pPoolHomeTemp->newF( tinP , LF , pbCatch , CBcATCH ) ; ___( pbCatch ) ;
    __Z( pbCatch ) ;
    //U::EDIT ap_artmentOldC TO SUPPORT poolC (MULTIPLE ROOT POOLoLDS BREAK THE ASSUMPTION OF ap_artmentOldC CODING)
    //if( pbCatch )
    //{
    //    memSetF( tinP , pbCatch , CBcATCH ) ; //IF THE MONITOR DOES NOT ALTER THIS BUFFER THEN I WILL DETECT THIS FAILURE WHEN I TEST THE FLAGS
    //    
    //    struct
    //    {
    //        countT idQuery ;
    //        countT ap_artmentOldCatch ;
    //        countT cbCatch ;
    //    }
    //    info ;
    //    info.idQuery = idP ;
    //    info.ap_artmentOldCatch = ap_artmentOldC( tinP , pbCatch ) ;
    //    __( !info.ap_artmentOldCatch ) ;
    //    info.cbCatch = CBcATCH ;
    //    
    //    ;//TELLsYSc3LIFI( ifcIDtYPEtELLsYS_QUERY , (byteT*)&info , sizeof info , idLineCt , idiFileCt )
    //    
    //    cbP = sizeof( monitorReplyOldS ) + ((monitorReplyOldS*)pbCatch)->cbReply ;
    //    newF( tinP , LF , pbP , cbP ) ; ___( pbP ) ;
    //    memCopyF( tinP , pbP , pbCatch , cbP ) ;
    //}
    PUSE( tinP , pbCatch ) ;

    //U:VALIDATE THE REPLY (AT LEAST CALL FV FOR THE flags FIELD IN THE WOTH monitorReplyOldS
    //U:IMPOTENCE IF VALIDATION FAILS
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600215a.etherc.ifcmonitorqueryoldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600215b.etherc.strkthereaddressf BEGIN
#define DDNAME       "3func.3600215b.etherc.strkthereaddressf"
#define DDNUMB      (countT)0x3600215b
#define IDFILE      (countT)0xd77


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strKtHereAddressF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301a6.1.0.html\"\>definition\</A\>
i calculate the address of the here branch (if any)
arguments
 tinP
 pczP
  must be 0
  will contain the branch address of the here branch, if any
  pczP[ 0 ] is not used and will always be 0
  pczP[ 1 ] will be M if the here branch is a kid of the M'th branch at level 1
  pczP[ 2 ] will be N if the here branch is a kid of the N'th kid of the M'th branch at level 1
  will be terminated with a null
  if there is no here branch, pczP[ 1 ] will be 0
 psttP
  must not be 0
*/
/**/

/*1*/voidT etherC::strKtHereAddressF( tinS& tinP , countT*& pczP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pczP ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    countT idLevel = 1 ;
    ZE( countT , idLevelMax ) ;
    const countT offMax = CSpREFIX - 1 + psttP->idAdam ;
    {
        for( countT off = CSpREFIX ; off <= offMax ; off ++ )
        {
            if( psttP[ off ].idCaste == scOld_KTaTTACH )
            {
                     if( psttP[ off ].idAdam == saOLD_KTaTTACHuP   ) idLevel ++ ;
                else if( psttP[ off ].idAdam == saOLD_KTaTTACHdOWN ) idLevel -- ;

                if( idLevelMax < idLevel ) idLevelMax = idLevel ;
            }
        }
    }

    newF( tinP , LF , pczP , 2 + idLevelMax ) ; ___( pczP ) ;
    if( pczP )
    {
        pczP[ 0 ] = 0 ;
        pczP[ 1 ] = 1 ;

        //MAINTAIN THE CURRENT ADDRESS IN pczP
        countT idLevel = 1 ;
        countT off = CSpREFIX ;
        for( ; off <= offMax ; off ++ )
        {
            if( psttP[ off ].idCaste == scOld_KTaTTACH )
            {
                     if( psttP[ off ].idAdam == saOLD_KTaTTACHnEXT ) pczP[ idLevel ] ++  ;
                else if( psttP[ off ].idAdam == saOLD_KTaTTACHuP ) pczP[ ++ idLevel ] = 1 ;
                else if( psttP[ off ].idAdam == saOLD_KTaTTACHdOWN )
                {
                    pczP[    idLevel ] = 0 ;
                    pczP[ -- idLevel ] ++  ;
                }
            }
            else if( psttP[ off ].idCaste == scOld_KTfLAGSsCRATCH && F(psttP[ off ].idAdam) & flKTsCRATCH_WMHhERE ) break ;
        }
        if( off > offMax ) pczP[ 1           ] = 0 ;
        else               pczP[ idLevel + 1 ] = 0 ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600215b.etherc.strkthereaddressf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600215c.etherc.strkthereaddressf BEGIN
#define DDNAME       "3func.3600215c.etherc.strkthereaddressf"
#define DDNUMB      (countT)0x3600215c
#define IDFILE      (countT)0xd78


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strKtHereAddressF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301a7.1.0.html\"\>definition\</A\>
i set the here flag, obeying pczP as much as possible
 my rule is to obey pczP, climbing up until i can no longer climb in obedience
 then i set the here flag where i am
arguments
 tinP
 psttP
  must not be 0
 pczP
  must not be 0
  pczP[ 0 ] must be 0
  if pczP[ 1 ] == 0 then i will clear all here flags
  else i will set a single here flag
   example: if pczP[ 1 ] == 1 and pczP[ 2 ] == 1 and pczP[ 3 ] == 0 then i will climb to the eldest kid of the eldest kid
    if the eldest kid has no kids, then he will get the here flag
    if there is no eldest kid, then the root will get the here flag
    if there is no root then nothing will be done and impotence will not occur
*/
/**/

/*1*/voidT etherC::strKtHereAddressF( tinS& tinP , strokeS* const psttP , const countT* const pczP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( pczP ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    stackC stIdBro( tinP , third , TAG( TAGiDnULL ) ) ;  //         stIdBro: idLevel        stIdBro[ 1 ]: idBro
    stIdBro << countTC( 1 ) ;

    const countT offMax = CSpREFIX - 1 + psttP->idAdam ;
    ZE( countT , idLevelMatched ) ;
    ZE( strokeS* , psttHighWater ) ;
    for( countT off = CSpREFIX ; off <= offMax ; off ++ )
    {
        if( psttP[ off ].idCaste == scOld_KTaTTACH )
        {
            if( psttP[ off ].idAdam == saOLD_KTaTTACHnEXT ) stIdBro[ 1 ] ++ ;
            else if( psttP[ off ].idAdam == saOLD_KTaTTACHuP ) stIdBro << countTC( 1 ) ;
            else if( psttP[ off ].idAdam == saOLD_KTaTTACHdOWN )
            {
                ZE( countT , cFoo ) ;
                stIdBro >> cFoo ;
                stIdBro[ 1 ] ++ ;
            }
        }
        else if( psttP[ off ].idCaste == scOld_KTfLAGSsCRATCH )
        {
            if( F(psttP[ off ].idAdam) & flKTsCRATCH_WMHhERE ) psttP[ off ].idAdam &= ~( F(flKTsCRATCH_WMHhERE) ) ;
            if( pczP[ stIdBro ] && idLevelMatched + 1 == stIdBro && pczP[ stIdBro ] == stIdBro[ 1 ] )
            {
                idLevelMatched = stIdBro ;
                psttHighWater = psttP + off ;
            }
        }
    }
    if( psttHighWater ) psttHighWater->idAdam |= F(flKTsCRATCH_WMHhERE) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600215c.etherc.strkthereaddressf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600215d.etherc.strgraphf BEGIN
#define DDNAME       "3func.3600215d.etherc.strgraphf"
#define DDNUMB      (countT)0x3600215d
#define IDFILE      (countT)0xd79


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strGraphF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301a8.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/voidT etherC::strGraphF( tinS& tinP , strokeS*& psttP , countT& leverP , batonC& bLeverP , switchStackC& swsXP , switchStackC& swsYP , switchC& swColorP , switchC& swMarkerP , const countT cColP , const countT cRowP , const countT idStyleP , const flagsT flagsP , const strokeS* const psttNoteP , const countT* pczLeverIncludeP , const countT* pczLeverExcludeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        FV( flSTRgRAPH , flagsP ) ;
        if( POOP ) return ;
    }

    _IO_

    if( !psttP ) strMakeF( tinP , LF , psttP , T("") , 0x100000 ) ; //U: SIZE ACCORDING TO AMOUNT OF DATA

    //const countT ccMarker = 4 ; //WITH CURRENT CODE, THESE MUST BE EVEN
    //const countT crMarker = 4 ;

    strFuseF( tinP , psttP , T("")+S2(0,scOld_cPUSHoRIGIN)+OLDmOVEtO(1,1)+S2(0,scOld_cPUSHoRIGIN)+OLDmOVE(1,0)+T(psttNoteP)+S2(0,scOld_POPoRIGIN)+OLDmOVEtO(0,0)+OLDlINEtO(cColP-1,0)+OLDlINEtO(cColP-1,cRowP-1)+OLDlINEtO(0,cRowP-1)+OLDlINEtO(0,0)+OLDmOVEtO(1/*+ccMarker/2*/,1/*+crMarker/2*/)+S2(0,scOld_cPUSHoRIGIN) ) ; //CALLER MUST TAG __(  )

    bLeverP.grabF( tinP , TAG( TAGiDnULL ) ) ;

    countT cFlavors = swsXP.cFlavorsF( tinP ) ;
    ZE( measureT , biasX ) ;
    ZE( measureT , scaleX ) ;
    ZE( measureT , biasY ) ;
    ZE( measureT , scaleY ) ;
    {
        ZE( measureT , mMinAllX ) ;
        ZE( measureT , mMinAllY ) ;
        ZE( measureT , mMaxAllX ) ;
        ZE( measureT , mMaxAllY ) ;
        if( cFlavors )
        {
            mMinAllY = mMinAllX =   MAXmEASUREt ;
            mMaxAllY = mMaxAllX = - MAXmEASUREt ;
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            {
                leverP = swsXP.leverF( tinP , idf ) ;
                if
                (
                    ( pczLeverIncludeP && !strIdNewF( pczLeverIncludeP , leverP ) ) ||
                    ( pczLeverExcludeP &&  strIdNewF( pczLeverExcludeP , leverP ) )
                )
                continue ;
        
                if( swsXP )
                {
                    ZE( measureT , mMinX ) ;
                    ZE( measureT , mMaxX ) ;
                    ZE( measureT , mMeanX ) ;
                    ZE( measureT , mMedianX ) ;
                    ZE( measureT , mStdDeviationX ) ;
                    statisticsF( tinP , mMinX , mMaxX , mMeanX , mMedianX , mStdDeviationX , swsXP ) ;
                    if( mMinAllX > mMinX ) mMinAllX = mMinX ;
                    if( mMaxAllX < mMaxX ) mMaxAllX = mMaxX ;
        
                    ZE( measureT , mMinY ) ;
                    ZE( measureT , mMaxY ) ;
                    ZE( measureT , mMeanY ) ;
                    ZE( measureT , mMedianY ) ;
                    ZE( measureT , mStdDeviationY ) ;
                    statisticsF( tinP , mMinY , mMaxY , mMeanY , mMedianY , mStdDeviationY , swsYP ) ;
                    if( mMinAllY > mMinY ) mMinAllY = mMinY ;
                    if( mMaxAllY < mMaxY ) mMaxAllY = mMaxY ;
                }
            }

            if( F(flagsP) & flSTRgRAPH_ORIGINyiSzE && 0.0 < mMinAllY ) mMinAllY = 0.0 ;
            if( F(flagsP) & flSTRgRAPH_ORIGINxiSzE && 0.0 < mMinAllX ) mMinAllX = 0.0 ;
        }
        boolT bSingleX = mMaxAllX < mMinAllX + 1e-10 ;
        boolT bSingleY = mMaxAllY < mMinAllY + 1e-10 ;
        biasX  = bSingleX ? ( cColP - 2 /* - ccMarker */ ) / 2 - mMinAllX : - mMinAllX ;
        biasY  = bSingleY ? ( cRowP - 2 /* - crMarker */ ) / 2 - mMinAllY : - mMinAllY ;
        scaleX = bSingleX ? 1 : ( cColP - 3 /* - ccMarker */ ) / ( mMaxAllX - mMinAllX ) ;
        scaleY = bSingleY ? 1 : ( cRowP - 3 /* - crMarker */ ) / ( mMaxAllY - mMinAllY ) ;
    }

    cFlavors = swsXP.cFlavorsF( tinP ) ;
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    {
        leverP = swsXP.leverF( tinP , idf ) ;
        if
        (
            ( pczLeverIncludeP && !strIdNewF( pczLeverIncludeP , leverP ) ) ||
            ( pczLeverExcludeP &&  strIdNewF( pczLeverExcludeP , leverP ) )
        )
        continue ;

        strFuseF( tinP , psttP , T("")+S2((countT)swColorP,scOld_cPUSHcOLOR) ) ;

        if( swsXP )
        {
            boolT bWoth = 1 ;
            handleC hDownX( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            handleC hDownY( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            do
            {
                measureT xx = scaleX * ( *(measureT*)&swsXP.downF( tinP , hDownX ) + biasX ) ;
                measureT yy = scaleY * ( *(measureT*)&swsYP.downF( tinP , hDownY ) + biasY ) ;
                strFuseF( tinP , psttP , T("")+(bWoth?OLDmOVEtO(xx+0.5,yy+0.5):OLDlINEtO(xx+0.5,yy+0.5)) ) ;

                //strFuseF( tinP , psttP , T("")+OLDmOVE(-2,-2)+OLDlINE(4,0)+OLDlINE(0,4)+OLDlINE(-4,0)+OLDlINE(0,-4)+OLDmOVE(2,2) ) ; //U: HARDCODED MARKER

                if( bWoth )
                {
                    bWoth = 0 ;
                    if( !hDownX ) strFuseF( tinP , psttP , T("")+OLDlINEtO(xx+0.5,yy+0.5) ) ;
                }
            }
            while( !swsXP.third && !swsYP.third && ~hDownX && ~hDownY ) ;
        }

        strFuseF( tinP , psttP , T("")+S2(0,scOld_POPcOLOR) ) ;
    }

    bLeverP.ungrabF( tinP ) ;

    strFuseF( tinP , psttP , T("")+S2(0,scOld_POPoRIGIN)+OLDmOVEtO(cColP,0)+S2(0,scOld_POPoRIGIN) ) ;

    if( swsYP.cFlavorsF( tinP ) && swMarkerP.cFlavorsF( tinP ) && idStyleP && flagsP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600215d.etherc.strgraphf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600215e.etherc.statisticsf BEGIN
#define DDNAME       "3func.3600215e.etherc.statisticsf"
#define DDNUMB      (countT)0x3600215e
#define IDFILE      (countT)0xd7a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$statisticsF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301a9.1.0.html\"\>definition\</A\>
*/
/**/

//U: ADD CODE TO CALC STD DEVIATION

/*1*/voidT etherC::statisticsF( tinS& tinP , measureT& minP , measureT& maxP , measureT& meanP , measureT& medianP , measureT& stdDeviationP , stackC& stXP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( minP ) ;
        __( maxP ) ;
        __( meanP ) ;
        __( medianP ) ;
        __( stdDeviationP ) ;
        __( stXP.idTypeF( tinP ) - ifcSTACKtYPE_measureT ) ;
        if( POOP ) return ;
    }
    
    _IO_

    if( stXP )
    {
        minP =   MAXmEASUREt ;
        maxP = - MAXmEASUREt ;

        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        do
        {
            measureT xx = *(measureT*)&stXP.downF( tinP , hDown ) ;
            if( minP > xx ) minP = xx ;
            if( maxP < xx ) maxP = xx ;
            meanP += xx ;
        }
        while( !stXP.third && ~hDown ) ;

        meanP /= stXP ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600215e.etherc.statisticsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600215f.etherc.ifcrenderinghandlerf BEGIN
#define DDNAME       "3func.3600215f.etherc.ifcrenderinghandlerf"
#define DDNUMB      (countT)0x3600215f
#define IDFILE      (countT)0xd7b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcRenderingHandlerF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301ac.1.0.html\"\>definition\</A\>
registers a handler function that is called each time i am about to render strokes into a face's drawing bitmap
 this is currently done only for selected strokeS caste values
at any time there is either 0 or 1 handler registered
arguments
 pIfcRenderingHandlerFIP
  can be 0
 infoP
  can be 0
  is passed to the handler each time that the handler is called
*/
/**/
/*1*/voidT etherC::ifcRenderingHandlerF( tinS& tinP , const ifcRenderingHandlerFT pIfcRenderingHandlerFIP , const countT infoP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    //thirdC::p WinRootIF()->baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
    tinP.pAdamGlobal1->_etherC_.pIfcRenderingHandlerF = pIfcRenderingHandlerFIP ;
    tinP.pAdamGlobal1->_etherC_.cIfcRenderingHandlerInfo = infoP ;
    //thirdC::p WinRootIF()->baton.ungrabF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600215f.etherc.ifcrenderinghandlerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002160.etherc.strifclogof BEGIN
#define DDNAME       "3func.36002160.etherc.strifclogof"
#define DDNUMB      (countT)0x36002160
#define IDFILE      (countT)0xd7c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strIfcLogoF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301ad.1.0.html\"\>definition\</A\>
*/
/**/

#if defined( NEVERdEFINED )

/*1*/voidT etherC::strIfcLogoF( tinS& tinP , strokeS*& psttP , const measureT mScaleP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __( !thirdC::pWinRootIF() ) ;
        if( POOP ) return ;
    }

    _IO_

    mScale = mScaleP ;

    ifcRenderingHandlerF( tinP , renderHandlerIdeaFarmLogoF ) ; //U: DO THIS USING A STROKES SO THAT IT IS "REGISTERED" AT RENDERING TIME RATHER THAN NOW

    TN( tWww , "Featuring    SOIL (tm)     Sentient Object Interface Language" ) ;

    ZE( strokeS* , psttw ) ;
    strMakeF( tinP , LF , psttw , T("") , 0x10000 ) ; ___( psttw ) ;

    OStEXTV( osto1 , "  PIGGYBACK DISTRIBUTED OPERATING SYSTEM  " )
    OStEXTV( osto2 , "*   IPDOS (tm)   *" )

    windowOldC& wRoot = *thirdC::pWinRootIF() ;
    countT cCols = R( wRoot.mCols ) % 2 ? R( wRoot.mCols ) - 1 : R( wRoot.mCols ) ;
    countT cRows = R( wRoot.mRows ) % 2 ? R( wRoot.mRows ) - 1 : R( wRoot.mRows ) ;

    measureT mCosHotAngle = thirdC::mathCosIF( tinP , PI / 16.0 ) ;
    measureT mSinHotAngle = thirdC::mathSinIF( tinP , PI / 16.0 ) ;

    measureT mColScale = 16.0 * mScaleP ;
    measureT mRowScale = 16.0 * mScaleP ;
    strFuseF( tinP , psttw , T("")+

        S2(
            flRENDERcONTROL_AT                      |
            flRENDERcONTROL_ROWsCALE                |
            flRENDERcONTROL_COLsCALE                |
            flRENDERcONTROL_ATaNGLE
        ,scOld_cRENDERfLAGScONTROLpUSH)+
        S2(mColScale,scOld_mRENDERcOLsCALEpUSH)+
        S2(mRowScale,scOld_mRENDERrOWsCALEpUSH)+
        S2(mCosHotAngle,scOld_mRENDERcOShOTaNGLEpUSH)+
        S2(mSinHotAngle,scOld_mRENDERsINhOTaNGLEpUSH)+
        //S2(CfROM2(MAXscOUNT01T/2,MAXscOUNT01T/2),scOld_mmMOVEpELtOrATIO)+
        S2(0xffff00,scOld_cPUSHcOLOR)+
        S2(1,scOld_FORaDAMtOuSE)

    ) ;

    ZE( countT , off ) ;
    while( osto1[ off ] ) strFuseF( tinP , psttw , T("")+S1C(osto1[off++]) ) ;

    mColScale = 12.0 ;
    strFuseF( tinP , psttw , T("")+

        S2(
            flRENDERcONTROL_AT                      |
            flRENDERcONTROL_ROWsCALE                |
            flRENDERcONTROL_COLsCALE                |
            flRENDERcONTROL_ATaNGLE
        ,scOld_cRENDERfLAGScONTROLpUSH)+
        //S2(CfROM2(MAXscOUNT01T/2,MAXscOUNT01T/2),scOld_mmMOVEpELtOrATIO)+
        S2(mColScale,scOld_mRENDERcOLsCALEpUSH)+
        S2(mRowScale,scOld_mRENDERrOWsCALEpUSH)+
        S2(0xff00ff,scOld_cPUSHcOLOR)+
        S2(2,scOld_FORaDAMtOuSE)

    ) ;

    off = 0 ;
    while( osto2[ off ] ) strFuseF( tinP , psttw , T("")+S1C(osto2[off++]) ) ;

    OStEXTV( ostoIdeaFarm , "IdeaFarm " "(tm)" )
    mColScale = 24.0 * mScaleP ;
    mRowScale = 32.0 * mScaleP ;
    measureT mFloatRight = 0.0 ;
    measureT mFloatUp    = 0.0 ;
    measureT mPadRight = 1.0 / 8.0 ;
    ZE( strokeS* , psttIdeaFarm ) ;
    strFuseF( tinP , psttIdeaFarm , T("")+

        S2(
            flRENDERcONTROL_FLOATrIGHT      |
            flRENDERcONTROL_FLOATuP         |
            flRENDERcONTROL_ROWsCALE        |
            flRENDERcONTROL_COLsCALE        |
            flRENDERcONTROL_PADrIGHT
        ,scOld_cRENDERfLAGScONTROLpUSH)+
        S2(mColScale,scOld_mRENDERcOLsCALEpUSH)+
        S2(mRowScale,scOld_mRENDERrOWsCALEpUSH)+
        S2(mPadRight,scOld_mRENDERpADrIGHTpUSH)+
        S2((countT)mFloatRight,scOld_cRENDERfLOATrIGHTpUSH)+
        S2((countT)mFloatUp,scOld_cRENDERfLOATuPpUSH)+
        S2(ifcRGB_W4,scOld_cPUSHcOLOR)+
        S2(3,scOld_FORaDAMtOuSE)

    , 0x1000 ) ;

    off = 0 ;
    while( ostoIdeaFarm[ off ] ) strFuseF( tinP , psttIdeaFarm , T("")+S1C(ostoIdeaFarm[off++]) ) ; //U::WHY THIS WAY (STROKE BY STROKE)?

    ZE( measureT , mIdColMin ) ;
    ZE( measureT , mIdRowMin ) ;
    ZE( measureT , mCols ) ;
    ZE( measureT , mRows ) ;
    //b oundingRectF( tinP , mIdColMin , mIdRowMin , mCols , mRows , T("")+S3(0.5,scOld_mmMOVEtO,0.5)+T(psttIdeaFarm) , 1 ) ;

    sCountT scAdjCol = - R( ( mCols - 1.0 ) / 2 ) ;
    sCountT scAdjRow = - R( ( mRows - 1.0 ) / 2 ) ;

    strFuseF( tinP , psttw , T("")+

        //S2(CfROM2(MAXscOUNT01T/2,MAXscOUNT01T/2),scOld_mmMOVEpELtOrATIO)+
        S2(CfROM2(scAdjCol,scAdjRow),scOld_mmMOVEpEL)

    ) ;

    strMakeF( tinP , LF , psttP , tWww+T(psttw)+T(psttIdeaFarm) , csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;
    delF( tinP , psttIdeaFarm ) ;
    delF( tinP , psttw ) ;
}

#endif


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002160.etherc.strifclogof END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002163.etherc.ifcqueryhandlesf BEGIN
#define DDNAME       "3func.36002163.etherc.ifcqueryhandlesf"
#define DDNUMB      (countT)0x36002163
#define IDFILE      (countT)0xd7d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifcQueryHandlesF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301b3.1.0.html\"\>definition\</A\>
arguments
 tinP
 psttOldCommentP
  must not be 0 and must not be null length
  should be an informative short title for the current job
  can be made unique by including time
  place the most unique and important words woth, as reports will truncate
  this title or comment is intended to facilitate debugging of ifc chat and can appear on ifc chat logs and console displays
 cTriesP
 nicNameP
  defaults to nicNameC(), which implies the local host
*/
/**/

/*1*/countT etherC::ifcQueryHandlesF( tinS& tinP , const strokeS* const psttOldCommentP , const countT cTriesP , nicNameC nicNameP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttOldCommentP ) ;
        if( POOP ) return 0 ;
        __( !psttOldCommentP->idAdam ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    stackC stCourses( tinP , third , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
    soulC sOrder( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDjOBoRDER_QUERYchANDLES ) ;
    stackC stOrders( tinP , third , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
    stOrders << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;

    if( !nicNameP ) nicNameP = socketC::nicNameIF( tinP , *this ) ;
    ifcJobF( tinP , stCourses , ifcIDaDAM_KERNEL2MONITOR , sOrder , stOrders , psttOldCommentP , cTriesP , nicNameP ) ;
    __Z( stCourses ) ;
    ZE( soulC* , psCourse ) ;
    stCourses >> psCourse ;
    __Z( psCourse ) ;
    ZE( countT , cHandles ) ;
    if( psCourse )
    {
        soulC sCodes( tinP , TAG( TAGiDnULL ) ) ;
        *psCourse >> sCodes ;
        soulC sData( tinP , TAG( TAGiDnULL ) ) ;
        *psCourse >> sData ;
        sData >> cHandles ;
    }
    DEL( psCourse ) ;
    return cHandles ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002163.etherc.ifcqueryhandlesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002164.etherc.etherblammof BEGIN
#define DDNAME       "3func.36002164.etherc.etherblammof"
#define DDNUMB      (countT)0x36002164
#define IDFILE      (countT)0xd7e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherBlammoF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301b4.1.0.html\"\>definition\</A\>
this function causes the etherC object to become impotent
arguments
 tinP
*/
/**/

/*1*/voidT etherC::etherBlammoF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    third.osBlammoIF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002164.etherc.etherblammof END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002165.etherc.etherwheref BEGIN
#define DDNAME       "3func.36002165.etherc.etherwheref"
#define DDNUMB      (countT)0x36002165
#define IDFILE      (countT)0xd7f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherWhereF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301b5.1.0.html\"\>definition\</A\>
arguments
 tinP
 idActionP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001024d.ifcIDaCTIONwHERE!||
 cThreadsMaxP
*/
/**/

/*1*/voidT etherC::etherWhereF( tinS& tinP , const countT idActionP , const flagsT flagsP , const countT cThreadsMaxP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( idActionP ) ;
        if( idActionP == ifcIDaCTIONwHERE_SETUP ) { __Z( cThreadsMaxP ) ; }
        else                                      { __(  cThreadsMaxP ) ; }
        FV(flETHERwHERE,flagsP)
        if( POOP ) return ;
    }

    _IO_
    static countT cWhereSetup ;
    switch( idActionP )
    {
        case ifcIDaCTIONwHERE_SETUP :
        {
            tinP.pAdamGlobal4->_etherC_grabWhere.grabF( tinP , TAG( TAGiDnULL ) ) ;
            tinP.pAdamGlobal1->_etherC_.cThreadsMaxWhere = cThreadsMaxP ;
            newF( tinP , LF , (countT*&)tinP.pAdamGlobal1->_etherC_.ppTinWhere , tinP.pAdamGlobal1->_etherC_.cThreadsMaxWhere ) ; ___( tinP.pAdamGlobal1->_etherC_.ppTinWhere ) ;
            memSetF( tinP , (byteT*)tinP.pAdamGlobal1->_etherC_.ppTinWhere , tinP.pAdamGlobal1->_etherC_.cThreadsMaxWhere * sizeof( countT ) ) ;
            tinP.pAdamGlobal1->_etherC_.pSgnDone_tmWhere = new( 0 , tinP , LF ) signC( tinP , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC2 ) ; ___( tinP.pAdamGlobal1->_etherC_.pSgnDone_tmWhere ) ;
            signC sgnReady( tinP , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC3 ) ;
            THREADmODE1oN( flTHREADmODE1_NOwHERE | flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            osThreadF( tinP , countTC() , tmWhereF , tinP.pAdamGlobal1->_etherC_.pSgnDone_tmWhere , flTHREADlAUNCH_null , 0 , (countT)&tinP.pAdamGlobal1->_etherC_.bQuitWhere , (countT)&sgnReady , (countT)&tinP.pAdamGlobal1->_etherC_.cEnabledWhere , (countT)&tinP.pAdamGlobal1->_etherC_.idTypeReportWhere , (countT)tinP.pAdamGlobal1->_etherC_.ppTinWhere , (countT)&tinP.pAdamGlobal1->_etherC_.cThreadsMaxWhere , (countT)&tinP.pAdamGlobal4->_etherC_grabWhere ) ;
            sgnReady.waitF( tinP ) ;
            THREADmODE1rESTORE
            __( cWhereSetup ++ ) ;
            tinP.pAdamGlobal4->_etherC_grabWhere.ungrabF( tinP ) ;
            break ;
        }
        case ifcIDaCTIONwHERE_SHUTDOWN :
        {
            tinP.pAdamGlobal4->_etherC_grabWhere.grabF( tinP , TAG( TAGiDnULL ) ) ;
            __( !( cWhereSetup -- ) ) ;
            tinP.pAdamGlobal1->_etherC_.bQuitWhere = 1 ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            tinP.pAdamGlobal1->_etherC_.pSgnDone_tmWhere->waitF( tinP ) ;
            DEL( tinP.pAdamGlobal1->_etherC_.pSgnDone_tmWhere ) ;
            THREADmODE1rESTORE
            delF( tinP , (countT*&)tinP.pAdamGlobal1->_etherC_.ppTinWhere ) ;
            tinP.pAdamGlobal4->_etherC_grabWhere.ungrabF( tinP ) ;
            break ;
        }
        case ifcIDaCTIONwHERE_REGISTERtHREAD :
        {
            tinP.pAdamGlobal4->_etherC_grabWhere.grabF( tinP , TAG( TAGiDnULL ) ) ;
            __Z( cWhereSetup ) ;
            ZE( countT , off ) ;
            for( ; off < tinP.pAdamGlobal1->_etherC_.cThreadsMaxWhere ; off ++ )
            {
                countT old = setIfZeAM( *(countT*)&tinP.pAdamGlobal1->_etherC_.ppTinWhere[ off ] , (countT)&tinP ) ;
                if( !old ) break ;
            }
            THREADmODE3oN( flTHREADmODE3_REGISTEREDwITHwHERE )
            __( off == tinP.pAdamGlobal1->_etherC_.cThreadsMaxWhere ) ;
            tinP.pAdamGlobal4->_etherC_grabWhere.ungrabF( tinP ) ;
            break ;
        }
        case ifcIDaCTIONwHERE_UNREGISTERtHREAD :
        {
            tinP.pAdamGlobal4->_etherC_grabWhere.grabF( tinP , TAG( TAGiDnULL ) ) ;
            __Z( cWhereSetup ) ;
            THREADmODE3oFF( flTHREADmODE3_REGISTEREDwITHwHERE )
            ZE( countT , off ) ;
            for( ; off < tinP.pAdamGlobal1->_etherC_.cThreadsMaxWhere ; off ++ ) if( (countT)&tinP == setIfEqualsAM( *(countT*)&tinP.pAdamGlobal1->_etherC_.ppTinWhere[ off ] , 0 , (countT)&tinP ) ) break ;
            __( off == tinP.pAdamGlobal1->_etherC_.cThreadsMaxWhere ) ;
            tinP.pAdamGlobal4->_etherC_grabWhere.ungrabF( tinP ) ;
            break ;
        }
        case ifcIDaCTIONwHERE_WATCH :
        {
            inc02AM( tinP.pAdamGlobal1->_etherC_.cEnabledWhere ) ;
            THREADmODE2oN( flTHREADmODE2_WHEREiSwATCHING )
            break ;
        }
        case ifcIDaCTIONwHERE_UNWATCH :
        {
            THREADmODE2oFF( flTHREADmODE2_WHEREiSwATCHING )
            dec02AM( tinP.pAdamGlobal1->_etherC_.cEnabledWhere ) ;
            break ;
        }
        default:
        {
            __( idActionP ) ;
            __1
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002165.etherc.etherwheref END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002166.etherc.oshttpviewerf BEGIN
#define DDNAME       "3func.36002166.etherc.oshttpviewerf"
#define DDNUMB      (countT)0x36002166
#define IDFILE      (countT)0xd80


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osHttpViewerF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301b6.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.7430104.1.1.0.html\"\>7430104:  WAKEsHOW( "example.simplest.func.10301b6.etherC.osHttpViewerF" )\</A\>
sets psttP to the name of the standard http viewer for the operating system being used
 if the current user has specified a viewer, and it exists, it will be used
  the current user is the last user to open the gate on this computer
 otherwise, the default viewer for the current operating system will be used
  os/2:       ///X/os2/system/U:
  windows nt: ///X/program files/internet explorer/iexplore.exe
  (where X is the identifying letter of a drive that contains the file)
arguments
 psttP
*/
/**//*1*/voidT etherC::osHttpViewerF( tinS& tinP , strokeS*& psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    {
        GETsETTING( *this , psttnu , T("httpviewer") )
        psttP = psttnu ;
    }

    if( psttP && !diskFileExistsF( tinP , psttP ) ) delF( tinP , psttP ) ;

    if( !psttP )
    {
        ZE( strokeS* , psttEnv ) ;
        osEnvironmentVariableF( tinP , psttEnv , T("ProgramFiles") ) ; ___( psttEnv ) ;
        if( psttEnv )
        {
            strConvertToLowerCaseF( tinP , psttEnv ) ;
            ifFileNameC iffn( tinP , third , T(psttEnv) ) ;
            strMakeF( tinP , LF , psttP , T(iffn)+T("/internet explorer/iexplore.exe") ) ; ___( psttP ) ;
            if( psttP && !diskFileExistsF( tinP , psttP ) ) delF( tinP , psttP ) ;
        }
    }

    if( !psttP )
    {
        ZE( strokeS* , psttEnv ) ;
        osEnvironmentVariableF( tinP , psttEnv , T("SystemDrive") ) ; ___( psttEnv ) ;
        if( psttEnv )
        {
            strConvertToLowerCaseF( tinP , psttEnv ) ;
            strMakeF( tinP , LF , psttP , T("///")+psttEnv[ CSpREFIX ]+T("/program files/plus!/microsoft internet/iexplore.exe") ) ; ___( psttP ) ;
            if( psttP && !diskFileExistsF( tinP , psttP ) ) delF( tinP , psttP ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002166.etherc.oshttpviewerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002167.etherc.oshttpviewf BEGIN
#define DDNAME       "3func.36002167.etherc.oshttpviewf"
#define DDNUMB      (countT)0x36002167
#define IDFILE      (countT)0xd81


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osHttpViewF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301b7.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.3730104.1.1.0.html\"\>3730104:  WAKEsHOW( "example.simplest.func.10301b7.etherC.osHttpViewF" )\</A\>
uses the default http viewer to view the named page
arguments
 psttP
  specifies the name of the page to view
  can be 0
  example: T("www.ideafarm.com//http/")
bAsynchP
 can be 0 or 1
 if 0 then i will not return until the operator closes the editor
 if 1 then i will return as soon as the editor is hired
*/
/**//*1*/voidT etherC::osHttpViewF( tinS& tinP , const strokeS* const psttP , const boolT bAsynchP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , pstta ) ;
    if( psttP )
    {
        #if defined( __OS2__ )
            //U:
        #elif defined( __NT__ )
    
            countT idf = 1 ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , psttHost ) ;
            strSubstringF( tinP , psttHost , idf , sttq , S1C('/') , psttP ) ; ___( psttHost ) ;
    
            ZE( strokeS* , psttw ) ;
            strSubstringF( tinP , psttw , idf , sttq , S1C('/') , psttP ) ; ___( psttw ) ; //PORT SPEC (IGNORED)
            delF( tinP , psttw ) ;
            strSubstringF( tinP , psttw , idf , sttq , S1C('/') , psttP ) ; ___( psttw ) ; //PROTOCOL (MUST BE "http")
            __( strCompareF( tinP , T("http") , psttw ) ) ;
            delF( tinP , psttw ) ;
    
            if( !idf ) { strMakeF( tinP , LF , pstta , T("http://")+T(psttHost)+T("/") ) ; ___( pstta ) ; }
            else
            {
                ZE( countT , idLathI ) ;
                strSubstringF( tinP , psttw , idf , idLathI , psttP ) ; ___( psttw ) ;
                strMakeF( tinP , LF , pstta , T("http://")+T(psttHost)+T("/")+T(psttw) ) ; ___( pstta ) ;
                delF( tinP , psttw ) ;
            }
            delF( tinP , psttHost ) ;
    
        #endif
    }

    ZE( strokeS* , psttViewer ) ;
    osHttpViewerF( tinP , psttViewer ) ; ___( psttViewer ) ;
    if( bAsynchP ) osSessionF( tinP , countTC() , countTC() , psttViewer , pstta , 0 , 0 , 640 , 480 ) ;
    else
    {
        ZE( countT , value ) ;
        ZE( countT , idDeathType ) ;
        osSessionF( tinP , countTC() , countTC() , value , idDeathType , psttViewer , pstta , 0 , 0 , 640 , 480 ) ;
        __( idDeathType ) ;
    }
    delF( tinP , pstta ) ;
    delF( tinP , psttViewer ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002167.etherc.oshttpviewf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002168.etherc.etherreadfromcyrcleoldf BEGIN
#define DDNAME       "3func.36002168.etherc.etherreadfromcyrcleoldf"
#define DDNUMB      (countT)0x36002168
#define IDFILE      (countT)0xd82


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherReadFromCyrcleOldF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301b8.1.0.html\"\>definition\</A\>
arguments
 tinP
 pNapkinP
  on wo'th call, must be 0
  will be allocated on the wo'th call
  caller is responsible for deleting after la'th call
 pCyrcleOldFP
  can be 0
  normally is not 0
  if not 0 then will be called for each entry in the circular buffer
 cParmP
  i do not use this value
  i simply pass it along to pCyrcleOldFP
 bQuitP
  i read but do not modify this value
  when this value transitions from ze i process the extant transactions and then quit
   all entries existing when bQuitP is woth seen are processed; then i quit
 psttNapkinP
  the name of the napkinC that contains the circular buffer
  another napkin with the same name can be, but normally is not, constructed by this process
 cbCyrcleOldP
  the size of the data portion of the circular buffer
*/
/**/

/*1*/voidT etherC::etherReadFromCyrcleOldF( tinS& tinP , napkinC*& pNapkinP , bitsC& bits_pNapkinP_P , cyrcleOldFT pCyrcleOldFP , countT& cParmP , boolT& bQuitP , const strokeS* const psttNapkinP , const countT cbCyrcleOldP , countT& cIgnoredP , byteT*& pbSnapP , countT& cbSnapP , countT& offBeginSnapP , boolT& bSnapP , const countT idMemorySpaceP , signC* const pSgnReadyP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pNapkinP ) ;
        __Z( psttNapkinP )
        __Z( cbCyrcleOldP )
        __( idMemorySpaceP && !( F(tinP.flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tinP ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tinP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        if( POOP ) return ;
    }

    _IO_
    if( !pNapkinP )
    {
        pNapkinP = new( 0 , tinP , LF ) napkinC( tinP , LF , (byteT*)bits_pNapkinP_P , textC( tinP , LF , (byteT*)bits_pNapkinP_P , flTEXTc_null , psttNapkinP ) , 0 , sizeof( cyrcleOldHeaderS ) + cbCyrcleOldP , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_null , - 1 , idMemorySpaceP ) ; ___( pNapkinP ) ;

        if( pNapkinP )
        {
            cyrcleOldHeaderS* ph = (cyrcleOldHeaderS*)(byteT*)*pNapkinP ;
            if( !ph ) { BLAMMO ; }
            else if( !( F(pNapkinP->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
            {
                memSetF( tinP , (byteT*)ph , sizeof( cyrcleOldHeaderS ) ) ;
                ph->flags = flCYRCLEoLD_null ;
                pNapkinP->formattingIsDoneF( tinP ) ;
            }
            else if( *pNapkinP != sizeof( cyrcleOldHeaderS ) + cbCyrcleOldP ) { BLAMMO ; }
        }
    }
    __Z( pNapkinP ) ;
    napkinC& napCyrcleOld = *pNapkinP ;
    cyrcleOldHeaderS* ph = (cyrcleOldHeaderS*)(byteT*)napCyrcleOld ;
    if( !ph ) { BLAMMO ; }
    else if( napCyrcleOld != sizeof( cyrcleOldHeaderS ) + cbCyrcleOldP ) { BLAMMO ; }
    byteT* pbBegin = (byteT*)ph + sizeof( cyrcleOldHeaderS ) ;
    byteT* pbEnd   = pbBegin + cbCyrcleOldP ;

    ZE( boolT , bSearch ) ;
    boolT bFinger1 = 1 ;
    ZE( boolT , bFinger2 ) ;
    ZE( boolT , bFlags1 ) ;
    ZE( boolT , bFlags2 ) ;
    ZE( boolT , bSize1 ) ;
    ZE( boolT , bSize2 ) ;
    ZE( countT , finger1 ) ;
    ZE( countT , finger2 ) ;
    ZE( flagsT , flags1 ) ;
    ZE( flagsT , flags2 ) ;
    ZE( countT , size1 ) ;
    ZE( countT , size2 ) ;
    ZE( byteT* , pbData ) ;
    const byteT* pbic = pbBegin ;
    byteT* pboc = (byteT*)&finger1 ;
    countT cbToDo = sizeof finger1 ;
    ZE( countT , cEntries ) ;
    ZE( boolT , bAbort ) ;
    ZE( countT , cbReadQuit ) ;
    ZE( boolT , bQuitSeen ) ;
    if( pSgnReadyP ) pSgnReadyP->giveF( tinP ) ;
    while( !POOP && !bAbort && ( !bQuitSeen || ph->cbRead < cbReadQuit ) )
    {
        if( bQuitP && !bQuitSeen )
        {
            ph->flags |= flCYRCLEoLD_CLOSING ;
            cbReadQuit = ph->cbWritten ; //U::THIS IS OBSOLETED BY flCYRCLEoLD_CLOSING: NAWWWH
            bQuitSeen = 1 ;
            continue ;
        }

        {
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            while( ph->cbWritten == ph->cbRead && !POOP && !bQuitP )
            {
                if( !bSnapP ) { ++ s ; thirdC::dosSleepRawIF( tinP , 0x20 ) ; }
                else if( !pbSnapP && !cbSnapP && !offBeginSnapP )
                {
                    bSnapP = 0 ;
                    etherSnapCyrcleOldF( tinP , pbSnapP , cbSnapP , offBeginSnapP , *pNapkinP ) ;
                }
            }
        }

        //FOR THE BENEFIT OF THE EXCEPTION HANDLER PROCESSING AN EXCEPTION IN cirMonitorF IN 2e40104, GRABBING IS UNDESIRABLE HERE BECAUSE THE EXCEPTION HANDLER WANTS TO WRITE TO THE CIRCLE DURING THE CALL TO pCyrcleOldFP


        countT cbNew  = ph->cbWritten - ph->cbRead ;
        if( (sCountT)cbNew < 0 ) cbNew = 0x7fffffff ; //A:ASSUME: sizeof( countT ) IS 02

        countT cbOver = pbic + cbNew - pbEnd ;
        countT cbThis = (sCountT)cbOver >= 0 ? cbNew - cbOver : cbNew ;



        const byteT* pbic2  = pbic ;
        const byteT* pbic2e = pbic + cbThis ;
        countT cRetryFlags = CrETRYcYRCLEoLDrEAD ;
        while( pbic2 < pbic2e && !POOP )
        {
            if( bSearch )
            {
                //BLAMMO ; //2008.07.05: CONJ: SEARCH SHOULD NEVER BE NEEDED: 
                thirdC::dosBeepIF( tinP , TUCK , TUCK ) ; //U::

                //U:: TO FIND A BUG
                static countT idInLath ;
                countT idIn = 1 + incv02AM( idInLath ) ;

                {
                    ZE( countT , timeN1 ) ;
                    ZE( sCountT , timeN2 ) ;
                    osTimeNowF( tinP , timeN1 , timeN2 ) ;

                    TN( tLog , "" ) ; tLog = TT(timeN1,timeN2)+T(" | search ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" within etherReadFromCyrcleOldF\r\n") ;
                    LOGrAW( tLog ) ;
                }

                _IO_
                while( getNegAM( *(countT*)pbic2 ) != FINGERnEG_CYRCLEoLDwRITE && ++ pbic2 < pbic2e ) ;  //U:: READ FROM HIGH ADDRESS OBSERVED HERE 2008: READ FROM 0001f94

                if( pbic2 < pbic2e )
                {
                    bSearch = 0 ;
                    bFinger1 = 1 ;
                    pboc = (byteT*)&finger1 ;
                    cbToDo = sizeof finger1 ;
                }
                else break ;
            }

            if( cbToDo )
            {
                cbToDo -- ;
                *( pboc ++ ) = *( pbic2 ++ ) ;
            }

            if( !cbToDo )
            {
                if( bFinger1 )
                {
                    bFinger1 = 0 ;
                    bFlags1  = 1 ;
                    pboc = (byteT*)&flags1 ;
                    cbToDo = sizeof flags1 ;
                    putNegAM( ((flagsT*)pbic2)[ - 1 ] , FINGERnEG_CYRCLEoLDwRITEsMUDGE ) ;
                }
                else if( bFlags1 )
                {
                    ZE( boolT , bOk ) ;
                    FiSvALID( bOk , flCYRCLEoLDwRITE , flags1 ) ;

                    if( bOk && F(flags1) & flCYRCLEoLDwRITE_CLEAN )
                    {
                        bFlags1 = 0 ;
                        bSize1 = 1 ;
                        pboc = (byteT*)&size1 ;
                        cbToDo = sizeof size1 ;
                    }
                    else
                    {
                        ZE( countT , timeN1 ) ;
                        ZE( sCountT , timeN2 ) ;
                        osTimeNowF( tinP , timeN1 , timeN2 ) ;
                        
                        TN( tLog , "" ) ; tLog = TT(timeN1,timeN2)+T(" | flags1:")+TF2(flags1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" is trashed or says \"dirty\" and cRetryFlags is ")+TF2(cRetryFlags,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" within etherReadFromCyrcleOldF: ") ;
                        if( !bOk ) tLog += T(" TRASHED") ;
                        if( !( F(flags1) & flCYRCLEoLDwRITE_CLEAN ) ) tLog += T(" DIRTY") ;
                        tLog += T("\r\n") ;
                        LOGrAW( tLog ) ;

                        if( cRetryFlags -- )
                        {
                            pbic2 -= sizeof flags1 ;
                            pboc = (byteT*)&flags1 ;
                            cbToDo = sizeof flags1 ;
    
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                            ++ s ; osSleepF( tinP , TUCK * 0x20 ) ;
                        }
                        else
                        {
                            bFlags1 = 0 ;
                            bSearch = 1 ;
                            pboc = 0 ;
                            cbToDo = 0 ;
                            cRetryFlags = CrETRYcYRCLEoLDrEAD ;
                        }
                    }
                }
                else if( bSize1 )
                {
                    bSize1 = 0 ;
                    if( size1 == - 1 ) { BLAMMO ; } ;

                    if( size1 >= TOCK )
                    {
                    }

                    _IO_
                    {
                        newF( tinP , LF , pbData , size1 + 1 ) ; ___( pbData ) ;
                    }

                    if( size1 >= TOCK )
                    {
                    }

                    if( !pbData ) { BLAMMO ; }
                    pbData[ size1 ] =  0 ;
                    pboc = pbData ;
                    cbToDo = pbData ? size1 : 0 ;
                }
                else if( bSize2 )
                {
                    bSize2 = 0 ;
                    bFlags2 = 1 ;
                    pboc = (byteT*)&flags2 ;
                    cbToDo = sizeof flags2 ;
                }
                else if( bFlags2 )
                {
                    bFlags2 = 0 ;
                    bFinger2 = 1 ;
                    pboc = (byteT*)&finger2 ;
                    cbToDo = sizeof finger2 ;
                }
                else if( bFinger2 )
                {
                    bFinger2 = 0 ;
                    bFinger1 = 1 ;
                    pboc = (byteT*)&finger1 ;
                    cbToDo = sizeof finger1 ;
                    putNegAM( ((countT*)pbic2)[ - 1 ] , FINGERnEG_CYRCLEoLDwRITEsMUDGE ) ;

                    if( size2 == size1 && pCyrcleOldFP ) bAbort = (*pCyrcleOldFP)( tinP , *this , cParmP , pbData , size1 ) ;
                    else                              ++ cIgnoredP ;
                    delF( tinP , pbData ) ;
                }
                else
                {
                    bSize2 = 1 ;
                    pboc = (byteT*)&size2 ;
                    cbToDo = sizeof size2 ;
                }
            }
        }

        pbic += cbThis ;
        if( pbic == pbEnd ) pbic = pbBegin ;

        ph->cbRead += cbThis ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002168.etherc.etherreadfromcyrcleoldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002169.etherc.ethersnapcyrcleoldf BEGIN
#define DDNAME       "3func.36002169.etherc.ethersnapcyrcleoldf"
#define DDNUMB      (countT)0x36002169
#define IDFILE      (countT)0xd83


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$etherSnapCyrcleOldF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301ba.1.0.html\"\>definition\</A\>
arguments
 tinP
 pbP
  must be 0
  will point to bytes that i allocate and then fill with the contents of the circular buffer
  the format is a sequence of length prefixed and length suffixed blobs
   each entry consists of a countT, followed by data, followed by another countT
   the oo countT objects contain the length of the data, in bytes
 cbP
  must be 0
  will be set to the number of bytes of data that pbP points to
   this is the size of the circular buffer
 offBeginP
  must be 0
 pNapkinP
*/
/**/

/*1*/voidT etherC::etherSnapCyrcleOldF( tinS& tinP , byteT*& pbP , countT& cbP , countT& offBeginP , napkinC& napkinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pbP ) ;
        __( cbP ) ;
        __( offBeginP ) ;
        if( POOP ) return ;
    }

    cyrcleOldHeaderS* ph = (cyrcleOldHeaderS*)(byteT*)napkinP ;
    if( !ph ) BLAMMO
    const countT cbCyrcleOld = (countT)napkinP - sizeof( cyrcleOldHeaderS ) ;
    byteT* pbBegin = (byteT*)ph + sizeof( cyrcleOldHeaderS ) ;
    byteT* pbEnd   = pbBegin + cbCyrcleOld ;

    countT cbToDoAll = cbCyrcleOld > ph->cbWritten ? ph->cbWritten : cbCyrcleOld ;
    newF( tinP , LF , pbP , cbToDoAll + 1 ) ; ___( pbP ) ;
    if( pbP )
    {
        cbP = cbToDoAll ;
        pbP[ cbP ] = 0 ;
        offBeginP = cbP ;

        boolT bFinger2 = 1 ;
        ZE( boolT , bFlags2 ) ;
        ZE( boolT , bSize2 ) ;
        ZE( boolT , bSize1 ) ;
        ZE( boolT , bFlags1 ) ;
        ZE( boolT , bFinger1 ) ;
        ZE( countT , finger1 ) ;
        ZE( countT , finger2 ) ;
        ZE( countT , flags1 ) ;
        ZE( countT , flags2 ) ;
        ZE( countT , size1 ) ;
        ZE( countT , size2 ) ;
        ZE( byteT* , pbData ) ;               //U::THE LATH RECORDS MIGHT NOT BE WRITTEN YET; VALIDATE THEM
        const countT offWoth = ph->cbWritten % cbCyrcleOld ;
        byteT* pbic = offWoth ? pbBegin + offWoth : pbEnd ; // THIS IS A "CEILING CURSOR"
        byteT* pbtc = (byteT*)&size2 + sizeof size2 ; //CURSOR TO TEMPORARY OUTPUT
        countT cbToDo = sizeof size2 ;
        byteT* pboc = pbP + cbToDoAll ; //CURSOR TO FINAL OUTPUT (THIS IS A "CEILING CURSOR")
        ZE( countT , idLoop )
        ZE( boolT , bSearch ) ;
        while( !POOP && cbToDoAll ) //WILL LOOP 2 TIMES EXCEPT WHEN pbic == pbEnd
        {
            countT cbThis = ( ++ idLoop == 1 ) ? pbic - pbBegin : cbCyrcleOld - offWoth ;
            cbToDoAll -= cbThis ;        

            const byteT* pbic2  = pbic ;
            const byteT* pbic2e = pbic - cbThis ;
            countT cRetryFlags = CrETRYcYRCLEoLDrEAD ;
            while( pbic2 > pbic2e && !POOP )
            {
                if( bSearch )
                {
                    while( getNegAM( *(countT*)pbic2 ) != FINGERnEG_CYRCLEoLDwRITEeND && -- pbic2 > pbic2e ) ;
                    if( pbic2 > pbic2e )
                    {
                        bSearch = 0 ;
                        bFinger2 = 1 ;
                        cbToDo = sizeof finger2 ;
                        pbtc = (byteT*)&finger2 + cbToDo ;
                    }
                    else break ;
                }

                if( cbToDo )
                {
                    cbToDo -- ;
                    *( -- pbtc ) = *( -- pbic2 ) ;
                }
        
                if( !cbToDo )
                {
                    if( bFinger2 )
                    {
                        bFinger2 = 0 ;
                        bFlags2 = 1 ;

                        pboc -= sizeof finger2 ;
                        *(countT*)pboc = finger2 ;
                        cbToDo = sizeof flags2 ;
                        pbtc = (byteT*)&flags2 + cbToDo ;
                    }
                    else if( bFlags2 )
                    {
                        if( F(flags2) & flCYRCLEoLDwRITE_CLEAN )
                        {
                            bFlags2 = 0 ;
                            bSize2 = 1 ;
    
                            pboc -= sizeof flags2 ;
                            *(countT*)pboc = flags2 ;
                            cbToDo = sizeof size2 ;
                            pbtc = (byteT*)&size2 + cbToDo ;
                        }
                        else if( cRetryFlags -- )
                        {
                            pbic2 += sizeof flags2 ;
                            cbToDo = sizeof flags2 ;
                            pbtc = (byteT*)&flags2 + cbToDo ;
    
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                            ++ s ; osSleepF( tinP , TUCK * 0x20 ) ;
                        }
                        else
                        {
                            bFlags2 = 0 ;
                            bSearch = 1 ;
                            cbToDo = 0 ;
                            cRetryFlags = CrETRYcYRCLEoLDrEAD ;
                        }
                    }
                    else if( bSize2 )
                    {
                        bSize2 = 0 ;

                        pboc -= sizeof size2 ;
                        *(countT*)pboc = size2 ;
                        cbToDo = size2 ;
                        pbtc = pboc ;

                        if( size2 == - 1 ) { BLAMMO ; } ;
                    }
                    else if( bSize1 )
                    {
                        bSize1 = 0 ;
                        bFlags1 = 1 ;

                        pboc -= sizeof size1 ;
                        *(countT*)pboc = size1 ;
                        cbToDo = sizeof flags1 ;
                        pbtc = (byteT*)&flags1 + cbToDo ;

                        __( size2 - size1 ) ;
                    }
                    else if( bFlags1 )
                    {
                        bFlags1 = 0 ;
                        bFinger1 = 1 ;

                        pboc -= sizeof flags1 ;
                        *(countT*)pboc = flags1 ;
                        cbToDo = sizeof finger1 ;
                        pbtc = (byteT*)&finger1 + cbToDo ;
                    }
                    else if( bFinger1 )
                    {
                        bFinger1 = 0 ;
                        bFinger2 = 1 ;

                        pboc -= sizeof finger1 ;
                        *(countT*)pboc = finger1 ;
                        cbToDo = sizeof finger2 ;
                        pbtc = (byteT*)&finger2 + cbToDo ;

                        offBeginP = pboc - pbP ;
                    }
                    else
                    {
                        bSize1 = 1 ;

                        pboc -= size2 ;
                        cbToDo = sizeof size1 ;
                        pbtc = (byteT*)&size1 + cbToDo ;
                    }
                }
            }
        
            pbic -= cbThis ;
            if( pbic == pbBegin ) pbic = pbEnd ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002169.etherc.ethersnapcyrcleoldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600216a.etherc.etherwaitcyrcleoldf BEGIN
#define DDNAME       "3func.3600216a.etherc.etherwaitcyrcleoldf"
#define DDNUMB      (countT)0x3600216a
#define IDFILE      (countT)0xd84


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


/*
\<A HREF=\"6.$etherWaitCyrcleOldF.0.html\"\>instances\</A\>
\<A HREF=\"5.10301bb.1.0.html\"\>definition\</A\>
i sleep until all bytes written to the circle have been read
arguments
 tinP
 napkinP
*/
/**/

/*1*/voidT etherC::etherWaitCyrcleOldF( tinS& tinP , napkinC& napkinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }
    cyrcleOldHeaderS* ph = (cyrcleOldHeaderS*)(byteT*)napkinP ;
    if( !ph ) BLAMMO
    
    {
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        while( ph->cbWritten != ph->cbRead ) { ++ s ; thirdC::dosSleepRawIF( tinP , 0x20 ) ; }
    }
    if( tinP.fingerprint ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600216a.etherc.etherwaitcyrcleoldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600216b.etherc.ifccallwhenfiredf BEGIN
#define DDNAME       "3func.3600216b.etherc.ifccallwhenfiredf"
#define DDNUMB      (countT)0x3600216b
#define IDFILE      (countT)0xd85


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i can be called to reset pFP
 since i am not serialized, tinP.pAdamGlobal1->_etherC_.pCalledWhenFiredF might be called with an arg that is legal only for its predecessor
 application code must ensure that this does not happen
arguments
 tinP
 pFP
  if not 0 then will be called when tmWatchF detects asynchronous impotence
 pcArgP
  if not 0 then must point to a countT object that will still exist at fire time
  this object will be passed as a reference to pFP
*/
/**/

/*1*/voidT etherC::ifcCallWhenFiredF( tinS& tinP , ifcFT pFP , countT* const pcArgP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    tinP.pAdamGlobal1->_etherC_.pCalledWhenFiredArg = pcArgP ;
    tinP.pAdamGlobal1->_etherC_.pCalledWhenFiredF = pFP ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600216b.etherc.ifccallwhenfiredf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600216c.etherc.strtofilenamef BEGIN
#define DDNAME       "3func.3600216c.etherc.strtofilenamef"
#define DDNUMB      (countT)0x3600216c
#define IDFILE      (countT)0xd86


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
psttOldP can be 0
arguments
 psttP
 psttOldP
*/
/**/

/*1*/voidT etherC::strToFileNameF( tinS& tinP , strokeS*& psttP , const strokeS* const psttOldP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        if( psttOldP )
        {
            strFuseF( tinP , psttP , psttOldP ) ; // CALLER MUST TAG ___( psttP ) ;
        }
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    strReplaceAnyF( tinP , psttP , 0 , T("<>:\"/\\|") , T(".") ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600216c.etherc.strtofilenamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600216d.etherc.strtallyf BEGIN
#define DDNAME       "3func.3600216d.etherc.strtallyf"
#define DDNUMB      (countT)0x3600216d
#define IDFILE      (countT)0xd87


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
arguments
 psttSmallP
 psttBigP
 sttQuoteP
*/
/**/

/*1*/countT etherC::strTallyF( tinS& tinP , const strokeS* const psttSmallP , const strokeS* psttBigP , strokeS& sttQuoteP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    ZE( countT , cFound ) ;
    countT idf = 1 ;
    while( idf && strIdF( tinP , 0 , flSTRmATCH_null , idf , sttQuoteP , psttSmallP , psttBigP ) ) cFound ++ ;

    return cFound ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600216d.etherc.strtallyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600216e.etherc.diskwaitdirf BEGIN
#define DDNAME       "3func.3600216e.etherc.diskwaitdirf"
#define DDNUMB      (countT)0x3600216e
#define IDFILE      (countT)0xd88


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
arguments
 tinP
 handleP
  must be null on woth call
 bQuitP
  if true then i will return almost immediately, after doing nothing
   inspected after each (hardcoded) timeout interval
 postDirP
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00102e1.flWAITdIR!||
*/
/**/

/*1*/boolT etherC::diskWaitDirF( tinS& tinP , handleC& handleP , const boolT& bQuitP , const strokeS* const psttDirP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttDirP ) ;
        if( POOP ) return 0 ;
        __( psttDirP[ CSpREFIX - 1 + psttDirP->idAdam ].idAdam != '/' ) ;
        if( POOP ) return 0 ;
    }

    ZE( strokeS* , psttn ) ;
    diskMapFileNameF( tinP , psttn , psttDirP ) ; ___( psttn ) ;
    boolT bChange = third.dosWaitDirF( tinP , handleP , bQuitP , osFileNameC( tinP , third , T(psttn) ) , flagsP ) ;
    delF( tinP , psttn ) ;

    return bChange ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600216e.etherc.diskwaitdirf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600216f.etherc.operator_call BEGIN
#define DDNAME       "3func.3600216f.etherc.operator_call"
#define DDNUMB      (countT)0x3600216f
#define IDFILE      (countT)0xd89


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::operator ()( tinS& tinP , soulC& slP )/*1*/
{
    SCOOP
    {
        ZE( baseSoilXxxxC* , pMeI ) ;_WQ
        slP >> pMeI ;_WQ
        if( pMeI != (baseSoilXxxxC*)this ) { BLAMMO ; }
    }

    ZE( countT , idCmdBase ) ;_WQ
    slP >> idCmdBase ;_WQ
    switch( idCmdBase )
    {
        case ifcIDcMDbASE_CLASSnAME :
        {
            slP << (strokeS*)T(tinP.pAdamGlobal1->_etherC_.postOldClassName) ;_WQ
            break ;
        }
        case ifcIDcMDbASE_INSTANCEnAME :
        {
            slP << (strokeS*)T(postName) ;_WQ
            break ;
        }
        case ifcIDcMDbASE_TICK :
        {
            break ;
        }
        case ifcIDcMDbASE_TOCK :
        {
            break ;
        }
        case ifcIDcMDbASE_REFERENCE :
        {
            flagsT save = slP.flags ;_WQ
            slP.flags &= ~( F(flSOUL_LIVE) ) ;_WQ
            slP << (baseSoilXxxxC*)this ;_WQ
            slP.flags = save ;_WQ
            break ;
        }
        case ifcIDcMDbASE_CMDdEFAULT :
        {
            if( !_pSwSoixlOldApi )
            {
                _pSwSoixlOldApi = new( 0 , tinP , LF ) switchC( tinP , third , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) , flSTACKc_null , _psttLeverSoixlOldApi ) ; ___( _pSwSoixlOldApi ) ;_WQ
                if( _pSwSoixlOldApi ) genSoixlOldWordLoadsF( tinP ) ;_WQ
            }

            if( _pSwSoixlOldApi )
            {
                ZE( strokeS* , psttw ) ;_WQ
                //U::TEST FOR EMPTY HERE
                slP >> psttw ; ___( psttw ) ;_WQ
                if( !strCompareF( tinP , psttw , T("?") ) )
                {
                    TN( tBody , "" ) ;_WQ
                    tBody = T(
    
                        POSTpROLOG "\r\n"
                        ". ")+T(postName)+T(" . etherC . n space\r\n"
                        ". off space\r\n"
                        USCORE79 "\r\n"
                        "IdeaFarm " "(tm) SOIL (tm) - Sentient Object Interface Language\r\n"
                        "\r\n"
                        "Class: etherC")+T("\r\n"
                        "Author: ")+T(postName)+T("\r\n"
                        "\r\n"
                        "Class synopsis: Objects of the etherC class are the workhorses of IdeaFarm " "(tm)\r\n"
                        "SOIXLoLD.  Within IdeaFarm " "(tm) SOIL (tm), virtually all side effects are accomplished\r\n"
                        "by manifesting an etherC object on a stack after placing argument literals and\r\n"
                        "a command literal on that stack.  Reading and writing disk files, displaying\r\n"
                        "popup menus, and communicating with other Internet hosts are examples.  When\r\n"
                        "an exception occurs while an etherC object is completing a task, that object\r\n"
                        "will generally become impotent.\r\n"
                        "\r\n"
                        "Object synopsis: The author of this document, \"")+T(postName)+T("\", is at your\r\n"
                        "service and is waiting to be given tasks to do.  You can obtain information about\r\n"
                        "some or all of the following command words by editing this list to move the \"on\"\r\n"
                        "and \"off\" lines so that the words of interest are bracketed.  Then save your\r\n"
                        "changes and drop this document into the depository:\r\n"
                        "\r\n"
                        "    . on space\r\n"
                        "    . off space\r\n"
                        #include "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\1snip.005001c.genSoixlOldWordMenus_etherC_1.h"
                        "\r\n"
                        "You can obtain information about each of these command words\r\n"
                        "by dropping this document into the Depository.\r\n"
    
                    ) ;_WQ
    
                    ZE( strokeS* , pstth ) ;_WQ
                    strReverseF( tinP , pstth , tBody , T("\r\n") ) ; ___( pstth ) ;_WQ
                    tBody = T(pstth) ;_WQ
                    delF( tinP , pstth ) ;_WQ
    
                    TN( tNameShort , "") ; tNameShort = T("soixlOld.help.")+T(postName)+T(".txt") ;_WQ
                    TN( tName , "" ) ; tName = T("///desk/")+tNameShort ;_WQ
                    boxPutF( tinP , tName , tBody , tBody.csF(  tinP ) ) ;_WQ
                    POPUPsOIXLoLD( T("I, \"")+T(postName)+T("\", have placed \"")+tNameShort+T("\" onto your desk.  Read that document and then edit it to indicate what additional information you want.  Then drop it into the Depository to obtain the additional information.") ) ;_WQ
                }
                else if( !strCompareF( tinP , psttw , T("??") ) )
                {
                    if( !_pSwSoixlOldApiDoc )
                    {
                        _pSwSoixlOldApiDoc = new( 0 , tinP , LF ) switchC( tinP , third , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) , flSTACKc_null , _psttLeverSoixlOldApi ) ; ___( _pSwSoixlOldApiDoc ) ;_WQ
                        if( _pSwSoixlOldApiDoc ) genSoixlOldWordHelpsF( tinP ) ;_WQ
                    }

                    ZE( strokeS* , psttQueryWord ) ;_WQ
                    //U::TEST FOR EMPTY HERE
                    slP >> psttQueryWord ; ___( psttQueryWord ) ;_WQ

                    ZE( strokeS* , psttzDoc ) ;_WQ
                    if( _pSwSoixlOldApiDoc && _pSwSoixlOldApiDoc->idSlotOfLeverF( tinP , (countT)psttQueryWord ) )
                    {
                        {
                            _pSwSoixlOldApi->grabF( tinP , TAG( TAGiDnULL ) ) ;_WQ
                            _psttLeverSoixlOldApi = psttQueryWord ;_WQ
                            psttzDoc = (strokeS*)(countT)*_pSwSoixlOldApiDoc ;_WQ
                            _pSwSoixlOldApi->ungrabF( tinP ) ;_WQ
                        }
                    }

                    if( !psttzDoc ) { POPUPsOIXLoLD( T("The word \"")+T(psttQueryWord)+T("\" is unknown to etherC object \"")+T(postName)+T("\".") ) ; }
                    else
                    {
                        ZE( strokeS* , pstth ) ;_WQ
                        strReverseF( tinP , pstth , T(psttzDoc) , T("\r\n") ) ; ___( pstth ) ;_WQ
                        TN( tBody , "" ) ; tBody = T(pstth) ;_WQ
                        delF( tinP , pstth ) ;_WQ
        
                        TN( tNameShort , "") ; tNameShort = T("soixlOld.help.")+T(postName)+T(".")+T(psttQueryWord)+T(".txt") ;_WQ
                        TN( tName , "" ) ; tName = T("///desk/")+tNameShort ;_WQ
                        boxPutF( tinP , tName , tBody , tBody.csF(  tinP ) ) ;_WQ
                        POPUPsOIXLoLD( T("I, \"")+T(postName)+T("\", have placed \"")+tNameShort+T("\" onto your desk.  Read that document and then edit it to indicate what additional information you want.  Then drop it into the Depository to obtain the additional information.") ) ;_WQ
                    }
                    delF( tinP , psttQueryWord ) ;_WQ
                }
                else if( _pSwSoixlOldApi->idSlotOfLeverF( tinP , (countT)psttw ) )
                {
                    ZE( ifcSoixlOldApiFT , pApi ) ;_WQ
                    {
                        _pSwSoixlOldApi->grabF( tinP , TAG( TAGiDnULL ) ) ;_WQ
                        _psttLeverSoixlOldApi = psttw ;_WQ
                        pApi = (ifcSoixlOldApiFT)(countT)*_pSwSoixlOldApi ;_WQ
                        _pSwSoixlOldApi->ungrabF( tinP ) ;_WQ
                    }
    
                    if( pApi ) (*pApi)( tinP , *this , slP , T(postName) ) ;
                    else       { POPUPsOIXLoLD( T("The word \"")+T(psttw)+T("\" is unknown to etherC object \"")+T(postName)+T("\".") ) ; }
                }
                delF( tinP , psttw ) ;_WQ
            }
            break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600216f.etherc.operator_call END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002170.etherc.operator_shiftleft BEGIN
#define DDNAME       "3func.36002170.etherc.operator_shiftleft"
#define DDNUMB      (countT)0x36002170
#define IDFILE      (countT)0xd8a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/baseSoilXxxxC& etherC::operator <<( soulC& slP )/*1*/
{
    TINSL
    SCOOP

    IFbEcAREFUL
    {
        if( POOP ) return *this ;
    }

    _IO_
    if( slP ) ;_WQ
    return *this ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002170.etherc.operator_shiftleft END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002171.etherc.operator_shiftright BEGIN
#define DDNAME       "3func.36002171.etherc.operator_shiftright"
#define DDNUMB      (countT)0x36002171
#define IDFILE      (countT)0xd8b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/baseSoilXxxxC& etherC::operator >>( soulC& slP )/*1*/
{
    TINSL
    SCOOP

    IFbEcAREFUL
    {
        if( POOP ) return *this ;
    }

    _IO_
    if( slP ) ;_WQ
    return *this ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002171.etherc.operator_shiftright END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002172.etherc.gensoilwordloadsf BEGIN
#define DDNAME       "3func.36002172.etherc.gensoilwordloadsf"
#define DDNUMB      (countT)0x36002172
#define IDFILE      (countT)0xd8c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

#include "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\1snip.005001c.genSoixlOldWordProtos_etherC_1.h"

/*1*/voidT etherC::genSoixlOldWordLoadsF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    #include "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\1snip.005001c.genSoixlOldWordLoads_etherC_1.h"
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002172.etherc.gensoilwordloadsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002173.etherc.gensoilwordhelpsf BEGIN
#define DDNAME       "3func.36002173.etherc.gensoilwordhelpsf"
#define DDNUMB      (countT)0x36002173
#define IDFILE      (countT)0xd8d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::genSoixlOldWordHelpsF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    #include "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\1snip.005001c.genSoixlOldWordHelps_etherC_1.h"
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002173.etherc.gensoilwordhelpsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002174.etherc.relayf BEGIN
#define DDNAME       "3func.36002174.etherc.relayf"
#define DDNUMB      (countT)0x36002174
#define IDFILE      (countT)0xd8e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i will return early if i must detach from relay
if this occurs, impotence will not occur
relay system pseudocode
 relayF
  connects to the local inner relay server
  launches tmRelayWriteWrapFromAppF
  for each incoming envelope: call callback  (BBBB)
 tmRelayWriteWrapFromAppF
  for each envelope pushed onto a stackC: write it to the local inner relay server (AAAA)  ========AOK (triplets)
 relayC::relayC
  does inner stuff
  launches tmRelayAcceptorF
 tmRelayAcceptorF
  binds, and puts that idPort value into homeS so local clients can connect to it
  for each local application client, launch tmRelayServerOuterF
 tmRelayServerOuterF
  launches tmRelayServerOuterIncomingF
  read outer envelopes, popping each into the inner system (AAAA)                          ========AOK (triplets)
 tmRelayServerOuterIncomingF
  for each outer envelope pushed onto a stackC (by the inner system)
   test against the filters registered by the application client
   if pass then write the envelope to the application (BBBB)
arguments
 tinP
 bQuitP
 stRelayOutP
  caller can asynchronously push pointers to soulC objects onto stRelayOutP
  the contents of these soulC objects must conform to the relay protocol
  each soulC item will be launched into relay
 cArgP
  passed to the callback function without being inspected
 pCioGetFP
  can be 0
  if not 0 then will be called for each incoming soulC payload
  calling process can change or reset this value asynchronously
  it is illegal to change the value without grabbing b_pCioGetFP
 b_pCioGetFP
*/
/**/

/*1*/voidT etherC::relayF( tinS& tinP , const boolT& bQuitP , stackC& stRelayOutP , countT*& pcArgP , cioGetFT& pCioGetFP , batonC& b_pCioGetFP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    IFsCRATCH
    {
        homeS& home = homeS::homeIF() ;
        idPortC idpTeatLag ;
        while( !bQuitP )
        {
            SCOOPS
            {
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                countT cTries = 0x40 ;
                while( ( !home.idpTeat || ( home.idpTeat == idpTeatLag && cTries -- ) ) && !bQuitP )
                {
                    //CONoUTrAW3( "waiting for home.idpTeat value " , (countT)home.idpTeat , " to change\r\n" ) ;
                    //LOGrAW3( "waiting for home.idpTeat value " , (countT)home.idpTeat , " to change\r\n" ) ;
                    ++ s ; osSleepF( tinP , TUCK * 0x40 ) ;
                }
            }
            idpTeatLag = home.idpTeat ;
    
            if( !bQuitP )
            {
                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                sock.connectF( tinP , home.idpTeat , (nicNameC&)home.idpTeat ) ;
            
                ZE( boolT , bQuitWoConnect ) ;
                signC sgnDone_tmRelayBlowTeatF( tinP , TAG( TAGiDnULL ) ) ;
                osThreadF( tinP , countTC() , tmRelayBlowTeatF , &sgnDone_tmRelayBlowTeatF , flTHREADlAUNCH_null , 0 , (countT)&sock , (countT)&bQuitWoConnect , (countT)&stRelayOutP ) ;
            
                while( !bQuitP && !POOP )
                {
                    soulC* psWrap = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
        
                    sock.readF( tinP , *psWrap ) ;
                    if( POOP )
                    {
                        POOPR
                        //CONoUTrAW3( "ERROR READING FROM TEAT PORT " , (countT)home.idpTeat , "\r\n" ) ;
                        //LOGrAW3( "ERROR READING FROM TEAT PORT " , (countT)home.idpTeat , "\r\n" ) ;
                        DEL( psWrap ) ;
                        break ;
                    }
                    //else { CONoUTrAW( "relayF: readF returned a wrap\r\n" ) ; }
            
                    {
                        ZE( countT , idtTM ) ;
                        ZE( flagsT , flTM ) ;
                        ZE( countT , cbTM ) ;
                        const byteT* pbfTM = psWrap->pbFieldF( tinP , idtTM , flTM , cbTM , ifcIDfIELDwRAP_TRADEmARK ) ;
            
                        ZE( strokeS* , psttTM ) ;
                        strDecodeF( tinP , psttTM , pbfTM ) ; ___( psttTM ) ;
                        strReplaceF( tinP , psttTM , 0 , ifcIDtYPEsTRrEPLACE_MAKEiMPORT , psttTM[ 2 ].idAdam ) ; ___( psttTM ) ;
    
                        __( strCompareF( tinP , psttTM , T("IdeaFarm " "(tm)") ) ) ;
                        delF( tinP , psttTM ) ;
                    }
                    __( psWrap->cFieldF( tinP , ifcIDfIELDwRAP_IDpROTOCOL ) - ifcIDpROTOCOL_RELAYwRAP ) ;
                    __( psWrap->cFieldF( tinP , ifcIDfIELDwRAP_IDvERSION ) - 1 ) ;
            
                    countT idType = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_IDtYPE ) ;
            
                    idPortTimeC idptNU ;
                    ZE( countT , ze ) ;
                    if( idType == ifcIDtYPEwRAP_QUIT    )
                    {
                        DEL( psWrap ) ;
                        break ;
                    }
                    else if( idType == ifcIDtYPEwRAP_GIFT )
                    {
                        ZE( countT , idtC ) ;
                        ZE( flagsT , flC ) ;
                        ZE( countT , cbC ) ;
                        const countT* pczChannel = (countT*)psWrap->pbFieldF( tinP , idtC , flC , cbC , ifcIDfIELDwRAP_CHANNEL ) ;
                        countT cca = 1 + strBodyLengthF( tinP , pczChannel ) ;
                        ZE( countT* , pczChannelCopy ) ;
                        newF( tinP , LF , pczChannelCopy , cca ) ; ___( pczChannelCopy ) ;
                        memCopyF( tinP , (byteT*)pczChannelCopy , (byteT*)pczChannel , cca * sizeof( countT ) ) ;

                        ZE( soulC* , psTo ) ;
                        {
                            ZE( countT , idtTo ) ;
                            ZE( flagsT , flTo ) ;
                            ZE( countT , cbTo ) ;
                            const byteT* pbsTo = psWrap->pbFieldF( tinP , idtTo , flTo , cbTo , ifcIDfIELDwRAP_TO ) ;
                            if( pbsTo )
                            {
                                (*this)( tinP , psTo , TAG( TAGiDnULL ) ) ;
                                if( psTo ) psTo->shiftLeftF( tinP , 0 , pbsTo , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                            }
                            if( psTo && !*psTo ) (*this)( tinP , psTo ) ;
                        }
        
                        //if( psTo ) { CONoUTrAW( "got wrap with sTo values from tit\r\n" ) ; }

                        ZE( soulC* , psToM ) ;
                        {
                            ZE( countT , idtToM ) ;
                            ZE( flagsT , flToM ) ;
                            ZE( countT , cbToM ) ;
                            const byteT* pbsToM = psWrap->pbFieldF( tinP , idtToM , flToM , cbToM , ifcIDfIELDwRAP_TOmEDIATOR ) ;
                            if( pbsToM )
                            {
                                (*this)( tinP , psToM , TAG( TAGiDnULL ) ) ;
                                if( psToM ) psToM->shiftLeftF( tinP , 0 , pbsToM , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                            }
                            if( psToM && !*psToM ) (*this)( tinP , psToM ) ;
                        }

                        //if( psToM ) { CONoUTrAW( "got wrap with sToM values from tit\r\n" ) ; }

                        flagsT& flags = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_FLAGS ) ;
        
                        idPortTimeC idptOrigin = idPortTimeC::fieldF( tinP , *psWrap , ifcIDfIELDwRAP_IDPToRIGIN ) ;
        
                        boolT bMediate = !( F(flags) & flCIOpUT_IGNOREmEDIATORlIST ) && psToM ;
        
                        if( bMediate )
                        {
                            flags |= flCIOpUT_IGNOREmEDIATORlIST ;
        
                            b_pCioGetFP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            if( pCioGetFP )
                            {
                                (*pCioGetFP)( tinP , *tinP.pEtScratch , bQuitP , ifcIDtYPEgIFT_MEDIATE , psWrap , pczChannelCopy , pcArgP ? *pcArgP : ze , idptOrigin ) ; //CALLBACK WILL NORMALLY psWrap AND BE RESPONSIBLE FOR DELETION
                                if( POOP ) POOPR
                            }
                            b_pCioGetFP.ungrabF( tinP ) ;
                        }
                        else
                        {
                            ZE( countT , idtsGift ) ;
                            ZE( flagsT , flsGift ) ;
                            ZE( countT , cbsGift ) ;
                            const byteT* pbsGift = psWrap->pbFieldF( tinP , idtsGift , flsGift , cbsGift , ifcIDfIELDwRAP_GIFT ) ;
            
                            b_pCioGetFP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            if( pCioGetFP )
                            {
                                soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                                if( psGift )
                                {
                                    psGift->shiftLeftF( tinP , 0 , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
            
                                    if( pCioGetFP )
                                    {
                                        (*pCioGetFP)( tinP , *tinP.pEtScratch , bQuitP , ifcIDtYPEgIFT_APPLICATION , psGift , pczChannelCopy , pcArgP ? *pcArgP : ze , idptOrigin ) ;
                                        if( POOP ) POOPR
                                    }
                                    DEL( psGift ) ; //CALLBACK WILL NORMALLY ZE THIS AND BE RESPONSIBLE FOR DELETION
                                }
                            }
                            b_pCioGetFP.ungrabF( tinP ) ;
                        }
                        delF( tinP , pczChannelCopy ) ; //CALLBACK MIGHT ZE THIS OUT AND BE RESPONSIBLE FOR DELETION
                    }
                    //U::CONJ: THE NEXT SNIPPETS ARE PSEUDOIDENTICAL; COMBINE THEM
                    else if( idType == ifcIDtYPEwRAP_REPLYrELAYrANK )
                    {
                        b_pCioGetFP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        if( pCioGetFP )
                        {
                            soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                            if( psGift )
                            {
                                ZE( countT , idtsGift ) ;
                                ZE( flagsT , flsGift ) ;
                                ZE( countT , cbsGift ) ;
                                const byteT* pbsGift = psWrap->pbFieldF( tinP , idtsGift , flsGift , cbsGift , ifcIDfIELDwRAP_RELAYrANK ) ;
                                psGift->shiftLeftF( tinP , 0 , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
        
                                if( pCioGetFP )
                                {
                                    ZE( countT* , pczChannelCopy ) ;
                                    (*pCioGetFP)( tinP , *tinP.pEtScratch , bQuitP , ifcIDtYPEgIFT_REPLYrELAYrANK , psGift , pczChannelCopy , pcArgP ? *pcArgP : ze , idptNU ) ;
                                    if( POOP ) POOPR
                                }
                                DEL( psGift ) ; //CALLBACK WILL NORMALLY ZE THIS AND BE RESPONSIBLE FOR DELETION
                            }
                        }
                        b_pCioGetFP.ungrabF( tinP ) ;
                    }
                    else if( idType == ifcIDtYPEwRAP_REPLYrELAYiDpORTtIMEc )
                    {
                        b_pCioGetFP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        if( pCioGetFP )
                        {
                            soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                            if( psGift )
                            {
                                ZE( countT , idtsGift ) ;
                                ZE( flagsT , flsGift ) ;
                                ZE( countT , cbsGift ) ;
                                const byteT* pbsGift = psWrap->pbFieldF( tinP , idtsGift , flsGift , cbsGift , ifcIDfIELDwRAP_PORTtIME ) ;
                                psGift->shiftLeftF( tinP , 0 , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
        
                                if( pCioGetFP )
                                {
                                    ZE( countT* , pczChannelCopy ) ;
                                    (*pCioGetFP)( tinP , *tinP.pEtScratch , bQuitP , ifcIDtYPEgIFT_REPLYrELAYiDpORTtIMEc , psGift , pczChannelCopy , pcArgP ? *pcArgP : ze , idptNU ) ;
                                    if( POOP ) POOPR
                                }
                                DEL( psGift ) ; //CALLBACK WILL NORMALLY ZE THIS AND BE RESPONSIBLE FOR DELETION
                            }
                        }
                        b_pCioGetFP.ungrabF( tinP ) ;
                    }
                    else if( idType == ifcIDtYPEwRAP_REPLYrELAYiDpORTtIMEcaLLhOMES )
                    {
                        b_pCioGetFP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        if( pCioGetFP )
                        {
                            soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                            if( psGift )
                            {
                                ZE( countT , idtsGift ) ;
                                ZE( flagsT , flsGift ) ;
                                ZE( countT , cbsGift ) ;
                                const byteT* pbsGift = psWrap->pbFieldF( tinP , idtsGift , flsGift , cbsGift , ifcIDfIELDwRAP_PORTtIMEaLLhOMES ) ;
                                psGift->shiftLeftF( tinP , 0 , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
        
                                if( pCioGetFP )
                                {
                                    ZE( countT* , pczChannelCopy ) ;
                                    (*pCioGetFP)( tinP , *tinP.pEtScratch , bQuitP , ifcIDtYPEgIFT_REPLYrELAYiDpORTtIMEcaLLhOMES , psGift , pczChannelCopy , pcArgP ? *pcArgP : ze , idptNU ) ;
                                    if( POOP ) POOPR
                                }
                                DEL( psGift ) ; //CALLBACK WILL NORMALLY ZE THIS AND BE RESPONSIBLE FOR DELETION
                            }
                        }
                        b_pCioGetFP.ungrabF( tinP ) ;
                    }

                    DEL( psWrap ) ;
                }
    
                bQuitWoConnect = 1 ;
                {
                    soulC* psNull = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                    __Z( psNull ) ;
                    if( psNull ) stRelayOutP << *(countT*)&psNull ;
                }
                sgnDone_tmRelayBlowTeatF.waitF( tinP ) ;
            }

            if( POOP ) POOPR
        }
    
        while( stRelayOutP )
        {
            ZE( soulC* , psPayload ) ;
            stRelayOutP >> *(countT*)&psPayload ;
            DEL( psPayload ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002174.etherc.relayf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002175.etherc.tallyf BEGIN
#define DDNAME       "3func.36002175.etherc.tallyf"
#define DDNUMB      (countT)0x36002175
#define IDFILE      (countT)0xd8f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i count the number of elements in pcP that satisfy minP and maxP
my intended application is to evaluate the level of security achieved in pcP, a string of marriage model encryption codes
 the most significant tally is when minP and maxP are allowed to default
  this tally is the tally of all value constants
  a value constant is a value in the range 00ff-ffff
  the value of such a code is just the low order byteT value, so is no secret at all!
  a good code string has few value constants
 arguments
  tinP
  pcP
  ccP
  minP
  maxP
*/
/**/

/*1*/countT etherC::tallyF( tinS& tinP , const count01T* const pcP , const countT ccP , const countT minP , const countT maxP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( countT , tally ) ;
    for( countT off = 0 ; off < ccP ; off ++ ) if( pcP[ off ] >= minP && pcP[ off ] <= maxP ) tally ++ ;
    return tally ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002175.etherc.tallyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002176.etherc.rangerf BEGIN
#define DDNAME       "3func.36002176.etherc.rangerf"
#define DDNUMB      (countT)0x36002176
#define IDFILE      (countT)0xd90


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/boolT etherC::rangerF( tinS& tinP , const byteT*& pbMinP , const byteT*& pbMaxP , const byteT* const pbAtP )/*1*/
{
    boolT bOkAt = rangerF( tinP , pbAtP ) ;

    if( bOkAt )
    {
        {
            const byteT* pbc = pbAtP ;
            RESTART
            if( !_restart )
            {
                _restart.flags |= flRESTARTc_QUIET ;
                do
                {
                    if( *pbc ) ;
                }
                while( pbc -- ) ;                   //EXITS AFTER TESTING ADDRESS 0
                if( !pbc ) pbMinP = pbc ;           //WILL NEVER GET HERE BECAUSE CANNOT READ ADDRESS 0
            }
            else pbMinP = pbc + 1 ;
        }

        {
            const byteT* pbc = pbAtP ;
            RESTART
            if( !_restart )
            {
                _restart.flags |= flRESTARTc_QUIET ;
                do
                {
                    if( *pbc ) ;
                }
                while( pbc ++ ) ;                   //EXITS AFTER TESTING ADDRESS 0
                if( !pbc ) pbMaxP = pbc ;           //WILL NEVER GET HERE BECAUSE CANNOT READ ADDRESS 0
            }
            else pbMaxP = pbc - 1 ;
        }
    }
    else
    {
        {
            const byteT* pbc = pbAtP ;
            ZE( countT , cFail ) ;
            RESTART
            _restart.flags |= flRESTARTc_QUIET ;

            if( _restart > cFail )
            {
                cFail ++ ;
                if( pbc )
                {
                    pbc -- ;
                    if( *pbc ) ;

                    pbMinP = pbc + 1 ;
                }
            }
            else if( *pbc ) ;                       //JUST TO GET IT STARTED
        }

        {
            const byteT* pbc = pbAtP ;
            ZE( countT , cFail ) ;
            RESTART
            _restart.flags |= flRESTARTc_QUIET ;

            if( _restart > cFail )
            {
                cFail ++ ;
                if( ++ pbc )
                {
                    if( *pbc ) ;

                    pbMaxP = pbc - 1 ;
                }
            }
            else if( *pbc ) ;                       //JUST TO GET IT STARTED
        }
    }

    return bOkAt ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002176.etherc.rangerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002177.etherc.rangerf BEGIN
#define DDNAME       "3func.36002177.etherc.rangerf"
#define DDNUMB      (countT)0x36002177
#define IDFILE      (countT)0xd91


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/boolT etherC::rangerF( tinS& tinP , const byteT* const pbAtP )/*1*/
{
    ZE( boolT , bOkAt ) ;
    {
        RESTART
        if( !_restart )
        {
            if( *pbAtP ) ;
        }
        bOkAt = !_restart ;
    }
    return bOkAt ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002177.etherc.rangerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002178.etherc.rangerf BEGIN
#define DDNAME       "3func.36002178.etherc.rangerf"
#define DDNUMB      (countT)0x36002178
#define IDFILE      (countT)0xd92


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::rangerF( tinS& tinP , stackC& stP , boolT& bQuitP , countT cbGrainP )/*1*/
{
    if( !cbGrainP ) cbGrainP = TOCK ;

    ZE( const byteT* , pbc ) ;
    while( !bQuitP )
    {
        if( etherC::rangerF( tinP , pbc ) )
        {
            //CONoUTrAW( "+" ) ;
            ZE( const byteT* , pbMin ) ;
            ZE( const byteT* , pbMax ) ;
            etherC::rangerF( tinP , pbMin , pbMax , pbc ) ;
            count2S minMax( (countT)pbMin , (countT)pbMax ) ;
            stP << (byteT*)&minMax ;
            //CONoUTrAW( "-" ) ;
            pbc = pbMax + cbGrainP ;
            if( pbc < pbMax ) break ; //WRAP
        }
        else
        {
            //CONoUTrAW( "." ) ;
            const byteT* pbOld = pbc ;
            pbc += cbGrainP ;
            if( pbc < pbOld ) break ; //WRAP
            if( (countT)pbc >= 0x80000000 ) break ; //I KNOW THAT THE UPPER HALF OF MEMORY IS UNREADABLE TO ME
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002178.etherc.rangerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600217a.etherc.getfromrecycler0 BEGIN
#define DDNAME       "3func.3600217a.etherc.getfromrecycler0"
#define DDNUMB      (countT)0x3600217a
#define IDFILE      (countT)0xd93


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/GETfROMrECYCLER0( soulC )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600217a.etherc.getfromrecycler0 END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600217b.returntorecycler0 BEGIN
#define DDNAME       "3func.3600217b.returntorecycler0"
#define DDNUMB      (countT)0x3600217b
#define IDFILE      (countT)0xd94


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/RETURNtOrECYCLER0( soulC )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600217b.returntorecycler0 END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600217d.etherc.osdriverparsenamef BEGIN
#define DDNAME       "3func.3600217d.etherc.osdriverparsenamef"
#define DDNUMB      (countT)0x3600217d
#define IDFILE      (countT)0xd95


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//ASSUMED FORMAT:  "IdeaFarm.H2.A1050104.Vd7"

/*1*/voidT etherC::osDriverParseNameF( tinS& tinP , countT& idHomeP , countT& idAdamP , countT& idVersionP , const strokeS* const psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( idHomeP ) ;
        __( idAdamP ) ;
        __( idVersionP ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , psttw ) ;
    ZE( strokeS* , psttw2 ) ;

    strWordF( tinP , psttw , psttP , sttq , S1C('.') , 1 ) ; ___( psttw ) ;
    __( strCompareF( tinP , psttw , T("IdeaFarm") ) ) ;
    delF( tinP , psttw ) ;

    countT* ppcTo[] = { &idHomeP , &idAdamP , &idVersionP } ;
    for( countT off = 0 ; off < 3 ; off ++ )
    {
        strWordF( tinP , psttw , psttP , sttq , S1C('.') , off + 2 ) ; ___( psttw ) ;
        countT idf = 2 ;
        strSubstringF( tinP , psttw2 , idf , countTC() , psttw ) ; ___( psttw2 ) ;
        delF( tinP , psttw ) ;
        *ppcTo[ off ] = strDigitsToSCountF( tinP , psttw2 ) ;
        delF( tinP , psttw2 ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600217d.etherc.osdriverparsenamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600217f.etherc.ciosetquitf BEGIN
#define DDNAME       "3func.3600217f.etherc.ciosetquitf"
#define DDNUMB      (countT)0x3600217f
#define IDFILE      (countT)0xd96


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::cioSetQuitF( tinS& tinP , countT& bQuitP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    if( tinP.pAdamGlobal1->_etherC_.cio_pcQuit  ) { BLAMMO ; } //CAN ONLY BE DECLARED WO TIME
    if( tinP.pAdamGlobal1->_etherC_.cio_pStkOut ) { BLAMMO ; } //CAN ONLY BE DECLARED BEFORE CHANNEL I/O IS SET UP (I MUST BE THE WO'TH SETUP CALL)
    tinP.pAdamGlobal1->_etherC_.cio_pcQuit = &bQuitP ;
    cioSetupF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600217f.etherc.ciosetquitf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002180.etherc.ciosetupf BEGIN
#define DDNAME       "3func.36002180.etherc.ciosetupf"
#define DDNUMB      (countT)0x36002180
#define IDFILE      (countT)0xd97


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
adam definitions that use me implicitly on a kid thread can call me explicitly on the main thread
 if i am called woth on a kid thread then that kid thread will not end until my tmCioF ends
 this is normally undesirable
*/
/**/

/*1*/voidT etherC::cioSetupF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    static countT idInLath ;
    countT idIn = 1 + incv02AM( idInLath ) ;
    if( idIn == 1 )
    {
        tinP.pAdamGlobal1->_etherC_.cio_pBaton  = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) ; ___( tinP.pAdamGlobal1->_etherC_.cio_pBaton  ) ;
        tinP.pAdamGlobal1->_etherC_.cio_pStkOut = new( 0 , tinP , LF ) stackC(  tinP , *tinP.pAdamGlobal1->_etherC_.pEtLongLasting , TAG( TAGiDnULL ) , flSTACKc_GIVEsIGNnEWpLATE|flSTACKc_GIVEsIGNdELpLATE )  ; ___( tinP.pAdamGlobal1->_etherC_.cio_pStkOut ) ;
        if( !tinP.pAdamGlobal1->_etherC_.cio_pBaton || !tinP.pAdamGlobal1->_etherC_.cio_pStkOut ) { BLAMMO ; }

        osThreadF( tinP , countTC() , tmCioF , 0 , flTHREADlAUNCH_null , 0 , (countT)tinP.pAdamGlobal1->_etherC_.cio_pcQuit , (countT)tinP.pAdamGlobal1->_etherC_.cio_pStkOut , (countT)&tinP.pAdamGlobal1->_etherC_.cio_pcArg , (countT)&tinP.pAdamGlobal1->_etherC_.cio_pGetF , (countT)tinP.pAdamGlobal1->_etherC_.cio_pBaton ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002180.etherc.ciosetupf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002181.etherc.ciosetgetf BEGIN
#define DDNAME       "3func.36002181.etherc.ciosetgetf"
#define DDNUMB      (countT)0x36002181
#define IDFILE      (countT)0xd98


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::cioSetGetF( tinS& tinP , cioGetFT pCioGetFP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    if( !tinP.pAdamGlobal1->_etherC_.cio_pStkOut ) cioSetupF( tinP ) ;
    tinP.pAdamGlobal1->_etherC_.cio_pBaton->grabF( tinP , TAG( TAGiDnULL ) ) ;
    tinP.pAdamGlobal1->_etherC_.cio_pGetF = pCioGetFP ;
    tinP.pAdamGlobal1->_etherC_.cio_pBaton->ungrabF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002181.etherc.ciosetgetf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002182.etherc.ciosetargf BEGIN
#define DDNAME       "3func.36002182.etherc.ciosetargf"
#define DDNUMB      (countT)0x36002182
#define IDFILE      (countT)0xd99


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::cioSetArgF( tinS& tinP , countT& cArgP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    if( !tinP.pAdamGlobal1->_etherC_.cio_pStkOut ) cioSetupF( tinP ) ;
    tinP.pAdamGlobal1->_etherC_.cio_pBaton->grabF( tinP , TAG( TAGiDnULL ) ) ;
    tinP.pAdamGlobal1->_etherC_.cio_pcArg = &cArgP ;
    tinP.pAdamGlobal1->_etherC_.cio_pBaton->ungrabF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002182.etherc.ciosetargf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002183.etherc.cioputf BEGIN
#define DDNAME       "3func.36002183.etherc.cioputf"
#define DDNUMB      (countT)0x36002183
#define IDFILE      (countT)0xd9a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::cioPutF( tinS& tinP , const boolT& bQuitP , const countT* const pczChannelP , soulC& sGiftP , soulC* const psToP , soulC* const psToMediatorP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    //CONoUTrAW( "cioPutF: cioSetupF\r\n" ) ;
    if( !tinP.pAdamGlobal1->_etherC_.cio_pStkOut ) cioSetupF( tinP ) ;
    //CONoUTrAW( "cioPutF: after cioSetupF\r\n" ) ;

    soulC* psWrap = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
    __Z( psWrap ) ;
    if( psWrap )
    {
        if( !pczChannelP ) *psWrap = sGiftP ;
        else
        {
            soulC* psTo = psToP ;
            if( !psTo ) (*this)( tinP , psTo , TAG( TAGiDnULL ) ) ;
            __Z( psTo ) ;

            soulC* psToMediator = psToMediatorP ;
            if( !psToMediator ) (*this)( tinP , psToMediator , TAG( TAGiDnULL ) ) ;
            __Z( psToMediator ) ;

            if( psTo && psToMediator )
            {
                /* 1 */ *psWrap << (strokeS*)textC( tinP , TAG( TAGiDnULL ) , flTEXTc_null , "IdeaFarm " "(tm)" ) ;
                /* 2 */ *psWrap << (countT)ifcIDpROTOCOL_RELAYwRAP ;
                /* 3 */ *psWrap << (countT)1 ; // idVersion
                /* 4 */ *psWrap << (countT)ifcIDtYPEwRAP_GIFT ;
                /* 5 */ *psWrap << pczChannelP ;
                /* 6 */ *psWrap << *psTo ;
                /* 7 */ *psWrap << *psToMediator ;
                /* 8 */ *psWrap << flagsP ;
                /* 9 */ *psWrap << sGiftP ;
                /* a-d */ homeS::homeIF().idptRelay >> *psWrap ;
            }
            if( !psToP ) (*this)( tinP , psTo ) ;
            if( !psToMediatorP ) (*this)( tinP , psToMediator ) ;
        }

        //CONoUTrAW( "cioPutF: pushing to *cio_pStkOutI\r\n" ) ;
        //CONoUTrAW( "cioPutF: waitGrabF\r\n" ) ;
        if( tinP.pAdamGlobal1->_etherC_.cio_pStkOut->waitGrabF( tinP , 0x100 , bQuitP ) ) //U::
        //U::if( tinP.pAdamGlobal1->_etherC_.cio_pStkOut->waitGrabF( tinP , 0x10 , bQuitP ) )
        {
            //CONoUTrAW( "cioPutF: pushing wrap onto stack\r\n" ) ;
            *tinP.pAdamGlobal1->_etherC_.cio_pStkOut << (countT)psWrap ; psWrap = 0 ;
            //{ CONoUTrAW3( "queue: " , *tinP.pAdamGlobal1->_etherC_.cio_pStkOut , "\r\n" ) ; }
            tinP.pAdamGlobal1->_etherC_.cio_pStkOut->ungrabF( tinP ) ;
        }
        //CONoUTrAW( "cioPutF: done\r\n" ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002183.etherc.cioputf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002184.etherc.strfromf BEGIN
#define DDNAME       "3func.36002184.etherc.strfromf"
#define DDNUMB      (countT)0x36002184
#define IDFILE      (countT)0xd9b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::strFromF( tinS& tinP , strokeS*& psttP , const idPortTimeC& idptP , const flagsT flFormatP , const countT csP , const countT radixP , const strokeS* const psttSeparatorP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
            if( POOP ) return ;
            __NZ( psttP ) ;_WQ
            __( radixP && radixP < 2 ) ;_WQ
            __( !tinP.strokeMode.idCasteDefault && radixP > 64 ) ;_WQ
            __(  tinP.strokeMode.idCasteDefault && radixP > 0x10000 ) ;_WQ
            __( !POOP && processGlobal1I.cb_idPortTimeC_ - 7 * sizeof( countT ) ) ;_WQ
            if( POOP ) return ;
    }

    _IO_

    TN( tSeparator , "." ) ;_WQ
    const strokeS* const psttSeparator = psttSeparatorP ? psttSeparatorP : tSeparator ;_WQ

    flagsT flFormat = F(flFormatP) ? flFormatP : flFORMAT_DOTTEDdECIMAL ;_WQ
    //flagsT flFormat = flFormatP ;_WQ

    //O:: USE RECYCLED soulC OBJECT FOR ALL CODE LIKE THIS (rather than stackC)
    ZE( boolT , bLong ) ;_WQ
    stackC stEach( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;_WQ
    {
        countT* pcv = (countT*)&idptP ;_WQ
        for( countT off = 0 ; off < 7 ; off ++ )
        {
            ZE( strokeS* , psttw ) ;_WQ
            strFromF( tinP , psttw , pcv[ off ] , flFormat , csP , radixP ) ; ___( psttw ) ;_WQ
            stEach << psttw ;_WQ
            if( off && pcv[ off ] && !bLong ) bLong = 1 ;_WQ
        }
    }

    countT csAll = csttExtraP ;_WQ
    {
        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;_WQ
        do
        {
            strokeS* psttw = (strokeS*)stEach.downF( tinP , handle ) ;_WQ
            if( psttw ) csAll += psttw->idAdam + ( ~handle ? psttSeparator->idAdam : 0 ) ;_WQ
        }
        while( ~handle ) ;_WQ
    }

    strMakeF( tinP , LF , psttP , T("") , csAll ) ; // CALLER MUST TAG ___( psttP ) ;_WQ
    while( stEach )
    {
        ZE( strokeS* , psttw ) ;_WQ
        stEach >> psttw ;_WQ
        strFuseF( tinP , psttP , psttw ) ; ___( psttP ) ;_WQ
        delF( tinP , psttw ) ;_WQ
        if( !bLong ) break ;
        if( stEach ) { strFuseF( tinP , psttP , psttSeparator ) ; ___( psttP ) ; }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002184.etherc.strfromf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002185.etherc.ciokeyf BEGIN
#define DDNAME       "3func.36002185.etherc.ciokeyf"
#define DDNUMB      (countT)0x36002185
#define IDFILE      (countT)0xd9c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i return the name of the youngest key file of the specified type
*/
/**/

/*1*/voidT etherC::cioKeyF( tinS& tinP , countT*& pczNameP , const countT idTypeP , const countT idSubTypeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    countT idHomeDisk = ifc_idHomeIdisk_IF() ;
    TN( tDot , "." ) ;
    TN( tLike , "///desk/" POSTfOLDERsECURITYkEYdEPOSITORY ) ;
    tLike += (idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/????????.????????.")+ //TIME2.TIME1.
        TF3(idTypeP,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot+
        TF3(idSubTypeP,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(".*")
    ;

    soulC soul1m( tinP , TAG( TAGiDnULL ) ) ;
    boxMenuF( tinP , soul1m , tLike ) ;
    
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    strokeS sttd = S1C( '/' ) ;
    TN( td , "." ) ;
    FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
    {
        if( soul1m ) continue ; //IF NOT LATH STRING (EDITED WHEN MIGRATED TO SOUL; NOT TESTED)

        ZE( strokeS* , psttw ) ;
        strWordF( tinP , psttw , psttc1 , sttq , sttd , - 1 ) ; ___( psttw ) ;
        ZE( strokeS* , pstt1w ) ;
        strWordsOldF( tinP , pstt1w , psttw , sttq , td ) ; ___( pstt1w ) ;
        delF( tinP , psttw ) ;

        ZE( countT , cWords ) ;
        FORsTRINGSiN2( pstt1w ) ++ cWords ;

        newF( tinP , LF , pczNameP , 1 + cWords ) ; ___( pczNameP ) ;
        if( pczNameP )
        {
            ZE( countT , off ) ;
            FORsTRINGSiN3( pstt1w ) pczNameP[ off ++ ] = strDigitsToSCountF( tinP , psttc3 , 0 , 1 ) ;
            pczNameP[ off ++ ] = 0 ;
        }
        delF( tinP , pstt1w ) ;
    }
    FORsTRINGSiNsPANNEDcOMBINEDtAIL1
    THREADmODE1rESTORE
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002185.etherc.ciokeyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002186.etherc.cioputsecretf BEGIN
#define DDNAME       "3func.36002186.etherc.cioputsecretf"
#define DDNUMB      (countT)0x36002186
#define IDFILE      (countT)0xd9d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::cioPutSecretF( tinS& tinP , const boolT& bQuitP , soulC& sSecretP , soulC& sToP , const countT* pczChannelSuffixP , const countT* pczPinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    ZE( soulC* , psToMediator ) ;
    if( !pczPinP ) //A: ASSUME: IF CALLER SPECIFIES A PIN THEN CALLER IS A MEDIATOR CALLING ME TO DELIVER TO FINAL RECIPIENT
    {
        (*this)( tinP , psToMediator , TAG( TAGiDnULL ) ) ;
        if( psToMediator )
        {
            idPortTimeC idptm ;
            idptm >> *psToMediator ;
        }
    }
    //else strokeF( tinP , T("delivering using pin ")+T(pczPinP)+T("\r\n") ) ; //U::

    ZE( soulC* , psGift ) ;
    (*this)( tinP , psGift , TAG( TAGiDnULL ) ) ;

    if( psGift && ( pczPinP || psToMediator ) )
    {
        momC mom( tinP , *this , TAG( TAGiDnULL ) ) ;

        ZE( count01T* , pc01all ) ;
        ZE( countT    , cc01all ) ;
        {
            ZE( count01T* , pc01pin ) ;
            ZE( countT    , cc01pin ) ;
            {
                boolT bDefault = !pczPinP ;
                if( bDefault ) { cioKeyF( tinP , *(countT**)&pczPinP , idbKEYtYPE_PIN , idbKEYpINtYPE_SECRETsERVICE ) ; ___( pczPinP ) ; } //A: ASSUME: A COPY OF THIS PIN FILE RESIDES AT THE HOME OF THE MEDIATOR (SINGLE CELL ADAM)
                if( pczPinP ) { mom( tinP , pc01pin , cc01pin , 0 , 0 , pczPinP , 1 ) ; ___( pc01pin ) ; }
                if( bDefault ) delF( tinP , *(countT**)&pczPinP ) ;
            }
    
            if( pc01pin )
            {
                ZE( count01T* , pc01secret ) ;
                ZE( countT    , cc01secret ) ;
                {
                    const byteT* pbs = sSecretP ;
                    mom( tinP , pc01secret , cc01secret , pbs , sizeof( countT ) + *(countT*)pbs ) ; ___( pc01secret ) ;
                }
        
                if( pc01secret )
                {
                    cc01all = cc01pin + cc01secret ;
                    newF( tinP , LF , pc01all , cc01all ) ; ___( pc01all ) ;
                    if( pc01all )
                    {
                        memCopyF( tinP , (byteT*)pc01all               , (byteT*)pc01pin    , cc01pin    * sizeof( count01T ) ) ;
                        memCopyF( tinP , (byteT*)( pc01all + cc01pin ) , (byteT*)pc01secret , cc01secret * sizeof( count01T ) ) ;
                    }
                }
                delF( tinP , pc01secret ) ;
            }
            delF( tinP , pc01pin ) ;
        }

        if( pc01all )
        {
            psGift->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_byteTptr , (byteT*)pc01all , cc01all * sizeof( count01T ) ) ;
    
            count8S c8Prefix( ifcIDcHANNEL1_BYfUNCTION , ifcIDcHANNELfUNCTION_MEDIATED , ifcIDaDAM_SECRETsERVICE ) ;
            ZE( countT* , pczChannel ) ;
            countT cc1 = strBodyLengthF( tinP , (countT*)c8Prefix ) ;
            countT cc2 = strBodyLengthF( tinP , pczChannelSuffixP ) ;
            newF( tinP , LF , pczChannel , cc1 + cc2 + 1 ) ; ___( pczChannel ) ;
            if( pczChannel )
            {
                memCopyF( tinP , (byteT*)pczChannel           , (byteT*)(countT*)c8Prefix          , cc1         * sizeof( countT ) ) ;
                memCopyF( tinP , (byteT*)( pczChannel + cc1 ) , (byteT*)(countT*)pczChannelSuffixP , ( cc2 + 1 ) * sizeof( countT ) ) ;
    
                cioPutF( tinP , bQuitP , pczChannel , *psGift , &sToP , psToMediator ) ;
            }
            delF( tinP , pczChannel ) ;
        }
        delF( tinP , pc01all ) ;
    }

    if( !pczPinP ) (*this)( tinP , psToMediator ) ;
    (*this)( tinP , psGift ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002186.etherc.cioputsecretf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002187.etherc.ciogetsecretf BEGIN
#define DDNAME       "3func.36002187.etherc.ciogetsecretf"
#define DDNUMB      (countT)0x36002187
#define IDFILE      (countT)0xd9e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::cioGetSecretF( tinS& tinP , soulC*& psSecretP , soulC& sGiftP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    (*this)( tinP , psSecretP , TAG( TAGiDnULL ) ) ;
    if( psSecretP )
    {
        ZE( byteT* , pbsSecret ) ;
        ZE( countT , cbsSecret ) ;
        {
            ZE( count01T* , pc01mm ) ;
            ZE( countT    , cc01mm ) ;
            sGiftP.shiftRightF( tinP , *(byteT**)&pc01mm , cc01mm , ifcIDtYPEsOULiTEM_byteTptr ) ; ___( pc01mm ) ;
            cc01mm /= sizeof( count01T ) ;
            if( pc01mm )
            {
                dadC dad( tinP , *this , TAG( TAGiDnULL ) ) ;
                dad( tinP , pbsSecret , cbsSecret , pc01mm , cc01mm , 1 ) ; ___( pbsSecret ) ;
            }
            delF( tinP , pc01mm ) ;
        }
        if( pbsSecret ) psSecretP->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbsSecret , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
        delF( tinP , pbsSecret ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002187.etherc.ciogetsecretf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002188.etherc.ciomakekeyf BEGIN
#define DDNAME       "3func.36002188.etherc.ciomakekeyf"
#define DDNUMB      (countT)0x36002188
#define IDFILE      (countT)0xd9f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

// !spec : naming convention for pin/pill files
//   like prior alt but name begins with time, in foreign digit order so files will sort by time
//   pczName[0]: time2, foreign order, ze filled
//   pczName[1]: time1, foreign order, ze filled
//   pczName[2]
//    1: pin
//    2: pill
//   pczName[3]: uses symbolic constant (separate list for pins, for pills)
//   pczName[4+]: no general spec


/*1*/voidT etherC::cioMakeKeyF( tinS& tinP , countT*& pczNameP , const countT idTypeP , const countT idSubTypeP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_
    
    TN( tDot , "." ) ;
    TN( tInLike , "///ideafarm/ephemeral/super.random.numbers/set.*" ) ;
    soulC soul1m( tinP , TAG( TAGiDnULL ) ) ;
    countT cFound = boxMenuF( tinP , soul1m , tInLike , 0 , 1 ) ;

    ZE( byteT* , pbi ) ;
    ZE( countT , cbi ) ;
    if( cFound )
    {
        IFsCRATCH
        {
            SCOOPS
            FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
            {
                tinP.pEtScratch->boxGetF( tinP , pbi , cbi , psttc1 , 1 ) ; ___( pbi ) ;
                if( !POOP ) break ;
                POOPR
            }
            FORsTRINGSiNsPANNEDcOMBINEDtAIL1
        }
    }

    if( !pbi )
    {
        cbi = TOCK ;
        newF( tinP , LF , pbi , cbi ) ; ___( pbi ) ;
        if( pbi )
        {
            countT* pci = (countT*)pbi ;
            countT  cci = cbi / sizeof( countT ) ;

            ranUniC ru( tinP , MAXcOUNTT ) ;
            for( countT off = 0 ; off < cci ; off ++ ) pci[ off ] = ru ;
        }
    }

    {
        ZE( countT , timeN1 ) ;
        ZE( sCountT , timeN2 ) ;
        osTimeNowF( tinP , timeN1 , timeN2 ) ;
    
        newF( tinP , LF , pczNameP , 9 ) ; ___( pczNameP ) ;
        if( pczNameP )
        {
            pczNameP[ 0 ] = timeN2 ;
            pczNameP[ 1 ] = timeN1 ;
            pczNameP[ 2 ] = idTypeP ;
            pczNameP[ 3 ] = idSubTypeP ;
            pczNameP[ 4 ] = homeS::homeIF().iduuHome ? homeS::homeIF().iduuHome : - 1 ;
            pczNameP[ 5 ] = processGlobal1I.idAdamRoot ;
            pczNameP[ 6 ] = tinP.monitor.idThread ;
            pczNameP[ 7 ] = tinP.monitor.idStep ;
            pczNameP[ 8 ] = 0 ;
        }

        countT idHomeDisk = ifc_idHomeIdisk_IF() ;
        TN( tFolderOut , "///desk/" POSTfOLDERsECURITYkEYdEPOSITORY ) ; tFolderOut += (idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/") ;
        TN( tDot , "." ) ;
        textC tShort( tinP , TAG( TAGiDnULL ) , flTEXTc_null , pczNameP , flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE , 8 , 0 , tDot ) ;
        TN( tLong , "" ) ; tLong = tFolderOut+tShort ;

        //if( pczNameP[ 3 ] == idbKEYpINtYPE_SOCKETcONNECTION ) { CONoUTrAW( T("mak: ")+TF1(cbi)+T(" ")+tShort+T("\r\n") ) ; }

        boxPutF( tinP , tLong , pbi , cbi ) ;
        //strokeF( tinP , T("+: ")+tLong+T("\r\n") ) ;
        if( *this ) delF( tinP , pczNameP ) ;
    }
    delF( tinP , pbi ) ;

    __Z( pczNameP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002188.etherc.ciomakekeyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002189.etherc.ciostrokeconsolef BEGIN
#define DDNAME       "3func.36002189.etherc.ciostrokeconsolef"
#define DDNUMB      (countT)0x36002189
#define IDFILE      (countT)0xda0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::cioStrokeConsoleF( tinS& tinP , const boolT& bQuitP , const strokeS* const psttP , const countT* pczChannelSuffixP , soulC* const psToP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    ZE( soulC* , psGift ) ;
    (*this)( tinP , psGift , TAG( TAGiDnULL ) ) ;

    if( psGift )
    {
        *psGift << psttP ;


        static countT idStrokeLath ;
        countT idStroke = 1 + incv02AM( idStrokeLath ) ;
        strokeF( tinP , T("cioStrokeConsoleF: stroking (")+TF1(idStroke)+T(")\r\n") ) ; //U::

        count8S c8Prefix( ifcIDcHANNEL1_BYfUNCTION , ifcIDcHANNELfUNCTION_STROKEcONSOLE ) ;
        ZE( countT* , pczChannel ) ;
        countT cc1 = strBodyLengthF( tinP , (countT*)c8Prefix ) ;
        countT cc2 = pczChannelSuffixP ? strBodyLengthF( tinP , pczChannelSuffixP ) : 0 ;
        newF( tinP , LF , pczChannel , cc1 + cc2 + 1 ) ; ___( pczChannel ) ;
        if( pczChannel )
        {
                      memCopyF( tinP , (byteT*)  pczChannel         , (byteT*)(countT*)c8Prefix          ,   cc1       * sizeof( countT ) ) ;
            if( cc2 ) memCopyF( tinP , (byteT*)( pczChannel + cc1 ) , (byteT*)(countT*)pczChannelSuffixP , ( cc2 + 1 ) * sizeof( countT ) ) ;
            else      *( pczChannel + cc1 ) = 0 ;

            cioPutF( tinP , bQuitP , pczChannel , *psGift , psToP ) ;
        }
        delF( tinP , pczChannel ) ;
    }

    (*this)( tinP , psGift ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002189.etherc.ciostrokeconsolef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600218a.etherc.operator_const_poopc_ref BEGIN
#define DDNAME       "3func.3600218a.etherc.operator_const_poopc_ref"
#define DDNUMB      (countT)0x3600218a
#define IDFILE      (countT)0xda1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/etherC::operator const poopC&( voidT )/*1*/
{
    return third ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600218a.etherc.operator_const_poopc_ref END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600218b.etherc.dllentryf BEGIN
#define DDNAME       "3func.3600218b.etherc.dllentryf"
#define DDNUMB      (countT)0x3600218b
#define IDFILE      (countT)0xda2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$dllEntryF.0.html\"\>instances\</A\>
\<A HREF=\"5.103007e.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 pSadamCBFP
 handleP
 psttP
*/
/**//*1*/voidT etherC::dllEntryF( tinS& tinP , sadamCBFT& pSadamCBFP , const handleC& handleP , const strokeS* psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( pSadamCBFP ) ;
        __Z( handleP ) ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    if( psttP )
    {
        //LOGrAW( T(psttP)+T("\r\n") ) ;

        //CODEsYNCH: 10301e9 0022025
        //TN( tOs2 , "" ) ; tOs2 = T(psttP) ;
        //TN( tLin , "" ) ; tLin = T("?") ;
        ZE( strokeS* , pstta ) ;
        strMakeF( tinP , LF , pstta , *tinP.pAdamGlobal1->_etherC_.pTxtDllEntry1 , psttP->idAdam + tinP.pAdamGlobal1->_etherC_.pTxtDllEntry2->csF( tinP ) ) ; ___( pstta ) ;
        strFuseF( tinP , pstta , psttP ) ;
        strFuseF( tinP , pstta , *tinP.pAdamGlobal1->_etherC_.pTxtDllEntry2 ) ;
    
        //LOGrAW( T("searching in ")+T((countT)handleP.osF(ifcIDtYPEhANDLE_DLL))+T(" for entry named \"")+T(pstta)+T("\"\r\n") ) ; //U::

        ZE( voidT* , pv ) ;
        dllEntryF( tinP , pv , handleP , pstta ) ;
        //LOGrAW( T(" found ")+TF1((countT)pv)+T("\r\n") ) ; //U::
        //dllEntryF( tinP , pv , handleP , TO((strokeS*)tOs2,(strokeS*)tWin,(strokeS*)tLin) ) ;
        delF( tinP , pstta ) ;
        pSadamCBFP = (sadamCBFT)pv ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600218b.etherc.dllentryf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600218c.etherc.getfromrecycler2_stackc BEGIN
#define DDNAME       "3func.3600218c.etherc.getfromrecycler2_stackc"
#define DDNUMB      (countT)0x3600218c
#define IDFILE      (countT)0xda3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/GETfROMrECYCLER2( stackC )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600218c.etherc.getfromrecycler2_stackc END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600218d.returntorecycler2_stackc BEGIN
#define DDNAME       "3func.3600218d.returntorecycler2_stackc"
#define DDNUMB      (countT)0x3600218d
#define IDFILE      (countT)0xda4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/RETURNtOrECYCLER2( stackC )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600218d.returntorecycler2_stackc END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600218e.etherc.strmakef BEGIN
#define DDNAME       "3func.3600218e.etherc.strmakef"
#define DDNUMB      (countT)0x3600218e
#define IDFILE      (countT)0xda5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strMakeF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030065.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.0a10104.1.1.0.html\"\>0a10104:  WAKEsHOW( "example.simplest.func.1030065.etherC.strMakeF" )\</A\>
arguments
 psttOutP
 sttInP
 csttExtraP
*/
/**/

/*1*/voidT etherC::strMakeF( tinS& tinP , const countT idLineP , const countT idiFileP , strokeS*& psttOutP , const strokeS sttInP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttOutP ) ;_WQ
        if( POOP ) return ;
    }

    _IO_
    third.newF( tinP , idLineP , idiFileP , psttOutP , CSpREFIX + 1 + csttExtraP ) ; ___LF( psttOutP , idLineP , idiFileP ) ;_WQ

    if( psttOutP )
    {
        SETpREFIX( psttOutP , 1 , csttExtraP ) ;_WQ
        const countT offEnd = CSpREFIX + 1 ;_WQ
        psttOutP[ CSpREFIX ] = sttInP ;_WQ
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600218e.etherc.strmakef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600218f.etherc.stridf BEGIN
#define DDNAME       "3func.3600218f.etherc.stridf"
#define DDNUMB      (countT)0x3600218f
#define IDFILE      (countT)0xda6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
arguments
 tinP
 cSmallP
  any value
 pcBigP
  must not be 0
 ccBigP
  can be 0
  if 0 then pcBigP is assumed to be null terminated
  if not 0 then ccBigP elements will be inspected
 note that i cannot be called for a string of 0 length that is not null terminated
*/
/**/

/*1*/countT etherC::strIdF( tinS& tinP , countT& idFirstP , const countT cSmallP , const countT* pcBigP , const countT ccBigP , sCountT idP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( idFirstP ) ;_WQ
        __Z( cSmallP ) ;_WQ
        __Z( pcBigP ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_

    STRiDrECURSE( strIdF( tinP , idf , cSmallP , pcBigP , ccBigP , 1 ) )
    {
        for( countT off = idFirstP - 1 ;; off ++ )
        {
            if( ccBigP )
            {
                if( ccBigP == off ) break ;
            }
            else
            {
                if( !pcBigP[ off ] ) break ;
            }
    
            if( pcBigP[ off ] == cSmallP )
            {
                idHit       = off + 1 ;_WQ
                idFirstP = off + 2 ;_WQ
                break ;
            }
        }
    }

    return idHit ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600218f.etherc.stridf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002190.etherc.strdecodef BEGIN
#define DDNAME       "3func.36002190.etherc.strdecodef"
#define DDNUMB      (countT)0x36002190
#define IDFILE      (countT)0xda7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i decompress a prefixed stroke string
i evaluate to the length of the encoding at pbP
*/
/**/

/*1*/countT etherC::strDecodeF( tinS& tinP , strokeS*& psttP , const byteT* const pbP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( psttP ) ;
        __Z( pbP ) ;
        if( POOP ) return 0 ;
        __( ((countT*)pbP)[ 0 ] != FINGERnEG_STReNCODEf && ((countT*)pbP)[ 0 ] != FINGERnEGoLD_strEncodeF ) ;
        __( !((countT*)pbP)[ 1 ] ) ;
        if( POOP ) return 0 ;
    }

    ZE( countT , cbUsed ) ;
    ZE( countT , offbi ) ; //BIT OFFSET OF NEXT READ
    {
        countT finger = valueInF( pbP , offbi , sizeof( countT ) * SB ) ;
        __( finger != FINGERnEG_STReNCODEf && finger != FINGERnEGoLD_strEncodeF ) ;

        const countT cbPrefix = valueInF( pbP , offbi , sizeof( countT ) * SB ) ;
        cbUsed = cbPrefix + 2 * sizeof( countT ) ;
        //COMMENTED OUT SO pbP CAN BE WITHIN A LARGE AGGREGATE OF ENCODINGS
        //countT cbActual = tinP.pDropNoteNewest->cbUsedReally ;
        //countT cbClaimed = cbPrefix + 2 * sizeof( countT ) ;
        //__( cbActual != cbClaimed && cbActual - 1 != cbClaimed && cbActual + 1 != cbClaimed ) ; //soulC APPENDS NULL TERMINATOR AS A COURTESY; I REQUIRE THAT LENGTHS DIFFER BY NO MORE THAN 1 BYTE
    }

    //WOTH STROKE
    strokeS stt1 ;
    getStrokeS( stt1 , pbP , offbi ) ;
    __( stt1.idCaste - sc_PREFIXlENGTH ) ;

    if( !POOP)
    {
        newF( tinP , LF , psttP , CSpREFIX + stt1.idAdam ) ; // CALLER MUST TAG ___( psttP ) ;
        if( psttP )
        {
            ZE( countT , offo ) ;
            psttP[ offo ++ ] = stt1 ;
            countT cToDoPrefix = CSpREFIX - 1 ;
            while( cToDoPrefix -- ) getStrokeS( psttP[ offo ++ ] , pbP , offbi ) ;

            countT cToDo = psttP->idAdam ;
            while( cToDo -- )
            {
                countT offbisave = offbi ;
                getStrokeS( psttP[ offo ++ ] , pbP , offbi ) ;
                if( psttP[ offo - 1 ].idCaste == sc_cADAMeXPORT )
                {
                    valueInF( pbP , offbi , ( SB - offbi ) % SB ) ;

                    countT csImage = psttP[ offo - 1 ].idAdam ;
                    countT cbImage = csImage * sizeof( strokeS ) ;
                    thirdC::c_memcpyIF( tinP , (byteT*)&psttP[ offo ] , pbP + offbi / SB , cbImage ) ;
                    offbi += cbImage * SB ;
                    offo  += csImage ;
                    cToDo -= csImage ;
                }
            }
        }
    }

    //CONoUTrAW( T("decoded  \"")+T(psttP)+T("\"\r\n") ) ; //TO FIND SLOWNESS

    //COMMENT OUT IN PRODUCTION
    //if( tinP.pc Utility[ 0 ] )
    //{
    //    ZE( strokeS* , psttdCodes ) ;
    //    strDumpIF( tinP , psttdCodes , pbP , ((countT*)pbP)[ 1 ] + 2 * sizeof( countT ) ) ; ___( psttdCodes ) ;
    //    TN( td , "" ) ; td = T("\r\nfrom codes  : ")+T(psttdCodes)+T("\r\n") ;
    //    LOGrAW( td ) ;
    //    delF( tinP , psttdCodes ) ;
    //}
    
    //COMMENT OUT IN PRODUCTION
    //if( tinP.pc Utility[ 0 ] )
    //{
    //    ZE( strokeS* , psttdStrokes ) ;
    //    strDumpIF( tinP , psttdStrokes , (byteT*)psttP , ( CSpREFIX + psttP->idAdam ) * sizeof( strokeS ) ) ; ___( psttdStrokes ) ;
    //    TN( td , "" ) ; td = T("  to strokes: ")+T(psttdStrokes)+T("\r\n") ;
    //    LOGrAW( td ) ;
    //    delF( tinP , psttdStrokes ) ;
    //}

    return cbUsed ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002190.etherc.strdecodef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002191.etherc.strencodef BEGIN
#define DDNAME       "3func.36002191.etherc.strencodef"
#define DDNUMB      (countT)0x36002191
#define IDFILE      (countT)0xda8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i encode strings of strokeS values to reduce the required space
i evaluate to the number of bytes actually used in the encoding
 pbP + myReturnValue is the pbEnd of the encoding
arguments
 tinP
 pbP
  can be 0
  if not 0 then must contain enough bytes to receive the worst case length encoding
  U:: can also be a value initialized by ZEJ() to specify that the drop is to be allocated within the specified jotC instance rather than in PUSE
 psttP
  may be 0
  if 0 then i do nothing
  if not 0 then must point to a string prefix
   see SETpREFIX
 pbeP
  if !pbP then must be 0
  if pbP then must not be 0, and must indicate the end of the bytes available at pbP
   must point to the woth byte that is not available
 cbHeadP
  extra bytes to allocate at beginning
   will be initialized to 0
 pbHeadP
  may be 0
  if not 0 then must point to cbHeadP bytes, which will be copied to pbP
*/
/**/

/*1*/countT etherC::strEncodeF( tinS& tinP , byteT*& pbP , const strokeS* const psttP , const byteT* const pbeP , const countT cbHeadP , const byteT* pbHeadP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( ISvALIDjpOINTER( pbP ) ) ;
        if( POOP ) return 0 ;

        if( !ISrAWpOINTER( pbP ) )
        {
            __NZ( pbeP ) ;        // END MUST NOT BE SPECIFIED
        }
        else
        {
            if( !pbP )
            {
                __NZ( pbeP ) ;
            }
            else
            {
                __Z( pbeP ) ;
                __Z( pbP <= pbeP ) ;
            }
        }

        __( psttP && psttP->idCaste != sc_PREFIXlENGTH ) ;

        if( POOP ) return 0 ;
    }

    ZE( countT , cbUsed ) ;
    if( psttP )
    {
        //CONoUTrAW( T("encoding \"")+T(psttP)+T("\"\r\n") ) ; //TO FIND SLOWNESS

        //HEADER LAYOUT
        // 0 -f1 fingerprint
        // 02-f3 cbBytes FOLLOWING
        // FOR EACH STROKE
        //  FLAG BITS
        //  ENCODED idAdam
        //  ENCODED idCaste
        //  ENCODED cNote
        // IF CASTE IS sc_cADAMeXPORT THEN THIS IS FOLLOWED BY THE IMAGE, BYTE ALIGNED, WITH LEADING PAD BITS SET TO 0

        //WCBC: WORST CASE BIT CONSUMPTION IS INDICATED AT EACH CONSUMING CODE LINE
        // SUMMARY
        // (A) PREFIX: 04 BITS
        // (B) EACH STROKE EXCLUDING SOUL IMAGE: 15
        // (C) SOUL IMAGE: 7 + csImage * 06
        //
        // TOTAL WORST CASE
        //
        //  IF NO IMAGES: 04 + 15 * cStrokes

        countT cba = cbHeadP + 2 * sizeof( countT ) + sizeof( strokeS ) * ( CSpREFIX + psttP->idAdam ) ; //ALLOWS FOR WHOLE STRING TO BE A SOUL IMAGE

        if( ISrAWpOINTER( pbP ) && pbP )
        {
            __Z( pbP + cba + sizeof( countT ) <= pbeP ) ;
        }

        if( ISnULLjpOINTER( pbP ) )
        {
            newF( tinP , LF , pbP , cba + sizeof( countT ) ) ; ___( pbP ) ;
            __NZ( ISnULLjpOINTER( pbP ) ) ;
        }

        if( !POOP )
        {
            boolT bIsIdJot = !ISrAWpOINTER( pbP ) ;

            byteT pb_pageOut[ sizeof pageC ] ;
            pageC* pPageOut = !bIsIdJot
                ? 0
                : new( 0 , tinP , pb_pageOut , sizeof pb_pageOut ) pageC( jotC::readIF( tinP , (countT)pbP ) ) ;
            ;

            byteT* pbOut = !bIsIdJot
                ? pbP
                : (byteT*)(const byteT*)*pPageOut
            ;

            const byteT* const pbe = pbOut + cba ;

            memSetF( tinP , pbOut , cba ) ; //ALL OF THE WRITES THAT FOLLOW ARE DONE BY OR'ING INTO THIS RANGE
            *(countT*)pbe = FINGERnEG_STReNCODEf + 1 ; //TO CATCH OVERWRITE ; U:: BUG: THIS SHOULD BE A UNIQUE FINGER_ VALUE THAT IS NOT USED ANYWHERE ELSE

            if( pbHeadP ) memCopyF( tinP , pbOut , pbHeadP , cbHeadP ) ;

            pbOut += cbHeadP ;

            ZE( countT , offbo ) ; //BIT OFFSET OF NEXT WRITE
            ZE( countT , offboa ) ;
            /*WCBC(A):02*/ { count2S c2t = valueF( offbo , offboa , FINGERnEG_STReNCODEf , SB * sizeof( countT ) ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
            /*WCBC(A):02*/ { count2S c2t = valueF( offbo , offboa , 0xffffffff           , SB * sizeof( countT ) ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; } //OVERWRITTEN LATER

            const countT offse = CSpREFIX + psttP->idAdam ;
            for( countT offs = 0 ; offs < offse ; offs ++ )
            {
                const strokeS& sttc = psttP[ offs ] ;

                boolT bAdamTiny  = sttc.idAdam < 0x100 ;
                boolT bAlphabet1 = sttc.idCaste == sc_cALPHABET1 ;
                countT cBytesNote = !sttc.cNote
                    ? 0
                    : sttc.cNote < 0x100
                        ? 1
                        : sttc.cNote < 0x10000
                            ? 2
                            : sttc.cNote < 0x1000000
                                ? 3
                                : 4
                ;
                countT cBitsNote = cBytesNote * SB ;
                /*WCBC(B):1 */                   { count2S c2t = valueF( offbo , offboa , bAdamTiny            , 1                    ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
                /*WCBC(B):1 */                   { count2S c2t = valueF( offbo , offboa , bAlphabet1           , 1                    ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
                /*WCBC(B):3 */                   { count2S c2t = valueF( offbo , offboa , cBytesNote           , 3                    ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
                /*WCBC(B):02*/                   { count2S c2t = valueF( offbo , offboa , sttc.idAdam          , bAdamTiny ? 8 : 0x20 ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
                /*WCBC(B):c */ if( !bAlphabet1 ) { count2S c2t = valueF( offbo , offboa , sttc.idCaste & 0xfff , 0xc                  ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
                /*WCBC(B):02*/ if( cBitsNote   ) { count2S c2t = valueF( offbo , offboa , sttc.cNote           , cBitsNote            ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }
                //CONoUTrAW3( "bytes remaining: " , pbe - ( pbOut + offbo / SB ) , "\r\n" ) ; //U::

                if( sttc.idCaste == sc_cADAMeXPORT )
                {
                    countT csImage = sttc.idAdam ;
                    offs ++ ;
                    if( offs == offse ) break ;

                    /*WCBC(C):7*/ { count2S c2t = valueF( offbo , offboa , 0 , ( SB - offbo ) % SB ) ; count2RefF( pbOut , offbo ) |= c2t ; offbo = offboa ; }

                    countT cbImage = csImage * sizeof( strokeS ) ;
                    /*WCBC(C):8*cbImage*/ thirdC::c_memcpyIF( tinP , pbOut + offbo / SB , (byteT*)&psttP[ offs ] , cbImage ) ;

                    //ZE( strokeS* , psttd ) ;
                    //strDumpIF( tinP , psttd , (byteT*)&psttP[ offs ] , cbImage ) ;
                    //LOGrAW3( "encoded this soul image at bit offset " , offbo , "\r\n" ) ;
                    //strokeF( tinP , psttd ) ;
                    //LOGrAW( "\r\n" ) ;
                    //delF( tinP , psttd ) ;

                    offbo += cbImage * SB ;
                    offs  += csImage - 1 ;
                }
            }

            cbUsed = ( SB - 1 + offbo ) / SB ;
            ((countT*)pbOut)[ 1 ] = cbUsed - 2 * sizeof( countT ) ;
            if( !pbeP )
            {
                //tinP.pDropNoteNewest->cbRequested  = tinP.pDropNoteNewest->cbUsedReally = cbUsed ;
            }

            //COMMENT OUT IN PRODUCTION
            //if( tinP.pc Utility[ 0 ] )
            //{
            //    ZE( strokeS* , psttdStrokes ) ;
            //    strDumpIF( tinP , psttdStrokes , (byteT*)psttP , ( CSpREFIX + psttP->idAdam ) * sizeof( strokeS ) ) ; ___( psttdStrokes ) ;
            //    TN( td , "" ) ; td = T("\r\nfrom strokes: ")+T(psttdStrokes)+T("\r\n") ;
            //    LOGrAW( td ) ;
            //    delF( tinP , psttdStrokes ) ;
            //}
            
            //COMMENT OUT IN PRODUCTION
            //if( tinP.pc Utility[ 0 ] )
            //{
            //    ZE( strokeS* , psttdCodes ) ;
            //    strDumpIF( tinP , psttdCodes , pbOut , ((countT*)pbOut)[ 1 ] + 2 * sizeof( countT ) ) ; ___( psttdCodes ) ;
            //    TN( td , "" ) ; td = T("to codes    : ")+T(psttdCodes)+T("\r\n") ;
            //    LOGrAW( td ) ;
            //    delF( tinP , psttdCodes ) ;
            //}

            __( *(countT*)pbe != ( FINGERnEG_STReNCODEf + 1 ) &&  *(countT*)pbe != ( FINGERnEGoLD_strEncodeF + 1 ) ) ; //TO CATCH OVERWRITE

            if( bIsIdJot ) DELzOMBIE( pPageOut ) ;
        }
    }

    return cbUsed ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002191.etherc.strencodef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002193.etherc.getfromrecycler5_switchc BEGIN
#define DDNAME       "3func.36002193.etherc.getfromrecycler5_switchc"
#define DDNUMB      (countT)0x36002193
#define IDFILE      (countT)0xda9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/GETfROMrECYCLER5( switchC )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002193.etherc.getfromrecycler5_switchc END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002194.etherc.returntorecycler5_switchc BEGIN
#define DDNAME       "3func.36002194.etherc.returntorecycler5_switchc"
#define DDNUMB      (countT)0x36002194
#define IDFILE      (countT)0xdaa


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/RETURNtOrECYCLER5( switchC )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002194.etherc.returntorecycler5_switchc END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002195.etherc.operator_call BEGIN
#define DDNAME       "3func.36002195.etherc.operator_call"
#define DDNUMB      (countT)0x36002195
#define IDFILE      (countT)0xdab


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::operator ()( tinS& tinP , switchC*& pObjectP , const countT idLineP , const countT idiFileP , const byteT* const pbBitsP , const flagsT flagsP , countT& cLeverP , countT* const pcLeverLathRefP , const countT cbDataP )/*1*/
{
    (*this)( tinP , pObjectP , idLineP , idiFileP , pbBitsP , ifcIDtYPElEVER_countT , flagsP , (countT)&cLeverP , (countT)pcLeverLathRefP , cbDataP ) ;_WQ
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002195.etherc.operator_call END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002196.etherc.operator_call BEGIN
#define DDNAME       "3func.36002196.etherc.operator_call"
#define DDNUMB      (countT)0x36002196
#define IDFILE      (countT)0xdac


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::operator ()( tinS& tinP , switchC*& pObjectP , const countT idLineP , const countT idiFileP , const byteT* const pbBitsP , const flagsT flagsP , strokeS*& psttLeverP , countT* const pcLeverLathRefP , const countT cbDataP )/*1*/
{
    (*this)( tinP , pObjectP , idLineP , idiFileP , pbBitsP , ifcIDtYPElEVER_PTR_strokeS , flagsP , (countT)&psttLeverP , (countT)pcLeverLathRefP , cbDataP ) ;_WQ
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002196.etherc.operator_call END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002197.etherc.getfromrecycler6_switchstackc BEGIN
#define DDNAME       "3func.36002197.etherc.getfromrecycler6_switchstackc"
#define DDNUMB      (countT)0x36002197
#define IDFILE      (countT)0xdad


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/GETfROMrECYCLER6( switchStackC )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002197.etherc.getfromrecycler6_switchstackc END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002198.etherc.returntorecycler6_switchstackc BEGIN
#define DDNAME       "3func.36002198.etherc.returntorecycler6_switchstackc"
#define DDNUMB      (countT)0x36002198
#define IDFILE      (countT)0xdae


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/RETURNtOrECYCLER6( switchStackC )/*1*/


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002198.etherc.returntorecycler6_switchstackc END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002199.etherc.operator_call BEGIN
#define DDNAME       "3func.36002199.etherc.operator_call"
#define DDNUMB      (countT)0x36002199
#define IDFILE      (countT)0xdaf


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::operator ()( tinS& tinP , switchStackC*& pObjectP , const countT idLineP , const countT idiFileP , const byteT* const pbBitsP , const flagsT flagsSwitchP , countT& cLeverP , const flagsT flagsStackP , const countT idTypeP , countT* const pcLeverLathRefP )/*1*/
{
    (*this)( tinP , pObjectP , idLineP , idiFileP , pbBitsP , ifcIDtYPElEVER_countT , flagsSwitchP , (countT)&cLeverP , flagsStackP , idTypeP , (countT)pcLeverLathRefP ) ;_WQ
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.36002199.etherc.operator_call END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600219a.etherc.operator_call BEGIN
#define DDNAME       "3func.3600219a.etherc.operator_call"
#define DDNUMB      (countT)0x3600219a
#define IDFILE      (countT)0xdb0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::operator ()( tinS& tinP , switchStackC*& pObjectP , const countT idLineP , const countT idiFileP , const byteT* const pbBitsP , const flagsT flagsSwitchP , strokeS*& psttLeverP , const flagsT flagsStackP , const countT idTypeP , countT* const pcLeverLathRefP )/*1*/
{
    (*this)( tinP , pObjectP , idLineP , idiFileP , pbBitsP , ifcIDtYPElEVER_PTR_strokeS , flagsSwitchP , (countT)&psttLeverP , flagsStackP , idTypeP , (countT)pcLeverLathRefP ) ;_WQ
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600219a.etherc.operator_call END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600219b.etherc.strconverttoothercasef BEGIN
#define DDNAME       "3func.3600219b.etherc.strconverttoothercasef"
#define DDNUMB      (countT)0x3600219b
#define IDFILE      (countT)0xdb1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strConvertToOtherCaseF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030055.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f810104.1.1.0.html\"\>f810104:  WAKEsHOW( "example.simplest.func.1030055.etherC.strConvertToOtherCaseF" )\</A\>
converts alphabetic strokes to the other case (upper to lower, lower to upper)
other idCaste = 0 strokes are copied unmodified
strokes with nonze idCaste are copied unmodified
arguments
 psttP
  can be any string of strokeS objects
*/
/**/

//ASSUME: IF THE strokeS STRING REPRESENTS MIXED 16,8 BYTE CHARS, THEN THIS FUNCTION WILL CHANGE THE MEANING AND EVEN THE NUMBER OF CHARACTERS
/*1*/voidT etherC::strConvertToOtherCaseF( tinS& tinP , strokeS* psttP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
    }

    _IO_
    countT cnt = psttP->idAdam ;
    for( countT ii = 1 ; !POOP && ii <= cnt ; ii ++ )
    {
         strConvertToOtherCaseF( tinP , psttP[ CSpREFIX - 1 + ii ] , psttP[ CSpREFIX - 1 + ii ] ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600219b.etherc.strconverttoothercasef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600219c.etherc.strconverttoothercasef BEGIN
#define DDNAME       "3func.3600219c.etherc.strconverttoothercasef"
#define DDNUMB      (countT)0x3600219c
#define IDFILE      (countT)0xdb2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
arguments
 sttOutP
  can be anything
 sttInP
  can be anything
*/
/**/

/*1*/voidT etherC::strConvertToOtherCaseF( tinS& tinP , strokeS& sttOutP , const strokeS& sttInP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    //U::all func.103*.strConvert* MUST BE EDITED TO HANDLE sc_cALPHABET1 idTool VALUES FOR 'A'-'Z' 'a'-'z'


    sttOutP = sttInP ;
    countT upper = (countT)sttInP & ~ 0x20 ;
    countT other = (countT)sttInP ^ 0x20 ;
    if( ( sttInP.idCaste == sc_cALPHABET1 || sttInP.idCaste == sc_cFROMaSCII || sttInP.idCaste == scOld_CONTROLkEY ) && upper >= 'A' && upper <= 'Z' ) sttOutP = other ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600219c.etherc.strconverttoothercasef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600219d.etherc.strconverttoothercasef BEGIN
#define DDNAME       "3func.3600219d.etherc.strconverttoothercasef"
#define DDNUMB      (countT)0x3600219d
#define IDFILE      (countT)0xdb3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strConvertToOtherCaseF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030106.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.4430104.1.1.0.html\"\>4430104:  WAKEsHOW( "example.simplest.func.1030106.etherC.strConvertToOtherCaseF" )\</A\>
converts alphabetic strokes to other case
other idCaste = 0 strokes are copied unmodified
strokes with nonze idCaste are copied unmodified
arguments
 psttFromP
  must not be null
  can be any string of strokeS objects
 psttP
  must be null
*/
/**/

//ASSUME: IF THE strokeS STRING REPRESENTS MIXED 16,8 BYTE CHARS, THEN THIS FUNCTION WILL CHANGE THE MEANING AND EVEN THE NUMBER OF CHARACTERS
/*1*/voidT etherC::strConvertToOtherCaseF( tinS& tinP , strokeS*& psttP , const strokeS* const psttFromP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( psttFromP ) ;
        if( POOP ) return ;
    }

    _IO_

    strMakeF( tinP , LF , psttP , psttFromP ) ; //CALLER MUST TAG ___( psttP ) ;
    strConvertToOtherCaseF( tinP , psttP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600219d.etherc.strconverttoothercasef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600219e.etherc.strcomparef BEGIN
#define DDNAME       "3func.3600219e.etherc.strcomparef"
#define DDNUMB      (countT)0x3600219e
#define IDFILE      (countT)0xdb4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strCompareF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030054.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.e810104.1.1.0.html\"\>e810104:  WAKEsHOW( "example.simplest.func.1030054.etherC.strCompareF" )\</A\>
evaluates to a positive number iff ppstt1P is "greater than" ppstt2P
 evaluates to the difference within the first pair of distinct strokes
 if one of the strings of strings is exhausted without finding a difference, evaluates to the difference in length of the two strings of strings
arguments
 pstt1P
 pstt2P
 ccMaxP
*/
/**/

/*1*/sCountT etherC::strCompareF( tinS& tinP , const strokeS** const ppstt1P , const strokeS** const ppstt2P , const countT cpsMaxP , const countT csMaxP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( ppstt1P ) ;_WQ
        __Z( ppstt2P ) ;_WQ
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( sCountT , sgn ) ;_WQ
    {
        for( countT off = 0 ; !sgn ; off ++ )
        {
            if( ( !ppstt1P[ off ] && !ppstt2P[ off ] ) || ( cpsMaxP && cpsMaxP == off ) ) break ;
            else if( !ppstt1P[ off ] ) sgn = - 1 ;
            else if( !ppstt2P[ off ] ) sgn =   1 ;
            else sgn = strCompareF( tinP , ppstt1P[ off ] , ppstt2P[ off ] , csMaxP ) ;
        }
    }

    return sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.3600219e.etherc.strcomparef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021a0.etherc.strdigitstomeasuref BEGIN
#define DDNAME       "3func.360021a0.etherc.strdigitstomeasuref"
#define DDNUMB      (countT)0x360021a0
#define IDFILE      (countT)0xdb5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strDigitsToSCountF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030057.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.1910104.1.1.0.html\"\>1910104:  WAKEsHOW( "example.simplest.func.1030057.etherC.strDigitsToSCountF" )\</A\>
the number can contain leading blanks
the negative sign must be the first nonblank character
the plus sign is legal
an explicit radix overrides defaultRadixP
 a radix can be specified by appending an underscore "_" followed by a single radix 64_9 digit [0..9 a..z A..Z ? @]
  "0"       is the value 0
  "10"      is the radix 16_9 value 10
  "89abcde" is the radix 16_9 value 89abcde
  "-efef_f" is the radix 16_9 (hex) value -efef
  "-yzyz_z" is the radix 36_9 value -yzyz
  "-EFEF_F" is the radix 42_9 value -EFEF
  "-YZ?@_@" is the radix 64_9 value -YZ?@
the radix override value is always expressed in radix 64_9 (the digits are 0..9 a..z A..Z ? @)
conversion terminates with the first nonnumeric stroke
 if there is no radix override, terminates with the first stroke that is not a value radix 16 digit
 if there is a radix override but it is invalid (not a radix 64_9 digit) then impotence occurs
 if there is a valid radix override, terminates with the radix override
overflow is not detected
after an overflow, the resulting sign will still be correct
arguments
 psttP
 defaultRadixP
  can be 0, which implies radix 16_9
  if nonze, must be at least 2 and not more than 64_9
 bForeignP
  can be 0 or 1
  0: IdeaFarm " "(tm) City digit ordering (least significant digit occurs first (i.e. at left)
  1: Foreign digit ordering (most significant digit occurs first (i.e. at left)
*/
/**/

//"candy": "candidate"
#define BcANDY ( psttc->idCaste == sc_cFROMaSCII || psttc->idCaste == sc_cALPHABET1 )
#define BcANDYo(offP) ( psttc[ offP ].idCaste == sc_cFROMaSCII || psttc[ offP ].idCaste == sc_cALPHABET1 )

/*1*/measureT etherC::strDigitsToMeasureF( tinS& tinP , const strokeS* const psttP , const countT defaultRadixP , const boolT bForeignP )/*1*/
{
    SCOOP
    countT radix = defaultRadixP ;
    if( !radix ) radix = 0x10 ;

    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttP ) ;
        __( radix < 2 ) ;
        __( radix > 0x40 ) ;
        if( POOP ) return 0 ;
        __( psttP->idCaste != sc_PREFIXlENGTH ) ;
        if( POOP ) return 0 ;
    }

    //U: OPTIMIZE TO ELIMINATE USE OF strReverseF BY REWRITING THIS FUNCTION
    // NOTE: THIS FUNCTION WAS CODED ASSUMING FOREIGN DIGIT ORDERING.  AFTER THE CODE WAS COMPLETED, IT WAS DECIDED TO ORDER DIGITS IN INCREASING SIGNIFICANCE WITHIN IFC

    _IO_

    ZE( measureT , mValue ) ;
    countT idRadix = strIdF( tinP , T(".") , psttP ) ;
    boolT bNeg = strIdF( tinP , T("-") , psttP ) ;
    if( !idRadix ) mValue = strDigitsToSCountF( tinP , psttP , defaultRadixP , bForeignP ) ;
    else
    {
        ZE( strokeS* , psttd ) ;
        strMakeF( tinP , LF , psttd , psttP ) ; ___( psttd ) ;
        if( !bForeignP )
        {
            idRadix = psttP->idAdam + 1 - idRadix ;
            strReverseF( tinP , psttd ) ; ___( psttd ) ;
        }

        if( psttd->idAdam >= 2 && psttd[ CSpREFIX - 2 + psttd->idAdam ].idAdam == '_' )
        {
            strokeS& stt = psttd[ CSpREFIX - 1 + psttd->idAdam ] ;

            {
                //U: OPTIMIZE BY MAKING THESE STATIC
                const strokeS stt_1( '1' ) ;
                const strokeS stt_9( '9' ) ;
                const strokeS stt_a( 'a' ) ;
                const strokeS stt_z( 'z' ) ;
                const strokeS stt_A( 'A' ) ;
                const strokeS stt_Z( 'Z' ) ;
                const strokeS stt_qu( '?' ) ;
                const strokeS stt_at( '@' ) ;
    
                if( stt.idCaste == sc_cALPHABET1 && ( stt.idAdam & 0xf0000000 == sscDIGIT ) ) radix = stt.idAdam & 0xffff ;
                else if( stt.idAdam >=  stt_1.idAdam && stt.idAdam <=  stt_9.idAdam ) radix = (countT)stt - '0' +  1 ;
                else if( stt.idAdam >=  stt_a.idAdam && stt.idAdam <=  stt_z.idAdam ) radix = (countT)stt - 'a' + 11 ;
                else if( stt.idAdam >=  stt_A.idAdam && stt.idAdam <=  stt_Z.idAdam ) radix = (countT)stt - 'A' + 37 ;
                else if( stt.idAdam >= stt_qu.idAdam && stt.idAdam <= stt_at.idAdam ) radix = (countT)stt - '?' + 63 ;
            }

            strokeS* psttDoomed = psttd ; psttd = 0 ;
            if( psttDoomed->idAdam > 2 )
            {
                countT idf = 1 ;
                countT idl = psttDoomed->idAdam - 2 ;
                strSubstringF( tinP , psttd , idf , idl , psttDoomed ) ; ___( psttd ) ;
            }
            delF( tinP , psttDoomed ) ;
        }

        ZE( boolT , bExpNeg ) ;
        ZE( countT , exp ) ;
        if( psttd )
        {
            if( psttP->idAdam < 2 || psttP[ CSpREFIX - 2 + psttP->idAdam ].idAdam != '_' )
            {
                ZE( strokeS* , psttw ) ;
                if( idRadix > 1 )
                {
                    countT idf = 1 ;
                    countT idl = idRadix - 1 ;
                    strSubstringF( tinP , psttw , idf , idl , psttd ) ; ___( psttw ) ;
                    mValue = strDigitsToSCountF( tinP , psttw , defaultRadixP , 1 ) ;
                    delF( tinP , psttw ) ;
                }
    
                if( idRadix < psttP->idAdam )
                {
                    countT idf = idRadix + 1 ;
                    ZE( countT , idl ) ;
                    strSubstringF( tinP , psttw , idf , idl , psttd ) ; ___( psttw ) ;
    
                    ZE( boolT , bExp ) ;
                    measureT unit = 1.0 ;
                    countT expUnit = TUCK ;
                    strokeS psttWo[ CSpREFIX + 1 ] ;
                    SETpREFIXA( psttWo )
                    psttWo->idAdam = 1 ;
                    for( countT ids = 1 ; ids <= psttw->idAdam ; ids ++ )
                    {
                        if( !bExp )
                        {
                            if( psttw[ CSpREFIX - 1 + ids ].idAdam == '^' )
                            {
                                bExp = 1 ;

                                ids ++ ;
                                     if( psttw[ CSpREFIX - 1 + ids ].idAdam == '-' ) bExpNeg = 1 ;
                                else if( psttw[ CSpREFIX - 1 + ids ].idAdam == '+' )             ;
                                else { __( psttw[ CSpREFIX - 1 + ids ].idAdam ) ; }

                                continue ;
                            }

                            unit *= 1.0 / (measureT)radix ;
                            psttWo[ CSpREFIX ] = psttw[ CSpREFIX - 1 + ids ] ;
                            measureT delta = unit * (measureT)strDigitsToSCountF( tinP , psttWo , defaultRadixP , 1 ) ;
                            if( bNeg ) mValue -= delta ;
                            else       mValue += delta ;
                        }
                        else
                        {
                            psttWo[ CSpREFIX ] = psttw[ CSpREFIX - 1 + ids ] ;
                            countT delta = expUnit * strDigitsToSCountF( tinP , psttWo , defaultRadixP , 1 ) ;
                            if( bExpNeg ) exp -= delta ;
                            else          exp += delta ;
                            expUnit /= radix ;
                        }
                    }
    
                    delF( tinP , psttw ) ;
                }
            }
        }

        delF( tinP , psttd ) ;

        if( exp ) mValue *= thirdC::mathExpIF( tinP , radix , bExpNeg ? - (sCountT)exp : (sCountT)exp ) ;
    }
    return mValue ;
}

#undef BcANDY


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021a0.etherc.strdigitstomeasuref END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021a4.etherc.sockstkidletimeoutersf BEGIN
#define DDNAME       "3func.360021a4.etherc.sockstkidletimeoutersf"
#define DDNUMB      (countT)0x360021a4
#define IDFILE      (countT)0xdb6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$sockStkIdleTimeoutersF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030131.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/stackC& etherC::sockStkIdleTimeoutersF( tinS& tinP )/*1*/
{
    if( tinP.fingerprint ) ;
    if( !tinP.pAdamGlobal1->_etherC_.pStkIdleTimeouters ) ;//TELLsYSc1( ifcIDtYPEtELLsYS_ERRORpsTiDLEtIMEOUTERSiS0 )
    return *tinP.pAdamGlobal1->_etherC_.pStkIdleTimeouters ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021a4.etherc.sockstkidletimeoutersf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021a5.etherc.diskmovefileordiruniquef BEGIN
#define DDNAME       "3func.360021a5.etherc.diskmovefileordiruniquef"
#define DDNUMB      (countT)0x360021a5
#define IDFILE      (countT)0xdb7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$diskMoveFileOrDirF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030013.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.6210104.1.1.0.html\"\>6210104:  WAKEsHOW( "example.simplest.func.1030013.etherC.diskMoveFileOrDirF" )\</A\>
arguments
 psttNewP
  normally is 0
  if not 0 then must point to the name of a directory and must have enough extra strokes to accomodate the file name plus a string returned by strUniqueF plus wo additional stroke
  on return, will contain the new file name
   example: T("///ideafarm/ephemeral/tmpnew/new")
  must be on the same device as psttOldP
   here is an example that would -not- work (on os/2 and on windows) because two devices (c : and d :) are involved
    psttOldP: T("///c" "/old")
    psttNewP: T("///d/new")
    this example -would- work, however, on Linux
 psttOldP
  file name
   example: T("///ideafarm/ephemeral/tmpold/old")
 cTriesP
  if 0 then will retry forever
*/
/**//*1*/voidT etherC::diskMoveFileOrDirUniqueF( tinS& tinP , strokeS*& psttNewP , const strokeS* const psttOldP , const countT cTriesP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttOldP ) ;
        if( POOP ) return ;
    }

    _IO_

    {
        boolT bDir = psttOldP[ CSpREFIX - 1 + psttOldP->idAdam ].idAdam == '/' ;

        ZE( strokeS* , psttu ) ;
        strUniqueF( tinP , psttu ) ; ___( psttu ) ;
    
        ZE( strokeS* , psttDir ) ;
        ZE( strokeS* , psttShort ) ;
        strBisectF( tinP , psttDir , psttShort , psttOldP , T("/") , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttDir ) ; ___( psttShort ) ;
        if( bDir && psttShort->idAdam ) psttShort->idAdam -- ; // TRUNCATE AWAY THE TRAILING SLASH

        TN( tNewShort , "" ) ;
        tNewShort = T(psttShort)+T(".!.")+T(psttu) ;                //20180501@1309: CHANGED "." TO ".!." WITHOUT ANALYSIS TO FACILITATE PARSING; SHOULD NOT BREAK EXISTING CODE BECAUSE THE CHANGE PRECEDES THE UNIQUIFIER WHICH I THINK IS NEVER PARSED

        if( !psttNewP ) { strMakeF( tinP , LF , psttNewP , T(psttDir) , tNewShort.csF( tinP ) ) ; ___( psttNewP ) ; }
    
        strFuseF( tinP , psttNewP , tNewShort ) ;

        delF( tinP , psttu ) ;
        delF( tinP , psttDir ) ;
        delF( tinP , psttShort ) ;
    }

    diskMoveFileOrDirF( tinP , psttNewP , psttOldP , cTriesP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021a5.etherc.diskmovefileordiruniquef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021a6.etherc.strbisectf BEGIN
#define DDNAME       "3func.360021a6.etherc.strbisectf"
#define DDNUMB      (countT)0x360021a6
#define IDFILE      (countT)0xdb8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
if i do not find the specified delimiter, i silently do nothing
arguments
 psttPart1P
  must be 0
  receives the woth part
 psttPart2P
  must be 0
  receives the ooth part
 psttDelimiterP
  marks the bisection point
 idP
  must not be 0
  can be negative
   1: woth occurance
   - 1: lath occurance
 flagsP
  modifies behavior
*/
/**//*1*/countT etherC::strBisectF( tinS& tinP , strokeS*& psttPart1P , strokeS*& psttPart2P , const strokeS* const psttBigP , const strokeS* const psttDelimiterP , const countT idP , const flagsT flagsP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( psttPart1P ) ;
        __NZ( psttPart2P ) ;
        __Z( idP ) ;
        FV( flSTRbISECT , flagsP ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    TN( tDelimiter , "/" ) ;
    if( psttDelimiterP ) tDelimiter = T(psttDelimiterP) ;

    countT idfBisect = 1 ;
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    countT idHere = F(flagsP) & flSTRbISECT_ANY
        ? strIdAnyF( tinP , 0 , flSTRmATCH_null , idfBisect , sttq , tDelimiter , psttBigP , 0 , idP )
        : strIdF(    tinP , 0 , flSTRmATCH_null , idfBisect , sttq , tDelimiter , psttBigP , 0 , idP )

    ;

    if( idHere )                // idHere IS THE LOCATION OF THE BISECTOR; idfBisect IS THE LOCATION OF THE TRAILING SUBSTRING, IF ANY
    {
        //PART 1
        if( idHere == 1 )
        {
            if( F(flagsP) & flSTRbISECT_APPENDdELIMITER  ) { strMakeF( tinP , LF , psttPart1P , tDelimiter ) ; ___( psttPart1P ) ; }
        }
        else
        {
            countT idf = 1 ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idl = !( F(flagsP) & flSTRbISECT_APPENDdELIMITER )
                ? idHere - 1
                : !idfBisect 
                    ? 0
                    : idfBisect - 1
            ;
            strSubstringF( tinP , psttPart1P , idf , idl , psttBigP , csttExtraP ) ; //CALLER MUST TAG ___( psttPart1P ) ;
        }

        //PART 2
        if( !idfBisect )
        {
            if( F(flagsP) & flSTRbISECT_PREPENDdELIMITER )
            {
                strMakeF( tinP , LF , psttPart2P , tDelimiter ) ; //CALLER MUST TAG ___( psttPart2P ) ;
            }
        }
        else
        {
            countT idf = F(flagsP) & flSTRbISECT_PREPENDdELIMITER ? idHere : idfBisect ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            strSubstringF( tinP , psttPart2P , idf , countTC() , psttBigP , csttExtraP ) ; // CALLER MUST TAG ___( psttPart2P ) ;
        }
    }
    return idHere ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021a6.etherc.strbisectf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021a8.etherc.chokeattackerf BEGIN
#define DDNAME       "3func.360021a8.etherc.chokeattackerf"
#define DDNUMB      (countT)0x360021a8
#define IDFILE      (countT)0xdb9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


/*
*/

/*1*/voidT etherC::chokeAttackerF( tinS& tinP , handleC& handleP , const countT cbRequestReadP , const countT cbRequestWriteP )/*1*/
{
    switch( handleP.idTypeF() )
    {
        case ifcIDtYPEhANDLE_SOCKET :
        {
            ZE( boolT , bChoke ) ;
            switch( processGlobal1I.idAdamRoot )
            {
                case ifcIDaDAM_TOOLuPLOADER :
                case ifcIDaDAM_ROOTfTPsERVER :
                {
                    if
                    (
                        tinP.odoSockCbRead  + cbRequestReadP  > TOCK ||
                        tinP.odoSockCbWrite + cbRequestWriteP > 2 * TICK //1 SNAP OR 1 DOWNLOAD CONTAINING DEBUG INFO
                    )
                    bChoke = 1 ;

                    break ;
                }
                case ifcIDaDAM_KERNEL3PANICdOOR :
                {
                    if
                    (
                        tinP.odoSockCbRead  + cbRequestReadP  > 2 * TICK /*1 UPLOAD OF SNAP*/ ||
                        tinP.odoSockCbWrite + cbRequestWriteP > TOCK
                    )
                    bChoke = 1 ;

                    break ;
                }
                default :
                {
                    if
                    (
                        tinP.odoSockCbRead  + cbRequestReadP  > TOCK ||
                        tinP.odoSockCbWrite + cbRequestWriteP > TOCK
                    )
                    bChoke = 1 ;
                
                    break ;
                }
            }

            //U::FALSE POSITIVES, SO COMMENTED OUT UNTIL DEBUGGED
            //if( bChoke )
            //{
            //    nicNameC nnPeer ;
            //    third.s_peerNameF( tinP , countTC() , nnPeer , handleP ) ;
            //    handleP.closeIfF() ;
            //
            //    TN( tcr , "\r\n" ) ;
            //    TN( tBody , "" ) ; tBody = TF2(processGlobal1S::_processGlobal1I_IF().idAdamRoot,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcr+T("2\r\nchokeAttackerF\r\n") ;
            //
            //    ZE( strokeS* , psttnu ) ;
            //    boxPutUniqueF( tinP , psttnu , T("///ideafarm/ephemeral/domains/com/ideafarm/ipdos/attackers/")+T(nnPeer)+T("/")+TF2(processGlobal1S::_processGlobal1I_IF().idAdamRoot,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("/attack") , tBody , tBody.csF( tinP ) ) ; ___( psttnu ) ;
            //    delF( tinP , psttnu ) ;
            //}

            break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021a8.etherc.chokeattackerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021aa.etherc.osthreadadamf BEGIN
#define DDNAME       "3func.360021aa.etherc.osthreadadamf"
#define DDNUMB      (countT)0x360021aa
#define IDFILE      (countT)0xdba


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//DESIGN DEFECT: ADAMS LAUNCHED BY ME WILL NOT SEE CTRL-C INTO THE PROCESS OR A CALL TO thirdFireImpersonateMonitorIF BY ANOTHER ADAM IN THE PROCESS
// TO FIX THIS, CODE WOULD NEED TO BE ADDED TO MAINTAIN A LIST OF thPrime INSTANCES (WO FOR EACH KID ADAM) AND TO CALL thirdFireImpersonateMonitorIF FOR EACH
// I WILL NOT DO THIS BECAUSE THIS DOES NOT AFFECT ADAMS RUNNING IN AN ADAM CHAIN LAUNCHED BY THE SERVICE AND MONITORED BY THE KERNEL MONITOR
// osThreadAdamF IS INTENDED TO BE USED AS AN OPTIMIZATION TO REDUCE THE MEMORY AND THREAD FOOTPRINT OF ADAMS RUNNING IN PRODUCTION
// WHEN AN ADAM IS NOT FULLY TESTED, IT SHOULD BE LAUNCHED AS A SEPARATE PROCESS USING ifcHireF RATHER THAN LAUNCHED BY ME

/*1*/voidT etherC::osThreadAdamF( tinS& tinP , countT idAdamP , const strokeS* const psttArgsP , const flagsT flagsP , signC* const pSgnDoneP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( idAdamP ) ;
        FV(flOStHREADaDAMf,flagsP)
        if( POOP ) return ;
    }

    _IO_
    if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DOnOThIREaDAMS ) ) // SUPPRESSED FOR IN PROCESS KID ADAMS IN ORDER TO MAKE IT EASY TO SWITCH A SYSTEM'S RECONFIGURATON FROM SINGLEPROCESS TO MULTIPROCESS
    {
        TN( tPostscript , "" ) ; //NORMALLY NULL STRING; CONVENIENT FOR DEBUGGING
        ZE( osTextT* , postArgs ) ;
        if( psttArgsP || tPostscript.csF( tinP ) ) { strMakeF( tinP , LF , postArgs , T(psttArgsP)+tPostscript ) ; ___( postArgs ) ; } // tmAdamMainF MUST DELETE THIS
    
        parm_tmAdamMainF_S* pam = new( 0 , tinP , LF ) parm_tmAdamMainF_S( tinP , idAdamP ) ; ___( pam ) ;
        __Z( pam ) ;    
        osThreadF( tinP , countTC() , tmAdamMainF , pSgnDoneP , flTHREADlAUNCH_null , 0 , idAdamP , (countT)postArgs , (countT)pam ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021aa.etherc.osthreadadamf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ae.etherc.ifcgetnextserialnumberf BEGIN
#define DDNAME       "3func.360021ae.etherc.ifcgetnextserialnumberf"
#define DDNUMB      (countT)0x360021ae
#define IDFILE      (countT)0xdbb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
parameters
 tinP
 postP
  must not be 0
  must be terminated by 0
  is the name of the serial number space for the ip domain IDEAFARM.COM
 adam ifcIDaDAM_DOMAINsERIALnUMBERdISPENSER must be alive in this home
*/
/**/

/*1*/countT etherC::ifcGetNextSerialNumberF( tinS& tinP , const osTextT* const postP )/*1*/
{
    //FOR TESTING STANDALONE
    //static countT idLath ;
    //return 1 + incv02AM( idLath ) ;

    const countT idPortDispenser = homeS::homeIF().idPortSerialNumberDispenser ;
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( postP ) ;
        __Z( idPortDispenser ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    CONoUTrAW( T("ifcGetNextSerialNumberF [postP]: \"")+T(postP)+T("\"\r\n") ) ; //U::

    socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
    sock.connectF( tinP , idPortDispenser ) ;

    TN( tSerialName , postP ) ;

    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    sOut << (countT)FINGERnEG_SERIALnUMBERdISPENSERcMD ;
    sOut << (countT)1 ;
    sOut << (countT)ifcIDcMDsERIALnUMBERdISPENSER_DISPENSEnAMEsTROKEsTRING ;
    sOut << (strokeS*)tSerialName ;

    sock.writeF( tinP , sOut ) ;

    soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    sock.readF( tinP , sIn ) ;

    ZE( countT , finger ) ;
    sIn >> finger ;
    __( finger - FINGERnEG_SERIALnUMBERdISPENSERrEPLY ) ;

    ZE( countT , idFormat ) ;
    sIn >> idFormat ;
    __( idFormat - 1 ) ;

    ZE( countT , idDispensed ) ;
    sIn >> idDispensed ;
    __Z( idDispensed ) ;

    return idDispensed ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ae.etherc.ifcgetnextserialnumberf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021b5.etherc.ifcgetnextserialnumberf BEGIN
#define DDNAME       "3func.360021b5.etherc.ifcgetnextserialnumberf"
#define DDNUMB      (countT)0x360021b5
#define IDFILE      (countT)0xdbc


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
parameters
 tinP
 pczP
  must not be 0
  must be terminated by 0
  is the name of the serial number space for the ip domain IDEAFARM.COM
*/
/**/

/*1*/countT etherC::ifcGetNextSerialNumberF( tinS& tinP , const countT* const pczP )/*1*/
{
    const countT idPortDispenser = homeS::homeIF().idPortSerialNumberDispenser ;
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( pczP ) ;
        __Z( idPortDispenser ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    CONoUTrAW( T("ifcGetNextSerialNumberF [pczP]: \"")+T(pczP)+T("\"\r\n") ) ; //U::

    socketC sock( tinP , *this , TAG( TAGiDnULL ) ) ;
    sock.connectF( tinP , idPortDispenser ) ;

    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    sOut << (countT)FINGERnEG_SERIALnUMBERdISPENSERcMD ;
    sOut << (countT)1 ;
    sOut << (countT)ifcIDcMDsERIALnUMBERdISPENSER_DISPENSEnAMEcOUNTsTRING ;
    sOut << pczP ;

    sock.writeF( tinP , sOut ) ;

    soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    sock.readF( tinP , sIn ) ;

    ZE( countT , finger ) ;
    sIn >> finger ;
    __( finger - FINGERnEG_SERIALnUMBERdISPENSERrEPLY ) ;

    ZE( countT , idFormat ) ;
    sIn >> idFormat ;
    __( idFormat - 1 ) ;

    ZE( countT , idDispensed ) ;
    sIn >> idDispensed ;
    __Z( idDispensed ) ;

    return idDispensed ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021b5.etherc.ifcgetnextserialnumberf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021b6.etherc.ostimenowuniquef BEGIN
#define DDNAME       "3func.360021b6.etherc.ostimenowuniquef"
#define DDNUMB      (countT)0x360021b6
#define IDFILE      (countT)0xdbd


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::osTimeNowUniqueF( tinS& tinP , countT& timeU1P , sCountT& timeU2P )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( timeU1P ) ;
        __( timeU2P ) ;
        if( POOP ) return ;
    }
    _IO_

    homeS& home = homeS::homeIF() ;

    home.grabTimeUnique.grabF( tinP , TAG( TAGiDnULL ) ) ;

    for(;;)
    {
        osTimeNowF( tinP , timeU1P , timeU2P ) ;
        timeU2P |= BM_HIGH ; //ALLOWS APPLICATION CODE SUCH AS DEF OF depositS TO ENFORCE MY USE TO OBTAIN TIME VALUES

        if( home.timeUniqueLath1 != timeU1P )
        {
            home.timeUniqueLath1 = timeU1P ;
            home.timeUniqueLath2 = timeU2P ;
            break ;
        }

        timeU2P = timeU1P = 0 ;
    }

    home.grabTimeUnique.ungrabF( tinP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021b6.etherc.ostimenowuniquef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021b7.etherc.strinsertf BEGIN
#define DDNAME       "3func.360021b7.etherc.strinsertf"
#define DDNUMB      (countT)0x360021b7
#define IDFILE      (countT)0xdbe


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
arguments
 tinP
 psttP
  must not be ze
  will be replaced
 psttMarkP
  must not be ze
 psttWhatP
  must not be ze
 flagsP
 csttExtraP
*/

/**/

/*1*/voidT etherC::strInsertF( tinS& tinP , strokeS*& psttP , const strokeS* const psttMarkP , const strokeS* const psttWhatP , const flagsT flagsP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttP ) ;
        __Z( psttMarkP ) ;
        __Z( psttWhatP ) ;
        FV( flSTRiNSERT , flagsP ) ;
        if( POOP ) return ;
        __( psttP->idAdam < psttMarkP->idAdam ) ;
        __( !psttMarkP->idAdam ) ;
        __( !psttWhatP->idAdam ) ;
        if( POOP ) return ;
    }

    _IO_

    strokeS* pstti = psttP ; psttP = 0 ;

    countT cstto = pstti->idAdam + psttWhatP->idAdam + csttExtraP ;
    strMakeF( tinP , LF , psttP , 0 , cstto ) ; //CALLER MUST TAG: ___( psttP ) ;

    countT idf = 1 ;
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , psttw ) ;

    strSubstringF( tinP , psttw , idf , sttq , psttMarkP , pstti ) ; ___( psttw ) ;
    strFuseF( tinP , psttP , psttw ) ;
    delF( tinP , psttw ) ;

    if( F(flagsP) & flSTRiNSERT_BEFORE ) strFuseF( tinP , psttP , psttWhatP ) ;

    strFuseF( tinP , psttP , psttMarkP ) ;

    if( !( F(flagsP) & flSTRiNSERT_BEFORE ) ) strFuseF( tinP , psttP , psttWhatP ) ;

    ZE( countT , idl ) ;
    strSubstringF( tinP , psttw , idf , idl , pstti ) ; ___( psttw ) ;
    strFuseF( tinP , psttP , psttw ) ;
    delF( tinP , psttw ) ;
    delF( tinP , pstti ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021b7.etherc.strinsertf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021b8.etherc.strmakef BEGIN
#define DDNAME       "3func.360021b8.etherc.strmakef"
#define DDNUMB      (countT)0x360021b8
#define IDFILE      (countT)0xdbf


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strMakeF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030064.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.f910104.1.1.0.html\"\>f910104:  WAKEsHOW( "example.simplest.func.1030064.etherC.strMakeF" )\</A\>
arguments
 postP
 psttP
*/
/**/

/*1*/countT etherC::strMakeF( tinS& tinP , const countT idLineP , const countT idiFileP , pbRefC*& prP , const strokeS* const psttP , const countT costExtraP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( prP ) ;_WQ
        __Z( psttP ) ;_WQ
        FV(flSTRmAKE,flagsP)
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( osTextT* , pzost ) ;_WQ
    countT cLength = strMakeF( tinP , idLineP , idiFileP , pzost , psttP , costExtraP , flagsP | flSTRmAKE_PREFIXbASErEFc | flSTRmAKE_INTERNALuSEoNLY ) ; ___LF( pzost , idLineP , idiFileP ) ;_WQ
    if( pzost ) { prP = new( 0 , tinP , idLineP , idiFileP ) pbRefC( pzost ) ; ___LF( prP , idLineP , idiFileP ) ; }

    return cLength ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021b8.etherc.strmakef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021b9.etherc.operator_shiftright BEGIN
#define DDNAME       "3func.360021b9.etherc.operator_shiftright"
#define DDNUMB      (countT)0x360021b9
#define IDFILE      (countT)0xdc0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/const baseSoilXxxxC& etherC::operator >>( soulC& slP ) const/*1*/
{
    TINSL
    SCOOP

    IFbEcAREFUL
    {
        if( POOP ) return *this ;
    }

    _IO_
    if( slP ) ;_WQ
    return *this ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021b9.etherc.operator_shiftright END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ba.etherc.diskwalkf BEGIN
#define DDNAME       "3func.360021ba.etherc.diskwalkf"
#define DDNUMB      (countT)0x360021ba
#define IDFILE      (countT)0xdc1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::diskWalkF( tinS& tinP , countT& cDirsP , countT& cFilesP , const strokeS* const psttNameP , const boolT& bQuitP , const flagsT flagsP , diskWalkCBFT pCbfP , countT* const pcArgP , countT* pModuloDirsP , countT* pModuloFilesP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttNameP ) ;
        FV( flDISKwALK , flagsP ) ;
        if( POOP ) return ;
    }

    _IO_
    ZE( strokeS* , psttm ) ;
    diskMapFileNameF( tinP , psttm , psttNameP ) ; ___( psttm ) ;

    thirdC::diskWalkIF( tinP , cDirsP , cFilesP , osFileNameC( tinP , third , T(psttm) ) , bQuitP , flagsP , pCbfP , pcArgP , pModuloDirsP , pModuloFilesP ) ;
    delF( tinP , psttm ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ba.etherc.diskwalkf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021bb.etherc.diskWalkCopyF BEGIN
#define DDNAME       "3func.360021bb.etherc.diskWalkCopyF"
#define DDNUMB      (countT)0x360021bb
#define IDFILE      (countT)0xdc2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::diskWalkCopyF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const strokeS* const psttToP , const strokeS* const psttFromP , diskWalkCopyCBFT pCbfP , countT* pcArgP )/*1*/
{
    diskMakeDirIfNeededF( tinP , psttToP ) ;
    third.diskWalkCopyF( tinP , cDirsP , cFilesP , bQuitP , osFileNameC( tinP , third , T(psttToP) ) , osFileNameC( tinP , third , T(psttFromP) ) , pCbfP , pcArgP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021bb.etherc.diskWalkCopyF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021bc.etherc.diskzipf BEGIN
#define DDNAME       "3func.360021bc.etherc.diskzipf"
#define DDNUMB      (countT)0x360021bc
#define IDFILE      (countT)0xdc3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::diskZipF( tinS& tinP , const strokeS* const psttToP , const strokeS* const psttFromP , const flagsT flagsP )/*1*/
{
    diskMakeDirIfNeededF( tinP , psttToP ) ;
    third.diskZipF( tinP , osFileNameC( tinP , third , T(psttToP) ) , osFileNameC( tinP , third , T(psttFromP) ) , flagsP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021bc.etherc.diskzipf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021bd.etherc.strwordsf BEGIN
#define DDNAME       "3func.360021bd.etherc.strwordsf"
#define DDNUMB      (countT)0x360021bd
#define IDFILE      (countT)0xdc4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$strWordsF.0.html\"\>instances\</A\>
\<A HREF=\"5.103011a.1.0.html\"\>definition\</A\>
parses psttP into separate strings
evaluates to the number of separate strings
delimiters within quotes are not used as delimiters
a single leading and trailing pair of double quotes, if present, is trimmed from each string
backslash quote pairs are replaced with a quote stroke
arguments
 tinP
 pstt1P
  can be 0
   after evaluation, will be allocated with exactly the number of strokes needed to store the result, plus csttExtraP
  if not 0 then must point to a string that has a sufficient unused capacity
 psttP
  must not be 0
 sttQuoteP
 psttDelimitersP
  can be 0
  if 0 then T(TbLACK) is used
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00103cf.flSTRwORDS!||
 csttExtraP
 csttPrefixNullsP
  each word in pstt1P will be prefixed with this many nulls
 csttSuffixNullsP
  each word in pstt1P will be suffixed with this many nulls
*/
/**/

#define PSTT1(aNameP,ost1P)                                                             \
                                                                                        \
    strokeS aNameP[ CSpREFIX + 1 ] ;                                                    \
    SETpREFIX( aNameP , 1 , 0 ) ;                                                       \
    aNameP[ CSpREFIX ] = ost1P ;                                                        \

#define PSTT2(aNameP,ost1P,ost2P)                                                       \
                                                                                        \
    strokeS aNameP[ CSpREFIX + 2 ] ;                                                    \
    SETpREFIX( aNameP , 2 , 0 ) ;                                                       \
    aNameP[ CSpREFIX ] = ost1P ;                                                        \
    aNameP[ CSpREFIX + 1 ] = ost2P ;

/*1*/countT etherC::strWordsF( tinS& tinP , strokeS*& pstt1P , const strokeS* const psttP , strokeS& sttQuoteP , const strokeS* psttDelimitersP , const flagsT flagsP , const countT csttExtraP , const countT csttPrefixNullsP , const countT csttSuffixNullsP , soulC* pSoulP , grabC* pGrabP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        //__NZ( pstt1P ) ;
        FV( flSTRwORDS , flagsP )
        __Z( psttP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    boolT bDelimiterString = !!( F(flagsP) & flSTRwORDS_DELIMITERsTRING ) ;
    boolT bDelimiters      = !!( F(flagsP) & flSTRwORDS_DELIMITERS      ) ;
    boolT bOnlyDelimiters  = !!( F(flagsP) & flSTRwORDS_ONLYdELIMITERS  ) ;
    const strokeS sttqSave = sttQuoteP ;
    TN( tBlack , TbLACK ) ;
    const strokeS* psttDelimiters = psttDelimitersP ? psttDelimitersP : (strokeS*)tBlack ;

    //if( tinP.pc Utility[ 0 ] )
    //{
    //    ZE( strokeS* , psttd ) ;
    //    etherC::strDumpStrokesIF( tinP , psttd , psttP ) ; ___( psttd ) ;
    //    LOGrAW( T(USCORE79 "\r\n\r\n")+T(tinP.monitor.idThread)+T("|psttP| ")+T(psttd)+T("\r\n") ) ;
    //    PUSE( tinP , *(byteT**)&psttd ) ;
    //}

    PSTT1( pstt_q  , '\"' ) ;
    PSTT2( pstt_sq , '\\' , '\"' ) ;

    countT cTries = 1 + !pstt1P ;
    ZE( countT , csNeeded ) ;
    ZE( countT , cWords ) ;
    while( cTries -- )
    {
        if( !pstt1P && !cTries )
        {
            if( !pSoulP ) strMakeF( tinP , LF , pstt1P , T("") , csNeeded + csttExtraP ) ; //CALLER MUST TAG ___( pstt1P )
        }

        countT idf = 1 ;
        while( !POOP && idf )
        {
            //traceF( tinP , T("[cTries,idf]: ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG

            countT idfSave = idf ;
            sttQuoteP = sttqSave ; //NEEDED WHEN INPUT CONTAINS AN UNPAIRED QUOTE
            countT idw = bDelimiterString
                ? strIdF   ( tinP , 0 , flSTRmATCH_null , idf , sttQuoteP , psttDelimiters , psttP )
                : strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttQuoteP , psttDelimiters , psttP )
            ;

            countT idfDelim = idw ;
            countT idlDelim = !idfDelim
                ? 0
                : idf
                    ? idf - 1
                    : psttP->idAdam ;
            ;

            //traceF( tinP , T("[idfDelim,idlDelim]: ")+TF2(idfDelim,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(idlDelim,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG

            //if( tinP.pc Utility[ 0 ] ) LOGrAW5( "[idfDelim,idlDelim]: " , idfDelim , " " , idlDelim , "\r\n" ) ;

            if( idfSave <= psttP->idAdam )
            {
                ZE( boolT , bIsDelimiter ) ;
                {
                    countT idf2 = idfSave ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

                    bIsDelimiter = bDelimiterString

                        ? 1 == strIdF( tinP , 0 , flSTRmATCH_null , idf2 , sttq , psttDelimiters , psttP )                        // IS THE DELIMITER STRING                      AT idfSave?
                        : !!strIdF( tinP , psttP[ CSpREFIX - 1 + idfSave ] , psttDelimiters )               // DOES THE DELIMITER STRING CONTAIN THE STROKE AT idfSave?

                    ;
                }

                if( !bIsDelimiter )
                {
                    if( idw > idfSave ) idw -- ;
                    ZE( strokeS* , psttw2 ) ;
                    strSubstringF( tinP , psttw2 , idfSave , idw , psttP ) ; ___( psttw2 ) ;
                    ZE( strokeS* , psttw3 ) ;
                    strokeS sttd = S1C(0x22) ; //0x22 is a double quote
                    if( sttQuoteP.idCaste != sc_IGNOREqUOTES && psttw2->idAdam > 1 && psttw2[ CSpREFIX ] == sttd && psttw2[ CSpREFIX - 1 + psttw2->idAdam ] == sttd )
                    {
                        if( psttw2->idAdam == 2 )
                        {
                            strMakeF( tinP , LF , psttw3 , T("") ) ; ___( psttw3 ) ;
                        }
                        else
                        {
                            countT idf3 = 2 ;
                            countT idl3 = psttw2->idAdam - 1 ;
                            strSubstringF( tinP , psttw3 , idf3 , idl3 , psttw2 ) ; ___( psttw3 ) ;
                        }
                    }
                    else
                    {
                        strMakeF( tinP , LF , psttw3 , psttw2 ) ; ___( psttw3 ) ;
                    }
                    delF( tinP , psttw2 ) ;

                    if( !bOnlyDelimiters )
                    {
                        if( cTries ) csNeeded += CSpREFIX + psttw3->idAdam + csttPrefixNullsP + csttSuffixNullsP ;
                        else
                        {
                            if( sttQuoteP.idCaste != sc_IGNOREqUOTES ) strReplaceF( tinP , psttw3 , 0 , pstt_sq , pstt_q , 0 , flSTRrEPLACE_IGNOREqUOTES ) ;
                            if( !pSoulP ) { strFuseSeparateF( tinP , pstt1P , psttw3 , csttPrefixNullsP , csttSuffixNullsP , pSoulP , pGrabP ) ; ___( pstt1P ) ; }
                            else            strFuseSeparateF( tinP , *pSoulP , psttw3 , csttPrefixNullsP , csttSuffixNullsP , pGrabP ) ;
                            cWords ++ ;
                        }
                    }

                    delF( tinP , psttw3 ) ;
                }
            }

            if( bDelimiters && idfDelim )
            {
                if( cTries ) csNeeded += CSpREFIX + idlDelim - idfDelim + 1 + csttPrefixNullsP + csttSuffixNullsP ;
                else
                {
                    ZE( strokeS* , psttd ) ;
                    strSubstringF( tinP , psttd , idfDelim , idlDelim , psttP ) ; ___( psttd ) ;
                    if( !pSoulP ) strFuseSeparateF( tinP , pstt1P , psttd , csttPrefixNullsP , csttSuffixNullsP , pSoulP , pGrabP  ) ;
                    else          strFuseSeparateF( tinP , *pSoulP , psttd , csttPrefixNullsP , csttSuffixNullsP , pGrabP  ) ;
                    delF( tinP , psttd ) ;
                    cWords ++ ;
                }
            }
        }
    }

    return cWords ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021bd.etherc.strwordsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021be.etherc.diskWalkGatherF BEGIN
#define DDNAME       "3func.360021be.etherc.diskWalkGatherF"
#define DDNUMB      (countT)0x360021be
#define IDFILE      (countT)0xdc5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::diskWalkGatherF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const strokeS* const psttToP , const strokeS* const psttFromP , diskWalkCopyCBFT pCbfP , countT* pcArgP )/*1*/
{
    diskMakeDirIfNeededF( tinP , psttToP ) ;
    third.diskWalkGatherF( tinP , cDirsP , cFilesP , bQuitP , osFileNameC( tinP , third , T(psttToP) ) , osFileNameC( tinP , third , T(psttFromP) ) , pCbfP , pcArgP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021be.etherc.diskWalkGatherF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021bf.etherc.diskWalkTimePrefixF BEGIN
#define DDNAME       "3func.360021bf.etherc.diskWalkTimePrefixF"
#define DDNUMB      (countT)0x360021bf
#define IDFILE      (countT)0xdc6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::diskWalkTimePrefixF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const strokeS* const psttFromP , diskWalkCopyCBFT pCbfP , countT* pcArgP )/*1*/
{
    third.diskWalkTimePrefixF( tinP , cDirsP , cFilesP , bQuitP , osFileNameC( tinP , third , T(psttFromP) ) , pCbfP , pcArgP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021bf.etherc.diskWalkTimePrefixF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c0.etherc.diskWalkRenameForArchivalF BEGIN
#define DDNAME       "3func.360021c0.etherc.diskWalkRenameForArchivalF"
#define DDNUMB      (countT)0x360021c0
#define IDFILE      (countT)0xdc7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::diskWalkRenameForArchivalF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const strokeS* const psttToP , const strokeS* const psttFromP , diskWalkCopyCBFT pCbfP )/*1*/
{
    ZE( strokeS* , psttmFrom ) ;
    diskMapFileNameF( tinP , psttmFrom , psttFromP ) ; ___( psttmFrom ) ;

    ZE( strokeS* , psttmTo ) ;
    diskMapFileNameF( tinP , psttmTo , psttToP ) ; ___( psttmTo ) ;

    third.diskWalkRenameForArchivalF( tinP , cDirsP , cFilesP , bQuitP , osFileNameC( tinP , third , T(psttmTo) ) , osFileNameC( tinP , third , T(psttmFrom) ) , pCbfP ) ;
    delF( tinP , psttmTo ) ;
    delF( tinP , psttmFrom ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c0.etherc.diskWalkRenameForArchivalF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c1.etherc.ethersoilf BEGIN
#define DDNAME       "3func.360021c1.etherc.ethersoilf"
#define DDNUMB      (countT)0x360021c1
#define IDFILE      (countT)0xdc8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//U:: 20160428@2015: SUPPORT NULL STEPS (LEVEL1 KEYS THAT RESULT IN NOTHING DONE)

#define CfLAG1mAX ( TUCK << 2 )
#define CfLAG23mAX 0x10
#define CSTTdOsHORT 0x80

//#define CfLAG1mAX TUCK

#define flETHERsOILrEPORT_null     0xe00000ff
#define flETHERsOILrEPORT_FRAGnOTE 0xe00001ff

osTextT* postReportProlog =

    "\r\n"

;

osTextT* postReportEpilog =

    "\r\n"

;

osTextT* postSoilForReport1 =

    "\r\n{replacements:\r\n"
    "    {replace: **__TOCaD41__** \"<p><table style=\\\\\\\\\"width:100%\\\\\\\\\"><tr><td align=left valign=center style=\\\\\\\\\"\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD42__** \"</td><td align=right valign=center style=\\\\\\\\\"width:20px\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD43__** \"</td><td align=right valign=center style=\\\\\\\\\"width:300px\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD44__** \"</td></tr></table>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD71__** \"<p><table style=\\\\\\\\\"width:100%\\\\\\\\\"><tr><td align=left valign=center style=\\\\\\\\\"\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD72__** \"</td><td align=right valign=center style=\\\\\\\\\"width:20px\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD73__** \"</td><td align=right valign=center style=\\\\\\\\\"width:300px\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD74__** \"</td></tr></table><p><table style=\\\\\\\\\"width:100%\\\\\\\\\"><tr><td align=left valign=center style=\\\\\\\\\"width:300px\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD75__** \"</td><td align=left valign=center style=\\\\\\\\\"width:20px\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD76__** \"</td><td align=right valign=center style=\\\\\\\\\"\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD77__** \"</td></tr></table>\" }\r\n"
    "    {replace: **__BEGINdOC__** \"<table style=\\\\\\\\\"width:100%\\\\\\\\\"><tr><td>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__BEGINdOC1__** \"<table style=\\\\\\\\\"width:100%\\\\\\\\\"><tr><td>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__BEGINdOC2__** \"</td></tr><tr><td>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__ENDdOC__** \"</td></tr></table>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__BEGINtABLE__** \"<center><table>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__ENDtABLE__** \"</table></center>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__BEGIN__**                                            \"<tr><td style=\\\\\\\\\"width:608px; padding: 8px 8px 8px 8px\\\\\\\\\" align=left valign=center>\\\\i\" }\r\n"
    "    {replace: **__BEGINbROWN__** \"<tr style=\\\\\\\\\"background-color:#420\\\\\\\\\"><td style=\\\\\\\\\"width:608px; padding: 8px 8px 8px 8px\\\\\\\\\" align=left valign=center>\\\\i\" }\r\n"
    "    {replace: **__BEGINnOpIC__** \"<tr style=\\\\\\\\\"background-color:#420\\\\\\\\\"><td style=\\\\\\\\\"width:608px; padding: 8px 8px 8px 8px\\\\\\\\\" align=center valign=center>\" }\r\n"
    "    {replace: **__TIMEnOpIC__**     \"</td><td><table><tr><td align=right valign=center>\" }\r\n"
    "    {replace: **__TIME__**       \"\\\\i[**__TIMEnOpIC__**]\" }\r\n"
    "    {replace: **__NOTE__**           \"</td></tr><tr><td><hr>\\\\m\" }\r\n"
    "    {replace: **__NULLnOTE__** \"[**__NOTE__**]\\\\r\\\\n\" }\r\n"
    "    {replace: **__NOTEnEWlINE__**           \"</td></tr><tr><td><hr>\\\\m\\\\n\\\\r\" }\r\n"
    "    {replace: **__END__**      \"\\\\m</td></tr></table></td></tr>\" }\r\n"
    "    {replace: **__NNeND__** \"[**__NULLnOTE__**][**__END__**]\" }\r\n"
    "    {replace: **__ENDnEWlINE__**      \"</td></tr></table></td></tr>\\\\m\\\\n\\\\r\" }\r\n"
    "    {replace: **__NEOL__** \"\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__AUDIO__** \"<tr style=\\\\\\\\\"background-color:#420\\\\\\\\\"><td style=\\\\\\\\\"width:608px; padding: 8px 8px 8px 8px\\\\\\\\\" align=center valign=center>\\\\rU::put this recording next to the temporally closest picture[**__TIMEnOpIC__**]\" }\r\n"
    "    {replace: **__AUDIOeARLY__** \"<tr style=\\\\\\\\\"background-color:#420\\\\\\\\\"><td style=\\\\\\\\\"width:608px; padding: 8px 8px 8px 8px\\\\\\\\\" align=center valign=center>\\\\rpictures before 2009-09-05 exist but have not yet been added[**__TIMEnOpIC__**]\" }\r\n"
    "    {replace: **__BEGINcHRONICLE__**         \"<p><center><table><tr><td>\\\\m\"                                        }\r\n"
    "    {replace: **__P1__**            \"\\\\m</td>\"                                                             }\r\n"
    "    {replace: **__P2JPG__**         \"\\\\n\"                                                                  }\r\n"
    "    {replace: **__P3__**            \"<td>\\\\m\"                                                              }\r\n"
    "    {replace: **__ENDcHRONICLE__**           \"\\\\m\\\\n\\\\m</td></tr></table></center>\"                                          }\r\n"
    "}\r\n"
    "\r\n"
    "{ktr:\r\n"
    "    {file: index }\r\n"
    "    {mode: archive }\r\n"
    "    {flags: noZip beep fragnote}\r\n"
    "    {folder: \""

;

osTextT* postSoilForReport2 =

    "\" }\r\n"
    "    {namespace: \""

;

osTextT* postSoilForReport3 =

    "\" }\r\n"
    "    {body:\r\n"
    "          {preInclude: \""

;

osTextT* postSoilForReport4 =

    "\" }\r\n"
    "         :archive: \\x\\rThe IdeaFarm (tm) Operations Archive\r\n"
    "        root\r\n"
    "    }\r\n"
    "}\r\n"

;

voidT pour360021c1F( tinS& tinP , etherC& etherP , const strokeS* const psttToP , const strokeS* const psttFromP )
{
    strokeS sttSlash( '/' ) ;
    TN( tTo , psttToP ) ;
    ZE( infoFileS* , pInfo ) ;
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    do
    {
        etherP.diskFindFileOrDirF( tinP , pInfo , hFind , psttFromP ) ;
        if( pInfo && etherP.strIdF( tinP , sttSlash , pInfo->psttIfoName , - 1 ) != pInfo->psttIfoName->idAdam )
        {
            TN( tShort , "" ) ;
            {
                ZE( strokeS* , psttPathNU ) ;
                ZE( strokeS* , psttShort ) ;
                etherP.strBisectF( tinP , psttPathNU , psttShort , pInfo->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                ___( psttPathNU ) ;
                ___( psttShort ) ;
                tShort = T(psttShort) ;
                etherP.delF( tinP , psttPathNU ) ;
                etherP.delF( tinP , psttShort ) ;
            }

            TN( tToLong , "" ) ; tToLong = tTo+tShort ;
            //etherP.traceF( tinP , T("deleting ")+tToLong ) ;
            etherP.diskFileOrDirDeleteF( tinP , tToLong ) ; //U:: BUG: RACE: DATA LOSS CAN OCCUR HERE IF SOMETHING IS DELETED.  ALT: MOVE IT OUT OF THE WAY RATHER THAN DELETE IT
            etherP.diskMoveFileOrDirF(   tinP , tToLong , pInfo->psttIfoName ) ;
        }
        DEL( pInfo ) ;
    }
    while( !etherC::etPrimeIF( tinP ) && ~hFind ) ;
}

voidT emitTranscriptIfChangedF( tinS& tinP , etherC& etherP , const strokeS* psttKey , const strokeS* psttvtP , countT time1P , sCountT time2P , const countT idTranscriptP , textC& tArchiveP )
{
    TN( tTranscript , psttvtP ) ;

    ZE( countT  , ms  ) ;
    ZE( countT  , ss  ) ;
    ZE( countT  , mm  ) ;
    ZE( countT  , hh  ) ;
    ZE( countT  , d   ) ;
    ZE( countT  , m   ) ;
    ZE( sCountT , y   ) ;
    ZE( countT  , dow ) ;
    etherP.osTimeToOldTimeF( tinP , ms , ss , mm , hh , d , m , y , dow , time1P , time2P ) ;

    TN( tDot  , "." ) ;
    ZE( strokeS* , psttodt ) ;
    ZE( strokeS* , psttod0 ) ;
    {
        TN( tAmp  , "@" ) ;
        etherP.strFuseF( tinP , psttodt , 0 , TUCK ) ; ___( psttodt ) ;
        etherP.strFuseF( tinP , psttod0 , 0 , TUCK ) ; ___( psttod0 ) ;
        etherP.strFuseF( tinP , psttodt , TF4(y+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,4,0xa) ) ;
        etherP.strFuseF( tinP , psttod0 , TF4(y+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,4,0xa) ) ;
        etherP.strFuseF( tinP , psttodt , TF4(m+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ) ;
        etherP.strFuseF( tinP , psttod0 , TF4(m+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ) ;
        etherP.strFuseF( tinP , psttodt , TF4(d+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ) ;
        etherP.strFuseF( tinP , psttod0 , TF4(d+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ) ;

        etherP.strFuseF( tinP , psttod0 , T("@0000") ) ;

        etherP.strFuseF( tinP , psttodt , tAmp ) ;
        etherP.strFuseF( tinP , psttodt , TF4(hh,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ) ;
        etherP.strFuseF( tinP , psttodt , TF4(ss>30&&mm!=59?mm+1:mm,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ) ;
    }

    TN( tFileTranscriptShort , "" ) ; tFileTranscriptShort = T("!ideafarm.9.2.00000000.00000001.")+T(psttodt)+T(".!.transcript.")+T(psttKey)+T(".ttt") ; // EXTENSION "ttt" IS USED RATHER THAN "txt" BECAUSE Rimstar AND OTHER EDITORS INSIST ON APPLYING WORD WRAP ON "txt" FILES, WHICH IS INCONVENIENT FOR KT SOURCE FILES
    TN( tFileTranscript      , "" ) ; tFileTranscript = tArchiveP+tFileTranscriptShort ;
    TN( tFileDayZipLike      , "" ) ; tFileDayZipLike = tArchiveP+T("!ideafarm.9.2.00000000.00000001.")+T(psttod0)+T(".???.!.day.zip") ;

    boolT bEmit = 1 ;
    if( etherP.diskFileExistsF( tinP , tFileTranscript ) ) 
    {
        ZE( osTextT* , posti ) ;
        ZE( countT   , costi ) ;
        etherP.boxGetShadowF( tinP , posti , costi , tFileTranscript ) ; ___( posti ) ;
        if( posti && costi )
        {
            //etherP.traceF( tinP , T("[posti]: ")+T(posti) ) ;
            if( !((thirdC&)etherP).c_strcmpIF( tinP , posti , tTranscript ) ) bEmit = 0 ;
        }
        etherP.delF( tinP , posti ) ;
    }

    if( bEmit )
    {
        TN( tExeUnzip , "" ) ;
        {
            ZE( strokeS* , psttm ) ;
            etherP.diskMapFileNameF( tinP , psttm , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/infozip/unzip.exe/unzip.exe") ) ; ___( psttm ) ;
            tExeUnzip = T(psttm) ;
            etherP.delF( tinP , psttm ) ;
        }

        fileNameC fnLike( tinP , etherP , tFileDayZipLike ) ;
        patternC pat( tinP , etherP , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
    
        ZE( boolT , bFound ) ;
        ZE( infoFileS* , pInfo ) ;
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        do
        {
            etherP.diskFindFileOrDirF( tinP , pInfo , hFind , fnLike.pathF() , &pat ) ;
            if( pInfo )
            {
                TN( tFileZip , pInfo->psttIfoName ) ;

                //etherP.traceF( tinP , T("day zip: ")+tFileZip ) ;

                osFileNameC osfnZipFile( tinP , etherP , tFileZip ) ;

                TN( tArg , "" ) ; tArg = T(" \"")+T(osfnZipFile)+T("\" ")+tFileTranscriptShort ;

                //etherP.traceF( tinP , tExeUnzip ) ;
                //etherP.traceF( tinP , tArg ) ;
                ZE( countT , value ) ;
                ZE( countT , idDeathType ) ;
                {

                    ZE( strokeS* , psttu ) ;
                    etherP.strUniqueF( tinP , psttu ) ; ___( psttu ) ;
                    //etherP.traceF( tinP , psttu ) ;
                    TN( tPathHover , "" ) ; tPathHover = T("///ideafarm/ephemeral/tmp/")+T(psttu)+T("/") ;
                    etherP.delF( tinP , psttu ) ;

                    {
                        //hoverC hover( tinP , etherP , tPathHover ) ; //U::NOT THREAD SAFE: ADD SERIALIZATION
                        etherP.osProcessF( tinP , countTC() , countTC() , value , idDeathType , tExeUnzip , tArg ) ; //THIS CAN FAIL (E.G. IF ZIP FILE IS CORRUPT

                        if( !value && !idDeathType )
                        {
                            bFound = 1 ;

                            ZE( osTextT* , posti ) ;
                            ZE( countT   , costi ) ;
                            etherP.boxGetShadowF( tinP , posti , costi , tPathHover+tFileTranscriptShort ) ; ___( posti ) ;
                            if( posti && costi )
                            {
                                //etherP.traceF( tinP , T("[posti]: ")+T(posti) ) ;
                                if( !((thirdC&)etherP).c_strcmpIF( tinP , posti , tTranscript ) ) bEmit = 0 ;
                            }
                            etherP.delF( tinP , posti ) ;
                        }
                    }

                    etherP.diskFileOrDirDeleteF( tinP , tPathHover ) ;
                }
                //__( value ) ;             // NOT CHECKED, BECAUSE CAN BE CAUSED BY USER ERROR (TARGET ZIP FILE IS CORRUPT)
                //__( idDeathType ) ;

                //etherP.traceF( tinP , T("[value,idDeathType]:    ")+TF2(value,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(idDeathType,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
            }
            DEL( pInfo ) ;
        }
        while( !bFound && !etherC::etPrimeIF( tinP ) && ~hFind ) ;
    }

    if( bEmit ) etherP.boxPutF( tinP , tFileTranscript , tTranscript , tTranscript.csF( tinP ) ) ;
    etherP.delF( tinP , psttodt ) ;
}

voidT obeyReplacementsF( tinS& tinP , etherC& etherP , strokeS*& psttP , switchC& swReplaceP , strokeS*& psttLeverReplaceP )
{
    countT cMaxCycles = TUCK ; // GRACEFULLY FAIL IF CYCLING OCCURS
    ZE( countT , cFound ) ;
    do
    {
        cFound = 0 ;

        countT cFlavors = swReplaceP.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            psttLeverReplaceP = (strokeS*)swReplaceP.leverF( tinP , idf ) ;
            strokeS*& psttAfter = *(strokeS**)&(countT&)swReplaceP ;
            cFound += etherP.strReplaceF( tinP , psttP , 0 , psttLeverReplaceP , psttAfter , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttP ) ;
        }
    }
    while( -- cMaxCycles && cFound ) ;
}

#define ifcIDmODEsOILwALK_REPORT             0xdddd0001
#define ifcIDmODEsOILwALK_EDIT               0xdddd0002
#define ifcIDmODEsOILwALK_ZIP                0xdddd0003
#define ifcIDmODEsOILwALK_INSPECTfILEnAMES   0xdddd0004

boolT etherSoilWalkCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )
{
    _IO_

    if( postNameP )
    {
        etherC&        etherP           = *(etherC*)pcArgP[ 0 ] ;
        stackC&        stTimeMinMaxP    = *(stackC*)pcArgP[ 1 ] ;
        soulC&         soulFileNamesP   =  *(soulC*)pcArgP[ 2 ] ;
        boolT          idModeWalkP      =           pcArgP[ 3 ] ;
        const strokeS* psttPrefixP      = (strokeS*)pcArgP[ 4 ] ;
        const strokeS* psttNix1P        = (strokeS*)pcArgP[ 5 ] ;
        const strokeS* psttNix2P        = (strokeS*)pcArgP[ 6 ] ;
        const strokeS* psttNix3P        = (strokeS*)pcArgP[ 7 ] ;
        const strokeS* psttNix4P        = (strokeS*)pcArgP[ 8 ] ;
        const strokeS* psttExtMp3P      = (strokeS*)pcArgP[ 9 ] ;

        ifFileNameC ifFileName( tinP , etherP , postNameP ) ;
        TN( tFile , ifFileName ) ;

        countT idf = 1 ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

        ZE( boolT , bTrace ) ;
        //bTrace = 1 ;
        ZE( countT , idIn ) ;
        {
            _IO_
            static countT idInLath ;
            idIn = 1 + incv02AM( idInLath ) ;

            if( bTrace ) /*if( !( idIn % ( TUCK << 4 ) ) )*/ etherP.traceF( tinP , T("etherSoilWalkCBF / inspecting ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
        }

        const countT costFileNameMax = COSToSfILEnAMEmAX + 1 - sizeof( countT ) * 2 ; // "+ 1 - sizeof( countT ) * 2": THIS IS TO ENSURE THAT CHANGING idHome WILL NOT CAUSE THE FILE NAMES TO BECOME TOO LONG
        if( tFile.csF( tinP ) > costFileNameMax )
        {
            _IO_
            //U:: TRACE A MESSAGE (DO THIS AFTER HAVE CONVERTED ARCHIVE TO FORMAT 7; KEEP SILENT TILL THEN TO REDUCE DISK ACTIVITY TO AVOIDPISSING OFF GODADDY TECHNICIANS WHO KILL PROCESSES
            //LOGrAW3( "\r\n\r\nrem TOO LONG (REMOVE " , tFile.csF( tinP ) - costFileNameMax , " CHARS):\r\nren \"" ) ;
            //LOGrAW( postNameP ) ;
            //LOGrAW( "\"    \"" ) ;
            //LOGrAW( postNameP ) ;
            //LOGrAW( "\"\r\n" ) ;
            etherP.traceF( tinP , T("etherSoilWalkCBF / file name is too long: ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
        }
        else if( etherP.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , psttPrefixP , tFile ) && idf )
        {
            _IO_
            if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / perhaps setting bHit for file: ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
            countT idl = idf + 0xc ;

            ZE( strokeS* , psttTime ) ;
            etherP.strSubstringF( tinP , psttTime , idf , idl , tFile ) ; ___( psttTime ) ;

            boolT bHit = 1 ;
            if( stTimeMinMaxP )
            {
                _IO_
                if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / rsetting bHit since have specs to inspect: ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
                bHit = 0 ;

                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                do
                {
                    strokeS** ppsttMinMax = (strokeS**)&stTimeMinMaxP.upF( tinP , hWalk ) ;

                    if( etherP.strCompareF( tinP , psttTime , ppsttMinMax[ 0 ] ) >= 0 && etherP.strCompareF( tinP , psttTime , ppsttMinMax[ 1 ] ) <= 0 )
                    {
                        if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / setting bHit for file: ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
                        bHit = 1 ;
                        break ;
                    }
                }
                while( ~hWalk ) ;
            }

            if( !bHit )
            {
                if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / excluding file: ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
            }
            else
            {
                _IO_
                if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / including file: ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
                ZE( strokeS* , psttPath ) ;
                ZE( strokeS* , psttShort ) ;
                {
                    _IO_
                    etherP.strBisectF( tinP , psttPath , psttShort , tFile , T("/") , -1 , flSTRbISECT_APPENDdELIMITER ) ;
                    ___( psttPath ) ;
                    ___( psttShort ) ;
                }

                boolT bOk = 1 ;
                ZE( strokeS* , psttCurrentName ) ;
                ZE( strokeS* , psttShortThumbnail ) ;
                boolT bControl = !!etherP.strIdF( tinP , T(".!.control.") , psttShort ) ;

                if( !bControl )
                {
                    _IO_
                    ZE( strokeS* , psttShorter ) ;
                    {
                        _IO_
                        ZE( strokeS* , psttShorterNU ) ;
                        etherP.strBisectF( tinP , psttShorter , psttShorterNU , psttShort , T(".data.") , -1 , flSTRbISECT_null ) ; //U::OPTIMIZE: PASS T(".data.") IN AS PARAM
                        ___( psttShorterNU ) ;
                        ___( psttShorter ) ;
                        etherP.delF( tinP , psttShorterNU ) ;
                    }

                    if( !psttShorter ) { bOk = 0 ; }
                    else
                    {
                        _IO_
                        ZE( osTextT* , postCurrentName ) ;
                        ZE( countT   , costCurrentName ) ;
                        TN( tFileCurrentName  , "" ) ; tFileCurrentName  = T(psttPath)+T(psttShorter)+T(".meta.currentname") ;        //U::OPTIMIZE: PASS T(".meta.currentname.") IN AS PARAM
                        TN( tFileHashedName   , "" ) ; tFileHashedName   = T(psttPath)+T(psttShorter)+T(".meta.hashedname" ) ;        //U::OPTIMIZE: PASS T(".meta.hashedname.") IN AS PARAM

                        {
                            TN( tMetaSuffix , ".meta.thumb.0600x.jpg" ) ;
                            TN( tFileThumbnail600 , "" ) ; tFileThumbnail600 = T(psttPath)+T(psttShorter)+tMetaSuffix ; //U::OPTIMIZE: PASS T(".meta.thumb.0600x.jpg") IN AS PARAM
                            if( bTrace ) etherP.traceF( tinP , T("[tFileThumbnail600]: ")+tFileThumbnail600 ) ;
                            if( etherP.diskFileExistsF( tinP , tFileThumbnail600 ) )
                            {
                                etherP.strMakeF( tinP , LF , psttShortThumbnail , T(psttShorter)+tMetaSuffix ) ; ___( psttShortThumbnail ) ;
                                if( bTrace ) etherP.traceF( tinP , T("[psttShortThumbnail]: ")+T(psttShortThumbnail) ) ;
                            }
                            else if( bTrace ) etherP.traceF( tinP , T("[tFileThumbnail600]: ")+tFileThumbnail600+T(" error: not found") ) ;
                        }

                        if( etherP.diskFileExistsF( tinP , tFileCurrentName ) ) { etherP.boxGetShadowF( tinP , postCurrentName , costCurrentName , tFileCurrentName ) ; ___( postCurrentName ) ; }
                        else
                        {
                            etherP.traceF( tinP , T("archive error: currentname file not found: ")+tFileCurrentName ) ;
                            if( etherP.diskFileExistsF( tinP , tFileHashedName  ) ) { etherP.boxGetShadowF( tinP , postCurrentName , costCurrentName , tFileHashedName  ) ; ___( postCurrentName ) ; }
                        }

                        if( postCurrentName ) { etherP.strMakeFromOsTextF( tinP , psttCurrentName , postCurrentName ) ; ___( psttCurrentName ) ; }
                        else                  { etherP.strMakeF(           tinP , LF , psttCurrentName , psttShort       ) ; ___( psttCurrentName ) ; }

                        etherP.delF( tinP , postCurrentName ) ;
                        etherP.strConvertToLowerCaseF( tinP , psttCurrentName ) ;

                        if
                        (
                            etherP.strIdF( tinP , psttNix1P , psttCurrentName , 1 )
                            ||
                            etherP.strIdF( tinP , psttNix2P , psttCurrentName , 1 )
                            ||
                            etherP.strIdF( tinP , psttNix3P , psttCurrentName , 1 )
                            ||
                            etherP.strIdF( tinP , psttNix4P , psttCurrentName , 1 )
                            ||
                            (
                                idModeWalkP == ifcIDmODEsOILwALK_EDIT
                                &&
                                etherP.strIdF( tinP , psttExtMp3P , psttCurrentName , 1 ) != psttCurrentName->idAdam - 3
                            )
                        )
                        bOk = 0 ;

                        etherP.delF( tinP , psttShorter ) ;
                    }
                }
                etherP.delF( tinP , psttPath ) ;

                if( !bOk )
                {
                    if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / REJECTED ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
                }
                else
                {
                    _IO_

                    if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / accepted ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;

                    ZE( strokeS* , pstt1NameTriple ) ;
                                             etherP.strFuseSeparateF( tinP , pstt1NameTriple , psttShort          , 0 , 0 , 0 , 0 , ( bControl ? 0 : CSpREFIX + psttCurrentName->idAdam + ( psttShortThumbnail ? CSpREFIX + psttShortThumbnail->idAdam : 0 ) ) ) ; ___( pstt1NameTriple ) ;
                    if( psttCurrentName    ) etherP.strFuseSeparateF( tinP , pstt1NameTriple , psttCurrentName    , 0 , 0 , 0 , 0 , 0                                                                                                                          ) ;
                    if( psttShortThumbnail ) etherP.strFuseSeparateF( tinP , pstt1NameTriple , psttShortThumbnail , 0 , 0 , 0 , 0 , 0                                                                                                                          ) ;

                    soulFileNamesP << pstt1NameTriple ;
                    etherP.delF( tinP , pstt1NameTriple ) ;
                }
                etherP.delF( tinP , psttShort ) ;
                etherP.delF( tinP , psttCurrentName ) ;
                etherP.delF( tinP , psttShortThumbnail ) ;
            }

            etherP.delF( tinP , psttTime ) ;
        }
    }

    return 1 ;
}

//THIS IS USED ONLY TO MAKE IT EASY TO PUT A BREAKPOINT IN WO PLACE TO FIND WHERE ERRONEOUS INPUT IS DETECTED
voidT strFuseErrorFlag_330021c0_F( tinS& tinP , etherC& etherP , soulC& soulOutP , const strokeS* const psttFlagP )
{
    etherP.strFuseF( tinP , soulOutP , psttFlagP ) ;
}

/*
*/
/**/

countT subtractBuy_330021c0_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )
{
    IFbEcAREFUL
    {
    }

    countT* pc1 = (countT*)c1P ;
    countT* pc2 = (countT*)c2P ;

    ZE( sCountT , scSgn ) ;
         if( pc1[ 0 ] > pc2[ 0 ] ) scSgn =   1 ;
    else if( pc1[ 0 ] < pc2[ 0 ] ) scSgn = - 1 ;
    else if( pc1[ 1 ] > pc2[ 1 ] ) scSgn =   1 ;
    else if( pc1[ 1 ] < pc2[ 1 ] ) scSgn = - 1 ;
    else                           scSgn = ((etherC*)pEther)->strCompareF( tinP , (strokeS*)pc1[ 2 ] , (strokeS*)pc2[ 2 ] ) ;

    return - scSgn ;
}

countT subtractTimecard_330021c0_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )
{
    IFbEcAREFUL
    {
    }

    countT* pc1 = (countT*)c1P ;
    countT* pc2 = (countT*)c2P ;

    ZE( sCountT , scSgn ) ;
         if( pc1[ 0 ] > pc2[ 0 ] ) scSgn =   1 ;
    else if( pc1[ 0 ] < pc2[ 0 ] ) scSgn = - 1 ;
    else if( pc1[ 1 ] > pc2[ 1 ] ) scSgn =   1 ;
    else if( pc1[ 1 ] < pc2[ 1 ] ) scSgn = - 1 ;
    else if( pc1[ 2 ] > pc2[ 2 ] ) scSgn =   1 ;
    else if( pc1[ 2 ] < pc2[ 2 ] ) scSgn = - 1 ;
    else                           scSgn = ((etherC*)pEther)->strCompareF( tinP , (strokeS*)pc1[ 3 ] , (strokeS*)pc2[ 3 ] ) ;

    return - scSgn ;
}


// SPECS
// 
// INPUT:
// 
// idfElement: MUST BE 0
// idlElement: MUST BE 0
// idf       : MUST NOT BE 0 ; I WILL LOOK FOR AN ELEMENT BEGINNING AT OR AFTER idf
// 
// OUTPUT:
// 
// idfElement: IF NOT 0 THEN IS THE POSITION OF AN ELEMENT OR A PARTIAL ELEMENT AT THE END
// idlElement: IF NOT 0 THEN THE ELEMENT AT idfELEMENT IS COMPLETE
// idf       : IF FOUND AND THERE ARE MORE STROKES THEN WILL BE THE POSITION OF THE WOTH STROKE AFTER THE ELEMENT
// 

voidT findElementF( tinS& tinP , etherC& etherP , countT& idfElementP , countT& idlElementP , const strokeS* const psttP , countT& idFirstP , textC** pptFindP , const countT cFindP )
{
    countT idf = idFirstP ;
                 idFirstP = 0 ; // I AM NOT GOING TO DO ANYTHING ELSE TO PARAMETERS UNLESS I FIND A SYNTACTICALLY VALID FULL OR PARTIAL ELEMENT

    while( idf )
    {
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        strokeS sttOpen( '{' ) ;
        countT idOpen = etherP.strIdF( tinP , idf , sttq , sttOpen , psttP ) ;

        // SKIP OPEN CURLIES THAT ARE ESCAPED
        if( idOpen > 1 )
        {
            strokeS sttbs( '\\' ) ;
            while( idOpen )
            {
                ZE( countT , cEscapes ) ;
                countT offNeg = 1 ;
                for( countT offNeg = 1 ; idOpen - offNeg ; offNeg ++ )
                {
                    if( psttP[ CSpREFIX - 1 + idOpen - offNeg ] != sttbs ) break ;
                    else                                                   cEscapes ++ ;
                }

                if( !( cEscapes % 2 ) ) break ; // IF THERE IS AN EVEN NUMBER OF ESCAPES THEN THE CURSORED OPEN CURLY IS NOT ESCAPED

                idOpen = !idf ? 0 : etherP.strIdF( tinP , idf , sttq , sttOpen , psttP ) ;
            }
        }

        if( idOpen )
        {
            //etherP.traceF( tinP , T("[idOpen]: >>>>")+TF2(idOpen,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
            if( !idf )
            {
                idfElementP = idOpen ;                                                       // PARTIAL ELEMENT (ONLY THE '{')
                break ;
            }
            else
            {
                const countT cMaxSource = psttP->idAdam - idf + 1 ;
                ZE( countT , offf ) ;
                for( ; offf < cFindP ; offf ++ )
                {
                    strokeS* psttFind = *pptFindP[ offf ] ;
    
                    countT cDo = psttFind->idAdam ;
                    if( cDo > cMaxSource ) cDo = cMaxSource ;
            
                    ZE( countT , offc ) ;
                    for( ; offc < cDo ; offc ++ )
                    {
                        if( psttP[ CSpREFIX - 1 + idf + offc ].idAdam != psttFind[ CSpREFIX + offc ].idAdam )
                        {
                            //etherP.traceF( tinP , T("NOT: >>>>")+T(psttFind)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                            break ;
                        }
                    }

                    if( offc == cDo )                                                               // NO MISMATCH WAS FOUND
                    {
                        //etherP.traceF( tinP , T("YES: >>>>")+T(psttFind)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                        idfElementP = idOpen ;
                        if( cDo < cMaxSource )                                                      // "{[key]:" WAS VERIFIED AND THERE ARE MORE STROKES TO INSPECT
                        {
                            strokeS sttClose( '}' ) ;
                            idFirstP = idf + cDo ;
                            idlElementP = etherP.strIdF( tinP , idFirstP , sttq , sttClose , psttP ) ;
                        }

                        break ;
                    }
                }

                if( offf < cFindP ) break ;
            }
        }
    }
}

//U::MOVE THIS INTO etherC
// if psttP contains eol then i return the number of strokes in psttP after the lath eol
// else i return -1, which means "eol not found"
countT csttIndentF( tinS& tinP , etherC& etherP , const strokeS* const psttP , strokeS* psttQuoteP = 0 )
{
    countT csttIndent = - 1 ;
    IFbEcAREFUL
    {
        if( POOP ) return csttIndent ;
        __Z( psttP ) ;
        if( POOP ) return csttIndent ;
    }

    strokeS sttqDefault( 0 , sc_IGNOREqUOTES ) ;
    strokeS& sttq = psttQuoteP
        ? *psttQuoteP
        : sttqDefault
    ;

    countT idf = 1 ;
    if( etherP.strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , T("\r\n") , psttP , 0 , - 1 ) )
    {
        csttIndent = idf
            ? psttP->idAdam - idf + 1
            : 0
        ;
    }

    return csttIndent ;
}

#define UPD8INDENT(csttIndentP,psttP)                                               \
                                                                                    \
    {                                                                               \
        countT _cstti = csttIndentF( tinP , *this , (psttP) ) ;                     \
        if( _cstti == - 1 ) (csttIndentP) += (psttP)->idAdam ;                      \
        else                (csttIndentP)  = _cstti          ;                      \
    }

struct emitSetParmS
{
    etherC&     ether               ;
    stackC&     stFileType          ; 
    const boolT bTrace              ;

    textC    tcr                    ;
    textC    tRaw                   ;
    textC    tTodayLath             ;
    textC    tTimeLath              ;
    textC    tSequenceLath          ;
    textC    tHtmlIdLath            ;
    textC    tDayPrefix             ;
    textC    tDayKeywordsFileName   ;
    textC    tDayNarrativeFileName  ;
    textC    tDaySignsFileName      ;
    textC    tDayTitleFileName      ;
    textC    tcs                    ;
    textC    tp4NotScrubbed         ;
    textC    tp4Scrubbed            ;
    textC    tBar                   ;
    textC    tSlash                 ;
    textC    tTocAfter              ;
    textC    tb1                    ;
    textC    tb2                    ;
    textC    tc                     ;
    textC    tp2jpg                 ;
    textC    tDayKeywordsSuffix     ;
    textC    tDayNarrativeSuffix    ;
    textC    tDaySignsSuffix        ;
    textC    tDayTitleSuffix        ;
    textC    tEnd                   ;
    textC    tp5                    ;
    textC    tn                     ;
    textC    tp3                    ;
    textC    tBegin                 ;
    textC    tCloudPath             ;
    textC    tMarkAvi               ;
    textC    tMarkBmp               ;
    textC    tMarkEml               ;
    textC    tMarkIco               ;
    textC    tMarkJpg               ;
    textC    tMarkMp3               ;
    textC    tMarkPdf               ;
    textC    tMarkPng               ;
    textC    tMarkSoil              ;
    textC    tMarkTxt               ;
    textC    tMarkZip               ;
    textC    tMark                  ;
    textC    tIconTranscript        ;
    textC    tp1                    ;
    textC    tNoteFileName          ;

    strokeS* psttb                  ;
    strokeS* psttExtAvi             ;
    strokeS* psttExtBmp             ;
    strokeS* psttExtEml             ;
    strokeS* psttExtIco             ;
    strokeS* psttExtJpg             ;
    strokeS* psttExtMp3             ;
    strokeS* psttExtPdf             ;
    strokeS* psttExtPng             ;
    strokeS* psttExtSoil            ;
    strokeS* psttExtTtt             ;
    strokeS* psttExtTxt             ;
    strokeS* psttExtZip             ;
    strokeS* psttDotHeyDot          ;
    strokeS* psttTestNote           ;
    strokeS* psttTestDayKeywords    ;
    strokeS* psttTestDayNarrative   ;
    strokeS* psttTestDaySigns       ;
    strokeS* psttTestDayTitle       ;

    ~emitSetParmS( voidT ) ;
    emitSetParmS( tinS& tinP , etherC& etherP , stackC& stFileTypeP , const boolT bTraceP , textC& tArchiveP ) ;
}
;

emitSetParmS::~emitSetParmS( voidT )
{
    TINSL
    ether.delF( tinP , psttb                    ) ;
    ether.delF( tinP , psttExtAvi               ) ;
    ether.delF( tinP , psttExtBmp               ) ;
    ether.delF( tinP , psttExtEml               ) ;
    ether.delF( tinP , psttExtIco               ) ;
    ether.delF( tinP , psttExtJpg               ) ;
    ether.delF( tinP , psttExtMp3               ) ;
    ether.delF( tinP , psttExtPdf               ) ;
    ether.delF( tinP , psttExtSoil              ) ;
    ether.delF( tinP , psttExtTtt               ) ;
    ether.delF( tinP , psttExtTxt               ) ;
    ether.delF( tinP , psttExtZip               ) ;
    ether.delF( tinP , psttDotHeyDot            ) ;
    ether.delF( tinP , psttTestNote             ) ;
    ether.delF( tinP , psttTestDayKeywords      ) ;
    ether.delF( tinP , psttTestDayNarrative     ) ;
    ether.delF( tinP , psttTestDaySigns         ) ;
    ether.delF( tinP , psttTestDayTitle         ) ;
}

emitSetParmS::emitSetParmS( tinS& tinP , etherC& etherP , stackC& stFileTypeP , const boolT bTraceP , textC& tArchiveP ) :
ether( etherP ) ,
stFileType( stFileTypeP ) ,
bTrace( bTraceP ) ,
tcr(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\r\n"                                                                 ) ,
tRaw(                  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\r"                                                                  ) ,
tTodayLath(            tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tTimeLath(             tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tSequenceLath(         tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tHtmlIdLath(           tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tDayPrefix(            tinP , TAG( TAGiDnULL ) , flTEXTc_null , "<p><table border=1 cellpadding=10><tr><td>\\m\\r"                     ) ,
tDayKeywordsFileName(  tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tDayNarrativeFileName( tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tDaySignsFileName(     tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tDayTitleFileName(     tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tcs(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , ": "                                                                   ) ,
tp4NotScrubbed(        tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tp4Scrubbed(           tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tBar(                  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "|"                                                                    ) ,
tSlash(                tinP , TAG( TAGiDnULL ) , flTEXTc_null , "/"                                                                    ) ,
tTocAfter(             tinP , TAG( TAGiDnULL ) , flTEXTc_null , "</td></tr></table>"                                                   ) ,
tb1(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , " "                                                                    ) ,
tb2(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "  "                                                                   ) ,
tc(                    tinP , TAG( TAGiDnULL ) , flTEXTc_null , ":"                                                                    ) ,
tp2jpg(                tinP , TAG( TAGiDnULL ) , flTEXTc_null , "[**__P2JPG__**]"                                                      ) ,
tDayKeywordsSuffix(    tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\" }"                                                                 ) ,
tDayNarrativeSuffix(   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\" }"                                                                 ) ,
tDaySignsSuffix(       tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\" }"                                                                 ) ,
tDayTitleSuffix(       tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\" }"                                                                 ) ,
tEnd(                  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "[**__ENDcHRONICLE__**]"                                               ) ,
tp5(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\" }"                                                                 ) ,
tn(                    tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tp3(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "[**__P3__**]"                                                         ) ,
tBegin(                tinP , TAG( TAGiDnULL ) , flTEXTc_null , "[**__BEGINcHRONICLE__**]"                                             ) ,
tCloudPath(            tinP , TAG( TAGiDnULL ) , flTEXTc_null , "http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/"                         ) ,
tMarkAvi(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\v"                                                                  ) ,
tMarkBmp(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\i"                                                                  ) ,
tMarkEml(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\e"                                                                  ) , //U:: 20180304@1401 CONJ: DO NOT WANT OR NEED A MARK FOR EMAIL FILES
tMarkIco(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\i"                                                                  ) ,
tMarkJpg(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\i"                                                                  ) ,
tMarkMp3(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\a"                                                                  ) ,
tMarkPdf(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\p"                                                                  ) ,
tMarkPng(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\i"                                                                  ) ,
tMarkSoil(             tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\w"                                                                  ) ,
tMarkTxt(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\c"                                                                  ) ,
tMarkZip(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\z"                                                                  ) ,
tMark(                 tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tIconTranscript(       tinP , TAG( TAGiDnULL ) , flTEXTc_null , /*"///ideafarm/IdeaFarm (tm)/Drop Files Here To"" Archive/"*/ "!ideafarm.9.2.00000000.00000001.20131214@1131.000b37ef.d03518a6.fa5b8bcb.scanner.!.wo.ideafarm.dictating.gold.tooth.0192x.jpg" ) ,
tp1(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "[**__P1__**]"                                                         ) ,
tNoteFileName(         tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
psttb( 0 ) ,
psttExtAvi( 0 ) ,
psttExtBmp( 0 ) ,
psttExtEml( 0 ) ,
psttExtIco( 0 ) ,
psttExtJpg( 0 ) ,
psttExtMp3( 0 ) ,
psttExtPdf( 0 ) ,
psttExtPng( 0 ) ,
psttExtSoil( 0 ) ,
psttExtTtt( 0 ) ,
psttExtTxt( 0 ) ,
psttExtZip( 0 ) ,
psttDotHeyDot( 0 ) ,
psttTestNote( 0 ) ,
psttTestDayKeywords( 0 ) ,
psttTestDayNarrative( 0 ) ,
psttTestDaySigns( 0 ) ,
psttTestDayTitle( 0 )
{
    tp4NotScrubbed = T(      "{preInclude: \"")+tArchiveP ;
    tp4Scrubbed    = T("{preIncludeScrub1: \"")+tArchiveP ;

    etherP.strMakeFromOsTextF( tinP , psttb                   , " "                           ) ; ___( psttb                    ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtAvi              , "avi"                         ) ; ___( psttExtAvi               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtBmp              , "bmp"                         ) ; ___( psttExtBmp               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtEml              , "eml"                         ) ; ___( psttExtEml               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtIco              , "ico"                         ) ; ___( psttExtIco               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtJpg              , "jpg"                         ) ; ___( psttExtJpg               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtMp3              , "mp3"                         ) ; ___( psttExtMp3               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtPdf              , "pdf"                         ) ; ___( psttExtPdf               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtPng              , "png"                         ) ; ___( psttExtPng               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtSoil             , "soil"                        ) ; ___( psttExtSoil              ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtTtt              , "ttt"                         ) ; ___( psttExtTtt               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtTxt              , "txt"                         ) ; ___( psttExtTxt               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtZip              , "zip"                         ) ; ___( psttExtZip               ) ;
    etherP.strMakeFromOsTextF( tinP , psttDotHeyDot           , ".!."                         ) ; ___( psttDotHeyDot            ) ;
    etherP.strMakeFromOsTextF( tinP , psttTestNote            , ".!.note."                    ) ; ___( psttTestNote             ) ;
    etherP.strMakeFromOsTextF( tinP , psttTestDayKeywords     , ".!.control.page.keywords"    ) ; ___( psttTestDayKeywords      ) ;
    etherP.strMakeFromOsTextF( tinP , psttTestDayNarrative    , ".!.control.page.narrative"   ) ; ___( psttTestDayNarrative     ) ;
    etherP.strMakeFromOsTextF( tinP , psttTestDaySigns        , ".!.control.page.signs"       ) ; ___( psttTestDaySigns         ) ;
    etherP.strMakeFromOsTextF( tinP , psttTestDayTitle        , ".!.control.page.title"       ) ; ___( psttTestDayTitle         ) ;
}

voidT emitSetF( tinS& tinP , etherC& etherP , soulC& soulrFileSetsP , soulC& soulIdFragShortP , const strokeS* const psttSetP , stackC& stSetP , emitSetParmS& espP , const strokeS* const psttCurrentNameP )
{
    __Z( psttSetP ) ;

    if( !POOP )
    {
        //if( espP.bTrace ) etherP.traceF( tinP , T("++++++++++++++++++++++++++++++++++++++++++++++++++++++ emitSetF/+ [psttSetP,tNoteFileName]: ")+T(psttSetP)+T("    \"")+espP.tNoteFileName+T("\"") ) ;

        strokeS sttDot( '.' ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        TN( tNoteFileName , "" ) ;

        //U:: MIGRATE THIS CODE.  IT IS FROM WHEN switchStackC WAS USED.  THIS MUST BE MIGRATED SO THAT NOTE FILES WILL BE OBEYED
        // if( espP.tNote FileName.csF( tinP ) )
        // {
        //     espP.tNote FileName = espP.tn ;
        //     etherP.delF( tinP , psttFile ) ;
        //     continue ;
        // }

        //U::20200410@2006: EDIT THIS CODE TO USE FORMAT 9 ARCHIVE FILE NAMES

        //
        //                                                      1               2               3               4               5
        //                                       123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
        //                                                                    |         |                                                       OLD 7
        //                                                                                        |         |                                   NEW 8  (+ 0x41)
        // FORMAT 9?

        // FILES WHOSE SHORT NAME IS OF THE FORM !ideafarm.9.2.00000000.00000001.20130709@1913.001.!.note.ttt ARE EXCLUDED
        // THIS IS A VARIATION OF THE FORMAT 5 FILE NAME; IT IS USED TO ANNOTATE THE ARCHIVE
        //

        //U:: MIGRATE THIS CODE.  IT IS FROM WHEN switchStackC WAS USED.  THIS MUST BE MIGRATED SO THAT NOTE FILES WILL BE OBEYED
        //U::CONJ: ALREADY DONE; THIS CODE CAN BE REMOVED
        // if( idFlavor > 1 ) // MAYBE SET espP.tNote FileName
        // {
        //     strokeS* psttzLeverNoteMaybe = (strokeS*)stSetP.leverF( tinP , idFlavor - 1 ) ;
        // 
        //     if( psttzLeverNoteMaybe->idAdam == 0x3b && psttzLeverNoteMaybe[ CSpREFIX - 1 + 0x32 ] == strokeS( '!' ) ) 
        //     {
        //         ZE( strokeS* , psttw ) ;
        //         countT idf = 0x32 ;
        //         countT idl = 0x3c ;
        //         etherP.strSubstringF( tinP , psttw , idf , idl , psttzLeverNoteMaybe ) ; ___( psttw ) ;
        // 
        //         if( !etherP.strCompareF( tinP , psttw , espP.psttTestNote ) ) espP.tNote FileName = T(psttzLeverNoteMaybe) ;
        // 
        //         etherP.delF( tinP , psttw ) ;
        //     }
        // }
        //
        //                                                      1               2               3               4
        //                                       123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd
        //                                                                    |              |                                          OLD 7
        //                                                                                        |              |                                          NEW 8
        // FILES WHOSE SHORT NAME IS OF THE FORM !ideafarm.8.2.00000000.00000001.20140122@0000.000.!.day.title.ttt ARE EXCLUDED
        // FILES WHOSE SHORT NAME IS OF THE FORM !ideafarm.9.2.00000000.00000001.20140122@0000.!.day.title.ttt ARE EXCLUDED

        // THIS IS A VARIATION OF THE FORMAT 4 FILE NAME; IT IS USED TO ANNOTATE THE ARCHIVE
        //

        // 20171002@1500:  THE MIGRATION TO !ideafarm.8.2.00000000.00000001.* FILE NAMES DISABLED ALL OF THE FANCY CODE IN ME AND IN MY CALLER
        // 20200410@2011:  THE MIGRATION TO !ideafarm.9.2.00000000.00000001.* FILE NAMES PROBABLY BROKE IT AGAIN
        // WITH THIS FILE NAME FORMAT, THE "FILE SET" WILL ALWAYS BE A SINGLE FILE NAME
        // THAT FILE NAME CAN BE PARSED TO OBTAIN THE NAME OF THE *.meta.currentname FILE
        // THE CONTENTS OF THAT FILE CAN BE USED BY ME TO DISPLAY THE "CURRENTNANE" TEXT RATHER THAN THE FORMAT 7 FILE NAME
        // THAT IS WHAT I DO NOW.  THE FANCY CODE REMAINS PRESENT BUT IS NEVER EXECUTED.
        //
        // BY FANCY CODE I MEAN THE DAY TITLE FILES AND THE NOTE FILES.  ALL OF THAT FUNCTIONALITY WILL NEED TO BE REIMPLEMENTED
        // WHEN MIGRATING THE ARCHIVE TO FORMAT 7, THE SPECIAL (FANCY) FILES WERE RETAINED AND SHOULD BE IN A ZIP FILE IN THE ARCHIVE SOMEWHERE

        etherP.traceF( tinP , T("[psttSetP]: ")+T(psttSetP) ) ; //U:: TO FIND A BUG

        if( psttSetP->idAdam > 0x2f && psttSetP[ CSpREFIX - 1 + 0x2f ] == strokeS( '!' ) ) 
        {
            //                                              0x2e                   0x45
            //                                              |                      |
            // 0              1               2               3               4               5
            // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
            // !ideafarm.8.2.00000000.00000001.20070516@1424.!.control.page.keywords
            // !ideafarm.9.2.00000000.00000001.20070516@1424.!.control.page.keywords

            // MAYBE SET espP.tDayKeywordsFileName
            if( psttSetP->idAdam == 0x45 ) 
            {
                ZE( strokeS* , psttw ) ;
                countT idf = 0x2e ;
                countT idl = 0x45 ;
                etherP.strSubstringF( tinP , psttw , idf , idl , psttSetP ) ; ___( psttw ) ;

                if( !etherP.strCompareF( tinP , psttw , espP.psttTestDayKeywords ) ) espP.tDayKeywordsFileName = T(psttSetP) ;
                etherP.delF( tinP , psttw ) ;
            }
            //                                              0x2e                    0x46
            //                                              |                       |
            // 0              1               2               3               4               5
            // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
            // !ideafarm.8.2.00000000.00000001.20070516@1424.!.control.page.narrative
            // !ideafarm.9.2.00000000.00000001.20070516@1424.!.control.page.narrative

            // MAYBE SET espP.tDayNarrativeFileName
            else if( psttSetP->idAdam == 0x46 ) 
            {
                ZE( strokeS* , psttw ) ;
                countT idf = 0x2e ;
                countT idl = 0x46 ;
                etherP.strSubstringF( tinP , psttw , idf , idl , psttSetP ) ; ___( psttw ) ;

                if( !etherP.strCompareF( tinP , psttw , espP.psttTestDayNarrative ) ) espP.tDayNarrativeFileName = T(psttSetP) ;
                etherP.delF( tinP , psttw ) ;
            }

            //                                              0x2e                0x42
            //                                              |                   |
            // 0              1               2               3               4               5
            // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
            // !ideafarm.8.2.00000000.00000001.20070516@1424.!.control.page.signs
            // !ideafarm.8.2.00000000.00000001.20070516@1424.!.control.page.title
            // !ideafarm.9.2.00000000.00000001.20070516@1424.!.control.page.title

            // MAYBE SET espP.tDaySignsFileName
            // MAYBE SET espP.tDayTitleFileName
            else if( psttSetP->idAdam == 0x42 ) 
            {
                ZE( strokeS* , psttw ) ;
                countT idf = 0x2e ;
                countT idl = 0x42 ;
                etherP.strSubstringF( tinP , psttw , idf , idl , psttSetP ) ; ___( psttw ) ;

                     if( !etherP.strCompareF( tinP , psttw , espP.psttTestDayNarrative ) ) espP.tDayNarrativeFileName = T(psttSetP) ;
                else if( !etherP.strCompareF( tinP , psttw , espP.psttTestDaySigns     ) ) espP.tDaySignsFileName     = T(psttSetP) ;
                else if( !etherP.strCompareF( tinP , psttw , espP.psttTestDayTitle     ) ) espP.tDayTitleFileName     = T(psttSetP) ;
                etherP.delF( tinP , psttw ) ;
            }
        }

        TN( tExt , "" ) ;
        TN( tTime , "" ) ;
        TN( tTitle , "" ) ;
        TN( tNarrativePrefix , "" ) ;
        {
            countT idf = 1 ;
            ZE( countT , idl ) ;
            countT idfLathDot = etherP.strIdF( tinP , idf , sttq , sttDot , psttSetP , 0 , - 1 ) ;
            if( !idfLathDot || !idf ) { LOGrAW( T("error: bad file name (no extension): ")+T(psttSetP)+espP.tcr ) ; }
            else
            {
                idf = idfLathDot + 1 ;
                ZE( strokeS* , psttExt ) ;
                etherP.strSubstringF( tinP , psttExt , idf , countTC() , psttSetP ) ; ___( psttExt ) ;
                etherP.strConvertToLowerCaseF( tinP , psttExt ) ;
                tExt = T(psttExt) ;
                etherP.delF( tinP , psttExt ) ;

                //
                //                1               2               3               4
                // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
                //             |           |                                        OLD 7
                //                                 |           |                                        NEW 8
                // !ideafarm.8.2.00000000.00000001.20130709@1913.000.*
                //
                // !ideafarm.9.2.00000000.00000001.20130709@1913.000.*
                //

                if( espP.stFileType )
                {
                    //LOGrAW3( T("looking up file type: \"")+tExt+T("\" among ") , espP.stFileType , " registered types\r\n" ) ;
                    {
                        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        do
                        {
                            strokeS* psttExt = (strokeS*)espP.stFileType.downF( tinP , hWalk ) ;
                            //LOGrAW( T("    checking: \"")+T(psttExt)+T("\"\r\n") ) ;
                        }
                        while( ~hWalk ) ;
                    }

                    if( !espP.stFileType( (strokeS*)tExt ) ) tExt = espP.tn ;
                }

                if( tExt.csF( tinP ) )
                {
                    ZE( strokeS* , psttTime ) ;
                    idf = 0x21 ;
                    idl = 0x2d ;
                    etherP.strSubstringF( tinP , psttTime , idf , idl , psttSetP ) ; ___( psttTime ) ;
                    tTime = T(psttTime) ;
                    etherP.delF( tinP , psttTime ) ;

                    //THIS COMMENT IS OBSOLETED BY FORMAT 7 FILE NAMES
                    // IF I DON'T HAVE A NOTE FILE THEN CALCULATE A TITLE FROM THE FILE NAME
                    //U::20171002@1440:CRAFTWORK: if( !espP.tNoteFileName.csF( tinP ) && idf && etherP.strIdF( tinP , idf , sttq , espP.psttDotHeyDot , psttSetP ) && idf )

                    if( psttCurrentNameP ) tTitle = T(psttCurrentNameP) ;
                    else
                    {
                        idl = idfLathDot - 1 ;
                        if( idl < idf ) idl = 0 ; // WILL OCCUR IF FILE NAME HAS NO EXTENSION, E.G. ".!.stamp"
                        ZE( strokeS* , psttTitle ) ;
                        etherP.strSubstringF( tinP , psttTitle , idf , idl , psttSetP ) ; ___( psttTitle ) ;

                        //EXAMPLE OF RAW TITLE: 130709_008_02_01_20130709@1640_mv_bicycling_rebuking_bicyclist_on_wrong_side
                        // GOAL: SUPPRESS PREDICTABLE PATTERNS ; MAP UNDERSCORES AND PERIODS TO BLANKS

                        idf = 1 ;
                        countT idfUse = etherP.strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , T("0123456789@_.") , psttTitle , 0 , 1 , flSTRiDaNY_NOT ) ;
                        if( idfUse )
                        {
                            strokeS* psttd = psttTitle ; psttTitle = 0 ;
                            idl = 0 ;
                            etherP.strSubstringF( tinP , psttTitle , idfUse , idl , psttd ) ; ___( psttTitle ) ;
                            etherP.delF( tinP , psttd ) ;
                            etherP.strReplaceAnyF( tinP , psttTitle , 0 , T("_.") , T(" ") ) ; ___( psttTitle ) ;
                            tTitle = espP.tRaw+T(psttTitle) ;
                        }
                        etherP.delF( tinP , psttTitle ) ;
                    }
                }
            }
        }

        if( tExt.csF( tinP ) )
        {
            boolT bDisplayTime = 1 ;
            ZE( boolT , bNarrative ) ;
            ZE( boolT , bImage ) ;
                 if( !etherP.strCompareF( tinP , tExt , espP.psttExtAvi  ) )   espP.tMark = espP.tMarkAvi ;
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtBmp  ) ) { espP.tMark = espP.tMarkBmp ; bImage = 1 ; }
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtEml  ) ) { espP.tMark = espP.tMarkEml ; bImage = 1 ; } //U:: 20180304@1402: SETTING bImage JUST TO SEE WHAT HAPPENS (CAN AN EMAIL BE DISPLAYED AS AN IMAGE?)
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtIco  ) ) { espP.tMark = espP.tMarkIco ; bImage = 1 ; }
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtJpg  ) ) { espP.tMark = espP.tMarkJpg ; bImage = 1 ; }
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtMp3  ) )   espP.tMark = espP.tMarkMp3 ;
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtPdf  ) )   espP.tMark = espP.tMarkPdf ;
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtPng  ) ) { espP.tMark = espP.tMarkPng ; bImage = 1 ; }
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtSoil ) )   espP.tMark = espP.tMarkSoil ;
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtTxt  ) )   espP.tMark = espP.tMarkTxt ;
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtZip  ) )   espP.tMark = espP.tMarkZip ;
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtTtt  ) )
            {
                if
                (
                    etherP.strIdF( tinP , T(".!.transcript.do.ttt")      , psttSetP )
                    ||
                    etherP.strIdF( tinP , T(".!.transcript.journal.ttt") , psttSetP )
                    ||
                    etherP.strIdF( tinP , T(".!.transcript.log.ttt")     , psttSetP )
                    ||
                    etherP.strIdF( tinP , T(".!.narrative.ttt")          , psttSetP )
                )
                {
                    tNarrativePrefix = etherP.strIdF( tinP , T(".!.transcript.do.ttt") , psttSetP )
                        ? T("(do)")
                        : etherP.strIdF( tinP , T(".!.transcript.journal.ttt") , psttSetP )
                            ? T("(journal)")
                            : etherP.strIdF( tinP , T(".!.transcript.log.ttt") , psttSetP )
                                ? T("(log)")
                                : espP.tn
                    ;

                    if( etherP.strIdF( tinP , T(".!.narrative.ttt") , psttSetP ) ) bDisplayTime = 0 ;

                    espP.tMark = espP.tMarkJpg ;
                    bImage = bNarrative = 1 ;
                    //espP.tNote FileName = T(psttSetP) ;      20141008@1429: COMMENTED THIS OUT BECAUSE IT APPEARS TO BE A BUG (tNote FileName APPEARS TO ONLY BE USED TO HOLD THE MOST RECENTLY ENCOUNTERED *.!.note.ttt FILE)
                }
            }

            TN( tToday , "" ) ;
            if( bNarrative || espP.tMark.csF( tinP ) )
            {
                // 0              1               2               3               4               5
                // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
                //                                 |-----------------------------|
                //                                 |------| |--|               |-|                                NEW 8
                // !ideafarm.8.2.00000000.00000001.20100115@1256.20170131@0039.888.0d6d4aac01544697a52d1cb3bcfca89c.00000001.data.jpg
                //
                // !ideafarm.9.2.00000000.00000001.20100115@1256.20170131@0039.0d6d4aac01544697a52d1cb3bcfca89c.001.data.jpg
                //

                countT idf = 0x21  ;
                countT idl = 0x28 ;
                ZE( strokeS* , psttToday ) ;
                etherP.strSubstringF( tinP , psttToday , idf , idl , psttSetP ) ; ___( psttToday ) ;
                etherP.strConvertToLowerCaseF( tinP , psttToday ) ;
                tToday = T(psttToday) ;
                etherP.delF( tinP , psttToday ) ;

                idf = 0x2a  ;
                idl = 0x2d ;
                ZE( strokeS* , psttTimeToday ) ;
                etherP.strSubstringF( tinP , psttTimeToday , idf , idl , psttSetP ) ; ___( psttTimeToday ) ;
                etherP.strConvertToLowerCaseF( tinP , psttTimeToday ) ;

                idf = 0x3d  ;
                idl = 0x3f ;
                ZE( strokeS* , psttSequence ) ;
                etherP.strSubstringF( tinP , psttSequence , idf , idl , psttSetP ) ; ___( psttSequence ) ;
                etherP.strConvertToLowerCaseF( tinP , psttSequence ) ;

                idf = 0x21  ;
                idl = 0x3f ;
                ZE( strokeS* , psttHtmlIdLath ) ;
                etherP.strSubstringF( tinP , psttHtmlIdLath , idf , idl , psttSetP ) ; ___( psttHtmlIdLath ) ;
                etherP.strConvertToLowerCaseF( tinP , psttHtmlIdLath ) ;

                if
                (
                    ( espP.tTodayLath.csF( tinP ) && etherP.strCompareF( tinP , tToday , espP.tTodayLath ) )

                    //20180405@1622: NOTWITHSTANDING THE COMMENT CLAIMING 2014, I THINK THAT I ADDED THIS JUST A FEW DAYS AGO
                    //||
                    //espP.tDay TitleFileName.csF( tinP )      // 20140929@1804: THIS WAS ADDED SO THAT ADDITIONAL DAY TITLE FILES CAN BE USED TO SPLIT THE FILES FOR A DAY INTO MULTIPLE HTML PAGES
                )
                {
                    //20180417@1332: THIS COMMENT IS STALE
                    // espP.tc
                    // |espP.tTodayLath
                    // ||       sttDot 
                    // ||       |psttTimeToday
                    // ||       ||       espP.tc
                    // ||       ||       |espP.tDayPrefix
                    // ||       ||       ||      espP.tTodayLath
                    // ||       ||       ||      |       espP.tcs
                    // ||       ||       ||      |       | espP.tp4Scrubbed
                    // ||       ||       ||      |       | |                                                                                 espP.tDayTitleFileName
                    // ||       ||       ||      |       | |                                                                                 |                                            espP.tDayTitleSuffix
                    // ||       ||       ||      |       | |                                                                                 |                                            |
                    // :20100815.0648.001:\r<p>\m20100815: {preIncludeScrub1: "///ideafarm/IdeaFarm (tm)/SYSTEM/Drop Files Here To"" Archive/!ideafarm.8.2.00000000.00000001.20100815@0000.001.!.day.title.ttt" }

                    // :20100815.0648.001:\r<p>\m20100815: {preIncludeScrub1: "///ideafarm/IdeaFarm (tm)/SYSTEM/Drop Files Here To"" Archive/!ideafarm.9.2.00000000.00000001.20100815@0000.!.day.title.ttt" }

                    //EXAMPLE KT LINE: :20100113.0000.000:<p><table border=1 cellpadding=10><tr><td>\m\r20100113: {preInclude: "///d/archive/2010/!ideafarm.9.2.00000000.00000001.20100113@0000.!.control.page.title" }\m</td></tr><tr><td>Keywords:  {preInclude: "///d/archive/2010/!ideafarm.9.2.00000000.00000001.20100113@0000.!.control.page.keywords" }</td></tr><tr><td>Signs:  {preIncludeScrub1: "///d/archive/2010/!ideafarm.9.2.00000000.00000001.20100113@0000.!.control.page.signs" }</td></tr></table>

                    etherP.strFuseF( tinP , soulrFileSetsP , 

                        //CS:CODEsYNC: PSEUDODUPLICATE CODE: 360021c1 360021c1
                        espP.tc
                        +espP.tTodayLath
                        //20180424@1606: SUPPRESSED TIME WITHOUT ANALYSIS SO THAT THE LABEL IS SIMPLY THE DAY
                        //+sttDot
                        //+espP.tTimeLath
                        //20180421@1406: SUPPRESSED SEQUENCE NUMBER WITHOUT ANALYSIS SO THAT THE LABEL IS SIMPLY THE DAYTIME
                        //+sttDot
                        //+espP.tSequenceLath
                        +espP.tc
                        +espP.tDayPrefix            // THIS ENDS WITH "\\m\\r", WHICH ENDS THE PREFIX OF THE BRANCH (THE BRANCH WILL CONSIST OF tTodayLath CONCATENATED WITH ": " FOLLOWED BY THE TITLE)
                        +espP.tTodayLath
                        +
                        (
                            !espP.tDayTitleFileName.csF(tinP)
                                ? espP.tn
                                : espP.tcs+espP.tp4NotScrubbed+espP.tDayTitleFileName+espP.tDayTitleSuffix
                        )
                        +T("\\m")
                        +
                        (
                            !espP.tDayNarrativeFileName.csF(tinP)
                                ? espP.tn
                                : T("</td></tr><tr><td>Narrative:  ")+espP.tp4Scrubbed+espP.tDayNarrativeFileName+espP.tDayNarrativeSuffix
                        )
                        +
                        (
                            !espP.tDayKeywordsFileName.csF(tinP)
                                ? espP.tn
                                : T("</td></tr><tr><td>Keywords:  ")+espP.tp4Scrubbed+espP.tDayKeywordsFileName+espP.tDayKeywordsSuffix
                        )
                        +
                        (
                            !espP.tDaySignsFileName.csF(tinP)
                                ? espP.tn
                                : T("</td></tr><tr><td>Signs:  ")+espP.tp4Scrubbed+espP.tDaySignsFileName+espP.tDaySignsSuffix
                        )
                        +espP.tTocAfter
                        +espP.tcr
                        +espP.tcr
                        +espP.tcr

                    ) ;

                    if( espP.tDayKeywordsFileName.csF(  tinP ) ) espP.tDayKeywordsFileName  = espP.tn ;                                                                                                                        /*20180405@1630: NotScrubbed*/
                    if( espP.tDayNarrativeFileName.csF( tinP ) ) espP.tDayNarrativeFileName = espP.tn ;                                                                                                                        /*20151018@1623: NotScrubbed*/
                    if( espP.tDaySignsFileName.csF(     tinP ) ) espP.tDaySignsFileName     = espP.tn ;                                                                                                                        /*20180409@1513: NotScrubbed*/
                    if( espP.tDayTitleFileName.csF(     tinP ) ) espP.tDayTitleFileName     = espP.tn ;                                                                                                                        /*20151018@1623: NotScrubbed*/
                }

                espP.tTodayLath    = tToday ;
                espP.tTimeLath     = T(psttTimeToday) ;
                espP.tSequenceLath = T(psttSequence) ;
                espP.tHtmlIdLath   = T(psttHtmlIdLath) ;
                etherP.delF( tinP , psttTimeToday ) ;
                etherP.delF( tinP , psttSequence ) ;
                etherP.delF( tinP , psttHtmlIdLath ) ;
            }

            TN( tIdFrag , "" ) ;
            if( espP.tNoteFileName.csF( tinP ) )
            {
                countT idf = 1 ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                countT idHit1 = etherP.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , espP.psttTestNote , espP.tNoteFileName ) ;
                if( idHit1 && idf )
                {
                    countT idWothSuffix = idf ;

                    if( espP.tNoteFileName.csF( tinP ) >= 0x32 ) // EVERY IdFrag BEGINS WITH "i." || TIME||SEQUENCE TO ENSURE THAT idFrag VALUES ARE UNIQUE ; IT IS ILLEGAL TO EXIST MULTIPLE .!.note.* FILES FOR THE SAME TIME||SEQUENCE
                    {
                        // 0              1               2               3               4
                        // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
                        //                              |                                           OLD 7
                        //                                                  |                                           NEW 8
                        // !ideafarm.8.2.00000000.00000001.20100815@0903.002.!.note.ttt

                        // !ideafarm.9.2.00000000.00000001.20100815@0903.002.!.note.ttt

                        countT idfp = 0x21 ;
                        countT idlp = 0x31 ;
                        ZE( strokeS* , psttTimeSeq ) ;
                        etherP.strSubstringF( tinP , psttTimeSeq , idfp , idlp , espP.tNoteFileName ) ; ___( psttTimeSeq ) ;
                        etherP.strReplaceF( tinP , psttTimeSeq , 0 , T("@") , T(".") ) ; ___( psttTimeSeq ) ;
                        tIdFrag = T("i.")+T(psttTimeSeq) ; //"i." IS PREPENDED TO ENSURE HTML 4.01 COMPLIANCE (WOTH CHAR MUST NOT BE A DIGIT); WILL ALSO FACILITATE SEARCHING FOR TAGS
                        etherP.delF( tinP , psttTimeSeq ) ;
                    }

                    countT idHit2 = etherP.strIdF( tinP , idf , sttq , strokeS( '.' ) , espP.tNoteFileName ) ;
                    if( idHit2 && idf ) // idf IS CHECKED JUST BECAUSE A ZE VALUE SHOULD BE IMPOSSIBLE (SINCE FILE TYPE ".ttt" IS REQUIRED)
                    {
                        countT idLathSuffix = idHit2 - 1 ;
                        ZE( strokeS* , psttSuffix ) ;
                        etherP.strSubstringF( tinP , psttSuffix , idWothSuffix , idLathSuffix , espP.tNoteFileName ) ; ___( psttSuffix ) ;
                        tIdFrag += T(".")+T(psttSuffix) ;
                        etherP.delF( tinP , psttSuffix ) ;
                    }
                }

                if( tIdFrag.csF( tinP ) )
                {
                    //if( espP.bTrace ) etherP.traceF( tinP , T("html frag: \"")+tIdFrag+T("\"") ) ;
                    soulIdFragShortP << (strokeS*)tIdFrag ;
                    soulIdFragShortP << (strokeS*)espP.tNoteFileName ;
                    tIdFrag = T("\\h")+tIdFrag+T("\\h") ;
                    
                }
            }

            if( bNarrative ) //THIS CODE IS AN ADAPTATION OF THE CODE IN THE NEXT SNIPPET SO CONTAINS UNNECESSARY STUFF
            {
                TN( tFileNameSet , "" ) ;
                {
                    TN( tComma , "," ) ;
                    while( stSetP )
                    {
                        ZE( strokeS* , psttFileName ) ;
                        stSetP >> psttFileName ;
        
                        //etherP.traceF( tinP , T("\r\n      emit [set,name]: ")+T(psttSetP)+T("    \"")+T(psttFileName)+T("\"") ) ;

                                     tFileNameSet += T(psttFileName) ;
                        if( stSetP ) tFileNameSet += tComma ;

                        etherP.delF( tinP , psttFileName ) ;
                    }
                }
                //if( espP.bTrace ) etherP.traceF( tinP , T("emitSetF [file,file,...]: ")+tFileNameSet ) ;

                strokeS sttDot( '.' ) ;
                TN( tEntry , "" ) ; tEntry =

                    espP.tBar+espP.tcr
                    +espP.tb1+espP.tEnd+espP.tcr
                    +
                    (
                        ( espP.tNoteFileName.csF( tinP ) || bNarrative )
                            ? (bDisplayTime?espP.tb2:espP.tb1)+(bNarrative?espP.tp4Scrubbed:espP.tp4NotScrubbed)+tFileNameSet+espP.tp5+espP.tcr
                            : tTitle.csF( tinP )
                                ? espP.tb1+tTitle+espP.tcr
                                : espP.tn
                    )

                    +espP.tb1+espP.tp3+(bDisplayTime?T("<span id=\"go.")+espP.tHtmlIdLath+T("\">")+tTime+T("</span>")+(tTitle.csF(tinP)||tNarrativePrefix.csF(tinP)?espP.tcs:espP.tc):espP.tn)+tNarrativePrefix+espP.tcr
                    +(bImage?espP.tb2+espP.tp2jpg+espP.tcr:espP.tn)
                    +espP.tb1+espP.tBegin+espP.tMark/*+espP.tCloudPath*/+espP.tIconTranscript+espP.tMark+espP.tp1+espP.tcr
                    +(!tIdFrag.csF(tinP)?espP.tn:espP.tb1+tIdFrag+espP.tcr)
                    +espP.tcr

                ;

                //U::TO FIND A BUG
                //LOGrAW( "\r\n--------------------------------------------- BEGIN 1 ------------------------------------------------------------------------\r\n" ) ;
                //LOGrAW( tEntry ) ;
                //LOGrAW( "\r\n--------------------------------------------- END 1 --------------------------------------------------------------------------\r\n" ) ;

                etherP.strFuseF( tinP , soulrFileSetsP , tEntry ) ;
            }
            else if( espP.tMark.csF( tinP ) )
            {
                TN( tFileNameSet , "" ) ;
                {
                    TN( tYear , "" ) ;
                    TN( tComma , "," ) ;
                    while( stSetP )
                    {
                        ZE( strokeS* , psttFileName ) ;
                        stSetP >> psttFileName ;
        
                        if( !tYear.csF( tinP ) )
                        {
                            ZE( strokeS* , psttYear ) ;                                                                     //                                1               2               3               4               5               6               7
                            countT idf = 0x21 ;                                                                             //                 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
                            countT idl = 0x24 ;                                                                             //                             yyyy                                                                                                      OLD 7
                                                                                                                            //                                                 yyyy                                                                                                      NEW 8
                            etherP.strSubstringF( tinP , psttYear , idf , idl , psttFileName ) ; ___( psttYear ) ;          // FORMAT EXAMPLE: !ideafarm.8.2.00000000.00000001.19991231@1211.20170130@2228.001.afaa979fbcc5e521b59359026aaaf90a.00000001.data.pdf
                                                                                                                            // FORMAT EXAMPLE: !ideafarm.9.2.00000000.00000001.19991231@1211.20170130@2228.afaa979fbcc5e521b59359026aaaf90a.001.data.pdf

                            countT year = etherP.strDigitsToSCountF( tinP , psttYear , 0xa , 1 ) ;

                            tYear =  year <= 1999
                                ? T("1999")
                                : year <= 2008
                                    ? T("2008")
                                    : T(psttYear)
                            ;
                            etherP.delF( tinP , psttYear ) ;
                        }

                        //if( espP.bTrace ) etherP.traceF( tinP , T("\r\n      emit [set,name]: ")+T(psttSetP)+T("    \"")+T(psttFileName)+T("\"") ) ;

                                     tFileNameSet += tYear+espP.tSlash+T(psttFileName) ;
                        if( stSetP ) tFileNameSet += tComma ;

                        etherP.delF( tinP , psttFileName ) ;
                    }
                }

                strokeS sttDot( '.' ) ;
                TN( tEntry , "" ) ; tEntry =

                    espP.tBar+espP.tcr
                    +espP.tb1+espP.tEnd+espP.tcr
                    +
                    (
                        espP.tNoteFileName.csF( tinP )
                            ? (bDisplayTime?espP.tb2:espP.tb1)+espP.tp4NotScrubbed+espP.tNoteFileName+espP.tp5+espP.tcr
                            : tTitle.csF( tinP )
                                ? espP.tb1+tTitle+espP.tcr
                                : espP.tn
                    )
                    +espP.tb1+espP.tp3+(bDisplayTime?T("<span id=\"go.")+espP.tHtmlIdLath+T("\">")+tTime+T("</span>"):espP.tn)+(tTitle.csF(tinP)?espP.tcs:espP.tc)+espP.tcr
                    +(bImage?espP.tb2+espP.tp2jpg+espP.tcr:espP.tn)
                    +espP.tb1+espP.tBegin+espP.tMark/*+espP.tCloudPath*/+tFileNameSet+espP.tMark+espP.tp1+espP.tcr
                    +(!tIdFrag.csF(tinP)?espP.tn:espP.tb1+tIdFrag+espP.tcr)
                    +espP.tcr

                ;

                //U::TO FIND A BUG
                //LOGrAW( "\r\n--------------------------------------------- BEGIN 2 ------------------------------------------------------------------------\r\n" ) ;
                //LOGrAW( tEntry ) ;
                //LOGrAW( "\r\n--------------------------------------------- END 2 --------------------------------------------------------------------------\r\n" ) ;

                etherP.strFuseF( tinP , soulrFileSetsP , tEntry ) ;
            }
            espP.tNoteFileName = espP.tMark = espP.tn ;
        }

        //if( espP.bTrace ) etherP.traceF( tinP , T("------------------------------------------------------ emitSetF/- [psttSetP,tNoteFileName]: ")+T(psttSetP)+T("    \"")+espP.tNoteFileName+T("\"") ) ;
    }

    while( stSetP )
    {
        ZE( strokeS* , psttFileName ) ;
        stSetP >> psttFileName ;
        etherP.delF( tinP , psttFileName ) ;
    }
}

byteT pbBuffer[ TUCK ] ;
byteT pbBufferCopy[ TUCK ] ;
countT walkCloudViewSettingsCBF( tinS& tinP , countT& cArg1P , countT& cArg2P )
{
    strokeS*&     psttzLeverCloudP =     *(strokeS**)(&cArg2P)[ 1 ] ;
    switchStackC& swsSettingsP     = *(switchStackC*)(&cArg2P)[ 2 ] ;

    thirdC::c_memsetIF( tinP , pbBufferCopy , sizeof pbBufferCopy ) ;

    for( countT offr = 0 ; pbBuffer[ offr ] ; offr ++ ) pbBufferCopy[ offr ] = reverseBitsF( pbBuffer[ offr ] ) ;

    osTextT postHey[] = "!cloudview." ;
    if( thirdC::c_strstrIF( tinP , pbBufferCopy , postHey ) )
    {
        osTextT* postc = pbBufferCopy + sizeof postHey - 1 ;
        osTextT* poste = thirdC::c_strrchrIF( tinP , postc , '.' ) ;
        *( poste ++ ) = 0 ;
    
        TN( tCloud , postc ) ;
        ZE( strokeS* , psttKey ) ;
        tinP.pEther->strMakeFromOsTextF( tinP , psttKey , poste ) ; ___( psttKey ) ;
    
        psttzLeverCloudP = tCloud ;
        ZE( countT , ids ) ;
        swsSettingsP.sinkF( tinP , ids , psttKey , flSTACKsINK_UNIQUE ) ;
        __Z( ids ) ; // NONUNIQUENESS IS IMPOSSIBLE BECAUSE bitTreeC IS USED TO STORE THE SETTINGS KEYS AND VALUES
    }

    return 0 ;
}

/*1*/countT etherC::etherSoilF( tinS& tinP , const boolT& bQuitP , soulC& soulOutP , soulC& soulInP , const countT idModeP , const strokeS* const psttKeyP , const flagsT flagsP , const osTextT* const postSourceP , const countT costSourceP )/*1*/
{
    boolT bTrace = idModeP == ifcIDmODEeTHERsOIL_REPORT /*|| idModeP == ifcIDmODEeTHERsOIL_LINT*/ ;
    /**/if( bTrace ) traceF( tinP , T("etherSoilF / entering (validating each field of soulInP)") ) ;
    //bTrace = 1 ; //U:: TO FIND A BUG

    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( soulOutP ) ;
        __Z( soulInP ) ;
        __Z( idModeP ) ;
        FV( flETHERsOILf , flagsP ) ;
        if( POOP ) return 0 ;
        countT cFieldsIn = soulInP ;
        for( countT idFieldIn = 1 ; idFieldIn <= cFieldsIn ; idFieldIn ++ )
        {
            {
                countT cRemain = cFieldsIn - idFieldIn ;
                /**/if( /* bTrace && */ !( cRemain % ( TUCK << 4 ) ) ) traceF( tinP , T("etherSoilF / entering (validating each field of soulInP) ; ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" fields remain") ) ;
            }

            ZE( countT , idTypeIn ) ;
            ZE( flagsT , flagsIn  ) ;
            ZE( countT , cbIn     ) ;
            byteT* pbzEncoded = soulInP.pbFieldF( tinP , idTypeIn , flagsIn , cbIn , idFieldIn ) ;
            __( idTypeIn - ifcIDtYPEsOULiTEM_strokeSptr ) ;
            __( flagsIn - flSOULiTEM_null ) ;
            __( !cbIn ) ;
        }
        if( POOP ) return 0 ;
    }

    _IO_

    //switch( idModeP )
    //{
    //    case ifcIDmODEeTHERsOIL_PREPAREsOURCE                    : { LOGrAW( "etherSoilF / PREPAREsOURCE   /+\r\n" ) ; strokeF( tinP , T("etherSoilF / PREPAREsOURCE   /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_NATIVEfROMaSCII                  : { LOGrAW( "etherSoilF / NATIVEfROMaSCII /+\r\n" ) ; strokeF( tinP , T("etherSoilF / NATIVEfROMaSCII /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE                  : { LOGrAW( "etherSoilF / ASCIIfROMnATIVE /+\r\n" ) ; strokeF( tinP , T("etherSoilF / ASCIIfROMnATIVE /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_LINT                             : { LOGrAW( "etherSoilF / LINT            /+\r\n" ) ; strokeF( tinP , T("etherSoilF / LINT            /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_TRIM                             : { LOGrAW( "etherSoilF / TRIM            /+\r\n" ) ; strokeF( tinP , T("etherSoilF / TRIM            /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_REPORT                           : { LOGrAW( "etherSoilF / REPORT          /+\r\n" ) ; strokeF( tinP , T("etherSoilF / REPORT          /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_QUERYvALUES                      : { LOGrAW( "etherSoilF / QUERYvALUES     /+\r\n" ) ; strokeF( tinP , T("etherSoilF / QUERYvALUES     /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_DO                               : { LOGrAW( "etherSoilF / DO              /+\r\n" ) ; strokeF( tinP , T("etherSoilF / DO              /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_DOdEBUG                          : { LOGrAW( "etherSoilF / DOdEBUG         /+\r\n" ) ; strokeF( tinP , T("etherSoilF / DOdEBUG         /+\r\n") ) ; break ; }
    //    default                                                  : { LOGrAW( "etherSoilF / ?               /+\r\n" ) ; strokeF( tinP , T("etherSoilF / ?               /+\r\n") ) ; break ; }
    //}

    /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1") ) ;

    TN( tcr , "\r\n" ) ;
    TN( tb , " " ) ;
    soulC soulOut( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.out" ) ;
    ZE( countT , cFlag1 ) ;
    ZE( boolT  , bRepeat ) ;
    switch( idModeP )
    {
        case ifcIDmODEeTHERsOIL_PREPAREsOURCE :
        {
            /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_PREPAREsOURCE / +") ) ;
            // PREPARE SOURCE
            //
            // SYNTAX (CONVENTION: ALL SOURCE PREPARATION KEYS BEGIN WITH "pre"
            //
            // SPECIFICATION                                                    EXAMPLES
            //
            // {preInclude: [fileName] }
            // {preIncludeScrub1: [fileName] }
            //                                                                  {preInclude: ///c" "/tmp/fooey }
            //                                                                  {preInclude: "///c" "/tmp/fooey gooey" }
            // 
            // {preInclude: [fileName] } is replaced with the contents of the file, which is interpreted as a string of osTextT.
            // If the file contains "\r\n" and "{preInclude:" occurs at column I of its line, then I-1 indentation spaces are appended to each occurance of "\r\n".
            // Multiple {preInclude: [fileName] } instances can occur on the same line either adjacently or separated by spaces or any other osTextT value.
            //U:: Future: Replacement is recursive and will continue until there are no more occurances of {preInclude: [fileName] }
            // 
            // "{preInclude:" AND "{preIncludeScrub1:" HAVE THE SAME EFFECT EXCEPT THAT THE LATTER KEY CAUSES THE INCLUDED CONTENT TO BE "SCRUBBED" I.E. EDITED AS FOLLOWS:
            //
            // SCRUBBING
            //
            //  preIncludeScrub1:  IF THE FIRST NONBLANK CHARACTER IS ':' THEN LEADING ' ' AND ':' ARE ELIMINATED
            //   20140827@0931:  THIS WAS ADDED TO SUPPORT INCLUDED TEXT THAT IS OBTAINED PROGRAMMATICALLY FROM VOICE-TO-TEXT OUTPUT THAT MIGHT CONTAIN UTTERANCES THAT CONSTITUTE KT SYNTAX OR SEMANTICS ERRORS
            //


            // RECIPE
            // 
            // FOR EACH PIECE IN soulInP
            //  WHILE FIND A SYNTACTICALLY CORRECT PREPROCESSOR ELEMENT OR A POSSIBLE PARTIAL WO AT THE END
            //   EMIT THE SNIP THAT I SKIPPED OVER TO GET TO IT
            //   IF IT IS COMPLETE THEN EMIT ITS VALUE WITH INDENTATION ADDED
            //   ELSE STORE ITS PARTIAL SYNTAX FOR DEFERRED EMISSION
            //  EMIT THE FINAL SNIP THAT I SKIPPED OVER TO GET TO THE END OF THE PIECE
            // 

            // RECIPE
            // 
            // FOR EACH PIECE IN soulInP
            //  WHILE FIND SYNTACTICALLY CORRECT PREPROCESSOR ELEMENT
            //   EMIT THE SNIP THAT PRECEEDED IT
            //   PROCESS IT
            //  EMIT ANY REMAINING SNIP
            // 

            // I WILL SET cFlag1 TO THE NUMBER OF REPLACEMENTS THAT I MAKE
            // THE CALLER SHOULD CALL ME REPEATEDLY UNTIL I RETURN 0

            TN( tKeyPreInclude       , "preInclude:"       ) ; // THESE VALUES ARE NONCONFORMANT IN THAT THEY INCLUDE THE COLON THAT DELIMITS KEYS IN THE SOURCE
            TN( tKeyPreIncludeScrub1 , "preIncludeScrub1:" ) ; // THESE VALUES ARE NONCONFORMANT IN THAT THEY INCLUDE THE COLON THAT DELIMITS KEYS IN THE SOURCE
            textC* pptFind[] =
            {
                &tKeyPreInclude       ,
                &tKeyPreIncludeScrub1
            } ;

            //LOGrAW( "etherSoilF / PREPAREsOURCE / F\r\n" ) ;
            TN( tKeyObeyPreInclude       , "{preInclude"       ) ; // THIS VALUE IS NONCONFORMANT IN THAT IT INCLUDES THE '{' THAT BEGINS THE ELEMENT
            TN( tKeyObeyPreIncludeScrub1 , "{preIncludeScrub1" ) ; // THIS VALUE IS NONCONFORMANT IN THAT IT INCLUDES THE '{' THAT BEGINS THE ELEMENT
            TN( tMaybeElement , "" ) ;
            strokeS sttColon( ':' ) ;
            strokeS sttClose( '}' ) ;
            if( F(flagsP) & flETHERsOILf_CONSUMEiNPUT )
            {
                /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_PREPAREsOURCE / flETHERsOILf_CONSUMEiNPUT / +") ) ;
                ZE( strokeS* , psttElementLag ) ;
                ZE( countT , csttDone ) ;
                ZE( countT , csttIndent ) ;              // csttIndent IS UPDATED WHENEVER STROKES ARE SHIFTED INTO soulOutP
                while( soulInP && !bQuitP )
                {
                    {
                        countT cRemain = soulInP ;
                        ///**/ if( /*bTrace &&*/ !( cRemain % ( TUCK << 4 ) ) ) traceF( tinP , T("etherSoilF / preparing source [soulInP]: ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" fields remain") ) ;
                                                                                traceF( tinP , T("etherSoilF / preparing source [soulInP]: ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" fields remain") ) ;
                    }

                    //LOGrAW3( "PREPAREsOURCE [soulInP]: " , soulInP , "\r\n" ) ;
                    ZE( strokeS* , psttp ) ;
                    soulInP >> psttp ; ___( psttp ) ;

                    //traceF( tinP , T("piece: >>>>")+T(psttp)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG

                    const countT csttNow = psttp->idAdam ;
                    //LOGrAW( "etherSoilF / PREPAREsOURCE / E\r\n" ) ;

                    if( psttElementLag )
                    {
                        //LOGrAW( "etherSoilF / PREPAREsOURCE / D\r\n" ) ;
                        strokeS* psttd = psttp ;
                                         psttp = 0 ;
                        strMakeF( tinP , LF , psttp , psttElementLag , psttd->idAdam ) ; ___( psttp ) ;
                        delF( tinP , psttElementLag ) ;
                        strFuseF( tinP , psttp , psttd ) ;
                        delF( tinP , psttd ) ;
                        //LOGrAW( "etherSoilF / PREPAREsOURCE / C\r\n" ) ;
                    }

                    countT idfNextOut = 1 ;
                    {
                        //LOGrAW( "etherSoilF / PREPAREsOURCE / B\r\n" ) ;
                        ZE( countT , idfElement ) ;
                        ZE( countT , idlElement ) ;
                        countT idf = 1 ;
    
                        ZE( countT , idLoop ) ;
                        while( !bQuitP && idf && ( findElementF( tinP , *this , idfElement , idlElement , psttp , idf , pptFind , sizeof pptFind / sizeof pptFind[ 0 ] ) , idfElement ) )
                        {
                            /**/if( /*bTrace &&*/ !( ++ idLoop % TUCK ) ) traceF( tinP , T("etherSoilF / preparing source / finding Elements [idLoop]: ")+TF2(idLoop,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" fields remain") ) ;

                            //LOGrAW( "etherSoilF / PREPAREsOURCE / A\r\n" ) ;
                            if( idfNextOut < idfElement )
                            {
                                //LOGrAW( "etherSoilF / PREPAREsOURCE / z\r\n" ) ;
                                countT idf2 = idfNextOut ;
                                countT idl2 = idfElement - 1 ;
                                if( idl2 )
                                {
                                    idfNextOut  = psttp->idAdam > idlElement ? idlElement + 1 : 0 ;
                                    ZE( strokeS* , psttSnip ) ;
                                    strSubstringF( tinP , psttSnip , idf2 , idl2 , psttp ) ; ___( psttSnip ) ;

                                    //strokeF( tinP , T("before: >>>>")+T(psttSnip)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG

                                    //traceF( tinP , T("out01: >>>>")+T(psttSnip)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                                    soulOutP << psttSnip ; //************************************************************************************************************
                                    UPD8INDENT( csttIndent , psttSnip )
                                    delF( tinP , psttSnip ) ;
                                }
                                //LOGrAW( "etherSoilF / PREPAREsOURCE / y\r\n" ) ;
                            }
    
                            //LOGrAW( "etherSoilF / PREPAREsOURCE / x\r\n" ) ;
                            ZE( strokeS* , psttElement ) ;
                            if( idfElement )
                            {
                                //LOGrAW( "etherSoilF / PREPAREsOURCE / w\r\n" ) ;
                                countT idfe = idfElement ;
                                countT idle = idlElement ;
                                strSubstringF( tinP , psttElement , idfe , idle , psttp ) ; ___( psttElement ) ;

                                //strokeF( tinP , T("element (full or part): >>>>")+T(psttElement)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG

                                //LOGrAW( "etherSoilF / PREPAREsOURCE / v\r\n" ) ;
                            }

                            //LOGrAW( "etherSoilF / PREPAREsOURCE / u\r\n" ) ;
                            if( psttElement )
                            {
                                //LOGrAW( "etherSoilF / PREPAREsOURCE / t\r\n" ) ;
                                //LOGrAW( "etherSoilF / PREPAREsOURCE / s\r\n" ) ;
                                if( idlElement ) // IF I HAVE A COMPLETE ELEMENT OF THE FORM "{preInclude: [fileName] }"
                                {
                                    //LOGrAW( "etherSoilF / PREPAREsOURCE / r\r\n" ) ;
                                    ZE( strokeS* , psttok ) ;
                                    countT idfok = 1 ;
                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                    strSubstringF( tinP , psttok , idfok , sttq , sttColon , psttElement ) ; ___( psttok ) ;
    
                                    //strokeF( tinP , T("okelement: >>>>")+T(psttok)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG

                                    //LOGrAW( "etherSoilF / PREPAREsOURCE / q\r\n" ) ;
                                    if
                                    (
                                        !strCompareF( tinP , psttok , tKeyObeyPreInclude )
                                        ||
                                        !strCompareF( tinP , psttok , tKeyObeyPreIncludeScrub1 )
                                    )
                                    {
                                        //LOGrAW( "etherSoilF / PREPAREsOURCE / p\r\n" ) ;
                                        if( idfok )
                                        {
                                            //LOGrAW( "etherSoilF / PREPAREsOURCE / o\r\n" ) ;
                                            ZE( strokeS* , psttv ) ;
                                            strSubstringF( tinP , psttv , idfok , sttq , sttClose , psttElement ) ; ___( psttv ) ;
                                            if( psttv && psttv->idAdam )
                                            {
                                                //LOGrAW( "etherSoilF / PREPAREsOURCE / n\r\n" ) ;
                                                strTrimF( tinP , psttv , 0 , 0 , T(TbLACK "\"")  ) ; ___( psttv ) ;
                                                //traceF( tinP , T("include: ")+T(psttv) ) ;
    
                                                IFsCRATCH
                                                {
                                                    cFlag1 ++ ;

                                                    //LOGrAW( "etherSoilF / PREPAREsOURCE / m\r\n" ) ;
                                                    SCOOPS

                                                    // PUSH INPUT LINES INTO soulOutP WITHOUT INPUT CAPACITY CONSTRAINT
                                                    // GOALS
                                                    //  NO LIMIT TO LINE LENGTH
                                                    //  NO LIMIT TO NUMBER OF LINES
                                                    //  NO LIMIT TO TOTAL SIZE OF INPUT
                                                    // 
                                                    // APPROACH: USE AN OO POWER EXPANDABLE BUFFER TO READ UNTIL RECEIVE AN END OF LINE
                                                    //  THIS CAN BE DONE USING arrayC
                                                    // 

                                                    fileC inFile( tinP , psttv ) ;
                                                    ZE( countT , cbFileLo ) ;
                                                    ZE( countT , cbFileHi ) ;
                                                    {
                                                        ZE( infoFileS* , pInfo ) ;
                                                        diskFileQueryF( tinP , pInfo , inFile ) ;
                                                        cbFileLo = pInfo->cbUsed ;
                                                        cbFileHi = pInfo->cbUsedHigh ;
                                                        DEL( pInfo ) ;
                                                    }

                                                    const countT cbaBuffer = ( cbFileHi || cbFileLo > TOCK ? TOCK : cbFileLo ) + 1 ; // ALLOCATE FOR A TRAILING NULL THAT IS PATCHED IN

                                                    arrayC aBuffer( tinP , 1 , cbaBuffer ) ;
                                                    aBuffer[ cbaBuffer - 1 ] ; // TOUCH THE LATH BYTE TO STIMULATE REALLOCATION IF NEEDED

                                                    ZE( strokeS* , psttPad ) ;
                                                    {
                                                        strokeS* psttzb = tb ;
                                                        strMakeF( tinP , LF , psttPad , 0 , csttIndent ) ; ___( psttPad ) ;
                                                        countT cDo = csttIndent ;
                                                        while( cDo -- ) strFuseF( tinP , psttPad , psttzb ) ;
                                                    }

                                                    TN( tb , " " ) ;
                                                    countT cbDoLo = cbFileLo ;
                                                    countT cbDoHi = cbFileHi ;
                                                    ZE( countT , cbBuffered ) ;
                                                    ZE( boolT , bDelimiterSeen ) ;
                                                    ZE( boolT , bDelimiterLath ) ;
                                                    ZE( countT , csttLathText ) ;
                                                    while( cbDoLo || cbDoHi || cbBuffered )  // EACH ITERATION EMITS WO SNIP (EITHER TEXT OR NEWLINE+PAD) TO soulOutP
                                                    {
                                                        if( bQuitP ) break ;

                                                        // ------------------------------------------------------
                                                        // FILL THE BUFFER TO THE TOP (IF IT IS NOT ALREADY FULL)
                                                        // ------------------------------------------------------

                                                        osTextT* postBuffer = (osTextT*)(const osTextT*)aBuffer ;
                                                        countT cbRead = cbaBuffer - 1 - cbBuffered ; // THE HIGH BYTE IS RESERVED FOR A PATCHED NULL
                                                        if( !cbDoHi && cbRead > cbDoLo ) cbRead = cbDoLo ;

                                                        if( cbRead )
                                                        {
                                                            countT cbWant = cbRead ;
                                                            fileReadF( tinP , postBuffer + cbBuffered , cbWant , inFile ) ;
                                                            __( cbWant - cbRead ) ;
                                                            cbBuffered += cbWant ;

                                                            countT cbDoLoWas = cbDoLo ;
                                                            cbDoLo -= cbRead ;
                                                            if( cbDoLo > cbDoLoWas ) cbDoHi -- ;
                                                        }

                                                        // -------------------------------------------------------------------
                                                        // FIND THE END OF THE SNIP THAT BEGINS AT THE BEGINNING OF THE BUFFER
                                                        // -------------------------------------------------------------------

                                                        boolT bDelimiter = postBuffer[ 0 ] == '\r' || postBuffer[ 0 ] == '\n' ;
                                                        if( !bDelimiterSeen && bDelimiter ) bDelimiterSeen = 1 ;

                                                        countT offEnd = 1 ;
                                                        if( bDelimiter ) while( offEnd < cbBuffered && ( postBuffer[ offEnd ] == '\r' || postBuffer[ offEnd ] == '\n' ) ) offEnd ++ ;
                                                        else             while( offEnd < cbBuffered &&   postBuffer[ offEnd ] != '\r' && postBuffer[ offEnd ] != '\n'   ) offEnd ++ ;

                                                        if
                                                        (
                                                            offEnd == cbBuffered                // DIDN'T FIND AN EOL IN THE BUFFER
                                                            &&
                                                            ( cbDoHi || cbDoLo )                // THERE'S MORE INPUT
                                                        )
                                                        { BLAMMO ; } //U::EDIT TO EXAPAND THE BUFFER AND ITERATE

                                                        if( !bDelimiter || offEnd < cbBuffered ) // IF NOT THE TRAILING DELIMITER (IF ANY)
                                                        {
                                                            // --------------------------------------------
                                                            // EMIT THE SNIP AT THE BEGINNING OF THE BUFFER
                                                            // --------------------------------------------

                                                            osTextT ostSave = postBuffer[ offEnd ] ;
                                                                              postBuffer[ offEnd ] = 0 ;

                                                            ZE( countT , costSkip ) ;
                                                            if( !bDelimiter && !strCompareF( tinP , psttok , tKeyObeyPreIncludeScrub1 ) )
                                                            {
                                                                // THIS IS DONE TO PREVENT VOICE TO TEXT TRANSCRIPTIONS FROM PRESENTING INVALID OR UNINTENDED CONTROL INPUT TO THE KT PARSER
                                                                // SMUDGE LEADING COLON ':' AND SKIP LEADING BLANKS
                                                                {
                                                                    boolT bLeadingBlanks = 1 ;
                                                                    ZE( boolT , bColonDone  ) ;
                                                                    ZE( countT , offi ) ;
                                                                    for( ; postBuffer[ offi ] ; offi ++ )
                                                                    {
                                                                        switch( postBuffer[ offi ] )
                                                                        {
                                                                            case ' '  : { if( bLeadingBlanks ) costSkip ++ ; break ; }

                                                                            case ':'  : { if( !bColonDone ) { postBuffer[ offi ] = '$' ; bColonDone = 1 ; } break ; }

                                                                            //CS:CODEsYNC: 360021c1 360021c1
                                                                            case '\\' :
                                                                            case '{'  :
                                                                            case '}'  :
                                                                            case '['  :
                                                                            case ']'  :
                                                                            case '|'  : {                     postBuffer[ offi ] = '$' ;                    break ; }

                                                                            default   : {                                                                   break ; }
                                                                        }

                                                                        if(  bLeadingBlanks &&                postBuffer[ offi ] != ' ' ) bLeadingBlanks = 0 ;
                                                                        if( !bLeadingBlanks && !bColonDone && postBuffer[ offi ] != ':' ) bColonDone     = 1 ;
                                                                    }
                                                                }
                                                            }

                                                            ZE( strokeS* , psttLine ) ;
                                                            strMakeFromOsTextF( tinP , psttLine , postBuffer + costSkip ) ; ___( psttLine ) ;
                                                            postBuffer[ offEnd ] = ostSave ;

                                                            if( !bDelimiter )                                                // IF NOT DELIMITER (CRLF)
                                                            {
                                                                csttLathText = psttLine->idAdam ;
                                                                soulOutP << psttLine ;
                                                                //traceF( tinP , T("out02: >>>>")+T(psttLine)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                                                            }
                                                            else if( !strCompareF( tinP , psttok , tKeyObeyPreInclude ) )    // ELSE IF NOT SCRUBBING
                                                            {
                                                                soulOutP << psttLine ;
                                                                soulOutP << psttPad ;
                                                                //traceF( tinP , T("out03: >>>>")+T(psttLine)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                                                                //traceF( tinP , T("out04: >>>>")+T(psttPad)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                                                            }
                                                            else
                                                            {
                                                                soulOutP << (strokeS*)tb ;                                  // ELSE EMIT BLANK INSTEAD OF CRLF
                                                                //traceF( tinP , T("out05: >>>>")+tb+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                                                            }

                                                            delF( tinP , psttLine ) ;
                                                        }

                                                        // -----------------------------------------------
                                                        // SHIFT LEFT THE REMAINING CONTENTS OF THE BUFFER
                                                        // -----------------------------------------------

                                                        if( offEnd >= sizeof( countT ) )
                                                        {
                                                            thirdC::c_memcpyIF( tinP , postBuffer , postBuffer + offEnd , cbBuffered - offEnd ) ; // CANNOT BE USED TO MOVE SMALL DISTANCES OR TO BE MOVED "UPWARD" WITHIN OVERLAPPING MEMORY BUFFERS
                                                        }
                                                        else
                                                        {
                                                            countT cbDo = cbBuffered - offEnd ;
                                                            for( countT offo = 0 ; offo < cbDo ; offo ++ ) postBuffer[ offo ] = postBuffer[ offo + offEnd ] ;
                                                        }

                                                        cbBuffered -= offEnd ;
                                                        bDelimiterLath = bDelimiter ;
                                                    }
                                                    delF( tinP , psttPad ) ;

                                                    //UPDATE csttIndent
                                                    if( bDelimiterSeen ) csttIndent  = csttLathText ;
                                                    else                 csttIndent += csttLathText ;

                                                    idfNextOut = idlElement < psttp->idAdam ? idlElement + 1 : 0 ;
                                                }
                                                //LOGrAW( "etherSoilF / PREPAREsOURCE / f\r\n" ) ;
                                            }
                                            delF( tinP , psttv ) ;
                                            //LOGrAW( "etherSoilF / PREPAREsOURCE / e\r\n" ) ;
                                        }
                                        //LOGrAW( "etherSoilF / PREPAREsOURCE / d\r\n" ) ;
                                    }
                                    delF( tinP , psttok ) ;
                                    delF( tinP , psttElement ) ;
                                    //LOGrAW( "etherSoilF / PREPAREsOURCE / c\r\n" ) ;
                                }
                                else
                                {
                                    //LOGrAW( "etherSoilF / PREPAREsOURCE / b\r\n" ) ;
                                    idfNextOut = 0 ;
                                    delF( tinP , psttElementLag ) ;  // WILL SILENTLY DISCARD PART OF AN ELEMENT THAT SPANS THREE PIECES, WHICH SHOULD BE IMPOSSIBLE (MAKE THE PIECES LARGER THAN THE LARGEST POSSIBLE LEGAL ELEMENT)
                                    psttElementLag = psttElement ;
                                                     psttElement = 0 ;
                                    //LOGrAW( "etherSoilF / PREPAREsOURCE / a\r\n" ) ;
                                }
                            }
                            //LOGrAW( "etherSoilF / PREPAREsOURCE / 9\r\n" ) ;

                            idlElement = idfElement = 0 ;
                        }
                    }

                    //LOGrAW( "etherSoilF / PREPAREsOURCE / 8\r\n" ) ;
                    if( idfNextOut )
                    {
                        //LOGrAW( "etherSoilF / PREPAREsOURCE / 7\r\n" ) ;
                        countT idf2 = idfNextOut ;
                        ZE( countT , idl2 ) ;
                        ZE( strokeS* , psttSnip ) ;
                        strSubstringF( tinP , psttSnip , idf2 , idl2 , psttp ) ; ___( psttSnip ) ;
                        soulOutP << psttSnip ; //************************************************************************************************************
                        //traceF( tinP , T("out06: >>>>")+T(psttSnip)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                        UPD8INDENT( csttIndent , psttSnip )
                        delF( tinP , psttSnip ) ;
                        //LOGrAW( "etherSoilF / PREPAREsOURCE / 6\r\n" ) ;
                    }

                    //LOGrAW( "etherSoilF / PREPAREsOURCE / 5\r\n" ) ;
                    delF( tinP , psttp ) ;
                    csttDone += csttNow ;
                }

                //LOGrAW( "etherSoilF / PREPAREsOURCE / 4\r\n" ) ;
                if( psttElementLag )
                {
                    //LOGrAW( "etherSoilF / PREPAREsOURCE / 3\r\n" ) ;
                    soulOutP << psttElementLag ; //************************************************************************************************************
                    //traceF( tinP , T("out07: >>>>")+T(psttElementLag)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                    //NOT NEEDED SINCE I AM DONE: UPD8INDENT( csttIndent , psttElementLag )
                    delF( tinP , psttElementLag ) ;
                    //LOGrAW( "etherSoilF / PREPAREsOURCE / 2\r\n" ) ;
                }
                //LOGrAW( "etherSoilF / PREPAREsOURCE / 1\r\n" ) ;
            }
            //LOGrAW( "etherSoilF / PREPAREsOURCE / 0\r\n" ) ;

            break ;
        }
        case ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE :
        case ifcIDmODEeTHERsOIL_NATIVEfROMaSCII :
        {
            /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / +") ) ;
            // ASCII TO NATIVE
            //
            //      BEFORE      AFTER
            //
            //      {           m1
            //      }           m2
            //      \[space]    m3
            //
            //      \\          \        x
            //      \{          {
            //      \}          }
            //

            //CS:CODEsYNC: 360021c1 360021c1
            // RESERVED STROKES (THESE STROKE VALUES CONTROL THE INTERPRETATION OF IdeaFarm (tm) SOIL INPUT
            TN( tb    , "\\"    ) ;
            TN( to    , "{"    ) ;
            TN( tc    , "}"    ) ;
            TN( tos   , "["    ) ;
            TN( tcs   , "]"    ) ;
            TN( tBar  , "|"    ) ;
            // END OF RESERVED STROKES
            
            TN( tbb   , "\\\\" ) ;
            TN( tbo   , "\\{"  ) ;
            TN( tbc   , "\\}"  ) ;
            TN( tbos  , "\\["  ) ;
            TN( tbcs  , "\\]"  ) ;
            TN( tbs   , "\\ "  ) ;
            TN( tbBar , "\\|"  ) ;
            TN( tm1   , ""     ) ; tm1 = T("")+S2(0x01,sc_MARK) ;
            TN( tm2   , ""     ) ; tm2 = T("")+S2(0x02,sc_MARK) ;
            TN( tm3   , ""     ) ; tm3 = T("")+S2(0x03,sc_MARK) ;
            TN( tm4   , ""     ) ; tm4 = T("")+S2(0x04,sc_MARK) ;
            TN( tm5   , ""     ) ; tm5 = T("")+S2(0x05,sc_MARK) ;
            TN( tm6   , ""     ) ; tm6 = T("")+S2(0x06,sc_MARK) ;
            TN( tm7   , ""     ) ; tm7 = T("")+S2(0x07,sc_MARK) ;
            TN( tm8   , ""     ) ; tm8 = T("")+S2(0x08,sc_MARK) ;
            TN( tm9   , ""     ) ; tm9 = T("")+S2(0x09,sc_MARK) ;
            TN( tma   , ""     ) ; tma = T("")+S2(0x0a,sc_MARK) ;
            TN( tmb   , ""     ) ; tmb = T("")+S2(sa_MARKsYSTEMbREAK,sc_MARKsYSTEM) ; //BREAK      : tBar  -> tmb
            TN( tmc   , ""     ) ; tmc = T("")+S2(0x0c,sc_MARK) ; //LITERAL BAR: tbBar -> tmc

            /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / 2") ) ;
            soulC soult1( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.t1" ) ;
            strFuseF( tinP , soult1 , soulInP , 0 , S1C( '\\' ) , T("[]") ) ; //U::ADD THIS API TO etherC

            boolT bNative = idModeP == ifcIDmODEeTHERsOIL_NATIVEfROMaSCII ;

            //LOGrAW( "ASCIIfROMnATIVE or NATIVEfROMaSCII\r\n" ) ;
            /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / 1") ) ;
            while( !bQuitP && soult1 )
            {
                {
                    countT cRemaining = soult1 ;
                    if( /*bTrace &&*/ !( cRemaining % TUCK ) ) traceF( tinP , T(bNative?"etherSoilF / native from ascii / handling a word, with ":"etherSoilF / ascii from native / handling a word, with ")+TF2(cRemaining,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" words still awaiting") ) ;
                }

                ///**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / loop / +") ) ;
                ZE( strokeS* , psttp ) ;

                soult1 >> psttp ; ___( psttp ) ;

                ///**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / loop / 3") ) ;
                if( bNative )
                {
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbs   , tm5   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ENCODE ALL LITERAL SPACE ' '
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbb   , tm6   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // HIDE ALL LITERAL BACKSLASH
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbo   , tm7   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // HIDE ALL LITERAL {
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbc   , tm8   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // HIDE ALL LITERAL }
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbos  , tm9   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // HIDE ALL LITERAL [
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbcs  , tma   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // HIDE ALL LITERAL ]
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbBar , tmc   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // HIDE ALL LITERAL |
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , to    , tm1   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ENCODE ALL {
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tc    , tm2   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ENCODE ALL }
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tos   , tm3   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ENCODE ALL [
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tcs   , tm4   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ENCODE ALL ]
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tBar  , tmb   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ENCODE ALL |
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm6   , tb    , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // SHOW ALL LITERAL BACKSLASH
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm7   , to    , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // SHOW ALL LITERAL {
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm8   , tc    , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // SHOW ALL LITERAL }
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm9   , tos   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // SHOW ALL LITERAL [
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tma   , tcs   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // SHOW ALL LITERAL ]
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tmc   , tBar  , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // SHOW ALL LITERAL |
                }
                else
                {
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm5   , tbs   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // DECODE ALL LITERAL SPACE ' '
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tb    , tbb   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ESCAPE THE LITERAL BACKSLASH
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , to    , tbo   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ESCAPE THE LITERAL {
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tc    , tbc   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ESCAPE THE LITERAL }
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tos   , tbos  , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ESCAPE THE LITERAL [
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tcs   , tbcs  , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ESCAPE THE LITERAL ]
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tBar  , tbBar , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ESCAPE THE LITERAL |
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm1   , to    , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // DECODE ALL {
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm2   , tc    , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // DECODE ALL }
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm3   , tos   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // DECODE ALL [
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm4   , tcs   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // DECODE ALL ]
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tmb   , tBar  , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // DECODE ALL |
                }
                ///**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / loop / 2") ) ;

                if( !bQuitP ) soulOutP << psttp ;

                ///**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / loop / 1") ) ;
                delF( tinP , psttp ) ;
                ///**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / loop / -") ) ;
            }
            /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / -") ) ;

            break ;
        }
        default :
        {
            /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 2") ) ;

            ZE( countT , cFlag23 ) ;
            countT idf = 1 ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            TN( tn     , ""        ) ;
            TN( tm1    , ""        ) ; tm1    = T("")+S2(1,sc_MARK) ;
            TN( tm2    , ""        ) ; tm2    = T("")+S2(2,sc_MARK) ;
            TN( tm3    , ""        ) ; tm3    = T("")+S2(3,sc_MARK) ;
            TN( tm4    , ""        ) ; tm4    = T("")+S2(4,sc_MARK) ;
            TN( tm21   , ""        ) ; tm21   = tm2+tm1 ;
            TN( tMarks , ""        ) ; tMarks = tm1+tm2 ; // S2(sa_MARKsYSTEMbREAK,sc_MARKsYSTEM) WILL ALSO APPEAR AS A DELIMITER IF THE SOURCE INPUT CONTAINS '|'; THIS IS A CONSEQUENCE OF strWordsF OBEYING THE flSTRwORDS_SPLITaTmARK FLAG
            TN( tBreakMark , ""    ) ; tBreakMark = tn+S2(sa_MARKsYSTEMbREAK,sc_MARKsYSTEM) ;
            TN( tWhite , TbLACK    ) ;
            TN( tBlack , TwHITEanu ) ;
            TN( tFlag1 , "(?)"     ) ;
            TN( tFlag2 , "(<)"     ) ;
            TN( tFlag3 , "(>)"     ) ;
            TN( tm001   , ""        ) ; tm001 = T("")+S2(0x100,sc_MARK) ; //USED TO MARK WHERE NESTING LEVEL BECOMES NEGATIVE
            TN( tm101   , ""        ) ; tm101 = T("")+S2(0x101,sc_MARK) ; //USED TO MARK WHERE NESTING LEVEL BECOMES GREATER THAN 1
            __( tFlag3.csF( tinP ) > tFlag2.csF( tinP ) ) ;               // IF WANT TO BREAK THIS THEN EDIT THE cstte EXPRESSION TO USE tFlag3
            TN( tAssign , "=" ) ;
            TN( tPlus   , "+" ) ;

            TN( tKeyBody                    , "body"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyBudget                  , "budget"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyBuy                     , "buy"                         ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyCalculate               , "calculate"                   ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyClosed                  , "closed"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyCloud                   , "cloud"                       ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyCloudView               , "cloudview"                   ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyComment                 , "comment"                     ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyCustomer                , "customer"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyDate                    , "date"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyDo                      , "do"                          ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyDoJobs                  , "dojobs"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyEdit                    , "edit"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFile                    , "file"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFileType                , "filetype"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFilter                  , "filter"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFlags                   , "flags"                       ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFolder                  , "folder"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFolderFrom              , "folderfrom"                  ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFolderTo                , "folderto"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyHtmlFolder              , "htmlfolder"                  ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyHtmlBodyPrefix          , "htmlbodyprefix"              ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyHtmlBodySuffix          , "htmlbodysuffix"              ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyHtmlHead                , "htmlhead"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyInclude                 , "include"                     ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyInspectFileNames        , "inspectfilenames"            ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyIPDOS                   , "ipdos"                       ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyJobQueue                , "jobqueue"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyJoin                    , "join"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyJournal                 , "journal"                     ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyKt                      , "kt"                          ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyKtr                     , "ktr"                         ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyKV                      , "kv"                          ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyKVF                     , "kvf"                         ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyLog                     , "log"                         ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyMath                    , "math"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyMemory                  , "memory"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyMode                    , "mode"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyModulo1                 , "modulo1"                     ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyModulo2                 , "modulo2"                     ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyMoney                   , "money"                       ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyNameSpace               , "namespace"                   ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyNapTocks                , "naptocks"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyNull                    , "null"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyRemainder1              , "remainder1"                  ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyRemainder2              , "remainder2"                  ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyRenameToHash            , "renametohash"                ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyRepeat                  , "repeat"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyReplace                 , "replace"                     ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyReplacements            , "replacements"                ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyReport                  , "report"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeySell                    , "sell"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeySettings                , "settings"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeySizeBytes               , "sizebytes"                   ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeySource                  , "source"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeySplit                   , "split"                       ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyStep                    , "step"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyTime                    , "time"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyTimecard                , "timecard"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyTrace                   , "trace"                       ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyTimeRange               , "timerange"                   ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyUser                    , "user"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyValidate                , "validate"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyVendor                  , "vendor"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyWaitStep                , "waitstep"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyZip                     , "zip"                         ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS

            const strokeS* ppsttOkKey[] =
            {
                tKeyBody                    ,           // 00
                tKeyBudget                  ,           // 10
                tKeyBuy                     ,           // 20
                tKeyCalculate               ,           // 30
                tKeyClosed                  ,           // 40
                tKeyCloud                   ,           // 50
                tKeyCloudView               ,           // 60
                tKeyComment                 ,           // 70
                tKeyCustomer                ,           // 80
                tKeyDate                    ,           // 90
                tKeyDo                      ,           // a0
                tKeyDoJobs                  ,           // b0
                tKeyEdit                    ,           // c0
                tKeyFile                    ,           // d0
                tKeyFileType                ,           // e0
                tKeyFilter                  ,           // f0
                tKeyFlags                   ,           // 01
                tKeyFolder                  ,           // 11
                tKeyFolderFrom              ,           // 21
                tKeyFolderTo                ,           // 31
                tKeyHtmlFolder              ,           // 41
                tKeyHtmlBodyPrefix          ,           // 51
                tKeyHtmlBodySuffix          ,           // 61
                tKeyHtmlHead                ,           // 71
                tKeyInclude                 ,           // 81
                tKeyInspectFileNames        ,           // 91
                tKeyIPDOS                   ,           // a1
                tKeyJobQueue                ,           // b1
                tKeyJoin                    ,           // c1
                tKeyJournal                 ,           // d1
                tKeyKt                      ,           // e1
                tKeyKtr                     ,           // f1
                tKeyKV                      ,           // 02
                tKeyKVF                     ,           // 12
                tKeyLog                     ,           // 22
                tKeyMath                    ,           // 32
                tKeyMemory                  ,           // 42
                tKeyMode                    ,           // 52
                tKeyModulo1                 ,           // 62
                tKeyModulo2                 ,           // 72
                tKeyMoney                   ,           // 82
                tKeyNameSpace               ,           // 92
                tKeyNapTocks                ,           // a2
                tKeyNull                    ,           // b2
                tKeyRemainder1              ,           // c2
                tKeyRemainder2              ,           // d2
                tKeyRenameToHash            ,           // e2
                tKeyRepeat                  ,           // f2
                tKeyReplace                 ,           // 03
                tKeyReplacements            ,           // 13
                tKeyReport                  ,           // 23
                tKeySell                    ,           // 33
                tKeySettings                ,           // 43
                tKeySizeBytes               ,           // 53
                tKeySource                  ,           // 63
                tKeySplit                   ,           // 73
                tKeyStep                    ,           // 83
                tKeyTime                    ,           // 93
                tKeyTimecard                ,           // a3
                tKeyTrace                   ,           // b3
                tKeyTimeRange               ,           // c3
                tKeyUser                    ,           // d3
                tKeyValidate                ,           // e3
                tKeyVendor                  ,           // f3
                tKeyWaitStep                ,           // 04
                tKeyZip                     ,           // 14
            } ;

            /*const*/ countT offKeyOkBuy  = 0x02 ;
            /*const*/ countT offKeyOkTime = 0x39 ;

            stackC stOkBuy(  tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
            stackC stOkCard( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

            ZE( strokeS* , psttzLeverAssign ) ;
            switchStackC swsAssign( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverAssign , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;

            ZE( strokeS* , psttzLeverBudget ) ;
            switchStackC swsBudget( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverBudget , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO | flSTACKc_ALLOWzE , ifcSTACKtYPE_measureT ) ; // EACH PLATE IS INTERPRETED AS A NUMBER OF IFC HOURS (EACH IFC HOUR IS 90 CONVENTIONAL MINUTES)

            ZE( strokeS* , psttzLeverReplace ) ;
            switchC swReplace( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverReplace ) ;

            ZE( strokeS* , psttzLeverSettings ) ;
            switchC swSettings( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverSettings ) ;

            traceF( tinP , T("etherSoilF / loading soulWords") ) ;

            soulC soulWords( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.words" ) ;
            countT cWords = strWordsF( tinP , soulWords , soulInP , sttq , tMarks , F(flagsP) & flETHERsOILf_CONSUMEiNPUT ? flSTRwORDS_DELIMITERS|flSTRwORDS_SPLITaTmARK|flSTRwORDS_CONSUMEiNPUT : flSTRwORDS_DELIMITERS|flSTRwORDS_SPLITaTmARK ) ;

            traceF( tinP , T("etherSoilF / setting up to handle ")+TF2(cWords,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" words") ) ;

            // INPUT FILE SPECIFICATION
            // THE FILE IS A STREAM OF ASCII CHARACTERS
            // THIS STREAM CONSISTS OF RECORDS SEPARATED BY WHITE SPACE
            // EACH RECORD BEGINS IMMEDIATELY AFTER A '{' AND ENDS IMMEDIATELY BEFORE A '}'
            // RECORDS MAY BE NESTED, BUT NESTED RECORDS ARE NOT OBEYED; THEY ARE SIMPLY PASSED THROUGH AS LITERALS WITHIN THE VALUE
            // ANY ASCII CHARACTER, INCLUDING NULL, IS ALLOWED WITHIN A RECORD
            // THE FOLLOWING ESCAPE SEQUENCES ARE USED TO REPRESENT CHARACTERS THAT WOULD OTHERWISE BE TREATED AS RECORD DELIMITERS
            //
            // "\\" REPRESENTS "\"
            // "\{" REPRESENTS "{"
            // "\}" REPRESENTS "}"
            // "\ " REPRESENTS HARD SPACE " " (A SPACE THAT IS NOT TO BE REMOVED BY TRIMMING OR COMPRESSING WHITE SPACE)
            //
            // RECORD SPECIFICATION
            //
            // KEY
            // DELIMITER
            // VALUE
            //
            // KEY SPECIFICATION
            //
            // WO OR MORE OF [a-z,0-9,_]
            //
            // DELIMITER SPECIFICATION
            //
            // ":"
            //
            // VALUE SPECIFICATION
            //
            // WOTH CHARACTER MUST NOT BE WHITE SPACE
            // THE REMAINING CHARACTERS CAN BE ANY ASCII VALUE INCLUDING NULL

            TN( tColon      , ":" ) ;
            TN( tKeyLevel1  , "" ) ;
            TN( tKeyLevel2  , "" ) ;
            TN( tKeyLevel3  , "" ) ;
            switch( idModeP )
            {
                case ifcIDmODEeTHERsOIL_LINT :
                {
                    break ;
                }
                case ifcIDmODEeTHERsOIL_TRIM :
                {
                    break ;
                }
                case ifcIDmODEeTHERsOIL_QUERYvALUES :
                {
                    break ;
                }
            }

            if( !POOP )
            {
                ZE( sCountT , scNest     ) ; // 0: WHITE SPACE BETWEEN RECORDS ; 1: NORMAL VALUE WITHIN A RECOD ; 2: WITHIN A BRACKET PAIR THAT IS WITHIN A RECORD
                ZE( boolT   , bDown      ) ;
                ZE( countT  , year       ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( countT  , month      ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( countT  , date       ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( countT  , date1      ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( sCountT , date2      ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( countT  , time1      ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( sCountT , time2      ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( countT  , offStrong ) ;
                ZE( countT  , timeCard1  ) ; // TIME OF LATH CHANGE OF ACTIVITY
                ZE( sCountT , timeCard2  ) ; // TIME OF LATH CHANGE OF ACTIVITY
                ZE( countT  , offStrongCard ) ;
                TN( tLeverBuy , "" ) ;
                ZE( strokeS* , psttLeverBuy      ) ; //MUST ALWAYS CONTAIN A POINTER RETURNED BY CASTING tLeverBuy (TO ENSURE THAT IT DOES NOT CONTAIN A ZOMBIE)
                TN( tLeverCard , "" ) ;
                ZE( strokeS* , psttLeverCard      ) ; //MUST ALWAYS CONTAIN A POINTER RETURNED BY CASTING tLeverCard (TO ENSURE THAT IT DOES NOT CONTAIN A ZOMBIE)
                ZE( switchC* , pSwSwBuy       ) ;
                ZE( switchC* , pSwSwTimeCard  ) ;
                ZE( switchC* , pSwTimeMax     ) ;
                ZE( stackC*  , pStDo          ) ;
                ZE( countT   , csttMaxDo      ) ;
                ZE( stackC*  , pStLog         ) ;
                ZE( countT   , csttMaxLog     ) ;
                ZE( stackC*  , pStJournal     ) ;
                ZE( countT   , csttMaxJournal ) ;
                ZE( countT   , cents          ) ;
                ZE( countT   , idString       ) ; //TO FIND A BUG
                boolT bAllowLevel1 = 1 ;
                ZE( boolT    , bAllowLevel2   ) ;
                ZE( boolT    , bAllowLevel3   ) ;
                TN( tcr , "\r\n" ) ;
                TN( tStar , "*" ) ;
                TN( tStarDotData , "*.data" ) ;
                TN( tbcrb , " \r\n" ) ; tbcrb += tBreakMark ;
                TN( tFile , "" ) ;
                TN( tUser , thirdC::postUserNameIF() ) ;
                TN( tUserOverride , "" ) ;
                TN( tNoRef , "noReferences" ) ;
                TN( tFlagNoZip , "noZip" ) ;
                TN( tFlagBeep  , "beep" ) ;
                TN( tFlagFragNote , "fragnote" ) ;
                TN( tFolderDefault , "///ideafarm/IdeaFarm " "(tm)/Pick Up SOIL (tm) Reply Text Here/" ) ;
                TN( tFolder , (strokeS*)tFolderDefault ) ;
                TN( tFolderFrom , "" ) ;
                TN( tFolderTo , "" ) ;
                TN( tJobQueueFolder , "" ) ;
                TN( tJobQueueRepeat , "" ) ;
                TN( tRenameToHashFolder , "" ) ;
                TN( tReportsFolder , "" ) ;
                TN( tReportsSource , "" ) ;
                TN( tHtmlFolder , "" ) ;
                TN( tHtmlBodyPrefix , "" ) ;
                TN( tHtmlBodySuffix , "" ) ;
                TN( tHtmlHead       , "" ) ;
                TN( tNameSpace      , "" ) ;
                TN( tMemory         , "" ) ;
                countT idKtrMode = ifcIDmODEpUTfILE_OTHER ;
                stackC stTimeMinMax( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY | flSTACKc_BLOB , 2 * sizeof( strokeS* ) ) ; // FORMAT EXAMPLE: 20130711@1401 20130711@1401
                stackC stFileType(   tinP , *this , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , ifcSTACKtYPE_PTR_strokeS ) ; // FORMAT EXAMPLE: mp3
                soulC soulValue( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.value" ) ; // USED TO ELIMINATE 02 BIT ADDRESS SPACE CAPACITY CONSTRAINT FOR HUGE VALUE STRINGS
                soulC soulBody( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.body" ) ; // IF LINT THEN RETAINS WHITE SPACE AND MIGHT HAVE ERROR FLAG MARKS ; IF REPORT THEN OMITS WHITE SPACE OTHER THAN INDENT BLANKS
                flagsT flagsLoad    = flBRANCHslOADf_null ;
                flagsT flagsPutFile = flBRANCHspUTfILEf_null ;
                flagsT flagsReport  = flETHERsOILrEPORT_null ;
                ZE( countT , idTranscriptLath ) ;
                ZE( countT , time1TranscriptLath ) ;
                ZE( sCountT , time2TranscriptLath ) ;
                TN( tSettingsKeyPrefix , "" ) ;
                TN( tTrace , "" ) ;

                TN( tValueKtrModeRoot        , "root"           ) ;
                TN( tValueKtrModePaid        , "paid"           ) ;
                TN( tValueKtrModeTutorials   , "tutorials"      ) ;
                TN( tValueKtrModeHooks       , "hooks"          ) ;
                TN( tValueKtrModeBundle      , "bundle"         ) ;
                TN( tValueKtrModeNews        , "news"           ) ;
                TN( tValueKtrModeEssays      , "essays"         ) ;
                TN( tValueKtrModeArchive     , "archive"        ) ;
                TN( tValueKtrModeWo          , "wo"             ) ;
                TN( tValueKtrModePay         , "pay"            ) ;
                TN( tValueKtrModeIpdos       , "ipdos"          ) ;
                TN( tValueKtrModeOther       , "other"          ) ;

                ZE( countT , waitStepModulo1 ) ;
                ZE( countT , waitStepModulo2 ) ;
                ZE( countT , waitStepRemainder1 ) ;
                ZE( countT , waitStepRemainder2 ) ;
                ZE( countT , waitStepNapTocks   ) ;
                ZE( countT , sizeBytes ) ;

                ZE( countT , idWord ) ;//U::
                TN( tBug , "and scatter it over the years" ) ;

                TN( tArchive , "" ) ;
                if( tReportsSource.csF( tinP ) )
                {
                    tArchive = tReportsSource ;
                    //traceF( tinP , T("set 1 [tArchive]: ")+tArchive ) ;
                }
                else
                {
                    ZE( strokeS* , psttm ) ;
                    diskMapFileNameF( tinP , psttm , T("///ideafarm/IdeaFarm (tm)/")+( tUserOverride.csF( tinP ) ? tUserOverride : tUser )+T("/Drop Files Here To Archive/") ) ; ___( psttm ) ;
                    tArchive = T(psttm) ;
                    //traceF( tinP , T("set 2 [tArchive]: ")+tArchive ) ;
                    delF( tinP , psttm ) ;
                }

                while( !bQuitP && soulWords )
                {
                    //LOGrAW3( "default soil processing [soulWords]: " , soulWords , " /+\r\n" ) ;

                    ZE( strokeS* , psttWord ) ;
                    soulWords >> psttWord ; ___( psttWord ) ;

                    {
                        countT cRemaining = soulWords ;
                        if( bTrace && !( cRemaining % TUCK ) ) traceF( tinP , T("etherSoilF / handling a word, with ")+TF2(cRemaining,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" words still awaiting") ) ;
                    }

                    //if( idModeP == ifcIDmODEeTHERsOIL_LINT )
                    //{
                    //    ++ idWord ;
                    //
                    //    //if( strIdF( tinP , tBug , psttWord ) )
                    //    //if( idWord > 0x140 )
                    //    {
                    //        strokeF( tinP , T("\r\n\r\n[idWord]: ")+TF2(idWord,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
                    //        strokeF( tinP , T("word:\r\n\"")+T(psttWord)+T("\"\r\n") ) ;
                    //    }
                    //}

                    idString ++ ;
                    //CONoUTrAW9( "[idString]: " , idString , "        [scNest]: " , scNest , "        [bAllowLevel1]: " , bAllowLevel1 , "        [bAllowLevel2]: " , bAllowLevel2 , "\r\n" ) ;
                    //traceF( tinP , T("\r\nword handler [idMode,idString,word]: ")+TF2(idModeP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(idString,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    >")+T(psttWord)+T("<") ) ;

                    if( idString == 3 )
                    {
                        countT foo = 2 ;
                    }

                    ZE( countT , cDown ) ; // THIS IS DONE TO SUPPORT OCCURRANCES LIKE "}}}}}" ; SUPPORT FOR "{{{{{{" IS NOT NEEDED BECAUSE SUCH IS ILLEGAL IN THE INPUT STREAM
                    {
                        countT idf = 1 ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        if( !strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , tm2 , psttWord , 0 , 1 , flSTRiDaNY_NOT ) ) cDown = psttWord->idAdam ; // IF psttWord ONLY CONTAINS '}'
                    }

                    ZE( boolT , bDone ) ;
                    if( cDown )
                    {
                        while( cDown -- )
                        {
                            switch( scNest -- )
                            {
                                case 1 :
                                {
/*N1D*/                             if( tKeyLevel1 == tKeyWaitStep )
/*N1D*/                             {
/*N1D*/                                 if( idModeP == ifcIDmODEeTHERsOIL_REPORT )
/*N1D*/                                 {
/*N1D*/                                     if( waitStepNapTocks )
/*N1D*/                                     {
/*N1D*/                                         homeS& home = homeS::homeIF() ;
/*N1D*/                                         TN( tb4 , "    " ) ;
/*N1D*/                                         traceF( tinP , T("waitstep: napping [idStepSoil,waitStepNapTocks]:    ")+TF2(home.idStepSoil,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepNapTocks,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N1D*/                                         sleepC s( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/                                         etherC& etPrime = etPrimeIF( tinP ) ;
/*N1D*/                                         ++ s ; etPrime.osSleepF( tinP , waitStepNapTocks * TOCK ) ;
/*N1D*/                                         traceF( tinP , T("waitstep: napped  [idStepSoil,waitStepNapTocks]:    ")+TF2(home.idStepSoil,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepNapTocks,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N1D*/                                     }
/*N1D*/                                     else if( waitStepModulo1 > 1 && ( !waitStepModulo2 || waitStepModulo2 > 1 ) )
/*N1D*/                                     {
/*N1D*/                                         homeS& home = homeS::homeIF() ;
/*N1D*/
/*N1D*/                                         sleepC s( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/
/*N1D*/                                         TN( tb4 , "    " ) ;
/*N1D*/                                         ZE( boolT , bNapped ) ;
/*N1D*/                                         etherC& etPrime = etPrimeIF( tinP ) ;
/*N1D*/
/*N1D*/                                         // MODULO1: SLEEP IF NOT HIT
/*N1D*/                                         // MODULO2: SLEEP IF     HIT  (MODULO2 IS OPTIONAL AND ACTS ONLY TO SUPPRESS THE "GO AHEAD" OF MODULO1)
/*N1D*/
/*N1D*/                                         // EXAMPLES:
/*N1D*/                                         // MOD1:4 REM1:0                - SLEEP IF REM1 NOT 0                 (PASSES EVERY 4TH)
/*N1D*/                                         // MOD1:4 REM1:0 MOD2:01 REM2:0 - SLEEP IF REM1 NOT 0 OR IF REM2 IS 0 (PASSES EVERY 4TH EXCEPT EVERY 01TH)
/*N1D*/
/*N1D*/                                         // DISCUSSION:  INTENTION IS TO SUPPORT NORMAL CYCLING WITH OCCASIONAL EXTENDED STEPS
/*N1D*/
/*N1D*/                                         // EXAMPLES
/*N1D*/                                         // MOD1 REM1 MOD2 REM2 STEP
/*N1D*/
/*N1D*/                                                                     // A1/A2 ALTERNATE, EXCEPT THAT OCCASIONALLY B1/B2 ARE DONE INSTEAD
/*N1D*/                                         // 4    0    01   0    A1
/*N1D*/                                         // 4    2    01   2    A2
/*N1D*/                                         // 01   0              B1
/*N1D*/                                                // 01   2              B2
/*N1D*/
/*N1D*/                                                                     // A1/A2 ALTERNATE, EXCEPT THAT OCCASIONALLY B1/B2/B3 ARE DONE INSTEAD (WHENEVER B3 IS ACTIVE, A1 WILL ALSO BE ACTIVE)
/*N1D*/                                         // 4    0    01   0    A1
/*N1D*/                                         // 4    2    01   2    A2
/*N1D*/                                         // 01   0              B1
/*N1D*/                                         // 01   2              B2
/*N1D*/                                         // 01   4              B3
/*N1D*/
/*N1D*/                                                                     // A1/A2/A3 CYCLE, EXCEPT THAT OCCASIONALLY B1/B2/B3 ARE DONE INSTEAD (A3 CAN BE A NULL ACTION)
/*N1D*/                                         // 6    0    01   0    A1
/*N1D*/                                         // 6    2    01   2    A2
/*N1D*/                                         // 6    4    01   4    A3
/*N1D*/                                         // 01   0              B1
/*N1D*/                                         // 01   2              B2
/*N1D*/                                         // 01   4              B3
/*N1D*/
/*N1D*/                                         while( !etPrime && ( home.idStepSoil % waitStepModulo1 != waitStepRemainder1 || ( waitStepModulo2 > 1 && home.idStepSoil % waitStepModulo2 == waitStepRemainder2 ) ) )
/*N1D*/                                         {
/*N1D*/                                             if( !bNapped )
/*N1D*/                                             {
/*N1D*/                                                 traceF( tinP , T("waitstep: waiting begun [idStepSoil,waitStepModulo1,waitStepRemainder1,waitStepModulo2,waitStepRemainder2]:    ")+TF2(home.idStepSoil,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepModulo1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepRemainder1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepModulo2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepRemainder2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N1D*/                                                 bNapped = 1 ;
/*N1D*/                                             }
/*N1D*/
/*N1D*/                                             ++ s ; etPrime.osSleepF( tinP , TOCK ) ;
/*N1D*/                                         }
/*N1D*/
/*N1D*/                                         traceF( tinP , T(bNapped?"waitstep: waiting ended [idStepSoil,waitStepModulo1,waitStepRemainder1,waitStepModulo2,waitStepRemainder2]:    ":"waitstep: did not wait  [idStepSoil,waitStepModulo1,waitStepRemainder1]:    ")+TF2(home.idStepSoil,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepModulo1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepRemainder1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepModulo2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepRemainder2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N1D*/                                     }
/*N1D*/
/*N1D*/                                     waitStepModulo1 = waitStepModulo2 = waitStepRemainder1 = waitStepRemainder2 = 0 ;
/*N1D*/                                 }
/*N1D*/                             }
/*N1D*/                             else if( tKeyLevel1 == tKeyStep )
/*N1D*/                             {
/*N1D*/                                 if( idModeP == ifcIDmODEeTHERsOIL_REPORT )
/*N1D*/                                 {
/*N1D*/                                     homeS& home = homeS::homeIF() ;
/*N1D*/                                     countT idStep = 1 + incv02AM( home.idStepSoil ) ;
/*N1D*/                                     traceF( tinP , T("step: [idStepSoil]:    ")+TF2(idStep,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N1D*/                                 }
/*N1D*/                             }
/*N1D*/                             else if( tKeyLevel1 == tKeyTrace )
/*N1D*/                             {
/*N1D*/                                 if( idModeP == ifcIDmODEeTHERsOIL_REPORT )
/*N1D*/                                 {
/*N1D*/                                     traceF( tinP , T("trace: ")+tTrace ) ;
/*N1D*/                                     tTrace = tn ;
/*N1D*/                                 }
/*N1D*/                             }
/*N1D*/                             else if( tKeyLevel1 == tKeyDoJobs )
/*N1D*/                             {
/*N1D*/                                 if( tJobQueueFolder.csF( tinP ) )
/*N1D*/                                 {
/*N1D*/                                     TN( tRepeatImage , "" ) ;
/*N1D*/                                     if( tJobQueueRepeat.csF( tinP ) ) tRepeatImage = T("\r\n{repeat: ")+tJobQueueRepeat+T("}\r\n") ;
/*N1D*/
/*N1D*/                                     ZE( countT , costAll ) ;
/*N1D*/                                     stackC stImage( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_count2S ) ;
/*N1D*/                                     {
/*N1D*/                                         if( tRepeatImage.csF( tinP ) )
/*N1D*/                                         {
/*N1D*/                                             ZE( osTextT* , postr ) ;
/*N1D*/                                             countT costr = strMakeF( tinP , LF , postr , tRepeatImage ) ; ___( postr ) ;
/*N1D*/
/*N1D*/                                             ZE( count2S* , pc2p ) ;
/*N1D*/                                             newF( tinP , LF , pc2p ) ; ___( pc2p ) ;
/*N1D*/                                             if( pc2p )
/*N1D*/                                             {
/*N1D*/                                                 pc2p->c1 = costr ;
/*N1D*/                                                 pc2p->c2 = (countT)postr ;
/*N1D*/                                                 stImage << pc2p ;
/*N1D*/                                                 costAll += costr ;
/*N1D*/                                             }
/*N1D*/                                         }
/*N1D*/
/*N1D*/                                         fileNameC fnLike( tinP , *this , tJobQueueFolder+T("*.soil") ) ;
/*N1D*/                                         patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                
/*N1D*/                                         ZE( infoFileS* , pInfo ) ;
/*N1D*/                                         strokeS sttSlash( '/' ) ;
/*N1D*/                                         handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
/*N1D*/                                         do
/*N1D*/                                         {
/*N1D*/                                             diskFindFileOrDirF( tinP , pInfo , hFind , fnLike.pathF() , &pat ) ;
/*N1D*/                                             if( pInfo && strIdF( tinP , sttSlash , pInfo->psttIfoName , - 1 ) != pInfo->psttIfoName->idAdam )
/*N1D*/                                             {
/*N1D*/                                                 ZE( osTextT* , postWo ) ;
/*N1D*/                                                 ZE( countT   , costWo ) ;
/*N1D*/                                                 boxGetF( tinP , postWo , costWo , pInfo->psttIfoName ) ; ___( postWo ) ;
/*N1D*/
/*N1D*/                                                 if( !POOP && postWo && costWo )
/*N1D*/                                                 {
/*N1D*/                                                     ZE( count2S* , pc2p ) ;
/*N1D*/                                                     newF( tinP , LF , pc2p ) ; ___( pc2p ) ;
/*N1D*/                                                     if( pc2p )
/*N1D*/                                                     {
/*N1D*/                                                         pc2p->c1 = costWo ;
/*N1D*/                                                         pc2p->c2 = (countT)postWo ;
/*N1D*/                                                         stImage << pc2p ;
/*N1D*/                                                         costAll += costWo ;
/*N1D*/                                                     }
/*N1D*/                                                 }
/*N1D*/                                             }
/*N1D*/                                             DEL( pInfo ) ;
/*N1D*/                                         }
/*N1D*/                                         while( !etherC::etPrimeIF( tinP ) && ~hFind ) ;
/*N1D*/                                     }
/*N1D*/
/*N1D*/                                     ZE( osTextT* , postAll ) ;
/*N1D*/                                     newF( tinP , LF , postAll , costAll ) ; ___( postAll ) ;
/*N1D*/
/*N1D*/                                     osTextT* postc = postAll ;
/*N1D*/                                     osTextT* poste = postAll + costAll ;
/*N1D*/                                     while( stImage )
/*N1D*/                                     {
/*N1D*/                                         ZE( count2S* , pc2p ) ;
/*N1D*/                                         stImage >> pc2p ;
/*N1D*/
/*N1D*/                                         countT costAvailable = poste - postc ;
/*N1D*/                                         if( pc2p->c2 && pc2p->c1 && costAvailable >= pc2p->c1 )
/*N1D*/                                         {
/*N1D*/                                             thirdC::c_memcpyIF( tinP , postc , (osTextT*)pc2p->c2 , pc2p->c1 ) ;
/*N1D*/                                             postc += pc2p->c1 ;
/*N1D*/                                         }
/*N1D*/
/*N1D*/                                         delF( tinP , *(osTextT**)&pc2p->c2 ) ;
/*N1D*/                                         delF( tinP , pc2p ) ;
/*N1D*/                                     }
/*N1D*/                                     __( poste - postc ) ;
/*N1D*/
/*N1D*/                                     ZE( strokeS* , psttu ) ;
/*N1D*/                                     strUniqueF( tinP , psttu ) ; ___( psttu ) ;
/*N1D*/
/*N1D*/                                     //U:: SUPPRESS THE JOBS IF etherSoilWalkCBF DETECTED NAMES THAT ARE TOO LONG
/*N1D*/
/*N1D*/                                     TN( tHomeUser    , ""                                     ) ; tHomeUser = T("///ideafarm/IdeaFarm (tm)/")+tUser ;
/*N1D*/                                     TN( tShort       , ""                                     ) ; tShort    = T("jobs.")+T(psttu)+T(".soil") ;
/*N1D*/                                     TN( tDropHere    , "/Drop a Copy of SOIL (tm) Text Here/" ) ;
/*N1D*/                                     TN( tPendingHere , "/SOIL (tm) Text Being Eaten/"         ) ;
/*N1D*/                                     TN( tDoneHere    , "/Pick Up SOIL (tm) Reply Text Here/"  ) ;
/*N1D*/
/*N1D*/                                     TN( tDrop     , "" ) ; tDrop    = tHomeUser+tDropHere   +tShort ;
/*N1D*/                                     TN( tPending  , "" ) ; tPending = tHomeUser+tPendingHere+tShort ;
/*N1D*/                                     TN( tDone     , "" ) ; tDone    = tHomeUser+tDoneHere   +tShort ;
/*N1D*/
/*N1D*/                                     boxPutF( tinP , tHomeUser+tDropHere+tShort , postAll , costAll ) ;
/*N1D*/
/*N1D*/                                     delF( tinP , psttu ) ;
/*N1D*/                                     delF( tinP , postAll ) ;
/*N1D*/
/*N1D*/                                     //U::DO THIS ONLY IF A SYNC FLAG IS SET
/*N1D*/                                     sleepC s( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/
/*N1D*/                                     etherC& etPrime = etPrimeIF( tinP ) ;
/*N1D*/
/*N1D*/                                     traceF( tinP , T("dojobs: 3 waiting for file to disappear from ")+tDrop ) ;
/*N1D*/                                     while( !etPrime && !POOP &&  etPrime.diskFileExistsF( tinP , tDrop    ) ) { ++ s ; etPrime.osSleepF( tinP , TOCK ) ; }
/*N1D*/
/*N1D*/                                     traceF( tinP , T("dojobs: 2 waiting for file to disappear from ")+tPending ) ;
/*N1D*/                                                                                                             ++ s ; etPrime.osSleepF( tinP , TOCK ) ;  // RACE: FOR A MOMENT, THE FILE EXISTS IN NEITHER DIRECTORY (BASE O.S. MOVE MIGHT NOT BE ATOMIC)
/*N1D*/                                     while( !etPrime && !POOP &&  etPrime.diskFileExistsF( tinP , tPending ) ) { ++ s ; etPrime.osSleepF( tinP , TOCK ) ; }
/*N1D*/
/*N1D*/                                     traceF( tinP , T("dojobs: 1 waiting for file to appear in ")+tDone ) ;
/*N1D*/                                     while( !etPrime && !POOP && !etPrime.diskFileExistsF( tinP , tDone    ) ) { ++ s ; etPrime.osSleepF( tinP , TOCK ) ; }
/*N1D*/
/*N1D*/                                     traceF( tinP , T("dojobs: 0 file is in ")+tDone ) ;
/*N1D*/                                 }
/*N1D*/                             }
/*N1D*/                             else if( tKeyLevel1 == tKeyKtr )
/*N1D*/                             {
/*N1D*/                                 switch( idModeP )
/*N1D*/                                 {
/*N1D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N1D*/                                     {
/*N1D*/                                         homeS& home = homeS::homeIF() ;
/*N1D*/
/*N1D*/                                         //U::if
/*N1D*/                                         //U::(
/*N1D*/                                         //U::    !( F(home.flags) & flHOMEs_PAIDpRIVILEGES )
/*N1D*/                                         //U::    &&
/*N1D*/                                         //U::    !( F(home.flags) & flHOMEs_IDEAFARMcLOUDiSgONE )
/*N1D*/                                         //U::)
/*N1D*/                                         //U::traceF( tinP , T("PISS / KTR: doing nothing because this home does not have PAID privileges") ) ;
/*N1D*/                                         //U::else
/*N1D*/                                         {
/*N1D*/                                             ZE( countT , csttTrimmed ) ;
/*N1D*/                                             ZE( boolT , bFail ) ;
/*N1D*/                                             IFsCRATCH
/*N1D*/                                             {
/*N1D*/                                                 SCOOPS
/*N1D*/
/*N1D*/                                                 ZE( countT , timeA1 ) ;
/*N1D*/                                                 ZE( sCountT , timeA2 ) ;
/*N1D*/                                                 osTimeNowF( tinP , timeA1 , timeA2 ) ;
/*N1D*/
/*N1D*/                                                 /**/if( bTrace ) traceF( tinP , T("etherSoilF / loading knowledge tree branches") ) ;
/*N1D*/
/*N1D*/                                                 // 20140829@0750: 4 BOOKS ARE REQUIRED IF EACH BOOK IS TICK << 2, SO IT WOULD BE NEAT IF TICK << 4 WOULD WORK (NOT TESTED YET)
/*N1D*/                                                 // 20140829@0750: 6 BOOKS ARE REQUIRED FOR THE INDEX
/*N1D*/                                                 //U:: USE AN INDEX THAT IS 8 TIMES THE DEFAULT SIZE, TO ELIMINATE THRASHING
/*N1D*/                                                 //OLD: FAILS FOR 2015: jotC jotBranches( tinP , "ethersoil.branches" , flJOTc_WRITE | flJOTc_DELETE | flJOTc_PRIVATE , TICK << 2 , TOCK << 6 , 1 ) ; //PRODUCTION (20140521@0515: TICK<<1 IS CURRENTLY LARGE ENOUGH FOR THE PRODUCTION WEB SITE)
/*N1D*/                                                                        jotC jotBranches( tinP , "ethersoil.branches" , flJOTc_WRITE | flJOTc_DELETE | flJOTc_PRIVATE , TICK << 4 , TOCK << 6 , 8 ) ; //20180724@1648: CNR STOPPAGE FOR 2015
/*N1D*/
/*N1D*/                                                 TN( tFolderFile , "" ) ; tFolderFile = tFolder+tFile ;
/*N1D*/
/*N1D*/                                                 traceF( tinP , T("tKeyKtr close curly [tFolderFile]: ")+tFolderFile ) ; //U::TO FIND A BUG
/*N1D*/
/*N1D*/                                                 if( F(flagsReport) & flETHERsOILrEPORT_FRAGnOTE )
/*N1D*/                                                 {
/*N1D*/                                                     TN( tFileNameSuffix , ".link.frag.notes.soul.not.html" ) ;
/*N1D*/                                                     TN( tFileBinary , "" ) ; tFileBinary = tFolderFile+tFileNameSuffix ;
/*N1D*/                                                     diskWalkCopyFileF( tinP , tFileBinary , T("///ideafarm/tmp/link.frag.note.soul.not.html") ) ;
/*N1D*/
/*N1D*/                                                     soulC sBinary( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/                                                     boxGetShadowF( tinP , sBinary , tFileBinary ) ;
/*N1D*/
/*N1D*/                                                     soulC soulReportFragments( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report.fragments" ) ;
/*N1D*/                                                     {
/*N1D*/                                                         TN( tHead ,
/*N1D*/
/*N1D*/                                                             "\r\n"
/*N1D*/                                                             "{report:\r\n"
/*N1D*/                                                             "\r\n"
/*N1D*/                                                             "    {name:     Knowledge Tree Linkage Fragment Report             }\r\n"
/*N1D*/                                                             "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
/*N1D*/                                                             "    {source:   ideafarm.com                                       }\r\n\r\n"
/*N1D*/                                                             "    {note:     This report is a nonauthoritative export of the\r\n"
/*N1D*/                                                             "               contents of accompanying binary file\r\n               "
/*N1D*/
/*N1D*/                                                         ) ;
/*N1D*/
/*N1D*/                                                         tHead += tFile+tFileNameSuffix+T(" }\r\n\r\n    {master:   \"")+tFolderFile+T("\" }\r\n\r\n    {idfrags:\r\n") ;
/*N1D*/
/*N1D*/                                                         strFuseF( tinP , soulReportFragments , tHead ) ;
/*N1D*/
/*N1D*/                                                         ZE( boolT , bKey ) ;
/*N1D*/                                                         while( sBinary )
/*N1D*/                                                         {
/*N1D*/                                                             bKey = !bKey ;
/*N1D*/
/*N1D*/                                                             ZE( strokeS* , psttp ) ;
/*N1D*/                                                             sBinary >> psttp ; ___( psttp ) ;
/*N1D*/                                                             //traceF( tinP , T("sBinary [psttp]: ")+T(psttp) ) ;
/*N1D*/
/*N1D*/                                                             TN( tSay , "" ) ; tSay = bKey
/*N1D*/
/*N1D*/                                                                 ? T("\r\n        {idfrag:\r\n            {key: ")+T(psttp)+T(" }\r\n            {value: \"")
/*N1D*/                                                                 : T(psttp)+T("\" }\r\n        }\r\n")
/*N1D*/
/*N1D*/                                                             ;
/*N1D*/
/*N1D*/                                                             strFuseF( tinP , soulReportFragments , tSay ) ;
/*N1D*/                                                             delF( tinP , psttp ) ;
/*N1D*/                                                         }
/*N1D*/                                                         strFuseF( tinP , soulReportFragments , T("    }\r\n}\r\n") ) ;
/*N1D*/                                                     }
/*N1D*/
/*N1D*/
/*N1D*/                                                     //TO FIND A BUG 20161130@1238
/*N1D*/                                                     //if( strIdF( tinP , T("2012") , tFolderFile , 1 ) )
/*N1D*/                                                     //{
/*N1D*/                                                     //    traceF( tinP , T("setting flTHREADmODE1_ALLOWeMITwORD") ) ;
/*N1D*/                                                     //    THREADmODE1oN( flTHREADmODE1_ALLOWeMITwORD )
/*N1D*/                                                     //}
/*N1D*/
/*N1D*/
/*N1D*/
/*N1D*/                                                     handleC hFile2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
/*N1D*/                                                     fileOpenF( tinP , hFile2 , countTC() , tFolderFile+T(".link.frag.notes.txt") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ; // READABLE LIST OF LINKAGE LABELS
/*N1D*/                                                     while( soulReportFragments )
/*N1D*/                                                     {
/*N1D*/                                                         ZE( strokeS* , psttp ) ;
/*N1D*/                                                         soulReportFragments >> psttp ; ___( psttp ) ;
/*N1D*/
/*N1D*/                                                         ZE( osTextT* , postp ) ;
/*N1D*/                                                         countT costp = strMakeF( tinP , LF , postp , psttp ) ; ___( postp ) ;
/*N1D*/                                                         delF( tinP , psttp ) ;
/*N1D*/
/*N1D*/                                                         fileWriteF( tinP , hFile2 , postp , costp ) ;
/*N1D*/                                                     }
/*N1D*/                                                 }
/*N1D*/
/*N1D*/                                                 {
/*N1D*/                                                     soulC soulReportLinkage( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report.linkage" ) ;
/*N1D*/                                                     {
/*N1D*/                                                         TN( tFileNameSuffix , ".link.pages.soul.not.html" ) ;
/*N1D*/                                                         TN( tHead ,
/*N1D*/
/*N1D*/                                                             "\r\n"
/*N1D*/                                                             "{report:\r\n"
/*N1D*/                                                             "\r\n"
/*N1D*/                                                             "    {name:     Knowledge Tree Linkage Report                      }\r\n"
/*N1D*/                                                             "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
/*N1D*/                                                             "    {source:   ideafarm.com                                       }\r\n\r\n"
/*N1D*/                                                             "    {note:     This report is a nonauthoritative export of the\r\n"
/*N1D*/                                                             "               contents of accompanying binary file\r\n               "
/*N1D*/
/*N1D*/                                                         ) ;
/*N1D*/
/*N1D*/                                                         tHead += tFile+tFileNameSuffix+T(" }\r\n\r\n    {master:   \"")+tFolderFile+T("\" }\r\n\r\n    {labels:\r\n") ;
/*N1D*/
/*N1D*/                                                         strFuseF( tinP , soulReportLinkage , tHead ) ;
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     soulC soulLinkOuter( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/                                                     {
/*N1D*/                                                         soulC soulLinkInner( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/                                                         {
/*N1D*/                                                             _IO_
/*N1D*/ /*---------------- LOAD BRANCHES ----------------*/         branchS::loadIF( tinP , *this , etPrimeIF( tinP ) , jotBranches , csttTrimmed , soulBody , flagsLoad , &soulLinkInner ) ;
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         if( !POOP )
/*N1D*/                                                         {
/*N1D*/                                                             soulLinkOuter << (osTextT*)T(" >> IdeaFarm (tm) - (c) Wo'O Ideafarm - ideafarm.com << ") ;
/*N1D*/                                                             ZE( countT , finger ) ;
/*N1D*/                                                             putNegAM( *(countT*)&finger , FINGERnEG_KTlINKfILEoUTER ) ;
/*N1D*/                                                             soulLinkOuter << finger ;
/*N1D*/                                                             soulLinkOuter << (countT)1 ; // idFormat
/*N1D*/    
/*N1D*/                                                             soulLinkOuter << (strokeS*)tFolderFile ;
/*N1D*/                                                             soulLinkOuter << soulLinkInner ;
/*N1D*/    
/*N1D*/                                                             ZE( osTextT* , postTM ) ;
/*N1D*/                                                             soulLinkInner >> postTM ; ___( postTM ) ;
/*N1D*/                                                             delF( tinP , postTM ) ;
/*N1D*/    
/*N1D*/                                                             ZE( countT , fingerv ) ;
/*N1D*/                                                             soulLinkInner >> fingerv ;
/*N1D*/    
/*N1D*/                                                             ZE( countT , idFormat ) ;
/*N1D*/                                                             soulLinkInner >> idFormat ;
/*N1D*/    
/*N1D*/                                                             ZE( countT , cFlavors ) ;
/*N1D*/                                                             soulLinkInner >> cFlavors ;
/*N1D*/    
/*N1D*/                                                             strokeS sttMark01( 0x10 , sc_MARK ) ;
/*N1D*/                                                             while( soulLinkInner )
/*N1D*/                                                             {
/*N1D*/                                                                 ZE( strokeS* , psttLabel ) ;
/*N1D*/                                                                 soulLinkInner >> psttLabel ; ___( psttLabel ) ;
/*N1D*/                                                                 strFuseF( tinP , soulReportLinkage , T("\r\n        {label:\r\n            {key: ")+T(psttLabel)+T(" }\r\n            {value: \"") ) ;
/*N1D*/    
/*N1D*/                                                                 ZE( countT , hashv ) ;
/*N1D*/                                                                 soulLinkInner >> hashv ;
/*N1D*/    
/*N1D*/                                                                 ZE( countT , hashId ) ;
/*N1D*/                                                                 soulLinkInner >> hashId ;
/*N1D*/    
/*N1D*/                                                                 ZE( strokeS* , psttText ) ;
/*N1D*/                                                                 soulLinkInner >> psttText ; ___( psttText ) ;
/*N1D*/    
/*N1D*/                                                                 if( !psttText )
/*N1D*/                                                                 {
/*N1D*/                                                                     traceF( tinP , T("error: no text is associated with this label [psttLabel]:    ")+T(psttLabel) ) ;
/*N1D*/                                                                     strMakeF( tinP , LF , psttText , T("[error: no text is associated with this label]") ) ; ___( psttText ) ;
/*N1D*/                                                                 }
/*N1D*/                                                                 delF( tinP , psttLabel ) ;
/*N1D*/    
/*N1D*/                                                                 // TRIM THE TEXT
/*N1D*/                                                                 {
/*N1D*/                                                                     countT idf = 1 ;
/*N1D*/                                                                     ZE( countT , idl ) ;
/*N1D*/                                                                     strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
/*N1D*/                                                                     if( strIdF( tinP , idf , sttq , sttMark01 , psttText , idl , 1 ) )
/*N1D*/                                                                     {
/*N1D*/                                                                         strokeS* psttd = psttText ;
/*N1D*/                                                                                          psttText = 0 ;
/*N1D*/    
/*N1D*/                                                                         strSubstringF( tinP , psttText , idf , sttq , sttMark01 , psttd ) ; ___( psttText ) ;
/*N1D*/                                                                         delF( tinP , psttd ) ;
/*N1D*/                                                                     }
/*N1D*/                                                                     //traceF( tinP , T("got trimmed [text]:   \"")+T(psttText)+T("\"") ) ;
/*N1D*/                                                                 }
/*N1D*/    
/*N1D*/                                                                 strFuseF( tinP , soulReportLinkage , T(psttText)+T("\" }\r\n        }\r\n") ) ;
/*N1D*/                                                                 delF( tinP , psttText ) ;
/*N1D*/                                                             }
/*N1D*/                                                             strFuseF( tinP , soulReportLinkage , T("    }\r\n}\r\n") ) ;
/*N1D*/                                                         }
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     if( !POOP )
/*N1D*/                                                     {
/*N1D*/                                                         {
/*N1D*/                                                             handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
/*N1D*/                                                             fileOpenF( tinP , hFile , countTC() , tFolderFile+T(".link.pages.soul.not.html") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ; // ".not.html" IS USED TO DEFEAT THE BRAIN DEAD STUPID PRACTICE BY HTTP SERVERS OF REFUSING TO SERVE REQUESTS BASED ON FILE EXTENSION
/*N1D*/                                                             fileWriteF( tinP , hFile , soulLinkOuter ) ;
/*N1D*/                                                         }
/*N1D*/    
/*N1D*/                                                         //TO FIND A BUG
/*N1D*/                                                         //while( soulReportLinkage )
/*N1D*/                                                         //{
/*N1D*/                                                         //    ZE( strokeS* , psttp ) ;
/*N1D*/                                                         //    soulReportLinkage >> psttp ; ___( psttp ) ;
/*N1D*/                                                         //    LOGrAW( T(psttp) ) ;
/*N1D*/                                                         //}
/*N1D*/    
/*N1D*/                                                         handleC hFile2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
/*N1D*/                                                         fileOpenF( tinP , hFile2 , countTC() , tFolderFile+T(".link.pages.txt") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ; // READABLE LIST OF LINKAGE LABELS
/*N1D*/                                                         while( soulReportLinkage )
/*N1D*/                                                         {
/*N1D*/                                                             ZE( strokeS* , psttp ) ;
/*N1D*/                                                             soulReportLinkage >> psttp ; ___( psttp ) ;
/*N1D*/    
/*N1D*/                                                             ZE( osTextT* , postp ) ;
/*N1D*/                                                             countT costp = strMakeF( tinP , LF , postp , psttp ) ; ___( postp ) ;
/*N1D*/                                                             delF( tinP , psttp ) ;
/*N1D*/    
/*N1D*/                                                             fileWriteF( tinP , hFile2 , postp , costp ) ;
/*N1D*/                                                         }
/*N1D*/                                                     }
/*N1D*/                                                 }
/*N1D*/
/*N1D*/                                                 /**/if( bTrace ) traceF( tinP , T("etherSoilF / loaded  knowledge tree branches") ) ;
/*N1D*/                                                 if( POOP ) POOPR
/*N1D*/                                                 else
/*N1D*/                                                 {
/*N1D*/                                                     ZE( strokeS* , psttLever ) ;
/*N1D*/                                                     switchC swUrlReferenced( tinP , third , TAG( TAGiDnULL) , flSTACKc_null , psttLever ) ;
/*N1D*/                                                 
/*N1D*/                                                     {
/*N1D*/                                                         ZE( strokeS* , psttBanner1 ) ;
/*N1D*/                                                         ZE( strokeS* , psttBanner2 ) ;
/*N1D*/                                                         switch( idKtrMode )
/*N1D*/                                                         {
/*N1D*/                                                             case ifcIDmODEpUTfILE_ROOT  :
/*N1D*/                                                             {
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.root") )
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.root") )
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 break ;
/*N1D*/                                                             }
/*N1D*/                                                             case ifcIDmODEpUTfILE_PAID  :
/*N1D*/                                                             {
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.paid") )
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.paid") )
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 break ;
/*N1D*/                                                             }
/*N1D*/                                                             case ifcIDmODEpUTfILE_TUTORIALS    :
/*N1D*/                                                             {
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.tutorials") )
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.tutorials") )
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 break ;
/*N1D*/                                                             }
/*N1D*/                                                             case ifcIDmODEpUTfILE_BUNDLE       :
/*N1D*/                                                             {
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.bundle") )
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.bundle") )
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 break ;
/*N1D*/                                                             }
/*N1D*/                                                             case ifcIDmODEpUTfILE_NEWS    :
/*N1D*/                                                             {
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.news") )
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.news") )
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 break ;
/*N1D*/                                                             }
/*N1D*/                                                             case ifcIDmODEpUTfILE_ESSAYS       :
/*N1D*/                                                             {
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.essays") )
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.essays") )
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 break ;
/*N1D*/                                                             }
/*N1D*/                                                             case ifcIDmODEpUTfILE_ARCHIVE      :
/*N1D*/                                                             {
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.archive") )
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.archive") )
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 break ;
/*N1D*/                                                             }
/*N1D*/                                                             case ifcIDmODEpUTfILE_WO          :
/*N1D*/                                                             {
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.bio") )
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.bio") )
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 break ;
/*N1D*/                                                             }
/*N1D*/                                                             case ifcIDmODEpUTfILE_PAY          :
/*N1D*/                                                             {
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.pay") )
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.pay") )
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 break ;
/*N1D*/                                                             }
/*N1D*/                                                             case ifcIDmODEpUTfILE_IPDOS        :
/*N1D*/                                                             {
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.ipdos") )
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.ipdos") )
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 break ;
/*N1D*/                                                             }
/*N1D*/                                                             case ifcIDmODEpUTfILE_OTHER        :
/*N1D*/                                                             default                            :
/*N1D*/                                                             {
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.other") )
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.other") )
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 break ;
/*N1D*/                                                             }
/*N1D*/                                                         }
/*N1D*/                                                                 
/*N1D*/                                                         if( !psttBanner1 )
/*N1D*/                                                         {
/*N1D*/                                                             GETsETTING( *this , psttnu1 , T("!ktr.banner1") )
/*N1D*/                                                             psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                         }
/*N1D*/                                                                 
/*N1D*/                                                         if( !psttBanner2 )
/*N1D*/                                                         {
/*N1D*/                                                             GETsETTING( *this , psttnu1 , T("!ktr.banner1") )
/*N1D*/                                                             psttBanner2 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         __Z( psttBanner1 ) ;
/*N1D*/                                                         __Z( psttBanner2 ) ;
/*N1D*/
/*N1D*/                                                         if( POOP )
/*N1D*/                                                         {
/*N1D*/                                                             POOPR
/*N1D*/
/*N1D*/                                                             if( !psttBanner1 )
/*N1D*/                                                             {
/*N1D*/                                                                 traceF( tinP , T("banner1 setting could not be retrieved ; using default banner1") ) ;
/*N1D*/                                                                 strMakeF( tinP , LF , psttBanner1 , T("") ) ; ___( psttBanner1 ) ;
/*N1D*/                                                             }
/*N1D*/
/*N1D*/                                                             if( !psttBanner2 )
/*N1D*/                                                             {
/*N1D*/                                                                 traceF( tinP , T("banner2 setting could not be retrieved ; using default banner2") ) ;
/*N1D*/                                                                 strMakeF( tinP , LF , psttBanner2 , T("") ) ; ___( psttBanner2 ) ;
/*N1D*/                                                             }
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         ZE( countT , timeN1 ) ;
/*N1D*/                                                         ZE( sCountT , timeN2 ) ;
/*N1D*/                                                         osTimeNowF( tinP , timeN1 , timeN2 ) ;
/*N1D*/
/*N1D*/                                                         ZE( strokeS* , psttTimeN ) ;
/*N1D*/                                                         strFromTimeF( tinP , psttTimeN , timeN1 , timeN2 , 4 , 7 , S1C('.') , 0 , ifcIDfORMATtIME_NUMERIC , flFORMAT_null ) ; ___( psttTimeN ) ;
/*N1D*/
/*N1D*/                                                         ZE( strokeS* , psttTimeT ) ;
/*N1D*/                                                         strFromTimeF( tinP , psttTimeT , timeN1 , timeN2 , 9 , 0xc , S1C('.') , 0 , ifcIDfORMATtIME_TEXT    , flFORMAT_null ) ; ___( psttTimeT ) ;
/*N1D*/
/*N1D*/                                                         // 20150128@1620: IT IS NOW ILLEGAL TO SPECIFY THE head AND tail KEYS, BUT THIS IS NOT ENFORCED
/*N1D*/                                                         // THE CODE REMAINS FOR USE AS A CODE MINE
/*N1D*/                                                         // WO POSSIBILITY IS TO ALLLOW THE SOIL FILE TO SPECIFY HEAD AND TAIL SUFFIXES THAT putFileIF WILL APPEND TO THE HEAD AND TAIL VALUES THAT IT CALCULATES AND USES
/*N1D*/                                                         // THIS CHANGE WAS MADE FOR OO REASONS
/*N1D*/                                                         // WOTH, THE CURRENT CODE DOES NOT SUPPORT CURLEY AND SQUARE BRACKETS IN THE HEAD VALUE, WHICH ARE REQUIRED IN ORDER TO SUPPORT THE USE OF GOOGLE AD WORDS TRACKING TAGS
/*N1D*/                                                         // OOTH, putFileIF NEEDS TO CALCULATE HEAD SO THAT IT CAN EMIT BOTH A BLACK AND A WHITE FLAVOR OF EACH FILE
/*N1D*/
/*N1D*/                                                         // 20150202@1600: tHead tTail RENAMED AND REPURPOSED TO tHtmlBodyPrefix tHtmlBodySuffix tHtmlHead.  WILL BE USED TO ALLOW USER TO CONTROL THE HTML RATHER THAN HAVE IT HARDCODED JUST FOR MY USE
/*N1D*/
/*N1D*/                                                         traceF( tinP , T("etherSoilF [tHtmlFolder]: ")+tHtmlFolder ) ;
/*N1D*/
/*N1D*/                                                         putFileS arg( tinP , *this , psttLever , swUrlReferenced , TUCK << 1 , tFolderFile , idKtrMode , flagsPutFile ) ;
/*N1D*/                                                         branchS::putFileIF( tinP , *tinP.pEtScratch , bQuitP , arg , jotBranches , 2 | jotBranches.tagHighNibbleF() , T(psttTimeN)+T(" : ")+T(psttTimeT) , psttBanner1 , psttBanner2 , tNameSpace , postSourceP , costSourceP ) ;
/*N1D*/
/*N1D*/                                                         delF( tinP , psttBanner1 ) ;
/*N1D*/                                                         delF( tinP , psttBanner2 ) ;
/*N1D*/                                                     }
/*N1D*/                                                 
/*N1D*/                                                     if( POOP )
/*N1D*/                                                     {
/*N1D*/                                                         POOPR
/*N1D*/                                                         traceF( tinP , T("error: could not create the html files, or an infinite loop was detected when doing so.") ) ;
/*N1D*/                                                     }
/*N1D*/                                                     else
/*N1D*/                                                     {
/*N1D*/                                                         countT cFlavors = swUrlReferenced.cFlavorsF( tinP ) ;
/*N1D*/                                                         for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
/*N1D*/                                                         {
/*N1D*/                                                             psttLever = (strokeS*)swUrlReferenced.leverF( tinP , idf ) ;
/*N1D*/                                                             countT cRef = swUrlReferenced ;
/*N1D*/                                                             traceF( tinP , T("etherSoilF swUrlReferenced [idf,cRef,lever]: ")+TF3(idf,flFORMAT_NObIGITvALUES,9)+T("    ")+TF3(cRef,flFORMAT_NObIGITvALUES,9)+T("\"")+T(psttLever)+T("\"") ) ;
/*N1D*/                                                         }
/*N1D*/                                                 
/*N1D*/                                                         traceF( tinP , T("ok") ) ;
/*N1D*/                                                     }
/*N1D*/                                                 }
/*N1D*/
/*N1D*/                                                 ZE( countT , timeB1 ) ;
/*N1D*/                                                 ZE( sCountT , timeB2 ) ;
/*N1D*/                                                 osTimeNowF( tinP , timeB1 , timeB2 ) ;
/*N1D*/                                                 osTimeSubtractF( tinP , timeB1 , timeB2 , timeA1 , timeA2 ) ;
/*N1D*/                                                 traceF( tinP , T("elapsed time to load branches and put html files: ")+TT(timeB1,timeB2) ) ;
/*N1D*/                                             }
/*N1D*/
/*N1D*/                                             tFolder = tFolderDefault ;
/*N1D*/                                             traceF( tinP , T("reset to default [tFolder]: ")+tFolder ) ; //U:: TO FIND A BUG
/*N1D*/                                             tJobQueueRepeat = tJobQueueFolder = tReportsSource = tReportsFolder = tHtmlHead = tHtmlBodySuffix = tHtmlBodyPrefix = tHtmlFolder = tn ;
/*N1D*/
/*N1D*/                                             {
/*N1D*/                                                 ZE( strokeS* , psttm ) ;
/*N1D*/                                                 diskMapFileNameF( tinP , psttm , T("///ideafarm/IdeaFarm (tm)/")+( tUserOverride.csF( tinP ) ? tUserOverride : tUser )+T("/Drop Files Here To Archive/") ) ; ___( psttm ) ;
/*N1D*/                                                 tArchive = T(psttm) ;
/*N1D*/                                                 //traceF( tinP , T("set 4 [tArchive]: ")+tArchive ) ;
/*N1D*/                                                 delF( tinP , psttm ) ;
/*N1D*/                                             }
/*N1D*/
/*N1D*/                                             soulBody.removeAllF( tinP ) ;
/*N1D*/                                             flagsLoad    = flBRANCHslOADf_null    ;
/*N1D*/                                             flagsPutFile = flBRANCHspUTfILEf_null ;
/*N1D*/                                             flagsReport  = flETHERsOILrEPORT_null ;
/*N1D*/                                         }
/*N1D*/
/*N1D*/                                         break ;
/*N1D*/                                     }
/*N1D*/                                 }
/*N1D*/                             }
/*N1D*/                             else if( tKeyLevel1 == tKeySettings )
/*N1D*/                             {
/*N1D*/                                 switch( idModeP )
/*N1D*/                                 {
/*N1D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N1D*/                                     {
/*N1D*/                                         const countT idMemorySpace = !strCompareF( tinP , tMemory , tn )
/*N1D*/                                             ? ifcIDmEMORYsPACE_APPLICATION
/*N1D*/                                             : !strCompareF( tinP , tMemory , T("application") )
/*N1D*/                                                 ? ifcIDmEMORYsPACE_APPLICATION
/*N1D*/                                                 : !strCompareF( tinP , tMemory , T("cloak") )
/*N1D*/                                                     ? ifcIDmEMORYsPACE_CLOAK
/*N1D*/                                                     : !strCompareF( tinP , tMemory , T("kernel") )
/*N1D*/                                                         ? ifcIDmEMORYsPACE_KERNEL
/*N1D*/                                                         : !strCompareF( tinP , tMemory , T("membrane") )
/*N1D*/                                                             ? ifcIDmEMORYsPACE_MEMBRANE
/*N1D*/                                                             : !strCompareF( tinP , tMemory , T("watch") )
/*N1D*/                                                                 ? ifcIDmEMORYsPACE_WATCH
/*N1D*/                                                                 : !strCompareF( tinP , tMemory , T("relay") )
/*N1D*/                                                                     ? ifcIDmEMORYsPACE_BANGrELAY
/*N1D*/                                                                     : 0
/*N1D*/                                         ;
/*N1D*/
/*N1D*/                                         if( !idMemorySpace )
/*N1D*/                                         {
/*N1D*/                                             traceF( tinP , T("error: unknown memory specification:    ")+tMemory ) ;
/*N1D*/                                         }
/*N1D*/                                         else
/*N1D*/                                         {
/*N1D*/                                             osTextT postTiny[] = "kv.settings.ipdos" ;
/*N1D*/
/*N1D*/                                             //DELETE ALL OF THE EXISTING FILES ASSOCIATED WITH kv HERE
/*N1D*/                                             {
/*N1D*/                                                 osTextT postPath[ TUCK << 1 ] ;
/*N1D*/
/*N1D*/                                                 THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
/*N1D*/                                                 thirdC::postPathStateSpaceIF( tinP , postPath , sizeof postPath , ifcIDsTATEsPACE_MULTIPLEaDAMS , idMemorySpace ) ;
/*N1D*/                                                 THREADmODE3rESTORE
/*N1D*/                                                 __Z( *postPath ) ;
/*N1D*/
/*N1D*/                                                 if( !POOP )
/*N1D*/                                                 {
/*N1D*/                                                     ifFileNameC iffn( tinP , third , postPath ) ;
/*N1D*/
/*N1D*/                                                     traceF( tinP , T("state space path: ")+T(iffn) ) ;
/*N1D*/
/*N1D*/                                                     fileNameC fnLike( tinP , *this , T(iffn)+T(postTiny)+T(".*") ) ;
/*N1D*/                                                     patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/
/*N1D*/                                                     ZE( strokeS* , pstt1f ) ;
/*N1D*/                                                     countT cFound = diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat , 0 , 0 , 0 , 8 ) ; ___( pstt1f ) ;
/*N1D*/                                                     FORsTRINGSiN1( pstt1f )
/*N1D*/                                                     {
/*N1D*/                                                         //traceF( tinP , T("deleting: ")+T(psttc1) ) ;
/*N1D*/                                                         diskFileOrDirDeleteF( tinP , psttc1 ) ;
/*N1D*/                                                         //traceF( tinP , T("deleted : ")+T(psttc1) ) ;
/*N1D*/                                                     }
/*N1D*/                                                     delF( tinP , pstt1f ) ;
/*N1D*/                                                 }
/*N1D*/                                             }
/*N1D*/
/*N1D*/                                             THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
/*N1D*/                                             keyValuePairsC kv( tinP , postTiny , flKEYvALUEpAIRSc_WRITE , ifcIDsTATEsPACE_MULTIPLEaDAMS , 0x15 , 0 , 0 , 0 , 0 , idMemorySpace ) ;
/*N1D*/                                             THREADmODE3rESTORE
/*N1D*/
/*N1D*/                                             countT cFlavors = swSettings.cFlavorsF( tinP ) ;
/*N1D*/                                             for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
/*N1D*/                                             {
/*N1D*/                                                 psttzLeverSettings = (strokeS*)swSettings.leverF( tinP , idf ) ;
/*N1D*/
/*N1D*/                                                 strokeS*& psttv = *(strokeS**)&(countT&)swSettings ;
/*N1D*/                                                 traceF( tinP , T("settings [key,value]:    \"")+T(psttzLeverSettings)+T("\"    \"")+T(psttv)+T("\"") ) ;
/*N1D*/
/*N1D*/                                                 ZE( osTextT* , postk ) ;
/*N1D*/                                                 ZE( osTextT* , postv ) ;
/*N1D*/                                                 countT costk = strMakeF( tinP , LF , postk , psttzLeverSettings ) ; ___( postk ) ;
/*N1D*/                                                 countT costv = strMakeF( tinP , LF , postv , psttv    ) ; ___( postv ) ;
/*N1D*/                                                 for( countT offr = 0 ; offr < costk ; offr ++ ) postk[ offr ] = reverseBitsF( postk[ offr ] ) ; // SO THAT WALKING kv WILL PRESENT THE KEYS IN THE NORMAL COLLATION ORDER
/*N1D*/
/*N1D*/                                                 //TO FIND A BUG
/*N1D*/                                                 //byteT bug = 0xff ;
/*N1D*/                                                 //kv.newF( tinP , LF , &bug , 0 , 1 , postv , costv + 1 ) ;
/*N1D*/
/*N1D*/                                                 //kv.newF( tinP , LF , postk , 0 , 1 , postv , costv + 1 ) ;
/*N1D*/
/*N1D*/                                                 kv.newF( tinP , LF , postk , 0 , costk * SB , postv , costv + 1 ) ;
/*N1D*/
/*N1D*/                                                 delF( tinP , postk ) ;
/*N1D*/                                                 delF( tinP , psttv ) ;
/*N1D*/                                             }
/*N1D*/                                             swSettings.freeAllF( tinP ) ;
/*N1D*/                                         }
/*N1D*/
/*N1D*/                                         tMemory = tn ;
/*N1D*/
/*N1D*/                                         break ;
/*N1D*/                                     }
/*N1D*/                                 }
/*N1D*/                             }
/*N1D*/                             else if( tKeyLevel1 == tKeyRenameToHash )
/*N1D*/                             {
/*N1D*/                                 switch( idModeP )
/*N1D*/                                 {
/*N1D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N1D*/                                     {
/*N1D*/                                         if( tFolder.csF( tinP ) )
/*N1D*/                                         {
/*N1D*/                                             diskMakeDirF( tinP , tFolder ) ;
/*N1D*/                                             diskRenameToHashF( tinP , tFolder , flETHERrENAMEtOhASH_RECURSE ) ;
/*N1D*/                                             tFolder = tn ;
/*N1D*/                                         }
/*N1D*/
/*N1D*/                                         break ;
/*N1D*/                                     }
/*N1D*/                                 }
/*N1D*/                             }
/*N1D*/                             else if( tKeyLevel1 == tKeySplit )
/*N1D*/                             {
/*N1D*/                                 switch( idModeP )
/*N1D*/                                 {
/*N1D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N1D*/                                     {
/*N1D*/                                         if( tFolderFrom.csF( tinP ) && sizeBytes )
/*N1D*/                                         {
/*N1D*/                                             if( !tFolderTo.csF( tinP) ) tFolderTo = tFolderFrom ;
/*N1D*/
/*N1D*/                                             traceF( tinP , T("splitting all data files larger than ")+TF2(sizeBytes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" in ")+tFolderFrom+T(" into parts placed into ")+tFolderTo ) ;
/*N1D*/
/*N1D*/                                             diskMakeDirF( tinP , tFolderFrom ) ;
/*N1D*/                                             diskMakeDirF( tinP , tFolderTo ) ;
/*N1D*/
/*N1D*/                                             {
/*N1D*/                                                 fileNameC fnLike( tinP , *this , tFolderFrom+T("*.meta.part.*") ) ;
/*N1D*/                                                 patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                        
/*N1D*/                                                 ZE( strokeS* , pstt1f ) ;
/*N1D*/                                                 diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat ) ; ___( pstt1f ) ;
/*N1D*/                                                 FORsTRINGSiN1( pstt1f )
/*N1D*/                                                 {
/*N1D*/                                                     diskFileOrDirDeleteF( tinP , psttc1 ) ;
/*N1D*/                                                 }
/*N1D*/                                             }
/*N1D*/
/*N1D*/                                             {
/*N1D*/                                                 fileNameC fnLike( tinP , *this , tFolderTo+T("*.meta.part.*") ) ;
/*N1D*/                                                 patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                        
/*N1D*/                                                 ZE( strokeS* , pstt1f ) ;
/*N1D*/                                                 diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat ) ; ___( pstt1f ) ;
/*N1D*/                                                 FORsTRINGSiN1( pstt1f )
/*N1D*/                                                 {
/*N1D*/                                                     diskFileOrDirDeleteF( tinP , psttc1 ) ;
/*N1D*/                                                 }
/*N1D*/                                             }
/*N1D*/
/*N1D*/                                             {
/*N1D*/                                                 fileNameC fnLike( tinP , *this , tFolderFrom+T("*.meta.numparts.*") ) ;
/*N1D*/                                                 patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                        
/*N1D*/                                                 ZE( strokeS* , pstt1f ) ;
/*N1D*/                                                 diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat ) ; ___( pstt1f ) ;
/*N1D*/                                                 FORsTRINGSiN1( pstt1f )
/*N1D*/                                                 {
/*N1D*/                                                     diskFileOrDirDeleteF( tinP , psttc1 ) ;
/*N1D*/                                                 }
/*N1D*/                                             }
/*N1D*/
/*N1D*/                                             {
/*N1D*/                                                 fileNameC fnLike( tinP , *this , tFolderTo+T("*.meta.numparts.*") ) ;
/*N1D*/                                                 patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                        
/*N1D*/                                                 ZE( strokeS* , pstt1f ) ;
/*N1D*/                                                 diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat ) ; ___( pstt1f ) ;
/*N1D*/                                                 FORsTRINGSiN1( pstt1f )
/*N1D*/                                                 {
/*N1D*/                                                     diskFileOrDirDeleteF( tinP , psttc1 ) ;
/*N1D*/                                                 }
/*N1D*/                                             }
/*N1D*/
/*N1D*/                                             TN( tLike , "" ) ; tLike = tFolderFrom+tStarDotData ;
/*N1D*/                                             if( diskFileExistsF( tinP , tLike ) )
/*N1D*/                                             {
/*N1D*/                                                 fileNameC fnLike( tinP , *this , tLike ) ;
/*N1D*/                                                 patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                        
/*N1D*/                                                 strokeS sttSlash( '/' ) ;
/*N1D*/                                                 ZE( infoFileS* , pInfo ) ;
/*N1D*/                                                 handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
/*N1D*/                                                 do
/*N1D*/                                                 {
/*N1D*/                                                     diskFindFileOrDirF( tinP , pInfo , hFind , fnLike.pathF() , &pat ) ;
/*N1D*/                                                     if( pInfo && strIdF( tinP , sttSlash , pInfo->psttIfoName , - 1 ) != pInfo->psttIfoName->idAdam && ( pInfo->cbUsedHigh || sizeBytes < pInfo->cbUsed ) )
/*N1D*/                                                     {
/*N1D*/                                                         TN( tShort , "" ) ;
/*N1D*/                                                         {
/*N1D*/                                                             ZE( strokeS* , psttPath ) ;
/*N1D*/                                                             ZE( strokeS* , psttShort ) ;
/*N1D*/                                                             strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
/*N1D*/                                                             ___( psttPath ) ;
/*N1D*/                                                             ___( psttShort ) ;
/*N1D*/                                                             __( strCompareF( tinP , psttPath ,tFolderFrom ) ) ;
/*N1D*/                                                             tShort = T(psttShort) ;
/*N1D*/                                                             delF( tinP , psttPath ) ;
/*N1D*/                                                             delF( tinP , psttShort ) ;
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         TN( tShortNoSuffix , "" ) ;
/*N1D*/                                                         {
/*N1D*/                                                             ZE( strokeS* , psttShortNoSuffix ) ;
/*N1D*/                                                             ZE( strokeS* , psttSuffix ) ;
/*N1D*/                                                             strBisectF( tinP , psttShortNoSuffix , psttSuffix , tShort , T(".") , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
/*N1D*/                                                             ___( psttSuffix ) ;
/*N1D*/                                                             ___( psttShortNoSuffix ) ;
/*N1D*/                                                             tShortNoSuffix = T(psttShortNoSuffix) ;
/*N1D*/                                                             delF( tinP , psttSuffix ) ;
/*N1D*/                                                             delF( tinP , psttShortNoSuffix ) ;
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         fileC fi( tinP , pInfo->psttIfoName ) ;
/*N1D*/                                                         countT cbInRemain     = pInfo->cbUsed     ;
/*N1D*/                                                         countT cbInRemainHigh = pInfo->cbUsedHigh ;
/*N1D*/
/*N1D*/                                                         ZE( fileC* , pFo ) ;
/*N1D*/                                                         ZE( countT , cbOutRemainPart ) ;
/*N1D*/                                                         ZE( countT , idPartLath ) ;
/*N1D*/                                                         while( cbInRemain || cbInRemainHigh && !POOP )
/*N1D*/                                                         {
/*N1D*/                                                             if( !pFo )
/*N1D*/                                                             {
/*N1D*/                                                                 pFo = new( 0 , tinP , LF ) fileC( tinP , (strokeS*)( tFolderTo+tShortNoSuffix+T("meta.part.")+TF3(++idPartLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ; ___( pFo ) ;
/*N1D*/                                                                 __Z( pFo ) ;
/*N1D*/           
/*N1D*/                                                                 cbOutRemainPart = !cbInRemainHigh && cbInRemain < sizeBytes
/*N1D*/                                                                     ? cbInRemain
/*N1D*/                                                                     : sizeBytes
/*N1D*/                                                                 ;
/*N1D*/                                                             }
/*N1D*/                                                             
/*N1D*/                                                             countT cbChunk = TOCK ;
/*N1D*/                                                             if( !cbInRemainHigh && cbChunk > cbInRemain      ) cbChunk = cbInRemain      ;
/*N1D*/                                                             if(                    cbChunk > cbOutRemainPart ) cbChunk = cbOutRemainPart ;
/*N1D*/
/*N1D*/                                                             ZE( byteT*, pbChunk ) ;
/*N1D*/                                                             newF( tinP , LF , pbChunk , cbChunk ) ; ___( pbChunk ) ;
/*N1D*/                                                             __Z( pbChunk ) ;
/*N1D*/
/*N1D*/                                                             if( !POOP )
/*N1D*/                                                             {
/*N1D*/                                                                 fileReadF(  tinP        , pbChunk , cbChunk , fi ) ;
/*N1D*/                                                                 fileWriteF( tinP , *pFo , pbChunk , cbChunk      ) ;
/*N1D*/
/*N1D*/                                                                 cbOutRemainPart -= cbChunk ;
/*N1D*/
/*N1D*/                                                                 if( !cbInRemainHigh ) cbInRemain -= cbChunk ;
/*N1D*/                                                                 else
/*N1D*/                                                                 {
/*N1D*/                                                                     countT save = cbInRemain ;
/*N1D*/                                                                                   cbInRemain -= cbChunk ;
/*N1D*/
/*N1D*/                                                                     if( cbInRemain > save ) cbInRemainHigh -- ;
/*N1D*/                                                                 }
/*N1D*/                                                             }
/*N1D*/                                                             delF( tinP , pbChunk ) ;
/*N1D*/
/*N1D*/                                                             if( !cbOutRemainPart ) DEL( pFo ) ;
/*N1D*/                                                         }
/*N1D*/                                                         __NZ( pFo ) ;
/*N1D*/
/*N1D*/                                                         fileC foTally( tinP , (strokeS*)( tFolderTo+tShortNoSuffix+T("meta.numparts.")+TF3(idPartLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
/*N1D*/                                                     }
/*N1D*/                                                     DEL( pInfo ) ;
/*N1D*/                                                 }
/*N1D*/                                                 while( !etherC::etPrimeIF( tinP ) && ~hFind ) ;
/*N1D*/                                             }
/*N1D*/                                         }
/*N1D*/                                         tFolderFrom = tn ;
/*N1D*/                                         tFolderTo = tn ;
/*N1D*/                                         sizeBytes = 0 ;
/*N1D*/
/*N1D*/                                         break ;
/*N1D*/                                     }
/*N1D*/                                 }
/*N1D*/                             }
/*N1D*/                             else if( tKeyLevel1 == tKeyJoin )
/*N1D*/                             {
/*N1D*/                                 switch( idModeP )
/*N1D*/                                 {
/*N1D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N1D*/                                     {
/*N1D*/                                         if( tFolderFrom.csF( tinP ) )
/*N1D*/                                         {
/*N1D*/                                             if( !tFolderTo.csF( tinP) ) tFolderTo = tFolderFrom ;
/*N1D*/
/*N1D*/                                             traceF( tinP , T("joining all *.meta.part.* files in ")+tFolderFrom+T(" into *.data files placed into ")+tFolderTo ) ;
/*N1D*/
/*N1D*/                                             diskMakeDirF( tinP , tFolderFrom ) ;
/*N1D*/                                             diskMakeDirF( tinP , tFolderTo ) ;
/*N1D*/
/*N1D*/                                             {
/*N1D*/                                                 fileNameC fnLike( tinP , *this , tFolderFrom+T("*.meta.numparts.*") ) ;
/*N1D*/                                                 patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                        
/*N1D*/                                                 TN( tData , "data" ) ;
/*N1D*/                                                 ZE( strokeS* , pstt1f ) ;
/*N1D*/                                                 diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat ) ; ___( pstt1f ) ;
/*N1D*/                                                 FORsTRINGSiN1( pstt1f )
/*N1D*/                                                 {
/*N1D*/                                                     traceF( tinP , T("join / *.meta.numparts.*: ")+T(psttc1) ) ;
/*N1D*/
/*N1D*/                                                     TN( tShort , "" ) ;
/*N1D*/                                                     {
/*N1D*/                                                         ZE( strokeS* , psttPath ) ;
/*N1D*/                                                         ZE( strokeS* , psttShort ) ;
/*N1D*/                                                         strBisectF( tinP , psttPath , psttShort , psttc1 , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
/*N1D*/                                                         ___( psttPath ) ;
/*N1D*/                                                         ___( psttShort ) ;
/*N1D*/                                                         __( strCompareF( tinP , psttPath ,tFolderFrom ) ) ;
/*N1D*/                                                         tShort = T(psttShort) ;
/*N1D*/                                                         delF( tinP , psttPath ) ;
/*N1D*/                                                         delF( tinP , psttShort ) ;
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     TN( tShortNoSuffix , "" ) ;
/*N1D*/                                                     TN( tSuffix , "" ) ;
/*N1D*/                                                     {
/*N1D*/                                                         ZE( strokeS* , psttShortNoSuffix ) ;
/*N1D*/                                                         ZE( strokeS* , psttSuffix ) ;
/*N1D*/                                                         strBisectF( tinP , psttShortNoSuffix , psttSuffix , tShort , T(".") , - 3 , flSTRbISECT_APPENDdELIMITER ) ;
/*N1D*/                                                         ___( psttSuffix ) ;
/*N1D*/                                                         ___( psttShortNoSuffix ) ;
/*N1D*/                                                         tShortNoSuffix = T(psttShortNoSuffix) ;
/*N1D*/                                                         tSuffix = T(psttSuffix) ;
/*N1D*/                                                         delF( tinP , psttSuffix ) ;
/*N1D*/                                                         delF( tinP , psttShortNoSuffix ) ;
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     ZE( countT , numParts ) ;
/*N1D*/                                                     {
/*N1D*/                                                         ZE( strokeS* , psttNU ) ;
/*N1D*/                                                         ZE( strokeS* , psttNumParts ) ;
/*N1D*/                                                         strBisectF( tinP , psttNU , psttNumParts , tSuffix , T(".") , - 1 ) ;
/*N1D*/                                                         ___( psttNumParts ) ;
/*N1D*/                                                         ___( psttNU ) ;
/*N1D*/                                                         numParts = strDigitsToSCountF( tinP , psttNumParts , 0 , 1 ) ;
/*N1D*/                                                         delF( tinP , psttNumParts ) ;
/*N1D*/                                                         delF( tinP , psttNU ) ;
/*N1D*/                                                     }
/*N1D*/                                                     traceF( tinP , T("numParts: ")+TF2(numParts,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N1D*/
/*N1D*/                                                     boolT bOk = 1 ;
/*N1D*/                                                     ZE( countT , idPartLath ) ;
/*N1D*/                                                     {
/*N1D*/                                                         fileNameC fnLike( tinP , *this , tFolderFrom+tShortNoSuffix+T("meta.part.*") ) ;
/*N1D*/                                                         patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                                
/*N1D*/                                                         ZE( strokeS* , pstt1fp ) ;
/*N1D*/                                                         diskFindFileOrDirF( tinP , pstt1fp , fnLike.pathF() , &pat ) ; ___( pstt1fp ) ;
/*N1D*/                                                         FORsTRINGSiN2( pstt1fp )
/*N1D*/                                                         {
/*N1D*/                                                             traceF( tinP , T("part: ")+T(psttc2) ) ;
/*N1D*/                                                             ZE( countT , idPart ) ;
/*N1D*/                                                             {
/*N1D*/                                                                 ZE( strokeS* , psttNU ) ;
/*N1D*/                                                                 ZE( strokeS* , psttIdPart ) ;
/*N1D*/                                                                 strBisectF( tinP , psttNU , psttIdPart , psttc2 , T(".") , - 1 ) ;
/*N1D*/                                                                 ___( psttIdPart ) ;
/*N1D*/                                                                 ___( psttNU ) ;
/*N1D*/                                                                 idPart = strDigitsToSCountF( tinP , psttIdPart , 0 , 1 ) ;
/*N1D*/                                                                 delF( tinP , psttIdPart ) ;
/*N1D*/                                                                 delF( tinP , psttNU ) ;
/*N1D*/                                                             }
/*N1D*/
/*N1D*/                                                             if( ++ idPartLath != idPart )
/*N1D*/                                                             {
/*N1D*/                                                                 bOk = 0 ;
/*N1D*/                                                                 break ;
/*N1D*/                                                             }
/*N1D*/                                                         }
/*N1D*/                                                         delF( tinP , pstt1fp ) ;
/*N1D*/
/*N1D*/                                                         if( idPartLath != numParts ) bOk = 0 ;
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     if( bOk )
/*N1D*/                                                     {
/*N1D*/                                                         TN( tLongData , "" ) ; tLongData = tFolderTo+tShortNoSuffix+tData ;
/*N1D*/                                                         traceF( tinP , T("i have all parts needed to reassemble ")+tLongData ) ;
/*N1D*/                                                         fileC foData( tinP , (strokeS*)tLongData , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
/*N1D*/
/*N1D*/                                                         fileNameC fnLike( tinP , *this , tFolderFrom+tShortNoSuffix+T("meta.part.*") ) ;
/*N1D*/                                                         patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                                
/*N1D*/                                                         ZE( strokeS* , pstt1fp ) ;
/*N1D*/                                                         diskFindFileOrDirF( tinP , pstt1fp , fnLike.pathF() , &pat ) ; ___( pstt1fp ) ;
/*N1D*/                                                         FORsTRINGSiN3( pstt1fp )
/*N1D*/                                                         {
/*N1D*/                                                             traceF( tinP , T("reading part: ")+T(psttc3) ) ;
/*N1D*/
/*N1D*/                                                             ZE( byteT* , posti ) ;
/*N1D*/                                                             ZE( countT , costi ) ;
/*N1D*/                                                             boxGetShadowF( tinP , posti , costi , psttc3 ) ; ___( posti ) ;
/*N1D*/                                                             fileWriteF( tinP , foData , posti , costi ) ;
/*N1D*/                                                             delF( tinP , posti ) ;
/*N1D*/                                                         }
/*N1D*/                                                         delF( tinP , pstt1fp ) ;
/*N1D*/                                                         traceF( tinP , T("reassembled: ")+tLongData ) ;
/*N1D*/                                                     }
/*N1D*/                                                 }
/*N1D*/                                                 delF( tinP , pstt1f ) ;
/*N1D*/                                             }
/*N1D*/                                         }
/*N1D*/                                         tFolderFrom = tn ;
/*N1D*/                                         tFolderTo = tn ;
/*N1D*/
/*N1D*/                                         break ;
/*N1D*/                                     }
/*N1D*/                                 }
/*N1D*/                             }
/*N1D*/                             else if( tKeyLevel1 == tKeyEdit || tKeyLevel1 == tKeyReport || tKeyLevel1 == tKeyZip || tKeyLevel1 == tKeyInspectFileNames )
/*N1D*/                             {
/*N1D*/                                 boolT idModeWalk = tKeyLevel1 == tKeyReport
/*N1D*/                                     ? ifcIDmODEsOILwALK_REPORT
/*N1D*/                                     : tKeyLevel1 == tKeyEdit
/*N1D*/                                         ? ifcIDmODEsOILwALK_EDIT
/*N1D*/                                         : tKeyLevel1 == tKeyZip
/*N1D*/                                             ? ifcIDmODEsOILwALK_ZIP
/*N1D*/                                             : tKeyLevel1 == tKeyInspectFileNames
/*N1D*/                                                 ? ifcIDmODEsOILwALK_INSPECTfILEnAMES
/*N1D*/                                                 : 0
/*N1D*/                                 ;
/*N1D*/
/*N1D*/                                 switch( idModeP )
/*N1D*/                                 {
/*N1D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N1D*/                                     {
/*N1D*/                                         TN( tPrefix       , "!ideafarm.9.2.00000000.00000001."  ) ;
/*N1D*/                                         TN( tConfidential , "!confidential" ) ;
/*N1D*/                                         TN( tPrivate      , "!private"      ) ;
/*N1D*/                                         TN( tPhone        , "!phone"        ) ;
/*N1D*/                                         TN( tVideophone   , "!videophone"   ) ;
/*N1D*/                                         TN( tExtMp3       , ".mp3"          ) ;
/*N1D*/
/*N1D*/                                         soulC soulFileNames( tinP , TAG( TAGiDnULL )             , ( idModeWalk == ifcIDmODEsOILwALK_ZIP || idModeWalk ==  ifcIDmODEsOILwALK_INSPECTfILEnAMES ) ? flSOUL_null                                             : flSOUL_LIFO , "soul.file.names"         ) ;
/*N1D*/                                         countT pcArg[] = { (countT)this , (countT)&stTimeMinMax , (countT)&soulFileNames , idModeWalk , (countT)(strokeS*)tPrefix , (countT)(strokeS*)tConfidential , (countT)(strokeS*)tPrivate , (countT)(strokeS*)tPhone , (countT)(strokeS*)tVideophone , (countT)(strokeS*)tExtMp3 } ;
/*N1D*/
/*N1D*/                                         ZE( countT , cDirs ) ;
/*N1D*/                                         ZE( countT , cFiles ) ;
/*N1D*/                                         ZE( boolT , bQuit ) ;
/*N1D*/                                         /**/if( bTrace ) traceF( tinP , T("etherSoilF / tKeyReport / loading soulFileNames from [tArchive]: ")+tArchive ) ;
/*N1D*/
/*N1D*/                                         IFsCRATCH
/*N1D*/                                         {
/*N1D*/                                             SCOOPS
/*N1D*/                                             tinP.pEtScratch->diskWalkF( tinP , cDirs , cFiles , tArchive , bQuit , flDISKwALK_null , etherSoilWalkCBF , pcArg ) ; // WILL FAIL IF tUserOverride CONTAINS DOUBLE QUOTE MARKS OR OTHER STROKES THAT MAKE THE PATH NAME INVALID
/*N1D*/                                             if( POOP ) POOPR ;
/*N1D*/                                         }
/*N1D*/
/*N1D*/                                         switch( idModeWalk )
/*N1D*/                                         {
/*N1D*/                                             case ifcIDmODEsOILwALK_REPORT :
/*N1D*/                                             {
/*N1D*/                                                 /**/if( bTrace ) traceF( tinP , T("etherSoilF / tKeyReport / setting up") ) ;
/*N1D*/
/*N1D*/                                                 // FOR EACH FILE (AND ASSOCIATED NOTE FILE IF ANY), TEXT LIKE THIS IS EMITTED AFTER EMITTING A BLANK LEADING LINE:
/*N1D*/                                                 //
/*N1D*/                                                 //       [**__BEGIN__**]\a<file>\a[**__P1__**]
/*N1D*/                                                 //       [**__P3__**]<time>: <title>
/*N1D*/                                                 //        {preIncludeScrub1: \"///ideafarm/IdeaFarm (tm)/SYSTEM/Drop Files Here To"" Archive/<noteFile>\" }
/*N1D*/                                                 //       [**__END__**]
/*N1D*/                                                 //|   
/*N1D*/                                                 //    
/*N1D*/                                                 //       [**__BEGIN__**]\a<file>\a[**__P1__**]
/*N1D*/                                                 //       [**__P3__**]<time>: <title>
/*N1D*/                                                 //        {preIncludeScrub1: \"///ideafarm/IdeaFarm (tm)/SYSTEM/Drop Files Here To"" Archive/<noteFile>\" }
/*N1D*/                                                 //       [**__END__**]
/*N1D*/                                                 //|   
/*N1D*/                                                 //      20131220
/*N1D*/                                                 //    
/*N1D*/                                                 //       [**__BEGIN__**]\a<file>\a[**__P1__**]
/*N1D*/                                                 //       [**__P3__**]<time>: <title>
/*N1D*/                                                 //        {preIncludeScrub1: \"///ideafarm/IdeaFarm (tm)/SYSTEM/Drop Files Here To"" Archive/<noteFile>\" }
/*N1D*/                                                 //       [**__END__**]
/*N1D*/                                                 //|   
/*N1D*/                                                 //    
/*N1D*/                                                 //       [**__BEGIN__**]\a<file>\a[**__P1__**]
/*N1D*/                                                 //       [**__P3__**]<time>: <title>
/*N1D*/                                                 //        {preIncludeScrub1: \"///ideafarm/IdeaFarm (tm)/SYSTEM/Drop Files Here To"" Archive/<noteFile>\" }
/*N1D*/                                                 //       [**__END__**]
/*N1D*/                                                 //|   
/*N1D*/
/*N1D*/                                                 TN( tSet , "" ) ;
/*N1D*/                                                 stackC       stSet( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
/*N1D*/                                                 emitSetParmS esp( tinP , *this , stFileType , bTrace , tArchive ) ;
/*N1D*/                                                 soulC        soulrFileSets( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.r.file.sets" ) ;
/*N1D*/                                                 strFuseF( tinP , soulrFileSets , T(postReportProlog) ) ;
/*N1D*/
/*N1D*/                                                 ZE( strokeS* , psttCurrentNameLag ) ;
/*N1D*/                                                 soulC soulIdFragShort( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/                                                 {
/*N1D*/                                                     TN( tSssDim , "" ) ; tSssDim =           // ".12345678x12345678."
/*N1D*/
/*N1D*/                                                         T("")
/*N1D*/                                                         +S2(sa_SSSaND,sc_ccSSS)
/*N1D*/                                                             +T(".")
/*N1D*/                                                             +S3(0,sc_ccSSSrEPEAT,7)                 // DOES NOT ENFORCE MIN NUMBER OF DIGITS: 4 ; THE MINIMUM 4 CONVENTION IS "GOOD STYLE" TO PROMOTE READABILITY AND SORTABILITY
/*N1D*/                                                             +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)     // 20141017@2254: ALL DIMENSIONED FILES IN THE ARCHIVE USE EXACTLY 4 DIGITS, E.G. FILE NAME ENDS WITH ".0600x.jpg"
/*N1D*/                                                             +T("x")
/*N1D*/
/*N1D*/                                                             //20141017@2254: OLD FORMAT: ".0600x0400."  
/*N1D*/                                                             //               NEW FORMAT: ".0600x."
/*N1D*/                                                             //+S3(0,sc_ccSSSrEPEAT,7)
/*N1D*/                                                             //+S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
/*N1D*/
/*N1D*/                                                             +T(".")
/*N1D*/                                                         +S2(sa_SSSaNDeND,sc_ccSSS)
/*N1D*/                                                                 
/*N1D*/                                                     ;
/*N1D*/
/*N1D*/                                                     //LOGrAW( T("\r\n**** PROCESSING FILE SETS ****\r\n") ) ;
/*N1D*/                                                     strokeS sttDot( '.' ) ;
/*N1D*/                                                     strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
/*N1D*/                                                     ZE( strokeS* , psttp1Lag ) ;
/*N1D*/                                                     ///**/if( bTrace ) traceF( tinP , T("etherSoilF / tKeyReport / beginning to load swsFileNameSet and there are ")+TF2(soulFileNames,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" files") ) ;
/*N1D*/                                                     while( soulFileNames )                                              // idHit:                   ^
/*N1D*/                                                     {                                                                   // idf:                              ^
/*N1D*/                                                         ZE( strokeS* , pstt1NameTriple ) ;                                //           |-----p1------||--sss--||2|
/*N1D*/                                                         soulFileNames >> pstt1NameTriple ; ___( pstt1NameTriple ) ;         // EXAMPLE: "!ideafarm.0.foo.600x400.jpg"
/*N1D*/
/*N1D*/                                                         ZE( strokeS* , psttzFileName ) ;
/*N1D*/                                                         ZE( strokeS* , psttzCurrentName ) ;
/*N1D*/                                                         ZE( strokeS* , psttzShortThumbnail ) ;
/*N1D*/                                                         FORsTRINGSiN1( pstt1NameTriple )
/*N1D*/                                                         {
/*N1D*/                                                                  if( !psttzFileName       ) psttzFileName       = psttc1 ;  // EXAMPLE: "!ideafarm.0.foo.600x400.jpg"
/*N1D*/                                                             else if( !psttzCurrentName    ) psttzCurrentName    = psttc1 ;
/*N1D*/                                                             else if( !psttzShortThumbnail ) psttzShortThumbnail = psttc1 ;
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         ZE( strokeS* , psttFileName ) ;
/*N1D*/                                                         strMakeF( tinP , LF , psttFileName , psttzFileName ) ; ___( psttFileName ) ;
/*N1D*/
/*N1D*/                                                         ZE( strokeS* , psttShortThumbnail ) ;
/*N1D*/                                                         if( psttzShortThumbnail ) { strMakeF( tinP , LF , psttShortThumbnail , psttzShortThumbnail ) ; ___( psttShortThumbnail ) ; }
/*N1D*/
/*N1D*/                                                                            traceF( tinP , T("soulFileNames >> [file]: ")+T(psttzFileName) ) ;
/*N1D*/                                                         ///**/if( bTrace ) traceF( tinP , T("soulFileNames >> [file]: ")+T(psttzFileName) ) ;
/*N1D*/
/*N1D*/                                                         if( (countT)psttzFileName < TUCK ) { BLAMMO ; } //U::TO FIND A BUG
/*N1D*/
/*N1D*/                                                         {
/*N1D*/                                                             countT cRemain = soulFileNames ;
/*N1D*/                                                             if( bTrace && !( cRemain % ( TUCK << 0 ) ) ) traceF( tinP , T("etherSoilF / tKeyReport / loading swsFileNameSet and ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" files remain") ) ;
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         countT idf = 1 ;
/*N1D*/                                                         countT idHit = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tSssDim , psttzFileName , 0 , -1 ) ;
/*N1D*/                                                         if( idHit > 1 && idf && idf == psttzFileName->idAdam - 2 )
/*N1D*/                                                         {
/*N1D*/                                                             countT idAfter = idf ;
/*N1D*/                                                             idf = 1 ;
/*N1D*/                                                             countT idl = idHit - 1 ;
/*N1D*/
/*N1D*/                                                             ZE( strokeS* , psttp1 ) ;
/*N1D*/                                                             strSubstringF( tinP , psttp1 , idf , idl , psttzFileName ) ; ___( psttp1 ) ;
/*N1D*/
/*N1D*/                                                             if( !psttp1Lag ) { strMakeF( tinP , LF , psttp1Lag , psttp1 ) ; ___( psttp1Lag ) ; }
/*N1D*/
/*N1D*/                                                             if( strCompareF( tinP , psttp1 , psttp1Lag ) || strIdF( tinP , T(".!.control.") , psttzFileName ) )
/*N1D*/                                                             {
/*N1D*/                                                                 delF( tinP , psttp1Lag ) ;
/*N1D*/                                                                 strMakeF( tinP , LF , psttp1Lag , psttp1 ) ; ___( psttp1Lag ) ;
/*N1D*/
/*N1D*/                                                                 // 0              1               2               3               4
/*N1D*/                                                                 // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
/*N1D*/                                                                 // !ideafarm.8.2.00000000.00000001.20140328@0556.001.!.note.optionalHtmlFragLabel.ttt
/*N1D*/                                                                 // !ideafarm.9.2.00000000.00000001.20140328@0556.!.note.optionalHtmlFragLabel.ttt
/*N1D*/
/*N1D*/                                                                 //CS:CODEsYNC: DUPLICATE CODE: 360021c1 360021c1
/*N1D*/                                                                 if( psttzFileName->idAdam >= 0x28 && psttzFileName[ CSpREFIX - 1 + 0x1f ] == strokeS( '!' ) ) 
/*N1D*/                                                                 {
/*N1D*/                                                                     ZE( strokeS* , psttw ) ;
/*N1D*/                                                                     countT idf = 0x1e ;
/*N1D*/                                                                     countT idl = 0x25 ;
/*N1D*/                                                                     strSubstringF( tinP , psttw , idf , idl , psttzFileName ) ; ___( psttw ) ;
/*N1D*/
/*N1D*/                                                                     if( !strCompareF( tinP , psttw , esp.psttTestNote ) ) esp.tNoteFileName = T(psttzFileName) ;
/*N1D*/
/*N1D*/                                                                     delF( tinP , psttw ) ;
/*N1D*/                                                                 }
/*N1D*/
/*N1D*/                                                                 emitSetF( tinP , *this , soulrFileSets , soulIdFragShort , tSet , stSet , esp , psttCurrentNameLag ) ;
/*N1D*/                                                             }
/*N1D*/
/*N1D*/                                                             ZE( strokeS* , psttp2 ) ;
/*N1D*/                                                             idf = idAfter ;
/*N1D*/                                                             idl = 0 ;
/*N1D*/                                                             strSubstringF( tinP , psttp2 , idf , idl , psttzFileName ) ; ___( psttp2 ) ;
/*N1D*/
/*N1D*/                                                             tSet = T(psttp1)+sttDot+T(psttp2) ;
/*N1D*/                                                             delF( tinP , psttp1 ) ;
/*N1D*/                                                             delF( tinP , psttp2 ) ;
/*N1D*/
/*N1D*/                                                             ///**/if( bTrace ) traceF( tinP , T("stSet << [set,file]:    \"")+tSet+T("\"    \"")+T(psttzFileName)+T("\"") ) ;
/*N1D*/
/*N1D*/                                                                                        stSet << psttFileName       ; psttFileName       = 0 ;
/*N1D*/                                                             if( psttShortThumbnail ) { stSet << psttShortThumbnail ; psttShortThumbnail = 0 ; }
/*N1D*/                                                         }
/*N1D*/                                                         else
/*N1D*/                                                         {
/*N1D*/                                                             countT idBeforeLathDot = strIdF( tinP , sttDot , psttzFileName , - 1 ) ;
/*N1D*/                                                             if( idBeforeLathDot ) idBeforeLathDot -- ;
/*N1D*/
/*N1D*/                                                             ZE( strokeS* , psttp1 ) ;
/*N1D*/                                                             countT idf = 1 ;
/*N1D*/                                                             countT idl = idBeforeLathDot ;
/*N1D*/                                                             strSubstringF( tinP , psttp1 , idf , idl , psttzFileName ) ; ___( psttp1 ) ;
/*N1D*/
/*N1D*/                                                             if( !psttp1Lag ) { strMakeF( tinP , LF , psttp1Lag , psttp1 ) ; ___( psttp1Lag ) ; }
/*N1D*/
/*N1D*/                                                             if( strCompareF( tinP , psttp1 , psttp1Lag ) || strIdF( tinP , T(".!.control.") , psttzFileName ) )
/*N1D*/                                                             {
/*N1D*/                                                                 delF( tinP , psttp1Lag ) ;
/*N1D*/                                                                 strMakeF( tinP , LF , psttp1Lag , psttp1 ) ; ___( psttp1Lag ) ;
/*N1D*/
/*N1D*/                                                                 // 0              1               2               3               4
/*N1D*/                                                                 // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
/*N1D*/                                                                 // !ideafarm.8.2.00000000.00000001.20140328@0556.001.!.note.optionalHtmlFragLabel.ttt
/*N1D*/                                                                 // !ideafarm.9.2.00000000.00000001.20140328@0556.!.note.optionalHtmlFragLabel.ttt
/*N1D*/
/*N1D*/                                                                 //CS:CODEsYNC: DUPLICATE CODE: 360021c1 360021c1
/*N1D*/                                                                 if( psttzFileName->idAdam >= 0x28 && psttzFileName[ CSpREFIX - 1 + 0x1f ] == strokeS( '!' ) ) 
/*N1D*/                                                                 {
/*N1D*/                                                                     ZE( strokeS* , psttw ) ;
/*N1D*/                                                                     countT idf = 0x1e ;
/*N1D*/                                                                     countT idl = 0x25 ;
/*N1D*/                                                                     strSubstringF( tinP , psttw , idf , idl , psttzFileName ) ; ___( psttw ) ;
/*N1D*/
/*N1D*/                                                                     if( !strCompareF( tinP , psttw , esp.psttTestNote ) ) esp.tNoteFileName = T(psttzFileName) ;
/*N1D*/
/*N1D*/                                                                     delF( tinP , psttw ) ;
/*N1D*/                                                                 }
/*N1D*/
/*N1D*/                                                                 emitSetF( tinP , *this , soulrFileSets , soulIdFragShort , tSet , stSet , esp , psttCurrentNameLag ) ;
/*N1D*/                                                             }
/*N1D*/
/*N1D*/                                                             delF( tinP , psttp1 ) ;
/*N1D*/
/*N1D*/                                                             /**/if( bTrace ) traceF( tinP , T("  stSet << [set     ]: ")+T(psttzFileName) ) ;
/*N1D*/
/*N1D*/                                                             tSet = psttShortThumbnail
/*N1D*/                                                                 ? T(psttzFileName)+T(",")+T(psttShortThumbnail)
/*N1D*/                                                                 : T(psttzFileName)
/*N1D*/                                                             ;
/*N1D*/
/*N1D*/                                                                                        stSet << psttFileName       ; psttFileName       = 0 ;
/*N1D*/                                                             if( psttShortThumbnail ) { stSet << psttShortThumbnail ; psttShortThumbnail = 0 ; }
/*N1D*/                                                         }
/*N1D*/                                                         delF( tinP , psttCurrentNameLag ) ;
/*N1D*/                                                         strMakeF( tinP , LF , psttCurrentNameLag , psttzCurrentName ) ; ___( psttCurrentNameLag ) ;
/*N1D*/                                                         delF( tinP , psttFileName ) ;
/*N1D*/                                                         delF( tinP , psttShortThumbnail ) ;
/*N1D*/                                                         delF( tinP , pstt1NameTriple ) ;
/*N1D*/                                                     }
/*N1D*/                                                     delF( tinP , psttp1Lag ) ;
/*N1D*/                                                 }
/*N1D*/
/*N1D*/                                                 if( tSet.csF( tinP ) ) emitSetF( tinP , *this , soulrFileSets , soulIdFragShort , tSet , stSet , esp , psttCurrentNameLag ) ;
/*N1D*/                                                 delF( tinP , psttCurrentNameLag ) ;
/*N1D*/
/*N1D*/                                                 {
/*N1D*/                                                     ZE( strokeS* , psttzLeverLocalFolder ) ;
/*N1D*/                                                     switchC swCloud( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverLocalFolder ) ;
/*N1D*/                                                     if( soulIdFragShort )
/*N1D*/                                                     {
/*N1D*/                                                         ZE( strokeS* , psttzLeverCloud ) ;
/*N1D*/                                                         switchStackC swsSettings( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverCloud , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
/*N1D*/
/*N1D*/                                                         countT pcArg[] = { 0 , (countT)&psttzLeverCloud , (countT)&swsSettings } ;
/*N1D*/                                                         walkSettingsF( tinP , pbBuffer , sizeof pbBuffer , countTC() , walkCloudViewSettingsCBF , pcArg ) ;
/*N1D*/
/*N1D*/                                                         countT cFlavors = swsSettings.cFlavorsF( tinP ) ;
/*N1D*/                                                         for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
/*N1D*/                                                         {
/*N1D*/                                                             psttzLeverCloud = (strokeS*)swsSettings.leverF( tinP , idf ) ;
/*N1D*/
/*N1D*/                                                             GETsETTING( *this , psttLocal  , T("!cloudview.")+T(psttzLeverCloud)+T(".local" ) )
/*N1D*/                                                             GETsETTING( *this , psttRemote , T("!cloudview.")+T(psttzLeverCloud)+T(".remote") )
/*N1D*/
/*N1D*/                                                             ZE( strokeS* , psttLocalMapped ) ;
/*N1D*/                                                             diskMapFileNameF( tinP , psttLocalMapped , psttLocal ) ; ___( psttLocalMapped ) ;
/*N1D*/
/*N1D*/                                                             if( psttLocalMapped && psttRemote )
/*N1D*/                                                             {
/*N1D*/                                                                 psttzLeverLocalFolder = psttLocalMapped ;
/*N1D*/
/*N1D*/                                                                 strokeS*& psttRemoteFolder = *(strokeS**)&(countT&)swCloud ;
/*N1D*/                                                                 delF( tinP , psttRemoteFolder ) ;
/*N1D*/                                                                 psttRemoteFolder = psttRemote ;
/*N1D*/                                                                                    psttRemote = 0 ;
/*N1D*/                                                             }
/*N1D*/                                                             delF( tinP , psttLocalMapped ) ;
/*N1D*/                                                             delF( tinP , psttLocal       ) ;
/*N1D*/                                                             delF( tinP , psttRemote      ) ;
/*N1D*/                                                         }
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     {
/*N1D*/                                                         countT cFlavors = swCloud.cFlavorsF( tinP ) ;
/*N1D*/                                                         for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
/*N1D*/                                                         {
/*N1D*/                                                             psttzLeverLocalFolder = (strokeS*)swCloud.leverF( tinP , idf ) ;
/*N1D*/                                                             strokeS* psttr = (strokeS*)(countT)swCloud ;
/*N1D*/                                                             traceF( tinP , T("cloudview [local,remote]:    \"")+T(psttzLeverLocalFolder)+T("\"    \"")+T(psttr)+T("\"") ) ;
/*N1D*/                                                         }
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     IFsCRATCH
/*N1D*/                                                     {
/*N1D*/                                                         SCOOPS
/*N1D*/
/*N1D*/                                                         soulC soulIdFragCloud( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/                                                         TN( tCloudDefault , "[error: unknown location in cloud]/" ) ;
/*N1D*/                                                         while( soulIdFragShort ) //U::EMIT [idFrag,boxCloud] PAIRS TO ROOT OF HTML OUTPUT
/*N1D*/                                                         {
/*N1D*/                                                             TN( tIdFrag , "" ) ;
/*N1D*/                                                             TN( tBoxCloud , "" ) ;
/*N1D*/                                                             {
/*N1D*/                                                                 psttzLeverLocalFolder = tArchive ;
/*N1D*/                                                                 strokeS* psttzCloud = (strokeS*)(countT)swCloud ;
/*N1D*/                                                                 if( !psttzCloud ) psttzCloud = tCloudDefault ;
/*N1D*/                                        
/*N1D*/                                                                 ZE( strokeS* , psttp ) ;
/*N1D*/
/*N1D*/                                                                 soulIdFragShort >> psttp ; ___( psttp ) ;
/*N1D*/                                                                 tIdFrag = T(psttp) ;
/*N1D*/                                                                 delF( tinP , psttp ) ;
/*N1D*/
/*N1D*/                                                                 soulIdFragShort >> psttp ; ___( psttp ) ;
/*N1D*/                                                                 tBoxCloud = T(psttzCloud)+T(psttp) ;
/*N1D*/                                                                 delF( tinP , psttp ) ;
/*N1D*/                                                             }
/*N1D*/
/*N1D*/                                                             soulIdFragCloud << (strokeS*)tIdFrag ;
/*N1D*/                                                             soulIdFragCloud << (strokeS*)tBoxCloud ;
/*N1D*/                                                             //traceF( tinP , T(" [frag]: ")+tIdFrag ) ;
/*N1D*/                                                             //traceF( tinP , T("[cloud]: ")+tBoxCloud ) ;
/*N1D*/
/*N1D*/                                                             ZE( byteT* , pbNote ) ;
/*N1D*/                                                             ZE( countT , cbNote ) ;
/*N1D*/                                                             tinP.pEtScratch->boxGetShadowF( tinP , pbNote , cbNote , tBoxCloud ) ; ___( pbNote ) ;
/*N1D*/                                                             if( POOP || !pbNote )
/*N1D*/                                                             {
/*N1D*/                                                                 POOPR
/*N1D*/                                                                 traceF( tinP , T(" could not obtain note from cloud [box]: ")+tBoxCloud ) ;
/*N1D*/                                                             }
/*N1D*/                                                             else if( !*pbNote )
/*N1D*/                                                             {
/*N1D*/                                                                 POOPR
/*N1D*/                                                                 traceF( tinP , T(" length of note is 0 [box]: ")+tBoxCloud ) ;
/*N1D*/                                                             }
/*N1D*/                                                             else
/*N1D*/                                                             {
/*N1D*/                                                                 //traceF( tinP , T(" [note]: ")+T(pbNote) ) ;
/*N1D*/                                                             }
/*N1D*/                                                             delF( tinP , pbNote ) ;
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         traceF( tinP , T("writing tmp file for pickup by subsequent soil job.  *** NOT THREAD SAFE ***") ) ; //U:: UNIQUIFY TO MAKE THREAD SAFE
/*N1D*/
/*N1D*/                                                         TN( tFolderFile , "" ) ; tFolderFile = tFolder+tFile ;
/*N1D*/                                                         handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
/*N1D*/                                                         //U::THIS IS NOT THREAD SAFE ; THE OUTPUT FILE IS INTENDED TO BE PROCESSED BY THE REPORT JOB THAT I WILL LAUNCH
/*N1D*/                                                         fileOpenF( tinP , hFile , countTC() , T("///ideafarm/tmp/link.frag.note.soul.not.html") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
/*N1D*/                                                         fileWriteF( tinP , hFile , soulIdFragCloud ) ;
/*N1D*/                                                     }
/*N1D*/                                                 }
/*N1D*/
/*N1D*/                                                 if( esp.tTodayLath.csF( tinP ) )
/*N1D*/                                                 {
/*N1D*/                                                     strokeS sttDot( '.' ) ;
/*N1D*/                                                     strFuseF( tinP , soulrFileSets ,
/*N1D*/
/*N1D*/                                                         //CS:CODEsYNC: PSEUDODUPLICATE CODE: 360021c1 360021c1
/*N1D*/                                                         esp.tc
/*N1D*/                                                         +esp.tTodayLath
/*N1d*/                                                         //20180424@1606: SUPPRESSED TIME WITHOUT ANALYSIS SO THAT THE LABEL IS SIMPLY THE DAY
/*N1D*/                                                         //+sttDot
/*N1D*/                                                         //+esp.tTimeLath
/*N1D*/                                                         //20180421@1406: SUPPRESSED SEQUENCE NUMBER WITHOUT ANALYSIS SO THAT THE LABEL IS SIMPLY THE DAYTIME
/*N1D*/                                                         //+sttDot
/*N1D*/                                                         //+esp.tSequenceLath
/*N1D*/                                                         +esp.tc
/*N1D*/                                                         +esp.tDayPrefix            // THIS ENDS WITH "\\m\\r", WHICH ENDS THE PREFIX OF THE BRANCH (THE BRANCH WILL CONSIST OF tTodayLath CONCATENATED WITH ": " FOLLOWED BY THE TITLE)
/*N1D*/                                                         +esp.tTodayLath
/*N1D*/                                                         +
/*N1D*/                                                         (
/*N1D*/                                                             !esp.tDayTitleFileName.csF(tinP)
/*N1D*/                                                                 ? esp.tn
/*N1D*/                                                                 : esp.tcs+esp.tp4NotScrubbed+esp.tDayTitleFileName+esp.tDayTitleSuffix
/*N1D*/                                                         )
/*N1D*/                                                         +T("\\m")
/*N1D*/                                                         +
/*N1D*/                                                         (
/*N1D*/                                                             !esp.tDayNarrativeFileName.csF(tinP)
/*N1D*/                                                                 ? esp.tn
/*N1D*/                                                                 : T("</td></tr><tr><td>Narrative:  ")+esp.tp4Scrubbed+esp.tDayNarrativeFileName+esp.tDayNarrativeSuffix
/*N1D*/                                                         )
/*N1D*/                                                         +
/*N1D*/                                                         (
/*N1D*/                                                             !esp.tDayKeywordsFileName.csF(tinP)
/*N1D*/                                                                 ? esp.tn
/*N1D*/                                                                 : T("</td></tr><tr><td>Keywords:  ")+esp.tp4Scrubbed+esp.tDayKeywordsFileName+esp.tDayKeywordsSuffix
/*N1D*/                                                         )
/*N1D*/                                                         +
/*N1D*/                                                         (
/*N1D*/                                                             !esp.tDaySignsFileName.csF(tinP)
/*N1D*/                                                                 ? esp.tn
/*N1D*/                                                                 : T("</td></tr><tr><td>Signs:  ")+esp.tp4Scrubbed+esp.tDaySignsFileName+esp.tDaySignsSuffix
/*N1D*/                                                         )
/*N1D*/                                                         +esp.tTocAfter
/*N1D*/                                                         +esp.tcr
/*N1D*/                                                         +esp.tcr
/*N1D*/                                                         +esp.tcr
/*N1D*/
/*N1D*/                                                     ) ;
/*N1D*/                                                 }
/*N1D*/
/*N1D*/                                                 strFuseF( tinP , soulrFileSets , T(postReportEpilog) ) ;
/*N1D*/
/*N1D*/                                                 TN( tDisk , "" ) ;
/*N1D*/                                                 {
/*N1D*/                                                     ZE( strokeS* , psttm ) ;
/*N1D*/                                                     diskMapFileNameF( tinP , psttm , T("///ideafarm/") ) ; ___( psttm ) ;
/*N1D*/                                                     if( psttm && psttm->idAdam > 3 )
/*N1D*/                                                     {
/*N1D*/                                                         osTextT postd[] = { '/' , '/' , '/' , (osTextT)psttm[ CSpREFIX + 3 ].idAdam , '/' , 0 } ;
/*N1D*/                                                         tDisk = T(postd) ;
/*N1D*/                                                     }
/*N1D*/                                                     delF( tinP , psttm ) ;
/*N1D*/                                                 }
/*N1D*/
/*N1D*/                                                 ZE( strokeS* , psttu ) ;
/*N1D*/                                                 strUniqueF( tinP , psttu ) ; ___( psttu ) ;
/*N1D*/
/*N1D*/                                                 TN( tFileInclude , "" ) ;
/*N1D*/                                                 if( soulrFileSets )
/*N1D*/                                                 {
/*N1D*/                                                     ZE( countT , timeN1 ) ;
/*N1D*/                                                     ZE( sCountT , timeN2 ) ;
/*N1D*/                                                     osTimeNowF( tinP , timeN1 , timeN2 ) ;
/*N1D*/
/*N1D*/                                                     //A:ASSUME: tmp/ktr IS ON THE SAME DRIVE AS HOME FOLDER
/*N1D*/                                                     handleC hFile1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
/*N1D*/                                                     //U::BUG: SHOULD tUserOverride BE USED IN THE NEXT LINE?
/*N1D*/                                                     //fileOpenF( tinP , hFile1 , countTC() , T("///ideafarm/IdeaFarm (tm)/")+tUser+T("/Drop a Copy of SOIL (tm) Text Here/")+TT(timeN1,timeN2)+T(".soil") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
/*N1D*/                                                     //fileOpenF( tinP , hFile1 , countTC() , tDisk+T("tmp/ktr/rpt.archive.soii") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
/*N1D*/                                                     tFileInclude = T("///ideafarm/tmp/ktr/rpt.archive.")+T(psttu)+T(".soii") ;
/*N1D*/                                                     fileOpenF( tinP , hFile1 , countTC() , tFileInclude , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
/*N1D*/
/*N1D*/                                                     while( soulrFileSets )
/*N1D*/                                                     {
/*N1D*/                                                         ZE( strokeS* , psttp ) ;
/*N1D*/                                                         soulrFileSets >> psttp ; ___( psttp ) ;
/*N1D*/
/*N1D*/                                                         ZE( osTextT* , postp ) ;
/*N1D*/                                                         countT costp = strMakeF( tinP , LF , postp , psttp ) ; ___( postp ) ;
/*N1D*/                                                         delF( tinP , psttp ) ;
/*N1D*/
/*N1D*/                                                         fileWriteF( tinP , hFile1 , postp , costp ) ;
/*N1D*/
/*N1D*/                                                         delF( tinP , postp ) ;
/*N1D*/                                                     }
/*N1D*/                                                 }
/*N1D*/
/*N1D*/                                                 //U::BUG: SHOULD tUserOverride BE USED IN THE NEXT LINE?
/*N1D*/                                                 //ENABLE IN PRODUCTION; COMMENT OUT JUST WHEN DEBUGGING WOTH STAGE OF ARCHIVE REPORTING
/*N1D*/
/*N1D*/                                                 TN( tSoil , postSoilForReport1 ) ; tSoil += ( tReportsFolder.csF(tinP) ? tReportsFolder : T("///ideafarm/tmp/reports/") )+T(postSoilForReport2)+( tNameSpace.csF(tinP) ? tNameSpace : T("[missing.namespace]") )+T(postSoilForReport3)+tFileInclude+T(postSoilForReport4) ;
/*N1D*/
/*N1D*/                                                 TN( tMouth , "" ) ; tMouth = tJobQueueFolder.csF( tinP )
/*N1D*/                                                     ? tJobQueueFolder
/*N1D*/                                                     : T("///ideafarm/IdeaFarm (tm)/")+tUser+T("/Drop a Copy of SOIL (tm) Text Here/")
/*N1D*/                                                 ;
/*N1D*/
/*N1D*/                                                 static countT idBox ;
/*N1D*/                                                 countT idBoxMe = 1 + incv02AM( idBox ) ;
/*N1D*/
/*N1D*/                                                 boxPutF( tinP , tMouth+T("report.")+TF3(idBoxMe,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(".")+T(psttu)+T(".soil") , tSoil , tSoil.csF( tinP ) ) ;
/*N1D*/                                                 delF( tinP , psttu ) ;
/*N1D*/
/*N1D*/                                                 break ;
/*N1D*/                                             }
/*N1D*/                                             case ifcIDmODEsOILwALK_EDIT :
/*N1D*/                                             {
/*N1D*/                                                 while( soulFileNames )                                              // 0              1               2               3               4               5               6
/*N1D*/                                                 {                                                                   // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
/*N1D*/                                                     ZE( strokeS* , pstt1NameTriple ) ;                                // |----------------------------|                                //           |-----p1------||--sss--||2|
/*N1D*/                                                     soulFileNames >> pstt1NameTriple ; ___( pstt1NameTriple ) ;         // !ideafarm.8.2.00000000.00000001.20140328@2129.001.000b3858.2feac2f0.fa5b8bcb.voice.pad.!.140328_034.mp3
/*N1D*/                                                                                                                         // !ideafarm.9.2.00000000.00000001.20140328@2129.000b3858.2feac2f0.fa5b8bcb.voice.pad.!.140328_034.mp3
/*N1D*/
/*N1D*/                                                     ZE( strokeS* , psttzFileName ) ;
/*N1D*/                                                     ZE( strokeS* , psttzCurrentName ) ;
/*N1D*/                                                     ZE( strokeS* , psttzShortThumbnail ) ;
/*N1D*/                                                     FORsTRINGSiN1( pstt1NameTriple )
/*N1D*/                                                     {
/*N1D*/                                                              if( !psttzFileName       ) psttzFileName       = psttc1 ;  // EXAMPLE: "!ideafarm.0.foo.600x400.jpg"
/*N1D*/                                                         else if( !psttzCurrentName    ) psttzCurrentName    = psttc1 ;
/*N1D*/                                                         else if( !psttzShortThumbnail ) psttzShortThumbnail = psttc1 ;
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     if( psttzFileName->idAdam > 0x1e  )
/*N1D*/                                                     {
/*N1D*/                                                         ZE( strokeS* , psttPrefix ) ;
/*N1D*/                                                         countT idf = 1 ;
/*N1D*/                                                         countT idl = 0x1e ;
/*N1D*/                                                         strSubstringF( tinP , psttPrefix , idf , idl , psttzFileName ) ; ___( psttPrefix ) ;
/*N1D*/
/*N1D*/                                                         TN( tNoteFile , psttPrefix ) ; tNoteFile += T("!.note.ttt") ;
/*N1D*/                                                         delF( tinP , psttPrefix ) ;
/*N1D*/
/*N1D*/                                                         //traceF( tinP , tNoteFile ) ;
/*N1D*/
/*N1D*/                                                         TN( tNoteFileLong , "" ) ; tNoteFileLong = tArchive+tNoteFile ;
/*N1D*/                                                         if( !diskFileExistsF( tinP , tNoteFileLong ) )
/*N1D*/                                                         {
/*N1D*/                                                             traceF( tinP , T("note file does not exist for [file]: ")+T(psttzFileName) ) ;
/*N1D*/
/*N1D*/                                                             ZE( strokeS* , psttm ) ;
/*N1D*/                                                             diskMapFileNameF( tinP , psttm , tArchive+T(psttzFileName) ) ; ___( psttm ) ;
/*N1D*/
/*N1D*/                                                             osFileNameC osfn( tinP , third , T(psttm) ) ;
/*N1D*/                                                             delF( tinP , psttm ) ;
/*N1D*/
/*N1D*/                                                             osTextT postExeMp3[ TUCK << 1 ] ;
/*N1D*/                                                             countT  costaExeMp3 = sizeof postExeMp3 ;
/*N1D*/                                                             thirdC::exeFromFileExtensionIF( tinP , postExeMp3 , costaExeMp3 , ".mp3" ) ;
/*N1D*/
/*N1D*/                                                             ZE( countT , value ) ;
/*N1D*/                                                             ZE( countT , idDeathType ) ;
/*N1D*/                                                             TN( tq , "\"" ) ;
/*N1D*/                                                             third.dosExecPgmF( tinP , countTC() , countTC() , value , idDeathType , postExeMp3 , tq+T(osfn)+tq ) ;
/*N1D*/
/*N1D*/                                                             { fileC( tinP , (strokeS*)tNoteFileLong , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeF ) ; }
/*N1D*/                                                             osEditF( tinP , tNoteFileLong ) ;
/*N1D*/                                                         }
/*N1D*/                                                     }
/*N1D*/                                                     delF( tinP , pstt1NameTriple ) ;
/*N1D*/                                                 }
/*N1D*/                                                 break ;
/*N1D*/                                             }
/*N1D*/                                             case ifcIDmODEsOILwALK_ZIP :
/*N1D*/                                             {
/*N1D*/                                                 /**************************************************************************************************************/
/*N1D*/                                                 /*****                                                                                                    *****/
/*N1D*/                                                 /***** INSPECT ALL ACCUMULATED FILE NAMES                                                                 *****/
/*N1D*/                                                 /***** IF AN UNZIPPED FILE EXISTS FOR A DAY, THEN UNZIP ALL FILES FOR THAT DAY                            *****/
/*N1D*/                                                 /***** (SAFELY, BY USING A TEMPORARY DIRECTORY AND MERGING THE NEW FILES "OVER" THE OLD FILES)            *****/
/*N1D*/                                                 /*****                                                                                                    *****/
/*N1D*/                                                 /**************************************************************************************************************/
/*N1D*/
/*N1D*/                                                 ZE( countT , cDaysUpdated ) ;
/*N1D*/                                                 if( soulFileNames )
/*N1D*/                                                 {
/*N1D*/                                                     TN( tExeUnzip , "" ) ;
/*N1D*/                                                     {
/*N1D*/                                                         ZE( strokeS* , psttm ) ;
/*N1D*/                                                         diskMapFileNameF( tinP , psttm , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/infozip/unzip.exe/unzip.exe") ) ; ___( psttm ) ;
/*N1D*/                                                         tExeUnzip = T(psttm) ;
/*N1D*/                                                         delF( tinP , psttm ) ;
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     TN( tDirTemporary , "" ) ;
/*N1D*/                                                     {
/*N1D*/                                                         ZE( strokeS* , psttu ) ;
/*N1D*/                                                         strUniqueF( tinP , psttu ) ; ___( psttu ) ;
/*N1D*/                                                         tDirTemporary = T("///ideafarm/ephemeral/tmp/")+T(psttu)+T("/") ;
/*N1D*/                                                         delF( tinP , psttu ) ;
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     stackC st_psttFile(  tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_countT ) ;
/*N1D*/
/*N1D*/                                                     /**********************************************************************************************************/
/*N1D*/                                                     /*****                                                                                                *****/
/*N1D*/                                                     /***** FOR EACH ACCEPTED FILE (FILE OTHER THAN !confidential !phone ETC.)                             *****/
/*N1D*/                                                     /*****                                                                                                *****/
/*N1D*/                                                     /**********************************************************************************************************/
/*N1D*/
/*N1D*/                                                     soulC soulFileNamesCopy( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.copy" ) ;
/*N1D*/                                                     soulFileNamesCopy = soulFileNames ;
/*N1D*/
/*N1D*/                                                     TN( tDateLath , "" ) ;
/*N1D*/                                                     TN( tDayZip , ".!.day.zip" ) ;
/*N1D*/                                                     TN( tQuote , "\"" ) ;
/*N1D*/                                                     boolT bWoth = 1 ;
/*N1D*/                                                     ZE( boolT , bMerge ) ;
/*N1D*/                                                     while( soulFileNamesCopy )
/*N1D*/                                                     {
/*N1D*/                                                         ZE( strokeS* , pstt1NameTriple ) ;
/*N1D*/                                                         soulFileNamesCopy >> pstt1NameTriple ; ___( pstt1NameTriple ) ;
/*N1D*/
/*N1D*/                                                         ZE( strokeS* , psttzFileName ) ;
/*N1D*/                                                         ZE( strokeS* , psttzCurrentName ) ;
/*N1D*/                                                         ZE( strokeS* , psttzShortThumbnail ) ;
/*N1D*/                                                         FORsTRINGSiN1( pstt1NameTriple )
/*N1D*/                                                         {
/*N1D*/                                                                  if( !psttzFileName       ) psttzFileName       = psttc1 ;  // EXAMPLE: "!ideafarm.0.foo.600x400.jpg"
/*N1D*/                                                             else if( !psttzCurrentName    ) psttzCurrentName    = psttc1 ;
/*N1D*/                                                             else if( !psttzShortThumbnail ) psttzShortThumbnail = psttc1 ;
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         ZE( strokeS* , psttFileName ) ;
/*N1D*/                                                         strMakeF( tinP , LF , psttFileName , psttzFileName ) ; ___( psttFileName ) ;
/*N1D*/                                                         //traceF( tinP , psttzFileName ) ;
/*N1D*/
/*N1D*/                                                         //CS:CODEsYNC: PSEUDOdUPLICATE CODE: 360021c1 360021c1
/*N1D*/                                                         TN( tDate , "" ) ;
/*N1D*/                                                         {
/*N1D*/                                                             ZE( strokeS* , psttDate ) ;
/*N1D*/                                                             countT idf = 0x0d ;
/*N1D*/                                                             countT idl = 0x14 ;
/*N1D*/                                                             strSubstringF( tinP , psttDate , idf , idl , psttzFileName ) ; ___( psttDate ) ;
/*N1D*/                                                             tDate = T(psttDate) ;
/*N1D*/                                                             delF( tinP , psttDate ) ;
/*N1D*/                                                         }
/*N1D*/                                                         boolT bNewDate = strCompareF( tinP , tDate , tDateLath ) ;
/*N1D*/
/*N1D*/                                                         if( bNewDate )
/*N1D*/                                                         {
/*N1D*/                                                             if( bMerge )
/*N1D*/                                                             {
/*N1D*/                                                                 cDaysUpdated ++ ;
/*N1D*/                                                                 pour360021c1F( tinP , *this , tArchive , tDirTemporary ) ;
/*N1D*/                                                             }
/*N1D*/
/*N1D*/                                                             tDateLath = tDate ;
/*N1D*/
/*N1D*/                                                             bWoth = 1 ;
/*N1D*/                                                             bMerge = 0 ;
/*N1D*/                                                             st_psttFile.purgeF( tinP ) ;
/*N1D*/                                                             if( diskFileExistsF( tinP , tDirTemporary ) ) diskFileOrDirDeleteF( tinP , tDirTemporary ) ;
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         if( strIdF( tinP , tDayZip , psttzFileName , 1 ) == psttzFileName->idAdam + 1 - tDayZip.csF( tinP ) )
/*N1D*/                                                         {
/*N1D*/                                                             st_psttFile << (countT)psttFileName ; psttFileName = 0 ;
/*N1D*/                                                             bMerge = 1 ;
/*N1D*/                                                         }
/*N1D*/                                                         else
/*N1D*/                                                         {
/*N1D*/                                                             if( bWoth )
/*N1D*/                                                             {
/*N1D*/                                                                 bWoth = 0 ;
/*N1D*/
/*N1D*/                                                                 /**********************************************************************************************************/
/*N1D*/                                                                 /*****                                                                                                *****/
/*N1D*/                                                                 /***** AT LEAST WO UNZIPPED FILE IS PRESENT, SO UNZIP AND DELETE ALL DAY ZIPS FOR THIS DAY INTO       *****/
/*N1D*/                                                                 /***** A TEMPORARY DIR                                                                                *****/
/*N1D*/                                                                 /*****                                                                                                *****/
/*N1D*/                                                                 /**********************************************************************************************************/
/*N1D*/
/*N1D*/                                                                 TN( tFileDayZipLike , "" ) ;
/*N1D*/                                                                 {
/*N1D*/                                                                     //   0              1               2               3               4               5               6               7               8
/*N1D*/                                                                     //   123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
/*N1D*/                                                                     //   !ideafarm.8.2.00000000.00000001.20140703@0000.000.001.!.day.zip
/*N1D*/                                                                     //   !ideafarm.9.2.00000000.00000001.20140703@0000.!.day.zip
/*N1D*/
/*N1D*/                                                                     ZE( strokeS* , psttPrefix ) ;
/*N1D*/                                                                     countT idf = 0x01 ;
/*N1D*/                                                                     countT idl = 0x15 ;
/*N1D*/                                                                     strSubstringF( tinP , psttPrefix , idf , idl , psttzFileName ) ; ___( psttPrefix ) ;
/*N1D*/
/*N1D*/                                                                     tFileDayZipLike = tArchive+T(psttPrefix)+T("0000.000.???.!.day.zip") ;
/*N1D*/                                                                     delF( tinP , psttPrefix ) ;
/*N1D*/                                                                 }
/*N1D*/
/*N1D*/                                                                 fileNameC fn( tinP , *this , tFileDayZipLike ) ;
/*N1D*/                                                                 patternC pat( tinP , *this , fn , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                                 ZE( infoFileS* , pInfo ) ;
/*N1D*/                                                                 handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
/*N1D*/                                                                 do
/*N1D*/                                                                 {
/*N1D*/                                                                     diskFindFileOrDirF( tinP , pInfo , hFind , fn.pathF() , &pat ) ;
/*N1D*/                                                                     if( pInfo && pInfo->psttIfoName )
/*N1D*/                                                                     {
/*N1D*/                                                                         //traceF( tinP , T("unziping to temp: ")+T(pInfo->psttIfoName) ) ;
/*N1D*/                                                                         {
/*N1D*/                                                                             osFileNameC osfnZipFile( tinP , third , T(pInfo->psttIfoName) ) ;
/*N1D*/
/*N1D*/                                                                             TN( tArg , "" ) ; tArg = T(" \"")+T(osfnZipFile)+tQuote ;
/*N1D*/
/*N1D*/                                                                             hoverC hover( tinP , *this , tDirTemporary ) ; //U::NOT THREAD SAFE: ADD SERIALIZATION
/*N1D*/
/*N1D*/                                                                             //traceF( tinP , tExeUnzip ) ;
/*N1D*/                                                                             //traceF( tinP , tArg ) ;
/*N1D*/                                                                             ZE( countT , value ) ;
/*N1D*/                                                                             ZE( countT , idDeathType ) ;
/*N1D*/                                                                             osProcessF( tinP , countTC() , countTC() , value , idDeathType , tExeUnzip , tArg ) ; //THIS CAN FAIL (E.G. IF TARGET ZIP FILE IS CORRUPT
/*N1D*/                                                                             //__( value ) ;             // NOT CHECKED, BECAUSE CAN BE CAUSED BY USER ERROR (TARGET ZIP FILE IS CORRUPT)
/*N1D*/                                                                             //__( idDeathType ) ;
/*N1D*/
/*N1D*/                                                                             if( !value && !idDeathType ) diskFileOrDirDeleteF( tinP , pInfo->psttIfoName ) ;
/*N1D*/                                                                         }
/*N1D*/                                                                     }
/*N1D*/                                                                     DEL( pInfo ) ;
/*N1D*/                                                                 }
/*N1D*/                                                                 while( !etherC::etPrimeIF( tinP ) && ~hFind ) ;
/*N1D*/                                                             }
/*N1D*/
/*N1D*/                                                             if( bMerge )
/*N1D*/                                                             {
/*N1D*/                                                                 TN( tShort , psttzFileName ) ;
/*N1D*/                                                                 diskFileOrDirDeleteF( tinP , tDirTemporary+tShort ) ;
/*N1D*/                                                                 diskMoveFileOrDirF(   tinP , tDirTemporary+tShort , tArchive+tShort ) ;
/*N1D*/                                                             }
/*N1D*/                                                         }
/*N1D*/                                                         delF( tinP , psttFileName ) ;
/*N1D*/                                                         delF( tinP , pstt1NameTriple ) ;
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     if( bMerge )
/*N1D*/                                                     {
/*N1D*/                                                         cDaysUpdated ++ ;
/*N1D*/                                                         pour360021c1F( tinP , *this , tArchive , tDirTemporary ) ;
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     if( diskFileExistsF( tinP , tDirTemporary ) ) diskFileOrDirDeleteF( tinP , tDirTemporary ) ;
/*N1D*/                                                 }
/*N1D*/
/*N1D*/                                                 /**************************************************************************************************************/
/*N1D*/                                                 /*****                                                                                                    *****/
/*N1D*/                                                 /***** THE FILES FOR EACH DAY ARE EITHER COMPLETELY ZIPPZED OR COMPLETELY UNZIPPED                        *****/
/*N1D*/                                                 /***** IT IS TIME TO ZIP THE ARCHIVE INTO DAY ZIP FILES                                                   *****/
/*N1D*/                                                 /*****                                                                                                    *****/
/*N1D*/                                                 /**************************************************************************************************************/
/*N1D*/
/*N1D*/                                                 if( cDaysUpdated )
/*N1D*/                                                 {
/*N1D*/                                                     /**********************************************************************************************************/
/*N1D*/                                                     /*****                                                                                                *****/
/*N1D*/                                                     /***** RELOAD stFileName SINCE IT IS STALE                                                            *****/
/*N1D*/                                                     /*****                                                                                                *****/
/*N1D*/                                                     /**********************************************************************************************************/
/*N1D*/
/*N1D*/                                                     soulFileNames.removeAllF( tinP ) ;
/*N1D*/
/*N1D*/                                                     cDirs  = 0 ;
/*N1D*/                                                     cFiles = 0 ;
/*N1D*/                                                     /**/if( bTrace ) traceF( tinP , T("etherSoilF / tKeyZip / reloading stale soulFileNames") ) ;
/*N1D*/
/*N1D*/                                                     IFsCRATCH
/*N1D*/                                                     {
/*N1D*/                                                         SCOOPS
/*N1D*/                                                         tinP.pEtScratch->diskWalkF( tinP , cDirs , cFiles , tArchive , bQuit , flDISKwALK_null , etherSoilWalkCBF , pcArg ) ; // WILL FAIL IF tUserOverride CONTAINS DOUBLE QUOTE MARKS OR OTHER STROKES THAT MAKE THE PATH NAME INVALID
/*N1D*/                                                         if( POOP ) POOPR ;
/*N1D*/                                                     }
/*N1D*/                                                 }
/*N1D*/
/*N1D*/                                                 TN( tExeZip , "" ) ;
/*N1D*/                                                 {
/*N1D*/                                                     ZE( strokeS* , psttm ) ;
/*N1D*/                                                     diskMapFileNameF( tinP , psttm , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/infozip/zip.exe/zip.exe") ) ; ___( psttm ) ;
/*N1D*/                                                     tExeZip = T(psttm) ;
/*N1D*/                                                     delF( tinP , psttm ) ;
/*N1D*/                                                 }
/*N1D*/
/*N1D*/                                                 TN( tZipSuffix , ".zip" ) ;
/*N1D*/                                                 TN( tDayZipSuffix1 , "@0000.000." ) ;
/*N1D*/                                                 TN( tDayZipSuffix2 , ".!.day.zip" ) ;
/*N1D*/                                                 TN( tNix1 , ".!.day.title.ttt" ) ;
/*N1D*/                                                 TN( tNix2 , ".!.locked.day.zip" ) ;
/*N1D*/
/*N1D*/                                                 TN( tBlank , " " ) ;
/*N1D*/                                                 TN( tQuote , "\"" ) ;
/*N1D*/
/*N1D*/                                                 TN( tDateListed , "" ) ;
/*N1D*/                                                 ZE( strokeS* , psttCurrentZipFile ) ;
/*N1D*/                                                 ZE( countT   , cbCurrentZipFile ) ;
/*N1D*/                                                 ZE( countT , cListed ) ;
/*N1D*/                                                 ZE( strokeS* , psttOsFileList ) ;
/*N1D*/                                                 ZE( countT , cbEstimateListed ) ;
/*N1D*/                                                 countT idZipNext = 1 ;
/*N1D*/                                                 const countT cFilesPerZipLaunch = TUCK >> 4 ;
/*N1D*/                                                 const countT cbEnough = TICK << 4 ;
/*N1D*/                                                 strMakeF( tinP , LF , psttOsFileList , 0 , ( 1 + cFilesPerZipLaunch ) * ( 1 + TUCK ) ) ; ___( psttOsFileList ) ; // WO EXTRA WO JUST TO MAKE SURE
/*N1D*/
/*N1D*/                                                 while( soulFileNames )                                              // 0              1               2               3               4               5               6
/*N1D*/                                                 {                                                                   // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
/*N1D*/                                                     ZE( strokeS* , pstt1NameTriple ) ;                                //           |-----p1------||--sss--||2|
/*N1D*/                                                     soulFileNames >> pstt1NameTriple ; ___( pstt1NameTriple ) ;         // EXAMPLE: "!ideafarm.0.foo.600x400.jpg"
/*N1D*/
/*N1D*/                                                     ZE( strokeS* , psttzFileName ) ;
/*N1D*/                                                     ZE( strokeS* , psttzCurrentName ) ;
/*N1D*/                                                     ZE( strokeS* , psttzShortThumbnail ) ;
/*N1D*/                                                     FORsTRINGSiN1( pstt1NameTriple )
/*N1D*/                                                     {
/*N1D*/                                                              if( !psttzFileName       ) psttzFileName       = psttc1 ;  // EXAMPLE: "!ideafarm.0.foo.600x400.jpg"
/*N1D*/                                                         else if( !psttzCurrentName    ) psttzCurrentName    = psttc1 ;
/*N1D*/                                                         else if( !psttzShortThumbnail ) psttzShortThumbnail = psttc1 ;
/*N1D*/                                                     }
/*N1D*/
/*N1D*/                                                     strConvertToLowerCaseF( tinP , psttzFileName ) ; ___( psttzFileName ) ;
/*N1D*/                                                     if
/*N1D*/                                                     (
/*N1D*/                                                         psttzFileName->idAdam <= 0x1e
/*N1D*/                                                         ||
/*N1D*/                                                         strIdF( tinP , tDayZipSuffix2 , psttzFileName )
/*N1D*/                                                         ||
/*N1D*/                                                         strIdF( tinP , tNix1 , psttzFileName )
/*N1D*/                                                         ||
/*N1D*/                                                         strIdF( tinP , tNix2 , psttzFileName )
/*N1D*/                                                     )
/*N1D*/                                                     {
/*N1D*/                                                         traceF( tinP , T("rejected: ")+T(psttzFileName) ) ;
/*N1D*/                                                     }
/*N1D*/                                                     else
/*N1D*/                                                     {
/*N1D*/                                                         //traceF( tinP , psttzFileName ) ;
/*N1D*/
/*N1D*/                                                         /**************************************************************************************************/
/*N1D*/                                                         /*****                                                                                        *****/
/*N1D*/                                                         /***** INSPECT THE FILE (GET ESTIMATED ZIPPED SIZE, DATE)                                     *****/
/*N1D*/                                                         /*****                                                                                        *****/
/*N1D*/                                                         /**************************************************************************************************/
/*N1D*/
/*N1D*/                                                         ZE( countT , cbEstimate ) ;
/*N1D*/                                                         {
/*N1D*/                                                             ZE( countT , cbInput ) ;
/*N1D*/                                                             {
/*N1D*/                                                                 fileC inFile( tinP , (const strokeS*)( tArchive+T(psttzFileName) ) ) ;
/*N1D*/                                                                 ZE( infoFileS* , pInfo ) ;
/*N1D*/                                                                 diskFileQueryF( tinP , pInfo , inFile ) ;
/*N1D*/                                                                 cbInput = pInfo->cbUsedHigh
/*N1D*/                                                                     ? - 1
/*N1D*/                                                                     : pInfo->cbUsed
/*N1D*/                                                                 ;
/*N1D*/                                                                 DEL( pInfo ) ;
/*N1D*/                                                             }
/*N1D*/
/*N1D*/                                                             cbEstimate = strIdF( tinP , tZipSuffix , psttzFileName ) == psttzFileName->idAdam + 1 - tZipSuffix.csF( tinP )
/*N1D*/                                                                 ? cbInput
/*N1D*/                                                                 : cbInput << 1  // THIS RULE ARBITRARILY ASSUMES THAT ZIP COMPRESSION IS 1/2
/*N1D*/                                                             ;
/*N1D*/                                                             cbEstimate += psttzFileName->idAdam >> 1 ; // ENSURES NONZE ; ADDS THE ESTIMATED BYTES NEEDED TO STORE THE FILE NAME
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         //CS:CODEsYNC: PSEUDOdUPLICATE CODE: 360021c1 360021c1
/*N1D*/                                                         TN( tDate , "" ) ;
/*N1D*/                                                         {
/*N1D*/                                                             ZE( strokeS* , psttDate ) ;
/*N1D*/                                                             countT idf = 0x0d ;
/*N1D*/                                                             countT idl = 0x14 ;
/*N1D*/                                                             strSubstringF( tinP , psttDate , idf , idl , psttzFileName ) ; ___( psttDate ) ;
/*N1D*/                                                             tDate = T(psttDate) ;
/*N1D*/                                                             delF( tinP , psttDate ) ;
/*N1D*/                                                         }
/*N1D*/                                                         boolT bNewDate = strCompareF( tinP , tDate , tDateListed ) ;
/*N1D*/
/*N1D*/                                                         if
/*N1D*/                                                         (
/*N1D*/                                                             cListed                                                              // AT LEAST 1 FILE IS LISTED
/*N1D*/                                                             &&
/*N1D*/                                                             (
/*N1D*/                                                                 cListed == cFilesPerZipLaunch                                    // ENOUGH FILES ARE LISTED
/*N1D*/                                                                 ||
/*N1D*/                                                                 (
/*N1D*/                                                                     bNewDate                                                     // THE DATE HAS CHANGED
/*N1D*/                                                                     ||
/*N1D*/                                                                     cbEnough <= cbCurrentZipFile + cbEstimateListed + cbEstimate // THE FILE WOULD OVERFLOW
/*N1D*/                                                                 )
/*N1D*/                                                             )
/*N1D*/                                                         )
/*N1D*/                                                         {
/*N1D*/                                                             /**************************************************************************************************/
/*N1D*/                                                             /*****                                                                                        *****/
/*N1D*/                                                             /***** FLUSH THE LISTED FILES TO THE CURRENT ZIP FILE                                         *****/
/*N1D*/                                                             /*****                                                                                        *****/
/*N1D*/                                                             /**************************************************************************************************/
/*N1D*/
/*N1D*/                                                             {
/*N1D*/                                                                 osFileNameC osfnZipFile( tinP , third , T(psttCurrentZipFile) ) ;
/*N1D*/
/*N1D*/                                                                 TN( tArg , "" ) ; tArg = T("-9mj \"")+T(osfnZipFile)+tQuote+tBlank+T(psttOsFileList) ;
/*N1D*/                                                                 delF( tinP , psttOsFileList ) ;
/*N1D*/                                                                 cListed = 0 ;
/*N1D*/                                                                 cbEstimateListed = 0 ;
/*N1D*/                                                                 strMakeF( tinP , LF , psttOsFileList , 0 , ( 1 + cFilesPerZipLaunch ) * ( 1 + TUCK ) ) ; ___( psttOsFileList ) ; // WO EXTRA WO JUST TO MAKE SURE
/*N1D*/
/*N1D*/                                                                 //traceF( tinP , tExeZip ) ;
/*N1D*/                                                                 //traceF( tinP , tArg ) ;
/*N1D*/                                                                 ZE( countT , value ) ;
/*N1D*/                                                                 ZE( countT , idDeathType ) ;
/*N1D*/                                                                 osProcessF( tinP , countTC() , countTC() , value , idDeathType , tExeZip , tArg ) ; //THIS CAN FAIL (E.G. IF TARGET ZIP FILE IS CORRUPT
/*N1D*/                                                                 //__( value ) ;             // NOT CHECKED, BECAUSE CAN BE CAUSED BY USER ERROR (TARGET ZIP FILE IS CORRUPT)
/*N1D*/                                                                 //__( idDeathType ) ;
/*N1D*/
/*N1D*/                                                                 {
/*N1D*/                                                                     fileC woZip( tinP , psttCurrentZipFile ) ;
/*N1D*/                                                                     ZE( infoFileS* , pInfo ) ;
/*N1D*/                                                                     diskFileQueryF( tinP , pInfo , woZip ) ;
/*N1D*/                                                                     cbCurrentZipFile = pInfo->cbUsedHigh
/*N1D*/                                                                         ? - 1
/*N1D*/                                                                         : pInfo->cbUsed
/*N1D*/                                                                     ;
/*N1D*/                                                                     DEL( pInfo ) ;
/*N1D*/                                                                 }
/*N1D*/                                                             }
/*N1D*/
/*N1D*/                                                             if( cbEnough <= cbCurrentZipFile + cbEstimate )
/*N1D*/                                                             {
/*N1D*/                                                                 delF( tinP , psttCurrentZipFile ) ;
/*N1D*/                                                                 cbCurrentZipFile = 0 ;
/*N1D*/                                                             }
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         /**************************************************************************************************/
/*N1D*/                                                         /*****                                                                                        *****/
/*N1D*/                                                         /***** CALCULATE THE NAME OF THE NEW CURRENT ZIP FILE (IF IT HAS BEEN RESET)                  *****/
/*N1D*/                                                         /*****                                                                                        *****/
/*N1D*/                                                         /**************************************************************************************************/
/*N1D*/
/*N1D*/                                                         if( bNewDate )
/*N1D*/                                                         {
/*N1D*/                                                             tDateListed = tDate ;
/*N1D*/                                                             idZipNext   = 1     ;
/*N1D*/                                                             delF( tinP , psttCurrentZipFile ) ;
/*N1D*/                                                             cbCurrentZipFile = 0 ;
/*N1D*/                                                         }
/*N1D*/
/*N1D*/                                                         //U:: 20200410@2018: THE NEXT LINE PROBABLY DOES NOT EMIT A VALID FORMAT 9 FILE NAME
/*N1D*/                                                         if( !psttCurrentZipFile ) { diskMapFileNameF( tinP , psttCurrentZipFile , tArchive+T("!ideafarm.9.2.00000000.00000001.")+tDateListed+tDayZipSuffix1+TF3(idZipNext++,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,3)+tDayZipSuffix2 ) ; ___( psttCurrentZipFile ) ; }
/*N1D*/
/*N1D*/                                                         /**************************************************************************************************/
/*N1D*/                                                         /*****                                                                                        *****/
/*N1D*/                                                         /***** LIST THE CURRENT FILE                                                                  *****/
/*N1D*/                                                         /*****                                                                                        *****/
/*N1D*/                                                         /**************************************************************************************************/
/*N1D*/
/*N1D*/                                                         ZE( strokeS* , psttm ) ;
/*N1D*/                                                         diskMapFileNameF( tinP , psttm , tArchive+T(psttzFileName) ) ; ___( psttm ) ;
/*N1D*/
/*N1D*/                                                         osFileNameC osfn( tinP , third , T(psttm) ) ;
/*N1D*/                                                         delF( tinP , psttm ) ;
/*N1D*/
/*N1D*/                                                         if( psttOsFileList->idAdam ) strFuseF( tinP , psttOsFileList , tBlank ) ;
/*N1D*/                                                         strFuseF( tinP , psttOsFileList , tQuote+T(osfn)+tQuote ) ;
/*N1D*/                                                         cListed ++ ;
/*N1D*/                                                         cbEstimateListed += cbEstimate ;
/*N1D*/                                                     }
/*N1D*/                                                     delF( tinP , pstt1NameTriple ) ;
/*N1D*/                                                 }
/*N1D*/
/*N1D*/                                                 /**************************************************************************************************/
/*N1D*/                                                 /*****                                                                                        *****/
/*N1D*/                                                 /***** FLUSH ALL LISTED FILES TO THE CURRENT ZIP FILE                                         *****/
/*N1D*/                                                 /*****                                                                                        *****/
/*N1D*/                                                 /**************************************************************************************************/
/*N1D*/
/*N1D*/                                                 if( psttOsFileList && cListed )
/*N1D*/                                                 {
/*N1D*/                                                     cListed = 0 ;
/*N1D*/                                                     osFileNameC osfnZipFile( tinP , third , T(psttCurrentZipFile) ) ;
/*N1D*/
/*N1D*/                                                     TN( tArg , "" ) ; tArg = T("-9mj \"")+T(osfnZipFile)+tQuote+tBlank+T(psttOsFileList) ;
/*N1D*/
/*N1D*/                                                     //traceF( tinP , tExeZip+T(" : ")+tArg ) ;
/*N1D*/                                                     ZE( countT , value ) ;
/*N1D*/                                                     ZE( countT , idDeathType ) ;
/*N1D*/                                                     osProcessF( tinP , countTC() , countTC() , value , idDeathType , tExeZip , tArg ) ;
/*N1D*/                                                     delF( tinP , psttOsFileList ) ;
/*N1D*/                                                 }
/*N1D*/                                                 delF( tinP , psttCurrentZipFile ) ;
/*N1D*/
/*N1D*/                                                 break ;
/*N1D*/                                             }
/*N1D*/                                             case ifcIDmODEsOILwALK_INSPECTfILEnAMES :
/*N1D*/                                             {
/*N1D*/                                                 break ;
/*N1D*/                                             }
/*N1D*/                                             default : { BLAMMO ; }
/*N1D*/                                         }
/*N1D*/
/*N1D*/                                         //INTENTIONAL FALLTHROUGH
/*N1D*/                                     }
/*N1D*/                                     default :
/*N1D*/                                     {
/*N1D*/                                         while( stTimeMinMax )
/*N1D*/                                         {
/*N1D*/                                             strokeS* ppstt2[ 2 ] ;
/*N1D*/                                             byteT* pbTo = (byteT*)ppstt2 ;
/*N1D*/                                             stTimeMinMax >> pbTo ;
/*N1D*/
/*N1D*/                                             //traceF( tinP , T("stTimeMinMax - [ppstt2[0],ppstt2[1]]:    \"")+T(ppstt2[0])+T("\"    \"")+T(ppstt2[1])+T("\"") ) ;
/*N1D*/
/*N1D*/                                             delF( tinP , ppstt2[ 0 ] ) ;
/*N1D*/                                             delF( tinP , ppstt2[ 1 ] ) ;
/*N1D*/                                         }
/*N1D*/                                     }
/*N1D*/                                 }
/*N1D*/                             }
/*N1D*/
/*N1D*/                             bAllowLevel1 = 1 ; bAllowLevel3 = bAllowLevel2 = 0 ; //NONDEFAULT SETTINGS FOR LEVEL 1 AND 2 PERSIST UNTIL CLIMBING DOWN FROM 1
/*N1D*/                             tUserOverride = tKeyLevel1 = tn ;
/*N1D*/                             if( !tReportsSource.csF( tinP ) )
/*N1D*/                             {
/*N1D*/                                 ZE( strokeS* , psttm ) ;
/*N1D*/                                 diskMapFileNameF( tinP , psttm , T("///ideafarm/IdeaFarm (tm)/")+( tUserOverride.csF( tinP ) ? tUserOverride : tUser )+T("/Drop Files Here To Archive/") ) ; ___( psttm ) ;
/*N1D*/                                 tArchive = T(psttm) ;
/*N1D*/                                 //traceF( tinP , T("set 6 [tArchive]: ")+tArchive ) ;
/*N1D*/                                 delF( tinP , psttm ) ;
/*N1D*/                             }
/*N1D*/
/*N1D*/                             break ;
                                }
                                case 2 :
                                {
/*N2D*/                             if( tKeyLevel2 == tKeyBody && tKeyLevel1 == tKeyKtr )
/*N2D*/                             {
/*N2D*/                                 switch( idModeP )
/*N2D*/                                 {
/*N2D*/                                     case ifcIDmODEeTHERsOIL_LINT :
/*N2D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N2D*/                                     {
/*N2D*/                                         //strokeF( tinP , T("before strReverseF [psttv]]:\r\n\"")+T(psttv)+T("\"\r\n") ) ;
/*N2D*/
/*N2D*/                                         soulC soulLines( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.lines" ) ;  // THIS IS LIFO BECAUSE KTR ("KNOWLEDGE TREE REVERSED") INPUT IS IN REVERSE ORDER SO THAT IT FLOWS UPWARD WHEN THE SOIL FILE IS EDITED USING A CONVENTIONAL FOREIGN EDITOR
/*N2D*/                                         traceF( tinP , T("calling strWordsF 1") ) ;
/*N2D*/                                         countT cWords = strWordsF( tinP , soulLines , soulValue , sttq , tcr , flSTRwORDS_DELIMITERS|flSTRwORDS_SPLITaTmARK|flSTRwORDS_CONSUMEiNPUT ) ;
/*N2D*/                                         traceF( tinP , T("called strWordsF 1") ) ;
/*N2D*/
/*N2D*/                                         ZE( countT , idWothMin ) ;
/*N2D*/                                         //U::20140127@1657: REPLACED WITH soulLinesLazy: staqC stq_psttl( tinP ) ;
/*N2D*/                                         soulC soulLinesLazy( tinP , TAG( TAGiDnULL ) , flSOUL_LIFO , "soul.lines.lazy" ) ;
/*N2D*/                                         {
/*N2D*/                                             ZE( strokeS* , psttLag ) ;
/*N2D*/                                             ZE( countT   , idWothLag ) ;
/*N2D*/                                             staqC stq_psttlDelimiterOrBlankAfterLag( tinP ) ;
/*N2D*/                                             while( soulLines )
/*N2D*/                                             {
/*N2D*/                                                 ZE( strokeS* , psttl ) ;
/*N2D*/                                                 soulLines >> psttl ; ___( psttl ) ;
/*N2D*/                                                 __Z( psttl ) ;
/*N2D*/                                                 if( !POOP )
/*N2D*/                                                 {
/*N2D*/                                                     /**/if( bTrace && !( soulLines % TUCK ) ) traceF( tinP , T("processing body with ")+TF2((countT)soulLines,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" lines remaining") ) ;
/*N2D*/
/*N2D*/                                                     strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
/*N2D*/                                                     countT idWoth = strIdAnyF( tinP , 0 , flSTRmATCH_null , countTC( 1 ) , sttq , tbcrb , psttl , 0 , 1 , flSTRiDaNY_NOT ) ;
/*N2D*/
/*N2D*/                                                     if( !idWoth ) { stq_psttlDelimiterOrBlankAfterLag << psttl ; psttl = 0 ; }
/*N2D*/                                                     else
/*N2D*/                                                     {
/*N2D*/                                                         //traceF( tinP , T("[idWoth,psttl]: ")+TF2(idWoth,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    >")+T(psttl)+T("<") ) ;
/*N2D*/
/*N2D*/                                                         if( !idWothMin || idWothMin > idWoth ) idWothMin = idWoth ;
/*N2D*/
/*N2D*/                                                         if( !psttLag )
/*N2D*/                                                         {
/*N2D*/                                                             //DUPLICATEcODE: 360021c1 360021c1
/*N2D*/                                                             countT cBlank = stq_psttlDelimiterOrBlankAfterLag ;
/*N2D*/                                                             for( countT idb = cBlank ; idb ; idb -- )
/*N2D*/                                                             {
/*N2D*/                                                                 strokeS*& psttb = *(strokeS**)&stq_psttlDelimiterOrBlankAfterLag[ idb ] ;
/*N2D*/                                                                 __Z( psttb ) ;
/*N2D*/                                                                 if( idModeP != ifcIDmODEeTHERsOIL_REPORT ) soulOut << psttb ;
/*N2D*/                                                                 delF( tinP , psttb ) ;
/*N2D*/                                                             }
/*N2D*/                                                             stq_psttlDelimiterOrBlankAfterLag.purgeF( tinP ) ;
/*N2D*/                                                         }
/*N2D*/                                                         else
/*N2D*/                                                         {
/*N2D*/                                                             if( idModeP == ifcIDmODEeTHERsOIL_LINT && idWothLag - 1 > idWoth && ++ cFlag1 <= CfLAG1mAX ) //INDENTATION CANNOT INCREASE BY MORE THAN 1
/*N2D*/                                                             {
/*N2D*/                                                                 //traceF( tinP , T("error [idWoth,idWothLag]")+TF2(idWoth,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" , ")+TF2(idWothLag,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
/*N2D*/                                                                 if( idModeP != ifcIDmODEeTHERsOIL_REPORT ) soulOut << (strokeS*)tFlag1 ;
/*N2D*/                                                             }
/*N2D*/                                                                    
/*N2D*/                                                             if( idModeP != ifcIDmODEeTHERsOIL_REPORT ) soulOut << psttLag ;
/*N2D*/                                                             soulLinesLazy << psttLag ;
/*N2D*/                                                             delF( tinP , psttLag ) ;
/*N2D*/
/*N2D*/                                                             //DUPLICATEcODE: 360021c1 360021c1
/*N2D*/                                                             countT cBlank = stq_psttlDelimiterOrBlankAfterLag ;
/*N2D*/                                                             for( countT idb = cBlank ; idb ; idb -- )
/*N2D*/                                                             {
/*N2D*/                                                                 strokeS*& psttb = *(strokeS**)&stq_psttlDelimiterOrBlankAfterLag[ idb ] ;
/*N2D*/                                                                 __Z( psttb ) ;
/*N2D*/                                                                 if( idModeP != ifcIDmODEeTHERsOIL_REPORT ) soulOut << psttb ;
/*N2D*/                                                                 delF( tinP , psttb ) ;
/*N2D*/                                                             }
/*N2D*/                                                             stq_psttlDelimiterOrBlankAfterLag.purgeF( tinP ) ;
/*N2D*/                                                         }
/*N2D*/
/*N2D*/                                                         psttLag = psttl ;
/*N2D*/                                                                   psttl = 0 ;
/*N2D*/                                                         idWothLag = idWoth ;
/*N2D*/                                                     }
/*N2D*/                                                 }
/*N2D*/                                             }
/*N2D*/
/*N2D*/                                             if( psttLag )
/*N2D*/                                             {
/*N2D*/                                                 if( idModeP != ifcIDmODEeTHERsOIL_REPORT ) soulOut << psttLag ;
/*N2D*/                                                 soulLinesLazy << psttLag ;
/*N2D*/                                                 delF( tinP , psttLag ) ;
/*N2D*/
/*N2D*/                                                 //DUPLICATEcODE: 360021c1 360021c1
/*N2D*/                                                 countT cBlank = stq_psttlDelimiterOrBlankAfterLag ;
/*N2D*/                                                 for( countT idb = cBlank ; idb ; idb -- )
/*N2D*/                                                 {
/*N2D*/                                                     strokeS*& psttb = *(strokeS**)&stq_psttlDelimiterOrBlankAfterLag[ idb ] ;
/*N2D*/                                                     __Z( psttb ) ;
/*N2D*/                                                     if( idModeP != ifcIDmODEeTHERsOIL_REPORT ) soulOut << psttb ;
/*N2D*/                                                     delF( tinP , psttb ) ;
/*N2D*/                                                 }
/*N2D*/                                                 stq_psttlDelimiterOrBlankAfterLag.purgeF( tinP ) ;
/*N2D*/                                             }
/*N2D*/                                         }
/*N2D*/
/*N2D*/                                         {
/*N2D*/                                             while( soulLinesLazy )
/*N2D*/                                             {
/*N2D*/                                                 ZE( strokeS* , psttl ) ;
/*N2D*/                                                 soulLinesLazy >> psttl ; ___( psttl ) ;
/*N2D*/
/*N2D*/                                                 ZE( strokeS* , psttlt ) ;
/*N2D*/                                                 strSubstringF( tinP , psttlt , countTC( idWothMin ) , countTC() , psttl ) ; ___( psttlt ) ;
/*N2D*/                                                 delF( tinP , psttl ) ;
/*N2D*/                                                 //traceF( tinP , T("[trimmed]: \"")+T(psttlt)+T("\"\r\n") ) ;
/*N2D*/
/*N2D*/                                                 soulBody << psttlt ;
/*N2D*/                                                 delF( tinP , psttlt ) ;
/*N2D*/                                             }
/*N2D*/                                         }
/*N2D*/
/*N2D*/                                         break ;
/*N2D*/                                     }
/*N2D*/                                 }
/*N2D*/                             }
/*N2D*/                             else if
/*N2D*/                             (
/*N2D*/                                 tKeyLevel1 == tKeySettings
/*N2D*/                                 &&
/*N2D*/                                 (
/*N2D*/                                        tKeyLevel2 == tKeyCloud
/*N2D*/                                     || tKeyLevel2 == tKeyCloudView
/*N2D*/                                     || tKeyLevel2 == tKeyIPDOS
/*N2D*/                                     || tKeyLevel2 == tKeyKtr
/*N2D*/                                 )
/*N2D*/                             )
/*N2D*/                             tSettingsKeyPrefix = tn ;
/*N2D*/
/*N2D*/                             bAllowLevel2 = 1 ;
/*N2D*/                             tKeyLevel2 = tn ;
/*N2D*/
/*N2D*/                             break ;
                                }
                                case 3 :
                                {
/*N3D*/                             bAllowLevel3 = 1 ;
/*N3D*/                             tKeyLevel3 = tn ;
/*N3D*/
/*N3D*/                             break ;
                                }
                            }

                            while( soulValue )
                            {
                                ZE( strokeS* , psttv ) ;
                                soulValue >> psttv ; ___( psttv ) ;
                                //traceF( tinP , T("unprocessed value piece [psttv]: \"")+T(psttv)+T("\"\r\n") ) ;
                                delF( tinP , psttv ) ;
                            }
                        }

                        bDown = 1 ;

                        switch( idModeP )
                        {
                            case ifcIDmODEeTHERsOIL_TRIM : { strFuseF( tinP , soulOut , psttWord ) ; break ; }
                            case ifcIDmODEeTHERsOIL_LINT :
                            {
                                if( scNest < 0 && cFlag23 < CfLAG23mAX )
                                {
                                    cFlag23 ++ ;
                                    strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tm001 ) ;
                                }
                                break ;
                            }
                        }
                    }
                    else if( !strCompareF( tinP , psttWord , tm21 ) )
                    {
                        bDown = 0 ;

                        switch( idModeP )
                        {
                            case ifcIDmODEeTHERsOIL_TRIM : { strFuseF( tinP , soulOut , psttWord ) ; break ; }
                        }
                    }
                    else if( !strCompareF( tinP , psttWord , tm1  ) )
                    {
                        scNest ++ ;
                        bDown = 0 ;

                        switch( idModeP )
                        {
                            case ifcIDmODEeTHERsOIL_TRIM : { strFuseF( tinP , soulOut , psttWord ) ; break ; }
                            case ifcIDmODEeTHERsOIL_LINT :
                            {
                                boolT bAllow = 1 ;
                                switch( scNest )
                                {
                                    case 1  : { if( !bAllowLevel1 ) bAllow = 0 ; break ; }
                                    case 2  : { if( !bAllowLevel2 ) bAllow = 0 ; break ; }
                                    case 3  : { if( !bAllowLevel3 ) bAllow = 0 ; break ; }
                                    default : {                     bAllow = 0 ; break ; }
                                }

                                if( !bAllow && cFlag23 < CfLAG23mAX )
                                {
                                    cFlag23 ++ ;
                                    strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tm101 ) ;
                                }
                                break ;
                            }
                        }
                    }
                    else if( !strCompareF( tinP , psttWord , tBreakMark ) )
                    {
                        if( soulValue ) soulValue << psttWord ;
                        else            strFuseF( tinP , soulOut , psttWord ) ;

                        bDone = 1 ;
                    }
                    else if
                    (
                        1 == strIdF( tinP , tm1 , psttWord )
                        ||
                        1 == strIdF( tinP , tm2 , psttWord )
                    )
                    {
                        cFlag1 ++ ;
                        switch( idModeP )
                        {
                            case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
                        }
                    }
                    else if( soulValue ) // HERE I ASSUME THAT THE "WORD" IS A PIECE, AFTER THE FIRST PIECE, OF A WHOLE VALUE, AND JUST QUEUE IT FOR LAZY PROCESSING
                    {
                        obeyReplacementsF( tinP , *this , psttWord , swReplace , psttzLeverReplace ) ;

                        //traceF( tinP , T("pushing [psttv]: \"")+T(psttWord)+T("\"\r\n") ) ;
                        soulValue << psttWord ;

                        bDone = 1 ;
                    }
                    else
                    {
                        if( !scNest )
                        {
                            countT idfw = 1 ;
                            strokeS sttqw( 0 , sc_IGNOREqUOTES ) ;
                            countT idw = strIdAnyF( tinP , 0 , flSTRmATCH_null , idfw , sttqw , tWhite , psttWord ) ;

                            // idw : BEGINNING OF A WHITE, IF ANY
                            // idfw: BEGINNING OF THE NONWHITE, IF ANY, THAT FOLLOWS THE WHITE

                            if( idw != 1 || idfw )
                            {
                                cFlag1 ++ ;
                                switch( idModeP )
                                {
                                    case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
                                }
                            }
                        }
                        else
                        {
                            ZE( boolT , bBadPrefix ) ;

                            countT idfb = 1 ;
                            strokeS sttqb( 0 , sc_IGNOREqUOTES ) ;
                            countT idb = strIdAnyF( tinP , 0 , flSTRmATCH_null , idfb , sttqb , tBlack , psttWord ) ;

                            // idb : BEGINNING OF A BLACK, IF ANY
                            // idfb: BEGINNING OF THE NONBLACK, IF ANY, THAT FOLLOWS THE BLACK

                            if( idb && !bAllowLevel1 && scNest == 1 )
                            {
                                cFlag1 ++ ;
                                switch( idModeP )
                                {
                                    case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
                                }
                                bBadPrefix = 1 ;
                            }

                            if( !bDown ) //THIS WILL PREVENT PARSING OF NONBLACK BETWEEN CONSECUTIVE CLOSE CURLY BRACKETS ; EDIT IF EVER NEED TO PARSE SUCH TEXT
                            {
                                if
                                (
                                    idb != 1                                        // KEY DOES NOT BEGIN AT 1 OR IS NULL LENGTH
                                    ||
                                    !idfb                                           // NOTHING FOLLOWS KEY
                                    ||
                                    psttWord[ CSpREFIX - 1 + idfb ].idAdam != ':'     // KEY NOT FOLLOWED BY COLON
                                    ||
                                    psttWord->idAdam < idfb                           // NO STROKES FOLLOW COLON
                                )
                                bBadPrefix = 1 ;

                                if( bBadPrefix )
                                {
                                    cFlag1 ++ ;
                                    switch( idModeP )
                                    {
                                        case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
                                    }
                                }
                                else
                                {
                                    ZE( strokeS* , psttKey ) ;
                                    countT idft = 1 ;
                                    strokeS sttqt( 0 , sc_IGNOREqUOTES ) ;
                                    __( !strSubstringF( tinP , psttKey , idft , sttqt , tColon , psttWord ) ) ; ___( psttKey ) ;

                                    ZE( boolT , bOkKey ) ;
                                    if( scNest > 1 && !strCompareF( tinP , tKeyLevel1 , tKeyComment ) && !strCompareF( tinP , tKeyLevel1 , tKeyNull ) ) bOkKey = 1 ;
                                    else for( countT offk = 0 ; offk < sizeof ppsttOkKey / sizeof ppsttOkKey[ 0 ] ; offk ++ )
                                    {
                                        if( !strCompareF( tinP , psttKey , ppsttOkKey[ offk ] ) )
                                        {
                                            bOkKey = offk == offKeyOkTime && ( !year || !month || !date )
                                                ? 0
                                                : offk == offKeyOkBuy && !cents && scNest == 1
                                                    ? 0
                                                    : 1
                                            ;
                                            break ;
                                        }
                                    }

                                    if( !bOkKey )
                                    {
                                        cFlag1 ++ ;
                                        bDone = 1 ;

                                        switch( idModeP )
                                        {
                                            case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
                                        }

                                        switch( idModeP )
                                        {
                                            case ifcIDmODEeTHERsOIL_REPORT :
                                            {
                                                break ;
                                            }
                                            default :
                                            {
                                                strFuseF( tinP , soulOut , psttKey ) ;
                                                strFuseF( tinP , soulOut , tColon ) ;

                                                if( idft )
                                                {
                                                    ZE( strokeS* , psttv ) ;
                                                    countT idfv = idft ;
                                                    ZE( countT , idlv ) ;
                                                    strSubstringF( tinP , psttv , idfv , idlv , psttWord ) ; ___( psttv ) ;
                                                    strFuseF( tinP , soulOut , psttv ) ;
                                                    delF( tinP , psttv ) ;
                                                }
                                                break ;
                                            }
                                        }
                                        delF( tinP , psttKey ) ;
                                    }
                                    else if( !idft )
                                    {
                                        cFlag1 ++ ;
                                        bDone = 1 ;

                                        switch( idModeP )
                                        {
                                            case ifcIDmODEeTHERsOIL_REPORT :
                                            {
                                                break ;
                                            }
                                            default :
                                            {
                                                strFuseF( tinP , soulOut , psttKey ) ;
                                                strFuseF( tinP , soulOut , tColon ) ;
                                                break ;
                                            }
                                        }
                                        delF( tinP , psttKey ) ;

                                        switch( idModeP )
                                        {
                                            case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
                                        }
                                    }
                                    else
                                    {
                                        ZE( strokeS* , psttv ) ;
                                        countT idfv = idft ;
                                        ZE( countT , idlv ) ;
                                        strSubstringF( tinP , psttv , idfv , idlv , psttWord ) ; ___( psttv ) ;

                                        obeyReplacementsF( tinP , *this , psttv , swReplace , psttzLeverReplace ) ;

                                        switch( idModeP )
                                        {
                                            case ifcIDmODEeTHERsOIL_LINT   :
                                            {
                                                bDone = 1 ;
                                                strFuseF( tinP , soulOut , psttKey ) ;
                                                strFuseF( tinP , soulOut , tColon ) ;
                                                // INTENTIONAL FALLTHROUGH
                                            }
                                            case ifcIDmODEeTHERsOIL_REPORT :
                                            {
                                                switch( scNest )
                                                {
                                                    case 1 :
                                                    {
/*N1U*/                                                 tKeyLevel1 = T(psttKey) ;
/*N1U*/                                                 if( !strCompareF( tinP , psttKey , tKeyDate ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "DATE\r\n" ) ;
/*N1U*/
/*N1U*/                                                     ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/
/*N1U*/                                                     ZE( boolT , vBad ) ;
/*N1U*/                                                     if( psttvt->idAdam != 8 || !strIsDigitsF( tinP , psttvt , 0xa ) ) vBad = 1 ;
/*N1U*/                                                     else
/*N1U*/                                                     {
/*N1U*/                                                         //traceF( tinP , T("value passed test 1: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N1U*/
/*N1U*/                                                         ZE( strokeS* , psttYear ) ;
/*N1U*/                                                         ZE( strokeS* , psttMonth ) ;
/*N1U*/                                                         ZE( strokeS* , psttDate ) ;
/*N1U*/                                                         countT idfc = 1 ;
/*N1U*/                                                         countT idlc = 4 ; strSubstringF( tinP , psttYear  , idfc , idlc , psttvt ) ; ___( psttYear  ) ;
/*N1U*/                                                                idlc = 6 ; strSubstringF( tinP , psttMonth , idfc , idlc , psttvt ) ; ___( psttMonth ) ;
/*N1U*/                                                                idlc = 0 ; strSubstringF( tinP , psttDate  , idfc , idlc , psttvt ) ; ___( psttDate  ) ;
/*N1U*/                                                         //traceF( tinP , T("year:  \"")+T(psttYear)+T("\"\r\n") ) ;
/*N1U*/                                                         //traceF( tinP , T("month: \"")+T(psttMonth)+T("\"\r\n") ) ;
/*N1U*/                                                         //traceF( tinP , T("date:  \"")+T(psttDate)+T("\"\r\n") ) ;
/*N1U*/
/*N1U*/                                                         countT yearNew  = strDigitsToSCountF( tinP , psttYear  , 0xa , 1 ) ;
/*N1U*/                                                         countT monthNew = strDigitsToSCountF( tinP , psttMonth , 0xa , 1 ) ;
/*N1U*/                                                         countT dateNew  = strDigitsToSCountF( tinP , psttDate  , 0xa , 1 ) ;
/*N1U*/
/*N1U*/                                                         delF( tinP , psttYear ) ;
/*N1U*/                                                         delF( tinP , psttMonth ) ;
/*N1U*/                                                         delF( tinP , psttDate ) ;
/*N1U*/
/*N1U*/                                                         countT dateMax = 31 ;
/*N1U*/                                                         {
/*N1U*/                                                             switch( monthNew )
/*N1U*/                                                             {
/*N1U*/                                                                 case  4 :
/*N1U*/                                                                 case  6 :
/*N1U*/                                                                 case  9 :
/*N1U*/                                                                 case 11 : { dateMax = 30 ; break ; }
/*N1U*/                                                                 case  2 :
/*N1U*/                                                                 {
/*N1U*/                                                                     // YEARS THAT ARE EVENLY DIVISIBLE BY 100 ARE NOT LEAP YEARS, UNLESS THEY ARE ALSO EVENLY DIVISIBLE BY 400
/*N1U*/                                                                     boolT bLeap = yearNew % 4
/*N1U*/                                                                         ? 0
/*N1U*/                                                                         : !( yearNew % 400 )
/*N1U*/                                                                             ? 1
/*N1U*/                                                                             : !( yearNew % 100 )
/*N1U*/                                                                                 ? 0
/*N1U*/                                                                                 : 1
/*N1U*/                                                                     ;
/*N1U*/
/*N1U*/                                                                     dateMax = bLeap
/*N1U*/                                                                         ? 29
/*N1U*/                                                                         : 28
/*N1U*/                                                                     ;
/*N1U*/                                                                     //CONoUTrAW5( "[bLeap,dateMax]: " , bLeap , " " , dateMax , "\r\n" ) ;
/*N1U*/
/*N1U*/                                                                     break ;
/*N1U*/                                                                 }
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/
/*N1U*/                                                         if
/*N1U*/                                                         (
/*N1U*/                                                             yearNew < 2011                                      //RULE: YEAR MUST BE 2011 OR LATER
/*N1U*/                                                             ||
/*N1U*/                                                             !monthNew
/*N1U*/                                                             ||
/*N1U*/                                                             monthNew > 12
/*N1U*/                                                             ||
/*N1U*/                                                             !dateNew
/*N1U*/                                                             ||
/*N1U*/                                                             dateNew > dateMax
/*N1U*/                                                         )
/*N1U*/                                                         vBad = 1 ;
/*N1U*/                                                         else
/*N1U*/                                                         {
/*N1U*/                                                             ZE( countT  , date1New ) ;
/*N1U*/                                                             ZE( sCountT , date2New ) ;
/*N1U*/                                                             osTimeFromOldTimeF( tinP , date1New , date2New , yearNew - 1 , monthNew - 1 , dateNew - 1 ) ;
/*N1U*/
/*N1U*/                                                             if( !date1New && !date2New )
/*N1U*/                                                             {
/*N1U*/                                                                 countT foo = 2 ;
/*N1U*/                                                             }
/*N1U*/
/*N1U*/                                                             if
/*N1U*/                                                             (
/*N1U*/                                                                 year >= 2012                                    //DATES AND TIMES PRIOR TO 2012 ARE NOT VALIDATED
/*N1U*/                                                                 &&
/*N1U*/                                                                 (
/*N1U*/                                                                     date2New < date2                                //RULE: DATE MUST NOT BE EARLIER THAN PRECEEDING DATE
/*N1U*/                                                                     ||
/*N1U*/                                                                     (
/*N1U*/                                                                         date2New == date2
/*N1U*/                                                                         &&
/*N1U*/                                                                         date1New < date1
/*N1U*/                                                                     )
/*N1U*/                                                                     ||
/*N1U*/                                                                     (
/*N1U*/                                                                         date2
/*N1U*/                                                                         &&
/*N1U*/                                                                         (
/*N1U*/                                                                             date2New > date2 + 1                            //RULE: DATE MUST NOT ADVANCE BY MORE THAN 1 DAY
/*N1U*/                                                                             ||
/*N1U*/                                                                             (
/*N1U*/                                                                                 date2New == date2 + 1
/*N1U*/                                                                                 &&
/*N1U*/                                                                                 date1New > date1 + 0x10000000               //ACROSS THE FALL BACK TIME CHANGE IN THE FALL, date1 WILL INCREASE BY 0x0aaaaaab ; WO IFC HOUR (90 CONVENTIONAL MINUTES) IS ALLOWED HERE JUST TO BE SURE
/*N1U*/                                                                             )                                               //A:ASSUME:WORD IS 02 BITS
/*N1U*/                                                                         )
/*N1U*/                                                                     )
/*N1U*/                                                                 )
/*N1U*/                                                             )
/*N1U*/                                                             vBad = 1 ;
/*N1U*/                                                             else
/*N1U*/                                                             {
/*N1U*/                                                                 date1 = date1New ;
/*N1U*/                                                                 date2 = date2New ;
/*N1U*/                                                                 year  = yearNew ;
/*N1U*/                                                                 month = monthNew ;
/*N1U*/                                                                 date  = dateNew ;
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                     delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             if( !vBad ) { strFuseF( tinP , soulOut , psttv ) ; }
/*N1U*/                                                             else
/*N1U*/                                                             {
/*N1U*/                                                                 cFlag1 ++ ;
/*N1U*/                                                                 if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; }
/*N1U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             }
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             if( vBad ) cFlag1 ++ ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyComment ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "COMMENT\r\n" ) ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyDoJobs ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "DOjOBS\r\n" ) ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyMoney ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "MONEY\r\n" ) ;
/*N1U*/
/*N1U*/                                                     ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/
/*N1U*/                                                     boolT bNeg = psttvt[ CSpREFIX ].idAdam == '-' ;
/*N1U*/
/*N1U*/                                                     if( bNeg )
/*N1U*/                                                     {
/*N1U*/                                                         strokeS* psttd = psttvt ;
/*N1U*/                                                                          psttvt = 0 ;
/*N1U*/                                                         countT idf = 2 ;
/*N1U*/                                                         ZE( countT , idl ) ;
/*N1U*/                                                         strSubstringF( tinP , psttvt , idf , idl , psttd ) ; ___( psttvt ) ;
/*N1U*/                                                         delF( tinP , psttd ) ;
/*N1U*/                                                     }
/*N1U*/
/*N1U*/                                                     ZE( boolT , vBad ) ;
/*N1U*/                                                     if( !strIsDigitsF( tinP , psttvt , 0xa ) ) vBad = 1 ;
/*N1U*/                                                     else
/*N1U*/                                                     {
/*N1U*/                                                         //traceF( tinP , T("value passed test 1: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N1U*/
/*N1U*/                                                         cents = strDigitsToSCountF( tinP , psttvt  , 0xa , 1 ) ;
/*N1U*/                                                         if( bNeg ) cents = - cents ;
/*N1U*/                                                     }
/*N1U*/                                                     delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             if( !vBad ) { strFuseF( tinP , soulOut , psttv ) ; }
/*N1U*/                                                             else
/*N1U*/                                                             {
/*N1U*/                                                                 cFlag1 ++ ;
/*N1U*/                                                                 if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; }
/*N1U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             }
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             if( vBad ) cFlag1 ++ ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyNull ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "NULL\r\n" ) ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyTrace ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "TRACE\r\n" ) ;
/*N1U*/                                                     //bAllowLevel1 = 0 ;
/*N1U*/                                                     //bAllowLevel2 = 1 ;
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             ZE( strokeS* , psttvt ) ;
/*N1U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             tTrace = T(psttvt) ;
/*N1U*/                                                             delF( tinP , psttvt ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyTime ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "TIME\r\n" ) ;
/*N1U*/
/*N1U*/                                                     ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/
/*N1U*/                                                     ZE( boolT , vBad ) ;
/*N1U*/                                                     if( psttvt->idAdam != 4 || !strIsDigitsF( tinP , psttvt , 0xa ) ) vBad = 1 ;
/*N1U*/                                                     else
/*N1U*/                                                     {
/*N1U*/                                                         //traceF( tinP , T("value passed test 1: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N1U*/
/*N1U*/                                                         ZE( strokeS* , psttHour ) ;
/*N1U*/                                                         ZE( strokeS* , psttMinute ) ;
/*N1U*/                                                         countT idfc = 1 ;
/*N1U*/                                                         countT idlc = 2 ; strSubstringF( tinP , psttHour   , idfc , idlc , psttvt ) ; ___( psttHour   ) ;
/*N1U*/                                                                idlc = 0 ; strSubstringF( tinP , psttMinute , idfc , idlc , psttvt ) ; ___( psttMinute ) ;
/*N1U*/                                                         //traceF( tinP , T("hour:   \"")+T(psttHour)+T("\"\r\n") ) ;
/*N1U*/                                                         //traceF( tinP , T("minute: \"")+T(psttMinute)+T("\"\r\n") ) ;
/*N1U*/
/*N1U*/                                                         countT hour   = strDigitsToSCountF( tinP , psttHour   , 0xa , 1 ) ;
/*N1U*/                                                         countT minute = strDigitsToSCountF( tinP , psttMinute , 0xa , 1 ) ;
/*N1U*/
/*N1U*/                                                         delF( tinP , psttHour ) ;
/*N1U*/                                                         delF( tinP , psttMinute ) ;
/*N1U*/
/*N1U*/                                                         if
/*N1U*/                                                         (
/*N1U*/                                                             hour > 23
/*N1U*/                                                             ||
/*N1U*/                                                             minute > 59
/*N1U*/                                                         )
/*N1U*/                                                         vBad = 1 ;
/*N1U*/                                                         else
/*N1U*/                                                         {
/*N1U*/                                                             ZE( countT  , time1New ) ;
/*N1U*/                                                             ZE( sCountT , time2New ) ;
/*N1U*/                                                             osTimeFromOldTimeF( tinP , time1New , time2New , year - 1 , month - 1 , date - 1 , hour , minute ) ;
/*N1U*/
/*N1U*/                                                             if( !time1New && !time2New )
/*N1U*/                                                             {
/*N1U*/                                                                 countT foo = 2 ;
/*N1U*/                                                             }
/*N1U*/
/*N1U*/                                                             if
/*N1U*/                                                             (
/*N1U*/                                                                 year >= 2012                                    //DATES AND TIMES PRIOR TO 2012 ARE NOT VALIDATED
/*N1U*/                                                                 &&
/*N1U*/                                                                 (
/*N1U*/                                                                     time2New < time2
/*N1U*/                                                                     ||
/*N1U*/                                                                     (
/*N1U*/                                                                         time2New == time2
/*N1U*/                                                                         &&
/*N1U*/                                                                         time1New < time1
/*N1U*/                                                                     )
/*N1U*/                                                                 )
/*N1U*/                                                             )
/*N1U*/                                                             vBad = 1 ;
/*N1U*/                                                             else
/*N1U*/                                                             {
/*N1U*/                                                                 time1 = time1New ;
/*N1U*/                                                                 time2 = time2New ;
/*N1U*/                                                                 offStrong = time2 & ~7 ;
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                     delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             if( !vBad ) { strFuseF( tinP , soulOut , psttv ) ; }
/*N1U*/                                                             else
/*N1U*/                                                             {
/*N1U*/                                                                 cFlag1 ++ ;
/*N1U*/                                                                 if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; }
/*N1U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             }
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             if( vBad ) cFlag1 ++ ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyBuy ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "BUY\r\n" ) ;
/*N1U*/
/*N1U*/                                                     ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/
/*N1U*/                                                     boolT bOkBuy = !!stOkBuy( psttvt ) ;
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             // WE DON'T VERIFY cents > 0 HERE BECAUSE THAT HAS ALREADY BEEN DONE (WHEN VALIDATING THE KEY)
/*N1U*/                                                             if( bOkBuy ) { strFuseF( tinP , soulOut , psttv ) ; }
/*N1U*/                                                             else
/*N1U*/                                                             {
/*N1U*/                                                                 cFlag1 ++ ;
/*N1U*/                                                                 if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; }
/*N1U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             }
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             if( cents )
/*N1U*/                                                             {
/*N1U*/                                                                 if( !pSwSwBuy )
/*N1U*/                                                                 {
/*N1U*/                                                                     pSwSwBuy = new( 0 , tinP , LF ) switchC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , offStrong ) ; ___( pSwSwBuy ) ;
/*N1U*/                                                                     __Z( pSwSwBuy ) ;
/*N1U*/                                                                 }
/*N1U*/
/*N1U*/                                                                 if( !POOP )
/*N1U*/                                                                 {
/*N1U*/                                                                     switchC*& pSwBuy = *(switchC**)&(countT&)*pSwSwBuy ;
/*N1U*/                                                                     if( !pSwBuy )
/*N1U*/                                                                     {
/*N1U*/                                                                         pSwBuy = new( 0 , tinP , LF ) switchC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , psttLeverBuy ) ; ___( pSwBuy ) ;
/*N1U*/                                                                         __Z( pSwBuy ) ;
/*N1U*/                                                                     }
/*N1U*/
/*N1U*/                                                                     if( !POOP )
/*N1U*/                                                                     {
/*N1U*/                                                                         psttLeverBuy = psttvt ;
/*N1U*/                                                                         *pSwBuy += cents ;
/*N1U*/                                                                         psttLeverBuy = 0 ;
/*N1U*/                                                                     }
/*N1U*/                                                                 }
/*N1U*/                                                             }
/*N1U*/
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                     delF( tinP , psttvt ) ;
/*N1U*/                                                     cents = 0 ;
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyTimecard ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "TIMECARD\r\n" ) ;
/*N1U*/
/*N1U*/                                                     if( year < 2012 )
/*N1U*/                                                     {
/*N1U*/                                                         switch( idModeP )
/*N1U*/                                                         {
/*N1U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                             {
/*N1U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                                 break ;
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                     else
/*N1U*/                                                     {
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/
/*N1U*/                                                         boolT bOkCard = !!stOkCard( psttvt ) ;
/*N1U*/
/*N1U*/                                                         switch( idModeP )
/*N1U*/                                                         {
/*N1U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                             {
/*N1U*/                                                                 if( bOkCard ) { strFuseF( tinP , soulOut , psttv ) ; }
/*N1U*/                                                                 else
/*N1U*/                                                                 {
/*N1U*/                                                                     cFlag1 ++ ;
/*N1U*/                                                                     if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; }
/*N1U*/                                                                     strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                                 }
/*N1U*/                                                                 break ;
/*N1U*/                                                             }
/*N1U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                             {
/*N1U*/                                                                 if( psttLeverCard && time2 && timeCard2 )
/*N1U*/                                                                 {
/*N1U*/                                                                     if( !pSwSwTimeCard )
/*N1U*/                                                                     {
/*N1U*/                                                                         pSwSwTimeCard = new( 0 , tinP , LF ) switchC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , offStrong ) ; ___( pSwSwTimeCard ) ;
/*N1U*/                                                                         __Z( pSwSwTimeCard ) ;
/*N1U*/
/*N1U*/                                                                         pSwTimeMax = new( 0 , tinP , LF ) switchC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , offStrong , 0 , sizeof( timeS ) ) ; ___( pSwTimeMax ) ;
/*N1U*/                                                                         __Z( pSwTimeMax ) ;
/*N1U*/                                                                     }
/*N1U*/
/*N1U*/                                                                     if( !POOP )
/*N1U*/                                                                     {
/*N1U*/                                                                         if( offStrong - offStrongCard )
/*N1U*/                                                                         {
/*N1U*/                                                                             if( offStrong - offStrongCard > 1 ) traceF( tinP , T("quantity ")+TF2(offStrong-offStrongCard-1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" consecutive strongs encountered for which there were no timecard entries.  reported timecard totals for the preceding strong will be incorrect") ) ;
/*N1U*/
/*N1U*/                                                                             countT    offStrongSaved = offStrong ;
/*N1U*/                                                                                       offStrong      = offStrongCard ;
/*N1U*/                                                                             switchC*& pSwTimeCard    = *(switchC**)&(countT&)*pSwSwTimeCard ;
/*N1U*/
/*N1U*/                                                                             if( !pSwTimeCard )
/*N1U*/                                                                             {
/*N1U*/                                                                                 pSwTimeCard = new( 0 , tinP , LF ) switchC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , psttLeverCard , 0 , sizeof( timeS ) ) ; ___( pSwTimeCard ) ;
/*N1U*/                                                                                 __Z( pSwTimeCard ) ;
/*N1U*/                                                                             }
/*N1U*/
/*N1U*/                                                                             if( !POOP )
/*N1U*/                                                                             {
/*N1U*/                                                                                 countT  timeE1 = 0 ;
/*N1U*/                                                                                 sCountT timeE2 = time2 ;
/*N1U*/                                                                                 osTimeSubtractF( tinP , timeE1 , timeE2 , 1 ) ; //SO THAT THIS END TIME IS WITHIN (AT THE END OF) THE LATH STRONG
/*N1U*/                                                                                 const countT  timeDivide1 = timeE1 ;
/*N1U*/                                                                                 const sCountT timeDivide2 = timeE2 ;
/*N1U*/
/*N1U*/                                                                                 timeS& timeMax = *(timeS*)&(countT&)*pSwTimeMax ;
/*N1U*/                                                                                 if
/*N1U*/                                                                                 (
/*N1U*/                                                                                     timeMax.time2 < timeDivide2
/*N1U*/                                                                                     ||
/*N1U*/                                                                                     (
/*N1U*/                                                                                         timeMax.time2 == timeDivide2
/*N1U*/                                                                                         &&
/*N1U*/                                                                                         timeMax.time1 < timeDivide1
/*N1U*/                                                                                     )
/*N1U*/                                                                                 )
/*N1U*/                                                                                 {
/*N1U*/                                                                                     timeMax.time1 = timeDivide1 ;
/*N1U*/                                                                                     timeMax.time2 = timeDivide2 ;
/*N1U*/                                                                                 }
/*N1U*/
/*N1U*/                                                                                 osTimeSubtractF( tinP , timeE1 , timeE2 , timeCard1 , timeCard2 ) ;
/*N1U*/                                                                                 timeS& accum = *(timeS*)&(countT&)*pSwTimeCard ;
/*N1U*/                                                                                 osTimeAddF( tinP , accum.time1 , accum.time2 , timeE1 , timeE2 ) ;
/*N1U*/
/*N1U*/                                                                                 timeCard1     = timeDivide1 ;
/*N1U*/                                                                                 timeCard2     = timeDivide2 ;
/*N1U*/                                                                                 offStrongCard = timeCard2 & ~7 ;
/*N1U*/
/*N1U*/                                                                                 offStrong = offStrongSaved ;
/*N1U*/                                                                             }
/*N1U*/                                                                         }
/*N1U*/
/*N1U*/                                                                         countT  timeE1 = time1 ; //ELAPSED TIME TO ACCUMULATE FOR THE OLD LEVER VALUE
/*N1U*/                                                                         sCountT timeE2 = time2 ;
/*N1U*/                                                                         osTimeSubtractF( tinP , timeE1 , timeE2 , timeCard1 , timeCard2 ) ;
/*N1U*/
/*N1U*/                                                                         switchC*& pSwTimeCard = *(switchC**)&(countT&)*pSwSwTimeCard ;
/*N1U*/                                                                         if( !pSwTimeCard )
/*N1U*/                                                                         {
/*N1U*/                                                                             pSwTimeCard = new( 0 , tinP , LF ) switchC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , psttLeverCard , 0 , sizeof( timeS ) ) ; ___( pSwTimeCard ) ;
/*N1U*/                                                                             __Z( pSwTimeCard ) ;
/*N1U*/                                                                         }
/*N1U*/
/*N1U*/                                                                         if( !POOP )
/*N1U*/                                                                         {
/*N1U*/                                                                             timeS& timeMax = *(timeS*)&(countT&)*pSwTimeMax ;
/*N1U*/                                                                             if
/*N1U*/                                                                             (
/*N1U*/                                                                                 timeMax.time2 < time2
/*N1U*/                                                                                 ||
/*N1U*/                                                                                 (
/*N1U*/                                                                                     timeMax.time2 == time2
/*N1U*/                                                                                     &&
/*N1U*/                                                                                     timeMax.time1 < time1
/*N1U*/                                                                                 )
/*N1U*/                                                                             )
/*N1U*/                                                                             {
/*N1U*/                                                                                 timeMax.time1 = time1 ;
/*N1U*/                                                                                 timeMax.time2 = time2 ;
/*N1U*/                                                                             }
/*N1U*/
/*N1U*/                                                                             timeS& accum = *(timeS*)&(countT&)*pSwTimeCard ;
/*N1U*/                                                                             osTimeAddF( tinP , accum.time1 , accum.time2 , timeE1 , timeE2 ) ;
/*N1U*/                                                                         }
/*N1U*/                                                                     }
/*N1U*/                                                                 }
/*N1U*/
/*N1U*/                                                                 timeCard1    = time1 ; // STARTING TIME FOR THE NEW LEVER VALUE
/*N1U*/                                                                 timeCard2    = time2 ;
/*N1U*/                                                                 offStrongCard = timeCard2 & ~7 ;
/*N1U*/
/*N1U*/                                                                 tLeverCard = T(psttvt) ;
/*N1U*/                                                                 psttLeverCard = tLeverCard ; // SET THE NEW LEVER VALUE
/*N1U*/
/*N1U*/                                                                 break ;
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyDo ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "DO\r\n" ) ;
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             if( !pStDo )
/*N1U*/                                                             {
/*N1U*/                                                                 pStDo = new( 0 , tinP , LF ) stackC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStDo ) ;
/*N1U*/                                                                 __Z( pStDo ) ;
/*N1U*/                                                             }
/*N1U*/
/*N1U*/                                                             ZE( strokeS* , psttvt ) ;
/*N1U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/
/*N1U*/                                                             if( time1 || time2 )
/*N1U*/                                                             {
/*N1U*/                                                                 if( time1TranscriptLath != time1 || time2TranscriptLath != time2 )
/*N1U*/                                                                 {
/*N1U*/                                                                     time1TranscriptLath = time1 ;
/*N1U*/                                                                     time2TranscriptLath = time2 ;
/*N1U*/                                                                     idTranscriptLath = 0 ;
/*N1U*/                                                                 }
/*N1U*/                                                                 emitTranscriptIfChangedF( tinP , *this , psttKey , psttvt , time1 , time2 , ++ idTranscriptLath , tArchive ) ;
/*N1U*/                                                             }
/*N1U*/
/*N1U*/                                                             if( csttMaxDo < psttvt->idAdam ) csttMaxDo = psttvt->idAdam ;
/*N1U*/                                                             pStDo->sinkF( tinP , countTC() , psttvt ) ; psttvt = 0 ;
/*N1U*/
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyLog ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "LOG\r\n" ) ;
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             if( !pStLog )
/*N1U*/                                                             {
/*N1U*/                                                                 pStLog = new( 0 , tinP , LF ) stackC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStLog ) ;
/*N1U*/                                                                 __Z( pStLog ) ;
/*N1U*/                                                             }
/*N1U*/
/*N1U*/                                                             ZE( strokeS* , psttvt ) ;
/*N1U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/
/*N1U*/                                                             ZE( strokeS* , pstte ) ;
/*N1U*/                                                             strMakeF( tinP , LF , pstte , TT4(time1,time2,4,6)+T(" } {l: ") , psttvt->idAdam ) ; ___( pstte ) ;
/*N1U*/                                                             strFuseF( tinP , pstte , psttvt ) ;
/*N1U*/
/*N1U*/                                                             if( time1 || time2 )
/*N1U*/                                                             {
/*N1U*/                                                                 if( time1TranscriptLath != time1 || time2TranscriptLath != time2 )
/*N1U*/                                                                 {
/*N1U*/                                                                     time1TranscriptLath = time1 ;
/*N1U*/                                                                     time2TranscriptLath = time2 ;
/*N1U*/                                                                     idTranscriptLath = 0 ;
/*N1U*/                                                                 }
/*N1U*/                                                                 emitTranscriptIfChangedF( tinP , *this , psttKey , psttvt , time1 , time2 , ++ idTranscriptLath , tArchive ) ;
/*N1U*/                                                             }
/*N1U*/
/*N1U*/                                                             delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                             if( csttMaxLog < pstte->idAdam ) csttMaxLog = pstte->idAdam ;
/*N1U*/                                                             *pStLog << pstte ; pstte = 0 ;
/*N1U*/
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyJournal ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "JOURNAL\r\n" ) ;
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             if( !pStJournal )
/*N1U*/                                                             {
/*N1U*/                                                                 pStJournal = new( 0 , tinP , LF ) stackC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStJournal ) ;
/*N1U*/                                                                 __Z( pStJournal ) ;
/*N1U*/                                                             }
/*N1U*/
/*N1U*/                                                             ZE( strokeS* , psttvt ) ;
/*N1U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/
/*N1U*/                                                             ZE( strokeS* , pstte ) ;
/*N1U*/                                                             strMakeF( tinP , LF , pstte , TT4(time1,time2,4,6)+T(" } {j: ") , psttvt->idAdam ) ; ___( pstte ) ;
/*N1U*/                                                             strFuseF( tinP , pstte , psttvt ) ;
/*N1U*/
/*N1U*/                                                             if( time1 || time2 )
/*N1U*/                                                             {
/*N1U*/                                                                 if( time1TranscriptLath != time1 || time2TranscriptLath != time2 )
/*N1U*/                                                                 {
/*N1U*/                                                                     time1TranscriptLath = time1 ;
/*N1U*/                                                                     time2TranscriptLath = time2 ;
/*N1U*/                                                                     idTranscriptLath = 0 ;
/*N1U*/                                                                 }
/*N1U*/                                                                 emitTranscriptIfChangedF( tinP , *this , psttKey , psttvt , time1 , time2 , ++ idTranscriptLath , tArchive ) ;
/*N1U*/                                                             }
/*N1U*/
/*N1U*/                                                             delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                             if( csttMaxJournal < pstte->idAdam ) csttMaxJournal = pstte->idAdam ;
/*N1U*/                                                             *pStJournal << pstte ; pstte = 0 ;
/*N1U*/
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyRepeat ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "REPEAT\r\n" ) ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             bRepeat = 1 ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyReplacements ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "REPLACEMENTS\r\n" ) ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/
/*N1U*/                                                     {
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         {
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             {
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyValidate ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "VALIDATE\r\n" ) ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/
/*N1U*/                                                     {
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         {
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             {
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyMath ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "ARITHMETIC\r\n" ) ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/
/*N1U*/                                                     {
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         {
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             {
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyKtr ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "KTR\r\n" ) ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/
/*N1U*/                                                     {
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         {
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             {
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if
/*N1U*/                                                 (
/*N1U*/                                                        !strCompareF( tinP , psttKey , tKeySettings )
/*N1U*/                                                     || !strCompareF( tinP , psttKey , tKeyWaitStep )
/*N1U*/                                                 )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "SETTINGS | WAITsTEP\r\n" ) ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/
/*N1U*/                                                     {
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         {
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             {
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyRenameToHash ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "RENAMEtOhASH\r\n" ) ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/
/*N1U*/                                                     {
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         {
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             {
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if
/*N1U*/                                                 (
/*N1U*/                                                        !strCompareF( tinP , psttKey , tKeySplit )
/*N1U*/                                                     || !strCompareF( tinP , psttKey , tKeyJoin  )
/*N1U*/                                                 )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "SPLIT JOIN\r\n" ) ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     if( !strCompareF( tinP , psttKey , tKeySplit ) ) sizeBytes = TICK ;
/*N1U*/
/*N1U*/                                                     {
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         {
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             {
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyEdit ) || !strCompareF( tinP , psttKey , tKeyReport ) || !strCompareF( tinP , psttKey , tKeyZip ) || !strCompareF( tinP , psttKey , tKeyInspectFileNames ) )
/*N1U*/                                                 {
/*N1U*/                                                     //traceF( tinP , "REPORT\r\n" ) ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/
/*N1U*/                                                     {
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         {
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             {
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             }
/*N1U*/                                                         }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         {
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 else
/*N1U*/                                                 {
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             break ;
/*N1U*/                                                         }
/*N1U*/                                                     }
/*N1U*/                                                 }
/*N1U*/                                                 break ;
                                                    }
                                                    case 2 :
                                                    {
/*N2U*/                                                 tKeyLevel2 = T(psttKey) ;
/*N2U*/                                                 if( !strCompareF( tinP , tKeyLevel1 , tKeyComment ) )
/*N2U*/                                                 {
/*N2U*/                                                     //traceF( tinP , "COMMENT / *\r\n" ) ;
/*N2U*/
/*N2U*/                                                     switch( idModeP )
/*N2U*/                                                     {
/*N2U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             break ;
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                 }
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyDoJobs ) )
/*N2U*/                                                 {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyJobQueue ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "DOjOBS / JOBqUEUE\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("DOjOBS / JOBqUEUE [jobqueuefolder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 tJobQueueFolder = T(psttvt) ;
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyRepeat ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "DOjOBS / REPEAT\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("[jobqueuerepeat]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 tJobQueueRepeat = T(psttvt) ;
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                 }
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyReplacements ) )
/*N2U*/                                                 {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyReplace ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "REPLACEMENTS / REPLACE\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/
/*N2U*/                                                         ZE( strokeS* , psttvt ) ;
/*N2U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/
/*N2U*/                                                         if( psttvt && psttvt->idAdam )
/*N2U*/                                                         {
/*N2U*/                                                             ZE( strokeS* , pstt1Words ) ;
/*N2U*/                                                             strokeS sttq ;
/*N2V*/                                                             traceF( tinP , T("calling strWordsF 2") ) ;
/*N2U*/                                                             strWordsF( tinP , pstt1Words , psttvt , sttq ) ; ___( pstt1Words ) ;
/*N2V*/                                                             traceF( tinP , T("called strWordsF 2") ) ;
/*N2U*/
/*N2U*/                                                             ZE( strokeS* , psttBefore ) ;
/*N2U*/                                                             FORsTRINGSiN1( pstt1Words )
/*N2U*/                                                             {
/*N2U*/                                                                 if( BwOTHsTRING1 )
/*N2U*/                                                                 {
/*N2U*/                                                                     delF( tinP , psttBefore ) ;
/*N2U*/                                                                     strMakeF( tinP , LF , psttBefore , tm3+T(psttc1)+tm4 ) ; ___( psttBefore ) ;
/*N2U*/                                                                     psttzLeverReplace = psttBefore ;
/*N2U*/                                                                 }
/*N2U*/                                                                 else
/*N2U*/                                                                 {
/*N2U*/                                                                     strokeS*& psttAfter = *(strokeS**)&(countT&)swReplace ;
/*N2U*/                                                                     if( psttAfter ) delF( tinP , psttAfter ) ;
/*N2U*/                                                                     strMakeF( tinP , LF , psttAfter , psttc1 ) ; ___( psttAfter ) ;
/*N2U*/                                                                     break ;
/*N2U*/                                                                 }
/*N2U*/                                                             }
/*N2U*/                                                             delF( tinP , psttBefore ) ;
/*N2U*/                                                             delF( tinP , pstt1Words ) ;
/*N2U*/                                                         }
/*N2U*/                                                         delF( tinP , psttvt ) ;
/*N2U*/                                                     }
/*N2U*/                                                 }
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeySettings ) )
/*N2U*/                                                 {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyMemory ) )
/*N2U*/                                                     {
/*N2U*/                                                         traceF( tinP , T("SETTINGS / MEMORY SPACE\r\n") ) ;
/*N2U*/                                                         //bAllowLevel2 = 0 ;
/*N2U*/                                                         //bAllowLevel3 = 1 ;
/*N2U*/
/*N2U*/                                                         {
/*N2U*/                                                             ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                             tMemory = T(psttvt) ;
/*N2U*/                                                             delF( tinP , psttvt ) ;
/*N2U*/                                                         }
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 //delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N3U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyCloud ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "SETTINGS / CLOUD\r\n" ) ;
/*N2U*/                                                         bAllowLevel2 = 0 ;
/*N2U*/                                                         bAllowLevel3 = 1 ;
/*N2U*/
/*N2U*/                                                         {
/*N2U*/                                                             ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                             if( !psttvt || !psttvt->idAdam )
/*N2U*/                                                             {
/*N2U*/                                                                 cFlag1 ++ ;
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                                 {
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N2U*/                                                                 }
/*N2U*/                                                             }
/*N2U*/                                                             else
/*N2U*/                                                             {
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                                 {
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                                     {
/*N2U*/                                                                         //tSettingsKeyPrefix = tn ;
/*N2U*/                                                                         tSettingsKeyPrefix = T("!cloud.")+T(psttvt)+strokeS('.') ;
/*N2U*/                                                                         break ;
/*N2U*/                                                                     }
/*N2U*/                                                                 }
/*N2U*/                                                             }
/*N2U*/                                                             delF( tinP , psttvt ) ;
/*N2U*/                                                         }
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 //delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyCloudView ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "SETTINGS / CLOUDVIEW\r\n" ) ;
/*N2U*/                                                         bAllowLevel2 = 0 ;
/*N2U*/                                                         bAllowLevel3 = 1 ;
/*N2U*/
/*N2U*/                                                         {
/*N2U*/                                                             ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                             if( !psttvt || !psttvt->idAdam )
/*N2U*/                                                             {
/*N2U*/                                                                 cFlag1 ++ ;
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                                 {
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N2U*/                                                                 }
/*N2U*/                                                             }
/*N2U*/                                                             else
/*N2U*/                                                             {
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                                 {
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                                     {
/*N2U*/                                                                         //tSettingsKeyPrefix = tn ;
/*N2U*/                                                                         tSettingsKeyPrefix = T("!cloudview.")+T(psttvt)+strokeS('.') ;
/*N2U*/                                                                         break ;
/*N2U*/                                                                     }
/*N2U*/                                                                 }
/*N2U*/                                                             }
/*N2U*/                                                             delF( tinP , psttvt ) ;
/*N2U*/                                                         }
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 //delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyIPDOS ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "SETTINGS / IPDOS\r\n" ) ;
/*N2U*/                                                         bAllowLevel2 = 0 ;
/*N2U*/                                                         bAllowLevel3 = 1 ;
/*N2U*/
/*N2U*/                                                         {
/*N2U*/                                                             ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                             if( psttvt && psttvt->idAdam )
/*N2U*/                                                             {
/*N2U*/                                                                 cFlag1 ++ ;
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                                 {
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N2U*/                                                                 }
/*N2U*/                                                             }
/*N2U*/                                                             else
/*N2U*/                                                             {
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                                 {
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                                     {
/*N2U*/                                                                         tSettingsKeyPrefix = T("!ipdos.") ;
/*N2U*/                                                                         break ;
/*N2U*/                                                                     }
/*N2U*/                                                                 }
/*N2U*/                                                             }
/*N2U*/                                                             delF( tinP , psttvt ) ;
/*N2U*/                                                         }
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 //delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyKtr ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "SETTINGS / KTR\r\n" ) ;
/*N2U*/                                                         bAllowLevel2 = 0 ;
/*N2U*/                                                         bAllowLevel3 = 1 ;
/*N2U*/
/*N2U*/                                                         {
/*N2U*/                                                             ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                             if( psttvt && psttvt->idAdam )
/*N2U*/                                                             {
/*N2U*/                                                                 cFlag1 ++ ;
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                                 {
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N2U*/                                                                 }
/*N2U*/                                                             }
/*N2U*/                                                             else
/*N2U*/                                                             {
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                                 {
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                                     {
/*N2U*/                                                                         //tSettingsKeyPrefix = tn ;
/*N2U*/                                                                         tSettingsKeyPrefix = T("!ktr.") ;
/*N2U*/                                                                         break ;
/*N2U*/                                                                     }
/*N2U*/                                                                 }
/*N2U*/                                                             }
/*N2U*/                                                             delF( tinP , psttvt ) ;
/*N2U*/                                                         }
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 //delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                 }
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyRenameToHash ) )
/*N2U*/                                                 {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyFolder ) )
/*N2U*/                                                     {
/*N2U*/                                                         traceF( tinP , T("RENAMEtOhASH / FOLDER\r\n") ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("[folder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 tFolder = T(psttvt) ;
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                 }
/*N2U*/                                                 else if
/*N2U*/                                                 (
/*N2U*/                                                        !strCompareF( tinP , tKeyLevel1 , tKeySplit )
/*N2U*/                                                     || !strCompareF( tinP , tKeyLevel1 , tKeyJoin  )
/*N2U*/                                                 )
/*N2U*/                                                 {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyFolderFrom ) )
/*N2U*/                                                     {
/*N2U*/                                                         traceF( tinP , T("SPLIT JOIN / FOLDERFROM\r\n") ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("[folder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 tFolderFrom = T(psttvt) ;
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyFolderTo ) )
/*N2U*/                                                     {
/*N2U*/                                                         traceF( tinP , T("SPLIT JOIN / FOLDERTO\r\n") ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("[folder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 tFolderTo = T(psttvt) ;
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeySizeBytes ) && !strCompareF( tinP , tKeyLevel1 , tKeySplit ) )
/*N2U*/                                                     {
/*N2U*/                                                         traceF( tinP , T("SPLIT / SIZEBYTES\r\n") ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     sizeBytes = strDigitsToSCountF( tinP , psttvt ) ;
/*N2U*/                                                                     traceF( tinP , T("[sizebytes]: ")+TF2(sizeBytes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                 }
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyValidate ) )
/*N2U*/                                                 {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyBuy ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "VALIDATE / BUY\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     ZE( strokeS* , pstt1Words ) ;
/*N2U*/                                                                     strokeS sttq ;
/*N2U*/                                                                     traceF( tinP , T("calling strWordsF 3") ) ;
/*N2U*/                                                                     strWordsF( tinP , pstt1Words , psttvt , sttq ) ; ___( pstt1Words ) ;
/*N2U*/                                                                     traceF( tinP , T("called strWordsF 3") ) ;
/*N2U*/
/*N2U*/                                                                     ZE( boolT , bGotBudget ) ;
/*N2U*/                                                                     FORsTRINGSiN1( pstt1Words )
/*N2U*/                                                                     {
/*N2U*/                                                                         ZE( strokeS* , psttOk ) ;
/*N2U*/                                                                         strMakeF( tinP , LF , psttOk , psttc1 ) ; ___( psttOk ) ;
/*N2U*/                                                                         ZE( countT , ids ) ;
/*N2U*/                                                                         stOkBuy.sinkF( tinP , ids , psttOk , flSTACKsINK_UNIQUE ) ;
/*N2U*/                                                                         if( !ids ) delF( tinP , psttOk ) ;
/*N2U*/                                                                     }
/*N2U*/                                                                     delF( tinP , pstt1Words ) ;
/*N2U*/                                                                 }
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyTimecard ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "VALIDATE / TIMECARD\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     ZE( strokeS* , pstt1Words ) ;
/*N2U*/                                                                     strokeS sttq ;
/*N2U*/                                                                     traceF( tinP , T("calling strWordsF 4") ) ;
/*N2U*/                                                                     strWordsF( tinP , pstt1Words , psttvt , sttq ) ; ___( pstt1Words ) ;
/*N2U*/                                                                     traceF( tinP , T("called strWordsF 4") ) ;
/*N2U*/
/*N2U*/                                                                     FORsTRINGSiN1( pstt1Words )
/*N2U*/                                                                     {
/*N2U*/                                                                         ZE( strokeS* , psttOk ) ;
/*N2U*/                                                                         strMakeF( tinP , LF , psttOk , psttc1 ) ; ___( psttOk ) ;
/*N2U*/                                                                         ZE( countT , ids ) ;
/*N2U*/                                                                         stOkCard.sinkF( tinP , ids , psttOk , flSTACKsINK_UNIQUE ) ;
/*N2U*/                                                                         if( !ids ) delF( tinP , psttOk ) ;
/*N2U*/                                                                     }
/*N2U*/                                                                     delF( tinP , pstt1Words ) ;
/*N2U*/                                                                 }
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                 }
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyWaitStep ) )
/*N2U*/                                                 {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyModulo1 ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "WAITsTEP / MODULO1\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     waitStepModulo1 = strDigitsToSCountF( tinP , psttvt ) ;
/*N2U*/                                                                     traceF( tinP , T("[waitStepModulo1]: ")+TF2(waitStepModulo1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyModulo2 ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "WAITsTEP / MODULO2\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     waitStepModulo2 = strDigitsToSCountF( tinP , psttvt ) ;
/*N2U*/                                                                     traceF( tinP , T("[waitStepModulo2]: ")+TF2(waitStepModulo2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyRemainder1 ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "WAITsTEP / REMAINDER1\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     waitStepRemainder1 = strDigitsToSCountF( tinP , psttvt ) ;
/*N2U*/                                                                     traceF( tinP , T("[waitStepRemainder1]: ")+TF2(waitStepRemainder1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyRemainder2 ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "WAITsTEP / REMAINDER2\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     waitStepRemainder2 = strDigitsToSCountF( tinP , psttvt ) ;
/*N2U*/                                                                     traceF( tinP , T("[waitStepRemainder2]: ")+TF2(waitStepRemainder2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyNapTocks ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "WAITsTEP / NAPTOCKS\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     waitStepNapTocks = strDigitsToSCountF( tinP , psttvt ) ;
/*N2U*/                                                                     traceF( tinP , T("[waitStepNapTocks]: ")+TF2(waitStepNapTocks,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                 }
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyMath ) )
/*N2U*/                                                 {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyBudget ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "MATH / BUDGET\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     ZE( strokeS* , pstt1Terms ) ;
/*N2U*/                                                                     strokeS sttq ;
/*N2U*/                                                                     traceF( tinP , T("calling strWordsF 5") ) ;
/*N2U*/                                                                     strWordsF( tinP , pstt1Terms , psttvt , sttq ) ; ___( pstt1Terms ) ;
/*N2U*/                                                                     traceF( tinP , T("called strWordsF 5") ) ;
/*N2U*/
/*N2U*/                                                                     ZE( boolT , bGotBudget ) ;
/*N2U*/                                                                     FORsTRINGSiN1( pstt1Terms )
/*N2U*/                                                                     {
/*N2U*/                                                                         if( BwOTHsTRING1 ) psttzLeverBudget = psttc1 ;
/*N2U*/                                                                         else if( !bGotBudget )
/*N2U*/                                                                         {
/*N2U*/                                                                             if( strCompareF( tinP , tAssign , psttc1 ) ) break ;
/*N2U*/                                                                             else
/*N2U*/                                                                             {
/*N2U*/                                                                                 bGotBudget = 1 ;
/*N2U*/                                                                                 swsBudget.purgeF( tinP ) ;
/*N2U*/                                                                             }
/*N2U*/                                                                         }
/*N2U*/                                                                         else swsBudget << (measureT)strDigitsToMeasureF( tinP , psttc1 ) ;
/*N2U*/                                                                     }
/*N2U*/                                                                     delF( tinP , pstt1Terms ) ;
/*N2U*/                                                                 }
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyCalculate ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "MATH / CALCULATE\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     ZE( strokeS* , pstt1Terms ) ;
/*N2U*/                                                                     strokeS sttq ;
/*N2U*/                                                                     traceF( tinP , T("calling strWordsF 6") ) ;
/*N2U*/                                                                     strWordsF( tinP , pstt1Terms , psttvt , sttq ) ; ___( pstt1Terms ) ;
/*N2U*/                                                                     traceF( tinP , T("called strWordsF 6") ) ;
/*N2U*/
/*N2U*/                                                                     ZE( boolT , bGotAssign ) ;
/*N2U*/                                                                     FORsTRINGSiN1( pstt1Terms )
/*N2U*/                                                                     {
/*N2U*/                                                                         if( BwOTHsTRING1 ) psttzLeverAssign = psttc1 ;
/*N2U*/                                                                         else if( !bGotAssign )
/*N2U*/                                                                         {
/*N2U*/                                                                             if( strCompareF( tinP , tAssign , psttc1 ) ) break ;
/*N2U*/                                                                             else
/*N2U*/                                                                             {
/*N2U*/                                                                                 bGotAssign = 1 ;
/*N2U*/                                                                                 swsAssign.purgeF( tinP ) ;
/*N2U*/                                                                             }
/*N2U*/                                                                         }
/*N2U*/                                                                         else
/*N2U*/                                                                         {
/*N2U*/                                                                             ZE( strokeS* , psttTerm ) ;
/*N2U*/                                                                             strMakeF( tinP , LF , psttTerm , psttc1 ) ; ___( psttTerm ) ;
/*N2U*/                                                                             swsAssign << psttTerm ;
/*N2U*/                                                                         }
/*N2U*/                                                                     }
/*N2U*/                                                                     delF( tinP , pstt1Terms ) ;
/*N2U*/                                                                 }
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                 }
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyKtr ) )
/*N2U*/                                                 {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyFile ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "KTR / FILE\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 //strokeF( tinP , T("[file]: \"")+T(psttvt)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/                                                                 tFile = T(psttvt) ;
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyFolder ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "KTR / FOLDER\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 traceF( tinP , T("trimming [psttv]: >>>>")+T(psttv)+T("<<<<") ) ; //U:: TO FIND A BUG
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv , 0 , T(TbLACK "\"")  ) ; ___( psttvt ) ;
/*N2U*/                                                                 //strokeF( tinP , T("[folder]: \"")+T(psttvt)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/                                                                 tFolder = T(psttvt) ;
/*N2U*/                                                                 traceF( tinP , T("set obeying tKeyFolder for KTR [tFolder]: ")+tFolder ) ; //U:: TO FIND A BUG
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyMode ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "KTR / MODE\r\n" ) ;
/*N2U*/
/*N2U*/                                                         ZE( strokeS* , psttvt ) ;
/*N2U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/
/*N2U*/                                                         idKtrMode = !strCompareF( tinP , psttvt , tValueKtrModeRoot )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_ROOT
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModePaid )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_PAID
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeTutorials )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_TUTORIALS
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeHooks )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_HOOKS
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeBundle )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_BUNDLE
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeNews )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_NEWS
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeEssays )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_ESSAYS
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeArchive )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_ARCHIVE
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeWo )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_WO
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModePay )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_PAY
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeIpdos )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_IPDOS
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeOther )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_OTHER
/*N2U*/                                                             : ifcIDmODEpUTfILE_OTHER //U:: SET AN ERROR AND REFUSE TO PROCESS THE INPUT
/*N2U*/                                                         ;
/*N2U*/
/*N2U*/                                                         if( !idKtrMode )
/*N2U*/                                                         {
/*N2U*/                                                             cFlag1 ++ ;
/*N2U*/                                                             switch( idModeP )
/*N2U*/                                                             {
/*N2U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 //strokeF( tinP , T("[mode]: \"")+T(psttv)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/
/*N2U*/                                                         delF( tinP , psttvt ) ;
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyHtmlFolder ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "KTR / HTMLFOLDER\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     traceF( tinP , T("ktr [htmlfolder name]: ")+T(psttvt) ) ;
/*N2U*/                                                                     tHtmlFolder = T(psttvt) ;
/*N2U*/                                                                 }
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyHtmlBodyPrefix ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "KTR / HTMLBODYPREFIX\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     IFsCRATCH
/*N2U*/                                                                     {
/*N2U*/                                                                         traceF( tinP , T("ktr [htmlbodyprefix file name]: ")+T(psttvt) ) ;
/*N2U*/
/*N2U*/                                                                         SCOOPS
/*N2U*/
/*N2U*/                                                                         ZE( osTextT* , postv ) ;
/*N2U*/                                                                         ZE( countT   , costv ) ;
/*N2U*/                                                                         tinP.pEtScratch->boxGetShadowF( tinP , postv , costv , psttvt , 1 ) ; ___( postv ) ;
/*N2U*/
/*N2U*/                                                                         if( POOP ) POOPR
/*N2U*/                                                                         else       tHtmlBodyPrefix = T(postv) ;
/*N2U*/                                                                         delF( tinP , postv ) ;
/*N2U*/                                                                     }
/*N2U*/                                                                 }
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyHtmlBodySuffix ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "KTR / HTMLBODYSUFFIX\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     IFsCRATCH
/*N2U*/                                                                     {
/*N2U*/                                                                         traceF( tinP , T("ktr [htmlbodysuffix file name]: ")+T(psttvt) ) ;
/*N2U*/
/*N2U*/                                                                         SCOOPS
/*N2U*/
/*N2U*/                                                                         ZE( osTextT* , postv ) ;
/*N2U*/                                                                         ZE( countT   , costv ) ;
/*N2U*/                                                                         tinP.pEtScratch->boxGetShadowF( tinP , postv , costv , psttvt , 1 ) ; ___( postv ) ;
/*N2U*/
/*N2U*/                                                                         if( POOP ) POOPR
/*N2U*/                                                                         else       tHtmlBodySuffix = T(postv) ;
/*N2U*/                                                                         delF( tinP , postv ) ;
/*N2U*/                                                                     }
/*N2U*/                                                                 }
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyHtmlHead ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "KTR / HTMLHEAD\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 {
/*N2U*/                                                                     IFsCRATCH
/*N2U*/                                                                     {
/*N2U*/                                                                         traceF( tinP , T("ktr [htmlhead file name]: ")+T(psttvt) ) ;
/*N2U*/
/*N2U*/                                                                         SCOOPS
/*N2U*/
/*N2U*/                                                                         ZE( osTextT* , postv ) ;
/*N2U*/                                                                         ZE( countT   , costv ) ;
/*N2U*/                                                                         tinP.pEtScratch->boxGetShadowF( tinP , postv , costv , psttvt , 1 ) ; ___( postv ) ;
/*N2U*/
/*N2U*/                                                                         if( POOP ) POOPR
/*N2U*/                                                                         else       tHtmlHead = T(postv) ;
/*N2U*/                                                                         delF( tinP , postv ) ;
/*N2U*/                                                                     }
/*N2U*/                                                                 }
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyFlags ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "KTR / FLAGS\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 //strokeF( tinP , T("[flags]: \"")+T(psttv)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/
/*N2U*/                                                                 ZE( strokeS* , pstt1w ) ;
/*N2U*/                                                                 strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
/*N2U*/                                                                 traceF( tinP , T("calling strWordsF 7") ) ;
/*N2U*/                                                                 strWordsF( tinP , pstt1w , psttv , sttq ) ; ___( pstt1w ) ;
/*N2U*/                                                                 traceF( tinP , T("called strWordsF 7") ) ;
/*N2U*/                                                                 FORsTRINGSiN1( pstt1w )
/*N2U*/                                                                 {
/*N2U*/                                                                     if( !strCompareF( tinP , psttc1 , tNoRef        ) ) flagsLoad    |= flBRANCHslOADf_NOrEFERENCES ;
/*N2U*/                                                                     if( !strCompareF( tinP , psttc1 , tFlagNoZip    ) ) flagsPutFile |= flBRANCHspUTfILEf_NOzIP ;
/*N2U*/                                                                     if( !strCompareF( tinP , psttc1 , tFlagBeep     ) ) flagsPutFile |= flBRANCHspUTfILEf_BEEP  ;
/*N2U*/                                                                     if( !strCompareF( tinP , psttc1 , tFlagFragNote ) ) flagsReport  |= flETHERsOILrEPORT_FRAGnOTE ;
/*N2U*/                                                                 }
/*N2U*/                                                                 delF( tinP , pstt1w ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyBody ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "KTR / BODY\r\n" ) ;
/*N2U*/                                                         bAllowLevel2 = 0 ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 //traceF( tinP , T("pushing [psttv]: \"")+T(psttv)+T("\"\r\n") ) ;
/*N2U*/                                                                 soulValue << psttv ;
/*N2U*/                                                                 delF( tinP , psttv ) ; // CAN BE LARGE, AND DON'T NEED IT ANY MORE
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyNameSpace ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "KTR / NAMESPACE\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 traceF( tinP , T("trimming [psttv]: >>>>")+T(psttv)+T("<<<<") ) ; //U:: TO FIND A BUG
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv , 0 , T(TbLACK "\"")  ) ; ___( psttvt ) ;
/*N2U*/                                                                 //strokeF( tinP , T("[folder]: \"")+T(psttvt)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/                                                                 tNameSpace = T(psttvt) ;
/*N2U*/                                                                 traceF( tinP , T("set obeying tKeyNameSpace for KTR [tNameSpace]: ")+tNameSpace ) ; //U:: TO FIND A BUG
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else
/*N2U*/                                                     {
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                 }
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyEdit ) || !strCompareF( tinP , tKeyLevel1 , tKeyReport ) || !strCompareF( tinP , tKeyLevel1 , tKeyZip ) || !strCompareF( tinP , tKeyLevel1 , tKeyInspectFileNames ) )
/*N2U*/                                                 {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyJobQueue ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "EDIT|REPORT|ZIP|INSPECT / JOBqUEUE\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T(" EDIT|REPORT|ZIP|INSPECT / JOBqUEUE [jobqueuefolder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 tJobQueueFolder = T(psttvt) ;
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyFolder ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "EDIT|REPORT|ZIP|INSPECT / FOLDER\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("[reportsfolder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 tReportsFolder = T(psttvt) ;
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyFilter ) )
/*N2U*/                                                     {
/*N2U*/                                                         if( idModeP == ifcIDmODEeTHERsOIL_LINT ) strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyUser ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "EDIT|REPORT|ZIP|INSPECT / USER\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 //strokeF( tinP , T("[file]: \"")+T(psttvt)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/
/*N2U*/                                                                 if( idModeP == ifcIDmODEeTHERsOIL_REPORT )
/*N2U*/                                                                 {
/*N2U*/                                                                     tUserOverride = T(psttvt) ;
/*N2U*/                                                                     if( !tReportsSource.csF( tinP ) )
/*N2U*/                                                                     {
/*N2U*/                                                                         ZE( strokeS* , psttm ) ;
/*N2U*/                                                                         diskMapFileNameF( tinP , psttm , T("///ideafarm/IdeaFarm (tm)/")+( tUserOverride.csF( tinP ) ? tUserOverride : tUser )+T("/Drop Files Here To Archive/") ) ; ___( psttm ) ;
/*N2U*/                                                                         tArchive = T(psttm) ;
/*N2U*/                                                                         //traceF( tinP , T("set 2 [tArchive]: ")+tArchive ) ;
/*N2U*/                                                                         delF( tinP , psttm ) ;
/*N2U*/                                                                     }
/*N2U*/                                                                 }
/*N2U*/                                                                 else
/*N2U*/                                                                 {
/*N2U*/                                                                     ZE( boolT , bFound ) ;
/*N2U*/                                                                     IFsCRATCH
/*N2U*/                                                                     {
/*N2U*/                                                                         SCOOPS
/*N2U*/                                                                         TN( tLike , "" ) ; tLike = T("///ideafarm/IdeaFarm (tm)/")+T(psttvt)+T("/*") ;
/*N2U*/                                                                         bFound = tinP.pEtScratch->diskFileExistsF( tinP , tLike ) ;
/*N2U*/                                                                         if( POOP )
/*N2U*/                                                                         {
/*N2U*/                                                                             POOPR
/*N2U*/                                                                             bFound = 0 ;
/*N2U*/                                                                         }
/*N2U*/                                                                     }
/*N2U*/
/*N2U*/                                                                     if( !bFound )
/*N2U*/                                                                     {
/*N2U*/                                                                         cFlag1 ++ ;
/*N2U*/                                                                         if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; }
/*N2U*/                                                                     }
/*N2U*/                                                                 }
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 if( idModeP == ifcIDmODEeTHERsOIL_LINT ) strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeySource ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "EDIT|REPORT|ZIP|INSPECT / SOURCE\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("[reportssource]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 traceF( tinP , T("DOjOBS / JOBqUEUE [jobqueuefolder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 tReportsSource = T(psttvt) ;
/*N2U*/                                                                 traceF( tinP , T("EDIT|REPORT|ZIP|INSPECT / SOURCE set [tReportsSource]: ")+tReportsSource ) ;
/*N2U*/
/*N2U*/                                                                 if( tReportsSource.csF( tinP ) )
/*N2U*/                                                                 {
/*N2U*/                                                                     tArchive = tReportsSource ;
/*N2U*/                                                                     //traceF( tinP , T("set 8 [tArchive]: ")+tArchive ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                 else
/*N2U*/                                                                 {
/*N2U*/                                                                     ZE( strokeS* , psttm ) ;
/*N2U*/                                                                     diskMapFileNameF( tinP , psttm , T("///ideafarm/IdeaFarm (tm)/")+( tUserOverride.csF( tinP ) ? tUserOverride : tUser )+T("/Drop Files Here To Archive/") ) ; ___( psttm ) ;
/*N2U*/                                                                     tArchive = T(psttm) ;
/*N2U*/                                                                     //traceF( tinP , T("set 9 [tArchive]: ")+tArchive ) ;
/*N2U*/                                                                     delF( tinP , psttm ) ;
/*N2U*/                                                                 }
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyNameSpace ) )
/*N2U*/                                                     {
/*N2U*/                                                         //traceF( tinP , "EDIT|REPORT|ZIP|INSPECT / NAMESPACE\r\n" ) ;
/*N2U*/
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                         {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                             {
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             {
/*N2U*/                                                                 traceF( tinP , T("trimming [psttv]: >>>>")+T(psttv)+T("<<<<") ) ; //U:: TO FIND A BUG
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv , 0 , T(TbLACK "\"")  ) ; ___( psttvt ) ;
/*N2U*/                                                                 //strokeF( tinP , T("[folder]: \"")+T(psttvt)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/                                                                 tNameSpace = T(psttvt) ;
/*N2U*/                                                                 traceF( tinP , T("set obeying tKeyNameSpace for KTR [tNameSpace]: ")+tNameSpace ) ; //U:: TO FIND A BUG
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 break ;
/*N2U*/                                                             }
/*N2U*/                                                         }
/*N2U*/                                                     }
/*N2U*/                                                     else
/*N2U*/                                                     {
/*N2U*/                                                         if( idModeP == ifcIDmODEeTHERsOIL_LINT ) strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                     }
/*N2U*/                                                 }
/*N2U*/                                                 break ;
                                                    }
                                                    case 3 :
                                                    {
/*N3U*/                                                 tKeyLevel3 = T(psttKey) ;
/*N3U*/                                                 if( !strCompareF( tinP , tKeyLevel2 , tKeyFilter ) )
/*N3U*/                                                 {
/*N3U*/                                                     if( !strCompareF( tinP , psttKey , tKeyFileType ) )
/*N3U*/                                                     {
/*N3U*/                                                         ZE( strokeS* , psttvt ) ;
/*N3U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N3U*/
/*N3U*/                                                         if( psttvt && psttvt->idAdam )
/*N3U*/                                                         {
/*N3U*/                                                             ZE( countT , ids ) ;
/*N3U*/                                                             stFileType.sinkF( tinP , ids , psttvt , flSTACKsINK_UNIQUE ) ;
/*N3U*/                                                             if( !ids ) delF( tinP , psttvt ) ;
/*N3U*/                                                         }
/*N3U*/                                                     }
/*N3U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyTimeRange ) )
/*N3U*/                                                     {
/*N3U*/                                                         ZE( strokeS* , psttvt ) ;
/*N3U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N3U*/
/*N3U*/                                                         ZE( strokeS* , pstt1w ) ;
/*N3U*/                                                         strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
/*N3U*/                                                         traceF( tinP , T("calling strWordsF 8") ) ;
/*N3U*/                                                         strWordsF( tinP , pstt1w , psttvt , sttq  ) ; ___( pstt1w ) ;
/*N3U*/                                                         traceF( tinP , T("called strWordsF 8") ) ;
/*N3U*/                                                         delF( tinP , psttvt ) ;
/*N3U*/
/*N3U*/                                                         ZE( strokeS* , psttzMin ) ;
/*N3U*/                                                         ZE( strokeS* , psttzMax ) ;
/*N3U*/                                                         {
/*N3U*/                                                             boolT bMin = 1 ;
/*N3U*/                                                             FORsTRINGSiN1( pstt1w )
/*N3U*/                                                             {
/*N3U*/                                                                 if( bMin )
/*N3U*/                                                                 {
/*N3U*/                                                                     bMin = 0 ;
/*N3U*/                                                                     psttzMin = psttc1 ;
/*N3U*/                                                                 }
/*N3U*/                                                                 else
/*N3U*/                                                                 {
/*N3U*/                                                                     psttzMax = psttc1 ;
/*N3U*/                                                                     break ;
/*N3U*/                                                                 }
/*N3U*/                                                             }
/*N3U*/                                                         }
/*N3U*/
/*N3U*/                                                         if( psttzMin && psttzMax )
/*N3U*/                                                         {
/*N3U*/                                                             strokeS* ppstt2[] = { 0 , 0 } ;
/*N3U*/                                                             strMakeF( tinP , LF , ppstt2[ 0 ] , psttzMin ) ; ___( ppstt2[ 0 ] ) ;
/*N3U*/                                                             strMakeF( tinP , LF , ppstt2[ 1 ] , psttzMax ) ; ___( ppstt2[ 1 ] ) ;
/*N3U*/
/*N3U*/                                                             //traceF( tinP , T("stTimeMinMax + [ppstt2[0],ppstt2[1]]:    \"")+T(ppstt2[0])+T("\"    \"")+T(ppstt2[1])+T("\"") ) ;
/*N3U*/
/*N3U*/                                                             stTimeMinMax << (byteT*)ppstt2 ;
/*N3U*/                                                         }
/*N3U*/
/*N3U*/                                                         delF( tinP , pstt1w ) ;
/*N3U*/                                                     }
/*N3U*/
/*N3U*/                                                     switch( idModeP )
/*N3U*/                                                     {
/*N3U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N3U*/                                                         {
/*N3U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N3U*/                                                             break ;
/*N3U*/                                                         }
/*N3U*/                                                     }
/*N3U*/                                                 }
/*N3U*/                                                 else if
/*N3U*/                                                 (
/*N3U*/                                                        !strCompareF( tinP , tKeyLevel2 , tKeyCloud     )
/*N3U*/                                                     || !strCompareF( tinP , tKeyLevel2 , tKeyCloudView )
/*N3U*/                                                     || !strCompareF( tinP , tKeyLevel2 , tKeyIPDOS     )
/*N3U*/                                                     || !strCompareF( tinP , tKeyLevel2 , tKeyKtr       )
/*N3U*/                                                 )
/*N3U*/                                                 {
/*N3U*/                                                     if( !strCompareF( tinP , psttKey , tKeyKV ) )
/*N3U*/                                                     {
/*N3U*/                                                         //traceF( tinP , "SETTINGS / KVPAIR\r\n" ) ;
/*N3U*/                                                         //bAllowLevel2 = 0 ;
/*N3U*/                                                         //bAllowLevel3 = 1 ;
/*N3U*/
/*N3U*/                                                         {
/*N3U*/                                                             ZE( strokeS* , psttvt ) ;
/*N3U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N3U*/                                                             if( psttvt && psttvt->idAdam )
/*N3U*/                                                             {
/*N3U*/                                                                 ZE( strokeS* , pstt1w ) ;
/*N3U*/                                                                 strokeS sttq ;
/*N3U*/                                                                 traceF( tinP , T("calling strWordsF 9") ) ;
/*N3U*/                                                                 strWordsF( tinP , pstt1w , psttvt , sttq ) ; ___( pstt1w ) ;
/*N3U*/                                                                 traceF( tinP , T("called strWordsF 9") ) ;
/*N3U*/                                                                 ZE( countT , idIn ) ;
/*N3U*/                                                                 TN( tKey , "" ) ;
/*N3U*/                                                                 FORsTRINGSiN1( pstt1w )
/*N3U*/                                                                 {
/*N3U*/                                                                     switch( ++ idIn )
/*N3U*/                                                                     {
/*N3U*/                                                                         case 1 : { tKey = tSettingsKeyPrefix+T(psttc1) ; break ; }
/*N3U*/                                                                         case 2 :
/*N3U*/                                                                         {
/*N3U*/                                                                             psttzLeverSettings = tKey ;
/*N3U*/                                                                             strokeS*& psttValue = *(strokeS**)&(countT&)swSettings ;
/*N3U*/                                                                             delF( tinP , psttValue ) ;
/*N3U*/                                                                             strMakeF( tinP , LF , psttValue , psttc1 ) ; ___( psttValue ) ;
/*N3U*/
/*N3U*/                                                                             break ;
/*N3U*/                                                                         }
/*N3U*/                                                                         default : { break ; }
/*N3U*/                                                                     }
/*N3U*/                                                                 }
/*N3U*/                                                                 delF( tinP , pstt1w ) ;
/*N3U*/                                                             }
/*N3U*/                                                             delF( tinP , psttvt ) ;
/*N3U*/                                                         }
/*N3U*/
/*N3U*/                                                         switch( idModeP )
/*N3U*/                                                         {
/*N3U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N3U*/                                                             {
/*N3U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N3U*/                                                                 break ;
/*N3U*/                                                             }
/*N3U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N3U*/                                                             {
/*N3U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N3U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N3U*/                                                                 //delF( tinP , psttvt ) ;
/*N3U*/
/*N3U*/                                                                 break ;
/*N3U*/                                                             }
/*N3U*/                                                         }
/*N3U*/                                                     }
/*N3U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyKVF ) )
/*N3U*/                                                     {
/*N3U*/                                                         //traceF( tinP , "SETTINGS / KVFPAIR\r\n" ) ;
/*N3U*/                                                         //bAllowLevel2 = 0 ;
/*N3U*/                                                         //bAllowLevel3 = 1 ;
/*N3U*/
/*N3U*/                                                         IFsCRATCH
/*N3U*/                                                         {
/*N3U*/                                                             ZE( strokeS* , psttvt ) ;
/*N3U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N3U*/                                                             if( psttvt && psttvt->idAdam )
/*N3U*/                                                             {
/*N3U*/                                                                 ZE( strokeS* , pstt1w ) ;
/*N3U*/                                                                 strokeS sttq ;
/*N3U*/                                                                 traceF( tinP , T("calling strWordsF a") ) ;
/*N3U*/                                                                 strWordsF( tinP , pstt1w , psttvt , sttq ) ; ___( pstt1w ) ;
/*N3U*/                                                                 traceF( tinP , T("called strWordsF a") ) ;
/*N3U*/                                                                 ZE( countT , idIn ) ;
/*N3U*/                                                                 TN( tKey , "" ) ;
/*N3U*/                                                                 FORsTRINGSiN1( pstt1w )
/*N3U*/                                                                 {
/*N3U*/                                                                     switch( ++ idIn )
/*N3U*/                                                                     {
/*N3U*/                                                                         case 1 : { tKey = tSettingsKeyPrefix+T(psttc1) ; break ; }
/*N3U*/                                                                         case 2 :
/*N3U*/                                                                         {
/*N3U*/                                                                             SCOOPS
/*N3U*/
/*N3U*/                                                                             ZE( osTextT* , postv ) ;
/*N3U*/                                                                             ZE( countT   , costv ) ;
/*N3U*/                                                                             tinP.pEtScratch->boxGetShadowF( tinP , postv , costv , psttc1 , 1 ) ; ___( postv ) ;
/*N3U*/
/*N3U*/                                                                             if( POOP ) POOPR
/*N3U*/                                                                             else
/*N3U*/                                                                             {
/*N3U*/                                                                                 psttzLeverSettings = tKey ;
/*N3U*/                                                                                 strokeS*& psttValue = *(strokeS**)&(countT&)swSettings ;
/*N3U*/                                                                                 delF( tinP , psttValue ) ;
/*N3U*/                                                                                 strMakeFromOsTextF( tinP , psttValue , postv ) ; ___( psttValue ) ;
/*N3U*/                                                                             }
/*N3U*/                                                                             delF( tinP , postv ) ;
/*N3U*/
/*N3U*/                                                                             break ;
/*N3U*/                                                                         }
/*N3U*/                                                                         default : { break ; }
/*N3U*/                                                                     }
/*N3U*/                                                                 }
/*N3U*/                                                                 delF( tinP , pstt1w ) ;
/*N3U*/                                                             }
/*N3U*/                                                             delF( tinP , psttvt ) ;
/*N3U*/                                                         }
/*N3U*/
/*N3U*/                                                         switch( idModeP )
/*N3U*/                                                         {
/*N3U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N3U*/                                                             {
/*N3U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N3U*/                                                                 break ;
/*N3U*/                                                             }
/*N3U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N3U*/                                                             {
/*N3U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N3U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N3U*/                                                                 //delF( tinP , psttvt ) ;
/*N3U*/
/*N3U*/                                                                 break ;
/*N3U*/                                                             }
/*N3U*/                                                         }
/*N3U*/                                                     }
/*N3U*/                                                 }
/*N3U*/                                                 break ;
                                                    }
                                                    default :
                                                    {
/*N.U*/                                                 if( !strCompareF( tinP , tKeyLevel1 , tKeyComment ) )
/*N.U*/                                                 {
/*N.U*/                                                     //traceF( tinP , "COMMENT / * / * ...\r\n" ) ;
/*N.U*/
/*N.U*/                                                     switch( idModeP )
/*N.U*/                                                     {
/*N.U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N.U*/                                                         {
/*N.U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N.U*/                                                             break ;
/*N.U*/                                                         }
/*N.U*/                                                     }
/*N.U*/                                                 }
/*N.U*/                                                 break ;
                                                    }
                                                }

                                                break ;
                                            }
                                            case ifcIDmODEeTHERsOIL_TRIM :
                                            {
                                                strFuseF( tinP , soulOut , psttKey ) ;
                                                strFuseF( tinP , soulOut , tColon ) ;

                                                ZE( strokeS* , psttvt ) ;
                                                strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
                                                strFuseF( tinP , soulOut , psttvt ) ;
                                                delF( tinP , psttvt ) ;

                                                break ;
                                            }
                                            case ifcIDmODEeTHERsOIL_QUERYvALUES :
                                            {
                                                if( !psttKeyP || !strCompareF( tinP , psttKey , psttKeyP ) )
                                                {
                                                    if( !psttKeyP ) strFuseSeparateF( tinP , soulOut , psttKey ) ;

                                                    ZE( strokeS* , psttvt ) ;
                                                    strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
                                                    strFuseSeparateF( tinP , soulOut , psttvt ) ;
                                                    delF( tinP , psttvt ) ;
                                                }

                                                break ;
                                            }
                                        }
                                        delF( tinP , psttv ) ;
                                        delF( tinP , psttKey ) ;
                                    }
                                }
                            }
                        }
                    }

                    switch( idModeP )
                    {
                        case ifcIDmODEeTHERsOIL_LINT :
                        {
                            if( !bDone ) strFuseF( tinP , soulOut , psttWord ) ;

                            break ;
                        }
                    }
                    delF( tinP , psttWord ) ;

                    //LOGrAW3( "default soil processing [soulWords]: " , soulWords , " /-\r\n" ) ;
                }

                /**/if( bTrace ) traceF( tinP , T("etherSoilF / generating reports") ) ;

                if( !bQuitP && idModeP == ifcIDmODEeTHERsOIL_REPORT )
                {
                    traceF( tinP , T("etherSoilF / generating report / 8") ) ;
                    ZE( countT  , grandMax1 ) ;
                    ZE( sCountT , grandMax2 ) ;
                    if( pSwTimeMax )
                    {
                        countT cFlavors = pSwTimeMax->cFlavorsF( tinP ) ;
                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        {
                            offStrong = pSwTimeMax->leverF( tinP , idf ) ;
                            timeS& timeMax = *(timeS*)&(countT&)*pSwTimeMax ;
                            if
                            (
                                grandMax2 < timeMax.time2
                                ||
                                (
                                    grandMax2 == timeMax.time2
                                    &&
                                    grandMax1 < timeMax.time1
                                )
                            )
                            {
                                grandMax1 = timeMax.time1 ;
                                grandMax2 = timeMax.time2 ;
                            }
                        }
                    }

                    stackC stSortedBuy(  tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE|flSTACKc_BLOB , 3 * sizeof( countT ) ) ;
                    stackC stSortedCard( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE|flSTACKc_BLOB , 4 * sizeof( countT ) ) ;

                    ZE( countT , csttCategory ) ;
                    ZE( countT , csttActivity ) ;
                    ZE( countT , cStrongBuy ) ;
                    ZE( countT , cStrongCard ) ;

                    traceF( tinP , T("etherSoilF / generating report / 7") ) ;
                    if( pSwSwBuy )
                    {
                        cStrongBuy = pSwSwBuy->cFlavorsF( tinP ) ;
                        for( countT idf = 1 ; idf <= cStrongBuy ; idf ++ )
                        {
                            offStrong = pSwSwBuy->leverF( tinP , idf ) ;
                            switchC*& pSwBuy = *(switchC**)&(countT&)*pSwSwBuy ;
                            __Z( pSwBuy ) ;
                            if( !POOP )
                            {
                                countT cFlavors2 = pSwBuy->cFlavorsF( tinP ) ;
                                if( !POOP )
                                {
                                    for( countT idf2 = 1 ; idf2 <= cFlavors2 ; idf2 ++ )
                                    {
                                        psttLeverBuy = (strokeS*)pSwBuy->leverF( tinP , idf2 ) ;
                                        countT centsTotal = *pSwBuy ;
                                        //strokeF( tinP , TF3(centsTotal,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,8)+T("    ")+T(psttLeverBuy)+T("\r\n") ) ;

                                        csttCategory += psttLeverBuy->idAdam ;

                                        countT pc3[] = { offStrong , centsTotal , (countT)psttLeverBuy } ;
                                        stSortedBuy.sinkF( tinP , countTC() , (byteT*)pc3 , flSTACKsINK_null , subtractBuy_330021c0_F ) ;
                                    }
                                }
                            }
                        }
                    }

                    traceF( tinP , T("etherSoilF / generating report / 6") ) ;
                    if( pSwSwTimeCard )
                    {
                        cStrongCard = pSwSwTimeCard->cFlavorsF( tinP ) ;
                        for( countT idf = 1 ; idf <= cStrongCard ; idf ++ )
                        {
                            offStrong = pSwSwTimeCard->leverF( tinP , idf ) ;
                            switchC*& pSwTimeCard = *(switchC**)&(countT&)*pSwSwTimeCard ;
                            __Z( pSwTimeCard ) ;
                            if( !POOP )
                            {
                                countT cFlavors2 = pSwTimeCard->cFlavorsF( tinP ) ;
                                if( !POOP )
                                {
                                    for( countT idf2 = 1 ; idf2 <= cFlavors2 ; idf2 ++ )
                                    {
                                        psttLeverCard = (strokeS*)pSwTimeCard->leverF( tinP , idf2 ) ;
                                        timeS& accum = *(timeS*)&(countT&)*pSwTimeCard ;
                                        //strokeF( tinP , TF3(accum.time1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,8)+T(".")+TF3(accum.time2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("    ")+T(psttLeverCard)+T("\r\n") ) ;

                                        csttActivity += psttLeverCard->idAdam ;

                                        countT pc4[] = { offStrong , accum.time2 , accum.time1 , (countT)psttLeverCard } ;
                                        stSortedCard.sinkF( tinP , countTC() , (byteT*)pc4 , flSTACKsINK_null , subtractTimecard_330021c0_F ) ;
                                    }
                                }
                            }
                        }
                    }

                    traceF( tinP , T("etherSoilF / generating report / 5") ) ;
                    {
                        TN( tHead ,

                            "\r\n"
                            "{report:\r\n"
                            "\r\n"
                            "    {name:     Time by Strong by Activity                         }\r\n"
                            "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
                            "    {source:   ideafarm.com                                       }\r\n"
                            "    {time:     "
                        ) ;

                        {
                            ZE( countT  , timeN1 ) ;
                            ZE( sCountT , timeN2 ) ;
                            osTimeNowF( tinP , timeN1 , timeN2 ) ;

                            tHead +=

                                 TT4(timeN1,timeN2,4,8)  +T("                                        }\r\n    {lathtime: ")
                                +TT4(grandMax1,grandMax2,4,8)+T("                                        }\r\n\r\n    {body:\r\n")

                            ;
                        }

                        soulC soulReport1( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report1" ) ;
                        strFuseF( tinP , soulReport1 , tHead ) ;
                        ZE( countT  , idsLath ) ;
                        ZE( countT  , total1  ) ;
                        ZE( sCountT , total2  ) ;
                        ZE( strokeS* , psttzLeverMath ) ;
                        switchC swMathValues( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverMath , 0 , sizeof( timeS ) ) ;
                        while( stSortedCard )
                        {
                            countT pc4[] = { 0 , 0 , 0 , 0 } ;
                            byteT* pbi = (byteT*)pc4 ;
                            stSortedCard >> pbi ;

                            if( idsLath != pc4[ 0 ] )
                            {
                                if( idsLath )
                                {
                                    countT cFlavorsAssign = swsAssign.cFlavorsF( tinP ) ;
                                    for( countT idf = 1 ; idf <= cFlavorsAssign ; idf ++ )
                                    {
                                        psttzLeverAssign = (strokeS*)swsAssign.leverF( tinP , idf ) ;

                                        stackC stForth( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , sizeof( timeS ) ) ;
                                        if( swsAssign )
                                        {
                                            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            do
                                            {
                                                strokeS* psttTerm = (strokeS*)swsAssign.downF( tinP , hWalk ) ;

                                                if( !strCompareF( tinP , psttTerm , tAssign ) )
                                                {
                                                }
                                                else if( !strCompareF( tinP , psttTerm , tPlus ) )
                                                {
                                                    timeS& t1 = *(timeS*)&stForth[ 1 ] ;
                                                    timeS& t2 = *(timeS*)&stForth[ 2 ] ;
                                                    osTimeAddF( tinP , t2.time1 , t2.time2 , t1.time1 , t1.time2 ) ;

                                                    timeS td ;
                                                    byteT* pbd = (byteT*)&td ;
                                                    stForth >> pbd ;
                                                }
                                                else
                                                {
                                                    psttzLeverMath = psttTerm ;
                                                    timeS& timeTerm = *(timeS*)&(countT&)swMathValues ;
                                                    stForth << (byteT*)&timeTerm ;
                                                }
                                            }
                                            while( ~hWalk ) ;
                                        }

                                        timeS timeResult ;
                                        if( stForth )
                                        {
                                            byteT* pbd = (byteT*)&timeResult ;
                                            stForth >> pbd ;
                                        }

                                        countT t1 = RC( timeResult.time1 , 0x18 ) ;
                                        countT t2 = timeResult.time2 ;
                                        if( t1 >= TUCK )
                                        {
                                            t1 -= TUCK ;
                                            t2 ++ ;
                                        }

                                        TN( tSay2 , "" ) ; tSay2 = T(idf==1?"\r\n":"")+T("            {c" ":    ")+TF3(t1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF3(t2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TP(psttzLeverAssign,0x30) ;
                                        strFuseF( tinP , soulReport1 , tSay2 ) ;

                                        if( swsBudget.idSlotOfLeverF( tinP , (countT)psttzLeverAssign ) )
                                        {
                                            psttzLeverBudget = psttzLeverAssign ;

                                            ZE( countT , timeBudget1 ) ;
                                            ZE( sCountT , timeBudget2 ) ;
                                            if( swsBudget )
                                            {
                                                ZE( countT , offDay ) ;
                                                {
                                                    countT save = offStrong ;
                                                    offStrong = idsLath ;
                                                    timeS& timeMax = *(timeS*)&(countT&)*pSwTimeMax ;
                                                    offStrong = save ;

                                                    if( !timeMax.time1 ) osTimeSubtractF( tinP , timeMax.time1 , timeMax.time2 , 1 ) ;

                                                    offDay = timeMax.time2 % 8 ;
                                                }

                                                countT cDo = 1 + offDay ;
                                                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                do
                                                {
                                                    if( !( cDo -- ) ) break ;

                                                    measureT mHours = *(measureT*)&swsBudget.downF( tinP , hWalk ) ; // IN swsBudget, THE UNITS ARE IFC HOURS
                                                    countT add = mHours * ( TICK << 4 ) ;
                                                    osTimeAddF( tinP , timeBudget1 , timeBudget2 , add ) ;
                                                }
                                                while( ~hWalk ) ;
                                            }

                                            countT t1 = RC( timeBudget1 , 0x18 ) ;
                                            countT t2 = timeBudget2 ;
                                            if( t1 >= TUCK )
                                            {
                                                t1 -= TUCK ;
                                                t2 ++ ;
                                            }

                                            strFuseF( tinP , soulReport1 , T("    {budget: ")+TF3(t1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF2(t2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" }") ) ;

                                            countT  var1 = timeResult.time1 ;
                                            sCountT var2 = timeResult.time2 ;

                                            osTimeSubtractF( tinP , var1 , var2 , timeBudget1 , timeBudget2 ) ;

                                            countT v1 = RC( var1 , 0x18 ) ;
                                            sCountT v2 = var2 ;
                                            if( v1 >= TUCK )
                                            {
                                                v1 -= TUCK ;
                                                v2 ++ ;
                                            }

                                            strFuseF( tinP , soulReport1 , T("    {variance: ")+TF3(v1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF2(v2,flFORMAT_NObIGITvALUES)+T(" }") ) ;
                                        }

                                        strFuseF( tinP , soulReport1 , T(" }\r\n") ) ;

                                    }

                                    countT t1 = RC( total1 , 0x18 ) ;
                                    countT t2 = total2;
                                    if( t1 >= TUCK )
                                    {
                                        t1 -= TUCK ;
                                        t2 ++ ;
                                    }

                                    TN( tTotal , "\r\n            {total: " ) ; tTotal += TF3(t1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF2(t2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" }\r\n        }\r\n") ; //CS:CODEsYNC 330021C0 330021C0 330021C0
                                    strFuseF( tinP , soulReport1 , tTotal ) ;
                                }

                                TN( tSubHead , "\r\n        {strong: " ) ; tSubHead += TF2(pc4[0],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n\r\n") ; //CS:CODEsYNC 330021C0 330021C0 330021C0
                                strFuseF( tinP , soulReport1 , tSubHead ) ;

                                idsLath = pc4[ 0 ] ;
                                total2 = total1 = 0 ;
                                swMathValues.freeF( tinP ) ;
                            }

                            psttzLeverMath = (strokeS*)pc4[ 3 ] ;
                            timeS& timeValue = *(timeS*)&(countT&)swMathValues ;
                            timeValue.time1 = pc4[ 2 ] ;
                            timeValue.time2 = pc4[ 1 ] ;

                            countT t1 = RC( pc4[ 2 ] , 0x18 ) ;
                            countT t2 = pc4[ 1 ] ;
                            if( t1 >= TUCK )
                            {
                                t1 -= TUCK ;
                                t2 ++ ;
                            }

                            strFuseF( tinP , soulReport1 , T("            {a:    ")+TF3(t1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF3(t2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TP(psttzLeverMath,0x30) ) ;
                            strFuseF( tinP , soulReport1 , T(" }\r\n") ) ;

                            osTimeAddF( tinP , total1 , total2 , pc4[ 2 ] , pc4[ 1 ] ) ;

                            idsLath = pc4[ 0 ] ;
                        }

                        if( idsLath )
                        {
                            countT cFlavorsAssign = swsAssign.cFlavorsF( tinP ) ;
                            for( countT idf = 1 ; idf <= cFlavorsAssign ; idf ++ )
                            {
                                psttzLeverAssign = (strokeS*)swsAssign.leverF( tinP , idf ) ;

                                stackC stForth( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , sizeof( timeS ) ) ;
                                if( swsAssign )
                                {
                                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    do
                                    {
                                        strokeS* psttTerm = (strokeS*)swsAssign.downF( tinP , hWalk ) ;

                                        if( !strCompareF( tinP , psttTerm , tAssign ) )
                                        {
                                        }
                                        else if( !strCompareF( tinP , psttTerm , tPlus ) )
                                        {
                                            timeS& t1 = *(timeS*)&stForth[ 1 ] ;
                                            timeS& t2 = *(timeS*)&stForth[ 2 ] ;
                                            osTimeAddF( tinP , t2.time1 , t2.time2 , t1.time1 , t1.time2 ) ;

                                            timeS td ;
                                            byteT* pbd = (byteT*)&td ;
                                            stForth >> pbd ;
                                        }
                                        else
                                        {
                                            psttzLeverMath = psttTerm ;
                                            timeS& timeTerm = *(timeS*)&(countT&)swMathValues ;
                                            stForth << (byteT*)&timeTerm ;
                                        }
                                    }
                                    while( ~hWalk ) ;
                                }

                                timeS timeResult ;
                                if( stForth )
                                {
                                    byteT* pbd = (byteT*)&timeResult ;
                                    stForth >> pbd ;
                                }

                                countT t1 = RC( timeResult.time1 , 0x18 ) ;
                                countT t2 = timeResult.time2 ;
                                if( t1 >= TUCK )
                                {
                                    t1 -= TUCK ;
                                    t2 ++ ;
                                }

                                TN( tSay2 , "" ) ; tSay2 = T(idf==1?"\r\n":"")+T("            {c" ":    ")+TF3(t1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF3(t2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TP(psttzLeverAssign,0x30)+T(" }\r\n") ;
                                strFuseF( tinP , soulReport1 , tSay2 ) ;
                            }

                            countT t1 = RC( total1 , 0x18 ) ;
                            countT t2 = total2;
                            if( t1 >= TUCK )
                            {
                                t1 -= TUCK ;
                                t2 ++ ;
                            }
                            TN( tTotal , "\r\n            {total: " ) ; tTotal += TF3(t1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF2(t2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" }\r\n        }\r\n") ; //CS:CODEsYNC 330021C0 330021C0 330021C0
                            strFuseF( tinP , soulReport1 , tTotal ) ;
                        }
                        strFuseF( tinP , soulReport1 , T("    }\r\n}\r\n") ) ;

                        if( pSwSwTimeCard )
                        {
                            countT cFlavors = pSwSwTimeCard->cFlavorsF( tinP ) ;
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            {
                                offStrong = pSwSwTimeCard->leverF( tinP , idf ) ;
                                switchC*& pSwTimeCard = *(switchC**)&(countT&)*pSwSwTimeCard ;
                                __Z( pSwTimeCard ) ;
                                DEL( pSwTimeCard ) ;
                            }
                        }
                        DEL( pSwSwTimeCard ) ;
                        DEL( pSwTimeMax ) ;

                        soulOutP << (strokeS*)T("Time.by.Strong.by.Activity") ;

                        soulOutP << soulReport1 ;
                    }

#if defined( NEVERdEFINED )
                    traceF( tinP , T("etherSoilF / generating report / 4") ) ;
                    {
                        TN( tHead ,

                            "\r\n"
                            "{report:\r\n"
                            "\r\n"
                            "    {name:     Spending by Category                               }\r\n"
                            "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
                            "    {source:   ideafarm.com                                       }\r\n"
                            "    {time:     "
                        ) ;

                        {
                            ZE( countT  , timeN1 ) ;
                            ZE( sCountT , timeN2 ) ;
                            osTimeNowF( tinP , timeN1 , timeN2 ) ;

                            tHead +=

                                 TT4(timeN1,timeN2,4,8)  +T("                                        }\r\n    {lathtime: ")
                                +TT4(grandMax1,grandMax2,4,8)+T("                                        }\r\n\r\n    {body:\r\n")

                            ;
                        }

                        TN( tTail ,

                            "    }\r\n"
                            "\r\n"
                            "    {notes:\r\n"
                            "\r\n"
                            "        {n: Each value is the number of whole dollars spent on the category.  Cents are used in calculating totals but are truncated (not rounded) away when each value is reported. }\r\n"
                            "    }\r\n"
                            "}\r\n"

                        ) ;

                        soulC soulReport2( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report2" ) ;
                        strFuseF( tinP , soulReport2 , tHead ) ;
                        ZE( countT  , idsLath ) ;
                        ZE( countT  , total   ) ;
                        while( stSortedBuy )
                        {
                            countT pc3[] = { 0 , 0 , 0 } ;
                            byteT* pbi = (byteT*)pc3 ;
                            stSortedBuy >> pbi ;

                            if( idsLath != pc3[ 0 ] )
                            {
                                if( idsLath )
                                {
                                    TN( tTotal , "\r\n            {total: " ) ; tTotal += TF3(total/100,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("}\r\n        }\r\n") ; //CS:CODEsYNC 330021C0 330021C0 330021C0
                                    strFuseF( tinP , soulReport2 , tTotal ) ;
                                }

                                idsLath = pc3[ 0 ] ;

                                TN( tSubHead , "\r\n        {strong: " ) ; tSubHead += TF2(pc3[0],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n\r\n") ; //CS:CODEsYNC 330021C0 330021C0 330021C0
                                strFuseF( tinP , soulReport2 , tSubHead ) ;

                                total = 0 ;
                            }

                            strokeS* pstta = (strokeS*)pc3[ 2 ] ;
                            strFuseF( tinP , soulReport2 , T("            {c" ":    ")+TF3(pc3[1]/100,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TP(pstta,0x30) ) ;
                            strFuseF( tinP , soulReport2 , T(" }\r\n") ) ;

                            total += pc3[ 1 ] ;

                            idsLath = pc3[ 0 ] ;
                        }

                        if( idsLath )
                        {
                            TN( tTotal , "\r\n            {total: " ) ; tTotal += TF3(total/100,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("}\r\n        }\r\n") ;
                            strFuseF( tinP , soulReport2 , tTotal ) ;
                        }
                        strFuseF( tinP , soulReport2 , tTail ) ;

                        if( pSwSwBuy )
                        {
                            countT cFlavors = pSwSwBuy->cFlavorsF( tinP ) ;
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            {
                                offStrong = pSwSwBuy->leverF( tinP , idf ) ;
                                switchC*& pSwBuy = *(switchC**)&(countT&)*pSwSwBuy ;
                                __Z( pSwBuy ) ;
                                DEL( pSwBuy ) ;
                            }
                        }
                        DEL( pSwSwBuy ) ;

                        soulOutP << (strokeS*)T("Spending.by.Category") ;

                        soulOutP << soulReport2 ;
                    }

                    traceF( tinP , T("etherSoilF / generating report / 3") ) ;
                    {
                        TN( tHeadFull ,

                            "\r\n"
                            "{report:\r\n"
                            "\r\n"
                            "    {name:     Things To Do                                       }\r\n"
                            "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
                            "    {source:   ideafarm.com                                       }\r\n"
                            "    {time:     "
                        ) ;

                        TN( tHeadAbridged ,

                            "\r\n"
                            "{report:\r\n"
                            "\r\n"
                            "    {name:     Things To Do (Abridged)                            }\r\n"
                            "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
                            "    {source:   ideafarm.com                                       }\r\n"
                            "\r\n"
                            "    {calendar: "
                            "\r\n"
                        ) ;

                        {
                            ZE( countT  , timeN1 ) ;
                            ZE( sCountT , timeN2 ) ;
                            osTimeNowF( tinP , timeN1 , timeN2 ) ;

                            ZE( strokeS* , psttc ) ;
                            strCalendarF( tinP , psttc , timeN2 ) ; ___( psttc ) ;

                            tHeadFull +=

                                 TT4(timeN1,timeN2,4,8)  +T("                                        }\r\n    {lathtime: ")
                                +TT4(grandMax1,grandMax2,4,8)+T("                                        }\r\n\r\n    {body:\r\n\r\n")

                            ;

                            tHeadAbridged +=

                                T("\r\n")
                                +T(psttc)+T("\r\n")
                                +T("\r\n")
                                +T("    }\r\n")
                                +T("\r\n")
                                +T("    {time:     ")
                                +TT4(timeN1,timeN2,4,8)  +T("                         }\r\n    {lathtime: ")
                                +TT4(grandMax1,grandMax2,4,8)+T("                         }\r\n\r\n    {body:\r\n\r\n")

                            ;
                            delF( tinP , psttc ) ;
                        }

                        TN( tTail , "    }\r\n}\r\n" ) ;
                        TN( tPrefix , "        {a: " ) ;
                        TN( tSuffix , " }\r\n" ) ;

                        TN( tNix1 , "administrative: law:" ) ;
                        TN( tNix2 , "craftwork: software:" ) ;
                        TN( tNix3 , "craftwork: text:" ) ;
                        TN( tNix4 , "legal point:" ) ;
                        TN( tNix5 , "online:" ) ;
                        TN( tNix6 , "sign idea:" ) ;
                        TN( tNix7 , "kt:" ) ;
                        countT cDo = pStDo ? *pStDo : 0 ;
                        ZE( countT , cDoAbridged ) ;
                        if( pStDo && *pStDo )
                        {
                            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            do
                            {
                                strokeS* psttDo = (strokeS*)pStDo->downF( tinP , hWalk ) ;
                                if
                                (
                                    1 != strIdF( tinP , tNix1 , psttDo ) //CS: 330021C0 330021C0: DUPLICATE CODE
                                    &&
                                    1 != strIdF( tinP , tNix2 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix3 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix4 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix5 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix6 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix7 , psttDo )
                                )
                                cDoAbridged ++ ;
                            }
                            while( ~hWalk ) ;
                        }

                        soulC soulReport3( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report3" ) ;
                        soulC soulReport4( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report4" ) ;
                        strFuseF( tinP , soulReport3 , tHeadFull ) ;
                        strFuseF( tinP , soulReport4 , tHeadAbridged ) ;
                        if( pStDo )
                        {
                            while( *pStDo )
                            {
                                ZE( strokeS* , psttDo ) ;
                                *pStDo >> psttDo ;

                                strFuseF( tinP , soulReport3 , tPrefix ) ;
                                strFuseF( tinP , soulReport3 , psttDo ) ;
                                strFuseF( tinP , soulReport3 , tSuffix ) ;

                                if
                                (
                                    1 != strIdF( tinP , tNix1 , psttDo ) //CS: 330021C0 330021C0: DUPLICATE CODE
                                    &&
                                    1 != strIdF( tinP , tNix2 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix3 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix4 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix5 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix6 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix7 , psttDo )
                                )
                                {
                                    ZE( strokeS* , psttDoShort ) ;

                                    countT idf = 1 ;
                                    countT idl = psttDo->idAdam < CSTTdOsHORT ? psttDo->idAdam : CSTTdOsHORT ;
                                    strSubstringF( tinP , psttDoShort , idf , idl , psttDo ) ; ___( psttDoShort ) ;

                                    strFuseF( tinP , soulReport4 , tPrefix ) ;
                                    strFuseF( tinP , soulReport4 , TP( psttDoShort , CSTTdOsHORT ) ) ;
                                    strFuseF( tinP , soulReport4 , tSuffix ) ;

                                    delF( tinP , psttDoShort ) ;
                                }

                                delF( tinP , psttDo ) ;
                            }
                        }
                        DEL( pStDo ) ;
                        strFuseF( tinP , soulReport3 , tTail ) ;
                        strFuseF( tinP , soulReport4 , tTail ) ;

                        soulOutP << (strokeS*)T("Things.To.Do.Full") ;
                        soulOutP << soulReport3 ;

                        soulOutP << (strokeS*)T("Things.To.Do.Abridged") ;
                        soulOutP << soulReport4 ;
                    }

                    traceF( tinP , T("etherSoilF / generating report / 2") ) ;
                    {
                        TN( tHead ,

                            "\r\n"
                            "{report:\r\n"
                            "\r\n"
                            "    {name:     Log                                                }\r\n"
                            "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
                            "    {source:   ideafarm.com                                       }\r\n"
                            "    {time:     "
                        ) ;

                        {
                            ZE( countT  , timeN1 ) ;
                            ZE( sCountT , timeN2 ) ;
                            osTimeNowF( tinP , timeN1 , timeN2 ) ;

                            tHead +=

                                 TT4(timeN1,timeN2,4,8)  +T("                                        }\r\n    {lathtime: ")
                                +TT4(grandMax1,grandMax2,4,8)+T("                                        }\r\n\r\n    {body:\r\n\r\n")

                            ;
                        }

                        TN( tTail , "    }\r\n}\r\n" ) ;
                        TN( tPrefix , "        {t: " ) ;
                        TN( tSuffix , " }\r\n" ) ;
                        countT cLog = pStLog ? *pStLog : 0 ;

                        soulC soulReport5( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report5" ) ;
                        strFuseF( tinP , soulReport5 , tHead ) ;
                        if( pStLog ) while( *pStLog )
                        {
                            ZE( strokeS* , psttLog ) ;
                            *pStLog >> psttLog ;
                            strFuseF( tinP , soulReport5 , tPrefix ) ;
                            strFuseF( tinP , soulReport5 , psttLog ) ;
                            strFuseF( tinP , soulReport5 , tSuffix ) ;
                            delF( tinP , psttLog ) ;
                        }
                        DEL( pStLog ) ;
                        strFuseF( tinP , soulReport5 , tTail ) ;

                        soulOutP << (strokeS*)T("Log") ;
                        soulOutP << soulReport5 ;
                    }

                    traceF( tinP , T("etherSoilF / generating report / 1") ) ;
                    {
                        TN( tHead ,

                            "\r\n"
                            "{report:\r\n"
                            "\r\n"
                            "    {name:     Journal                                            }\r\n"
                            "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
                            "    {source:   ideafarm.com                                       }\r\n"
                            "    {time:     "
                        ) ;

                        {
                            ZE( countT  , timeN1 ) ;
                            ZE( sCountT , timeN2 ) ;
                            osTimeNowF( tinP , timeN1 , timeN2 ) ;

                            tHead +=

                                 TT4(timeN1,timeN2,4,8)  +T("                                        }\r\n    {lathtime: ")
                                +TT4(grandMax1,grandMax2,4,8)+T("                                        }\r\n\r\n    {body:\r\n\r\n")

                            ;
                        }

                        TN( tTail , "    }\r\n}\r\n" ) ;
                        TN( tPrefix , "        {t: " ) ;
                        TN( tSuffix , " }\r\n" ) ;
                        countT cJournal = pStJournal ? *pStJournal : 0 ;

                        soulC soulReport6( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report6" ) ;
                        strFuseF( tinP , soulReport6 , tHead ) ;
                        if( pStJournal ) while( *pStJournal )
                        {
                            ZE( strokeS* , psttJournal ) ;
                            *pStJournal >> psttJournal ;
                            strFuseF( tinP , soulReport6 , tPrefix ) ;
                            strFuseF( tinP , soulReport6 , psttJournal ) ;
                            strFuseF( tinP , soulReport6 , tSuffix ) ;
                            delF( tinP , psttJournal ) ;
                        }
                         DEL( pStJournal ) ;
                        strFuseF( tinP , soulReport6 , tTail ) ;

                        soulOutP << (strokeS*)T("Journal") ;
                        soulOutP << soulReport6 ;
                    }
#endif

                    __NZ( soulOut ) ;
                    traceF( tinP , T("etherSoilF / generating report / 0") ) ;
                }
                else
                {
                    if( scNest )
                    {
                        cFlag1 ++ ;

                        ZE( boolT , bNeg ) ;
                        if( scNest < 0 )
                        {
                            bNeg = 1 ;
                            scNest = - scNest ;
                        }

                        switch( idModeP )
                        {
                            case ifcIDmODEeTHERsOIL_LINT :
                            {
                                TN( t1  , "" ) ; t1 = T(scNest==1?"[there is ":"[there are ")+TF2(scNest,flFORMAT_NObIGITvALUES) ;
                                TN( tco , bNeg ? "close" : "open" ) ;
                                TN( tsp , scNest == 1 ? " curly bracket]" : " curly brackets]" ) ;
                                TN( t2 , "" ) ; t2 = T(" unmatched ")+tco+tsp ;

                                TN( tAll , "" ) ; tAll = T("\r\n\r\n")+tFlag1+t1+t2 ;

                                strFuseF( tinP , soulOut , tAll ) ;

                                break ;
                            }
                            case ifcIDmODEeTHERsOIL_TRIM :
                            {
                                soulOut.removeAllF( tinP ) ;

                                break ;
                            }
                        }
                    }

                    if( idModeP == ifcIDmODEeTHERsOIL_LINT )
                    {
                        if( cFlag1 )
                        {
                            TN( t1  , "\r\n\r\n" ) ; t1 += tFlag1+T("[")+TF2(cFlag1,flFORMAT_NObIGITvALUES) ;
                            TN( tsp , cFlag1 == 1 ? " error was" : " errors were" ) ;
                            TN( t2 , cFlag1 <= CfLAG1mAX ? " detected]\r\n" : " detected (only the woth " ) ;
                            TN( t3 , "" ) ; t3 = TF2((countT)CfLAG1mAX,flFORMAT_NObIGITvALUES) ;
                            TN( t4 , " were flagged]\r\n" ) ;

                            TN( tAll , "" ) ; tAll = cFlag1 <= CfLAG1mAX
                                ? t1+tsp+t2
                                : t1+tsp+t2+t3+t4
                            ;

                            strFuseF( tinP , soulOut , tAll ) ;
                        }

                        if( cFlag1 )
                        {
                            /**/if( bTrace ) traceF( tinP , T("etherSoilF / replacing tm001 with tFlag2") ) ;
                            strReplaceF( tinP , soulOut , tm001 , tFlag2 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ;
                            /**/if( bTrace ) traceF( tinP , T("etherSoilF / replacing tm101 with tFlag3") ) ;
                            strReplaceF( tinP , soulOut , tm101 , tFlag3 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ;
                        }
                        else
                        {
                            TN( tn , "" ) ;
                            /**/if( bTrace ) traceF( tinP , T("etherSoilF / replacing tm001 with null") ) ;
                            strReplaceF( tinP , soulOut , tm001 , tn , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ;
                            /**/if( bTrace ) traceF( tinP , T("etherSoilF / replacing tm101 with null") ) ;
                            strReplaceF( tinP , soulOut , tm101 , tn , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ;
                        }
                    }

                    /**/if( bTrace ) traceF( tinP , T("etherSoilF / fusing soulOut to soulOutP") ) ;
                    strPourF( tinP , soulOutP , soulOut , flSTRpOURf_CONSUMEiNPUT ) ;
                    /**/if( bTrace ) traceF( tinP , T("etherSoilF / purging soulOut") ) ;
                    soulOut.removeAllF( tinP ) ;
                }
            }

            /**/if( bTrace ) traceF( tinP , T("etherSoilF / cleaning up") ) ;

            countT cFlavors = swReplace.cFlavorsF( tinP ) ;
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            {
                psttzLeverReplace = (strokeS*)swReplace.leverF( tinP , idf ) ;
                strokeS*& psttAfter = *(strokeS**)&(countT&)swReplace ;
                //strokeF( tinP , T("\"")+T(psttzLeverReplace)+T("\" -> \"")+T(psttAfter)+T("\"\r\n") ) ;
                delF( tinP , psttAfter ) ;
            }
        }
    }

    countT rc = idModeP == ifcIDmODEeTHERsOIL_REPORT
        ? bRepeat
        : cFlag1
    ;

    //switch( idModeP )
    //{
    //    case ifcIDmODEeTHERsOIL_PREPAREsOURCE                    : { LOGrAW( "etherSoilF / PREPAREsOURCE   /-\r\n" ) ; strokeF( tinP , T("etherSoilF / PREPAREsOURCE   /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_NATIVEfROMaSCII                  : { LOGrAW( "etherSoilF / NATIVEfROMaSCII /-\r\n" ) ; strokeF( tinP , T("etherSoilF / NATIVEfROMaSCII /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE                  : { LOGrAW( "etherSoilF / ASCIIfROMnATIVE /-\r\n" ) ; strokeF( tinP , T("etherSoilF / ASCIIfROMnATIVE /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_LINT                             : { LOGrAW( "etherSoilF / LINT            /-\r\n" ) ; strokeF( tinP , T("etherSoilF / LINT            /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_TRIM                             : { LOGrAW( "etherSoilF / TRIM            /-\r\n" ) ; strokeF( tinP , T("etherSoilF / TRIM            /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_REPORT                           : { LOGrAW( "etherSoilF / REPORT          /-\r\n" ) ; strokeF( tinP , T("etherSoilF / REPORT          /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_QUERYvALUES                      : { LOGrAW( "etherSoilF / QUERYvALUES     /-\r\n" ) ; strokeF( tinP , T("etherSoilF / QUERYvALUES     /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_DO                               : { LOGrAW( "etherSoilF / DO              /-\r\n" ) ; strokeF( tinP , T("etherSoilF / DO              /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_DOdEBUG                          : { LOGrAW( "etherSoilF / DOdEBUG         /-\r\n" ) ; strokeF( tinP , T("etherSoilF / DOdEBUG         /-\r\n") ) ; break ; }
    //    default                                                  : { LOGrAW( "etherSoilF / ?               /-\r\n" ) ; strokeF( tinP , T("etherSoilF / ?               /-\r\n") ) ; break ; }
    //}

    return rc ;
}

#undef CfLAG1mAX
#undef CfLAG23mAX
#undef CSTTdOsHORT


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c1.etherc.ethersoilf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c2.etherc.strindentf BEGIN
#define DDNAME       "3func.360021c2.etherc.strindentf"
#define DDNUMB      (countT)0x360021c2
#define IDFILE      (countT)0xdc9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/voidT etherC::strIndentF( tinS& tinP , strokeS*& psttP , const strokeS* psttOldP , const countT csttP )/*1*/
{
    SCOOP

    IFbEcAREFUL
    {
        if( POOP ) return ;
        __( !psttP == !psttOldP ) ;
        if( POOP ) return ;
    }

    _IO_

    boolT bDeleteOld = !psttOldP ;
    if( bDeleteOld )
    {
        psttOldP = psttP ;
                   psttP = 0 ;
    }

    ZE( strokeS* , pstt1Lines ) ;
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    TN( tb , " " ) ;
    TN( tcr , "\r\n" ) ;
    strWordsF( tinP , pstt1Lines , psttOldP , sttq , tcr , flSTRwORDS_DELIMITERS ) ; ___( pstt1Lines ) ;
    if( bDeleteOld ) delF( tinP , *(strokeS**)&psttOldP ) ;

    ZE( countT , idMin ) ;
    ZE( countT , cDelimitersNeeded ) ;
    ZE( countT , csttText ) ;
    ZE( countT , cNonblankLines ) ;
    TN( tIndent , "" ) ; tIndent = TP("",csttP) ;
    for( countT offPass = 0 ; offPass <= 2 ; offPass ++ ) // 0: CALD idMin ; 1: CALC SPACE NEEDED ; 2: ALLOCATE AND BUILD THE OUTPUT
    {
        boolT bWoth = 1 ;
        FORsTRINGSiN1( pstt1Lines )
        {
            if( bWoth )
            {
                bWoth = 0 ;
                switch( offPass )
                {
                    case 2 :
                    {
                        strMakeF( tinP , LF , psttP , 0 , cNonblankLines * csttP + csttText + cDelimitersNeeded * tcr.csF( tinP ) ) ; //CALLER MUST TAG
                        break ;
                    }
                }
            }

            countT idf = 1 ;
            if( strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , tcr , psttc1 ) )                                                 // IF THE LINE IS DELIMITERS
            {
                switch( offPass )
                {
                    case 1 : { cDelimitersNeeded ++ ; break ; }
                    case 2 : { strFuseF( tinP , psttP , tcr ) ; break ; }
                }
            }
            else
            {
                idf = 1 ;
                countT idWoth = strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , tb , psttc1 , 0 , 1 , flSTRiDaNY_NOT ) ;
                if( idWoth )                                                                                    // IF THE LINE CONTAINS NONBLANK TEXT
                {
                    switch( offPass )
                    {
                        case 0 : { if( !idMin || idMin > idWoth ) idMin = idWoth              ; break ; }
                        case 1 : { cNonblankLines ++ ; csttText += psttc1->idAdam - idMin + 1 ; break ; }
                        case 2 :
                        {
                            ZE( strokeS* , psttw ) ;
                            countT idf = idMin ;
                            ZE( countT , idl ) ;
                            strSubstringF( tinP , psttw , idf , idl , psttc1 ) ; ___( psttw ) ;
                            strFuseF( tinP , psttP , tIndent ) ;
                            strFuseF( tinP , psttP , psttw ) ;
                            delF( tinP , psttw ) ;
                            
                            break ;
                        }
                    }
                }

            }
        }
    }
    delF( tinP , pstt1Lines ) ;

    if( !psttP ) // THIS WILL HAPPEN IF psttP IS NULL LENGTH
    {
        strMakeF( tinP , LF , psttP , T("") ) ; //CALLER MUST TAG
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c2.etherc.strindentf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c3.etherc.strfuseseparatef BEGIN
#define DDNAME       "3func.360021c3.etherc.strfuseseparatef"
#define DDNUMB      (countT)0x360021c3
#define IDFILE      (countT)0xdca


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/ voidT etherC::strFuseSeparateF( tinS& tinP , soulC& soulP , const strokeS* const psttInP , countT csttPrefixNullsP , countT csttSuffixNullsP , grabC* pGrabP , const countT csttExtraP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttInP ) ;_WQ
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , psttOut ) ;_WQ
    strFuseSeparateF( tinP , psttOut , psttInP , csttPrefixNullsP , csttSuffixNullsP , &soulP , pGrabP , csttExtraP ) ; ___( psttOut ) ;_WQ

    if( psttOut )
    {
        if( pGrabP ) pGrabP->grabF( tinP , TAG( TAGiDnULL ) ) ;_WQ
        soulP << psttOut ;_WQ
        if( pGrabP ) pGrabP->ungrabF( tinP ) ;_WQ
        delF( tinP , psttOut ) ;_WQ
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c3.etherc.strfuseseparatef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c4.etherc.strfusef BEGIN
#define DDNAME       "3func.360021c4.etherc.strfusef"
#define DDNUMB      (countT)0x360021c4
#define IDFILE      (countT)0xdcb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//U:: 20140201@0845: LATH OO PARAMETERS NOT REFERENCED

/*1*/ voidT etherC::strFuseF( tinS& tinP , soulC& soulP , const strokeS* const psttInP , grabC* pGrabP , const strokeS sttEscapeP , const strokeS* psttDelimiterPairsP , const countT csttMaxDelimiterP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttInP ) ;_WQ
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , psttOut ) ;_WQ
    strFuseF( tinP , psttOut , psttInP , &soulP , pGrabP , sttEscapeP ) ; ___( psttOut ) ;_WQ

    if( psttOut )
    {
        if( pGrabP ) pGrabP->grabF( tinP , TAG( TAGiDnULL ) ) ;_WQ
        soulP << psttOut ;_WQ
        if( pGrabP ) pGrabP->ungrabF( tinP ) ;_WQ
        delF( tinP , psttOut ) ;_WQ
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c4.etherc.strfusef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c5.etherc.strpourf BEGIN
#define DDNAME       "3func.360021c5.etherc.strpourf"
#define DDNUMB      (countT)0x360021c5
#define IDFILE      (countT)0xdcc


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
arguments
 tinP
 soulToP
 soulFromP
 flagsP
*/
/**/

//U::THIS IS OBSOLETED BY soulC::strDrinkF
//U::MIGRATE CODE THAT CALLS ME AND THEN DELETE ME

/*1*/voidT etherC::strPourF( tinS& tinP , soulC& soulToP , soulC& soulFromP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        FV( flSTRpOURf , flagsP ) ;
        if( POOP ) return ;
    }

    _IO_

    if( F(flagsP) & flSTRpOURf_CONSUMEiNPUT )
    {
        if( F(flagsP) & flSTRpOURf_REVERSE )
        {
            while( soulFromP )
            {
                ZE( strokeS* , psttw ) ;
                soulFromP >> psttw ; ___( psttw ) ;

                strReverseF( tinP , psttw ) ; ___( psttw ) ;

                soulToP << psttw ;
                delF( tinP , psttw ) ;
            }
        }
        else
        {
            while( soulFromP )
            {
                ZE( byteT* , pbEncoded ) ;
                ZE( countT , cbEncoded ) ;
                soulFromP.shiftRightF( tinP , pbEncoded , cbEncoded , ifcIDtYPEsOULiTEM_strokeSptr ) ; ___( pbEncoded ) ;
                countT cbv = !pbEncoded ? 0 : 2 * sizeof( countT ) + ((countT*)pbEncoded)[ 1 ] ;
                __( cbv - cbEncoded ) ;

                if( !POOP ) soulToP.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_strokeSptr , pbEncoded , cbv ) ;
                delF( tinP , pbEncoded ) ;
            }
        }
    }
    else
    {
        if( F(flagsP) & flSTRpOURf_REVERSE )
        {
            countT cFieldsIn = soulFromP ;
            for( countT idFieldIn = 1 ; idFieldIn <= cFieldsIn ; idFieldIn ++ )
            {
                ZE( countT , idTypeIn ) ;
                ZE( flagsT , flagsIn  ) ;
                ZE( countT , cbIn     ) ;
                byteT* pbzEncoded = soulFromP.pbFieldF( tinP , idTypeIn , flagsIn , cbIn , idFieldIn ) ;
                __( idTypeIn - ifcIDtYPEsOULiTEM_strokeSptr ) ;
                __( flagsIn - flSOULiTEM_null ) ;
                __( !cbIn ) ;

                if( !pbzEncoded || !cbIn ) soulToP.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_strokeSptr , pbzEncoded , !pbzEncoded ? 0 : 2 * sizeof( countT ) + ((countT*)pbzEncoded)[ 1 ] ) ;
                else
                {
                    ZE( strokeS* , psttw ) ;
                    strDecodeF( tinP , psttw , pbzEncoded ) ; ___( psttw ) ;

                    if( psttw ) { strReverseF( tinP , psttw ) ; ___( psttw ) ; }

                    ZE( byteT* , pbEncoded ) ;
                    if( psttw )
                    {
                        strEncodeF( tinP , pbEncoded , psttw ) ; ___( pbEncoded ) ;
                        delF( tinP , psttw ) ;
                    }
                    soulToP.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_strokeSptr , pbEncoded , !pbEncoded ? 0 : 2 * sizeof( countT ) + ((countT*)pbEncoded)[ 1 ] ) ;
                    delF( tinP , pbEncoded ) ;
                }
            }
        }
        else
        {
            countT cFieldsIn = soulFromP ;
            for( countT idFieldIn = 1 ; idFieldIn <= cFieldsIn ; idFieldIn ++ )
            {
                ZE( countT , idTypeIn ) ;
                ZE( flagsT , flagsIn  ) ;
                ZE( countT , cbIn     ) ;
                byteT* pbzEncoded = soulFromP.pbFieldF( tinP , idTypeIn , flagsIn , cbIn , idFieldIn ) ;
                __( idTypeIn - ifcIDtYPEsOULiTEM_strokeSptr ) ;
                __( flagsIn - flSOULiTEM_null ) ;
                __( !cbIn ) ;

                if( !POOP ) soulToP.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_strokeSptr , pbzEncoded , !pbzEncoded ? 0 : 2 * sizeof( countT ) + ((countT*)pbzEncoded)[ 1 ] ) ;
            }
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c5.etherc.strpourf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c6.etherc.strwordsf BEGIN
#define DDNAME       "3func.360021c6.etherc.strwordsf"
#define DDNUMB      (countT)0x360021c6
#define IDFILE      (countT)0xdcd


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
see my other overload
*/
/**/

#define PSTT1(aNameP,ost1P)                                                             \
                                                                                        \
    strokeS aNameP[ CSpREFIX + 1 ] ;                                                    \
    SETpREFIX( aNameP , 1 , 0 ) ;                                                       \
    aNameP[ CSpREFIX ] = ost1P ;                                                        \

#define PSTT2(aNameP,ost1P,ost2P)                                                       \
                                                                                        \
    strokeS aNameP[ CSpREFIX + 2 ] ;                                                    \
    SETpREFIX( aNameP , 2 , 0 ) ;                                                       \
    aNameP[ CSpREFIX ] = ost1P ;                                                        \
    aNameP[ CSpREFIX + 1 ] = ost2P ;

voidT emitConcatenationF( tinS& tinP , etherC& ether , soulC& soulOutP , staqC& stqLazyP )
{
    countT cLazy = stqLazyP ;

    ZE( countT , csttl ) ;
    for( countT idLazy = cLazy ; idLazy ; idLazy -- ) csttl += ( (strokeS*)stqLazyP[ idLazy ] )->idAdam ;

    ZE( strokeS* , psttLazies ) ;
    ether.strMakeF( tinP , LF , psttLazies , 0 , csttl ) ; ___( psttLazies ) ;
    for( countT idLazy = cLazy ; idLazy ; idLazy -- )
    {
        strokeS*& psttl = *(strokeS**)&stqLazyP[ idLazy ] ;
        //CONoUTrAW( T("concatenation piece: \"")+T(psttl)+T("\"\r\n") ) ;
        ether.strFuseF( tinP , psttLazies , psttl ) ;
        ether.delF( tinP , psttl ) ;
    }
    stqLazyP.purgeF( tinP ) ;
    //CONoUTrAW( T("emit concatenation: \"")+T(psttLazies)+T("\"\r\n") ) ;
    soulOutP << psttLazies ;
    //CONoUTrAW( T("1 emitted \"")+T(psttLazies)+T("\"\r\n") ) ;
    ether.delF( tinP , psttLazies ) ;
}

voidT emitLaziesF( tinS& tinP , etherC& ether , soulC& soulOutP , staqC& stqLazyP , const flagsT flagsP , textC& tBreakP )
{
    countT cLazy = stqLazyP ;

    if( cLazy )
    {
        if( F(flagsP) & flSTRwORDS_DOnOTcONCATENATEwORDpIECES )
        {
            for( countT idLazy = cLazy ; idLazy ; idLazy -- )
            {
                strokeS*& psttl = *(strokeS**)&stqLazyP[ idLazy ] ;
                //CONoUTrAW( T("emit without concatenating:  \"")+T(psttl)+T("\"\r\n") ) ;
                soulOutP << psttl ;
                //CONoUTrAW( T("2 emitted \"")+T(psttl)+T("\"\r\n") ) ;
                ether.delF( tinP , psttl ) ;
            }
            stqLazyP.purgeF( tinP ) ;
        }
        else if( !( F(flagsP) & flSTRwORDS_SPLITaTmARK ) ) emitConcatenationF( tinP , ether , soulOutP , stqLazyP ) ;
        else  // CONCATENATE BUT SPLIT AT BREAKS (I DO THIS BY CALLING MYSELF RECURSIVELY, SPECIFYING tBreakP AS THE DELIMITER STRING)
        {
            ZE( boolT , bBroken ) ;
            for( countT idLazy = cLazy ; idLazy ; idLazy -- )
            {
                strokeS*& psttl = *(strokeS**)&stqLazyP[ idLazy ] ;
                if( !bBroken && ether.strIdF( tinP , tBreakP , psttl ) )
                {
                    bBroken = 1 ;
                    //CONoUTrAW( T("is broken: \"")+T(psttl)+T("\"\r\n") ) ;
                    break ;
                }
            }
        
            if( !bBroken ) emitConcatenationF( tinP , ether , soulOutP , stqLazyP ) ;
            else
            {
                soulC soulLazy( tinP , TAG( TAGiDnULL ) , flSOUL_null , F(flagsP) & flSTRwORDS_USEjOT ? "soul.lazy" : (osTextT*)0 ) ;

                for( countT idLazy = cLazy ; idLazy ; idLazy -- )
                {
                    strokeS*& psttl = *(strokeS**)&stqLazyP[ idLazy ] ;
                    soulLazy << psttl ;
                    ether.delF( tinP , psttl ) ;
                }
                stqLazyP.purgeF( tinP ) ;        

                flagsT flagsNest = F(flagsP) & flSTRwORDS_DELIMITERS

                    ? flSTRwORDS_CONSUMEiNPUT | flSTRwORDS_DELIMITERS
                    : flSTRwORDS_CONSUMEiNPUT
                ;

                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ether.strWordsF( tinP , soulOutP , soulLazy , sttq , tBreakP , flagsNest ) ;
            }
        }
    }
}

/*1*/countT etherC::strWordsF( tinS& tinP , soulC& soulOutP , soulC& soulInP , strokeS& sttQuoteP , const strokeS* psttDelimitersP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        //__NZ( soulOutP ) ;
        FV( flSTRwORDS , flagsP )
        __Z( soulInP ) ;
        if( POOP ) return 0 ;
    }

    static countT offNestLevel ; //U::THIS IS ONLY USED TO CONTROL traceF ; IF MULTIPLE THREADS CALL ME, ONLY WO THREAD WILL RECEIVE TRACING
    countT offNest = incv02AM( offNestLevel ) ;

    _IO_

    tinP.cPoolDropDt = tinP.cPoolDropCt = 0 ; //U::TO FIND A BUG

    //
    // I PUSH ENTIRE WORDS INTO soulOutP.
    // INPUT soulInP IS TREATED AS A STREAM, WHICH MEANS THAT AN ENTIRE WORD OR AN ENTIRE DELIMITER MIGHT BE BROKEN INTO PIECES WITHIN soulInP.
    // TO HANDLE THIS, ALL INPUT IS BUFFERED INTO stqLazy AND ALL OUTPUT IS OBTAINED FROM stqLazy.
    // 
    // OPTIONALLY, I WILL EMIT EACH ENTIRE WORD IN ITS ORIGINAL PIECES RATHER THAN CONCATENATE THEM FOR A SINGLE EMISSION
    // (THIS MUST BE DONE IF AN ENTIRE WORD MIGHT BE HUGE ENOUGH TO EXHAUST THE POOL)
    //

    boolT bDelimiters = !!( F(flagsP) & flSTRwORDS_DELIMITERS ) ;
    const strokeS sttqSave = sttQuoteP ;
    TN( tWhite , TbLACK ) ;
    const strokeS* psttDelimiters = psttDelimitersP ? psttDelimitersP : (strokeS*)tWhite ;
    strokeS sttBreak( sa_MARKsYSTEMbREAK , sc_MARKsYSTEM ) ;
    TN( tBreak , "" ) ; tBreak = tBreak+sttBreak ;

    PSTT1( pstt_q  , '\"' ) ;
    PSTT2( pstt_sq , '\\' , '\"' ) ;

    ZE( countT , cWords ) ;
    countT cFieldsIn = soulInP ;
    staqC stqLazy( tinP ) ;
    ZE( boolT    , bLazyIsDelim ) ;
    for( countT idFieldIn = 1 ; idFieldIn <= cFieldsIn ; idFieldIn ++ )
    {
        //CONoUTrAW9( "[idFieldIn,cPoolDropDt,cPoolDropCt,stqLazy]: " , idFieldIn , "    " , tinP.cPoolDropCt , "    " , tinP.cPoolDropDt , "    " , stqLazy , "\r\n" ) ;
        {
            countT cRemain = cFieldsIn - idFieldIn ;
            if( !offNest && !( cRemain % TUCK ) ) traceF( tinP , T("strWordsF / words remaining [cRemain]: ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
        }

        ZE( strokeS* , psttp ) ;
        if( F(flagsP) & flSTRwORDS_CONSUMEiNPUT ) { soulInP >> psttp ; ___( psttp ) ; }
        else
        {
            ZE( countT , idTypeIn ) ;
            ZE( flagsT , flagsIn  ) ;
            ZE( countT , cbIn     ) ;
            byteT* pbzEncoded = soulInP.pbFieldF( tinP , idTypeIn , flagsIn , cbIn , idFieldIn ) ;
            __( idTypeIn - ifcIDtYPEsOULiTEM_strokeSptr ) ;
            __( flagsIn - flSOULiTEM_null ) ;
            __( !cbIn ) ;
            strDecodeF( tinP , psttp , pbzEncoded ) ; ___( psttp ) ;
        }

        if( !POOP )
        {
            countT idf = 1 ;
            while( !POOP && idf )
            {
                countT idfSaveReally = idf ;
                countT idfSave = idf ;
                sttQuoteP = sttqSave ; //NEEDED WHEN INPUT CONTAINS AN UNPAIRED QUOTE
                countT idw = strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttQuoteP , psttDelimiters , psttp ) ;

                countT idfDelim = idw ;
                countT idlDelim = !idfDelim
                    ? 0
                    : idf
                        ? idf - 1
                        : psttp->idAdam ;
                ;

                //if( tinP.pc Utility[ 0 ] ) LOGrAW5( "[idfDelim,idlDelim]: " , idfDelim , " " , idlDelim , "\r\n" ) ;

                if( idfSave <= psttp->idAdam && !strIdF( tinP , psttp[ CSpREFIX - 1 + idfSave ] , psttDelimiters ) ) // IF CURSOR IS NOT AT A DELIMITER
                {
                    if( idw > idfSave ) idw -- ;                                                                     // LATH BEFORE DELIMITER OR, IF NONE, BEGINNING OF DELIMITER
                    ZE( strokeS* , psttw2 ) ;
                    strSubstringF( tinP , psttw2 , idfSave , idw , psttp ) ; ___( psttw2 ) ;                         // SNIP BEFORE DELIMITER
                    ZE( strokeS* , psttw3 ) ;                                                                      // SNIP WITH DOUBLE QUOTES REMOVED
                    strokeS sttd = S1C(0x22) ; //0x22 is a double quote
                    if( sttQuoteP.idCaste != sc_IGNOREqUOTES && psttw2->idAdam > 1 && psttw2[ CSpREFIX ] == sttd && psttw2[ CSpREFIX - 1 + psttw2->idAdam ] == sttd ) // IF SNIP IS QUOTED STRING
                    {
                        if( psttw2->idAdam == 2 )
                        {
                            strMakeF( tinP , LF , psttw3 , T("") ) ; ___( psttw3 ) ;
                        }
                        else
                        {
                            countT idf3 = 2 ;
                            countT idl3 = psttw2->idAdam - 1 ;
                            strSubstringF( tinP , psttw3 , idf3 , idl3 , psttw2 ) ; ___( psttw3 ) ;
                        }
                    }
                    else
                    {
                        strMakeF( tinP , LF , psttw3 , psttw2 ) ; ___( psttw3 ) ;
                    }
                    delF( tinP , psttw2 ) ;

                    strReplaceF( tinP , psttw3 , 0 , pstt_sq , pstt_q , 0 , flSTRrEPLACE_IGNOREqUOTES ) ;           // \" -> "
                    cWords ++ ;                                                                                     // psttw3 IS SNIP READY TO BE PUSHED

                    if( bLazyIsDelim )
                    {
                        emitLaziesF( tinP , *this , soulOutP , stqLazy , flagsP , tBreak ) ;
                        bLazyIsDelim = 0 ;
                    }

                    if( !strIdF( tinP , tBreak , psttw3 ) ) { stqLazy << psttw3 ; psttw3 = 0 ; }
                    else
                    {
                        ZE( strokeS* , pstt1p ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        strWordsF( tinP , pstt1p , psttw3 , sttq , tBreak , bDelimiters ? flSTRwORDS_DELIMITERS : flSTRwORDS_null ) ; ___( pstt1p ) ;
                        delF( tinP , psttw3 ) ;

                        FORsTRINGSiN1( pstt1p )
                        {
                            if( psttc1->idAdam )
                            {
                                if( psttc1[ CSpREFIX ] == sttBreak )
                                {
                                    if( bDelimiters )
                                    {
                                        ZE( strokeS* , psttp ) ;
                                        strMakeF( tinP , LF , psttp , psttc1 ) ; ___( psttp ) ;

                                        emitLaziesF( tinP , *this , soulOutP , stqLazy , flagsP , tBreak ) ;
                                        stqLazy << psttp ; psttp = 0 ;
                                    }
                                }
                                else
                                {
                                    ZE( strokeS* , psttp ) ;
                                    strMakeF( tinP , LF , psttp , psttc1 ) ; ___( psttp ) ;

                                    stqLazy << psttp ; psttp = 0 ;
                                }
                            }
                        }
                        delF( tinP , pstt1p ) ;
                    }
                }

                if( idfDelim )
                {
                    if( !bLazyIsDelim )
                    {
                        emitLaziesF( tinP , *this , soulOutP , stqLazy , flagsP , tBreak ) ;
                        bLazyIsDelim = 1 ;
                    }

                    if( bDelimiters )
                    {
                        ZE( strokeS* , psttd ) ;
                        strSubstringF( tinP , psttd , idfDelim , idlDelim , psttp ) ; ___( psttd ) ;
                        cWords ++ ;

                        stqLazy << psttd ; psttd = 0 ; //A:ASSUME: tBreak IS NOT A DELIMITER
                        //SINCE psttd IS ASSUMED TO NOT CONTAIN tBreak, THERE IS NO NEED TO FLUSH stqLazy HERE IF psttd CONTAINS tBreak
                    }
                }
            }
            delF( tinP , psttp ) ;
        }
    }

    emitLaziesF( tinP , *this , soulOutP , stqLazy , flagsP , tBreak ) ;

    dec02AM( offNestLevel ) ;

    return cWords ;
}

#undef PSTT1
#undef PSTT2


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c6.etherc.strwordsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c7.etherc.strfusef BEGIN
#define DDNAME       "3func.360021c7.etherc.strfusef"
#define DDNUMB      (countT)0x360021c7
#define IDFILE      (countT)0xdce


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//U::O: THERE IS SOMETHING EXTREMELY INEFFICIENT HERE; STUDY WHY I AM SO SLOOOOOW FOR LARGE INPUT
//etherSoilF USED TO CALL ME TO POUR soulOut INTO soulOutP BUT THIS TOOK FOREEEEEVER

/*1*/ voidT etherC::strFuseF( tinS& tinP , soulC& soulOutP , soulC& soulInP , grabC* pGrabP , const strokeS sttEscapeP , const strokeS* psttDelimiterPairsP , const countT csttMaxDelimiterP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( soulInP ) ;_WQ
        if( POOP ) return ;
    }

    _IO_

    countT cFieldsIn = soulInP ;_WQ
    for( countT idFieldIn = 1 ; idFieldIn <= cFieldsIn ; idFieldIn ++ )
    {
        ZE( countT , idTypeIn ) ;_WQ
        ZE( flagsT , flagsIn  ) ;_WQ
        ZE( countT , cbIn     ) ;_WQ
        byteT* pbzEncoded = soulInP.pbFieldF( tinP , idTypeIn , flagsIn , cbIn , idFieldIn ) ;_WQ
        __( idTypeIn - ifcIDtYPEsOULiTEM_strokeSptr ) ;_WQ
        __( flagsIn - flSOULiTEM_null ) ;_WQ
        __( !cbIn ) ;_WQ

        if( !POOP )
        {
            ZE( strokeS* , psttp ) ;_WQ
            strDecodeF( tinP , psttp , pbzEncoded ) ; ___( psttp ) ;_WQ

            ZE( strokeS* , psttOut ) ;_WQ
            strFuseF( tinP , psttOut , psttp , &soulOutP , pGrabP , sttEscapeP ) ; ___( psttOut ) ;_WQ

            if( psttOut )
            {
                if( pGrabP ) pGrabP->grabF( tinP , TAG( TAGiDnULL ) ) ;_WQ
                soulOutP << psttOut ;_WQ
                if( pGrabP ) pGrabP->ungrabF( tinP ) ;_WQ
                delF( tinP , psttOut ) ;_WQ
            }

            delF( tinP , psttp ) ;_WQ
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c7.etherc.strfusef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c8.etherc.strreplacef BEGIN
#define DDNAME       "3func.360021c8.etherc.strreplacef"
#define DDNUMB      (countT)0x360021c8
#define IDFILE      (countT)0xdcf


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT etherC::strReplaceF( tinS& tinP , soulC& soulP , const strokeS* const psttOldSmallP , const strokeS* const psttNewSmallP , const flagsT flagsP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( soulP ) ;
        __Z( psttOldSmallP ) ;
        __Z( psttNewSmallP ) ;
        FV(flSTRrEPLACE,flagsP) ;
        if( POOP ) return 0 ;
    }

    traceF( tinP , T("strReplaceF / +") ) ; //U::TO FIND A BUG

    ZE( osTextT* , postJot ) ;
    if( F(flagsP) & flSTRrEPLACE_USEjOT )
    {
        ZE( strokeS* , psttJot ) ;
        tinP.pEther->strUniqueF( tinP , psttJot ) ; ___( psttJot ) ;
        tinP.pEther->strMakeF( tinP , LF , postJot , psttJot ) ; ___( postJot ) ;
        tinP.pEther->delF( tinP , psttJot ) ;
    }

    traceF( tinP , T("strReplaceF / 2") ) ; //U::TO FIND A BUG

    soulC sAfter( tinP , TAG( TAGiDnULL ) , flSOUL_null , postJot ) ;
    if( postJot ) tinP.pEther->delF( tinP , postJot ) ;

    traceF( tinP , T("strReplaceF / 1 [soulP]:  ")+TF2((countT)soulP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U::TO FIND A BUG

    ZE( countT , cDone ) ;
    while( soulP )
    {
        ZE( strokeS* , psttp ) ;
        soulP >> psttp ; ___( psttp ) ;
        cDone += strReplaceF( tinP , psttp , 0 , psttOldSmallP , psttNewSmallP , 0 , flagsP ) ; ___( psttp ) ;
        sAfter << psttp ;
        delF( tinP , psttp ) ;
    }

    traceF( tinP , T("strReplaceF / 0 [sAfter]:  ")+TF2((countT)sAfter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U::TO FIND A BUG

    if( !soulP.bUsesJotF() && !sAfter.bUsesJotF() ) soulP = sAfter ;
    else
    {
        while( sAfter )
        {
            ZE( strokeS* , psttp ) ;
            sAfter >> psttp ; ___( psttp ) ;
            soulP << psttp ;
            delF( tinP , psttp ) ;
        }
    }

    traceF( tinP , T("strReplaceF / -") ) ; //U::TO FIND A BUG

    return cDone ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c8.etherc.strreplacef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c9.etherc.diskcopyfilef BEGIN
#define DDNAME       "3func.360021c9.etherc.diskcopyfilef"
#define DDNUMB      (countT)0x360021c9
#define IDFILE      (countT)0xdd0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/voidT etherC::diskWalkCopyFileF( tinS& tinP , const strokeS* const psttNewP , const strokeS* const psttOldP , const countT cTriesP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttNewP ) ;
        __Z( psttOldP ) ;
        if( POOP ) return ;
        __Z( psttNewP->idAdam ) ;
        __Z( psttOldP->idAdam ) ;
        if( POOP ) return ;
        __( psttNewP[ psttNewP[ 0 ].idAdam - 1 ].idAdam == '/' ) ; //MUST NOT DESIGNATE A DIRECTORY
        __( psttOldP[ psttOldP[ 0 ].idAdam - 1 ].idAdam == '/' ) ; //MUST NOT DESIGNATE A DIRECTORY
        if( POOP ) return ;
    }

    _IO_
    ZE( osTextT* , postNew ) ;
    ZE( osTextT* , postOld ) ;
    ZE( strokeS* , psttn ) ;
    ZE( strokeS* , pstto ) ;
    diskMapFileNameF( tinP , psttn , psttNewP ) ; ___( psttn ) ;
    diskMapFileNameF( tinP , pstto , psttOldP ) ; ___( pstto ) ;
    diskMakeDirIfNeededF( tinP , psttn ) ;
    countT costNew = strMakeF( tinP , LF , postNew , psttn ) ; ___( postNew ) ;
    countT costOld = strMakeF( tinP , LF , postOld , pstto ) ; ___( postOld ) ;
    delF( tinP , psttn ) ;
    delF( tinP , pstto ) ;

    third.dosCopyF( tinP , osFileNameC( tinP , *this , postNew ) , osFileNameC( tinP , *this , postOld ) , cTriesP ) ;
    delF( tinP , postNew ) ;
    delF( tinP , postOld ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021c9.etherc.diskcopyfilef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ca.etherc.diskunzipf BEGIN
#define DDNAME       "3func.360021ca.etherc.diskunzipf"
#define DDNUMB      (countT)0x360021ca
#define IDFILE      (countT)0xdd1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
warning: the specified file will be extracted into the destination directory, overwriting any file with the same name
then the extracted file will be renamed to the specified short name
 "short name" refers to the portion of psttToP to the right of the rightmost slash '/'
 "destination directory" refers to the portion of psttToP from the beginning up to and including the rightmost slash '/'
*/
/**/

/*1*/voidT etherC::diskUnzipF( tinS& tinP , const strokeS* const psttToP , const strokeS* const psttFromFileP , const strokeS* const psttFromZipP , const flagsT flagsP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttToP ) ;
        __Z( psttFromFileP ) ;
        __Z( psttFromZipP ) ;
        FV(flUNZIP,flagsP) ;
        if( POOP ) return ;
    }

    ZE( strokeS* , psttToPath  ) ;
    ZE( strokeS* , psttToShort ) ;
    strBisectF( tinP , psttToPath , psttToShort , psttToP , 0 , -1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttToPath ) ; ___( psttToShort ) ;
    delF( tinP , psttToShort ) ;
    __Z( psttToPath ) ;

    ZE( strokeS* , psttFromPath  ) ;
    ZE( strokeS* , psttFromShort ) ;
    strBisectF( tinP , psttFromPath , psttFromShort , psttFromFileP , 0 , -1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttFromPath ) ; ___( psttFromShort ) ;
    delF( tinP , psttFromPath ) ;

    hoverC hover( tinP , *this , psttToPath ) ;
    third.diskUnzipF( tinP , osFileNameC( tinP , third , T(psttFromFileP) ) , osFileNameC( tinP , third , T(psttFromZipP) ) , flagsP ) ;

    diskMoveFileOrDirF( tinP , psttToP , T(psttToPath)+T(psttFromShort?psttFromShort:psttFromFileP) ) ;
    delF( tinP , psttToPath ) ;
    delF( tinP , psttFromShort ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ca.etherc.diskunzipf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021cb.etherc.strgetmimeheaderf BEGIN
#define DDNAME       "3func.360021cb.etherc.strgetmimeheaderf"
#define DDNUMB      (countT)0x360021cb
#define IDFILE      (countT)0xdd2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/**/

/*1*/voidT etherC::strGetMimeHeaderF( tinS& tinP , strokeS*& psttToP , const strokeS* const psttFromP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttToP ) ;
        __Z( psttFromP ) ;
        if( POOP ) return ;
    }

    ZE( strokeS* , psttHead ) ;
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    strSubstringF( tinP , psttHead , countTC( 1 ) , sttq , T("\r\n\r\n") , psttFromP ) ; ___( psttHead ) ;

    TN( tcr , "\r\n" ) ;
    TN( tb , " " ) ;
    TN( tbt , " \x09" ) ;
    TN( tn , "" ) ;

    ZE( strokeS* , pstt1Lines ) ;
    strWordsF( tinP , pstt1Lines , psttHead , sttq , tcr ) ; ___( pstt1Lines ) ;
    delF( tinP , psttHead ) ;

    {
        ZE( countT , csttNeeded ) ;
        FORsTRINGSiN1( pstt1Lines )
        {
            countT idBlack = strIdAnyF( tinP , 0 , flSTRmATCH_null , countTC( 1 ) , sttq , tbt , psttc1 , 0 , 1 , flSTRiDaNY_NOT ) ;
            csttNeeded += psttc1->idAdam - idBlack + 3 ;
        }

        strMakeF( tinP , LF , psttToP , 0 , csttNeeded ) ; ___( psttToP ) ;
    }

    // RECIPE
    // 
    // FOR EACH LINE
    //  GET THE TRIMMED VALUE
    //  IF CONTINUATION OUTPUT A BLANK
    //  ELSE IF NOT WOTH LINE THEN OUTPUT CRLF
    //  OUTPUT THE TRIMMED VALUE
    // IF HAVE OUTPUT ANYTHING THEN OUTPUT CRLF
    // 

    FORsTRINGSiN1( pstt1Lines )
    {
        countT idBlack = strIdAnyF( tinP , 0 , flSTRmATCH_null , countTC( 1 ) , sttq , tbt , psttc1 , 0 , 1 , flSTRiDaNY_NOT ) ;

        ZE( strokeS* , psttTrimmed ) ;
        if( idBlack > 1 )
        {
            strSubstringF( tinP , psttTrimmed , idBlack , countTC() , psttc1 ) ; ___( psttTrimmed ) ;
            strFuseF( tinP , psttToP , tb ) ;
        }
        else if( !BwOTHsTRING1 ) strFuseF( tinP , psttToP , tcr ) ;

        strFuseF( tinP , psttToP , psttTrimmed ? psttTrimmed : psttc1 ) ;
        delF( tinP , psttTrimmed ) ;
    }

    if( psttToP && psttToP->idAdam ) strFuseF( tinP , psttToP , tcr ) ;

    delF( tinP , pstt1Lines ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021cb.etherc.strgetmimeheaderf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021cc.etherc.strgetmimebodyf BEGIN
#define DDNAME       "3func.360021cc.etherc.strgetmimebodyf"
#define DDNUMB      (countT)0x360021cc
#define IDFILE      (countT)0xdd3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
parameters
 tinP
 psttToP
  must be 0
 psttFromP
  must not be 0
*/

/**/

/*1*/voidT etherC::strGetMimeBodyF( tinS& tinP , strokeS*& psttToP , const strokeS* const psttFromP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttToP ) ;
        __Z( psttFromP ) ;
        if( POOP ) return ;
    }

    ZE( strokeS* , psttBoundary ) ;
    {
        ZE( strokeS* , psttHead ) ;
        strGetMimeHeaderF( tinP , psttHead , psttFromP ) ; ___( psttHead ) ;

        ZE( strokeS* , psttv ) ;
        strSubstringMimeHeaderF( tinP , psttv , psttHead , T("content-type") ) ; ___( psttv ) ;
        delF( tinP , psttHead ) ;

        if( psttv && psttv->idAdam )
        {
            // INPUT EXAMPLE: "multipart/mixed; boundary=0016368e20f0e2dd310498cd0ae7"

            countT idf = 1 ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , T("boundary=") , psttv ) ;

            if( idf ) { strSubstringF( tinP , psttBoundary , idf , countTC() , psttv ) ; ___( psttBoundary ) ; }
        }
        delF( tinP , psttv ) ;
    }

    TN( tcrcr , "\r\n\r\n" ) ;

    if( !psttBoundary )
    {
        countT idf = 1 ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tcrcr , psttFromP ) ;

        if( idf ) { strSubstringF( tinP , psttToP , idf , countTC() , psttFromP ) ; ___( psttToP ) ; }
    }
    else
    {
        TN( tBoundary , "--" ) ; tBoundary += T(psttBoundary) ;
        delF( tinP , psttBoundary ) ;

        countT idf = 1 ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        if
        (
            strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tBoundary , psttFromP )
            &&
            idf
            &&
            strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tcrcr , psttFromP )
            &&
            idf
        )
        {
            countT idBegin = idf ;
            countT idEnd   = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tBoundary , psttFromP ) ;

            if( idBegin < idEnd )
            {
                idEnd -- ;
                strSubstringF( tinP , psttToP , idBegin , idEnd , psttFromP ) ; ___( psttToP ) ;
            }
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021cc.etherc.strgetmimebodyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021cd.etherc.ssstestf BEGIN
#define DDNAME       "3func.360021cd.etherc.ssstestf"
#define DDNUMB      (countT)0x360021cd
#define IDFILE      (countT)0xdd4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/boolT etherC::sssTestF( tinS& tinP , boolT& bDoNotAdvanceBigP , const strokeS* const psttSmallP , const strokeS* const psttBigP , const countT idsDoP , countT& idbDoP , const strokeS* const psttBlackP , const strokeS* const psttPunctuationP )/*1*/
{
    ZE( boolT , bOk ) ;
    switch( psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste )
    {
        case sc_cSSSmARK :
        {
            boolT bDone = 1 ;
            switch( psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam )
            {
                case sa_SSSmARKaNY :
                {
                    bOk = 1 ;
                    break ;
                }
                case sa_SSSmARKlINEbEGIN :
                {
                    strokeS sTest = psttBigP[ CSpREFIX - 2 + idbDoP ] ;
                    bOk = idbDoP == 1 || sTest == S1C( '\n' ) || sTest == S1C( '\r' ) ;
                    bDoNotAdvanceBigP = 1 ;
                    break ;
                }
                case sa_SSSmARKlINEeND :
                {
                    //WILL ONLY GET HERE IF sa_SSSmARKlINEeND WAS THE WOTH SPECIFICATION ENCOUNTERED

                    bOk = psttBigP[ CSpREFIX - 1 + idbDoP ] == S1C( '\r' ) || psttBigP[ CSpREFIX - 1 + idbDoP ] == S1C( '\n' ) ;

                    if( bOk ) while( idbDoP < psttBigP->idAdam && ( psttBigP[ CSpREFIX + idbDoP ] == S1C( '\r' ) || psttBigP[ CSpREFIX + idbDoP ] == S1C( '\n' ) ) ) idbDoP ++ ;

                    break ;
                }
                case sa_SSSmARKbLACK :
                {
                    bOk = strIdF( tinP , psttBigP[ CSpREFIX - 1 + idbDoP ] , psttBlackP ) ;
                    break ;
                }
                case sa_SSSmARKcONTROL :
                {
                    bOk = psttBigP[ CSpREFIX - 1 + idbDoP ].idAdam < 0x20 ;
                    break ;
                }
                case sa_SSSmARKgRAPHIC :
                {
                    bOk = psttBigP[ CSpREFIX - 1 + idbDoP ].idAdam >= 0x80 ;
                    break ;
                }
                case sa_SSSmARKpUNCTUATION :
                {
                    bOk = strIdF( tinP , psttBigP[ CSpREFIX - 1 + idbDoP ] , psttPunctuationP ) ;
                    break ;
                }
                case sa_SSSmARKaLPHABETIC :
                {
                    bOk =

                        ( S1C('a') <= psttBigP[ CSpREFIX - 1 + idbDoP ] && psttBigP[ CSpREFIX - 1 + idbDoP ] <= S1C('z') )
                        ||
                        ( S1C('A') <= psttBigP[ CSpREFIX - 1 + idbDoP ] && psttBigP[ CSpREFIX - 1 + idbDoP ] <= S1C('Z') )

                    ;

                    break ;
                }
                case sa_SSSmARKnUMERIC9 :
                {
                    bOk = S1C('0') <= psttBigP[ CSpREFIX - 1 + idbDoP ] && psttBigP[ CSpREFIX - 1 + idbDoP ] <= S1C('9') ;
                    break ;
                }
                case sa_SSSmARKnUMERICf :
                {
                    bOk =

                        ( S1C('0') <= psttBigP[ CSpREFIX - 1 + idbDoP ] && psttBigP[ CSpREFIX - 1 + idbDoP ] <= S1C('9') )
                        ||
                        ( S1C('a') <= psttBigP[ CSpREFIX - 1 + idbDoP ] && psttBigP[ CSpREFIX - 1 + idbDoP ] <= S1C('f') )

                    ;

                    break ;
                }
                default :
                {
                    bDone = 0 ;
                    break ;
                }
            }

            if( bDone ) break ;
        }
        default :
        {
            bOk = psttSmallP[ CSpREFIX - 1 + idsDoP ] == psttBigP[ CSpREFIX - 1 + idbDoP ] ;
            break ;
        }
    }

    return bOk ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021cd.etherc.ssstestf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ce.etherc.sssandf BEGIN
#define DDNAME       "3func.360021ce.etherc.sssandf"
#define DDNUMB      (countT)0x360021ce
#define IDFILE      (countT)0xdd5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
parameters
 tinP
 psttSmallP
  must have sc_ccSSS(sa_SSSaND) at position idsDoP
 psttBigP
 idsDoP
  must be nonze
  position idsDoP in psttSmallP must be sc_ccSSS(sa_SSSaND,?)
  when i return, will point to the lath position done
 idbDoP
  must be nonze
  the position in psttBigP at which to look for the specified AND pattern
  when i return, will point to the lath position done
*/

/**/

/*1*/boolT etherC::sssAndF( tinS& tinP , stackC* const pstMatchP , const flagsT flagsMatchP , const strokeS* const psttSmallP , const strokeS* const psttBigP ,  countT& idsDoP ,  countT& idbDoP )/*1*/
{
    ZE( boolT , bMatch ) ;

    IFbEcAREFUL
    {
        if( POOP ) return bMatch ;
        __Z( psttSmallP ) ;
        __Z( psttBigP ) ;
        __Z( idsDoP ) ;
        __Z( idbDoP ) ;
        if( POOP ) return bMatch ;
        __( psttSmallP->idAdam < idsDoP + 1 ) ; // NULL LENGTH SPECS ARE ALLOWED
        __Z( psttBigP->idAdam ) ;
        if( POOP ) return bMatch ;
        __NZ( psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste - sc_ccSSS  ) ;
        __NZ( psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam  - sa_SSSaND ) ;
        if( pstMatchP )
        {
            __( F( pstMatchP->flagsF( tinP ) ) & flSTACKc_FIFO ) ; // IF FIFO THEN WILL CONTAIN INCORRECT CONTENTS
        }
        //FV(flSTRmATCH,flagsMatchP) ;
        if( POOP ) return bMatch ;
    }

    const countT idbDoSave  = idbDoP ;
    const countT cPlatesWas = pstMatchP ? *pstMatchP : 0 ;

    countT idsMax = strIdLathExpressionF( tinP , psttSmallP , idsDoP ) ;              // SINCE idsDoP MUST POINT TO AN [sc_ccSSS,sa_SSSaND], idsMax IS HERE SET TO THE CORRESPONDING [sc_ccSSS,sa_SSSaNDeND]
    __Z( idsMax ) ;

    ZE( boolT  , bLathTested ) ;
    if( !POOP )
    {
        idsDoP ++ ;                           // WOTH AFTER '('
        idsMax -- ; // LATH BEFORE ')'

        bMatch = 1 ; // A NULL LENGTH PATTERN WILL ALWAYS MATCH

        ZE( countT , cRepeat ) ;
        ZE( countT , cRepeatIf ) ;
        ZE( boolT  , bUndoIfNotMatch ) ;
        ZE( boolT  , bDisarmUndoIf ) ;
        ZE( countT , cArmLiterals ) ;
        ZE( countT , idbReportWoth ) ;

        TN( tBlack , TbLACKeXCLUDINGnEWlINE ) ;
        TN( tPunctuation , TpUNCTUATION ) ;

        ZE( countT , idsDoLathMatch ) ;
        ZE( countT , idbDoLathMatch ) ;
        if( idsDoP <= idsMax && idbDoP <= psttBigP->idAdam ) for(;;)
        {
            const countT idsDoSaveInLoop = idsDoP ;
            const countT idbDoSaveInLoop = idbDoP ;
            ZE( boolT , bDoNotAdvanceBig ) ;

            if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERAL )
            {
                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL
                else
                {
                    cArmLiterals = 1 ;
                    idsDoP ++ ;
                    continue ;
                }
            }
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERALbEGIN )
            {
                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL
                else
                {
                    cArmLiterals = - 1 ;
                    idsDoP ++ ;
                    continue ;
                }
            }
            else if( psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERALeND )
            {
                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL
                else
                {
                    cArmLiterals = 0 ;
                    idsDoP ++ ;
                    continue ;
                }
            }
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSrEPORTmATCH )
            {
                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL
                else
                {
                    idsDoP ++ ;

                    if( !idbReportWoth ) idbReportWoth = idbDoP ;
                    continue ;
                }
            }
            else if( psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSrEPORTmATCHeND )
            {
                if( idbReportWoth && idbReportWoth < idbDoP )
                {
                    if( pstMatchP && F(flagsMatchP) & flSTRmATCH_REPORTmATCH )
                    {
                        ZE( strokeS* , psttm ) ;
                        countT idf = idbReportWoth ;
                        countT idl = idbDoP - 1 ;
                        strSubstringF( tinP , psttm , idf , idl , psttBigP ) ; ___( psttm ) ;
                        *pstMatchP << psttm ; psttm = 0 ;
                    }
                }
                idbReportWoth = 0 ;

                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL
                else
                {
                    idsDoP ++ ;
                    continue ;
                }
            }
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSSrEPEAT )
            {
                if( psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam <= psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote )
                {
                    cRepeat   = psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam           ;
                    cRepeatIf = psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote  - cRepeat ;
                }
                else if( psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == -1 && psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote )            // SPECIAL VALUES THAT MEAN: "IGNORE THE NEXT cNote SUBEXPRESSIONS"
                {
                    countT cIgnore = psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote ;
                    idsDoP ++ ;
                    while( cIgnore -- && idsDoP <= psttSmallP->idAdam )
                    {
                        countT idsLathMe = strIdLathExpressionF( tinP , psttSmallP , idsDoP ) ;
                        __Z( idsLathMe ) ;

                        if( !POOP )
                        {
                            idsDoP = idsLathMe ;
                            if( idsDoP > psttSmallP->idAdam )
                            {
                                idsDoP = 0 ;
                                bMatch = 0 ;
                                break ;
                            }
                        }
                        else
                        {
                            bMatch = 0 ;
                            break ;
                        }
                    }
                }

                if( idsDoP == idsMax ) break ;
                else
                {
                    idsDoP ++ ;
                    continue ;
                }
            }
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSaND )
            {
                bLathTested = 1 ;
                if( !sssAndF( tinP , pstMatchP , flagsMatchP , psttSmallP , psttBigP ,  idsDoP ,  idbDoP ) )
                {
                    if( !bUndoIfNotMatch )
                    {
                        bMatch = 0 ;
                        break ;
                    }
                    else
                    {
                        bUndoIfNotMatch = 0 ;

                        if( idsDoP == idsMax )
                        {
                            idsDoP = idsDoLathMatch ;
                            idbDoP = idbDoLathMatch ;
                            break ;
                        }
                        else
                        {
                            idsDoP ++ ;
                            idbDoP = idbDoSaveInLoop ;
                            cRepeatIf = 0 ;
                            continue ;
                        }
                    }
                }
            }
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam  == sa_SSSoR )
            {
                bLathTested = 1 ;
                if( !sssOrF( tinP , pstMatchP , flagsMatchP , psttSmallP , psttBigP ,  idsDoP ,  idbDoP ) )
                {
                    if( !bUndoIfNotMatch )
                    {
                        bMatch = 0 ;
                        break ;
                    }
                    else
                    {
                        bUndoIfNotMatch = 0 ;

                        if( idsDoP == idsMax )
                        {
                            idsDoP = idsDoLathMatch ;
                            idbDoP = idbDoLathMatch ;
                            break ;
                        }
                        else
                        {
                            idsDoP ++ ;
                            idbDoP = idbDoSaveInLoop ;
                            cRepeatIf = 0 ;
                            continue ;
                        }
                    }
                }
            }
            else
            {
                bLathTested = 1 ;
                boolT bOk = cArmLiterals
                    ? psttSmallP[ CSpREFIX - 1 + idsDoP ] == psttBigP[ CSpREFIX - 1 + idbDoP ]
                    : sssTestF( tinP , bDoNotAdvanceBig , psttSmallP , psttBigP , idsDoP , idbDoP , tBlack , tPunctuation )
                ;

                if( !bOk )
                {
                    if( !bUndoIfNotMatch )
                    {
                        bMatch = 0 ;
                        break ;
                    }
                    else
                    {
                        bUndoIfNotMatch = 0 ;

                        if( idsDoP == idsMax )
                        {
                            idsDoP = idsDoLathMatch ;
                            idbDoP = idbDoLathMatch ;
                            break ;
                        }
                        else
                        {
                            idsDoP ++ ;
                            idbDoP = idbDoSaveInLoop ;
                            cRepeatIf = 0 ;
                            continue ;
                        }
                    }
                }
            }

            // LOOK AHEAD RECIPES
            // IF WE GET HERE THEN THE CURRENT CURSORED STROKES MATCH
            // THIS IS THE TIME TO TEST ANY LOOK AHEAD SPECIFICATIONS
            // AS OF THIS WRITING, THE ONLY SPECIFICATION THAT MUST BE OBEYED USING LOOK AHEAD IS: sa_SSSmARKlINEeND
            if
            (
                idsDoP < idsMax
                &&
                psttSmallP[ CSpREFIX + idsDoP ].idCaste == sc_cSSSmARK
                &&
                psttSmallP[ CSpREFIX + idsDoP ].idAdam == sa_SSSmARKlINEeND
            )
            {
                if
                (
                    idbDoP == psttBigP->idAdam
                    ||
                    psttBigP[ CSpREFIX + idbDoP ] == S1C( '\r' )
                    ||
                    psttBigP[ CSpREFIX + idbDoP ] == S1C( '\n' )
                )
                {
                    idsDoP ++ ;
                    while( idbDoP < psttBigP->idAdam && ( psttBigP[ CSpREFIX + idbDoP ] == S1C( '\r' ) || psttBigP[ CSpREFIX + idbDoP ] == S1C( '\n' ) ) ) idbDoP ++ ;
                }
                else
                {
                    bMatch = 0 ;
                    break ;
                }
            }

            idsDoLathMatch = idsDoP ;
            idbDoLathMatch = idbDoP ;

            if( cArmLiterals  ) cArmLiterals -- ;
            if( bDisarmUndoIf ) bDisarmUndoIf = bUndoIfNotMatch = 0 ;

            if( idsDoP == idsMax )
            {
                if( !cRepeat && ( !cRepeatIf || idbDoP == psttBigP->idAdam ) ) break ;      // WE ARE DONE
                else
                {
                    if( idbDoP == psttBigP->idAdam && cRepeat ) { bMatch = 0 ; break ; } // WE ARE DONE
                    else
                    {
                        idsDoP = idsDoSaveInLoop ;
                        if( !bDoNotAdvanceBig ) idbDoP ++ ;

                        if( cRepeat ) cRepeat -- ;
                        else if( cRepeatIf )
                        {
                            if( !( -- cRepeatIf ) ) bDisarmUndoIf = 1 ;
                            bUndoIfNotMatch = 1 ;
                        }
                    }
                }
            }
            //U:: THIS CODE WRONGLY ASSUMES THAT REMAINDER OF SMALL IS NOT TO BE IGNORED: else if( idbDoP == psttBigP->idAdam && !bDoNotAdvanceBig ) { bMatch = 0 ; break ; } // WE ARE DONE
            else
            {
                if( cRepeat || cRepeatIf )
                {
                    idsDoP = idsDoSaveInLoop ;
                    if( !bDoNotAdvanceBig && bLathTested )
                    {
                        bLathTested = 0 ;
                        idbDoP ++ ;
                    }

                    if( cRepeat ) cRepeat -- ;
                    else
                    {
                        if( !( -- cRepeatIf ) ) bDisarmUndoIf = 1 ;
                        bUndoIfNotMatch = 1 ;
                    }
                }
                else
                {
                    idsDoP ++ ;
                    if( !bDoNotAdvanceBig && bLathTested )
                    {
                        bLathTested = 0 ;
                        idbDoP ++ ;
                    }
                }
            }
        }

        idsDoP = ++ idsMax ; // ')'
    }

    if( !bMatch )
    {
        //idsDoP = idsDoSave ;
        idbDoP = idbDoSave ;

        if( pstMatchP ) pstMatchP->purgeF( tinP , cPlatesWas ) ;
    }
    else
    {
        if( !bLathTested ) idbDoP -- ;

        if( pstMatchP && F(flagsMatchP) & flSTRmATCH_AND )
        {
            ZE( strokeS* , psttm ) ;
            countT idf = idbDoSave ;
            countT idl = idbDoP ;
            strSubstringF( tinP , psttm , idf , idl , psttBigP ) ; ___( psttm ) ;
            *pstMatchP << psttm ; psttm = 0 ;
        }
    }

    return bMatch ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ce.etherc.sssandf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021cf.etherc.sssorf BEGIN
#define DDNAME       "3func.360021cf.etherc.sssorf"
#define DDNUMB      (countT)0x360021cf
#define IDFILE      (countT)0xdd6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
parameters
 tinP
 psttSmallP
  must have sc_ccSSS(sa_SSSoR) at position idsDoP
 psttBigP
 idsDoP
  must be nonze
  position idsDoP in psttSmallP must be sc_ccSSS(sa_SSSoR,?)
  when i return, will point to the lath position done
 idbDoP
  must be nonze
  the position in psttBigP at which to look for the specified OR pattern
  when i return, will point to the lath position done
*/

/**/

/*1*/boolT etherC::sssOrF( tinS& tinP , stackC* const pstMatchP , const flagsT flagsMatchP , const strokeS* const psttSmallP , const strokeS* const psttBigP ,  countT& idsDoP ,  countT& idbDoP )/*1*/
{

    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttSmallP ) ;
        __Z( psttBigP ) ;
        __Z( idsDoP ) ;
        __Z( idbDoP ) ;
        if( POOP ) return 0 ;
        __( psttSmallP->idAdam < idsDoP + 1 ) ; // NULL LENGTH SPECS ARE ALLOWED
        __Z( psttBigP->idAdam ) ;
        if( POOP ) return 0 ;
        __NZ( psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste - sc_ccSSS ) ;
        __NZ( psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam  - sa_SSSoR ) ;
        if( pstMatchP )
        {
            __( F( pstMatchP->flagsF( tinP ) ) & flSTACKc_FIFO ) ; // IF FIFO THEN WILL CONTAIN INCORRECT CONTENTS
        }
        //FV(flSTRmATCH,flagsMatchP) ;
        if( POOP ) return 0 ;
    }

    countT cPlatesWas = pstMatchP ? *pstMatchP : 0 ;
    const countT idbDoSave = idbDoP ;
    const boolT bRangePairs = !!( psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote & sp_SSSfLAGrANGEpAIRS ) ;
    const boolT bNot = !!( psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote & sp_SSSfLAGnOT ) ;
    boolT bMatch = bNot ;

    // --------------------------------------------------------------------------------------------------------------------------------------------------
    // FIND THE MATCHING END
    // --------------------------------------------------------------------------------------------------------------------------------------------------

    idsDoP ++ ;                           // WOTH AFTER '['
    countT idsMax = idsDoP ;
    {
        countT cLevels = 1 ;
        ZE( boolT , cArmLiterals ) ;
        for( ; idsMax <= psttSmallP->idAdam ; idsMax ++ )
        {
                 if( psttSmallP[ CSpREFIX - 1 + idsMax ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsMax ].idAdam == sa_SSSlITERALeND ) cArmLiterals = 0 ;
            else if( cArmLiterals                                            ) cArmLiterals -- ;
            else if( psttSmallP[ CSpREFIX - 1 + idsMax ].idCaste == sc_ccSSS )
            {
                ZE( boolT , bFound ) ;
                switch( psttSmallP[ CSpREFIX - 1 + idsMax ].idAdam )
                {
                    case sa_SSSlITERAL :
                    {
                        cArmLiterals = 1 ;
                        break ;
                    }
                    case sa_SSSlITERALbEGIN :
                    {
                        cArmLiterals = - 1 ; //A:ASSUME: STRING LENGTH CANNOT EXCEED maxCountTT
                        break ;
                    }
                    case sa_SSSlITERALeND :
                    {
                        cArmLiterals = 0 ;
                        break ;
                    }
                    case sa_SSSoR :
                    {
                        ++ cLevels ;
                        break ;
                    }
                    case sa_SSSoReND :
                    {
                        if( !( -- cLevels ) ) bFound = 1 ;
                        break ;
                    }
                }

                if( bFound ) break ;
            }
        }

        if( idsMax > psttSmallP->idAdam ) idsMax = 0 ;
    }
    __Z( idsMax ) ;

    // --------------------------------------------------------------------------------------------------------------------------------------------------
    // SET bMatch
    // --------------------------------------------------------------------------------------------------------------------------------------------------

    if( !POOP )
    {
        idsMax -- ; // LATH BEFORE ']'
        ZE( boolT , bCeiling   ) ; // IF bRangePairs THEN INDIVIDUAL STROKES ARE ALTERNATELY INTERPRETED AS FLOOR,CEILING,FLOOR,CEILING,...
        ZE( boolT , bFloorPass ) ; // IF bRangePairs THEN FLOOR PASS/FAIL IS STORED HERE TO BE INSPECTED WHEN TESTING CEILING
        ZE( boolT , cArmLiterals ) ;

        TN( tBlack , TbLACKeXCLUDINGnEWlINE ) ;
        TN( tPunctuation , TpUNCTUATION ) ;

        if( idsDoP <= idsMax && idbDoP <= psttBigP->idAdam ) for(;;)
        {
            ZE( boolT , bDoNotAdvanceBigNU ) ;

                 if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERAL      ) cArmLiterals =   1 ;
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERALbEGIN ) cArmLiterals = - 1 ;
            else if(                  psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERALeND   ) cArmLiterals =   0 ;
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSaND )
            {
                boolT bHit = sssAndF( tinP , pstMatchP , flagsMatchP , psttSmallP , psttBigP ,  idsDoP ,  idbDoP ) ;

                if( bHit )
                {
                    bMatch = !bNot ;
                    break ;
                }
            }
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam  == sa_SSSoR )
            {
                boolT bHit = sssOrF( tinP , pstMatchP , flagsMatchP , psttSmallP , psttBigP ,  idsDoP ,  idbDoP ) ;

                if( bHit )
                {
                    bMatch = !bNot ;
                    break ;
                }
            }
            else
            {
                ZE( boolT , bHit ) ;
                if( !bRangePairs )
                {
                    bHit = cArmLiterals
                        ? psttSmallP[ CSpREFIX - 1 + idsDoP ] == psttBigP[ CSpREFIX - 1 + idbDoP ]
                        : sssTestF( tinP , bDoNotAdvanceBigNU , psttSmallP , psttBigP , idsDoP , idbDoP , tBlack , tPunctuation )
                    ;
                }
                else if( !bCeiling    ) bFloorPass = psttSmallP[ CSpREFIX - 1 + idsDoP ] <= psttBigP[ CSpREFIX - 1 + idbDoP ] ;
                else
                {
                    boolT bCeilingPass = psttSmallP[ CSpREFIX - 1 + idsDoP ] >= psttBigP[ CSpREFIX - 1 + idbDoP ] ;
                    bHit = bFloorPass && bCeilingPass ;
                }

                bCeiling = !bCeiling ;

                if( bHit )
                {
                    bMatch = !bNot ;
                    break ;
                }
            }

            if( idsDoP == idsMax ) break ;      // WE ARE DONE
            else
            {
                idsDoP ++ ;
                if( cArmLiterals ) cArmLiterals -- ;
            }
        }

        idsDoP = ++ idsMax ; // ')'
    }

    if( !bMatch )
    {
        idbDoP = idbDoSave ;
        if( pstMatchP ) pstMatchP->purgeF( tinP , cPlatesWas ) ;
    }

    else if( pstMatchP && F(flagsMatchP) & flSTRmATCH_OR )
    {
        ZE( strokeS* , psttm ) ;
        countT idf = idbDoSave ;
        countT idl = idbDoP ;
        strSubstringF( tinP , psttm , idf , idl , psttBigP ) ; ___( psttm ) ;
        *pstMatchP << psttm ; psttm = 0 ;
    }

    return bMatch ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021cf.etherc.sssorf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d0.etherc.tracef BEGIN
#define DDNAME       "3func.360021d0.etherc.tracef"
#define DDNUMB      (countT)0x360021d0
#define IDFILE      (countT)0xdd7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
parameters
 tinP
 psttP
  may be 0
*/

/**/

//DON'T USE _ IN HERE (WILL BLOW STACK)

/*1*/voidT etherC::traceF( tinS& tinP , const strokeS* const psttP , const flagsT flagsP , const countT idDivertP )/*1*/
{
    homeS& home = homeS::homeIF() ;
    boolT bTraceOk  = F(flagsP) & flTRACE_FORCEnOsILENCE || !( F(home.flags) & flHOMEs_TRACEsILENCED ) ;
    boolT bDivertOk = F(flagsP) & flTRACE_FORCEdIVERT    || !( F(home.flags) & flHOMEs_TRACEnOdIVERT ) ;

    //LOGrAWb( "\r\ntraceF [idAdam,flagsP,home.flags,bTraceOk,bDivertOk]:    " , tinP.pAdamGlobal1->idAdam , "    " , flagsP , "    " , home.flags , "    " , bTraceOk , "    " , bDivertOk , "\r\n" ) ; //U:: TO FIND A BUG

    //if( !thirdC::c_strcmpIF( tinP , tinP.postThreadName , "tmGetIdHomeF" ) )
    if( !bTraceOk || F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_NOtRACING || F(tinP.flagsThreadMode3) & flTHREADmODE3_SUPPRESStRACING )
    {
        //U:: ENHANCE TO POSTPONE BY WRITING TO A TEMPORARY BUFFER THAT IS FLUSHED BY booksC WHEN IT CAN DO SO
        //LOGrAW( "\r\ntraceF: suppressing trace:  " ) ;
        //if( F(flagsP) & flTRACE_PARAMETERiSoStEXT )
        //{
        //    LOGrAW( (osTextT*)psttP ) ;
        //}
        //else
        //{
        //    LOGrAW( T(psttP) ) ;
        //}
        //LOGrAW( "\r\n" ) ;
    }
    else
    {
        countT c_this = (countT)this ;

        ZE( scoopC* , pScoop ) ;
        byteT pbScoop[ sizeof( scoopC ) ] ;
        if( c_this ) pScoop = new( 0 , tinP , pbScoop , sizeof pbScoop ) scoopC( tinP , LF , poop ) ; 

        {
            IFbEcAREFUL
            {
                //20160530@1034: I AM NOW CALLED BY poopC::gruntF SO MUST DO MY JOB EVEN IF IMPOTENCE
                //if( POOP ) return ;
                //FV( flTRACE , flagsP ) ;
                //if( POOP ) return ;
            }

            OStEXT( ostoSay , TUCK + CBrEADABILITYmAPdUMP ) ; //CS:CODEsYNC: 360020 360020 ; 20171225@1122: INCREASED TO BE BIG ENOUGH FOR MEMORY READABILITY MAP DUMP
            OStEXTAK( ostoSay , "\r\n" ) ;

            if( !( F(flagsP) & flTRACE_NOpREFIX ) )
            {
                OStEXT( ostoTimeDelta , TUCK >> 3 ) ;
                OStEXT( ostoTime , TUCK >> 3 ) ;
                OStEXT( ostoTimeElapsed , TUCK >> 3 ) ;

                if( !c_this )
                {
                    OStEXTAK( ostoTimeDelta   , "--------.--------" ) ;
                    OStEXTAK( ostoTime        , "--------.--------" ) ;
                    OStEXTAK( ostoTimeElapsed , "--------.--------" ) ;
                }
                else
                {
                    boolT bReset = ( !tinP.timeTraceWoth.time2 && !tinP.timeTraceWoth.time1 ) || F(flagsP) & flTRACE_RESET ;

                    ZE( countT  , timeDelta1 ) ;
                    ZE( sCountT , timeDelta2 ) ;
                    osTimeNowF( tinP , timeDelta1 , timeDelta2 ) ;
                    timeS now( timeDelta1 , timeDelta2 ) ;
                    if( bReset ) tinP.timeTraceWoth = tinP.timeTraceLath = now ;
                    osTimeSubtractF( tinP , timeDelta1 , timeDelta2 , tinP.timeTraceLath.time1 , tinP.timeTraceLath.time2 ) ;
                    tinP.timeTraceLath = now ;

                    OStEXTCF(  ostoTimeDelta , timeDelta2 , '0' ) ;
                    OStEXTAK( ostoTimeDelta , "." ) ;
                    OStEXTCF(  ostoTimeDelta , timeDelta1 , '0' ) ;

                    OStEXTCF(  ostoTime , tinP.timeTraceLath.time2 , '0' ) ;
                    OStEXTAK( ostoTime , "." ) ;
                    OStEXTCF(  ostoTime , tinP.timeTraceLath.time1 , '0' ) ;

                    countT  timeE1 = tinP.timeTraceLath.time1 ;
                    sCountT timeE2 = tinP.timeTraceLath.time2 ;
                    osTimeSubtractF( tinP , timeE1 , timeE2 , tinP.timeTraceWoth.time1 , tinP.timeTraceWoth.time2 ) ;

                    OStEXTCF(  ostoTimeElapsed , timeE2 , '0' ) ;
                    OStEXTAK( ostoTimeElapsed , "." ) ;
                    OStEXTCF(  ostoTimeElapsed , timeE1 , '0' ) ;
                }

                sCountT costPad = ( TUCK >> 4 ) - thirdC::c_strlenIF( tinP.postThreadName ) ;
                if( costPad < 0 ) costPad = 0 ;

                OStEXTA(  ostoSay , ostoTime ) ;
                OStEXTAK( ostoSay , " ! " ) ;
                OStEXTA(  ostoSay , ostoTimeElapsed ) ;
                OStEXTAK( ostoSay , " @ " ) ;
                OStEXTA(  ostoSay , ostoTimeDelta ) ;
                OStEXTAK( ostoSay , " # " ) ;
                OStEXTC(  ostoSay , tinP.pAdamGlobal1->idCell , ' ' ) ;
                OStEXTAK( ostoSay , " $ " ) ;
                OStEXTC(  ostoSay , tinP.monitor.idThread , ' ' ) ;
                OStEXTAK( ostoSay , " % " ) ;
                OStEXTA(  ostoSay , tinP.postThreadName ) ;
                while( costPad -- ) { OStEXTAK( ostoSay , " " ) ; }
                OStEXTAK( ostoSay , " | " ) ;
            }

            if( psttP )
            {
                if( F(flagsP) & flTRACE_PARAMETERiSoStEXT )
                {
                    if( !( F(flagsP) & flTRACE_NOtELL ) ) { TELL( (osTextT*)psttP ) ; }
                    OStEXTA(  ostoSay , (osTextT*)psttP ) ;
                }
                else
                {
                    countT costBefore = ostoSay.costF() ;

                    countT offEnd = CSpREFIX + ( psttP->idAdam < TUCK << 4 ? psttP->idAdam : TUCK << 4 ) ; //CS:CODEsYNC: 360020 3600204

                    const boolT bKeepCrLf = F(flagsP) & flTRACE_KEEPcRlF ;

                    for( countT offi = CSpREFIX ; offi < offEnd ; offi ++ )
                    {
                        if
                        (
                            (
                                psttP[ offi ].idCaste == sc_cFROMaSCII
                                ||
                                psttP[ offi ].idCaste == sc_cALPHABET1
                                ||
                                (
                                    psttP[ offi ].idCaste == sc_cFROMcONTROL
                                    &&
                                    bKeepCrLf
                                )
                            )
                            &&
                            psttP[ offi ].idAdam < TUCK
                        )
                        {
                            osTextT post2[] = { (osTextT)psttP[ offi ].idAdam , 0 } ;
                            if
                            (
                                ( *post2 >= 0x20 && *post2 <= 0x7f )
                                ||
                                ( bKeepCrLf && ( *post2 == '\r' || *post2 == '\n' ) )
                            )
                            {
                                if( *post2 == '\r' )
                                {
                                    countT foo = 2 ;
                                }

                                OStEXTA(  ostoSay , post2 ) ;
                            }
                        }
                    }
                    if( !( F(flagsP) & flTRACE_NOtELL ) ) { TELL( (const osTextT*)ostoSay + costBefore ) ; }
                }
            }

            if( F(processGlobal1I.flCt) & flCTdTg_exceptionHandlerRegistered && !( F(processGlobal1I.flDt) & flCTdTg_exceptionHandlerRegistered ) )
            {
                RESTART
                _restart.flags |= flRESTARTc_QUIET ;

                if( _restart )
                {
                    LOGrAW( "\r\ntraceF: logging because exception caught while attempting to write to bksTraceUse\r\n" ) ;
                    LOGrAW( ostoSay ) ;
                }
                else if( F(flagsP) & flTRACE_LOOP )
                {
                    ZE( flagsT , flagsResult ) ;
                    countT cb1 = ostoSay.costF() ;
                    processGlobal3S::_processGlobal3I_IF().bkTraceLoop.writeF( tinP , flagsResult , ostoSay , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLOWoDDlENGTH | flBOOK0cwRITE_ALLoRnONE | flBOOK0cwRITE_PURGEiFfULL ) ;
                }
                else
                {
                    if( !( F(flagsP) & flTRACE_ECHOoNLY ) )
                    {
                        ZE( booksC* , pBksUse ) ;
                        if( !bDivertOk ) pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTrace ;
                        else switch( idDivertP )
                        {
                            case 0                   : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTrace         ; break ; }
                            case ifcIDtRACEdIVERT_1  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert01 ; break ; }
                            case ifcIDtRACEdIVERT_2  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert02 ; break ; }
                            case ifcIDtRACEdIVERT_3  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert03 ; break ; }
                            case ifcIDtRACEdIVERT_4  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert04 ; break ; }
                            case ifcIDtRACEdIVERT_5  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert05 ; break ; }
                            case ifcIDtRACEdIVERT_6  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert06 ; break ; }
                            case ifcIDtRACEdIVERT_7  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert07 ; break ; }
                            case ifcIDtRACEdIVERT_8  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert08 ; break ; }
                            case ifcIDtRACEdIVERT_9  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert09 ; break ; }
                            case ifcIDtRACEdIVERT_a  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert0a ; break ; }
                            case ifcIDtRACEdIVERT_b  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert0b ; break ; }
                            case ifcIDtRACEdIVERT_c  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert0c ; break ; }
                            case ifcIDtRACEdIVERT_d  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert0d ; break ; }
                            case ifcIDtRACEdIVERT_e  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert0e ; break ; }
                            case ifcIDtRACEdIVERT_f  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert0f ; break ; }
                            case ifcIDtRACEdIVERT_10 : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert10 ; break ; }
                            default :
                            {
                                __( idDivertP ) ;
                            }
                        }

                        if( pBksUse ) pBksUse->writeF( tinP , ostoSay , 0 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                    }

                    if( F(flagsP) & flTRACE_HOMEeCHO )
                    {
                        THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                        processGlobal3S::_processGlobal3I_IF().bksTraceHomeEcho.writeF( tinP , ostoSay , 0 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                        THREADmODE3rESTORE
                    }

                    if( F(flagsP) & flTRACE_HOMEeCHOdEADMAN1 )
                    {
                        THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                        processGlobal3S::_processGlobal3I_IF().bksTraceHomeEchoDeadman1.writeF( tinP , ostoSay , 0 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                        THREADmODE3rESTORE
                    }

                    if( F(flagsP) & flTRACE_HOMEeCHOgORILLAhOME )
                    {
                        THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                        processGlobal3S::_processGlobal3I_IF().bksTraceHomeEchoGorillaHome.writeF( tinP , ostoSay , 0 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                        THREADmODE3rESTORE
                    }
                }
            }
            else
            {
                LOGrAW( "\r\ntraceF: logging because exception handler is not registered\r\n" ) ;
                LOGrAW( ostoSay ) ;
            }

            if( !( F(flagsP) & flTRACE_NOcONSOLE ) ) { CONoUTrAW( ostoSay ) ; }
        }
        DELzOMBIE( pScoop ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d0.etherc.tracef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d1.etherc.openssl_setupf BEGIN
#define DDNAME       "3func.360021d1.etherc.openssl_setupf"
#define DDNUMB      (countT)0x360021d1
#define IDFILE      (countT)0xdd8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/voidT etherC::openSsl_setupF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    thirdC::openSsl_setupIF() ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d1.etherc.openssl_setupf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d2.etherc.openssl_shutdownf BEGIN
#define DDNAME       "3func.360021d2.etherc.openssl_shutdownf"
#define DDNUMB      (countT)0x360021d2
#define IDFILE      (countT)0xdd9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/voidT etherC::openSsl_shutdownF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    thirdC::openSsl_shutdownIF() ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d2.etherc.openssl_shutdownf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d3.etherc.openssl_getcontextf BEGIN
#define DDNAME       "3func.360021d3.etherc.openssl_getcontextf"
#define DDNUMB      (countT)0x360021d3
#define IDFILE      (countT)0xdda


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/voidT etherC::openSsl_getContextF( tinS& tinP , handleC& handleP , const strokeS* const psttPemCertificatesP , const strokeS* const psttPemPrivateKeyP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    thirdC::openSsl_getContextIF( tinP , handleP , psttPemCertificatesP && psttPemCertificatesP->idAdam ? (osTextT*)osFileNameC( tinP , third , T(psttPemCertificatesP) ) : (osTextT*)0 , psttPemPrivateKeyP && psttPemPrivateKeyP->idAdam ? (osTextT*)osFileNameC( tinP , third , T(psttPemPrivateKeyP) ) : (osTextT*)0 ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d3.etherc.openssl_getcontextf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d4.etherc.openssl_getwrapperf BEGIN
#define DDNAME       "3func.360021d4.etherc.openssl_getwrapperf"
#define DDNUMB      (countT)0x360021d4
#define IDFILE      (countT)0xddb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/voidT etherC::openSsl_getWrapperF( tinS& tinP , handleC& handleP , const handleC& hContextP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( ~handleP   ) ;
        __Z(  ~hContextP ) ;
        if( POOP ) return ;
    }

    _IO_

    thirdC::openSsl_getWrapperIF( tinP , handleP , hContextP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d4.etherc.openssl_getwrapperf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d5.etherc.openssl_wrapsocketf BEGIN
#define DDNAME       "3func.360021d5.etherc.openssl_wrapsocketf"
#define DDNUMB      (countT)0x360021d5
#define IDFILE      (countT)0xddc


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/voidT etherC::openSsl_wrapSocketF( tinS& tinP , const handleC& hWrapperP , const handleC& hSocketP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( ~hWrapperP ) ;
        __Z( ~hSocketP  ) ;
        if( POOP ) return ;
    }

    _IO_

    thirdC::openSsl_wrapSocketIF( tinP , hWrapperP , hSocketP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d5.etherc.openssl_wrapsocketf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d6.etherc.openssl_shakehandsasclientf BEGIN
#define DDNAME       "3func.360021d6.etherc.openssl_shakehandsasclientf"
#define DDNUMB      (countT)0x360021d6
#define IDFILE      (countT)0xddd


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/voidT etherC::openSsl_shakeHandsAsClientF( tinS& tinP , const handleC& hWrapperP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( ~hWrapperP ) ;
        if( POOP ) return ;
    }

    _IO_

    thirdC::openSsl_shakeHandsAsClientIF( tinP , hWrapperP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d6.etherc.openssl_shakehandsasclientf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d7.etherc.openssl_writef BEGIN
#define DDNAME       "3func.360021d7.etherc.openssl_writef"
#define DDNUMB      (countT)0x360021d7
#define IDFILE      (countT)0xdde


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/countT etherC::openSsl_writeF( tinS& tinP , const handleC& hWrapperP , const byteT* const pbP , const countT cbP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( pbP ) ;
        __Z( cbP ) ;
        __Z( ~hWrapperP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    return thirdC::openSsl_writeIF( tinP , hWrapperP , pbP , cbP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d7.etherc.openssl_writef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d8.etherc.openssl_readf BEGIN
#define DDNAME       "3func.360021d8.etherc.openssl_readf"
#define DDNUMB      (countT)0x360021d8
#define IDFILE      (countT)0xddf


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/countT etherC::openSsl_readF( tinS& tinP , byteT* const pbP , const countT cbP , const handleC& hWrapperP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( pbP ) ;
        __Z( cbP ) ;
        __Z( ~hWrapperP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    return thirdC::openSsl_readIF( tinP , pbP , cbP , hWrapperP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d8.etherc.openssl_readf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d9.etherc.diskfixbadfilenamesf BEGIN
#define DDNAME       "3func.360021d9.etherc.diskfixbadfilenamesf"
#define DDNUMB      (countT)0x360021d9
#define IDFILE      (countT)0xde0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/**/

boolT bBadOrCapF( tinS& tinP , const osTextT* postP )
{
    ZE( boolT , bBadOrCap ) ;
    for( ; *postP ; postP ++ )
    {
        if
        (
            *postP < 0x20
            ||
            *postP > 0x7f
            ||
            ( 'A' <= *postP && *postP <= 'Z' )
        )
        {
            bBadOrCap = 1 ;
            break ;
        }
        else switch( *postP )
        {
            BADcASEScHARiNfILEnAME\
            {
                bBadOrCap = 1 ;
                break ;
            }
        }
    }

    return bBadOrCap ;
}

//20170413@1406: THIS IS OBSOLETE NOW THAT FILESETS ARE USED FOR CLOUD ARCHIVAL; DISABLING THIS TO ENSURE THAT IT IS NOT USED TO MODIFY FILE NAMES; IT WORKS BUT SHOULD REMAIN DISABLED UNLESS A NEW NEED ARISES
#if defined( NEVERdEFINED )

/*1*/countT etherC::disk FixBadFileNamesF( tinS& tinP , const strokeS* const psttFolderP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttFolderP ) ;
        if( POOP ) return 0 ;
        __Z( psttFolderP[ CSpREFIX - 1 + psttFolderP->idAdam ].idAdam == '/' ) ;
        FV(flETHERfIXnAMES,flagsP) ;
        if( POOP ) return 0 ;
    }

    _IO_

    const boolT bIgnoreEtPrime = F(flagsP) & flETHERfIXnAMES_KEEPwORKINGiFfIRED ;
    etherC& etPrime = etPrimeIF( tinP ) ;

    ZE( strokeS* , psttFolderMapped ) ;
    diskMapFileNameF( tinP , psttFolderMapped , psttFolderP ) ; ___( psttFolderMapped ) ;

    ZE( countT , cBadOrCapFound ) ;
    if( !( F(flagsP) & flETHERfIXnAMES_SYSTEMpREwASH ) ) cBadOrCapFound = disk FixBadFileNamesF( tinP , psttFolderMapped , ( flagsP & ~( F(flETHERfIXnAMES_RECURSE) ) ) | flETHERfIXnAMES_FOLDERSoNLY | flETHERfIXnAMES_SYSTEMpREwASH ) ; // THIS CLEANS UP THE DIRECTORY NAMES THAT MUST BE CLEAN WHEN I RECURSE INTO THEM

    //THE JOB IS DONE FOR THE CURRENT FOLDER, EXCEPT FOR RECURSION

    TN( tSDS , "/./" ) ;
    TN( tSDDS , "/../" ) ;
    TN( tOsLikePath , osFileNameC( tinP , third , T(psttFolderMapped) ) ) ;
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    do
    {
        ZE( infoFileS* , pInfo ) ;
        diskFindFileOrDirF( tinP , pInfo , hFind , T(psttFolderMapped) ) ;
        if( pInfo && pInfo->psttIfoName )
        {
            if( pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' )
            {
                if( F(flagsP) & flETHERfIXnAMES_RECURSE && !strIdF( tinP , tSDS , pInfo->psttIfoName ) && !strIdF( tinP , tSDDS , pInfo->psttIfoName ) ) cBadOrCapFound += disk FixBadFileNamesF( tinP , pInfo->psttIfoName , flagsP ) ;
            }
            else if( !( F(flagsP) & flETHERfIXnAMES_FOLDERSoNLY ) )
            {
                const osTextT* postOsShort = thirdC::c_strrchrIF( tinP , pInfo->postOsName , '\\' ) ;
                if( postOsShort )
                {
                    postOsShort ++ ;
                    countT offShort = postOsShort - pInfo->postOsName ;

                    if( bBadOrCapF( tinP , postOsShort ) )
                    {
                        cBadOrCapFound ++ ;
                        traceF( tinP , T("invalid character found in file name.  repairing...") ) ;

                        //20150204@1508: UPPER CASE CHARACTERS ARE "PSEUDO-BAD" IN THAT AS POLICY THEY ARE CONVERTED TO LOWER CASE

                        ZE( osTextT* , postOsLongLike ) ; // MADE FROM INVALID FILE NAME, WITH INVALID CHARACTERS REPLACED WITH '?'
                        ZE( osTextT* , postOsLongNew  ) ; // MADE FROM INVALID FILE NAME, WITH INVALID CHARACTERS REPLACED WITH '.'
                        {
                            {
                                countT costa = thirdC::c_strlenIF( tinP , pInfo->postOsName ) + 1 ;
                                newF( tinP , LF , postOsLongLike , costa ) ; ___( postOsLongLike ) ;
                                newF( tinP , LF , postOsLongNew  , costa ) ; ___( postOsLongNew  ) ;
                            }
                            thirdC::c_strcpyIF( tinP , postOsLongLike , pInfo->postOsName ) ;
                            thirdC::c_strcpyIF( tinP , postOsLongNew  , pInfo->postOsName ) ;

                            countT offr = offShort ;
                            for( ; postOsLongLike[ offr ] ; offr ++ )
                            {
                                ZE( boolT , bBad ) ;
                                ZE( boolT , bCap ) ;
                                     if( 'A' <= postOsLongLike[ offr ] && postOsLongLike[ offr ] <= 'Z' ) bCap = 1 ;
                                else if( 0x20 > postOsLongLike[ offr ] || postOsLongLike[ offr ] > 0x7f ) bBad = 1 ;
                                else switch( postOsLongLike[ offr ] )
                                {
                                    //CS:CODEsYNC: 360021d9 360021d9
                                    BADcASEScHARiNfILEnAME
                                    {
                                        bBad = 1 ;
                                        break ;
                                    }
                                }

                                if( bCap ) postOsLongNew[ offr ] = (osTextT)( postOsLongNew[ offr ] + 'a' - 'A' ) ;
                                else if( bBad )
                                {
                                    postOsLongLike[ offr ] = '?' ;
                                    postOsLongNew[  offr ] = '.' ;
                                }
                            }

                            traceF( tinP , T(" [bad]: ")+T(pInfo->postOsName) ) ;
                            traceF( tinP , T("[like]: ")+T(postOsLongLike)    ) ;
                            traceF( tinP , T(" [new]: ")+T(postOsLongNew)     ) ;
                            {                

                                fileNameC fnLike( tinP , *this , T(ifFileNameC(tinP,third,postOsLongLike)) ) ;
                                patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                                
                                handleC hFind2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                do
                                {
                                    ZE( infoFileS* , pInfo2 ) ;
                                    diskFindFileOrDirF( tinP , pInfo2 , hFind2 , fnLike.pathF() , &pat ) ;
                                    if( pInfo2 )
                                    {
                                        if( bBadOrCapF( tinP , pInfo2->postOsName ) )
                                        {
                                            ZE( osTextT* , postLongWas ) ;
                                            ZE( osTextT* , postLongNew ) ;
                                                                       strMakeF( tinP , LF , postLongWas , T(pInfo2->postOsNameAlt?pInfo2->postOsNameAlt:pInfo2->postOsName) ) ; ___( postLongWas ) ;
                                            const countT costLongNew = strMakeF( tinP , LF , postLongNew , T(postOsLongNew) , 9 ) ; ___( postLongNew ) ; // EXTRA IS ALLOCATED TO ACCOMMODATE tSuffix

                                            // ONLY THE WOTH MATCHING FILE CAN BE RENAMED TO postLongNew
                                            // COLLISIONS ARE HANDLED BY UNIQUIFYING postLongNew BY APPENDING AN INTEGER

                                            IFsCRATCH
                                            {
                                                SCOOPS

                                                thirdC& thScratch = *tinP.pEtScratch ;

                                                ZE( countT , idDupLath ) ;
                                                ZE( boolT , bDone ) ;
                                                countT cTry = TUCK ;
                                                while( cTry -- )
                                                {
                                                    thScratch.dosMoveF( tinP , postLongNew , postLongWas , 1 ) ;
                                                    if( !POOP )
                                                    {
                                                        bDone = 1 ;
                                                        break ;
                                                    }
                                                    else
                                                    {
                                                        POOPR
                                                        postLongNew[ costLongNew ] = 0 ;
                                                        TN( tSuffix , "." ) ; tSuffix += TF3(++idDupLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;
                                                        thirdC::c_strcatIF( tinP , postLongNew , tSuffix ) ;
                                                    }
                                                }
                                                
                                                if( !bDone ) traceF( tinP , T("could not rename file: ")+T(pInfo->postOsName) ) ;
                                            }
                                            delF( tinP , postLongWas ) ;
                                            delF( tinP , postLongNew ) ;
                                        }
                                    }
                                    DEL( pInfo2 ) ;
                                }
                                while( ~hFind2 ) ;
                            }

                            delF( tinP , postOsLongLike ) ;
                            delF( tinP , postOsLongNew  ) ;
                        }
                    }
                }
            }
        }
        DEL( pInfo ) ;
    }
    while( ~hFind && ( !etPrime || bIgnoreEtPrime ) ) ;
    delF( tinP , psttFolderMapped ) ;

    return cBadOrCapFound ;
}

#endif


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021d9.etherc.diskfixbadfilenamesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021da.etherc.strfromjsonf BEGIN
#define DDNAME       "3func.360021da.etherc.strfromjsonf"
#define DDNUMB      (countT)0x360021da
#define IDFILE      (countT)0xde1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::strFromJsonF( tinS& tinP , strokeS*& psttP , const strokeS* const psttFromP )/*1*/
{
    strTrimF(    tinP , psttP , psttFromP , 0 , T("\"") ) ; ___( psttP ) ;
    strReplaceF( tinP , psttP , 0 , T("\\/") , T("/") ) ; ___( psttP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021da.etherc.strfromjsonf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021db.etherc.strcompareencodedf BEGIN
#define DDNAME       "3func.360021db.etherc.strcompareencodedf"
#define DDNUMB      (countT)0x360021db
#define IDFILE      (countT)0xde2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/sCountT etherC::strCompareEncodedF( tinS& tinP , const byteT* const pb1P , const byteT* const pb2P )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( pb1P ) ;
        __Z( pb2P ) ;
        if( POOP ) return 0 ;
        __( ((countT*)pb1P)[ 0 ] != FINGERnEG_STReNCODEf && ((countT*)pb1P)[ 0 ] != FINGERnEGoLD_strEncodeF ) ;
        __( ((countT*)pb2P)[ 0 ] != FINGERnEG_STReNCODEf && ((countT*)pb2P)[ 0 ] != FINGERnEGoLD_strEncodeF ) ;
        __( !((countT*)pb1P)[ 1 ] ) ;
        __( !((countT*)pb2P)[ 1 ] ) ;
        if( POOP ) return 0 ;
    }

    const byteT* ppb[] = { pb1P , pb2P } ;

    ZE( countT , offbi1 ) ; //BIT OFFSET OF NEXT READ
    ZE( countT , offbi2 ) ; //BIT OFFSET OF NEXT READ
    countT* pOffbi[] = { &offbi1 , &offbi2 } ;

    strokeS sttWoth1 ;
    strokeS sttWoth2 ;
    strokeS* ppsttWoth[] = { &sttWoth1 , &sttWoth2 } ;

    for( countT offs = 0 ; offs < sizeof ppb / sizeof ppb[ 0 ] ; offs ++ )
    {
        {
            countT finger = valueInF( ppb[ offs ] , *pOffbi[ offs ] , sizeof( countT ) * SB ) ;
            __( finger != FINGERnEG_STReNCODEf && finger != FINGERnEGoLD_strEncodeF ) ;
            valueInF( ppb[ offs ] , *pOffbi[ offs ] , sizeof( countT ) * SB ) ;
        }

        for( countT offi = 0 ; offi < CSpREFIX ; offi ++ )
        {
            strokeS stti ;
            getStrokeS( stti , ppb[ offs ] , *pOffbi[ offs ] ) ;

            switch( offi ) //CS:CODEsYNC: strCompareEncodedF 11200035
            {
                case 0 : { __( stti.idCaste - sc_PREFIXlENGTH  ) ; *ppsttWoth[ offs ] = stti ; break ; }
                case 1 : { __( stti.idCaste - sc_PREFIXuTILITY )                             ; break ; }
                case 2 : { __( stti.idCaste - sc_PREFIXeXTRA   )                             ; break ; }
            }
        }
    }

    ZE( sCountT , sgn ) ;
    if( !POOP)
    {
        countT cToDo = sttWoth1.idAdam < sttWoth2.idAdam
            ? sttWoth1.idAdam
            : sttWoth2.idAdam
        ;

        while( !sgn && cToDo -- )
        {
            strokeS stti1 ;
            strokeS stti2 ;
            getStrokeS( stti1 , pb1P , offbi1 ) ;
            getStrokeS( stti2 , pb2P , offbi2 ) ;
                       sgn = stti1.idCaste - stti2.idCaste ;
            if( !sgn ) sgn = stti1.idAdam  - stti2.idAdam  ;
            if( !sgn ) sgn = stti1.cNote   - stti2.cNote   ;

            if( !sgn && stti1.idCaste == sc_cADAMeXPORT )     // EITHER stti1 OR stti2 CAN BE INSPECTED SINCE BOTH MUST BE IDENTICAL
            {
                valueInF( pb1P , offbi1 , ( SB - offbi1 ) % SB ) ;
                valueInF( pb2P , offbi2 , ( SB - offbi2 ) % SB ) ;

                countT csImage1 = stti1.idAdam ;
                countT csImage2 = stti2.idAdam ;
                countT cbImage1 = csImage1 * sizeof( strokeS ) ;
                countT cbImage2 = csImage2 * sizeof( strokeS ) ;

                countT cbImageMin = cbImage1 < cbImage2
                    ? cbImage1
                    : cbImage2
                ;

                sgn = thirdC::c_memcmpIF( tinP , pb1P + offbi1 / SB , pb2P + offbi2 / SB , cbImageMin ) ;
                if( !sgn ) sgn = cbImage1 - cbImage2 ;

                offbi1 += cbImage1 * SB ;
                offbi2 += cbImage2 * SB ;
                cToDo  -= csImage1      ; // THIS IS SAFE BECAUSE IF THE IMAGE SIZES ARE NOT THE SAME SIZE THEN sgn IS NONZE SO WILL NOT ITERATE AGAIN
            }
        }

        if( !sgn ) sgn = sttWoth1.idAdam - sttWoth2.idAdam ;
    }

    return sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021db.etherc.strcompareencodedf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021dc.etherc.querysettingf BEGIN
#define DDNAME       "3func.360021dc.etherc.querysettingf"
#define DDNUMB      (countT)0x360021dc
#define IDFILE      (countT)0xde3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::querySettingF( tinS& tinP , strokeS*& psttP , const strokeS* const psttKeyP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP    ) ;
        __Z(  psttKeyP ) ;
        if( POOP ) return ;
    }

    ZE( boolT , cFilesFound )
    {
        osTextT postTiny[] = "kv.settings.ipdos" ;

        osTextT postPath[ TUCK << 1 ] ;
        thirdC::postPathStateSpaceIF( tinP , postPath , sizeof postPath , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
        __Z( *postPath ) ;

        if( !POOP )
        {
            ifFileNameC iffn( tinP , third , postPath ) ;

            fileNameC fnLike( tinP , *this , T(iffn)+T(postTiny)+T(".*") ) ;
            patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
            
            ZE( strokeS* , pstt1f ) ;
            cFilesFound += diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat , 0 , 0 , 0 , 8 ) ; ___( pstt1f ) ;
            delF( tinP , pstt1f ) ;
        }
    }

    if( cFilesFound )
    {
        IFsCRATCH
        {
            SCOOPS

            ZE( osTextT* , postKey ) ;
            countT costKey = strMakeF( tinP , LF , postKey , psttKeyP ) ; ___( postKey ) ;
            for( countT offr = 0 ; offr < costKey ; offr ++ ) postKey[ offr ] = reverseBitsF( postKey[ offr ] ) ; // KEYS ARE ASSUMED TO BE REGISTERED IN REVERSED BIT ORDER SO THAT WALKING kv WILL PRESENT THE KEYS IN THE NORMAL COLLATION ORDER

            keyValuePairsC kv( tinP , "kv.settings.ipdos" , flKEYvALUEpAIRSc_null  , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
            pageC page = kv( tinP , postKey , 0 , thirdC::c_strlenIF( tinP , postKey ) * SB ) ;
            delF( tinP , postKey ) ;

            const osTextT* postv = page ;

                 if( POOP  ) POOPR
            else if( postv ) { strMakeFromOsTextF( tinP , psttP , postv ) ; ___( psttP ) ; }
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021dc.etherc.querysettingf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021dd.etherc.walksettingsf BEGIN
#define DDNAME       "3func.360021dd.etherc.walksettingsf"
#define DDNUMB      (countT)0x360021dd
#define IDFILE      (countT)0xde4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::walkSettingsF( tinS& tinP , byteT* pbBufferP , countT cbBufferP , countT& cNestP , ifc2FT pCBFP , countT* pcArgP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( pbBufferP ) ;
        __Z( cbBufferP ) ;
        __NZ( cNestP ) ;
        if( POOP ) return ;
    }

    osTextT postTiny[] = "kv.settings.ipdos" ;

    osTextT postPath[ TUCK << 1 ] ;
    thirdC::postPathStateSpaceIF( tinP , postPath , sizeof postPath , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
    __Z( *postPath ) ;

    if( !POOP )
    {
        countT costPath = thirdC::c_strlenIF( tinP , postPath ) ;

        thirdC::c_strcatIF( tinP , postPath , "kv.settings.ipdos.bitTreeC.napkins.00000000.napkinsC.napkinC" ) ;
        ifFileNameC ifFile1( tinP , third , postPath ) ;

        postPath[ costPath ] = 0 ;
        thirdC::c_strcatIF( tinP , postPath , "kv.settings.ipdos.jotC.data.booksC.1.book.00000001.00000001.bookC" ) ;
        ifFileNameC ifFile2( tinP , third , postPath ) ;

        postPath[ costPath ] = 0 ;
        thirdC::c_strcatIF( tinP , postPath , "kv.settings.ipdos.jotC.index.booksC.1.book.00000001.00000001.bookC" ) ;
        ifFileNameC ifFile3( tinP , third , postPath ) ;

        boolT bFile1 = diskFileExistsF( tinP , T(ifFile1) ) ;
        boolT bFile2 = diskFileExistsF( tinP , T(ifFile2) ) ;
        boolT bFile3 = diskFileExistsF( tinP , T(ifFile3) ) ;

        if( bFile1 && bFile2 && bFile3 )
        {
            IFsCRATCH                   //U:: DO I REALLY WANT THIS USAGE OF etScratch?
            {                           //U:: CONJ: NO ; THIS SHOULD JUST FAIL
                SCOOPS

                stackC stThis(     tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY                    , ifcSTACKtYPE_countT ) ;
                stackC stKidsDone( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY | flSTACKc_ALLOWzE , ifcSTACKtYPE_countT ) ;

                keyValuePairsC kv( tinP , "kv.settings.ipdos" , flKEYvALUEpAIRSc_null  , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;

                kv.walkF( tinP , stThis , stKidsDone , pbBufferP , cbBufferP , cNestP , pCBFP , pcArgP ) ;

                if( POOP )         //20200425@1952: ADDED WITHOUT ANALYSIS TO ENSURE THAT etScratch IS NOT LEFT IN AN IMPOTENT STATE
                {                   //U:: CONJ: I SHOULD NOT BE USING etScratch HERE AT ALL
                                    //U:: CONJ: THIS CODE DOES NOT USE etScratch AND SO THE IFsCRATCH SCOOPS SHOULD BE ELIMINATED
                    POOPR
                    __1
                }
            }
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021dd.etherc.walksettingsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021de.etherc.openssl_wavebyef BEGIN
#define DDNAME       "3func.360021de.etherc.openssl_wavebyef"
#define DDNUMB      (countT)0x360021de
#define IDFILE      (countT)0xde5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/voidT etherC::openSsl_waveByeF( tinS& tinP , const handleC& hWrapperP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( ~hWrapperP ) ;
        if( POOP ) return ;
    }

    _IO_

    thirdC::openSsl_waveByeIF( tinP , hWrapperP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021de.etherc.openssl_wavebyef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021df.etherc.strfilematchf BEGIN
#define DDNAME       "3func.360021df.etherc.strfilematchf"
#define DDNUMB      (countT)0x360021df
#define IDFILE      (countT)0xde6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i return true iff psttP satisfies the pattern specified in psttLikeP
 the pattern is a string containing '*', '?', and other strokes
 '*' matches ze or more strokes
 '?' matches exactly wo strokes
 any other stroke matches only itself
i am intended to produce exactly the same result that would be produced by the base operating system
 i was tested using Windows 7
*/

/**/

/*1*/boolT etherC::strFileMatchF( tinS& tinP , const strokeS* const psttLikeP , const strokeS* const psttP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttLikeP ) ;
        __Z( psttP ) ;
        if( POOP ) return 0 ;
        __Z( *psttLikeP ) ;
        if( POOP ) return 0 ;
    }

    //traceF( tinP , T("[psttLikeP]: ")+T(psttLikeP) ) ;
    //traceF( tinP , T("[psttP]    : ")+T(psttP    ) ) ;

    boolT bMatch = 1;

    ZE( countT , cOk ) ;

    ZE( strokeS* , pstt1w ) ;
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    strWordsF( tinP , pstt1w , psttLikeP , sttq , T("*?") , flSTRwORDS_DELIMITERS ) ; ___( pstt1w ) ;
    TN( tStar , "*" ) ;
    TN( tQuestion , "?" ) ;
    ZE( boolT , bArmedStar ) ;
    ZE( countT , cArmedQuestion ) ;
    FORsTRINGSiN1( pstt1w )
    {
        //traceF( tinP , T("like: ")+T(psttc1) ) ;

        ZE( countT , cWild ) ;                                                      // THIS IS ONLY USED AS A BOOLEAN
        if( strIdF( tinP , tStar , psttc1 ) ) cWild = bArmedStar = 1 ;              // MULTIPLE ASTERISKS ARE REDUNDANT AND ONLY WO WILL BE COUNTED

        {
            countT idfq = 1 ;
            while( idfq && strIdF( tinP , 0 , flSTRmATCH_null , idfq , sttq , tQuestion , psttc1 ) ) { cArmedQuestion ++ ; cWild ++ ; }
        }

        if( !cWild )
        {
            if( psttP->idAdam - cOk < psttc1->idAdam )                              // IF NOT ENOUGH THEN QUIT
            {
                bMatch = 0 ;
                break ;
            }
            else
            {
                countT idf = cOk + 1 ;
                countT idHit = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , psttc1 , psttP ) ;            

                countT cWildEat = idHit >= cOk + 1
                    ?             idHit -  cOk - 1
                    :             0
                ;

                if
                (
                    !idHit                                                          // NOT FOUND
                    ||
                    cWildEat < cArmedQuestion                                       // NOT ENOUGH WILD EATEN
                    ||
                    !bArmedStar && cArmedQuestion < cWildEat                        // TOO MANY WILD EATEN
                )
                {
                    bMatch = 0 ;
                    break ;
                }
                else cOk = idf ? idf - 1 : psttP->idAdam ;
            }

            cArmedQuestion = bArmedStar = 0 ;
        }
    }
    delF( tinP , pstt1w ) ;

    countT cWildRemain = psttP->idAdam - cOk ;

    if
    (
        cWildRemain < cArmedQuestion                                                // NOT ENOUGH WILD REMAIN
        ||
        !bArmedStar && cArmedQuestion < cWildRemain                                 // TOO MANY WILD REMAIN
    )
    bMatch = 0 ;

    return bMatch ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021df.etherc.strfilematchf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e0.etherc.snapwordf BEGIN
#define DDNAME       "3func.360021e0.etherc.snapwordf"
#define DDNUMB      (countT)0x360021e0
#define IDFILE      (countT)0xde7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
arguments
 tinP
 pcWordP
  calling code should use pcWordP (singular) when calling me and pcWordsP (plural) when calling snapWordsF
*/
/**/

/*1*/countT etherC::snapWordF( tinS& tinP , countT*& pcWordP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( pcWordP ) ;
        if( POOP ) return 0 ;
    }

    bookC& bkWord = processGlobal3S::_processGlobal3I_IF().bksWord.bookNowF() ; //A:ASSUME: bksWords.cKeepInactive IS 0 SO THE CURRENT BOOK WILL REMAIN OPEN

    const byteT* const pbBody = bkWord.pbBodyF() ;
    const countT       cbBody = bkWord.cbBodyF() ;
    const countT       cWord  = cbBody / sizeof( countT ) ;

    if( cWord * sizeof( countT ) != cbBody ) { BLAMMO ; }

    newF( tinP , LF , pcWordP , cWord ) ; ___( pcWordP ) ;
    __Z( pcWordP ) ;

    if( POOP ) return 0 ;
    else
    {
        unwrapCircleIF( tinP , (byteT*)pcWordP , cbBody , pbBody , cbBody , bkWord.cbUsedF() ) ;
        return cWord ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e0.etherc.snapwordf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e1.etherc.snapwordsf BEGIN
#define DDNAME       "3func.360021e1.etherc.snapwordsf"
#define DDNUMB      (countT)0x360021e1
#define IDFILE      (countT)0xde8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
arguments
 tinP
 pcWordsP
  calling code should use pcWordsP (plural) when calling me and pcWordP (singular) when calling snapWordF
*/
/**/

/*1*/countT etherC::snapWordsF( tinS& tinP , countT*& pcWordsP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( pcWordsP ) ;
        if( POOP ) return 0 ;
    }

    bookC& bkWords = processGlobal3S::_processGlobal3I_IF().bksWords.bookNowF() ; //A:ASSUME: bksWordss.cKeepInactive IS 0 SO THE CURRENT BOOK WILL REMAIN OPEN

    const byteT* const pbBody = bkWords.pbBodyF() ;
    const countT       cbBody = bkWords.cbBodyF() ;
    const countT       cWords = cbBody / sizeof( countT ) ;

    if( cWords * sizeof( countT ) != cbBody ) { BLAMMO ; }

    newF( tinP , LF , pcWordsP , cWords ) ; ___( pcWordsP ) ;
    __Z( pcWordsP ) ;

    if( POOP ) return 0 ;
    else
    {
        unwrapCircleIF( tinP , (byteT*)pcWordsP , cbBody , pbBody , cbBody , bkWords.cbUsedF() ) ;
        return cWords ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e1.etherc.snapwordsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e2.etherc.diskrenametohashf BEGIN
#define DDNAME       "3func.360021e2.etherc.diskrenametohashf"
#define DDNUMB      (countT)0x360021e2
#define IDFILE      (countT)0xde9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/**/

/*1*/countT etherC::diskRenameToHashF( tinS& tinP , const strokeS* const psttFolderP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttFolderP ) ;
        if( POOP ) return 0 ;
        __Z( psttFolderP[ CSpREFIX - 1 + psttFolderP->idAdam ].idAdam == '/' ) ;
        FV(flETHERrENAMEtOhASH,flagsP) ;
        if( POOP ) return 0 ;
    }

    _IO_

    const boolT bIgnoreEtPrime = F(flagsP) & flETHERrENAMEtOhASH_KEEPwORKINGiFfIRED ;
    etherC& etPrime = etPrimeIF( tinP ) ;

    ZE( strokeS* , psttFolderMapped ) ;
    diskMapFileNameF( tinP , psttFolderMapped , psttFolderP ) ; ___( psttFolderMapped ) ;

    //FILE NAME FORMAT: !ideafarm.9.2.00000000.00000001.

    // EXAMPLE: !ideafarm.6.19991228@0000.001.000b3751.c44d5e6f.2f9afda7.scanner.!.19991228@0000.notarized.declaration.of.legal.name.change.0600x.jpg
    // EXAMPLE: !ideafarm.6.19981028@0000.001.!.day.title.ttt
    // RECIPE
    //  
    //  LOOK FOR OO TIMES AFTER ".!."
    //   IF FIND 2 USE THEM IN THE ORDER FOUND, EVEN IF NOT IN ORDER
    //   IF FIND 1 THEN USE IT AND FOLLOW IT WITH THE FILE TIME
    //   IF FIND 0 THEN USE TIME AFTER ".6." FOR WOTH TIME AND FILE TIME FOR OOTH TIME

    //  yyyymmdd hhmm
    // "20130510@2359"
    TN( tPatternDateAtTime , "" ) ; tPatternDateAtTime =

        T("")
        +S3(7,sc_ccSSSrEPEAT,7)
        +S2(sa_SSSoR,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
        +S2(sa_SSSoReND,sc_ccSSS)
        +T("@")
        +S2(sa_SSSoR,sc_ccSSS)
            +T("012xz")
        +S2(sa_SSSoReND,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +S2(sa_SSSoR,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
        +S2(sa_SSSoReND,sc_ccSSS)

    ;

    //   yyyymmdd hhmm yyyymmdd hhmm
    // ".20130510@2359.20130510@2359."
    TN( tSssDotDateAtTimeDotDateAtTimeDot , "" ) ; tSssDotDateAtTimeDotDateAtTimeDot =

        T("")
        +S2(sa_SSSaND,sc_ccSSS)
            +T(".")
            +tPatternDateAtTime
            +T(".")
            +tPatternDateAtTime
            +T(".")
        +S2(sa_SSSaNDeND,sc_ccSSS)

    ;

    //   yyyymmdd hhmm
    // ".20130510@2359."
    TN( tSssDotDateAtTimeDot , "" ) ; tSssDotDateAtTimeDot =

        T("")
        +S2(sa_SSSaND,sc_ccSSS)
            +T(".")
            +tPatternDateAtTime
            +T(".")
        +S2(sa_SSSaNDeND,sc_ccSSS)

    ;

    ZE( countT , cRenamed ) ;
    TN( tDot , "." ) ;
    TN( tSlash , "/" ) ;
    TN( tSDS , "/./" ) ;
    TN( tSDDS , "/../" ) ;
    TN( tOsLikePath , osFileNameC( tinP , third , T(psttFolderMapped) ) ) ;
    TN( tNewPrefix , "!ideafarm.9.2.00000000.00000001." ) ;
    TN( tDotTypeData , ".data" ) ;
    TN( tDotTypeMetaDotHashedName , ".meta.hashedname" ) ;
    TN( tDotTypeMetaDotCurrentName , ".meta.currentname" ) ;
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    do
    {
        ZE( infoFileS* , pInfo ) ;
        diskFindFileOrDirF( tinP , pInfo , hFind , T(psttFolderMapped) ) ;
        if( pInfo && pInfo->psttIfoName )
        {
            if( pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' )
            {
                if( F(flagsP) & flETHERrENAMEtOhASH_RECURSE && !strIdF( tinP , tSDS , pInfo->psttIfoName ) && !strIdF( tinP , tSDDS , pInfo->psttIfoName ) ) cRenamed += diskRenameToHashF( tinP , pInfo->psttIfoName , flagsP ) ;
            }
            else
            {
                TN( tDateAtTimeFromFileMeta , "" ) ;
                {
                    ZE( countT , ms ) ;
                    ZE( countT , ss ) ;
                    ZE( countT , mm ) ;
                    ZE( countT , hh ) ;
                    ZE( countT , da ) ;
                    ZE( countT , mo ) ;
                    ZE( sCountT , ye ) ;
                    ZE( countT , dow ) ;
                    osTimeToOldTimeF( tinP , ms , ss , mm , hh , da , mo , ye , dow , pInfo->timeWritten1 , pInfo->timeWritten2 ) ;
    
                    tDateAtTimeFromFileMeta =
    
                         TF4(1+ye,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,4,0xa)
                        +TF4(1+mo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)
                        +TF4(1+da,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)
                        +S1C('@')
                        +TF4(hh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)
                        +TF4(mm,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)
    
                    ;
                }

                TN( tPath , "" ) ;
                TN( tShort , "" ) ;
                {
                    ZE( strokeS* , psttPath ) ;
                    ZE( strokeS* , psttShort ) ;
                    strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                    tPath  = T(psttPath) ;
                    tShort = T(psttShort) ;
                    delF( tinP , psttPath ) ;
                    delF( tinP , psttShort ) ;
                }

                TN( tDotExt , "" ) ;
                {
                    ZE( strokeS* , psttnu ) ;
                    ZE( strokeS* , psttDotExt ) ;
                    strBisectF( tinP , psttnu , psttDotExt , tShort , tDot , - 1 , flSTRbISECT_PREPENDdELIMITER ) ; ___( psttnu ) ; ___( psttDotExt ) ;
                    tDotExt = T(psttDotExt) ;
                    delF( tinP , psttnu ) ;
                    delF( tinP , psttDotExt ) ;
                }

                if( tShort.csF( tinP ) )
                {
                    if( 1 != strIdF( tinP , tNewPrefix , tShort ) )
                    {
                        cRenamed ++ ;

                        TN( tTimePair , "" ) ;
                        TN( tSequenceNumber , "001" ) ;
                        {
                            countT idf = 1 ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                            TN( tDot , "." ) ;
                            TN( tDotHeyDot , ".!." ) ;
                            TN( tPrefix6   , "!ideafarm.6." ) ;

                            countT idHit = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tPrefix6 , tShort ) ;

                            if( !idHit )                    // NOT A VALID PREFIX
                            {
                                tTimePair = tDot+tDateAtTimeFromFileMeta+tDot+tDateAtTimeFromFileMeta+tDot ;
                            }
                            else                            // I HAVE A PREFIX
                            {
                                TN( tTimeFromPrefix , "" ) ;
                                {
                                    ZE( strokeS* , psttTimeFromPrefix ) ;
                                    countT idl = idf + 0xc ;
                                    strSubstringF( tinP , psttTimeFromPrefix , idf , idl , tShort ) ; ___( psttTimeFromPrefix ) ;
                                    tTimeFromPrefix = T(psttTimeFromPrefix) ;
                                    delF( tinP , psttTimeFromPrefix ) ;
                                }

                                TN( tSequenceNumberFromPrefix , "" ) ;
                                {
                                    ZE( strokeS* , psttSequenceNumberFromPrefix ) ;
                                    countT idl = ++ idf + 2 ;
                                    strSubstringF( tinP , psttSequenceNumberFromPrefix , idf , idl , tShort ) ; ___( psttSequenceNumberFromPrefix ) ;
                                    tSequenceNumberFromPrefix = T(psttSequenceNumberFromPrefix) ;
                                    delF( tinP , psttSequenceNumberFromPrefix ) ;
                                }
                                tSequenceNumber = tSequenceNumberFromPrefix ;

                                idHit = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tDotHeyDot , tShort ) ;
                                if( !idHit )
                                {
                                    tTimePair = tDot+tTimeFromPrefix+tDot+tDateAtTimeFromFileMeta+tDot ;
                                }
                                else                        // I HAVE A DOT HEY DOT
                                {
                                    countT idfSave = -- idf ;                             
                                    countT idHit2 = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tSssDotDateAtTimeDotDateAtTimeDot , tShort ) ;
                                    if( idHit2 )            // I HAVE A DOUBLE TIME AFTER HEY                                                  
                                    {
                                        ZE( strokeS* , psttDoubleTime ) ;
                                        countT idl = idf - 1 ;
                                        countT idf = idHit2 ;
                                        strSubstringF( tinP , psttDoubleTime , idf , idl , tShort ) ; ___( psttDoubleTime ) ;
                                        tTimePair = T(psttDoubleTime) ;
                                        delF( tinP , psttDoubleTime ) ;
                                    }
                                    else
                                    {
                                        idf = idfSave ;
                                        idHit2 = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tSssDotDateAtTimeDot , tShort ) ;
                                        if( idHit2 )            // I HAVE A SINGLE TIME AFTER HEY                                                  
                                        {
                                            ZE( strokeS* , psttSingleTime ) ;
                                            countT idl = idf - 1 ;
                                            countT idf = idHit2 ;
                                            strSubstringF( tinP , psttSingleTime , idf , idl , tShort ) ; ___( psttSingleTime ) ;
                                            tTimePair = T(psttSingleTime)+tDateAtTimeFromFileMeta+tDot ;
                                            delF( tinP , psttSingleTime ) ;
                                        }
                                        else                    // THERE IS NO TIME AFTER HEY
                                        {
                                            tTimePair = tDot+tTimeFromPrefix+tDot+tDateAtTimeFromFileMeta+tDot ;
                                        }
                                    }
                                }
                            }

                            if( tTimePair.csF( tinP ) > 2 )
                            {
                                ZE( strokeS* , psttSansDots ) ;
                                countT idf = 2 ;
                                countT idl = tTimePair.csF( tinP) - 1 ;
                                strSubstringF( tinP , psttSansDots , idf , idl , tTimePair ) ; ___( psttSansDots ) ;
                                tTimePair = T(psttSansDots) ;
                                delF( tinP , psttSansDots ) ;
                            }
                        }

                        TN( tNewFileData , "" ) ;
                        TN( tNewFileMetaHashedName , "" ) ;
                        TN( tNewFileMetaCurrentName , "" ) ;
                        {
                            TN( tHash , "" ) ;
                            {
                                hasherC hasher( tinP , *this ) ;
                                hasher.eatF( tinP , tShort , tShort.csF( tinP ) ) ;

                                ZE( strokeS* , psttHash ) ;
                                hasher.queryStringF( tinP , psttHash ) ; ___( psttHash ) ;
                                tHash = T(psttHash) ;
                                delF( tinP , psttHash ) ;
                            }

                            ZE( countT , idSeq ) ;
                            do
                            {
                                TN( tPart1 , "" ) ; tPart1 = tPath+tNewPrefix+tTimePair+tDot+tHash+tDot+TF3(++idSeq,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,3) ;

                                //U::20200410@2003: CONJ: THIS CODE IS INCOMPLETE ; THERE ARE NOW MORE META FILES IN EACH FILE GROUP

                                tNewFileData            = tPart1+tDotTypeData+tDotExt ;
                                tNewFileMetaHashedName  = tPart1+tDotTypeMetaDotHashedName ;
                                tNewFileMetaCurrentName = tPart1+tDotTypeMetaDotCurrentName ;
                            }
                            while
                            (
                                   diskFileExistsF( tinP , tNewFileData            )
                                || diskFileExistsF( tinP , tNewFileMetaHashedName  )
                                || diskFileExistsF( tinP , tNewFileMetaCurrentName )
                            ) ;
                        }

                        traceF( tinP , tNewFileData+T("    ")+T(pInfo->psttIfoName) , flTRACE_null , ifcIDtRACEdIVERT_8 ) ;

                        diskMoveFileOrDirF( tinP , tNewFileData            , pInfo->psttIfoName ) ;
                        boxPutF(            tinP , tNewFileMetaHashedName  , tShort , tShort.csF( tinP ) ) ;
                        boxPutF(            tinP , tNewFileMetaCurrentName , tShort , tShort.csF( tinP ) ) ;
                    }
                }
            }
        }
        DEL( pInfo ) ;
    }
    while( ~hFind && ( !etPrime || bIgnoreEtPrime ) ) ;
    delF( tinP , psttFolderMapped ) ;

    return cRenamed ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e2.etherc.diskrenametohashf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e3.etherc.tracepooltalliesf BEGIN
#define DDNAME       "3func.360021e3.etherc.tracepooltalliesf"
#define DDNUMB      (countT)0x360021e3
#define IDFILE      (countT)0xdea


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/**/

/*1*/voidT etherC::tracePoolTalliesF( tinS& tinP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
    }

    _IO_

    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )
    {
        ZE( const countT* , pczLever ) ;
        switchC swTally( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , *(const countT**)&pczLever , 0 , 4 * sizeof( countT ) ) ;
        PUSE.reportF( tinP , pczLever , swTally ) ;

        ZE( countT , cFree ) ;
        ZE( countT , cbFree ) ;
        ZE( countT , cOwned ) ;
        ZE( countT , cbOwned ) ;
        stackC stSort( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_countT ) ;
        {
            countT cFlavors = swTally.cFlavorsF( tinP ) ;
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            {
                pczLever = (countT*)swTally.leverF( tinP , idf ) ;

                countT* pcTally = &(countT&)swTally ;

                ZE( countT* , pcSort ) ;
                newF( tinP , LF , pcSort , 8 ) ; ___( pcSort ) ;

                if( pcSort )                            // IF DROP IS OWNED                             IF DROP IS AVAILABLE (NOT OWNED)
                {                                       //
                    pcSort[ 0 ] = pcTally[ 1 ] ;        // TOTAL BYTES                                  SAME
                    pcSort[ 1 ] = pcTally[ 0 ] ;        // NUMBER OF DROPS (ALLOCATIONS)                SAME
                    pcSort[ 2 ] = pcTally[ 2 ] ;        // MINIMUM DROP SIZE                            -1
                    pcSort[ 3 ] = pcTally[ 3 ] ;        // MAXIMUM DROP SIZE                            -1
                    pcSort[ 4 ] = pczLever[ 0 ] ;       // IDlINE                                       -1
                    pcSort[ 5 ] = pczLever[ 1 ] ;       // IDIfILE                                      -1
                    pcSort[ 6 ] = pczLever[ 2 ] ;       // IDlINE2                                      CBsLOT
                    pcSort[ 7 ] = pczLever[ 3 ] ;       // IDIfILE2                                     CsLOTS

                    if( pcTally[ 2 ] == -1 )    // IF FREE
                    {
                        cFree   += pcTally[ 0 ] ;
                        cbFree  += pcTally[ 1 ] ;
                    }
                    else
                    {
                        cOwned  += pcTally[ 0 ] ;
                        cbOwned += pcTally[ 1 ] ;
                    }

                    stSort.sinkF( tinP , countTC() , pcSort , flSTACKsINK_null , 0 , 1 ) ;
                }
            }
        }

        traceF( tinP , T("pool tallies for the current pool:    ")+T(PUSE.postNameF(tinP)) , flTRACE_null ) ;

        TN( tcr , "\r\n" ) ;
        {
            ZE( strokeS* , psttr ) ;
            strMakeF( tinP , LF , psttr , T("\r\ncOwned        : ")+TF2(cOwned,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr     , TUCK << 2 ) ; ___( psttr ) ;
            strFuseF( tinP , psttr , T(    "cFree         : ")+TF2(cFree,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr     ) ;
            strFuseF( tinP , psttr , T(    "cTotal        : ")+TF2(cOwned+cFree,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr ) ;
            strFuseF( tinP , psttr , T(    "cOwnedPerTuck : ")+TF2( (countT)( (measureT)cOwned * TUCK / (measureT)( cOwned+ cFree ) ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr+tcr ) ;


            strFuseF( tinP , psttr , T(    "cbOwned       : ")+TF2(cbOwned,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr ) ;
            strFuseF( tinP , psttr , T(    "cbFree        : ")+TF2(cbFree ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr ) ;
            strFuseF( tinP , psttr , T(    "cbTotal       : ")+TF2(cbOwned+cbFree,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr ) ;
            strFuseF( tinP , psttr , T(    "cbOwnedPerTuck: ")+TF2( (countT)((measureT)cbOwned * TUCK / (measureT)(cbOwned+cbFree ) ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr+tcr ) ;

            strFuseF( tinP , psttr , T("owned:      bytes       #slots      minsize     maxsize     file        line        file2       line2\r\nfree:       bytes       #slots      ffffffff    ffffffff    ffffffff    ffffffff    cbSlot      cSlots\r\n\r\n") ) ; ___( psttr ) ;
            traceF( tinP , psttr , flTRACE_NOpREFIX|flTRACE_KEEPcRlF ) ;
            delF( tinP , psttr ) ;
        }

        TN( tb4 , "    " ) ;
        while( stSort )
        {
            ZE( strokeS* , psttr ) ;
            strMakeF( tinP , LF , psttr , TF3(stSort,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4 , TUCK ) ;
            ZE( countT* , pcSort ) ;
            stSort >> pcSort ;
            for( countT offs = 0 ; offs < 8 ; offs ++ ) strFuseF( tinP , psttr , TF3(pcSort[offs],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4 ) ;
            traceF( tinP , psttr , flTRACE_NOpREFIX ) ;
            delF( tinP , psttr ) ;
            delF( tinP , pcSort ) ;
        }
    }
    THREADmODE3rESTORE
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e3.etherc.tracepooltalliesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e4.etherc.strFromIdJotF BEGIN
#define DDNAME       "3func.360021e4.etherc.strFromIdJotF"
#define DDNUMB      (countT)0x360021e4
#define IDFILE      (countT)0xdeb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i retrieve a string by searching the jotC instances registered for this thread
*/

/**/

/*1*/voidT etherC::strFromIdJotF( tinS& tinP , strokeS*& psttP , const countT idJotP , const countT cbJotStringDecodePrefixP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        __Z( idJotP ) ;
        __Z( idJotP & NM_HIGH ) ;   // I WOULD WORK AOK BUT COULD SUFFER A FALSE POSITIVE HIT, CAUSING UNDEFINED BEHAVIOR BY strDecodeF.  SO TO IMPOSE DISCIPLINE ON MY CALLER, I REQUIRE THE HIGH NIBBLE TO ENSURE THAT I ONLY TRY TO USE THE INTENDED jotC INSTANCE
        if( POOP ) return ;
    }

    _IO_

    IFsCRATCH
    {
        SCOOPS

        for( countT offr = 0 ; offr < CsLOTSjOTrEGISTRY ; offr ++ )
        {
            if( tinP.ppJot[ offr ] )
            {
                jotC& jc = *tinP.ppJot[ offr ] ;
                boolT  bTagOk = !( idJotP & NM_HIGH ) || ( idJotP & NM_HIGH ) == jc.tagHighNibbleF() ;
                if( bTagOk )
                {
                    countT idJotNaked = idJotP - jc.tagHighNibbleF() ;
                    if( idJotNaked && idJotNaked <= jc.cElementsF() )
                    {
                        pageC pageHe = jc[ idJotP ] ;

                        const byteT* pbEncodedHe = pageHe ;
                        countT       cbEncodedHe = pageHe ;

                        if( !pbEncodedHe || !cbEncodedHe ) continue ;
                        else
                        {
                            tinP.pEtScratch->strDecodeF( tinP , psttP , pbEncodedHe + cbJotStringDecodePrefixP ) ; ___( psttP ) ;
                            if( POOP )
                            {
                                POOPR
                                tinP.pEtScratch->delF( tinP , psttP ) ;
                                continue ;
                            }
                            break ;
                        }
                    }
                }
            }
        }
    }

    __Z( psttP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e4.etherc.strFromIdJotF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e5.etherc.diskWalkSearchF BEGIN
#define DDNAME       "3func.360021e5.etherc.diskWalkSearchF"
#define DDNUMB      (countT)0x360021e5
#define IDFILE      (countT)0xdec


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::diskWalkSearchF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const strokeS* const psttP , const osTextT* const postFindP , const flagsT flagsP , diskWalkSearchCBFT pCbfP , countT* pcArgP )/*1*/
{
    third.diskWalkSearchF( tinP , cDirsP , cFilesP , bQuitP , osFileNameC( tinP , third , T(psttP) ) , postFindP , flagsP , pCbfP , pcArgP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e5.etherc.diskWalkSearchF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e6.etherc.ether_psttEarlyFolder_f BEGIN
#define DDNAME       "3func.360021e6.etherc.ether_psttEarlyFolder_f"
#define DDNUMB      (countT)0x360021e6
#define IDFILE      (countT)0xded


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/strokeS*& etherC::ether_psttEarlyFolder_F( tinS& tinP )/*1*/
{
    SCOOP
    _IO_

    return tinP.pAdamGlobal1->_etherC_.psttEarlyFolder ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e6.etherc.ether_psttEarlyFolder_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e7.etherc.emailFactoryReportF BEGIN
#define DDNAME       "3func.360021e7.etherc.emailFactoryReportF"
#define DDNUMB      (countT)0x360021e7
#define IDFILE      (countT)0xdee


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i retrieve a string by searching the jotC instances registered for this thread
*/

/**/

/*1*/voidT etherC::emailFactoryReportF( tinS& tinP , const strokeS* const psttSubjectP , const strokeS* const psttBodyP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttSubjectP ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( countT  , timeN1 ) ;
    ZE( sCountT , timeN2 ) ;
    osTimeNowF( tinP , timeN1 , timeN2 ) ;

    textC tTime( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

    TN( tHost , "" ) ;
    {
        ZE( osTextT* , postComputer ) ;
        third.s_getComputerNameF( tinP , postComputer ) ; ___( postComputer ) ;
        tHost = T(postComputer) ;
        delF( tinP , postComputer ) ;
        if( !tHost.csF( tinP ) ) tHost = T("factories") ;
    }

    TN( tHome , "" ) ;
    {
        tHome = TF2(etherC::ifc_idHomeIdisk_IF(),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
    }

    TN( tAdam , "" ) ;
    {
        mapCTC& mapAdam = processGlobal3S::_processGlobal3I_IF().mapAdam ;
        tAdam = T(mapAdam(tinP.pAdamGlobal1->idAdam)) ;
        if( !tAdam.csF( tinP ) ) tAdam = TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
    }

    TN( tBody , "Subject: " ) ;
    tBody += tHome+T("-")+tAdam+T(": ") ;
    tBody += T(psttSubjectP)+T("\r\n\r\n") ;
    tBody += tTime+T(" ") ;
    tBody += TT(timeN1,timeN2)+T(" ") ; //MY CELL PHONE LIMITS LENGTH OF SUBJECT; CAN PUT THIS INTO BODY IF NEEDED
    if( psttBodyP && psttBodyP->idAdam ) tBody += T(psttBodyP)+T("\r\n") ;

    traceF( tinP , T("emailFactoryReportF [subject]: \"")+T(psttSubjectP)+T("\"") ) ;
    boxPutF( tinP , T("smtp.mailgun.org[internal]/b42/smtp/")+tHost+T("@ideafarm.com/ideafarm.factory.reports@gmail.com") , tBody ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e7.etherc.emailFactoryReportF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e8.etherc.boxputuniquef BEGIN
#define DDNAME       "3func.360021e8.etherc.boxputuniquef"
#define DDNUMB      (countT)0x360021e8
#define IDFILE      (countT)0xdef


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$boxPutUniqueF.0.html\"\>instances\</A\>
\<A HREF=\"5.1030078.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.c710104.1.1.0.html\"\>c710104:  WAKEsHOW( "example.simplest.func.1030078.etherC.boxPutUniqueF" )\</A\>
arguments
 psttP
  will be set to the actual name used
 psttLikeP
  the prefix for the unique name
   example: T("///ideafarm/ephemeral/tmp/1030078")
 cOpenTriesP
  if 0 then will retry forever
  if not 0 then will try cTriesP times
*/
/**/

/*1*/voidT etherC::boxPutUniqueF( tinS& tinP , strokeS*& psttP , const strokeS* const psttLikeP , soulC& soulP , countT cOpenTriesP , const flagsT flagsOpenDetailsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    }

    _IO_

    ZE( strokeS* , psttU ) ;
    strUniqueF( tinP , psttU ) ; ___( psttU ) ;

    boolT bStringOfStrings = ISsTRINGoFsTRINGS( psttLikeP ) ;
    ZE( strokeS* , pstt1Like ) ;
    if( !bStringOfStrings ) { strFuseSeparateF( tinP , pstt1Like , psttLikeP ) ; ___( pstt1Like ) ; }
    else                    pstt1Like = (strokeS*)psttLikeP ;

    TlIST( tListUse ) ;
    {
        TN( tMark , "@1@" ) ;
        FORsTRINGSiN1( pstt1Like )
        {
            ZE( strokeS* , psttUse ) ;
            if( strIdF( tinP , tMark , psttc1 ) ) { strReplaceF( tinP , psttUse , psttc1 , tMark , psttU ) ; ___( psttUse ) ; }
            else
            {
                strMakeF( tinP , LF , psttUse , psttLikeP , ( psttU ? 1 + psttU->idAdam : 0 ) ) ; ___( psttUse ) ;
                strFuseF( tinP , psttUse , T(".") ) ; ___( psttP ) ;
                strFuseF( tinP , psttUse , psttU ) ; ___( psttP ) ;
            }

            tListUse += T(psttUse) ;
            delF( tinP , psttUse ) ;
        }
    }
    strokeS* pstt1zUse = tListUse ;

    ZE( countT , cFail ) ;
    FORsTRINGSiN1( pstt1zUse )
    {
        if( this != tinP.pEtScratch )
        {
            boxC box( tinP , *this , psttc1 , 0 , 0 , 0 , cOpenTriesP , 0 , 0 , flagsOpenDetailsP ) ;
            box.putF( tinP , soulP ) ;
            if( POOP ) break ;
        }
        else
        {
            IFsCRATCH
            {
                SCOOPS
                boxC box( tinP , *this , psttc1 , 0 , 0 , 0 , cOpenTriesP , 0 , 0 , flagsOpenDetailsP ) ;
                box.putF( tinP , soulP ) ;
                if( POOP )
                {
                    POOPRqUIET
                    cFail ++ ;
                }
            }
        }
    }

    if( !bStringOfStrings ) delF( tinP , pstt1Like ) ;
                            delF( tinP , psttU     ) ;

    __( cFail ) ;

    if( bStringOfStrings ) { strMakeF( tinP , LF , psttP , pstt1zUse ) ; ___( psttP ) ; }
    else
    {
        FORsTRINGSiN1( pstt1zUse )
        {
            strMakeF( tinP , LF , psttP , psttc1 ) ; ___( psttP ) ;
            break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e8.etherc.boxputuniquef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e9.etherc.ifcIdCopyF BEGIN
#define DDNAME       "3func.360021e9.etherc.ifcIdCopyF"
#define DDNUMB      (countT)0x360021e9
#define IDFILE      (countT)0xdf0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT etherC::ifcIdCopyF( tinS& tinP , countT cNameP )/*1*/
{
    if( !cNameP ) cNameP = tinP.pAdamGlobal1->idAdam ;

    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( cNameP ) ;
        if( POOP ) return 0 ;
    }

    _IO_
    ZE( countT , idCopy ) ;
    TN( tFileMaster , "" ) ; tFileMaster = T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/master/ideafarm.")+TF3(cNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,sizeof(countT)*2)+T(".ipdos-wm") ;

    ZE( byteT* , pbm ) ;
    ZE( countT , cbm ) ;
    boxGetShadowF( tinP , pbm , cbm , tFileMaster ) ; ___( pbm ) ;

    ZE( imageExeDllC* , pInfo ) ;
    third.imageExeDllF( tinP , pInfo , pbm ) ; ___( pInfo ) ;
    if( !pInfo ) __1
    else
    {
        TN( tDescription , pInfo->postDescription ) ;

        ZE( strokeS* , pstt1w ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        strWordsF( tinP , pstt1w , tDescription , sttq ) ; ___( pstt1w ) ;
        ZE( boolT , bArmedName ) ;
        ZE( boolT , bArmedCopy ) ;
        TN( tHeyName , "!cName"  ) ;
        TN( tHeyCopy , "!idCopy" ) ;
        FORsTRINGSiN1( pstt1w )
        {
            //traceF( tinP , T("word: ")+T(psttc1) ) ;

            if( bArmedName )
            {
                bArmedName = 0 ;
                countT cNameVerify = strDigitsToSCountF( tinP , psttc1 ) ;
                __( cNameVerify - cNameP ) ;
            }
            else if( bArmedCopy )
            {
                bArmedCopy = 0 ;
                idCopy = strDigitsToSCountF( tinP , psttc1 ) ;
            }
            else if( !strCompareF( tinP , psttc1 , tHeyName ) ) bArmedName = 1 ;
            else if( !strCompareF( tinP , psttc1 , tHeyCopy ) ) bArmedCopy = 1 ;
        }
    }
    DEL( pInfo ) ;
    delF( tinP , pbm ) ;
    return idCopy ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021e9.etherc.ifcIdCopyF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ea.etherc.strIdOptimizedClosureF BEGIN
#define DDNAME       "3func.360021ea.etherc.strIdOptimizedClosureF"
#define DDNUMB      (countT)0x360021ea
#define IDFILE      (countT)0xdf1

//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i evaluate to the id of the woth strokeS in psttBigP that matches psttSmallP
if psttSmallP does not contain a special strokeS value that requests "closure iteration", then i am just a thin wraper for strIdF
if psttSmallP is an IPDOS (tm) regular expression that contains "closure iteration" values, then i call myself recursively to search for a match, using flags that specify how i am to search
for example, i am used to conduct searches semantically equivalent to the '*' wildcard in a windows file name search
 in such a search, the '*' will match 0 or more of any character but will not consume literal matches that follow the '*' in the search string
parameters
 tinP
 idFirstP
  the position in psttBigP to start the search
  this is the woth position that will be inspected when looking for a match
 sttQuoteP
  a quote strokeS to use to delimit literals, or strokeS( 0 , sc_IGNOREqUOTES )
 psttSmallP
  a search specification string
  if it does not contain a particular special strokeS value, then i am just a thin wrapper for strIdF
  normally, an IPDOS (tm) regular expression  
   to be a regular expression, must begin with S2(sa_SSSaND,sc_ccSSS)
   the special stroke value is S3(-1,sc_ccSSSrEPEAT,-1)
   to optimize closure, i call myself recursively for each occurrance, and for each occurance, i try every "repeat value" in a range until i either match or exhaust the range
 psttBigP
  the string to search within
 flagsP
  controls how i search
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT indicates that the leftmost occurance changes the most rapidly during the search
   for simple searches, this search order does not affect the result
  the match evaluation is always done left to right, i.e. from the beginning of psttSmallP to the end
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT only changes the order in which the "closure iteration" strokeS's are iterated
 pFlagsOverrideP
  may be 0
  if not 0 then must point to a null terminated array of flagsT values, and each of these nonze values must be a valid flSTRiDoPTIMIZEDcLOSURE constant
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT in these values is ignored (has no effect)
  all other valid flags override the corresponding flag in flagsP for the "closure iteration" occurance that corresponds to each element of the array
  for example, optimization of the woth "closure iteration" value encountered (normally the leftmost) is controlled by the woth element of the array
 pcMinOverrideP
  may be 0
  if not 0 then must point to a null terminated array of countT values, and each of these values must have the high bit set (using BM_HIGH)
  the value of each element, ignoring the high bit, overrides the default repeat minimum (which is 0)
   for example, if the element contains BM_HIGH | 7, then optimization will search only 7 or more repeats (8 or more occurances)
  whether "ignore" is tried is not affected
   example: BM_HIGH | 7 , flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG , not flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE:
    ignore is tried
    then 7 is tried
    then 8, then 9, then 0xa, ...
   the effect of that example is that a match requires either 0 occurrances or at least 8 occurrances, and minimal closure is done
 pcMaxOverrideP
  may be 0
  if not 0 then must point to a null terminated array of countT values, and each of these values must have the high bit set (using BM_HIGH)
  the value of each element, ignoring the high bit, overrides the default repeat maximum (which is psttBigP->idAdam - 2)
   for example, if the element contains BM_HIGH | 7, then optimization will search only 7 or fewer repeats (8 or fewer occurances)
  whether "ignore" is tried is not affected
   example: BM_HIGH | 7 , flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG , not flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE:
    ignore is tried
    then 0 is tried
    then 1, then 2, ... then 7, but no more, even if psttBigP is very long
   the effect of that example is that a match requires either 0 occurrances or at most 8 occurrances, and minimal closure is done
 idLastP
  the position in psttBigP to end the search
  this is the lath position that will be inspected when looking for a match
 idP
  normally 1, which means that the caller wants the woth match in psttBigP
  if 2, then caller wants the ooth match, etc.
*/
/**/                                          

/*1*/countT etherC::strIdOptimizedClosureF( tinS& tinP , stackC* const pstMatchP , const flagsT flagsMatchP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* psttSmallP , const strokeS* psttBigP , const flagsT flagsP , const flagsT* pFlagsOverrideP , const countT* pcMinOverrideP , const countT* pcMaxOverrideP , const countT idLastP , sCountT idP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( idFirstP ) ;
        __Z( psttSmallP ) ;
        __Z( psttBigP ) ;
        //U::FV(flSTRiDoPTIMIZEDcLOSURE,flagsP) ;
        __Z( idP ) ;
        if( POOP ) return 0 ;
        __Z( psttSmallP->idAdam ) ;
        __Z( psttBigP->idAdam ) ;
        if( pstMatchP )
        {
            __( F( pstMatchP->flagsF( tinP ) ) & flSTACKc_FIFO ) ; // IF FIFO THEN WILL CONTAIN INCORRECT CONTENTS
        }
        if( POOP ) return 0 ;
    }

    _IO_

    //boolT bChatter = 0 ; //0 IN PRODUCTION

    //if( bChatter )
    //{
    //    ZE( strokeS* , psttd ) ;
    //    strDumpStrokesIF( tinP , psttd , psttSmallP ) ; ___( psttd ) ;
    //    traceF( tinP , T("pattern:    ")+T(psttd) ) ;
    //    delF( tinP , psttd ) ;
    //}

    stackC stFixedSmall( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB | flSTACKc_FIFO , 2 * sizeof( countT ) ) ;
    ZE( countT , csttMin ) ;
    ZE( countT , csttMax ) ;
    strExpressionLengthMinMaxF( tinP , csttMin , csttMax , stFixedSmall , countTC( 1 ) , psttSmallP , flagsP , pFlagsOverrideP , pcMinOverrideP , pcMaxOverrideP ) ;

    ZE( countT , idHit ) ;
    if( csttMin <= psttBigP->idAdam /*&& psttBigP->idAdam <= csttMax*/ )            // THE OOTH TEST IS DISABLED BECAUSE, LIKE OTHER strId FUNCTIONS, I LOOK FOR A MATCH *WITHIN* psttBigP
    {                                                                               //U:: REMOVE THE OOTH TEST ; IT IS INCORRECT
        boolT bAllFixedFound = 1 ;
        if( stFixedSmall )
        {
            countT idfBig = 1 ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            do
            {
                count2S& c2f = *(count2S*)&stFixedSmall.downF( tinP , hDown ) ;

                ZE( strokeS* , psttf ) ;
                countT idf = c2f.c1 ;
                countT idl = c2f.c2 ;
                strSubstringF( tinP , psttf , idf , idl , psttSmallP ) ; ___( psttf ) ;

                ZE( strokeS* , psttd ) ;

                //if( bChatter )
                //{
                //    TN( tb4 , "    " ) ;
                //    strDumpStrokesIF( tinP , psttd , psttf ) ; ___( psttd ) ;
                //    traceF( tinP , T("fixed small [idf,idl,text,dump]:    ")+TF2(c2f.c1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(c2f.c2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    \"")+T(psttf)+T("\"    ")+T(psttd) ) ;
                //}

                TN( tn , "" ) ;
                TN( tWrapped , "" ) ; tWrapped = tn+S2(sa_SSSaND,sc_ccSSS)+T(psttf)+S2(sa_SSSaNDeND,sc_ccSSS) ;

                countT idHit = strIdF( tinP , 0 , flSTRmATCH_null , idfBig , sttq , tWrapped , psttBigP , 0 , 1 ) ;
                if( !idHit )
                {
                    //if( bChatter ) traceF( tinP , T("a fixed small was not found, inspecting left to right, in big [text,dump]:    \"")+T(psttf)+T("\"    ")+T(psttd) ) ;
                    bAllFixedFound = 0 ;
                }

                delF( tinP , psttf ) ;
                delF( tinP , psttd ) ;

                if( !bAllFixedFound ) break ;
            }
            while( !stFixedSmall.third && ~hDown ) ;
        }

        if( bAllFixedFound )
        {
            countT cPlatesWas = pstMatchP ? *pstMatchP : 0 ;

            ZE( countT , idsPatch ) ;
            {
                strokeS sttPatchRequest( - 1 , sc_ccSSSrEPEAT , - 1 ) ;
                ZE( countT , offo ) ;
                if( F(flagsP) & flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT ) for( countT idsIn = psttSmallP->idAdam ; idsIn                       ; idsIn -- )
                {
                    if( psttSmallP[ CSpREFIX - 1 + idsIn ] == sttPatchRequest )
                    {
                        idsPatch = idsIn ;
                        break ;
                    }
                }
                else                                                  for( countT idsIn = 1                  ; idsIn <= psttSmallP->idAdam ; idsIn ++ )
                {
                    if( psttSmallP[ CSpREFIX - 1 + idsIn ] == sttPatchRequest )
                    {
                        idsPatch = idsIn ;
                        break ;
                    }
                }
            }

            //static countT woth_idsPatch ;
            //static countT ooth_idsPatch ;
            //static countT reth_idsPatch ;
            //static countT foth_idsPatch ;
            //if( idsPatch )
            //{
            //         if( !woth_idsPatch                                                                                           ) woth_idsPatch = idsPatch ;
            //    else if(  woth_idsPatch != idsPatch && !ooth_idsPatch                                                             ) ooth_idsPatch = idsPatch ;
            //    else if(  woth_idsPatch != idsPatch &&  ooth_idsPatch != idsPatch && !reth_idsPatch                               ) reth_idsPatch = idsPatch ;
            //    else if(  woth_idsPatch != idsPatch &&  ooth_idsPatch != idsPatch &&  reth_idsPatch != idsPatch && !foth_idsPatch ) foth_idsPatch = idsPatch ;
            //}

            if( !idsPatch )
            {
                countT idfSave = idFirstP ;
                idHit = strIdF( tinP , pstMatchP , flagsMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , idLastP , idP ) ;
                if( idHit && idFirstP && F(flagsP) & flSTRiDoPTIMIZEDcLOSURE_NOlEFTOVERS )
                {
                    idHit = 0 ;
                    idFirstP = idfSave ;
                }
            }
            else
            {
                //U::O: THIS IS THE MOST EXPENSIVE (TIME) SECTION OF CODE
                countT& patch_idAdam  = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].idAdam  ;
                countT& patch_idCaste = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].idCaste ;
                countT& patch_cNote   = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].cNote   ;

                //___( patch_idAdam  - ( - 1 )        ) ;
                //___( patch_idCaste - sc_ccSSSrEPEAT ) ;
                //___( patch_cNote   - ( - 1 )        ) ;

                flagsT flagsMe = pFlagsOverrideP && *pFlagsOverrideP
                    ? *pFlagsOverrideP
                    : flagsP
                ;

                //U::FV(flSTRiDoPTIMIZEDcLOSURE,flagsMe) ;

                if( pcMinOverrideP && *pcMinOverrideP ) { __Z( *pcMinOverrideP & BM_HIGH ) ; }      //ENFORCES THE USE OF BM_HIGH ; CODE WOULD WORK CORRECTLY WITHOUT THAT BIT EXCEPT WHEN THE VALUE 0 IS INTENDED AS A VALUE RATHER THAN AS A TRMINATOR ; SO ENFORCEMENT IS DONE TO PREVENT BUGS THAT ARE DIFFICULT TO ANALYZE
                if( pcMaxOverrideP && *pcMaxOverrideP ) { __Z( *pcMaxOverrideP & BM_HIGH ) ; }      //ENFORCES THE USE OF BM_HIGH ; CODE WOULD WORK CORRECTLY WITHOUT THAT BIT EXCEPT WHEN THE VALUE 0 IS INTENDED AS A VALUE RATHER THAN AS A TRMINATOR ; SO ENFORCEMENT IS DONE TO PREVENT BUGS THAT ARE DIFFICULT TO ANALYZE

                countT cMinMe = pcMinOverrideP && *pcMinOverrideP
                    ? *pcMinOverrideP & ~BM_HIGH
                    : 0
                ;

                countT cMaxMe = pcMaxOverrideP && *pcMaxOverrideP && ( *pcMaxOverrideP & ~BM_HIGH ) < ( psttBigP->idAdam - 1 )          // "- 1" IS BECAUSE THIS IS MAX REPEAT COUNT TO TRY, AND "REPEAT COUNT" IS NET ( REPEATING 3 TIMES MEANS 4 CONSECUTIVE OCCURANCES
                    ? *pcMaxOverrideP & ~BM_HIGH
                    : psttBigP->idAdam - 1
                ;

                //if( bChatter )
                //{
                //    TN( tb4 , "    " ) ;
                //    traceF( tinP , T("patch [idsPatch,flagsMe,cMinMe,cMaxMe]:")+tb4+TF2(idsPatch,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(flagsMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cMinMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cMaxMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                //}

                ZE( countT , idBefore ) ;
                ZE( countT , idAfter ) ;
                if( stFixedSmall )
                {
                    ZE( countT , idPlate ) ;
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    do
                    {
                        ++ idPlate ;
                        count2S& c2f = *(count2S*)&stFixedSmall.downF( tinP , hDown ) ;

                             if( idsPatch < c2f.c1              ) idAfter  = idPlate ;
                        else if(            c2f.c2   < idsPatch ) idBefore = idPlate ;
                    }
                    while( !stFixedSmall.third && ~hDown && !idAfter ) ;
                }

                //if( bChatter )
                //{
                //    TN( tb4 , "    " ) ;
                //    traceF( tinP , T("patch [idBefore,idAfter]:")+tb4+TF2(idBefore,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idAfter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                //}

                ZE( strokeS* , psttBefore ) ;
                stackC stIdHitBefore( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_countT ) ;
                if( idBefore )
                {
                    count2S& c2f = *(count2S*)&stFixedSmall[ idBefore ] ;

                    countT idf = c2f.c1 ;
                    countT idl = c2f.c2 ;
                    strSubstringF( tinP , psttBefore , idf , idl , psttSmallP ) ; ___( psttBefore ) ;
                    //if( bChatter )
                    //{
                    //    TN( tb4 , "    " ) ;
                    //    traceF( tinP , T("this is before the patch [idf,idl,string]:    ")+TF2(c2f.c1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(c2f.c2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttBefore) ) ;
                    //}

                    ZE( countT , idHit ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    idf = 1 ;
                    do
                    {
                        idHit = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , psttBefore , psttBigP , 0 , 1 ) ;
                        if( idHit )
                        {
                            countT idLath = idf ? idf - 1 : psttBigP->idAdam ;
                            //if( bChatter )
                            //{
                            //    TN( tb4 , "    " ) ;
                            //    traceF( tinP , T("before: found in big at [idHit,idLath]:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //}
                            stIdHitBefore << idHit ;
                        }
                    }
                    while( idHit && idf ) ;
                }

                ZE( strokeS* , psttAfter  ) ;
                stackC stIdHitAfter( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_countT ) ;
                if( idAfter )
                {
                    count2S& c2f = *(count2S*)&stFixedSmall[ idAfter ] ;

                    countT idf = c2f.c1 ;
                    countT idl = c2f.c2 ;
                    strSubstringF( tinP , psttAfter , idf , idl , psttSmallP ) ; ___( psttAfter ) ;
                    //if( bChatter )
                    //{
                    //    TN( tb4 , "    " ) ;
                    //    traceF( tinP , T("this is after the patch [idf,idl,string]:    ")+TF2(c2f.c1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(c2f.c2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttAfter) ) ;
                    //}

                    ZE( countT , idHit ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    idf = 1 ;
                    do
                    {
                        idHit = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , psttAfter , psttBigP , 0 , 1 ) ;
                        if( idHit )
                        {
                            //if( bChatter ) traceF( tinP , T("after: found in big at [idHit]:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            stIdHitAfter << idHit ;
                        }
                    }
                    while( idHit && idf ) ;
                }

                stackC stTryLength( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_countT ) ;
                ZE( flagsT , flagsMeSave ) ;
                {
                    if( !idBefore && !idAfter )
                    {
                        stTryLength << psttBigP->idAdam ;
                        flagsMeSave = flagsMe ;
                        flagsMe |= F(flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE) ;
                    }
                    else if( !idBefore && idAfter )
                    {
                        ZE( boolT , bTryIgnore ) ;
                        while( stIdHitAfter )
                        {
                            ZE( countT , idHit ) ;
                            stIdHitAfter >> idHit ;

                            if( idHit > 1 ) stTryLength << idHit - 1 ;
                            else            bTryIgnore = 1 ;
                        }

                        if( stTryLength && !bTryIgnore )
                        {
                            flagsMeSave = flagsMe ;
                            flagsMe |= F(flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE) ;
                        }
                    }
                    else if( idBefore && !idAfter )
                    {
                        ZE( boolT , bTryIgnore ) ;
                        while( stIdHitBefore )
                        {
                            ZE( countT , idHit ) ;
                            stIdHitBefore >> idHit ;

                            countT idLath = idHit - 1 + psttBefore->idAdam ;
                            if( psttBigP->idAdam > idLath ) stTryLength << psttBigP->idAdam - idLath ;
                            else                            bTryIgnore = 1 ;
                        }

                        if( stTryLength && !bTryIgnore )
                        {
                            flagsMeSave = flagsMe ;
                            flagsMe |= F(flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE) ;
                        }
                    }
                    else if( idBefore && idAfter )
                    {
                        while( stIdHitBefore )
                        {
                            ZE( countT , idHitBefore ) ;
                            stIdHitBefore >> idHitBefore ;
                            countT idTryWoth = idHitBefore + psttBefore->idAdam ;

                            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            do
                            {
                                countT idHitAfter = stIdHitAfter.downF( tinP , hDown ) ;
                                countT idTryLath  = idHitAfter - 1 ;
                                countT cLengthTry = 1 + idTryLath - idTryWoth ;

                                if( cLengthTry ) stTryLength << cLengthTry ;
                            }
                            while( !stIdHitAfter.third && ~hDown ) ;
                        }

                        if( stTryLength )
                        {
                            flagsMeSave = flagsMe ;
                            flagsMe |= F(flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE) ;
                        }
                    }
                }

                delF( tinP , psttBefore ) ;
                delF( tinP , psttAfter ) ;

                if( !POOP )
                {
                    if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG )                      //MINIMAL CLOSURE BEHAVIOR (WILL INCREASE THE LENGTH FROM THIS MINIMUM UNTIL FIND A HIT
                    {
                        if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) patch_cNote = patch_idAdam = cMinMe ;
                        else
                        {
                            patch_idAdam = - 1 ;                                                // BEGIN BY IGNORING THE SUBEXPRESSION
                            patch_cNote  =   1 ;
                        }
                    }
                    else patch_idAdam = patch_cNote = cMaxMe ;                                  //MAXIMAL CLOSURE BEHAVIOR (WILL DECREASE THE LENGTH FROM THIS MAXIMUM UNTIL FIND A HIT

                    countT restore_idAdam = - 1 ;  //THIS IS THE PATCH REQUEST VALUE SO WILL NEVER OCCUR DURING PATCH OPTIMIZATION
                    countT restore_cNote  = - 1 ;  // "
                    if( stTryLength ) //CS:CODEsYNCH:PSEUDODUPLICATE 51012003 51012003
                    {
                        if( restore_idAdam == - 1 && restore_cNote == - 1 )
                        {
                            restore_idAdam = patch_idAdam ;
                            restore_cNote  = patch_cNote  ;
                        }

                        ZE( countT , cLength ) ;
                        stTryLength >> cLength ;

                        patch_cNote = patch_idAdam = cLength - 1 ;   //ASSUME: THIS ASSUMES THAT WHAT IS BEING REPEATED IS OF LENGTH 1
                    }

                    ZE( countT , csttOptimal ) ;
                    static countT idCall ;
                    //TN( tb4  , "    " ) ;
                    //TN( tb41 , "                    " ) ;
                    //TN( tb42 , "                                    " ) ;
                    //TN( tb43 , "                                                    " ) ;
                    {
                        for(;;)
                        {
                            countT idfSave = idFirstP ;

                            ++ idCall ;
                            //if( bChatter )
                            //{
                            //         if( woth_idsPatch == idsPatch ) etherC::etRockIF( tinP ).traceF( tinP , T("++++    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //    else if( ooth_idsPatch == idsPatch ) etherC::etRockIF( tinP ).traceF( tinP , T("++++    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb41+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //    else if( reth_idsPatch == idsPatch ) etherC::etRockIF( tinP ).traceF( tinP , T("++++    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb42+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //    else if( foth_idsPatch == idsPatch ) etherC::etRockIF( tinP ).traceF( tinP , T("++++    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb43+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //}

                                      //THE NEXT LINE SHOWS MY OWN PARAMETERS SO THAT THEY CAN BE EASILY COMPARED WITH WHAT I PASS AS ARGUMENTS TO THE RECURSION CALL
                                      //strIdOptimizedClosureF( tinP , pstMatchP , flagsMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , flagsP , pFlagsOverrideP                                 , pcMinOverrideP                                , pcMaxOverrideP                                , idLastP , idP )

                            {
                                idHit = strIdOptimizedClosureF( tinP , pstMatchP , flagsMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , flagsP , pFlagsOverrideP ? ( ++ pFlagsOverrideP ) -- : 0 , pcMinOverrideP ? ( ++ pcMinOverrideP ) -- : 0 , pcMaxOverrideP ? ( ++ pcMaxOverrideP ) -- : 0 , idLastP , idP ) ;
                                //U:: idHit = strIdOptimizedClosureF( tinP , pstMatchP , flagsMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , flagsP , pFlagsOverrideP ? ( ++ pFlagsOverrideP ) -- : 0 , pcMinOverrideP ? ( ++ pcMinOverrideP ) -- : 0 , pcMaxOverrideP ? ( ++ pcMaxOverrideP ) -- : 0 , idLastP , idP ) ;
                            }
             
                            //if( bChatter )
                            //{
                            //         if( woth_idsPatch == idsPatch ) etherC::etRockIF( tinP ).traceF( tinP , T("----    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //    else if( ooth_idsPatch == idsPatch ) etherC::etRockIF( tinP ).traceF( tinP , T("----    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb41+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //    else if( reth_idsPatch == idsPatch ) etherC::etRockIF( tinP ).traceF( tinP , T("----    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb42+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //    else if( foth_idsPatch == idsPatch ) etherC::etRockIF( tinP ).traceF( tinP , T("----    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb43+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //}

                            if( idHit && ( !idFirstP || !( F(flagsP) & flSTRiDoPTIMIZEDcLOSURE_NOlEFTOVERS ) ) )
                                break ;

                            idFirstP = idfSave ;

                            {
                                if( stTryLength ) //CS:CODEsYNCH:PSEUDODUPLICATE 51012003 51012003
                                {
                                    ZE( countT , cLength ) ;
                                    stTryLength >> cLength ;

                                    patch_cNote = patch_idAdam = cLength - 1 ;   //ASSUME: THIS ASSUMES THAT WHAT IS BEING REPEATED IS OF LENGTH 1
                                }
                                else if( restore_idAdam != - 1 || restore_cNote != - 1 )
                                {
                                    patch_idAdam = restore_idAdam  ;
                                    patch_cNote  = restore_cNote   ;
                                    restore_cNote  = restore_idAdam = - 1 ;
                                    flagsMe = flagsMeSave ;
                                }
                                else if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG )
                                {
                                    if( patch_idAdam == cMaxMe )
                                        break ;

                                    if( patch_idAdam == - 1 ) patch_idAdam = patch_cNote = cMinMe ;
                                    else
                                    {
                                        patch_idAdam ++ ;
                                        patch_cNote  ++ ;

                                        if( cMaxMe < patch_idAdam ) break ;
                                    }
                                }
                                else
                                {
                                    if( patch_idAdam == - 1 || ( patch_idAdam == cMinMe && F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) )
                                        break ;

                                    if( patch_cNote == cMinMe )
                                    {
                                        patch_idAdam = - 1 ;                                        // END BY IGNORING THE SUBEXPRESSION
                                        patch_cNote  =   1 ;
                                    }
                                    else
                                    {
                                        patch_idAdam -- ;
                                        patch_cNote  -- ;
                                    }
                                }
                            }
                        }
                    }

                    patch_idAdam  = ( - 1 ) ;
                    patch_cNote   = ( - 1 ) ;
                }
            }

            if( !idHit && pstMatchP ) pstMatchP->purgeF( tinP , cPlatesWas ) ;
        }
    }

    //if( bChatter ) traceF( tinP , T("returning [idHit,idFirstP:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idFirstP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    return idHit ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ea.etherc.strIdOptimizedClosureF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021eb.etherc.strPatternFromWildcardsMicrosoftF BEGIN
#define DDNAME       "3func.360021eb.etherc.strPatternFromWildcardsMicrosoftF"
#define DDNUMB      (countT)0x360021eb
#define IDFILE      (countT)0xdf2

//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::strPatternFromWildcardsMicrosoftF( tinS& tinP , strokeS*& psttRegExpP , flagsT& flagsOptimizeP , flagsT*& pFlagsOverrideP , countT*& pcMinOverrideP , countT*& pcMaxOverrideP , const strokeS* const psttWildP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttRegExpP ) ;
        __NZ( pFlagsOverrideP ) ;
        __NZ( pcMinOverrideP ) ;
        __NZ( pcMaxOverrideP ) ;
        __Z( psttWildP ) ;
        if( POOP ) return ;
    }

    newF( tinP , LF , pFlagsOverrideP , psttWildP->idAdam + 1 ) ; ___( pFlagsOverrideP ) ;
    newF( tinP , LF , pcMinOverrideP  , psttWildP->idAdam + 1 ) ; ___( pcMinOverrideP  ) ;
    newF( tinP , LF , pcMaxOverrideP  , psttWildP->idAdam + 1 ) ; ___( pcMaxOverrideP  ) ;
    ZE( countT , offo ) ;

    TN( tn , "" ) ;
    TN( tre , "" ) ; tre = tn + S2(sa_SSSaND,sc_ccSSS) ;
    
    for( countT ids = 1 ; ids <= psttWildP->idAdam ; ids ++ )
    {
        switch( psttWildP[ CSpREFIX - 1 + ids ].idAdam )
        {
            #if defined( NEVERdEFINED )
                case '@' :          //U:: REMOVE IN PRODUCTION ; THIS IS ONLY FOR TESTING THE HANDLING OF VARYING LENGTH OR GROUPS
                {
                    tre += tn
                
                        +S2(sa_SSSrEPORTmATCH,sc_ccSSS)
                           +S2(sa_SSSoR,sc_ccSSS)
                               +S2(sa_SSSaND,sc_ccSSS)
                                   +T("hello")
                               +S2(sa_SSSaNDeND,sc_ccSSS)
                               +S2(sa_SSSaND,sc_ccSSS)
                                   +T("bye")
                               +S2(sa_SSSaNDeND,sc_ccSSS)
                           +S2(sa_SSSoReND,sc_ccSSS)
                        +S2(sa_SSSrEPORTmATCHeND,sc_ccSSS)
                
                    ;
                
                    break ;
                }
            #endif
            case '.' :
            {
                tre += tn

                    +S2(sa_SSSrEPORTmATCH,sc_ccSSS)                  // 123456789abcde
                        +S3(-1,sc_ccSSSrEPEAT,-1)
                        +S1C( '.' )
                    +S2(sa_SSSrEPORTmATCHeND,sc_ccSSS)                  // 123456789abcde

                ;

                pFlagsOverrideP[ offo    ] = flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG ;
                pcMinOverrideP[  offo    ] = BM_HIGH | 0 ;
                pcMaxOverrideP[  offo ++ ] = BM_HIGH | 0 ;

                break ;
            }
            case '?' :
            {
                tre += tn

                    +S2(sa_SSSrEPORTmATCH,sc_ccSSS)                  // 123456789abcde
                        +S3(-1,sc_ccSSSrEPEAT,-1)
                        +S2(sa_SSSoR,sc_ccSSS)
                            +S2(sa_SSSmARKaNY,sc_cSSSmARK)
                        +S2(sa_SSSoReND,sc_ccSSS)
                    +S2(sa_SSSrEPORTmATCHeND,sc_ccSSS)                  // 123456789abcde

                ;

                pFlagsOverrideP[ offo    ] = flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG ;
                pcMinOverrideP[  offo    ] = BM_HIGH | 0 ;
                pcMaxOverrideP[  offo ++ ] = BM_HIGH | 0 ;

                break ;
            }
            case '*' :
            {
                tre += tn

                    +S2(sa_SSSrEPORTmATCH,sc_ccSSS)                  // 123456789abcde
                        +S3(-1,sc_ccSSSrEPEAT,-1)                    // 15000002.signc
                        +S2(sa_SSSoR,sc_ccSSS)
                            +S2(sa_SSSmARKaNY,sc_cSSSmARK)
                        +S2(sa_SSSoReND,sc_ccSSS)
                    +S2(sa_SSSrEPORTmATCHeND,sc_ccSSS)

                ;

                pFlagsOverrideP[ offo    ] = flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG ;
                pcMinOverrideP[  offo    ] = BM_HIGH |   0 ;
                pcMaxOverrideP[  offo ++ ] = BM_HIGH | - 1 ;

                ids ++ ;
                while( ids <= psttWildP->idAdam && ( psttWildP[ CSpREFIX - 1 + ids ].idAdam == '*' || psttWildP[ CSpREFIX - 1 + ids ].idAdam == '?' ) ) ids ++ ;        // IF WILDCARD THEN SKIP
                if( ids > psttWildP->idAdam ) ids = 0 ;

                if( ids ) ids -- ;

                break ;
            }
            default :
            {
                tre += tn + psttWildP[ CSpREFIX - 1 + ids ] ;

                break ;
            }
        }

        if( !ids ) break ;
    }

    flagsOptimizeP = flSTRiDoPTIMIZEDcLOSURE_NOlEFTOVERS ;

    pFlagsOverrideP[ offo    ] = 0 ;
    pcMinOverrideP[  offo    ] = 0 ;
    pcMaxOverrideP[  offo ++ ] = 0 ;

    tre += tn + S2(sa_SSSaNDeND,sc_ccSSS) ;

    strMakeF( tinP , LF , psttRegExpP , tre ) ; ___( psttRegExpP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021eb.etherc.strPatternFromWildcardsMicrosoftF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ec.etherc.strIdLathExpressionF BEGIN
#define DDNAME       "3func.360021ec.etherc.strIdLathExpressionF"
#define DDNUMB      (countT)0x360021ec
#define IDFILE      (countT)0xdf3

//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
will return idsWothP except when idsWoth points to the beginning of an "and subexpression" or an "or subexpression"
*/
/**/

/*1*/countT etherC::strIdLathExpressionF( tinS& tinP , const strokeS* const psttSmallP , countT idsWothP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttSmallP ) ;
        __Z( idsWothP ) ;
        if( POOP ) return 0 ;
    }

    ZE( countT , cNest ) ;
    ZE( boolT , cArmLiterals ) ;
    countT idsLath = idsWothP ;
    for( ; idsLath <= psttSmallP->idAdam ; idsLath ++ )
    {
             if( psttSmallP[ CSpREFIX - 1 + idsLath ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsLath ].idAdam == sa_SSSlITERALeND ) cArmLiterals = 0 ;
        else if( cArmLiterals                                            ) cArmLiterals -- ;
        else if( psttSmallP[ CSpREFIX - 1 + idsLath ].idCaste == sc_ccSSS )
        {
            ZE( boolT , bFound ) ;
            switch( psttSmallP[ CSpREFIX - 1 + idsLath ].idAdam )
            {
                case sa_SSSlITERAL :
                {
                    cArmLiterals = 1 ;
                    break ;
                }
                case sa_SSSlITERALbEGIN :
                {
                    cArmLiterals = - 1 ; //A:ASSUME: STRING LENGTH CANNOT EXCEED maxCountTT
                    break ;
                }
                case sa_SSSlITERALeND :
                {
                    cArmLiterals = 0 ;
                    break ;
                }
                case sa_SSSaND :
                case sa_SSSoR :
                {
                    ++ cNest ;
                    break ;
                }
                case sa_SSSaNDeND :
                case sa_SSSoReND :
                {
                    if( !( -- cNest ) ) bFound = 1 ;
                    break ;
                }
            }

            if( bFound ) break ;
        }
        else if( !cNest ) break ;
    }

    if( idsLath > psttSmallP->idAdam ) idsLath = 0 ;

    return idsLath ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ec.etherc.strIdLathExpressionF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ed.etherc.strExpressionLengthMinMaxF BEGIN
#define DDNAME       "3func.360021ed.etherc.strExpressionLengthMinMaxF"
#define DDNUMB      (countT)0x360021ed
#define IDFILE      (countT)0xdf4

//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i return the minimum and maximum number of strokes that can be consumed by the subexpression at idsP
parameters
 tinP
 csttMinP
  must be 0
  will be the minimum number of strokes that the AND subexpression at idsP will consume
 csttMaxP
  must be 0
  will be the maximum number of strokes that the AND subexpression at idsP will consume
 idsP
  must not be 0
  must point to an sa_SSSaND
  will point to the matching sa_SSSaNDeND
 psttRegExpP
  must be a valid search pattern
   if contains regular expressions, must begin with sa_SSSaND
    this is not currently enforced but might be in the future
*/
/**/

/*1*/voidT etherC::strExpressionLengthMinMaxF( tinS& tinP , countT& csttMinP , countT& csttMaxP , stackC& stFixedSmallP , countT& idsP , const strokeS* const psttRegExpP , const flagsT flagsOptimizeP , const flagsT* pFlagsOverrideP , const countT* pcMinOverrideP , const countT* pcMaxOverrideP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( csttMinP ) ;
        __NZ( csttMaxP ) ;
        __Z( idsP ) ;
        __Z( psttRegExpP ) ;
        if( POOP ) return ;
        __( psttRegExpP[ CSpREFIX - 1 + idsP ].idCaste - sc_ccSSS  ) ;
        __( psttRegExpP[ CSpREFIX - 1 + idsP ].idAdam != sa_SSSaND && ( idsP == 1 || psttRegExpP[ CSpREFIX - 1 + idsP ].idAdam != sa_SSSoR ) ) ;  //THE OUTERMOST MUST BE AN AND GROUP
        if( POOP ) return ;
    }

    const boolT bOutermost = idsP == 1 ;
    const boolT bOr = psttRegExpP[ CSpREFIX - 1 + idsP ].idAdam == sa_SSSoR ;
    const countT idsLath = strIdLathExpressionF( tinP , psttRegExpP , idsP ) ;
    if( bOr ) csttMinP = - 1 ;                                                          //U::BUG: HANDLE WHEN OR GROUP IS EMPTY SO THIS IS NEVER REDUCED
    ZE( countT , offPatch ) ;
    ZE( countT , cIgnore ) ;
    ZE( boolT  , bArmPossibleIgnore ) ;
    ZE( countT , repeatMin ) ;
    ZE( countT , repeatMax ) ;
    ZE( countT , idfFixed ) ;
    for( countT idsi = idsP + 1 ; idsi < idsLath ; idsi ++ )
    {
        if( !idfFixed ) idfFixed = idsi ;                           // PRESUMED TO BE THE BEGINNING OF A FIXED LENGTH SUBSTRING

        if( cIgnore )
        {
            cIgnore -- ;
            idfFixed = 0 ;

            idsi = strIdLathExpressionF( tinP , psttRegExpP , idsi ) ;

            repeatMin = repeatMax = 0 ;
        }
        else if( psttRegExpP[ CSpREFIX - 1 + idsi ].idCaste == sc_ccSSS && ( psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam == sa_SSSrEPORTmATCH || psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam == sa_SSSrEPORTmATCHeND ) )
        {
            repeatMin = repeatMax = 0 ;

            if( idfFixed < idsi )
            {
                count2S c2f( idfFixed , idsi - 1 ) ;
                stFixedSmallP << (byteT*)&c2f ;
            }
            idfFixed = 0 ;
        }
        else if( psttRegExpP[ CSpREFIX - 1 + idsi ].idCaste == sc_ccSSS && ( psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam == sa_SSSaND || psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam == sa_SSSoR ) )
        {
            countT cPlatesSave = bOr ? stFixedSmallP : 0 ;

            ZE( countT , csttMin2 ) ;
            ZE( countT , csttMax2 ) ;
            const countT idsiSave = idsi ;
            strExpressionLengthMinMaxF( tinP , csttMin2 , csttMax2 , stFixedSmallP , idsi , psttRegExpP , flagsOptimizeP , pFlagsOverrideP , pcMinOverrideP , pcMaxOverrideP ) ;

            if( idfFixed && ( bArmPossibleIgnore || csttMin2 != csttMax2 ) )
            {
                if( idfFixed < idsiSave )
                {
                    count2S c2f( idfFixed , idsiSave - 1 ) ;
                    stFixedSmallP << (byteT*)&c2f ;
                }
                idfFixed = 0 ;
            }

            if( bOr )
            {
                stFixedSmallP.purgeF( tinP , cPlatesSave ) ;                                // ALWAYS DISCARD FIXED STRINGS ACCUMULATED WHILE PROCESSING AN OR EXPRESSION

                if( !bArmPossibleIgnore )
                {
                    countT csttMinMe = csttMin2 * ( repeatMin + 1 ) ;

                    if( csttMinP > csttMinMe ) csttMinP = csttMinMe ;
                }

                if( csttMaxP != - 1 )
                {
                    countT csttMaxMe = repeatMax == - 1
                        ? - 1
                        : csttMax2 * ( repeatMax + 1 )
                    ;

                    if( csttMaxP < csttMaxMe ) csttMaxP = csttMaxMe ;
                }
            }
            else
            {
                if( !bArmPossibleIgnore ) csttMinP += csttMin2 * ( repeatMin + 1 ) ;
                if( csttMaxP != - 1     ) csttMaxP = repeatMax == - 1
                    ? - 1
                    : csttMaxP + csttMax2 * ( repeatMax + 1 ) ;                            // CAN OVERFLOW FOR BAD FORM PARAMETER VALUES (HIGH VALUES OTHER THAN -1)
                ;
            }

            repeatMin = repeatMax = 0 ;
        }
        else if( psttRegExpP[ CSpREFIX - 1 + idsi ].idCaste == sc_ccSSSrEPEAT )
        {
            repeatMin = repeatMax = 0 ;
            countT idRepeatMin = psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam ;
            countT idRepeatMax = psttRegExpP[ CSpREFIX - 1 + idsi ].cNote  ;

            ZE( boolT , bPushFixedIf ) ;
            if( idRepeatMin == - 1 )
            {
                if( idRepeatMax == - 1 )                                                //U:: THIS CODE IS INCORRECT IN THAT IT FAILS TO HANDLE "DO NOT IGNORE" FLAG AND ALSO FAILS TO HANDLE IGNORE POSSIBILITY
                {
                    if( pFlagsOverrideP && pFlagsOverrideP[ offPatch ] && !( F(pFlagsOverrideP[ offPatch ]) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) ) bArmPossibleIgnore = 2 ;

                    repeatMin = pcMinOverrideP && pcMinOverrideP[ offPatch ]
                        ? pcMinOverrideP[ offPatch ] & ~BM_HIGH
                        : 0
                    ;

                    repeatMax = pcMaxOverrideP && pcMaxOverrideP[ offPatch ]
                        ? pcMaxOverrideP[ offPatch ] == - 1
                            ? - 1
                            : pcMaxOverrideP[ offPatch ] & ~BM_HIGH
                        : 0
                    ;

                    if( bArmPossibleIgnore || repeatMin != repeatMax ) bPushFixedIf = 1 ;

                    offPatch ++ ;
                }
                else cIgnore += idRepeatMax ;
            }
            else
            {
                if( idRepeatMin != idRepeatMax ) bPushFixedIf = 1 ;

                if( !bArmPossibleIgnore ) csttMinP += idRepeatMin ;
                if( csttMaxP != - 1     ) csttMaxP += idRepeatMax ;
            }

            if( bPushFixedIf )
            {
                if( idfFixed < idsi )
                {
                    count2S c2f( idfFixed , idsi - 1 ) ;
                    stFixedSmallP << (byteT*)&c2f ;
                }
                idfFixed = 0 ;
            }
        }
        else                                                                // A:ASSUME: IF GET HERE THEN idsi POINTS TO A SINGLE STROKE THAT IS EITHER REQUIRED OR AN ALLOWED VALUE DEPENDING UPON bOr
        {
            if( bArmPossibleIgnore || repeatMin != repeatMax )
            {
                if( idfFixed < idsi )
                {
                    count2S c2f( idfFixed , idsi - 1 ) ;
                    stFixedSmallP << (byteT*)&c2f ;
                }
                idfFixed = 0 ;
            }

            countT csttMin2 = 1 ;
            countT csttMax2 = 1 ;
            if( bOr )
            {
                if( !bArmPossibleIgnore )
                {
                    countT csttMinMe = csttMin2 * ( repeatMin + 1 ) ;

                    if( csttMinP > csttMinMe ) csttMinP = csttMinMe ;
                }

                if( csttMaxP != - 1 )
                {
                    countT csttMaxMe = repeatMax == - 1
                        ? - 1
                        : csttMax2 * ( repeatMax + 1 )
                    ;

                    if( csttMaxP < csttMaxMe ) csttMaxP = csttMaxMe ;
                }
            }
            else
            {
                if( !bArmPossibleIgnore ) csttMinP += csttMin2 * ( repeatMin + 1 ) ;
                if( csttMaxP != - 1     ) csttMaxP = repeatMax == - 1
                    ? - 1
                    : csttMaxP + csttMax2 * ( repeatMax + 1 ) ;                            // CAN OVERFLOW FOR BAD FORM PARAMETER VALUES (HIGH VALUES OTHER THAN -1)
                ;
            }

            repeatMin = repeatMax = 0 ;
        }

        if( bArmPossibleIgnore ) bArmPossibleIgnore -- ;
    }

    if( bOutermost && idfFixed && ( !bOr || csttMinP == csttMaxP ) )
    {
        count2S c2f( idfFixed , idsLath - 1 ) ;
        stFixedSmallP << (byteT*)&c2f ;
        idfFixed = 0 ;
    }

    idsP = idsLath ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ed.etherc.strExpressionLengthMinMaxF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ee.etherc.strIdOptimizedClosureF BEGIN
#define DDNAME       "3func.360021ee.etherc.strIdOptimizedClosureF"
#define DDNUMB      (countT)0x360021ee
#define IDFILE      (countT)0xdf5

//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i am a thin wrapper for another overload
my only function is to make it easy for a caller to provide a search pattern by specifying a patternC instance as a parameter
*/
/**/                                          

/*1*/countT etherC::strIdOptimizedClosureF( tinS& tinP , stackC* const pstMatchP , const flagsT flagsMatchP , countT& idFirstP , strokeS& sttQuoteP , const patternC& patP , const strokeS* psttBigP , const countT idLastP , sCountT idP )/*1*/
{
    return strIdOptimizedClosureF( tinP , pstMatchP , flagsMatchP , idFirstP , sttQuoteP , patP.psttPattern , psttBigP , patP.flagsOptimize , patP.pFlagsOverride , patP.pcMinOverride , patP.pcMaxOverride , idLastP , idP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ee.etherc.strIdOptimizedClosureF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ef.etherc.diskfindfileordirf BEGIN
#define DDNAME       "3func.360021ef.etherc.diskfindfileordirf"
#define DDNUMB      (countT)0x360021ef
#define IDFILE      (countT)0xdf6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
to find a directory, specify its leaf directory as pattern, with its parent directory in psttPathP
parameters
 tinP
 pInfoFileP
  must be 0
  if a matching file is not found, will remain 0
  else will point to an information structure for a single matching file or directory
  caller must delete, normally by using DEL()
 handleP
  must be newly constructed on woth call
  call me repeatedly until !handleP
 psttPathP
  example: T("///d/tmp/")
  must end in '/'
 pPatternP
  if 0 then i match all files and directories that are the immediate children of psttPathP
  else only matching are found
  to find a directory, specify its leaf as the pattern
*/
/**/

/*1*/voidT etherC::diskFindFileOrDirF( tinS& tinP , infoFileS*& pInfoP , handleC& handleP , const strokeS* const psttPathP , const patternC* pPatternP , const flagsT flagsP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttPathP ) ;
        //FV(flDISKfIND,flagsP)
        if( POOP ) return ;
        __( psttPathP->idAdam < 5 ) ;
        if( POOP ) return ;
        __( psttPathP[ CSpREFIX - 1 + psttPathP->idAdam ].idAdam - '/' ) ;
        if( POOP ) return ;
    }

    _IO_
    {
        _IO_
        IFwHEREkNOWStHREAD
        {
            _IO_
            if( tinP.pEther ) tinP.pEther->etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
        }

        {
            _IO_
            ZE( strokeS* , psttPath ) ;
            diskMapFileNameF( tinP , psttPath , psttPathP ) ; ___( psttPath ) ;
            __Z( psttPath ) ;

            if( !POOP )
            {
                _IO_
                __( psttPath->idCaste != sc_PREFIXlENGTH ) ;
                __( psttPath[ CSpREFIX     ] != S1C('/') ) ;
                __( psttPath[ CSpREFIX + 1 ] != S1C('/') ) ;
                __( psttPath[ CSpREFIX + 2 ] != S1C('/') ) ;
                if( psttPath[ CSpREFIX + 3 ] != S1C('/') )          //20190826@0844: ACCOMMODATE NETWORK FILE NAMES OF THE FORM "////netbiosname/disk/path/short"
                {
                    __( psttPath[ CSpREFIX + 4 ] != S1C('/') ) ;
                }
            }    

            if( !POOP )
            {
                _IO_
                ZE( osTextT* , postLike ) ;
                strMakeF( tinP , LF , postLike , T(psttPath)+T("*") ) ; ___( postLike ) ;
                osFileNameC osfnLike( tinP , third , postLike ) ;
                third.delF( tinP , postLike ) ;

                while( !POOP )
                {
                    _IO_
                    third.dosFindFileOrDirF( tinP , pInfoP , handleP , osfnLike ) ; ___( pInfoP ) ;

                         if( !pInfoP                                    ) { break ; }
                    else if( F(pInfoP->flags) & flFILEaTTR_DOTdIRECTORY ) { DEL( pInfoP ) ; }
                    else
                    {
                        _IO_

                        countT costOsName = thirdC::c_strlenIF( tinP , pInfoP->postOsName ) ;

                        if( !costOsName )
                        {
                            DEL( pInfoP ) ;
                            continue ;
                        }

                        if( !pPatternP )
                        {
                            _IO_
                            ifFileNameC iffn( tinP , third , pInfoP->postOsName ) ;
                            strMakeF( tinP , LF , pInfoP->psttIfoName , T(iffn) ) ; ___( pInfoP->psttIfoName ) ;
                            break ;
                        }
                        else
                        {
                            _IO_
                            //THIS BLOCK IS A SPEED OPTIMIZATION THAT REJECTS CANDIDATES THAT DO NOT CONTAIN REQUIRED LITERALS

                            //20210207@1347: EDITED THE NEXT CODE LINES TO ACCEPT DIRECTORY ENTRIES ; ORIGINAL COMMENT:  SHOULD BE IMPOSSIBLE SINCE NOT ACCEPTING DIRECTORY ENTRIES
                            // CONJ: WHEN I ADDED THIS SPEED OPTIMIZATION, I MISTAKENLY ASSUMED THAT I WOULD NOT WANT DIRECTORIES, NOTWITHSTANDING THE FUNCTION NAME

                            boolT bOk = 1 ;
                            osTextT* postc = pInfoP->postOsName + costOsName - 1 ; // NOW POINTS TO LATH CHAR ; WILL BE ADJUSTED TO POINT TO LEAF

                            {
                                countT cDo = costOsName - 1 ;
                                if( *postc == '\\' )
                                {
                                    postc -- ;
                                    cDo   -- ;
                                }

                                if( *postc == '\\' ) bOk = 0 ; // SHOULD BE IMPOSSIBLE SINCE IT WOULD IMPLY A NULL LENGTH DIRECTORY NAME
                                else
                                {
                                    while( cDo -- )
                                    {
                                        if( postc[ - 1 ] == '\\' ) break ;
                                        else                       postc -- ;
                                    }
                                }
                            }
                            // NOW EITHER !bOk OR postc POINTS TO LEAF

                            if( !bOk ) { DEL( pInfoP ) ; }
                            else
                            {
                                for( countT offLit = 0 ; offLit < sizeof pPatternP->ppostLiteral / sizeof pPatternP->ppostLiteral[ 0 ] && pPatternP->ppostLiteral[ offLit ] ; offLit ++ )
                                {
                                    _IO_
                                    countT costLit = thirdC::c_strlenIF( tinP , pPatternP->ppostLiteral[ offLit ] ) ;
                                    if( pPatternP->ppostLiteral[ offLit ][ costLit - 1 ] == '/' ) pPatternP->ppostLiteral[ offLit ][ costLit - 1 ] = '\\' ; // PATCH THE LITERAL SO THAT IT WILL MATCH ITS BASE OS MAPPING (SLASH TO BACKSLASH) ; NOTE: THIS HAS IMPLICATIONS IF THE patternC INSTANCE IS USED MULTIPLE TIMES (IT WILL BE PATCHED ONLY WO TIME) ; THIS IS DONE HERE RATHER THAN IN patternC BECAUSE patternC CAN BE USED FOR SEARCHES OTHER THAN FOR FILES SO FUTURE CODE MIGHT USE THE LITERALS IN WAYS THAT WOULD NOT WANT THE PATCH

                                    osTextT* postHit = thirdC::c_strstrIF( tinP , postc , pPatternP->ppostLiteral[ offLit ] ) ;
                                    if
                                    (
                                        !postHit
                                        ||
                                        (
                                            !offLit
                                            &&
                                            F(pPatternP->flagsLiterals) & flPATTERNlITERALS_LITERALbEGINNING
                                            &&
                                            postHit - postc
                                        )
                                    )
                                    {
                                        _IO_
                                        bOk = 0 ;
                                        break ;
                                    }

                                    if( !pPatternP->ppostLiteral[ offLit + 1 ] && F(pPatternP->flagsLiterals) & flPATTERNlITERALS_LITERALeNDING )
                                    {
                                        _IO_
                                        osTextT* poste = postc + thirdC::c_strlenIF( tinP , postc ) ;
                                        while( postHit && postHit + costLit < poste )
                                        {
                                            _IO_
                                            postc += costLit ;
                                            postHit = thirdC::c_strstrIF( tinP , postc , pPatternP->ppostLiteral[ offLit ] ) ;
                                        }
                                        if( !postHit )
                                        {
                                            _IO_
                                            bOk = 0 ;
                                            break ;
                                        }
                                    }
                                }

                                if( !bOk ) { DEL( pInfoP ) ; }
                                else
                                {
                                    _IO_
                                    ifFileNameC iffn( tinP , third , pInfoP->postOsName ) ;
                                    strMakeF( tinP , LF , pInfoP->psttIfoName , T(iffn) ) ; ___( pInfoP->psttIfoName ) ;

                                    fileNameC fn( tinP , *this , pInfoP->psttIfoName ) ;

                                    if( !fn ) { DEL( pInfoP ) ; }
                                    else
                                   {
                                        _IO_
                                        IFpATTERN( *this , *pPatternP , fn ) { break ; }
                                        else                                 { DEL( pInfoP ) ; }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            delF( tinP , psttPath ) ;
        }

        IFwHEREkNOWStHREAD
        {
            _IO_
            if( tinP.pEther ) tinP.pEther->etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021ef.etherc.diskfindfileordirf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f0.etherc.diskfindfileordirf BEGIN
#define DDNAME       "3func.360021f0.etherc.diskfindfileordirf"
#define DDNUMB      (countT)0x360021f0
#define IDFILE      (countT)0xdf7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
it is illegal to refer to this symbol in the definition of an adam
returns the single file that is exactly identified by psttLikeP
psttLikeP contains a string such as "///ideafarm/ephemeral/domains/com/foo/myfile"
psttLikeP must not contain wildcards
arguments
 psttNameP
 handleP
 psttPathP
  must not be 0
  must not specify a root directory, e.g. T("///x/")
 pPatternP
  may be 0
*/
/**/

//U: IMPOTENCE IF handleP BEFORE OR AFTER I OBTAIN A FILE (OR, ALLOW IT BUT CALL CLOSEEARLY)

/*1*/voidT etherC::diskFindFileOrDirF( tinS& tinP , strokeS*& psttNameP , handleC& handleP , const strokeS* const psttPathP , const patternC* pPatternP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( psttPathP ) ;
        if( POOP ) return ;
        __( psttPathP->idAdam < 5 ) ;
        if( POOP ) return ;
    }

    _IO_
    {
        ZE( infoFileS* , pInfo ) ;
        diskFindFileOrDirF( tinP , pInfo , handleP , psttPathP , pPatternP ) ; ___( pInfo ) ;
        if( pInfo )
        {
            strMakeF( tinP , LF , psttNameP , pInfo->psttIfoName ) ; ___( psttNameP ) ;
            DEL( pInfo ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f0.etherc.diskfindfileordirf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f1.etherc.diskfindfileordirf BEGIN
#define DDNAME       "3func.360021f1.etherc.diskfindfileordirf"
#define DDNUMB      (countT)0x360021f1
#define IDFILE      (countT)0xdf8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
examples
 simplest
evaluates to the number of files found
if a wildcard ("*" or "?") is specified for the disk, remote drives are excluded from the search
i will silently quit early if *tinP.pcQuit
 if i quit early for this reason, my results are useable but incomplete
i will not 
arguments
 pstt1FoundP
  can be 0 or not 0
  if not 0 then must be a string of strings, and my results will be appended
   a file will not be included in the append if it is already present in the list
  will contain a string of strings
   use the FORsTRINGSiN1 macro to obtain each string
  if no files are found, pstt1FoundP will be set to the null string
 psttPathP
  must not be 0
  must not specify a root directory, e.g. T("///x/")
 csttExtraP
 cMaxP
  can be 0
  if not 0, then is the maximum number of matching files to report in pstt1FoundP
*/
/**/

/*1*/countT etherC::diskFindFileOrDirF( tinS& tinP , strokeS*& pstt1FoundP , const strokeS* const psttPathP , const patternC* pPatternP , soulC* pSoulP , grabC* pGrabP , const countT csttExtraP , const countT cMaxP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttPathP ) ;
        if( POOP ) return 0 ;
        __( psttPathP->idAdam < 5 ) ;
        __( psttPathP->idCaste != sc_PREFIXlENGTH ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    ZE( countT , cItems ) ;
    IFsCRATCH
    {
        stackC stFound( tinP , third , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
        {
            ZE( strokeS* , psttPath ) ;
            if
            (
                   psttPathP[ CSpREFIX     ] == S1C('/')
                && psttPathP[ CSpREFIX + 1 ] == S1C('/')
                && psttPathP[ CSpREFIX + 2 ] == S1C('/')
                &&
                (
                    (
                          psttPathP[ CSpREFIX + 3 ] == S1C('/')           // NETBIOS      NAME OF FORM "////netbios/d/path/short"
                       && psttPathP[ CSpREFIX + 4 ] != S1C('/')
                    )
                    ||
                    (
                          psttPathP[ CSpREFIX + 3 ] != S1C('/')           // LOCAL MAPPED NAME OF FORM "///d/path/short"
                       && psttPathP[ CSpREFIX + 4 ] == S1C('/')
                    )
                )
            )
            {
                strFuseF(            tinP , psttPath , psttPathP ) ; ___( psttPath ) ;
            }
            else { diskMapFileNameF( tinP , psttPath , psttPathP ) ; ___( psttPath ) ; }

            if( POOP ) ;
            else if( psttPath && ( psttPath[ CSpREFIX + 3 ] == S1C('*') || psttPath[ CSpREFIX + 3 ] == S1C('?') ) )
            {
                strokeS psttDisk[ CSpREFIX + 4 ] ;
                SETpREFIX( psttDisk , 4 ,0 ) ;
                psttDisk[ CSpREFIX     ] = '/' ;
                psttDisk[ CSpREFIX + 1 ] = '/' ;
                psttDisk[ CSpREFIX + 2 ] = '/' ;
                psttDisk[ CSpREFIX + 3 ] = 0 ;
                countT cRem = cMaxP ;

                for( psttDisk[ CSpREFIX + 3 ] = S1C('c') ; psttDisk[ CSpREFIX + 3 ] <= S1C('z') ; ++ psttDisk[ CSpREFIX + 3 ] )
                {
                    ZE( infoDiskS* , pInfoDisk ) ;
                    {
                        SCOOPS
                        tinP.pEtScratch->diskInfoF( tinP , pInfoDisk , psttDisk , 1 ) ; ___( pInfoDisk ) ; //U::NOT IN HERE
                        if( POOP ) { POOPRqUIET ; }
                    }

                    if( pInfoDisk )
                    {
                        if( pInfoDisk->bLocal )
                        {
                            ZE( strokeS* , psttPath2 ) ;
                            strMakeF( tinP , LF , psttPath2 , psttDisk , psttPath ? psttPath->idAdam : 0 ) ; ___( psttPath2 ) ;
                            ZE( strokeS* , psttTmp ) ;
                            countT idf = 5 ;
                            ZE( countT , idLathI ) ;
                            strSubstringF( tinP , psttTmp , idf , idLathI , psttPath ) ; ___( psttTmp ) ;
                            strFuseF( tinP , psttPath2 , psttTmp ) ; ___( psttPath2 ) ;
                            delF( tinP , psttTmp ) ;
                            ZE( strokeS* , pstt2Found ) ;
                            countT cFoundHere = diskFindFileOrDirF( tinP , pstt2Found , psttPath2 , pPatternP , pSoulP , pGrabP , csttExtraP , cRem ) ; ___( pstt2Found ) ;
                            FORsTRINGSiN2( pstt2Found )
                            {
                                strokeS* psttv = psttOldC( tinP , *this , psttc2 ) ; ___( psttv ) ; //U::O: CONVERT THIS FUNCTION TO TAKE A stackC PARAMETER, AND WRITE AN OVERLOAD WRAPPER TO RETURN A STRING OF STRINGS
                                stFound << psttv ;
                            }
                            delF( tinP , pstt2Found ) ;
                            cRem   -= cFoundHere ;
                            delF( tinP , psttPath2 ) ;
                        }
                        DEL( pInfoDisk ) ;
                    }
                
                    if( ( tinP.pcQuit && *tinP.pcQuit ) || ( cMaxP && !cRem ) ) break ;
                }
            }
            else
            {
                handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                ZE( strokeS* , psttA ) ;
                {
                    SCOOPS
                    tinP.pEtScratch->diskFindFileOrDirF( tinP , psttA , handle , psttPath , pPatternP ) ; ___( psttA ) ;
                    if( POOP ) { POOPRqUIET ; }
                }

                countT cRem = cMaxP ;
                while( psttA )
                {
                    //if( !( cRem % TUCK ) ) { CONoUTrAW( "." ) ; }
                    ZE( boolT , bDots ) ;
                    {
                        boolT bDir = psttA && psttA[ CSpREFIX - 1 + psttA->idAdam ].idAdam == '/' ;

                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                        ZE( strokeS* , psttw ) ;
                        strWordF( tinP , psttw , psttA , sttq , S1C('/') , - 1 - bDir ) ; ___( psttw ) ;

                        bDots = 
                            !strCompareF( tinP , psttw , T("..") ) ||
                            !strCompareF( tinP , psttw , T(".") )
                        ;
                        delF( tinP , psttw ) ;
                    }

                    if( !bDots )
                    {
                        stFound << psttA ; psttA = 0 ;
                        if( cRem ) cRem -- ;
                    }
                    else delF( tinP , psttA ) ;

                    if( ( tinP.pcQuit && *tinP.pcQuit ) || ( cMaxP && !cRem ) )
                    {
                        if( ~handle ) handle.closeIfF() ;
                        break ;
                    }

                    {
                        SCOOPS
                        tinP.pEtScratch->diskFindFileOrDirF( tinP , psttA , handle , psttPath , pPatternP ) ; ___( psttA ) ;
                        if( POOP ) { POOPRqUIET ; }
                    }
                }
            }
            delF( tinP , psttPath ) ;

            countT cstte = csttExtraP ;
            if( stFound )
            {
                boolT bWoth = 1 ;
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                do
                {
                    strokeS* psttw = (strokeS*)stFound.downF( tinP , hDown ) ;
                    if( bWoth ) bWoth = 0 ;
                    else if( psttw ) cstte += CSpREFIX + psttw->idAdam ;
                }
                while( !POOP && ~hDown ) ;
            }

            while( stFound )
            {
                ZE( strokeS* , psttw ) ;
                stFound >> psttw ;

                ZE( boolT , bDup ) ;
                if( pstt1FoundP )
                {
                    FORsTRINGSiN1( pstt1FoundP )
                    {
                        if( !strCompareF( tinP , psttc1 , psttw ) )
                        {
                            bDup = 1 ;
                            break ;
                        }
                    }
                }

                if( !bDup )
                {
                    cItems ++ ;
                    strFuseSeparateF( tinP , pstt1FoundP , psttw , 0 , 0 , pSoulP , pGrabP , cstte ) ; ___( pstt1FoundP ) ;
                }
                delF( tinP , psttw ) ;
            }

            if( !pstt1FoundP && !pGrabP ) { strFuseF( tinP , pstt1FoundP , T("") , pSoulP , pGrabP , csttExtraP ) ; ___( pstt1FoundP ) ; }
        }
    }

    return cItems ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f1.etherc.diskfindfileordirf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f2.etherc.strPatternFromWildcardsStrictF BEGIN
#define DDNAME       "3func.360021f2.etherc.strPatternFromWildcardsStrictF"
#define DDNUMB      (countT)0x360021f2
#define IDFILE      (countT)0xdf9

//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::strPatternFromWildcardsStrictF( tinS& tinP , strokeS*& psttRegExpP , flagsT& flagsOptimizeP , flagsT*& pFlagsOverrideP , countT*& pcMinOverrideP , countT*& pcMaxOverrideP , const strokeS* const psttWildP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( psttRegExpP ) ;
        __NZ( pFlagsOverrideP ) ;
        __NZ( pcMinOverrideP ) ;
        __NZ( pcMaxOverrideP ) ;
        __Z( psttWildP ) ;
        if( POOP ) return ;
    }

    newF( tinP , LF , pFlagsOverrideP , psttWildP->idAdam + 1 ) ; ___( pFlagsOverrideP ) ;
    newF( tinP , LF , pcMinOverrideP  , psttWildP->idAdam + 1 ) ; ___( pcMinOverrideP  ) ;
    newF( tinP , LF , pcMaxOverrideP  , psttWildP->idAdam + 1 ) ; ___( pcMaxOverrideP  ) ;
    ZE( countT , offo ) ;

    TN( tn , "" ) ;
    TN( tre , "" ) ; tre = tn + S2(sa_SSSaND,sc_ccSSS) ;
    
    for( countT ids = 1 ; ids <= psttWildP->idAdam ; ids ++ )
    {
        switch( psttWildP[ CSpREFIX - 1 + ids ].idAdam )
        {
            case '?' :
            {
                tre += tn

                    +S2(sa_SSSrEPORTmATCH,sc_ccSSS)                  // 123456789abcde
                        +S2(sa_SSSoR,sc_ccSSS)
                            +S2(sa_SSSmARKaNY,sc_cSSSmARK)
                        +S2(sa_SSSoReND,sc_ccSSS)
                    +S2(sa_SSSrEPORTmATCHeND,sc_ccSSS)                  // 123456789abcde

                ;

                break ;
            }
            case '*' :
            {
                tre += tn

                    +S2(sa_SSSrEPORTmATCH,sc_ccSSS)                  // 123456789abcde
                        +S3(-1,sc_ccSSSrEPEAT,-1)                    // 15000002.signc
                        +S2(sa_SSSoR,sc_ccSSS)
                            +S2(sa_SSSmARKaNY,sc_cSSSmARK)
                        +S2(sa_SSSoReND,sc_ccSSS)
                    +S2(sa_SSSrEPORTmATCHeND,sc_ccSSS)

                ;

                pFlagsOverrideP[ offo    ] = flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG ;
                pcMinOverrideP[  offo    ] = BM_HIGH |   0 ;
                pcMaxOverrideP[  offo ++ ] = BM_HIGH | - 1 ;

                ids ++ ;
                while( ids <= psttWildP->idAdam && ( psttWildP[ CSpREFIX - 1 + ids ].idAdam == '*' || psttWildP[ CSpREFIX - 1 + ids ].idAdam == '?' ) ) ids ++ ;        // IF WILDCARD THEN SKIP
                if( ids > psttWildP->idAdam ) ids = 0 ;

                if( ids ) ids -- ;

                break ;
            }
            default :
            {
                tre += tn + psttWildP[ CSpREFIX - 1 + ids ] ;

                break ;
            }
        }

        if( !ids ) break ;
    }

    flagsOptimizeP = flSTRiDoPTIMIZEDcLOSURE_NOlEFTOVERS ;

    pFlagsOverrideP[ offo    ] = 0 ;
    pcMinOverrideP[  offo    ] = 0 ;
    pcMaxOverrideP[  offo ++ ] = 0 ;

    tre += tn + S2(sa_SSSaNDeND,sc_ccSSS) ;

    strMakeF( tinP , LF , psttRegExpP , tre ) ; ___( psttRegExpP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f2.etherc.strPatternFromWildcardsStrictF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f3.etherc.openssl_shakehandsasserverf BEGIN
#define DDNAME       "3func.360021f3.etherc.openssl_shakehandsasserverf"
#define DDNUMB      (countT)0x360021f3
#define IDFILE      (countT)0xdfa


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/voidT etherC::openSsl_shakeHandsAsServerF( tinS& tinP , const handleC& hWrapperP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( ~hWrapperP ) ;
        if( POOP ) return ;
    }

    _IO_

    thirdC::openSsl_shakeHandsAsServerIF( tinP , hWrapperP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f3.etherc.openssl_shakehandsasserverf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f4.etherc.openssl_peekf BEGIN
#define DDNAME       "3func.360021f4.etherc.openssl_peekf"
#define DDNUMB      (countT)0x360021f4
#define IDFILE      (countT)0xdfb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**//*1*/countT etherC::openSsl_peekF( tinS& tinP , byteT* const pbP , const countT cbP , const handleC& hWrapperP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( pbP ) ;
        __Z( cbP ) ;
        __Z( ~hWrapperP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    return thirdC::openSsl_peekIF( tinP , pbP , cbP , hWrapperP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f4.etherc.openssl_peekf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f5.etherc.etherDispenseSerialNumberF BEGIN
#define DDNAME       "3func.360021f5.etherc.etherDispenseSerialNumberF"
#define DDNUMB      (countT)0x360021f5
#define IDFILE      (countT)0xdfc


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/count04T etherC::etherDispenseSerialNumberF( tinS& tinP , const strokeS* const psttFileP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __Z( psttFileP ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    fileC fi( tinP , psttFileP , ifcOPENaCCESS_WR , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeO , flFILEaTTR_null , flFILEc_null , 0 , 0 ) ;

    ZE( count04T , idLath ) ;
    ZE( countT   , cbIn   ) ;
    if( fi.idOpenResultF( tinP ) == ifcOPENrESULT_EXISTED )
    {
        cbIn = sizeof idLath ;
        fileReadF( tinP , (byteT*)&idLath , cbIn , fi , 0 ) ;
    }

    if( cbIn != sizeof idLath ) idLath = 0 ;        //THIS SHOULD BE IMPOSSIBLE

    //if( !idLath ) idLath = (countT)( - 0x10 ) ; //REMOVE IN PRODUCTION

    idLath ++ ;
    if( !idLath ) { BLAMMO ; }

    count2S c2z ;
    fileSetPtrF( tinP , fi , flSETfILEpTR_BEGINNING , c2z ) ;
    fileWriteF(  tinP , fi , (byteT*)&idLath , sizeof idLath ) ;

    return idLath ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f5.etherc.etherDispenseSerialNumberF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f6.etherc.osTimeToOldTimeMsF BEGIN
#define DDNAME       "3func.360021f6.etherc.osTimeToOldTimeMsF"
#define DDNUMB      (countT)0x360021f6
#define IDFILE      (countT)0xdfd



//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


/*
*/
/**/

/*1*/countT etherC::osTimeToOldTimeMsF( tinS& tinP , countT time1P , sCountT time2P )/*1*/
{
    ZE( countT , oldTimeMs ) ;
    ZE( countT , v_d ) ;
    ZE( countT , v_m ) ;
    ZE( sCountT , v_y ) ;
    ZE( countT , v_hh ) ;
    ZE( countT , v_mm ) ;
    ZE( countT , v_ss ) ;
    ZE( countT , v_ms ) ;
    ZE( countT , v_dow ) ;
    osTimeToOldTimeF( tinP , v_ms , v_ss , v_mm , v_hh , v_d , v_m , v_y , v_dow , time1P , time2P , flOStIMEfROMoLDtIME_OLDtIMEiSutc ) ;
    __( v_m ) ;
    __( v_y ) ;

    if( !POOP )
    {
        v_hh += v_d  *   24 ;
        v_mm += v_hh *   60 ;
        v_ss += v_mm *   60 ;
        v_ms += v_ss * 1000 ;
        oldTimeMs = v_ms ;
    }

    return oldTimeMs ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f6.etherc.osTimeToOldTimeMsF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f7.etherc.etherDoHttpJobF BEGIN
#define DDNAME       "3func.360021f7.etherc.etherDoHttpJobF"
#define DDNUMB      (countT)0x360021f7
#define IDFILE      (countT)0xdfe


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//'K': "KEEP"
#define PUSHK(prPostsP)                                                                             \
                                                                                                    \
    if( prPostsP )                                                                                  \
    {                                                                                               \
        *pStkBody << (byteT*)0 ;                                                                    \
        new( 0 , tinP , (byteT*)&(*pStkBody)[ - 1 ] , sizeof( pbRefC ) ) pbRefC( *prPostsP ) ;      \
    }

//'D': "DELETE"
#define PUSHD(prPostsP)                                                                             \
                                                                                                    \
    if( prPostsP )                                                                                  \
    {                                                                                               \
        *pStkBody << (byteT*)0 ;                                                                    \
        new( 0 , tinP , (byteT*)&(*pStkBody)[ - 1 ] , sizeof( pbRefC ) ) pbRefC( *prPostsP ) ;      \
        pbRefC* prDoomed = (prPostsP) ;                                                             \
        DEL( prDoomed )                                                                             \
    }

#define PUSHsNIP(meP,idSnipP)                                                                       \
                                                                                                    \
    {                                                                                               \
        ZE( pbRefC* , prPosts ) ;                                                                   \
        (meP).getSnipF( tinP , prPosts , (idSnipP) ) ; ___( prPosts ) ;                             \
        PUSHD( prPosts ) ;                                                                          \
    }

#define PUSHrEPLY(prPostP) PUSHK( REPLY.##prPostP ) ;

#define REPLY REF( httpReplyS , *pRefReply )

/*1*/voidT etherC::etherDoHttpJobF( tinS& tinP , taskDrivenServerJobS& jobP , socketC*& psoP , sessionC& sessionP , countT idPortMeP , nicNameC nnMeP )/*1*/
{
    _IO_

    //THREADmODE4oN( flTHREADmODE4_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY )
    if( jobP.cArg )
    {
        _IO_
        {
            _IO_
            TESTsCRATCH //U:: TO FIND A BUG
        }

        //traceF( tinP , T("etherDoHttpJobF / ++++") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

        //CS:CODEsYNC: 3300005b 3600212d
        //traceF( tinP , T("etherDoHttpJobF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
        //traceF( tinP , T("etherDoHttpJobF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
        //traceF( tinP , T("etherDoHttpJobF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
        //traceF( tinP , T("etherDoHttpJobF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
        //traceF( tinP , T("etherDoHttpJobF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
        //traceF( tinP , T("etherDoHttpJobF / ++++ ") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;

        //tinP.pAdamGlobal1->pEtThreadMain->etherTestF( tinP ) ; //U:: TO FIND A BUG

        HTTPsYSpARAMS( jobP.cArg )
        if( !pHttpEatKeyValuePairsCBFP ) pHttpEatKeyValuePairsCBFP = httpEatKeyValuePairsDefaultCBF ;

        ZE( boolT , bOsFire ) ;
        ZE( countT , idPortPeer ) ;
        ZE( countT , cHamburgersThisSession ) ;

        ZE( strokeS* , psttLeverKV ) ;
        switchC swKV( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttLeverKV ) ;

        ZE( strokeS* , psttLeverUrlTally ) ;
        switchC swTally( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttLeverUrlTally ) ;

        TN( tb4 , "    " ) ;
        TN( tSlashDeadman1    , "/deadman1" ) ;
        TN( tSlashDeadman2    , "/deadman2" ) ;
        {
            _IO_
            count8S& c8P = *(count8S*)cArgAppP ;
            puseC& pusePeanutP = *(puseC*)c8P.c1 ;

            cacheC* pzCache = meP.pzCacheF() ;

            if( pHttpRawCommandServerCBFP )
            {
                ZE( pbRefC* , prPosts ) ;
                meP.getSnipF( tinP , prPosts , ifcIDsNIPpREDEFINED_HTTPcONTINUEwELCOME ) ; ___( prPosts ) ;
                if( prPosts && COSTS( *prPosts ) ) psoP->writeF( tinP , POSTS( *prPosts ) , COSTS( *prPosts ) ) ;
                DEL( prPosts ) ;
            }

            //CONoUTrAW( T("------------------------- B E G I N   S E S S I O N -------------------------------------------------------\r\n") ) ;
            //LOGrAW( T("------------------------- B E G I N   S E S S I O N -------------------------------------------------------\r\n") ) ;
            ZE( countT , idEscaped ) ;
            TN( tSlash                          , "/"              ) ;
            TN( tSlashTalkBody                  , "/talk.body"     ) ;
            TN( tQuest                          , "?"              ) ;
            TN( tNameTestFavIcon                , "/favicon.ico"   ) ;
            TN( tFileFavIcon                    , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/7reso.71000002.favicon.ico" ) ;
            TN( tNameCacheTalkBodySuffixPublic  , "(public)"       ) ;
            TN( tNameCacheTalkBodySuffixPrivate , "(private)"      ) ;
            TN( tBadge                          , "badge"          ) ;
            TN( tBadgeForce                     , "force"          ) ;
            TN( tCacheSearch                    , "cachesearch"    ) ;
            TN( tNo                             , "no"             ) ;
            ZE( countT  , timeTotalPending1 ) ;
            ZE( sCountT , timeTotalPending2 ) ;
            const countT maxAgeDeadman              = osTimeToOldTimeMsF( tinP , - 1       ) ;
            const countT maxAgeMsFileFavIcon        = osTimeToOldTimeMsF( tinP , - 1       ) ;
            const countT maxAgeMsFile               = osTimeToOldTimeMsF( tinP , TICK << 4 ) ;
            const countT maxAgeMsNotFileTalkBody    = osTimeToOldTimeMsF( tinP , TOCK << 2 ) ;
            const countT maxAgeMsNotFileNotTalkBody = osTimeToOldTimeMsF( tinP , TICK << 4 ) ;
            ZE( countT , cRequests ) ;
            TESTsCRATCH //U:: TO FIND A BUG
            while( !third && !POOP )
            {
                _IO_
                ZE( countT  , timeRead1 ) ;
                ZE( sCountT , timeRead2 ) ;
                osTimeNowF( tinP , timeRead1 , timeRead2 ) ;

                TESTsCRATCH //U:: TO FIND A BUG
                TELL( "reading a request" ) ;
                ZE( strokeS* , psttName ) ;
                ZE( strokeS* , psttQueryKV ) ;
                ZE( strokeS* , psttAgent ) ;
                ZE( osTextT* , postBody ) ;
                ZE( boolT , bClose ) ;
                ZE( boolT , bFail ) ;
                //traceF( tinP , T("etherDoHttpJobF / calling readRequestF") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                {
                    _IO_
                    idEscaped = meP.readRequestF( tinP , bFail , psttName , psttQueryKV , swKV , psttLeverKV , psttAgent , postBody , bClose , psoP , pHttpRawCommandServerCBFP ? "!@" : 0 ) ;
                }
                ___( psttName ) ;
                ___( psttLeverKV ) ;
                ___( psttAgent ) ;
                ___( postBody ) ;

                if( bFail ) break ;

                traceF( tinP , T("U:: [psttName]:       ")+T(psttName) ) ;
                traceF( tinP , T("U:: [psttQueryKV]:    ")+T(psttQueryKV) ) ;

                {
                    _IO_
                    TESTsCRATCH //U::TO FIND A BUG
                }
                __Z(  psttName->idCaste                   ) ;  //U::20201021@1217: TO FIND A BUG: NULL CASTE DETECTED WITHIN getReplyF
                __NZ( psttName->idCaste - sc_PREFIXlENGTH ) ;  //U::20201021@1217: TO FIND A BUG: NULL CASTE DETECTED WITHIN getReplyF

                //U:: COMMENTED OUT TO FIND A BUG
                //if( ++ cRequests == 0x10 ) bClose = 1 ;     // ATTACK PREVENTION (IN CONJUNCTION WITH CONNECTION RATE LIMIT)

                ZE( boolT , bNoCacheSearch ) ;
                ZE( boolT , bNoCacheStore  ) ;
                ZE( boolT , bBadgeOk ) ;
                if( swKV.cFlavorsF( tinP ) )
                {
                    _IO_
                    if( swKV.idSlotOfLeverF( tinP , (countT)(strokeS*)tCacheSearch ) )
                    {
                        _IO_
                        psttLeverKV = tCacheSearch ;
                        strokeS* psttzv = (strokeS*)(countT&)swKV ;
                        if( psttzv && !strCompareF( tinP , psttzv , tNo ) )
                        {
                            bNoCacheSearch = 1 ;
                            traceF( tinP , T("i have been told to not search the cache") ) ;
                        }
                    }

                    if( swKV.idSlotOfLeverF( tinP , (countT)(strokeS*)tBadge ) )
                    {
                        _IO_
                        psttLeverKV = tBadge ;
                        strokeS* psttzv = (strokeS*)(countT&)swKV ;

                        if( !strCompareF( tinP , psttzv , tBadgeForce ) )
                        {
                            if( jobP.nnPeer == nnMeP ) bBadgeOk = 1 ;       // ONLY I AM ALLOWED TO FORCE THE BADGE (SUPPRESS BADGE VALIDATION)
                        }
                        else
                        {
                            countT badge = strDigitsToSCountF( tinP , psttzv ) ;
                            bBadgeOk = meP.isBadgeOkF( tinP , badge , jobP.nnPeer ) ;
                        }
                        traceF( tinP , T(bBadgeOk?"badge is ok":"badge is NOT ok") ) ;
                    }
                }

                bBadgeOk = 1 ; //U:: WORKAROUND BECAUSE @ IS SERVED BY MULTIPLE FACTORIES, YET BADGE PAIRS ARE NOT YET PROPOGATED TO ALL FACTORIES

                // SCHEDULING PRIORITY
                // RUDE   : SERVING DEADMAN
                // RUSH   : ACCEPTING CONNECTIONS, LAUNCHING MY THREAD, SERVING CACHED RESPONSES
                // NORMAL : GENERAL SERVER WORKLOAD
                // LAZY   : CONSTRUCTING AND SERVING NONCACHED RESPONSES

                const boolT bQuery = psttQueryKV && psttQueryKV->idAdam ;
                ZE( boolT , bDeadman1 ) ;
                ZE( boolT , bDeadman2 ) ;
                ZE( boolT , bTalkBody ) ;
                ZE( boolT , bFavIcon ) ;
                ZE( countT , idDesireOld ) ;
                TN( tNameCache , psttName ) ;
                {
                    _IO_
                    bDeadman1 = !strCompareF( tinP , psttName  , tSlashDeadman1 ) ;
                    bDeadman2 = !strCompareF( tinP , psttName  , tSlashDeadman2 ) ;
                    bTalkBody = !strCompareF( tinP , psttName  , tSlashTalkBody ) ;

                    if( bDeadman1 || bDeadman2 )                // DEADMAN QUERY IS SUPPRESSED IN tNameCache BECAUSE ITS ONLY FUNCTION IS TO UNIQUELY IDENTIFY THE DEADMAN REQUEST FOR TRACING / DEBUGGING
                    {
                        _IO_
                             if( bDeadman1 ) idDesireOld = osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE    ) ;      // DEADMAN1 TESTS ARE TO DETECT THAT I AM DEAD
                        else if( bDeadman2 ) idDesireOld = osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIEST ) ;      // DEADMAN2 TESTS ARE TO DETECT THAT I AM OVERWHELMED
                        else                 idDesireOld = osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZY    ) ;
                        bClose = 1 ; //O:OPTIMIZATION
                    }
                    else
                    {
                        _IO_
                        {                                   //CASE IS IGNORED FOR psttName WHEN SETTING tNameCache
                            ZE( strokeS* , psttLower ) ;
                            strConvertToLowerCaseF( tinP , psttLower , psttName ) ; ___( psttLower ) ;
                            bFavIcon = !strCompareF( tinP , psttLower , tNameTestFavIcon ) ;
                            tNameCache = T(psttLower) ;
                            delF( tinP , psttLower ) ;
                        }

                        if( bFavIcon ) ;
                        else if( bTalkBody ) tNameCache += bBadgeOk ? tNameCacheTalkBodySuffixPrivate : tNameCacheTalkBodySuffixPublic ;
                        else if( bQuery    ) tNameCache += tQuest+T(psttQueryKV) ;
                    }
                }

                ZE( countT  , timeStart1 ) ;
                ZE( sCountT , timeStart2 ) ;
                osTimeNowF( tinP , timeStart1 , timeStart2 ) ;

                countT  timeElRead1 = timeStart1 ;
                sCountT timeElRead2 = timeStart2 ;
                osTimeSubtractF( tinP , timeElRead1 , timeElRead2 , timeRead1 , timeRead2 ) ;

                if( bDeadman1 )
                {
                    _IO_
                    traceF( tinP , T("deadman1 accepted      [idCycle,timeAccepted]  :    ")+T(psttQueryKV)+tb4+TTF(jobP.timeAccepted1,jobP.timeAccepted2)    +tb4+T("accepted")      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    traceF( tinP , T("deadman1 job created   [idCycle,timeJobCreated]:    ")+T(psttQueryKV)+tb4+TTF(jobP.timeJobCreated1,jobP.timeJobCreated2)+tb4+T("job created")   , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    traceF( tinP , T("deadman1 job popped    [idCycle,timeJobPopped] :    ")+T(psttQueryKV)+tb4+TTF(jobP.timeJobPopped1,jobP.timeJobPopped2)  +tb4+T("job popped")    , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    traceF( tinP , T("deadman1 do job        [idCycle,timeDoJob]     :    ")+T(psttQueryKV)+tb4+TTF(jobP.timeDoJob1,jobP.timeDoJob2)          +tb4+T("do job")        , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    traceF( tinP , T("deadman1 reading began [idCycle,timeRead]      :    ")+T(psttQueryKV)+tb4+TTF(timeRead1,timeRead2)                      +tb4+T("reading began") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                    countT  timeElA2R1 = timeRead1 ;
                    sCountT timeElA2R2 = timeRead2 ;
                    osTimeSubtractF( tinP , timeElA2R1 , timeElA2R2 , jobP.timeAccepted1 , jobP.timeAccepted2 ) ;

                         if( timeElA2R2                   ) traceF( tinP , T("deadman1 accept to reading ****!**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   0 ) ) traceF( tinP , T("deadman1 accept to reading ****0**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   1 ) ) traceF( tinP , T("deadman1 accept to reading ****1**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   2 ) ) traceF( tinP , T("deadman1 accept to reading ****2**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   3 ) ) traceF( tinP , T("deadman1 accept to reading ****3**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   4 ) ) traceF( tinP , T("deadman1 accept to reading ****4**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   5 ) ) traceF( tinP , T("deadman1 accept to reading ****5**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   6 ) ) traceF( tinP , T("deadman1 accept to reading ****6**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   7 ) ) traceF( tinP , T("deadman1 accept to reading ****7**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   8 ) ) traceF( tinP , T("deadman1 accept to reading ****8**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >>   9 ) ) traceF( tinP , T("deadman1 accept to reading ****9**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >> 0xa ) ) traceF( tinP , T("deadman1 accept to reading ****a**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >> 0xb ) ) traceF( tinP , T("deadman1 accept to reading ****b**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >> 0xc ) ) traceF( tinP , T("deadman1 accept to reading ****c**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >> 0xd ) ) traceF( tinP , T("deadman1 accept to reading ****d**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >> 0xe ) ) traceF( tinP , T("deadman1 accept to reading ****e**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    else if( timeElA2R1 > ( TICK >> 0xf ) ) traceF( tinP , T("deadman1 accept to reading ****f**** [idCycle,timeRead]:    ")+T(psttQueryKV)+tb4+TTF(timeElA2R1,timeElA2R2) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                }

                //if( bDeadman1 || bDeadman2 ) traceF( tinP , T(psttName)+T(!bClose?"        connection will be kept open":"        CONNECTION WILL BE CLOSED") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                TESTsCRATCH //U::TO FIND A BUG
                if( bFail )
                {
                    _IO_
                    //TlIST( tListHuman ) ;
                    //tListHuman += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(jobP.nnPeer) ;
                    //tListHuman += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(jobP.nnPeer) ;
                    //tListHuman += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(jobP.nnPeer) ;
                    //
                    //TlIST( tListAllowWoMore ) ;
                    //tListAllowWoMore += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(jobP.nnPeer) ;
                    //tListAllowWoMore += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(jobP.nnPeer) ;
                    //tListAllowWoMore += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(jobP.nnPeer) ;
                    //
                    //TlIST( tListBlock ) ;
                    //tListBlock += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(jobP.nnPeer) ;
                    //tListBlock += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(jobP.nnPeer) ;
                    //tListBlock += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(jobP.nnPeer) ;
                    //
                    //TlIST( tListWhite ) ;
                    //tListWhite += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(jobP.nnPeer) ;
                    //tListWhite += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(jobP.nnPeer) ;
                    //tListWhite += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(jobP.nnPeer) ;
                    //
                    //boolT bHuman  = diskFileExistsF( tinP , tListHuman  ) ;
                    //boolT bWhite  = diskFileExistsF( tinP , tListWhite  ) ;
                    //boolT bWoMore = diskFileExistsF( tinP , tListAllowWoMore ) ;
                    //
                    //if( !bHuman && !bWhite && !bWoMore )    //U::20200804@2120: I'VE SEEN THIS BLOCK FACTORY 3-5, SO THIS IS TOO STRICT; WITH THIS CODE, I AM BLOCKING INNOCENT PEERS
                    //{
                    //    TN( tSay , "blocked because readRequestF failed, which is attacker behavior" ) ;
                    //
                    //    IFsCRATCH
                    //    {
                    //        SCOOPS
                    //        tinP.pEtScratch->boxPutF( tinP , tListBlock , tSay , tSay.csF( tinP ) ) ;
                    //        if( POOP ) { POOPRqUIET ; }
                    //    }
                    //}

                    //CS:CODEsYNC: 3300005b 3600212d
                    if( bDeadman1 || bDeadman2 ) traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_2 ) ;
                    traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                    traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                    traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                    traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                    traceF( tinP , T("etherDoHttpJobF / error: readRequestF failed") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;

                    break ;
                }

                ZE( boolT , bFileChallenge ) ;
                ZE( boolT , bFileArchive ) ;
                if( !bDeadman1 && !bDeadman2 && psttName->idAdam )
                {
                    _IO_
                    //  yyyy
                    // "2013/!ideafarm."
                    TN( tPattern , "" ) ; tPattern =

                        T("")
                        +S2(sa_SSSaND,sc_ccSSS)
                            +tSlash
                            +S3(3,sc_ccSSSrEPEAT,3)
                                +S2(sa_SSSoR,sc_ccSSS)
                                    +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
                                    +T("x")                                                 // "x" IS ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
                                +S2(sa_SSSoReND,sc_ccSSS)
                            +T("/!ideafarm.")
                        +S2(sa_SSSaNDeND,sc_ccSSS)

                    ;


                    // "/.well-known/acme-challenge/ZkmjsTYwqPtrWqTRu-3VunoLb_X656Tg8iILtFL8ZWE"
                    TN( tPatternChallenge , "/.well-known/acme-challenge/" ) ;

                    bFileChallenge = 1 == strIdF( tinP , tPatternChallenge , psttName ) ;
                    bFileArchive   = 1 == strIdF( tinP , tPattern          , psttName ) ;
                }

                //CS:CODEsYNC: 360021f7 3600212d
                const countT idTraceDivert = !strCompareF( tinP , psttName , tSlashDeadman1 )
                    ? ifcIDtRACEdIVERT_3
                    : !strCompareF( tinP , psttName , tSlashDeadman2 )
                        ? ifcIDtRACEdIVERT_4
                        : !strCompareF( tinP , psttName , tSlash )
                            ? ifcIDtRACEdIVERT_5
                            : !bFileArchive && !bFileChallenge
                                ? ifcIDtRACEdIVERT_6
                                : ifcIDtRACEdIVERT_7
                ;

                //traceF( tinP , T("accepted      [timeAccepted]  :    ")+TTF(jobP.timeAccepted1,jobP.timeAccepted2)    +tb4+T("accepted")      , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                //traceF( tinP , T("job created   [timeJobCreated]:    ")+TTF(jobP.timeJobCreated1,jobP.timeJobCreated2)+tb4+T("job created")   , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                //traceF( tinP , T("job popped    [timeJobPopped] :    ")+TTF(jobP.timeJobPopped1,jobP.timeJobPopped2)  +tb4+T("job popped")    , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                //traceF( tinP , T("do job        [timeDoJob]     :    ")+TTF(jobP.timeDoJob1,jobP.timeDoJob2)          +tb4+T("do job")        , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                //traceF( tinP , T("reading began [timeRead]      :    ")+TTF(timeRead1,timeRead2)                      +tb4+T("reading began") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                              //traceF( tinP , T("U:: etherDoHttpJobF / O    ")+TT(timeElRead1,timeElRead2)+tb4+T(psttName) , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / O    ")+TT(timeElRead1,timeElRead2)+tb4+T(psttName) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    request:    \"")+T(psttName)+T("\"")+(psttQueryKV?tb4+T(psttQueryKV):T("")) , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    request:    \"")+T(psttName)+T("\"")+(psttQueryKV?tb4+T(psttQueryKV):T("")) , bDeadman1 || bDeadman2 ? flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY : flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                              //traceF( tinP , T("U:: etherDoHttpJobF / N") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / N") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                TESTsCRATCH //U::TO FIND A BUG
                ZE( cachedS* , pzCached ) ;
                if( pzCache && !bNoCacheSearch )
                {
                    _IO_
                    traceF( tinP , T("querying cache") ) ;

                                  //traceF( tinP , T("U:: etherDoHttpJobF / M") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / M") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    pzCache->grabF( tinP , TAG( TAGiDnULL ) ) ;
                                  //traceF( tinP , T("U:: etherDoHttpJobF / L") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / L") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    pzCached = (*pzCache)( tinP , tNameCache ) ;
                    if( pzCached ) ; // traceF( tinP , T("found in cache:    ")+tNameCache , bDeadman1 || bDeadman2 ? flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE : flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    else
                    {
                                      //traceF( tinP , T("U:: etherDoHttpJobF / K") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / K") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        pzCache->ungrabF( tinP ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / J") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / J") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        //traceF( tinP , T("NOT found in cache:    ")+tNameCache , bDeadman1 || bDeadman2 ? flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE : flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    }
                                  //traceF( tinP , T("U:: etherDoHttpJobF / I") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / I") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                }

                              //traceF( tinP , T("U:: etherDoHttpJobF / H") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / H") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                if( pzCached )
                {
                    _IO_
                    traceF( tinP , T("found in cache") ) ;

                                  //traceF( tinP , T("U:: etherDoHttpJobF / G") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / G") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    POINTERc ptr_pbBlob = *pzCached->pPtr_pbBlob ;
                    PrEF( bytesC , bytesBlob , ptr_pbBlob ) ;

                    boolT bPrefixed = pzCached->cArg ;

                    countT cbzBlob = bPrefixed
                        ? COSTS( bytesBlob )
                        : pzCached->cbBlob
                    ;

                    const byteT* pbzBlob = bPrefixed
                        ? POSTS( bytesBlob )
                        :        bytesBlob
                    ;

                    pzCache->ungrabF( tinP ) ;

                    TELL( "writing reply" ) ;
                    IFsCRATCH
                    {
                        SCOOPS
                        psoP->writeF( tinP , pbzBlob , cbzBlob ) ;
                        if( !POOP )
                        {
                            //traceF( tinP , T("etherDoHttpJobF: wrote reply from cache") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        }
                        else
                        {
                            POOPRqUIET
                            if( bDeadman1 || bDeadman2 ) traceF( tinP , T("etherDoHttpJobF: could not write to socket 96 [nnPeer]:    ")+T(jobP.nnPeer) , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                            bClose = 1 ;
                        }
                    }
                                  //traceF( tinP , T("U:: etherDoHttpJobF / F") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / F") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                }
                else
                {
                    _IO_
                    {
                        _IO_
                        TESTsCRATCH //U::TO FIND A BUG
                    }

                                  //traceF( tinP , T("U:: etherDoHttpJobF / E") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / E") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    if( bFavIcon )
                    {
                        _IO_
                                      //traceF( tinP , T("U:: etherDoHttpJobF / D") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / D") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        ZE( byteT* , pbIcon ) ;
                        ZE( countT , cbIcon ) ;
                        boxGetShadowF( tinP , pbIcon , cbIcon , tFileFavIcon ) ; ___( pbIcon ) ;

                        TN( tReply , "" ) ; tReply = T("HTTP/1.1 200 OK\r\nServer: IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System (tm)\r\nContent-Type: image/x-icon\r\nContent-Length: ")+TF4(cbIcon,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;

                                      //traceF( tinP , T("U:: etherDoHttpJobF / C") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / C") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        IFsCRATCH
                        {
                            SCOOPS
                            psoP->writeF( tinP , (osTextT*)tReply , tReply.csF( tinP ) ) ;
                            psoP->writeF( tinP , pbIcon , cbIcon ) ;
                            if( POOP )
                            {
                                POOPRqUIET
                                traceF( tinP , T("etherDoHttpJobF: could not write to socket 980") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                bClose = 1 ;
                            }
                        }

                                      //traceF( tinP , T("U:: etherDoHttpJobF / B") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / B") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        if( pzCache && !bNoCacheStore )
                        {
                            _IO_
                            ZE( strokeS* , psttn ) ;
                            strMakeF( tinP , LF , psttn , tNameCache ) ; ___( psttn ) ;

                            ZE( byteT* , pbBlob ) ;
                            countT       cbBlob = tReply.csF( tinP ) + cbIcon ;
                            newF( tinP , LF , pbBlob , cbBlob ) ; ___( pbBlob ) ;
                            if( pbBlob )
                            {
                                byteT* pbc = pbBlob ;
                                countT cbDo = cbBlob - cbIcon ;
                                memCopyF( tinP , pbc , (osTextT*)tReply , cbDo   ) ; pbc += cbDo ;
                                memCopyF( tinP , pbc , pbIcon           , cbIcon ) ;

                                pzCache->pushF( tinP , psttn , pbBlob , cbBlob , maxAgeMsFileFavIcon , 0 ) ; // "0": "NOT LENGTH PREFIXED"

                                //U:: LATER, PURGE BY NUMBER OF PLATES, BY AGE, AND/OR BY SIZE
                            }
                        }

                        delF( tinP , pbIcon ) ;

                        //if( bClose ) traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    closing connection") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / A") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / A") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    }
                    else if( bFileChallenge )
                    {
                        _IO_
                        //                               "////" postCRAFTWORKfACTORY "/d/tmp/certbot.challenge/.well-known/acme-challenge
                        TN( tFileIn , "" ) ; tFileIn = T("////" postCRAFTWORKfACTORY "/d/tmp/certbot.challenge")+T(psttName) ;

                                      //traceF( tinP , T("U:: etherDoHttpJobF / z") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / z") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        ZE( byteT* , pbIn ) ;
                        ZE( countT , cbIn ) ;
                        IFsCRATCH
                        {
                            SCOOPS
                            tinP.pEtScratch->boxGetShadowF( tinP , pbIn , cbIn , tFileIn ) ; ___( pbIn ) ;
                            if( POOP )
                            {
                                POOPRqUIET
                                traceF( tinP , T("etherDoHttpJobF: could not get challenge file") ) ;
                                bClose = 1 ;
                            }
                        }

                        TN( tReply , "" ) ; tReply = T("HTTP/1.1 200 OK\r\nServer: IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System (tm)\r\nContent-Type: text/plain\r\nContent-Length: ")+TF4(cbIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;

                        IFsCRATCH
                        {
                            SCOOPS
                            psoP->writeF( tinP , (osTextT*)tReply , tReply.csF( tinP ) ) ;
                            psoP->writeF( tinP , pbIn , cbIn ) ;
                            if( POOP )
                            {
                                POOPRqUIET
                                //traceF( tinP , T("etherDoHttpJobF: could not write to socket 1118") ) ;
                                bClose = 1 ;
                            }
                        }
                        delF( tinP , pbIn ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / y") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / y") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    }
                    else if( bFileArchive )
                    {
                        _IO_
                                      //traceF( tinP , T("U:: etherDoHttpJobF / x") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / x") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        ZE( fileWindowsC* , pFW ) ;

                        TN( tFileIn3e , "" ) ; tFileIn3e = T("////factory3/e/archive")+T(psttName) ;
                        TN( tFileIn8x , "" ) ; tFileIn8x = T("////factory8/x/archive")+T(psttName) ;
                        TN( tFileIn8y , "" ) ; tFileIn8y = T("////factory8/y/archive")+T(psttName) ;
                        TN( tFileIn8z , "" ) ; tFileIn8z = T("////factory8/z/archive")+T(psttName) ;

                        textC* pptFileIn[]=
                        {
                            &tFileIn3e ,
                            &tFileIn8x ,
                            &tFileIn8y ,
                            &tFileIn8z ,
                        } ;

                                      //traceF( tinP , T("U:: etherDoHttpJobF / w") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / w") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        for( countT offf = 0 ; offf < sizeof pptFileIn / sizeof pptFileIn[ 0 ] ; offf ++ )
                        {
                            //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    attempting to open file:    ")+*pptFileIn[offf] , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                            IFsCRATCH
                            {
                                SCOOPS
                                _IO_
                                //tinP.pc Utility[ 0 ] ++ ; //U:: TO FIND A BUG
                                pFW = new( 0 , tinP , LF ) fileWindowsC( tinP , *tinP.pEtScratch , *pptFileIn[ offf ] , flFILEwINDOW_DOnOTvALIDATE | flFILEwINDOW_DOnOTmAKEdIRiFnEEDED , 1 ) ; ___( pFW ) ; //DOnOTvALIDATE IS A WORKAROUND TO PREVENT dosOpenIF FROM USING THE WRONG poopC INSTANCE (THIS IS A CODE DESIGN ERROR: NO IMAGE FUNCTION SHOULD ASSUME A PARTICULAR thirdC OR etherC INSTANCE TO USE WHEN CALLING NONIMAGE FUNCTIONS)
                                //tinP.pc Utility[ 0 ] -- ; //U:: TO FIND A BUG
                                if( !POOP ) break ;
                                else
                                {
                                    POOPRqUIET
                                    DEL( pFW ) ;
                                }
                            }
                        }

                                      //traceF( tinP , T("U:: etherDoHttpJobF / v") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / v") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        if( !pFW )
                        {
                            for( countT offf = 0 ; offf < sizeof pptFileIn / sizeof pptFileIn[ 0 ] ; offf ++ )
                            {
                                traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    error: could not open file:    ")+*pptFileIn[offf] , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                            }

                            TN( tBody , "The page (or other resource) that you requested does not exist here.\r\n\r\nIf you think that this is our error, please let us know.\r\n" ) ;

                            TN( tReply , "" ) ; tReply = T("HTTP/1.1 404 Not Found\r\nServer: IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System (tm)\r\nContent-Type: text")+T("\r\nContent-Length: ")+TF4(tBody.csF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;

                            IFsCRATCH
                            {
                                SCOOPS
                                psoP->writeF( tinP , (osTextT*)tReply , tReply.csF( tinP ) ) ;
                                if( POOP )
                                {
                                    POOPRqUIET
                                    traceF( tinP , T("etherDoHttpJobF: could not write to socket 1004") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                }
                            }
                        }
                        else
                        {
                            //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    serving file [cbFileLo,cbFileHi]:    ")+TF3(pFW->cbFileLoF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pFW->cbFileHiF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9) ) ;
                            countT pcLoHi[] = { pFW->cbFileLoF() , pFW->cbFileHiF() } ;
                            sCountC cbBody( tinP , *this , pcLoHi , SC << 1 ) ;

                            const countT cbWindow = TICK >> 2 ;

                            boolT bCacheThis = !pcLoHi[ 1 ] && pcLoHi[ 0 ] <= cbWindow ;

                            TN( tContentType , "" ) ;
                            {
                                ZE( strokeS* , psttLower ) ;
                                strConvertToLowerCaseF( tinP , psttLower , psttName ) ; ___( psttLower ) ;

                                     if( psttLower->idAdam - 3 == strIdF( tinP , T(".avi" ) , psttLower , - 1 ) ) tContentType = T("video/avi" ) ;
                                else if( psttLower->idAdam - 3 == strIdF( tinP , T(".mp4" ) , psttLower , - 1 ) ) tContentType = T("video/mp4" ) ;
                                else if( psttLower->idAdam - 3 == strIdF( tinP , T(".mp3" ) , psttLower , - 1 ) ) tContentType = T("audio/mp3" ) ;
                                else if( psttLower->idAdam - 3 == strIdF( tinP , T(".png" ) , psttLower , - 1 ) ) tContentType = T("image/png" ) ;
                                else if( psttLower->idAdam - 3 == strIdF( tinP , T(".jpg" ) , psttLower , - 1 ) ) tContentType = T("image/jpeg") ;
                                else if( psttLower->idAdam - 4 == strIdF( tinP , T(".jpeg") , psttLower , - 1 ) ) tContentType = T("image/jpeg") ;

                                delF( tinP , psttLower ) ;
                            }

                            TN( tReply , "" ) ; tReply = T("HTTP/1.1 200 OK\r\nServer: IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System (tm)\r\nContent-Type: ")+tContentType+T("\r\nContent-Length: ")+TF4(cbBody,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;

                            IFsCRATCH
                            {
                                SCOOPS
                                psoP->writeF( tinP , (osTextT*)tReply , tReply.csF( tinP ) ) ;
                                if( POOP )
                                {
                                    POOPRqUIET
                                    traceF( tinP , T("etherDoHttpJobF: could not write to socket 980") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                    bClose = 1 ;
                                }
                            }

                            while( !POOP )
                            {
                                ZE( byteT* , pbw ) ;
                                ZE( countT , cbw ) ;
                                pFW->getF( tinP , pbw , cbw , cbWindow ) ;

                                if( !pbw || !cbw )
                                {
                                    //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    all file windows have been written") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                    break ;
                                }
                                else
                                {
                                    //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    writing file window [cbw]:    ")+TF2(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                                    IFsCRATCH
                                    {
                                        SCOOPS
                                        psoP->writeF( tinP , pbw , cbw ) ;
                                        if( POOP )
                                        {
                                            POOPRqUIET
                                            traceF( tinP , T("etherDoHttpJobF: could not write to socket 965") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                            bClose = 1 ;
                                        }
                                    }

                                    //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    wrote   file window [cbw]:    ")+TF2(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                                    if( bCacheThis )
                                    {
                                        bCacheThis = 0 ;

                                        if( pzCache && !bNoCacheStore )
                                        {
                                            ZE( strokeS* , psttn ) ;
                                            strMakeF( tinP , LF , psttn , tNameCache ) ; ___( psttn ) ;

                                            ZE( byteT* , pbBlob ) ;
                                            countT       cbBlob = tReply.csF( tinP ) + cbw ;
                                            newF( tinP , LF , pbBlob , cbBlob ) ; ___( pbBlob ) ;
                                            if( pbBlob )
                                            {
                                                byteT* pbc = pbBlob ;
                                                countT cbDo = cbBlob - cbw ;
                                                memCopyF( tinP , pbc , (osTextT*)tReply , cbDo ) ; pbc += cbDo ;
                                                memCopyF( tinP , pbc , pbw              , cbw  ) ;

                                                pzCache->pushF( tinP , psttn , pbBlob , cbBlob , maxAgeMsFile , 0 ) ; // "0": "NOT LENGTH PREFIXED"

                                                //U:: LATER, PURGE BY NUMBER OF PLATES, BY AGE, AND/OR BY SIZE
                                            }
                                        }
                                    }
                                }
                            }
                            DEL( pFW ) ;
                        }

                        //if( bClose ) traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    closing connection") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / u") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / u") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    }
                    else
                    {
                        _IO_
                        //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    preparing nonfile response") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                        //const boolT bDebug = !strCompareF( tinP , psttName , T("/nobot/action/myaccount.html") ) ;
                        //const boolT bDebug = 1 ;
                        //if( bDebug )
                        //{
                        //    countT foo = 2 ;
                        //}

                        //CONoUTrAW( T(DASH127 "\r\n")+T(psttName)+T("\r\n") ) ;

                        //COMMENT OUT IN PRODUCTION: USED TO SEE KEYVALUES SUBMITTED USING FORMS
                        //{
                        //    _IO_
                        //    TN( tSay , "" ) ;
                        //
                        //    countT cFlavors = swKV.cFlavorsF( tinP ) ;
                        //    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        //    {
                        //        psttLeverKV = (strokeS*)swKV.leverF( tinP , idf ) ;
                        //        strokeS*& zsttv = *(strokeS**)&(countT&)swKV ;
                        //
                        //        tSay += T("[")+T(psttLeverKV)+T("]: \"")+T(zsttv)+T("\"\r\n") ;
                        //    }
                        //    if( tSay.csF( tinP ) ) { POPUP( tSay ) ; }
                        //}

                                      //traceF( tinP , T("U:: etherDoHttpJobF / t") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / t") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        TESTsCRATCH //U::TO FIND A BUG
                        ZE( countT , idHeadFlavorOverride ) ;
                        {
                            TELL( "getting idHeadFlavorOverride" ) ;
                            sessionC& session = jobP.sessions( tinP , jobP.nnPeer ) ;
                            session.touchF( tinP , psttName ) ;    
                            idHeadFlavorOverride = session.getIdHeadFlavorOverrideF( tinP ) ;
                            //POPUPcOUNT( "idHeadFlavorOverride before: " , idHeadFlavorOverride ) ;

                            {
                                _IO_
                                TN( tKeyHeadFlavor , "headflavor" ) ;

                                countT cFlavors = swKV.cFlavorsF( tinP ) ;
                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                {
                                    psttLeverKV = (strokeS*)swKV.leverF( tinP , idf ) ;
                                    if( !strCompareF( tinP , psttLeverKV , tKeyHeadFlavor ) )
                                    {
                                        strokeS* psttv = *(strokeS**)&(countT&)swKV ;
                                        if( psttv )
                                        {
                                                 if( !strCompareF( tinP , psttv , T("verbose") ) ) idHeadFlavorOverride = ifcIDhEADfLAVOR_VERBOSE ;
                                            else if( !strCompareF( tinP , psttv , T("terse"  ) ) ) idHeadFlavorOverride = ifcIDhEADfLAVOR_TERSE   ;

                                            if( idHeadFlavorOverride ) session.setIdHeadFlavorOverrideF( tinP , idHeadFlavorOverride ) ;
                                        }
                                        break ;
                                    }
                                }
                            }
                            //POPUPcOUNT( "idHeadFlavorOverride after: " , idHeadFlavorOverride ) ;

                            TELL( "inspecting session age" ) ;
                            {
                                countT cTouch = session.cTouchF( tinP ) ;
                                timeS timeAge = session.ageF( tinP ) ;

                                if( cTouch > TUCK && !timeAge.time2 )
                                {
                                    countT cTock = timeAge.time1 / TOCK ;
                                    if( /*U::TO FIND A BUG: cTock &&*/ cTouch / cTock )
                                    {
                                        //nicNameC nnMe = socketC::nicNameIF( tinP , *this ) ;
                                        //nicNameC nnLocal( NICnAMElOCAL ) ;
                                        //if( nnMe != jobP.nnPeer && jobP.nnPeer != nnLocal ) boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/ipdos/attackers/")+T(jobP.nnPeer) ) ; 
                                    }
                                }
                            }

                            TELL( "inspecting idEscaped" ) ;
                            if( idEscaped || POOP )
                            {
                                delF( tinP , psttName ) ;
                                delF( tinP , psttAgent ) ;
                                delF( tinP , postBody ) ;
                                break ;
                            }

                            TELL( "maybe changing privileges to hide ads" ) ;
                            if
                            (
                                !strCompareF( tinP , psttName , T("/nobot/noads.html") ) ||
                                !strCompareF( tinP , psttName , T("/robots.txt") )
                            )
                            session.privilegesF( tinP , flSESSIONpRIVILEGE_HIDEiMAGEaDS | flSESSIONpRIVILEGE_HIDEaDlINKS ) ;
                        }
                        TESTsCRATCH //U::TO FIND A BUG

                                      //traceF( tinP , T("U:: etherDoHttpJobF / s") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / s") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        TELL( "calling keyvalue eater" ) ;
                        ZE( strokeS* , psttKVReport ) ;
                        (*pHttpEatKeyValuePairsCBFP)( tinP , *this , bQuitP , psttKVReport , 0 /*DISABLED TO PREVENT ATTACK: T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(ifcIDaDAM_ROOTfORMdATAeATER)+T("/in/form") */ , swKV , psttLeverKV , jobP.sessions , jobP.nnPeer , psttName , psttQueryKV , psttAgent , postBody ) ;

                                      //traceF( tinP , T("U:: etherDoHttpJobF / r") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / r") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        TELL( "getting recycled items" ) ;
                        ZE( stackC* , pStkBody ) ; //EVERYTHING AFTER THE HTTP HEADER AND ITS TRAILING "\r\n\r\n"
                        (*this)( tinP , pStkBody , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_ALLOWzE | flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , sizeof( pbRefC ) ) ;

                                      //traceF( tinP , T("U:: etherDoHttpJobF / q") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / q") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        ZE( stackC* , pStkBodyDynamic ) ;
                        (*this)( tinP , pStkBodyDynamic , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_ALLOWzE | flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , sizeof( pbRefC ) ) ;

                                      //traceF( tinP , T("U:: etherDoHttpJobF / p") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / p") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        TESTsCRATCH //U::TO FIND A BUG
                        if( !pStkBody || !pStkBodyDynamic )
                        {
                            traceF( tinP , T("etherDoHttpJobF / error: recycler failure 2") , flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_2 ) ;
                            traceF( tinP , T("etherDoHttpJobF / error: recycler failure 2") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                            traceF( tinP , T("etherDoHttpJobF / error: recycler failure 2") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                            traceF( tinP , T("etherDoHttpJobF / error: recycler failure 2") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                            traceF( tinP , T("etherDoHttpJobF / error: recycler failure 2") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                        }
                        else
                        {
                                          //traceF( tinP , T("U:: etherDoHttpJobF / o") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                            if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / o") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                            TESTsCRATCH //U::TO FIND A BUG
                            TELL( "preparing to compile the reply" ) ;
                            ZE( boolT , bDebugLog ) ;
                            ZE( osTextT* , postsReply ) ;
                            {
                                TESTsCRATCH //U::TO FIND A BUG
                                ZE( httpReplyRefC* , pRefReply ) ;
                                {
                                    _IO_
                                    meP.getReplyF( tinP , pRefReply , psttName ) ; ___( pRefReply ) ;
                                }
                                TESTsCRATCH //U::TO FIND A BUG

                                if( !pRefReply )
                                {
                                    _IO_
                                    meP.getReplyF( tinP , pRefReply , T("!nf") ) ; ___( pRefReply ) ;
                                }
                                TESTsCRATCH //U::TO FIND A BUG

                                if( !pRefReply ) { BLAMMO ; }

                                //bDebugLog = REPLY.idSnipHttpPrefix == ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP ; //U::

                                countT idHeadFlavor = idHeadFlavorOverride
                                    ? idHeadFlavorOverride
                                    : REPLY.idForm == ifcIDfORMhTTPrEPLY_PINhEAD
                                        ? ifcIDhEADfLAVOR_TERSE
                                        : ifcIDhEADfLAVOR_VERBOSE
                                ;
                                //POPUPcOUNT( "idHeadFlavor after: " , idHeadFlavor ) ;

                                ZE( pbRefC* , prPostsPort            ) ;
                                ZE( pbRefC* , prPostsIdPort1         ) ;
                                ZE( pbRefC* , prPostsIdPort2         ) ;
                                ZE( pbRefC* , prPostsIdSession       ) ;
                                ZE( pbRefC* , prPostsBarMaroon2      ) ;
                                ZE( pbRefC* , prPostsBarGray         ) ;
                                ZE( pbRefC* , prPostsBarOrange       ) ;
                                ZE( pbRefC* , prPostsBarGreen        ) ;
                                ZE( pbRefC* , prPostsBarBrown        ) ;
                                ZE( pbRefC* , prPostsMugShot         ) ;
                                TESTsCRATCH //U::TO FIND A BUG
                                switch( REPLY.idSnipHttpPrefix )
                                {
                                    case ifcIDsNIPpREDEFINED_HTTPcONTINUEwELCOME :
                                    {
                                        break ;
                                    }
                                    case ifcIDsNIPpREDEFINED_HTTPoKiMAGEiCON :
                                    case ifcIDsNIPpREDEFINED_HTTPoKiMAGEgIF :
                                    case ifcIDsNIPpREDEFINED_HTTPoKiMAGEjPEG :
                                    case ifcIDsNIPpREDEFINED_HTTPoKmP3 :
                                    {
                                        PUSHrEPLY( prPostBody ) ;
                                        break ;
                                    }
                                    case ifcIDsNIPpREDEFINED_HTTPoKtEXThTML :
                                    case ifcIDsNIPpREDEFINED_HTTPfAILnOTfOUND :
                                    case ifcIDsNIPpREDEFINED_HTTPfAILmOVED :
                                    case ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP :
                                    {
                                                      //traceF( tinP , T("U:: etherDoHttpJobF / n") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / n") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                        TESTsCRATCH //U::TO FIND A BUG
                                        switch( REPLY.idForm )
                                        {
                                            case ifcIDfORMhTTPrEPLY_RAW :
                                            {
                                                              //traceF( tinP , T("U:: etherDoHttpJobF / m") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / m") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                TELL( "ifcIDfORMhTTPrEPLY_RAW" ) ;
                                                ZE( countT , idPortMe ) ;
                                                nicNameC nnMe ;
                                                psoP->myNameF( tinP , idPortMe , nnMe ) ;

                                                httpReplyS& info = *(httpReplyS*)&(refCounterC&)*pRefReply ;

                                                PUSHrEPLY( prPostBody ) ;

                                                if( REPLY.pCBF )
                                                {
                                                    _IO_
                                                    (*REPLY.pCBF)( tinP , *this , bQuitP , meP , cArgAppP , REPLY , *pStkBody , psttKVReport , swKV , psttLeverKV , jobP.sessions , jobP.nnPeer , psttName , psttQueryKV , psttAgent , postBody ) ;
                                                }
                                                              //traceF( tinP , T("U:: etherDoHttpJobF / l") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / l") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                break ;
                                            }
                                            case ifcIDfORMhTTPrEPLY_FULLcUSTOM :
                                            {
                                                              //traceF( tinP , T("U:: etherDoHttpJobF / k") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / k") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                TELL( "ifcIDfORMhTTPrEPLY_FULLcUSTOM" ) ;
                                                ZE( countT , idBannerAd ) ;
                                                if
                                                (
                                                    strCompareF( tinP , psttName , T("/"                          ) )              &&
                                                    strCompareF( tinP , psttName , T("/header/idea/slideshow.tellin.it.html") )    &&
                                                    strCompareF( tinP , psttName , T("/header/idea/slideshow.regrets.html") )
                                                )
                                                {
                                                    {
                                                        sessionC& session = jobP.sessions( tinP , jobP.nnPeer ) ;

                                                        countT idAd = session.dispenseIdF( tinP , 1 ) ;
                                                        const countT cAd = 8 ; //CS:CODEsYNC: 1d20003 0b5000d
                                                        if( idAd <= 4 ) ;
                                                        else if( idAd <= 4 + cAd ) idBannerAd = idAd - 4 ;
                                                        else if( idAd > cAd * 2 )
                                                        {
                                                            measureT mDo    = etherC::ranUniI_IF( tinP ) ;
                                                            measureT mCutDo = 1.0 / 4.0 ;
                                                            if( mDo < mCutDo )
                                                            {
                                                                measureT mSwitch = etherC::ranUniI_IF( tinP ) ;
                                                                measureT mCutSwitch = (measureT)1.0 / (measureT)cAd ;
                                                                idBannerAd = 1 + (countT)( mSwitch / mCutSwitch ) ;
                                                            }
                                                        }
                                                    }

                                                }

                                                TELL( "ifcIDfORMhTTPrEPLY_FULLcUSTOM/getting nnMe" ) ;
                                                ZE( countT , idPortMe ) ;
                                                nicNameC nnMe ;
                                                IFsCRATCH
                                                {
                                                    SCOOPS
                                                    psoP->myNameF( tinP , idPortMe , nnMe ) ;
                                                    if( POOP )
                                                    {
                                                        POOPRqUIET
                                                        traceF( tinP , T("etherDoHttpJobF: could not obtain socket my name 734") , flTRACE_FORCEnOsILENCE ) ;
                                                    }
                                                }

                                                //ZE( boolT , bShowAdLinks ) ;
                                                //if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_HIDEaDlINKS ) ) bShowAdLinks = 1 ;

                                                //ZE( boolT , bShowImageAds ) ;
                                                //if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_HIDEiMAGEaDS ) )
                                                //{
                                                //    measure04T mProb = !strCompareF( tinP , psttName , tSlash ) ? 1.0 / 8.0 : 1.0 / 4.0 ;
                                                //    bShowImageAds = etherC::ranUniI_IF( tinP ) <= mProb ; //"=" IS REDUNDANT BECAUSE ranUniC GUARANTEES RESULT STRICTLY LESS THAN RANGE 
                                                //}

                                                TELL( "ifcIDfORMhTTPrEPLY_FULLcUSTOM/making posts" ) ;
                                                strMakeF( tinP , LF , prPostsIdSession       , TF1((countT)sessionP)       , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdSession       ) ;
                                                strMakeF( tinP , LF , prPostsIdPort1         , TF1(idPortMe)               , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdPort1         ) ;
                                                strMakeF( tinP , LF , prPostsIdPort2         , TF1(idPortMe)               , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdPort2         ) ;
                                                strMakeF( tinP , LF , prPostsPort            , T((const strokeS*)*psoP)    , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsPort            ) ;
                                                strMakeF( tinP , LF , prPostsBarGray , T(

                                                        "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyGrayF() ;\">\r\n"
                                                            "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnOTEdIM " ; color:" ifcCOLORhTMLwHAT_FOREnOTEbRIGHT "\">\r\n"
                                                                "<SPAN class=spaXXSmall>\r\n"
                                                                    "<>\r\n "
                                                                "</SPAN>\r\n"
                                                            "</td>\r\n"
                                                        "</tr>\r\n"

                                                ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarGray ) ;

                                                if( idPortMe == ifcIDpORT_DOOR || idPortMe == ifcIDpORT_PANICdOOR )
                                                {
                                                    strMakeF( tinP , LF , prPostsBarGreen , T(

                                                            "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyGreenF() ;\">\r\n"
                                                                "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ; color=#060\">\r\n"
                                                                    "<SPAN class=spaXXSmall>\r\n"
                                                                        "<B>IdeaFarm</B> (tm) <B>City</B>"
                                                                        " <> <B>Federal Constitutional Protectorate of the United States of America</B>\r\n"
                                                                    "</SPAN>\r\n"
                                                                "</td>\r\n"
                                                            "</tr>\r\n"

                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarGreen ) ;
                                                }
                                                else
                                                {
                                                    strMakeF( tinP , LF , prPostsBarBrown , T(

                                                            "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyBrownF() ;\">\r\n"
                                                                "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTbROWN  " ; color=#840\">\r\n"
                                                                    "<SPAN class=spaXXSmall>\r\n"
                                                                        "<B>IdeaFarm</B> (tm) <B>Space</B>\r\n"
                                                                    "</SPAN>\r\n"
                                                                "</td>\r\n"
                                                            "</tr>\r\n"

                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarBrown ) ;
                                                }

                                                TELL( "ifcIDfORMhTTPrEPLY_FULLcUSTOM/pushing snips" ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD1         ) ;
                                                PUSHrEPLY( prPostTitle ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD2         ) ;
                                                PUSHrEPLY( prPostMetaDescription ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD3         ) ;
                                                PUSHrEPLY( prPostKeywords ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD4         ) ;
                                                PUSHrEPLY( prPostBody ) ;

                                                if( REPLY.pCBF )
                                                {
                                                    _IO_
                                                    (*REPLY.pCBF)( tinP , *this , bQuitP , meP , cArgAppP , REPLY , *pStkBody , psttKVReport , swKV , psttLeverKV , jobP.sessions , jobP.nnPeer , psttName , psttQueryKV , psttAgent , postBody ) ;
                                                }

                                                //THESE WERE REMOVED IN 2019. 20200729@1734: ENABLED WITHOUT ANALYSIS
                                                PUSHsNIP( meP , !sessionP.getIdAccountCommissionF( tinP ) ? ifcIDsNIPpREDEFINED_FOOT1 : ifcIDsNIPpREDEFINED_FOOT2 ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_FOOT3        ) ;
                                                              //traceF( tinP , T("U:: etherDoHttpJobF / j") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / j") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                break ;
                                            }
                                            case ifcIDfORMhTTPrEPLY_DEBUG :
                                            {
                                                break ;
                                            }
                                            case ifcIDfORMhTTPrEPLY_PINhEAD :
                                            case ifcIDfORMhTTPrEPLY_BIGhEAD :
                                            {
                                                              //traceF( tinP , T("U:: etherDoHttpJobF / i") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / i") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                TESTsCRATCH //U::TO FIND A BUG
                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD" ) ;
                                                sessionC& session = jobP.sessions( tinP , jobP.nnPeer ) ;
                                                ZE( countT , idBannerAd ) ;
                                                if
                                                (
                                                    idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE                                            &&
                                                    strCompareF( tinP , psttName , T("/"                          ) )              &&
                                                    strCompareF( tinP , psttName , T("/header/idea/slideshow.tellin.it.html") )    &&
                                                    strCompareF( tinP , psttName , T("/header/idea/slideshow.regrets.html") )
                                                )
                                                {
                                                    {

                                                        countT idAd = session.dispenseIdF( tinP , 1 ) ;
                                                        const countT cAd = 8 ; //CS:CODEsYNC: 1d20003 0b5000d
                                                        if( idAd <= 4 ) ;
                                                        else if( idAd <= 4 + cAd ) idBannerAd = idAd - 4 ;
                                                        else if( idAd > cAd * 2 )
                                                        {
                                                            measureT mDo    = etherC::ranUniI_IF( tinP ) ;
                                                            measureT mCutDo = 1.0 / 4.0 ;
                                                            if( mDo < mCutDo )
                                                            {
                                                                measureT mSwitch = etherC::ranUniI_IF( tinP ) ;
                                                                measureT mCutSwitch = (measureT)1.0 / (measureT)cAd ;
                                                                idBannerAd = 1 + (countT)( mSwitch / mCutSwitch ) ;
                                                            }
                                                        }
                                                    }

                                                }

                                                TESTsCRATCH //U::TO FIND A BUG
                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/getting nnMe" ) ;
                                                ZE( countT , idPortMe ) ;
                                                nicNameC nnMe ;
                                                IFsCRATCH
                                                {
                                                    SCOOPS
                                                    psoP->myNameF( tinP , idPortMe , nnMe ) ;
                                                    if( POOP )
                                                    {
                                                        POOPRqUIET
                                                        traceF( tinP , T("etherDoHttpJobF: could not obtain socket my name 611") , flTRACE_FORCEnOsILENCE ) ;
                                                    }
                                                }

                                                //DONE EARLY TO GIVE CBF AN EARLY CHANCE TO CHANGE STATE IN WAYS THAT WILL AFFECT BUILDING OF HEADER
                                                if( REPLY.pCBF )
                                                {
                                                    _IO_
                                                    TELL( T(psttName) ) ;
                                                    (*REPLY.pCBF)( tinP , *this , bQuitP , meP , cArgAppP , REPLY , *pStkBodyDynamic , psttKVReport , swKV , psttLeverKV , jobP.sessions , jobP.nnPeer , psttName , psttQueryKV , psttAgent , postBody ) ;
                                                }

                                                ZE( boolT , bAllowBigHead ) ;
                                                if( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_FULLhEADER ) bAllowBigHead = 1 ;
                                                else if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) idHeadFlavor = ifcIDhEADfLAVOR_TERSE ;

                                                //ZE( boolT , bShowAdLinks ) ;
                                                //ZE( boolT , bShowImageAds ) ;
                                                //if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                                //{
                                                    //if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_HIDEaDlINKS ) ) bShowAdLinks = 1 ;

                                                    //if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_HIDEiMAGEaDS ) )
                                                    //{
                                                    //    measure04T mProb = !strCompareF( tinP , psttName , tSlash ) ? 1.0 / 8.0 : 1.0 / 4.0 ;
                                                    //    bShowImageAds = etherC::ranUniI_IF( tinP ) <= mProb ; //"=" IS REDUNDANT BECAUSE ranUniC GUARANTEES RESULT STRICTLY LESS THAN RANGE 
                                                    //}
                                                //}

                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/making posts" ) ;
                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                                {
                                                    strMakeF( tinP , LF , prPostsIdSession       , TF1((countT)sessionP)       , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdSession       ) ;
                                                    strMakeF( tinP , LF , prPostsIdPort1         , TF1(idPortMe)               , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdPort1         ) ;
                                                    strMakeF( tinP , LF , prPostsIdPort2         , TF1(idPortMe)               , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdPort2         ) ;
                                                    strMakeF( tinP , LF , prPostsPort            , T((const strokeS*)*psoP)    , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsPort            ) ;
                                                }

                                                {
                                                    ZE( countT , idAccCommission ) ;
                                                    sessionC& session = jobP.sessions( tinP , jobP.nnPeer ) ;
                                                    idAccCommission      = session.getIdAccountCommissionF( tinP ) ; //MUST BE DONE AFTER DYNAMIC CONTENT CALL HAS BEEN MADE

                                                    strMakeF( tinP , LF , prPostsMugShot , idAccCommission

                                                        ? T("<IMG SRC=\"/blob/user.")+TF4(idAccCommission,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(".64x48.jpeg\" alt=\"\" border=\"0\">\r\n")
                                                        : T("<IMG onMouseOut=\"swatF();\" onMouseOver=\"flyF( this , 'The Earth, depicted with the Sun and Moon on a field of stars, is the official symbol for IdeaFarm " "(tm) Associates.  The lower hand, Youth, receives Earth from the upper hand, Elders.   A female breast appears in the place of a continent.  The wise infant does not bite his mother while suckling, and the wise elder never forgets his debt.  Love your Mother!' );\" SRC=\"/blob/ifc.ico\" alt=\"\" border=\"0\">\r\n")

                                                    , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsMugShot ) ;
                                                }

                                                TN( tUrl , POSTS( *REPLY.prPostUrl ) ) ;

                                                const boolT bIsRootPage =
                                                    idPortMe == ifcIDpORT_HTTP                      &&
                                                    (
                                                        !strCompareF( tinP , tSlash , tUrl ) ||
                                                        1 == strIdF( tinP , T("/?") , tUrl )
                                                    )
                                                ;

                                                //const boolT bIsLogoutPage = 1 == strIdF( tinP , T("/header/action/logout.html") , tUrl ) ;
                                                const boolT bIsHelpPage = !!strIdF( tinP , T("/nobot/help/") , tUrl ) ;
                                                const boolT bExistHelp  = REPLY.prPostPageHelp && COSTS( REPLY.prPostPageHelp ) ;

                                                TN( tHelp , bIsHelpPage
                                                    ? "aboutHelp"
                                                    : bExistHelp
                                                        ? "HELP"
                                                        : "help"
                                                ) ;

                                                TN( tFlyHelp , bExistHelp

                                                    ? " onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'A helpful information page is available for the page that you are viewing.' );\""
                                                    : " onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'A helpful information page is NOT available for the page that you are viewing, but click here anyway to view the general helpful information page for IdeaFarm " "(tm) City.' );\""

                                                ) ;

                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/making posts 2" ) ;
                                                {
                                                    ZE( strokeS* , psttEmail ) ;
                                                    sessionP.getEmailF( tinP , psttEmail ) ; ___( psttEmail ) ;

                                                    TN( tLinks , "" ) ;
                                                    TN( tSpace , " <> " ) ;

                                                    if( sessionP.getIdAccountCommissionF( tinP ) || sessionP.getIdAccountF( tinP ) ) // MIGHT HAVE LOGGED IN BY CLICKING AN OLD EMAIL LINK AND HAS NOT SELECTED A RECRUITER
                                                    {
                                                        if( tLinks.csF( tinP ) ) tLinks += tSpace ;

                                                        tLinks += psttEmail

                                                            ? T("<A HREF=\"/header/action/logout.html\" onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'Click here to log out.  This is important if you are using a public computer or if your computer can be accessed by others.');\">logout</A> <> ")+T(psttEmail)
                                                            : T("<A HREF=\"/header/action/login.html\"  onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'Click here to log in.  Anywo with an email address can log in; you do not need to open an account or create a password.  A login link that can only be used wo time will be sent to your email address immediately.' );\">login</A>")

                                                        ;
                                                    }

                                                    //THIS ALL WORKS BUT IS HIDDEN TO KEEP THE WEB SITE SIMPLE AND TO LIMIT THE SCOPE OF CUSTOMER SERVICE DURING LAUNCH OF THE MAIN PRODUCT (DIRECTORY)
                                                    if( sessionP.getIdAccountF( tinP ) == 1 )
                                                    {
                                                        if( psttEmail && idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE )
                                                        {
                                                            if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                            tLinks += T("<A HREF=\"/header/do.html\"    onMouseOut=\"swatF() ;\" onMouseOver=\"flyF( this , 'Work and play and live in IdeaFarm " "(tm) City!' ) ;\">do</A>\r\n") ;
                                                        }

                                                        if( psttEmail )
                                                        {
                                                            if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                            tLinks += T("<A HREF=\"/nobot/help/help.html?url=")+T(POSTS(*REPLY.prPostUrl))+T("\"")+T(bIsHelpPage?"":" TARGET=\"_blank\"")+tFlyHelp+T(">")+tHelp+T("</A>\r\n") ;
                                                        }
                                                    }

                                                    if( !bIsRootPage && !bIsHelpPage )
                                                    {
                                                        if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                        tLinks += T("<A HREF=\"http://ideafarm.com/\" onMouseOut=\"swatF() ;\" onMouseOver=\"flyF( 'Click to display the IDEAFARM.COM domain root (home) page.' ) ;\">IDEAFARM.COM</A>\r\n") ;
                                                    }

                                                    //THIS ALL WORKS BUT IS HIDDEN TO KEEP THE WEB SITE SIMPLE AND TO LIMIT THE SCOPE OF CUSTOMER SERVICE DURING LAUNCH OF THE MAIN PRODUCT (DIRECTORY)
                                                    //BEFORE MAKING THIS VISIBLE, THE ENTIRE "MORE" WEB SITE MUST BE EDITED TO ELIMINATE INACCURACIES (E.G. DISCUSSING FREEBIES WHEN THERE AREN'T ANY YET)
                                                    //if( sessionP.getIdAccountF( tinP ) == 1 )
                                                    {
                                                        if( bAllowBigHead )
                                                        {
                                                            if( tLinks.csF( tinP ) ) tLinks += tSpace ;
                                                            TN( tLinkMore , "<A HREF=\"" ) ; tLinkMore += T(POSTS(*REPLY.prPostUrl))+T("?headflavor=") ;
                                                            tLinkMore += T( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE

                                                                ? "terse\"   onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'This is the full page header.  Click here to indicate that you want to see brief page headers during this session.' );\">less</A>"
                                                                : "verbose\" onMouseOut=\"swatF();\" onMouseOver=\"flyF( 'This page header is abbreviated.  Click here to indicate that you want to see full page headers during this session.' );\">more</A>"

                                                            ) ;

                                                            tLinks += tLinkMore ;
                                                        }
                                                    }

                                                    if( !tLinks.csF( tinP ) ) tLinks += T("Connecting People Wholesomely") ;

                                                    strMakeF( tinP , LF , prPostsBarMaroon2 , T(

                                                            "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyMaroon2F() ;\">\r\n"
                                                                "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTrED   " ; color:" ifcCOLORhTMLwHAT_FOREaCCENTrED    "\">\r\n"
                                                                    "<SPAN class=spaXXSmall>\r\n")
                                                                        + tLinks
                                                                        +T("\r\n "
                                                                    "</SPAN>\r\n"
                                                                "</td>\r\n"
                                                            "</tr>\r\n"

                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarMaroon2 ) ;
                                                    delF( tinP , psttEmail ) ;
                                                }

                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/making posts 3" ) ;
                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                                {
                                                    strMakeF( tinP , LF , prPostsBarGray , T(

                                                            "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyGrayF() ;\">\r\n"
                                                                "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnOTEdIM " ; color=#ccc\">\r\n"
                                                                    "<SPAN class=spaXXSmall>\r\n"
                                                                        "<A HREF=\"/nobot/header/calendar.html\"  onMouseOut=\"swatF() ;\" onMouseOver=\"flyTimeF() ;\">")+TnOWtICK+T("</A>\r\n"
                                                                        //"<BR>system status: frequent service interruptions (8 per hour), each lasting about 1 minute\r\n "
                                                                        //"<BR>system status: irregular service interruptions (1 to 3 per hour), each lasting about 1 minute\r\n "
                                                                        "<BR>system status: occasional service interruptions (2 per day), each lasting about 5 minutes\r\n "
                                                                    "</SPAN>\r\n"
                                                                "</td>\r\n"
                                                            "</tr>\r\n"

                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarGray ) ;

                                                    if( idBannerAd == 8 )
                                                    {
                                                        strMakeF( tinP , LF , prPostsBarOrange , T(

                                                                "<A HREF=\"/header/action/alert.html\">\r\n"
                                                                    "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyOrangeF() ;\">\r\n"
                                                                        "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaLERT " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL "\">\r\n"
                                                                            "<SPAN class=spaLarge>\r\n"
                                                                                "ALERT: Price Doubling for <B>IdeaFarm</B> (tm) <B>Basic Privileges</B> will occur within 0-64 days.<BR><CENTER><I>Click here or you'll regret it!</I></CENTER>\r\n "
                                                                            "</SPAN>\r\n"
                                                                        "</td>\r\n"
                                                                    "</tr>\r\n"
                                                                "</A>\r\n"

                                                        ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarOrange ) ;
                                                    }
                                                }

                                                if( idPortMe == ifcIDpORT_DOOR || idPortMe == ifcIDpORT_PANICdOOR )
                                                {
                                                    strMakeF( tinP , LF , prPostsBarGreen , T(

                                                            "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyGreenF() ;\">\r\n"
                                                                "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ; color=#060\">\r\n"
                                                                    "<SPAN class=spaXXSmall>\r\n"
                                                                        "<B>IdeaFarm</B> (tm) <B>City</B>"
                                                                        " <> <B>Federal Constitutional Protectorate of the United States of America</B>\r\n"
                                                                    "</SPAN>\r\n"
                                                                "</td>\r\n"
                                                            "</tr>\r\n"

                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarGreen ) ;
                                                }
                                                else
                                                {
                                                    strMakeF( tinP , LF , prPostsBarBrown , T(

                                                            "<tr onMouseOut=\"swatF() ;\" onMouseOver=\"flyBrownF() ;\">\r\n"
                                                                "<td align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTbROWN  " ; color=#840\">\r\n"
                                                                    "<SPAN class=spaXXSmall>\r\n"
                                                                        "<B>IdeaFarm</B> (tm) <B>Space</B>\r\n"
                                                                    "</SPAN>\r\n"
                                                                "</td>\r\n"
                                                            "</tr>\r\n"

                                                    ) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsBarBrown ) ;
                                                }

                                                //POPUP
                                                //(
                                                //    prPostsBarBrown && prPostsBarGreen
                                                //        ? "have both"
                                                //        : prPostsBarBrown
                                                //            ? "have brown"
                                                //            : prPostsBarGreen
                                                //                ? "have green"
                                                //                : "have neither"
                                                //)
                                                //;

                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/making posts 4" ) ;
                                                ZE( pbRefC* , prPostsLathPeanut ) ;
                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                                {
                                                    ZE( countT* , pczName ) ;
                                                    { countT pczFrom[] = { LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION , idPortMe | BM_HIGH , 0 } ; strStretchIF( tinP , pczName , pczFrom , T(POSTS(*REPLY.prPostUrl)) ) ; ___( pczName ) ; }

                                                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                                                    {
                                                        ZE( osTextT* , postLathPeanut ) ;
                                                        puseC pusePeanut( pusePeanutP ) ;
                                                        //PUSE.list_osTextTstrz_Old 2012F( tinP , postLathPeanut , pczName ) ; //A:ASSUME: ANOTHER THREAD MIGHT REPLACE THIS VALUE WHILE I AM USING THIS POINTER, BUT THIS POINTER WILL REMAIN POINTING TO VALID STORAGE
                                                        puseC puseWork1( tinP , ifcIDpOOL_ADAMtEMP ) ; //--------------------------------------------------------------------------------------
                                                        if( postLathPeanut ) { strMakeF( tinP , LF , prPostsLathPeanut , T(postLathPeanut) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsLathPeanut ) ; }
                                                        delF( tinP , postLathPeanut ) ;
                                                    }
                                                    THREADmODE2rESTORE

                                                    delF( tinP , pczName ) ;
                                                }

                                                TELL( "ifcIDfORMhTTPrEPLY_BIGhEAD/pushing snips" ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD1         ) ;
                                                PUSHrEPLY( prPostTitle ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD2         ) ;
                                                PUSHrEPLY( prPostMetaDescription ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD3         ) ;
                                                PUSHrEPLY( prPostKeywords ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD4         ) ;
                                                //reserved: error message goes here
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD5         ) ;

                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                                {
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD6         ) ;
                                                    PUSHrEPLY( prPostSlogan ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD7         ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD8         ) ;
                                                    PUSHK( prPostsIdPort1 ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD9         ) ;
                                                    PUSHrEPLY( prPostUrl ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADa         ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADb         ) ;
                                                    PUSHK( prPostsLathPeanut ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADc         ) ;
                                                }
                                                else
                                                {
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD71        ) ;
                                                    PUSHrEPLY( prPostTitle ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD81        ) ;
                                                    PUSHrEPLY( prPostDescription ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD91        ) ;
                                                }

                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADd         ) ;
                                                PUSHK( prPostsMugShot ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADe         ) ;

                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                                {
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEADf         ) ;
                                                    PUSHK( prPostsIdPort2 ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD01         ) ;
                                                    PUSHK( prPostsPort ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD11         ) ;
                                                    PUSHK( prPostsIdSession ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD21         ) ;
                                                }
                                                PUSHK( prPostsBarMaroon2 ) ;

                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                                {
                                                    PUSHK( prPostsBarGray   ) ;
                                                    if( idBannerAd == 8 ) PUSHK( prPostsBarOrange ) ;
                                                }

                                                PUSHK( prPostsBarGreen  ) ;
                                                PUSHK( prPostsBarBrown  ) ;
                                                if( idBannerAd ) PUSHsNIP( meP , ifcIDsNIPrESERVEDbANNER - 1 + idBannerAd ) ;

                                                //OBSOLETE: NOT EDITED TO USE pbRefC
                                                //if( bShowImageAds )
                                                //{
                                                //    *pStkBody << (countT)meP.getSnipF( tinP ,
                                                //        F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DOnOTdISPLAYtHIRDpARTYaDS
                                                //            ? ifcIDsNIPpREDEFINED_HEADiMAGEaDSbLANK
                                                //            : ifcIDsNIPpREDEFINED_HEADiMAGEaDSgOOGLE
                                                //    ) ;
                                                //}
                                                //if( bShowAdLinks )
                                                //{
                                                //    *pStkBody << (countT)meP.getSnipF( tinP ,
                                                //        F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DOnOTdISPLAYtHIRDpARTYaDS
                                                //            ? ifcIDsNIPpREDEFINED_HEADfDlINKSbLANK
                                                //            : ifcIDsNIPpREDEFINED_HEADfDlINKSgOOGLE
                                                //    ) ;
                                                //}

                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD31         ) ;

                                                if( idHeadFlavor == ifcIDhEADfLAVOR_VERBOSE ) 
                                                {
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD41         ) ;
                                                    PUSHrEPLY( prPostTitle ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD51         ) ;
                                                    PUSHrEPLY( prPostDescription ) ;
                                                    PUSHsNIP( meP , ifcIDsNIPpREDEFINED_HEAD61         ) ;
                                                }

                                                PUSHrEPLY( prPostBody ) ;
                                                while( !POOP && *pStkBodyDynamic )
                                                {
                                                    *pStkBody << (byteT*)0 ;
                                                    pStkBodyDynamic->extractF( (byteT*)&(*pStkBody)[ - 1 ] , tinP , 1 ) ;
                                                }

                                                PUSHsNIP( meP , !sessionP.getIdAccountCommissionF( tinP ) ? ifcIDsNIPpREDEFINED_FOOT1 : ifcIDsNIPpREDEFINED_FOOT2 ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_FOOTiMAGEaDS ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_FOOTaDlINKS  ) ;
                                                PUSHsNIP( meP , ifcIDsNIPpREDEFINED_FOOT3        ) ;

                                                DEL( prPostsLathPeanut ) ;
                                                              //traceF( tinP , T("U:: etherDoHttpJobF / h") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / h") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                break ;
                                            }
                                            default :
                                            {
                                                BLAMMO ;
                                                break ;
                                            }
                                        }
                                                      //traceF( tinP , T("U:: etherDoHttpJobF / g") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / g") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                        break ;
                                    }
                                    default :
                                    {
                                        BLAMMO ;
                                        break ;
                                    }
                                }

                                              //traceF( tinP , T("U:: etherDoHttpJobF / f") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / f") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                ZE( pbRefC* , prPostsHttpLocation ) ;
                                if( REPLY.idSnipHttpPrefix == ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP )
                                {
                                    countT idSnip = REPLY.idSnipHttpLocation ;
                                    if( !idSnip ) idSnip =  ifcIDsNIPpREDEFINED_HTTPlOCATIONrOOT ;
                                    meP.getSnipF( tinP , prPostsHttpLocation , idSnip ) ; ___( prPostsHttpLocation ) ;
                                }

                                if( REPLY.idSnipHttpPrefix == ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP && !*pStkBody )
                                {
                                    PUSHK( prPostsHttpLocation ) ;
                                }

                                              //traceF( tinP , T("U:: etherDoHttpJobF / e") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / e") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                TELL( "getting prPostsCostBody" ) ;
                                ZE( pbRefC* , prPostsCostBody ) ;
                                ZE( countT , costBody ) ;
                                {                                                                           
                                    if( *pStkBody )
                                    {
                                        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        do
                                        {
                                            pbRefC& rPosts = *(pbRefC*)&pStkBody->downF( tinP , hWalk ) ;
                                            costBody += COSTS( rPosts ) ;
                                        }
                                        while( !POOP && ~hWalk ) ;
                                    }

                                    strMakeF( tinP , LF , prPostsCostBody , TF4(costBody,flFORMAT_NObASE|flFORMAT_FOREIGN,0,0xa) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsCostBody ) ;
                                }

                                              //traceF( tinP , T("U:: etherDoHttpJobF / d") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / d") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                TELL( "building postsReply" ) ;
                                {
                                    ZE( pbRefC* , prPostsHttp ) ;
                                    meP.getSnipF( tinP , prPostsHttp , REPLY.idSnipHttpPrefix ) ; ___( prPostsHttp ) ;

                                    const osTextT postOldConnectionClose[] = { "\r\nConnection: close" } ;
                                    const osTextT postLocationKey[] = { "\r\nLocation: " } ;

                                    countT costReply =
                                          ( !prPostsHttp     ? 0 : COSTS( *prPostsHttp     ) )
                                        + ( !prPostsCostBody ? 0 : COSTS( *prPostsCostBody ) )
                                        + 4
                                        + costBody
                                    ;

                                    if( !psttQueryKV || !psttQueryKV->idAdam )
                                    {
                                        delF( tinP , psttQueryKV ) ;
                                        strMakeFromOsTextF( tinP , psttQueryKV , "rc=" postREFERRALcHAMPIONiD ) ; ___( psttQueryKV) ;
                                    }

                                    if( prPostsHttpLocation ) costReply += sizeof postLocationKey - 1 + COSTS( *prPostsHttpLocation ) + ( bQuery ? 1 + psttQueryKV->idAdam : 0 ) ;
                                    if( bClose ) costReply += sizeof postOldConnectionClose - 1 ;

                                    newF( tinP , LF , postsReply , sizeof( countT ) + costReply + 1 ) ; ___( postsReply ) ;
                                    if( postsReply )
                                    {
                                        osTextT* postc = postsReply ;
                                        *(countT*)postc = costReply ; postc += sizeof( countT ) ;
                                        if( prPostsHttp     ) { memCopyF( tinP , postc , POSTS( *prPostsHttp     ) , COSTS( *prPostsHttp     ) ) ; postc += COSTS( *prPostsHttp     ) ; }
                                        if( prPostsCostBody ) { memCopyF( tinP , postc , POSTS( *prPostsCostBody ) , COSTS( *prPostsCostBody ) ) ; postc += COSTS( *prPostsCostBody ) ; }

                                        if( prPostsHttpLocation )
                                        {
                                            memCopyF( tinP , postc , postLocationKey               , sizeof postLocationKey - 1    ) ; postc += sizeof postLocationKey - 1    ;
                                            memCopyF( tinP , postc , POSTS( *prPostsHttpLocation ) , COSTS( *prPostsHttpLocation ) ) ; postc += COSTS( *prPostsHttpLocation ) ;

                                            if( bQuery )
                                            {
                                                TN( tKV , "?" ) ; tKV += T(psttQueryKV) ;
                                                memCopyF( tinP , postc , tKV , tKV.csF( tinP ) ) ; postc += tKV.csF( tinP ) ;
                                            }
                                        }

                                        if( bClose ) { memCopyF( tinP , postc , postOldConnectionClose , sizeof postOldConnectionClose - 1              ) ; postc += sizeof postOldConnectionClose - 1    ; }

                                        memCopyF( tinP , postc , "\r\n\r\n" , 4                                                                         ) ; postc += 4                                    ;

                                        if( *pStkBody )
                                        {
                                            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            do
                                            {
                                                pbRefC& rPosts = *(pbRefC*)&pStkBody->downF( tinP , hWalk ) ;
                                                memCopyF( tinP , postc , POSTS( rPosts ) , COSTS( rPosts ) ) ; postc += COSTS( rPosts ) ;
                                            }
                                            while( !POOP && ~hWalk ) ;
                                        }
                                    }
                                    DEL( prPostsHttp ) ;
                                }
                                DEL( prPostsHttpLocation ) ;
                                DEL( prPostsCostBody ) ;

                                              //traceF( tinP , T("U:: etherDoHttpJobF / c") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / c") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                bOsFire = F(REPLY.flagsHttpReply) & flHTTPrEPLY_OSfIRE ;
                                DEL( pRefReply ) ;

                                              //traceF( tinP , T("U:: etherDoHttpJobF / b") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / b") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                DEL( prPostsPort            ) ;
                                DEL( prPostsIdPort1         ) ;
                                DEL( prPostsIdPort2         ) ;
                                DEL( prPostsIdSession       ) ;
                                DEL( prPostsBarMaroon2      ) ;
                                DEL( prPostsBarGray         ) ;
                                DEL( prPostsBarOrange       ) ;
                                DEL( prPostsBarGreen        ) ;
                                DEL( prPostsBarBrown        ) ;
                                DEL( prPostsMugShot         ) ;

                                              //traceF( tinP , T("U:: etherDoHttpJobF / a") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / a") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                TELL( "cleaning up 3" ) ;
                                while( !POOP && *pStkBody )
                                {
                                    pbRefC* prPosts = (pbRefC*)&(*pStkBody)[ 1 ] ;
                                    DELzOMBIE( prPosts ) ;
                                    pStkBody->extractF( 0 , tinP , 1 ) ;
                                }
                                              //traceF( tinP , T("U:: etherDoHttpJobF / 9") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 9") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                            }

                            //U::
                            //if( bDebugLog )
                            //{
                            //    LOGrAW( "postsReply:\r\n\"" ) ;
                            //    LOGrAW( POSTS( postsReply ) ) ;
                            //    LOGrAW( "\"\r\n" ) ;
                            //}
                                            //traceF( tinP , T("U:: etherDoHttpJobF / 8") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                            if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 8") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                            TELL( "writing reply" ) ;
                            IFsCRATCH
                            {
                                SCOOPS
                                psoP->writeF( tinP , POSTS( postsReply ) , COSTS( postsReply ) ) ;
                                if( POOP )
                                {
                                    POOPRqUIET
                                    traceF( tinP , T("etherDoHttpJobF: could not write to socket 109 [nnPeer]:    ")+T(jobP.nnPeer) , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                    bClose = 1 ;
                                }
                            }

                                          //traceF( tinP , T("U:: etherDoHttpJobF / 7") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                            if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 7") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                            if( pzCache && !bNoCacheStore )
                            {
                                ZE( strokeS* , psttn ) ;
                                strMakeF( tinP , LF , psttn , tNameCache ) ; ___( psttn ) ;
                                countT costo = COSTS( postsReply ) ;

                                countT maxAge = bDeadman1 || bDeadman2 ? maxAgeDeadman : /*U:: bTalkBody ? maxAgeMsNotFileTalkBody :*/ maxAgeMsNotFileNotTalkBody ;
                                pzCache->pushF( tinP , psttn , postsReply , costo , maxAge , 1 ) ; // "1": "LENGTH PREFIXED, SO NEED TO USE POSTS( pb )"

                                //traceF( tinP , T("etherDoHttpJobF: cached this reply [maxAge]:    ")+TF2(maxAge,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                                pzCache->purgeF( tinP , TUCK ) ; //THIS IS SUPPOSED TO RETAIN THE MOST RECENTLY PUSHED ITEMS (U:: INSPECT TRACE TO VERIFY)
                            }
                            else delF( tinP , postsReply ) ;

                                          //traceF( tinP , T("U:: etherDoHttpJobF / 6") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                            if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 6") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                            TELL( "tallying" ) ;
                            meP.swReply.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            psttLeverUrlTally = psttName ;
                            ++ swTally ;
                            meP.swReply.ungrabF( tinP ) ;
                                          //traceF( tinP , T("U:: etherDoHttpJobF / 5") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                            if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 5") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        }
                                      //traceF( tinP , T("U:: etherDoHttpJobF / 4") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 4") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        (*this)( tinP , pStkBody ) ;
                        (*this)( tinP , pStkBodyDynamic ) ;

                                      //traceF( tinP , T("U:: etherDoHttpJobF / 3") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 3") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        TELL( "cleaning up 4" ) ;
                        {
                            _IO_
                            countT cFlavors = swKV.cFlavorsF( tinP ) ;            //U:: BUG: swKV ACCESS IS NOT SERIALIZED IN SEVERAL PLACES; CONJ: ONLY USED BY THIS THREAD SO SHOULD NOT NEED SERIALIZATION: 
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            {
                                psttLeverKV = (strokeS*)swKV.leverF( tinP , idf ) ;
                                strokeS*& psttv = *(strokeS**)&(countT&)swKV ;        //U::20210126@1850: psttLeverKV->idCaste - sc_PREFIXlENGTH: 57d425ff
                                delF( tinP , psttv ) ;                                  //U::               psttLeverKV->idCaste: 0xddddf001 + 0xff524d75: 0xdd303d76
                            }
                        }
                        TELL( "cleaning up 5" ) ;
                        swKV.freeNullsF( tinP ) ;
                        delF( tinP , psttKVReport ) ;

                        //traceF( tinP , TF3(meP.idPortF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(jobP.nnPeer)+T("    nonfile response has been written") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                                      //traceF( tinP , T("U:: etherDoHttpJobF / 2") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                        if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 2") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    }
                                  //traceF( tinP , T("U:: etherDoHttpJobF / 1") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                    if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 1") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                }

                              //traceF( tinP , T("U:: etherDoHttpJobF / 0") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                if( bDeadman1 ) traceF( tinP , T("U:: etherDoHttpJobF / 0") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                if( idDesireOld ) osThreadSwitchingDesireF( tinP , idDesireOld ) ;

                ZE( countT  , timeElapsed1 ) ;
                ZE( sCountT , timeElapsed2 ) ;
                osTimeNowF(      tinP , timeElapsed1 , timeElapsed2 ) ;
                osTimeSubtractF( tinP , timeElapsed1 , timeElapsed2 , timeStart1 , timeStart2 ) ;
                osTimeAddF(      tinP , timeTotalPending1 , timeTotalPending2 , timeElapsed1 , timeElapsed2 ) ;
                if( bDeadman1 || bDeadman2 ) traceF( tinP , T("accumulated time pending [idCycle,nnPeer,time]:    ")+T(psttQueryKV)+tb4+T(jobP.nnPeer)+tb4+TT(timeTotalPending1,timeTotalPending2)+T(timeTotalPending1>TOCK?"    ********":"") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;
                //else                         traceF( tinP , T("accumulated time pending [nnPeer,time]:    "        )                   +T(jobP.nnPeer)+tb4+TT(timeTotalPending1,timeTotalPending2)+T(timeTotalPending1>TOCK?"    ********":"") , flTRACE_FORCEnOsILENCE , idTraceDivert ) ;

                delF( tinP , psttQueryKV ) ;
                delF( tinP , psttName    ) ;
                delF( tinP , psttAgent   ) ;
                delF( tinP , postBody    ) ;

                if( bClose ) break ;
            }
            //CONoUTrAW( T("------------------------- E N D   O F   S E S S I O N -------------------------------------------------------\r\n") ) ;
            //LOGrAW( T("------------------------- E N D   O F   S E S S I O N -------------------------------------------------------\r\n") ) ;

            TELL( "maybe calling raw command server" ) ;
            if( idEscaped ) (*pHttpRawCommandServerCBFP)( tinP , *this , bQuitP , cArgAppP , *psoP , time1idleTimeoutReadP , time1idleTimeoutWriteP , jobP.sessions , jobP.nnPeer , idEscaped ) ;
        }

        TELL( "etherDoHttpJobF: cleaning up (part 1)" ) ;
        ZE( countT , timeA1 ) ;
        ZE( sCountT , timeA2 ) ;
        osTimeNowF( tinP , timeA1 , timeA2 ) ;
        //TN( tLog , "" ) ; tLog =
        //
        //    TT(timeA1,timeA2)
        //    +T("| http 05 session peer:")
        //    +TF2(jobP.nnPeer.pcId[0],flFORMAT_NObIGITvALUES)
        //    +T(" total:")
        //    +TF2(cHamburgersThisSession,flFORMAT_NObIGITvALUES)
        //    +T("\r\n")
        //
        ;

        ZE( boolT , bDeadman ) ;
        {
            _IO_
            TN( t1 , ": " ) ;
            TN( t2 , "    " ) ;
            TN( tcr , "\r\n" ) ;
            countT cFlavors = swTally.cFlavorsF( tinP ) ;
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            {
                psttLeverUrlTally = (strokeS*)swTally.leverF( tinP , idf ) ;
                if
                (
                    psttLeverUrlTally
                    &&
                    (
                        !strCompareF( tinP , psttLeverUrlTally , tSlashDeadman1 )
                        ||
                        !strCompareF( tinP , psttLeverUrlTally , tSlashDeadman2 )
                    )
                )
                bDeadman = 1 ;
                //else tLog += t2+TF2(swTally,flFORMAT_NObIGITvALUES)+t1+T(psttLeverUrlTally)+tcr ;
            }
        }

        if( !bDeadman ) //VISITORS CAN CONCEAL THEIR VISIT BY ASKING FOR DEADMAN URL
        {
            //TELL( "appending log entry to log file" ) ;
            //tLog += T("\r\n") ;
            //LOGrAW( tLog ) ;
        }
        TELL( "etherDoHttpJobF: cleaning up (part 2)" ) ;

        //if( bOsFire )
        //{
        //    traceF( tinP , T("calling osFireIF") ) ;
        //    thirdC::osFireIF( tinP ) ;
        //}

        //tinP.pAdamGlobal1->pEtThreadMain->etherTestF( tinP ) ; //U:: TO FIND A BUG
        //traceF( tinP , T("etherDoHttpJobF / ---- ") ) ;
    }
    //THREADmODE4rESTORE
}

#undef PEEP
#undef PUSHK
#undef REPLY
#undef PUSHsNIP
#undef PUSHrEPLY


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f7.etherc.etherDoHttpJobF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f8.etherc.diskWalkSearchIgnoreCaseF BEGIN
#define DDNAME       "3func.360021f8.etherc.diskWalkSearchIgnoreCaseF"
#define DDNUMB      (countT)0x360021f8
#define IDFILE      (countT)0xdff


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::diskWalkSearchIgnoreCaseF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const strokeS* const psttP , const osTextT* const postFindP , const flagsT flagsP , diskWalkSearchCBFT pCbfP , countT* pcArgP )/*1*/
{
    third.diskWalkSearchIgnoreCaseF( tinP , cDirsP , cFilesP , bQuitP , osFileNameC( tinP , third , T(psttP) ) , postFindP , flagsP , pCbfP , pcArgP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f8.etherc.diskWalkSearchIgnoreCaseF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f9.etherc.sockoptionDualStackF BEGIN
#define DDNAME       "3func.360021f9.etherc.sockoptionDualStackF"
#define DDNUMB      (countT)0x360021f9
#define IDFILE      (countT)0x0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT etherC::sockOptionDualStackF( tinS& tinP , const handleC& handleP )/*1*/
{
    SCOOP
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    }

    _IO_
    third.s_optionDualStackF( tinP , handleP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.36002* : 3func.360021f9.etherc.sockoptionDualStackF END
