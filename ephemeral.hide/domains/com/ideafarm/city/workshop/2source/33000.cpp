//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\1snip.1a000006.ifcENABLEtHIRDpARTIES : 1snip.1a000006.ifcenablethirdparties BEGIN
#define DDNAME       "1snip.1a000006.ifcenablethirdparties"
#define DDNUMB      (countT)0x1a000006
#define IDFILE      (countT)0x871


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.005f003.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
*/
/**/
/*1*//*ifcENABLEtHIRDpARTIES*//*1*/
#define ifcENABLEtHIRDpARTIES


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\1snip.1a000006.ifcENABLEtHIRDpARTIES : 1snip.1a000006.ifcenablethirdparties END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\1snip.1a000003.includeGenMake.base.show.third : 1snip.1a000003.includegenmake.base.show.third BEGIN
#define DDNAME       "1snip.1a000003.includegenmake.base.show.third"
#define DDNUMB      (countT)0x1a000003
#define IDFILE      (countT)0x86c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.005f002.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
*/
/**/
/*1*//*this includes the base show flavor of ipdos.h*//*1*/
#include "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\ipdos.base.show.third.1.h"
#include "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\ipdos.base.show.third.2.h"


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\1snip.1a000003.includeGenMake.base.show.third : 1snip.1a000003.includegenmake.base.show.third END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\1snip.01000002.cnotcppheader : 1snip.01000002.cnotcppheader BEGIN
#define DDNAME       "1snip.01000002.cnotcppheader"
#define DDNUMB      (countT)0x01000002
#define IDFILE      (countT)0x1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*//*CnOTcPPhEADER*//*1*/

#if defined( __cplusplus )

    #define MYpREFIX extern "C"

#else

    #include "d:\ideafarm.home.1\precious\domains\com\ideafarm\city\workshop\openssl\include\openssl\ssl.h"

    //----------------------------------------------------- BEGIN

    //CS:CODEsYNC:DUPLICATED: 15000014 01000002

    typedef const SSL_METHOD* (__syscall *openSsl_pMethodFT        )( void )                                                    ; //const SSL_METHOD *TLS_method(void);  /* SSLv3 but can rollback to v2 */

    typedef int               (__syscall *openSsl_pInitFT          )( void )                                                    ; //int __syscall SSL_library_init( void ) ;

    typedef SSL_CTX*          (__syscall *openSsl_pContextFT       )( const SSL_METHOD* pMethodP )                              ; //SSL_CTX* __syscall SSL_CTX_new( const SSL_METHOD* method ) ;

    typedef void              (__syscall *openSsl_pContextFreeFT   )( SSL_CTX* pContextP )                                      ; // void SSL_CTX_free(SSL_CTX *ctx) ;

    typedef SSL*              (__syscall *openSsl_pWrapperFT       )( SSL_CTX* pContextP )                                      ; // SSL *SSL_new(SSL_CTX *ctx) ;

    typedef void              (__syscall *openSsl_pWrapperFreeFT   )( SSL* pWrapP )                                             ; // void SSL_free(SSL *ssl);

    typedef int               (__syscall *openSsl_pWrapFT          )( SSL* pWrapP , int hSockP )                                ; // int SSL_set_fd(SSL *ssl, int fd);

    typedef int               (__syscall *openSsl_pShakeAsClientFT )( SSL* pWrapP )                                             ; //  int SSL_connect(SSL *ssl);

    typedef int               (__syscall *openSsl_pShakeAsServerFT )( SSL* pWrapP )                                             ; //  int SSL_accept(SSL *ssl);

    typedef int               (__syscall *openSsl_pWriteFT         )( SSL* pWrapP , const void* pbP , int cbP )                 ; // int SSL_write(SSL *ssl, const void *buf, int num);

    typedef int               (__syscall *openSsl_pReadFT          )( SSL* pWrapP , void* pbP , int cbP )                       ; // int SSL_read(SSL *ssl, void *buf, int num);

    typedef int               (__syscall *openSsl_pPeekFT          )( SSL* pWrapP , void* pbP , int cbP )                       ; // int SSL_peek(SSL *ssl, void *buf, int num);

    typedef int               (__syscall *openSsl_pWaveByeFT       )( SSL* pWrapP )                                             ; // int SSL_shutdown(SSL *ssl);

    typedef int               (__syscall *openSsl_pPemFileCertFT   )( SSL_CTX* pContextP , const char* postPemP )               ; // int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file);

    typedef int               (__syscall *openSsl_pPemFileKeyFT    )( SSL_CTX* pContextP , const char* postPemP , int idTypeP ) ; // int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);

    typedef int               (__syscall *openSsl_pCurvesFT        )( SSL_CTX* pContextP , int onOffP )                         ; // int SSL_CTX_set_ecdh_auto(SSL_CTX *ctx, int onoff);

    //----------------------------------------------------- END

    #define MYpREFIX

#endif

#undef UNICODE
#include <excpt.h>
#include <stdio.h>
#include <winsock2.h>
#include <ws2tcpip.h>

MYpREFIX void _export           c_debugF( void ) ;
MYpREFIX void _export __watcall c_getaddrinfoF( char* pbListP , unsigned cbListP , const char* const postNameP ) ;
MYpREFIX void _export           c_traceHelperIF( unsigned pP ) ;

MYpREFIX void     __watcall c_openSsl_setupIF(              unsigned* pEcP , openSsl_pInitFT            pInitFP                                                                                                                                                                                                      ) ;
MYpREFIX void     __watcall c_openSsl_waveByeIF(            unsigned* pEcP , openSsl_pWaveByeFT         pWaveByeFP       , SSL* pSslP                                                                                                                                                                                ) ;
MYpREFIX SSL_CTX* __watcall c_openSsl_getContextIF(         unsigned* pEcP , openSsl_pContextFT         pContextFP       , openSsl_pMethodFT pMethodFP , openSsl_pPemFileCertFT pPemFileCertFP , openSsl_pPemFileKeyFT pPemFileKeyFP , openSsl_pCurvesFT pCurvesFP , const char* const postPemCertificatesP , const char* const postPemPrivateKeyP ) ;
MYpREFIX SSL*     __watcall c_openSsl_getWrapperIF(         unsigned* pEcP , openSsl_pWrapperFT         pWrapperFP       , SSL_CTX* pContextP                                                                                                                                                                        ) ;
MYpREFIX void     __watcall c_openSsl_wrapperFreeIF(        unsigned* pEcP , openSsl_pWrapperFreeFT     pWrapperFreeFP   , SSL* pSslP                                                                                                                                                                                ) ;
MYpREFIX void     __watcall c_openSsl_wrapSocketIF(         unsigned* pEcP , openSsl_pWrapFT            pWrapFP          , unsigned oshSocketP , SSL* pSslP                                                                                                                                                          ) ;
MYpREFIX void     __watcall c_openSsl_shakeHandsAsClientIF( unsigned* pEcP , openSsl_pShakeAsClientFT   pShakeAsClientFP , SSL* pSslP                                                                                                                                                                                ) ;
MYpREFIX void     __watcall c_openSsl_shakeHandsAsServerIF( unsigned* pEcP , openSsl_pShakeAsServerFT   pShakeAsServerFP , SSL* pSslP                                                                                                                                                                                ) ;
MYpREFIX unsigned __watcall c_openSsl_writeIF(              unsigned* pEcP , openSsl_pWriteFT           pWriteFP         , SSL* pSslP , const char* const pbP , const unsigned cbP                                                                                                                                   ) ;
MYpREFIX unsigned __watcall c_openSsl_readIF(               unsigned* pEcP , openSsl_pReadFT            pReadFP          , char* pbP , unsigned cbP , SSL* pSslP                                                                                                                                                     ) ;
MYpREFIX unsigned __watcall c_openSsl_peekIF(               unsigned* pEcP , openSsl_pPeekFT            pPeekFP          , char* pbP , unsigned cbP , SSL* pSslP                                                                                                                                                     ) ;

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
 
#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\1snip.01000002.cnotcppheader : 1snip.01000002.cnotcppheader END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000002.tmboxgetputdeadmanf BEGIN
#define DDNAME       "3func.33000002.tmboxgetputdeadmanf"
#define DDNUMB      (countT)0x33000002
#define IDFILE      (countT)0x8ef


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$tmBoxGetPutDeadmanF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b00004.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
arguments
 c1
*/
/**/

/*1*/TASK( tmBoxGetPutDeadmanF )/*1*/
ZE( infoBoxGetPutS* , pInfo ) ;
pInfo = pTaskP ? (infoBoxGetPutS*)pTaskP->c1 : 0 ;
if( pInfo )
{
    countT msWait = ( pInfo->msWait / 100 ) * 100 ;
    TELL( "sleeping for msWait" )
    {
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        while( !etThread && msWait && pInfo->fZombie )
        {
            msWait -= 100 ;
            ++ s ; etThread.osSleepF( tinP , TUCK * 0x10 ) ;
        }
    }
    TELL( "working" )
    if( pInfo->fZombie )
    {
        pInfo->fAttacked = 1 ;
        OStEXTV( ostoe , "!tinS tmBoxGetPutDeadmanF: canceling socket because fZombie is set" )
        thirdC::dosTellMonitorIF( tinP , tellC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEtELLsYS_LOG , ostoe , ostoe.costF() + 1 ) , ifcIDbOOKStELL_SYS ) ;
        pInfo->socket.stopWaitingF( tinP ) ;
    }
    pInfo->fCanDeleteMe = 1 ;
    TELL( "tmBoxGetPutDeadmanF: cleaning up" )
}
DONE( tmBoxGetPutDeadmanF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000002.tmboxgetputdeadmanf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000003.winmessagehandlerf BEGIN
#define DDNAME       "3func.33000003.winmessagehandlerf"
#define DDNUMB      (countT)0x33000003
#define IDFILE      (countT)0x8f0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$winMessageHandlerF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b00007.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
*/
/**/

/*1*/extern "C" countT __export OSF winMessageHandlerF( const countT oshWindowP , const countT idCmdP , const countT p1P , const countT p2P )/*1*/
{
    return threadLocalStorageLocationF( oshWindowP , idCmdP , p1P , p2P ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000003.winmessagehandlerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000004.wmidf_wmpostf BEGIN
#define DDNAME       "3func.33000004.wmidf_wmpostf"
#define DDNUMB      (countT)0x33000004
#define IDFILE      (countT)0x8f1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$wmIdF_wmPostF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b00009.1.0.html\"\>definition\</A\>
*/
/**/
/*1*//*wmIdF , wmPostF*//*1*/

struct title2S
{
    countT      id ;
    osTextT*    post ;
}
;

const title2S id_title2[] =
{
    0x0000 , "WM_NULL" ,
    0x0001 , "WM_CREATE" ,
    0x0002 , "WM_DESTROY" ,
    0x0003 , "WM_MOVE" ,
    0x0005 , "WM_SIZE" ,
    0x0006 , "WM_ACTIVATE" ,
    0x0007 , "WM_SETFOCUS" ,
    0x0008 , "WM_KILLFOCUS" ,
    0x000A , "WM_ENABLE" ,
    0x000B , "WM_SETREDRAW" ,
    0x000C , "WM_SETTEXT" ,
    0x000D , "WM_GETTEXT" ,
    0x000E , "WM_GETTEXTLENGTH" ,
    0x000F , "WM_PAINT" ,
    0x0010 , "WM_CLOSE" ,
    0x0011 , "WM_QUERYENDSESSION" ,
    0x0012 , "WM_QUIT" ,
    0x0013 , "WM_QUERYOPEN" ,
    0x0014 , "WM_ERASEBKGND" ,
    0x0015 , "WM_SYSCOLORCHANGE" ,
    0x0016 , "WM_ENDSESSION" ,
    0x0018 , "WM_SHOWWINDOW" ,
    0x001A , "WM_WININICHANGE|WM_SETTINGCHANGE" ,
    0x001B , "WM_DEVMODECHANGE" ,
    0x001C , "WM_ACTIVATEAPP" ,
    0x001D , "WM_FONTCHANGE" ,
    0x001E , "WM_TIMECHANGE" ,
    0x001F , "WM_CANCELMODE" ,
    0x0020 , "WM_SETCURSOR" ,
    0x0021 , "WM_MOUSEACTIVATE" ,
    0x0022 , "WM_CHILDACTIVATE" ,
    0x0023 , "WM_QUEUESYNC" ,
    0x0024 , "WM_GETMINMAXINFO" ,
    0x0026 , "WM_PAINTICON" ,
    0x0027 , "WM_ICONERASEBKGND" ,
    0x0028 , "WM_NEXTDLGCTL" ,
    0x002A , "WM_SPOOLoLDERSTATUS" ,
    0x002B , "WM_DRAWITEM" ,
    0x002C , "WM_MEASUREITEM" ,
    0x002D , "WM_DELETEITEM" ,
    0x002E , "WM_VKEYTOITEM" ,
    0x002F , "WM_CHARTOITEM" ,
    0x0030 , "WM_SETFONT" ,
    0x0031 , "WM_GETFONT" ,
    0x0032 , "WM_SETHOTKEY" ,
    0x0033 , "WM_GETHOTKEY" ,
    0x0037 , "WM_QUERYDRAGICON" ,
    0x0039 , "WM_COMPAREITEM" ,
    0x0041 , "WM_COMPACTING" ,
    0x0044 , "WM_COMMNOTIFY" ,
    0x0046 , "WM_WINDOWPOSCHANGING" ,
    0x0047 , "WM_WINDOWPOSCHANGED" ,
    0x0048 , "WM_POWER" ,
    0x004A , "WM_COPYDATA" ,
    0x004B , "WM_CANCELJOURNAL" ,
    0x004E , "WM_NOTIFY" ,
    0x0050 , "WM_INPUTLANGCHANGEREQUEST" ,
    0x0051 , "WM_INPUTLANGCHANGE" ,
    0x0052 , "WM_TCARD" ,
    0x0053 , "WM_HELP" ,
    0x0054 , "WM_USERCHANGED" ,
    0x0055 , "WM_NOTIFYFORMAT" ,
    0x007B , "WM_CONTEXTMENU" ,
    0x007C , "WM_STYLECHANGING" ,
    0x007D , "WM_STYLECHANGED" ,
    0x007E , "WM_DISPLAYCHANGE" ,
    0x007F , "WM_GETICON" ,
    0x0080 , "WM_SETICON" ,
    0x0081 , "WM_NCCREATE" ,
    0x0082 , "WM_NCDESTROY" ,
    0x0083 , "WM_NCCALCSIZE" ,
    0x0084 , "WM_NCHITTEST" ,
    0x0085 , "WM_NCPAINT" ,
    0x0086 , "WM_NCACTIVATE" ,
    0x0087 , "WM_GETDLGCODE" ,
    0x00A0 , "WM_NCMOUSEMOVE" ,
    0x00A1 , "WM_NCLBUTTONDOWN" ,
    0x00A2 , "WM_NCLBUTTONUP" ,
    0x00A3 , "WM_NCLBUTTONDBLCLK" ,
    0x00A4 , "WM_NCRBUTTONDOWN" ,
    0x00A5 , "WM_NCRBUTTONUP" ,
    0x00A6 , "WM_NCRBUTTONDBLCLK" ,
    0x00A7 , "WM_NCMBUTTONDOWN" ,
    0x00A8 , "WM_NCMBUTTONUP" ,
    0x00A9 , "WM_NCMBUTTONDBLCLK" ,
    0x0100 , "WM_KEYFIRST" ,
    0x0100 , "WM_KEYDOWN" ,
    0x0101 , "WM_KEYUP" ,
    0x0102 , "WM_CHAR" ,
    0x0103 , "WM_DEADCHAR" ,
    0x0104 , "WM_SYSKEYDOWN" ,
    0x0105 , "WM_SYSKEYUP" ,
    0x0106 , "WM_SYSCHAR" ,
    0x0107 , "WM_SYSDEADCHAR" ,
    0x0108 , "WM_KEYLAST" ,
    0x010D , "WM_IME_STARTCOMPOSITION" ,
    0x010E , "WM_IME_ENDCOMPOSITION" ,
    0x010F , "WM_IME_COMPOSITION" ,
    0x010F , "WM_IME_KEYLAST" ,
    0x0110 , "WM_INITDIALOG" ,
    0x0111 , "WM_COMMAND" ,
    0x0112 , "WM_SYSCOMMAND" ,
    0x0113 , "WM_TIMER" ,
    0x0114 , "WM_HSCROLL" ,
    0x0115 , "WM_VSCROLL" ,
    0x0116 , "WM_INITMENU" ,
    0x0117 , "WM_INITMENUPOPUP" ,
    0x011F , "WM_MENUSELECT" ,
    0x0120 , "WM_MENUCHAR" ,
    0x0121 , "WM_ENTERIDLE" ,
    0x0132 , "WM_CTLCOLORMSGBOX" ,
    0x0133 , "WM_CTLCOLOREDIT" ,
    0x0134 , "WM_CTLCOLORLISTBOX" ,
    0x0135 , "WM_CTLCOLORBTN" ,
    0x0136 , "WM_CTLCOLORDLG" ,
    0x0137 , "WM_CTLCOLORSCROLLBAR" ,
    0x0138 , "WM_CTLCOLORSTATIC" ,
    0x0200 , "WM_MOUSEFIRST" ,
    0x0200 , "WM_MOUSEMOVE" ,
    0x0201 , "WM_LBUTTONDOWN" ,
    0x0202 , "WM_LBUTTONUP" ,
    0x0203 , "WM_LBUTTONDBLCLK" ,
    0x0204 , "WM_RBUTTONDOWN" ,
    0x0205 , "WM_RBUTTONUP" ,
    0x0206 , "WM_RBUTTONDBLCLK" ,
    0x0207 , "WM_MBUTTONDOWN" ,
    0x0208 , "WM_MBUTTONUP" ,
    0x0209 , "WM_MBUTTONDBLCLK" ,
    0x0209 , "WM_MOUSELAST" ,
    0x0210 , "WM_PARENTNOTIFY" ,
    0x0211 , "WM_ENTERMENULOOP" ,
    0x0212 , "WM_EXITMENULOOP" ,
    0x0213 , "WM_NEXTMENU" ,
    0x0214 , "WM_SIZING" ,
    0x0215 , "WM_CAPTURECHANGED" ,
    0x0216 , "WM_MOVING" ,
    0x0218 , "WM_POWERBROADCAST" ,
    0x0219 , "WM_DEVICECHANGE" ,
    0x0281 , "WM_IME_SETCONTEXT" ,
    0x0282 , "WM_IME_NOTIFY" ,
    0x0283 , "WM_IME_CONTROL" ,
    0x0284 , "WM_IME_COMPOSITIONFULL" ,
    0x0285 , "WM_IME_SELECT" ,
    0x0286 , "WM_IME_CHAR" ,
    0x0290 , "WM_IME_KEYDOWN" ,
    0x0291 , "WM_IME_KEYUP" ,
    0x0220 , "WM_MDICREATE" ,
    0x0221 , "WM_MDIDESTROY" ,
    0x0222 , "WM_MDIACTIVATE" ,
    0x0223 , "WM_MDIRESTORE" ,
    0x0224 , "WM_MDINEXT" ,
    0x0225 , "WM_MDIMAXIMIZE" ,
    0x0226 , "WM_MDITILE" ,
    0x0227 , "WM_MDICASCADE" ,
    0x0228 , "WM_MDIICONARRANGE" ,
    0x0229 , "WM_MDIGETACTIVE" ,
    0x0230 , "WM_MDISETMENU" ,
    0x0231 , "WM_ENTERSIZEMOVE" ,
    0x0232 , "WM_EXITSIZEMOVE" ,
    0x0233 , "WM_DROPFILES" ,
    0x0234 , "WM_MDIREFRESHMENU" ,
    0x0300 , "WM_CUT" ,
    0x0301 , "WM_COPY" ,
    0x0302 , "WM_PASTE" ,
    0x0303 , "WM_CLEAR" ,
    0x0304 , "WM_UNDO" ,
    0x0305 , "WM_RENDERFORMAT" ,
    0x0306 , "WM_RENDERALLFORMATS" ,
    0x0307 , "WM_DESTROYCLIPBOARD" ,
    0x0308 , "WM_DRAWCLIPBOARD" ,
    0x0309 , "WM_PAINTCLIPBOARD" ,
    0x030A , "WM_VSCROLLCLIPBOARD" ,
    0x030B , "WM_SIZECLIPBOARD" ,
    0x030C , "WM_ASKCBFORMATNAME" ,
    0x030D , "WM_CHANGECBCHAIN" ,
    0x030E , "WM_HSCROLLCLIPBOARD" ,
    0x030F , "WM_QUERYNEWPALETTE" ,
    0x0310 , "WM_PALETTEISCHANGING" ,
    0x0311 , "WM_PALETTECHANGED" ,
    0x0312 , "WM_HOTKEY" ,
    0x0317 , "WM_PRINT" ,
    0x0318 , "WM_PRINTCLIENT" ,
    0x0358 , "WM_HANDHELDFIRST" ,
    0x035F , "WM_HANDHELDLAST" ,
    0x0360 , "WM_AFXFIRST" ,
    0x037F , "WM_AFXLAST" ,
    0x0380 , "WM_PENWINFIRST" ,
    0x038F , "WM_PENWINLAST" ,
    0x0400 , "WM_USER" ,
    0x8000 , "WM_APP" ,
}
;

//U: NOT REENTRANT AND MUST BE SERIALIZED BECAUSE IT CAN RETURN THE ADDRESS OF A STATIC BUFFER
const osTextT* __export wmPostF( tinS& tinP , const countT idP )
{
    _IO_
    static osTextT postb[ 0x40 ] ;

    countT cRows = sizeof id_title2 / sizeof id_title2[ 0 ] ;
    ZE( countT , off ) ;
    while( off < cRows && idP != id_title2[ off ].id ) off ++ ;
    ZE( const osTextT* , wmPost ) ;
    if( off < cRows ) wmPost = id_title2[ off ].post ;
    else
    {
        wmPost = postb ;
        ZE( countT , ecnu ) ;
        thirdC::c_itoaIF( tinP , postb , sizeof postb , idP ) ;
    }
    return wmPost ;
}

countT __export OSF wmIdF( tinS& tinP , const osTextT* const postP )
{
    _IO_
    countT cRows = sizeof id_title2 / sizeof id_title2[ 0 ] ;
    ZE( countT , ecnu ) ;

    ZE( countT , off ) ;
    while( off < cRows && thirdC::c_strcmpIF( tinP , postP , id_title2[ off ].post ) ) off ++ ;
    ZE( countT , wmId ) ;
    if( off < cRows ) wmId = id_title2[ off ].id ;
    return wmId ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000004.wmidf_wmpostf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000005.postuniquetimenowf BEGIN
#define DDNAME       "3func.33000005.postuniquetimenowf"
#define DDNUMB      (countT)0x33000005
#define IDFILE      (countT)0x8f2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$postUniqueTimeNowF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b0000e.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
*/
/**/
/*1*/voidT postUniqueTimeNowF( tinS& tinP , osTextC& ostoP )/*1*/
{
    // INTENDED FOR USE AS A UNIQUE STRING

    _IO_
    if( !POOP ) OStEXTC( ostoP , thirdC::osClockIF( tinP ) , 0 )
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000005.postuniquetimenowf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000006.postuniquedatumnamef BEGIN
#define DDNAME       "3func.33000006.postuniquedatumnamef"
#define DDNUMB      (countT)0x33000006
#define IDFILE      (countT)0x8f3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$postUniqueDatumNameF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b0000f.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
*/
/**/
/*1*/voidT postUniqueDatumNameF( tinS& tinP , osTextC& ostoP , const osTextT* const postShortLikeP )/*1*/
{
    OStEXTAK( ostoP , "\\ideafarm.home." )
    OStEXTC(  ostoP , processGlobal1I.idHome , 0 )
    OStEXTAK( ostoP , "\\domains\\com\\ideafarm\\city\\data\\out\\" )
    OStEXTA(  ostoP , postShortLikeP )
    postUniqueTimeNowF( tinP , ostoP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000006.postuniquedatumnamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000007.tmwindowsf BEGIN
#define DDNAME       "3func.33000007.tmwindowsf"
#define DDNUMB      (countT)0x33000007
#define IDFILE      (countT)0x8f4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

#if defined( NEVERdEFINED )

//DEBUG
PAINTSTRUCT info ;
extern "C" countT __export OSF winMessageHandlerDebugF( const handleC& hWindowP , const countT idCmdP , const countT p1P , const countT p2P )
{
    TINSL
    ZE( countT , rc ) ;
    switch( idCmdP )
    {
        case WM_CLOSE :
        case idwm_CLOSE :
        {
            etherC*& pEtThread  = etherC::ether_pMainRefsIF( tinP )->pEtThread ;
            DEL( tinP.pEtScratch ) ;
            DEL( pEtThread ) ; //THIS ALSO CAUSES tinP TO BE DESTROYED
            TINSL
            DEL( etherC::ether_pMainRefsIF( tinP ) ) ; // NO FURTHER USE FOR THIS

            thirdC::third_flagsProcessStateI_IF( tinP , flPROCESSsTATE_WM_CLOSE_RECEIVED , 1 ) ; // main WILL PROCEED TO CLEANUP WHEN IT SEES THIS
            {
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                while( !( F(thirdC::third_flagsProcessStateI_IF(tinP)) & flPROCESSsTATE_MAINtHREADcLEANUPiScOMPLETE ) ) { ++ s ; thirdC::dosSleepRawIF( tinP , 250 ) ; }
            }
            BOSdOnOTtEST( WHATgbo , DefWindowProc( (HWND)hWindowP , idCmdP , p1P , p2P ) )
            rc = tinP.brcRaw ;
            BOS( WHATgbo , BOSoK , PostMessage( (HANDLE)hWindowP , WM_QUIT , 0 , 0 ) )
            BOSpOOP
            break ;
        }
        case WM_PAINT :
        {
            BOS( WHATgbo , BOSoK , BeginPaint( (HWND)hWindowP , &info ) )
            BOSpOOP
            BOSdOnOTtEST( WHATgbo , EndPaint(   (HWND)hWindowP , &info ) )
            break ;
        }
        default:
        {
            BOSdOnOTtEST( WHATgbo , DefWindowProc( (HWND)hWindowP , idCmdP , p1P , p2P ) )
            rc = tinP.brcRaw ;
            break ;
        }
    }

    return rc ;
}
#endif

/*
\<A HREF=\"6.$tmWindowsF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b00012.1.0.html\"\>definition\</A\>
i create windows, handle their messages, and destroy them
example scenario: gui process that is launched automatically at boot
 at boot, i am launched
 i detect that i cannot maximize my root window, so i patiently wait indefinitely (hours, days,...) for an operator to log on
 an operator logs on
 since i can now maximize my root window, i do so, create my input window, and begin pumping window messages
 the operator logs off
 my root window receives a WM_CLOSE message
 my root window handles the WM_CLOSE by destroying itself, which also destroys the input window, its child
 my root window handles the WM_DESTROY by destroying its object and posting WM_QUIT
 my windows are all gone
 the WM_QUIT causes the message pump to return
 i reset sgnReady and sleep for 01 tock
 i wake up, create my root window, and wait patiently until i can maximize it
arguments
 sgnReady
 psttTitle
wo tricky aspect of this thread is that it blocks in the WM_CLOSE handler, which destroys its etThread and its tinP objects
 after that time, i must avoid referring to etThread or tinP and i must also avoid referring to other ifc objects
  for example, i must not use the T macro
 i am essentially an orphan thread, hanging around while main d eletes all of this processes ifc objects
 i must do this because MS Windows is such a piece of shit
 in particular, i must hang around and not return from WM_CLOSE until my whole process cleanup is complete
*/
/**/

// tmWindowsF IS TO BE UNAFFECTED BY ether I.E. WHETHER THE CELL HAS BEEN FIRED

/*
*/
/**/

/*1*/TASK( tmWindowsF )/*1*/

THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //OBSERVED SLEEP BLAMMO FOR CONSOLE a45 OCCASIONALLY July 31,2005 DURING INSTALL; DID NOT ANALYZE
{
    THREADmODE2oN( flTHREADmODE2_MYoWNrECYCLER )
    if( pTaskP && pTaskP->c1 && pTaskP->c2 )
    {
        TELL( "setting up" )
        if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS ) ) { __( tinP.monitor.idThread - ifcIDtHREADlOW_tmWindowsOrServiceMainF ) ; }
        processGlobal1I.ebp_tmWindowsF_ = ebpAM() ; //winMessageHandlerWorkF WILL USE THIS VALUE TO FIND tinP
        tinP.idPhase2 = 1 ;
    
        {
            countT osMin = thirdC::winIdMsgUserIF( tinP ) ;
            countT ifMin = idwm_USER ;
            __( ifMin < osMin ) ;
        }
        //THIS IS A NO NO.  A FAILURE ON THIS THREAD CAN CAUSE RUSH SPIN OF THE CPU: etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;
        signC&    sgnReady  =    *(signC*)pTaskP->c1 ;
        strokeS*& psttTitle = *(strokeS**)pTaskP->c2 ;
        thirdC::third_idThreadWindowsIF( tinP ) = tinP.monitor.idThread ;
        thirdC& thThread = etThread ;
#if defined( NEVERdEFINED )
        etherC::ether_pMainRefsIF( tinP ) = new( 0 , tinP , LF ) mainRefsS( tinP , ether , pEtThread ) ; ___( etherC::ether_pMainRefsIF( tinP ) ) ;
        //thThread.winCreateWindowClassF( tinP , MAINwINDOWcLASSnAME , winMessageHandlerDebugF ) ;
        thThread.winCreateWindowClassF( tinP , MAINwINDOWcLASSnAME , winMessageHandlerF ) ;
    
        const countT cPapersRoot = 3 ; //MUST BE 3 OR GREATER BECAUSE EXIST 3 IS GUARANTEED (3 CAN BE USED AS SCRATCH)
        {
            //PSEUDODUPLICATED CODE: 1020171 0b0001b (APPARENTLY OBSOLETE COMMENT)

            ZE( sCountT , ifCol ) ;
            ZE( sCountT , ifRow ) ;
            ZE( countT , cCol ) ;
            ZE( countT , cRow ) ;
            ZE( countT , cColClient ) ;
            ZE( countT , cRowClient ) ;
            {
                ZE( countT , cColDisplay ) ;
                ZE( countT , cRowDisplay ) ;
                thThread.osDisplaySizeF( tinP , cColDisplay , cRowDisplay ) ;
    
//#if defined( NEVERdEFINED )
                //if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DEBUG ) )
                {
                    ifCol = 1 ;
                    ifRow = 1 ;
                    cColClient = cColDisplay ;
                    cRowClient = cRowDisplay ;
                }
                //else
//#endif
                //{
                //    cColClient = cColDisplay >> 3 ;
                //    //LOGrAW3( "[cColClient]: " , cColClient , "\r\n" ) ;
                //    //cColClient = cColDisplay - 0x80 ;
                //    cRowClient = cRowDisplay >> 3 ;
                //    ifCol = 0x8 ;
                //    ifRow = 0x30 ;
                //}

                //{
                //    cColClient = TUCK >> 1 ;
                //    cRowClient = TUCK >> 1 ;
                //    ifCol = 1 ;
                //    ifRow = 1 ;
                //}

                cCol = cColClient ;
                cRow = cRowClient ;
            }

            thThread.winAdjustWindowPositionF( tinP , ifCol , ifRow , cCol , cRow ) ;
            { windowOldC* pwq = new( 0 , tinP , LF ) windowOldC( tinP , etThread , cPapersRoot , 0 , 1 , ifCol , ifRow , cCol , cRow , cColClient , cRowClient , 1 ) ; ___( pwq ) ; } // winRoot MUST BE THE WO'TH WINDOW CONSTRUCTED
        }

        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
        if( pRootI )
        {
            thThread.winSetTitleF( tinP , T(psttTitle) , *pRootI ) ;

            {
                for( countT idPaper = cPapersRoot ; idPaper >= 1 ; idPaper -- )
                {
                    const paperOldC& paper = pRootI->selectPaperF( tinP , ifcIDcMDpAPERsELECT_SETrENDER , idPaper ) ;
                    ((paperOldC&)paper).purgeF( tinP ) ;
                }
            }
    
            if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_HIDEwITHiCON ) ) thThread.winShowWindowF( tinP , *pRootI , F(thirdC::third_flagsModeProcess1I_IF(tinP)) & flMODEpROCESS1_LAUNCHmINIMIZED ? idcWINsHOW_MINIMIZE : /*idcWINsHOW_MAXIMIZE*/idcWINsHOW_SHOW ) ;
            etThread.delF( tinP , psttTitle ) ;
        
            pRootI->letRefF() ;
        }
        else __1 ;        

        sgnReady.giveF( tinP ) ;
        if( !etThread )
        {
            TELL( "pumping window messages" )
            DEL( pTaskP ) ;
            tinP.idPhase2 = 2 ;
            //FROM HERE ON DO NOT REFER TO ANY IFC OBJECTS (EG etThread)
            //LOGrAW( "tmWindowsF/dispatchola/+\r\n" ) ;
            thirdC::winDispatchMessagesIF( tinP ) ; // WM_CLOSE WILL DELETE pEtThread (WHICH DELETES tinP) BEFORE THIS RETURNS
        }
        else
        {
            {
                POOPIES
                thirdC::third_flagsProcessStateI_IF( tinP , flPROCESSsTATE_WM_CLOSE_RECEIVED , 1 ) ; // main WILL PROCEED TO CLEANUP WHEN IT SEES THIS
            }
            thirdC::third_flagsModeAdam1I_IF( tinP ) &= ~( F(flADAMmODE1_tmWindows) ) ;
            ether.etherFireImpersonateMonitorIF( tinP ) ;
        }

        //TELL( "cleaning up" )
        {
            TINSL
            //LOGrAW( "tmWindowsF/dispatchola/-\r\n" ) ;
            tinP.idPhase2 = 3 ;
            thirdC::winDestroyWindowClassIF( tinP , MAINwINDOWcLASSnAME ) ;
        }

#else

        etThread.delF( tinP , psttTitle ) ;
        sgnReady.giveF( tinP ) ;
        etherC::loafIF( tinP ) ; //U::DOODLING

#endif
    
    }
    THREADmODE2rESTORE
}
THREADmODE1rESTORE

processGlobal1I._thirdC_flagsProcessState |= flPROCESSsTATE_tmWindowsF_HASeNDED | flPROCESSsTATE_MAINtHREADiSaLONE ;

//WARNING: IF I AM EDITED TO LAUNCH KID THREADS, I MUST EXPLICITLY WAIT HERE FOR THEM ALL TO END
//DONE WILL NOT DO THIS BECAUSE tinP AND etThread ARE ALREADY GONE
//CONJ: THIS COMMENT IS WRONG BECAUSE tinP IS NOW tinEarlyLate

DONE( tmWindowsF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000007.tmwindowsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000008.tmwatchf BEGIN
#define DDNAME       "3func.33000008.tmwatchf"
#define DDNUMB      (countT)0x33000008
#define IDFILE      (countT)0x8f5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$tmWatchF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b00013.1.0.html\"\>definition\</A\>
i wait for all other child threads other than tmWindowsF to end
then i cause tmWindowsF to end
*/
/**/

/*
*/
/**/
/*1*/TASK( tmWatchF )/*1*/
//tinP.pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
{
    //THIS BLOCK IS TO ENSURE THAT tmWindowsF AND tmAnimateSadamsF GET STARTED BEFORE I CHECK FOR THEIR PRESENCE
    //I CANNOT JUST LAUNCH tmWatchF LATER BECAUSE THAT WOULD CHANGE idThread VALUES FOR SYSTEM THREADS (MY idThread WOULD DEPEND UPON WINDOWING AND PROBABLY ALSO ON A RACE CONDITION INVOLVING THREAD STARTUP)
    {
        signC& sgnWatchReady   = *(signC*)pTaskP->c1 ;
        signC& sgnWindowsReady = *(signC*)pTaskP->c2 ;

        sgnWindowsReady.waitF( tinP ) ;
        sgnWatchReady.giveF( tinP ) ;
    }

    //__( tinP.monitor.idThread - ifcIDtHREADlOW_tmWatchF ) ;
    TELL( "waiting for asynch impotence" ) ;

    //U:://--------------------------------------------------------------------------
    //U::
    //U::    /*CODE SYNCH: 1610009 0010262*/
    //U::    bitsC bits( tinP , CbITSlIFI , 0 , 1 ) ;
    //U::    napkinC napFireAll( tinP , LF , (byteT*)bits , "tmWatchF/napFireAll" , 0 , 2 * sizeof( countT ) + CfIREaLLrANKS * sizeof( fireAllS ) ) ;
    //U::    /* THIS IS CREATE SO THAT THE CELL MONITOR CAN BE RUN WITHOUT THE DRIVER (FOR DEBUGGING) */
    //U::    countT* pcn = (countT*)(byteT*)napFireAll ;
    //U::    if( !pcn ) { BLAMMO ; }
    //U::    else if( !( F(napFireAll.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
    //U::    {
    //U::        fireAllS* home.pFireAll = (fireAllS*)( pcn + 2 ) ;
    //U::        for( countT off = 0 ; off < CfIREaLLrANKS ; off ++ ) home.pFireAll[ off ].bFire = home.pFireAll[ off ].cHeartBeats = home.pFireAll[ off ].cHearts = 0 ;
    //U::
    //U::        pcn[ 1 ] = processGlobal1I.idAdamRoot ;
    //U::        putNegAM( pcn[ 0 ] , FINGERnEG_NAPfIREcELLmONITOR ) ;
    //U::        napFireAll.formattingIsDoneF( tinP ) ;
    //U::    }
    //U::    else if( napFireAll != 2 * sizeof( countT ) + CfIREaLLrANKS * sizeof( fireAllS ) ) { BLAMMO ; }
    //U::    else if( getNegAM( pcn[ 0 ] ) != FINGERnEG_NAPfIREcELLmONITOR ) { BLAMMO ; }
    //U::
    //U:://--------------------------------------------------------------------------

    tinP.unwatchedF() ;

    homeS& home = homeS::homeIF() ;
    ZE( countT , idLook ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    TN( tb , " " ) ;
    //countT cSkip = 0x20 ;
    ZE( countT , idCycle ) ;
    stackC& stIdleTimeouters = *tinP.pAdamGlobal1->_etherC_.pStkIdleTimeouters ;
    stackC& stAcceptors              = *tinP.pAdamGlobal1->_etherC_.pStkAcceptors ;
    stackC& stCatchers               = *tinP.pAdamGlobal1->_etherC_.pStkCatchers ;
    stackC& stQuitters               = *tinP.pAdamGlobal1->_etherC_.pStkQuitters ;
    //if( stAcceptors.third         ) stAcceptors.third         = 0 ;
    //if( stCatchers.third          ) stCatchers.third          = 0 ;
    //if( stQuitters.third          ) stQuitters.third          = 0 ;
    const boolT b_tmWindows = !!( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_tmWindows ) ;

    countT desireSave = etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZY ) ;

    boolT bTraceMemoryReadability =                                  //U:: TO FIND A LEAK (DISABLE THIS IN PRODUCTION)
           //tinP.pAdamGlobal1->idAdam == ifcIDaDAM_ROOThTTPsERVER
        tinP.pAdamGlobal1->idAdam == ifcIDaDAM_KERNEL2MONITOR
    ;

    //ZE( boolT , bTraceMemoryReadability ) ;

    //if( tinP.pAdamGlobal1->idAdam == ifcIDaDAM_CLOUD )
    //{
    //    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tinP ) ;
    //    TN( tHit , "zap..CDN_ACCESS_LOGS" ) ;
    //    FORsTRINGSiN1( pstt1Param )
    //    {
    //        if( !etThread.strCompareF( tinP , psttc1 , tHit ) ) bTraceMemoryReadability = 1 ;
    //    }
    //}

    TN( tDirBlammo , "///ideafarm/controls/blammo/" ) ;
    TN( tSayTick , "tick" ) ;
    while( ( !ether || tinP.pAdamGlobal1->cThreadsWatched > b_tmWindows << 1 ) && !etThread ) // tmWindowsF tmAnimateSadamsOnPaperF
    {
        if( etRock )
        {
            etThread.traceF( tinP , T("etRock is impotent") ) ;
            BLAMMO ;
        }

        //DUPLICATE CODE: 33000008 33000008
        if( etThread.diskFileExistsF( tinP , tDirBlammo+T("*") ) )
        {
            etThread.diskFileOrDirDeleteF( tinP , tDirBlammo , flFILEoRdIRdELETE_RECURSE , 1 ) ;
            etThread.traceF( tinP , T("calling osFireIF, setting flHOMEs_KILLsELFiMMEDIATELY, and then calling BLAMMO because a file existed in ")+tDirBlammo ) ;
            thirdC::osFireIF( tinP ) ;
            homeS::homeIF().flags |= flHOMEs_KILLsELFiMMEDIATELY ;
            BLAMMO ;
        }

        if( ++ idCycle > TUCK >> 4 && !( idCycle % 0x10 ) ) poolC::deleteEmptiesIfIF( tinP ) ; // SUPPRESSED FOR WOTH 01 TOCK TO ALLOW adamMainF TO CALL pMainF AND pMainF TO DO ITS INITIALIZATION ; THIS IS AN OPTIMIZATION TO AVOID UNNECESSARY DT/CT OF sexC INSTANCES WITH SAME SPECIFICATIONS

        if( !( idCycle % ( TUCK >> 1 ) ) )
        {
            if( !bTraceMemoryReadability ) ; // etRock.traceF( tinP , T("not tracing memory usage [idAdam]:    ")+TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            else
            {
                etherC& etRock = etherC::etRockIF( tinP ) ;
        
                etRock.traceF( tinP , T("tmWatchF: tracing pool tallies") ) ;
                etRock.tracePoolTalliesF( tinP ) ;
                etRock.traceF( tinP , T("tmWatchF: traced  pool tallies") ) ;
        
                // TRACE OUT A MEMORY READABILITY MAP TO SHOW HOW MUCH MEMORY OF THE ADDRESS SPACE IS NOT YET COMMITTED
                {
                    static byteT pbBits[ TUCK << 4 ] ; //EACH LINE OF REPORT WILL REPRESENT 1 TICK OF MEMORY
                                    
                    countT cbGrain = thirdC::osMemoryReadabilityMapIF( tinP , pbBits , sizeof pbBits ) ;
                    countT cbaNeeded = etherC::ifcBitDumpIF( tinP , 0 , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;
                                    
                    if( cbaNeeded == CBrEADABILITYmAPdUMP )
                    {
                        static byteT postr[ TUCK + CBrEADABILITYmAPdUMP ] ; // NOT THREAD SAFE WHEN A PROCESS IS RUNNING MULTIPLE ADAMS  U:: USE THE STACK SO IS THREAD SAFE
                        static osTextT postProlog[] = "memory readability dump:\r\n" ;
                        thirdC::c_strcpyIF( tinP , postr , postProlog ) ;
                
                        etherC::ifcBitDumpIF( tinP , postr + sizeof postProlog - 1 , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;
                        etRock.traceF( tinP , (strokeS*)postr , flTRACE_PARAMETERiSoStEXT /*| flTRACE_NOpREFIX*/ | flTRACE_KEEPcRlF ) ;
                    }
                }
            }
        }

        //CONoUTrAW5( "tmWatchF [ether,cThreadsWatched]: " , ether , " " , tinP.pAdamGlobal1->cThreadsWatched , "\r\n" ) ;

        thirdC::dosPriorityProcessIF( tinP ) ; //THIS ENFORCES RULE THAT USER CANNOT CHANGE THE PRIORITY CLASS OF AN IFC PROCESS; (IFC MAKES THIS ASSUMPTION SO THAT IT CAN USE YIELD WITHOUT HAVING CPU SPINS)
        if( tinP.pAdamGlobal1->idGroupFireAll && tinP.pAdamGlobal1->idGroupFireAll <= CfIREaLLrANKS && home.pFireAll[ tinP.pAdamGlobal1->idGroupFireAll - 1 ].bFire )
        {
            LOGrAW5( "adam " , tinP.pAdamGlobal1->idAdam ,  "'s tmWatchF sees that group " , tinP.pAdamGlobal1->idGroupFireAll , " has been fired\r\n" ) ;
            etThread.etherFireImpersonateMonitorIF( tinP ) ;
        }

        //S: SECURITY HOLE: SKIPPING LIKE THIS WILL ALLOW CODE TO DO LOTS OF WORK IN THE 02 TOCKS BEFORE THE VERSION REFUSAL BECOMES EFFECTIVE
        //if( cSkip && cSkip -- ) ; //GIVES THIS PROCESS TIME TO GET STARTED AOK (SOME PROCESSES FAIL IF FIRED VERY EARLY DURING STARTUP)

        //U::COMMENTED OUT AS A WORKAROUND WHILE GETTING GUI PROCESS TO WORK
        //THIS APPEARS TO BE NECESSARY BECAUSE GUI PROCESS GetCommandLine() DOES NOT PROVIDE THE EXE FILE'S PATH, SO IS FLAGGED AS HOMELESS (BUT NOT WHEN RUN IN WDW)
        /*else*/ if
        (
            F(home.flags) & flHOMEs_VERSIONrEFUSED
            ||
            (
                   tinP.pAdamGlobal1->idAdam != ifcIDaDAM_CLOAK
                && !( processGlobal1I.idHome & 0xff000000 )
                && !thirdC::osTestWaterIF( tinP , ifcIDtYPEtESTwATER_LOOKfORdRIVER )
            )
        )
        {
            if( F(home.flags) & flHOMEs_VERSIONrEFUSED )
            {
                LOGrAW3( "adam " , tinP.pAdamGlobal1->idAdam ,  "'s tmWatchF sees that this version has been refused\r\n" ) ;
                etThread.etherFireImpersonateMonitorIF( tinP ) ; // 20200620@1605: ENABLED THIS WITHOUT ANALYSIS (VERSIONING ENFORCEMENT USES A DNS RECORD)
            }

            if( !( processGlobal1I.idHome & 0xff000000 ) && !thirdC::osTestWaterIF( tinP , ifcIDtYPEtESTwATER_LOOKfORdRIVER ) )
            {
                LOGrAW3( "adam " , tinP.pAdamGlobal1->idAdam ,  "'s tmWatchF cannot see the driver\r\n" ) ; // ifcIDaDAM_CLOAK IS EXEMPT BECAUSE CLOAK LAUNCHES WOTH AND LAUNCHES THE DRIVER/MONITOR AS OF 20200525@1817
                etThread.etherFireImpersonateMonitorIF( tinP ) ;
            }
        }

        tinP.pAdamGlobal5->grabGrabWatch.grabF( tinP , TAG( TAGiDnULL ) ) ;
        if( tinP.pAdamGlobal1->pGrabWatch ) thirdC::dosBeepIF( tinP , TUCK * ( 1 + !!tinP.pAdamGlobal1->pGrabWatch->cGrabbedF() ) , TUCK ) ;
        tinP.pAdamGlobal5->grabGrabWatch.ungrabF( tinP ) ;

        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
        if( pRootI )
        {
            //NOTIFYICONDATA info ;
            //info.cbSize = sizeof info ;
            //info.hWnd = (HWND)( (const handleC&)*pRootI ).osF( ifcIDtYPEhANDLE_WINDOW ) ;
            //info.uID = 0x1 ;
            //info.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP ;
            //info.uCallbackMessage = idwm_TASKbARiCON ;
            //info.hIcon = LoadIcon( (HINSTANCE)thirdC::third_hWindowingClientIF( tinP ).osF( ifcIDtYPEhANDLE_WINDOWINGcLIENT ) , MAKEINTRESOURCE( 1 ) ) ;
            //    
            //OStEXT( oston , 0x80 )
            //OStEXTAK( oston , "IPDOS (tm) IdeaFarm " "(tm) Piggyback Distributed Operating System" )
            //if( processGlobal1I.idHome > 1 )
            //{
            //    OStEXTAK( oston , " (Home " )
            //    OStEXTC(  oston , processGlobal1I.idHome , 0 )
            //    OStEXTAK( oston , ")" )
            //}
            //thirdC::c_strncpyIF( tinP , info.szTip , oston , sizeof info.szTip ) ;
            //    
            //Shell_NotifyIcon( NIM_ADD , &info ) ;
                
            pRootI->letRefF() ;
        }
        
        TELL( "setting/resetting control flags" ) ;
        {
            etThread.diskMakeDirF( tinP , T("///ideafarm/controls/off/") ) ;
            etThread.diskMakeDirF( tinP , T("///ideafarm/controls/on/") ) ;

            if( !etThread.diskFileExistsF( tinP , T("///ideafarm/controls/off/in.out.trace.txt") ) && !etThread.diskFileExistsF( tinP , T("///ideafarm/controls/on/in.out.trace.txt") ) )
            {
                etThread.boxPutF( tinP , T("///ideafarm/controls/off/in.out.trace.txt") , "The contents of this file do not matter.\r\nTo save space, use any plain text editor to make this an empty file.\r\nIf you delete this file, it wll be recreated in its default control directory.\r\nTo turn this control on or off, move this file to the \"on\" or the \"off\" folder." ) ;
                etThread.traceF( tinP , T("flHOMEs_INoUTtRACE off (control file created)") ) ;
            }
            else if( etThread.diskFileExistsF( tinP , T("///ideafarm/controls/on/in.out.trace.txt") ) )
            {
                if( !( F(home.flags) & flHOMEs_INoUTtRACE ) ) etThread.traceF( tinP , T("flHOMEs_INoUTtRACE turned on") ) ;
                home.flags |= flHOMEs_INoUTtRACE ;
            }
            else
            {
                if( F(home.flags) & flHOMEs_INoUTtRACE ) etThread.traceF( tinP , T("flHOMEs_INoUTtRACE turned off") ) ;
                home.flags &= ~( F(flHOMEs_INoUTtRACE) ) ;
            }
        }

        TELL( "canceling sockets that are timed out" ) ;
        if( stIdleTimeouters.third    ) stIdleTimeouters.third    = 0 ;
        stIdleTimeouters.grabF( tinP , TAG( TAGiDnULL ) ) ;
        if( !etThread && stIdleTimeouters )
        {
            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            do
            {
                socketC* pso = (socketC*)stIdleTimeouters.downF( tinP , handle ) ;
                __Z( pso ) ;
                if( pso ) pso->cancelIfTimedOutF( tinP ) ;
            }
            while( !etThread && !stIdleTimeouters.third && ~handle ) ;
        }
        stIdleTimeouters.ungrabF( tinP ) ;

        if( ether )    
        {
            TELL( "releasing threads blocked listening for new socket client connections" ) ;
            stAcceptors.grabF( tinP , TAG( TAGiDnULL ) ) ;
            if( !etThread && stAcceptors )
            {
                handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                do
                {
                    socketC* pso = (socketC*)stAcceptors.downF( tinP , handle ) ;
                    __Z( pso ) ;
                    if( pso ) 
                    {
                        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //LEGACYwORKAROUND
                        IFsCRATCH
                        {
                            SCOOPS
                            socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                            sock.connectF( tinP , (countT)*pso ) ;
                            if( POOP ) POOPR
                        }
                        THREADmODE1rESTORE
                    }
                }
                while( !etThread && !stAcceptors.third && ~handle ) ;
            }
            stAcceptors.ungrabF( tinP ) ;
                
            TELL( "releasing threads blocked catching socket datagrams" ) ;
            IFsCRATCH
            {
                stCatchers.grabF( tinP , TAG( TAGiDnULL ) ) ;
                if( !etThread && stCatchers )
                {
                    handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    do
                    {
                        socketC* pso = (socketC*)stCatchers.downF( tinP , handle ) ;
                        __Z( pso ) ;
                        if( pso ) 
                        {
                            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //LEGACYwORKAROUND
                            SCOOPS
                            {
                                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
                                sock.writeF( tinP , (countT)*pso , nicNameC() , ifcIDtYPEdATAGRAM_LETSaLLqUIT ) ;
                                if( POOP ) POOPR
                            }
                            THREADmODE1rESTORE
                        }
                    }
                    while( !etThread && !stCatchers.third && ~handle ) ;
                }
                stCatchers.ungrabF( tinP ) ;
            }
                
            TELL( "canceling quitter sockets/+" ) ;
            while( !etThread && !stQuitters.third && stQuitters )
            {
                stQuitters.grabF( tinP , TAG( TAGiDnULL ) ) ;
                if( !etThread && !stQuitters.third && stQuitters )
                {
                    handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    do
                    {
                        socketC* pso = (socketC*)stQuitters.downF( tinP , handle ) ;
                        __Z( pso ) ;
                        if( pso )
                        {
                            handleC& hSoc = *(handleC*)&pso->handleF( tinP ) ;
                            //CONoUTrAW( "tmWatchF/cancelling a quitter socket\r\n" ) ;
                            //CONoUTrAW3( "********************* cancelling quitter socket " , (countT)pso , "\r\n" ) ;
                            //tinP.pEtScratch->sockCancelF( tinP , hSoc ) ;
                            //CONoUTrAW3( "tmWatchF/closing quitter handle at " , (countT)&hSoc , "\r\n" ) ; //U::
                            hSoc.closeIfF() ; //U::ELIMINATING ALL USAGE OF "shutdown" WIN32 API
                            //*tinP.pEtScratch = 0 ;
                        }
                    }
                    while( !etThread && !stQuitters.third && ~handle ) ;
                }
                stQuitters.ungrabF( tinP ) ;

                {
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    ++ s ; etThread.osSleepF( tinP , TOCK ) ;
                }
            }
        }

        if( !( idCycle % ( TUCK << 0 ) ) ) etThread.traceF( tinP , tSayTick ) ; //APPROXIMATELY ONCE PER TICK

        //U::SELL THE RESOURCE FLOW AND THEN DISTRIBUTE THE PROCEEDS EQUALLY TO ALL adamC INSTANCES THAT ARE ENTITLED TO A SHARE OF THAT
        //U::THIS IS DONE ACCORDING TO THE NUMBER OF SHARES THAT EACH adamC INSTANCE OWNS
        //TELL( "distributing manna from heaven to adamC instances" ) ;
        //{
        //    tinP.pAdamGlobal4->_adamC_grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
        //
        //    adamC* pac = tinP.pAdamGlobal1->_adamC_pAdam ;
        //    while( pac )
        //    {                
        //        pac->mannaF( tinP , 1.0 ) ;
        //        pac = pac->pAdam ;
        //    }
        //
        //    tinP.pAdamGlobal4->_adamC_grab.ungrabF( tinP ) ;
        //}

        //20130918@1315: THIS IS CPU COSTLY SO COMMENTED OUT.  AFAIK IT WORKS
        //20210220@1100: ENABLED IN RESPONSE TO "OUT OF MEMORY" (CODE 8) WINDOWS ERROR

        if( !( idCycle % ( TUCK << 0 ) ) ) //APPROXIMATELY ONCE PER TICK
        {
            etherC& etRock = etherC::etRockIF( tinP ) ;
            etRock.traceF( tinP , T("dosCreateDirF: tracing pool tallies") ) ;
            etRock.tracePoolTalliesF( tinP ) ;
            etRock.traceF( tinP , T("dosCreateDirF: traced  pool tallies; now calling BLAMMO") ) ;
        }

//U:: 20210220@1114: REMOVE THIS OLD CODE, WHICH IS REPLACED WITH THE PRECEDING (OLD: ALL poolC INSTANCES.  NEW: ONLY THE CURRENT poolC INSTANCE
#if defined( NEVERdEFINED )
        //if( !( idCycle % ( TUCK << 4 ) ) ) //APPROXIMATELY ONCE PER HOUR
        if( !( idCycle % ( TUCK << 0 ) ) ) //APPROXIMATELY ONCE PER TICK
        {
            LOGrAW3( "\r\npoolC tally report [idTick]: " , idCycle , "\r\n" ) ;
        
            ZE( const countT* , pczLever ) ;
            switchC swTally( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , *(const countT**)&pczLever , 0 , 3 * sizeof( countT ) ) ;
            poolC::reportIF( tinP , pczLever , swTally ) ;
            
            ZE( countT , tallyAll ) ;
            countT cFlavors = swTally.cFlavorsF( tinP ) ;
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            {
                pczLever = (countT*)swTally.leverF( tinP , idf ) ;
                countT tally = swTally ;
                tallyAll += tally ;
            
                LOGrAW( T("    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(tally,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pczLever,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
            }
        
            ZE( countT , timeN1 ) ;
            ZE( sCountT , timeN2 ) ;
            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
        
            LOGrAW( T("[time,idAdam,tallyAll]: ")+TT(timeN1,timeN2)+T("    ")+TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(tallyAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
        }
#endif

        //thirdC::osLogWrongNodeIF( tinP ) ;

        TELL( "napping for a tock" ) ;
        ++ s ; etThread.osSleepF( tinP , TOCK ) ;
    }

    //DUPLICATE CODE: 33000008 33000008
    if( etThread.diskFileExistsF( tinP , tDirBlammo+T("*") ) )
    {
        etThread.diskFileOrDirDeleteF( tinP , tDirBlammo , flFILEoRdIRdELETE_RECURSE , 1 ) ;
        etThread.traceF( tinP , T("calling osFireIF, setting flHOMEs_KILLsELFiMMEDIATELY, and then calling BLAMMO because a file existed in ")+tDirBlammo ) ;
        thirdC::osFireIF( tinP ) ;
        homeS::homeIF().flags |= flHOMEs_KILLsELFiMMEDIATELY ;
        BLAMMO ;
    }

    //TELL( "resetting control flags (to default behavior)" ) ;
    //{
    //    home.flags &= ~( F(flHOMEs_INoUTtRACE) ) ;
    //}

    etThread.osThreadSwitchingDesireF( tinP , desireSave ) ;
    tinP.pAdamGlobal1->flagsAdam |= flADAM_FIRED ;

    {
        ZE( countT , ze ) ;
        if( tinP.pAdamGlobal1->_etherC_.pCalledWhenFiredF ) (*tinP.pAdamGlobal1->_etherC_.pCalledWhenFiredF)( tinP , tinP.pAdamGlobal1->_etherC_.pCalledWhenFiredArg ? *tinP.pAdamGlobal1->_etherC_.pCalledWhenFiredArg : ze ) ;
    }

    TELL( "launching late threads" ) ;
    ((thirdC&)etThread).thirdLaunchLateThreadsF( tinP ) ;
    
    TELL( "initializing references" ) ;
    countT& cAllKidThreadsI          = thirdC::os_cAllKidThreadsI_IF( tinP ) ;
    countT& cAllOrphanThreadsI       = thirdC::os_cAllOrphanThreadsI_IF( tinP ) ;
    flagsT& flQuittingI              = tinP.pAdamGlobal1->_thirdC_.flQuitting ;
    stackC& stTasksWhenQuitting      = *tinP.pAdamGlobal1->_thirdC_.pStkTasksWhenQuitting ;
    boolT&  bNoNewKids               = tinP.pAdamGlobal1->_etherC_.bNoNewKids ;
    batonC& batFiringKids            = *tinP.pAdamGlobal1->_etherC_.pBatFiringKids ;
    countT& cFaceClientsI            = tinP.pAdamGlobal1->_etherC_.cFaceClients ;
    
    do
    {
        //THIS IS BAD STYLE.  IT IS DONE HERE TO GIVE tmWatchF EVERY CHANCE TO SUCCEED
        //THIS BLOCK CAN RACE WITH OTHER THREADS, AFFECTING WHETHER THEY CAN REGISTER ACCEPTORS, CATCHERS, QUITTERS, ETC.
        if( stTasksWhenQuitting.third ) stTasksWhenQuitting.third = 0 ;
    
        TELL( "waiting until i and tmWindowsF and tmAnimateSadamsOnPaperF are the only child threads" ) ;
        countT cTries = 0x10 ;
        {
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            while( cAllKidThreadsI + cAllOrphanThreadsI > 1 + 2 * b_tmWindows && cTries -- ) { ++ s ; etThread.osSleepF( tinP , TUCK * 0x40 ) ; } // tmWindowsF tmAnimateSadamsOnPaperF
        }
    
        TELL( "cleaning up for this cycle" ) ;
        //U:: DISABLED PENDING DEBUG AND TUNE OF 6a4
        #if defined( NEVERdEFINED )
        static countT idTry ;
        static boolT bArmed = 1 ;
        if( bArmed && ++ idTry >= 0x8 && !etThread && cAllKidThreadsI + cAllOrphanThreadsI > 1 + 2 * b_tmWindows )
        {
            bArmed = 0 ;
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLoN     ) 
            etThread.beeClickF( tinP , 0x3800 , TOCK ) ;
            {
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                ++ s ; etThread.osSleepF( tinP , TOCK * 4 ) ;
            }
            etThread.beeClickF( tinP , 0x3800 , TOCK ) ;
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLoFF    ) 
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLrEPORT ) 
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLpURGE  ) 
        }
        #endif
    
        if( etThread )
        {
            etThread = 0 ;
            //U: MAYBE POPUP A BOX SAYING THAT I BECAME IMPOTENT BUT AM NOW POTENT AND WILL TRY AGAIN
        }
    }
    while( !etThread && ( thirdC::third_idPhaseAdam_IF( tinP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAIN2 || cAllKidThreadsI + cAllOrphanThreadsI > 1 + 2 * b_tmWindows ) ) ; // tmWatchF tmWindowsF tmAnimateSadamsOnPaperF
    
    displayC* pDisplay = displayC::pDisplayIF() ;
    if( pDisplay) ((thirdC&)etThread).winPostMessageF( tinP , *pDisplay , idwm_CLOSE ) ;

    //U::CONJ: THIS IS OBSOLETED BY displayC AND IS NOW REDUNDANT WITH THE PRECEDING LINE
    //if( b_tmWindows )
    //{
    //    if( !( F(thirdC::third_flagsProcessStateI_IF(tinP)) & flPROCESSsTATE_WM_CLOSE_RECEIVED ) )
    //    {
    //        TELL( "posting CLOSE window message to the root window" ) ;
    //        etherC etp( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ;
    //
    //        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
    //        if( pRootI )
    //        {
    //            ((thirdC&)etp).winPostMessageF( tinP , *pRootI , idwm_CLOSE ) ;
    //            pRootI->letRefF() ;
    //        }
    //    }
    //}
    
    TELL( "tmWatchF: cleaning up" ) ;
}
//tinP.pc Utility[ 0 ] -- ; //U::TO FIND A BUG
DONE( tmWatchF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000008.tmwatchf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000009.declarevmusagetypef BEGIN
#define DDNAME       "3func.33000009.declarevmusagetypef"
#define DDNUMB      (countT)0x33000009
#define IDFILE      (countT)0x8f6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$declareVmUsageTypeF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b00014.1.0.html\"\>definition\</A\>
arguments
 tinP
 pbP
  must not be 0
 flUsageTypeP
 postNameP
  can be 0
*/
/**/
/*1*/voidT __export declareVmUsageTypeGF( tinS& tinP , const byteT* const pbP , const flagsT flUsageTypeP , const countT idP , const osTextT* const postNameP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( pbP ) ;
        FV( flVMuSAGEtYPE , flUsageTypeP ) ;
        if( POOP ) return ;
    }

    //U:COMMENTED OUT TILL ENABLE VM TRACKING IN 6a40104
    //if( ( postNameP ? thirdC::c_strlenIF( tinP , postNameP ) : 0 ) < 0x100 )
    //{
    //    OStEXT( ostoNote , 0x140 )
    //    OStEXTAK( ostoNote  , "aok/vm/" ) ;
    //    OStEXTC( ostoNote  , (countT)pbP , 0 ) ;
    //    OStEXTAK( ostoNote  , "/" ) ;
    //    OStEXTC( ostoNote  , postb , (countT)flUsageTypeP , 0 ) ;
    //    if( idP )
    //    {
    //        OStEXTAK( ostoNote  , "/" ) ;
    //        OStEXTC( ostoNote  , idP , 0 ) ;
    //    }
    //    if( postNameP )
    //    {
    //        OStEXTAK( ostoNote  , "/" ) ;
    //        OStEXTA( ostoNote  , postNameP ) ;
    //    }
    //
    //    //U::USE tellC:TELLsYSc3() ostoNote
    //}
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000009.declarevmusagetypef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300000a.tmrelaychatrepliesf BEGIN
#define DDNAME       "3func.3300000a.tmrelaychatrepliesf"
#define DDNUMB      (countT)0x3300000a
#define IDFILE      (countT)0x8f7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$tmRelayChatRepliesF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b00015.1.0.html\"\>definition\</A\>
*/
/**/
/*1*/TASK( tmRelayChatRepliesF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
{
    TELL( "setting up" )
    socketC& soDn        = *(socketC*)pTaskP->c1 ;
    socketC& soUp        = *(socketC*)pTaskP->c2 ;
    signC&   sgnUpTested =   *(signC*)pTaskP->c3 ;
    countT   idRelay     =            pTaskP->c4 ;

    IFsCRATCH
    {
        SCOOPS
        etherC& etText = etherC::etTextIF( tinP ) ;
        soDn.etherF( tinP , *tinP.pEtScratch ) ;
        soUp.etherF( tinP , *tinP.pEtScratch ) ;
    
        boolT bWoth = 1 ;
        ZE( countT , idTray ) ;
        while( !POOP && !etThread )
        {
            idTray ++ ;
            soulC sReply( tinP , TAG( TAGiDnULL ) ) ;
            TELL( "reading from above a reply soulC" )
            soUp.readF( tinP , sReply ) ;
            TELL( "handling the soulC read from above" )
    
            //if( soUp.etherF( tinP ) ) etText.strokeF( tinP , T("RcHAT/")+TF1(idRelay)+T("/tmRelayChatRepliesF/could not read sReply from up\r\n") ) ;
            //else if( !sReply )        etText.strokeF( tinP , T("RcHAT/")+TF1(idRelay)+T("/tmRelayChatRepliesF/read a null sReply from up\r\n") ) ;
            //else                      etText.strokeF( tinP , T("RcHAT/")+TF1(idRelay)+T("/tmRelayChatRepliesF/read a nonnull sReply from up\r\n") ) ;
    
            if( bWoth )
            {
                bWoth = 0 ;
                sgnUpTested.giveF( tinP ) ;
            }
            if( POOP )
            {
                POOPR
                //etText.strokeF( tinP , T("RcHAT/")+TF1(idRelay)+T("/tmRelayChatRepliesF/telling soDn to stop waiting for an order\r\n") ) ;
                {
                    OStEXTV( ostoe , "!tinS tmRelayChatRepliesF: canceling soDn because soUp is impotent" )
                    thirdC::dosTellMonitorIF( tinP , tellC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEtELLsYS_LOG , ostoe , ostoe.costF() + 1 ) , ifcIDbOOKStELL_SYS ) ;
                }
                soDn.stopWaitingF( tinP ) ;
                break ;
            }
    
            soulC sNull( tinP , TAG( TAGiDnULL ) ) ;
            soulC& sWrite = soUp.etherF( tinP ) ? sNull : sReply ;
            TELL( "writing to below the reply soul read from above" )
            etThread.traceF( tinP , T("writing sWrite (sNull or sReply)") ) ;
            soDn.writeF( tinP , sWrite ) ;
    
            if( !sReply ) break ;
        }
        if( bWoth ) sgnUpTested.giveF( tinP ) ;
        TELL( "tmRelayChatRepliesF: cleaning up" )
        if( POOP ) POOPR
    }
}
DONE( tmRelayChatRepliesF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300000a.tmrelaychatrepliesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300000b.osanglef BEGIN
#define DDNAME       "3func.3300000b.osanglef"
#define DDNUMB      (countT)0x3300000b
#define IDFILE      (countT)0x8f8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$osAngleF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b00016.1.0.html\"\>definition\</A\>
i map ifc angle values to foreign angle values
the range of an ifc angle is [0,1]
 both bounds correspond to the base (lowest) point on a circle
 angles increasing from 0 sweep the circle clockwise from the lowest point
the range of a foreign angle is [0,PI*2]
 both bounds correspond to the rightmost point on a circle
 angles increasing from 0 sweep the circle counterclockwise from the rightmost point
ifc and foreign conventions both treat the bottommost point as having cos = 0 and sin = - 1
so the trigonometric functions do not require mental translation
however, angle values are "always" stored using the ifc convention
*/
/**/

/*1*/measureT __export osAngleF( const measureT ifAngleP )/*1*/
{
    return ( 0.75 - ifAngleP ) * 2 * PI ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300000b.osanglef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300000c.ifanglef BEGIN
#define DDNAME       "3func.3300000c.ifanglef"
#define DDNUMB      (countT)0x3300000c
#define IDFILE      (countT)0x8f9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ifAngleF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b00017.1.0.html\"\>definition\</A\>
i map foreign angle values to ifc angle values
the range of an ifc angle is [0,1]
 both bounds correspond to the base (lowest) point on a circle
 angles increasing from 0 sweep the circle clockwise from the lowest point
the range of a foreign angle is [0,PI*2]
 both bounds correspond to the rightmost point on a circle
 angles increasing from 0 sweep the circle counterclockwise from the rightmost point
*/
/**/

/*1*/measureT __export ifAngleF( const measureT osAngleP )/*1*/
{
    return 0.75 - osAngleP / 2 / PI ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300000c.ifanglef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300000d.threadlocalstoragef BEGIN
#define DDNAME       "3func.3300000d.threadlocalstoragef"
#define DDNUMB      (countT)0x3300000d
#define IDFILE      (countT)0x8fa


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$threadLocalStorageF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b00018.1.0.html\"\>definition\</A\>
i allocate oo objects on the thread's stack so that they can be found at known offsets within the stack frame
my stack frame can be found by walking the stack looking for FINGERnEG_THREADlOCALsTORAGE
then the value in pTin can be obtained
pTin, if not ze, points to the tinS, object for this thread
*/
/**/

// NOTE: I MUST BE COMPILED WITH OPTIMIZATIONS DISABLED (-od)

/*1*/countT __export threadLocalStorageF( const countT idTypeP , kidFT pThreadWorkF , countT cArgP , countT cHowP , const osTextT** ppostHowP , countT hWindowingClientIP , countT hPreviousWindowingClientP , osTextT* postP , countT idCmdShowP )/*1*/
{
    ZE( countT , rc ) ;
    inc02AM( processGlobal1I.cTls ) ;
    {
        tlsStackFrameS sf( idTypeP , postP , cArgP ) ; //CODE SYNC: THE OFFSET OF SOME MEMBERS OF sf FROM [ebp] (THE STACK FRAME) IS HARDCODED IN snip.009*

        //I HAVE SEEN WDW FAIL TO LOAD SYMBOLIC INFO BECAUSE THE OFFSET OF sf FROM [ebp] CHANGED, AND APPARENTLY pTinAM CRAPPED EARLY ON SOME DEBUGGING INFO SO WDW COULDN'T EVEN GET THE MODULE LOADED
        //IF WDW EVER FAILS TO LOAD ITS INFO, DEBUG STARTUP (IF YOU CAN); ELSE USE OTHER MEANS (WRITE TO CONSOLE) TO SEE THE NEW OFFSETS
    
        if( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WINDOW || idTypeP == ifcIDtYPEtLS_BENCH )
        {
            offFingerVerifyI = ebpAM() - (countT)&sf.fingerVerify ; //MUST BE DONE BEFORE pTinAM OR pTin2AM ARE CALLED ; THIS IS THE OFFSET OF FINGERvERIFY *BELOW* EBP, CALCULATED HERE SO THAT ITS VALUE IS POSITIVE, TO MAKE DEBUGGER DISPLAYS EASIER TO READ
            processGlobal1I.flCt |= flCTdTg_THREADlOCALsTORAGE ;
                                    if( &pTinF() != &pTinMainI_IF() ) { BLAMMO ; }
            bTlsEarlyLateIF() = 0 ; if( &pTinF() != &sf.pTin        ) { BLAMMO ; }
    
            sf.pTin = pTinMainI_IF() ;
    
            if( pTinF() != &sf.tinEarlyLate ) { BLAMMO ; }
        }
    
        {
            TINSL
            _IO_
                 if( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WINDOW                                 ) sf.rc = mainThreadWorkF( idTypeP , cHowP , ppostHowP , hWindowingClientIP , hPreviousWindowingClientP , postP , idCmdShowP ) ;
            else if( idTypeP == ifcIDtYPEtLS_KID || idTypeP == ifcIDtYPEtLS_EXCEPTION || idTypeP == ifcIDtYPEtLS_BENCH ) sf.rc = (*pThreadWorkF)( cArgP ) ;
            else                                                                                                         sf.rc = 1 ;
        }
    
        if( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WINDOW || idTypeP == ifcIDtYPEtLS_BENCH )
        {
            {
                TINSL
                _IO_
                {
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    while( processGlobal1I.cTls > 1 )
                    {
                        ++ s ; thirdC::dosSleepWinkIF( tinP ) ;
                    }
                }
            }

            pTinMainI_IF() = sf.pTin ;
            bTlsEarlyLateIF() = 1 ;
            processGlobal1I.flDt |= flCTdTg_THREADlOCALsTORAGE ;
        }

        rc = sf.rc ;
    }
    dec02AM( processGlobal1I.cTls ) ;

    return rc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300000d.threadlocalstoragef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300000e.mainthreadworkf BEGIN
#define DDNAME       "3func.3300000e.mainthreadworkf"
#define DDNUMB      (countT)0x3300000e
#define IDFILE      (countT)0x8fb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$mainThreadWorkF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b00019.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
seven reliability levels are supported
 1build:     being crafted; unfinished; might not work
 2play:      still being crafted, but can be played with
 3check:     ready for testing to see whether everything still works
 4batter:    ready for gorilla testing to see whether it can be broken
 5useok:     ready for user testing to see whether the changes are an improvement
 6usebetter: ready for many-user testing to confirm reliability and quality
 7use:       ready for applications requiring highest reliability
parameter 1 must either be a seven digit immutable file id, or a full file name
 both examples refer to the same dll
 example: 4321104
 example: //ideafarm/ephemeral/domains/com/ideafarm/city/park/test/43211040.ipdos-wd
it is illegal to refer to this symbol in the definition of an adam
limit: the average parameter length, calculated using all parameters (including the executable file name), must not exceed 100
the following single word directives are automatically processed if specified as arguments when starting a process
 single word directives
  !bCarefree
   suppresses the validation of kernel function parameters
  !bWatchfulI
   enables code that selectively (according to other flags) monitors process state and elapsed time
  !testAuto
   tells etherC::strokeF to return immediately with a default response, and suppresses sleeping
  !testAutoDoSleeps
   when !testAuto is also specified, enables sleeping
  !bWatchTime
   if !bWatchEmployers is also specified, causes the collection of information about the gross time spent in each function
    "gross time" refers to time spent in a function, including time spent in other functions that it calls
   otherwise, causes the collection of information about the net time spent in each function
    "net time" refers to time spent in a function, excluding time spent in other functions that it calls
   elapsed times are tracked separately for each thread
   elapsed times are net of time that the thread is blocked sleeping, waiting for a sign, waiting for user input, or waiting for a baton
    U: verify that these details are true
    in a multithreaded application, this can result in understatement of the actual time spent in a function
     U: study code and then specify the formula for the amount of understatement
  !bWatchEmployers
   causes the time watching code for each function to "know" the identity of the calling function, on down to the root calling function for the thread
   the time watching code uses this extra information to calculate net elapsed time instead of gross elapsed time
  !bWatchSay
   causes function entries and exits to be logged to the face
 multiple word directives
  !tinP.pAdamGlobal1->_etherC_.idCitizenHirer <value>
   example: !tinP.pAdamGlobal1->_etherC_.idCitizenHirer 21
    in this example, citizen 21 is the "hirer" of this adam life
    the "hirer" is used by city center to determine who is responsible for paying the wages of this worker adam
application code can inspect all parameters by using a FORsTRINGSiN macro to inspect tinP.pAdamGlobal1->_etherC_.pstt1_processParameters
 be sure to use ether.ether_tinP.pAdamGlobal1->_etherC_.pstt1_processParameters_F( tinP ) to refer to this static member
it is illegal for application code to modify or replace tinP.pAdamGlobal1->_etherC_.pstt1_processParameters
pseudocode
 this code does the following when building 0100002 (basic process driver)
  partial scan of parameters using static functions
  construct 2 poolC objects, 1 buoyTinC object, ether
  full scan of parameters
  construct etThread, set up error mode, exception handler, and sockets
  emit hired datum, test the poolOld, mark the poolOld
  hover, open the adam dll
  call the main function of the adam
  destroy all objects, shut down sockets
 when building 0100003 (gui process driver), the following additional work is done
  launch tmWindowsF; wait for it to give a sign that it is ready
*/
/**/

//OBSOLETE COMMENT:
// I AM IN A SNIPPET BECAUSE I MUST BE DEFINED WITHIN THE EXE IMAGE (FOR THE WINDOWING FLAVOR OF THE EXE)

/*1*/countT mainThreadWorkF( const countT idTypeP , countT cHowP , const osTextT** ppostHowP , countT hWindowingClientIP , countT hPreviousWindowingClientP , osTextT* postP , countT idCmdShowP )/*1*/
{
    //U::THESE REMAIN HERE, OUTSIDE OF adamMainF
    TINSL
    _IO_
    handleC hZits( tinP , TAGnOtIN( TAGiDnULL ) , ifcIDtYPEhANDLE_EXCEPTIONhANDLER ) ; //WOULD LIKE THIS TO BE THE WOTH STATIC, BUT IT DOESN'T WORK THAT EARLY
    handleC hConsole( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_CONSOLEhANDLER ) ;
    if( idTypeP == ifcIDtYPEtLS_CONSOLE ) thirdC::dosPushConsoleHandlerIF( tinP , hConsole ) ;

    ZE( countT , rc ) ;
    {
        _IO_
        rc = adamMainF( tinP , idTypeP , cHowP , ppostHowP , hWindowingClientIP , hPreviousWindowingClientP , postP , idCmdShowP ) ;
    }
    return rc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300000e.mainthreadworkf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300000f.threadlocalstoragelocationf BEGIN
#define DDNAME       "3func.3300000f.threadlocalstoragelocationf"
#define DDNUMB      (countT)0x3300000f
#define IDFILE      (countT)0x8fc


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$threadLocalStorageLocationF.0.html\"\>instances\</A\>
\<A HREF=\"5.0b0001a.1.0.html\"\>definition\</A\>
my stack frame can be found by walking the stack looking for FINGERnEG_THREADlOCALsTORAGElOCATION
then the value in ebp can be obtained
ebp, if not ze, points to the stack frame where pTinF should continue to look for this thread's tls
arguments
*/
/**/

// NOTE: I MUST BE COMPILED WITH OPTIMIZATIONS DISABLED (-od)
//U:: CONJ: THIS IS NO LONGER TRUE NOW THAT CODE DYNAMICALLY CALCULATES THE OFFSET THAT IT NEEDS TO GET INTO sf

/*1*/countT __export threadLocalStorageLocationF( const countT oshWindowP , const countT idCmdP , const countT p1P , const countT p2P )/*1*/
{
    ZE( countT , rc ) ;
    {
        tlsStackFrameLocationS sf ; //CODE SYNC: THE OFFSET OF SOME MEMBERS OF sf FROM [ebp] (THE STACK FRAME) IS HARDCODED IN snip.009*
        {
            offFingerVerifyLocationI = ebpAM() - (countT)&sf.fingerVerify ; //MUST BE DONE BEFORE ebpTlsAM IS CALLED ; THIS IS THE OFFSET OF FINGERvERIFY *BELOW* EBP, CALCULATED HERE SO THAT ITS VALUE IS POSITIVE, TO MAKE DEBUGGER DISPLAYS EASIER TO READ
            if( &ebpTlsAM() != &sf.ebp )
            {
                OStEXT( ostoFile , 0x100 )
                OStEXTAK( ostoFile , "\\ideafarm." ) ;
                OStEXTC( ostoFile , processGlobal1I.idHome , 0 ) ;
                OStEXTAK( ostoFile , ".log.threadLocalStorageLocationF" ) ;
                { BLAMMO ; }
            }
        
            if( idCmdP ) sf.rc = thirdC::winMessageHandlerWorkF( oshWindowP , idCmdP , p1P , p2P ) ;
            else
            {
                if( oshWindowP || p1P ) { BLAMMO ; }
                sf.rc = thirdC::osExceptionHandlerWorkIF( p2P ) ;
            }
    
            rc = sf.rc ;
        }
    }

    return rc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300000f.threadlocalstoragelocationf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000010.matherr BEGIN
#define DDNAME       "3func.33000010.matherr"
#define DDNUMB      (countT)0x33000010
#define IDFILE      (countT)0x8fd


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.0c00004.1.0.html\"\>definition\</A\>
this function is called by the compiler c library when an error is detected by a c library math function
*/
/**/

/*1*/extern "C" int matherr( struct _exception* pInfoP )/*1*/
{
    TINSL
    _IO_
    FIREmYSELF( 3 ) ;
    if( pInfoP ) ;
    return 1 ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000010.matherr END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000011.subtractf BEGIN
#define DDNAME       "3func.33000011.subtractf"
#define DDNUMB      (countT)0x33000011
#define IDFILE      (countT)0x8fe


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$subtractF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c00005.1.0.html\"\>definition\</A\>
evaluates to one of re values (-1,0,1) depending on the relative sort ordering of pb1P and pb2P
 1: pb1P > pb2P
 0: pb1P == pb2P
 -1: pb1P < pb2P
arguments
 tinP
 pb1P
 pb2P
 cb1P
 cb2P
 bNumericP
  0: pb1P and pb2P point to adjacent byteT objects
  1: pb1P and pb2P point to adjacent countT objects
 bSignificanceIncreasingP
  0: pb1P and pb2P point to objects (countT or byteT) that are in order of decreasing significance (osTextT and pcz names are stored this way)
  1: pb1P and pb2P point to objects (countT or byteT) that are in order of increasing significance (large integer values are stored this way)
*/
/**/

#define RAT(xP)                                                                                                         \
                                                                                                                        \
    (                                                                                                                   \
        bMod                                                                                                            \
        ?                                                                                                               \
        (                                                                                                               \
            ( (xP) / sizeof( countT ) ) * sizeof( countT ) - (xP) % sizeof( countT ) + sizeof( countT ) - 1             \
        )                                                                                                               \
        :                                                                                                               \
            (xP)                                                                                                        \
    )

/*1*/sCountT subtractF( tinS& tinP , thirdC& third , const byteT* const pb1P , const byteT* const pb2P , const countT cb1P , const countT cb2P , const boolT bNumericP , const boolT bSignificanceIncreasingP )/*1*/
{
    IFbEcAREFUL    
    {
        if( third ) return 0 ;
    }

    _IO_
    // STRATEGY: LOOK AT MOST SIGNIFICANT BYTE PAIR FIRST, AND END AS SOON AS HAVE A NONZE VALUE
    //
    //  !bNumeric !bSignificanceIncreasing    0 1 2 3 4 5 6 7 ... cb-1    (example: text)           up      moduloNo
    //  !bNumeric  bSignificanceIncreasing    cb-1 ... 7 6 5 4 3 2 1 0                              down    moduloNo
    //   bNumeric !bSignificanceIncreasing    3 2 1 0 7 6 5 4 ...         (example: pcz names)      up      moduloYes
    //   bNumeric  bSignificanceIncreasing    cb-1 ... 7 6 5 4 3 2 1 0    (example: large digits)   down    moduloNo

    const boolT bUp  = !bSignificanceIncreasingP ;
    const boolT bMod = bNumericP && !bSignificanceIncreasingP ;

    countT cb1 = pb1P ? ( cb1P ? cb1P : third.c_strlenIF( tinP , pb1P ) ) : 0 ;
    countT cb2 = pb2P ? ( cb2P ? cb2P : third.c_strlenIF( tinP , pb2P ) ) : 0 ;

    __( bMod && cb1 % sizeof( countT ) ) ;
    __( bMod && cb2 % sizeof( countT ) ) ;

    sCountT o1 = bUp ? 0 : cb1 - 1 ; // "o" IS FOR OFFSET
    sCountT o2 = bUp ? 0 : cb2 - 1 ;

    ZE( sCountT , sgn ) ;
    if( !third )
    {
             if( !pb1P && !pb2P ) ;
        else if( !pb1P ) sgn = - 1 ;
        else if( !pb2P ) sgn =   1 ;
        else if( !cb1 && !cb2 ) ;
        else if( !cb1 ) sgn = - 1 ;
        else if( !cb2 ) sgn =   1 ;
        else if( bUp ) // UP
        {
            while( !sgn && o1 < cb1 && o2 < cb2 )
            {
                sgn = pb1P[ RAT( o1 ) ] - pb2P[ RAT( o2 ) ] ;

                o1 ++ ;
                o2 ++ ;
            }

            if( !sgn )
            {
                if( o1 == cb1 && o2 == cb2 ) ;
                else if( o1 == cb1 ) sgn = - 1 ;
                else if( o2 == cb2 ) sgn =   1 ;
            }
        }
        else // DOWN
        {
            if( cb1 > cb2 )
            {
                while( !sgn && o1 > o2 )
                {
                    if( pb1P[ o1 -- ] ) sgn = 1 ;
                }
            }
            else if( cb1 < cb2 )
            {
                while( !sgn && o2 > o1 )
                {
                    if( pb2P[ o2 -- ] ) sgn = - 1 ;
                }
            }

            while( !sgn && o1 >= 0 )
            {
                sgn = pb1P[ o1 ] - pb2P[ o2 ] ;

                o1 -- ;
                o2 -- ;
            }
        }
    }

         if( sgn < 0 ) sgn = - 1 ;
    else if( sgn > 0 ) sgn =   1 ;
    return sgn ;
}

#undef RAT


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000011.subtractf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000012.hoverf BEGIN
#define DDNAME       "3func.33000012.hoverf"
#define DDNUMB      (countT)0x33000012
#define IDFILE      (countT)0x8ff


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$hoverF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c00006.1.0.html\"\>definition\</A\>
arguments
 tinP
 third
 postHoverP
  must be 0
  after i return, will contain the full name of a directory
  the caller is responsible for deleting this poolOld drop
 idHoverDirP
  can be 0
   if 0 then the hover directory is implied
   else the current directory is set to the specified directory
*/
/**/
/*1*/voidT __export hoverF( tinS& tinP , thirdC& third , osTextT*& postHoverP , const countT idHoverDirP )/*1*/
{
    IFbEcAREFUL    
    {
        if( third ) return ;
        __NZ( postHoverP ) ;
        if( third ) return ;
    }

    _IO_
    // FIND HOME
    ZE( osTextT* , postHome ) ;
    const osTextT postDisk[] = "///?" ;
    osTextT& ostDisk3 = ((osTextT*)postDisk)[ 3 ] ;
    {
        {
            ZE( osTextT* , posth ) ;
            third.dosScanEnvF( tinP , posth , "ideafarm" ) ; ___( posth ) ;
            if( !posth )
            {
                OStEXT( ostov , 0x40 )
                OStEXTAK( ostov , "ideafarm.home." ) ; //A: ASSUME: sizeof( countT ) <= 81
                OStEXTC( ostov , processGlobal1I.idHome , 0 ) ;
                third.newF( tinP , LF , posth , ostov.costF() + 1 ) ; ___( posth ) ;
                third.c_memcpyIF( tinP , posth , ostov , ostov.costF() + 1 ) ;
            }

            OStEXT( ostoHome , 0x200 )
            OStEXTAK( ostoHome  , "?:\\" )
            OStEXTA( ostoHome  , posth )
            OStEXTAK( ostoHome  , "\\" )
            third.delF( tinP , posth ) ;

            third.newF( tinP , LF , postHome , ostoHome.costF() + 1 ) ; ___( postHome ) ;
            third.c_memcpyIF( tinP , postHome , ostoHome , ostoHome.costF() + 1 ) ;
        }

        if( postHome )
        {
            for( ostDisk3 = 'z' ; ostDisk3 >= 'c' ; ostDisk3 -- )
            {
                ZE( boolT , bFound ) ;
                ZE( infoDisk1S* , pInfo1 ) ;
                third.dosQueryFSInfoF( tinP , pInfo1 , postDisk ) ; ___( pInfo1 ) ;
                if( pInfo1 && pInfo1->bLocal )
                {
                    *postHome = ostDisk3 ;
                    if( bFileOrDirExistsF( tinP , third , postHome ) && third.c_zDiskFLongFileNamesOKF( tinP , postDisk ) ) bFound = 1 ;
                }
                DEL( pInfo1 ) ;
                if( bFound ) break ;
            }

            if( ostDisk3 < 'c' ) // IF DIDN'T FIND HOME
            {
                *postHome = '?' ;

                {
                    OStEXT( ostom , 0x800 )
                    OStEXTAK( ostom  , 
                        "aok/cmd/log/"
                        "then open me again and i will seach for the folder and use it\r\n"
                        "then manually create the folder at the root of the preferred disk\r\n"
                        "if you want it to be on a specific disk, select \"cancel\"\r\n"
                        "\r\n"
                        "to have me create this folder on the disk with the most space, press \"ok\"\r\n"
                        "\r\n"
                    ) ;

                    OStEXTAK( ostom  , "a folder called \"" ) ;
                    OStEXTA( ostom  , postHome ) ;
                    OStEXTAK( ostom  , "\" was not found at the root of any local disk" ) ;

                    //U:COMMENTED OUT WHEN LOGGING SUPPORT REPLACED: thirdC::( tinP , ostom ) ;
                }

                if( !third )
                {
                    ZE( osTextT , ostDiskBest ) ;
                    ZE( countT , cbFreeBest ) ;
                    for( ostDisk3 = 'z' ; ostDisk3 >= 'c' ; ostDisk3 -- )
                    {
                        ZE( infoDisk1S* , pInfo1 ) ;
                        third.dosQueryFSInfoF( tinP , pInfo1 , postDisk ) ; ___( pInfo1 ) ;
                        if( pInfo1 && pInfo1->bLocal && third.c_zDiskFLongFileNamesOKF( tinP , postDisk ) )
                        {
                            countT cbFree = pInfo1->cBytesPerSector * pInfo1->cSectorsPerAllocationUnit * pInfo1->cUnusedUnits ;
                            if( cbFreeBest < cbFree )
                            {
                                cbFreeBest = cbFree ;
                                ostDiskBest = ostDisk3 ;
                            }
                        }
                        DEL( pInfo1 ) ;
                    }

                    *postHome = ostDiskBest ;

                    third.dosCreateDirF( tinP , postHome ) ;
                }
            }
        }
    }

    // HOVER
    {
        #ifdef __OS2__
            third.dosSetDefaultDiskF( tinP , postDisk ) ;
        #endif

        OStEXT( ostoHover , 0x200 ) //ASSUME: THIS IS LARGE ENOUGH TO HOLD A FILE NAME OF MAX LENGTH
        OStEXTA( ostoHover , postHome     ) ; cdF( tinP , third  , ostoHover ) ;
        OStEXTAK( ostoHover , "domains\\"  ) ; cdF( tinP , third  , ostoHover ) ;
        OStEXTAK( ostoHover , "com\\"      ) ; cdF( tinP , third  , ostoHover ) ;
        OStEXTAK( ostoHover , "ideafarm\\" ) ; cdF( tinP , third  , ostoHover ) ;
        OStEXTAK( ostoHover , "city\\"     ) ; cdF( tinP , third  , ostoHover ) ;
        OStEXTAK( ostoHover , "park\\"     ) ; cdF( tinP , third  , ostoHover ) ;
        switch( idHoverDirP )
        {
            case ifcIDhOVERdIR_DRIVER : { OStEXTAK( ostoHover , "driver\\"   ) ; cdF( tinP , third  , ostoHover ) ; break ; }
            default :
            {
                OStEXTAK( ostoHover , "exedll\\"   ) ; cdF( tinP , third  , ostoHover ) ;
                OStEXTAK( ostoHover , "1\\"        ) ; cdF( tinP , third  , ostoHover ) ;
                switch( idHoverDirP )
                {
                    case ifcIDhOVERdIR_MASTER : { OStEXTAK( ostoHover  , "master\\" ) ; break ; }
                    default                   : { OStEXTAK( ostoHover  , "hover\\"  ) ; break ; }
                }
                cdF( tinP , third , ostoHover ) ;
                break ;
            }
        }
        countT costa = ostoHover.costF() + 1 ;
        third.newF( tinP , LF , postHoverP , costa ) ; ___( postHoverP ) ;
        thirdC::c_strncpyIF( tinP , postHoverP , ostoHover , costa ) ;
    }

    third.delF( tinP , postHome ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000012.hoverf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000013.bfileordirexistsf BEGIN
#define DDNAME       "3func.33000013.bfileordirexistsf"
#define DDNUMB      (countT)0x33000013
#define IDFILE      (countT)0x900


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$bFileOrDirExistsF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c00007.1.0.html\"\>definition\</A\>
*/
/**/
/*1*/boolT __export bFileOrDirExistsF( tinS& tinP , thirdC& third , const osTextT* const postP )/*1*/
{
    _IO_
    ZE( infoFileS* , pInfo ) ;
    {
        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        third.dosFindFileOrDirF( tinP , pInfo , handle , postP ) ; ___( pInfo ) ;
    }
    boolT bFound = !!pInfo ;
    DEL( pInfo ) ;
    return bFound ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000013.bfileordirexistsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000014.cdf BEGIN
#define DDNAME       "3func.33000014.cdf"
#define DDNUMB      (countT)0x33000014
#define IDFILE      (countT)0x901


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$cdF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c00008.1.0.html\"\>definition\</A\>
*/
/**/
/*1*/voidT cdF( tinS& tinP , thirdC& third , const osTextT* const postP )/*1*/
{
    const countT costP = postP ? thirdC::c_strlenIF( tinP , postP ) : 0 ;
    IFbEcAREFUL
    {
        if( third ) return ;
        __Z( postP ) ;
        if( third ) return ;
        __( postP[ costP - 1 ] - '\\' ) ;
        if( third ) return ;
    }

    _IO_
    {
        third.dosCreateDirF( tinP , postP ) ;
        third.dosSetCurrentDirIF( tinP , postP ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000014.cdf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000015.bleapyearf BEGIN
#define DDNAME       "3func.33000015.bleapyearf"
#define DDNUMB      (countT)0x33000015
#define IDFILE      (countT)0x902


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$bLeapYearF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c0000c.1.0.html\"\>definition\</A\>
arguments
 yP
  this is an offset value
   for example, yP 1999_9 corresponds to the year conventionally referred to as 2000
*/
/*1*/boolT bLeapYearF( const sCountT yP )/*1*/
{
    //CANNOT USE SINCE I AM CALLED BY thirdC::ct: TINSL //U: THIS IS ILLEGAL. PASS tinP AS A PARAM
    //IN
    const sCountT yc = yP + 1 ;
    //OUT
    return    !(yc%4)    &&    (    !!(yc%100)    ||    ( yc && !(yc%400) )    ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000015.bleapyearf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000016.operator_new BEGIN
#define DDNAME       "3func.33000016.operator_new"
#define DDNUMB      (countT)0x33000016
#define IDFILE      (countT)0x903


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


/*
\<A HREF=\"5.0c0000d.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
*/
/**/
/*1*/voidT* operator new[]( countT cbP )/*1*/
{
    TINSL
    _IO_
    return operator new( cbP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000016.operator_new END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000017.operator_new BEGIN
#define DDNAME       "3func.33000017.operator_new"
#define DDNUMB      (countT)0x33000017
#define IDFILE      (countT)0x904


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"5.0c0000e.1.0.html\"\>definition\</A\>
it is illegal to refer to this symbol in the definition of an adam
*/
/**/
/*1*/voidT* operator new( countT cbP )/*1*/
{
    TINSL
    _IO_
    ;//TELLsYSc1( ifcIDtYPEtELLsYS_ERRORgLOBALnEWoPERATORuSED )
    if( cbP ) ;
    return 0 ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000017.operator_new END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000018.postfromtingf BEGIN
#define DDNAME       "3func.33000018.postfromtingf"
#define DDNUMB      (countT)0x33000018
#define IDFILE      (countT)0x905


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$postFromTinF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c0000f.1.0.html\"\>definition\</A\>
arguments
 tinP
  can be 0
 postoP
  must be 0
  if tinP.pEther is not 0 then postP will be allocated from *tinP.pEther's poolOld
  else it will be allocated from the default poolOld
*/
/**/
/*1*/voidT __export postFromTinGF( tinS& tinP , const countT idLineP , const countT idFileP , osTextT*& postP , const countT idSinP )/*1*/
{
    _IO_
    switch( idSinP )
    {
        case ifcIDsIN_DEFAULThEAPdEL : { postFromTinGF( tinP , idLineP , idFileP , postP , "attempted to call DEL with an argument that is not a drop in a poolC object" , "This might be a code line that calls DEL() specifying the name of a variable on this thread's stack." ) ; break ; }
        default                      : { postFromTinGF( tinP , idLineP , idFileP , postP , "an undocumented exceptional condition was detected" , "Please report this to IdeaFarm " "(tm) City." ) ; break ; }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000018.postfromtingf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000019.postfromtingf BEGIN
#define DDNAME       "3func.33000019.postfromtingf"
#define DDNUMB      (countT)0x33000019
#define IDFILE      (countT)0x906


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$postFromTinF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c00010.1.0.html\"\>definition\</A\>
arguments
 tinP
  can be 0
 postP
  must be 0
  if tinP.pEther is not 0 then postP will be allocated from *tinP.pEther's poolOld
  else it will be allocated from the default poolOld
*/
/**/
/*1*/voidT __export postFromTinGF( tinS& tinP , const countT idLineP , const countT idFileP , osTextT*& postP , const osTextT* postSinP , const osTextT* postPenanceP )/*1*/
{
    IFbEcAREFUL        
    {
        if( POOP ) return ;
        __NZ( postP ) ;
        if( POOP ) return ;
    }

    _IO_

    osTextT* pposta[] =
    {
        "<notUsed>" ,
        "Thread " ,
        ", \"" ,
        "\", of an adam of class " ,
        ", " ,
        ", at raw line " ,
        " of file " ,
        ".  " ,
    } ;

    ZE( countT , costx ) ;
    {
        countT cElts = sizeof pposta / sizeof pposta[ 0 ] ;
        for( countT off = 0 ; off < cElts ; off ++ ) costx += thirdC::c_strlenIF( tinP , pposta[ off ] ) ;
    }
    costx += thirdC::c_strlenIF( tinP , postSinP ) ;
    costx += thirdC::c_strlenIF( tinP , postPenanceP ) ;
    costx += 8 * 4 ; // 4 IS THE NUMBER OF c_itoa CONCATENATIONS

    //U::postoP = new( costx + 1 , tinP ) osTextC( costx + 1 ) ;

    if( tinP.pEther )
    {
        OStEXT( ostot , 0x400 )
        OStEXTA( ostot , pposta[ 1 ] )
        OStEXTC( ostot , tinP.monitor.idThread , 0 )
        OStEXTA( ostot , pposta[ 2 ] )
        OStEXTA( ostot , tinP.postThreadName )
        OStEXTA( ostot , pposta[ 3 ] )
        OStEXTC( ostot , processGlobal1I.idAdamRoot , 0 )
        OStEXTA( ostot , pposta[ 4 ] )
        OStEXTA( ostot , postSinP )
        OStEXTA( ostot , pposta[ 5 ] )
        OStEXTC( ostot , tinP.pLFstep[ ( tinP.monitor.idStep & OFFsLOTtINsTEPmAX ) << 1 ] & 0xfffffff , 0 )
        OStEXTC( ostot , idLineP , 0 )
        OStEXTA( ostot , pposta[ 6 ] )
        OStEXTC( ostot , tinP.pLFstep[ ( ( tinP.monitor.idStep & OFFsLOTtINsTEPmAX ) << 1 ) + 1 ] , 0 )
        OStEXTC( ostot , idFileP , 0 )
        OStEXTA( ostot , pposta[ 7 ] )
        OStEXTA( ostot , postPenanceP )

        tinP.pEther->newF( tinP , LF , postP , ostot.costF() + 1 ) ; ___( postP ) ;
        thirdC::c_strncpyIF( tinP , postP , ostot , ostot.costF() + 1 ) ;
    }


    //U:: if( postoP )
    //U:: {
    //U::     ZE( countT , ecnu ) ;
    //U::     OStEXTcLEAR( *postP )
    //U::     OStEXTA( *postP , pposta[ 1 ] )
    //U::     OStEXTC( *postP , tinP.monitor.idThread , 0 )
    //U::     OStEXTA( *postP , pposta[ 2 ] )
    //U::     OStEXTA( *postP , tinP.postThreadName )
    //U::     OStEXTA( *postP , pposta[ 3 ] )
    //U::     OStEXTC( *postP , processGlobal1I.idAdamRoot , 0 )
    //U::     OStEXTA( *postP , pposta[ 4 ] )
    //U::     OStEXTA( *postP , postSinP )
    //U::     OStEXTA( *postP , pposta[ 5 ] )
    //U::     OStEXTC( *postP , tinP.pLFstep[ ( tinP.monitor.idStep & OFFsLOTtINsTEPmAX ) << 1 ] & 0xfffffff , 0 )
    //U::     OStEXTC( *postP , idLineP , 0 )
    //U::     OStEXTA( *postP , pposta[ 6 ] )
    //U::     OStEXTC( *postP , tinP.pLFstep[ ( ( tinP.monitor.idStep & OFFsLOTtINsTEPmAX ) << 1 ) + 1 ] , 0 )
    //U::     OStEXTC( *postP , idFileP , 0 )
    //U::     OStEXTA( *postP , pposta[ 7 ] )
    //U::     OStEXTA( *postP , postPenanceP )
    //U:: }
    
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000019.postfromtingf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300001a.hashf BEGIN
#define DDNAME       "3func.3300001a.hashf"
#define DDNUMB      (countT)0x3300001a
#define IDFILE      (countT)0x907


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$hashF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c00018.1.0.html\"\>definition\</A\>
examples
 simplest
  \<A HREF=\"5.9740104.1.1.0.html\"\>9740104:  WAKEsHOW( "example.simplest.func.0c00018.hashF" )\</A\>
for fast execution, there is no overhead code in the definition of this function
acknowledgements: Bob Jenkins
 "By Bob Jenkins, 1996, bob_jenkins@burtleburtle.net"
 http://burtleburtle.net/bob/hash/evahash.html
 "You may use this code any way you wish, private, educational, or commercial.  It's free."
 "Use for hash table lookup, or anything where one collision in 2^^32 is acceptable."
 "Do NOT use for cryptographic purposes."
this function has been observed to return 0, so applications that want a nonze hash must detect and handle this
arguments
 pbP
 cbP
 seedP
  style recommendation: specify 0 unless there is a particular reason to do otherwise
*/
/**/

#define HASHmIX(aP,bP,cP)                                                                                               \
                                                                                                                        \
    {                                                                                                                   \
        aP -= bP ; aP -= cP ; aP ^= cP >> 13 ;                                                                          \
        bP -= cP ; bP -= aP ; bP ^= aP <<  8 ;                                                                          \
        cP -= aP ; cP -= bP ; cP ^= bP >> 13 ;                                                                          \
        aP -= bP ; aP -= cP ; aP ^= cP >> 12 ;                                                                          \
        bP -= cP ; bP -= aP ; bP ^= aP << 16 ;                                                                          \
        cP -= aP ; cP -= bP ; cP ^= bP >>  5 ;                                                                          \
        aP -= bP ; aP -= cP ; aP ^= cP >>  3 ;                                                                          \
        bP -= cP ; bP -= aP ; bP ^= aP << 10 ;                                                                          \
        cP -= aP ; cP -= bP ; cP ^= bP >> 15 ;                                                                          \
    }

/*1*/count02T __export hashF( register const byteT* pbP , register count02T cbP , register count02T seedP )/*1*/
{
    register count02T aa   = 0x9e3779b9 ; /* THE GOLDEN RATIO; AN ARBITRARY VALUE */
    register count02T bb   = 0x9e3779b9 ; /* THE GOLDEN RATIO; AN ARBITRARY VALUE */
    register count02T cc   = seedP ;      /* THE PREVIOUS HASH VALUE, OR AN ARBITRARY VALUE */
    register count02T cbr  = cbP ;

    while( cbr >= 12 )
    {
        aa += pbP[ 0 ] + ( (count02T)pbP[ 1 ] << 8 ) + ( (count02T)pbP[  2 ] << 16 ) + ( (count02T)pbP[  3 ] << 24 ) ;
        bb += pbP[ 4 ] + ( (count02T)pbP[ 5 ] << 8 ) + ( (count02T)pbP[  6 ] << 16 ) + ( (count02T)pbP[  7 ] << 24 ) ;
        cc += pbP[ 8 ] + ( (count02T)pbP[ 9 ] << 8 ) + ( (count02T)pbP[ 10 ] << 16 ) + ( (count02T)pbP[ 11 ] << 24 ) ;
        HASHmIX( aa , bb , cc ) ;
        pbP += 12 ; cbr -= 12 ;
    }

    cc += cbP ; // THE WO'TH BYTE OF cc WILL CONTAIN cbP % 0x100
    switch(cbr)
    {
        case 11 : cc+= (count02T)pbP[ 10 ] << 0x18 ;
        case 10 : cc+= (count02T)pbP[  9 ] << 0x10 ;
        case  9 : cc+= (count02T)pbP[  8 ] <<  0x8 ;
        case  8 : bb+= (count02T)pbP[  7 ] << 0x18 ;
        case  7 : bb+= (count02T)pbP[  6 ] << 0x10 ;
        case  6 : bb+= (count02T)pbP[  5 ] <<  0x8 ;
        case  5 : bb+=           pbP[  4 ]         ;  
        case  4 : aa+= (count02T)pbP[  3 ] << 0x18 ;
        case  3 : aa+= (count02T)pbP[  2 ] << 0x10 ;
        case  2 : aa+= (count02T)pbP[  1 ] <<  0x8 ;
        case  1 : aa+=           pbP[  0 ]         ;  
    }

    HASHmIX( aa , bb , cc ) ;

    return cc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300001a.hashf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300001b.timebasebuiltf BEGIN
#define DDNAME       "3func.3300001b.timebasebuiltf"
#define DDNUMB      (countT)0x3300001b
#define IDFILE      (countT)0x908


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//



/*
\<A HREF=\"6.$timeBaseBuiltF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c00019.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/const timeS& __export timeBaseBuiltF( voidT )/*1*/
{
    return processGlobal3I.timeBaseBuilt ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300001b.timebasebuiltf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300001c.subtractwothcountinblobsf BEGIN
#define DDNAME       "3func.3300001c.subtractwothcountinblobsf"
#define DDNUMB      (countT)0x3300001c
#define IDFILE      (countT)0x909


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$subtractWothCountInBlobsF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c0001d.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/countT _export subtractWothCountInBlobsF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    //O:IFbEcAREFUL
    //O:{
    //O:    if( *pEther ) return 0 ;
    //O:    __( c3P - 2 * sizeof( countT ) ) ;
    //O:    if( *pEther ) return 0 ;
    //O:}

    if( tinP.fingerprint && pEther && c3P ) ;
    return *(countT*)c1P - *(countT*)c2P ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300001c.subtractwothcountinblobsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300001d.hprocessf BEGIN
#define DDNAME       "3func.3300001d.hprocessf"
#define DDNUMB      (countT)0x3300001d
#define IDFILE      (countT)0x90a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$hProcessF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c00024.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/handleC hProcessF( tinS& tinP , const countT osPidP , const countT osPidMeP )/*1*/
{
    handleC hProcess( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_PROCESS ) ;

    if( osPidP == osPidMeP ) hProcess.osF( ifcIDtYPEhANDLE_PROCESS , thirdC::osOpenProcessIF() ) ;
    else
    {
        //U:: DECIDE WHETHER I WANT TO PERMIT "DANGLING HANDLES" IN ORDER TO AVOID THE COST OF HANDLE DUPLICATION
        //U:: if( tinP.pAdamGlobal1->_thirdC_.pSwProcessHandle )
        //U:: {
        //U::     tinP.pAdamGlobal4->_thirdC_grab_lOsPid.grabF( tinP , TAG( TAGiDnULL ) ) ;
        //U::     tinP.pAdamGlobal1->_thirdC_.lOsPid = osPidP ;
        //U::     countT& hProcessMem = *tinP.pAdamGlobal1->_thirdC_.pSwProcessHandle ; //U: OS DEPENDENT; ASSUMES THAT OS RETURNS 0 FOR INVALID PROCESS HANDLE
        //U::     if( !hProcessMem ) hProcessMem = (countT)OpenProcess( PROCESS_ALL_ACCESS , 0 , osPidP ) ;
        //U::     hProcess.osF( ifcIDtYPEhANDLE_PROCESS , hProcessMem ) ;
        //U::     tinP.pAdamGlobal4->_thirdC_grab_lOsPid.ungrabF( tinP ) ;
        //U:: }
        //U:: else
        //U:: {

            hProcess.osF( ifcIDtYPEhANDLE_PROCESS , thirdC::osOpenProcessIF( osPidP ) ) ;

        //U:: }
    }

    //U::CONJ: THIS LINE IS UNDESIRABLE; LET THE CALLER CODE CHECK FOR NULL HANDLE: if( !hProcess ) { BLAMMO ; }
    if( tinP.fingerprint ) ;
    return hProcess ; //U::VERIFY THAT COPY CONSTRUCTOR IS DUPLICATING THE HANDLE
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300001d.hprocessf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300001e.ptinf BEGIN
#define DDNAME       "3func.3300001e.ptinf"
#define DDNUMB      (countT)0x3300001e
#define IDFILE      (countT)0x90b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$pTinF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c00026.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/tinS*& _export pTinF( voidT )/*1*/
{
    //THIS IS NEEDED BECAUSE OTHER THREADS CONTINUE TO EXECUTE WHILE THE EXCEPTION HANDLER IS PROCESSING AN EXCEPTION
    //IF YOU DON'T BELIEVE THIS, ENABLE THE CONoUTrAW3 LINE AND RUN A TEST ADAM THAT BLAMMOS AND HAS SYSTEM THREADS

    if( F(processGlobal1I._thirdC_flagsProcessState) & flPROCESSsTATE_EXCEPTIONnOThANDLED && bTlsEarlyLateIF() )
    //if( F(processGlobal1I._thirdC_flagsProcessState) & flPROCESSsTATE_EXCEPTIONnOThANDLED && bTlsEarlyLateI )
    {
        countT osTidMe = dosGetInfoBlocksIdThreadIF() ;
        if( osTidMe != processGlobal1I.osTidMain && osTidMe != processGlobal1I.osTidTerminator )
        {
            ZE( countT* , pcb ) ; //CANNOT USE BLAMMO MACRO HERE BECAUSE THAT INVOKES TINSL WHICH INVOKES ME
            *pcb = 0xbad32000 ; // "bad32000": "bad" <DDNUMB group bigits>
        }
    }
    
    tinS*& pTin = pTinAM() ; //IF THIS LINE A.V.'S IN DEBUGGER, CLIMB THE CALL STACK INTO TH CALLER AND READ COMMENTS THERE

    if( pTin && getNegAM( pTin->fingerprint ) != FINGERnEG_TINs && getNegAM( pTin->fingerprint ) != FINGERnEG_TINszOMBIE )
    {
        ZE( countT* , pcb ) ; //CANNOT USE BLAMMO MACRO HERE BECAUSE THAT INVOKES TINSL WHICH INVOKES ME
        *pcb = 0xbad32000 ; // "bad32000": "bad" <DDNUMB group bigits>
    }

    return pTin ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300001e.ptinf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300001f.ptinmaini_if BEGIN
#define DDNAME       "3func.3300001f.ptinmaini_if"
#define DDNUMB      (countT)0x3300001f
#define IDFILE      (countT)0x90c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/tinS*& _export pTinMainI_IF( voidT )/*1*/
{
    return pTinMainI ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300001f.ptinmaini_if END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000020.btlsearlylategf BEGIN
#define DDNAME       "3func.33000020.btlsearlylategf"
#define DDNUMB      (countT)0x33000020
#define IDFILE      (countT)0x90d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$bTlsEarlyLateIF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c00028.1.0.html\"\>definition\</A\>
*/
/**/

/*1*/boolT& _export bTlsEarlyLateIF( voidT )/*1*/
{
    return bTlsEarlyLateI ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000020.btlsearlylategf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000021.ranyieldf BEGIN
#define DDNAME       "3func.33000021.ranyieldf"
#define DDNUMB      (countT)0x33000021
#define IDFILE      (countT)0x90e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
\<A HREF=\"6.$ranYieldF.0.html\"\>instances\</A\>
\<A HREF=\"5.0c0002a.1.0.html\"\>definition\</A\>
i will yield the cpu a random number [1,cMaxP] of times
the caller must reset tinP.cYield outside of whatever loop, if any, i am called from
*/
/**/

#if defined( NEVERdEFINED )

    /*1*/voidT ranYieldF( tinS& tinP , countT cMaxP )/*1*/
    {
        const countT idDesireSave = thirdC::dosPriorityIF( tinP ) ;
        thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
        tinP.cYield = 0 ;
        countT cYield = tinP.ranUni % TUCK ;
        cYield = cYield % cMaxP + 1 ;
        {
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            while( cYield -- )
            {
                ++ s ; thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) ) ;
            }
        }
        thirdC::dosPriorityIF( tinP , idDesireSave ) ;
        tinP.cYield = 0 ;
    }

#endif


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000021.ranyieldf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000022.timezonefunctions BEGIN
#define DDNAME       "3func.33000022.timezonefunctions"
#define DDNUMB      (countT)0x33000022
#define IDFILE      (countT)0x90f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/**/

const timeZoneSpecS pSpec[] =
{
    "Dateline"         , "Dateline Standard Time"         , "Dateline Standard Time"         ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  720 ,  0 ,   0 , 
    "Samoa"            , "Samoa Standard Time"            , "Samoa Standard Time"            ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  660 ,  0 ,   0 , 
    "Hawaiian"         , "Hawaiian Standard Time"         , "Hawaiian Standard Time"         ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  600 ,  0 ,   0 , 
    "Alaskan"          , "Alaskan Standard Time"          , "Alaskan Daylight Time"          , 10 ,  0 ,  5 ,  2 ,  4 ,  0 ,  1 ,  2 ,  540 ,  0 , -60 , 
    "Pacific"          , "Pacific Standard Time"          , "Pacific Daylight Time"          , 10 ,  0 ,  5 ,  2 ,  4 ,  0 ,  1 ,  2 ,  480 ,  0 , -60 , 
    "US Mountain"      , "US Mountain Standard Time"      , "US Mountain Standard Time"      ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  420 ,  0 ,   0 , 
    "Mountain"         , "Mountain Standard Time"         , "Mountain Daylight Time"         , 10 ,  0 ,  5 ,  2 ,  4 ,  0 ,  1 ,  2 ,  420 ,  0 , -60 , 
    "Canada Central"   , "Canada Central Standard Time"   , "Canada Central Standard Time"   ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  360 ,  0 ,   0 , 
    "Mexico"           , "Mexico Standard Time"           , "Mexico Standard Time"           ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  360 ,  0 ,   0 , 
    "Central"          , "Central Standard Time"          , "Central Daylight Time"          , 10 ,  0 ,  5 ,  2 ,  4 ,  0 ,  1 ,  2 ,  360 ,  0 , -60 , 
    "US Eastern"       , "US Eastern Standard Time"       , "US Eastern Standard Time"       ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  300 ,  0 ,   0 , 
    "SA Pacific"       , "SA Pacific Standard Time"       , "SA Pacific Standard Time"       ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  300 ,  0 ,   0 , 
    "Eastern"          , "Eastern Standard Time"          , "Eastern Daylight Time"          , 10 ,  0 ,  5 ,  2 ,  4 ,  0 ,  1 ,  2 ,  300 ,  0 , -60 , 
    "SA Western"       , "SA Western Standard Time"       , "SA Western Standard Time"       ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  240 ,  0 ,   0 , 
    "Atlantic"         , "Atlantic Standard Time"         , "Atlantic Daylight Time"         , 10 ,  0 ,  5 ,  2 ,  4 ,  0 ,  1 ,  2 ,  240 ,  0 , -60 , 
    "Newfoundland"     , "Newfoundland Standard Time"     , "Newfoundland Daylight Time"     , 10 ,  0 ,  5 ,  2 ,  4 ,  0 ,  1 ,  2 ,  210 ,  0 , -60 , 
    "SA Eastern"       , "SA Eastern Standard Time"       , "SA Eastern Standard Time"       ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  180 ,  0 ,   0 , 
    "E. South America" , "E. South America Standard Time" , "E. South America Daylight Time" ,  2 ,  0 ,  2 ,  2 , 10 ,  0 ,  3 ,  2 ,  180 ,  0 , -60 , 
    "Mid-Atlantic"     , "Mid-Atlantic Standard Time"     , "Mid-Atlantic Daylight Time"     ,  9 ,  0 ,  5 ,  2 ,  3 ,  0 ,  5 ,  2 ,  120 ,  0 , -60 , 
    "Azores"           , "Azores Standard Time"           , "Azores Daylight Time"           , 10 ,  0 ,  5 ,  3 ,  3 ,  0 ,  5 ,  2 ,   60 ,  0 , -60 , 
    "Greenwich (UTC)"  , "Greenwich Standard Time"        , "Greenwich Standard Time"        ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,    0 ,  0 ,   0 , 
    "GMT"              , "GMT Standard Time"              , "GMT Daylight Time"              , 10 ,  0 ,  5 ,  3 ,  3 ,  0 ,  5 ,  2 ,    0 ,  0 , -60 , 
    "Central Europe"   , "Central Europe Standard Time"   , "Central Europe Daylight Time"   , 10 ,  0 ,  5 ,  3 ,  3 ,  0 ,  5 ,  2 , - 60 ,  0 , -60 , 
    "W. Europe"        , "W. Europe Standard Time"        , "W. Europe Daylight Time"        , 10 ,  0 ,  5 ,  3 ,  3 ,  0 ,  5 ,  2 , - 60 ,  0 , -60 , 
    "Central European" , "Central European Standard Time" , "Central European Daylight Time" , 10 ,  0 ,  5 ,  3 ,  3 ,  0 ,  5 ,  2 , - 60 ,  0 , -60 , 
    "Romance"          , "Romance Standard Time"          , "Romance Daylight Time"          , 10 ,  0 ,  5 ,  3 ,  3 ,  0 ,  5 ,  2 , - 60 ,  0 , -60 , 
    "FLE"              , "FLE Standard Time"              , "FLE Daylight Time"              , 10 ,  0 ,  5 ,  4 ,  3 ,  0 ,  5 ,  3 , -120 ,  0 , -60 , 
    "Egypt"            , "Egypt Standard Time"            , "Egypt Daylight Time"            ,  9 ,  3 ,  5 ,  2 ,  5 ,  5 ,  1 ,  2 , -120 ,  0 , -60 , 
    "E. Europe"        , "E. Europe Standard Time"        , "E. Europe Daylight Time"        ,  9 ,  0 ,  5 ,  1 ,  3 ,  0 ,  5 ,  0 , -120 ,  0 , -60 , 
    "GTB"              , "GTB Standard Time"              , "GTB Daylight Time"              , 10 ,  0 ,  5 ,  3 ,  3 ,  0 ,  5 ,  2 , -120 ,  0 , -60 , 
    "South Africa"     , "South Africa Standard Time"     , "South Africa Standard Time"     ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -120 ,  0 ,   0 , 
    "Israel"           , "Israel Standard Time"           , "Israel Standard Time"           ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -120 ,  0 ,   0 , 
    "Russian"          , "Russian Standard Time"          , "Russian Daylight Time"          , 10 ,  0 ,  5 ,  3 ,  3 ,  0 ,  5 ,  2 , -180 ,  0 , -60 , 
    "E. Africa"        , "E. Africa Standard Time"        , "E. Africa Standard Time"        ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -180 ,  0 ,   0 , 
    "Arab"             , "Arab Standard Time"             , "Arab Standard Time"             ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -180 ,  0 ,   0 , 
    "Iran"             , "Iran Standard Time"             , "Iran Daylight Time"             ,  9 ,  2 ,  4 ,  2 ,  3 ,  0 ,  1 ,  2 , -210 ,  0 , -60 , 
    "Arabian"          , "Arabian Standard Time"          , "Arabian Standard Time"          ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -240 ,  0 ,   0 , 
    "Caucasus"         , "Caucasus Standard Time"         , "Caucasus Standard Time"         ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -240 ,  0 ,   0 , 
    "Afghanistan"      , "Afghanistan Standard Time"      , "Afghanistan Standard Time"      ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -270 ,  0 ,   0 , 
    "Ekaterinburg"     , "Ekaterinburg Standard Time"     , "Ekaterinburg Daylight Time"     , 10 ,  0 ,  5 ,  3 ,  3 ,  0 ,  5 ,  2 , -300 ,  0 , -60 , 
    "West Asia"        , "West Asia Standard Time"        , "West Asia Standard Time"        ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -300 ,  0 ,   0 , 
    "India"            , "India Standard Time"            , "India Standard Time"            ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -330 ,  0 ,   0 , 
    "Central Asia"     , "Central Asia Standard Time"     , "Central Asia Standard Time"     ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -360 ,  0 ,   0 , 
    "Sri Lanka"        , "Sri Lanka Standard Time"        , "Sri Lanka Standard Time"        ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -360 ,  0 ,   0 , 
    "SE Asia"          , "SE Asia Standard Time"          , "SE Asia Standard Time"          ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -420 ,  0 ,   0 , 
    "Taipei"           , "Taipei Standard Time"           , "Taipei Standard Time"           ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -480 ,  0 ,   0 , 
    "W. Australia"     , "W. Australia Standard Time"     , "W. Australia Standard Time"     ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -480 ,  0 ,   0 , 
    "Singapore"        , "Singapore Standard Time"        , "Singapore Standard Time"        ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -480 ,  0 ,   0 , 
    "China"            , "China Standard Time"            , "China Standard Time"            ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -480 ,  0 ,   0 , 
    "Yakutsk"          , "Yakutsk Standard Time"          , "Yakutsk Daylight Time"          , 10 ,  0 ,  5 ,  3 ,  3 ,  0 ,  5 ,  2 , -540 ,  0 , -60 , 
    "Korea"            , "Korea Standard Time"            , "Korea Standard Time"            ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -540 ,  0 ,   0 , 
    "Tokyo"            , "Tokyo Standard Time"            , "Tokyo Standard Time"            ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -540 ,  0 ,   0 , 
    "Cen. Australia"   , "Cen. Australia Standard Time"   , "Cen. Australia Daylight Time"   ,  3 ,  0 ,  5 ,  2 , 10 ,  0 ,  5 ,  2 , -570 ,  0 , -60 , 
    "AUS Central"      , "AUS Central Standard Time"      , "AUS Central Standard Time"      ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -570 ,  0 ,   0 , 
    "AUS Eastern"      , "AUS Eastern Standard Time"      , "AUS Eastern Daylight Time"      ,  3 ,  0 ,  5 ,  2 , 10 ,  0 ,  5 ,  2 , -600 ,  0 , -60 , 
    "Vladivostxk"      , "Vladivostxk Standard Time"      , "Vladivostxk Daylight Time"      , 10 ,  0 ,  5 ,  3 ,  3 ,  0 ,  5 ,  2 , -600 ,  0 , -60 , 
    "Tasmania"         , "Tasmania Standard Time"         , "Tasmania Daylight Time"         ,  3 ,  0 ,  5 ,  2 , 10 ,  0 ,  1 ,  2 , -600 ,  0 , -60 , 
    "E. Australia"     , "E. Australia Standard Time"     , "E. Australia Standard Time"     ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -600 ,  0 ,   0 , 
    "West Pacific"     , "West Pacific Standard Time"     , "West Pacific Standard Time"     ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -600 ,  0 ,   0 , 
    "Central Pacific"  , "Central Pacific Standard Time"  , "Central Pacific Standard Time"  ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -660 ,  0 ,   0 , 
    "New Zealand"      , "New Zealand Standard Time"      , "New Zealand Daylight Time"      ,  3 ,  0 ,  3 ,  2 , 10 ,  0 ,  1 ,  2 , -720 ,  0 , -60 , 
    "Fiji"             , "Fiji Standard Time"             , "Fiji Standard Time"             ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , -720 ,  0 ,   0 , 
}
;

/*1*/countT __export cTimeZonesF( tinS& tinP )/*1*/
{
    if( tinP.fingerprint ) ;
    return sizeof pSpec / sizeof pSpec[ 0 ] ;
}

const timeZoneSpecS& __export timeZoneSpecF( tinS& tinP , const countT idP )
{
    countT idMax = cTimeZonesF( tinP ) ;
    return pSpec[ idP <= idMax ? idP - 1 : 0 ] ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000022.timezonefunctions END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000023.treeoldcallbackdefaultf BEGIN
#define DDNAME       "3func.33000023.treeoldcallbackdefaultf"
#define DDNUMB      (countT)0x33000023
#define IDFILE      (countT)0x910


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT _export treeBranchDefinitionDefaultOldCBF( tinS& tinP , etherC& etherP , const countT idTypeP , const flagsT flagsP , const handleC& handleP , byteT* pbP , countT cbP , countT& cArgP )/*1*/
{
    switch( idTypeP )
    {
        case ifcIDtYPEtREEbRANCHdEFINITIONoLDcb_NEW :
        {
            strokeS* psttb = psttOldC( tinP , etherP , (strokeS*)cArgP ) ; ___( psttb ) ;
            new( 0 , tinP , pbP , cbP ) branchDataOldS( psttb ) ;
            break ;
        }
        case ifcIDtYPEtREEbRANCHdEFINITIONoLDcb_DELETE :
        {
            branchDataOldS* pDoomed = (branchDataOldS*)pbP ;
            DELzOMBIE( pDoomed ) ;
            break ;
        }
    }

    if( flagsP && !handleP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000023.treeoldcallbackdefaultf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000024.tmwatchflagsf BEGIN
#define DDNAME       "3func.33000024.tmwatchflagsf"
#define DDNUMB      (countT)0x33000024
#define IDFILE      (countT)0x911


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmWatchFlagsF )/*1*/
TELL( "preparing for work" ) ;
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
{
    flagsT& flags    = *(flagsT*)pTaskP->c1 ;
    signC&  sgnReady =  *(signC*)pTaskP->c2 ;

    sgnReady.giveF( tinP ) ;
    TELL( "watching for flSTATE_FIRED" ) ;
    {
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        while( !ether && !( F(flags) & flSTATE_FIRED ) )
        {
            ++ s ; ether.osSleepF( tinP , TUCK * 0x40 ) ;
        }
    }
    TELL( "saw flSTATE_FIRED so am firing myself" ) ;
    ether.etherFireImpersonateMonitorIF( tinP ) ;
}
TELL( "tmWatchFlagsF: cleaning up" ) ;
DONE( tmWatchFlagsF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000024.tmwatchflagsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000025._tmcatchf BEGIN
#define DDNAME       "3func.33000025._tmcatchf"
#define DDNUMB      (countT)0x33000025
#define IDFILE      (countT)0x912


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( _tmCatchF )/*1*/
TELL( "setting up" )
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
{
    boolT&  bQuit_tmCatch = *(boolT*) pTaskP->c1 ;
    boolT&  bDone_tmCatch = *(boolT*) pTaskP->c2 ;
    countT  idPort        =           pTaskP->c3 ;
    batonC& b_stCatch     = *(batonC*)pTaskP->c4 ;
    stackC& stCatch       = *(stackC*)pTaskP->c5 ;
    signC&  sgnCatch      = *(signC*) pTaskP->c6 ;
    thirdC& thConstructor = *(thirdC*)pTaskP->c7 ;

    thirdC& thThread = etThread ;

    //thThread.dosPriorityIF( tinP , ifcTHREADpRIORITY_RUSH ) ; // NEEDED DUE TO OS BUG (WINDOWS)
    //__( thThread , thThread.dosPriorityIF( tinP ) - ifcTHREADpRIORITY_RUSH ) ;

    handleC hsoc( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_SOCKET ) ;
    thThread.s_socketIF( tinP , hsoc , ifcSOCKETtYPE_DATAgRAM ) ;
    thThread.s_bindF( tinP , hsoc , idPort ) ; // IF MOD THIS LINE TO BIND TO A SPECIFIC ADAPTER, THIS LINE WILL CONTINUE TO BLOCK IF THE nicNameC THAT IT IS BOUND TO GOES AWAY

    while( !bQuit_tmCatch && !thThread )
    {
        soulC* pSouli = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( pSouli ) ;
        if( pSouli )
        {
            ZE( countT , idpi ) ;
            nicNameC nicNamei ;
            TELL( "waiting for a soulC object to arrive in a datagram" )
            thThread.s_readF( tinP , *pSouli , hsoc ) ;

            //U:: MOVE THIS INTO THE API (20210210@1928: THE EXISTING API WAS REMOVED BECAUSE IT WAS CODED WRONG AND WAS REDUNDANT ; SUPPORT FOR THIS SHOULD BE A SIMPLE WRAPPER OVERLOAD OF s_readF THAT CONTAINS THE CODE HERE)
            {                           //20210210@1928: UNTESTED BLOCK ; WRITTEN WHEN REMOVED API SUPPORT FOR s_readF TO soulC FROM DATAGRAM
                ZE( byteT* , pbi ) ;
                ZE( countT , cbi ) ;
                thThread.s_readF( tinP , pbi , cbi , idpi , nicNamei , hsoc ) ; ___( pbi ) ;
                pSouli->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbi , cbi , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                thThread.delF( tinP , pbi ) ;
            }

            TELL( "handling a soulC object that just arrived in a datagram" )
            if( bQuit_tmCatch )
            {
                { DEL( pSouli ) ; }
                sgnCatch.giveF( tinP ) ;
            }
            else
            {
                ZE( countT , idTypeIdType ) ;
                ZE( boolT  , flagsIdType ) ;
                ZE( countT , cbIdType ) ;
                const byteT* pbIdType = pSouli->pbFieldF( tinP , idTypeIdType , flagsIdType , cbIdType , 1 ) ;

                ZE( countT , idTypeDisk ) ;
                ZE( boolT  , flagsDisk ) ;
                ZE( countT , cbIdDisk ) ;
                const byteT* pbIdDisk = pSouli->pbFieldF( tinP , idTypeDisk , flagsDisk , cbIdDisk , 2 ) ;

                if( cbIdType == sizeof( countT ) && flagsIdType & flSOULiTEM_MADEoFcOUNToBJECTS && *(countT*)pbIdType == ifcIDtYPEdATAGRAM_NETc_SOULc && cbIdDisk == sizeof( countT ) && flagsDisk & flSOULiTEM_MADEoFcOUNToBJECTS )
                {
                    TELL( "grabbing b_stCatch" )
                    b_stCatch.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    TELL( "putting the soulC object that just arrived onto stackC stCatch" )

                    ZE( countT , ids ) ;
                    stCatch.sinkF( tinP , ids , pSouli , flSTACKsINK_UNIQUE , netC_subtract_soulC_F ) ;
                    if( !ids ) { DEL( pSouli ) ; }
                    else       sgnCatch.giveF( tinP ) ;

                    b_stCatch.ungrabF( tinP ) ;
                }
                else { DEL( pSouli ) ; }
            }
        }
    }
    TELL( "_tmCatchF: cleaning up" )
    bDone_tmCatch = 1 ;
}
DONE( _tmCatchF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000025._tmcatchf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000026.tmriverservef BEGIN
#define DDNAME       "3func.33000026.tmriverservef"
#define DDNUMB      (countT)0x33000026
#define IDFILE      (countT)0x913


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmRiverServeF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
{
    TELL( "setting up" )
    boolT&   bDestroy = *(boolT*) pTaskP->c1 ;
    socketC* pso      = (socketC*)pTaskP->c2 ;
    riverC&  river    = *(riverC*)pTaskP->c3 ;
    countT&  cClients = *(countT*)pTaskP->c4 ;
    pso->etherF( tinP , etThread ) ;
    cClients ++ ;

    TN( tDry , "!amDry" ) ;
    ZE( boolT , bClose ) ;
    while( !etThread && !bClose && !bDestroy )
    {
        ZE( byteT* , pbMsg ) ;
        TELL( "waiting for a message to arrive on a socket" )
        countT cbMsg = pso->readMsgF( tinP , pbMsg ) ;
        TELL( "acknowledging receipt of a message" )
        pso->readMsgOkF( tinP ) ;
        bClose = !etThread && cbMsg == tDry.csF( tinP ) && !etThread.strCompareF( tinP , T(pbMsg) , tDry ) ;
        TELL( "writing the message just received to the river" )
        if( !bClose ) river.writeMsgF( tinP , pbMsg , cbMsg ) ;
        etThread.delF( tinP , pbMsg ) ;
    }
    etThread = 0 ;
    TELL( "tmRiverServeF: cleaning up" )

    DEL( pso ) ;
    cClients -- ;
}
DONE( tmRiverServeF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000026.tmriverservef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000027.tmriveracceptf BEGIN
#define DDNAME       "3func.33000027.tmriveracceptf"
#define DDNUMB      (countT)0x33000027
#define IDFILE      (countT)0x914


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmRiverAcceptF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
{
    TELL( "setting up" )
    boolT&  bDestroy = *(boolT*)pTaskP->c1 ;
    countT  idPort   =          pTaskP->c2 ;
    riverC* pRiver   = (riverC*)pTaskP->c3 ;
    signC&  sgnReady = *(signC*)pTaskP->c4 ;
    ZE( countT , cClients ) ;

    ZE( boolT , bSgnGiven ) ;
    while( !ether && !bDestroy )
    {
        TELL( "setting up a new or replacement socket" )
        socketC in( tinP , etThread , TAG( TAGiDnULL ) ) ;
        in.bindF( tinP , idPort ) ;
        in.listenF( tinP ) ;
        while( !POOP && !bDestroy )
        {
            ZE( socketC* , pso ) ;
            if( !bSgnGiven )
            {
                bSgnGiven = 1 ;
                sgnReady.giveF( tinP ) ;
            }
            TELL( "waiting for a host to connect" )
            nicNameC nnPeer ;
            ZE( countT , idPortPeer ) ;
            ZE( boolT , bRefuse ) ;
            in.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ;
            __( bRefuse ) ;
            TELL( "launching a thread to serve connection" )
            if( !bDestroy && !ether && !etThread ) { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmRiverServeF , 0 , flTHREADlAUNCH_null , 0 , (countT)&bDestroy , (countT)pso , (countT)pRiver , (countT)&cClients ) ; }
            else                                   { DEL( pso ) ; }
        }
    }
    TELL( "cleaning up: waiting for all sessions to end" )

    while( !ether && !etThread && cClients )
    {
        ether.beeSingDigitsF( tinP , 0x7 ) ;
        {
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            ++ s ; etThread.osSleepF( tinP , TOCK ) ;
        }
    }
    TELL( "tmRiverAcceptF: cleaning up" )
}
DONE( tmRiverAcceptF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000027.tmriveracceptf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000028.tmquitsubscribef BEGIN
#define DDNAME       "3func.33000028.tmquitsubscribef"
#define DDNUMB      (countT)0x33000028
#define IDFILE      (countT)0x915


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmQuitSubscribeF )/*1*/
TELL( "setting up" )

__Z( pTaskP ) ;
__( pTaskP && !pTaskP->c1 ) ;
__( pTaskP && !pTaskP->c2 ) ;

if( !etThread )
{
    signC&  sgnQuit_tmSubscribe = *(signC*) pTaskP->c1 ;
    boolT&  bQuitSubscribe      = *(boolT*) pTaskP->c2 ;
    countT& idPortSubscribe     = *(countT*)pTaskP->c3 ;

    TELL( "waiting for sgnQuit_tmSubscribe to be given" )
    sgnQuit_tmSubscribe.waitF( tinP ) ;
    TELL( "cleaning up: connecting to idPortSubscribe" )

    bQuitSubscribe = 1 ;
    {
        socketC sockz( tinP , etThread , TAG( TAGiDnULL ) ) ;
        sockz.connectF( tinP , idPortSubscribe ) ;
    }
    TELL( "tmQuitSubscribeF: cleaning up" )
    etThread = 0 ;
}

DONE( tmQuitSubscribeF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000028.tmquitsubscribef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000029.tmsubscribef BEGIN
#define DDNAME       "3func.33000029.tmsubscribef"
#define DDNUMB      (countT)0x33000029
#define IDFILE      (countT)0x916


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmSubscribeF )/*1*/
TELL( "setting up" )

__Z( pTaskP ) ;
__( pTaskP && !pTaskP->c1 ) ;
__( pTaskP && !pTaskP->c2 ) ;

if( !etThread )
{
    busC&   bus                 = *(busC*)  pTaskP->c1 ;
    signC&  sgnQuit_tmSubscribe = *(signC*) pTaskP->c2 ;
    countT& idPortSubscribe     = *(countT*)pTaskP->c3 ;
    signC&  sgnReady            = *(signC*) pTaskP->c4 ;
    signC&  sgn_cSubscribers    = *(signC*) pTaskP->c5 ;
    signC&  sgn_pbv             = *(signC*) pTaskP->c6 ;

    ZE( boolT , bQuitSubscribe ) ;
    signC sgnDone_tmQuitSubscribe( tinP , TAG( TAGiDnULL ) ) ;
    { ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmQuitSubscribeF , &sgnDone_tmQuitSubscribe , flTHREADlAUNCH_null , 0 , (countT)&sgnQuit_tmSubscribe , (countT)&bQuitSubscribe , (countT)&idPortSubscribe ) ; }

    socketC sockSub( tinP , etThread , TAG( TAGiDnULL ) ) ;
    idPortSubscribe = sockSub.bindF( tinP ) ;
    sockSub.listenF( tinP ) ;
    sgnReady.giveF( tinP ) ;

    while( !ether && !etThread && !bQuitSubscribe )
    {
        ZE( socketC* , pso ) ;
        TELL( "waiting for a client to connect" )
        nicNameC nnPeer ;
        ZE( countT , idPortPeer ) ;
        ZE( boolT , bRefuse ) ;
        sockSub.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ; ___( pso ) ;
        __( bRefuse ) ;
        if( bQuitSubscribe ) { DEL( pso ) ; }
        else if( pso )
        {
            ZE( countT , idCmd ) ;
            TELL( "reading idCmd" )
            pso->readF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;

            switch( idCmd )
            {
                case idCMDbUS_HELLO :
                {
                    ZE( countT , cSub ) ;
                    TELL( "idCMDbUS_HELLO: reading cSub" )
                    pso->readF( tinP , (byteT*)&cSub , sizeof cSub ) ;
                    bus.cSubscribers = cSub ;
                    sgn_cSubscribers.giveF( tinP ) ;

                    break ;
                }
                case idCMDbUS_GOODbYE :
                {
                    ZE( countT , cSub ) ;
                    TELL( "idCMDbUS_GOODbYE: reading cSub" )
                    pso->readF( tinP , (byteT*)&cSub , sizeof cSub ) ;
                    bus.cSubscribers = cSub ;
                    sgn_cSubscribers.giveF( tinP ) ;

                    break ;
                }
                case idCMDbUS_WRITE :
                case idCMDbUS_READ :
                {
                    ether.delF( tinP , bus.pbv ) ;

                    ZE( countT , cbv ) ;
                    TELL( "idCMDbUS_WRITE idCMDbUS_READ: reading cbv" )
                    pso->readF( tinP , (byteT*)&cbv , sizeof cbv ) ;
                    bus.cbv = cbv ;

                    ZE( byteT* , pbv ) ;
                    ether.newF( tinP , LF , pbv , cbv + 1 ) ; ___( pbv ) ;
                    if( pbv )
                    {
                        pbv[ cbv ] = 0 ;
                        TELL( "idCMDbUS_WRITE idCMDbUS_READ: reading bytes" )
                        if( cbv ) pso->readF( tinP , pbv , cbv ) ;
                        bus.pbv = pbv ;
                    }
                    sgn_pbv.giveF( tinP ) ;

                    break ;
                }
            }

            TELL( "closing connection" )
            DEL( pso ) ;
        }
    }

    TELL( "cleaning up: waiting for sgnDone_tmQuitSubscribe to be given" )
    sgnDone_tmQuitSubscribe.waitF( tinP ) ;
    TELL( "tmSubscribeF: cleaning up" )
}

DONE( tmSubscribeF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000029.tmsubscribef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300002a.tmwheref BEGIN
#define DDNAME       "3func.3300002a.tmwheref"
#define DDNUMB      (countT)0x3300002a
#define IDFILE      (countT)0x917


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

countT subtractTallyF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )
{
    IFbEcAREFUL
    {
        if( !c1P || !c2P ) return 0 ;
    }

    countT tally1 = *(countT*)c1P ;
    countT tally2 = *(countT*)c2P ;

    if( tinP.fingerprint && pEther && c3P ) ;
    return tally1 - tally2 ;
}

/*1*/TASK( tmWhereF )/*1*/
etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
{
    boolT&  bQuitWhereI        =  *(boolT*)pTaskP->c1 ;
    signC&  sgnReady           =  *(signC*)pTaskP->c2 ;
    countT& cEnabledWhereI     = *(countT*)pTaskP->c3 ;
    countT& idTypeReportWhereI = *(countT*)pTaskP->c4 ;
    tinS**  ppTinWhereI        =   (tinS**)pTaskP->c5 ;
    countT& cThreadsMaxWhereI  = *(countT*)pTaskP->c6 ;
    grabC&  grabWhere          =  *(grabC*)pTaskP->c7 ;

    //count8S c8idiFileFocus( 0x6000f71 , 0x5000a01 , 0x6000021 , 0x5000511 ) ;
    //count8S c8idiFileFocus( 0x4000611 ) ;
    count8S c8idiFileFocus ;
    countT  cFoci = etThread.strBodyLengthF( tinP , (countT*)c8idiFileFocus ) ;
    ZE( countT , idWhat1 ) ;
    switchC swTallyWhat1( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , idWhat1 ) ;
    ZE( countT , idWhat2 ) ;
    switchC swTallyWhat2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , idWhat2 ) ;
    count2S c2Lever ;
    const byteT* pbLever = (const byteT*)&c2Lever ;
    switchC swTally( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pbLever , sizeof c2Lever ) ;
    sgnReady.giveF( tinP ) ;
    //TN( tSay2 , "where is looking 2 grabbing" ) ; //U:: COMMENT OUT IN PRODUCTION
    //TN( tSay1 , "where is looking 1 got" ) ; //U:: COMMENT OUT IN PRODUCTION
    //TN( tSay0 , "where is looking 0 napping " ) ; //U:: COMMENT OUT IN PRODUCTION
    while( !etThread && !bQuitWhereI && !ether ) //COMMENT OUT !ether IF WANT TO LOOK AT QUIT BEHAVIOR
    {
        if( cEnabledWhereI )
        {
            //etThread.traceF( tinP , tSay2 ) ; //U:: COMMENT OUT IN PRODUCTION
            grabWhere.grabF( tinP , TAG( TAGiDnULL ) ) ;
            //etThread.traceF( tinP , tSay1 ) ; //U:: COMMENT OUT IN PRODUCTION
            for( countT off = 0 ; off < cThreadsMaxWhereI ; off ++ )
            {
                if( ppTinWhereI[ off ] ) //U:: USE A grabC TO SERIALIZE SO DON'T GET BIT BY A DANGLING POINTER TO A DOOMED tinS, OBJECT
                {
                    byteT pbWhere[ sizeof( whereS ) ] ;                    
                    whereS& where = *(whereS*)pbWhere ;
                    {
                        countT idDirtyVerify ; //INTENTIONALLY NOT INITIALIZED, FOR SPEED
                        do
                        {
                            thirdC::c_memcpyIF( tinP , pbWhere , (byteT*)&ppTinWhereI[ off ]->monitor , sizeof pbWhere ) ;
                            idDirtyVerify = ppTinWhereI[ off ]->monitor.idDirty ;
                        }
                        while( where.idDirty % 2 || where.idDirty != idDirtyVerify ) ;
                    }

                    idWhat1 = where.idWhat1 ;
                    ++ ( (countT&)swTallyWhat1 ) ;

                    idWhat2 = where.idWhat2 ;
                    ++ ( (countT&)swTallyWhat2 ) ;

                    //if( idWhat1 <= 0x100 ) //CAN USE TO INVESTIGATE FIND LOCATION WITHIN A CODE SNIPPET
                    //if( idWhat1 <= ifcIDwHAT_GOaDAM )
                    {
                        //++ ( (countT&)swTallyWhat1 ) ;

                        if( !cFoci )
                        {
                            c2Lever.c1 = where.pLFnest[ ( ( where.cInNest & OFFsLOTtINnESTmAX ) << 1 )     ] ;
                            c2Lever.c2 = where.pLFnest[ ( ( where.cInNest & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;

                            if( c2Lever.c2 == 0x33065 )
                            {
                                countT foo = 2 ;
                            }

                            ++ ( (countT&)swTally ) ;
                        }
                        else
                        {
                            boolT bDo = 1 ;
                            if( cFoci >= where.cInNest ) bDo = 0 ;
                            else
                            {
                                countT* pczFocus = c8idiFileFocus ;
                                for( countT offFocus = 0 ; bDo && offFocus < cFoci ; offFocus ++ )
                                    if( pczFocus[ offFocus ] != where.pLFnest[ ( ( ( where.cInNest - offFocus ) & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ) bDo = 0 ;
                            }

                            if( bDo )
                            {
                                c2Lever.c1 = where.pLFnest[ ( ( ( where.cInNest - cFoci ) & OFFsLOTtINnESTmAX ) << 1 )     ] ;
                                c2Lever.c2 = where.pLFnest[ ( ( ( where.cInNest - cFoci ) & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
    
                                ++ ( (countT&)swTally ) ;
                            }
                        }
                    }
                }
            }
            //etThread.traceF( tinP , tSay0 ) ; //U:: COMMENT OUT IN PRODUCTION
            grabWhere.ungrabF( tinP ) ;
        }

        thirdC::dosSleepWinkIF( tinP ) ;
    }

    stackC stSorter( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( count3S ) ) ;

    OStEXT( ostoRpt , TOCK << 4 )        // 20180123@1526: TOCK -> TOCK << 4
    countT cToDo = 2 ;
    while( cToDo -- )
    {
        countT&  idWhat12 = cToDo ? idWhat1 : idWhat2 ;
        switchC& swTallyWhat12 = cToDo ? swTallyWhat1 : swTallyWhat2 ;

        ZE( countT , totalTallyWhat ) ;
        countT cFlavors = swTallyWhat12.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            idWhat12 = swTallyWhat12.leverF( tinP , idf ) ;
            count3S c3s( - swTallyWhat12 , idWhat12 ) ;
            totalTallyWhat -= c3s.c1 ;
            stSorter.sinkF( tinP , countTC() , (byteT*)&c3s , flSTACKsINK_null , subtractTallyF ) ;
        }
    
        {
            OStEXTA( ostoRpt , cToDo ? "THREAD WHEREABOUTS REPORT\r\n|\r\n| WHAT 1 (PREDEFINED CATEGORIES)\r\n|\r\n| tally: " : "THREAD WHEREABOUTS REPORT\r\n|\r\n| WHAT 2 (AD HOC CATEGORIES)\r\n|\r\n| tally: " ) ;
            OStEXTC( ostoRpt , totalTallyWhat , 0 ) ;
            OStEXTAK( ostoRpt , "\r\n|\r\n| [ % , tally , postWhat ]\r\n|\r\n" ) ;
            while( stSorter )
            {
                count3S c3s ;
                byteT* pb_c3s = (byteT*)&c3s ;
                stSorter >> pb_c3s ;
        
                OStEXTAK( ostoRpt , "| " ) ;
                countT tally = - c3s.c1 ;
                countT perTuck = totalTallyWhat ? ( tally * 0x100 ) / totalTallyWhat : 0 ;
                OStEXTC( ostoRpt , perTuck , ' ' ) ;
        
                OStEXTAK( ostoRpt , " " ) ;
                OStEXTC( ostoRpt , tally , ' ' ) ;
                OStEXTAK( ostoRpt , " " ) ;
                const osTextT* postn = processGlobal3I.mapWhat( c3s.c2 ) ;

                if( !postn && cToDo ) postn = processGlobal3I.mapGroup( c3s.c2 ) ;

                if( postn ) { OStEXTA( ostoRpt , postn ) ; }
                else        { OStEXTC( ostoRpt , c3s.c2 , ' ' ) ; }
                OStEXTAK( ostoRpt , "\r\n" ) ;
            }
            OStEXTAK( ostoRpt , "|\r\n" ) ;
        }
    }

    ZE( countT , totalTally ) ;
    countT cFlavors = swTally.cFlavorsF( tinP ) ;
    {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            etThread.memCopyF( tinP , (byteT*)&c2Lever , (byteT*)swTally.leverF( tinP , idf ) , sizeof c2Lever ) ;
            count3S c3s( - swTally , c2Lever.c1 , c2Lever.c2 ) ;
            totalTally -= c3s.c1 ;
            stSorter.sinkF( tinP , countTC() , (byteT*)&c3s , flSTACKsINK_null , subtractTallyF ) ;
        }
    }

    {
        if( cFoci )
        {
            TN( tList , "" ) ; tList = T((countT*)c8idiFileFocus) ;
            OStEXTAK( ostoRpt , "FOCUS: CALLER OF " ) ;
            OStEXTA( ostoRpt , tList ) ;
            OStEXTAK( ostoRpt , "\r\n" ) ;
        }
        OStEXTAK( ostoRpt , "| WHERE\r\n|\r\n| tally: " ) ;
        OStEXTC( ostoRpt , totalTally , 0 ) ;
        OStEXTAK( ostoRpt , "\r\n|\r\n| [ % , tally , idLine , (idLine_9) , idiFile , fileTitle ]\r\n|\r\n" ) ;
        while( stSorter )
        {
            count3S c3s ;
            byteT* pb_c3s = (byteT*)&c3s ;
            stSorter >> pb_c3s ;
    
            OStEXTAK( ostoRpt , "| " ) ;
            countT tally = - c3s.c1 ;
            countT perTuck = totalTally ? ( tally * 0x100 ) / totalTally : 0 ;
            OStEXTC( ostoRpt , perTuck , ' ' ) ;
    
            OStEXTAK( ostoRpt , " " ) ;
            OStEXTC( ostoRpt , tally , ' ' ) ;
            OStEXTAK( ostoRpt , " " ) ;
            OStEXTC( ostoRpt , c3s.c2 , ' ' ) ;
            OStEXTAK( ostoRpt , " (" ) ;
            OStEXTC9( ostoRpt , c3s.c2 ) ;
            OStEXTAK( ostoRpt , "_9) " ) ;
            OStEXTC( ostoRpt , c3s.c3 , ' ' ) ;
            const osTextT* postn = processGlobal7I.source.postFileTitleF( tinP , processGlobal7I.source.idFileRankF( tinP , c3s.c3 ) ) ;
            if( postn )
            {
                OStEXTAK( ostoRpt , " " ) ;
                OStEXTA( ostoRpt , postn ) ;
            }
            OStEXTAK( ostoRpt , "\r\n" ) ;
        }
        OStEXTAK( ostoRpt , "|\r\n" ) ;
    }

    ZE( countT , cExits ) ;
    for( countT off = 1 ; off < sizeof tinP.pAdamGlobal1->pcExitsWhere / sizeof tinP.pAdamGlobal1->pcExitsWhere[ 0 ] ; off ++ )
    {
        if( tinP.pAdamGlobal1->pcExitsWhere[ off ] )
        {
            count3S c3s( - tinP.pAdamGlobal1->pcExitsWhere[ off ] , 0 , off ) ;
            cExits -= c3s.c1 ;
            stSorter.sinkF( tinP , countTC() , (byteT*)&c3s , flSTACKsINK_null , subtractTallyF ) ;
        }
    }

    {
        OStEXTAK( ostoRpt , "| EXITS\r\n|\r\n| tally: " ) ;
        OStEXTC( ostoRpt , cExits , 0 ) ;
        OStEXTAK( ostoRpt , "\r\n| [ % , exits , idiFile , fileTitle ]\r\n|\r\n" ) ;
        while( stSorter )
        {
            count3S c3s ;
            byteT* pb_c3s = (byteT*)&c3s ;
            stSorter >> pb_c3s ;
    
            OStEXTAK( ostoRpt , "| " ) ;
            countT cExitsMe = - c3s.c1 ;
            countT perTuck = cExits ? ( cExitsMe * 0x100 ) / cExits : 0 ;
            OStEXTC( ostoRpt , perTuck , ' ' ) ;
    
            OStEXTAK( ostoRpt , " " ) ;
            OStEXTC( ostoRpt , cExitsMe , ' ' ) ;
            OStEXTAK( ostoRpt , " " ) ;
            OStEXTC( ostoRpt , processGlobal7I.source.idFileImmutableF( tinP , c3s.c3 ) , ' ' ) ;
            const osTextT* postn = processGlobal7I.source.postFileTitleF( tinP , c3s.c3 ) ;
            if( postn )
            {
                OStEXTAK( ostoRpt , " " ) ;
                OStEXTA( ostoRpt , postn ) ;
            }
            OStEXTAK( ostoRpt , "\r\n" ) ;
        }
        OStEXTAK( ostoRpt , "|\r\n" ) ;
    }
    
    LOGrAWaDAM( ostoRpt ) ;
}
DONE( tmWhereF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300002a.tmwheref END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300002b.tmtimeoutf BEGIN
#define DDNAME       "3func.3300002b.tmtimeoutf"
#define DDNUMB      (countT)0x3300002b
#define IDFILE      (countT)0x918


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmTimeoutF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c6 )
{
    TELL( "setting up" )
    socketC&  sockd      = *(socketC*)pTaskP->c1 ;
    boolT&    bGoItIt     =   *(boolT*)pTaskP->c2 ;
    boolT&    bTimeout   =   *(boolT*)pTaskP->c3 ;
    countT    timeO1     =            pTaskP->c4 ;
    sCountT   timeO2     =            pTaskP->c5 ;
    countT    idPortMe   =            pTaskP->c6 ;

    ZE( countT , timeE1 ) ;
    ZE( sCountT , timeE2 ) ;
    etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
    etThread.osTimeAddF( tinP , timeE1 , timeE2 , timeO1 , timeO2 ) ;

    while( !ether && !etThread )
    {
        TELL( "setting up in loop" )
        ZE( countT , timeN1 ) ;
        ZE( sCountT , timeN2 ) ;
        etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
        etThread.osTimeSubtractF( tinP , timeN1 , timeN2 , timeE1 , timeE2 ) ;
        if( bGoItIt || timeN2 >= 0 ) break ;

        TELL( "sleeping for 04 tock" )
        {
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            ++ s ; ether.osSleepF( tinP , TUCK * 0x40 ) ;
        }
    }

    if( !bGoItIt )
    {
        TELL( "bGoItIt is 0 so writing \"let's all quit\" datagram" )
        bTimeout = 1 ;
        sockd.writeF( tinP , idPortMe , nicNameC() , ifcIDtYPEdATAGRAM_LETSaLLqUIT ) ;
    }
    TELL( "tmTimeoutF: cleaning up" )
}
DONE( tmTimeoutF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300002b.tmtimeoutf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300002c.tmaskdnsf BEGIN
#define DDNAME       "3func.3300002c.tmaskdnsf"
#define DDNUMB      (countT)0x3300002c
#define IDFILE      (countT)0x919


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmAskDnsF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
{
    TELL( "setting up" )
    socketC&  sockd      = *(socketC*)pTaskP->c1 ;
    boolT&    bGoItIt     =   *(boolT*)pTaskP->c2 ;
    boolT&    bTimeout   =   *(boolT*)pTaskP->c3 ;
    byteT*    pbQuery    =    (byteT*)pTaskP->c4 ;
    countT    cbQuery    =            pTaskP->c5 ;

    while( !ether && !etThread && !bGoItIt && !bTimeout )
    {
        TELL( "writing query datagram to the IdeaFarm " "(tm) City name server" )
        sockd.writeF( tinP , 0x35 , socketC::nicNameIF( tinP , ether , T(postIFCnAMEsERVER) ) , pbQuery , cbQuery ) ;
        TELL( "sleeping for 2 tock" )
        {
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            ++ s ; ether.osSleepF( tinP , TOCK * 2 ) ;
        }
    }
    TELL( "tmAskDnsF: cleaning up" )
}
DONE( tmAskDnsF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300002c.tmaskdnsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300002d.threadlocalstoragenotlsf BEGIN
#define DDNAME       "3func.3300002d.threadlocalstoragenotlsf"
#define DDNUMB      (countT)0x3300002d
#define IDFILE      (countT)0x91a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i allocate oo objects on the thread's stack so that they can be found at known offsets within the stack frame
my stack frame can be found by walking the stack looking for FINGERnEG_THREADlOCALsTORAGE
then the value in pTin can be obtained
pTin, if not ze, points to the tinS, object for this thread
*/
/**/

// NOTE: I MUST BE COMPILED WITH OPTIMIZATIONS DISABLED (-od)

/*1*/countT __export threadLocalStorageNoTlsF( const countT idTypeP , kidFT pThreadWorkF , countT cArgP , countT cHowP , const osTextT** ppostHowP , countT hWindowingClientIP , countT hPreviousWindowingClientP , osTextT* postP , countT idCmdShowP )/*1*/
{
    ZE( countT , rc ) ;
    inc02AM( processGlobal1I.cTls ) ;
    {
        tlsStackFrameNoTlsS sf( idTypeP , postP , cArgP ) ; //CODE SYNC: THE OFFSET OF SOME MEMBERS OF sf FROM [ebp] (THE STACK FRAME) IS HARDCODED IN snip.009*
        //I HAVE SEEN WDW FAIL TO LOAD SYMBOLIC INFO BECAUSE THE OFFSET OF sf FROM [ebp] CHANGED, AND APPARENTLY pTinAM CRAPPED EARLY ON SOME DEBUGGING INFO SO WDW COULDN'T EVEN GET THE MODULE LOADED
        //IF WDW EVER FAILS TO LOAD ITS INFO, DEBUG STARTUP (IF YOU CAN); ELSE USE OTHER MEANS (WRITE TO CONSOLE) TO SEE THE NEW OFFSETS

        if( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WINDOW || idTypeP == ifcIDtYPEtLS_BENCH )
        {
            processGlobal1I.flCt |= flCTdTg_THREADlOCALsTORAGE ;

            offFingerVerifyI = ebpAM() - (countT)&sf.fingerVerify ; //MUST BE DONE BEFORE pTinAM OR pTin2AM ARE CALLED ; THIS IS THE OFFSET OF FINGERvERIFY *BELOW* EBP, CALCULATED HERE SO THAT ITS VALUE IS POSITIVE, TO MAKE DEBUGGER DISPLAYS EASIER TO READ

            // WHEN sf.tinEarlyLate WAS CT, pTinMainI WAS UPDATED ; NOW THAT offFingerVerifyI IS SET, bTlsEarlyLateI CAN BE RESET, AND pTinMainI LOADED INTO sf.pTin
            // ALL OF THIS IS UNWOUND BY THE NORMAL UNWINDING CODE THAT IS EXECUTED DURING ~tinS, AND THAT CODE ALSO SETS bTlsEarlyLateI
            // THE JOB DONE BY THE FOLLOWING LINES CANNOT EASILY BE DONE AT tinS CT TIME BECAUSE offFingerVerifyI CANNOT BE SET THERE; IT MUST BE SET IN THIS STACK FRAME

                                    if( &pTinF() != &pTinMainI_IF() ) { BLAMMO ; }
            bTlsEarlyLateIF() = 0 ; if( &pTinF() != &sf.pTin        ) { BLAMMO ; }
            sf.pTin = pTinMainI_IF() ;
            if( pTinF() != &sf.tinEarlyLate ) { BLAMMO ; }
        }
    
        {
            TINSL
            _IO_
                 if( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WINDOW                                 ) sf.rc = mainThreadWorkF( idTypeP , cHowP , ppostHowP , hWindowingClientIP , hPreviousWindowingClientP , postP , idCmdShowP ) ;
            else if( idTypeP == ifcIDtYPEtLS_KID || idTypeP == ifcIDtYPEtLS_EXCEPTION || idTypeP == ifcIDtYPEtLS_BENCH ) sf.rc = (*pThreadWorkF)( cArgP ) ;
            else                                                                                                         sf.rc = 1 ;
        }
    
        if( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WINDOW || idTypeP == ifcIDtYPEtLS_BENCH )
        {
            {
                TINSL
                _IO_
                {
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    while( processGlobal1I.cTls > 1 )
                    {
                        ++ s ; thirdC::dosSleepWinkIF( tinP ) ;
                    }
                }
            }

            processGlobal1I.flDt |= flCTdTg_THREADlOCALsTORAGE ;
        }

        rc = sf.rc ;
    }
    dec02AM( processGlobal1I.cTls ) ;

    return rc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300002d.threadlocalstoragenotlsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300002e.tmstackcoursesf BEGIN
#define DDNAME       "3func.3300002e.tmstackcoursesf"
#define DDNUMB      (countT)0x3300002e
#define IDFILE      (countT)0x91b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmStackCoursesF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
{
    TELL( "setting up" )
    etherC&  etDad         =  *(etherC*)pTaskP->c1 ;
    stackC&  stCoursesP    =  *(stackC*)pTaskP->c2 ;
    socketC& soUp          = *(socketC*)pTaskP->c3 ;
    signC&   sgnReadTested =   *(signC*)pTaskP->c4 ;
    stackC&  stOrdersP     =  *(stackC*)pTaskP->c5 ;
    strokeS* psttOldComment   =  (strokeS*)pTaskP->c6 ;
    etherC&  etText        = etherC::etTextIF( tinP ) ; //U:
    TN( tBar , "| " ) ;
    //etherC::ifcSayIF( TP("",9)+T(psttOldComment)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/tmStackCoursesF/")+T(tinP.postTell) , flSAY_APPEND | flSAY_LOG ) ;

    boolT bWoth = 1 ;
    while( !etThread && !etDad && !stCoursesP.third )
    {
        soulC sTray( tinP , TAG( TAGiDnULL ) ) ;
        TELL( "reading a tray soulC from above" )
        //etherC::ifcSayIF( TP("",9)+T(psttOldComment)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/tmStackCoursesF/")+T(tinP.postTell) , flSAY_APPEND | flSAY_LOG ) ;
        soUp.readF( tinP , sTray ) ; // THIS LINE MAKES etDad IMPOTENT IF THE REMOTE 1140104 IS NOT ALIVE
        //etText.strokeF( tinP , T("tmStackCoursesF/soUp.readF/-\r\n") ) ;
        if( bWoth )
        {
            bWoth = 0 ;
            TELL( "giving sgnReadTested" )
            //etherC::ifcSayIF( TP("",9)+T(psttOldComment)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/tmStackCoursesF/")+T(tinP.postTell) , flSAY_APPEND | flSAY_LOG ) ;
            sgnReadTested.giveF( tinP ) ;
            TELL( "returned from giving sgnReadTested" )
            //etherC::ifcSayIF( TP("",9)+T(psttOldComment)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/tmStackCoursesF/")+T(tinP.postTell) , flSAY_APPEND | flSAY_LOG ) ;
        }

        if( soUp.etherF( tinP ) )
        {
            TELL( "my upward socket is impotent: putting a final course onto stCoursesP" )
            //etherC::ifcSayIF( TP("",9)+T(psttOldComment)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/tmStackCoursesF/")+T(tinP.postTell) , flSAY_APPEND | flSAY_LOG ) ;
            stOrdersP << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;

            soulC sCodes( tinP , TAG( TAGiDnULL ) ) ;
            soulC sData( tinP , TAG( TAGiDnULL ) ) ;
            soulC sNotesText( tinP , TAG( TAGiDnULL ) ) ;
            soulC sNotesData( tinP , TAG( TAGiDnULL ) ) ;
    
            sCodes << (countT)1 ; // idVersion
            sCodes << (countT)ifcIDrEPLYjOBcOURSE_FINALcOURSE ;
            sCodes << (countT)ifcIDeRRORjOBcOURSE_JOBdONEwITHeRRORSsTATEaOK ; /*U: AM LYING HERE SINCE STATE MIGHT HAVE BEEN CORRUPTED*/
    
            soulC* psCourse = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psCourse ) ;
            if( psCourse )
            {
                *psCourse << sCodes ;
                *psCourse << sData ;
                *psCourse << sNotesText ;
                *psCourse << sNotesData ;
                stCoursesP << psCourse ;
            }    
        }

        if( !sTray ) break ; // WILL BREAK IF soUp.etherF() SINCE sTray WILL BE IMPOTENT
        else
        {
            TELL( "processing a tray soulC that i just received from above" )
            //etherC::ifcSayIF( TP("",9)+T(psttOldComment)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/tmStackCoursesF/")+T(tinP.postTell) , flSAY_APPEND | flSAY_LOG ) ;
            ZE( countT , idReply ) ;
            sTray >> idReply ;
            __( idReply - ifcIDcMDsESSION_JOBrEPLY ) ;
    
            soulC* psCourse = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psCourse ) ;
            if( psCourse )
            {
                soulC& sCourse = *psCourse ;
                sTray >> sCourse ;
    
                ZE( countT , idType ) ;
                ZE( flagsT , flags ) ;
                ZE( countT , cbsCodes ) ;
                const byteT* pbsCodes = sCourse.pbFieldF( tinP , idType , flags , cbsCodes ) ;
                __( idType - ifcIDtYPEsOULiTEM_soulC ) ;
                __Z( pbsCodes ) ;
    
                soulC sCodes( tinP , TAG( TAGiDnULL ) , pbsCodes , flSOUL_null , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
    
                ZE( countT , idVersion ) ;
                sCodes >> idVersion ;
                if( idVersion != 1 )
                {
                    __( idVersion ) ;
                    __1
                }
    
                ZE( countT , idReply ) ;
                sCodes >> idReply ;
                if( idReply != ifcIDrEPLYjOBcOURSE_NONfINALcOURSE && idReply != ifcIDrEPLYjOBcOURSE_FINALcOURSE )
                {
                    __( idReply ) ;
                    __1
                }
    
                ZE( countT , idError ) ;
                sCodes >> idError ;
                if( idError != ifcIDeRRORjOBcOURSE_JOBdONEaOK )
                {
                    __( idError ) ;
                    __1
                }
    
                stCoursesP << psCourse ; // MUST NOT BE PUSHED UNTIL I AM DONE INSPECTING, BECAUSE ANOTHER THREAD MIGHT PULL IT AND DELETE IT
            }
        }
    }
    if( bWoth ) sgnReadTested.giveF( tinP ) ;
    TELL( "tmStackCoursesF: cleaning up" )
    //etherC::ifcSayIF( TP("",9)+T(psttOldComment)+tBar+TF3(processGlobal1I.idAdamRoot,flFORMAT_UNSIGNED,9)+T("etherC::ifcJobF/inner/tmStackCoursesF/")+T(tinP.postTell) , flSAY_APPEND | flSAY_LOG ) ;
    etThread.delF( tinP , psttOldComment ) ;
}
DONE( tmStackCoursesF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300002e.tmstackcoursesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300002f.tmmaketraysf BEGIN
#define DDNAME       "3func.3300002f.tmmaketraysf"
#define DDNUMB      (countT)0x3300002f
#define IDFILE      (countT)0x91c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmMakeTraysF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
{
    TELL( "setting up" )
    socketC& soDn                  =       *(socketC*)pTaskP->c1 ;
    soulC&   sOrder                =         *(soulC*)pTaskP->c2 ;
    countT   idAdam                =                  pTaskP->c3 ;
    countT&  cArg                  =        *(countT*)pTaskP->c4 ;
    count8S& c8arg                 =       *(count8S*)pTaskP->c5 ;
    jobFillCourseFT jobFillCourseF = (jobFillCourseFT)pTaskP->c6 ;
    countT   idChatSession         =                  pTaskP->c7 ;

    ZE( countT , idCourse ) ;
    while( !etThread )
    {
        TELL( "calling handler so that it can inspect the order and fill data and notes soulC objects" )
        soulC sCodes( tinP , TAG( TAGiDnULL ) ) ;
        soulC sData( tinP , TAG( TAGiDnULL ) ) ;
        soulC sNotesText( tinP , TAG( TAGiDnULL ) ) ;
        soulC sNotesData( tinP , TAG( TAGiDnULL ) ) ;
        (*jobFillCourseF)( tinP , ether , etThread , sData , sNotesText , sNotesData , ++ idCourse , idAdam , idChatSession , sOrder , cArg , c8arg ) ;
        boolT bFail = etThread ;
        etThread = 0 ;

        TELL( "filling a course soulC with data, notes, codes, and then putting this course into a tray" )
        sCodes << (countT)1 ; // idVersion
        sCodes << (countT)( bFail || !sData ? ifcIDrEPLYjOBcOURSE_FINALcOURSE               : ifcIDrEPLYjOBcOURSE_NONfINALcOURSE ) ;
        sCodes << (countT)( bFail           ? ifcIDeRRORjOBcOURSE_JOBdONEwITHeRRORSsTATEaOK : ifcIDeRRORjOBcOURSE_JOBdONEaOK     ) ; /*U: AM LYING HERE SINCE STATE MIGHT HAVE BEEN CORRUPTED*/

        soulC sCourse( tinP , TAG( TAGiDnULL ) ) ;
        sCourse << sCodes ;
        sCourse << sData ;
        sCourse << sNotesText ;
        sCourse << sNotesData ;

        soulC sTray( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_JOBrEPLY ) ;
        sTray << sCourse ;
        TELL( "writing downward a tray containing a course containing data notes codes" )
        soDn.writeF( tinP , sTray ) ; // CAN SET IMPOTENCE IF CLIENT IS GONE

        if( bFail || !sData ) break ;
    }

    TELL( "writing downward a null tray" )
    soulC sNull( tinP , TAG( TAGiDnULL ) ) ;
    soDn.writeF( tinP , sNull ) ;
    TELL( "tmMakeTraysF: cleaning up" )
}
DONE( tmMakeTraysF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300002f.tmmaketraysf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000030.tmregisterportf BEGIN
#define DDNAME       "3func.33000030.tmregisterportf"
#define DDNUMB      (countT)0x33000030
#define IDFILE      (countT)0x91d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmRegisterPortF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
{
    TELL( "setting up" )
    signC&  sgnIdPortReplaced  =  *(signC*)pTaskP->c1 ;
    countT& idPort             = *(countT*)pTaskP->c2 ;
    signC&  sgnRegistered      =  *(signC*)pTaskP->c3 ;
    boolT   bSgnRegisteredVirgin = 1 ;

    IFsCRATCH
    {
        SCOOPS
        while( !ether && !etThread )
        {
            TELL( "waiting for sgnIdPortReplaced" )
            sgnIdPortReplaced.waitF( tinP ) ;
    
            if( idPort )
            {
                TELL( "in outer loop, setting up *tinP.pEtScratch ru" )
                boolT bFail = 1 ;
                ranUniC ru( tinP , TOCK * 8 ) ;
                while( !ether && !etThread && bFail )
                {
                    {
                        ZE( countT , idPort2 ) ;
                        {
                            socketC sChat( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                            TELL( "connecting to the local IdeaFarm " "(tm) chat server to get a port referral" )
                            sChat.connectF( tinP , ifcPORToLD2_CHAT ) ;
        
                            soulC soulo( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_NEWsOCKET ) ;
                            TELL( "writing a ifcIDcMDsESSION_NEWsOCKET soulC to the local IdeaFarm " "(tm) chat server" )
                            sChat.writeF( tinP , soulo ) ;
        
                            soulC souli( tinP , TAG( TAGiDnULL ) ) ;
                            TELL( "reading a soulC from the local IdeaFarm " "(tm) chat server" )
                            sChat.readF( tinP , souli ) ;
                            ZE( countT , idReply ) ;
                            souli >> idReply ;
                            __( idReply - ifcIDcMDsESSION_NEWsOCKETrEPLY ) ;
                            souli >> idPort2 ;
                        }
        
                        socketC sChat2( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                        TELL( "connecting to the port that the local IdeaFarm " "(tm) chat server referred me to" )
                        sChat2.connectF( tinP , idPort2 ) ;
    
                        soulC soulo2( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_REGISTERiDpORTlOCALcHAT ) ;
                        soulo2 << processGlobal1I.idAdamRoot ;
                        soulo2 << idPort ;
                        TELL( "writing a ifcIDcMDsESSION_REGISTERiDpORTlOCALcHAT soulC" )
                        sChat2.writeF( tinP , soulo2 ) ;
        
                        soulC souli2( tinP , TAG( TAGiDnULL ) ) ;
                        TELL( "reading a ifcIDcMDsESSION_REGISTERiDpORTlOCALcHATrEPLY soulC" )
                        sChat2.readF( tinP , souli2 ) ;
                        ZE( countT , idReply ) ;
                        souli2 >> idReply ;
                        __( idReply - ifcIDcMDsESSION_REGISTERiDpORTlOCALcHATrEPLY ) ;
        
                        soulC soulo3( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_BYE ) ;
                        TELL( "writing a ifcIDcMDsESSION_BYE soulC" )
                        sChat2.writeF( tinP , soulo3 ) ;
                    }
        
                    if( !POOP && !etThread ) bFail = 0 ;
                    else
                    {
                        POOPR
                        TELL( "sleeping for ru time" )
                        {
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                            ++ s ; ether.osSleepF( tinP , ru ) ;
                        }
                    }
                }
                TELL( "in outer loop: cleaning up" )
                if( bSgnRegisteredVirgin )
                {
                    sgnRegistered.giveF( tinP ) ;
                    bSgnRegisteredVirgin = 0 ;
                }
                if( !idPort ) break ;
            }
            TELL( "in outer loop: sleeping for 04 tock" )
    
            {
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                ++ s ; ether.osSleepF( tinP , TOCK * 40 ) ; // THIS IS USED RATHER THAN THE SIGN SO THAT CALLER REMAINS REGISTERED EVEN IF 1140104 DIES AND IS REPLACED
            }
        }
        if( bSgnRegisteredVirgin ) sgnRegistered.giveF( tinP ) ;
        TELL( "tmRegisterPortF: cleaning up" )
    }
    if( POOP ) POOPR
}
DONE( tmRegisterPortF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000030.tmregisterportf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000031.tmchatf BEGIN
#define DDNAME       "3func.33000031.tmchatf"
#define DDNUMB      (countT)0x33000031
#define IDFILE      (countT)0x91e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmChatF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c3 )
{
    TELL( "setting up" )
    signC&          sgnRegistered  =         *(signC*)pTaskP->c1 ;
    countT          cArgAdamDef    =                  pTaskP->c2 ;
    countT          idAdamHandling =                  pTaskP->c3 ;
    chatHandlerFT   chatHandlerF   =   (chatHandlerFT)pTaskP->c4 ;
    countT          idPortHint     =                  pTaskP->c5 ;
    jobFillCourseFT jobFillCourseF = (jobFillCourseFT)pTaskP->c6 ;
    jobHearOrderFT  jobHearOrderF  =  (jobHearOrderFT)pTaskP->c7 ;

    if( !chatHandlerF   ) chatHandlerF   = jobHandlerF        ;
    if( !jobFillCourseF ) jobFillCourseF = jobFillCourseDfltF ;
    if( !jobHearOrderF  ) jobHearOrderF  = jobHearOrderDfltF  ;

    ZE( countT , idPort ) ;
    signC sgnIdPortReplaced( tinP , TAG( TAGiDnULL ) ) ;
    signC sgnDone_tmRegisterPort( tinP , TAG( TAGiDnULL ) ) ;
    etThread.osThreadF( tinP , countTC() , tmRegisterPortF , &sgnDone_tmRegisterPort , flTHREADlAUNCH_null , 0 , (countT)&sgnIdPortReplaced , (countT)&idPort , (countT)&sgnRegistered ) ;

    // tmcChatF's cArg MUST ALWAYS CONTAIN THE ADDRESS OF A count3S CONTAINING chatHandlerF cArg idAdamHandling
    // IF A NONDEFAULT HANDLER IS SPECIFIED, THIS cArg WILL BE cArgAdamDef
    // IF THE  DEFAULT HANDLER IS SPECIFIED, THIS cArg WILL BE cArgJobber WHICH IS DEFINED IMMEDIATELY ABOVE

    ZE( countT , cSessions ) ;
    count3S cArgJobber( cArgAdamDef , (countT)jobFillCourseF , (countT)jobHearOrderF ) ;
    count4S c4p_tmcChat( (countT)chatHandlerF , ( chatHandlerF == jobHandlerF ? (countT)&cArgJobber : cArgAdamDef ) , idAdamHandling , (countT)&cSessions ) ;

    ZE( boolT , bHandedOffNU ) ;

    TELL( "serving a chat port" )
    ZE( countT , time1idleTimeoutRead ) ;
    ZE( countT , time1idleTimeoutWrite ) ;
    serverInfo1S i1( 0 , 0 , bHandedOffNU , sgnIdPortReplaced , tmcChatF , idPort , ether , time1idleTimeoutRead , time1idleTimeoutWrite ) ;
    serverInfo2S i2( idPortHint , flSOCKETc_null , T("[tmChatF]") , 0 , (countT)&c4p_tmcChat , 0 , - 1 , 0 ) ;
    etThread.ifcDrivenServerF( tinP , i1 , i2 ) ;
    TELL( "waiting for sgnDone_tmRegisterPort" )
    sgnDone_tmRegisterPort.waitF( tinP ) ;
    TELL( "cleaning up" )
}
DONE( tmChatF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000031.tmchatf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000032.tmloadsilentf BEGIN
#define DDNAME       "3func.33000032.tmloadsilentf"
#define DDNUMB      (countT)0x33000032
#define IDFILE      (countT)0x91f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

//DUPLICATED CODE: 1030168 2540104 U::MOVED
/*
*/
/**/
/*1*/TASK( tmLoadSilentF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
{
    countT& cArgThreadP = *(countT*)pTaskP->c1 ;
    boolT& bQuitP = *(boolT*)pTaskP->c2 ;

    count8S*   pc8tp = (count8S*)cArgThreadP ;
    batonC&    b_pnnSilentP =    *(batonC*)pc8tp->c1 ;
    nicNameC*& pnnSilentP   = *(nicNameC**)pc8tp->c2 ;
    countT&    cnnSilentP   =    *(countT*)pc8tp->c3 ;

    while( !etThread && !bQuitP )
    {
        GETsETTING( etThread , psttAll , T("nnSilent") ) //IN THE FORMER CODE, THERE WAS SERIALIZATION OF ACCESS TO THE SETTINGS FILE, BUT THAT SERIALIZATION CODE WAS COMMENTED OUT

        if( psttAll )
        {
            b_pnnSilentP.grabF( tinP , TAG( TAGiDnULL ) ) ;

            etThread.delF( tinP , pnnSilentP ) ;
            cnnSilentP = 0 ;

            ZE( strokeS* , pstt1Lines ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            cnnSilentP = etThread.strWordsOldF( tinP , pstt1Lines , psttAll , sttq , T("\r\n") ) ; ___( pstt1Lines ) ;
            etThread.newF( tinP , LF , pnnSilentP , cnnSilentP ) ; ___( pnnSilentP ) ;
            ZE( countT , off ) ;
            FORsTRINGSiN1( pstt1Lines )
            {
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttnn ) ;
                etThread.strWordF( tinP , psttnn , psttc1 , sttq , S1C(';') ) ; ___( psttnn ) ;
                pnnSilentP[ off ++ ] = etThread.strDigitsToNicNameF( tinP , psttnn ) ;
                //etThread.strokeF( tinP , T("i will silently ignore: ")+T(pnnSilentP[off-1])+T(" (\"")+T(psttnn)+T("\")\r\n") ) ;
                etThread.delF( tinP , psttnn ) ;
            }
            b_pnnSilentP.ungrabF( tinP ) ;
            etThread.delF( tinP , pstt1Lines ) ;
        }
        etThread.delF( tinP , psttAll ) ;

        {
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;

            countT cToDo = TUCK ;
            while( !bQuitP && cToDo -- )
            {
                ++ s ; etThread.osSleepF( tinP , TOCK >> 2 ) ;
            }
        }
    }

    b_pnnSilentP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    etThread.delF( tinP , pnnSilentP ) ;
    cnnSilentP = 0 ;
    b_pnnSilentP.ungrabF( tinP ) ;
    etThread.delF( tinP , pc8tp ) ;
}
DONE( tmLoadSilentF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000032.tmloadsilentf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000033.tmpaperopencatchf BEGIN
#define DDNAME       "3func.33000033.tmpaperopencatchf"
#define DDNUMB      (countT)0x33000033
#define IDFILE      (countT)0x920


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmPaperOpenCatchF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
{
    TELL( "setting up" )
    countT&  hFace     = *(countT*)pTaskP->c1 ;
    stackC&  st_psttIn = *(stackC*)pTaskP->c2 ;
    etherC&  ep        = *(etherC*)pTaskP->c3 ;

    count5S*& pc5s     = (count5S*&)hFace ;
    batonC*&  pbo      = (batonC*&) pc5s->c3 ;
    socketC*& pso      = (socketC*&)pc5s->c4 ;

    pso->etherF( tinP , ep ) ;

    strokeS psttPrefix[ CSpREFIX ] ;

    while( !ep )
    {
        TELL( "reading the prefix strokeS's" )
        pso->readF( tinP , (byteT*)psttPrefix , sizeof psttPrefix ) ;
        __( psttPrefix[ 0 ].idCaste - sc_PREFIXlENGTH ) ;

        if( ep ) ;
        else if( !psttPrefix->idAdam ) break ;
        else
        {
            ZE( strokeS* , psttri ) ;
            ep.newF( tinP , LF , psttri , psttPrefix->idAdam ) ; ___( psttri ) ;
            if( psttri )
            {
                TELL( "reading the remainder of a strokeS string" )
                pso->readF( tinP , (byteT*)psttri , sizeof( strokeS ) * psttPrefix->idAdam ) ;

                if( !ep )
                {
                    for( countT off = 0 ; off < psttPrefix->idAdam ; off ++ )
                    {
                        strokeS psttOne[ CSpREFIX + 1 ] ;
                        SETpREFIX( psttOne , 1 , 0 ) ;
                        psttOne[ CSpREFIX ] = psttri[ off ] ;
                        ZE( strokeS* , psttw ) ;
                        ep.strMakeF( tinP , LF , psttw , psttOne ) ; ___( psttw ) ;
                        st_psttIn << psttw ;
                    }
                }
            }
            ep.delF( tinP , psttri ) ;
        }
    }

    TELL( "grabbing pbo" )
    pbo->grabF( tinP , TAG( TAGiDnULL ) ) ;
    DEL( pso ) ;
    pbo->ungrabF( tinP ) ;

    // ASSUME: SIGN WILL BE GIVEN EVEN IF IMPOTENT
    TELL( "tmPaperOpenCatchF: cleaning up" )
}
DONE( tmPaperOpenCatchF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000033.tmpaperopencatchf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000034.tmserveportf BEGIN
#define DDNAME       "3func.33000034.tmserveportf"
#define DDNUMB      (countT)0x33000034
#define IDFILE      (countT)0x921


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmServePortF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
{
    TELL( "setting up" )
    socketC*      pso             =  (socketC*)pTaskP->c1 ;
    count7S&      c7p1            = *(count8S*)pTaskP->c2 ;

    batonC&       b_idProcessOldI     =  *(batonC*)c7p1.c1 ;
    countT&       idProcessOldI       =  *(countT*)c7p1.c2 ;
    switchC&      swc2            = *(switchC*)c7p1.c3 ;
    batonC&       b_idProcessOldLast =  *(batonC*)c7p1.c4 ;
    countT&       idProcessOldLast   =  *(countT*)c7p1.c5 ;
    batonC&       b_idMiscLast    =  *(batonC*)c7p1.c6 ;
    countT&       idMiscLast      =  *(countT*)c7p1.c7 ;

    pso->etherF( tinP , etThread ) ;

    ZE( countT , idCmd ) ;
    TELL( "reading idCmd" )
    __( sizeof idCmd - pso->readF( tinP , (byteT*)&idCmd , sizeof idCmd ) ) ;
    TELL( "processing idCmd" )

    if( !ether && !etThread )
    {
        switch( idCmd )
        {
            case ifcCMDpORTaUTHORITY_LAUNCHkIDpROCESS :
            {
                count4S c4i ;
                countT& idKidI         = c4i.c1 ;
                countT& idAdam        = c4i.c2 ;
                countT& csArgs        = c4i.c3 ;
                countT& idPortFaceDadI = c4i.c4 ;
                TELL( "ifcCMDpORTaUTHORITY_LAUNCHkIDpROCESS: reading idKidI idAdam csArgs idPortFaceDadI" )
                __( sizeof c4i - pso->readF( tinP , (byteT*)&c4i , sizeof c4i ) ) ;

                nicNameC nicNamePaperDadI ;
                TELL( "ifcCMDpORTaUTHORITY_LAUNCHkIDpROCESS: reading nicNamePaperDadI" )
                __( processGlobal1I.cb_nicNameC_ - pso->readF( tinP , (byteT*)&nicNamePaperDadI , processGlobal1I.cb_nicNameC_ ) ) ;

                ZE( strokeS* , psttArgs ) ;
                etThread.newF( tinP , LF , psttArgs , CSpREFIX + csArgs ) ; ___( psttArgs ) ;
                TELL( "ifcCMDpORTaUTHORITY_LAUNCHkIDpROCESS: reading psttArgs" )
                { countT cbi = sizeof( strokeS ) * ( CSpREFIX + csArgs ) ; __( cbi - pso->readF( tinP , (byteT*)psttArgs , cbi ) ) ; }

                TELL( "launching process" )
                etThread.osProcessF( tinP , countTC() , countTC() , idAdam , T(psttArgs)+T(" !idKidI ")+TF1(idKidI)+T(" !idPortFaceDadI ")+TF1(idPortFaceDadI)+T(" !nicNamePaperDadI ")+TF1(nicNamePaperDadI) ) ;

                etThread.delF( tinP , psttArgs ) ;
                break ;
            }
            case ifcCMDpORTaUTHORITY_NEWiDmISC :
            {
                b_idMiscLast.grabF( tinP , TAG( TAGiDnULL ) ) ;
                countT idMisc = ++ idMiscLast ;
                b_idMiscLast.ungrabF( tinP ) ;
                TELL( "ifcCMDpORTaUTHORITY_NEWiDmISC: writing idMisc" )
                pso->writeF( tinP , (byteT*)&idMisc , sizeof idMisc ) ;

                break ;
            }
            case ifcCMDpORTaUTHORITY_NEWpROCESS :
            {
                b_idProcessOldLast.grabF( tinP , TAG( TAGiDnULL ) ) ;
                countT idProcessOldI = ++ idProcessOldLast ;
                b_idProcessOldLast.ungrabF( tinP ) ;
                TELL( "ifcCMDpORTaUTHORITY_NEWpROCESS: writing idProcessOldI" )
                pso->writeF( tinP , (byteT*)&idProcessOldI , sizeof idProcessOldI ) ;

                break ;
            }
            case ifcCMDpORTaUTHORITY_NEW :
            {
                TELL( "ifcCMDpORTaUTHORITY_NEW" )
                count3S c3i ;
                countT& idProcessOldIn = c3i.c1 ;
                countT& idiClassIn  = c3i.c2 ;
                countT& idPortIn    = c3i.c3 ;

                __( sizeof c3i - pso->readF( tinP , (byteT*)&c3i , sizeof c3i ) ) ;
                __Z( idProcessOldIn ) ;
                __Z( idiClassIn ) ;
                __Z( idPortIn ) ;

                //WE DO NOT VERIFY THAT idPortIn IS OK HERE BECAUSE THE SERVER MIGHT NOT BE ACCEPTING CONNECTIONS UNTIL AFTER I RETURN

                if( !ether && !etThread )
                {
                    b_idProcessOldI.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    idProcessOldI = idProcessOldIn ;

                    __( (countT&)swc2 ) ;

                    if( !etThread )
                    {
                        ZE( count2S* , pc2cp ) ;
                        etThread.newF( tinP , LF , pc2cp ) ; ___( pc2cp ) ;
                        if( pc2cp )
                        {
                            pc2cp->c1 = idiClassIn ;
                            pc2cp->c2  = idPortIn ;
                            swc2 = (countT)pc2cp ;
                        }
                    }
                    b_idProcessOldI.ungrabF( tinP ) ;
                }

                break ;
            }
            case ifcCMDpORTaUTHORITY_DELETE :
            {
                TELL( "ifcCMDpORTaUTHORITY_DELETE" )
                ZE( countT , idProcessOldIn ) ;

                __( sizeof idProcessOldIn - pso->readF( tinP , (byteT*)&idProcessOldIn , sizeof idProcessOldIn ) ) ;
                __Z( idProcessOldIn ) ;

                if( !ether && !etThread )
                {
                    b_idProcessOldI.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    idProcessOldI = idProcessOldIn ;
                    count2S* pc2cp = (count2S*)(countT)swc2 ;
                    swc2.freeF( tinP ) ;
                    etThread.delF( tinP , pc2cp ) ;
                    b_idProcessOldI.ungrabF( tinP ) ;
                }

                break ;
            }
            case ifcCMDpORTaUTHORITY_QUERY :
            case ifcCMDpORTaUTHORITY_QUERYaLL :
            {
                ZE( countT , idiClassWanted ) ;
                if( idCmd == ifcCMDpORTaUTHORITY_QUERY )
                {
                    TELL( "ifcCMDpORTaUTHORITY_QUERY ifcCMDpORTaUTHORITY_QUERYaLL: reading idiClassWanted" )
                    __( sizeof idiClassWanted - pso->readF( tinP , (byteT*)&idiClassWanted , sizeof idiClassWanted ) ) ;
                    __Z( idiClassWanted ) ;
                }

                b_idProcessOldI.grabF( tinP , TAG( TAGiDnULL ) ) ;

                TELL( "ifcCMDpORTaUTHORITY_QUERY ifcCMDpORTaUTHORITY_QUERYaLL: validating" )
                validateF( tinP , etThread , swc2 , idProcessOldI ) ;

                stackC stc2p( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_count2S ) ; // WILL CONTAIN SORTED PROCESS [CLASS,PORT] PAIRS
                {
                    countT cFlavors = swc2.cFlavorsF( tinP ) ;
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    {
                        idProcessOldI = swc2.leverF( tinP , idf ) ;
                        count2S* pc2cp = (count2S*)(countT)swc2 ;
                        __Z( pc2cp ) ;

                        if( pc2cp && ( !idiClassWanted || idiClassWanted == pc2cp->c1 ) )
                        {
                            ZE( countT , idSlot ) ;
                            stc2p.sinkF( tinP , idSlot , pc2cp , flSTACKsINK_UNIQUE ) ;
                            __Z( idSlot ) ;
                        }
                    }
                }

                countT cPorts = stc2p ;
                TELL( "ifcCMDpORTaUTHORITY_QUERY ifcCMDpORTaUTHORITY_QUERYaLL: writing port authorities " )
                pso->writeF( tinP , (byteT*)&cPorts , sizeof cPorts ) ;
                while( stc2p )
                {
                    ZE( count2S* , pc2cp ) ;
                    stc2p >> pc2cp ;
                    if( idCmd == ifcCMDpORTaUTHORITY_QUERY ) pso->writeF( tinP , (byteT*)&pc2cp->c2 , sizeof( countT  ) ) ;
                    else                                     pso->writeF( tinP , (byteT*)pc2cp      , sizeof( count2S ) ) ;
                    //U: OPTIMIZE: ELIMINATE THE WRITING OF REDUNDANT idiClass VALUES. ALT: SEND idiClass, cPort, idPort , idPort , ... FOR EACH DISTINCT idiClass
                }

                b_idProcessOldI.ungrabF( tinP ) ;

                break ;
            }
            default :
            {
                __( idCmd ) ;
                __1
                break ;
            }
        }
    }
    TELL( "cleaning up: writing acknack" )

    countT idAck = etThread ? ifcREPLY_NACK : ifcREPLY_ACK ;
    etThread = 0 ;
    pso->writeF( tinP , (byteT*)&idAck , sizeof idAck ) ;

    ZE( byteT , bnu ) ;
    TELL( "cleaning up: reading a byteT so client can disconnect" )
    pso->readF( tinP , &bnu , 1 , flSOCKETcrEAD_STILLhUNGRYiSoK ) ;
    DEL( pso ) ;
    TELL( "cleaning up: final" )
}

DONE( tmServePortF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000034.tmserveportf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000035.tmportauthorityf BEGIN
#define DDNAME       "3func.33000035.tmportauthorityf"
#define DDNUMB      (countT)0x33000035
#define IDFILE      (countT)0x922


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmPortAuthorityF )/*1*/
TELL( "setting up" )

batonC b_idProcessOldI( tinP , TAG( TAGiDnULL ) ) ;
ZE( countT , idProcessOldI ) ;
switchC swc2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idProcessOldI ) ;
batonC b_idProcessOldLast( tinP , TAG( TAGiDnULL ) ) ;
ZE( countT , idProcessOldLast ) ;
batonC b_idMiscLast( tinP , TAG( TAGiDnULL ) ) ;
ZE( countT , idMiscLast ) ;

count7S c7p1 ;
c7p1.c1 = (countT)&b_idProcessOldI ;
c7p1.c2 = (countT)&idProcessOldI ;
c7p1.c3 = (countT)&swc2 ;
c7p1.c4 = (countT)&b_idProcessOldLast ;
c7p1.c5 = (countT)&idProcessOldLast ;
c7p1.c6 = (countT)&b_idMiscLast ;
c7p1.c7 = (countT)&idMiscLast ;

while( !ether && !etThread )
{
    TELL( "in outer loop: setting up" )
    socketC socket( tinP , etThread , TAG( TAGiDnULL ) ) ;
    countT idPort = socket.bindF( tinP , ifcPORToLD1pORTaUTHORITY ) ;
    socket.listenF( tinP ) ;

    while( !ether && !etThread )
    {
        ZE( socketC* , pso ) ;
        TELL( "waiting for a client to connect" )
        nicNameC nnPeer ;
        ZE( countT , idPortPeer ) ;
        ZE( boolT , bRefuse ) ;
        socket.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ; ___( pso ) ;
        __( bRefuse ) ;
        if( ether || etThread ) { DEL( pso ) ; }
        else                    { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmServePortF , 0 , flTHREADlAUNCH_null , 0 , (countT)pso , (countT)&c7p1 ) ; }
    }

    etThread = 0 ;
}

TELL( "cleaning up: sleeping while i have kid threads" )
{
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    while( !etThread && tinP.cKidThreads ) { ++ s ; etThread.osSleepF( tinP , TOCK ) ; }
}

TELL( "cleaning up: final" )
countT cFlavors = swc2.cFlavorsF( tinP ) ;
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
{
    idProcessOldI = swc2.leverF( tinP , idf ) ;
    count2S*& pc2cp = (count2S*&)(countT&)swc2 ;
    etThread.delF( tinP , pc2cp ) ;
    swc2.freeF( tinP ) ;
}

DONE( tmPortAuthorityF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000035.tmportauthorityf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000036.tmnapf BEGIN
#define DDNAME       "3func.33000036.tmnapf"
#define DDNUMB      (countT)0x33000036
#define IDFILE      (countT)0x923


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmNapF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
{
    TELL( "setting up" )
    countT  time1     =           pTaskP->c1 ;
    countT  oshWindow =           pTaskP->c2 ;
    countT  idCmd     =           pTaskP->c3 ;
    countT  arg1      =           pTaskP->c4 ;
    countT  arg2      =           pTaskP->c5 ;

    thirdC& thPrime = etherC::etPrimeIF( tinP ) ;

    TELL( "sleeping before work" )
    {
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        POOPIES
        ++ s ; thPrime.dosSleepIF( tinP , time1 ) ;
    }
    TELL( "tmNapF: cleaning up" )
    if( !ether )
    {
        handleC hWindow( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_WINDOW ) ;
        hWindow.osF( ifcIDtYPEhANDLE_WINDOW , oshWindow ) ;
        thPrime.winPostMessageF( tinP , hWindow , idCmd , arg1 , arg2 ) ;
        hWindow.resetF() ;
    }
}
DONE( tmNapF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000036.tmnapf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000037.tmftpservef BEGIN
#define DDNAME       "3func.33000037.tmftpservef"
#define DDNUMB      (countT)0x33000037
#define IDFILE      (countT)0x924


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/**/

#define ifcIDaRM_USER            0x1
#define ifcIDaRM_PASSWORD        0x2
#define ifcIDaRM_TYPE            0x3
#define ifcIDaRM_QUIT            0x4
#define ifcIDaRM_STAT            0x5
#define ifcIDaRM_LIST            0x6
#define ifcIDaRM_PORT            0x7
#define ifcIDaRM_SIZE            0x8
#define ifcIDaRM_RETRIEVE        0x9
#define ifcIDaRM_STORE           0xa
#define ifcIDaRM_PWD             0xb
#define ifcIDaRM_PASSIVE         0xc
#define ifcIDaRM_USERaCK         0xd
#define ifcIDaRM_USERnACK        0xe
#define ifcIDaRM_PASSCODEaCK     0xf
#define ifcIDaRM_PASSCODEnACK    0x10
#define ifcIDaRM_TYPEaCKi        0x11
#define ifcIDaRM_TYPEnACK        0x12

#define SETiDaRM(postOldCmdP,idArmP) if( !tinP.pEtScratch->strCompareF( tinP , psttc1 , T(postOldCmdP) ) ) idArm = idArmP ;

#define CHECKqUOTA(cbWantP)                                                                                     \
                                                                                                                \
        batQuotaP.grabF( tinP , TAG( TAGiDnULL ) ) ;                                                            \
        {                                                                                                       \
            bRefuse = 1 ;                                                                                       \
            ZE( byteT* , pbi ) ;                                                                              \
            ZE( countT , cbi ) ;                                                                              \
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )                                               \
            tinP.pEtScratch->boxGetShadowF( tinP , pbi , cbi , tFileQuota , 1 ) ; ___( pbi ) ;                  \
            if( POOP ) POOPR                                                                                    \
            else if( cbi == sizeof( countT ) && *(countT*)pbi >= (cbWantP) )                                    \
            {                                                                                                   \
                *(countT*)pbi -= (cbWantP) ;                                                                    \
                tinP.pEtScratch->boxPutF( tinP , tFileQuota , pbi , cbi , 1 ) ; ___( pbi ) ;                    \
                if( POOP ) POOPR                                                                                \
                else       bRefuse = 0 ;                                                                        \
            }                                                                                                   \
                                                                                                                \
            if( bRefuse )                                                                                       \
            {                                                                                                   \
                timeS timeNow ;                                                                                 \
                etThread.osTimeNowF( tinP , timeNow.time1 , timeNow.time2 ) ;                                   \
                TN( tSay , "" ) ; tSay = TT(timeNow.time1,timeNow.time2)+T(": ftp refused request of ")+TF2((countT)(cbWantP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" bytes because remaining quota for day is only ")+TF2(*(countT*)pbi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(".\r\n") ; \
                LOGrAW( tSay ) ;                                                                                \
            }                                                                                                   \
            THREADmODE1rESTORE                                                                                  \
            etThread.delF( tinP , pbi ) ;                                                                       \
        }                                                                                                       \
        batQuotaP.ungrabF( tinP ) ;

/*1*/TASK( tmFtpServeF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c7 )
{
    TELL( "setting up" )
    socketC*  pso        =   (socketC*)pTaskP->c1 ;
    countT    idClient   =             pTaskP->c2 ;
    countT&   cDone      =   *(countT*)pTaskP->c3 ;
    strokeS*& psttLever  = *(strokeS**)pTaskP->c4 ;
    switchC&  swImage    =  *(switchC*)pTaskP->c5 ;
    batonC&   batQuotaP  =   *(batonC*)pTaskP->c6 ;
    timeS&    timeTouchP =    *(timeS*)pTaskP->c7 ;

    TN( tFileQuota , "///ideafarm/ephemeral/domains/com/ideafarm/ipdos/quotas/socket.io" ) ;
    {
        timeS timeNow ;
        etThread.osTimeNowF( tinP , timeNow.time1 , timeNow.time2 ) ;

        if( !etThread.diskFileExistsF( tinP , tFileQuota ) || timeNow.time2 > timeTouchP.time2 )
        {
            batQuotaP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            countT cbForDay = TICK * 0x16 ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            tinP.pEtScratch->boxPutF( tinP , tFileQuota , (byteT*)&cbForDay , sizeof cbForDay , 1 ) ;
            THREADmODE1rESTORE
            if( POOP ) POOPR
            batQuotaP.ungrabF( tinP ) ;
        }
    }

    IFsCRATCH
    {
        SCOOPS
        pso->etherF( tinP , *tinP.pEtScratch ) ;
        TN( tPrefix , "ftp." ) ; tPrefix += TF2(idClient,flFORMAT_NObIGITvALUES)+T("| ") ;
    
        //nicNameC nicNamePeer ;
        //{ ZE( countT , idp ) ; pso->peerNameF( tinP , idp , nicNamePeer ) ; } //IMPOTENCE DURING TERMINATION
        //ZE( strokeS* , psttPeer ) ;
        //U::CONJ: THIS CAN FAIL, CAUSING IMPOTENCE: tinP.pEtScratch->sockPsttHostF( tinP , psttPeer , nicNamePeer ) ; ___( psttPeer ) ;
        //U::20200728@1950: SHOULD NOT BE ABLE TO GO IMPOTENT
    
        ZE( boolT , bRefuse ) ;
        if( !ether ) { CHECKqUOTA( TUCK ) }

        if( bRefuse )
        {
            pso->writeF( tinP , (osTextT*)T("600 too busy now\r\n") ) ;
            DEL( pso ) ;
        }
        else
        {
            TELL( "writing welcome ack" )
            pso->writeF( tinP , (osTextT*)T("220 ok\r\n") ) ;
        
            //tinP.pEtScratch->strokeF( tinP , T("client \"")+T(psttPeer)+T("\"+\r\n") ) ;
            //tinP.pEtScratch->ifcSayIF( tPrefix+T("client ")+T(nicNamePeer)+T(" \"")+T(psttPeer)+T("\"+") , flSAY_APPEND | flSAY_LOG ) ;
        
            nicNameC nicNameClient ;
            ZE( countT , idPortClient ) ;
            ZE( strokeS* , psttl ) ;
            ZE( boolT , bClientQuit ) ;
            ZE( socketC* , psoPassiveData ) ;
            TN( tLastFile , "" ) ;
            TN( tRest , "rest" ) ;
            while( !ether && !etThread && !POOP && !bClientQuit && !bRefuse )
            {
                TELL( "reading wo line of a strokeS string" )
                pso->readWoLineF( tinP , psttl , 0x100 ) ; ___( psttl ) ; // MICROSOFT'S PIECE OF SHIT Internet Explorer DOES THIS; IT DOES NOT SEND "QUIT"
                tinP.pEtScratch->strokeF( tinP , T(" ")+T(psttl)+T("\r\n") ) ;
                //tinP.pEtScratch->ifcSayIF( tPrefix+T("\"")+T(psttl)+T("\"") , flSAY_APPEND | flSAY_LOG ) ; //U:
                TELL( "setting up to process wo line of a strokeS string" )
                if( POOP || !psttl )
                {
                    POOPR
                    bClientQuit = 1 ;
                    etThread.delF( tinP , psttl ) ;
                    break ;
                }
        
                tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttl ) ;
        
                //REPLACE GOOFY ILLEGAL USE OF R ESTART COMMAND (BY WIN98 CLIENT)
                if( 1 == tinP.pEtScratch->strIdF( tinP , psttl , tRest ) && tLastFile.csF( tinP ) )
                {
                    tinP.pEtScratch->delF( tinP , psttl ) ;
                    tinP.pEtScratch->strMakeF( tinP , LF , psttl , T("retr ")+tLastFile ) ; ___( psttl ) ;
                    tinP.pEtScratch->strokeF( tinP , T(" replacing goofy (and illegal) REST command with: ")+T(psttl)+T("\r\n") ) ;
                }
        
                ZE( strokeS* , pstt1words ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                countT cWords = tinP.pEtScratch->strWordsOldF( tinP , pstt1words , psttl , sttq ) ; ___( pstt1words ) ;

                ZE( countT , idWord ) ;
                ZE( countT , idArm ) ;
                ZE( boolT  , bFlushLine ) ;
                FORsTRINGSiN1( pstt1words )
                {
                    if( bFlushLine || !psttc1->idAdam ) continue ;

                    switch( ++ idWord )
                    {
                        case 1 :
                        {
                                 SETiDaRM( "user" , ifcIDaRM_USER     )
                            else SETiDaRM( "pass" , ifcIDaRM_PASSWORD )
                            else SETiDaRM( "type" , ifcIDaRM_TYPE )
                            else SETiDaRM( "quit" , ifcIDaRM_QUIT )
                            else SETiDaRM( "stat" , ifcIDaRM_STAT )
                            else SETiDaRM( "list" , ifcIDaRM_LIST )
                            else SETiDaRM( "port" , ifcIDaRM_PORT )
                            else SETiDaRM( "size" , ifcIDaRM_SIZE )
                            else SETiDaRM( "retr" , ifcIDaRM_RETRIEVE )
                            else SETiDaRM( "stor" , ifcIDaRM_STORE )
                            else SETiDaRM( "pwd"  , ifcIDaRM_PWD )
                            else SETiDaRM( "pasv" , ifcIDaRM_PASSIVE )
                            else
                            {
                                TELL( "writing a reply to a command that is not implemented" )
                                TN( tReply , "502 command not implemented\r\n" ) ;
                                tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                pso->writeF( tinP , (osTextT*)tReply ) ;
                            }

                            switch( idArm )
                            {
                                case ifcIDaRM_QUIT :
                                {
                                    TELL( "writing ack for \"quit\"" )
                                    TN( tReply , "221 ok\r\n" ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    bClientQuit = 1 ;
                                    idArm = 0 ;
                                    break ;
                                }
                                case ifcIDaRM_PWD :
                                {
                                    TELL( "writing a reply to \"pwd\"" )
                                    TN( tReply , "257 \"/\" is current directory.\r\n" ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    idArm = 0 ;
                                    break ;
                                }
                                case ifcIDaRM_PASSIVE :
                                {
                                    idArm = 0 ;
                                    TELL( "writing a reply to \"pasv\"" )
                                    socketC sockA( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                    {
                                        ZE( strokeS* , psttnp ) ;
                                        tinP.pEtScratch->strFromIdPortNicNameF( tinP , psttnp , sockA.bindF( tinP , *tinP.pEtScratch ) ) ; ___( psttnp ) ;
                                        sockA.listenF( tinP ) ;
                                        TN( to , "" ) ; to = T("227 entering passive mode (")+T(psttnp)+T(")\r\n") ;
                                        tinP.pEtScratch->delF( tinP , psttnp ) ;
                                
                                        pso->writeF( tinP , (osTextT*)to ) ;
                                        tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+to ) ;
                                        pso->writeF( tinP , (osTextT*)to ) ;
                                    }
                                
                                    TELL( "\"pasv\": waiting for the client to connect" )
                                    ZE( boolT , bRefuse ) ;
                                    { nicNameC nnnu ; sockA.acceptF( tinP , psoPassiveData , countTC() , nnnu , bRefuse ) ; }
                                    __( bRefuse ) ;
                                    break ;
                                }
                            }

                            if( !idArm ) bFlushLine = 1 ;

                            break ;
                        }
                        case 2 :
                        {
                            switch( idArm )
                            {
                                case ifcIDaRM_USER :
                                {
                                    SETiDaRM(         "visitor" , ifcIDaRM_USERaCK )
                                    else                  idArm = ifcIDaRM_USERnACK ;
                                    break ;
                                }
                                case ifcIDaRM_PASSWORD :
                                {
                                    TN( tDirOld , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets/" ) ;
                                    TN( tDirNew , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets.used/" ) ;
                                    TN( tShort  , "soul.ticket." ) ; tShort += T(psttc1)+T(".soul") ;

                                    tinP.pEtScratch->diskMoveFileOrDirF( tinP , tDirNew+tShort , tDirOld+tShort ) ;
                                    if( !POOP ) idArm = ifcIDaRM_PASSCODEaCK ;
                                    else
                                    {
                                        POOPR
                                        idArm = ifcIDaRM_PASSCODEnACK ;
                                    }

                                    break ;
                                }
                                case ifcIDaRM_TYPE :
                                {
                                    SETiDaRM(               "i" , ifcIDaRM_TYPEaCKi )
                                    else                  idArm = ifcIDaRM_TYPEnACK ;
                                    break ;
                                }
                            }

                            switch( idArm )
                            {
                                case ifcIDaRM_STAT :
                                case ifcIDaRM_LIST :
                                {
                                    idArm = 0 ;
                                    TELL( "preparing to reply to \"stat\" or \"list\"" )
                                    ZE( strokeS* , psttn ) ;
                                    tLastFile = T(psttc1) ;
                                    cleanFileNameF( tinP , *tinP.pEtScratch , tLastFile ) ;
                                    ZE( byteT* , pbi ) ;
                                    ZE( countT , cbi ) ;
                                    pbcbF( tinP , *tinP.pEtScratch , pbi , cbi , tLastFile , psttLever , swImage ) ;
                                    if( POOP ) { POOPR ; pbi = 0 ; }

                                    if( pbi )
                                    {
                                        textC tReply = T("213-status\r\n- 111 222 333 ")+TF4(cbi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FOREIGN,0,0xa)+T(" 555 666 777 888 999\r\n213 status\r\n") ;
                                        TELL( "writing reply to \"stat\" or \"list\"" )
                                        tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                        pso->writeF( tinP , (osTextT*)tReply ) ;
                                    }
                                    else
                                    {
                                        TELL( "writing nack for \"stat\" or \"list\"" )
                                        TN( tReply , "600 error\r\n" ) ;
                                        ( idArm == ifcIDaRM_STAT ? pso : psoPassiveData )->writeF( tinP , (osTextT*)tReply ) ;
                                        tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    }
                                    break ;
                                }
                                case ifcIDaRM_PORT :
                                {
                                    idArm = 0 ;
                                    TELL( "preparing reply to \"port\"" )
                        
                                    ZE( strokeS* , pstt1w ) ;
                                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                    tinP.pEtScratch->strWordsOldF( tinP , pstt1w , psttc1 , sttq , T(",") ) ; ___( pstt1w ) ;
                                    ZE( countT , idw ) ;
                                    FORsTRINGSiN1( pstt1w )
                                    {
                                        countT vv = tinP.pEtScratch->strDigitsToSCountF( tinP , psttc1 , 0xa , 1 ) ;
                        
                                        if( ++ idw < 5 ) //U: DOES NOT SUPPORT IPV6 (128 BIT nicName VALUES)
                                        {
                                            countT idh = *(const countT*)nicNameClient << 8 ;
                                            idh |= vv ;
                                            nicNameClient = idh ;
                                        }
                                        else { idPortClient <<= 8 ; idPortClient |= vv ; }
                                    }
                                    tinP.pEtScratch->delF( tinP , pstt1w ) ;
                        
                                    TELL( "writing reply to \"port\"" )
                                    TN( tReply , "200 ok\r\n" ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    break ;
                                }
                                case ifcIDaRM_SIZE :
                                {
                                    idArm = 0 ;
                                    TELL( "preparing a reply to \"size\"" )
                                    tLastFile = T(psttc1) ;
                                    cleanFileNameF( tinP , *tinP.pEtScratch , tLastFile ) ;
                                    ZE( byteT* , pbi ) ;
                                    ZE( countT , cbi ) ;
                                    pbcbF( tinP , *tinP.pEtScratch , pbi , cbi , tLastFile , psttLever , swImage ) ;
                                    if( POOP ) { POOPR ; pbi = 0 ; }

                                    if( pbi )
                                    {
                                        TN( tr , "" ) ; tr = T("213 ")+TF4(cbi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FOREIGN,0,0xa)+T("\r\n") ;
                                        TELL( "writing a reply to \"size\"" )
                                        pso->writeF( tinP , (osTextT*)tr , tr.csF( tinP ) ) ;
                    
                                        TN( tReply , "" ) ; tReply = tr ;
                                        tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    }
                                    else
                                    {
                                        TELL( "writing nack for \"size\"" )
                                        TN( tReply , "600 error\r\n" ) ;
                                        pso->writeF( tinP , (osTextT*)tReply ) ;
                                        tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    }

                                    break ;
                                }
                                case ifcIDaRM_RETRIEVE :
                                {
                                    idArm = 0 ;
                                    TELL( "preparing a reply to \"retr\"" )
                                    tLastFile = T(psttc1) ;
                                    cleanFileNameF( tinP , *tinP.pEtScratch , tLastFile ) ;
                                    ZE( byteT* , pbi ) ;
                                    ZE( countT , cbi ) ;
                                    pbcbF( tinP , *tinP.pEtScratch , pbi , cbi , tLastFile , psttLever , swImage ) ;
                                    if( pbi ) { CHECKqUOTA( cbi ) ; if( bRefuse ) pbi = 0 ; }

                                    if( pbi )
                                    {
                                        TELL( "writing a reply to \"retr\"" )
                                        if( psoPassiveData )
                                        {
                                            //OPERA BROWSER DOES NOT EXPECT THIS
                                            //TN( tReply , "150 ok\r\n" ) ;
                                            //tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                            //pso->writeF( tinP , (osTextT*)tReply ) ;

                                            psoPassiveData->writeF( tinP , pbi , cbi ) ;
                                            DEL( psoPassiveData ) ;

                                            TN( tReply , "226 ok\r\n" ) ;
                                            tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                            pso->writeF( tinP , (osTextT*)tReply ) ;
                                        }
                                        else
                                        {
                                            socketC sData( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                            tinP.pEtScratch->strokeF( tinP , T("connecting to port ")+TF2(idPortClient,flFORMAT_NObIGITvALUES)+T(" of nn ")+T(nicNameClient)+T("\r\n") ) ;
                                            sData.connectF( tinP , idPortClient , nicNameClient , 1 , TOCK * 4 ) ;
                        
                                            TN( tReply , "150 ok\r\n" ) ;
                                            tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                            pso->writeF( tinP , (osTextT*)tReply ) ;
                                            sData.writeF( tinP , pbi , cbi ) ;
                                            tReply = T("226 ok\r\n") ;
                                            tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                            pso->writeF( tinP , (osTextT*)tReply ) ;
                        
                                            //IE DOESN'T EVER SEND ANYTHING AND DOES NOT DISCONNECT EITHER
                                            //if( !etThread && !*tinP.pEtScratch )
                                            //{
                                            //    ZE( byteT , bIn ) ;
                                            //    sData.readF( tinP , &bIn , 1 ) ;
                                            //    *tinP.pEtScratch = 0 ;
                                            //}
                                        }
                                        bClientQuit = 1 ; //MS IE DOESN'T EVER SEND A QUIT (FUCKIN SHIT SOFTWARE)
                                    }
                                    else
                                    {
                                        TELL( "writing nack for \"retr\"" )
                                        TN( tReply , "600 error\r\n" ) ;
                                        pso->writeF( tinP , (osTextT*)tReply ) ;
                                        tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    }
                                    break ;
                                }
                                case ifcIDaRM_STORE :
                                {
                                    //THIS IS A QUICK HACK JUST TO SUPPORT UPLOADING OF RELEASED IPDOS

                                    idArm = 0 ;
                                    TELL( "preparing a reply to \"stor\"" )
                                    tLastFile = T(psttc1) ;
                                    cleanFileNameF( tinP , *tinP.pEtScratch , tLastFile ) ;

                                    ZE( byteT* , pbi ) ;
                                    ZE( countT , cbi ) ;
                                    const countT cbia = TOCK * 0x40 ;
                                    etThread.newF( tinP , LF , pbi , cbia ) ; ___( pbi ) ;
                                    if( pbi )
                                    {
                                        if( psoPassiveData )
                                        {
                                            POOPR //REDUNDANT; JUST TO MAKE SURE
                                            while( cbi < cbia )
                                            {
                                                psoPassiveData->readF( tinP , pbi + cbi , 1 ) ;
                                                if( !POOP ) cbi ++ ;
                                                else
                                                {
                                                    POOPR ;
                                                    break ;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            TN( tReply , "150 ok\r\n" ) ;
                                            {
                                                socketC sData( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                                tinP.pEtScratch->strokeF( tinP , T("connecting to port ")+TF2(idPortClient,flFORMAT_NObIGITvALUES)+T(" of nn ")+T(nicNameClient)+T("\r\n") ) ;
                                                sData.connectF( tinP , idPortClient , nicNameClient , 1 , TOCK * 4 ) ;
                            
                                                tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;

                                                POOPR //REDUNDANT; JUST TO MAKE SURE
                                                while( cbi < cbia )
                                                {
                                                    sData.readF( tinP , pbi + cbi , 1 ) ;
                                                    if( !POOP ) cbi ++ ;
                                                    else
                                                    {
                                                        POOPR ;
                                                        break ;
                                                    }
                                                }

                                                pso->writeF( tinP , (osTextT*)tReply ) ;
                                                sData.writeF( tinP , pbi , cbi ) ;
                                            }
                                            tReply = T("226 ok\r\n") ;
                                            tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                            pso->writeF( tinP , (osTextT*)tReply ) ;
                                        }
                                    }

                                    if( cbi ) etThread.boxPutF( tinP , tLastFile , pbi , cbi ) ;
                                    etThread.delF( tinP , pbi ) ;

                                    break ;
                                }
                                case ifcIDaRM_USERaCK :
                                {
                                    TELL( "writing ack for \"user\"" )
                                    TN( tReply , "331 ok\r\n" ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    idArm = 0 ;
                                    break ;
                                }
                                case ifcIDaRM_USERnACK :
                                {
                                    TELL( "writing nack for \"user\"" )
                                    TN( tReply , "600 error\r\n" ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    idArm = 0 ;
                                    break ;
                                }
                                case ifcIDaRM_PASSCODEaCK :
                                {
                                    TELL( "writing ack for \"pass\"" )
                                    TN( tReply , "230 ok\r\n" ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    idArm = 0 ;
                                    break ;
                                }
                                case ifcIDaRM_PASSCODEnACK :
                                {
                                    TELL( "writing nack for \"pass\"" )
                                    TN( tReply , "600 error\r\n" ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    idArm = 0 ;
                                    break ;
                                }
                                case ifcIDaRM_TYPEaCKi :
                                {
                                    TELL( "writing ack for \"type i\"" )
                                    TN( tReply , "200 ok\r\n" ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    idArm = 0 ;
                                    break ;
                                }
                                case ifcIDaRM_TYPEnACK :
                                {
                                    TELL( "writing nack for \"type\"" )
                                    TN( tReply , "600 error\r\n" ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    idArm = 0 ;
                                    break ;
                                }
                            }

                            if( !idArm ) bFlushLine = 1 ;

                            break ;
                        }
                    }
                }
        
                etThread.delF( tinP , psttl ) ;
                etThread.delF( tinP , pstt1words ) ;
            }
        
            if( POOP ) POOPR
            //else
            //{
            //    ZE( byteT , bIn ) ;
            //    TELL( "cleaning up: waiting for client to write a byteT so that it can disconnect" )
            //    //pso->readF( tinP , &bIn , 1 ) ;
            //    {
            //        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //        ++ s ; tinP.pEtScratch->osSleepF( tinP , TUCK * 0x80 ) ; //AS COURTESY
            //    }
            //    TELL( "cleaning up" )
            //    POOPR
            //}
            DEL( pso ) ;
            //U:DEL( psoPassiveData ) ;
        
            //tinP.pEtScratch->ifcSayIF( tPrefix+T("client ")+T(nicNamePeer)+T(" \"")+T(psttPeer)+T("\"-") , flSAY_APPEND | flSAY_LOG ) ;
            //tinP.pEtScratch->delF( tinP , psttPeer ) ;
        }
        cDone ++ ;
    }
    if( POOP ) POOPR
}

DONE( tmFtpServeF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000037.tmftpservef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000038.tmserveboxclientsf BEGIN
#define DDNAME       "3func.33000038.tmserveboxclientsf"
#define DDNUMB      (countT)0x33000038
#define IDFILE      (countT)0x925


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/TASK( tmServeBoxClientsF )/*1*/
__( !pTaskP || !pTaskP->c1 ) ;
if( !etThread )
{
    TELL( "setting up" )
    socketC* pso = (socketC*)pTaskP->c1 ;
    boolT  bTalk =           pTaskP->c2 ;
    pso->etherF( tinP , etThread ) ;

    ZE( strokeS* , psttList ) ;
    TELL( "reading wo line of a strokeS string" )
    pso->readWoLineF( tinP , psttList , 0x10000 ) ; ___( psttList ) ;
    if( !etThread.strCompareF( tinP , psttList , T("!quit") ) )
    {
        etThread.etherFireImpersonateMonitorIF( tinP ) ;
        TELL( "writing ack to \"!quit\"" )
        pso->writeF( tinP , (osTextT*)T("ok") ) ;
    }
    else
    {
        TELL( "processing wo line of a received strokeS string" )
        ZE( byteT* , pbAll ) ;
        ZE( countT , cbAll ) ;

        // ALLOCATE p1Root TO POINT TO A CHAIN OF LINKS CONTAINING THESE BOXES
        batonC bFileId( tinP , TAG( TAGiDnULL ) ) ;
        ZE( countT , fileId ) ;
        ZE( link189S* , p1Root ) ;
        countT idf = 1 ;
        ZE( countT , idl ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        while( idf )
        {
            {
                countT idfs = idf ;
                strokeS sttqs = sttq ;
                idl = etThread.strIdF( tinP , idf , sttq , S1C(' ') , psttList ) ;
                __( idl == 1 ) ;
                if( idl > 1 ) idl -- ;
                idf = idfs ;
                sttq = sttqs ;
            }
            ZE( strokeS* , psttw ) ;
            etThread.strSubstringF( tinP , psttw , idf , idl , psttList ) ; ___( psttw ) ;
            if( idl ) idf ++ ;

            ZE( link189S* , p1c ) ;
            if( !p1Root )
            {
                p1c = p1Root = new( 0 , tinP , LF ) link189S( etThread , p1Root ) ; ___( p1Root ) ; ___( p1Root ) ;
            }
            else
            {
                p1c = p1Root ;
                while( p1c && p1c->pR ) p1c = p1c->pR ;
                if( p1c ) // SHOULD ALWAYS BE TRUE
                {
                    p1c->pR = new( 0 , tinP , LF ) link189S( etThread , p1Root ) ; ___( p1c->pR ) ;
                    if( p1c->pR )
                    {
                        p1c->pR->pL = p1c ;
                        p1c = p1c->pR ;
                    }
                }
            }

            {
                ZE( strokeS* , psttFileId ) ;
                etThread.strFromF( tinP , psttFileId , ++ fileId ) ; ___( psttFileId ) ;
                if( bTalk ) etThread.strokeF( tinP , T(psttFileId)+T("\t") ) ;
                etThread.delF( tinP , psttFileId ) ;
            }

            IFsCRATCH
            {
                SCOOPS
                if( bTalk ) etThread.strokeF( tinP , psttw ) ;
                {
                    boxC box( tinP , *tinP.pEtScratch , psttw , 0 , 0 , 0 , 1 ) ;
                    if( p1c ) { box.getF( tinP , p1c->pbd , p1c->cbd ) ; ___( p1c->pbd ) ; } // SHOULD ALWAYS BE TRUE
                    if( POOP && bTalk ) etThread.strokeF( tinP , T(" (does not exist)") ) ;
                    if( POOP ) POOPR
                }
            }

            if( bTalk ) etThread.strokeF( tinP , T("\r\n") ) ;

            etThread.delF( tinP , psttw ) ;
        }

        {
            ZE( link189S* , p1c ) ;
            p1c = p1Root ;
            while( p1c )
            {
                cbAll += sizeof p1c->cbd ;
                cbAll += p1c->cbd ;
                p1c = p1c->pR ;
            }
            etThread.newF( tinP , LF , pbAll , cbAll ) ; ___( pbAll ) ;

            p1c = p1Root ;
            ZE( byteT* , pbc ) ;
            pbc = pbAll ;
            while( p1c )
            {
                etThread.memCopyF( tinP , pbc , (byteT*)&p1c->cbd , sizeof p1c->cbd ) ;
                pbc += sizeof p1c->cbd ;

                if( p1c->pbd )
                {
                    etThread.memCopyF( tinP , pbc , p1c->pbd , p1c->cbd ) ;
                    pbc += p1c->cbd ;
                }

                p1c = p1c->pR ;
            }
        }

        while( p1Root ) delete p1Root ; // DO NOT USE DEL HERE

        if( bTalk ) etThread.strokeF( tinP , T("Sending aggregate.") ) ;
        pso->writeF( tinP , (byteT*)&cbAll , sizeof cbAll ) ;
        if( !pbAll )
        {
            __( cbAll ) ;
        }
        else
        {
            __Z( cbAll ) ;
            pso->writeF( tinP , pbAll , cbAll ) ;
            etThread.delF( tinP , pbAll ) ;
        }
        if( bTalk ) etThread.strokeF( tinP , T("\r" BLANK79 "\r") ) ;
    }
    etThread.delF( tinP , psttList ) ;
    ZE( byteT , bnu ) ;
    TELL( "cleaning up: waiting for client to disconnect" )
    __( pso->readF( tinP , &bnu , 1 , flSOCKETcrEAD_STILLhUNGRYiSoK ) ) ; // PEER WILL NEVER WRITE A BYTE, BUT WILL CLOSE CONN INSTEAD
    TELL( "cleaning up: final" )
    DEL( pso ) ;
}

DONE( tmServeBoxClientsF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000038.tmserveboxclientsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000039.tmoutf BEGIN
#define DDNAME       "3func.33000039.tmoutf"
#define DDNUMB      (countT)0x33000039
#define IDFILE      (countT)0x926


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmOutF )/*1*/
ZE( argS* , pArgs ) ;
pArgs = pTaskP ? (argS*)pTaskP->c1 : 0 ;
if( pArgs )
{
    TELL( "working" )
    etherC& ether = pArgs->ether ;
    {
        boxC out( tinP , ether , T("/process.out/")+T(pArgs->psttUnique)+T("/")+T(pArgs->psttExe) ) ;
        out.getF( tinP , pArgs->post , pArgs->cost ) ; ___( pArgs->post ) ;
    }
    TELL( "tmOutF: cleaning up" )
}
DONE( tmOutF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000039.tmoutf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300003a.tmerrorf BEGIN
#define DDNAME       "3func.3300003a.tmerrorf"
#define DDNUMB      (countT)0x3300003a
#define IDFILE      (countT)0x927


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmErrorF )/*1*/
ZE( argS* , pArgs ) ;
pArgs = pTaskP ? (argS*)pTaskP->c1 : 0 ;
if( pArgs )
{
    TELL( "working" )
    etherC& ether = pArgs->ether ;
    {
        boxC error( tinP , ether , T("/process.error/")+T(pArgs->psttUnique)+T("/")+T(pArgs->psttExe) ) ;
        error.getF( tinP , pArgs->post , pArgs->cost ) ; ___( pArgs->post ) ;
    }
    TELL( "tmErrorF: cleaning up" )
}
DONE( tmErrorF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300003a.tmerrorf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300003b.subtractidportsf BEGIN
#define DDNAME       "3func.3300003b.subtractidportsf"
#define DDNUMB      (countT)0x3300003b
#define IDFILE      (countT)0x928


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/countT subtractIdPortsF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
    }

    _IO_     //TLNA( "subtractNodes2F" )
    sCountT sgn = c1P && c2P ? *(idPortC*)c1P - *(idPortC*)c2P : 0 ;

    if( tinP.fingerprint && pEther && c3P ) ;
    return sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300003b.subtractidportsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300003c.subtractidporttimesf BEGIN
#define DDNAME       "3func.3300003c.subtractidporttimesf"
#define DDNUMB      (countT)0x3300003c
#define IDFILE      (countT)0x929


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/countT subtractIdPortTimesF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
    }

    _IO_     //TLNA( "subtractIdPortTimesF" )

    idPortTimeC&  idpt1 = *(idPortTimeC*)c1P ;
    idPortTimeC&  idpt2 = *(idPortTimeC*)c2P ;

    if( !(nicNameC&)idpt1 || !(nicNameC&)idpt2 ) { BLAMMO ; }

    sCountT sgn = c1P && c2P ? idpt1 - idpt2 : 0 ;

    if( sgn && c1P && c2P && c3P != - 1 )
    {
        //P: THE OPEN RELAYS LIST BEGINS WITH UNGOSSIPPED RELAYS ELDEST TO YOUNGEST, FOLLOWED BY GOSSIPPED RELAYS ELDEST TO YOUNGEST
        stackC& stIdptGossipP = *(stackC*)c3P ;
        boolT   bg1 = !!stIdptGossipP( (byteT*)c1P , subtractIdPortsF , - 1 ) ;
        boolT   bg2 = !!stIdptGossipP( (byteT*)c2P , subtractIdPortsF , - 1 ) ;

             if(  bg1 && !bg2 ) sgn =   1 ;
        else if( !bg1 &&  bg2 ) sgn = - 1 ;
    }

    if( tinP.fingerprint && pEther && c3P ) ;
    return sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300003c.subtractidporttimesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300003d.tmrelaypopclientf BEGIN
#define DDNAME       "3func.3300003d.tmrelaypopclientf"
#define DDNUMB      (countT)0x3300003d
#define IDFILE      (countT)0x92a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmRelayPopClientF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
{
    RELAYiNFOtm
    countT idWorkP = pTaskP->c4 ;

    TELL( "setting up" )
    stackC& stPop = idWorkP == IDtYPErELAYpOPcLIENTwORK_IMPLODE
        ? *pStPop0P
        : idWorkP == IDtYPErELAYpOPcLIENTwORK_EXPLODE1
            ? *pStPop1P
            : idWorkP == IDtYPErELAYpOPcLIENTwORK_EXPLODE2
                ? *pStPop2P
                : idWorkP == IDtYPErELAYpOPcLIENTwORK_LEFT
                    ? *pStPop3P
                    : *pStPop4P
    ;


    IFsCRATCH
    {
        SCOOPS
    
        soulC sInOk( tinP , TAG( TAGiDnULL ) ) ;
        boolT bWoth = 1 ;
        ZE( socketC* , pso ) ;
        idPortTimeC idptServer ;
        ZE( boolT , bMoreToPop ) ;
        while( !ether && !bQuitP )
        {
            TELL( " waiting for a push onto stPop" )
            if( bWoth )           bWoth = 0 ;
            else if( bMoreToPop ) bMoreToPop = 0 ;
            else
            {    
                //etThread.traceF( tinP , TF2(idWorkP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": waiting for a push") ) ;
                stPop.waitF( tinP ) ;
                //etThread.traceF( tinP , TF2(idWorkP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": waited  for a push") ) ;
            }

            TELL( "calculating idPortTimeCorrect" )
            idPortTimeC idptServerCorrect ;
            relayC::idptServerIF( tinP , idptServerCorrect , stIdptOpenP , idptP , stIdptGossipP , idWorkP ) ;
    
            if( pso && idptServer && idptServer != idptServerCorrect && !bQuitP && !ether )
            {
                //P: CLIENTS THAT ARE NOT QUITTING ARE POLITE WHEN CLOSING CONNECTION
                TELL( "writing bye" )
                {
                    ZE( soulC* , psBag ) ;
                    etThread( tinP , psBag , TAG( TAGiDnULL ) ) ;
                    if( psBag )
                    {
                        relayC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flRELAYpOP_null , ifcIDtYPEbAG_CLIENTpOPbYE ) ;
                        //etThread.traceF( tinP , T("writing *psBag") ) ;
                        pso->writeF( tinP , *psBag ) ;
                        etThread( tinP , psBag ) ;
                    }
                }
                TELL( "reading ok+ 2" )
                VERIFYrELAY( *pso ) ;
                TELL( "reading ok-" )
                if( POOP )
                {
                    POOPRqUIET
                    etThread.traceF( tinP , T("could not say bye to stale (incorrect) client") ) ;
                }
                DEL( pso ) ;
                idptServer = 0 ;
            }
            
            while( !ether && !bQuitP && !pso && idptServerCorrect )
            {
                TELL( "looping to write hello" )
                pso = new( 0 , tinP , LF ) socketC( tinP , *tinP.pEtScratch , TAG( TAGiDnULL )/*U:: , 0 , flSOCKETc_TOPsECRET*/ ) ; ___( pso ) ;
                idptServer = idptServerCorrect ;
                TELL( "connecting" )
                pso->connectF( tinP , idptServer , (nicNameC&)idptServer ) ;
                if( ether || bQuitP )
                {
                    //P: CLIENTS THAT ARE QUITTING ARE RUDE WHEN CLOSING CONNECTION
                    DEL( pso ) ;
                    if( POOP )
                    {
                        POOPRqUIET
                        etThread.traceF( tinP , T("quitting, so am not going to connect to correct client") ) ;
                    }
                    idptServer = 0 ;
                }
                else if( POOP )
                {
                    POOPRqUIET
                    DEL( pso ) ;
                    etThread.traceF( tinP , T("could not connect to correct client") ) ;
                    idptServer = 0 ;
                }
                else
                {
                    TELL( "writing hello" )
                    soulC sBagHello( tinP , TAG( TAGiDnULL ) ) ;
                    relayC::hdrBagIF( tinP , sBagHello , idptP , idSerialLathHeaderP , flRELAYpOP_null , ifcIDtYPEbAG_CLIENTpOPhELLO ) ;
                    sBagHello << idWorkP ;
    
                    //etThread.traceF( tinP , T("writing sBagHello") ) ;
                    pso->writeF( tinP , sBagHello ) ;
                    TELL( "reading ok+ 3" )
                    VERIFYrELAY( *pso ) ;
                    TELL( "reading ok-" )
                    if( POOP )
                    {
                        POOPRqUIET
                        DEL( pso ) ;
                        idptServer = 0 ;
                        etThread.traceF( tinP , T("could not say hello to correct client") ) ;
                    }
                }
                idptServerCorrect = 0 ;
                if( !ether && !bQuitP ) relayC::idptServerIF( tinP , idptServerCorrect , stIdptOpenP , idptP , stIdptGossipP , idWorkP ) ;
            }
            
            //etThread.traceF( tinP , TF2(idWorkP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": writing from stPop [stPop]:    ")+TF2(stPop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            while( stPop )
            {
                TELL( "pulling from stPop" )
                ZE( soulC* , psBag ) ;
                stPop >> psBag ;
                //P: CLIENTS THAT ARE QUITTING SILENTLY DISCARD ITEMS THAT THEY ARE SUPPOSE TO POP
                if( pso && !ether && !bQuitP && *psBag >= 4 ) //CODEsYNC df40104 df40104
                {
                    countT idType = psBag->cFieldF( tinP , ifcIDfIELDbAG_IDtYPE ) ;
                    if( idType != ifcIDtYPEbAG_CLIENTnULL )
                    {
                        //etThread.traceF( tinP , TF2(idWorkP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": writing [idType]:    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        TELL( "writing bang" )
                        pso->writeF( tinP , *psBag ) ;
                        TELL( "reading ok+ 5" )
                        VERIFYrELAY( *pso ) ;
                        TELL( "reading ok-" )
                        if( POOP )
                        {
                            POOPRqUIET
                            etThread.traceF( tinP , T("could not write bag") ) ;
                            if( !ether && !bQuitP )
                            {
                                stPop.insertF( tinP , (countT)psBag , ifcSTACKtYPE_PTR_soulC , 1 ) ;
                                psBag = 0 ;
                            }
                            DEL( pso ) ;
                            idptServer = 0 ;
                            bMoreToPop = 1 ;
                            etThread( tinP , psBag ) ;
                            break ;
                        }
                    }
                }
                TELL( "recycling soul" )
                etThread( tinP , psBag ) ;
            }
        }

        if( POOP )
        {
            etThread.traceF( tinP , T("probable coding error: still impotent 2") ) ;
            POOPR
        }
        DEL( pso ) ;
    
        TELL( "tmRelayPopClientF: cleaning up" )
    }

    if( POOP )
    {
        etThread.traceF( tinP , T("probable coding error: still impotent 1") ) ;
        POOPR
    }
}
DONE( tmRelayPopClientF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300003d.tmrelaypopclientf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300003e.tmrelayservercatchbagf BEGIN
#define DDNAME       "3func.3300003e.tmrelayservercatchbagf"
#define DDNUMB      (countT)0x3300003e
#define IDFILE      (countT)0x92b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmRelayServerCatchBagF )/*1*/
TELL( "setting up" )
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
{
    RELAYiNFOtm
    socketC* psoP              =  (socketC*)pTaskP->c4 ;
    socketC& sListenP          = *(socketC*)pTaskP->c5 ;
    stackC&  stIdptPopClientP  =  *(stackC*)pTaskP->c6 ;
    countT&  cLooksForNewPingP =  *(countT*)pTaskP->c7 ;

    IFsCRATCH
    {
        psoP->etherF( tinP , *tinP.pEtScratch ) ;
    }

    stPsoServerP.sinkF( tinP , countTC() , (countT)psoP , flSTACKsINK_UNIQUE ) ;

    idPortTimeC idptPopClient ;
    idPortTimeC idptOriginLathGood ;
    ZE( countT , idPingLath ) ;
    ZE( boolT  , bPopClient ) ;
    ZE( countT , idWork ) ;
    ZE( boolT  , bSaidBye ) ;
    stackC stIdMe( tinP , etThread , TAG( TAGiDnULL ) ) ;
    static countT idCatchLath ;
    ZE( countT , idCatch ) ;
    TN( tTraceFail , "" ) ;
    ZE( countT , cBagsCaught ) ;
    while( !etThread && !ether && !bQuitP && psoP )
    {
        IFsCRATCH
        {
            ZE( boolT , bFail ) ;
            soulC sBag( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
            soulC sOk(  tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
            sOk << ifcIDtYPEbAG_SERVERoK ;

            TELL( "reading soul" )
            sBag.removeAllF( tinP ) ;
            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 0 waiting for a bag to arrive\r\n" ) ; //U::

            //etThread.traceF( tinP , T("reading a bag") ) ;
            IFsCRATCH
            {
                SCOOPS
                psoP->readF( tinP , sBag ) ;
                if( POOP )
                {
                    POOPRqUIET
                    bFail = 1 ;
                    if( !cBagsCaught ) tTraceFail = T("could not read woth sBag, so client is gone without sending me a bag, so i'm done") ;
                }
            }
            //etThread.traceF( tinP , T("readed  a bag") ) ;

            if( !bFail )
            {
                cBagsCaught ++ ;
                //etThread.traceF( tinP , T("processing a bag") ) ;
                idCatch = 1 + incv02AM( idCatchLath ) ;
                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": j a bag has arrived\r\n" ) ; //U::
                idPortTimeC idptNull ;
                idPortTimeC idptOrigin = POOP ? idptNull : idPortTimeC::fieldF( tinP , sBag , ifcIDfIELDbAG_RELAYoRIGIN ) ;

                idptOriginLathGood = idptOrigin ;
        
                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": h inspecting bQuitP\r\n" ) ; //U::
                if( bQuitP )
                {
                    bFail = 1 ;
                    tTraceFail = T("i have been told to quit") ;
                }
                else
                {
                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": g inspecting psoP\r\n" ) ; //U::

                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": f preparing to inspect bag\r\n" ) ; //U::
                    TELL( "inspecting received soul" )
                    countT   idSerial   = sBag.cFieldF( tinP , ifcIDfIELDbAG_IDsERIAL ) ;
                    flagsT&  flags      = sBag.cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                    countT   idType     = sBag.cFieldF( tinP , ifcIDfIELDbAG_IDtYPE ) ;
            
                    //etThread.traceF( tinP , T("[idSerial,flags]:    ")+TF2(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": e inspecting for null serial\r\n" ) ; //U::
                    TELL( "handling soul" )
                    TN( tcr , "\r\n" ) ;
                    if( !idSerial )
                    {
                        bFail = 1 ;
                        tTraceFail = T("error: null serial") ;
                    }
                    else
                    {
                        //CONoUTrAW3( "tmCatchBagF " , idCatch , ": d.2 inspecting serial\r\n" ) ; //U::
                        swsIdSerialReceivedP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        idPortOriginP = idptOrigin ;
                        if( swsIdSerialReceivedP( idSerial ) || swsIdSerialReceivedAltP( idSerial ) )
                        {
                            //etThread.traceF( tinP , T("already seen [idSerial,flags,itType]:    ")+TF2(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": c.1 serial already seen\r\n" ) ; //U::
                            swsIdSerialReceivedP.ungrabF( tinP ) ;
        
                            //FOR DEBUGGING ONLY; MUST BE COMMENTED OUT IN PRODUCTION
                            //{
                            //    if( idType == ifcIDtYPEbAG_WRAP )
                            //    {
                            //        ZE( countT , idTypesWrap ) ;
                            //        ZE( flagsT , flagssWrap ) ;
                            //        ZE( countT , cbsWrap ) ;
                            //        byteT* pbsWrap = sBag.pbFieldF( tinP , idTypesWrap , flagssWrap , cbsWrap , ifcIDfIELDbAG_WRAP ) ;
                            //        if( pbsWrap )
                            //        {
                            //            ZE( countT , idTypesTo ) ;
                            //            ZE( flagsT , flagssTo ) ;
                            //            ZE( countT , cbsTo ) ;
                            //            byteT* pbsTo = soulC::pbFieldIF( tinP , idTypesTo , flagssTo , cbsTo , ifcIDfIELDwRAP_TO , pbsWrap ) ;
                            //
                            //            if( pbsTo && soulC::cFieldsIF( tinP , pbsTo ) ) { CONoUTrAW3( "ignoring directed bag " , idSerial , "\r\n" ) ; }
                            //        }
                            //    }
                            //}
                        }
                        else
                        {
                            //etThread.traceF( tinP , T("not fooey already seen [idSerial,flags,itType]:    ")+TF2(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            //{
                            //    countT nn4 = *(const countT*)(nicNameC&)idptOrigin ;
                            //    //etThread.traceF( tinP , T("[nn4]:    ")+TF2(nn4,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //    if( nn4 != 0x266f9365 )
                            //    {
                            //        etThread.traceF( tinP , T("foreign") ) ;
                            //    }
                            //}

                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": c.2 grabbing lists before inspecting for being root\r\n" ) ; //U::
                            GRABrELAYlISTS
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": b inspecting whether i am root\r\n" ) ; //U::
                            const boolT bRoot = 1 == stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                            //etThread.traceF( tinP , T("[bRoot]:    ")+TF2(bRoot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //P: A SERVER THAT THINKS THAT IT IS ROOT WILL BANG MOST ITEMS IMPLODED DOWN INTO IT
                            if
                            (
                                F(flags) & flRELAYpOP_DOWN                &&
                                bRoot                                     &&
                                idType != ifcIDtYPEbAG_CLIENTpOPpONG      &&
                                idType != ifcIDtYPEbAG_CLIENTpOPgOSSIP    &&
                                idType != ifcIDtYPEbAG_CLIENTpOPuNgOSSIP
                            )
                            {
                                flags &= ~( F(flRELAYpOP_DOWN) ) ;
                                flags |=      flRELAYpOP_UP      ;
                                //etThread.traceF( tinP , T("flipped flags from down to up [flags]:    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            }
                            UNGRABrELAYlISTS
            
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": a registering serial\r\n" ) ; //U::
                            if
                            (
                                F(flags) & flRELAYpOP_UP ||
                                (
                                    bRoot &&
                                    (
                                        idType == ifcIDtYPEbAG_CLIENTpOPpONG     ||
                                        idType == ifcIDtYPEbAG_CLIENTpOPgOSSIP   ||
                                        idType == ifcIDtYPEbAG_CLIENTpOPuNgOSSIP
                                    )
                                )
                            )
                            {
                                TELL( "registering serial" )
                                switchStackC& swsId = bAltSwsP ? swsIdSerialReceivedAltP : swsIdSerialReceivedP ;
                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                swsId.sinkF( tinP , countTC() , idSerial , flSTACKsINK_UNIQUE ) ;
                                THREADmODE1rESTORE
                                if( swsId > 0x100 )
                                {
                                    ((stackC&)swsId).purgeF( tinP ) ;
                                    bAltSwsP = !bAltSwsP ;
                                }
                                //P: EACH SERVER IGNORES DUPLICATES OF UPWARD BOUND ITEMS THAT IT HAS ALREADY PROCESSED
                            }
                            swsIdSerialReceivedP.ungrabF( tinP ) ;
            
                            {
                                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 9 grabbing lists\r\n" ) ; //U::
                                GRABrELAYlISTS
                                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 8 after grabbing lists\r\n" ) ; //U::
                                countT ideMe = stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                if( ideMe == 1 && idptOrigin && !relayC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idptOrigin ) )
                                {
                                    stIdptOpenP.sinkF( tinP , countTC() , (byteT*)&idptOrigin , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                    countT nn4 = *(const countT*)(nicNameC&)idptOrigin ;
                                    etThread.traceF( tinP , T("registered origin [cNodes,idptOrigin]:    ")+TF2(stIdptOpenP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(nn4,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                }
                                //P: A SERVER THAT THINKS THAT IT IS ROOT WILL ADD UNKNOWN ORIGIN RELAYS TO ITS LIST
                                UNGRABrELAYlISTS
                            }
            
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 7 switching on bag type\r\n" ) ; //U::
                            TELL( "local processing" )
                            ZE( byteT* , pbsWrap ) ;
                            if( POOP ) { BLAMMO ; }
                            switch( idType ) //ALL PROCESSING HERE MUST BE FAST; LONG PROCESSING SHOULD BE DONE AFTER POPPING
                            {
                                case ifcIDtYPEbAG_CLIENTpOPhELLO :
                                {
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPhELLO\r\n" ) ; //U::
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPhELLO+" )
                                    idptPopClient = idptOrigin ;
                                    bPopClient = 1 ;
                                    stIdptPopClientP.sinkF( tinP , countTC() , (byteT*)&idptPopClient , flSTACKsINK_null , subtractIdPortTimesF , - 1 ) ;
                                    idWork = sBag.cFieldF( tinP , ifcIDfIELDbAG_IDwORK ) ;
        
                                    //CONoUTrAW5( "tmRelayServerCatchBagF (idThread,idWork): " , tinP.monitor.idThread , processGlobal3I.mapPopClientWork(idWork) , 0 , "\r\n" ) ;
        
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPhELLO-" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPhELLO\r\n" ) ; //U::
                                    break ;
                                }
                                case ifcIDtYPEbAG_CLIENTpOPbYE :
                                {
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPbYE\r\n" ) ; //U::
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPbYE+" )
                                    bSaidBye = 1 ;
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPbYE-" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPbYE\r\n" ) ; //U::
                                    break ;
                                }
                                case ifcIDtYPEbAG_CLIENTpOPgOSSIP :
                                case ifcIDtYPEbAG_CLIENTpOPuNgOSSIP :
                                {
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOP*gOSSIP\r\n" ) ; //U::
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPgOSSIP+" )
                                    GRABrELAYlISTS
                                    idPortTimeC* pnRoot = stIdptOpenP ? (idPortTimeC*)&stIdptOpenP[ 1 ] : 0 ;
                                    //P: A SERVER WILL IGNORE GOSSIP UNLESS IT THINKS THAT IT IS ROOT
                                    if( pnRoot && *pnRoot == idptP )
                                    {
                                        idPortTimeC idptGossip = idPortTimeC::fieldF( tinP , sBag , ifcIDfIELDbAG_IDtYPE + 1 ) ;
                                        if( idType == ifcIDtYPEbAG_CLIENTpOPgOSSIP )
                                        {
                                            //P: GOSSIP HAS THE SAME EFFECT ON THE RELAY DOING THE GOSSIP AS ON THE VICTIM RELAY
                                            stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptGossip , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
                                            stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptOrigin , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
                                        }
                                        else
                                        {
                                            idPortTimeC idptGossipNew = idPortTimeC::fieldF( tinP , sBag , ifcIDfIELDbAG_IDtYPE + 1 + idPortTimeC::cFieldsF( tinP ) ) ;
                                            if( stIdptOpenP( (byteT*)&idptGossip , subtractIdPortTimesF , (countT)&stIdptGossipP ) )
                                            {
                                                stIdptOpenP.extractF( 0 , tinP ) ;
                                            }
                                            else if( relayC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idptGossip ) )
                                            {
                                                stIdptOpenP.extractF( 0 , tinP ) ;
                                            }
            
                                            if( stIdptGossipP( (byteT*)&idptGossip , subtractIdPortsF , - 1 ) )
                                            {
                                                stIdptGossipP.extractF( 0 , tinP ) ;
                                            }
                                            else if( relayC::bListedIF( tinP , stIdptGossipP , stIdptGossipP , idptGossip ) )
                                            {
                                                stIdptGossipP.extractF( 0 , tinP ) ;
                                            }
            
                                            if( !relayC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idptGossipNew ) ) stIdptOpenP.sinkF( tinP , countTC() , (byteT*)&idptGossipNew , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                        }
                                        relayC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                                        inc02AM( cGossipInP ) ;
                                    }
            
                                    UNGRABrELAYlISTS
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPgOSSIP-" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOP*gOSSIP\r\n" ) ; //U::
                                    break ;
                                }
                                case ifcIDtYPEbAG_CLIENTpOPpING :
                                {
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPpING\r\n" ) ; //U::
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPpING+" )
                                    cLooksForNewPingP = 0 ;
                                    if( idptOrigin && idptOrigin - idptP < 0 )
                                    {
                                        //P: SERVER REPLACES ITS LISTS IFF PING IS RECEIVED FROM ELDER
                                        GRABrELAYlISTS
                                        stIdptOpenP.purgeF( tinP ) ;
                                        stIdptGossipP.purgeF( tinP ) ;
                                        {
                                            countT idField = ifcIDfIELDbAG_IDtYPE + 1 ;
                                            relayC::hisListIF( tinP , stIdptGossipP , sBag , stIdptGossipP , idField ) ;
                                            relayC::hisListIF( tinP , stIdptOpenP , sBag , stIdptGossipP , idField ) ;
                                        }
                                        UNGRABrELAYlISTS
                                    }
            
                                    if( stIdptGossipP( (byteT*)&idptP , subtractIdPortsF , - 1 ) )
                                    {
                                        //P: WHENEVER SELF IS GOSSIPPED IN A PING, THE FALSELY GOSSIPPED SERVER IMPODE POPS DOWNWARD AN "UNGOSSIP" ITEM AFTER RETIMESTAMPING ITSELF
                                        idPortTimeC idptOld ;
                                        idptOld = idptP ;
                                        idptP.timeStampIfF( tinP , etThread ) ;
        
                                        relayC::handleRefreshTimeStampF( tinP , idptP ) ;
            
                                        ZE( soulC* , psBag ) ;
                                        etThread( tinP , psBag , TAG( TAGiDnULL ) ) ;
                                        if( psBag )
                                        {
                                            relayC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flRELAYpOP_DOWN , ifcIDtYPEbAG_CLIENTpOPuNgOSSIP ) ;
                                            idptOld >> *psBag ;
                                            idptP   >> *psBag ;
                                            relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                                            etThread( tinP , psBag ) ;
                                        }
                                    }
            
                                    //P: SERVER RESPONDS TO PING BY IMPLODE POPPING DOWNWARD A "PONG"
                                    ZE( soulC* , psBag ) ;
                                    etThread( tinP , psBag , TAG( TAGiDnULL ) ) ;
                                    if( psBag )
                                    {
                                        relayC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flRELAYpOP_DOWN , ifcIDtYPEbAG_CLIENTpOPpONG ) ;
                                        relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                                        etThread( tinP , psBag ) ;
                                    }
            
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPpING-" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPpING\r\n" ) ; //U::
                                    break ;
                                }
                                case ifcIDtYPEbAG_WRAP :
                                {
                                    //etThread.traceF( tinP , T("ifcIDtYPEbAG_WRAP") ) ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP\r\n" ) ; //U::
                                    TELL( "ifcIDtYPEbAG_WRAP+" )
        
                                    {
                                        ZE( countT , idTypesWrap ) ;
                                        ZE( flagsT , flagssWrap ) ;
                                        ZE( countT , cbsWrap ) ;
                                        pbsWrap = sBag.pbFieldF( tinP , idTypesWrap , flagssWrap , cbsWrap , ifcIDfIELDbAG_WRAP ) ;
                                    }
        
                                    //if( pbsWrap ) { CONoUTrAW( "w" ) ; }
        
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP doing\r\n" ) ; //U::
                                    if( pbsWrap ) relayC::doWrapLocallyIfIF( tinP , etThread , RELAYiNFOaRGS , pbsWrap , idptOrigin , 1 ) ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP done\r\n" ) ; //U::
                                    TELL( "ifcIDtYPEbAG_WRAP-" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP\r\n" ) ; //U::
                                    break ;
                                }
                            }
            
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 5 popping\r\n" ) ; //U::
                            //etThread.traceF( tinP , T("calling popIF") ) ;
                            relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , sBag , stIdptOpenP , stIdptGossipP , idptP ) ;

                            //etThread.traceF( tinP , T("called popIF") ) ;
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 4 doing\r\n" ) ; //U::
                            if( pbsWrap )
                            {
                                relayC::doWrapLocallyIfIF( tinP , etThread , RELAYiNFOaRGS , pbsWrap , idptOrigin /*U::, 2*/ ) ;  //U:: 20210209@2012: COMMENTED OUT ", 2" WITHOUT ANALYSIS TO GET DUT TO WORK
                                //etThread.traceF( tinP , T("called doWrapLocallyIfIF") ) ;
                            }
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 3 after doing\r\n" ) ; //U::
                        }
                    }
            
                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 1 writing ok\r\n" ) ; //U::
                    TELL( "writing ok" )
                    //etThread.traceF( tinP , T("writing sOk") ) ;
                    IFsCRATCH
                    {
                        SCOOPS
                        //P: SERVER NORMALLY REPLIES TO EACH COMMAND BY WRITING AN sOk
                        psoP->writeF( tinP , sOk ) ;
        
                        if( POOP )
                        {
                            POOPRqUIET
                            bFail = 1 ;
                            tTraceFail = T("could not write sOk") ;
                        }
                    }
                }
            }

            if( bFail )
            {
                if( tTraceFail.csF( tinP ) ) etThread.traceF( tinP , tTraceFail ) ;
                if( psoP )
                {
                    stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
                    stPsoServerP.ungrabF( tinP ) ;
                    DEL( psoP ) ;
                }
                break ;
            }
        }
    }

    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": exited loop; deleting socket\r\n" ) ; //U::
    TELL( "deleting socket" )
    if( psoP )
    {
        stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
        stPsoServerP.ungrabF( tinP ) ;
        DEL( psoP ) ;
    }

    TELL( "tmRelayServerCatchBagF: cleaning up" )
    if( bPopClient )
    {
        stIdptPopClientP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        if( stIdptPopClientP( (byteT*)&idptPopClient , subtractIdPortTimesF , - 1 ) ) stIdptPopClientP.extractF( 0 , tinP ) ;
        stIdptPopClientP.ungrabF( tinP ) ;
    }

    ZE( soulC* , psBag ) ;
    etThread( tinP , psBag , TAG( TAGiDnULL ) ) ;
    if( psBag )
    {
        ZE( boolT , bPop ) ;
        GRABrELAYlISTS
        idPortTimeC* pnRoot = stIdptOpenP ? (idPortTimeC*)&stIdptOpenP[ 1 ] : 0 ;
        if( idptPopClient && !bSaidBye && !bQuitP && idWork == IDtYPErELAYpOPcLIENTwORK_IMPLODE ) //THIS CODE WILL NEVER GOSSIP ABOUT THE ROOT
        {
            //P: SERVER WILL GOSSIP IF A POP CLIENT IMPLODING DOWNWARD TO IT DIED WITHOUT SAYING GOODBYE
            if( pnRoot && *pnRoot == idptP )
            {
                stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptPopClient , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
                relayC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
            }
            else bPop = 1 ;
        }
        UNGRABrELAYlISTS

        if( bPop )
        {
            relayC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flRELAYpOP_DOWN , ifcIDtYPEbAG_CLIENTpOPgOSSIP ) ;
            idptPopClient >> *psBag ;
            relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
        }

        etThread( tinP , psBag ) ;
    }

    if( POOP ) { BLAMMO ; } //U:: TO FIND A BUG

    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": thread ending\r\n" ) ; //U::
    if( !bSaidBye && !ether && !bQuitP ) ;
}
DONE( tmRelayServerCatchBagF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300003e.tmrelayservercatchbagf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300003f.tmrelayticklef BEGIN
#define DDNAME       "3func.3300003f.tmrelayticklef"
#define DDNUMB      (countT)0x3300003f
#define IDFILE      (countT)0x92c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmRelayTickleF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
{
    idPortC idPortP =          pTaskP->c1 ;
    boolT&  bWothP  = *(boolT*)pTaskP->c2 ;

    IFsCRATCH
    {
        SCOOPS
        soulC sInOk( tinP , TAG( TAGiDnULL ) ) ;
        while( !ether && bWothP )
        {
            socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) /*U::, 0 , flSOCKETc_TOPsECRET*/ ) ;
            sock.connectF( tinP , idPortP , (nicNameC&)idPortP ) ;
            VERIFYrELAY( sock ) ;
    
            if( !POOP ) break ;
            else
            {
                POOPR
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                ether.osSleepF( tinP , TUCK * 0x40 ) ;
            }
        }
        if( POOP ) POOPR
    }
}
DONE( tmRelayTickleF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300003f.tmrelayticklef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000040.tmrelaykillf BEGIN
#define DDNAME       "3func.33000040.tmrelaykillf"
#define DDNUMB      (countT)0x33000040
#define IDFILE      (countT)0x92d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmRelayKillF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
{
    RELAYiNFOtm
    TELL( "napping for life" )
    etherC::loafIF( tinP ) ;

    {
   
        TELL( "killing" )
        //P: WHEN A RELAY QUITS, IT DOES SO RUDELY
        //LOGrAW( "tmRelayKillF: setting bQuitP\r\n" ) ; //U::
        bQuitP = 1 ;

        if( pStPop0P ) { ZE( soulC* , psBag ) ; etThread( tinP , psBag , TAG( TAGiDnULL ) ) ; *pStPop0P << psBag ; }
        if( pStPop1P ) { ZE( soulC* , psBag ) ; etThread( tinP , psBag , TAG( TAGiDnULL ) ) ; *pStPop1P << psBag ; }
        if( pStPop2P ) { ZE( soulC* , psBag ) ; etThread( tinP , psBag , TAG( TAGiDnULL ) ) ; *pStPop2P << psBag ; }
        if( pStPop3P ) { ZE( soulC* , psBag ) ; etThread( tinP , psBag , TAG( TAGiDnULL ) ) ; *pStPop3P << psBag ; }
        if( pStPop4P ) { ZE( soulC* , psBag ) ; etThread( tinP , psBag , TAG( TAGiDnULL ) ) ; *pStPop4P << psBag ; }

        IFsCRATCH
        {
            SCOOPS
            socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
            sock.connectF( tinP , idptP , (nicNameC&)idptP ) ;
            if( POOP ) POOPR
        }

        {
            stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            if( !etThread && !stPsoServerP.third && stPsoServerP )
            {
                handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                do
                {
                    socketC* pso = (socketC*)stPsoServerP.downF( tinP , handle ) ;
                    __Z( pso ) ;
                    if( pso )
                    {
                        SCOOPS
                        handleC& hSoc = *(handleC*)&pso->handleF( tinP ) ;
                        hSoc.closeIfF() ;
                        if( POOP ) POOPR
                    }
                }
                while( !etThread && !stPsoServerP.third && ~handle ) ;
            }
            stPsoServerP.ungrabF( tinP ) ;
        }
    }
}
DONE( tmRelayKillF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000040.tmrelaykillf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000041.tmrelayinitiatorf BEGIN
#define DDNAME       "3func.33000041.tmrelayinitiatorf"
#define DDNUMB      (countT)0x33000041
#define IDFILE      (countT)0x92e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmRelayInitiatorF )/*1*/
tinP.idPhase2 = 1 ;
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
{
    RELAYiNFOtm
    stackC&   stIdptPopClientP  =    *(stackC*)pTaskP->c4 ;
    countT&   cLooksForNewPingP =    *(countT*)pTaskP->c5 ;
    boolT&    bReadyP           =     *(boolT*)pTaskP->c6 ;

    soulC soul( tinP , TAG( TAGiDnULL ) ) ;
    stackC stRelayAbsent1( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent3( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent4( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent5( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent1Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent2Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent3Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent4Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent5Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stIdMe( tinP , etThread , TAG( TAGiDnULL ) ) ;
    ZE( countT , idCycle ) ;
    idPortTimeC idptHandleLag ;
    while( !etThread && !stIdptOpenP.third && !ether && !bQuitP )
    {
        //CONoUTrAW( "tmRelayInitiatorF: 8 look for absentees\r\n" ) ;
        ZE( boolT , bRollTaken ) ;
        idPortTimeC idptAbsent1 ;
        idPortTimeC idptAbsent2 ;
        idPortTimeC idptAbsent3 ;
        idPortTimeC idptAbsent4 ;
        idPortTimeC idptAbsent5 ;
        ZE( boolT , bHelloHandle ) ;
        if( !( ++ idCycle % 0x2 ) )
        {
            bRollTaken = 1 ;
            stRelayAbsent1.purgeF( tinP ) ;
            stRelayAbsent2.purgeF( tinP ) ;
            stRelayAbsent3.purgeF( tinP ) ;
            stRelayAbsent4.purgeF( tinP ) ;
            stRelayAbsent5.purgeF( tinP ) ;
            relayC::idPortTimeClientsExpectedIF( tinP , stRelayAbsent1 , stIdptOpenP , stIdptGossipP , idptP , IDtYPErELAYpOPcLIENTwORK_IMPLODE  ) ;
            relayC::idPortTimeClientsExpectedIF( tinP , stRelayAbsent2 , stIdptOpenP , stIdptGossipP , idptP , IDtYPErELAYpOPcLIENTwORK_EXPLODE1 ) ;
            relayC::idPortTimeClientsExpectedIF( tinP , stRelayAbsent3 , stIdptOpenP , stIdptGossipP , idptP , IDtYPErELAYpOPcLIENTwORK_EXPLODE2 ) ;
            relayC::idPortTimeClientsExpectedIF( tinP , stRelayAbsent4 , stIdptOpenP , stIdptGossipP , idptP , IDtYPErELAYpOPcLIENTwORK_LEFT     ) ;
            relayC::idPortTimeClientsExpectedIF( tinP , stRelayAbsent5 , stIdptOpenP , stIdptGossipP , idptP , IDtYPErELAYpOPcLIENTwORK_RIGHT    ) ;
            {
                if( stIdptPopClientP )
                {
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    do
                    {
                        //P: RELAY WILL COUNT A CLIENT AS "PRESENT" EVEN IF THE CLIENT DISAGREES ABOUT THE TYPE OF WORK IT IS CONNECTED TO DO
                        //U: COUNT THE CLIENT AS PRESENT HERE ONLY IF THE CLIENT AGREES ABOUT THE TYPE OF WORK IT IS DOING
                        //U: ISSUE: A CLIENT IS NOT REALLY ABSENT AS RIGHT IF IT IS PRESENT AS DOWN
                        idPortTimeC& idpt = *(idPortTimeC*)&stIdptPopClientP.downF( tinP , hDown ) ;
                        if( stRelayAbsent1( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent1.extractF( 0 , tinP ) ;
                        if( stRelayAbsent2( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent2.extractF( 0 , tinP ) ;
                        if( stRelayAbsent3( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent3.extractF( 0 , tinP ) ;
                        if( stRelayAbsent4( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent4.extractF( 0 , tinP ) ;
                        if( stRelayAbsent5( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent5.extractF( 0 , tinP ) ;
                    }
                    while( !stIdptPopClientP.third && ~hDown ) ;
                }
            }
    
            GOSSIPaBSENTrELAY( 1 )
            GOSSIPaBSENTrELAY( 2 )
            GOSSIPaBSENTrELAY( 3 )
            GOSSIPaBSENTrELAY( 4 )
            GOSSIPaBSENTrELAY( 5 )
    
            POURaBSENTrELAY( 1 )
            POURaBSENTrELAY( 2 )
            POURaBSENTrELAY( 3 )
            POURaBSENTrELAY( 4 )
            POURaBSENTrELAY( 5 )
    
            if( idptAbsent1 || idptAbsent2 || idptAbsent3 || idptAbsent4 || idptAbsent5 )
            {
                bHelloHandle = 1 ; //P: RELAY SAYS HELLO TO HANDLE WHENEVER WO OR MORE EXPECTED CLIENTS ARE ABSENT
            }
        }

        //CONoUTrAW( "tmRelayInitiatorF: 7 root work\r\n" ) ;
        ZE( boolT , bRoot ) ;
        ZE( countT , cGossipPopped ) ;
        GRABrELAYlISTS
        idPortTimeC* pnRoot = stIdptOpenP ? (idPortTimeC*)&stIdptOpenP[ 1 ] : 0 ;
        if( pnRoot )
        {
            if
            (
                !bReadyP
                &&
                bRollTaken
                &&
                ( !idptAbsent1 && !idptAbsent2 && !idptAbsent3 && !idptAbsent4 && !idptAbsent5 )
                &&
                ( ( *pnRoot != idptP ) || idCycle >= 0x1/*U::0x10*/ )
            )
            bReadyP = 1 ;

            if( *pnRoot == idptP )
            {
                {
                    idPortTimeC idpth = relayC::handleQueryIF( tinP ) ;
                    if( idpth && !relayC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idpth ) ) stIdptOpenP.sinkF( tinP , countTC() , (byteT*)&idpth , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ; //P: A ROOT RELAY ALWAYS KNOWS ABOUT A HANDLE RELAY
                }

                //U: I DO NOT KNOW WHY THIS CAUSES CYCLING IF DONE EVERY CYCLE
                if( !( idCycle % 0x4 ) ) bHelloHandle = 1 ; //P: EVERY RELAY THAT THINKS THAT IT IS ROOT ALWAYS SAYS HELLO TO HANDLE
                bRoot = 1 ;
                cGossipPopped = cGossipInP ;
                if( idptAbsent5 )
                {
                    //P: A RELAY THAT THINKS IT IS ROOT WILL DELIST AN ABSENT RELAY THAT IT EXPECTS TO BE AT ITS LEFT
                    if( stIdptOpenP(   (byteT*)&idptAbsent5 , subtractIdPortTimesF , (countT)&stIdptGossipP ) ) stIdptOpenP.extractF(   0 , tinP ) ;
                    if( stIdptGossipP( (byteT*)&idptAbsent5 , subtractIdPortsF  , - 1                    ) ) stIdptGossipP.extractF( 0 , tinP ) ;
                    relayC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                }

                //TEST ALL GOSSIPPED RELAYS
                //P: A RELAY THAT THINKS THAT IT IS ROOT WILL TEST ALL GOSSIPPED RELAYS AND DELIST THOSE THAT FAIL
                if( stIdptGossipP )
                {
                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    do
                    {
                        idPortTimeC& idptTest = *(idPortTimeC*)&stIdptGossipP.downF( tinP , hDown ) ;
                        if( !relayC::testIF( tinP , idptP , idSerialLathHeaderP , idptTest ) )
                        {
                            if( stIdptOpenP(   (byteT*)&idptTest , subtractIdPortTimesF , (countT)&stIdptGossipP ) ) stIdptOpenP.extractF(   0 , tinP ) ;
                            if( stIdptGossipP( (byteT*)&idptTest , subtractIdPortsF  , - 1                    ) ) stIdptGossipP.extractF( 0 , tinP ) ;
                            relayC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                        }
                    }
                    while( !stIdptGossipP.third && ~hDown ) ;
                    THREADmODE1rESTORE
                }

                //etThread.traceF( tinP , T("loading ifcIDtYPEbAG_CLIENTpOPpING bag [cNodesOpen,cNodesGossip]:    ")+TF2(stIdptOpenP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(stIdptGossipP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                relayC::hdrBagIF( tinP , soul , idptP , idSerialLathHeaderP , flRELAYpOP_UP , ifcIDtYPEbAG_CLIENTpOPpING ) ;
                relayC::myListIF( tinP , soul , stIdptGossipP ) ;
                relayC::myListIF( tinP , soul , stIdptOpenP ) ;
            }
            else if( incv02AM( cLooksForNewPingP ) > 4 )
            {
                cLooksForNewPingP = 0 ;
                stIdptOpenP.extractF( 0 , tinP ) ;

                bHelloHandle = 1 ; //P: A NONROOT RELAY THAT HAS NOT RECEIVED A PING LATELY WILL SAY HELLO TO HANDLE
            }
        }

        //CHATTER MY OPEN LIST
        //THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        //if( stIdptOpenP )
        //{
        //    TN( tcol , ":" ) ;
        //    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        //    do
        //    {
        //        idPortTimeC& idpt = *(idPortTimeC*)&stIdptOpenP.downF( tinP , hDown ) ;
        //        countT          idPort = idpt ;
        //        const nicNameC& nn     = (const nicNameC&)(const idPortC&)idpt ;
        //        const timeS&    tt     = idpt ;
        //        //etThread.strokeF( tinP , T(nn)+tcol+T(idPort)+tcol+TT(tt.time1,tt.time2)+T(!hDown?"\r\n":" , ") ) ;
        //    }
        //    while( !stIdptPopClientP.third && ~hDown ) ;
        //}
        //THREADmODE1rESTORE

        //CONoUTrAW( "tmRelayInitiatorF: 6 register myself as handle\r\n" ) ;
        UNGRABrELAYlISTS
        relayC::handleRegisterMeIfIF( tinP , idptP ) ; //P: A RELAY WILL GRAB A HANDLE VACANCY

        //CONoUTrAW( "tmRelayInitiatorF: 5 pour mediator list\r\n" ) ;
        if( !( idCycle % 0x8 ) ) //02->001
        {
            swsIdptMediatorP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            swsIdptMediatorAltP.grabF( tinP , TAG( TAGiDnULL ) ) ;

            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            swsIdptMediatorAltP.freeAllF( tinP ) ;

            countT cFlavors = swsIdptMediatorP.cFlavorsF( tinP ) ;
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            {
                idAdamMediatorP = swsIdptMediatorP.leverF( tinP , idf ) ;
                if( swsIdptMediatorP )
                {
                    //etThread.strokeF( tinP , T("pouring ")+TF1(swsIdptMediatorP)+T(" registered mediator cells of adam ")+TF1(idAdamMediatorP)+T("\r\n") ) ;
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    do
                    {
                        idPortTimeC& idptm = *(idPortTimeC*)&swsIdptMediatorP.downF( tinP , hDown ) ;
                        swsIdptMediatorAltP.sinkF( tinP , countTC() , (byteT*)&idptm , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                        swsIdptMediatorP.extractF( 0 , tinP ) ;
                    }
                    while( !stIdptOpenP.third && ~hDown ) ;
                }
            }

            swsIdptMediatorP.freeAllF( tinP ) ;
            THREADmODE1rESTORE

            swsIdptMediatorAltP.ungrabF( tinP ) ;
            swsIdptMediatorP.ungrabF( tinP ) ;
        }

        //CONoUTrAW( "tmRelayInitiatorF: 4 set bHelloHandle\r\n" ) ;
        {
            idPortTimeC idptHandleCopy = relayC::handleQueryIF( tinP ) ;
            if( idptHandleCopy && idptHandleCopy != idptHandleLag && idptHandleCopy != idptP ) bHelloHandle = 1 ; //P: ALL RELAYS SAY HELLO TO A NEW HANDLE RELAY
            idptHandleLag = idptHandleCopy ;
        }

        //CONoUTrAW( "tmRelayInitiatorF: 3 say hello to handle\r\n" ) ;
        //U::
        static countT cHere ;
        if( ++ cHere == 4 )
        {
            countT foo = 2 ;
        }

        if( bHelloHandle ) relayC::helloToHandleIF( tinP , idptP , idSerialLathHeaderP ) ;

        //CONoUTrAW( "tmRelayInitiatorF: 2 pop the soul\r\n" ) ;
        if( soul ) //U::CONJ: BUG: IS USING operator byteT*
        {
            static countT cPops ; //U::CONJ: NEEDS TO BE VISIBLE TO SOME OTHER SNIPPET
            cPops ++ ;
            relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , soul , stIdptOpenP , stIdptGossipP , idptP ) ;
            soul.removeAllF( tinP ) ;
        }

        //CONoUTrAW( "tmRelayInitiatorF: 1 pop a null bag\r\n" ) ;
        { //THIS IS TO STIMULATE THE POP STACKS SO THAT THE POP CLIENTS WILL KEEP THEIR CONNECTIONS CURRENT
            ZE( soulC* , psBag ) ;
            etThread( tinP , psBag , TAG( TAGiDnULL ) ) ;
            if( psBag )
            {
                relayC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flRELAYpOP_UP|flRELAYpOP_DOWN , ifcIDtYPEbAG_CLIENTnULL ) ;
                relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                etThread( tinP , psBag ) ;
            }
        }

        //CONoUTrAW( "tmRelayInitiatorF: 0 napping\r\n" ) ;
        TELL( "napping" )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        countT cTries = /*U:: TUCK / 0x10 */ 1 ; //U::TO FIND A BUG
        //P: A ROOT RELAY WILL CONTINUE IMMEDIATELY TO NEXT CYCLE IF IT HAS RECEIVED NEW GOSSIP
        while( cTries -- && ( !bRoot || ( cGossipPopped == cGossipInP ) ) ) { ++ s ; ether.osSleepF( tinP , TUCK * 0x80 ) ; }
    }
}
tinP.idPhase2 = 0 ;
DONE( tmRelayInitiatorF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000041.tmrelayinitiatorf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000042.tmrelayteatserverf BEGIN
#define DDNAME       "3func.33000042.tmrelayteatserverf"
#define DDNUMB      (countT)0x33000042
#define IDFILE      (countT)0x92f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmRelayTeatServerF )/*1*/
if( pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
{
    RELAYiNFOtm
    socketC* psoP = (socketC*)pTaskP->c4 ;

    IFsCRATCH
    {
        swsWrapRefP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        cLeverPayloadP = tinP.monitor.idThread ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        stackC& stWrapRef = (stackC&)swsWrapRefP ;
        THREADmODE1rESTORE
        swsWrapRefP.ungrabF( tinP ) ;
    
        stackC stChannelInclude( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count4S ) ;
        stackC stChannelExclude( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count4S ) ;
    
        psoP->etherF( tinP , *tinP.pEtScratch ) ;
    
        ZE( boolT , bQuit ) ;
        ZE( countT , idAdamClient ) ;
        {
            ZE( soulC* , psWrap ) ;
            etThread( tinP , psWrap , TAG( TAGiDnULL ) ) ;
            if( psWrap )
            {
                SCOOPS
                psoP->readF( tinP , *psWrap ) ;
                if( POOP ) POOPR
                else       *psWrap >> idAdamClient ;
            }
            etThread( tinP , psWrap ) ;
            if( !idAdamClient ) bQuit = 1 ;
        }

        signC sgnDone_tmRelayServerWrapToAppF( tinP , TAG( TAGiDnULL ) ) ;
        etThread.osThreadF( tinP , countTC() , tmRelayServerWrapToAppF , &sgnDone_tmRelayServerWrapToAppF , flTHREADlAUNCH_null , 0 , (countT)&bQuit , (countT)&psoP , (countT)&stWrapRef , (countT)&stChannelInclude , (countT)&stChannelExclude , idAdamClient ) ;

        etThread.traceF( tinP , T("tmRelayTeatServerF: client is ")+TF2(idAdamClient,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        while( !ether && !bQuitP && !bQuit && !etThread )
        {
            ZE( soulC* , psWrap ) ;
            etThread( tinP , psWrap , TAG( TAGiDnULL ) ) ;
            if( psWrap )
            {
                {
                    SCOOPS
                    psoP->readF( tinP , *psWrap ) ;
                    static countT idInLath ;
                    countT idIn = 1 + incv02AM( idInLath ) ;
                    //CONoUTrAW3( "tmRelayTeatServerF: readF returned (" , idIn , ")\r\n" ) ;
                    if( POOP )
                    {
                        POOPR
                        etThread( tinP , psWrap ) ;
                        break ;
                    }
                }
    
                {
                    ZE( countT , idTypeTM ) ;
                    ZE( flagsT , flagsTM ) ;
                    ZE( countT , cbfTM ) ;
                    byteT* pbfTM = psWrap->pbFieldF( tinP , idTypeTM , flagsTM , cbfTM , ifcIDfIELDwRAP_TRADEmARK ) ; //U::BUG: STRINGS OF STROKES ARE NOW ENCODED
        
                    ZE( strokeS* , psttTM ) ;
                    if( pbfTM && cbfTM )
                    {
                        etThread.strDecodeF( tinP , psttTM , pbfTM ) ; ___( psttTM ) ;
                        etThread.strReplaceF( tinP , psttTM , 0 , ifcIDtYPEsTRrEPLACE_MAKEiMPORT , psttTM[ 2 ].idAdam ) ; ___( psttTM ) ;

                        //OStEXT( ostoSay , TUCK << 2 ) ;
                        //OStEXTAK( ostoSay , "tmRelayTeatServerF [psttTM]: \"" ) ;
                        //OStEXTA(  ostoSay , T(psttTM) ) ;
                        //OStEXTA(  ostoSay , "\"\r\n" ) ;
                        //CONoUTrAW( ostoSay ) ;
                    }

                    {
                        SCOOPS
                        __Z( psttTM ) ;
                        __( idTypeTM - ifcIDtYPEsOULiTEM_strokeSptr ) ;
                        __( tinP.pEtScratch->strCompareF( tinP , psttTM , T("IdeaFarm " "(tm)") ) ) ;
                        __( psWrap->cFieldF( tinP , ifcIDfIELDwRAP_IDpROTOCOL ) - ifcIDpROTOCOL_RELAYwRAP ) ;
                        __( psWrap->cFieldF( tinP , ifcIDfIELDwRAP_IDvERSION ) - 1 ) ; //idVersion
                        if( POOP )
                        {
                            tinP.pEther->traceF( tinP , T("tmRelayTeatServerF / wrapper contains garbage") ) ;
                            POOPRqUIET
                            bQuit = 1 ;
                        }
                    }
                    etThread.delF( tinP , psttTM ) ;
                }
    
                if( !bQuit )
                {
                    countT idType = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_IDtYPE ) ;
                    //CONoUTrAW3( "tmRelayTeatServerF [idType]: " , idType , "\r\n" ) ;
                    switch( idType )
                    {
                        case ifcIDtYPEwRAP_CHANNELiNCLUDEpUSH :
                        case ifcIDtYPEwRAP_CHANNELeXCLUDEpUSH :
                        {
                            countT* pczChannel = (countT*)psWrap->pbFieldF( tinP , countTC() , countTC() , countTC() , ifcIDfIELDwRAP_CHANNEL ) ;
                            ZE( count4S* , pc4c ) ;
                            etThread.newF( tinP , LF , pc4c ) ; ___( pc4c ) ;
                            if( pc4c )
                            {
                                countT*& pczTest   = *(countT**)&pc4c->c1 ;    
                                countT&  ccTestMax =  *(countT*)&pc4c->c2 ;
                                countT*& pcFilter  = *(countT**)&pc4c->c3 ;
                                countT&  ccFilter  =  *(countT*)&pc4c->c4 ;
        
                                countT cca = 1 + etThread.strBodyLengthF( tinP , pczChannel ) ;
                                etThread.newF( tinP , LF , pczTest , cca ) ; ___( pczTest ) ;
                                if( pczTest ) etThread.memCopyF( tinP , (byteT*)pczTest , (byteT*)pczChannel , cca * sizeof( countT ) ) ;
        
                                ccTestMax = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_CCtESTmAX ) ;
        
                                countT* pcFilterFrom = (countT*)psWrap->pbFieldF( tinP , countTC() , countTC() , countTC() , ifcIDfIELDwRAP_FILTER ) ;
                                ccFilter  = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_CCfILTER ) ;
                                etThread.newF( tinP , LF , pcFilter , ccFilter ) ; ___( pcFilter ) ;
                                if( pcFilter ) etThread.memCopyF( tinP , (byteT*)pcFilter , (byteT*)pcFilterFrom , ccFilter * sizeof( countT ) ) ;
        
                                stackC& stChannel = idType == ifcIDtYPEwRAP_CHANNELiNCLUDEpUSH ? stChannelInclude : stChannelExclude ;
                                stChannel << pc4c ;
                            }
                            break ;
                        }
                        case ifcIDtYPEwRAP_CHANNELiNCLUDEpOP :
                        {
                            break ;
                        }
                        case ifcIDtYPEwRAP_CHANNELiNCLUDEpOPaLL :
                        {
                            break ;
                        }
                        case ifcIDtYPEwRAP_QUIT : //OPTIONAL: CLIENTS ARE ASSUMED TO BE RUDE
                        {
                            bQuit = 1 ;
                            break ;
                        }
                        case ifcIDtYPEwRAP_GIFT :
                        {
                            countT* pczChannel = (countT*)psWrap->pbFieldF( tinP , countTC() , countTC() , countTC() , ifcIDfIELDwRAP_CHANNEL ) ;
        
                            ZE( boolT , bDebug ) ;
                            if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATED && pczChannel[ 2 ] == ifcIDaDAM_SECRETsERVICE && pczChannel[ 3 ] == ifcIDaDAM_CONSOLE && pczChannel[ 4 ] == ifcIDcHANNELfUNCTION_STROKEcONSOLE )
                                bDebug = 1 ;
        
                            if( bDebug ) { CONoUTrAW3( "teat read a secret wrap that contains " , (countT)*psWrap , " members\r\n" ) ; }
                            else
                            {
                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                //tinP.pEther->traceF( tinP , T("wrap from app for channel ")+T(pczChannel) ) ;
                                THREADmODE1rESTORE
                            }
        
                            if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATORrEGISTRATION ) { static countT idIn ; tinP.pEther->traceF( tinP , TF2(++idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" tmRelayTeatServerF: ifcIDtYPEwRAP_GIFT (mediator registration channel)") ) ; }
        
                            ZE( soulC* , psBag ) ;
                            etThread( tinP , psBag , TAG( TAGiDnULL ) ) ;
                            if( psBag )
                            {
                                GRABrELAYlISTS
                                idPortTimeC* pnRoot = stIdptOpenP ? (idPortTimeC*)&stIdptOpenP[ 1 ] : 0 ;
                                boolT bRoot = pnRoot && *pnRoot == idptP ;
                                boolT bDontHoldBreath = bRoot /*&& stIdptOpenP < 4*/ ; //IF bDontHoldBreath THEN THE ROOT WILL NOT EVER GET ITS OWN POP
                                UNGRABrELAYlISTS
            
                                relayC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , bRoot ? flRELAYpOP_UP : flRELAYpOP_DOWN , ifcIDtYPEbAG_WRAP ) ;
                                *psBag << *psWrap ;

                                //tinP.pEther->traceF( tinP , T("tmRelayTeatServerF: calling popIF [bRoot,bDontHoldBreath]:    ")+TF2(bRoot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(bDontHoldBreath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
            
                                if( bDontHoldBreath ) relayC::doWrapLocallyIfIF( tinP , etThread , RELAYiNFOaRGS , *psWrap , idptP ) ;
                                etThread( tinP , psBag ) ;
                            }
                            break ;
                        }
                        case ifcIDtYPEwRAP_QUERYrELAYrANK :
                        {
                            ZE( soulC* , psWrapo ) ;
                            etThread( tinP , psWrapo , TAG( TAGiDnULL ) ) ;
                            ZE( soulC* , psGift ) ;
                            etThread( tinP , psGift , TAG( TAGiDnULL ) ) ;
                            if( psGift && psWrapo )
                            {
                                GRABrELAYlISTS
                                countT idRank = stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                //CONoUTrAW( T("the requested idRank is ")+TF1(idRank)+T("\r\n") ) ;
                                if( stIdptOpenP )
                                {
                                    ZE( countT , ids ) ;
                                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    do
                                    {
                                        idPortTimeC& idpt = *(idPortTimeC*)&stIdptOpenP.downF( tinP , hDown ) ;
                                        timeS time = idpt ;
                                        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                        //CONoUTrAW( TF1(++ids)+T(": ")+TT(time.time1,time.time2)+T(" ")+TF1((countT)idpt)+T(" ")+TF1((nicNameC&)idpt)+T("\r\n") ) ;
                                        THREADmODE1rESTORE
                                    }
                                    while( !stIdptOpenP.third && ~hDown ) ;
                                }
                                UNGRABrELAYlISTS
                                *psGift << idRank ;
        
                                TN( tTM , "IdeaFarm " "(tm)" ) ;
                                *psWrapo << (strokeS*)tTM ;
                                *psWrapo << (countT)ifcIDpROTOCOL_RELAYwRAP ;
                                *psWrapo << (countT)1 ; // idVersion
                                *psWrapo << (countT)ifcIDtYPEwRAP_REPLYrELAYrANK ;
                                *psWrapo << *psGift ;
        
                                etThread.traceF( tinP , T("writing *psWrapo ifcIDtYPEwRAP_QUERYrELAYrANK") ) ;
                                {
                                    SCOOPS
                                    psoP->writeF( tinP , *psWrapo ) ;
                                    if( POOP )
                                    {
                                        POOPR
                                        bQuit = 1 ;
                                    }
                                }
                            }
                            etThread( tinP , psWrapo ) ;
                            etThread( tinP , psGift ) ;
                            break ;
                        }
                        case ifcIDtYPEwRAP_QUERYrELAYiDpORTtIMEc :
                        {
                            ZE( soulC* , psWrapo ) ;
                            etThread( tinP , psWrapo , TAG( TAGiDnULL ) ) ;
                            ZE( soulC* , psGift ) ;
                            etThread( tinP , psGift , TAG( TAGiDnULL ) ) ;
                            if( psGift && psWrapo )
                            {
                                idptP >> *psGift ;
        
                                TN( tTM , "IdeaFarm " "(tm)" ) ;
                                *psWrapo << (strokeS*)tTM ;
                                *psWrapo << (countT)ifcIDpROTOCOL_RELAYwRAP ;
                                *psWrapo << (countT)1 ; // idVersion
                                *psWrapo << (countT)ifcIDtYPEwRAP_REPLYrELAYiDpORTtIMEc ;
                                *psWrapo << *psGift ;
        
                                etThread.traceF( tinP , T("writing *psWrapo ifcIDtYPEwRAP_QUERYrELAYiDpORTtIMEc") ) ;
                                {
                                    SCOOPS
                                    psoP->writeF( tinP , *psWrapo ) ;
                                    if( POOP )
                                    {
                                        POOPR
                                        bQuit = 1 ;
                                    }
                                }
                            }
                            etThread( tinP , psWrapo ) ;
                            etThread( tinP , psGift ) ;
                            break ;
                        }
                        case ifcIDtYPEwRAP_QUERYrELAYiDpORTtIMEcaLLhOMES :
                        {
                            ZE( soulC* , psWrapo ) ;
                            etThread( tinP , psWrapo , TAG( TAGiDnULL ) ) ;
                            ZE( soulC* , psGift ) ;
                            etThread( tinP , psGift , TAG( TAGiDnULL ) ) ;
                            if( psGift && psWrapo )
                            {
                                GRABrELAYlISTS
                                *psGift << (countT)stIdptOpenP ;
                                if( stIdptOpenP )
                                {
                                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    do *(idPortTimeC*)&stIdptOpenP.downF( tinP , hDown ) >> *psGift ;
                                    while( !stIdptOpenP.third && ~hDown ) ;
                                }
                                UNGRABrELAYlISTS
        
                                TN( tTM , "IdeaFarm " "(tm)" ) ;
                                *psWrapo << (strokeS*)tTM ;
                                *psWrapo << (countT)ifcIDpROTOCOL_RELAYwRAP ;
                                *psWrapo << (countT)1 ; // idVersion
                                *psWrapo << (countT)ifcIDtYPEwRAP_REPLYrELAYiDpORTtIMEcaLLhOMES ;
                                *psWrapo << *psGift ;
        
                                etThread.traceF( tinP , T("writing *psWrapo ifcIDtYPEwRAP_QUERYrELAYiDpORTtIMEcaLLhOMES") ) ;
                                {
                                    SCOOPS
                                    psoP->writeF( tinP , *psWrapo ) ;
                                    if( POOP )
                                    {
                                        POOPR
                                        bQuit = 1 ;
                                    }
                                }
                            }
                            etThread( tinP , psWrapo ) ;
                            etThread( tinP , psGift ) ;
                            break ;
                        }
                    }
                }
    
                if( psWrap ) etThread( tinP , psWrap ) ; //MIGHT BE 0 IFF I CALLED relayC::doWrapLocallyIfIF
            }
        }
    
        if( etThread ) { ((const poopC&)etThread).chatterF( tinP , LF ) ; LOGrAW( "tmRelayTeatServerF: etThread is impotent so BLAMMO\r\n" ) ; BLAMMO ; } //NEEDED TO PRECLUDE DEADLOCK GRABBING swsWrapRefP
        swsWrapRefP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        bQuit = 1 ;
        {
            ZE( count2S* , pc2WrapRef ) ;
            etThread.newF( tinP , LF , pc2WrapRef ) ; ___( pc2WrapRef ) ; //U::LEAKS SOMETIMES
            if( pc2WrapRef )
            {
                pc2WrapRef->c1 = 0 ;
                pc2WrapRef->c2 = 1 ;
                stWrapRef << (countT)pc2WrapRef ;
            }
        }
        sgnDone_tmRelayServerWrapToAppF.waitF( tinP ) ;
    
        while( stWrapRef )
        {
            ZE( count2S* , pc2WrapRef ) ;
            stWrapRef >> *(countT*)&pc2WrapRef ;
    
            if( 1 == decv02AM( pc2WrapRef->c2 ) )
            {
                etThread( tinP , *(soulC**)&pc2WrapRef->c1 ) ;
                etThread.delF( tinP , pc2WrapRef ) ;
            }
        }
    
        {
            cLeverPayloadP = tinP.monitor.idThread ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            swsWrapRefP.freeF( tinP ) ;
            THREADmODE1rESTORE
        }
        swsWrapRefP.ungrabF( tinP ) ;
    
        DEL( psoP ) ;
    
        while( stChannelInclude )
        {
            ZE( count4S* , pc4c ) ;
            stChannelInclude >> pc4c ;
            etThread.delF( tinP , *(countT**)&pc4c->c1 ) ;
            etThread.delF( tinP , *(countT**)&pc4c->c3 ) ;
            etThread.delF( tinP , pc4c ) ;
        }
    
        while( stChannelExclude )
        {
            ZE( count4S* , pc4c ) ;
            stChannelExclude >> pc4c ;
            etThread.delF( tinP , *(countT**)&pc4c->c1 ) ;
            etThread.delF( tinP , *(countT**)&pc4c->c3 ) ;
            etThread.delF( tinP , pc4c ) ;
        }
    }
}
DONE( tmRelayTeatServerF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000042.tmrelayteatserverf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000043.tmrelayserverwraptoappf BEGIN
#define DDNAME       "3func.33000043.tmrelayserverwraptoappf"
#define DDNUMB      (countT)0x33000043
#define IDFILE      (countT)0x930


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmRelayServerWrapToAppF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
{
    boolT&        bQuitP               =        *(boolT*)pTaskP->c1 ;    
    socketC*&     psoP                 =     *(socketC**)pTaskP->c2 ;
    stackC&       stWrapRefP           =       *(stackC*)pTaskP->c3 ;
    stackC&       stChannelIncludeP    =       *(stackC*)pTaskP->c4 ;
    stackC&       stChannelExcludeP    =       *(stackC*)pTaskP->c5 ;
    countT        idAdamClient         =                 pTaskP->c6 ;

    while( !ether && !bQuitP && !etThread && !stWrapRefP.third )
    {
        stWrapRefP.waitF( tinP ) ;
        if( idAdamClient == ifcIDaDAM_CONSOLE )
            { tinP.pEther->traceF( tinP , T("tmRelayServerWrapToAppF: see a push for ifcIDaDAM_CONSOLE") ) ; }
        if( bQuitP ) break ;

        while( stWrapRefP )
        {
            ZE( count2S* , pc2WrapRef ) ;
            stWrapRefP >> *(countT*)&pc2WrapRef ;

            if( !bQuitP )
            {
                countT* pczChannel = (countT*)((soulC*)pc2WrapRef->c1)->pbFieldF( tinP , countTC() , countTC() , countTC() , ifcIDfIELDwRAP_CHANNEL ) ;
    
                //if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATORrEGISTRATION ) { CONoUTrAW( "tmRelayServerWrapToAppF: this push is on the mediator reg channel\r\n" ) ; } //U::

                boolT bWrite = 1 ;
                stChannelIncludeP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                if( stChannelIncludeP )
                {
                    bWrite = 0 ;
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    do
                    {
                        count4S*& pc4c = *(count4S**)&stChannelIncludeP.downF( tinP , hDown ) ;
                        countT*& pczTest   = *(countT**)&pc4c->c1 ;
                        countT   ccTestMax =             pc4c->c2 ;
                        countT*& pcFilter  = *(countT**)&pc4c->c3 ;
                        countT   ccFilter  =             pc4c->c4 ;
    
                        if( !etThread.strCompareF( tinP , pczChannel , pczTest , 0 , ccTestMax , pcFilter , ccFilter ) )
                        {
                            bWrite = 1 ;
                            break ;
                        }
                    }
                    while( !stChannelIncludeP.third && ~hDown ) ;
                }
                stChannelIncludeP.ungrabF( tinP ) ;
    
                if( bWrite )
                {
                    stChannelExcludeP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    if( stChannelExcludeP )
                    {
                        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        do
                        {
                            count4S*& pc4c = *(count4S**)&stChannelExcludeP.downF( tinP , hDown ) ;
                            countT*& pczTest   = *(countT**)&pc4c->c1 ;
                            countT   ccTestMax =             pc4c->c2 ;
                            countT*& pcFilter  = *(countT**)&pc4c->c3 ;
                            countT   ccFilter  =             pc4c->c4 ;
        
                            if( !etThread.strCompareF( tinP , pczChannel , pczTest , 0 , ccTestMax , pcFilter , ccFilter ) )
                            {
                                bWrite = 0 ;
                                break ;
                            }
                        }
                        while( !stChannelExcludeP.third && ~hDown ) ;
                    }
                    stChannelExcludeP.ungrabF( tinP ) ;
                }
    
                if( bWrite )
                {
                    //if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATORrEGISTRATION ) { CONoUTrAW( "tmRelayServerWrapToAppF: survived filters; writing to client\r\n" ) ; } //U::

                    //U::TO TRAP A BUG
                    //CONoUTrAW( "tmRelayServerWrapToAppF: trapping a bug\r\n" ) ;
                    {
                        soulC& sWrap = *(soulC*)pc2WrapRef->c1 ;
                        countT idType = sWrap.cFieldF( tinP , ifcIDfIELDwRAP_IDtYPE ) ;
                        if( idType == ifcIDtYPEwRAP_GIFT )
                        {
                            idPortTimeC idptOrigin = idPortTimeC::fieldF( tinP , sWrap , ifcIDfIELDwRAP_IDPToRIGIN ) ;
                        }
                    }

                    //etThread.traceF( tinP , T("writing soul") ) ;
                    scoopC scoop( tinP , LF , psoP->etherF( tinP ) ) ;
                    psoP->writeF( tinP , *(soulC*)pc2WrapRef->c1 ) ;
                    if( POOP )
                    {
                        POOPRqUIET
                        etThread.traceF( tinP , T("could not write soul") ) ;
                        bQuitP = 1 ;
                    }
                }
            }

            if( 1 == decv02AM( pc2WrapRef->c2 ) )
            {
                etThread( tinP , *(soulC**)&pc2WrapRef->c1 ) ;
                etThread.delF( tinP , pc2WrapRef ) ;
            }
        }
    }
}
DONE( tmRelayServerWrapToAppF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000043.tmrelayserverwraptoappf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000044.tmrelayteatacceptorf BEGIN
#define DDNAME       "3func.33000044.tmrelayteatacceptorf"
#define DDNUMB      (countT)0x33000044
#define IDFILE      (countT)0x931


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmRelayTeatAcceptorF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
{
    RELAYiNFOtm

    homeS& home = homeS::homeIF() ;
    idPortC& idpTeat = *(idPortC*)pTaskP->c4 ;

    socketC sListen( tinP , etThread , TAG( TAGiDnULL ) ) ;
    home.idpTeat = idPortC() ;
    (countT&)home.idpTeat = sListen.bindF( tinP ) ; //nn REMAINS 0 BECAUSE I AM ONLY TO BE USED BY CLIENTS ON THE LOCAL HOST
    sListen.listenF( tinP ) ;

    if( home.idpTeat )
    {
        while( !etThread && !bQuitP )
        {
            ZE( socketC* , pso ) ;
            TELL( "waiting for a client to connect" )
            nicNameC nnPeer ;
            ZE( countT , idPortPeer ) ;
            ZE( boolT , bRefuse ) ;
            sListen.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ;
            __( bRefuse ) ;
    
            TELL( "launching tmRelayTeatServerF" )
            if( !bQuitP && pso ) etThread.osThreadF( tinP , countTC() , tmRelayTeatServerF , 0 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , (countT)pso ) ;
            else                 { DEL( pso ) ; }
        }

        home.idpTeat = idPortC() ;
    }
    //CONoUTrAW7( "tit acceptor ending (ether,etThread.bQuitP): " , ether , " " , etThread , " " , bQuitP , "\r\n" ) ; //U::
    //LOGrAW7( "tit acceptor ending (ether,etThread.bQuitP): " , ether , " " , etThread , " " , bQuitP , "\r\n" ) ; //U::
}
DONE( tmRelayTeatAcceptorF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000044.tmrelayteatacceptorf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000045.tmtimenowf BEGIN
#define DDNAME       "3func.33000045.tmtimenowf"
#define DDNUMB      (countT)0x33000045
#define IDFILE      (countT)0x932


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmTimeNowF )/*1*/

//tinP.pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
TELL( "setting up" )
static countT cInstancesI ;
if( !( cInstancesI ++ ) )
{
    __( tinP.monitor.idThread - ifcIDtHREADlOW_tmTimeNowF ) ; //COMMENT THIS OUT WHEN USING etherWhereF EARLY IN adamMainF
    //CONJ: idThread MUST BE ENFORCED BECAUSE THE LOW THREADS ARE MONITORED AND THE idThread VALUES ARE USED TO INDEX INTO AN ARRAY
    while( !ether && !etThread )
    {
        TELL( "working" )
        tinP.pAdamGlobal1->_thirdC_.timeNow.time2 = tinP.pAdamGlobal1->_thirdC_.timeNow.time1 = 0 ;
        etThread.osTimeNowF( tinP , tinP.pAdamGlobal1->_thirdC_.timeNow.time1 , tinP.pAdamGlobal1->_thirdC_.timeNow.time2 ) ;
        TELL( "sleeping for a tock" )
        {
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            ++ s ; etThread.osSleepF( tinP , TOCK ) ;
        }
    }
    
    //THIS IS A KLUGE.  IF THERE IS A DEADLOCK, LETS DEBUG IT
    //TELL( "U::sleeping to avoid deadlock trying to grab the buoyTinC ahead of me at the anchor" )
    //{
    //    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    //    ++ s ; etThread.osSleepF( tinP , TOCK * 2 ) ;
    //}
    
    TELL( "tmTimeNowF: cleaning up" )
}

//tinP.pc Utility[ 0 ] -- ; //U::TO FIND A BUG
DONE( tmTimeNowF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000045.tmtimenowf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000047.gensoilwordloadsf BEGIN
#define DDNAME       "3func.33000047.gensoilwordloadsf"
#define DDNUMB      (countT)0x33000047
#define IDFILE      (countT)0x933


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

#include "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\1snip.005001c.genSoixlOldWordProtos_etherC_1.h"

/*1*/voidT genSoixlOldWordLoadsF( tinS& tinP , strokeS*& _psttLeverSoixlOldApi , switchC*& _pSwSoixlOldApi )/*1*/
{
    #include "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\1snip.005001c.genSoixlOldWordLoads_etherC_1.h"
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000047.gensoilwordloadsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000048.netc_subtract_soulc_f BEGIN
#define DDNAME       "3func.33000048.netc_subtract_soulc_f"
#define DDNUMB      (countT)0x33000048
#define IDFILE      (countT)0x934


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/countT netC_subtract_soulC_F( tinS& tinP , countT& pEtherP , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
        if( !c1P || !c2P ) return 0 ;
    }

    if( pEtherP ) ;

    soulC& s1 = *(soulC*)c1P ;
    soulC& s2 = *(soulC*)c2P ;

    ZE( countT , idTypeGram1 ) ;
    ZE( boolT  , flagsGram1 ) ;
    ZE( countT , cbIdGram1 ) ;
    const byteT* pbIdGram1 = s1.pbFieldF( tinP , idTypeGram1 , flagsGram1 , cbIdGram1 , 3 ) ;

    ZE( countT , idTypeGram2 ) ;
    ZE( boolT  , flagsGram2 ) ;
    ZE( countT , cbIdGram2 ) ;
    const byteT* pbIdGram2 = s2.pbFieldF( tinP , idTypeGram2 , flagsGram2 , cbIdGram2 , 3 ) ;

    ZE( countT , sgn ) ;
    if( cbIdGram1 == sizeof( countT ) && cbIdGram2 == sizeof( countT ) && flagsGram1 & flSOULiTEM_MADEoFcOUNToBJECTS && flagsGram2 & flSOULiTEM_MADEoFcOUNToBJECTS )
    {
        sgn = *(countT*)pbIdGram1 - *(countT*)pbIdGram2 ;
    }

    if( c3P ) ;
    return sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000048.netc_subtract_soulc_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000049.jobhandlerf BEGIN
#define DDNAME       "3func.33000049.jobhandlerf"
#define DDNUMB      (countT)0x33000049
#define IDFILE      (countT)0x935


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/voidT jobHandlerF( tinS& tinP , etherC& ether , etherC& etThread , socketC*& pso , const countT idChatSessionP , countT cArgP , const countT idAdamHandlingP )/*1*/
{
    __Z( pso ) ; //IN THIS DEFINITION, AS IN ALL CHAT HANDLERS, TESTS RELATED TO DOWNWARD CHAT USE etScratch; TESTS RELATED TO UPWARD CHAT USE etThread
    __Z( idAdamHandlingP ) ;
    __Z( cArgP ) ;

    IFsCRATCH
    {
        SCOOPS
        //etherC::ifcSayIF( T("jobHandlerF/")+TF1(idAdamHandlingP)+T("/")+TF1(idChatSessionP)+T("/+") , flSAY_APPEND | flSAY_LOG ) ;
        if( !ether && !etThread )
        {
            count3S& c3p_jobHandler = *(count3S*)cArgP ;
            __( !c3p_jobHandler.c2 ) ;
            __( !c3p_jobHandler.c3 ) ;
    
            if( !ether && !etThread && !POOP )
            {
                countT          cAppArg        =                  c3p_jobHandler.c1 ;
                jobFillCourseFT jobFillCourseF = (jobFillCourseFT)c3p_jobHandler.c2 ;
                jobHearOrderFT  jobHearOrderF  =  (jobHearOrderFT)c3p_jobHandler.c3 ;
    
                soulC sJob( tinP , TAG( TAGiDnULL ) ) ;
                pso->readF( tinP , sJob ) ;
    
                //__( (countT)sJob - 5 ) ;
                //etThread.strokeF( tinP , T("jobHandlerF/")+T(*tinP.pEtScratch?"impotent":"aok")+T("/tested number of items in sJob\r\n") ) ; //U:
    
                if( !etThread && sJob.cFieldF( tinP ) == ifcIDcMDsESSION_JOB )
                {
                    countT idAdam    = sJob.cFieldF( tinP , 2 ) ;
                    boolT& bAccepted = sJob.cFieldF( tinP , 4 ) ;
    
                    if( !bAccepted ) // JOB ACCEPTOR
                    {
                        __( (countT)sJob - 5 ) ;
                        __( idAdam - idAdamHandlingP ) ; // TO FACILITATE SECURITY AND SIMPLIFY DESIGN, AN ADAM DEF WILL ONLY ACCEPT JOBS FOR ITS OWN ADAM; IF SUPERVISORY LAYERS ARE DESIRED, THE SAME ADAM DEF MUST DEFINE THE WORKER FUNCTION AND ALL SUPERVISORY FUNCTIONS
                        bAccepted = 1 ;
    
                        nicNameC nicNameHint ;
                        {
                            ZE( countT , idType ) ;
                            ZE( flagsT , flags ) ;
                            ZE( countT , cbNicName ) ;
                            const byteT* const pbNicName = sJob.pbFieldF( tinP , idType , flags , cbNicName , 3 ) ;
                            __( idType - ifcIDtYPEsOULiTEM_nicNameC ) ;
                            __( flags - ( flSOULiTEM_MADEoFcOUNToBJECTS | flSOULiTEM_INCREASINGiNsIGNIFICANCE ) ) ;
                            __( cbNicName - 1 - processGlobal1I.cb_nicNameC_ ) ; // THE "1" CORRESPONDS TO THE flags2 BYTE
                            __Z( pbNicName ) ;
    
                            tinP.pEtScratch->memCopyF( tinP , (byteT*)&nicNameHint , pbNicName + 1 , processGlobal1I.cb_nicNameC_ ) ;
                        }
    
                        if( !POOP )
                        {
                            soulC sRelay( tinP , TAG( TAGiDnULL ) ) ;
                            etThread.ifcChatRelayPackageF( tinP , sRelay , sJob , idAdamHandlingP , TF1(idAdamHandlingP)+T("/ifcChatF/jobHandlerF/acceptor") , 1 , 0 , nicNameHint ) ;
    
                            socketC soUp( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                            soUp.connectF( tinP ) ;
                            soUp.writeF( tinP , sRelay ) ;
    
                            signC sgnReadTested( tinP , TAG( TAGiDnULL ) ) ;
                            signC sgnDone_tmRelayChatReplies( tinP , TAG( TAGiDnULL ) ) ;
                            etThread.osThreadF( tinP , countTC() , tmRelayChatRepliesF , &sgnDone_tmRelayChatReplies , flTHREADlAUNCH_null , 0 , (countT)pso , (countT)&soUp , (countT)&sgnReadTested , 0 ) ;
                            if( !etThread ) sgnReadTested.waitF( tinP ) ;
    
                            while( !POOP && !etThread )
                            {
                                soulC sOrder( tinP , TAG( TAGiDnULL ) ) ;
                                pso->readF( tinP , sOrder ) ;
    
                                if( !POOP && sOrder ) soUp.writeF( tinP , sOrder ) ;
                                else                  break ;
                            }
                            if( POOP ) soUp.stopWaitingF( tinP ) ; // WAD WAC: SERVER (UPWARD) IS NEVER RUDE; CLIENT (DOWNWARD) IS ALWAYS RUDE; SO THIS SOCKET CANCEL IS NOT LOGGED
                            sgnDone_tmRelayChatReplies.waitF( tinP ) ;
                        }
                    }
                    else // JOB DOER
                    {
                        __( (countT)sJob - 5 ) ;
    
                        ZE( countT , idCmd ) ;
                        sJob >> idCmd ;
                        __( idCmd - ifcIDcMDsESSION_JOB ) ;
    
                        ZE( countT , idAdam ) ;
                        sJob >> idAdam ;
    
                        nicNameC nicNameHint ;
                        nicNameHint << sJob ;
    
                        ZE( boolT  , bAccepted ) ;
                        sJob >> bAccepted ;
                        __Z( bAccepted ) ;
    
                        soulC sOrder( tinP , TAG( TAGiDnULL ) ) ;
                        sJob >> sOrder ;
    
                        if( !POOP )
                        {
                            count8S c8arg ;
                            signC sgnDone_tmMakeTrays( tinP , TAG( TAGiDnULL ) ) ;
                            etThread.osThreadF( tinP , countTC() , tmMakeTraysF , &sgnDone_tmMakeTrays , flTHREADlAUNCH_null , 0 , (countT)pso , (countT)&sOrder , idAdam , (countT)&cAppArg , (countT)&c8arg , (countT)jobFillCourseF , idChatSessionP ) ;
    
                            while( !POOP && !etThread )
                            {
                                soulC sOrder( tinP , TAG( TAGiDnULL ) ) ;
                                pso->readF( tinP , sOrder ) ;
    
                                soulC sNull( tinP , TAG( TAGiDnULL ) ) ;
                                soulC& sUse = POOP ? sNull : sOrder ;
                                (*jobHearOrderF)( tinP , ether , etThread , idAdam , idChatSessionP , sUse , cAppArg , c8arg ) ;
                                if( !sUse ) break ;
                            }
                            sgnDone_tmMakeTrays.waitF( tinP ) ;
                        }
                    }
                }
            }
        }
        //etherC::ifcSayIF( T("jobHandlerF/")+TF1(idAdamHandlingP)+T("/")+TF1(idChatSessionP)+T("/-") , flSAY_APPEND | flSAY_LOG ) ;
        if( POOP ) POOPR
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000049.jobhandlerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300004a.jobfillcoursedfltf BEGIN
#define DDNAME       "3func.3300004a.jobfillcoursedfltf"
#define DDNUMB      (countT)0x3300004a
#define IDFILE      (countT)0x936


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/voidT jobFillCourseDfltF( tinS& tinP , etherC& ether , etherC& etThread , soulC& sDataP , soulC& sNotesTextP , soulC& sNotesDataP , const countT idCourseP , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )/*1*/
{
    __( idAdamP - processGlobal1I.idAdamRoot ) ;

    switch( idCourseP )
    {
        case 1  : { sDataP << (countT)0x12344321 ; break ; }
    }

    if( cArgP && c8argP.c1 && sOrderP && sNotesTextP && sNotesDataP && ether && etThread && idChatSessionP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300004a.jobfillcoursedfltf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300004b.jobhearorderdfltf BEGIN
#define DDNAME       "3func.3300004b.jobhearorderdfltf"
#define DDNUMB      (countT)0x3300004b
#define IDFILE      (countT)0x937


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/voidT jobHearOrderDfltF( tinS& tinP , etherC& ether , etherC& etThread , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )/*1*/
{
    __( idAdamP - processGlobal1I.idAdamRoot ) ;

    if( cArgP && c8argP.c1 && sOrderP && ether && etThread && idChatSessionP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300004b.jobhearorderdfltf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300004c.tmcchatf BEGIN
#define DDNAME       "3func.3300004c.tmcchatf"
#define DDNUMB      (countT)0x3300004c
#define IDFILE      (countT)0x938


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/TASKdRIVENsERVER( tmcChatF )/*1*/
if( jobP.cArg )
{
    TELL( "setting up" )
    count4S& c4p_tmcChat = *(count4S*)jobP.cArg ;
    if( c4p_tmcChat.c1 && c4p_tmcChat.c3 && c4p_tmcChat.c4 )
    {
        chatHandlerFT chatHandlerF   = (chatHandlerFT)c4p_tmcChat.c1 ;
        countT        cArg           =                c4p_tmcChat.c2 ;
        countT        idAdamHandling =                c4p_tmcChat.c3 ;
        countT&       cSessions      =      *(countT*)c4p_tmcChat.c4 ;

        static countT idChatSessionLast ;
        static grabC grab_idChatSessionLast( tinP , TAG( TAGiDnULL ) ) ;
        TELL( "grabbing grab_idChatSessionLast" )
        grab_idChatSessionLast.grabF( tinP , TAG( TAGiDnULL ) ) ;
        countT idChatSession = ++ idChatSessionLast ;
        grab_idChatSessionLast.ungrabF( tinP ) ;

        TELL( "calling chat handler" )
        //etherC::ifcSayIF( TF1(idAdamHandling)+T(" ")+TF1(tinP.osPid)+T(" ++cSessions:")+TF1(++cSessions) , flSAY_APPEND | flSAY_LOG ) ;
        (*chatHandlerF)( tinP , ether , etThread , psoP , idChatSession , cArg , idAdamHandling ) ;
        //etherC::ifcSayIF( TF1(idAdamHandling)+T(" ")+TF1(tinP.osPid)+T(" --cSessions:")+TF1(--cSessions) , flSAY_APPEND | flSAY_LOG ) ;

        TELL( "reading a countT that will never arrive, so that client can disconnect" )
        ZE( countT , cFoo ) ;
        SCOOPS
        psoP->readF( tinP , (byteT*)&cFoo , sizeof cFoo , flSOCKETcrEAD_STILLhUNGRYiSoK ) ; // psoP WILL BE NULL IF, FOR EXAMPLE, THE CLIENT DID NOT START THE SESSION BY CORRECTLY SWITCHING PORTS; THAT WOULD CAUSE AN EARLY IMPOTENCE, WHICH WOULD PREVENT THE acceptF FROM RETURNING A NONZE psoP
        POOPR
    }
    TELL( "tmcChatF: cleaning up" )
}
DONEdRIVENsERVER( tmcChatF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300004c.tmcchatf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300004d.validatef BEGIN
#define DDNAME       "3func.3300004d.validatef"
#define DDNUMB      (countT)0x3300004d
#define IDFILE      (countT)0x939


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/voidT validateF( tinS& tinP , etherC& etThread , switchC& swc2P , countT& idProcessOldP )/*1*/
{
    //ASSUME: CALLER HAS SERLIALIZED ON b_idProcessOld, SO IS SERIALIZED ON THE TWO SWITCHES

    IFsCRATCH
    {
        stackC stIdProcessGone( tinP , etThread , TAG( TAGiDnULL ) ) ;
        countT cFlavors = swc2P.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            idProcessOldP = swc2P.leverF( tinP , idf ) ;
            count2S* pc2cp = (count2S*)(countT)swc2P ;
    
            ZE( boolT , bFail ) ;
            {
                if( !pc2cp || !pc2cp->c1 || !pc2cp->c2 ) bFail = 1 ;
                else
                {
                    if( POOP )
                    {
                        POOPR
                        bFail |= 1 ;
                    }
                }
            }
    
            if( bFail ) stIdProcessGone << idProcessOldP ;
        }
    
        while( !etThread && stIdProcessGone )
        {
            ZE( countT , idp ) ;
            stIdProcessGone >> idp ;
            idProcessOldP = idp ;
            count2S*& pc2cp = (count2S*&)(countT&)swc2P ;
            etThread.delF( tinP , pc2cp ) ;
            swc2P.freeF( tinP ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300004d.validatef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300004e.cleanfilenamef BEGIN
#define DDNAME       "3func.3300004e.cleanfilenamef"
#define DDNUMB      (countT)0x3300004e
#define IDFILE      (countT)0x93a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/voidT cleanFileNameF( tinS& tinP , etherC& etThread , textC& tP )/*1*/
{
    strokeS stts('/') ;
    while( 1 == etThread.strIdF( tinP , stts , tP ) )
    {
        ZE( strokeS* , psttw ) ;
        countT idf = 2 ;
        ZE( countT , idl ) ;
        etThread.strSubstringF( tinP , psttw , idf , idl , tP ) ; ___( psttw ) ;
        tP = T(psttw) ;
        etThread.delF( tinP , psttw ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300004e.cleanfilenamef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300004f.pbcbf BEGIN
#define DDNAME       "3func.3300004f.pbcbf"
#define DDNUMB      (countT)0x3300004f
#define IDFILE      (countT)0x93b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/voidT pbcbF( tinS& tinP , etherC& etThread , byteT*& pbP , countT& cbP , strokeS* psttNameP , strokeS*& psttLeverP , switchC& swImageP )/*1*/
{
    _IO_
    scoopC scoop( tinP , LF , etThread ) ;
    IFsCRATCH
    {
        swImageP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        psttLeverP = psttNameP ;
        count2S*& pc2pbcb = *(count2S**)&(countT&)swImageP ;
        if( !pc2pbcb )
        {
            etThread.newF( tinP , LF , pc2pbcb ) ; ___( pc2pbcb ) ;
            if( pc2pbcb )
            {
                SCOOPS
                handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                ZE( countT , idr ) ;
                ZE( infoFileS* , pInfo ) ;
                tinP.pEtScratch->fileOpenF( tinP , handle , idr , T("///ideafarm/ephemeral/domains/com/ideafarm/ftp/public/")+T(psttNameP) , ifcOPENaCCESS_R , ifcOPENsHARE_WR , flOPENdETAILS_FAIL , ifcOPENhOW_nFeO , flFILEaTTR_null , 0 , 1 ) ;
                tinP.pEtScratch->diskFileQueryF( tinP , pInfo , handle ) ; ___( pInfo ) ;
                if( pInfo )
                {
                    pc2pbcb->c2 = pInfo->cbUsed ;
                    etThread.newF( tinP , LF , *(byteT**)&pc2pbcb->c1 , pc2pbcb->c2 + 1 ) ; ___( pbP ) ;
                    countT cba = pc2pbcb->c2 ;
                    tinP.pEtScratch->fileReadF( tinP , (byteT*)pc2pbcb->c1 , cba , handle ) ;
                    ((byteT*)pc2pbcb->c1)[ cba ] = 0 ;
                }
                DEL( pInfo ) ;
                if( POOP ) POOPR
            }
        }
    
        __Z( pc2pbcb ) ;
        if( pc2pbcb )
        {
            pbP = (byteT*)pc2pbcb->c1 ;
            cbP =         pc2pbcb->c2 ;
        }
        swImageP.ungrabF( tinP ) ;
        __Z( pbP ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300004f.pbcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000050.ungrabf BEGIN
#define DDNAME       "3func.33000050.ungrabf"
#define DDNUMB      (countT)0x33000050
#define IDFILE      (countT)0x93c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/voidT ungrabF( tinS& tinP , boolT& bGrabbedP , countT& idDesireGrabberP )/*1*/
{
    idDesireGrabberP = 0 ;
    if( 1 != setIfEqualsAM( bGrabbedP , 0 , 1 ) ) { BLAMMO ; }
    if( tinP.fingerprint ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000050.ungrabf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000051.postmanglecodef BEGIN
#define DDNAME       "3func.33000051.postmanglecodef"
#define DDNUMB      (countT)0x33000051
#define IDFILE      (countT)0x93d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

struct postPostS
{
    osTextT*    post1 ;
    osTextT*    post2 ;
}
;

const postPostS postPostMangle[] =
{
    #include "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\1snip.5100050a.genMangleTable.h"
}
;

/*1*/const osTextT* _export postMangleF( tinS& tinP , const osTextT* postOldClassNameIP )/*1*/
{
    _IO_
    countT cRows = sizeof postPostMangle / sizeof postPostMangle[ 0 ] ;
    ZE( countT , off ) ;
    while( off < cRows && thirdC::c_strcmpIF( tinP , postOldClassNameIP , postPostMangle[ off ].post2 ) ) off ++ ;
    return off < cRows ? postPostMangle[ off ].post1 : 0 ;
}

/*1*/const osTextT* _export postUnmangleF( tinS& tinP , const osTextT* postMangleP )/*1*/
{
    _IO_
    countT cRows = sizeof postPostMangle / sizeof postPostMangle[ 0 ] ;
    ZE( countT , off ) ;
    while( off < cRows && thirdC::c_strcmpIF( tinP , postMangleP , postPostMangle[ off ].post1 ) ) off ++ ;
    return off < cRows ? postPostMangle[ off ].post2 : 0 ;
}

countT _export costUnmangleMaxF( tinS& tinP )
{
    static countT costMax ;
    if( !costMax )
    {
        countT cRows = sizeof postPostMangle / sizeof postPostMangle[ 0 ] ;
        for( countT off = 0 ; off < cRows ; off ++ )
        {
            countT costUnmangle = thirdC::c_strlenIF( tinP , postPostMangle[ off ].post2 ) ;
            if( costMax < costUnmangle ) costMax = costUnmangle ;
        }
    }
    return costMax ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000051.postmanglecodef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000052.cbitssetf BEGIN
#define DDNAME       "3func.33000052.cbitssetf"
#define DDNUMB      (countT)0x33000052
#define IDFILE      (countT)0x93e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
no overhead code, for max speed
*/
/**/

/*1*/countT _export cBitsSetF( tinS& tinP , const byteT* pbP , countT cbP )/*1*/
{
    _IO_

    ZE( countT , cBits ) ;
    while( cbP )
    {
        if( cbP >= sizeof( countT ) )
        {
            countT vv = *(countT*)pbP ;
            while( vv )
            {
                if( vv & 1 ) cBits ++ ;
                vv >>= 1 ;
            }

            pbP += sizeof( countT ) ;
            cbP -= sizeof( countT ) ;
        }
        else
        {
            byteT vv = *pbP ;
            while( vv )
            {
                if( vv & 1 ) cBits ++ ;
                vv >>= 1 ;
            }

            pbP ++ ;
            cbP -- ;
        }
    }

    return cBits ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000052.cbitssetf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000053.cbfullsetf BEGIN
#define DDNAME       "3func.33000053.cbfullsetf"
#define DDNUMB      (countT)0x33000053
#define IDFILE      (countT)0x93f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT cbFullSetF( tinS& tinP , const byteT* pbP , const countT cbP )/*1*/
{
    _IO_
    const countT bpc = sizeof( countT ) * SB ; // "bpc": "bits per countT"
    flagsT pFlags[ 0x100 / bpc ] ;
    thirdC::c_memsetIF( tinP , (byteT*)pFlags , sizeof pFlags , 0xff ) ;

    ZE( countT , off ) ;
    for( off = 0 ; off < cbP ; off ++ )
    {
        pFlags[ pbP[ off ] / bpc ] &= ~( 1 << pbP[ off ] % bpc ) ;

        if( bIsZeF( (byteT*)pFlags , sizeof pFlags ) ) break ;
    }
    return 1 + off ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000053.cbfullsetf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000054.biszef BEGIN
#define DDNAME       "3func.33000054.biszef"
#define DDNUMB      (countT)0x33000054
#define IDFILE      (countT)0x940


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/boolT bIsZeF( const byteT* pbP , countT cbP )/*1*/
{
    boolT bZe = 1 ;
    while( cbP -- )
    {
        if( *( pbP ++ ) )
        {
            bZe = 0 ;
            break ;
        }
    }

    return bZe ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000054.biszef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000055.tmkillsocketf BEGIN
#define DDNAME       "3func.33000055.tmkillsocketf"
#define DDNUMB      (countT)0x33000055
#define IDFILE      (countT)0x941


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmKillSocketF )/*1*/

//tinP.pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
if( pTaskP )
{
    TELL( "working" )
    boolT& bQuitKillSocket = tinP.pAdamGlobal1->_thirdC_.bQuitKillSocket ;
    {
        countT& cLever = tinP.pAdamGlobal1->_thirdC_.cLever_pSwKillSocket ;
        switchC& swKillSocket = *tinP.pAdamGlobal1->_thirdC_.pSwKillSocket ;
    
        //__( tinP.monitor.idThread - ifcIDtHREADlOW_tmKillSocketF ) ;
        while( !etThread && !bQuitKillSocket )
        {
            ZE( countT , timeN1 ) ;
            ZE( sCountT , timeN2 ) ;
            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;

            swKillSocket.grabF( tinP , TAG( TAGiDnULL ) ) ;
            countT cFlavors = swKillSocket.cFlavorsF( tinP ) ;
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            {
                cLever = swKillSocket.leverF( tinP , idf ) ;
                killSocketS* pks = (killSocketS*)&(countT&)swKillSocket ;
                if( pks )
                {
                    countT  te1 = pks->timeExpire1 ;
                    sCountT te2 = pks->timeExpire2 ;
                    etThread.osTimeSubtractF( tinP , te1 , te2 , timeN1 , timeN2 ) ;
                    if( te2 < 0 )
                    {
                        handleC& hDoomed = *(handleC*)cLever ;
                        //CONoUTrAW( "TIMEOUT\r\n" ) ;
                        hDoomed.closeIfF() ;
                    }
                }
            }
            swKillSocket.ungrabF( tinP ) ;

            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            ++ s ; etThread.osSleepF( tinP , TUCK * 0x20 ) ;
        }
    }
    bQuitKillSocket = 0 ;
}

//tinP.pc Utility[ 0 ] -- ; //U::TO FIND A BUG
DONE( tmKillSocketF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000055.tmkillsocketf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000056.tmkillzombief BEGIN
#define DDNAME       "3func.33000056.tmkillzombief"
#define DDNUMB      (countT)0x33000056
#define IDFILE      (countT)0x942


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmKillZombieF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && ( pTaskP->c4 || pTaskP->c5 ) )
{
    TELL( "working" )
    handleC& handle  = *(handleC*)pTaskP->c1 ;
    signC&   sgnDone =   *(signC*)pTaskP->c2 ;
    boolT&   bKilled =   *(boolT*)pTaskP->c3 ;
    countT   time1   =            pTaskP->c4 ;
    sCountT  time2   =            pTaskP->c5 ;

    //CONoUTrAW3( "connect time1 limit: " , time1 , "\r\n" ) ; //U::

    IFsCRATCH
    {
        SCOOPS
        thirdC& thScratch = *tinP.pEtScratch ;
    
        if( !thScratch.s_bCanWriteF( tinP , handle , time1 , time2 ) )
        {
            //CONoUTrAW("tmKillZombieF: TIMEOUT\r\n") ;
            //CONoUTrAW3( "tmKillZombieF killing after time " , time1 , "\r\n" ) ; //U::
            bKilled = 1 ;
            thScratch.s_cancelF( tinP , handle ) ;
        }
        if( POOP ) POOPR
    }

    sgnDone.giveF( tinP ) ;
    TELL( "tmKillZombieF: cleaning up" )
}

DONE( tmKillZombieF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000056.tmkillzombief END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000057.valueinf BEGIN
#define DDNAME       "3func.33000057.valueinf"
#define DDNUMB      (countT)0x33000057
#define IDFILE      (countT)0x943


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/countT valueInF( const byteT* const pbP , countT& offbiP , const countT cBitsP )/*1*/
{
    count2S vf = count2RefF( pbP , offbiP ) ; //"f":"from"
    countT cBitShift = offbiP % SB ;

    countT value = !cBitShift ? vf.c1 : vf.c1 >> cBitShift | vf.c2 << sizeof( countT ) * SB - cBitShift ;

    countT cBitsClr = sizeof( countT ) * SB - cBitsP ;
    if( cBitsClr )
    {
        value <<= cBitsClr ;
        value >>= cBitsClr ;
    }

    offbiP += cBitsP ;
    return value ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000057.valueinf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000058.valuef BEGIN
#define DDNAME       "3func.33000058.valuef"
#define DDNUMB      (countT)0x33000058
#define IDFILE      (countT)0x944


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/count2S valueF( const countT offboP , countT& offboAfterP , const countT valueP , const countT cBitsP )/*1*/
{
    offboAfterP = offboP + cBitsP ;

    countT cBitShift = offboP % SB ;
    return !cBitShift ? count2S( valueP , 0 ) : count2S( valueP << cBitShift , valueP >> ( sizeof( countT ) * SB - cBitShift ) ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000058.valuef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000059.count2reff BEGIN
#define DDNAME       "3func.33000059.count2reff"
#define DDNUMB      (countT)0x33000059
#define IDFILE      (countT)0x945


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/count2S& count2RefF( const byteT* const pbP , const countT offboP )/*1*/
{
    return *(count2S*)&pbP[ offboP / SB ] ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000059.count2reff END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300005a.tmanimatesadamsonpaperf BEGIN
#define DDNAME       "3func.3300005a.tmanimatesadamsonpaperf"
#define DDNUMB      (countT)0x3300005a
#define IDFILE      (countT)0x946


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
my main job is to animate
i also poll the joysticks
*/
/**/

#define MSsLEEPmIN 1
//#define MSsLEEPmIN 8

/*1*/TASK( tmAnimateSadamsOnPaperF )/*1*/
if( pTaskP )
{
    thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_LAZIEST ) ;

    IFsCRATCH
    {
        SCOOPS

        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        countT pcNotes[ 5 ] = { 1 , 2 , 0 , 0 , 0 } ;
        ZE( countT , idCycle ) ;
        ZE( countT , timeL1 ) ;
        ZE( sCountT , timeL2 ) ;
        etThread.osTimeNowF( tinP , timeL1 , timeL2 ) ;
        TN( tcr , "\r\n" ) ;
        TN( tb , " " ) ;
        countT cyclesPerSleep = 1 ;
        countT msPowerBelow = 0x20 ;
        countT msSleep = 0x40 ; //NOT ALLOWED TO GO BELOW 8
        countT msPowerAbove = 0x80 ;
        countT bJump = 1 ; // 0=SINGLEsTEP 1=POWERoF2
        countT timeTarget1 = TOCK << 0 ;
        ZE( boolT , bLathUp ) ;
        ZE( boolT , bLathUpLag ) ;
        countT msStep = msPowerAbove >> 4 ;
        ZE( sCountT , timeTarget2 ) ;
        while( !( F(paperOldC::flagsModeIF( tinP )) & flPAPERmODEi_ANIMATIONtHREADfIRED ) )
        {
            if( !( ++ idCycle ) ) ++ idCycle ;
            if( !( ++ pcNotes[ 2 ] ) ) ++ pcNotes[ 3 ] ;

#if defined( NEVERdEFINED )
            //JOYSTICK IS NORMALLY NOT POLLED WHEN CONSOLE IS NOT ACTIVE (HENCE NOT VISIBLE); THIS IS TO MINIMIZE CPU LOAD WHEN OPERATOR IS NOT INTERACTING WITH CONSOLE
            //SPECIAL APPLICATIONS SUCH AS SCREEN CAPTURE CAN SET flPAPERbACKmODE_POLLjOYeVENwHENcONSOLEhIDDEN TEMPORARILY

            backOldC::freshJoyIfIF( tinP , etThread ) ;
            
            {
                windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
                if( pRootI )
                {
                    if( !pRootI->backAbsentF() )
                    {
                        //LOGrAW3( "back is reportedly not absent [idCycle]: " , idCycle , "\r\n" ) ;

                        if( !( idCycle % 0x20 ) )
                        {
                            ZE( countT , timeE1 ) ; //U::MOVE ALL OF THIS ADJUSTMENT LOGIC INTO BASE LIBRARY
                            ZE( sCountT , timeE2 ) ;
                            etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                            etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeL1 , timeL2 ) ;
            
                            if( timeE1 < timeTarget1 )
                            {
                                if( !bLathUp && bJump && idCycle != 0x20 ) bJump = 0 ;
            
                                if( cyclesPerSleep > 1 ) cyclesPerSleep >>= 1 ;
                                else
                                {
                                    if( !bJump && !bLathUp && bLathUpLag && msStep > 1 ) msStep >>= 1 ;
            
                                    if( !bJump ) msSleep += msStep ;
                                    else         msSleep = msPowerAbove ;
                
                                    if( msSleep == msPowerAbove )
                                    {
                                        msPowerBelow <<= 1 ;
                                        msPowerAbove <<= 1 ;
                                        msStep = msPowerAbove >> 4 ;
                
                                        if( bLathUp && !bJump ) bJump = 1 ;
                                    }
                                }
            
                                bLathUpLag = bLathUp ;
                                if( !bLathUp ) bLathUp = 1 ;
                                //etThread.beeClickF( tinP , TUCK * 8 ) ; //U::
                                //LOGrAW5( "too fast [cyclesPerSleep,msSleep]: " , cyclesPerSleep , " " , msSleep , "\r\n" ) ; //U::
                            }
                            else if( timeE1 > timeTarget1 )
                            {
                                if( !bJump && bLathUp && !bLathUpLag && msStep < ( msPowerAbove >> 4 ) ) msStep <<= 1 ;
            
                                if( bLathUp && bJump && idCycle != 0x20 ) bJump = 0 ;
            
                                if( !bJump ) msSleep -= msStep ;
                                else         msSleep = msPowerBelow ;
            
                                if( msSleep < MSsLEEPmIN )
                                {
                                    msSleep = MSsLEEPmIN ;
                                    if( !( cyclesPerSleep & BM_HIGH ) ) cyclesPerSleep <<= 1 ;
                                }
            
                                if( msSleep == msPowerBelow )
                                {
                                    msPowerBelow >>= 1 ;
                                    msPowerAbove >>= 1 ;
                                    msStep = msPowerAbove >= 0x10 ? msPowerAbove >> 4 : 1 ;
            
                                    if( !bLathUp && !bJump ) bJump = 1 ;
                                }
            
                                bLathUpLag = bLathUp ;
                                if( bLathUp ) bLathUp = 0 ;
                                //etThread.beeClickF( tinP , TUCK * 1 ) ; //U::
                                //LOGrAW5( "too slow [cyclesPerSleep,msSleep]: " , cyclesPerSleep , " " , msSleep , "\r\n" ) ; //U::
                            }
            
                            timeL2 = timeL1 = 0 ;
                            etThread.osTimeNowF( tinP , timeL1 , timeL2 ) ;
                        }

                        paperOldC::grabIF( tinP , TAG( TAGiDnULL ) ) ;
                        if( !( F(paperOldC::flagsModeIF( tinP )) & flPAPERmODEi_SUPPRESSaNIMATION ) && !( F(paperOldC::flagsModeIF( tinP )) & flPAPERmODEi_ANIMATIONtHREADfIRED ) )
                        {
                            //if( !( idCycle % ( TUCK >> 4 ) ) ) Beep ( TUCK << 1 , TUCK >> 2 ) ; //U::
                            paperOldC::beforeAnimatingIF( tinP , etThread , idCycle ) ;
                            paperOldC::obeyAnimateCbfStrokesIF( tinP , etThread , idCycle , ether ) ;
                            paperOldC::freshVolatileTextIF( tinP , etThread , pcNotes , idCycle ) ;
                            sadamsC::pSadamsIF( tinP )->highlightIfF( tinP ) ;
                        }
            
                        //LOGrAWtID( T("[idCycle]: ")+TF1(idCycle) ) ;
                        if( paperOldC::queryResetTabFreshIF( tinP ) || !( idCycle % TUCK ) )
                        {
                            //LOGrAWtID( "calling tabFreshF" ) ;
                            sadamsC::pSadamsIF( tinP )->tabFreshF( tinP , etThread ) ;
                        }

                        //paperOldC& paper = (paperOldC&)pRootI->selectPaperF( tinP , ifcIDcMDpAPERsELECT_QUERYrENDER ) ;
                        paperOldC& paper = (paperOldC&)pRootI->selectPaperF(tinP,ifcIDcMDpAPERsELECT_QUERYsHOW) ;
                        paper.flushF( tinP ) ;
                        paperOldC::ungrabIF( tinP ) ;

                    }
                    pRootI->letRefF() ;
                }
            }
#endif

            if( F(paperOldC::flagsModeIF( tinP )) & flPAPERmODEi_ANIMATIONtHREADfIRED ) break ;
            if( !( idCycle % cyclesPerSleep ) ) { ++ s ; thirdC::dosSleepRawIF( tinP , msSleep ) ; }
        }

        paperOldC::obeyAnimateCbfStrokesIF( tinP , etThread , 0 , ether ) ;
    }
}
DONE( tmAnimateSadamsOnPaperF )

#undef MSsLEEPmIN


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300005a.tmanimatesadamsonpaperf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300005b.tmchttpserverwojobf BEGIN
#define DDNAME       "3func.3300005b.tmchttpserverwojobf"
#define DDNUMB      (countT)0x3300005b
#define IDFILE      (countT)0x947


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/


/*1*/TASKdRIVENsERVER( tmcHttpServerWoJobF )/*1*/
TELL( "preparing for work" ) ;
{
    _IO_
    etThread.etherDoHttpJobF( tinP , jobP , psoP , sessionP , idPortMeP , nnMeP ) ;
}
DONEdRIVENsERVER( tmcHttpServerWoJobF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300005b.tmchttpserverwojobf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300005d.tmhttpcachef BEGIN
#define DDNAME       "3func.3300005d.tmhttpcachef"
#define DDNUMB      (countT)0x3300005d
#define IDFILE      (countT)0x948


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tmHttpCacheF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
{
    countT&  cArgSysP = *(countT*)pTaskP->c1 ;
    boolT&   _bQuitP  =  *(boolT*)pTaskP->c2 ;

    HTTPsYSpARAMS( cArgSysP )

    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIEST ) ;

    while( !_bQuitP && !etThread )
    {
        if( pHttpFreshenCacheCBFP ) (*pHttpFreshenCacheCBFP)( tinP , etThread , _bQuitP , meP , meP.sessions , cArgAppP , 0 ) ;

        {
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            countT cToDo = 0x40 ;
            while( cToDo -- )
            {
                if( _bQuitP ) break ;
                ++ s ; etThread.osSleepF( tinP , TUCK * 0x40 ) ;
            }
        }
    }
    if( pHttpFreshenCacheCBFP ) (*pHttpFreshenCacheCBFP)( tinP , etThread , _bQuitP , meP , meP.sessions , cArgAppP , 1 ) ;
}
DONE( tmHttpCacheF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300005d.tmhttpcachef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300005e.idtoolshadowf BEGIN
#define DDNAME       "3func.3300005e.idtoolshadowf"
#define DDNUMB      (countT)0x3300005e
#define IDFILE      (countT)0x949


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//CODEsYNC: 0010296 00103c6: EVERY idTool VALUE MUST HAVE AN ASSOCIATED VK VALUE, IN THE SAME ORDER (FOR SPEEDY MAPPING)

countT ppVk2[][ 2 ] =
{
    #if defined( __NT__ )

        ifcIDtYPEtOOL_UP                , ifcIDtYPEtOOL_UPnUM           ,
        ifcIDtYPEtOOL_TAB               , ifcIDtYPEtOOL_TABbACK         ,
        ifcIDtYPEtOOL_RIGHT             , ifcIDtYPEtOOL_RIGHTnUM        ,
        ifcIDtYPEtOOL_ENTER             , ifcIDtYPEtOOL_ENTERnUM        ,
        ifcIDtYPEtOOL_PAGEuP            , ifcIDtYPEtOOL_PAGEuPnUM       ,
        ifcIDtYPEtOOL_PAGEdOWN          , ifcIDtYPEtOOL_PAGEdOWNnUM     ,
        ifcIDtYPEtOOL_LEFT              , ifcIDtYPEtOOL_LEFTnUM         ,
        ifcIDtYPEtOOL_INSERT            , ifcIDtYPEtOOL_INSERTnUM       ,
        ifcIDtYPEtOOL_HOME              , ifcIDtYPEtOOL_HOMEnUM         ,
        ifcIDtYPEtOOL_END               , ifcIDtYPEtOOL_ENDnUM          ,
        ifcIDtYPEtOOL_DOWN              , ifcIDtYPEtOOL_DOWNnUM         ,
        ifcIDtYPEtOOL_DELETE            , ifcIDtYPEtOOL_DELETEnUM       ,
        ifcIDtYPEtOOL_QUOTEdOUBLE       , ifcIDtYPEtOOL_QUOTEsINGLE     ,
        ifcIDtYPEtOOL_CURLEYcLOSE       , ifcIDtYPEtOOL_SQUAREcLOSE     ,
        ifcIDtYPEtOOL_BACKsLASH         , ifcIDtYPEtOOL_OR              ,
        ifcIDtYPEtOOL_CURLEYoPEN        , ifcIDtYPEtOOL_SQUAREoPEN      ,
        ifcIDtYPEtOOL_ACCENT            , ifcIDtYPEtOOL_TILDE           ,
        ifcIDtYPEtOOL_DIVIDE            , ifcIDtYPEtOOL_QUESTION        ,
        ifcIDtYPEtOOL_GREATERtHAN       , ifcIDtYPEtOOL_PERIOD          ,
        ifcIDtYPEtOOL_MINUS             , ifcIDtYPEtOOL_UNDERSCORE      ,
        ifcIDtYPEtOOL_COMMA             , ifcIDtYPEtOOL_LESStHAN        ,
        ifcIDtYPEtOOL_EQUALS            , ifcIDtYPEtOOL_PLUS            ,
        ifcIDtYPEtOOL_COLON             , ifcIDtYPEtOOL_SEMICOLON       ,

    #endif
}
;

/*1*/countT idToolShadowF( const countT idToolP )/*1*/
{
    ZE( countT , idToolShadow ) ;
         if( idToolP >= ifcIDtYPEtOOL_a && idToolP <= ifcIDtYPEtOOL_z ) idToolShadow = ifcIDtYPEtOOL_A - ifcIDtYPEtOOL_a + idToolP ;
    else if( idToolP >= ifcIDtYPEtOOL_A && idToolP <= ifcIDtYPEtOOL_Z ) idToolShadow = ifcIDtYPEtOOL_a - ifcIDtYPEtOOL_A + idToolP ;
    else
    {
        countT cElts = sizeof ppVk2 / sizeof ppVk2[ 0 ] ;
        for( countT off = 0 ; off < cElts ; off ++ )
        {
            if( ppVk2[ off ][ 0 ] == idToolP )
            {
                idToolShadow = ppVk2[ off ][ 1 ] ;
                break ;
            }
            else if( ppVk2[ off ][ 1 ] == idToolP )
            {
                idToolShadow = ppVk2[ off ][ 0 ] ;
                break ;
            }
        }
    }

    return idToolShadow ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300005e.idtoolshadowf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300005f.cbitssetf BEGIN
#define DDNAME       "3func.3300005f.cbitssetf"
#define DDNUMB      (countT)0x3300005f
#define IDFILE      (countT)0x94a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT _export cBitsSetF( countT cP )/*1*/
{
    ZE( countT , tally ) ;
    while( cP )
    {
        if( cP & 1 ) tally ++ ;
        cP >>= 1 ;
    }
    return tally ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300005f.cbitssetf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000060.usf BEGIN
#define DDNAME       "3func.33000060.usf"
#define DDNUMB      (countT)0x33000060
#define IDFILE      (countT)0x94b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


/*
"us": "unit square"
i evaluate to the number of corners contained, moving clockwise from plumb downward
arguments
 xP: [-1.0,1.0] x coord of point on unit square
 yP: [-1.0,1.0] y coord of point on unit square
 rP: [0.0,1.0] angle, clockwise from plumb (6 o'clock position)
*/

/*1*/countT usF( tinS& tinP , measureT& xP , measureT& yP , const measureT rP )/*1*/
{
    ZE( countT , cCorners ) ;

    measureT cosp = thirdC::mathCosIF( tinP , - ( rP + 0.25 ) * PI * 2 ) ;
    measureT sinp = thirdC::mathSinIF( tinP , - ( rP + 0.25 ) * PI * 2 ) ;

    measureT cospa = cosp >= 0.0 ? cosp : - cosp ;
    measureT sinpa = sinp >= 0.0 ? sinp : - sinp ;

    if( cospa >= sinpa )
    {
        xP = 1.0 ;
        yP = sinpa / cospa ;
    }
    else
    {
        xP = cospa / sinpa ;
        yP = 1.0 ;
    }

    if( cosp <= 0.0 )
    {
        if( sinp <= 0.0 )
        {
            if( xP != 1.0 ) cCorners = 0 ;
            else            cCorners = 1 ;
        }
        else
        {
            if( xP == 1.0 ) cCorners = 1 ;
            else            cCorners = 2 ;
        }
    }
    else
    {
        if( sinp > 0.0 )
        {
            if( xP != 1.0 ) cCorners = 2 ;
            else            cCorners = 3 ;
        }
        else
        {
            if( xP == 1.0 ) cCorners = 3 ;
            else            cCorners = 4 ;
        }
    }

    if( cosp < 0.0 ) xP = - xP ;
    if( sinp < 0.0 ) yP = - yP ;

    return cCorners ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000060.usf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000061.papertoeyedefaultcbf BEGIN
#define DDNAME       "3func.33000061.papertoeyedefaultcbf"
#define DDNUMB      (countT)0x33000061
#define IDFILE      (countT)0x94c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/*1*/voidT _export paperToEyeDefaultOldCBF( mapPaperToBackS& mP )/*1*/
{
    mapPaperToEyeOldS& map = *(mapPaperToEyeOldS*)&mP ;

    map.xx = map.mIdCol ;
    map.yy = map.mIdRow ;
    map.zz = 0.0 ; //U:: *(measureT*)&mP.cArg
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000061.papertoeyedefaultcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000062.tm_httpserverc_f BEGIN
#define DDNAME       "3func.33000062.tm_httpserverc_f"
#define DDNUMB      (countT)0x33000062
#define IDFILE      (countT)0x94d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tm_httpServerC_F )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
{
    countT& cArgThreadP                                                 =                 *(countT*)pTaskP->c1 ;
    boolT&  bQuitP                                                      =                  *(boolT*)pTaskP->c2 ;

    count8S& _c8tp  = *(count8S*)cArgThreadP ;
    count8S& _c8tp1 = *(count8S*)_c8tp.c1 ;
    count8S& _c8tp2 = *(count8S*)_c8tp.c2 ;

    httpServerC&             meP                                        =            *(httpServerC*)_c8tp1.c1 ;
    flagsT                   flagsSocketP                               =                   (flagsT)_c8tp1.c2 ;
    countT                   idPortP                                    =                           _c8tp1.c3 ;
    countT&                  cArgAppP                                   =                 *(countT*)_c8tp1.c4 ;
    httpLoadContentStaticFT  pHttpLoadContentStaticFP                   =  (httpLoadContentStaticFT)_c8tp1.c5 ;
    httpLoadContentDynamicFT pHttpLoadContentDynamicFP                  = (httpLoadContentDynamicFT)_c8tp1.c6 ;
    httpEatKeyValuePairsCBFT pHttpEatKeyValuePairsCBFP                  = (httpEatKeyValuePairsCBFT)_c8tp1.c7 ;
    httpFreshenCacheCBFT     pHttpFreshenCacheCBFP                      =     (httpFreshenCacheCBFT)_c8tp1.c8 ;
    httpRawCommandServerCBFT pHttpRawCommandServerCBFP                  = (httpRawCommandServerCBFT)_c8tp2.c1 ;
    strokeS*&                psttName                                   =              *(strokeS**)&_c8tp2.c2 ;

    TELL( "waiting for meP.sgnCtDone" ) ;
    meP.sgnCtDone.waitF( tinP ) ;
    TELL( "saw meP.sgnCtDone; loading static content if" ) ;

    if( pHttpLoadContentStaticFP ) (*pHttpLoadContentStaticFP)( tinP , etThread , bQuitP , meP , cArgAppP ) ;

    TELL( "loading dynamic content if" ) ;
    if( pHttpLoadContentDynamicFP ) (*pHttpLoadContentDynamicFP)( tinP , etThread , bQuitP , meP , cArgAppP ) ;

    TELL( "freshening cache if" ) ;
    if( pHttpFreshenCacheCBFP ) (*pHttpFreshenCacheCBFP)( tinP , etThread , bQuitP , meP , meP.sessions , cArgAppP , 0 ) ; //ENSURE THAT APP CODE HAS OPPORTUNITY TO INITIALIZE ITS CACHE BEFORE ANY CLIENT CONNECTIONS ARE ACCEPTED

    {
        TELL( "launching tmHttpCacheF" ) ;
        ZE( countT , time1idleTimeoutRead ) ;
        ZE( countT , time1idleTimeoutWrite ) ;
        HTTPsYSpARAMSsET( cArgSys )
        threadC thrCache( tinP , etThread , TAG( TAGiDnULL ) , tmHttpCacheF , cArgSys , flTHREADlAUNCH_SHOWpONY ) ;
    
        TELL( "constructing serverInfoS parameters" ) ;
        ZE( boolT , bHandedOff ) ;
        signC sgnIdPortReplaced( tinP , TAG( TAGiDnULL ) ) ;
        serverInfo1S i1( 0 , 0 , bHandedOff , sgnIdPortReplaced , /*tmcHttpServerWoJobF*/ tmcHttpServerWorkerF , countTC() , bQuitP , time1idleTimeoutRead , time1idleTimeoutWrite ) ;

        serverInfo2S i2( idPortP , flagsSocketP , psttName , 0 , cArgSys , 0 , - 1 , /*1U::bState SET TO ZE PROVISIONALLY SO DOOR AND PANIC DOOR CAN BE SERVED BY SAME PROCESS TO MAKE DEVELOPMENT OF THE INTERFACES EASIER; SET TO 1 WHEN THESE DOORS ARE SERVED BY SEPARATE PROCESSES, AS CALLED FOR IN THE DESIGN*/0 , 0 , 0 , 0 , 0 , 0 , &meP.sessions ) ;
        etThread.delF( tinP , psttName ) ;
        //20190904@1529: RETIRED i1.time1idleTimeoutWrite = i1.time1idleTimeoutRead = TOCK * 0x40 ; //RAW COMMAND SERVERS MUST REPLACE THIS WITH A LARGER VALUE; THIS VALUE ASSUMES WEB BROWSER ONLY NEEDS TO BURST ALL IMAGES FOR A PAGE AND WILL DO SO IMMEDIATELY
        i1.time1idleTimeoutWrite = i1.time1idleTimeoutRead = SOCKETtIMEOUTdEFAULTwAN ; //RAW COMMAND SERVERS MUST REPLACE THIS WITH A LARGER VALUE; THIS VALUE ASSUMES WEB BROWSER ONLY NEEDS TO BURST ALL IMAGES FOR A PAGE AND WILL DO SO IMMEDIATELY

        countT idDesireOld = etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;

        TELL( "calling ifcDrivenServerF" ) ;
        etThread.ifcDrivenServerF( tinP , i1 , i2 ) ;
        TELL( "returned from ifcDrivenServerF" ) ;

        etThread.osThreadSwitchingDesireF( tinP , idDesireOld ) ;
    }
    TELL( "cleaning up" ) ;
}
TELL( "cleaned up" ) ;
DONE( tm_httpServerC_F )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000062.tm_httpserverc_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000063.tm_sessionsc_watchf BEGIN
#define DDNAME       "3func.33000063.tm_sessionsc_watchf"
#define DDNUMB      (countT)0x33000063
#define IDFILE      (countT)0x94e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/TASK( tm_sessionsC_watchF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
{
    _IO_
    countT& cArgThreadP = *(countT*)pTaskP->c1 ;

    sessionsC& sessionsP = *(sessionsC*)cArgThreadP ;

    stackC st_pSession( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY ) ;
    while( !etThread && !sessionsP.bQuitWatching )
    {
        //etThread.beeClickF( tinP ) ; //U:: TO FIND A BUG

        _IO_
        sessionsP.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
        countT cFlavors = sessionsP.swSession.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            sessionsP.nnLever_peer = *(nicNameC*)sessionsP.swSession.leverF( tinP , idf ) ;
            sessionC& session = *(sessionC*)(countT)sessionsP.swSession ;

            timeS idle = session.idleF( tinP ) ;
            if( idle.time2 || idle.time1 > ifcTIMEtIMEOUTsESSION )
            {
                countT& c_pSession = sessionsP.swSession ;
                st_pSession << c_pSession ;
                c_pSession = 0 ;
            }
        }
        sessionsP.swSession.freeNullsF( tinP ) ;
        sessionsP.baton.ungrabF( tinP ) ;

        while( st_pSession )
        {
            ZE( sessionC* , pSession ) ;
            st_pSession >> *(countT*)&pSession ;
            DEL( pSession ) ;
        }

        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        countT cToDo = TUCK ;
        while( !sessionsP.bQuitWatching && cToDo -- )
        {
            ++ s ; etThread.osSleepF( tinP , TUCK << 2 ) ;
            //U::PROD: ++ s ; etThread.osSleepF( tinP , TOCK >> 3 ) ;
        }
    }

    sessionsP.bQuitWatching = 0 ;
}
DONE( tm_sessionsC_watchF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000063.tm_sessionsc_watchf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000064.httpeatkeyvaluepairsdefaultcbf BEGIN
#define DDNAME       "3func.33000064.httpeatkeyvaluepairsdefaultcbf"
#define DDNUMB      (countT)0x33000064
#define IDFILE      (countT)0x94f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT httpEatKeyValuePairsDefaultCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , strokeS*& psttReportP , const strokeS* const psttFileLikeP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    _IO_
    //U::EDIT THIS TO WRITE soulC IMAGE FILES
    // BEGIN THE SOUL WITH A FINGERPRINT, AND ENSURE THAT CODE CAN DETECT WHETHER THE FILE IS A SOUL IMAGE

    if( swKVP.cFlavorsF( tinP ) )
    {
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;

        sOut << (strokeS*)T("_idHome") ;
        sOut << (strokeS*)TF2(processGlobal1I.idHome,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
            
        sOut << (strokeS*)T("_idAdam") ;
        sOut << (strokeS*)TF2(processGlobal1I.idAdamRoot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;

        TN( tReport , "" ) ;
        countT cFlavors = swKVP.cFlavorsF( tinP ) ;
        ZE( strokeS* , psttForm ) ;
        for( countT idf = 1 ; !bQuitP && idf <= cFlavors ; idf ++ )
        {
            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
            strokeS*& psttv = *(strokeS**)&(countT&)swKVP ;
                            
            ZE( strokeS* , psttvTrimmed ) ;
            etThread.strTrimF( tinP , psttvTrimmed , psttv , T(TbLACKnEWlINE) ) ; ___( psttvTrimmed ) ;

            if( !tinP.pEtScratch->strCompareF( tinP , psttLeverKVP , T("form"  ) ) )
            {
                //U::BUG? WILL THE NEXT LINE ALWAYS COMPLAIN, EVEN IF ONLY WO form LEVER IS SEEN?
                etThread.traceF( tinP , T("coding error / multiple \"form\" keys received [lag,now]:    ")+T(psttForm)+T("    ")+T(psttvTrimmed) ) ;
                etThread.delF( tinP , psttForm ) ;
                etThread.strMakeF( tinP , LF , psttForm , psttvTrimmed ) ; ___( psttForm ) ;
            }
            else if(  tinP.pEtScratch->strCompareF( tinP , psttLeverKVP , T("submit") ) ) tReport += T(psttLeverKVP)+T(": \"")+T(psttvTrimmed)+T("\"<BR>\r\n") ;
                            
            sOut << psttLeverKVP ;
            sOut << psttvTrimmed ;

            etThread.delF( tinP , psttvTrimmed ) ;
        }
            
        if( !bQuitP )
        {                                   // ON THE NEXT LINE, "&& psttForm" IS ADDED AS A PARTIAL PROTECTION AGAINST ATTACK
            if( psttFileLikeP && psttForm ) // THIS IS AN ATTACK SURFACE.  AN ATTACKER CAN OVERWHELM A SERVER WITH DISK I/O AND EVENTUALLY FILL THE DISK
            {
                ZE( strokeS* , psttFileName ) ;
                etThread.boxPutUniqueF( tinP , psttFileName , T(psttFileLikeP)+T(".")+(psttForm?T(psttForm):T("unk")) , WS( sOut ) ) ;
                etThread.delF( tinP , psttFileName ) ;
            }
                                
            if( tReport.csF( tinP ) ) { etThread.strMakeF( tinP , LF , psttReportP , tReport ) ; ___( psttReportP ) ; }
        }
        etThread.delF( tinP , psttForm ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000064.httpeatkeyvaluepairsdefaultcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000065.adammainf BEGIN
#define DDNAME       "3func.33000065.adammainf"
#define DDNUMB      (countT)0x33000065
#define IDFILE      (countT)0x950


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//
                                                   
/*
*/
/**/

//U::MOVE TO SYMPOL DEF FILE

#define ADAMpHASE(idPhaseP) if( thirdC::third_idPhaseAdam_IF( tinP ) < (idPhaseP) ) { thirdC::third_idPhaseAdam_IF( tinP ) = (idPhaseP) ; /*CONoUTrAW3( "[idPhase]: " , idPhaseP , "\r\n" ) ;*/ }

//U::#define ADAMpHASE(idPhaseP) if( thirdC::third_idPhaseAdam_IF( tinP ) < (idPhaseP) ) thirdC::third_idPhaseAdam_IF( tinP ) = (idPhaseP)

/*1*/countT adamMainF( tinS& tinP , const countT idTypeP , countT cHowP , const osTextT** ppostHowP , countT hWindowingClientIP , countT hPreviousWindowingClientP , const osTextT* postP , countT idCmdShowP )/*1*/
{
    {
        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 ) ;
        cryC cry00( TOCK + 0x00 ) ;

        //REMOVE THIS, OR MAKE IT A TESTER TO VERIFY THAT THIS MUCH MEMORY IS AVAILABLE
        //{
        //    p oolC poolt( tinP , TAG( TAGiDnULL ) , "test" , 0x10 ) ;
        //    for( countT expCb = 0 ; expCb < 0x1e ; expCb ++ )
        //    {
        //        countT cbWant = 1 ;
        //        countT cDo = expCb ;
        //        while( cDo -- ) cbWant <<= 1 ;
        //
        //        byteT* pbt = poolt.newF( tinP , LF , cbWant ) ;
        //        poolt( tinP , pbt ) ;
        //    }
        //}

        _IO_
        //tinP.pc Utility[ 0 ] ++ ; //U::TO FIND A BUG

        {
            homeS& home = homeS::homeIF() ;

            poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;
            if( pRegs ) ;
        }

        thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_NORMAL ) ;
        {
            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN2 ) ;
            const osTextT* ppostHow[ 0x10 ] ; //WILL BE FILLED WITH REFERENCES TO SNIPS IN postOldCopy; ppostHowP WILL BE SET TO ME, SO I MUST EXIST WHILE ppostHowP IS VISIBLE
            tinP.flagsThreadMode2 |= flTHREADmODE2_ADAMmAINtHREAD ;
            if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }

            etherC::paperZitsOffF( tinP ) ;

            OStEXT(   _ostoTmp , 0x80 )
            OStEXTAK( _ostoTmp , "!ifc" )
            OStEXTAK( _ostoTmp , "RangerTag:threadStack.tm1F.1" )
            staticC _statRangerTag( tinP , "rangerTag" , "sys" , 2 * sizeof( countT ) + _ostoTmp.costF() + 1 , ifcIDtYPEsTATICC_FOOT ) ;
            osTextC _ostRangerTag( _ostoTmp.costF() + 1 , _ostoTmp , _statRangerTag , _statRangerTag.cbF() ) ;
            OStEXTcLEAR( _ostoTmp )

            if( idTypeP == ifcIDtYPEtLS_WINDOW )
            {
                //AllocConsole() ; //U::DO THIS IFF PARAMETER IS SPECIFIED !console
                //BLAMMO ; //20120907@1304: TO PREVENT THE BLACK SCREEN THAT IGNORES ALL HUMAN INPUT BECAUSE THE GRAPHICS PRESENTATION SYSTEM IS BEING REWRITTEN

                ((handleC&)thirdC::third_hWindowingClientIF( tinP )).osF( ifcIDtYPEhANDLE_WINDOWINGcLIENT , hWindowingClientIP ) ;
                if( !thirdC::third_hWindowingClientIF( tinP ) ) BLAMMO
            }
        
            handleC hDll( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DLL ) ; //MUST NOT BE CLOSED UNTIL tmWindowsF HAS ENDED, BECAUSE LATTER CAN CALL CALLBACK FUNCTIONS DEFINED IN THE ADAM
            tinP.pAdamGlobal1->_etherC_.pHdll = &hDll ;
            {
                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN3 ) ;
                ZE( boolT , bTestAuto ) ;
        
                const osTextT osId = thirdC::osIdIF( tinP ) ;
                const boolT bOsSupportsServices = osId == 'w' ;
                {
                    if( idTypeP == ifcIDtYPEtLS_WINDOW || idTypeP == ifcIDtYPEtLS_WITHINpROCESS )
                    {
                        _IO_
                        ZE( countT , cHow ) ;
                        static const osTextT* const postUnk1 = "<exeNameNotAvailable>" ;
                        static const osTextT* const postUnk2 = "<withinDadProcess>" ;
                        const osTextT* postUnk = idTypeP == ifcIDtYPEtLS_WINDOW ? postUnk1 : postUnk2 ;
                        {
                            osTextT postOldCopy[ 0x200 ] ;
                            thirdC::c_strncpyIF( postOldCopy , postP , sizeof postOldCopy ) ;
                            const countT costCopy = thirdC::c_strlenIF( postOldCopy ) ;
                            {
                                ZE( boolT , bQuote ) ;
                                countT cToDo = costCopy ;
                                ZE( countT , off ) ;
                                while( cToDo -- )
                                {
                                    if( postOldCopy[ off ] == 0x22 ) bQuote = !bQuote ;
                                    if( !bQuote && postOldCopy[ off ] == ' ' ) postOldCopy[ off ] = 0 ;
                                    off ++ ;
                                }
                            }
        
                            if( postOldCopy[ 1 ] != ':' ) ppostHow[ cHow ++ ] = postUnk ; //WINDOWS CMD.EXE DOES NOT INCLUDE THE EXE FILE NAME WITH THE PARAMETER LIST FOR GUI PROCESSES
        
                            for( countT off = 0 ; off < costCopy && cHow < sizeof ppostHow / sizeof ppostHow[ 0 ] ; off ++ )
                            {
                                if( !postOldCopy[ off ] ) continue ;
        
                                if( ( !off || !postOldCopy[ off - 1 ] ) && postOldCopy[ off ] ) ppostHow[ cHow ++ ] = postOldCopy + off ;
                            }
                        }
        
                        cHowP = cHow ;
                        ppostHowP = ppostHow ;
                    }

                    ZE( boolT , bPseudoService ) ;
                    if( cHowP > 1 ) ;
                    else if( bOsSupportsServices )
                    {
                        thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_DRIVER ; //I WANT TO SET flMODEpROCESS1_DRIVER BIT AS SOON AS I KNOW THAT I AM THE DRIVER PROCESS, SO THAT I WILL GET POPUP IF AN EXCEPTION OCCURS
                    }
                    else
                    {
                        bPseudoService = 1 ;
                        thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_DRIVER ; //I WANT TO SET flMODEpROCESS1_DRIVER BIT AS SOON AS I KNOW THAT I AM THE DRIVER PROCESS, SO THAT I WILL GET POPUP IF AN EXCEPTION OCCURS
                    }
        
                    ZE( countT , idArg ) ;
                    for( countT idp = 1 ; idp <= cHowP ; idp ++ )
                    {
                        if( idArg )
                        {
                            switch( idArg )
                            {
                                case 2 : { idArg = 0 ; thirdC::third_idProcessOldI_IF( tinP ) = thirdC::c_atoiIF( tinP , ppostHowP[ idp - 1 ] ) ; break ; }
                                case 5 : { idArg = 0 ; thirdC::third_idTrialI_IF( tinP ) = thirdC::c_atoiIF( tinP , ppostHowP[ idp - 1 ] ) ; break ; }
                            }
                        }
                        //CS:CODEsYNC: 33000065 33000065
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!idTrial"                  ) ) { idArg          = 5                        ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!idProcessOld"             ) ) { idArg          = 2                        ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!testAuto"                 ) ) { bTestAuto      = 1                        ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!quietConsole"             ) ) { thirdC::third_flagsModeAdam1I_IF( tinP    ) |= flADAMmODE1_QUIETcONSOLE ; } // WIN32 DOES NOT PROVIDE A WAY TO QUERY WHETHER THIS PROCESS IS ATTACHED TO A CONSOLE; CALLING system( cls ) WHEN NOT ATTACHED CAUSES A CONSOLE WINDOW TO MOMENTARILY APPEAR; THE WORKAROUND IS TO USE A CMD LINE PARAMETER; DETACHED PROCESSES THAT ALLOCATE A CONSOLE MUST MAINTAIN (RESET) THIS FLAG
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!threadFiles"              ) ) { thirdC::third_flagsModeAdam1I_IF( tinP    ) |= flADAMmODE1_SEEtHREADSaSfILES ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!ignoreFireByOperator"     ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_IGNOREfIREbYoPERATOR ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!jot"                      ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_JOT ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!debug"                    ) ) { thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_DEBUG  ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!debug1"                   ) ) { thirdC::third_flagsModeAdam1I_IF( tinP    ) |= flADAMmODE1_DEBUG1 ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!utility"                  ) ) { thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_CHECKtINuTILITYeLEMENTS ; }
                        //else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!utility0"               ) ) { tinP.pc Utility[ 0 ] = 1 ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!noInterprocessGrabs"      ) ) { thirdC::third_flagsModeAdam1I_IF( tinP    ) |= flADAMmODE1_DISALLOWgRABoFiNTERPROCESSgRABs ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!noSystemThreads"          ) ) { thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_NOsYSTEMtHREADS ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!threadChatter"            ) ) { thirdC::third_flagsModeAdam2I_IF( tinP    ) |= flADAMmODE2_THREADcHATTER ; }
                    }
                }

                //QueryThreadCycleTime( (HANDLE)(-2) , (ULONG64*)&tinP.pc Utility04[ 0 ] ) ; //U:: TO FIND A BUG
                _IO_
                cryC cry01( TOCK + 0x01 ) ;
                {
                    {
                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN4 ) ;
                        if( !POOP )
                        {
                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN5 ) ;
                            OStEXT( ostoPoolAdamTemp , TUCK << 2 )
                            OStEXTAK( ostoPoolAdamTemp , "adam.temp." )
                            OStEXTC(  ostoPoolAdamTemp , tinP.pAdamGlobal1->idAdam , 0 )
                            OStEXTAK( ostoPoolAdamTemp , "." )
                            OStEXTC(  ostoPoolAdamTemp , tinP.osPid , 0 )                   //20141129@1426: ADDED TO UNIQUIFY SO THAT MULTIPLE INSTANCES OF SAME idAdam CAN COEXIST
                            
                            //U:: ifcIDsTATEsPACE_MULTIPLEaDAMS: REMOVE IN PRODUCTION AND WHEN NOT INVESTIGATING LEAKAGE
                            
                            //TO DEBUG FOR LEAKS OR TO USE poolC::reportF, ENABLE THE  FLAG HERE AND ALSO ENABLE THE DEFINITION OF THE "ENABLEdROPnOTES" SYMBOLIC CONSTANT
                            
                            //20141026@1654: IGNORE THIS CS COMMENT; IT IS UNUSEABLE SINCE IT REFERENCES OBSOLETE MODULE NUMBERS (BEFORE ALL FILES IN DICTIONARY WERE RENUMBERED TO A NEW NUMBERING SCHEME YEARS AGO)
                            //WHEN A BUG IS LOCATED THAT IS DUE TO CODE OUT OF SYNC, EDIT CODE TO CONDITIONALLY COMPILE BASED ON WHETHER ENABLEdROPnOTES IS DEFINED
                            //CS:CODEsYNC: 0b50064 0b50064 21b0002 21b0003
                            
                            cryC cry02( TOCK + 0x02 ) ;
                            // UNDEFINE ENABLEdROPnOTES IN PRODUCTION AND WHEN NOT CHECKING FOR LEAKS
                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN6 ) ;

                            #if defined( ENABLEdROPnOTES )
                                poolC poolAdamTemp( tinP , TAG( TAGiDnULL ) , ostoPoolAdamTemp , flPOOLc_NOTES ) ; //MUST BE WOTH
                            #else
                                poolC poolAdamTemp( tinP , TAG( TAGiDnULL ) , ostoPoolAdamTemp                 ) ; //MUST BE WOTH
                            #endif
                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN7 ) ;
                            cryC cry03( TOCK + 0x03 ) ;

                            //thirdC::third_flagsModeAdam2I_IF(tinP) |= flADAMmODE2_THREADcHATTER /*| flMODEpROCESS2_NOsYSTEMtHREADS*/ ;
                            
                            if( !thirdC::third_idProcessOldI_IF( tinP ) ) thirdC::third_idProcessOldI_IF( tinP ) = - 1 ;

                            ZE( boolT , bServiceManagerHiredMe ) ; // 1 IFF THE O.S. SUPPORTS "SERVICES" AND I AM THE INSTANCE BEING STARTED BY THE SERVICE MANAGER; WILL BE 0 IF I AM THE IDEAFARM DRIVER ON AN OS THAT DOES NOT SUPPORT "SERVICES"
                            if( !POOP )
                            {
                                _IO_
                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN8 ) ;
                                if( idTypeP == ifcIDtYPEtLS_WINDOW )
                                {
                                    if( bTestAuto )
                                    {
                                        OStEXTcLEAR( ostoPoolAdamTemp )
                                        OStEXTAK( ostoPoolAdamTemp , "testAuto" )
                                    }
                                }
                                else if( cHowP == 1 ) //ASSUME: IF THERE ARE NO PARAMETERS THEN I WAS LAUNCHED BY THE WINDOWS SERVICE CONTROL MGR
                                {
        
                                    //COMMENTED THIS OUT SO WILL USE LESS MEMORY, FOR SERVICE ON GODADDY VIRTUAL DEDICAED HOST THAT IS MEMORY CONSTRIAED
                                    //OStEXTcLEAR( ostoPoolAdamTemp )
                                    //OStEXTAK( ostoPoolAdamTemp , "driver" )
                                }
                                else if( bTestAuto )
                                {
                                    OStEXTcLEAR( ostoPoolAdamTemp )
                                    OStEXTAK( ostoPoolAdamTemp , "testAuto" )
                                }
        
                                //boolT bWorkNotRoot = !!thirdC::c_strcmpIF( tinP , ostoPoolAdamTemp , "root" ) ; /* HANDY FOR DEBUGGING */
        
                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN9 ) ;
                                cryC cry04( TOCK + 0x04 ) ;
                                ZE( boolT , bTinOk ) ;
                                {
                                    _MILE
                                    osTextT* postName = POSTtHREADnAMEmAIN ;_
                                    tinS* pTin = new( 0 , tinP , LF ) tinS( tinP , TAG( TAGiDnULL ) , 0 , 0 , postName , flTINs_null , tinP.monitor.idThread == 1 ? ifcIDtINnAMED_tinInPoolMain : ifcIDtINnAMED_tinInPool ) ;_
                                    TINSL
                                    if( pTin ) // pTin WILL BE TAGGED AT /*HERE*/
                                    {
                                        bTinOk = 1 ;_
                                        TELLsYSlIFInAME( postName ) ; //THE TELLsYSlIFInAME MUST BE ON THE SAME LINE AS THE CONSTRUCTOR CALL
                                    }
                                    TELL( "main: tinS, in poolOld is constructed" ) ;_
                                    _MOLE
                                }
                                cryC cry05( TOCK + 0x05 ) ;
                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINa ) ;

                                //_IO_    CANNOT CT HERE, BECAUSE tinP CURRENTLY REFERENCES THE PRIOR tinS
                                if( bTinOk )
                                {
                                    TINSL
                                    //_IO_  CANNOT DO THIS HERE, BECAUSE DT'OR FOR ether WILL DESTROY THE CURRENT tinP
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINb ) ;
                                    TELL( "main: setting up" ) ;
                                    ___( &tinP ) ;                                          /*HERE*/
                                    putNegAM( tinP.fingerprint , FINGERnEG_TINs ) ;
                                    tinP.idiTask  = DDNUMB ;
                                    tinP.idlTask  = ifcLINE ;
            
                                    declareVmUsageTypeGF( tinP , (byteT*)declareVmUsageTypeGF , flVMuSAGEtYPE_CODEbASE ) ;
                                    {
                                        //U::NOW THAT I AM IN base, THE NEXT LINE EXERCISES THE OVERLOAD SO DOES NOT WORK
                                        //byteT* pbnu = new byteT ;
                                        //declareVmUsageTypeGF( tinP , pbnu , flVMuSAGEtYPE_DEFAULThEAP ) ;
                                        //DELzOMBIE( pbnu ) ;
                                    }
        
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINc ) ;
                                    cryC cry06( TOCK + 0x06 ) ;
                                    TELL( "constructing ether" ) ;
                                    etherC ether( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_TINoWNER | flTHIRDmODE_QUITTER /* | flTHIRDmODE_CHECKpOOLoLD */ ) ; //DEBUGGING: TURN ON flTHIRDmODE_CHECKpOOLoLD HERE
                                    TELL( "constructed ether" ) ;
                                    _IO_        // MUST BE CT AFTER ether BECAUSE DT OF ether WILL DESTROY THE CURRENT tinP

                                    cryC cry07( TOCK + 0x07 ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINd ) ;
        
                                    tinP.pEther = &ether ;

                                    if( !ether )
                                    {
                                        _IO_
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINe ) ;
                                        TELL( "constructing etThread" ) ;
                                        cryC cry08( TOCK + 0x08 ) ;
                                        etherC etThread( tinP , TAG( TAGiDnULL ) ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINf ) ;
                                        cryC cry09( TOCK + 0x09 ) ;

                                        {   //TO FACILITATE DEBUGGING (CAN SET A WATCHPOINT HERE TO BREAK WHEN pPoop->idSubType CHANGES)
                                            poopC* pPoop = (poopC*)&(const poopC&)etThread ;
                                            if( pPoop ) ;
                                        }

                                        //etThread.traceF( tinP , T("enabling where") ) ;
                                        //tinP.monitor.idWhat2 = - 1 ;
                                        //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , 1 ) ;
                                        //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
                                        //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;

                                        if( processGlobal1I.idNumaNode ) etThread.traceF( tinP , T("NUMA:  this process will default to limiting itself to using a single NUMA node on NUMA computers [idNumaNode]: ")+TF2(processGlobal1I.idNumaNode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN01 ) ;
                                        TELL( "constructed etThread" ) ;
                                        TELL( "constructing tinP.pEtScratch" ) ;
                                        tinP.pEtScratch = new( 0 , tinP , LF ) etherC( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ; ___( tinP.pEtScratch ) ;
                                        TELL( "constructed tinP.pEtScratch" ) ;
                                        scoopC scoop( tinP , LF , etThread ) ;
                                        //__( tinP.monitor.idThread - ifcIDtHREADlOW_main ) ;
        
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN11 ) ;
                                        TELL( "main: ether and etThread constructed" ) ;
                                        TELL( "main: " ) ;
                                        tinP.pAdamGlobal1->pEtThreadMain = tinP.pEther = &etThread ;
                    
                                        tinP.tally.resetF( tinP ) ;
                                        tinP.tally.nowF( tinP , etThread ) ;
                                        tinP.tally.bTally = 1 ;

                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN21 ) ;
                                        TELL( "main: constructing log" ) ;
                                        cryC cry0a( TOCK + 0x0a ) ;
                                        tinP.pAdamGlobal1->pBksLog = new( 0 , tinP , LF ) booksC( tinP , TAG( TAGiDnULL ) , "log" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER , TOCK ) ; ___( tinP.pAdamGlobal1->pBksLog ) ;
                                        cryC cry0b( TOCK + 0x0b ) ;

                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN31 ) ;
                                        ZE( strokeS* , psttDriverName ) ;
                                        if( ( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WITHINpROCESS ) && cHowP == 1 && bOsSupportsServices )
                                        {
                                            TELL( "main: setting bServiceManagerHiredMe" ) ;
                                            etThread.osDriverNameFromMasterF( tinP , psttDriverName , ifcIDaDAM_KERNEL2MONITOR ) ; ___( psttDriverName ) ;
                                            bServiceManagerHiredMe = ifcDRIVERsTATUS_STARTING == ((thirdC&)ether).osDriverStatusF( tinP , T(psttDriverName) ) ;
                                        }
            
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN41 ) ;
                                        if( !ether )
                                        {
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN51 ) ;
                                            etThread.delF( tinP , psttDriverName ) ;
                    
                                            /*U:((thirdC&)ether).osRealtimeModeOnF( tinP ) ;*/
        
                                            TELL( "main: informing ether of time and of process parameters" ) ;
                                            timeS timeBorn ;
                                            etThread.osTimeNowF( tinP , timeBorn.time1 , timeBorn.time2 ) ;
                                            tinP.time1    = timeBorn.time1 ;
                                            tinP.time2    = timeBorn.time2 ;

                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN61 ) ;
                                            ZE( strokeS* , psttTitle ) ;
                                            {
                                                mapCTC& mapAdam = processGlobal3S::_processGlobal3I_IF().mapAdam ;

                                                TN( tAdam , "" )       ; tAdam = T(mapAdam(tinP.pAdamGlobal1->idAdam)) ;
                                                if( !tAdam.csF( tinP ) ) tAdam = TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
                                                TN( t8b , "        " ) ;

                                                etThread.strMakeF( tinP , LF , psttTitle , tAdam+t8b+T(postIPDOSsHORTlONG)+( processGlobal1I.idHome==1 ? T("") : T(" (home ")+TF2(processGlobal1I.idHome,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(")") ) ) ; ___( psttTitle ) ;
                                            }

                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN71 ) ;
                                            {
                                                TN( tDriver  , "" ) ;
                                                TN( tMonitor , "" ) ;
                                                if( bOsSupportsServices )
                                                {
                                                    tDriver  = TF1(ifcIDaDAM_KERNEL1DRIVER)  ;
                                                    tMonitor = TF1(ifcIDaDAM_KERNEL2MONITOR) ;
                                                }

                                                countT csttNeeded = CSpREFIX ;
                                                for( countT off = 0 ; off < cHowP ; off ++ )
                                                {
                                                    csttNeeded += CSpREFIX + thirdC::c_strlenIF( tinP , ppostHowP[off] ) ;

                                                    if
                                                    (
                                                           bOsSupportsServices
                                                        && !off
                                                        &&
                                                        (
                                                            cHowP == 1
                                                            ||
                                                            (
                                                                *ppostHowP[ off + 1 ] == '!'
                                                            )
                                                        )
                                                    )
                                                    csttNeeded += 2 * CSpREFIX + tDriver.csF( tinP ) + tMonitor.csF( tinP ) ;
                                                }
                                                etThread.strMakeF( tinP , LF , etThread.ether_pstt1_processParametersI_F( tinP ) , 0 , csttNeeded ) ; ___( etThread.ether_pstt1_processParametersI_F( tinP ) ) ;

                                                for( countT off = 0 ; off < cHowP ; off ++ )
                                                {
                                                    etThread.strFuseSeparateF( tinP , etThread.ether_pstt1_processParametersI_F( tinP ) , T(ppostHowP[off]) ) ; ___( etThread.ether_pstt1_processParametersI_F( tinP ) ) ;
                                                    if
                                                    (
                                                           bOsSupportsServices
                                                        && !off
                                                        &&
                                                        (
                                                            cHowP == 1
                                                            ||
                                                            (
                                                                *ppostHowP[ off + 1 ] == '!'
                                                            )
                                                        )
                                                    )
                                                    {
                                                        etThread.strFuseSeparateF( tinP , etThread.ether_pstt1_processParametersI_F( tinP ) , tDriver  ) ;
                                                        etThread.strFuseSeparateF( tinP , etThread.ether_pstt1_processParametersI_F( tinP ) , tMonitor ) ;
                                                    }
                                                }

                                                //FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )
                                                //{
                                                //    etThread.traceF( tinP , T("parameter: \"")+T(psttc1)+T("\"") ) ;
                                                //}
                                            }

                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN81 ) ;
                                            etThread.etherScanProcessParametersF( tinP ) ;

                                            TELL( "main: inspecting process parameters" ) ;
                                            {
                                                //etThread.traceF( tinP , T("adam parameters (command line arguments) BEGIN [idAdam]:    ")+TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                ZE( countT , off ) ;
                                                ZE( countT , idArg ) ;
                                                FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )
                                                {
                                                    //etThread.traceF( tinP , T("    [parameter]: ")+T(psttc1) ) ;

                                                    if( idTypeP == ifcIDtYPEtLS_WINDOW && !psttTitle && ( off ++ ) == 1 ) { etThread.strMakeF( tinP , LF , psttTitle , psttc1 ) ; ___( psttTitle ) ; }

                                                    ZE( boolT , bOk ) ;
                                                    if( idArg )
                                                    {
                                                        switch( idArg )
                                                        {
                                                            case  1 : { idArg = 0 ; etThread.ether_idCitizenHirerI_F( tinP ) = etThread.strDigitsToSCountF( tinP , psttc1 ) ; bOk = 1 ; break ; }
                                                            case  2 : { idArg = 0 ; etherC::ether_cUtility_IF( tinP )          = etThread.strDigitsToSCountF( tinP , psttc1 ) ; bOk = 1 ; break ; }
                                                            case  3 :
                                                            {
                                                                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                                                countT idf = 1 ;
                                                                if( psttc1->idAdam && 1 == etThread.strIdF( tinP , idf , sttq , S1C('!') , psttc1 ) ) idArg = 0 ;
                                                                break ;
                                                            }
                                                        }
                                                    }
                                                    //CS:CODEsYNC: 33000065 33000065
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!bCarefulINo"       ) ) ) { ((thirdC&)ether).third_bCarefulI_F( tinP ) = 0                                           ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!bWatchfulINo"      ) ) ) { ((thirdC&)ether).third_bWatchfulI_F( tinP ) = 0                                          ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!testAuto"          ) ) ) { etThread.flagsMode  |=  flTHIRDmODE_TESTaUTO                                             ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!testAutoDoSleeps"  ) ) ) { etThread.flagsMode  |=  flTHIRDmODE_TESTaUTOdOsLEEPS                                     ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!debug"             ) ) ) { thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_DEBUG  ;                   ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!bWatchTimeNo"      ) ) ) { etThread.flagsWatch &= ~( F(flWATCH_TIME) )                                              ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!bWatchEmployers"   ) ) ) { etThread.flagsWatch |=  flWATCH_EMPLOYERS                                                ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!bWatchSay"         ) ) ) { etThread.flagsWatch |=  flWATCH_SAY                                                      ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!idCitizenHirerI"   ) ) ) { idArg = 1                                                                                ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!cUtility"          ) ) ) { idArg = 2                                                                                ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!faceHear"          ) ) ) { idArg = 3                                                                                ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!log2file"          ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_LOG | flADAMmODE1_LOGtOfILE      ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!log2popup"         ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_LOG | flADAMmODE1_LOGtOpOPUP     ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!log2monitor"       ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_LOG | flADAMmODE1_LOGtOmONITOR   ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!quitAtLogoff"      ) ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_QUITaTlOGOFF               ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!quitAtShutdown"    ) ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_QUITaTsHUTDOWN             ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!minimized"         ) ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_LAUNCHmINIMIZED            ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!noGlobalGrab"      ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_DISALLOWgRABoFiNTERPROCESSgRABs  ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!whereAll"          ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_WHEREaLL                         ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!noTellsHome"       ) ) ) { homeS::homeIF().flags |= flHOMEs_SUPPRESStELLS                                           ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!noTells"           ) ) ) { thirdC::third_flagsModeProcess2I_IF(tinP) |= flMODEpROCESS2_SUPPRESStELLS                ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!noSynchronousTells") ) ) { thirdC::third_flagsModeProcess2I_IF(tinP) |= flMODEpROCESS2_NOsYNCHRONOUStELLS           ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!hideWithIcon"      ) ) ) { thirdC::third_flagsModeProcess2I_IF(tinP) |= flMODEpROCESS2_HIDEwITHiCON                 ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!dead"              ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_LOGdEADLOCKS                     ; bOk = 1 ; }

                                                    //U::if( bOk ) etThread.strokeF( tinP , T("process parameter \"")+T(psttc1)+T("\" recognized\r\n") ) ;
                                                }
                                                //etThread.traceF( tinP , T("adam parameters (command line arguments) END [idAdam]:    ")+TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            }
                                            TELL( "main: parameters scanned" ) ;

                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN91 ) ;
                                            if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS ) )
                                            {
                                                etThread.osThreadF( TaRG1( tmKillSocketF ) ) ; //A:ASSUME: thirdC::s_setupIF HAS ALREADY BEEN CALLED (LOOK FOR IT VERY EARLY DURING CT OF processGlobal3I)
                                                etThread.osThreadF( tinP , countTC() , tmTimeNowF ) ;
                                            }
                                            etThread.ifcDatumF( tinP , flDATUM1_CLASStRACEaLWAYShIRE , flDATUM2_null , 0 , 0 , 0 , (voidT*)DDNAME ) ;

                                            _IO_
                                            if( ether )
                                            {
                                                _IO_
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINa1 ) ;
                                            }
                                            else
                                            {
                                                _IO_
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINb1 ) ;
                                                ZE( strokeS* , psttDll ) ;
                                                {
                                                    _IO_
                                                    #if defined( NEVERdEFINED )

                                                    // 20181112@1144: THE WOTH ARGUMENT (IDENTIFYING idAdam) IS NOW ALLOWED TO BE SYMBOLIC, E.G. "@find", SO THIS CODE IS REPLACED WITH CODE THAT USES processGlobal1I.idAdamRoot
                                                    // '@' IS USED RATHER THAN '!' SO THAT I CAN LOOK AT ONLY THE WOTH CHARACTER TO DETECT THE ABSENCE OF AN idAdam SPECIFICATION IN THE WOTH PARAMETER AFTER THE EXE NAME
                                                    // OTHERWISE, THE SYMBOLIC ADAMS WOULD BE OF THE FORM "!aFind", AND SPECIFYING THEM WOULD CAUSE ME TO THINK THAT NO idAdam WAS SPECIFIED, UNLESS ALL OF THEIR POSSIBLE VALUES WERE HARDCODED IN ME

                                                    // 20181113@0922:
                                                    // THIS DECISION TO USE '@' RATHER THAN '!' MIGHT BE THE BEGINNING OF CHANGING CONFORMANCE RULES TO ABANDON THE SPEC THAT ALL PARAMETER KEYS START WITH '!'
                                                    // NEW CONFORMANCE SPEC:  PARAMETER KEYS CAN START WITH EITHER '!' OR '@', WITH POSSIBLE FUTURE USE OF '#', '$', '%', ... TO RESERVE SUCH USE OF ALL OF THE SYMBOLS IN THE TOPMOST ROW OF THE US KEYBOARD
                                                    // RESERVED: ` ~ ! @ # $ % ^ & * - + =
                                                    // THE TRAILING FO SYMBOLS AND ~ AND ` SHOULD NOT BE USED FOR PARAMETER KEYS BECAUSE THEY WOULD BE USEFUL AS OPERATORS

                                                    countT cSkip = 1 ;
                                                    strokeS sttExclaim('!') ;
                                                    FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )
                                                    {
                                                        //CONoUTrAW( T("parameter: \"")+T(psttc1)+T("\"\r\n") ) ;
                                                        if( cSkip -- ) continue ;
                                                        if( !psttc1->idAdam || psttc1[ CSpREFIX ] == sttExclaim ) break ;
                    
                                                        etThread.strMakeF( tinP , LF , psttDll , psttc1 ) ; ___( psttDll ) ;
                                                        break ;
                                                    }

                                                    #else

                                                        etThread.strMakeF( tinP , LF , psttDll , TF3(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( psttDll ) ;

                                                    #endif
                                                }

                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINc1 ) ;
                                                {
                                                    _IO_
                                                    TN( t8 , "        " ) ;

                                                    TN( tTitle , "" ) ; tTitle =
                                                        T(postIPDOSsHORT)
                                                        +t8+T("H_")+TF2(processGlobal1I.idHome,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                        +t8+T("M_")+TF2(tinP.pAdamGlobal1->idMemorySpace,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                        +t8+T("A_")+TF2(rootAdamGlobal1I.idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("(")+TF2(processGlobal1I.idAdamRoot&0xfff,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(")")
                                                        +t8+T("A+")+TF2(tinP.pAdamGlobal1->idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("(")+TF2(tinP.pAdamGlobal1->idAdam&0xfff,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(")")
                                                        +t8+T("F_")+TF2(tinP.pAdamGlobal1->idGroupFireAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                        +t8+T("P_")+TF2(tinP.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("(")+TF4(tinP.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(")")
                                                    ;
                                                
                                                    etThread.traceF( tinP , tTitle ) ; //RETAIN THIS; IT IS USEFUL TO DEFEND AGAINST ATTACK
                                                }
                                                //etherC::ifcSayIF( T("ADAM CELL (idAdam,osPid): ")+TF1(processGlobal1I.idAdamRoot)+T(" ")+TF1(tinP.osPid)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;

                                                if( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_WHEREaLL )
                                                {
                                                    _IO_
                                                    etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , 0x30 ) ;
                                                }

                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINd1 ) ;
                                                sadamsC sadams( tinP , etThread , TAG( TAGiDnULL ) ) ;
                                                __( &sadams - sadamsC::pSadamsIF( tinP ) ) ;
            
                                                {
                                                    _IO_
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINe1 ) ;
                                                    signC sgnWatchReady( tinP , TAG( TAGiDnULL ) ) ;
                                                    signC sgnWindowsReady( tinP , TAG( TAGiDnULL ) ) ;
        
                                                    //etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;

                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINf1 ) ;
                                                    if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS ) ) etThread.osThreadF( tinP , countTC() , tmWatchF , 0 , flTHREADlAUNCH_null , 0 , (countT)&sgnWatchReady , (countT)&sgnWindowsReady ) ;
                                                    else                                                                                     etThread.traceF( tinP , T("warning: build is configured for \"no system threads\"") ) ;

                                                    //etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_NORMAL ) ;
                
                                                    //TO FIND BUGS
                                                    //etThread.winSetTitleF( tinP , T("tmWatchF launched ; napping for 4 tocks") ) ;
                                                    //sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                                                    //ether.osSleepF( tinP , TOCK << 2 ) ;

                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN02 ) ;
                                                    if( idTypeP != ifcIDtYPEtLS_WINDOW )
                                                    {
                                                        sgnWindowsReady.giveF( tinP ) ;
                                                        etThread.winSetTitleF( tinP , psttTitle ) ;
                                                        etThread.delF( tinP , psttTitle ) ;
                                                    }
                                                    else
                                                    {
                                                        thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_tmWindows ;
                                                        etThread.osThreadF( tinP , countTC() , tmWindowsF , 0 , flTHREADlAUNCH_null , 0 , (countT)&sgnWindowsReady , (countT)&psttTitle ) ;
                                                    }

                                                    if( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS )
                                                    {
                                                        if( idTypeP == ifcIDtYPEtLS_WINDOW ) sgnWindowsReady.waitF( tinP ) ;
                                                        sgnWatchReady.giveF( tinP ) ;
                                                    }

                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN12 ) ;
                                                    sgnWatchReady.waitF( tinP ) ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN22 ) ;
                                                }
            
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN32 ) ;
                                                byteT pbDisplay[ sizeof( displayC ) ] ;
                                                ZE( displayC* , pDisplay ) ;
                                                if( idTypeP == ifcIDtYPEtLS_WINDOW )        //U:: 20200314@1545: CT THIS STACK FAILS ON NONMONOTONIC GRAB.  TESTING OF NONMONOTONIC GRAB ENFORCEMENT DID NOT INCLUDE TESTS FOR GUI PROCESSES
                                                {
                                                    _IO_
                                                    tinP.pAdamGlobal1->_deviceC_pStkJob = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_GIVEsIGNnEWpLATE , sizeof( drawJobS ) ) ; ___( tinP.pAdamGlobal1->_deviceC_pStkJob ) ;
                                                    pDisplay = new( 0 , tinP , pbDisplay , sizeof pbDisplay ) displayC( tinP , etThread , ((measureT)1e1) , 0 , 0 , flDEVICEc_NOsMOOTHIES ) ; //USE SMOOTHIES IN PRODUCTION BUT NOT FOR SOME TESTING
                                                }

                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN42 ) ;
                                                //U:etThread.postcConstructedInFile = ppostHowP[ 1 ] ;
                                                //U:etThread.constructedInLine = 0 ;
                                                TNCID ;

                                                TELL( "main: linking in the adam dll" ) ;
                                                {
                                                    _IO_
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN52 ) ;
                                                    OStEXTV( ostoCopy , "ideafarm.@1000001.ipdos-wm" )
                                                    ( (osTextT*)(const osTextT*)ostoCopy )[ 9 ] = '8' ;
                                                    if( etThread.strIdF( tinP , T("/IdeaFarm " "(tm) Removal Utility/") , psttDll ) )
                                                    {
                                                        _IO_
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN62 ) ;
                                                        etThread.dllOpenF( tinP , hDll , psttDll ) ;
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN72 ) ;
                                                    }
                                                    else if( !etThread.strCompareF( tinP , T(thirdC::postBaseNameIF(tinP)) , T(ostoCopy) ) ) // THE SMUDGER THAT MAKES THE HOVER FILE WILL NOT REPLACE ostoCopy BUT IT WILL REPLACE THE STRING IN postBasenameIF
                                                    {
                                                        _IO_
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN82 ) ;

                                                        // THIS WILL BE DONE IF THE EXE IMAGE IS COMING FROM THE MASTER DIRECTORY
                                                        // IPDOS PROCESSES ARE ONLY LAUNCHED FROM THE MASTER DIRECTORY WHEN THE DESIRED IMAGE DOES NOT EXIST IN THE HOVER DIRECTORY
                                                        // FOR EXAMPLE, WHEN INSTALLING THE BUILD FOLDER ON A NEW DEVELOPMENT COMPUTER, THE BUILD PROGRAMS (IN BENCH) WILL BUILD THE MASTER FILES AND THEN LOAD PROCESSES FROM THEM TO BUILD THE HOVER FILES

                                                        __( etThread.strIdF( tinP , S1C('/') , psttDll ) ) ;
                                                        etThread.dllOpenF( tinP , hDll , T("ideafarm.")+T(psttDll)+T(".ipdos-wm") ) ;
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN92 ) ;
                                                    }
                                                    else
                                                    {
                                                        _IO_
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINa2 ) ;

                                                        // THIS WILL BE DONE IF THE EXE IMAGE IS COMING FROM THE HOVER DIRECTORY
                                                        // IPDOS PROCESSES ARE NORMALLY LOADED FROM THE HOVER DIRECTORY
                                                        // THE MAIN (PERHAPS ONLY) REASON FOR THIS IS TO MAKE "HOT UPDATING" POSSIBLE

                                                        // A MASTER FILE CAN BE UPDATED WHILE ITS CORRESPONDING HOVER FILE IS LOADED AND IN USE BY RUNNING PROCESSES

                                                        // THE FOLLOWING COMMENTS ARE OBSOLETE; MULTIPLE INSTANCES CAN COEXIST (SEE E.G. ifcIDaDAM_CLOUD); THE OLD HANDOFF CODE WAS DISABLED/REMOVED AND CODE RELATED TO SAVING AND LOADING ADAM STATE IS DISABLED OR IN AN UNKNOWN UNUSED STATE
                                                        // BY DEFAULT, ONLY ONE INSTANCE OF AN ADAM CAN EXIST AT A TIME IN A HOME
                                                        // THE NEW INSTANCE WILL IMMEDIATELY ASSUME RESPONSIBILITY FOR ACCEPTING NEW CLIENTS
                                                        // THE OLD INSTANCE WILL COMPLETE ALL SERVICE TO EXISTING CLIENTS AND THEN TERMINATE

                                                        // THIS FEATURE IS BROKEN AND REQUIRES WORK
                                                        // state C IS OBSOLETED BY THE adam.perm POOL AND ALL state C CODE SHOULD BE MIGRATED AND THEN state C REMOVED

                                                        if( etThread.strIdF( tinP , S1C('/') , psttDll ) ) etThread.dllOpenF( tinP , hDll , psttDll ) ;
                                                        else
                                                        {
                                                            //hoverC hover( tinP , etThread , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/") ) ;
                                                            etThread.dllOpenF( tinP , hDll , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.")+T(psttDll)+T(".ipdos-wd") ) ;
                                                        }
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINb2 ) ;
                                                    }
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINc2 ) ;
                                                }

                                                ZE( mainFT , pMainF ) ;
                                                {
                                                    _IO_
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINd2 ) ;
                                                    TELL( "main: looking up the entry point" ) ;
                                                    etThread.delF( tinP , psttDll ) ;
                                                    __Z( hDll ) ;
                                                    etThread.dllEntryF( tinP , pMainF , hDll , T("mainF") ) ;
                                                    __Z( pMainF ) ;
                                                }

                                                TELL( "main: constructing mainS object" ) ;
                                                mainS main( tinP , ether , etThread , hDll , T("cid ")+tCid+T(" level 1") ) ;
                    
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINe2 ) ;
                                                TELL( "main: mainS object constructed" ) ;

                                                if( !pMainF || ether )
                                                {
                                                    _IO_
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINf2 ) ;
                                                    tinP.unwatchedF() ;
                                                }
                                                else
                                                {
                                                    _IO_
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN03 ) ;
                                                    declareVmUsageTypeGF( tinP , (byteT*)pMainF , flVMuSAGEtYPE_CODEaDAM ) ;
                                                    TELLsYSc1( ifcIDtYPEtELLsYS_AOKfYIaBOUTtOcALLaDAMmAIN ) 
                                                    TELL( "main: calling pMainF" ) ;
            
                                                    {
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN13 ) ;
                                                        _IO_
                                                        //etherC::ifcSayIF( T("calling pMainF") , flSAY_APPEND | flSAY_LOG ) ;
                                                        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }

                                                        static countT idAdamWant = 0x401057b ; //TO FACILITATE WDW DEBUGGING
                                                        if( idAdamWant == tinP.pAdamGlobal1->idAdam )
                                                        {
                                                            countT foo = 2 ;
                                                        }

                                                        __( tinP.pAdamGlobal1->idMemorySpace - rootAdamGlobal1I.idMemorySpace ) ; // THIS ENSURES THAT ALL ADAMS WITHIN A PROCESS ARE USING THE SAME MEMORY SPACE (THEY HAVE ACCESS TO PROCESS GLOBALS THAT USE A MEMORY SPACE)

                                                        cryC cry0c( TOCK + 0x0c ) ;
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN23 ) ;
                                                        {
                                                            _IO_
                                                            (*pMainF)( &main ) ; // ASSUME: WILL NOT RETURN UNTIL ALL KID THREADS HAVE ENDED, INCLUDING tmWatchF
                                                        }
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN1 ) ;
                                                        cryC cry0d( TOCK + 0x0d ) ;
                                                        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                                        //etherC::ifcSayIF( T("called pMainF") , flSAY_APPEND | flSAY_LOG ) ;
                                                        tinP.unwatchedF() ;
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN2 ) ;
                                                    }
                                                    TELL( "main: returned from pMainF" ) ;
                                                    TELLsYSc1( ifcIDtYPEtELLsYS_AOKfYIjUSTcALLEDaDAMmAIN ) 
                                                }
                                                if( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_WHEREaLL ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;

                                                if( idTypeP == ifcIDtYPEtLS_WINDOW )
                                                {
                                                    DELzOMBIE( pDisplay ) ;
                                                    DEL( tinP.pAdamGlobal1->_deviceC_pStkJob ) ;
                                                }
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN3 ) ;
                                            }
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN4 ) ;
                                            thirdC::s_shutdown1IF( tinP ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN5 ) ;
                                            if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                        }
                    
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN6 ) ;
                                        tinP.tally.bTally = 0 ;
                                        tinP.tally.nowF( tinP , etThread ) ;
                                        tinP.tally.flushF( tinP , etThread ) ;
                    
                                        //tinP.pEther = 0 ;
                                        //if( etThread ) thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_etThreadONmainISiMPOTENT ;
                                        TELL( "main: inspecting phase" ) ;
                                        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                        TELL( "main: destroying pEtScratch" ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN7 ) ;
                                        DEL( tinP.pEtScratch ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN8 ) ;
        
                                        TELL( "main: inspecting phase 2" ) ;
                                        {
                                            TINSL
                                            if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                        }

                                        TELL( "main: destroying log" ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN9 ) ;
                                        DEL( tinP.pAdamGlobal1->pBksLog ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINa ) ;

                                        //U::POOLS 2 3 4 WERE DESTROYED HERE

                                        //ether.traceF( tinP , T("disabling where") ) ;
                                        //ether.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
                                        //ether.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
                                        //ether.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;
                                        //tinP.monitor.idWhat2 = 0 ;

                                        TELL( "main: destroying etThread and tinP reference" ) ;

                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINb ) ;
                                    }
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINc ) ;
                                    {
                                        TINSL
                                        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                        TELL( "main: destroying ether" ) ;
                                    }
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINd ) ;
                                    // tinP IS DESTROYED HERE (BY etherC DT'OR)
                                }
                                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINe ) ;
                                if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINf ) ;
                            }

                            //THIS IS DONE HERE TO FLUSH PENDING inOutFrameC APP TELEMETRY WHILE poolC IS STILL AVAILABLE (AS OF THIS WRITING, tellC ALWAYS USES heap, SO WHETHER tinP.pPoolUse IS NONZE HAS NO EFFECT
                            //THE CODE IS RETAINED BECAUSE tellC MIGHT USE *tinP.pPoolUse IN THE FUTURE, AND ALSO FLUSHING ESTABLISHES A KNOWN STATE (AN EMPTY BUFFER) FOR PROCESS TERMINATION
                            //PSEUDOdUPLICATEcODE 360fc002 33000065
                            if( tinP.pbPendingInOutFramePackets )
                            {
                                THREADmODE4oN( flTHREADmODE4_INoUTfRAMEdOnOTcOLLECTaPPtELEMETRY | flTHREADmODE4_DOnOTfLUSHpENDINGaPPtELEMETRY ) ;

                                countT& cPending = *(countT*)tinP.pbPendingInOutFramePackets ;

                                if( cPending )
                                {
                                    tellInfoAppInOutFrameS* pPending = (tellInfoAppInOutFrameS*)( tinP.pbPendingInOutFramePackets + sizeof( countT ) ) ;

                                    if( cPending > CmAXpENDINGiNoUTfRAMEpACKETS )
                                    {
                                        CONoUTrAW5( "adamMainF error: [cPending,cMax]: " , cPending , " " , CmAXpENDINGiNoUTfRAMEpACKETS , "\r\n" ) ;
                                        LOGrAW5(    "adamMainF error: [cPending,cMax]: " , cPending , " " , CmAXpENDINGiNoUTfRAMEpACKETS , "\r\n" ) ;
                                        BLAMMO ;
                                    }

                                    {
                                        tellC tell( tinP , LF , 0 , ifcIDtYPEtELLaPP_INoUTaRRAY , tinP.pbPendingInOutFramePackets , sizeof( countT ) + cPending * sizeof( tellInfoAppInOutFrameS ) ) ;
                                        thirdC::dosTellMonitorIF( tinP , tell , ifcIDbOOKStELL_APP ) ;
                                    }

                                    cPending = 0 ;
                                }
                                THREADmODE4rESTORE
                            }

                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN01 ) ;
                        }
                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN11 ) ;
                    }
                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN21 ) ;
                    if( thirdC::third_cThirdObjectsI_IF( tinP ) ) ;//TELLsYSc1( ifcIDtYPEtELLsYS_ERRORsOMEtHIRDoBJECTSeXIST )
        
                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN31 ) ;
                    if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }

                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN41 ) ;
                    if( idTypeP == ifcIDtYPEtLS_WINDOW )
                    {
                        //if( idTypeP == ifcIDtYPEtLS_WINDOW && !idCmdShowP && !hPreviousWindowingClientP ) { ZE( countT , foo ) ; } //U:: CONJ: NOT NEEDED
                        thirdC::third_flagsProcessStateI_IF( tinP , flPROCESSsTATE_MAINtHREADcLEANUPiScOMPLETE , 1 ) ;
                        {
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                            while( !( F(thirdC::third_flagsProcessStateI_IF(tinP)) & flPROCESSsTATE_tmWindowsF_HASeNDED ) ) { ++ s ; thirdC::dosSleepRawIF( tinP , 250 ) ; }
                        }
                    }
                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN51 ) ;
                }
                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN61 ) ;
            }
            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN71 ) ;
            tinP.pAdamGlobal1->_etherC_.pHdll = 0 ;

            OStEXT(   ostoSay , TUCK << 2 ) ;
            OStEXTAK( ostoSay , "adamMainF [idAdam,cYieldHighWater,cSpins1,cSpins2,cSpins3,cSpins4]:    " ) ;
            OStEXTC(  ostoSay , tinP.pAdamGlobal1->idAdam , 0 ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , tinP.pAdamGlobal1->cYieldHighWater , 0 ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , tinP.pAdamGlobal1->cSpins1 , '0' ) ;
            OStEXTAK( ostoSay , "." ) ;
            OStEXTC(  ostoSay , tinP.pAdamGlobal1->cSpins2 , '0' ) ;
            OStEXTAK( ostoSay , "." ) ;
            OStEXTC(  ostoSay , tinP.pAdamGlobal1->cSpins3 , '0' ) ;
            OStEXTAK( ostoSay , "." ) ;
            OStEXTC(  ostoSay , tinP.pAdamGlobal1->cSpins4 , '0' ) ;
            etherC::etRockIF( tinP ).traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;

            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN81 ) ;
        }
        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN91 ) ;
        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        //tinP.pc Utility[ 0 ] -- ; //U::TO FIND A BUG
    }
    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINb1 ) ;

    //U:: TO FIND A BUG
    //CS:DUPLICATE: 3612c002 3612c003
    if( processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH07 )
    {
        if( processGlobal4I.tinVeryEarlyLateMain.pEther )
        { CONoUTrAW3( "adamMainF set   [pEther]" , processGlobal4I.tinVeryEarlyLateMain.pEther , "\r\n" ) ; }
    }

    return POOP ? ifcEXITcODEpROCESSiMPOTENT : ifcEXITcODEpROCESSaOK ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000065.adammainf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000066.tmadammainf BEGIN
#define DDNAME       "3func.33000066.tmadammainf"
#define DDNUMB      (countT)0x33000066
#define IDFILE      (countT)0x951


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

countT tmAdamMainF_workF( countT argP )
{
    taskS* pTaskP = (taskS*)argP ;
    ZE( countT , rc ) ;
    if( pTaskP && pTaskP->c1 && pTaskP->c3 )
    {
        TINSL
        {
            _IO_
    
            countT              idAdamP   =                      pTaskP->c1 ;
            osTextT*            postArgsP =            (osTextT*)pTaskP->c2 ;
            parm_tmAdamMainF_S* pamP      = (parm_tmAdamMainF_S*)pTaskP->c3 ;

            adamGlobal1S* const pag1save = tinP.pAdamGlobal1 ; tinP.pAdamGlobal1 = pamP->pag1 ;
            adamGlobal2S* const pag2save = tinP.pAdamGlobal2 ; tinP.pAdamGlobal2 = pamP->pag2 ;
            adamGlobal3S* const pag3save = tinP.pAdamGlobal3 ; tinP.pAdamGlobal3 = pamP->pag3 ;
            adamGlobal4S* const pag4save = tinP.pAdamGlobal4 ; tinP.pAdamGlobal4 = pamP->pag4 ;
            adamGlobal5S* const pag5save = tinP.pAdamGlobal5 ; tinP.pAdamGlobal5 = pamP->pag5 ;
            adamGlobal6S* const pag6save = tinP.pAdamGlobal6 ; tinP.pAdamGlobal6 = pamP->pag6 ;
    
            OStEXT(   ostoCmdLine , 0x80 )
            OStEXTCF(  ostoCmdLine , idAdamP , 0 )
            if( postArgsP )
            {
                OStEXTAK( ostoCmdLine , " " )
                OStEXTA(  ostoCmdLine , postArgsP )
            }
        
            if( postArgsP ) PUSE( tinP , postArgsP ) ;

            {
                _IO_
                {                                                      //20181112@2041: CONJ: THE NEXT LINE'S COMMENT IS WRONG.  THERE IS NOTHING WRONG WITH USING tinP, WHICH I THINK WAS CT BY A CALLER
                    poolC* pSave = tinP.pPoolUse ; tinP.pPoolUse = 0 ; //U::BUG: I SHOULD NOT BE PASSING MY OWN tinP INTO adamMainF ; I SHOULD CT A VIRGIN tinS
                    rc = adamMainF( tinP , ifcIDtYPEtLS_WITHINpROCESS , 0 , 0 , 0 , 0 , ostoCmdLine , 0 ) ;
                    tinP.pPoolUse = pSave ;
                }
            }
            __( rc - ifcEXITcODEpROCESSaOK ) ;
    
            dec02AM( pamP->dadAg1.cThreadsWatched ) ;

            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
            {
                puseC( tinP , pamP->poolUsedByLauncher ) ;
                DEL( pamP ) ;
            }
            THREADmODE2rESTORE

            tinP.pAdamGlobal1 = pag1save ;
            tinP.pAdamGlobal2 = pag2save ;
            tinP.pAdamGlobal3 = pag3save ;
            tinP.pAdamGlobal4 = pag4save ;
            tinP.pAdamGlobal5 = pag5save ;
            tinP.pAdamGlobal6 = pag6save ;
    
            dec02AM( thirdC::os_cAllKidThreadsI_IF( tinP ) ) ;
    
        }
        DEL( pTaskP ) ;
    }

    return rc ;
}

/*1*/TASK0PROTO( tmAdamMainF )/*1*/
{
    return threadLocalStorageF( ifcIDtYPEtLS_KID , tmAdamMainF_workF , (countT)argP , 0 , 0 , 0 , 0 , "tmAdamMainF" ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000066.tmadammainf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300006a.pushfieldvaluesf BEGIN
#define DDNAME       "3func.3300006a.pushfieldvaluesf"
#define DDNUMB      (countT)0x3300006a
#define IDFILE      (countT)0x952


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT pushFieldValuesF( tinS& tinP , stackC& stToP , stackC& stFromP )/*1*/
{
    while( stFromP )
    {
        ZE( strokeS* , psttw ) ;
        stFromP >> psttw ; ___( psttw ) ;
        stToP << psttw ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300006a.pushfieldvaluesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300006b.pushfieldvaluesf BEGIN
#define DDNAME       "3func.3300006b.pushfieldvaluesf"
#define DDNUMB      (countT)0x3300006b
#define IDFILE      (countT)0x953


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/
/*1*/voidT pushFieldValuesF( tinS& tinP , soulC& sP , stackC* const pStkP )/*1*/
{
    if( !pStkP ) sP << (countT)0 ;
    else
    {
        sP << (countT)*pStkP ;
        while( *pStkP )
        {
            ZE( strokeS* , psttw ) ;
            *pStkP >> psttw ; ___( psttw ) ;
            sP << psttw ;
            PUSE( tinP , *(byteT**)&psttw ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300006b.pushfieldvaluesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300006c.addf BEGIN
#define DDNAME       "3func.3300006c.addf"
#define DDNUMB      (countT)0x3300006c
#define IDFILE      (countT)0x954


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
arguments
 tinP
 pcpP
  if 0 then i will allocate from PUSE and set to result
  if not 0 then must equal pcp1P, and I will set pcp1P to the result
   20190114@0841: this appears to no longer be required by the code ( pcpP need not equal pcp1P)
 pcp1P
 pcp2P
 bSignedP
*/
/**/

/*1*/voidT addF( tinS& tinP , countT*& pcpP , countT* const pcp1P , const countT* const pcp2P , const boolT bSignedP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __Z( pcp1P ) ;
        __Z( pcp2P ) ;
        if( POOP ) return ;

        //20190114@1142: CANNOT DO THIS WITH CURRENT CODE BECAUSE pcpP CAN POINT TO PREALLOCATED STRING OF TUCK NULL COUNTS
        //if( pcpP )                  //20190114@0839: ADDED THIS BLOCK OF TESTS WITHOUT ANALYSIS BECAUSE APPARENTLY IMPLICITLY ASSUMED BY THIS CODE
        //{
        //    __( *pcpP < *pcp1P ) ;
        //    __( *pcpP < *pcp2P ) ;
        //}
        //if( POOP ) return ;
    }

    _IO_

    const countT ccMax = *pcp1P > *pcp2P                        //U::20190114@0844: THIS FUNCTION NEEDS TO BE STUDIED CLOSELY TO VERIFY CORRECT FUNCTION, AS IT APPEARED TO CONTAIN A MEMORY TRASHING BUG AND THE CODE WAS NOT CONSISTENT WITH THE COMMENTS
        ? *pcp1P                                                //TO FACILITATE THIS STUDY, CONJ: bSignedP IS NEVER USED AND PERHAPS !pcpP IS NEVER USED (pcpP IS ALWAYS PREALLOCATED BY THE CALLER)
        : *pcp2P                                                //ALT: REWRITE TO USE ONLY OO PARAMETERS (OTHER THAN bSignedP) RATHER THAN RE, TO ELIMINATE pcp2P
    ;

    if( !pcpP )
    {
        countT cba = sizeof( countT ) * ( ( 1 + !bSignedP ) + ccMax ) ;
        PUSE.newF( tinP , LF , *(byteT**)&pcpP , cba ) ; //CALLER MUST TAG ; INCLUDES SPACE FOR OVERFLOW AS WELL AS THE PREFIX ___( pcpP ) ;
        thirdC::c_memsetIF( tinP , (byteT*)pcpP , cba ) ;
    }

    if( pcpP )
    {
        if( pcpP != pcp1P )
        {
            thirdC::c_memsetIF( tinP , (byteT*)pcpP                 , sizeof( countT ) * ( 1 + ccMax  ) ) ;                          //20190114@0826: "2 + ccMax" -> "1 + ccMax" WITHOUT ANALYSIS TO FIX OBSERVED HEAP TRASHING BY RESETTING TOO MANY BYTES AT HEAP ITEM CREATED BY PUSE.newF( tinP , LF , *(byteT**)&PCPiDbOOKnOW , sizeof( countT ) * *pcpOffIdBookWant ) ; ___( PCPiDbOOKnOW ) ; IN booksC::readF( tinS& tinP , const byteT*& pbP , countT& cbP , handleC& handleP , const flagsT flagsP , const boolT* pbQuitP , handleC* const phCursorP , const countT idCursorP )
            thirdC::c_memcpyIF( tinP , (byteT*)pcpP , (byteT*)pcp1P , sizeof( countT ) * ( 1 + *pcp1P ) ) ;
        }

        if( *pcpP < *pcp2P )
        {
            if( (sCountT)pcpP[ *pcpP ] < 0 )
            {
                for( countT offo = *pcpP + 1 ; offo <= *pcp2P ; offo ++ ) pcpP[ offo ] = - 1 ; //PROPOGATE SIGN
            }

            *pcpP += *pcp2P - *pcpP ;
        }

        ZE( boolT , bCarry ) ;
        const countT cci = *pcp2P ;
        ZE( countT , offi ) ;
        for( offi = 1 ; offi <= cci ; offi ++ )
        {
            if( bCarry )
            {
                pcpP[ offi ] ++ ;
                bCarry = !pcpP[ offi ] ;
            }
    
            countT save = pcpP[ offi ] ;
            pcpP[ offi ] += pcp2P[ offi ] ;
    
            if( pcpP[ offi ] < save ) bCarry = 1 ;
        }

        if( bCarry && !bSignedP )
        {
            ++ *pcpP ;
            pcpP[ offi ] ++ ;
        }

        while( *pcpP > 1 && !pcpP[ *pcpP ] ) -- *pcpP ;

        if( bSignedP ) while( *pcpP > 1 && pcpP[ *pcpP ] == - 1 && (sCountT)pcpP[ *pcpP - 1 ] < 0 ) -- *pcpP ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300006c.addf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300006d.subtractf BEGIN
#define DDNAME       "3func.3300006d.subtractf"
#define DDNUMB      (countT)0x3300006d
#define IDFILE      (countT)0x955


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i calculate pcp1P - pcp2P
i evaluate to wo of {-1,0,1}
 1: pcp1P > pcp2P
 0: pcp1P == pcp2P
 -1: pcp1P < pcp2P
*/
/**/

countT pcpi[ TUCK ] ;

/*1*/sCountT subtractF( tinS& tinP , countT*& pcpP , countT* const pcp1P , const countT* const pcp2P , const boolT bSignedP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return 0 ;
        __NZ( pcpP ) ;
        __Z( pcp1P ) ;
        __Z( pcp2P ) ;
        __( !tinP.pPoolUse && tinP.monitor.idThread != 1 ) ;
        if( POOP ) return 0 ;
    }

    _IO_

    const countT ccMax = *pcp1P > *pcp2P
        ? *pcp1P
        : *pcp2P
    ;

    __( sizeof pcpi < ( 1 + ccMax ) * sizeof( countT ) ) ;

    ZE( sCountT , sgn ) ;
    if( !POOP )
    {
        if( !tinP.pPoolUse ) pcpP = pcpi ;
        else
        {
            PUSE.newF( tinP , LF , *(byteT**)&pcpP , sizeof( countT ) * ( ( 1 + !bSignedP ) + ccMax ) ) ; ___( pcpP ) ;
        }

        if( pcpP )
        {
            thirdC::c_memsetIF( tinP , (byteT*)pcpP , sizeof( countT ) * ( 2 + ccMax ) ) ;
            thirdC::c_memcpyIF( tinP , (byteT*)pcpP , (byteT*)pcp1P , sizeof( countT ) * ( 1 + *pcp1P ) ) ;
    
            if( *pcpP < *pcp2P )
            {
                if( (sCountT)pcpP[ *pcpP ] < 0 )
                {
                    for( countT offo = *pcpP + 1 ; offo <= *pcp2P ; offo ++ ) pcpP[ offo ] = - 1 ; //PROPOGATE SIGN
                }
    
                *pcpP += *pcp2P - *pcpP ;
            }
    
            ZE( boolT , bCarry ) ;
            const countT cci = *pcp2P ;
            ZE( countT , offi ) ;
            for( offi = 1 ; offi <= cci ; offi ++ )
            {
                if( bCarry )
                {
                    pcpP[ offi ] -- ;
                    bCarry = pcpP[ offi ] == - 1 ;
                }
        
                countT save = pcpP[ offi ] ;
                pcpP[ offi ] -= pcp2P[ offi ] ;
        
                if( pcpP[ offi ] > save ) bCarry = 1 ;
            }
    
            if( bCarry && !bSignedP )
            {
                ++ *pcpP ;
                pcpP[ offi ] -- ;
            }
    
            while( *pcpP > 1 && !pcpP[ *pcpP ] ) -- *pcpP ;
    
            if( bSignedP ) while( *pcpP > 1 && pcpP[ *pcpP ] == - 1 && (sCountT)pcpP[ *pcpP - 1 ] < 0 ) -- *pcpP ;
        }

        sgn = (sCountT)pcpP[ *pcpP ] < 0
            ? - 1
            : (sCountT)pcpP[ *pcpP ] > 0
                ? 1
                : 0
        ;

        if( !tinP.pPoolUse ) pcpP = 0 ;
    }

    return sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300006d.subtractf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300006e.listwalkchattercbf BEGIN
#define DDNAME       "3func.3300006e.listwalkchattercbf"
#define DDNUMB      (countT)0x3300006e
#define IDFILE      (countT)0x956


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkChatterCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    listingC* pListing                 = tinP.ta.pushed.u.listWalk.cbf.pListingP ;
    flagsT    flagsP                   = tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] ;
    countT    cbJotStringDecodePrefixP = tinP.ta.pushed.u.listWalk.util.pcP[ 2 ] ;
    FV( flLISTwALKcHATTER , flagsP ) ;

    const countT levelOoNameMe  = !pListing                          ? 0 : pListing->nameF( 2 )                          ;
    const countT levelOoNameDad = !tinP.ta.pushed.u.listWalk.cbf.pDadP ? 0 : tinP.ta.pushed.u.listWalk.cbf.pDadP->nameF( 2 ) ;

    const countT levelReNameMe  = !pListing                          ? 0 : pListing->nameF( 3 )                          ;
    const countT levelReNameDad = !tinP.ta.pushed.u.listWalk.cbf.pDadP ? 0 : tinP.ta.pushed.u.listWalk.cbf.pDadP->nameF( 3 ) ;

    const countT levelOoNameUse = levelOoNameMe ? levelOoNameMe : levelOoNameDad ;
    const countT levelReNameUse = levelReNameMe ? levelReNameMe : levelReNameDad ;

    const boolT bUseDictionary =                                             // 20180508@1624: AVOID DICTIONARY IF SYSTEM1 OR SYSTEM3 (ADDED WITHOUT ANALYSIS TO ELIMINATE DEADLOCK IN ADAM 206 (602_) WHICH USED TO WORK AOK)
             levelOoNameUse 
        && ( levelOoNameUse != LISTnAME_ROOTsYSTEM2 || levelReNameUse != LISTnAME_DICTIONARY )
    ;

    THREADmODE2oN( flTHREADmODE2_ALLOWdICTIONARYwHILEgRABBING )
    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )                         // MY CALLER MIGHT HAVE GRABBED LISTnAME_ROOT, WHICH COULD DEADLOCK sexC::sexC

    if( tinP.ta.pushed.u.listWalk.cbf.idCallP == 1 )
    {
        IFsCRATCH
        {
            SCOOPS
            for( countT max = TOCK ;; max <<= 1 )
            {
                ZE( strokeS* , pstto ) ;
                tinP.pEtScratch->strMakeF( tinP , LF , pstto , 0 , max ) ; ___( pstto ) ;

                tinP.pEtScratch->strFuseF( tinP , pstto , T(tinP.pPoolUse->postNameF(tinP)) ) ;
                tinP.pEtScratch->strFuseF( tinP , pstto , T(bUseDictionary?" | ------------------------------------------------------------------------------- ":" | ------------------------------------------------------------------------------- (NO DICTIONARY LOOKUP) ") ) ;

                ZE( countT* , pczName ) ;
                tinP.ta.pushed.u.listWalk.cbf.pDadP->nameF( tinP , pczName ) ; // ___( pczName ) ;

                ZE( countT* , pczSquished ) ;
                { puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ; etherC::strSquishIF( tinP , pczSquished , pczName ) ; ___( pczSquished ) ; }

                ZE( countT , offi ) ;
                while( pczSquished[ offi ] )
                {
                    const osTextT* postzMap = processGlobal3I.mapListName( pczSquished[ offi ] ) ;

                    if( postzMap ) { tinP.pEtScratch->strFuseF( tinP , pstto , T(postzMap) ) ; }
                    else
                    {
                        blobVSP vspo ;
                        if( bUseDictionary ) vspo = listC::dictionaryQueryFromIdIF( tinP , pczSquished[ offi ] ) ;
            
                        if( !(const byteT*)vspo ) { tinP.pEtScratch->strFuseF( tinP , pstto , TF2(pczSquished[offi],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ; }
                        else            
                        {
                            tinP.pEtScratch->strFuseF( tinP , pstto , T("\"") ) ;
                            tinP.pEtScratch->strFuseF( tinP , pstto , T((const byteT*)vspo) ) ;
                            tinP.pEtScratch->strFuseF( tinP , pstto , T("\"") ) ;
                        }
                    }

                    if( pczSquished[ ++ offi ] ) { tinP.pEtScratch->strFuseF( tinP , pstto , T("/") ) ; }
                }
                //{ puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ; PUSE( tinP , *(byteT**)&pczName ) ; }
                tinP.tlsDelF( *(byteT**)&pczName ) ;
                { puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ; PUSE( tinP , *(byteT**)&pczSquished ) ; }

                if( !POOP )
                {
                    tinP.pEtScratch->traceF( tinP , pstto ) ;
                    tinP.pEtScratch->delF( tinP , pstto ) ;
                    break ;
                }
                else
                {
                    POOPR
                    tinP.pEtScratch->delF( tinP , pstto ) ;
                }
            }
        }
    }

    flagsT flrc = flLISTwALKcALLbACKrETURNcODE_null ;
    if( pListing )
    {
        aptC aptListing( tinP , pListing ) ;

        if( !listingC::bIsListingIF( tinP , aptListing ) )
        {
            CONoUTrAW( "EXCEPTION: An apartment was encountered that does not contain a valid listingC object.  quitting\r\n" ) ;
            flrc |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
        }
        else
        {
            ZE( countT*  , pcValue ) ;
            ZE( osTextT* , postValue ) ;
            ZE( countT*  , pczValue ) ;
            listingVSP       vspValue ;
    
            flagsT flagsi = pListing->flagsF() ;
            if( flagsi & fliLISTINGc_MIXINdATUM )
            {
                if( !( flagsi & fliLISTINGc_MIXINlIST ) )
                {
                    switch( pListing->idTypeDatumF() ) //CS:CODEsYNC: 00104b0 21e0006 21e0002 21e0008 21e0009 220000e
                    {
                        case ifcIDtYPEmIXINdATUM_countT     : { pcValue   =     (countT*)*(listing_countT_C*)pListing ; break ; }
                        case ifcIDtYPEmIXINdATUM_blob       : { postValue =      (osTextT*)*(listing_blob_C*)pListing ; break ; }
                        case ifcIDtYPEmIXINdATUM_countTstrz : { pczValue  = (countT*)*(listing_countTstrz_C*)pListing ; break ; }
                        case ifcIDtYPEmIXINdATUM_listingVSP : { vspValue  =          *(listing_listingVSP_C*)pListing ; break ; }
                        default                             : { BLAMMO                                                ; break ; }
                    }
                }
                else
                {
                    switch( pListing->idTypeDatumF() ) //CS:CODEsYNC: 00104b0 21e0006 21e0002 21e0008 21e0009 220000e
                    {
                        case ifcIDtYPEmIXINdATUM_countT     : { pcValue   =        (countT*)*(list_countT_C*)pListing ; break ; }
                        case ifcIDtYPEmIXINdATUM_blob       : { postValue =         (osTextT*)*(list_blob_C*)pListing ; break ; }
                        case ifcIDtYPEmIXINdATUM_countTstrz : { pczValue  =    (countT*)*(list_countTstrz_C*)pListing ; break ; }
                        case ifcIDtYPEmIXINdATUM_listingVSP : { vspValue  =             *(list_listingVSP_C*)pListing ; break ; }
                        default                             : { BLAMMO                                                ; break ; }
                    }
                }
            }
    
            osTextT* postMark = flagsi & fliLISTINGc_MIXINlIST
                ? "LIST    "
                : "listing "
            ;
    
            ZE( countT   , cName ) ;
            blobVSP vspbName ;
            ZE( const byteT* , postzName ) ;
            if( flagsi & fliLISTINGc_MIXINlIST )
            {
                listC* pList = (listC*)pListing ;
                cName = pList->nameF() ;

                const osTextT* postzMap = processGlobal3I.mapListName( cName ) ;

                if( postzMap && !thirdC::c_strcmpIF( tinP , postzMap , "ROOTaPPLICATION" ) )
                {
                    countT foo = 2 ;
                }

                if( postzMap ) postzName = postzMap ;
                else if( bUseDictionary && cName )
                {
                    vspbName = listC::dictionaryQueryFromIdIF( tinP , cName ) ;
                    if( (const byteT*)vspbName ) postzName = (const byteT*)vspbName ;
                }
            }

            IFsCRATCH
            {
                SCOOPS
                for( countT max = TOCK ;; max <<= 1 )
                {
                    ZE( strokeS* , pstto ) ;
                    tinP.pEtScratch->strMakeF( tinP , LF , pstto , 0 , max ) ; ___( pstto ) ;

                    tinP.pEtScratch->strFuseF( tinP , pstto , T(tinP.pPoolUse->postNameF(tinP)) ) ;
                    tinP.pEtScratch->strFuseF( tinP , pstto , T(" | ") ) ;
                    tinP.pEtScratch->strFuseF( tinP , pstto , TF2(tinP.ta.pushed.u.listWalk.walk.cRecurseP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    tinP.pEtScratch->strFuseF( tinP , pstto , T(" | p: ") ) ;
                    tinP.pEtScratch->strFuseF( tinP , pstto , TF2((countT)pListing,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    tinP.pEtScratch->strFuseF( tinP , pstto , T(" | a: ") ) ;
                    tinP.pEtScratch->strFuseF( tinP , pstto , TF2(aptListing,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    tinP.pEtScratch->strFuseF( tinP , pstto , T(" | ") ) ;
                    tinP.pEtScratch->strFuseF( tinP , pstto , T(postMark) ) ;
                    if( postzName )
                    {
                        tinP.pEtScratch->strFuseF( tinP , pstto , T(postzName) ) ;
                        tinP.pEtScratch->strFuseF( tinP , pstto , T(" ") ) ;
                    }
                    else if( cName )
                    {
                        tinP.pEtScratch->strFuseF( tinP , pstto , TF2(cName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        tinP.pEtScratch->strFuseF( tinP , pstto , T(" ") ) ;
                    }

                    if( pcValue )
                    {
                        tinP.pEtScratch->strFuseF( tinP , pstto , T("countT: ") ) ;
                        tinP.pEtScratch->strFuseF( tinP , pstto , TF2(*pcValue,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        if( F(flagsP) & flLISTwALKcHATTER_MAPiDjOTvALUES )
                        {
                            ZE( strokeS* , psttJot ) ;
                            tinP.pEtScratch->strFromIdJotF( tinP , psttJot , *pcValue , cbJotStringDecodePrefixP ) ; ___( psttJot ) ;
                            if( POOP ) POOPR
                            else
                            {
                                tinP.pEtScratch->strFuseF( tinP , pstto , T("    ")+T(psttJot) ) ;
                                tinP.pEtScratch->delF( tinP , psttJot ) ;
                            }
                        }
                    }
                    else if( postValue )
                    {
                        countT cbv = ((countT*)postValue)[ - 1 ] ;
                        countT offNull = cbv - 1 ;
                        byteT  bText = !postValue[ offNull ] ;
                        if( bText )
                        {
                            for( countT offi = 0 ; offi < offNull ; offi ++ )
                            {
                                byteT test = postValue[ offi ] ;
                                if( !test || test < 0x20 || test > 0x7f )
                                {
                                    bText = 0 ;
                                    break ;
                                }
                            }
                        }

                        if( bText )
                        {
                            tinP.pEtScratch->strFuseF( tinP , pstto , T("blob: \"") ) ;
                            tinP.pEtScratch->strFuseF( tinP , pstto , T(postValue) ) ;
                            tinP.pEtScratch->strFuseF( tinP , pstto , T("\"") ) ;
                        }
                        else
                        {
                            boolT bPartial = cbv > TUCK ;

                            static countT idInLath ;
                            countT idIn = 1 + incv02AM( idInLath ) ;

                            if( idIn == 0x18 )
                            {
                                countT foo = 2 ;
                            }

                            ZE( strokeS* , psttw ) ;
                            tinP.pEtScratch->strDumpIF( tinP , psttw , postValue , bPartial ? TUCK : cbv , flSTRdUMP_null , 0x20 , 4 , '~' ) ; ___( psttw ) ;
                            tinP.pEtScratch->strFuseF( tinP , pstto , T("blob):\r\n") ) ;
                            tinP.pEtScratch->strFuseF( tinP , pstto , T(psttw) ) ;
                            if( bPartial ) tinP.pEtScratch->strFuseF( tinP , pstto , (strokeS*)( T(" ... (there are ")+TF2(cbv,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" total bytes)") ) ) ;
                            tinP.pEtScratch->delF( tinP , psttw ) ;
                        }
                    }
                    else if( pczValue )
                    {
                        tinP.pEtScratch->strFuseF( tinP , pstto , T("countTstrz: ") ) ;

                        countT offo = 0 ;
                        while( pczValue[ offo ] )
                        {
                            const osTextT* postzMap = processGlobal3I.mapListName( pczValue[ offo ] ) ;
                            if( postzMap ) { tinP.pEtScratch->strFuseF( tinP , pstto , T(postzMap) ) ; }
                            else
                            {
                                blobVSP vspo ;
                                if( bUseDictionary ) vspo = listC::dictionaryQueryFromIdIF( tinP , pczValue[ offo ] ) ;
            
                                if( !(const byteT*)vspo ) { tinP.pEtScratch->strFuseF( tinP , pstto , TF2(pczValue[offo],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; }
                                else            
                                {
                                    tinP.pEtScratch->strFuseF( tinP , pstto , T("\"") ) ;
                                    tinP.pEtScratch->strFuseF( tinP , pstto , T((const byteT*)vspo) ) ;
                                    tinP.pEtScratch->strFuseF( tinP , pstto , T("\"") ) ;
                                }
                            }

                            if( pczValue[ ++ offo ] ) { tinP.pEtScratch->strFuseF( tinP , pstto , T("/") ) ; }
                        }
                    }
                    else if( (const listingC*)vspValue )
                    {
                        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;
                        {
                            poolC* pPool = poolC::pPoolIF( tinP , (byteT*)(const listingC*)vspValue ) ;
                            __Z( pPool ) ;

                            puseC puseRecord( tinP , *pPool ) ;
            
                            aptC aptRef( tinP , vspValue ) ;
            
                            tinP.pEtScratch->strFuseF( tinP , pstto , T("listingVSP: p: ") ) ;
                            tinP.pEtScratch->strFuseF( tinP , pstto , TF2((countT)(const listingC*)vspValue,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            tinP.pEtScratch->strFuseF( tinP , pstto , T(" a: ") ) ;
                            tinP.pEtScratch->strFuseF( tinP , pstto , TF2(aptRef,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            const osTextT* postNamePool = tinP.pPoolUse ? tinP.pPoolUse->postNameF( tinP ) : 0 ;
                            if( postNamePool )
                            {
                                tinP.pEtScratch->strFuseF( tinP , pstto , T(" in pool: \"") ) ;
                                tinP.pEtScratch->strFuseF( tinP , pstto , T(postNamePool) ) ;
                                tinP.pEtScratch->strFuseF( tinP , pstto , T("\"") ) ;
                            }
                            if( flagsi & fliLISTINGc_DELETErEQUESTED ) tinP.pEtScratch->strFuseF( tinP , pstto , T(" DELETErEQUESTED") ) ;

                            ZE( countT* , pczHe ) ;
                            ((const listingC*)vspValue)->nameF( tinP , pczHe ) ; //___( pczHe ) ;

                            tinP.pEtScratch->strFuseF( tinP , pstto , T(" Refers to: ") ) ;
                            countT offo = 0 ;
                            while( pczHe[ offo ] )
                            {
                                const osTextT* postzMap = processGlobal3I.mapListName( pczHe[ offo ] ) ;
                                if( postzMap ) { tinP.pEtScratch->strFuseF( tinP , pstto , T(postzMap) ) ; }
                                else
                                {
                                    blobVSP vspo ;
                                    if( bUseDictionary ) vspo = listC::dictionaryQueryFromIdIF( tinP , pczHe[ offo ] ) ;
                
                                    if( !(const byteT*)vspo ) { tinP.pEtScratch->strFuseF( tinP , pstto , TF2(pczHe[offo],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; }
                                    else            
                                    {
                                        tinP.pEtScratch->strFuseF( tinP , pstto , T("\"") ) ;
                                        tinP.pEtScratch->strFuseF( tinP , pstto , T((const byteT*)vspo) ) ;
                                        tinP.pEtScratch->strFuseF( tinP , pstto , T("\"") ) ;
                                    }
                                }
            
                                if( pczHe[ ++ offo ] ) { tinP.pEtScratch->strFuseF( tinP , pstto , T("/") ) ; }
                            }

                            //{ puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ; PUSE( tinP , *(byteT**)&pczHe ) ; }
                            tinP.tlsDelF( *(byteT**)&pczHe ) ;
                        }
                        THREADmODE1rESTORE
                    }

                    if( flagsi & fliLISTINGc_DELETErEQUESTED ) tinP.pEtScratch->strFuseF( tinP , pstto , T("DELETErEQUESTED") ) ;

                    if( !POOP )
                    {
                        tinP.pEtScratch->traceF( tinP , pstto ) ;
                        tinP.pEtScratch->delF( tinP , pstto ) ;
                        break ;
                    }
                    else
                    {
                        POOPR
                        tinP.pEtScratch->delF( tinP , pstto ) ;
                    }
                }
            }
        }
    }

    THREADmODE3rESTORE
    THREADmODE2rESTORE
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flrc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300006e.listwalkchattercbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300006f.listwalkdeletelistcbf BEGIN
#define DDNAME       "3func.3300006f.listwalkdeletelistcbf"
#define DDNUMB      (countT)0x3300006f
#define IDFILE      (countT)0x957


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkDeleteListCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    flagsT flagsRC      = flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE ;
    listingC* pListing  = tinP.ta.pushed.u.listWalk.cbf.pListingP ;
    countT idName       = tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] ;
    flagsT flagsP       = tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] ;
    flagsT& flagsWalkRC = *(flagsT*)tinP.ta.pushed.u.listWalk.util.pcP[ 2 ] ;

    if
    (
        pListing
        &&
        (
            !( pListing->flagsF() & fliLISTINGc_MIXINlIST )
            ||
            (
                ( !idName || idName == pListing->nameF() ) 
                &&
                ( !( F(flagsP) & flLISTdELETE_IFeMPTY ) || ((listC*)pListing)->isEmptyF() )
            )
        )
    )
    {
        flagsRC     |= flLISTwALKcALLbACKrETURNcODE_DELETE ; //I DO NOT ASSUME THAT idName IS UNIQUE AND WILL CONTINUE TO WALK THE ENTIRE DAD LIST
        flagsWalkRC |= flLISTwALKrETURNcODE_LISTINGdELETED ;
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flagsRC ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300006f.listwalkdeletelistcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000070.listwalkselectcbf BEGIN
#define DDNAME       "3func.33000070.listwalkselectcbf"
#define DDNUMB      (countT)0x33000070
#define IDFILE      (countT)0x958


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT _export listWalkSelectCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    listingC* pListing = tinP.ta.pushed.u.listWalk.cbf.pListingP ;

    if( pListing && !( pListing->flagsF() & fliLISTINGc_MIXINlIST ) && pListing->idTypeDatumF() == ifcIDtYPEmIXINdATUM_listingVSP )
    {
        listing_listingVSP_C& entry = *(listing_listingVSP_C*)pListing ;
        listingVSP spRecord = entry ;
    
        listC& record = *(listC*)(const listingC*)spRecord ;
        __( !listingC::bIsListingIF( tinP , &record ) ) ;
    
        //SINK UNIQUE A listingVSP for record INTO A TEMPORARY LIST
        {
            puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
        
            countT pczTo[] = { LISTnAME_ROOT , LISTnAME_ROOTsYSTEM4 , LISTnAME_TEMPORARY , LISTnAME_SELECTED , tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] , 0 } ;
            handleC hTo( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            listC::openIF( tinP , hTo , pczTo ) ;
        
            ZE( fieldEditParamOutC* , pOut ) ;
            countT pczField[] = { LISTnAME_RECORD , 0 } ;                                                                                                                                                 \
            listC::fieldIF( tinP , pOut , hTo , pczField , _1_pushC( record ) + _1_modePushSinkC() + _1_modeUniqueC() , LF ) ;
            DELlIST( fieldEditParamOutC , pOut ) ;
        }
    
        // grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
        // 
        // handleC hRecord( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
        // record.openF( tinP , hRecord ) ;
        // 
        // CONoUTrAW( "================== CHATTERING RECORD ==============================\r\n" ) ;
        // PUSHtINaRGS
        // tinP.ta.pushed.u.listWalk.walk.pListWalkCBFP = listWalkChatterCBF ;
        // tinP.ta.pushed.u.listWalk.walk.flagsWalkP = flLISTwALK_null ;
        // tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] = record.nameF() ;
        // tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] = flLISTwALKcHATTER_null ;
        // flagsT flagsRC = listC::walkIF( tinP , hRecord ) ;
        // POPtINaRGS
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000070.listwalkselectcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000071.listwalkselectandcbf BEGIN
#define DDNAME       "3func.33000071.listwalkselectandcbf"
#define DDNUMB      (countT)0x33000071
#define IDFILE      (countT)0x959


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT _export listWalkSelectAndCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    listingC* pListingP =            tinP.ta.pushed.u.listWalk.cbf.pListingP ;
    countT    idNameToP =            tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] ;
    selectC&  selectHeP = *(selectC*)tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] ;

    if( pListingP && !( pListingP->flagsF() & fliLISTINGc_MIXINlIST ) && pListingP->idTypeDatumF() == ifcIDtYPEmIXINdATUM_listingVSP )
    {
        listing_listingVSP_C& entry = *(listing_listingVSP_C*)pListingP ;
        listingVSP spRecord = entry ;

        const listingC& record = *(const listingC*)spRecord ;
        __( !listingC::bIsListingIF( tinP , &record ) ) ;

        ZE( boolT , isListed ) ;
        {
            puseC puseRecord( tinP , *tinP.ta.retained.u.listWalk.walk.pPoolRecord ) ;
            tinP.ta.retained.u.listWalk.walk.pPoolRecord = 0 ;
            isListed = selectHeP.isListedF( tinP , record ) ;
            tinP.ta.retained.u.listWalk.walk.pPoolRecord = &PUSE ;
        }

        if( isListed )
        {
            //SINK UNIQUE A listingVSP for record INTO A TEMPORARY LIST
            {
                puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
    
                countT pczTo[] = { LISTnAME_ROOT , LISTnAME_ROOTsYSTEM4 , LISTnAME_TEMPORARY , LISTnAME_SELECTED , idNameToP , 0 } ;
                handleC hTo( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                listC::openIF( tinP , hTo , pczTo ) ;
    
                ZE( fieldEditParamOutC* , pOut ) ;
                countT pczField[] = { LISTnAME_RECORD , 0 } ;                                                                                                                                                 \
                listC::fieldIF( tinP , pOut , hTo , pczField , _1_pushC( record ) + _1_modePushSinkC() + _1_modeUniqueC() , LF ) ;
                DELlIST( fieldEditParamOutC , pOut ) ;
            }
        }
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000071.listwalkselectandcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000072.listwalkselectwalkcbf BEGIN
#define DDNAME       "3func.33000072.listwalkselectwalkcbf"
#define DDNUMB      (countT)0x33000072
#define IDFILE      (countT)0x95a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT _export listWalkSelectWalkCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    listingC*      pListing        =                 tinP.ta.pushed.u.listWalk.cbf.pListingP ;
    selectWalkCBFT pSelectWalkCBFP = (selectWalkCBFT)tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] ;

    if( pListing && !( pListing->flagsF() & fliLISTINGc_MIXINlIST ) && pListing->idTypeDatumF() == ifcIDtYPEmIXINdATUM_listingVSP )
    {
        listing_listingVSP_C& entry = *(listing_listingVSP_C*)pListing ;
        listingVSP spRecord = entry ;

        listC& record = *(listC*)(const listingC*)spRecord ;
        __( !listingC::bIsListingIF( tinP , &record ) ) ;

        grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
        
        handleC hRecord( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
        record.openF( tinP , hRecord , 0 , tinP.ta.retained.u.listWalk.walk.idGrabLayer ) ;
        
        puseC puseRecord( tinP , *tinP.ta.retained.u.listWalk.walk.pPoolRecord ) ;

        if( pSelectWalkCBFP ) (*pSelectWalkCBFP)( tinP , *tinP.pEther , hRecord ) ;
        else
        {
            CONoUTrAW( "================== CHATTERING SELECTED RECORD (BEGIN) ==============================\r\n" ) ;
            PUSHtINaRGS
            tinP.ta.pushed.u.listWalk.walk.pListWalkCBFP = listWalkChatterCBF ;
            tinP.ta.pushed.u.listWalk.walk.flagsWalkP = flLISTwALK_null ;
            tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] = record.nameF() ;
            tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] = flLISTwALKcHATTER_null ;
            flagsT flagsRC = listC::walkIF( tinP , hRecord ) ; //U::BUG: NEED pcP[ 0 ] AND pcP[ 1 ]
            POPtINaRGS
            CONoUTrAW( "================== CHATTERING SELECTED RECORD (END) ==============================\r\n" ) ;
        }
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000072.listwalkselectwalkcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000073.listwalkselectislistedcbf BEGIN
#define DDNAME       "3func.33000073.listwalkselectislistedcbf"
#define DDNUMB      (countT)0x33000073
#define IDFILE      (countT)0x95b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT _export listWalkSelectIsListedCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    listingC* pListingP    =             tinP.ta.pushed.u.listWalk.cbf.pListingP ;
    boolT&    bListedP     =    *(boolT*)tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] ;
    listingC& listingTestP = *(listingC*)tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] ;

    flagsT flagsRC = flLISTwALKcALLbACKrETURNcODE_null ;
    if( pListingP && !( pListingP->flagsF() & fliLISTINGc_MIXINlIST ) && pListingP->idTypeDatumF() == ifcIDtYPEmIXINdATUM_listingVSP )
    {
        listing_listingVSP_C& entry = *(listing_listingVSP_C*)pListingP ;
        listingVSP spRecord = entry ;

        const listingC& record = *(const listingC*)spRecord ;
        __( !listingC::bIsListingIF( tinP , &record ) ) ;

        if( &record == &listingTestP )
        {
            bListedP = 1 ;
            flagsRC = flLISTwALKcALLbACKrETURNcODE_QUIT ;
        }
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flLISTwALKcALLbACKrETURNcODE_null ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000073.listwalkselectislistedcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000074.getlistnamegf BEGIN
#define DDNAME       "3func.33000074.getlistnamegf"
#define DDNUMB      (countT)0x33000074
#define IDFILE      (countT)0x95c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT getListNameGF( tinS& tinP , osTextT*& postP , const countT cNameP , const flagsT flagsP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( postP ) ;
        __Z( cNameP ) ;
        FV(flGETlISTnAME,flagsP) ;
        if( POOP ) return ;
    }

    blobVSP spo ;
    const osTextT* postzMap = processGlobal3I.mapListName( cNameP ) ;

    //if( !postzMap /*&& cNameP & 0xe0000000 == 0x80000000*/ && !( F(flagsP) & flGETlISTnAME_DOnOTuSEdICTIONARY ) )
    //{
    //    spo = listC::dictionaryQueryFromIdIF( tinP , cNameP ) ;
    //    postzMap = spo ;
    //}

    countT cba = postzMap
        ? 1 +     thirdC::c_strlenIF( tinP , postzMap )
        : 1 + 2 * sizeof( countT )
    ;

    puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
    PUSE.newF( tinP , LF , postP , cba ) ; ___( postP ) ;
    __Z( postP ) ;

    if( !POOP )    
    {
        if( postzMap ) thirdC::c_memcpyIF( tinP , postP , postzMap , cba ) ;
        else           thirdC::c_itoaIF(   tinP , postP , cba , cNameP ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000074.getlistnamegf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000077.cutilityif BEGIN
#define DDNAME       "3func.33000077.cutilityif"
#define DDNUMB      (countT)0x33000077
#define IDFILE      (countT)0x95d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT& cUtilityIF( countT offP )/*1*/
{
    return pcUtilityI[ offP ] ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000077.cutilityif END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300007b.tmdrawf BEGIN
#define DDNAME       "3func.3300007b.tmdrawf"
#define DDNUMB      (countT)0x3300007b
#define IDFILE      (countT)0x95e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
wo instance of me exists for each instance of deviceC
if the device has ze dimension or animation is suppressed for it then i do nothing
else i periodically call the device's callback function and then, if the device is a displayC, invalidate the entire window of the displayC
i attempt to keep the length of each period as close as i can to a target value in msP
this is difficult because the time consumed by the callback can vary wildly as the complexity of what the device's associates draw changes
*/
/**/

/*1*/TASK( tmDrawF )/*1*/
//tinP.pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
{
    boolT&   bQuitP    =   *(boolT*)pTaskP->c1 ;
    deviceC& deviceP   = *(deviceC*)pTaskP->c2 ;
    stackC&  st_idEyeP =  *(stackC*)pTaskP->c3 ;
    signC&   sgnReadyP =   *(signC*)pTaskP->c4 ;

    sgnReadyP.waitF( tinP ) ;

    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;

    displayArgS* pStuff = displayC::pStuffIF() ;

    countT pcOlder[ TUCK >> 4 ] ;
    countT pcNap[ TUCK >> 4 ] ;
    thirdC::c_memsetIF( tinP , (byteT*)pcOlder , sizeof pcOlder ) ;
    thirdC::c_memsetIF( tinP , (byteT*)pcNap   , sizeof pcNap   ) ;
    ZE( countT , offoOlder ) ;
    ZE( countT , offoNap ) ;

    const countT msTarget = /*TUCK >> 3*/1 ;
    countT msNap = msTarget ;
    ZE( countT , msAgeLath ) ;
    deviceP.grabF( tinP , TAG( TAGiDnULL ) ) ; //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ZE( countT , idCycle ) ;

    ZE( countT , idTickLath ) ;
    flagsT flagsCbf = flDEVICEcbf_null ;
    while( !bQuitP /*&& !etThread*/ )
    {
        idCycle ++ ;

        if( deviceP.bSuppressAnimation || !deviceP.cColF() || !deviceP.cRowF() )
        {
            //LOGrAW5( "tmDrawF [pDevice,bSuppressAnimation]: " , &deviceP , " " , deviceP.bSuppressAnimation , "\r\n" ) ;
            deviceP.ungrabF( tinP ) ; //------------------------------------------------------------------------------------------------------------------
            {
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                ++ s ; thirdC::dosSleepRawIF( tinP , TUCK >> 2 ) ;
            }
            msAgeLath = 0 ;
            deviceP.grabF( tinP , TAG( TAGiDnULL ) ) ; //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        }
        else
        {
            if( deviceP.pDeviceCBF )
            {
                // ALL CHANGES TO ASSOCIATES OF deviceP SHOULD BE MADE WITHIN THIS CALL ; APPLICATION CODE THAT MAKES SUCH CHANGES AT ANY OTHER TIME MUST GRAB deviceP BEFORE DOING SO TO AVOID DEADLOCKING WITH ME BY GRABBING ANOTHER ASSOCIATE AND THEN ATTEMPTING TO GRAB THE deviceP ASSOCIATE ; IOW, THE deviceP ASSOCIATE MUST ALWAYS BE THE WOTH ASSOCIATE GRABBED, AND THIS IS DONE BY EXPLICITLY GRABBING deviceP WOTH ; THE ASSOCIATION TOPOLOGY IS UNCONSTRAINED, SO VARIOUS ASSOCIATES WALKING EACH'S ASSOCIATE STACK CAN RESULT IN GRABBING IN ARBITRARY ORDERINGS, CAUSING DEADLOCK
                // CALLBACK SHOULD INSPECT flagsP AND/OR WATCH tinP.pAdamGlobal1->m01DrawSmooth AND ADJUST ITS BEHAVIOR TO MAINTAIN A BALANCE BETWEEN SPEED, COMPLEXITY, AND DESIRED SMOOTHING
            
                _IO_
                (*deviceP.pDeviceCBF)( tinP , flagsCbf , deviceP , deviceP.cArg , ifcIDeVENTdEVICEc_TICK , ++ idTickLath ) ;
            }

            if( deviceP.idGroupF() == /*displayC*/ 0x36118 ) ((displayC*)&deviceP)->invalidateF( tinP ) ;
            
            deviceP.ungrabF( tinP ) ; //------------------------------------------------------------------------------------------------------------------

            //U::TO OPTIMIZE FOR DRAWING SPEED ; FOR PRODUCTION, THIS CODE SHOULD BE REPLACED WITH A msNap RAW SLEEP
            //tinP.cYield = 0 ;
            //thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) ) ;
            //tinP.cYield = 0 ;

            pcNap[ ( offoNap ++ ) % ( sizeof pcNap / sizeof pcNap[ 0 ] ) ] = msNap ;
            
            deviceP.grabF( tinP , TAG( TAGiDnULL ) ) ; //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            
            countT msAge = (countT)thirdC::osTimeTicksSinceBootIF() ;
            if( msAge >= msAgeLath )
            {
                countT msOlder = msAge - msAgeLath ;
                pcOlder[ ( offoOlder ++ ) % ( sizeof pcOlder / sizeof pcOlder[ 0 ] ) ] = msOlder ;
            
                if( msOlder < msTarget ) // TOO FAST
                {
                         if( !tinP.pAdamGlobal1->m01DrawSmooth                  ) tinP.pAdamGlobal1->m01DrawSmooth      = 1.0 / 16.0                  ;
                    else if(  tinP.pAdamGlobal1->m01DrawSmooth <= 1.0 / 16.0    ) tinP.pAdamGlobal1->m01DrawSmooth     *= 2                           ;
                    else if(  F(flagsCbf) & flDEVICEcbf_TOOsLOW                 ) flagsCbf                             &= ~( F(flDEVICEcbf_TOOsLOW) ) ;
                    else if(  tinP.pAdamGlobal1->m01DrawSmooth <= 8.0 / 16.0    ) tinP.pAdamGlobal1->m01DrawSmooth     *= 2                           ;
                    else                                                          msNap ++ ;
                }
                else if( msOlder > msTarget ) // TOO SLOW
                {
                         if(  msNap >= 2                                        ) msNap >>= 1 ;
                    else if(  tinP.pAdamGlobal1->m01DrawSmooth >= 2.0 / 16.0    ) tinP.pAdamGlobal1->m01DrawSmooth     /= 2.0 ;
                    else if( !( F(flagsCbf) & flDEVICEcbf_TOOsLOW )             ) flagsCbf                             |= flDEVICEcbf_TOOsLOW ;
                    else if(  tinP.pAdamGlobal1->m01DrawSmooth >= 1.0 / 16.0    ) tinP.pAdamGlobal1->m01DrawSmooth     /= 2.0 ;
                    else if(  tinP.pAdamGlobal1->m01DrawSmooth                  ) tinP.pAdamGlobal1->m01DrawSmooth      = 0.0 ;
                }
            
                //flagsCbf                         &= ~( F(flDEVICEcbf_TOOsLOW) ) ; //TO SUPPRESS GIVING THIS HINT TO APPLICATION CODE ; NORMALLY THIS SHOULD BE COMMENTED OUT
                //tinP.pAdamGlobal1->m01DrawSmooth  = 1.0                         ; //TO SUPPRESS GIVING THIS HINT TO APPLICATION CODE ; NORMALLY THIS SHOULD BE COMMENTED OUT
            }
            msAgeLath = msAge ;
        }
    }
    deviceP.ungrabF( tinP ) ; //------------------------------------------------------------------------------------------------------------------------

    {
        ZE( measureT , mean ) ;
        for( countT offi = 0 ; offi < sizeof pcOlder / sizeof pcOlder[ 0 ] ; offi ++ ) mean += pcOlder[ offi ] ;
        mean /= sizeof pcOlder / sizeof pcOlder[ 0 ] ;
        LOGrAW( T("mean time [target,mean]: ")+TF1((measureT)msTarget)+T(" ")+TF1(mean)+T("\r\n") ) ;
    }

    {
        ZE( measureT , mean ) ;
        for( countT offi = 0 ; offi < sizeof pcNap / sizeof pcNap[ 0 ] ; offi ++ ) mean += pcNap[ offi ] ;
        mean /= sizeof pcNap / sizeof pcNap[ 0 ] ;
        LOGrAW( T("mean nap time [mean,tinP.m01DrawSmooth]: ")+TF1(mean)+T(" ")+TF6(tinP.pAdamGlobal1->m01DrawSmooth,flFORMAT_EXPONENT,0,0,2,6)+T("\r\n") ) ;
    }
}
//tinP.pc Utility[ 0 ] -- ; //U::TO FIND A BUG
DONE( tmDrawF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300007b.tmdrawf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300007c.subtractassblobsf BEGIN
#define DDNAME       "3func.3300007c.subtractassblobsf"
#define DDNUMB      (countT)0x3300007c
#define IDFILE      (countT)0x95f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractAssBlobsF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
    }

    byteT* pb1 = (byteT*)c1P ;
    byteT* pb2 = (byteT*)c2P ;

    countT v1 = *(countT*)(byteT*)c1P ;
    countT v2 = *(countT*)(byteT*)c2P ;

    return v1 - v2 ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300007c.subtractassblobsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300007d.listwalkunindexcbf BEGIN
#define DDNAME       "3func.3300007d.listwalkunindexcbf"
#define DDNUMB      (countT)0x3300007d
#define IDFILE      (countT)0x960


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkUnIndexCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    listingC* pListing = tinP.ta.pushed.u.listWalk.cbf.pListingP ;

    if( pListing && pListing->idTypeDatumF() )
    {
        datumC* pDatum = pListing->flagsF() & fliLISTINGc_MIXINlIST
            ? (datumC*)( (listC*)pListing + 1 )
            : (datumC*)(         pListing + 1 )
        ;

        pDatum->unIndexF( tinP ) ;
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flLISTwALKcALLbACKrETURNcODE_null ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300007d.listwalkunindexcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300007e.listwalkindexcbf BEGIN
#define DDNAME       "3func.3300007e.listwalkindexcbf"
#define DDNUMB      (countT)0x3300007e
#define IDFILE      (countT)0x961


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkIndexCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    listingC* pListing  = tinP.ta.pushed.u.listWalk.cbf.pListingP ;

    if( pListing && pListing->idTypeDatumF() )
    {
        datumC* pDatum = pListing->flagsF() & fliLISTINGc_MIXINlIST
            ? (datumC*)( (listC*)pListing + 1 )
            : (datumC*)(         pListing + 1 )
        ;

        pDatum->indexF( tinP ) ;
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flLISTwALKcALLbACKrETURNcODE_null ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300007e.listwalkindexcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000083.branchdestructioncbf BEGIN
#define DDNAME       "3func.33000083.branchdestructioncbf"
#define DDNUMB      (countT)0x33000083
#define IDFILE      (countT)0x962


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT branchDestructionCBF( tinS& tinP , etherC& etherP , const countT idTypeP , const flagsT flagsP , const handleC& handleP , byteT* pbP , countT cbP , countT& cArgP )/*1*/
{
    switch( idTypeP )
    {
        case ifcIDtYPEtREEwALKcb_BRANCHbEGIN :
        {
            count4S& c4p = *(count4S*)cArgP ;
            ZE( countT , cArg ) ;
            branchHeaderOldS* pHdr = (branchHeaderOldS*)pbP ;
            treeOldC& treeP = *(treeOldC*)c4p.c1 ;
            etherC& ether = *(etherC*)c4p.c2 ;

            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_TREEwALK ) ;
            handle.osF( ifcIDtYPEhANDLE_TREEwALK , (countT)pHdr ) ;

            (*(treeOldCBFT)c4p.c3)( tinP , ether , ifcIDtYPEtREEbRANCHdEFINITIONoLDcb_DELETE , flTREEwALK_null , handle , (byteT*)( pHdr + 1 ) , c4p.c4 , cArg ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            ether( tinP , pHdr->pSwsKids ) ;
            ether( tinP , pHdr->pSw_idKidLathHugged ) ;
            if( pHdr->pSw_psttWife )
            {
                countT cFlavors = pHdr->pSw_psttWife->cFlavorsF( tinP ) ;
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                {
                    pHdr->cLeverWife = treeP.cLeverWifeShared = pHdr->pSw_psttWife->leverF( tinP , idf ) ;
                    ether.delF( tinP , *(strokeS**)&(countT&)*pHdr->pSw_psttWife ) ;
                }
            }
            ether( tinP , pHdr->pSw_psttWife ) ;
            THREADmODE1rESTORE
            DEL( pHdr ) ;
        }
    }

    if( cbP && etherP && flagsP && !handleP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000083.branchdestructioncbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000084._treewritecbf BEGIN
#define DDNAME       "3func.33000084._treewritecbf"
#define DDNUMB      (countT)0x33000084
#define IDFILE      (countT)0x963


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT _treeWriteCBF( tinS& tinP , etherC& etherP , const countT idTypeP , const flagsT flagsP , const handleC& handleP , byteT* pbP , countT cbP , countT& cArgP )/*1*/
{
    count2S& c2p   = *(count2S*)cArgP ;
    treeOldC& treeP   = *(treeOldC*)c2p.c1 ;
    soulC& sBranch = *(soulC*)c2p.c2 ;
    if( cArgP ) sBranch << idTypeP ;

    switch( idTypeP )
    {
        case ifcIDtYPEtREEwALKcb_BRANCHbEGIN :
        {
            branchHeaderOldS& hdr = *(branchHeaderOldS*)pbP ;
            if( cArgP )
            {
                sBranch << *(strokeS**)( &hdr + 1 ) ; //U::GENERALIZE THIS BY CALLING THE DEFINITION CALLBACK

                flagsT flagsTreeWrite = flTREEwRITE_null ;
                if( hdr.cLeverWife    ) flagsTreeWrite |= flTREEwRITE_cLeverWife ;
                if( hdr.pSw_psttWife  ) flagsTreeWrite |= flTREEwRITE_pSw_psttWife ;
                if( hdr.psttLeverKids ) flagsTreeWrite |= flTREEwRITE_psttLeverKids ;
                if( hdr.pSwsKids      ) flagsTreeWrite |= flTREEwRITE_pSwsKids ;

                sBranch << flagsTreeWrite ;

                if( F(flagsTreeWrite) & flTREEwRITE_cLeverWife )
                {
                    sBranch << hdr.cLeverWife ;
                }

                if( F(flagsTreeWrite) & flTREEwRITE_pSw_psttWife )
                {
                    countT cFlavors = hdr.pSw_psttWife->cFlavorsF( tinP ) ;
                    sBranch << cFlavors ;
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    {
                        hdr.cLeverWife = treeP.cLeverWifeShared = hdr.pSw_psttWife->leverF( tinP , idf ) ;
                        sBranch << hdr.cLeverWife ;
                        sBranch << *(strokeS**)&(countT&)*hdr.pSw_psttWife ;
                    }
                }

                if( F(flagsTreeWrite) & flTREEwRITE_psttLeverKids )
                {
                    sBranch << hdr.psttLeverKids ;
                }

                if( F(flagsTreeWrite) & flTREEwRITE_pSwsKids )
                {
                    countT cFlavors = hdr.pSwsKids->cFlavorsF( tinP ) ;
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    {
                        treeP.psttLeverKidsShared = hdr.psttLeverKids = (strokeS*)hdr.pSwsKids->leverF( tinP , idf ) ;
                        stackC& stKids = *hdr.pSwsKids ;
                        ZE( countT , idLathRef ) ;
                        stKids.pPlateF( tinP , idLathRef ) ;
                        *hdr.pSw_idKidLathHugged = idLathRef ;
                    }
                }
            }
            break ;
        }
        case ifcIDtYPEtREEwALKcb_BRANCHeND :
        {
            branchHeaderOldS& hdr = *(branchHeaderOldS*)pbP ;
            if( cArgP )
            {
                flagsT flagsTreeWrite = flTREEwRITE_null ;
                if( hdr.cLeverWife    ) flagsTreeWrite |= flTREEwRITE_cLeverWife ;
                if( hdr.pSw_psttWife  ) flagsTreeWrite |= flTREEwRITE_pSw_psttWife ;
                if( hdr.psttLeverKids ) flagsTreeWrite |= flTREEwRITE_psttLeverKids ;
                if( hdr.pSwsKids      ) flagsTreeWrite |= flTREEwRITE_pSwsKids ;
                sBranch << flagsTreeWrite ;

                if( F(flagsTreeWrite) & flTREEwRITE_pSwsKids )
                {
                    countT cFlavors = hdr.pSwsKids->cFlavorsF( tinP ) ;
                    sBranch << cFlavors ;
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    {
                        treeP.psttLeverKidsShared = hdr.psttLeverKids = (strokeS*)hdr.pSwsKids->leverF( tinP , idf ) ;
                        sBranch << hdr.psttLeverKids ;
                        sBranch << (countT)*hdr.pSw_idKidLathHugged ;
                    }
                }
            }
            break ;
        }
        case ifcIDtYPEtREEwALKcb_WIFEbEGIN :
        {
            if( cArgP ) sBranch << (strokeS*)pbP ;
            break ;
        }
    }

    if( cbP && flagsP && tinP.fingerprint && etherP && !handleP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000084._treewritecbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000085._vtcbf BEGIN
#define DDNAME       "3func.33000085._vtcbf"
#define DDNUMB      (countT)0x33000085
#define IDFILE      (countT)0x964


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/boolT _export _vtCBF( tinS& tinP , etherC& etherP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , sadamC& sadamP )/*1*/
{
    _IO_

    vTextC& vt = *(vTextC*)sadamP.features.fc.callBackArg ;

    countT pcNotes[ 0x20 ] ;
    if( !pcNotesP )
    {
        pcNotes[ 0 ] = 1 ;
        pcNotes[ 1 ] = 1 ;
        pcNotes[ 2 ] = vt.cArg ;
        pcNotes[ 3 ] = 0 ;
    }
    else if( pcNotesP[ 0 ] == 1 && pcNotesP[ 1 ] <= 0x18 ) //U::EXACT TEST
    {
        pcNotes[ 0 ] = 1 ;
        pcNotes[ 1 ] = pcNotesP[ 1 ] + 1 ;
        pcNotes[ 2 ] = vt.cArg ;
        thirdC::c_memcpyIF( tinP , (byteT*)( pcNotes + 3 ) , (byteT*)( pcNotesP + 2 ) , sizeof( countT ) * ( pcNotesP[ 1 ] + 1 ) ) ;
    }
    else { BLAMMO ; }

    if( vt.pSadamCBF ) (*vt.pSadamCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotes , sadamP ) ;

    return 0 ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000085._vtcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000086._tcbuttoncbf BEGIN
#define DDNAME       "3func.33000086._tcbuttoncbf"
#define DDNUMB      (countT)0x33000086
#define IDFILE      (countT)0x965


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/boolT _export _tcButtonCBF( tinS& tinP , etherC& etherP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , sadamC& sadamP )/*1*/
{
    _IO_

    ZE( boolT , bHandled ) ;
    //sadamHighlightF IS ALWAYS CALLED BEFORE THE CBF BECAUSE THE CBF MIGHT HIDE THE WINDOW

    tcButtonC& tc = *(tcButtonC*)sadamP.features.fc.callBackArg ;
    switch( idTypeCallP )
    {
        case ifcIDtYPEsTROKEcALLbACK_DRAGbEGIN :
        case ifcIDtYPEsTROKEcALLbACK_DRAGeND :
        case ifcIDtYPEsTROKEcALLbACK_INoUTqUERY :
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER     :
        case ifcIDtYPEsTROKEcALLbACK_TABaRRIVING :
        case ifcIDtYPEsTROKEcALLbACK_TABlEAVING  :
        {
            if( tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , tc.flagsTcState , sadamP ) ;
            break ;
        }
        case ifcIDtYPEsTROKEcALLbACK_SLEEP :
        case ifcIDtYPEsTROKEcALLbACK_DESTROY :
        case ifcIDtYPEsTROKEcALLbACK_ERASE :
        {
            const flagsT flagsOld = tc.flagsTcState ;
            tc.flagsTcState = flTCsTATE_null ;
            if( tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , flagsOld , sadamP ) ;
            break ;
        }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        {
            if( !tc.pFlagsTcFeatureDisable || !( F(*tc.pFlagsTcFeatureDisable) & flTCfEATURE_HOTkEY ) )
            {
                if( !( F(tc.flagsTcState) & flTCsTATE_DOWN ) )
                {
                    if( F(tc.flFeatures) & flTCfEATURE_HOTkEYgRABStAB ) etherP.osThreadF( TaRG1( tmGrabTabF ) , (countT)&sadamP ) ; //I AM CALLED BY callSadamsIF, WHICH HAS GRABBED A BUNCH OF sadamC IMAGES, SO I'VE GOT TO DO THIS ON ANOTHER THREAD
                    else
                    {
                        if( F(tc.flFeatures) & flTCfEATURE_ACTIONhIGHLIGHT ) paperOldC::setFlashIF( tinP , sadamP , 2 , 1 , flSADAMhIGHLIGHT_DOWN ) ;
                        if( tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , tc.flagsTcState , sadamP ) ;
                    }
                }
            }
            break ;
        }
        case ifcIDtYPEsTROKEcALLbACK_KEYBOARD :
        {
            if( !tc.pFlagsTcFeatureDisable || !( F(*tc.pFlagsTcFeatureDisable) & flTCfEATURE_KEYaCTION ) )
            {
                const countT& idTool = pcNotesP[ 2 ] ;
                if( idTool != ifcIDtYPEtOOL_TAB && idTool != ifcIDtYPEtOOL_TABbACK && tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , tc.flagsTcState , sadamP ) ;
            }
            break ;
        }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        {
            const countT& idTool   = pcNotesP[ 2 ] ;
            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idCol    = pcNotesP[ 4 ] ;
            const countT& idRow    = pcNotesP[ 5 ] ;

            boolT bIn =
            (
                (sCountT)idCol >= R( sadamP.pStrike->sc.mIdColHot )                                   &&
                (sCountT)idCol <= R( sadamP.pStrike->sc.mIdColHot ) - 1.0 + R( sadamP.pStrike->sc.mColsHot ) &&
                (sCountT)idRow >= R( sadamP.pStrike->sc.mIdRowHot )                                   &&
                (sCountT)idRow <= R( sadamP.pStrike->sc.mIdRowHot ) - 1.0 + R( sadamP.pStrike->sc.mRowsHot )
            )
            ;

            switch( idTool )
            {
                case ifcIDtYPEtOOL_MOUSEbUTTONlEFT :
                {
                    if( bIn ) switch( idAction )
                    {
                        case ifcIDtYPEaCTION_DOWN :
                        {
                            if( !( F(tc.flagsTcState) & flTCsTATE_DOWN ) )
                            {
                                const flagsT flagsOld = tc.flagsTcState ;
                                tc.flagsTcState |= flTCsTATE_DOWN ;
                                if( F(tc.flagsTcState) & flTCsTATE_ON ) tc.flagsTcState &= ~( F(flTCsTATE_ON) ) ;
                                else                                  tc.flagsTcState |=      flTCsTATE_ON    ;
                                if( F(tc.flFeatures) & flTCfEATURE_ACTIONhIGHLIGHT ) sadamP.pStrike->sc.pPaper->sadamHighlightF( tinP , sadamP , flSADAMhIGHLIGHT_DOWN ) ;
                                if( tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , flagsOld , sadamP ) ;
                            }
                            break ;
                        }
                        case ifcIDtYPEaCTION_UP :
                        {
                            if( F(tc.flagsTcState) & flTCsTATE_DOWN )
                            {
                                const flagsT flagsOld = tc.flagsTcState ;
                                tc.flagsTcState &= ~( F(flTCsTATE_DOWN) ) ;
                                if( F(tc.flFeatures) & flTCfEATURE_ACTIONhIGHLIGHT ) sadamP.pStrike->sc.pPaper->sadamHighlightF( tinP , sadamP , flSADAMhIGHLIGHT_DOWN ) ;
                                if( tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , flagsOld , sadamP ) ;
                            }
                            break ;
                        }
                    }
                    break ;
                }
                case ifcIDtYPEtOOL_MOUSEpOSITION :
                {
                    if( !bIn && F(tc.flagsTcState) & flTCsTATE_DOWN )
                    {
                        const flagsT flagsOld = tc.flagsTcState ;
                        tc.flagsTcState &= ~( F(flTCsTATE_DOWN) ) ;
                        if( F(tc.flFeatures) & flTCfEATURE_ACTIONhIGHLIGHT ) sadamP.pStrike->sc.pPaper->sadamHighlightF( tinP , sadamP , flSADAMhIGHLIGHT_DOWN ) ;
                        if( tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , flagsOld , sadamP ) ;
                    }
                    break ;
                }
            }

            break ;
        }
    }

    return bHandled ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000086._tcbuttoncbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000087.bupromptcbf BEGIN
#define DDNAME       "3func.33000087.bupromptcbf"
#define DDNUMB      (countT)0x33000087
#define IDFILE      (countT)0x966


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/boolT buPromptCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamC& sadamP )/*1*/
{
    tcPromptC& buPrompt = *(tcPromptC*)cArgP ;

    ZE( boolT , bHandled ) ;
    switch( idTypeCallP )
    {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
        {
            if( buPrompt.pTcStateCBF ) (*buPrompt.pTcStateCBF)( tinP , etherP , buPrompt.cArg , idTypeCallP , idEventP , pcNotesP , flTcStateNewP , flTcStateOldP , sadamP ) ;
            break ;
        }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        {
            const countT& idTool   = pcNotesP[ 2 ] ;
            const countT& idAction = pcNotesP[ 3 ] ;

            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;
        }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        {
            break ;
        }
        case ifcIDtYPEsTROKEcALLbACK_KEYBOARD :
        {
            if( buPrompt.pBaton ) buPrompt.pBaton->grabF( tinP , TAG( TAGiDnULL ) ) ;
            const countT& idTool   = pcNotesP[ 2 ] ;
            const countT& idAction = pcNotesP[ 3 ] ;

            if( idAction == ifcIDtYPEaCTION_DOWN )
            {
                ZE( boolT , bFresh ) ;
                TN( tNewValue , "" ) ;
                if( idTool == ifcIDtYPEtOOL_BACKSPACE )
                {
                    if( buPrompt.psttValue && buPrompt.psttValue->idAdam )
                    {
                        if( buPrompt.psttValue->idAdam == 1 ) tNewValue = T("") ;
                        else
                        {
                            countT idf = 1 ;
                            countT idl = buPrompt.psttValue->idAdam - 1 ;
                            ZE( strokeS* , psttw ) ;
                            etherP.strSubstringF( tinP , psttw , idf , idl , buPrompt.psttValue ) ; ___( psttw ) ;
                            tNewValue = T(psttw) ;
                            etherP.delF( tinP , psttw ) ;    
                        }

                        bFresh = 1 ;
                    }
                }
                else
                {
                    strokeS sttNew = strokeS::strokeIF( tinP , idTool ) ;
                    switch( sttNew.idAdam )
                    {
                        case 0 :
                        case saA1_TOOLSHIFT :
                        case saA1_TOOLSHIFTrIGHT :
                        case saA1_TOOLLOCKnUM :
                        case saA1_TOOLLOCKcAPS :
                        {
                            break ;
                        }
                        case saA1_TOOLENTERnUM :
                        case saA1_TOOLENTER :
                        {
                            if( buPrompt.pSign ) buPrompt.pSign->giveF( tinP ) ;
                            break ;
                        }                                                                                                                                                         
                        default :                                                                                                                                                 
                        {                                                                                                                                                         
                            tNewValue = T(buPrompt.psttValue)+strokeS::strokeIF(tinP,idTool) ;
                            bFresh = 1 ;
                            break ;
                        }
                    }
                }

                if( bFresh )
                {
                    etherP.delF( tinP , buPrompt.psttValue ) ;
                    etherP.strMakeF( tinP , LF , buPrompt.psttValue , tNewValue ) ; ___( buPrompt.psttValue ) ;
    
                    buPrompt.freshF( tinP ) ;
                    //buPrompt.setF( tinP , T("")+S3((measureT)(buPrompt.psttPrompt->idAdam+buPrompt.psttValue->idAdam),scOld_mmFRAMEcELLS,(measureT)1.0)+T(buPrompt.psttPrompt)+tNewValue+S2(0,scOld_POPfRAME) ) ;
                }
            }

            if( buPrompt.pTcStateCBF ) (*buPrompt.pTcStateCBF)( tinP , etherP , buPrompt.cArg , idTypeCallP , idEventP , pcNotesP , flTcStateNewP , flTcStateOldP , sadamP ) ;

            if( buPrompt.pBaton ) buPrompt.pBaton->ungrabF( tinP ) ;
            break ;
        }
    }

    return bHandled ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000087.bupromptcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000088.tcslidercbf BEGIN
#define DDNAME       "3func.33000088.tcslidercbf"
#define DDNUMB      (countT)0x33000088
#define IDFILE      (countT)0x967


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/boolT tcSliderCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamC& sadamP )/*1*/
{
    ZE( boolT , bHandled ) ;
    tcSliderC& tcSlider = *(tcSliderC*)cArgP ;

    switch( idTypeCallP )
    {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
        {
            if( tcSlider.pTcStateCBF ) (*tcSlider.pTcStateCBF)( tinP , etherP , tcSlider.cArg , idTypeCallP , idEventP , pcNotesP , flTcStateNewP , flTcStateOldP , sadamP ) ;
            break ;
        }
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        case ifcIDtYPEsTROKEcALLbACK_KEYBOARD :
        {
            const countT& idTool   = pcNotesP[ 2 ] ;
            const countT& idAction = pcNotesP[ 3 ] ;

            if( idAction == ifcIDtYPEaCTION_DOWN )
            {
                ZE( boolT , bDo ) ;
                TN( tNewValue , "" ) ;
                tcSlider.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
                switch( idTool )
                {
                    case ifcIDtYPEtOOL_MOUSEbUTTONlEFT :
                    {
                        const countT& idCol = pcNotesP[ 4 ] ;
                        const countT& idRow = pcNotesP[ 5 ] ;

                        const measureT mMin  = sadamP.pStrike->sc.mIdColHot +         1.0 + sadamP.pStrike->sc.mColsMarginSadamFrame   ;
                        const measureT mCols = sadamP.pStrike->sc.mColsHot  - 2.0 * ( 1.0 + sadamP.pStrike->sc.mColsMarginSadamFrame ) ;
                        if( mCols > 1.0 ) tcSlider.mValue = ( idCol - mMin ) / ( mCols - 1.0 ) ;
                        else              tcSlider.mValue = 0.5 ;
                        bDo = 1 ;
                        break ;
                    }
                    case ifcIDtYPEtOOL_RIGHT :
                    case ifcIDtYPEtOOL_RIGHTnUM :
                    case ifcIDtYPEtOOL_UP :
                    case ifcIDtYPEtOOL_UPnUM :
                    {
                        tcSlider.mValue += 1.0 / ( 1.0 + tcSlider.cTickMarks ) ;
                        bDo = 1 ;
                        break ;
                    }
                    case ifcIDtYPEtOOL_LEFT :
                    case ifcIDtYPEtOOL_LEFTnUM :
                    case ifcIDtYPEtOOL_DOWN :
                    case ifcIDtYPEtOOL_DOWNnUM :
                    {
                        tcSlider.mValue -= 1.0 / ( 1.0 + tcSlider.cTickMarks ) ;
                        bDo = 1 ;
                        break ;
                    }
                }

                     if( tcSlider.mValue < 0.0 ) tcSlider.mValue = 0.0 ;
                else if( tcSlider.mValue > 1.0 ) tcSlider.mValue = 1.0 ;

                if( bDo )
                {
                    tcSlider.drawF( tinP ) ;
                    tcSlider.sign.giveF( tinP ) ;
                }

                tcSlider.baton.ungrabF( tinP ) ;
            }

            break ;
        }
    }

    return bHandled ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000088.tcslidercbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000089.tcbuttonquitcbf BEGIN
#define DDNAME       "3func.33000089.tcbuttonquitcbf"
#define DDNUMB      (countT)0x33000089
#define IDFILE      (countT)0x968


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/boolT tcButtonQuitCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamC& sadamP )/*1*/
{
    ZE( boolT , bHandled ) ;
    switch( idTypeCallP )
    {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        {
            const countT& idTool   = pcNotesP[ 2 ] ;
            const countT& idAction = pcNotesP[ 3 ] ;

            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;
        }
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        {
            etherP.etherFireImpersonateMonitorIF( tinP ) ;
            break ;
        }
    }

    return bHandled ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000089.tcbuttonquitcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300008a.privilegescbf BEGIN
#define DDNAME       "3func.3300008a.privilegescbf"
#define DDNUMB      (countT)0x3300008a
#define IDFILE      (countT)0x969


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT privilegesCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    TN( tValue_on                                   , "on" ) ;

    TN( tKeyAction                                  , "Action" ) ;
    TN( tAction_setMyPrivileges                     , "Set My Privileges" ) ;
    TN( tAction_clearMyPrivileges                   , "Clear My Privileges" ) ;

    TN( tKeyPrivelege_viewServerReports             , "View Server Reports" ) ;
    TN( tKeyPrivilege_viewUntestedPages             , "View Untested Pages" ) ;
    TN( tKeyPrivilege_sendReceiveEmail              , "Send and Receive Email" ) ;
    TN( tKeyPrivilege_hideImageAds                  , "Hide Image Ads" ) ;
    TN( tKeyPrivilege_hideAdLinks                   , "Hide Ad Links" ) ;
    TN( tKeyPrivilege_recall                        , "Recall From Lath Session" ) ;

    TN( tKeyUser                                    , "User Id"     ) ;
    TN( tKeyPassword                                , "Password"   ) ;

    countT cFlavors = swKVP.cFlavorsF( tinP ) ;
    if( cFlavors )
    {
        //TN( tSay , "" ) ; tSay = T("---- keys and value  received ----------------------------------\r\n") ;
        //LOGrAW( tSay ) ; //U::
        //for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        //{
        //    psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
        //    strokeS* pzsttv = (strokeS*)(countT)swKVP ;
        //    TN( tSay , "" ) ; tSay = T("\"")+T(psttLeverKVP)+T("\":\"")+T(pzsttv)+T("\"\r\n") ;
        //    LOGrAW( tSay ) ; //U::
        //}

        const countT idLeverAction = swKVP.idSlotOfLeverF( tinP , (countT)tKeyAction.psttLowerF( tinP ) ) ;
        if( idLeverAction )
        {
            psttLeverKVP = tKeyAction.psttLowerF( tinP ) ;
            strokeS* pzsttvAction = (strokeS*)(countT)swKVP ;
    
            {
                sessionC& session = sessionsP( tinP , nnPeerP ) ;
                session.privilegesF( tinP , flSESSIONpRIVILEGE_null ) ;
            }

            if( !tinP.pEtScratch->strCompareF( tinP , pzsttvAction , tAction_clearMyPrivileges ) ) sessionsP.registerConnectionF( tinP , nnPeerP , 0 , 0 , 1 ) ;
            else if( !tinP.pEtScratch->strCompareF( tinP , pzsttvAction , tAction_setMyPrivileges ) )
            {
                const countT idLeverUser     = swKVP.idSlotOfLeverF( tinP , (countT)tKeyUser.psttLowerF( tinP )     ) ;
                const countT idLeverPassword = swKVP.idSlotOfLeverF( tinP , (countT)tKeyPassword.psttLowerF( tinP ) ) ;
                ZE( countT , cPrivilegeLevel ) ;
                {
                    if( idLeverUser && idLeverPassword )
                    {
                        psttLeverKVP = tKeyUser.psttLowerF( tinP ) ;
                        strokeS* pzsttvUser = (strokeS*)(countT)swKVP ;

                        psttLeverKVP = tKeyPassword.psttLowerF( tinP ) ;
                        strokeS* pzsttvPassword = (strokeS*)(countT)swKVP ;

                        TN( tDirAccount   , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/accounts/" ) ; tDirAccount += T(pzsttvUser)+T("/") ;
                        TN( tShortFilePassword   , "password." ) ;
                        TN( tFilePassword , "" ) ; tFilePassword = tDirAccount+tShortFilePassword+T(pzsttvPassword) ;

                        cPrivilegeLevel = tinP.pEtScratch->diskFileExistsF( tinP , tDirAccount ) && tinP.pEtScratch->diskFileExistsF( tinP , tFilePassword ) ; //!! ELIMINATED FROM WOTH TERM BECAUSE REDUNDANT (&& RETURNS 0 OR 1)

                        if( cPrivilegeLevel )
                        {
                            sessionsP.registerConnectionF( tinP , nnPeerP , 0 , pzsttvUser , 1 ) ;

                            ZE( osTextT* , posti ) ;
                            ZE( countT   , costi ) ;
                            tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , tDirAccount+T("privileges.txt") , 1 ) ; ___( posti ) ;
                            if( POOP ) { POOPR ; }
                            else if( posti )
                            {
                                ZE( strokeS* , pstt1w ) ;
                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                etThread.strWordsOldF( tinP , pstt1w , T(posti) , sttq ) ; ___( pstt1w ) ;
                                FORsTRINGSiN1( pstt1w )
                                {
                                    if( !etThread.strCompareF( tinP , psttc1 , T("all") ) )
                                    {
                                        cPrivilegeLevel = 2 ;
                                        break ;
                                    }
                                }
                                etThread.delF( tinP , pstt1w ) ;
                            }
                        }
                    }
                }

                sessionC& session = sessionsP( tinP , nnPeerP ) ;
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                {
                    if( idf == idLeverAction || idf == idLeverUser || idf == idLeverPassword ) continue ;

                    psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
                    strokeS* pzsttv = (strokeS*)(countT)swKVP ;
                    //TN( tSay , "" ) ; tSay = T("\"")+T(psttLeverKVP)+T("\":\"")+T(pzsttv)+T("\"\r\n") ;
                    //LOGrAW( tSay ) ;

                         if( !tinP.pEtScratch->strCompareF( tinP , psttLeverKVP , tKeyPrivilege_viewUntestedPages.psttLowerF( tinP ) ) && !tinP.pEtScratch->strCompareF( tinP , pzsttv , tValue_on ) ) session.privilegesF( tinP , session.privilegesF( tinP ) | flSESSIONpRIVILEGE_VIEWuNTESTEDpAGES ) ;
                    //else if( !tinP.pEtScratch->strCompareF( tinP , psttLeverKVP , tKeyPrivilege_hideImageAds.psttLowerF( tinP )      ) && !tinP.pEtScratch->strCompareF( tinP , pzsttv , tValue_on ) ) session.privilegesF( tinP , session.privilegesF( tinP ) | flSESSIONpRIVILEGE_HIDEiMAGEaDS      ) ;
                    else if( cPrivilegeLevel )
                    {
                             if( !tinP.pEtScratch->strCompareF( tinP , psttLeverKVP , tKeyPrivilege_sendReceiveEmail.psttLowerF( tinP )  ) && !tinP.pEtScratch->strCompareF( tinP , pzsttv , tValue_on ) ) session.privilegesF( tinP , session.privilegesF( tinP ) | flSESSIONpRIVILEGE_SENDaNDrECEIVEeMAIL ) ;
                        //else if( !tinP.pEtScratch->strCompareF( tinP , psttLeverKVP , tKeyPrivilege_hideAdLinks.psttLowerF( tinP )       ) && !tinP.pEtScratch->strCompareF( tinP , pzsttv , tValue_on ) ) session.privilegesF( tinP , session.privilegesF( tinP ) | flSESSIONpRIVILEGE_HIDEaDlINKS         ) ;

                        if( cPrivilegeLevel >= 2 ) //WORKAROUND TO CLOSE SECURITY HOLE NOW THAT ANYWO CAN GET A LOGIN ACCOUNT
                        {
                            if( !tinP.pEtScratch->strCompareF( tinP , psttLeverKVP , tKeyPrivelege_viewServerReports.psttLowerF( tinP ) ) && !tinP.pEtScratch->strCompareF( tinP , pzsttv , tValue_on ) ) session.privilegesF( tinP , session.privilegesF( tinP ) | flSESSIONpRIVILEGE_VIEWsERVERrEPORTS   ) ;
                        }
                    }
                }
            }
    
            if( POOP ) POOPR
        }
    }

    //CS:CODEsYNC: 0010435 1850104
    sessionC& session = sessionsP( tinP , nnPeerP ) ;
    flagsT flagsp = session.privilegesF( tinP ) ;

    TN( tPrivilegesOld , "" ) ;
    TN( tbr , "<BR>" ) ;
    TN( tli , "<LI>" ) ;
    if( F(flagsp) & flSESSIONpRIVILEGE_VIEWsERVERrEPORTS   ) tPrivilegesOld += tli+tKeyPrivelege_viewServerReports+tbr ;
    if( F(flagsp) & flSESSIONpRIVILEGE_VIEWuNTESTEDpAGES   ) tPrivilegesOld += tli+tKeyPrivilege_viewUntestedPages+tbr ;
    if( F(flagsp) & flSESSIONpRIVILEGE_SENDaNDrECEIVEeMAIL ) tPrivilegesOld += tli+tKeyPrivilege_sendReceiveEmail +tbr ;
    //if( F(flagsp) & flSESSIONpRIVILEGE_HIDEiMAGEaDS        ) tPrivilegesOld += tli+tKeyPrivilege_hideImageAds     +tbr ;
    //if( F(flagsp) & flSESSIONpRIVILEGE_HIDEaDlINKS         ) tPrivilegesOld += tli+tKeyPrivilege_hideAdLinks      +tbr ;

    TN( tssbr , "* <BR>" ) ;
    TN( tsssbr , "** <BR>" ) ;
    TN( tPrivilegesNew , "" ) ;
    tPrivilegesNew += T("<INPUT TYPE=CHECKBOX NAME=\"")+tKeyPrivilege_recall           +T("\" VALUE=\"")+tValue_on+T("\" CHECKED> "                                                                )+tKeyPrivilege_recall           +tssbr  ;
    tPrivilegesNew += T("<P>") ;
    //tPrivilegesNew += T("<INPUT TYPE=CHECKBOX NAME=\"")+tKeyPrivilege_hideImageAds     +T("\" VALUE=\"")+tValue_on+T("\" ")+T(F(flagsp)&flSESSIONpRIVILEGE_HIDEiMAGEaDS       ?"CHECKED":"")+T("> ")+tKeyPrivilege_hideImageAds     +tbr    ;
    tPrivilegesNew += T("<INPUT TYPE=CHECKBOX NAME=\"")+tKeyPrivilege_viewUntestedPages+T("\" VALUE=\"")+tValue_on+T("\" ")+T(F(flagsp)&flSESSIONpRIVILEGE_VIEWuNTESTEDpAGES  ?"CHECKED":"")+T("> ")+tKeyPrivilege_viewUntestedPages+tbr    ;
    //tPrivilegesNew += T("<INPUT TYPE=CHECKBOX NAME=\"")+tKeyPrivilege_hideAdLinks      +T("\" VALUE=\"")+tValue_on+T("\" ")+T(F(flagsp)&flSESSIONpRIVILEGE_HIDEaDlINKS        ?"CHECKED":"")+T("> ")+tKeyPrivilege_hideAdLinks      +tssbr  ;
    tPrivilegesNew += T("<INPUT TYPE=CHECKBOX NAME=\"")+tKeyPrivilege_sendReceiveEmail +T("\" VALUE=\"")+tValue_on+T("\" ")+T(F(flagsp)&flSESSIONpRIVILEGE_SENDaNDrECEIVEeMAIL?"CHECKED":"")+T("> ")+tKeyPrivilege_sendReceiveEmail +tssbr  ;
    tPrivilegesNew += T("<INPUT TYPE=CHECKBOX NAME=\"")+tKeyPrivelege_viewServerReports+T("\" VALUE=\"")+tValue_on+T("\" ")+T(F(flagsp)&flSESSIONpRIVILEGE_VIEWsERVERrEPORTS  ?"CHECKED":"")+T("> ")+tKeyPrivelege_viewServerReports+tsssbr ;

    if( !tPrivilegesOld.csF( tinP ) ) tPrivilegesOld = T("(none)<BR>") ;

    meP.pushSnipF( tinP , stBodyP ,

        tPrivilegesOld
        +T(
        
            "<P>\r\n"
            "This sesssion currently has the privileges listed above.\r\n"
            "  A session ends only when it times out.\r\n"
            "  But you can \"log out\" by clearing all of your privileges:\r\n"
            "<FORM ACTION=\"/header/do/privileges.html\" METHOD=\"post\">\r\n"
                "<INPUT TYPE=\"hidden\" VALUE=\"logout\" NAME=\"form\"><P>\r\n"
                "<INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"")+tAction_clearMyPrivileges+T("\" ALT=\"")+tAction_clearMyPrivileges+T("\">\r\n"
            "</FORM>\r\n"
            "<P>\r\n"
            "All privileges that are available to you are listed below.\r\n"
            "  Your current session privileges are indicated.\r\n"
            "  Select only those privileges that you will need during this session.\r\n"
            "  For privileges marked with (*), a valid user id and password must be entered.\r\n"
            "  For privileges marked with (**), the valid user id and password of a security cleared user must be entered.\r\n"
            "<P>\r\n"
            "<FORM ACTION=\"/header/do/privileges.html\" METHOD=\"post\">\r\n"
                "<INPUT TYPE=\"hidden\" VALUE=\"privileges\" NAME=\"form\">\r\n"
                "<P>\r\n"

        )
        +tPrivilegesNew

        +T(

                "<P>\r\n"
                "<INPUT NAME=\"")+tKeyUser+T("\" VALUE=\"")+tKeyUser+T("\" TYPE=\"text\" MAXLENGTH=\"16\" SIZE=\"16\" ONCLICK=\"select() ;\">\r\n"
                "Password: <INPUT NAME=\"")+tKeyPassword+T("\" VALUE=\"\" TYPE=\"password\" MAXLENGTH=\"8\" SIZE=\"8\" ONCLICK=\"select() ;\">\r\n"
                "<P>\r\n"
                "<INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"")+tAction_setMyPrivileges+T("\" ALT=\"")+tAction_setMyPrivileges+T("\">\r\n"
            "</FORM>\r\n"

        )

    ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300008a.privilegescbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300008b.peanutcbf BEGIN
#define DDNAME       "3func.3300008b.peanutcbf"
#define DDNUMB      (countT)0x3300008b
#define IDFILE      (countT)0x96a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT peanutCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    count8S& c8P = *(count8S*)cArgP ;
    puseC& pusePeanutP = *(puseC*)c8P.c1 ;

    meP.pushSnipF( tinP , stBodyP ,

        T(
        
            "This comment has been stored and will be read by the organizer:\r\n"
            "<SPAN class=\"spaLarge\" style=\"color:gray\" onMouseOut=\"swatF() ; \" onMouseOver=\"flyF( this , 'Thank you for the feedback.  Feedback, constructive or otherwise, always makes my day.' ) ;\">"
                "<P>\r\n"
        
        )
        +T(     psttKVReportP)
        +T(     "Received from: ")+T(psttPeerAgentP)
        +T(

            "</SPAN>\r\n"
            "<P>\r\n"
            "This web site is tested using Microsoft's Internet Explorer.\r\n"
            "  If these pages don't display properly, or you cannot download a file, try using the current version of IE.\r\n"
            "<P>\r\n"
            "  What goes around does indeed come around.\r\n"
            "  If you have just sent the organizer a compliment to encourage him, or constructive criticism to help him do a better job, you will probably live a long and happy life.\r\n"
            "  This pleases the organizer, who thanks you and wishes you well.\r\n"
            "<P>\r\n"
            "  If you have just sent the organizer an insult, or left some other form of defecation on his pamphlet, hoping to discourage him or to add more weight to the burden that he carries, your last years will certainly be interminable and miserable.\r\n"
            "  This also pleases the organizer, who hopes that you end your days with a six inch open bedsore, your flesh rotted away to the bone.\r\n"
            "<P>\r\n"
            "  Now, go comfort those unfortunate people in your area who are suffering such horrors today,\r\n"
            "  the bedridden, the homeless, the disabled, the untouchables of your town.\r\n"
            "  These are the living ghosts of the cemeterial urb.\r\n"
            "  The organizer has seen their wounds and has held their frigid hands.\r\n"
            "  Open your hearts, and your eyes will then see them.\r\n"
            "  In that moment, you will rediscover your humanity; you will return to life.\r\n"
        
        )

    ) ;

    TN( tKeyIdPort   , "idport"  ) ;
    TN( tKeyUrl      , "url"     ) ;
    TN( tKeyPeanut   , "comment" ) ;
    TN( tValueIdPort , "" ) ;
    TN( tValueUrl    , "" ) ;
    TN( tValuePeanut , "" ) ;
    countT cFlavors = swKVP.cFlavorsF( tinP ) ;
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    {
        psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;

        ZE( textC* , ptv ) ;
             if( !etThread.strCompareF( tinP , tKeyIdPort , psttLeverKVP ) ) ptv = &tValueIdPort ;
        else if( !etThread.strCompareF( tinP , tKeyUrl    , psttLeverKVP ) ) ptv = &tValueUrl    ;
        else if( !etThread.strCompareF( tinP , tKeyPeanut , psttLeverKVP ) ) ptv = &tValuePeanut ;

        if( ptv ) *ptv = T((strokeS*)(countT)swKVP) ;
    }

    countT idPort = etThread.strDigitsToSCountF( tinP , tValueIdPort ) ;
    if( idPort && tValueUrl.csF( tinP ) && tValuePeanut.csF( tinP ) )
    {
        ZE( strokeS* , psttReady ) ;
        {
            ZE( strokeS* , psttw ) ;
            etThread.strReplaceAnyF( tinP , psttw , tValuePeanut , T(TbLACK) , T(" ") , 0 , 1 ) ; ___( psttw ) ;
            etThread.strCleanF( tinP , psttw , S1C(' ') , ifcIDtYPEsTROKEcLEAN_CnAMESoRbLANKoRpUNCTUATION ) ;
    
            ZE( strokeS* , pstt1w ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT cWords = etThread.strWordsOldF( tinP , pstt1w , psttw , sttq ) ; ___( pstt1w ) ;
            etThread.delF( tinP , psttw ) ;

            const countT csttMax = 0x10 ;
            ZE( countT , cstta ) ;
            {
                FORsTRINGSiN1( pstt1w )
                {
                    if( psttc1->idAdam < csttMax ) cstta += psttc1->idAdam + 1 ;
                    else                           cstta += csttMax        + 1 ;
                }
            }

            etThread.strMakeF( tinP , LF , psttReady , 0 , cstta ) ; ___( psttReady ) ;
            TN( tb , " " ) ;
            FORsTRINGSiN1( pstt1w )
            {
                ZE( strokeS* , psttm ) ;
                if( psttc1->idAdam > csttMax )
                {
                    countT idf = 1 ;
                    countT idl = csttMax ;
                    etThread.strSubstringF( tinP , psttm , idf , idl , psttc1 ) ; ___( psttm ) ;
                }

                etThread.strFuseF( tinP , psttReady , psttm ? psttm : psttc1 ) ;
                if( !BlATHsTRING1 ) etThread.strFuseF( tinP , psttReady , tb     ) ;
                etThread.delF( tinP , psttm ) ;
            }

            etThread.delF( tinP , pstt1w ) ;
        }

        if( idPort )
        {
            ZE( osTextT* , postPeanut ) ;
            countT costPeanut = etThread.strMakeF( tinP , LF , postPeanut , psttReady ) ; ___( postPeanut ) ;
            etThread.delF( tinP , psttReady ) ;
    
            ZE( countT* , pczName ) ;
            { countT pczFrom[] = { LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION , idPort | BM_HIGH , 0 } ; etThread.strStretchIF( tinP , pczName , pczFrom , tValueUrl ) ; ___( pczName ) ; }
    
            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
            {
                puseC pusePeanut( pusePeanutP ) ;

                grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
                            
                handleC hList( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                listC::openIF( tinP , hList , pczName ) ;

                ZE( fieldEditParamOutC* , pOut ) ;
                countT pczField[] = { /*U::peanut*/0x87654321 , 0 } ;                                                                                                                                                 \
                listC::fieldIF( tinP , pOut , hList , pczField , _1_pushC( postPeanut ) , LF ) ;
                DELlIST( fieldEditParamOutC , pOut ) ;
            }
            THREADmODE2rESTORE
            etThread.delF( tinP , postPeanut ) ;
            etThread.delF( tinP , pczName ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300008b.peanutcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300008c.logoutcbf BEGIN
#define DDNAME       "3func.3300008c.logoutcbf"
#define DDNUMB      (countT)0x3300008c
#define IDFILE      (countT)0x96b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT logoutCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    sessionC& session = sessionsP( tinP , nnPeerP ) ;
    session.setEmailF( tinP ) ;
    session.setIdAccountF( tinP ) ;
    session.privilegesF( tinP , flSESSIONpRIVILEGE_null ) ;

    meP.pushSnipF( tinP , stBodyP ,

        T(

            "This session will continue until it times out due to inactivity.\r\n"
            "  But it will no longer have the privileges that are associated with your account.\r\n"
        
        )

    ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300008c.logoutcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300008d.logincbf BEGIN
#define DDNAME       "3func.3300008d.logincbf"
#define DDNUMB      (countT)0x3300008d
#define IDFILE      (countT)0x96c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

osTextT* ppostEmail[] =
{
    "9bn.3vho@gmail.com" ,
    //"x0upY7.r@gmail.com" ,
} ;

countT pcIdAccount[] =
{
    1 ,
    //0x10 ,
} ;

/*1*/voidT loginCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    sessionC& session = sessionsP( tinP , nnPeerP ) ;

    if( etThread.diskIdF( tinP , T("///c") ) == IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 ) //FOR DEVELOPMENT CONVENIENCE; THIS BLOCK CAN REMAIN IN PRODUCTION CODE
    {
        ZE( countT , offa ) ;
        {
            static countT idInLath ;
            countT offIn = incv02AM( idInLath ) ;
            offa = offIn % ( sizeof pcIdAccount / sizeof pcIdAccount[ 0 ] ) ;
        }
    
        session.setEmailF( tinP , T(ppostEmail[offa]) ) ;
        session.setIdAccountF( tinP , pcIdAccount[ offa ] ) ;
    
        flagsT flagsp = flSESSIONpRIVILEGE_HIDEaDlINKS | flSESSIONpRIVILEGE_HIDEiMAGEaDS | flSESSIONpRIVILEGE_SENDaNDrECEIVEeMAIL | flSESSIONpRIVILEGE_VIEWuNTESTEDpAGES | flSESSIONpRIVILEGE_VIEWsERVERrEPORTS ;
        {
            accountS info( tinP , etThread , pcIdAccount[ offa ] , flACCOUNT1_null , flACCOUNT2_QUERYpAYPALpAYEReMAIL ) ;
            if( info.psttPaypalPayerEmail && info.psttPaypalPayerEmail->idAdam ) flagsp |= flSESSIONpRIVILEGE_FULLhEADER ;
        }
    
        session.privilegesF( tinP , flagsp ) ;
    }
    else
    {
        session.setEmailF( tinP ) ;
        session.setIdAccountF( tinP ) ;
    }

    ZE( pbRefC* , prPosts ) ;
    {
        ZE( osTextT* , postEmail ) ;
        IFsCRATCH
        {
            SCOOPS
            ZE( countT , costEmail ) ;
            // 3z141z1 IS THE VALUE -1 FOR idAccount
            tinP.pEtScratch->boxGetShadowF( tinP , postEmail , costEmail , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/accounts/3z141z1/txt.email.owner.txt") , 1 ) ; ___( postEmail ) ;
            if( POOP ) { POOPR ; }
        }
    
        if( postEmail )
        {
            session.setEmailF( tinP , T(postEmail) ) ;
            session.setIdAccountF( tinP , - 1 ) ;

            etThread.strMakeF( tinP , LF , prPosts , 
        
                T(
        
                    "<CENTER>\r\n"
                        "You have been logged into the test account.\r\n\r\n"
                    "</CENTER>\r\n"
                
                )
        
            , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        }
        else
        {
            etThread.strMakeF( tinP , LF , prPosts , 
        
                T(
        
                    "<CENTER>\r\n"
                        "<FORM METHOD=\"POST\" NAME=\"requestloginlink\" ACTION=\"/header/action/sendloginlink.html\">\r\n"
                            "<TABLE style=\"border-width: thick ; border-style: ridge ; border-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; width: 80% ;\">\r\n"
                                "<TR>\r\n"
                                    "<TD colspan=3 align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL " ;\">\r\n"
                                        "<SPAN class=\"spaLarge\">Login Via Email</SPAN>\r\n"
                                    "</TD>\r\n"
                                "</TR>\r\n"
                                "<TR>\r\n"
                                    "<TD align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTgRAY " ; color:white ;\">\r\n"
                                        "<SPAN class=\"spaXSmall\">\r\n"
                                            "A login link will be emailed to you immediately.\r\n"
                                            "  Do not enter an email address that conatins the trademark \"ideafarm\".\r\n"
                                        "</SPAN>\r\n"
                                    "</TD>\r\n"
                                    "<TD rowspan=3 align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL " ;\">\r\n"
                                        "<INPUT TYPE=\"hidden\" NAME=\"form\" VALUE=\"loginviaemaillink\">\r\n"
                                        "<INPUT TYPE=\"hidden\" NAME=\"port\" VALUE=\"")+TF2(meP.idPortF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\">\r\n"
                                        "Email: <INPUT ID=idaEmail TYPE=\"text\" MAXLENGTH=\"64\" SIZE=\"64\" NAME=\"email\" value=\"\"><BR>\r\n"
                                        "<SCRIPT LANGUAGE=\"JavaScript\">\r\n"
                                            "<!--\r\n"
                                                "document.getElementById( \"idaEmail\" ).focus() ;\r\n"
                                            "// -->\r\n"
                                        "</SCRIPT>\r\n"
                                    "</TD>\r\n"
                                    "<TD align=center valign=middle style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTrED   " ; color:white ;\">\r\n"
                                        "<INPUT TYPE=\"Submit\" NAME=\"Submit\" VALUE=\"Log Me In!\"> \r\n"
                                    "</TD>\r\n"
                                "</TR>\r\n"
                            "</TABLE>\r\n"
                        "</FORM>\r\n"
                    "</CENTER>\r\n"
                    "<P>\r\n"
                    "IdeaFarm " "(tm) Pledge signers can use this web site to contact other signers.\r\n"
                    "  To do that, log in by entering your email.\r\n"
                    "  Enter the same email address that you used to sign the IdeaFarm " "(tm) Pledge.\r\n"
                    "<P>\r\n"
                    "A link that can only be used one time will be emailed to you.\r\n"
                    "  Clicking that link will complete your login.\r\n"
                    "<P>\r\n"
                    "This \"login by email\" mechanism is a part of the security system that prevents people from using " postIFPE " to send spam to others.\r\n"
                    "  It is also a part of the general security system for IPDOS (tm), the system that serves this web site.\r\n"

                    //"Anonymous visitors are given only limited access.\r\n"
                    //"  For example, without logging in, you cannot view all of the pages that are available here.\r\n"
                    //"  You also cannot download files.\r\n"
                    //"<P>\r\n"
                    //"No account setup is required to log in to the IdeaFarm " "(tm) City web site.\r\n"
                    //"  You just need an email account, preferably with a provider that gives you access via your web browser.\r\n"
                    //"  To  login, enter your email above.\r\n"
                    //"  A link will be emailed to you immediately.\r\n"
                    //"  Click on that link to complete your login.\r\n"
                    //"<P>\r\n"
                    //"By logging in, you provide IdeaFarm " "(tm) Operations with a way to communicate with you.\r\n"
                    //"  Your email address will only be used administratively;\r\n"
                    //"  you will never receive sales, marketing, surveys, newsletters, or any other spam content.\r\n"
                    //"  You still enjoy anonymity, because no information other than your email address is required.\r\n"
                    //"  When you are logged in, additional pages and actions are available to you.\r\n"
                    //"  For example, you can edit the settings of your " postIFPE " subaccounts.\r\n"
                
                )
        
            , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        }
        etThread.delF( tinP , postEmail ) ;
    }

    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
    DEL( prPosts ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300008d.logincbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300008e.replaceowneremailcbf BEGIN
#define DDNAME       "3func.3300008e.replaceowneremailcbf"
#define DDNUMB      (countT)0x3300008e
#define IDFILE      (countT)0x96d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT replaceOwnerEmailCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    meP.pushSnipF( tinP , stBodyP ,

        T(
        
            "A confirmation email will be sent shortly to the email address that you used to log in.\r\n"
        
        )

    ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300008e.replaceowneremailcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300008f.newrelayemailcbf BEGIN
#define DDNAME       "3func.3300008f.newrelayemailcbf"
#define DDNUMB      (countT)0x3300008f
#define IDFILE      (countT)0x96e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT newRelayEmailCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    meP.pushSnipF( tinP , stBodyP ,

        T(
        
            "A confirmation email will be sent shortly to the following address:\r\n"
            "<SPAN class=\"spaLarge\" style=\"color:gray\">"
                "<P>\r\n"
        
        )
        +T(     psttKVReportP)
        +T("</SPAN>\r\n")

    ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300008f.newrelayemailcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000090.newlogincbf BEGIN
#define DDNAME       "3func.33000090.newlogincbf"
#define DDNUMB      (countT)0x33000090
#define IDFILE      (countT)0x96f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT newLoginCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    meP.pushSnipF( tinP , stBodyP ,

        T(
        
            "You account will be set up immediately, and login instructions will be sent to the following address:\r\n"
            "<SPAN class=\"spaLarge\" style=\"color:gray\">"
                "<P>\r\n"
        
        )
        +T(     psttKVReportP)
        +T("</SPAN>\r\n")

    ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000090.newlogincbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000091.downloadmenucbf BEGIN
#define DDNAME       "3func.33000091.downloadmenucbf"
#define DDNUMB      (countT)0x33000091
#define IDFILE      (countT)0x970


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT downloadMenuCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{

    ZE( strokeS* , zsttPasscode ) ;
    ZE( boolT , bOk ) ;
    {
        TN( tKey , "passcode" ) ;
        if( swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKey ) )
        {
            psttLeverKVP = tKey ;
            zsttPasscode = (strokeS*)(countT)swKVP ;
        }

        TN( tFile , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets/soul.ticket." ) ; tFile += T(zsttPasscode)+T(".soul") ;
        
        IFsCRATCH
        {
            SCOOPS
            bOk = !!tinP.pEtScratch->diskFileExistsF( tinP , tFile ) ;
            if( POOP ) { POOPR ; }
        }
    }

    meP.pushSnipF( tinP , stBodyP , !bOk

        ?

            T(
            
                "The ticket number below, which you entered, isn't valid.\r\n"
                "  A new ticket can be sent you you immediately.\r\n"
                "  Click \"do\" and then enter your email address where indicated.\r\n"
                "\r\n"
                "<SPAN class=\"spaLarge\" style=\"color:gray\">"
                    "<P>\r\n"
            
            )
            +T(     "you entered: \"")+T(zsttPasscode)+T("\"\r\n")
            +T("</SPAN>\r\n")

        :

            T(
            
                "You can view this menu as often as you like, even if you did not enter a valid ticket number.\r\n"
                "  The download links on this page have been configured to specify the ticket number that you entered.\r\n"
                "  If that ticket is expired, has already been used, or is invalid, the link won't work.\r\n"
                "<P>\r\n"
                "Tickets expire faster than milk goes bad on a hot day.\r\n"
                "  Only a limited number of tickets will be dispensed to you.\r\n"
                "  So use your ticket right away!\r\n"
                "<P>\r\n"
                "<CENTER>\r\n"
                    "<P>\r\n"
                    "<TABLE style=\"border-width: thick ; border-style: ridge ; border-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; width: 80% ;\">\r\n"
                        "<TR>\r\n"
                            "<TD colspan=3 align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL " ;\">\r\n"
                                "<SPAN class=\"spaLarge\"><B>IdeaFarm</B> (tm) <B>Piggyback Distributed Operating System</B></SPAN>\r\n"
                            "</TD>\r\n"
                        "</TR>\r\n"
                        "<TR>\r\n"
                            "<TD align=center valign=middle style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTrED   " ; color:white ;\">\r\n"
                            "<A HREF=\"ftp://visitor:")+T(zsttPasscode)+T("@" "ideafarm.com/ideafarm.zip\">ideafarm.zip</A>\r\n"
                            "</TD>\r\n"
                            "<TD align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTgRAY " ; color:white ;\">\r\n"
                                "<SPAN class=\"spaXSmall\">\r\n"
                                    "Be conversing with humans and other sentient objects in minutes!\r\n"
                                "</SPAN>\r\n"
                            "</TD>\r\n"
                            "<TD rowspan=3 align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL " ;\">\r\n"
                                "Required base operating system: Microsoft Windows.\r\n"
                                "<P>\r\n"
                                "  <B>IPDOS</B> (tm) is just a small Windows application, and installs like one.\r\n"
                                "  To install, just open this file after you've downloaded it.\r\n"
                                "  Within a minute, the SOIL (tm) tutorial will begin.\r\n"
                                "<P>\r\n"
                                "  With <B>IdeaFarm</B> (tm) <B>Sentient Object Interface Language</B>, you can converse with other sentient objects in <B>IdeaFarm</B> (tm) <B>Space</B>.\r\n"
                                "  This release only contains SOIL (tm); there is no other functionality.\r\n"
                                "  The current release of SOIL (tm) is only a sneak preview of great things to come.\r\n"
                                "  SOIL (tm) is currently being actively developed.\r\n"
                                "<P>\r\n"
                                "  A limited amount of free email support is included.\r\n"
                                "  Support turnaround is often 1 day, but please allow 8 days.\r\n"
                                "  SOIL (tm) will eventually be for everyone, but this early preview is intended only for experienced software developers.\r\n"
                                "  If you are not a software developer, but are curious, go ahead, but don't be suprised if you can get the software to fail.\r\n"
                                "<P>\r\n"
                                "  This release automatically disables itself when you reboot.\r\n"
                                "  After reboot, removal is completed by using the <B>IdeaFarm</B> (tm) <B>Removal Utility</B> that will be placed onto your desktop.\r\n"
                            "</TD>\r\n"
                        "</TR>\r\n"
                    "</TABLE>\r\n"
                "</CENTER>\r\n"
            
            )

    ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000091.downloadmenucbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000092.wotimepasscodecbf BEGIN
#define DDNAME       "3func.33000092.wotimepasscodecbf"
#define DDNUMB      (countT)0x33000092
#define IDFILE      (countT)0x971


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT woTimePasscodeCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    meP.pushSnipF( tinP , stBodyP ,

        T(
        
            "You one time passcode will be sent immediately to the email address displayed below.\r\n"
            "  Your passcode can only be used one time.\r\n"
            "  Subsequent attempts will fail.\r\n"
            "<P>\r\n"
            "One time passcodes give legitimate visitors easy access to " postIFC " while defending the City against attack.\r\n"
            "  When the City is locked down, one time passcodes will generally not be dispensed.\r\n"
            "  Your passcode is enabled only for a single purpose.\r\n"
            "  Passcodes for some purposes are issued only to <B>mEx</B> (tm) account holders with the " postIFC " bank.\r\n"
            "<P>\r\n"
            "Your passcode will expire one " postIFC " hour (90 foreign minutes) after it is sent.\r\n"
            "  Delivery of the email can be delayed.\r\n"
            "  Please use your passcode immediately upon receipt.\r\n"
            "<P>\r\n"
            "Only a limited number of passcodes will be dispensed to you.\r\n"
            "  Please ensure that you use your passcode immediately and that you do not reveal it to anyone.\r\n"
            "  If your email address becomes correlated with security problems, your access to " postIFC " might become restricted, even if the problems are caused by someone other than you.\r\n"
            "<SPAN class=\"spaLarge\" style=\"color:gray\">"
                "<P>\r\n"
        
        )
        +T(     psttKVReportP)
        +T("</SPAN>\r\n")

    ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000092.wotimepasscodecbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000093.obeyloginviaemaillinkcbf BEGIN
#define DDNAME       "3func.33000093.obeyloginviaemaillinkcbf"
#define DDNUMB      (countT)0x33000093
#define IDFILE      (countT)0x972


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

#define postSESSIONnEEDtOkNOW                                                                                                                                   \
                                                                                                                                                                \
    "You are now logged in.\r\n"                                                                                                                                \
    "  That means that the privileges that are associated with your account have been added to your session.\r\n"                                               \
    "<P>\r\n"                                                                                                                                                   \
    "This server views all activity originating from your computer as a \"session\".\r\n"                                                                       \
    "  Your computer is identified by its IP address.\r\n"                                                                                                      \
    "  The id of your session is displayed in the full page header.\r\n"                                                                                        \
    "  To view the full header, click \"more\".\r\n"                                                                                                            \
    "  The \"more\" selection will not appear until you have established your identity with " postIFO " by using PayPal (tm) to make a deposit.\r\n"            \
    "<P>\r\n"                                                                                                                                                   \
    "What you need to know about " postIPDOS " sessions:\r\n"                                                                                                   \
    "<P>\r\n"                                                                                                                                                   \
    "<UL>\r\n"                                                                                                                                                  \
    "<LI>Sessions end only by timing out.\r\n"                                                                                                                  \
    "<LI>You can open multiple browser windows, even using different browsers.  All such windows will show the same session id.\r\n"                            \
    "<LI>If someone is logged into your computer, e.g. using Windows Remote Desktop, then that person is effectively logged in as you.\r\n"                     \
    "</UL>\r\n"                                                                                                                                                 \
    "<P>\r\n"                                                                                                                                                   \
    "You can get to the home page from any other page by clicking \"IDEAFARM.COM\" in the page header.\r\n"                                                     \
    "  If the window or browser tab containing the \"login\" link that you clicked is still open, click \"IDEAFARM.COM\" in it after closing the new window or tab that you are now reading.\r\n"

/*1*/voidT obeyLoginViaEmailLinkCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    //ZE( strokeS* , psttEmailAlready ) ;
    ZE( countT   , idAccountAlready ) ;
    {
        sessionC& session = sessionsP( tinP , nnPeerP ) ;
        //session.getEmailF( tinP , psttEmailAlready ) ; ___( psttEmailAlready ) ;
        idAccountAlready = session.getIdAccountF( tinP ) ;
    }

    ZE( boolT , bOk ) ;
    ZE( boolT , bNewAccount ) ;
    ZE( countT , idPortVerify ) ;
    TN( tEmail , "" ) ;
    IFsCRATCH
    {
        SCOOPS
        TN( tKey , "idticket" ) ;
        if( swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKey ) )
        {
            psttLeverKVP = tKey ;
            strokeS*& zsttIdTicket = *(strokeS**)&(countT&)swKVP ;
            if( zsttIdTicket ) { etThread.strTrimF( tinP , zsttIdTicket , 0 , T(TbLACKnEWlINE) ) ; ___( zsttIdTicket ) ; }

            TN( tDirOld , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets/" ) ;
            TN( tDirNew , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets.used/" ) ;
            tinP.pEtScratch->diskMakeDirIfNeededF( tinP , tDirNew ) ;
            if( POOP ) { POOPR ; }

            TN( tShort  , "soul.ticket." ) ; tShort += T(zsttIdTicket)+T(".soul") ;
            TN( tFileNew , "" ) ; tFileNew = tDirNew+tShort ;
            tinP.pEtScratch->diskMoveFileOrDirF( tinP , tFileNew , tDirOld+tShort , 1 ) ;
            if( POOP ) { POOPR ; }
            else
            {
                soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                tinP.pEtScratch->boxGetShadowF( tinP , sIn , tFileNew ) ;

                ZE( countT , finger ) ;
                sIn >> finger ;
                if( finger == FINGERnEG_TICKET )
                {
                    ZE( countT , idFormat ) ;
                    sIn >> idFormat ;
                    if( idFormat == 1 )
                    {
                        ZE( countT , idType ) ;
                        sIn >> idType ;
                        if( idType == ifcIDtYPEtICKET_LOGINvIAeMAILlINK )
                        {
                            {
                                ZE( strokeS* , psttEmail ) ;
                                sIn >> psttEmail ; ___( psttEmail ) ;
                                tEmail = T(psttEmail) ;
                                etThread.delF( tinP , psttEmail ) ;
                            }

                            sIn >> idPortVerify ;

                            countT idAccount = queryIdAccountFromEmailF( tinP , tEmail ) ;
                            __Z( idAccount ) ;
                            if( idAccount )
                            {
                                sessionC& session = sessionsP( tinP , nnPeerP ) ;
                                session.setEmailF( tinP , tEmail ) ;
                                session.setIdAccountF( tinP , idAccount ) ;

                                flagsT flagsp = flSESSIONpRIVILEGE_null ;

                                {
                                    accountS info( tinP , etThread , idAccount , flACCOUNT1_null , flACCOUNT2_QUERYpAYPALpAYEReMAIL ) ;
                                    if( info.psttPaypalPayerEmail && info.psttPaypalPayerEmail->idAdam ) flagsp = flSESSIONpRIVILEGE_FULLhEADER ;
                                }

                                if( idAccount == 1 ) flagsp |= flSESSIONpRIVILEGE_HIDEaDlINKS | flSESSIONpRIVILEGE_HIDEiMAGEaDS | flSESSIONpRIVILEGE_SENDaNDrECEIVEeMAIL | flSESSIONpRIVILEGE_VIEWuNTESTEDpAGES | flSESSIONpRIVILEGE_VIEWsERVERrEPORTS ;

                                session.privilegesF( tinP , flagsp ) ;

                                bOk = 1 ;
                            }
                        }
                    }
                }
            }
        }
    }

    boolT bOkPort = idPortVerify == meP.idPortF( tinP ) ;

    ZE( pbRefC* , prPosts ) ;
    if( bOk && bOkPort )
    {
        if( idPortVerify == ifcIDpORT_HTTP )
        {
            etThread.strMakeF( tinP , LF , prPosts , 
        
                T(
                
                    postSESSIONnEEDtOkNOW
                    "<P>\r\n"
                    "Please note, by inspecting the header bar above, that you are NOT\r\n"
                    "  connected to an IdeaFarm " "(tm) City Door or Panic Door.\r\n"
                    "  " postIPDOS " is serving you from IdeaFarm " "(tm) City, but your\r\n"
                    "  speech is NOT entering IdeaFarm " "(tm) City and is NOT taking effect\r\n"
                    "  there.  Territorial law applies.\r\n"
    
                )
        
            , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        }
        else
        {
            etThread.strMakeF( tinP , LF , prPosts , 
        
                T(
                
                    postSESSIONnEEDtOkNOW
                    "<P>\r\n"
                    "Please note, by inspecting the header bar above, that you ARE\r\n"
                    "  connected to an IdeaFarm " "(tm) City Door or Panic Door.\r\n"
                    "  Your speech IS entering IdeaFarm " "(tm) City and IS taking effect\r\n"
                    "  there.  Beware; you are neither protected nor constrained by territorial law.\r\n"
                    "  IdeaFarm " "(tm) City law does apply.\r\n"
                    "<P>\r\n"
                    "If you are not familiar with the legal aspects of IdeaFarm " "(tm) City, please\r\n"
                    "  read the relevant information by clicking \"ideas\" above.\r\n"
    
                )
        
            , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        }
    }
    else if( bOk )
    {
        if( idPortVerify == ifcIDpORT_HTTP )
        {
            etThread.strMakeF( tinP , LF , prPosts , 
        
                T(
                
                    postSESSIONnEEDtOkNOW
                    "<P>\r\n"
                    "Please note, by inspecting the header bar above, that you are NOT\r\n"
                    "  connected to an IdeaFarm " "(tm) City Door or Panic Door.\r\n"
                    "  " postIPDOS " is serving you from IdeaFarm " "(tm) City, but your\r\n"
                    "  speech is NOT entering IdeaFarm " "(tm) City and is NOT taking effect\r\n"
                    "  there.  Territorial law applies.\r\n"
                    "<P>\r\n"
                    "The link that you used to log in appears to have been modified.\r\n"
                    "  Please note that you were logged in according to the link and\r\n"
                    "  not according to the session type (Web, Door, Panic Door) that\r\n"
                    "  was in effect when you requested that a link be emailed to you.\r\n"
    
                )
        
            , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        }
        else
        {
            etThread.strMakeF( tinP , LF , prPosts , 
        
                T(
                
                    postSESSIONnEEDtOkNOW
                    "<P>\r\n"
                    "Please note, by inspecting the header bar above, that you ARE\r\n"
                    "  connected to an IdeaFarm " "(tm) City Door or Panic Door.\r\n"
                    "  Your speech IS entering IdeaFarm " "(tm) City and IS taking effect\r\n"
                    "  there.  Beware; you are neither protected nor constrained by territorial law.\r\n"
                    "  IdeaFarm " "(tm) City law does apply.\r\n"
                    "<P>\r\n"
                    "If you are not familiar with the legal aspects of IdeaFarm " "(tm) City, please\r\n"
                    "  read the relevant information by clicking \"ideas\" above.\r\n"
                    "<P>\r\n"
                    "The link that you used to log in appears to have been modified.\r\n"
                    "  Please note that you were logged in according to the link and\r\n"
                    "  not according to the session type (Web, Door, Panic Door) that\r\n"
                    "  was in effect when you requested that a link be emailed to you.\r\n"
    
                )
        
            , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        }
    }
    else
    {
        TN( tSay , idAccountAlready

            ?
                "Clicking that login link did <U>not</U> log you in.\r\n"
                "  However, the computer that you are using is already logged in.\r\n"
                "<P>\r\n"
                "The login link that you clicked to display this page has already been used.\r\n"
                "  Each login link can only be used wo time.\r\n"
                "<P>\r\n"
                "Wo time login links provide good security for your account, but only if you click them as soon as they arrive in your email inbox.\r\n"
                "  If you know that you did not click this login link before, contact the organizer immediately by clicking \"contact\" in the header of any page.\r\n"
                "  Report that this page displayed and state that you believe the security of your account has been breached.\r\n"
            :
                "You have <U>not</U> been logged in.\r\n"
                "<P>\r\n"
                "The login link that you clicked to display this page has already been used.\r\n"
                "  Each login link can only be used wo time.\r\n"
                "<P>\r\n"
                "Wo time login links provide good security for your account, but only if you click them as soon as they arrive in your email inbox.\r\n"
                "  If you know that you did not click this login link before, contact the organizer immediately by clicking \"contact\" in the header of any page.\r\n"
                "  Report that this page displayed and state that you believe the security of your account has been breached.\r\n"

        ) ;

        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
    }

    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
    DEL( prPosts ) ;

    if( bNewAccount )
    {
        meP.pushSnipF( tinP , stBodyP ,

            T(
            
                "<P>\r\n"
                "Welcome to " postIFC ".\r\n"
                "  An account has been set up for you.\r\n"
                "  When you are logged in, your email address will appear in the grey bar above.\r\n"
                "  This account is the same account that has been, or will be, used to set up any " postIFPE " subaccounts for you.\r\n"

            )

        ) ;
    }
}

#undef postSESSIONnEEDtOkNOW


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000093.obeyloginviaemaillinkcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000094.obeyearnmoneylinkcbf BEGIN
#define DDNAME       "3func.33000094.obeyearnmoneylinkcbf"
#define DDNUMB      (countT)0x33000094
#define IDFILE      (countT)0x973


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT obeyEarnMoneyLinkCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    ZE( boolT , bOk ) ;
    IFsCRATCH
    {
        SCOOPS
        TN( tKey , "idticket" ) ;
        if( swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKey ) )
        {
            psttLeverKVP = tKey ;
            strokeS*& zsttIdTicket = *(strokeS**)&(countT&)swKVP ;
            if( zsttIdTicket ) { etThread.strTrimF( tinP , zsttIdTicket , 0 , T(TbLACKnEWlINE) ) ; ___( zsttIdTicket ) ; }

            TN( tDirOld , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets/" ) ;
            TN( tDirNew , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets.used/" ) ;
            tinP.pEtScratch->diskMakeDirIfNeededF( tinP , tDirNew ) ;
            if( POOP ) { POOPR ; }

            TN( tShort  , "soul.ticket." ) ; tShort += T(zsttIdTicket)+T(".soul") ;
            TN( tFileNew , "" ) ; tFileNew = tDirNew+tShort ;
            tinP.pEtScratch->diskMoveFileOrDirF( tinP , tFileNew , tDirOld+tShort , 1 ) ;
            if( POOP ) { POOPR ; }
            else
            {
                soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                tinP.pEtScratch->boxGetShadowF( tinP , sIn , tFileNew ) ;

                ZE( countT , finger ) ;
                sIn >> finger ;
                if( finger == FINGERnEG_TICKET )
                {
                    ZE( countT , idFormat ) ;
                    sIn >> idFormat ;
                    if( idFormat == 1 )
                    {
                        ZE( countT , idType ) ;
                        sIn >> idType ;
                        if( idType == ifcIDtYPEtICKET_EARNmONEYlINK )
                        {
                            TN( tEmail , "" ) ;
                            {
                                ZE( strokeS* , psttEmail ) ;
                                sIn >> psttEmail ; ___( psttEmail ) ;
                                tEmail = T(psttEmail) ;
                                etThread.delF( tinP , psttEmail ) ;
                            }

                            if( POOP ) { POOPR ; }
                            else
                            {
                                bOk = 1 ;

                                countT idAccCommission = queryIdAccountFromEmailF( tinP , tEmail ) ;
                                //U::LOGrAW3( "idAccCommission: " , idAccCommission , "\r\n" ) ;

                                sessionC& session = sessionsP( tinP , nnPeerP ) ;
                                session.setIdAccountCommissionF( tinP , idAccCommission ) ;
                            }
                        }
                    }
                }
            }
        }
    }

    TN( tSay , "" ) ; tSay = T(

        "Thank you for giving " postIFO " a moment to present itself.\r\n"
        "  The person who sent you the link is selling for " postIFO " to earn money.\r\n"
        "  That person is required to obtain your permission before sending a link to you.\r\n"
        "  This rule is strictly enforced.\r\n"
        "  If you did not give permission, please report this by clicking \"contact\" at the top of this or any page.\r\n"
        "<P>\r\n"
        "These links are not to be published or posted to newsgroups or any other public forum.\r\n"
        "  They are intended only for person to person word of mouth referral.\r\n"
        "  If the link was posted in a public place, please report that.\r\n"
        "<P>\r\n"
        "The link cannot be used again.\r\n"
        "  If you would like to send a similar link to somewo, click \"login\" above and then click \"do\".\r\n"
        "  On that page, you will find a button that will send you a link that you can copy and paste into an email to send to somewo.\r\n"
        "<P>\r\n"
        "Please click IDEAFARM.COM at the top of this page and give a moment to consider our proposition.\r\n"
        "  If you make a purchase during the current session, the person that sent you the link will receive 1/8th commission on your purchase.\r\n"
        "  If you make a purchase at some later time, without using a referral link, a 1/8 th commission will be placed into a general fund and distributed to all of the people selling for " postIFO ".\r\n"
        "<P>\r\n"
        postIFO " operates transparently and will respect your privacy.\r\n"

    ) ;

    meP.pushSnipF( tinP , stBodyP , tSay ) ;

    if( !bOk )
    {
        tSay = T(

            "<P>\r\n"
            "Note: The link that you clicked had already been used, so the person who sent it to you will not receive a commission on anything that you purchase in this session.\r\n"
            "  If you make a purchase, the commission will be put into a general fund that is paid out to all of the people who sell for IdeaFarm " "(tm) Operations.\r\n"
            "  Restricting these links to a single use is intended to discourage spamming.\r\n"
            "  If you did not give your correspondent permission to send the link to you, or if you found the link posted publicly, please report this using the white box at the top of this page.\r\n"

        ) ;

        meP.pushSnipF( tinP , stBodyP , tSay ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000094.obeyearnmoneylinkcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000095.obeyemaillinkreplaceowneremailcbf BEGIN
#define DDNAME       "3func.33000095.obeyemaillinkreplaceowneremailcbf"
#define DDNUMB      (countT)0x33000095
#define IDFILE      (countT)0x974


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT obeyEmailLinkReplaceOwnerEmailCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    TN( tEmailLoggedIn , "" ) ;
    ZE( countT , idAccountLoggedIn ) ;
    {
        ZE( strokeS* , psttEmailLoggedIn ) ;
        sessionC& session = sessionsP( tinP , nnPeerP ) ;
        session.getEmailF( tinP , psttEmailLoggedIn ) ; ___( psttEmailLoggedIn ) ;
        idAccountLoggedIn = session.getIdAccountF( tinP ) ;
        tEmailLoggedIn = T(psttEmailLoggedIn) ;
        etThread.delF( tinP , psttEmailLoggedIn ) ;
    }

    ZE( boolT , bDone ) ;
    ZE( boolT , bAlreadyExists ) ;
    TN( tEmailTicket , "" ) ;
    IFsCRATCH
    {
        SCOOPS
        TN( tKey , "idticket" ) ;
        if( swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKey ) )
        {
            psttLeverKVP = tKey ;
            strokeS*& zsttIdTicket = *(strokeS**)&(countT&)swKVP ;
            if( zsttIdTicket ) { etThread.strTrimF( tinP , zsttIdTicket , 0 , T(TbLACKnEWlINE) ) ; ___( zsttIdTicket ) ; }

            TN( tDirOld , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets/" ) ;
            TN( tDirNew , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets.used/" ) ;
            tinP.pEtScratch->diskMakeDirIfNeededF( tinP , tDirNew ) ;
            if( POOP ) { POOPR ; }

            TN( tShort  , "soul.ticket." ) ; tShort += T(zsttIdTicket)+T(".soul") ;
            TN( tFileNew , "" ) ; tFileNew = tDirNew+tShort ;
            tinP.pEtScratch->diskMoveFileOrDirF( tinP , tFileNew , tDirOld+tShort ) ;
            if( POOP ) { POOPR ; }
            else
            {
                soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                tinP.pEtScratch->boxGetShadowF( tinP , sIn , tFileNew ) ;

                ZE( countT , finger ) ;
                sIn >> finger ;
                if( finger == FINGERnEG_TICKET )
                {
                    ZE( countT , idFormat ) ;
                    sIn >> idFormat ;
                    if( idFormat == 1 )
                    {
                        ZE( countT , idType ) ;
                        sIn >> idType ;
                        if( idType == ifcIDtYPEtICKET_REPLACEaCCOUNToWNEReMAIL )
                        {
                            ZE( countT , idAccountTicket ) ;
                            sIn >> idAccountTicket ;
                            if( idAccountTicket && idAccountTicket == idAccountLoggedIn )
                            {
                                {
                                    ZE( strokeS* , psttEmailTicket ) ;
                                    sIn >> psttEmailTicket ; ___( psttEmailTicket ) ;
                                    tEmailTicket = T(psttEmailTicket) ;
                                    etThread.delF( tinP , psttEmailTicket ) ;
                                }

                                //SEARCH FOR AN EXISTING ACCOUNT OWNED BY tEmailTicket; THIS NEEDS TO BE DONE WITHOUT BLOWING MEMORY WITH A LARGE LIST
                                TN( tIpdosAccounts , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/accounts/" ) ;
                                TN( tShortFileOwner , "txt.email.owner.txt" ) ;
                                {
                                    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                    ZE( strokeS* , psttDirAccount ) ;
                                    etThread.diskFindFileOrDirF( tinP , psttDirAccount , hFind , tIpdosAccounts ) ; ___( psttDirAccount ) ;
                        
                                    while( !etThread && psttDirAccount && !bAlreadyExists )
                                    {
                                        ZE( boolT , bDots ) ;
                                        ZE( boolT , bDir ) ;
                                        {
                                            bDir = psttDirAccount && psttDirAccount[ CSpREFIX - 1 + psttDirAccount->idAdam ].idAdam == '/' ;
                        
                                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                            ZE( strokeS* , psttw ) ;
                                            etThread.strWordF( tinP , psttw , psttDirAccount , sttq , S1C('/') , - 1 - bDir ) ; ___( psttw ) ;
                        
                                            bDots = 
                                                !etThread.strCompareF( tinP , psttw , T("..") ) ||
                                                !etThread.strCompareF( tinP , psttw , T(".") )
                                            ;
                                            etThread.delF( tinP , psttw ) ;
                                        }
                        
                                        if( !bDir || bDots ) etThread.delF( tinP , psttDirAccount ) ;
                                        else
                                        {
                                            ZE( osTextT* , posti ) ;
                                            ZE( countT , costi ) ;
                                            tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , T(psttDirAccount)+tShortFileOwner ) ; ___( posti ) ;
                                            if( POOP ) { POOPR ; }
                                            else if( posti && costi && !etThread.strCompareF( tinP , tEmailTicket , T(posti) ) ) bAlreadyExists = 1 ;
                                            etThread.delF( tinP , posti ) ;
                                        }
                        
                                        etThread.delF( tinP , psttDirAccount ) ;
                                        if( !bAlreadyExists ) { etThread.diskFindFileOrDirF( tinP , psttDirAccount , hFind , tIpdosAccounts ) ; ___( psttDirAccount ) ; }
                                    }
                                }

                                if( !bAlreadyExists )
                                {
                                    TN( tDirAccount , "" ) ; tDirAccount = tIpdosAccounts+TF4(idAccountLoggedIn,flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_NObIGITvALUES,0,36)+T("/") ;
            
                                    TN( tFile , "" ) ; tFile = tDirAccount+tShortFileOwner ;
                                    ZE( osTextT* , posti ) ;
                                    ZE( countT , costi ) ;
                                    tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , tFile , 1 ) ; ___( posti ) ;
                                    if( POOP ) { POOPR ; }
                                    else if( posti && !etThread.strCompareF( tinP , T(posti) , tEmailLoggedIn ) )
                                    {
                                        etThread.boxPutF( tinP , tFile , tEmailTicket , tEmailTicket.csF( tinP ) ) ;
                                        {
                                            TN( tDirSubaccounts , "" ) ; tDirSubaccounts += tDirAccount+T("/subaccounts/") ;
                                            handleC hFind1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                            do
                                            {
                                                ZE( infoFileS* , pInfo1 ) ;
                                                tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo1 , hFind1 , tDirSubaccounts ) ; ___( pInfo1 ) ;
                                                if( pInfo1 && F(pInfo1->flags) & flFILEaTTR_DIRECTORY && !( F(pInfo1->flags) & flFILEaTTR_DOTdIRECTORY ) )
                                                {
                                                    TN( tDirSubaccount , "" ) ; tDirSubaccount = T(pInfo1->psttIfoName) ;
                                                    patternC pat( tinP , etThread , T("txt.*") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                                                    handleC hFind2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                                    do
                                                    {
                                                        ZE( infoFileS* , pInfo2 ) ;
                                                        tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo2 , hFind2 , tDirSubaccount , &pat ) ; ___( pInfo2 ) ;
                                                        if( pInfo2 && !( F(pInfo2->flags) & flFILEaTTR_DIRECTORY ) )
                                                        {
                                                            ZE( osTextT* , posti ) ;
                                                            ZE( countT , costi ) ;
                                                            tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , pInfo2->psttIfoName , 1 ) ; ___( posti ) ;
                                                            if( POOP ) { POOPR ; }
                                                            else if( posti && *posti )
                                                            {
                                                                ZE( strokeS* , psttw ) ;
                                                                etThread.strReplaceF( tinP , psttw , T(posti) , tEmailLoggedIn , tEmailTicket , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttw ) ;
                                                                TN( tNew , "" ) ; tNew = T(psttw) ;
                                                                etThread.delF( tinP , psttw ) ;
                                                                tinP.pEtScratch->boxPutF( tinP , pInfo2->psttIfoName , tNew , tNew.csF( tinP ) ) ;
                                                            }
                                                            etThread.delF( tinP , posti ) ;
                                                        }
                                                        DEL( pInfo2 ) ;
                                                    }
                                                    while( ~hFind2 ) ;
                                                }
                                                DEL( pInfo1 ) ;
                                            }
                                            while( ~hFind1 ) ;
                                        }
                                        bDone = 1 ;
                                    }
                                    etThread.delF( tinP , posti ) ;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if( bDone )
    {
        meP.pushSnipF( tinP , stBodyP ,

            T(
            
                "Done.\r\n"
                "<P>\r\n"

            )
            +T(     psttKVReportP)
            +T("</SPAN>\r\n")

        ) ;
    }
    else if( bAlreadyExists )
    {
        meP.pushSnipF( tinP , stBodyP ,

            T(
            
                "Not done.  Another account is owned by the proposed email address.\r\n"
                "<P>\r\n"

            )
            +T(     psttKVReportP)
            +T("</SPAN>\r\n")

        ) ;
    }
    else
    {
        meP.pushSnipF( tinP , stBodyP ,

            T(
            
                "Not done.\r\n"
                "<P>\r\n"

            )
            +T(     psttKVReportP)
            +T("</SPAN>\r\n")

        ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000095.obeyemaillinkreplaceowneremailcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000096.earnmoneylinkcbf BEGIN
#define DDNAME       "3func.33000096.earnmoneylinkcbf"
#define DDNUMB      (countT)0x33000096
#define IDFILE      (countT)0x975


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT earnMoneyLinkCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    meP.pushSnipF( tinP , stBodyP ,

        T(
        
            "Your Earn Money link will be sent immediately to the email address displayed below.\r\n"
            "  This link can only be used one time.\r\n"
            "<P>\r\n"
            "  Obtain permission before emailing the link to anywo.\r\n"
            "  Don't publish the link or post it to any newsgroup or public forum.\r\n"
            "<P>\r\n"
            postIFO " uses permission selling.\r\n"
            "  Respect others.\r\n"
            "  Don't spam people!\r\n"
            "<P>\r\n"
            "Abuse can result in temporary or permanent loss of sales commission privileges.\r\n"
            "<SPAN class=\"spaLarge\" style=\"color:gray\">"
                "<P>\r\n"
        
        )
        +T(     psttKVReportP)
        +T("</SPAN>\r\n")

    ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000096.earnmoneylinkcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000097.loginviaemaillinkcbf BEGIN
#define DDNAME       "3func.33000097.loginviaemaillinkcbf"
#define DDNUMB      (countT)0x33000097
#define IDFILE      (countT)0x976


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT loginViaEmailLinkCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    meP.pushSnipF( tinP , stBodyP ,

        T(
        
            "Your Login Via Email link will be sent immediately to the email address displayed below.\r\n"
            "  This link can only be used one time.\r\n"
            "<P>\r\n"
            "If the email containing the link does not arrive within 2 minutes, please check your spam folder.\r\n"
            "  If you find it there, please configure your email account to accept email from addresses ending with \"@ideafarm.com\".\r\n"
            "<P>\r\n"
            "Login Via Email links give legitimate visitors easy access to " postIFC " while defending the City against attack.\r\n"
            "  When you Login Via Email, there are no user ids or passwords to remember, reset, or curse!\r\n"
            "  When you click the link, a session will open of the same type that you were using when you requested the link.\r\n"
            "  The privileges associated with your account will be in effect until that session expires due to inactivity.\r\n"
            "<P>\r\n"
            "Your link will expire one " postIFC " hour (90 foreign minutes) after it is sent.\r\n"
            "  Delivery of the email can be delayed.\r\n"
            "  Please use your login link immediately upon receipt.\r\n"
            "<SPAN class=\"spaLarge\" style=\"color:gray\">"
                "<P>\r\n"
        
        )
        +T(     psttKVReportP)
        +T("</SPAN>\r\n")

    ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000097.loginviaemaillinkcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000098.slideshowtellinitcbf BEGIN
#define DDNAME       "3func.33000098.slideshowtellinitcbf"
#define DDNUMB      (countT)0x33000098
#define IDFILE      (countT)0x977


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT slideShowTellinItCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    TN( tKeyMode , "mode" ) ;
    TN( tModeList   , "View List of All Slides" ) ;
    TN( tModeSlides , "View Slide Show" ) ;

    TN( tKeyNext , "next" ) ;
    TN( tNextForward  , ">" ) ;
    TN( tNextBackward , "<" ) ;

    ZE( strokeS* , zsttMode ) ;
    if( swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKeyMode ) )
    {
        psttLeverKVP = tKeyMode ;
        zsttMode = (strokeS*)(countT)swKVP ;
    }

    ZE( strokeS* , zsttNext ) ;
    if( swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKeyNext ) )
    {
        psttLeverKVP = tKeyNext ;
        zsttNext = (strokeS*)(countT)swKVP ;
    }

    static osTextT* postThanks =

        "\"Thank you!\" to the hundreds of men and women who taught the organizer \"how it is\" as together they sweated, froze, got soaked, mashed their fingers, cut up their hands, filled their lungs with dust and sewer gas, and barely escaped death on construction sites across the United States."
        "<P>\r\n"
        "The organizer has lived on the road since 2000, working as a construction laborer and carpenter up and down both coasts and throughout the interior.\r\n"
        "  The party line served up by the thought steering industry is horseshit casserole, and the people either know it outright or have a deep sense that something is very wrong.\r\n"
        "  Hear them as they \"Tell It Like It Is\"!\r\n"
        //"<P>\r\n"
        //"These are \"synthetic quotes\".\r\n"
        //"  A few of them are word for word quotes from people that the organizer met while working, waiting at agencies to be sent out to jobs, shopping in grocery stores, doing his laundry at laundromats, etc.\r\n"
        //"  A few of them are completely fictional quotes that express what the organizer thinks is on the minds of the people.\r\n"
        //"  Most are semifactual synthesized voices of the powerless rage and silent fear of thousands of real men and women personally encountered.\r\n"
        //"<P>\r\n"
        //"These quotes present the people of the United States as the organizer encountered them, and so do not fairly represent the entire population.\r\n"
        //"  His years as a migrant construction laborer give disproportionate weight to those who occupy the lower economic and social classes in the United States.\r\n"
        //"  The resulting \"view from below\" can be useful to occupants of all income and social classes in constructing a complete picture of this moment in the history of the United States.\r\n"

    ;

    static osTextT* ppostSlide[] =
    {
            "Joe: \"Recession?  That's the party line.  We need to get real.<BR>The United States is sliding into third world economic status.\"\r\n"
        ,
            "Sam: \"I can't concentrate at work.  My wife... Her office \"mate\"...<BR>It's just driving me crazy.\"\r\n"
        ,
            "Ed: \"I like to work and am a skilled engineer.  But at the office,<BR>it's 10% production and 90% bullshit.\r\n"
        ,
            "Pete: \"Concentrate on building a product?  The income tax forces me to invest in real estate.<BR>I lost more money on my home last quarter than I'll make all year at work.<BR>I fall asleep thinking about the city council agenda and the<BR>local economy, not about product design!\"\r\n"
        ,
            "Joe: \"There is something very wrong with our economic system.<BR>But what can we do about it?\"\r\n"
        ,
            "Bill: \"I don't have time to do anything about anything.<BR>Layoffs are coming at work, and we're all doing<BR>the 'cover thine ass' scramble.\"\r\n"
        ,
            "<B>IdeaFarm</B> (tm) <B>Associates</B>:  Weekly community dinner hour.<BR>You can do this.  Feel Your Power!\r\n"
        ,
            "Weekly community dinner hour.<BR>Where your grandchildren's world will be born.\r\n"
        ,
            "Take action!  Feel Your Power!<BR>Your children, and your teenagers, are watching.\r\n"
        ,
            "Sharon: \"I manage a software engineering group.  It's really two groups.<BR>The women connect, they build consensus.  For the men, its<BR>all about winning/losing, with every man for himself.\"\r\n"
        ,
            "\"I never played with dolls or dreamed of marrying Prince Charming or of being a mommy.<BR>Making a home?  That's not who I am.  Men have their uses,<BR>but I'm no one's dependent!\"\r\n"
        ,
            "Luz: \"George came home drunk last night... See these bruises...<BR>Do you think I should leave him?\"\r\n"
        ,
            "Vivian: \"When I was young, I could get anything with a smile.<BR>My schmuck husband didn't have a clue.  Let me tell you,<BR>I had some great sex; just not with him!\"\r\n"
        ,
            "Marsha: \"I'm an at-home wife and mother.<BR>It's so boring and lonely.  The neighborhood women are gone all day,<BR>wrapped up in their jobs, in a different world.\"\r\n"
        ,
            "Gwen: \"I'm home with young children.  Bill just lost his job, and the sparkle in his eyes is gone.<BR>I don't know him anymore; he won't tell me anything.  I'm scared...\"\r\n"
        ,
            "Sharon: \"At work, I have authority and am respected.  At home,<BR>it's an unending stream of little put downs by a weak,<BR>insecure man who's life is going nowhere.\"\r\n"
        ,
            "\"It's not working out.  We never wanted children.  Now we don't even want sex,<BR>with each other, anyways.  What has happened to all of the men?<BR>Where did all of the good ones go?\"\r\n"
        ,
            "Joe: \"How can the United States be strong if we cannot<BR>even produce a can opener that works?\"\r\n"
        ,
            "Sam: \"Building kickass products that people worldwide want to buy,<BR>products that 'come out swinging',<BR>is work for Men.\"\r\n"
        ,
            "Ed: \"My Chinese competitor doesn't need to pussyfoot around building consensus<BR>while asking, \"Pretty please, with sugar on top?\".<BR>He just says, \"Do it.\", and it gets done.<BR>100% production.  0% bullshit.\r\n"
        ,
            "\"Then he goes home to a warm clean home, respectful and happy children, and a<BR>good meal prepared by a competent wife who loves him<BR>and honors his authority.\"\r\n"
        ,
            "\"I come home to a cold, dark, silent place.  My 'wife', a trial lawyer, doesn't want children.<BR>It's not a woman; it's a man with tits!\"\r\n"
        ,
            "\"We don't have sex anymore.  Not real sex.<BR>Not the 'I love you; let's make a family' kind of sex.<BR>My gun is only loaded with blanks.  What's the point?\"\r\n"
        ,
            "Bill: \"I can't be a Man either at work or at home.  But I'm drawing the line.<BR>This globally warmed Hell will freeze over before<BR>I will take orders from a female boss.\"\r\n"
        ,
            "Sam: \"Put me on a crew of men.  Let me work as men work.  Let me cuss like a sailor<BR>and sing baudy limericks and of heroes past and present with my brothers.  Give me sweat,<BR>muscle, a paycheck, and honor at home.  I will give you Production,<BR>and together, we shall Kick Ass.\"\r\n"
        ,
            "!end"
    } ;
    const countT cElt = sizeof ppostSlide / sizeof ppostSlide[ 0 ] ;

    boolT bForward  = zsttNext && !etThread.strCompareF( tinP , zsttNext , tNextForward ) ;
    boolT bBackward = zsttNext && !etThread.strCompareF( tinP , zsttNext , tNextBackward ) ;
    boolT bSlideRequested = bForward || bBackward || ( zsttMode && !etThread.strCompareF( tinP , zsttMode , tModeSlides ) ) ;
    boolT bEpilog = 1 ;
    ZE( boolT , bThanksVisible ) ;
    if( bSlideRequested )
    {
        sessionC& session = sessionsP( tinP , nnPeerP ) ;
        countT idSlide = session.dispenseIdF( tinP , 2 , bBackward ) ;

        countT offs = ( idSlide - 1 ) % cElt ;

        TN( tRemaining , "" ) ;
        {
            TN( tDot  , "." ) ;
            TN( tUp   , "/" ) ;
            TN( tPeak , "|" ) ;
            TN( tDown , "\\" ) ;
            TN( tb    , " " ) ;
            measureT mAll      = ( cElt - 1 ) ;
            measureT mHalf     = mAll / 2.0 ;
            measureT mQuarter1 = mAll / 4.0 ;
            measureT mQuarter3 = mAll * 3.0 / 4.0 ;
            measureT mHere     = 1 + offs ;
            for( measureT mIds = mHere ; mIds <= mAll ; mIds ++ )
            {
                     if( mIds <  mQuarter1   ) tRemaining += tb+tDot  ;
                else if( mIds <  mHalf - 0.5 ) tRemaining += tb+tUp   ;
                else if( mIds <= mHalf + 0.5 ) tRemaining += tb+tPeak ;
                else if( mIds <= mQuarter3   ) tRemaining += tb+tDown ;
                else                           tRemaining += tb+tDot  ;
            }
            tRemaining += tb ;
        }

        if( offs == cElt - 1 ) bThanksVisible = bEpilog = 1 ;
        else
        {
            bEpilog = 0 ;

            meP.pushSnipF( tinP , stBodyP ,

                T(
                
                    "<CENTER>\r\n"
                        "<TABLE style=\"\">\r\n"
                            "<TR>\r\n"
                                "<TD align=center valign=top style=\"\">"
                                    "<SPAN STYLE=\"\">"
                                        "<FORM METHOD=\"post\">"
                                            "<INPUT TYPE=\"submit\" NAME=\"")+tKeyNext+T("\" VALUE=\"")+tNextBackward+T("\">"
                                        "</FORM>"
                                    "</SPAN>"
                                "</TD>\r\n"
                                "<TD align=center valign=top style=\"\">"
                                    "<SPAN STYLE=\"color:" ifcCOLORhTMLwHAT_FOREaCCENTbROWN " ;\">"
                                        )+tRemaining+T(""
                                    "</SPAN>"
                                "</TD>\r\n"
                                "<TD align=center valign=top style=\"\">"
                                    "<SPAN STYLE=\"\">"
                                        "<FORM METHOD=\"post\">"
                                            "<INPUT ID=ilistForward TYPE=\"submit\" NAME=\"")+tKeyNext+T("\" VALUE=\"")+tNextForward+T("\">"
                                        "</FORM>"
                                    "</SPAN>"
                                "</TD>\r\n"
                            "</TR>\r\n"
                        "</TABLE>\r\n"
                        "<P>\r\n"
                        "<TABLE style=\"border-width: thick ; border-style: ridge ; border-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ;\">\r\n"
                            "<TR>\r\n"
                                "<TD align=center valign=middle style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTrED   " ; color:" ifcCOLORhTMLwHAT_FOREnOTEbRIGHT " ;\">\r\n"
                                    "<SPAN CLASS=\"spaMedium\">\r\n"
                                        )+T(ppostSlide[offs])+T(
                                    "</SPAN>\r\n"
                                "</TD>\r\n"
                            "</TR>\r\n"
                        "</TABLE>\r\n"
                        "<SCRIPT LANGUAGE=\"JavaScript\">\r\n"
                            "<!--\r\n"
                                "document.getElementById( \"ilistForward\" ).focus() ;\r\n"
                            "// -->\r\n"
                        "</SCRIPT>\r\n"
                    "</CENTER>\r\n"

                )

            ) ;
        }
    }

    if( bEpilog )
    {
        meP.pushSnipF( tinP , stBodyP ,

            (
                bThanksVisible
                    ?
                        T(
                            "<CENTER>\r\n"
                                "Please click \"ideas\" at top of page (or key Enter) now.\r\n"
                                "<SCRIPT LANGUAGE=\"JavaScript\">\r\n"
                                "<!--\r\n"
                                    "document.getElementById( \"idaIdeas\" ).focus() ;\r\n"
                                "// -->\r\n"
                                "</SCRIPT>\r\n"
                            "</CENTER>\r\n"
                            "<P>\r\n")+T(
                            postThanks)+T(""
                        )
                    :
                        T(
                            "<CENTER>\r\n"
                                "<FORM METHOD=\"post\">\r\n"
                                    "<INPUT ID=idtViewSlides TYPE=\"submit\" NAME=\"")+tKeyMode+T("\" VALUE=\"")+tModeSlides+T("\" ALT=\"Click to view this page as a slideshow.\">\r\n"
                                    "<SCRIPT LANGUAGE=\"JavaScript\">\r\n"
                                    "<!--\r\n"
                                        "document.getElementById( \"idtViewSlides\" ).focus() ;\r\n"
                                    "// -->\r\n"
                                    "</SCRIPT>\r\n"
                                "</FORM>\r\n"
                                "<P>\r\n"
                                "Please click \"")+tModeSlides+T("\" (or key Enter) now.\r\n"
                            "</CENTER>\r\n"
                            "<P>\r\n")+T(
                            "<SPAN STYLE=\"color:" ifcCOLORhTMLwHAT_BACKnORMAL "\"\r\n")+T(
                                postThanks)+T(
                            "</SPAN>\r\n"
                        )
            )

        ) ;

        if( !bThanksVisible )
        {
            meP.pushSnipF( tinP , stBodyP ,

                T(
                    
                "<P>\r\n"
                "<CENTER>\r\n"
                    "<TABLE>\r\n"
            
                )

            ) ;

            for( countT offs = 0 ; offs < cElt - 1 ; offs ++ )
            {
                meP.pushSnipF( tinP , stBodyP ,

                    T(
    
                            "<TR>\r\n"
                                "<TD align=center valign=middle style=\"background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL " ;\">\r\n"
                                    "<SPAN CLASS=\"spaXXSmall\">\r\n"
                                        )+T(ppostSlide[offs])+T(
                                    "</SPAN>\r\n"
                                "</TD>\r\n"
                            "</TR>\r\n"
            
                    )

                ) ;
            }

            meP.pushSnipF( tinP , stBodyP ,

                T(
                    
                    "</TABLE>\r\n"
            
                )

            ) ;
        }

        meP.pushSnipF( tinP , stBodyP ,

            T(
                
                "</CENTER>\r\n"
        
            )

        ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000098.slideshowtellinitcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000099.slideshowregretscbf BEGIN
#define DDNAME       "3func.33000099.slideshowregretscbf"
#define DDNUMB      (countT)0x33000099
#define IDFILE      (countT)0x978


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT slideShowRegretsCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    TN( tKeyMode , "mode" ) ;
    TN( tModeList   , "View List of All Slides" ) ;
    TN( tModeSlides , "View Slide Show" ) ;

    TN( tKeyNext , "next" ) ;
    TN( tNextForward  , ">" ) ;
    TN( tNextBackward , "<" ) ;

    ZE( strokeS* , zsttMode ) ;
    if( swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKeyMode ) )
    {
        psttLeverKVP = tKeyMode ;
        zsttMode = (strokeS*)(countT)swKVP ;
    }

    ZE( strokeS* , zsttNext ) ;
    if( swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKeyNext ) )
    {
        psttLeverKVP = tKeyNext ;
        zsttNext = (strokeS*)(countT)swKVP ;
    }

    static osTextT* postThanks =

        "<CENTER>\r\n"
        "<I>Thank you for listening to Sam and Joe.<I>\r\n"
        "</CENTER>\r\n"

    ;

    static osTextT* ppostSlide[] =
    {
            "Sam: \"How much do you pay for your <B>IdeaFarm</B> (tm) <B>Basic Privileges</B>?\""
        ,
            "Joe: \"About 10 dollars per day, and it's well worth it.\""
        ,
            "\"I am a carpenter.  The perfect market increases my income<BR>much more than the union did for my grandfather.<BR>I pay $10 per day for that.\""
        ,
            "\"The perfect market benefits me whenever I sell anything,<BR>not just when I sell my carpentry services.\""
        ,
            "\"I also win each time I buy something.<BR>The perfect market energizes all economic facets of my life!\""
        ,
            "\"I only have one regret, and it's that I didn't get my <B>Basic Privileges</B><BR>when I first heard about " postIFC ".\""
        ,
            "\"By the way, how much do you pay for your <B>Basic Privileges</B>?\""
        ,
            "Sam: \"I only pay one penny per day!\""
        ,
            "\"When " postIFC " was first being organized, I read the web site<BR>and knew right away that it was going to happen.\""
        ,
            "\"I am a professional investor, so I need to be able to see such things.\""
        ,
            "\"The organizer had a \"Price Doubling Guarantee\" that the price<BR>would double every 64 days 'or your money back'.\""
        ,
            "\"He said that he was \"willing to give up lots of future revenue<BR>in exchange for a tiny bit of revenue NOW\".\""
        ,
            "\"He obviously needed revenue right away, with his shabby truck<BR>covered with 'Come, Eat With Us!' signs.\""
        ,
            "\"I thought that his 'Price Doubling Guarantee' was a pretty clever<BR>solution to his apparent cash flow problem.\""
        ,
            "\"I liked the 'Don't Be Selfish' message on his signs, and<BR>the IdeaFarm " "(tm) City mission statement impressed me.\""
        ,
            "\"So I bought my <B>Basic Privileges</B> right away.<BR>I was one of the first.\""
        ,
            "\"Only a few people got in before the first price doubling.\""
        ,
            "\"It really wasn't that long ago;<BR>there have only been 10 doublings,<BR>and sure enough, he's kept to the schedule.\""
        ,
            "Joe: \"Yeah, I remember seeing his truck,<BR>but I didn't take him seriously because<BR>he obviously didn't have corporate funding.\""
        ,
            "\"I never saw " postIFC " advertised on tv,<BR>so I didn't think that it was real.\""
        ,
            "Sam: \"Well, you're selling your<BR>carpentry services on the perfect market now.<BR>Better late than never!\""
        ,
            "Joe: \"You only pay one penny per day?\""
        ,
            "Sam: \"Yeah, and I get to do that for the rest of my life.\""
        ,
            "!end"
    } ;
    const countT cElt = sizeof ppostSlide / sizeof ppostSlide[ 0 ] ;

    boolT bForward  = zsttNext && !etThread.strCompareF( tinP , zsttNext , tNextForward ) ;
    boolT bBackward = zsttNext && !etThread.strCompareF( tinP , zsttNext , tNextBackward ) ;
    boolT bSlideRequested = bForward || bBackward || ( zsttMode && !etThread.strCompareF( tinP , zsttMode , tModeSlides ) ) ;
    boolT bEpilog = 1 ;
    ZE( boolT , bThanksVisible ) ;
    if( bSlideRequested )
    {
        sessionC& session = sessionsP( tinP , nnPeerP ) ;
        countT idSlide = session.dispenseIdF( tinP , 3 , bBackward ) ;

        countT offs = ( idSlide - 1 ) % cElt ;

        TN( tRemaining , "" ) ;
        {
            TN( tDot  , "." ) ;
            TN( tUp   , "/" ) ;
            TN( tPeak , "|" ) ;
            TN( tDown , "\\" ) ;
            TN( tb    , " " ) ;
            measureT mAll      = ( cElt - 1 ) ;
            measureT mHalf     = mAll / 2.0 ;
            measureT mQuarter1 = mAll / 4.0 ;
            measureT mQuarter3 = mAll * 3.0 / 4.0 ;
            measureT mHere     = 1 + offs ;
            for( measureT mIds = mHere ; mIds <= mAll ; mIds ++ )
            {
                     if( mIds <  mQuarter1   ) tRemaining += tb+tDot  ;
                else if( mIds <  mHalf - 0.5 ) tRemaining += tb+tUp   ;
                else if( mIds <= mHalf + 0.5 ) tRemaining += tb+tPeak ;
                else if( mIds <= mQuarter3   ) tRemaining += tb+tDown ;
                else                           tRemaining += tb+tDot  ;
            }
            tRemaining += tb ;
        }

        if( offs == cElt - 1 ) bThanksVisible = bEpilog = 1 ;
        else
        {
            bEpilog = 0 ;

            meP.pushSnipF( tinP , stBodyP ,

                T(
                
                    "<CENTER>\r\n"
                        "<TABLE style=\"\">\r\n"
                            "<TR>\r\n"
                                "<TD align=center valign=top style=\"\">"
                                    "<SPAN STYLE=\"\">"
                                        "<FORM METHOD=\"post\">"
                                            "<INPUT TYPE=\"submit\" NAME=\"")+tKeyNext+T("\" VALUE=\"")+tNextBackward+T("\">"
                                        "</FORM>"
                                    "</SPAN>"
                                "</TD>\r\n"
                                "<TD align=center valign=top style=\"\">"
                                    "<SPAN STYLE=\"color:" ifcCOLORhTMLwHAT_FOREaCCENTbROWN " ;\">"
                                        )+tRemaining+T(""
                                    "</SPAN>"
                                "</TD>\r\n"
                                "<TD align=center valign=top style=\"\">"
                                    "<SPAN STYLE=\"\">"
                                        "<FORM METHOD=\"post\">"
                                            "<INPUT ID=ilistForward TYPE=\"submit\" NAME=\"")+tKeyNext+T("\" VALUE=\"")+tNextForward+T("\">"
                                        "</FORM>"
                                    "</SPAN>"
                                "</TD>\r\n"
                            "</TR>\r\n"
                        "</TABLE>\r\n"
                        "<P>\r\n"
                        "<TABLE style=\"border-width: thick ; border-style: ridge ; border-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ;\">\r\n"
                            "<TR>\r\n"
                                "<TD align=center valign=middle style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTrED   " ; color:" ifcCOLORhTMLwHAT_FOREnOTEbRIGHT " ;\">\r\n"
                                    "<SPAN CLASS=\"spaMedium\">\r\n"
                                        )+T(ppostSlide[offs])+T(
                                    "</SPAN>\r\n"
                                "</TD>\r\n"
                            "</TR>\r\n"
                        "</TABLE>\r\n"
                        "<SCRIPT LANGUAGE=\"JavaScript\">\r\n"
                            "<!--\r\n"
                                "document.getElementById( \"ilistForward\" ).focus() ;\r\n"
                            "// -->\r\n"
                        "</SCRIPT>\r\n"
                    "</CENTER>\r\n"

                )

            ) ;
        }
    }

    if( bEpilog )
    {
        meP.pushSnipF( tinP , stBodyP ,

            (
                bThanksVisible
                    ?
                        T(
                            "<CENTER>\r\n"
                                "Please purchase your <B>IdeaFarm</B> (tm) <B>Basic Privileges</B><BR>by clicking \"buy\" (or keying Enter) now.\r\n"
                                "<SCRIPT LANGUAGE=\"JavaScript\">\r\n"
                                "<!--\r\n"
                                    "document.getElementById( \"idaBuy\" ).focus() ;\r\n"
                                "// -->\r\n"
                                "</SCRIPT>\r\n"
                            "</CENTER>\r\n"
                            "<P>\r\n")+T(
                            postThanks)+T(""
                        )
                    :
                        T(
                            "<CENTER>\r\n"
                                "<FORM METHOD=\"post\">\r\n"
                                    "<INPUT ID=idtViewSlides TYPE=\"submit\" NAME=\"")+tKeyMode+T("\" VALUE=\"")+tModeSlides+T("\" ALT=\"Click to view this page as a slideshow.\">\r\n"
                                    "<SCRIPT LANGUAGE=\"JavaScript\">\r\n"
                                    "<!--\r\n"
                                        "document.getElementById( \"idtViewSlides\" ).focus() ;\r\n"
                                    "// -->\r\n"
                                    "</SCRIPT>\r\n"
                                "</FORM>\r\n"
                                "<P>\r\n"
                                "Please click \"")+tModeSlides+T("\" (or key Enter) now.\r\n"
                            "</CENTER>\r\n"
                            "<P>\r\n")+T(
                            "<SPAN STYLE=\"color:" ifcCOLORhTMLwHAT_BACKnORMAL "\"\r\n")+T(
                                postThanks)+T(
                            "</SPAN>\r\n"
                        )
            )

        ) ;

        if( !bThanksVisible )
        {
            meP.pushSnipF( tinP , stBodyP ,

                    T(
                    
                    "<P>\r\n"
                    "<CENTER>\r\n"
                        "<TABLE>\r\n"
            
                    )

            ) ;

            for( countT offs = 0 ; offs < cElt - 1 ; offs ++ )
            {
                meP.pushSnipF( tinP , stBodyP ,

                    T(
    
                            "<TR>\r\n"
                                "<TD align=center valign=middle style=\"background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL " ;\">\r\n"
                                    "<SPAN CLASS=\"spaXXSmall\">\r\n"
                                        )+T(ppostSlide[offs])+T(
                                    "</SPAN>\r\n"
                                "</TD>\r\n"
                            "</TR>\r\n"
            
                    )

                ) ;
            }

            meP.pushSnipF( tinP , stBodyP ,

                T(
                    
                    "</TABLE>\r\n"
            
                )

            ) ;
        }

        meP.pushSnipF( tinP , stBodyP ,

            T(
                
                "</CENTER>\r\n"
        
            )

        ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000099.slideshowregretscbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300009a.helpcbf BEGIN
#define DDNAME       "3func.3300009a.helpcbf"
#define DDNUMB      (countT)0x3300009a
#define IDFILE      (countT)0x979


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT helpCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    ZE( countT , idSnip ) ;
    {
        TN( tKeyQHelp , "qhelp" ) ;
        if( swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKeyQHelp ) )
        {
            psttLeverKVP = tKeyQHelp ;
            strokeS* zsttv = (strokeS*)(countT)swKVP ;
            if( zsttv ) idSnip = etThread.strDigitsToSCountF( tinP , zsttv ) ;
        }

    }

    if( idSnip ) { meP.pushSnipF( tinP , stBodyP , idSnip ) ; }
    else
    {
        ZE( httpReplyRefC* , pRefReply ) ;
        {
            TN( tKeyUrl , "url" ) ;
            if( swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKeyUrl ) )
            {
                psttLeverKVP = tKeyUrl ;
                strokeS* zsttw = (strokeS*)(countT)swKVP ;
                meP.getReplyF( tinP , pRefReply , zsttw ) ; ___( pRefReply ) ;
            }
        }
    
        TN( tHelp ,
    
            (
                pRefReply && REF( httpReplyS , *pRefReply ).prPostPageHelp && COSTS( *REF( httpReplyS , *pRefReply ).prPostPageHelp )
                    ? POSTS( *REF( httpReplyS , *pRefReply ).prPostPageHelp )
                    :

                        "No helpful information has been written for the page that you clicked.\r\n"
                        "  When helpful information is available for a page, \"HELP\" in the gray bar will appear in capital letters.\r\n"
                        "  Otherwise, \"help\" will appear in lower case letters.\r\n"
                        "<P>For general helpful information applicable to all pages, click \"aboutHelp\" at the top of THIS page or any helpful information page.\r\n"
            )
    
        ) ;
        DEL( pRefReply ) ;

        meP.pushSnipF( tinP , stBodyP , tHelp ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300009a.helpcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300009b.freebiescbf BEGIN
#define DDNAME       "3func.3300009b.freebiescbf"
#define DDNUMB      (countT)0x3300009b
#define IDFILE      (countT)0x97a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT freebiesCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    meP.pushSnipF( tinP , stBodyP ,

        T(
        
            "Coming soon!\r\n"
        
        )

    ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300009b.freebiescbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300009c.emailzipcbf BEGIN
#define DDNAME       "3func.3300009c.emailzipcbf"
#define DDNUMB      (countT)0x3300009c
#define IDFILE      (countT)0x97b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/


/*1*/voidT emailZipCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    count8S&      c8pP                                               =        *(count8S*)cArgP ;
    countT&       cLeverPasswordP                                    =       *(countT*)c8pP.c3 ;
    switchStackC& swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP = *(switchStackC*)c8pP.c4 ;

    //swKVP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    //countT cFlavors = swKVP.cFlavorsF( tinP ) ;
    //etThread.traceF(   tinP , TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" KV's received:") ) ;
    //for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    //{
    //    psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
    //    strokeS* psttv = (strokeS*)(countT)swKVP ;
    //
    //    etThread.traceF( tinP           , T("KV:  ")+T(psttLeverKVP)+T(":  \"")+T(psttv)+T("\"") ) ;
    //}
    //swKVP.ungrabF( tinP ) ;

    TN( tKeyDelete  , "delete" ) ;
    TN( tKeyScheme  , "scheme" ) ;
    TN( tKeyEmail   , "email"   ) ;
    TN( tKeyZip     , "zip" ) ;
    TN( tKeyCountry , "country" ) ;

    TN( tPeer    , "" ) ; tPeer = T(nnPeerP) ;
    TN( tDelete  , "" ) ;
    TN( tScheme  , "" ) ;
    TN( tEmail   , "" ) ;
    TN( tZip     , "" ) ;
    TN( tCountry , "" ) ;
    swKVP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    psttLeverKVP = tKeyDelete  ; tDelete  = T((strokeS*)(countT)swKVP) ;
    psttLeverKVP = tKeyScheme  ; tScheme  = T((strokeS*)(countT)swKVP) ;
    psttLeverKVP = tKeyEmail   ; tEmail   = T((strokeS*)(countT)swKVP) ;
    psttLeverKVP = tKeyZip     ; tZip     = T((strokeS*)(countT)swKVP) ;
    psttLeverKVP = tKeyCountry ; tCountry = T((strokeS*)(countT)swKVP) ;
    swKVP.ungrabF( tinP ) ;

    TN( tIpFile , (strokeS*)( T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/unconfirmed.email/ip.") + T(nnPeerP) ) ) ;
    TN( tSchemeCorrect , "1" ) ;
    TN( tUrlCorrect    , "/header/action/emailzip.captcha.4.html" ) ; //U:: REMOVE "header"
    boolT bWriteIpFile = 1 ;
    ZE( countT , idRequestStatus )
    //if( etThread.strCompareF( tinP , tScheme , tSchemeCorrect ) )
    {
        idRequestStatus = ifcIDeMAILrEGISTRATIONrEQUESTsTATUS_BOTwRONGsCHEME ;
        meP.pushSnipF(   tinP , stBodyP , T("I think that you are a bot, not a human.\r\nTo request assistance, email support@ideafarm.com.") ) ;
    }

//THIS ENTIRE FUNCTION IS OBSOLETED BY THE USE OF PAYPAL
//BAD ACTORS WILL CONTINUE TO EXERCISE ME
#if defined( NEVERdEFINED )

    else if( etThread.strCompareF( tinP , psttUrlP , tUrlCorrect ) )
    {
        idRequestStatus = ifcIDeMAILrEGISTRATIONrEQUESTsTATUS_BOTwRONGiMAGE ;
        meP.pushSnipF(   tinP , stBodyP , T("I think that you are a bot, not a human, because you clicked the wrong image.\r\nTo request assistance, email support@ideafarm.com.\r\n") ) ;
    }
    else
    {
        ranUniC ru( tinP , MAXcOUNTT ) ;
        countT password = ru ;

        ZE( boolT , bAllow ) ;
        IFsCRATCH
        {
            SCOOPS

            etherC& etScratch = *tinP.pEtScratch ;

            bWriteIpFile = 0 ;
            fileC fo( tinP , (strokeS*)tIpFile , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeF , flFILEaTTR_null , flFILEc_null , 1 ) ;

            if( POOP ) { POOPR ; } // EACH PEER IS ONLY ALLOWED WO PENDING REGISTRATION.  AS OF THIS WRITING, EACH FILE REMAINS UNTIL THE REGISTRATION SUCCEEDS OR UNTIL THE FILE IS MANUALLY DELETED
            else
            {
                bAllow = 1 ;
                idRequestStatus = ifcIDeMAILrEGISTRATIONrEQUESTsTATUS_HUMANnOpRIORpENDING ;

                ZE( countT , finger ) ;
                putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEuNCONFIRMEDeMAIL ) ;

                soulC rec( tinP , TAG( TAGiDnULL ) ) ;
                rec << finger ;
                rec << (countT)1 ;          // IDfORMAT
                rec << (strokeS*)tPeer ;
                rec << idRequestStatus ;
                rec << (strokeS*)tScheme ;
                rec << (strokeS*)tDelete ;
                rec << (strokeS*)tEmail ;
                rec << (strokeS*)tZip ;
                rec << (strokeS*)tCountry ;

                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                etScratch.fileWriteF( tinP , fo , WS( rec ) ) ;
                THREADmODE1rESTORE
            }
        }

        if( !bAllow ) meP.pushSnipF( tinP , stBodyP , T("I think that you are a bot, not a human, because there is already one pending (not yet confirmed) registration request made from your IP address.\r\nIf you are a human, try using a different computer or a different Wifi hotspot.\r\nOr, to request assistance, email support@ideafarm.com.") ) ;
        else
        {
            meP.pushSnipF(   tinP , stBodyP , T("I will email a confirmation link to ")+tEmail+T(", which you must click within 10 minutes.\r\n") ) ;

            ZE( strokeS* , psttPeer    ) ; etThread.strMakeF( tinP , LF , psttPeer    , tPeer    ) ; ___( psttPeer    ) ;
            ZE( strokeS* , psttDelete  ) ; etThread.strMakeF( tinP , LF , psttDelete  , tDelete  ) ; ___( psttDelete  ) ;
            ZE( strokeS* , psttEmail   ) ; etThread.strMakeF( tinP , LF , psttEmail   , tEmail   ) ; ___( psttEmail   ) ;
            ZE( strokeS* , psttZip     ) ; etThread.strMakeF( tinP , LF , psttZip     , tZip     ) ; ___( psttZip     ) ;
            ZE( strokeS* , psttCountry ) ; etThread.strMakeF( tinP , LF , psttCountry , tCountry ) ; ___( psttCountry ) ;

            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP.grabF( tinP , TAG( TAGiDnULL ) ) ;

            cLeverPasswordP = password ;

            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP.purgeF( tinP ) ;

            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP << psttPeer    ;
            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP << psttDelete  ;
            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP << psttEmail   ;
            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP << psttZip     ;
            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP << psttCountry ;

            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP.ungrabF( tinP ) ;

            TN( tPass , "" ) ; tPass = TF2(password,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;

            TN( tMyNetBiosHostName , "" ) ;
            {
                ZE( strokeS* , psttMyNetBiosHostName ) ;
                etThread.sockPsttHostF( tinP , psttMyNetBiosHostName , nicNameC() ) ; ___( psttMyNetBiosHostName ) ;
                if( !psttMyNetBiosHostName ) etThread.traceF( tinP , T("error: reverse DNS lookup on myself failed") ) ;
                else                         tMyNetBiosHostName = T(psttMyNetBiosHostName) ;
                etThread.delF( tinP , psttMyNetBiosHostName ) ;
            }

            boolT bDelete = psttDelete && !etThread.strCompareF( tinP , psttDelete , T("yes") ) ;

            TN( tBody ,

                bDelete
                ?

                    "Subject: Wo'O's Table (TIME SENSITIVE)\r\n"
                    "\r\n"
                    "If you did NOT just enter your email address at IDEAFARM.COM, then take no action.\r\n"
                    "Otherwise, click the link below immediately to confirm that you are unregistering.\r\n"
                    "\r\n"
                    "    http://"

                :

                    "Subject: Wo'O's Table (TIME SENSITIVE)\r\n"
                    "\r\n"
                    "If you did NOT just enter your email address at IDEAFARM.COM, then take no action.\r\n"
                    "Otherwise, click the link below immediately to confirm.\r\n"
                    "\r\n"
                    "By clicking the link, you agree to the following terms and conditions:\r\n"
                    "\r\n"
                    "(1) You are registering your email with Wo'O Ideafarm, an agent of\r\n"
                    "IdeaFarm Operations, a California nonprofit public benefit corporation.\r\n"
                    "\r\n"
                    "(3) Registration is free and creates no contractual liability.\r\n"
                    "\r\n"
                    "(4) Privacy policy:  Your information will be used to administer\r\n"
                    "your participation in Wo'O's Table.  It will be used for no\r\n"
                    "other purpose without your prior consent.  This administrative use \r\n"
                    "includes disclosure to other persons who have registered in the same\r\n"
                    "or nearby postal codes so that you all can arrange to eat together.\r\n"
                    "\r\n"
                    "Key benefit:  Wo'O's Table attracts and excites people who are\r\n"
                    "exceptionally friendly, tolerant, and intelligent.  The IDEAFARM.COM\r\n"
                    "servers and web site use registrations to put people into email contact,\r\n"
                    "postal code by postal code, worldwide, and to make it easy for registrants\r\n"
                    "to eat together weekly to find new friends and empower one another.\r\n"
                    "\r\n"
                    "How it works:  When two or more emails are registered for a postal code,\r\n"
                    "an email will be sent to invite those people to decide which among them\r\n"
                    "will \"moderate\" an \"eat together\" group.  Initially, moderation is\r\n"
                    "done informally; the moderator simply picks a fast food restaurant or\r\n"
                    "other venue, and the group begins to meet weekly for a meal.\r\n"
                    "\r\n"
                    "Moderation can continue informally, or the relationship between the\r\n"
                    "moderator and IDEAFARM.COM can be formalized to obtain additional\r\n"
                    "resources and assistance.\r\n"
                    "\r\n"
                    "No purchase is required to ether participate or to moderate.\r\n"
                    "\r\n"
                    "If you agree, click to confirm:\r\n"
                    "\r\n"
                    "    http://"

            ) ;

            tBody += tMyNetBiosHostName+T(".ideafarm.com/emailzip.confirm.html?pass=")+tPass+T("\r\n") ;

            etThread.boxPutF( tinP , T("smtp.mailgun.org[unconfirmed]/b42/smtp/factories@ideafarm.com/")+tEmail+T("//wo@ideafarm.com") , tBody ) ;
        }
    }

    if( bWriteIpFile )
    {
        IFsCRATCH
        {
            SCOOPS

            etherC& etScratch = *tinP.pEtScratch ;

            fileC fo( tinP , (strokeS*)tIpFile , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeF , flFILEaTTR_null , flFILEc_null , 1 ) ;

            if( POOP ) { POOPR ; } // EACH PEER IS ONLY ALLOWED WO PENDING REGISTRATION.  AS OF THIS WRITING, EACH FILE REMAINS UNTIL THE REGISTRATION SUCCEEDS OR UNTIL THE FILE IS MANUALLY DELETED
            else
            {
                ZE( countT , finger ) ;
                putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEuNCONFIRMEDeMAIL ) ;

                soulC rec( tinP , TAG( TAGiDnULL ) ) ;
                rec << finger ;
                rec << (countT)1 ;          // IDfORMAT
                rec << (strokeS*)tPeer ;
                rec << idRequestStatus ;
                rec << (strokeS*)tScheme ;
                rec << (strokeS*)tDelete ;
                rec << (strokeS*)tEmail ;
                rec << (strokeS*)tZip ;
                rec << (strokeS*)tCountry ;

                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                etScratch.fileWriteF( tinP , fo , WS( rec ) ) ;
                THREADmODE1rESTORE
            }
        }
    }

#endif

    etThread.traceF( tinP , T("nnPeerP: ")+T(nnPeerP) ) ;
    //etThread.traceF( tinP , T("psttUrlP:  ")+T(psttUrlP) ) ;
    //etThread.traceF( tinP , T("psttPeerAgentP:  ")+T(psttPeerAgentP) ) ;
    //etThread.traceF( tinP , T("postBodyP:  ")+T(postBodyP) ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300009c.emailzipcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300009d.menuofreportscbf BEGIN
#define DDNAME       "3func.3300009d.menuofreportscbf"
#define DDNUMB      (countT)0x3300009d
#define IDFILE      (countT)0x97c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT menuOfReportsCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    TN( tContent , "" ) ;
    sessionC& session = sessionsP( tinP , nnPeerP ) ;
    if( !( F(session.privilegesF(tinP)) & flSESSIONpRIVILEGE_VIEWsERVERrEPORTS ) )
    {
        tContent =
    
            T(
                "Your session does not currently have the needed privilege.\r\n"
                "  To set privileges for your session, click \"privileges\" in the upper left corner of this page.\r\n"
            )
        ;
    }
    else
    {
        tContent =

            T(
                "The following reports are available.\r\n"
                "  Each report is compiled in real time, so please be patient while waiting for your selection.\r\n"
                "<P>\r\n"
                "<OL>\r\n"
                "</OL>\r\n"
            )
        ;
    }

    meP.pushSnipF( tinP , stBodyP , tContent ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300009d.menuofreportscbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300009e.docbf BEGIN
#define DDNAME       "3func.3300009e.docbf"
#define DDNUMB      (countT)0x3300009e
#define IDFILE      (countT)0x97d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT doCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    sessionC&       session         = sessionsP( tinP , nnPeerP ) ;
    flagsT          flagsPrivilege  = session.privilegesF( tinP ) ;
    countT          idAcc           = session.getIdAccountF( tinP ) ;
    countT          idAccCommission = session.getIdAccountCommissionF( tinP ) ;
    ZE( pbRefC* , prPostsEmail ) ;
    if( idAcc )
    {
        ZE( strokeS* , psttEmail ) ;
        session.getEmailF( tinP , psttEmail ) ; ___( psttEmail ) ;
        if( psttEmail ) { etThread.strMakeF( tinP , LF , prPostsEmail , psttEmail , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsEmail ) ; }
        etThread.delF( tinP , psttEmail ) ;
    }

    if( prPostsEmail )
    {
        //PAYPAL LINK (FOR BECOMING AN ASSOCIATE?)
        //meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_DO1 ) ;
        //meP.pushSnipF( tinP , stBodyP , TF4(idAcc,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36) ) ;
        //meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_DO2 ) ;
        //meP.pushSnipF( tinP , stBodyP , TF4(idAccCommission , flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36) ) ;
        //meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_DO3 ) ;

        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_DO4 ) ;
        meP.pushSnipF( tinP , stBodyP , *prPostsEmail ) ;
        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_DO5 ) ;

        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_DO8 ) ;

        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_DO9 ) ;

        if( F(flagsPrivilege) & flSESSIONpRIVILEGE_FULLhEADER ) //A:ASSUME: WILL HAVE THIS PRIVILEGE IFF HAVE MADE A DEPOSIT
        {
            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_DOa ) ;
            meP.pushSnipF( tinP , stBodyP , *prPostsEmail ) ;
            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_DOb ) ;
            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_DOc ) ;
        }
    }
    DEL( prPostsEmail ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300009e.docbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300009f.calendarcbf BEGIN
#define DDNAME       "3func.3300009f.calendarcbf"
#define DDNUMB      (countT)0x3300009f
#define IDFILE      (countT)0x97e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT calendarCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    ZE( strokeS* , psttCalBody ) ;
    {
        ZE( sCountT , time2 ) ;
        etThread.osTimeNowF( tinP , countTC() , time2 ) ;
        ZE( sCountT , scDaysOff ) ; //FUTURE ENHANCEMENT: LET USER SPECIFY A DAY OTHER THAN TODAY
    
        etThread.strCalendarF( tinP , psttCalBody , time2 + scDaysOff ) ; ___( psttCalBody ) ;
    }

    meP.pushSnipF( tinP , stBodyP ,

        T(

            "<CENTER>\r\n"
                "<TABLE style=\"border-width: thick ; border-style: ridge ; border-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; width: 80% ;\">\r\n" \
                    "<TR>\r\n"
                        "<TD style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTdARKgRAY " ; color:" ifcCOLORhTMLwHAT_FOREnOTEbRIGHT " ;\">"
                            "<PRE>")+T(psttCalBody)+T("</PRE>"
                        "</TD>\r\n"
                    "</TR>\r\n"
                "</TABLE>\r\n"
            "</CENTER>\r\n"

        )

    ) ;
    etThread.delF( tinP , psttCalBody ) ;

    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_CALENDAR1 ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.3300009f.calendarcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a0.obeydirectoryclickcbf BEGIN
#define DDNAME       "3func.330000a0.obeydirectoryclickcbf"
#define DDNUMB      (countT)0x330000a0
#define IDFILE      (countT)0x97f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT obeyDirectoryClickCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    ZE( countT , idAccClicker ) ;
    ZE( countT , idAccClickee ) ;
    ZE( strokeS* , psttEmailClicker ) ;
    {
        TN( tKeyIdAccClickee , "idaccclickee" ) ;
        countT cFlavors = swKVP.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
            if( !etThread.strCompareF( tinP , psttLeverKVP , tKeyIdAccClickee ) )
            {
                idAccClickee = etThread.strDigitsToSCountF( tinP , *(strokeS**)&(countT&)swKVP ) ;
                break ;
            }
        }

        sessionC& session = sessionsP( tinP , nnPeerP ) ;
        idAccClicker = session.getIdAccountF( tinP ) ;
        session.getEmailF( tinP , psttEmailClicker ) ; ___( psttEmailClicker ) ;
    }

    if( idAccClickee && idAccClicker && psttEmailClicker )
    {
        //POPUP( TF2(idAccClicker,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" clicked ")+TF2(idAccClickee,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

        //CS:CODEsYNC: b750104 1d20005
        if( idAccClickee == idAccClicker ) meP.pushSnipF( tinP , stBodyP , T("Clicks on your own entry are ignored.  Nothing has been done.") ) ;
        else
        {
            TN( tSay , "idSub list: [" ) ;
            TN( tb , " " ) ;
    
            ZE( countT , idSubOfClickee ) ;
            {
                stkIdSubC stkIdSub( tinP , idAccClickee ) ;
                while( stkIdSub )
                {
                    ZE( countT , idSub ) ;
                    stkIdSub >> idSub ;
                    tSay += tb+TF2(idSub,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
        
                    subaccountS sub( tinP , etThread , idAccClickee , idSub , flSUBACCOUNT_QUERYfLAGSmODE | flSUBACCOUNT_QUERYeMAILpENPALeXACToR ) ;
                    tSay += T("{")+TF2(sub.flagsMode,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("}") ;
        
                    if( F(sub.flagsMode) & fliSUBACCOUNTmODE_OWNEDbYdIRECTORYoRhELLO && !( F(sub.flagsMode) & fliSUBACCOUNTmODE_DELETED ) && sub.pStkEmailPenpalExactOr )
                    {
                        while( *sub.pStkEmailPenpalExactOr )
                        {
                            ZE( strokeS* , psttw ) ;
                            *sub.pStkEmailPenpalExactOr >> psttw ;
                            etThread.strConvertToLowerCaseF( tinP , psttw ) ;
                            if( !etThread.strCompareF( tinP , psttw , psttEmailClicker ) )
                            {
                                idSubOfClickee = idSub ;
                                tSay += T(" FOUND") ;
                                break ;
                            }
                        }
        
                        if( idSubOfClickee ) break ;
                    }
                }
                tSay += T(" ]") ;
            }
    
            if( !idSubOfClickee )
            {
                // fliSUBACCOUNTmODE_RELAYrEPLYeNDScONVERSATION MAKES THE CONVERSATION CLEANER SINCE ALL ITEMS REFER TO THE SAME EMAIL ADDRESS; THE PREFIX TO IDENTIFY THE RESPONDING RELAY IS NOT NEEDED BECAUSE THERE IS ALWAYS EXACTLY ONE RELAY
                subaccountS newSub( tinP , etThread , idAccClickee , idSubOfClickee , TF2(idAccClicker,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , T("IdeaFarm " "(tm) Directory Clicker") , T("IdeaFarm " "(tm) Directory Clickee") , fliSUBACCOUNTmODE_OWNERcONFIRMED | fliSUBACCOUNTmODE_OWNEDbYdIRECTORYoRhELLO | fliSUBACCOUNTmODE_RELAYrEPLYeNDScONVERSATION ) ;

                ZE( strokeS* , psttw ) ;
                etThread.strMakeF( tinP , LF , psttw , psttEmailClicker ) ; ___( psttw ) ;
                *newSub.pStkEmailPenpalExactOr << psttw ; psttw = 0 ;

                ZE( strokeS* , psttEmailClickee ) ;
                {
                    socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                    sock.connectF( tinP , homeS::homeIF().idPortListServerEmailIdAccount ) ;
                
                    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
                    sOut << (countT)FINGERnEG_LISTsERVERcMD ;
                    sOut << (countT)1 ;
                    sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKeMAILfROMiDaCCOUNT ;
                    sOut << idAccClickee ;
                    sock.writeF( tinP , sOut ) ;
                
                    soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                    sock.readF( tinP , sIn ) ;
                
                    ZE( countT , finger ) ;
                    sIn >> finger ;
                    __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
                
                    ZE( countT , idFormat ) ;
                    sIn >> idFormat ;
                    __( idFormat - 1 ) ;
                
                    sIn >> psttEmailClickee ; ___( psttEmailClickee ) ;
                }

                *newSub.pStkEmailRelay << psttEmailClickee ;
            }

            if( !idSubOfClickee ) tSay += T(" The server unexpectedly was not able to create a subaccount for you.") ;
            else
            {
                accountS info( tinP , etThread , idAccClickee , flACCOUNT1_null , flACCOUNT2_QUERYfLAGSmODE | flACCOUNT2_QUERYaDDRESScOUNTRYcODE | flACCOUNT2_QUERYaDDRESSzIP | flACCOUNT2_QUERYaDDRESScITY | flACCOUNT2_QUERYaDDRESSnAME | flACCOUNT2_QUERYrESIDENCEcOUNTRY | flACCOUNT2_QUERYzIPaT | flACCOUNT2_QUERYdIRECTORYgREETING ) ;
                ZE( strokeS* , psttListEntry ) ;
                {

                    etThread.strMakeF( tinP , LF , psttListEntry , 0 , TOCK ) ; ___( psttListEntry ) ;
    
                    TN( tSep , " <> " ) ;
                    strokeS* psttSep = tSep ;
                    STRfUSEsAFE( psttListEntry , info.psttAddressCountryCode )
                    STRfUSEsAFE( psttListEntry , psttSep )
                    STRfUSEsAFE( psttListEntry , info.psttAddressZip )
                    STRfUSEsAFE( psttListEntry , psttSep )
                    STRfUSEsAFE( psttListEntry , info.psttAddressCity )
                    STRfUSEsAFE( psttListEntry , psttSep )
                    STRfUSEsAFE( psttListEntry , info.psttAddressName )
                    STRfUSEsAFE( psttListEntry , psttSep )
                    STRfUSEsAFE( psttListEntry , info.psttResidenceCountry )
                    STRfUSEsAFE( psttListEntry , psttSep )
                    STRfUSEsAFE( psttListEntry , info.psttZipAt  )
                }

                ZE( strokeS* , psttSubEmail ) ;

                TN( tDot , "." ) ;
                etThread.strMakeF( tinP , LF , psttSubEmail , TF4(idSubOfClickee,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+tDot+TF4(idAccClickee,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(".doubleblind.1@ideafarm.com") ) ; ___( psttSubEmail ) ;

                {
                    TN( tOpener , "" ) ; tOpener = T(

                        "Subject: IdeaFarm " "(tm) Directory <> The new conversation that you requested.\r\n"
                        "\r\n"
                        "This was sent to you because you, or someone impersonating you, clicked the following IdeaFarm " "(tm) Directory entry while logged in at IDEAFARM.COM using your email address:\r\n"
                        "\r\n"
                        "    ")+T(psttListEntry)+T("\r\n"
                        "\r\n"
                        "If this was done without your knowledge, you do not need to do anything."
                        "  You may report this possible security compromise of your email or of your account by logging in to IDEAFARM.COM.\r\n"
                        "\r\n"
                        "Begin your conversation by replying to this note."
                        "  Your reply will be relayed to the IdeaFarm " "(tm) Directory entry that you clicked."

                    ) ;

                    if( info.psttDirectoryGreeting && info.psttDirectoryGreeting->idAdam ) tOpener += T(

                        "\r\n"
                        "\r\n"
                        "-------------------------\r\n"
                        "Autoresponse from clickee:\r\n"
                        "-------------------------\r\n"
                        "\r\n")+T(info.psttDirectoryGreeting)

                    ;

                    etThread.boxPutF( tinP , T("//smtp/")+T(psttSubEmail)+T("/")+T(psttEmailClicker) , tOpener , tOpener.csF( tinP ) ) ;
                }

                tSay = T(

                    "An email from an " postIFPE " address will be sent to you as soon as possible.\r\n"
                    "  That address is for your exclusive use in contacting the entry in IdeaFarm " "(tm) Directory that you clicked.\r\n"
                    "  That email address will only accept incoming email from the email address that you used to log in.\r\n"

                ) ;

                etThread.delF( tinP , psttSubEmail ) ;
                etThread.delF( tinP , psttListEntry ) ;
            }

            meP.pushSnipF( tinP , stBodyP , tSay ) ;
        }
    }
    etThread.delF( tinP , psttEmailClicker ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a0.obeydirectoryclickcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a1.secretlogincbf BEGIN
#define DDNAME       "3func.330000a1.secretlogincbf"
#define DDNUMB      (countT)0x330000a1
#define IDFILE      (countT)0x980


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT secretLoginCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    sessionC& session = sessionsP( tinP , nnPeerP ) ;
    session.setEmailF( tinP , T("9bn.3vho@gmail.com") ) ;
    session.setIdAccountF( tinP , etThread.strDigitsToSCountF( tinP , T("wqc46l") , 36 ) ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a1.secretlogincbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a2.notefrompaypalcbf BEGIN
#define DDNAME       "3func.330000a2.notefrompaypalcbf"
#define DDNUMB      (countT)0x330000a2
#define IDFILE      (countT)0x981


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT noteFromPaypalCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    ZE( boolT , bValid ) ;
    ZE( boolT , bGot ) ;
    TN( tValidationRequest , "" ) ;
    TN( tValidationReply   , "" ) ;
    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;
    {
        //20200731@1556: CHANGED FROM HTTP/1.0 TO HTTP/1.1 WITHOUT ANALYSIS
        //OLD FORMAT: GET /cgi-bin/webscr?cmd=_notify-validate&mc_gross=1.00&protection_eligibility=Eligible&address_status=confirmed&payer_id=4QLHUR4EYW37J&address_street=1+Main+St&payment_date=17%3A04%3A06+Jun+04%2C+2020+PDT&payment_status=Completed&charset=windows-1252&address_zip=95131&first_name=John&mc_fee=0.33&address_country_code=US&address_name=John+Doe&notify_version=3.9&subscr_id=I-1CXF383WH8P0&payer_status=verified&business=sb-znjve1276155%40business.example.com&address_country=United+States&address_city=San+Jose&verify_sign=AEHpL6M1JS9Z4r02TsvVIey5ocFqAgLcANkEe9kVFcJG4kqTWCtTJprq&payer_email=sb-prtxq883780%40personal.example.com&txn_id=1XX85736SF014420R&payment_type=instant&btn_id=4125335&last_name=Doe&address_state=CA&receiver_email=sb-znjve1276155%40business.example.com&payment_fee=0.33&receiver_id=755UKLGFJ8XU2&txn_type=subscr_payment&item_name=Wo%27O%27s+Table+Registration+and+Subscription&mc_currency=USD&item_number=20200604&residence_country=US&test_ipn=1&transaction_subject=Wo%27O%27s+Table+Registration+and+Subscription&payment_gross=1.00&ipn_track_id=92fb2ec1f693b HTTP/1.1
        //THIS WORKS IN FIREFOX BROWSER: https://www.sandbox.paypal.com:443/cgi-bin/webscr?cmd=_notify-validate&mc_gross=1.00&protection_eligibility=Eligible&address_status=confirmed&payer_id=4QLHUR4EYW37J&address_street=1+Main+St&payment_date=15%3A55%3A04+Jun+04%2C+2020+PDT&payment_status=Completed&charset=windows-1252&address_zip=95131&first_name=John&mc_fee=0.33&address_country_code=US&address_name=John+Doe&notify_version=3.9&subscr_id=I-DEKU4NNTHS0H&payer_status=verified&business=sb-znjve1276155%40business.example.com&address_country=United+States&address_city=San+Jose&verify_sign=AS.sXmO3SZlbZsuBgmx57wrfjxyDAk855hu6vdRmhFRd0mqr2l3hMU7l&payer_email=sb-prtxq883780%40personal.example.com&txn_id=5W609239EF681420H&payment_type=instant&btn_id=4125335&last_name=Doe&address_state=CA&receiver_email=sb-znjve1276155%40business.example.com&payment_fee=0.33&receiver_id=755UKLGFJ8XU2&txn_type=subscr_payment&item_name=Wo'O's+Table+Registration+and+Subscription&mc_currency=USD&item_number=20200604&residence_country=US&test_ipn=1&transaction_subject=Wo'O's+Table+Registration+and+Subscription&payment_gross=1.00&ipn_track_id=5075e5b427054 HTTP/1.1

        //LOGrAW( "\r\n---- postBodyP (BEGIN) -----------------------------------------------------------------\r\n" ) ;
        //LOGrAW( postBodyP ) ;
        //LOGrAW( "\r\n---- postBodyP (END) -----------------------------------------------------------------\r\n" ) ;

        {
            TN( tSay1 ,

                "POST /cgi-bin/webscr HTTP/1.1\r\n"
                "Content-Type: application/x-www-form-urlencoded\r\n"
                "Host: www"

            ) ;

            if( bSandbox ) tSay1 += T(".sandbox") ;

            tSay1 += T(

                ".paypal.com\r\n"
                "Content-Length: "

            ) ;

            TN( tSay2 , "\r\nConnection: close\r\n\r\n" ) ;
            TN( tSayCmd , "cmd=_notify-validate&" ) ;
            TN( tSayBody , postBodyP ) ;

            countT costBodyAll = tSayCmd.csF( tinP ) + tSayBody.csF( tinP ) ;

            tValidationRequest = tSay1+TF4(costBodyAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+tSay2+tSayCmd+tSayBody ;
        }

        IFsCRATCH
        {
            SCOOPS
        
            nicNameC nnPayPal = socketC::nicNameIF( tinP , *tinP.pEtScratch , T(bSandbox?"www.sandbox.paypal.com":"www.paypal.com") ) ;

            countT cTries = TUCK >> 4 ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            if( nnPayPal ) while( !bGot && cTries -- )
            {
                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL ) ;
                sock.connectF( tinP , 443 , nnPayPal ) ;
                sock.writeF( tinP , (osTextT*)tValidationRequest , tValidationRequest.csF( tinP ) ) ;

                tValidationReply = T("") ;
                ZE( strokeS* , psttBuffer ) ;
                ZE( osTextT , ostVerdict ) ;
                {
                    LOGrAW( "\r\n---- validation response debug (BEGIN) -----------------------------------------------------------------\r\n" ) ;
                    ZE( boolT , bArmed ) ;
                    osTextT post5[ 5 ] = { 0 , 0 , 0 , 0 , 0 } ;
                    ZE( countT , cIn ) ;
                    while( !POOP )
                    {
                        sock.readF( tinP , post5 + ( cIn ++ ) % sizeof post5 , 1 ) ;

                        osTextT ostNow = post5[ ( cIn - 1 ) % sizeof post5 ] ;

                        if( psttBuffer && !psttBuffer[ 2 ].idAdam )
                        {
                            tValidationReply += T(psttBuffer) ;
                            etThread.delF( tinP , psttBuffer ) ;
                        }

                        if( !psttBuffer ) { etThread.strMakeF( tinP , LF , psttBuffer , 0 , TUCK << 2 ) ; ___( psttBuffer ) ; }

                        {
                            osTextT post2[] = { ostNow , 0 } ;
                            LOGrAW( post2 ) ;                                       //U:: THIS IS REDUNDANT AND SHOULD BE REMOVED
                            etThread.strFuseF( tinP , psttBuffer , T(post2) ) ;
                        }

                        if( bArmed )
                        {
                            ostVerdict = ostNow == 'V'
                                ? 'V'
                                : 'I'
                            ;
                            break ;
                        }
                        else if
                        (
                            cIn >= 4
                            && post5[ ( cIn - 1 ) % sizeof post5 ] == '\n'
                            && post5[ ( cIn - 2 ) % sizeof post5 ] == '\r'
                            && post5[ ( cIn - 3 ) % sizeof post5 ] == '\n'
                            && post5[ ( cIn - 4 ) % sizeof post5 ] == '\r'
                        )
                        {
                            bArmed = 1 ;
                        }
                    }
                    LOGrAW( "\r\n---- validation response debug (END) -----------------------------------------------------------------\r\n" ) ;
                }

                osTextT postVerdict[ 2 ] = { ostVerdict , 0 } ;
                etThread.traceF( tinP , T("verdict:    ")+T(postVerdict) ) ;
                bValid = ostVerdict == 'V' ;
                bGot = 1 ;

                if( POOP ) POOPR

                if( !bGot && cTries )
                {
                    etThread.traceF( tinP , TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": napping because did not receive a valid reply from www.paypal.com to confirm that the ipn is valid") ) ;
                    ++ s ; etThread.osSleepF( tinP , TOCK ) ;
                }

                if( psttBuffer && psttBuffer->idAdam ) tValidationReply += T(psttBuffer) ;
                etThread.delF( tinP , psttBuffer ) ;
            }
        }
    }

    //ifcIDtESTpASSCODE IS USED BY THE TOOL THAT ALLOWS ME TO MANUALLY SIMULATE PAYMENTS  //ARBITRARY SECRET PASSWORD; DISABLE THE TEST ACCEPTANCE EXCEPT WHEN TESTING
    if( !( bValid /*|| idTest == ifcIDtESTpASSCODE*/ ) )
    {
        LOGrAW( "\r\n---- tValidationRequest BAD (BEGIN) -----------------------------------------------------------------\r\n" ) ;
        LOGrAW( tValidationRequest ) ;
        LOGrAW( "\r\n---- tValidationRequest BAD (END) -----------------------------------------------------------------\r\n" ) ;
        LOGrAW( "\r\n---- tValidationReply BAD (BEGIN) -----------------------------------------------------------------\r\n" ) ;
        LOGrAW( tValidationReply ) ;
        LOGrAW( "\r\n---- tValidationReply BAD (END) -----------------------------------------------------------------\r\n" ) ;
    }
    else
    {
        //U::COMMENT THIS OUT IN PRODUCTION AFTER CONFIDENT IN PROD FUNCTION
        LOGrAW( "\r\n---- tValidationRequest GOOD (BEGIN) -----------------------------------------------------------------\r\n" ) ;
        LOGrAW( tValidationRequest ) ;
        LOGrAW( "\r\n---- tValidationRequest GOOD (END) -----------------------------------------------------------------\r\n" ) ;
        LOGrAW( "\r\n---- tValidationReply GOOD (BEGIN) -----------------------------------------------------------------\r\n" ) ;
        LOGrAW( tValidationReply ) ;
        LOGrAW( "\r\n---- tValidationReply GOOD (END) -----------------------------------------------------------------\r\n" ) ;

        TN( tKeyAddressCity                     , "address_city"           ) ;
        TN( tKeyAddressCountry                  , "address_country"        ) ;
        TN( tKeyAddressCountryCode              , "address_country_code"   ) ;
        TN( tKeyAddressName                     , "address_name"           ) ;
        TN( tKeyAddressState                    , "address_state"          ) ;
        TN( tKeyAddressStatus                   , "address_status"         ) ;
        TN( tKeyAddressStreet                   , "address_street"         ) ;
        TN( tKeyAddressZip                      , "address_zip"            ) ;
        TN( tKeyCharset                         , "charset"                ) ;
        TN( tKeyFirstName                       , "first_name"             ) ;
        TN( tKeyLastName                        , "last_name"              ) ;
        TN( tKeyPaypalPayerEmail                , "payer_email"            ) ;
        TN( tKeyPaypalPayerId                   , "payer_id"               ) ;
        TN( tKeyPaypalPayerStatus               , "payer_status"           ) ;
        TN( tKeyPaypalProtectionEligibility     , "protection_eligibility" ) ;
        TN( tKeyResidenceCountry                , "residence_country"      ) ;

        TN( tKeyPaypalPaymentFee                , "payment_fee"            ) ;
        TN( tKeyPaypalPaymentGross              , "payment_gross"          ) ;
        TN( tKeyPaypalPaymentStatus             , "payment_status"         ) ;
        TN( tKeyPaypalCustom                    , "custom"                 ) ;
        TN( tKeyIdTest                          , "ifcidtest"              ) ;

        TN( tKeyRewardBoxHidden                 , "option_selection2"      ) ;
        TN( tKeyRewardBox                       , "option_selection1"      ) ;

        TN( tKeyTransType                       , "txn_type"               ) ;
        TN( tKeyTransId                         , "txn_id"                 ) ;
        TN( tKeyItemNumber                      , "item_number"            ) ;

        TN( tValueAddressCity                   , "" ) ;
        TN( tValueAddressCountry                , "" ) ;
        TN( tValueAddressCountryCode            , "" ) ;
        TN( tValueAddressName                   , "" ) ;
        TN( tValueAddressState                  , "" ) ;
        TN( tValueAddressStatus                 , "" ) ;
        TN( tValueAddressStreet                 , "" ) ;
        TN( tValueAddressZip                    , "" ) ;
        TN( tValueCharset                       , "" ) ;
        TN( tValueFirstName                     , "" ) ;
        TN( tValueLastName                      , "" ) ;
        TN( tValuePaypalPayerEmail              , "" ) ;
        TN( tValuePaypalPayerId                 , "" ) ;
        TN( tValuePaypalPayerStatus             , "" ) ;
        TN( tValuePaypalProtectionEligibility   , "" ) ;
        TN( tValueResidenceCountry              , "" ) ;

        TN( tValuePaypalPaymentFee              , "" ) ;
        TN( tValuePaypalPaymentGross            , "" ) ;
        TN( tValuePaypalPaymentStatus           , "" ) ;
        TN( tValuePaypalCustom                  , "" ) ;
        TN( tValueIdTest                        , "" ) ;

        TN( tValueRewardBoxHidden               , "" ) ;
        TN( tValueRewardBox                     , "" ) ;

        TN( tValueTransType                     , "" ) ;
        TN( tValueTransId                       , "" ) ;
        TN( tValueItemNumber                    , "" ) ;

        textC* pptKey[] =
        {
            //CS:CODEsYNC: 1d20005 1d20005 1d20005
            &tKeyAddressCity                    ,
            &tKeyAddressCountry                 ,
            &tKeyAddressCountryCode             ,
            &tKeyAddressName                    ,
            &tKeyAddressState                   ,
            &tKeyAddressStatus                  ,
            &tKeyAddressStreet                  ,
            &tKeyAddressZip                     ,
            &tKeyCharset                        ,
            &tKeyFirstName                      ,
            &tKeyLastName                       ,
            &tKeyPaypalPayerEmail               ,
            &tKeyPaypalPayerId                  ,
            &tKeyPaypalPayerStatus              ,
            &tKeyPaypalProtectionEligibility    ,
            &tKeyResidenceCountry               ,

            //CS:B
            &tKeyPaypalPaymentFee               ,
            &tKeyPaypalPaymentGross             ,
            &tKeyPaypalPaymentStatus            ,
            &tKeyPaypalCustom                   ,
            &tKeyIdTest                         ,

            &tKeyRewardBoxHidden                ,
            &tKeyRewardBox                      ,

            &tKeyTransType                      ,
            &tKeyTransId                        ,
            &tKeyItemNumber                     ,
        } ;

        textC* pptValue[] =
        {
            //CS:CODEsYNC: 1d20005 1d20005 1d20005
            &tValueAddressCity                   ,
            &tValueAddressCountry                ,
            &tValueAddressCountryCode            ,
            &tValueAddressName                   ,
            &tValueAddressState                  ,
            &tValueAddressStatus                 ,
            &tValueAddressStreet                 ,
            &tValueAddressZip                    ,
            &tValueCharset                       ,
            &tValueFirstName                     ,
            &tValueLastName                      ,
            &tValuePaypalPayerEmail              ,
            &tValuePaypalPayerId                 ,
            &tValuePaypalPayerStatus             ,
            &tValuePaypalProtectionEligibility   ,
            &tValueResidenceCountry              ,

            //CS:B
            &tValuePaypalPaymentFee              ,
            &tValuePaypalPaymentGross            ,
            &tValuePaypalPaymentStatus           ,
            &tValuePaypalCustom                  ,
            &tValueIdTest                        ,

            &tValueRewardBoxHidden               ,
            &tValueRewardBox                     ,

            &tValueTransType                     ,
            &tValueTransId                       ,
            &tValueItemNumber                    ,
        } ;

        countT cFlavors = swKVP.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;

            for( countT offk = 0 ; offk < sizeof pptKey / sizeof pptKey[ 0 ] ; offk ++ )
            {
                if( !etThread.strCompareF( tinP , psttLeverKVP , *pptKey[ offk ] ) ) *pptValue[ offk ] = T((strokeS*)(countT)swKVP) ;
            }
        }

        const countT idTest = !tValueIdTest.csF( tinP ) ? 0 : etThread.strDigitsToSCountF( tinP , tValueIdTest ) ;

        //U:: 20120905: COMMENTED OUT TO BRING UP HTTP SERVER WITH NO DATABASE FUNCTIONALITY; ALL DATABASE FUNCTIONALITY CODE NEEDS TO BE MIGRATED TO THE NEW LIST SUPPORT IN poolC
        #if defined( NEVERdEFINED )

            const countT idAcc = queryIdAccountFromEmailF( tinP , tValuePaypalPayerEmail ) ;

            if( idAcc )
            {
                {
                    accountS info( tinP , etThread , idAcc , flACCOUNT1_SET , flACCOUNT2_QUERYfLAGSmODE | flACCOUNT2_QUERYzIPaT ) ; //MUST QUERY FOR ALL FIELDS THAT ARE CAPTURED FROM ACCOUNT OWNER OR FROM ANOTHER SOURCE OTHER THAN PAYPAL

                    if( F(info.flagsThis1) & flACCOUNT1_FYIdOESnOTeXIST ) info.flagsMode = fliACCOUNTmODE_LISTmEdIRECTORY | fliACCOUNTmODE_OWNERcONFIRMED ;

                    strokeS** pppstto[] =
                    {
                        //20200622@1031: NO LONGER KEPT IN SYNC BECAUSE AM NOT USING THIS ACCOUNTING SYSTEM

                        //CS:CODEsYNC: 1d20005 1d20005 1d20005
                        &info.psttAddressCity                   ,
                        &info.psttAddressCountry                ,
                        &info.psttAddressCountryCode            ,
                        &info.psttAddressName                   ,
                        &info.psttAddressState                  ,
                        &info.psttAddressStatus                 ,
                        &info.psttAddressStreet                 ,
                        &info.psttAddressZip                    ,
                        &info.psttCharset                       ,
                        &info.psttFirstName                     ,
                        &info.psttLastName                      ,
                        &info.psttPaypalPayerEmail              ,
                        &info.psttPaypalPayerId                 ,
                        &info.psttPaypalPayerStatus             ,
                        &info.psttPaypalProtectionEligibility   ,
                        &info.psttResidenceCountry              ,
                    } ;

                    countT cKey   = sizeof pptKey   / sizeof pptKey[   0 ] ;
                    countT cField = sizeof pppstto  / sizeof pppstto[  0 ] ;
                    {
                        countT cValue = sizeof pptValue / sizeof pptValue[ 0 ] ;
                        __( cValue - cKey ) ;
                        __( cField - cKey + 5 ) ; //CS:B
                    }

                    if( !POOP )
                    {
                        for( countT offo = 0 ; offo < cField ; offo ++ )
                        {
                            strokeS*& pstto = *pppstto[ offo ] ;
                            //U::CONoUTrAW( T("updating account description OLD [")+*pptKey[offo]+T("]: \"")+T(pstto)+T("\"\r\n") ) ;
                            if( pstto ) { PUSE( tinP , *(byteT**)&pstto ) ; }
                            if( pptValue[ offo ]->csF( tinP ) ) { etThread.strMakeF( tinP , LF , pstto , *pptValue[ offo ] ) ; ___( pstto ) ; }
                            //U::CONoUTrAW( T("updating account description NEW [")+*pptKey[offo]+T("]: \"")+T(pstto)+T("\"\r\n") ) ;
                        }
                    }
                }

                if
                (
                    !POOP &&
                    (
                        !etThread.strCompareF( tinP , tValuePaypalPaymentStatus , T("Completed") ) ||
                        !etThread.strCompareF( tinP , tValuePaypalPaymentStatus , T("Refunded" ) )
                    )
                )
                {
                    countT cMoneyGross = cMoneyF( tinP , etThread , tValuePaypalPaymentGross ) ;
                    countT cMoneyFee   = cMoneyF( tinP , etThread , tValuePaypalPaymentFee   ) ;

                    countT cMoneyIn = cMoneyGross - cMoneyFee ;
        
                    if( cMoneyIn )
                    {

                        ZE( countT , idAccCommission ) ;
                        if( tValuePaypalCustom.csF( tinP ) )
                        {
                            TN( tCustomKeyIdAccCommission , "idAccCommission" ) ;

                            ZE( strokeS* , pstt1w ) ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                            etThread.strWordsOldF( tinP , pstt1w , tValuePaypalCustom , sttq , T(TbLACK)+T(";") ) ; ___( pstt1w ) ;
                            FORsTRINGSiN1( pstt1w )
                            {
                                ZE( strokeS* , pstt2w ) ;
                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                etThread.strWordsOldF( tinP , pstt2w , psttc1 , sttq , T(TbLACK)+T(":") ) ; ___( pstt2w ) ;
                                ZE( countT , idArm ) ;
                                FORsTRINGSiN2( pstt2w )
                                {
                                    switch( idArm )
                                    {
                                        case 1 :
                                        {
                                            idAccCommission = etThread.strDigitsToSCountF( tinP , psttc2 , 36 ) ;
                                            break ;
                                        }
                                        default :
                                        {
                                            if( !etThread.strCompareF( tinP , psttc2 , tCustomKeyIdAccCommission ) ) idArm = 1 ;
                                            break ;
                                        }
                                    }



                                }
                                etThread.delF( tinP , pstt2w ) ;
                            }
                            etThread.delF( tinP , pstt1w ) ;
                        }

                        {
                            ZE( countT  , moneyT1 ) ;
                            ZE( sCountT , moneyT2 ) ;
                            if( (sCountT)cMoneyIn > 0 ) moneyT1 = cMoneyIn ;
                            else                        etThread.osTimeSubtractF( tinP , moneyT1 , moneyT2 , - cMoneyIn , 0 ) ;
            
                            ZE( countT  , timeN1 ) ;
                            ZE( sCountT , timeN2 ) ;
                            etThread.osTimeNowUniqueF( tinP , timeN1 , timeN2 ) ;
                        
                            //U::CONoUTrAW7( "deposit: [moneyT1,idAcc,idAccCommission]: " , moneyT1 , " " , idAcc , " " , idAccCommission , "\r\n" ) ;

                            count8S c8n( 6 , 7 , 8 , 9 ) ;
                            { depositS info( tinP , 1/*idAccBucketOwner*/ , 1/*idBucket*/ , 1/*idProduct*/ , idAcc/*Depositor*/ , 0/*pczNote*/ , timeN1 , timeN2 , 1/*idDeposit*/ , idAccCommission , moneyT1 , moneyT2 ) ; }

                            {
                                ZE( strokeS* , psttEmail ) ;
                                queryEmailFromIdAccountF( tinP , psttEmail , idAcc ) ; ___( psttEmail ) ;

                                TN( tSay , "" ) ; tSay = T(

                                    "Subject: Thank you for your deposit!\r\n"
                                    "\r\n"
                                    "This is a notification that your PayPal (tm) account has been used to make a purchase at IDEAFARM.COM."
                                    "  You can view the details of this payment by logging into your PayPal (tm) account.\r\n"
                                    "\r\n"
                                    "This is a nonrefundable purchase."
                                    "  However, if you feel that you are entitled to a refund, you will be given one, no questions asked."
                                    "  This is an example of the trust reversal policy of IdeaFarm " "(tm) Operations."
                                    "  Instead of asking you to trust us, we do business in a way that requires that we trust you!"
                                    "  It is an honor system."
                                    "  Please do not request a refund unless you really feel entitled to one.\r\n"
                                    "\r\n"
                                    "IdeaFarm " "(tm) Operations must make 8 sales of the same size to recover from each refund."
                                    "  This is because 7/8 of your purchase price is paid as a commission to sales workers."
                                    "  Sales workers are not asked to return their commission."

                                ) ;

                                etThread.boxPutF( tinP , T("//smtp/" ifcEMAIL_AUTOrESPONDERbANKtELLER "/")+T(psttEmail) , tSay , tSay.csF( tinP ) ) ;
                                etThread.delF( tinP , psttEmail ) ;
                            }

                            if( idAccCommission )
                            {
                                ZE( strokeS* , psttEmail ) ;
                                queryEmailFromIdAccountF( tinP , psttEmail , idAccCommission ) ; ___( psttEmail ) ;

                                countT cents   = moneyT1 % 100 ;
                                countT dollars = moneyT1 / 100 ;

                                TN( tSay , "" ) ; tSay = T(

                                    "Subject: You've just been paid a commission!\r\n"
                                    "\r\n"
                                    "A sale of ")+TF2(moneyT1,flFORMAT_NObIGITvALUES)+T(" mEx (tm), worth $")+TF4(dollars,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T(".")+TF4(cents,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T(", has just been booked, and you are the sales worker of record for that sale!"
                                    "  Your commission on this sale will be paid to you on demand, via PayPal (tm)."
                                    "  Contact the organizer to request a payout."
                                    "  Please allow several days for the organizer to make the payout."
                                    "  The organizer will respond to payout requests as quickly as he can."

                                ) ;

                                etThread.boxPutF( tinP , T("//smtp/" ifcEMAIL_AUTOrESPONDERbANKtELLER "/")+T(psttEmail) , tSay , tSay.csF( tinP ) ) ;
                                etThread.delF( tinP , psttEmail ) ;
                            }

                            {
                                sessionsP.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                countT cFlavors = sessionsP.swSession.cFlavorsF( tinP ) ;
                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                {
                                    sessionsP.nnLever_peer = *(nicNameC*)sessionsP.swSession.leverF( tinP , idf ) ;
                                    sessionC& session = *(sessionC*)(countT)sessionsP.swSession ;
                                    if( idAcc == session.getIdAccountF( tinP ) ) session.privilegesF( tinP , session.privilegesF( tinP ) | flSESSIONpRIVILEGE_FULLhEADER ) ;
                                }
                                sessionsP.baton.ungrabF( tinP ) ;
                            }
                        }
                    }
                }
            }

        #endif

        // 20200604@1905:  REGISTER THE PURCHASER FOR WO'O'S TABLE


        // ---- psttKVReportP (END) -----------------------------------------------------------------
        // address_city: "San Jose"<BR>
        // address_country: "United States"<BR>
        // address_country_code: "US"<BR>
        // address_name: "John Doe"<BR>
        // address_state: "CA"<BR>
        // address_status: "confirmed"<BR>
        // address_street: "1 Main St"<BR>
        // address_zip: "95131"<BR>
        // amount3: "20.91"<BR>
        // btn_id: "4125553"<BR>
        // business: "sb-znjve1276155@business.example.com"<BR>
        // charset: "windows-1252"<BR>
        // first_name: "John"<BR>
        // ipn_track_id: "b74bafb2990bf"<BR>
        // item_name: "Wo'O's Table Registration and Subscription"<BR>
        // item_number: "20200604"<BR>
        // last_name: "Doe"<BR>
        // mc_amount3: "20.91"<BR>
        // mc_currency: "USD"<BR>
        // notify_version: "3.9"<BR>
        // payer_email: "sb-prtxq883780@personal.example.com"<BR>
        // payer_id: "4QLHUR4EYW37J"<BR>
        // payer_status: "verified"<BR>
        // period3: "1 D"<BR>
        // reattempt: "1"<BR>
        // receiver_email: "sb-znjve1276155@business.example.com"<BR>
        // recurring: "1"<BR>
        // residence_country: "US"<BR>
        // subscr_date: "13:30:53 Jun 30, 2020 PDT"<BR>
        // subscr_id: "I-40KPDG5ERKE8"<BR>
        // test_ipn: "1"<BR>
        // txn_type: "subscr_signup"<BR>
        // verify_sign: "A6Wl-dV.Rl9HlgUaUiaylqrnaEu-A-m.2EaCOFABnQmIlQVYHSVWnUsE"<BR>
        // ---- psttKVReportP (BEGIN) -----------------------------------------------------------------

        // PROCESS IF:
        //
        // txn_type: "subscr_payment"<BR>
        // payment_status: "Completed"<BR>
        // item_number: "20200604"<BR>
        // item_name: "Wo'O's Table Registration and Subscription"<BR>

        if
        (
            !etThread.strCompareF( tinP , tValueItemNumber , T("20200604") )
            &&
            (
                  !etThread.strCompareF( tinP , tValueTransType  , T("subscr_signup") )
               || !etThread.strCompareF( tinP , tValueTransType  , T("subscr_cancel") )
            )
        )
        {
            ZE( countT , finger ) ;
            putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEcONFIRMEDeMAIL ) ;

            boolT bDelete = !etThread.strCompareF( tinP , tValueTransType , T("subscr_cancel") ) ;
            TN( tAction , bDelete ? "unregister" : "register" ) ;

            etThread.traceF( tinP , T("paypal subscription [tAction]: ")+tAction ) ;

            boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

            // THIS WILL BLOCK UNTIL IT CAN OPEN THE SERIAL NUMBER FILE, WHICH MIGHT TAKE A TICK IF factory2 IS REBOOTING
            // SO THIS IS NOT A SPF EVEN THOUGH IT REQUIRES factory2, SINCE IT WILL BLOCK UNTIL IT SUCCEEDS
            count04T idSubscriber = bDelete ? 0 : etThread.etherDispenseSerialNumberF( tinP , T(bSandbox?"////"postCRAFTWORKfACTORY"/d/tmp/idSubscriberLath":"////"postCRAFTWORKfACTORY"/d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/idSubscriberLath") ) ;

            TN( tIdSubscriber , "" ) ; tIdSubscriber = TF4((countT)idSubscriber,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e) ;

            ZE( countT , secret ) ;
            if( !bDelete )
            {
                ranUniC ru( tinP , (measure04T)MAXcOUNTT + 1 ) ;
                secret = ru ;
            }

            ZE( countT , timeN1 ) ;
            ZE( sCountT , timeN2 ) ;
            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;

            TN( tZipUse , (strokeS*)tValueAddressZip ) ;
            if( !tZipUse.csF( tinP ) ) tZipUse = tValueAddressCity ;

            soulC rec( tinP , TAG( TAGiDnULL ) ) ;
            rec << finger                             ;
            rec << (countT)7                          ; // IDfORMAT
            rec << (countT)timeN1                     ; //ADDED IN FORMAT 5
            rec << (countT)timeN2                     ; //ADDED IN FORMAT 5
            rec << (strokeS*)tAction                  ;
            rec << (strokeS*)T(nnPeerP)               ;
            rec << (strokeS*)tValuePaypalPayerEmail   ;
            rec << (strokeS*)tZipUse                  ;
            rec << (strokeS*)tValueRewardBoxHidden    ;
            rec << (strokeS*)tValueRewardBox          ;
            rec << (strokeS*)tValueTransType          ;
            rec << (strokeS*)tValueTransId            ;
            rec << ((countT*)&idSubscriber)[ 0 ]      ; //ADDED IN FORMAT 5
            rec << ((countT*)&idSubscriber)[ 1 ]      ; //ADDED IN FORMAT 5
            rec << (countT)secret                     ; //ADDED IN FORMAT 7
            rec << (strokeS*)tValueFirstName          ; //ADDED IN FORMAT 5
            rec << (strokeS*)tValueLastName           ; //ADDED IN FORMAT 6
            rec << (strokeS*)tValueAddressName        ; //ADDED IN FORMAT 6
            rec << (strokeS*)tValueAddressStreet      ; //ADDED IN FORMAT 6
            rec << (strokeS*)tValueAddressCity        ; //ADDED IN FORMAT 6
            rec << (strokeS*)tValueAddressState       ; //ADDED IN FORMAT 6
            rec << (strokeS*)tValueAddressCountryCode ; //ADDED IN FORMAT 6
            rec << (strokeS*)tValueAddressCountry     ; //ADDED IN FORMAT 6
            rec << (strokeS*)tValueAddressZip         ; //ADDED IN FORMAT 6
            rec << (strokeS*)tValueAddressStatus      ; //ADDED IN FORMAT 6

            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            TN( tHost , "" ) ;
            {
                ZE( strokeS* , psttHost ) ;
                etThread.sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
                if( !psttHost ) etThread.traceF( tinP , T("error: reverse DNS lookup on myself failed 105") ) ;
                else            tHost = T(psttHost) ;
                etThread.delF( tinP , psttHost ) ;
                if( !tHost.csF( tinP ) ) tHost = T("factories") ;
            }

            TN( tShort , "" ) ;
            {
                TlIST( tListSubscriptionFileLong ) ;
                {
                    TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/subscriptions/subscription.table")+T(bSandbox?".sandbox.@1@.":".live.@1@.")+T(nnPeerP)+T(".")+tIdSubscriber+T(".")+tHost ;
                    TlISTlOAD( tListSubscriptionFileLong , meP.tListFactoryF() , tSuffix ) ;
                }

                ZE( strokeS* , psttFile ) ;
                etThread.boxPutUniqueF( tinP , psttFile , tListSubscriptionFileLong , WS( rec ) ) ; ___( psttFile ) ;
                FORsTRINGSiN1( psttFile )
                {
                    etThread.traceF( tinP , T("wrote   ")+T(psttc1) ) ;

                    if( !tShort.csF( tinP ) )
                    {
                        ZE( strokeS* , psttnu ) ;
                        ZE( strokeS* , psttShort ) ;
                        etThread.strBisectF( tinP , psttnu , psttShort , psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                        tShort = T(psttShort) ;
                        etThread.delF( tinP , psttnu ) ;
                        etThread.delF( tinP , psttShort ) ;
                    }
                }
                etThread.delF( tinP , psttFile ) ;
            }

            textC tTime( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

            TN( tBody ,

                bDelete
                ?
                    "Subject: Wo'O's Table:  Your email has been unregistered, effective immediately.\r\n"
                    "\r\n"
                    "Sorry to see you go!  If you change your mind, just register again.\r\n"
                    "\r\n"
                :    
                    "Subject: Wo'O's Table:  Your email is now registered.\r\n"
                    "\r\n"
                    "Thank you for deciding to participate in Wo'O's Table.\r\n"
                    "The following information has been registered:\r\n"
                    "\r\n"

            ) ;

            tBody += T("email:  ")+tValuePaypalPayerEmail+T("\r\n") ;

            if( !bDelete )
            {
                TN( tIdSubscriber , "" ) ; tIdSubscriber = TF4((countT)idSubscriber,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e) ;
                TN( tSecret       , "" ) ; tSecret       = TF4((countT)secret      ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e) ;

                tBody += T("postal code:  ")+tValueAddressZip+T("\r\n") ;
                tBody += T("country:  ")+tValueAddressCountry+T("\r\n") ;
                tBody += T("subscriber id:  ")+tIdSubscriber+T("\r\n\r\n") ;
                tBody += T("Give this link to others:  https://ideafarm.com?")+tIdSubscriber+T("\r\n\r\n") ;
                tBody += T("Keep this secret and use it to prove your identity:  ")+tSecret+T("\r\n") ;
            }

            tBody += T("\r\nreference:  ")+tShort+T("\r\n") ;
            tBody += T("time:  ")+tTime+T("\r\n") ;

            TN( tEmailSandboxMe , "ideafarmcity@gmail.com" ) ;
            textC& tToUse = bSandbox
                ? tEmailSandboxMe
                : tValuePaypalPayerEmail
            ;

            etThread.boxPutF( tinP , T("smtp.mailgun.org[admin]/b42/smtp/")+tHost+T("@ideafarm.com/")+tToUse+T("//wo@ideafarm.com/ideafarm.factory.reports@gmail.com") , tBody ) ;

            THREADmODE1rESTORE
        }
    }

    LOGrAW3( "noteFromPaypalCBF [bValid]:    " , bValid , "\r\n" ) ;
    LOGrAW( "\r\n---- psttKVReportP (BEGIN) -----------------------------------------------------------------\r\n" ) ;
    LOGrAW( T(psttKVReportP) ) ;
    LOGrAW( "\r\n---- psttKVReportP (END) -----------------------------------------------------------------\r\n" ) ;

    //{
    //    TN( tKey   , "" ) ;
    //    TN( tValue , "" ) ;
    //    countT cFlavors = swKVP.cFlavorsF( tinP ) ;
    //    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    //    {
    //        psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
    //        strokeS* psttv = (strokeS*)(countT)swKVP ;
    //
    //        tKey   = T(psttLeverKVP) ;
    //        tValue = T(psttv) ;
    //
    //        TN( tSay , "" ) ; tSay = T("keyValue: \"")+tKey+T("\" = \"")+tValue+T("\"\r\n") ;
    //        LOGrAW( tSay ) ;
    //    }
    //}

    etThread.traceF( tinP , T("noteFromPaypalCBF [bGot,bValid]:    ")+TF2(bGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(bValid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a2.notefrompaypalcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a3.cmoneyf BEGIN
#define DDNAME       "3func.330000a3.cmoneyf"
#define DDNUMB      (countT)0x330000a3
#define IDFILE      (countT)0x982


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
parameters
 psttP
  format: "123.45" (one hundred twenty three dollars and forty five cents)
   returns the value 12345_9
*/
/**/

/*1*/countT cMoneyF( tinS& tinP , etherC& etherP , const strokeS* const psttP )/*1*/
{
    ZE( strokeS* , pstt1w ) ;
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    countT cWords = etherP.strWordsOldF( tinP , pstt1w , psttP , sttq , T(".") ) ; ___( pstt1w ) ;

    ZE( countT , cCents   ) ;
    ZE( countT , cDollars ) ;
    boolT bDollars = 1 ;
    countT* ppcOut[] = { &cCents , &cDollars } ;
    FORsTRINGSiN1( pstt1w )
    {
        *ppcOut[ bDollars ] = etherP.strDigitsToSCountF( tinP , psttc1 , 0xa , 1 ) ;

        if( !bDollars ) break ;
        else            bDollars = 0 ;
    }

    PUSE( tinP , *(byteT**)&pstt1w ) ;

    return cCents + cDollars * 100 ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a3.cmoneyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a4.homeOld20190809CBF BEGIN
#define DDNAME       "3func.330000a4.homeOld20190809CBF"
#define DDNUMB      (countT)0x330000a4
#define IDFILE      (countT)0x983


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

                            //"<OPTION VALUE=\"application.email.no.spam\">Application: Email Without Spam</OPTION>\r\n"
                            //"<OPTION VALUE=\"application.email.wide.area.crisis.response\">Application: Rapid Wide Area Crisis Response</OPTION>\r\n"
                            //"<OPTION VALUE=\"application.email.presale.inquiry\">Application: Presales Inquiry Response</OPTION>\r\n"
                            //"<OPTION VALUE=\"application.email.customer.care\">Application: Postsale Customer Care</OPTION>\r\n"
                            //"<OPTION VALUE=\"application.email.local.crisis.response\">Application: Rapid Local Crisis Response</OPTION>\r\n"
                            //"<OPTION VALUE=\"application.email.local.event.rsvp\">Application: Local Event Announcements With RSVP</OPTION>\r\n"
                            //"<OPTION VALUE=\"application.email.conversations\">Application: Conversations</OPTION>\r\n"

#define postSURVEY1qUESTION1(postWhoP)                                                                                                                                                            \
                                                                                                                                                                                                \
                                        "<TR>\r\n"                                                                                                                                              \
                                            "<TD align=center style=\"width:25%\">\r\n"                                                                                                         \
                                                postWhoP                                                                                                                                        \
                                            "</TD>\r\n"                                                                                                                                         \
                                            "<TD align=center style=\"width:25%\">\r\n"                                                                                                         \
                                                "<input type=radio name=" postWhoP " value=notselfish>\r\n"                                                                                     \
                                            "</TD>\r\n"                                                                                                                                         \
                                            "<TD align=center style=\"width:25%\">\r\n"                                                                                                         \
                                                "<input type=radio name=" postWhoP " value=donotcare>\r\n"                                                                                      \
                                            "</TD>\r\n"                                                                                                                                         \
                                            "<TD align=center style=\"width:25%\">\r\n"                                                                                                         \
                                                "<input type=radio name=" postWhoP " value=selfish>\r\n"                                                                                        \
                                            "</TD>\r\n"                                                                                                                                         \
                                        "</TR>\r\n"

#define postSURVEY1qUESTION2(postValueP,postAnswerP)                                                                                                                                            \
                                                                                                                                                                                                \
                                        "<TR>\r\n"                                                                                                                                              \
                                            "<TD align=center style=\"\">\r\n"                                                                                                                  \
                                                "<input type=radio name=wheretofind value=" postValueP "  onclick=\"submit();\">\r\n"                                                           \
                                            "</TD>\r\n"                                                                                                                                         \
                                            "<TD align=left style=\"\">\r\n"                                                                                                                    \
                                                postAnswerP                                                                                                                                     \
                                            "</TD>\r\n"                                                                                                                                         \
                                        "</TR>\r\n"

/*1*/voidT homeOld20190809CBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    count8S& c8P = *(count8S*)cArgP ;
    booksC&  booksSurveyP = *(booksC*)c8P.c2 ;

    sessionC& session = sessionsP( tinP , nnPeerP ) ;
    {
        TN( tPopup , "" ) ;

        TN( tKeyIdAccCommission  , "idacccommission" ) ;
        TN( tValueIdAccCommission , "" ) ;
        TN( tb , " " ) ;
        TN( tcq , ": \"" ) ;
        TN( tq , "\"" ) ;

        TN( tsq1k1  , "child"         ) ;
        TN( tsq1k2  , "coworker"      ) ;
        TN( tsq1k3  , "customer"      ) ;
        TN( tsq1k4  , "employee"      ) ;
        TN( tsq1k5  , "friend"        ) ;
        TN( tsq1k6  , "parent"        ) ;
        TN( tsq1k7  , "spouse"        ) ;
        TN( tsq1k8  , "student"       ) ;
        TN( tsq1k9  , "supervisor"    ) ;
        TN( tsq1ka  , "teacher"       ) ;

        textC* pptSurveyQ1Key[] =
        {
            &tsq1k1 ,
            &tsq1k2 ,
            &tsq1k3 ,
            &tsq1k4 ,
            &tsq1k5 ,
            &tsq1k6 ,
            &tsq1k7 ,
            &tsq1k8 ,
            &tsq1k9 ,
            &tsq1ka
        } ;

        TN( tsq1v1  , "donotcare"     ) ;
        TN( tsq1v2  , "notselfish"    ) ;
        TN( tsq1v3  , "selfish"       ) ;

        textC* pptSurveyQ1Value[] =
        {
            &tsq1v1 ,
            &tsq1v2 ,
            &tsq1v3 ,
        } ;

        TN( tsq2k1  , "wheretofind"   ) ;

        textC* pptSurveyQ2Key[] =
        {
            &tsq2k1
        } ;

        TN( tsq2v1  , "bar"           ) ;
        TN( tsq2v2  , "believers"     ) ;
        TN( tsq2v3  , "everywhere"    ) ;
        TN( tsq2v4  , "homeless"      ) ;
        TN( tsq2v5  , "nowhere"       ) ;
        TN( tsq2v6  , "online"        ) ;
        TN( tsq2v7  , "park"          ) ;
        TN( tsq2v8  , "poor"          ) ;
        TN( tsq2v9  , "rich"          ) ;
        TN( tsq2va  , "school"        ) ;
        TN( tsq2vb  , "street"        ) ;
        TN( tsq2vc  , "students"      ) ;
        TN( tsq2vd  , "work"          ) ;
        TN( tsq2ve  , "working"       ) ;

        textC* pptSurveyQ2Value[] =
        {
            &tsq2v1 ,
            &tsq2v2 ,
            &tsq2v3 ,
            &tsq2v4 ,
            &tsq2v5 ,
            &tsq2v6 ,
            &tsq2v7 ,
            &tsq2v8 ,
            &tsq2v9 ,
            &tsq2va ,
            &tsq2vb ,
            &tsq2vc ,
            &tsq2vd ,
            &tsq2ve
        } ;

        countT cFlavors = swKVP.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
            strokeS* psttv = (strokeS*)(countT)swKVP ;

            writeBookSurveyF( tinP , etThread , booksSurveyP , psttLeverKVP , psttv , pptSurveyQ1Key , sizeof pptSurveyQ1Key / sizeof pptSurveyQ1Key[ 0 ] , pptSurveyQ1Value , sizeof pptSurveyQ1Value / sizeof pptSurveyQ1Value[ 0 ] , pptSurveyQ2Key , sizeof pptSurveyQ2Key / sizeof pptSurveyQ2Key[ 0 ] , pptSurveyQ2Value , sizeof  pptSurveyQ2Value / sizeof pptSurveyQ2Value[ 0 ] ) ;
            tPopup += tb+T(psttLeverKVP)+tcq+T(psttv)+tq ;

            if( !etThread.strCompareF( tinP , psttLeverKVP , tKeyIdAccCommission ) )
            {
                //POPUP( T("value: \"")+T(psttv)+T("\"") ) ;
                countT idAccComm = etThread.strDigitsToSCountF( tinP , psttv , 36 ) ;
                session.setIdAccountCommissionF( tinP , idAccComm ) ;
            }
        }
        //if( tPopup.csF( tinP ) ) POPUP( tPopup ) ;
    }

    const countT idAccount       = session.getIdAccountF( tinP ) ;
    const countT idAccCommission = session.getIdAccountCommissionF( tinP ) ;

    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOME3 ) ;

    if( !idAccCommission ) meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOME4 ) ;
    else
    {
        flagsT flagsUtility = session.getFlagsUtilityF( tinP ) ;
        if( !idAccount && !( F(flagsUtility) & flSESSIONuTILITY_SURVEY1qUESTION1dONE ) )
        {
            session.setFlagsUtilityF( tinP , flagsUtility | flSESSIONuTILITY_SURVEY1qUESTION1dONE ) ;

            TN( tSay , "" ) ; tSay = T(

                "<P>\r\n"
                "<HR>\r\n"
                "<P>\r\n"
                "Give a moment's thought to truthfully answering two questions, and you will know what this web site is all about:\r\n"
                "<P>\r\n"
                "<CENTER>\r\n"
                    "<FORM METHOD=\"POST\" NAME=\"survey1q1\" ACTION=\"/\">\r\n"
                        "<TABLE style=\"border-width: thick ; border-style: ridge ; border-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; width:80%\">\r\n"
                            "<TR>\r\n"
                                "<TD colspan=3 align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL " ;\">\r\n"
                                    "<SPAN class=\"spaLarge\">Click Your Selfishness Preferences (Question 1 of 2)</SPAN>\r\n"
                                "</TD>\r\n"
                            "</TR>\r\n"
                            "<TR>\r\n"
                                "<TD align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTgRAY " ; color:white ;\">\r\n"
                                    "<SPAN class=\"spaXSmall\">\r\n"
                                        "I would rather have a ...\r\n"
                                    "</SPAN>\r\n"
                                "</TD>\r\n"
                                "<TD align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL " ;\">\r\n"
                                    "<TABLE style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTdARKrED " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL " \">\r\n"
                                        "<TR>\r\n"
                                            "<TD style=\"width:25%\">\r\n"
                                                ""
                                            "</TD>\r\n"
                                            "<TD align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; width:25%\">\r\n"
                                                "that is <B>NOT SELFISH</B>"
                                            "</TD>\r\n"
                                            "<TD align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; width:25%\">\r\n"
                                                "no preference"
                                            "</TD>\r\n"
                                            "<TD align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; width:25%\">\r\n"
                                                "that is <B>SELFISH</B>"
                                            "</TD>\r\n"
                                        "</TR>\r\n"
                                        postSURVEY1qUESTION1( "friend" )
                                        postSURVEY1qUESTION1( "spouse" )
                                        postSURVEY1qUESTION1( "parent" )
                                        postSURVEY1qUESTION1( "child" )
                                        postSURVEY1qUESTION1( "teacher" )
                                        postSURVEY1qUESTION1( "student" )
                                        postSURVEY1qUESTION1( "supervisor" )
                                        postSURVEY1qUESTION1( "coworker" )
                                        postSURVEY1qUESTION1( "employee" )
                                        postSURVEY1qUESTION1( "customer" )
                                    "</TABLE>\r\n"
                                "</TD>\r\n"
                                "<TD align=center valign=middle style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTrED   " ; color:white ;\">\r\n"
                                    "<INPUT TYPE=\"Submit\" NAME=\"Submit\" VALUE=\"I'm Done\"> \r\n"
                                "</TD>\r\n"
                            "</TR>\r\n"
                        "</TABLE>\r\n"
                    "</FORM>\r\n"
                "<CENTER>\r\n"

            ) ;

            meP.pushSnipF( tinP , stBodyP , tSay ) ;
        }
        else if( !idAccount && !( F(flagsUtility) & flSESSIONuTILITY_SURVEY1qUESTION2dONE ) )
        {
            session.setFlagsUtilityF( tinP , flagsUtility | flSESSIONuTILITY_SURVEY1qUESTION2dONE ) ;

            TN( tSay , "" ) ; tSay = T(

                "<P>\r\n"
                "<HR>\r\n"
                "<P>\r\n"
                "Give a moment's thought to truthfully answering this last question, and you will know what this web site is all about:\r\n"
                "<P>\r\n"
                "<CENTER>\r\n"
                    "<FORM METHOD=\"POST\" NAME=\"survey1q2\" ACTION=\"/\">\r\n"
                        "<TABLE style=\"border-width: thick ; border-style: ridge ; border-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; width:80%\">\r\n"
                            "<TR>\r\n"
                                "<TD colspan=3 align=center style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL " ;\">\r\n"
                                    "<SPAN class=\"spaLarge\">Where To Find Unselfish People (Question 2 of 2)</SPAN>\r\n"
                                "</TD>\r\n"
                            "</TR>\r\n"
                            "<TR>\r\n"
                                "<TD align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTgRAY " ; color:white ;\">\r\n"
                                    "<SPAN class=\"spaXSmall\">\r\n"
                                        "The best place to find <B>UNSELFISH PEOPLE</B> is (click one)\r\n"
                                    "</SPAN>\r\n"
                                "</TD>\r\n"
                                "<TD align=center style=\"background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL " ;\">\r\n"
                                    "<TABLE style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTdARKrED " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL " \">\r\n"
                                        postSURVEY1qUESTION2( "skip"        , "skip this question" )
                                        postSURVEY1qUESTION2( "bar"         , "in a bar" )
                                        postSURVEY1qUESTION2( "believers"   , "among religious believers" )
                                        postSURVEY1qUESTION2( "online"      , "on the Internet" )
                                        postSURVEY1qUESTION2( "work"        , "at work" )
                                        postSURVEY1qUESTION2( "school"      , "at school" )
                                        postSURVEY1qUESTION2( "street"      , "on the street" )
                                        postSURVEY1qUESTION2( "park"        , "at the park" )
                                        postSURVEY1qUESTION2( "students"    , "wherever high school students hang out" )
                                        postSURVEY1qUESTION2( "rich"        , "wherever rich people hang out" )
                                        postSURVEY1qUESTION2( "working"     , "wherever normal working people hang out" )
                                        postSURVEY1qUESTION2( "poor"        , "wherever poor people hang out" )
                                        postSURVEY1qUESTION2( "homeless"    , "wherever homeless people hang out" )
                                        "<P>\r\n"
                                        postSURVEY1qUESTION2( "everywhere"  , "unselfish people are easy to find everywhere" )
                                        postSURVEY1qUESTION2( "nowhere"     , "there isn't any good place to find unselfish people" )
                                    "</TABLE>\r\n"
                                "</TD>\r\n"
                                //"<TD align=center valign=middle style=\"background-color:" ifcCOLORhTMLwHAT_BACKaCCENTrED   " ; color:white ;\">\r\n"
                                //    "<INPUT TYPE=\"Submit\" NAME=\"Submit\" VALUE=\"I'm Done\"> \r\n"
                                //"</TD>\r\n"
                            "</TR>\r\n"
                        "</TABLE>\r\n"
                    "</FORM>\r\n"
                "<CENTER>\r\n"

            ) ;

            meP.pushSnipF( tinP , stBodyP , tSay ) ;
        }
        else
        {
            if( idAccount ) meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOME8 ) ;
            else    
            {
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOME5 ) ;
                meP.pushSnipF( tinP , stBodyP , TF4(idAccCommission,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36) ) ;
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOME6 ) ;
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOME7 ) ;
            }

            ZE( pbRefC* , prZipList ) ;
            meP.getSnipF( tinP , prZipList , T("zip.list") ) ; ___( prZipList ) ;
            if( prZipList )
            {
                const osTextT* postsZips = *prZipList ;
                countT cbImage = *(countT*)postsZips ;
                strokeS* const pstt1Zips = (strokeS*)( postsZips + sizeof( countT ) ) ;
                if( cbImage == sizeof( strokeS ) * ( CSpREFIX + pstt1Zips->idAdam ) )
                {
                    FORsTRINGSiN1( pstt1Zips ) meP.pushSnipNamedF( tinP , stBodyP , T(idAccount?"zip.click.":"zip.show.")+T(psttc1) ) ;
                }
            }
            DEL( prZipList ) ;
        }
    }
}

#undef postSURVEY1qUESTION1
#undef postSURVEY1qUESTION2


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a4.homeOld20190809CBF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a5.writebooksurveyf BEGIN
#define DDNAME       "3func.330000a5.writebooksurveyf"
#define DDNUMB      (countT)0x330000a5
#define IDFILE      (countT)0x984


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT writeBookSurveyF( tinS& tinP , etherC& etThread , booksC& booksP , const strokeS* const psttkP , const strokeS* const psttvP , textC** const pptSurveyQ1KeyP , const countT cq1KeysP , textC** const pptSurveyQ1ValueP , const countT cq1ValuesP , textC** const pptSurveyQ2KeyP , const countT cq2KeysP , textC** const pptSurveyQ2ValueP , const countT cq2ValuesP )/*1*/
{
    if( cq2KeysP >= 0x10 ) BLAMMO ; //IF Q2 EVER HAS MORE THAN 01 KEYS, THE BOOKS OBJECT WILL NEED TO BE MIGRATED TO SHIFT THE KEY VALUES FOR THE ARCHIVED Q1 KEYS

    ZE( countT , offk ) ;
    for( ; offk < cq2KeysP ; offk ++ ) //Q2 IS DONE WOTH BECAUSE IT HAS FEWER KEYS (CONJ: IT DOES NOT MATTER)
    {
        if( !etThread.strCompareF( tinP , *pptSurveyQ2KeyP[ offk ] , psttkP ) )
        {
            for( countT offv = 0 ; offv < cq2ValuesP ; offv ++ )
            {
                if( !etThread.strCompareF( tinP , *pptSurveyQ2ValueP[ offv ] , psttvP ) )
                {
                    CONoUTrAW( T("q2 value matched: psttk:\"")+T(psttkP)+T("\"    psttv:\"")+T(psttvP)+T("\"\r\n") ) ;
        
                    countT pc2[] = { LISTnAMEaDAMoLD_1 + offk , LISTnAMEaDAMoLD_1 + offv } ;
                    booksP.writeF( tinP , (byteT*)pc2 , sizeof pc2 ) ;
        
                    break ;
                }
            }

            break ;
        }
    }

    if( offk == cq2KeysP ) for( offk = 0 ; offk < cq1KeysP ; offk ++ )
    {
        if( !etThread.strCompareF( tinP , *pptSurveyQ1KeyP[ offk ] , psttkP ) )
        {
            for( countT offv = 0 ; offv < cq1ValuesP ; offv ++ )
            {
                if( !etThread.strCompareF( tinP , *pptSurveyQ1ValueP[ offv ] , psttvP ) )
                {
                    CONoUTrAW( T("q1 value matched: psttk:\"")+T(psttkP)+T("\"    psttv:\"")+T(psttvP)+T("\"\r\n") ) ;
        
                    countT pc2[] = { LISTnAMEaDAMoLD_1 + 0x10 + offk , LISTnAMEaDAMoLD_1 + offv } ;
                    booksP.writeF( tinP , (byteT*)pc2 , sizeof pc2 ) ;
        
                    break ;
                }
            }

            break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a5.writebooksurveyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a6.obeyworkerpictureclickcbf BEGIN
#define DDNAME       "3func.330000a6.obeyworkerpictureclickcbf"
#define DDNUMB      (countT)0x330000a6
#define IDFILE      (countT)0x985


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//U::?idAccCommission=1

/*1*/voidT obeyWorkerPictureClickCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    {
        TN( tKeyIdAccCommission  , "idacccommission" ) ;
        TN( tValueIdAccCommission , "" ) ;
        countT cFlavors = swKVP.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;

            if( !etThread.strCompareF( tinP , psttLeverKVP , tKeyIdAccCommission ) )
            {
                sessionC& session = sessionsP( tinP , nnPeerP ) ;
                strokeS* psttw = (strokeS*)(countT)swKVP ;
                //POPUP( T("value: \"")+T(psttw)+T("\"") ) ;
                countT idAccComm = etThread.strDigitsToSCountF( tinP , psttw , 36 ) ;
                session.setIdAccountCommissionF( tinP , idAccComm ) ;
            }
        }
    }

    meP.pushSnipF( tinP , stBodyP , T(

        "A small picture of the sales worker that you selected will now appear at the top of every page during this session.\r\n"
        "  This sales worker will receive 7/8 of any deposit that you make during this session, net of the payment processor's fee.\r\n"
        "<P>\r\n"
        "If you selected a sales worker based on criteria other than hard and smart work, please go back and select again.\r\n"
        "  This is not a charity site, and these people are not waiting for a handout.\r\n"
        "  Please select the sales worker who got you to take the time to read this web site and decide to take a look at the organizer's invention (a new kind of email).\r\n"
        "<P>\r\n"
        "Taking a look requires that you identify yourself to the organizer, because that is a part of the security system for " postIPDOS ".\r\n"
        "  You accomplish this by making a \"deposit\" of any amount, using PayPal (tm).\r\n"
        "  (You can also make a deposit in person with the organizer.\r\n"
        "  Bring a photo id, and be sure to inspect the id of any person claiming to be the organizer.)\r\n"
        "<P>\r\n"
        "Your deposit can be in any amount, even just a penny.\r\n"
        "  The organizer suggests a deposit of $8.55.\r\n"
        "  A deposit of that amount or less will not be too much; you will eventually spend it within " postIFC ".\r\n"
        "  After the payment processor deducts its 55 cent fee, the net receipt will be $8.00, which will result in an even $7.00 commission paid to the sales worker.\r\n"
        "<P>\r\n"
        "Deposits of any amount over 50 cents will result in net receipts and thus commissions paid.\r\n"
        "  Even if you deposit only a penny, you will be given full access for life to " postIFCBPP ", including full access to this web site's documentation for " postIFC ".\r\n"

    ) ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a6.obeyworkerpictureclickcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a7.queryidaccountfromemailf BEGIN
#define DDNAME       "3func.330000a7.queryidaccountfromemailf"
#define DDNUMB      (countT)0x330000a7
#define IDFILE      (countT)0x986


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//DUPLICATE CODE: b750104 e750104 1d20005

/*1*/countT queryIdAccountFromEmailF( tinS& tinP , const strokeS* const psttP )/*1*/
{
    if( POOP ) return 0 ;
    __Z( psttP ) ;
    if( POOP ) return 0 ;

    ZE( countT , idAccount ) ;
    IFsCRATCH
    {
        SCOOPS

        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
        sock.connectF( tinP , homeS::homeIF().idPortListServerEmailIdAccount ) ;
    
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        sOut << (countT)1 ;
        sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKiDaCCOUNTfROMeMAIL ;
        sOut << psttP ;
        sock.writeF( tinP , sOut ) ;
    
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
        sock.readF( tinP , sIn ) ;
    
        ZE( countT , finger ) ;
        sIn >> finger ;
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
    
        ZE( countT , idFormat ) ;
        sIn >> idFormat ;
        __( idFormat - 1 ) ;
    
        sIn >> idAccount ;
        __Z( idAccount ) ;
    }

    return idAccount ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a7.queryidaccountfromemailf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a8.queryemailfromidaccountf BEGIN
#define DDNAME       "3func.330000a8.queryemailfromidaccountf"
#define DDNUMB      (countT)0x330000a8
#define IDFILE      (countT)0x987


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//DUPLICATE CODE: b750104 3a50104 1d20005

/*1*/voidT queryEmailFromIdAccountF( tinS& tinP , strokeS*& psttP , const countT cPassAccountP )/*1*/
{
    if( POOP ) return ;
    __NZ( psttP ) ;
    if( POOP ) return ;

    IFsCRATCH
    {
        SCOOPS

        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
        sock.connectF( tinP , homeS::homeIF().idPortListServerEmailIdAccount ) ;
    
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        sOut << (countT)1 ;
        sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKeMAILfROMiDaCCOUNT ;
        sOut << cPassAccountP ;
        sock.writeF( tinP , sOut ) ;
    
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
        sock.readF( tinP , sIn ) ;
    
        ZE( countT , finger ) ;
        sIn >> finger ;
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
    
        ZE( countT , idFormat ) ;
        sIn >> idFormat ;
        __( idFormat - 1 ) ;
    
        sIn >> psttP ; ___( psttP ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a8.queryemailfromidaccountf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a9.myaccountsettingscbf BEGIN
#define DDNAME       "3func.330000a9.myaccountsettingscbf"
#define DDNUMB      (countT)0x330000a9
#define IDFILE      (countT)0x988


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

#define SETcOL2EMAILrELAY(cEmailRelayDrawingsP)                                                                                                                 \
                                                                                                                                                                \
    if( ++ idRow == 2 )                                                                                                                                         \
    {                                                                                                                                                           \
        tCol2 = TQ(ifcIDsNIPpREDEFINED_HELP3)+T(" <SELECT NAME=\"relaydrawings.00000001\" onMouseOut=\"swatF();\" onMouseOver=\"flyF( this , 'Use this drop down menu to specify the number of randomly selected relay email addresses to relay each incoming item to.' );\">\r\n<OPTION")+T(cRelays>1&&cEmailRelayDrawingsP&&cEmailRelayDrawingsP<cRelays?"":" SELECTED")+T(" VALUE=\"0\">all\r\n") ; \
        for( countT cDraw = 1 ; cDraw < cRelays ; cDraw ++ ) tCol2 += T("<OPTION")+T(cDraw<cRelays&&cDraw==cEmailRelayDrawingsP?" SELECTED":"")+T(">")+TF2(cDraw,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ; \
        tCol2 += T("</SELECT>\r\n") ;                                                                                                                           \
    }


/*1*/voidT myAccountSettingsCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    //{
    //    TN( tcr , "\r\n" ) ;
    //    TN( tSay , "" ) ;
    //    
    //    countT cFlavors = swKVP.cFlavorsF( tinP ) ;
    //    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    //    {
    //        psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
    //        tSay += T(psttLeverKVP)+T(": \"")+T((strokeS*)(countT&)swKVP)+T("\"")+tcr ;
    //    }
    //    if( tSay.csF( tinP ) ) { P OPUP( tSay ) ; }
    //}

    ZE( strokeS* , psttEmail ) ;
    ZE( countT   , idAccount ) ;
    ZE( strokeS* , psttIdAccount ) ;
    {
        sessionC& session = sessionsP( tinP , nnPeerP ) ;
        session.getEmailF( tinP , psttEmail ) ; ___( psttEmail ) ;
        idAccount = session.getIdAccountF( tinP ) ;
        if( psttEmail && psttEmail->idAdam ) { etThread.strFromF( tinP , psttIdAccount , idAccount , flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE , 0 , 36 ) ; ___( psttIdAccount ) ; }
    }

    if( !psttEmail ){ meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT1 ) ; }
    else
    {
        ZE( boolT  , bDeleteSub ) ;
        ZE( boolT  , bSpamSub ) ;
        ZE( boolT  , bEditSub ) ;
        ZE( boolT  , bEditAcc ) ;
        ZE( boolT  , bFieldMore ) ;
        ZE( boolT  , bAllFields ) ;
        ZE( boolT  , bSaveSub ) ;
        ZE( boolT  , bSaveAcc ) ;
        TN( tSubaccount , "" ) ;
        ZE( countT , idSub ) ;
        TN( tFieldMore , "" ) ;
        {
            TN( tKeyForm          , "form"         ) ;
            TN( tKeySuba          , "idsuba"       ) ;
            TN( tKeyDo            , "do"           ) ;
            TN( tKeyDoFieldDot    , "dofield."     ) ;
            TN( tValueDoDelete    , "Delete"       ) ;
            TN( tValueDoSpam      , "Report Abuse" ) ;
            TN( tValueDoEdit      , "Edit"         ) ;
            TN( tValueDoMore      , "More"         ) ;
            TN( tValueDoSave      , "Save"         ) ;
            TN( tValueFormSpamSub , "spamsuba"     ) ;
            TN( tValueFormEditSub , "editsuba"     ) ;
            TN( tValueFormEditAcc , "editacc"      ) ;
            TN( tValueFormSaveSub , "savesuba"     ) ;
            TN( tValueFormSaveAcc , "saveacc"      ) ;

            TN( tForm , "" ) ;
            {
                countT cFlavors = swKVP.cFlavorsF( tinP ) ;
                {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    {
                        psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
    
                        if( 1 == etThread.strIdF( tinP , tKeyDoFieldDot , psttLeverKVP ) )
                        {
                            ZE( strokeS* , psttw ) ;
                            countT idf = tKeyDoFieldDot.csF( tinP ) + 1 ;
                            ZE( countT , idl ) ;
                            etThread.strSubstringF( tinP , psttw , idf , idl , psttLeverKVP ) ; ___( psttw ) ;
                            tFieldMore = T(psttw) ;
                            etThread.delF( tinP , psttw ) ;
                            bFieldMore = 1 ;
                            break ;
                        }
                    }
                }

                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                {
                    psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;

                    if( !etThread.strCompareF( tinP , tKeyForm , psttLeverKVP ) )
                    {
                        tForm = T((strokeS*)(countT)swKVP) ;
                        break ;
                    }
                }
            }

            if( !bFieldMore && swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKeyDo ) )
            {
                psttLeverKVP = tKeyDo ;
                strokeS* zsttw = (strokeS*)(countT)swKVP ;

                     if( !etThread.strCompareF( tinP , zsttw , tValueDoDelete ) ) bDeleteSub    = 1 ;
                else if( !etThread.strCompareF( tinP , zsttw , tValueDoMore   ) ) bAllFields = 1 ;
                else if( !etThread.strCompareF( tinP , zsttw , tValueDoSave   ) )
                {
                         if( !etThread.strCompareF( tinP , tValueFormSaveSub , tForm ) ) bSaveSub = 1 ;
                    else if( !etThread.strCompareF( tinP , tValueFormSaveAcc , tForm ) ) bSaveAcc = 1 ;
                }
                else if( !etThread.strCompareF( tinP , zsttw , tValueDoSpam   ) )
                {
                    if( !etThread.strCompareF( tinP , tValueFormSpamSub , tForm ) ) bSpamSub = 1 ;
                }
                else if( !etThread.strCompareF( tinP , zsttw , tValueDoEdit   ) )
                {
                         if( !etThread.strCompareF( tinP , tValueFormEditSub , tForm ) ) bEditSub = 1 ;
                    else if( !etThread.strCompareF( tinP , tValueFormEditAcc , tForm ) ) bEditAcc = 1 ;
                }
            }

            if( ( bAllFields || bSpamSub || bEditSub || bDeleteSub || bSaveSub || bFieldMore ) && swKVP.idSlotOfLeverF( tinP , (countT)(strokeS*)tKeySuba ) )
            {
                psttLeverKVP = tKeySuba ;
                strokeS*& zsttv = *(strokeS**)&(countT&)swKVP ;
                if( zsttv ) { etThread.strTrimF( tinP , zsttv , 0 , T(TbLACKnEWlINE) ) ; ___( zsttv ) ; }
                tSubaccount = T(zsttv) ;
                idSub = etThread.strDigitsToSCountF( tinP , tSubaccount , 36 ) ;
            }
        }

        TN( tDot , "." ) ;
        TN( tSuffix , "" ) ; tSuffix = tDot+T(psttIdAccount)+T(ifcEMAIL_DOUBLEbLINDsUFFIX) ;

        IFsCRATCH
        {
            SCOOPS

            const countT idSnipBreak            = ifcIDsNIPpREDEFINED_MYaCCOUNT5   ;
            const countT idSnipParagraph        = ifcIDsNIPpREDEFINED_MYaCCOUNT6   ;
            const countT idSnipSubaccountColon  = ifcIDsNIPpREDEFINED_MYaCCOUNT7   ;
            const countT idSnipColon            = ifcIDsNIPpREDEFINED_MYaCCOUNT8   ;
            const countT idSnipEnd              = ifcIDsNIPpREDEFINED_MYaCCOUNT9   ;
            const countT idSnipTagOn            = ifcIDsNIPpREDEFINED_MYaCCOUNTa   ;
            const countT idSnipTagOff           = ifcIDsNIPpREDEFINED_MYaCCOUNTb   ;
            const countT idSnipDelete1          = ifcIDsNIPpREDEFINED_MYaCCOUNTc   ;
            const countT idSnipDelete2          = ifcIDsNIPpREDEFINED_MYaCCOUNTd   ;
        
            //ORDER OF PUSHING: 1 [idSuba] 2 [idSuba] 3 4 [label] 5 [input] 4 [label] 5 [input] ... 6

            const countT idSnipInput1           = ifcIDsNIPpREDEFINED_MYaCCOUNT82  ;
            const countT idSnipInput2           = ifcIDsNIPpREDEFINED_MYaCCOUNT92  ;
            const countT idSnipInput3small      = ifcIDsNIPpREDEFINED_MYaCCOUNTa2  ;
            const countT idSnipInput3big        = ifcIDsNIPpREDEFINED_MYaCCOUNTd2  ;

            const countT idSnipTextArea1        = ifcIDsNIPpREDEFINED_MYaCCOUNTe2  ;
            const countT idSnipTextArea2        = ifcIDsNIPpREDEFINED_MYaCCOUNTf2  ;
            const countT idSnipTextArea3        = ifcIDsNIPpREDEFINED_MYaCCOUNT13  ;

            TN( tTitleTitle                         , "title"                                                                                                                                               ) ;
            TN( tTitleFlagOwnedByDirectory          , "owned by directory"                                                                                                                                  ) ;
            TN( tTitleFlagReplyEndsConversation     , "reply from relay ends conversation"                                                                                                                  ) ;
            TN( tTitleFlagListInDirectory           , "i am listed in IdeaFarm " "(tm) Directory"                                                                                                                 ) ;
            TN( tTitleFlagListInHello               , "i am listed in IdeaFarm " "(tm) Hello"                                                                                                                 ) ;
            TN( tTitleNameIn                        , "from (seen by relay)"                                                                                                                                ) ;
            TN( tTitleNameOut                       , "from (seen by others)"                                                                                                                               ) ;
            TN( tTitleEmailRelay                    , "relay"                                                                                                                                               ) ;
            TN( tTitleAutoresponse                  , "autoresponse"                                                                                                                                        ) ;
            TN( tTitleRecipe                        , "recipe"                                                                                                                                              ) ;
            TN( tTitleEmailPenpalExactOr            , "penpal (exact or)"                                                                                                                                   ) ;
            TN( tTitleEmailPenpalContainsOr         , "penpal (contains or)"                                                                                                                                ) ;
            TN( tTitleEmailPenpalContainsAnd        , "penpal (contains and)"                                                                                                                               ) ;

            TN( tTitleAddressName                   , "address name"                                                                                                                                        ) ;
            TN( tTitleAddressStreet                 , "address street"                                                                                                                                      ) ;
            TN( tTitleAddressCity                   , "address city"                                                                                                                                        ) ;
            TN( tTitleAddressState                  , "address state"                                                                                                                                       ) ;
            TN( tTitleAddressCountryCode            , "address country code"                                                                                                                                ) ;
            TN( tTitleAddressZip                    , "address zip"                                                                                                                                         ) ;
            TN( tTitleAddressCountry                , "address country"                                                                                                                                     ) ;
            TN( tTitleAddressStatus                 , "address status"                                                                                                                                      ) ;
            TN( tTitleFirstName                     , "woth name"                                                                                                                                           ) ;
            TN( tTitleLastName                      , "lath name"                                                                                                                                           ) ;
            TN( tTitleResidenceCountry              , "residence country"                                                                                                                                   ) ;
            TN( tTitleZipAt                         , "zip at"                                                                                                                                              ) ;
            TN( tTitleCharset                       , "character set"                                                                                                                                       ) ;
            TN( tTitlePaypalPayerEmail              , "PayPal (tm) payer email"                                                                                                                             ) ;
            TN( tTitlePaypalPayerId                 , "PayPal (tm) payer id"                                                                                                                                ) ;
            TN( tTitlePaypalPayerStatus             , "PayPal (tm) payer status"                                                                                                                            ) ;
            TN( tTitlePaypalProtectionEligibility   , "PayPal (tm) protection eligibility"                                                                                                                  ) ;
            TN( tTitleDirectoryGreeting             , "greeting text for directory clicker"                                                                                                                 ) ;
            TN( tTitleHelloGreeting                 , "greeting text for conversation opener from hello@ideafarm.com"                                                                                       ) ;

            TN( tKeyTitle                           , "title."                                                                                                                                              ) ;
            TN( tKeyFlagOwnedByDirectory            , "ownedbydirectory."                                                                                                                                   ) ;
            TN( tKeyFlagReplyEndsConversation       , "replyendsconversation."                                                                                                                              ) ;
            TN( tKeyFlagListInDirectory             , "listindirectory."                                                                                                                                    ) ;
            TN( tKeyFlagListInHello                 , "listinhello."                                                                                                                                    ) ;
            TN( tKeyNameIn                          , "namein."                                                                                                                                             ) ;
            TN( tKeyNameOut                         , "nameout."                                                                                                                                            ) ;
            TN( tKeyEmailRelay                      , "relay."                                                                                                                                              ) ;
            TN( tKeyEmailRelayDrawings              , "relaydrawings."                                                                                                                                      ) ;
            TN( tKeyAutoresponse                    , "autoresponse."                                                                                                                                       ) ;
            TN( tKeyRecipe                          , "recipe."                                                                                                                                             ) ;
            TN( tKeyEmailPenpalExactOr              , "penpalexactor."                                                                                                                                      ) ;
            TN( tKeyEmailPenpalContainsOr           , "penpalcontainsor."                                                                                                                                   ) ;
            TN( tKeyEmailPenpalContainsAnd          , "penpalcontainsand."                                                                                                                                  ) ;

            TN( tKeyAddressName                     , "addressname."                                                                                                                                        ) ;
            TN( tKeyAddressStreet                   , "addressstreet."                                                                                                                                      ) ;
            TN( tKeyAddressCity                     , "addresscity."                                                                                                                                        ) ;
            TN( tKeyAddressState                    , "addressstate."                                                                                                                                       ) ;
            TN( tKeyAddressCountryCode              , "addresscountrycode."                                                                                                                                 ) ;
            TN( tKeyAddressZip                      , "addresszip."                                                                                                                                         ) ;
            TN( tKeyAddressCountry                  , "addresscountry."                                                                                                                                     ) ;
            TN( tKeyAddressStatus                   , "addressstatus."                                                                                                                                      ) ;
            TN( tKeyFirstName                       , "wothname."                                                                                                                                           ) ;
            TN( tKeyLastName                        , "lathname."                                                                                                                                           ) ;
            TN( tKeyResidenceCountry                , "residencecountry."                                                                                                                                   ) ;
            TN( tKeyZipAt                           , "zipat."                                                                                                                                              ) ;
            TN( tKeyCharset                         , "characterset."                                                                                                                                       ) ;
            TN( tKeyPaypalPayerEmail                , "paypalpayeremail."                                                                                                                                   ) ;
            TN( tKeyPaypalPayerId                   , "paypalpayerid."                                                                                                                                      ) ;
            TN( tKeyPaypalPayerStatus               , "paypalpayerstatus."                                                                                                                                  ) ;
            TN( tKeyPaypalProtectionEligibility     , "paypalprotectioneligibility."                                                                                                                        ) ;
            TN( tKeyDirectoryGreeting               , "directorygreeting."                                                                                                                                  ) ;
            TN( tKeyHelloGreeting                   , "hellogreeting."                                                                                                                                      ) ;

            boolT bShowAll = 1 ;
            if( !idSub )
            {
                if( bAllFields )
                {
                    bSaveAcc = bEditAcc = 1 ;
                }
                else if( bFieldMore )
                {
                    bFieldMore = 0 ;
                    bSaveAcc = bEditAcc = 1 ;
                }

                if( bSaveAcc )
                {
                    accountS info( tinP , etThread , idAccount , fliACCOUNTmODE_OWNERcONFIRMED , (strokeS*)0 ) ;
    
                    countT cFlavors = swKVP.cFlavorsF( tinP ) ;
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    {
                        psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
    
                        TN( tYes , "yes" ) ;

                        ZE( strokeS** , ppstto ) ;
                             if( 1 == etThread.strIdF( tinP , tKeyFlagListInDirectory           , psttLeverKVP ) && !etThread.strCompareF( tinP , tYes , *(strokeS**)&(countT&)swKVP ) ) info.flagsMode |= fliACCOUNTmODE_LISTmEdIRECTORY ;
                        else if( 1 == etThread.strIdF( tinP , tKeyFlagListInHello               , psttLeverKVP ) && !etThread.strCompareF( tinP , tYes , *(strokeS**)&(countT&)swKVP ) ) info.flagsMode |= fliACCOUNTmODE_LISTmEhELLO ;
                        else if( 1 == etThread.strIdF( tinP , tKeyAddressName                   , psttLeverKVP ) ) ppstto = &info.psttAddressName                   ;
                        else if( 1 == etThread.strIdF( tinP , tKeyAddressStreet                 , psttLeverKVP ) ) ppstto = &info.psttAddressStreet                 ;
                        else if( 1 == etThread.strIdF( tinP , tKeyAddressCity                   , psttLeverKVP ) ) ppstto = &info.psttAddressCity                   ;
                        else if( 1 == etThread.strIdF( tinP , tKeyAddressState                  , psttLeverKVP ) ) ppstto = &info.psttAddressState                  ;
                        else if( 1 == etThread.strIdF( tinP , tKeyAddressCountryCode            , psttLeverKVP ) ) ppstto = &info.psttAddressCountryCode            ;
                        else if( 1 == etThread.strIdF( tinP , tKeyAddressZip                    , psttLeverKVP ) ) ppstto = &info.psttAddressZip                    ;
                        else if( 1 == etThread.strIdF( tinP , tKeyAddressCountry                , psttLeverKVP ) ) ppstto = &info.psttAddressCountry                ;
                        else if( 1 == etThread.strIdF( tinP , tKeyAddressStatus                 , psttLeverKVP ) ) ppstto = &info.psttAddressStatus                 ;
                        else if( 1 == etThread.strIdF( tinP , tKeyFirstName                     , psttLeverKVP ) ) ppstto = &info.psttFirstName                     ;
                        else if( 1 == etThread.strIdF( tinP , tKeyLastName                      , psttLeverKVP ) ) ppstto = &info.psttLastName                      ;
                        else if( 1 == etThread.strIdF( tinP , tKeyResidenceCountry              , psttLeverKVP ) ) ppstto = &info.psttResidenceCountry              ;
                        else if( 1 == etThread.strIdF( tinP , tKeyZipAt                         , psttLeverKVP ) ) ppstto = &info.psttZipAt                         ;
                        else if( 1 == etThread.strIdF( tinP , tKeyCharset                       , psttLeverKVP ) ) ppstto = &info.psttCharset                       ;
                        else if( 1 == etThread.strIdF( tinP , tKeyPaypalPayerEmail              , psttLeverKVP ) ) ppstto = &info.psttPaypalPayerEmail              ;
                        else if( 1 == etThread.strIdF( tinP , tKeyPaypalPayerId                 , psttLeverKVP ) ) ppstto = &info.psttPaypalPayerId                 ;
                        else if( 1 == etThread.strIdF( tinP , tKeyPaypalPayerStatus             , psttLeverKVP ) ) ppstto = &info.psttPaypalPayerStatus             ;
                        else if( 1 == etThread.strIdF( tinP , tKeyPaypalProtectionEligibility   , psttLeverKVP ) ) ppstto = &info.psttPaypalProtectionEligibility   ;
                        else if( 1 == etThread.strIdF( tinP , tKeyDirectoryGreeting             , psttLeverKVP ) ) ppstto = &info.psttDirectoryGreeting             ;
                        else if( 1 == etThread.strIdF( tinP , tKeyHelloGreeting                 , psttLeverKVP ) ) ppstto = &info.psttHelloGreeting                 ;
    
                        if( ppstto ) { etThread.strMakeF( tinP , LF , *ppstto , *(strokeS**)&(countT&)swKVP ) ; ___( *ppstto ) ; }
                    }
                }

                if( bEditAcc )
                {
                    bShowAll = 0 ;
                    accountS info( tinP , etThread , idAccount ) ;
    
                    if( !POOP )
                    {
                        const boolT bAllFieldsOccupied = 

                            info.psttAddressName                  && info.psttAddressName->idAdam                 &&
                            info.psttAddressStreet                && info.psttAddressStreet->idAdam               &&
                            info.psttAddressCity                  && info.psttAddressCity->idAdam                 &&
                            info.psttAddressState                 && info.psttAddressState->idAdam                &&
                            info.psttAddressCountryCode           && info.psttAddressCountryCode->idAdam          &&
                            info.psttAddressZip                   && info.psttAddressZip->idAdam                  &&
                            info.psttAddressCountry               && info.psttAddressCountry->idAdam              &&
                            info.psttAddressStatus                && info.psttAddressStatus->idAdam               &&
                            info.psttFirstName                    && info.psttFirstName->idAdam                   &&
                            info.psttLastName                     && info.psttLastName->idAdam                    &&
                            info.psttResidenceCountry             && info.psttResidenceCountry->idAdam            &&
                            info.psttZipAt                        && info.psttZipAt->idAdam                       &&
                            info.psttCharset                      && info.psttCharset->idAdam                     &&
                            info.psttPaypalPayerEmail             && info.psttPaypalPayerEmail->idAdam            &&
                            info.psttPaypalPayerId                && info.psttPaypalPayerId->idAdam               &&
                            info.psttPaypalPayerStatus            && info.psttPaypalPayerStatus->idAdam           &&
                            info.psttPaypalProtectionEligibility  && info.psttPaypalProtectionEligibility->idAdam &&
                            info.psttDirectoryGreeting            && info.psttDirectoryGreeting->idAdam           &&
                            info.psttHelloGreeting                && info.psttHelloGreeting->idAdam

                        ;

                        const boolT bNoFieldsOccupied = 

                            ( !info.psttAddressName                  || !info.psttAddressName->idAdam                   ) &&
                            ( !info.psttAddressStreet                || !info.psttAddressStreet->idAdam                 ) &&
                            ( !info.psttAddressCity                  || !info.psttAddressCity->idAdam                   ) &&
                            ( !info.psttAddressState                 || !info.psttAddressState->idAdam                  ) &&
                            ( !info.psttAddressCountryCode           || !info.psttAddressCountryCode->idAdam            ) &&
                            ( !info.psttAddressZip                   || !info.psttAddressZip->idAdam                    ) &&
                            ( !info.psttAddressCountry               || !info.psttAddressCountry->idAdam                ) &&
                            ( !info.psttAddressStatus                || !info.psttAddressStatus->idAdam                 ) &&
                            ( !info.psttFirstName                    || !info.psttFirstName->idAdam                     ) &&
                            ( !info.psttLastName                     || !info.psttLastName->idAdam                      ) &&
                            ( !info.psttResidenceCountry             || !info.psttResidenceCountry->idAdam              ) &&
                            ( !info.psttZipAt                        || !info.psttZipAt->idAdam                         ) &&
                            ( !info.psttCharset                      || !info.psttCharset->idAdam                       ) &&
                            ( !info.psttPaypalPayerEmail             || !info.psttPaypalPayerEmail->idAdam              ) &&
                            ( !info.psttPaypalPayerId                || !info.psttPaypalPayerId->idAdam                 ) &&
                            ( !info.psttPaypalPayerStatus            || !info.psttPaypalPayerStatus->idAdam             ) &&
                            ( !info.psttPaypalProtectionEligibility  || !info.psttPaypalProtectionEligibility->idAdam   ) &&
                            ( !info.psttDirectoryGreeting            || !info.psttDirectoryGreeting->idAdam             ) &&
                            ( !info.psttHelloGreeting                || !info.psttHelloGreeting->idAdam                 )

                        ;

                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT93 ) ;
                        meP.pushSnipF( tinP , stBodyP , psttEmail ) ;
                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTa3 ) ;
                        if( !bAllFieldsOccupied && !bAllFields ) { meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTb3 ) ; }
                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTc3 ) ;

                        //FOR EACH FIELD:
                        {
                            flagsT flagsSay = flSAYfIELDeDIT_ACCOUNT | flSAYfIELDeDIT_WOTH ;
                            ZE( countT   , cExtra    ) ;
                            ZE( countT   , idBoxLath ) ;
                            ZE( osTextT* , postsw    ) ;
                            ZE( countT , cNew ) ;

                            if( !bAllFields && bNoFieldsOccupied )
                            {
                                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTd3 ) ;
                                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT34 ) ;
                                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTe3 ) ;
                                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT44 ) ;
                                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTf3 ) ;
                            }
                            else
                            {
                                //FIELDS THAT THE ACCOUNT OWNER IS ALLOWED TO MODIFY
                                flagsSay |= flSAYfIELDeDIT_CHECKBOX ;
                                meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleFlagListInDirectory , tKeyFlagListInDirectory , flagsSay , ifcIDsNIPpREDEFINED_HELP52 , 0 , (strokeS*)!!( F(info.flagsMode) & fliACCOUNTmODE_LISTmEdIRECTORY ) ) ;
                                meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleFlagListInHello     , tKeyFlagListInHello     , flagsSay , ifcIDsNIPpREDEFINED_HELP82 , 0 , (strokeS*)!!( F(info.flagsMode) & fliACCOUNTmODE_LISTmEhELLO     ) ) ;
                                flagsSay &= ~( F(flSAYfIELDeDIT_CHECKBOX) ) ;
                                if( bAllFields || ( info.psttDirectoryGreeting            && info.psttDirectoryGreeting->idAdam           ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleDirectoryGreeting           , tKeyDirectoryGreeting              , flagsSay , ifcIDsNIPpREDEFINED_HELP62 , 0 , info.psttDirectoryGreeting               ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttHelloGreeting                && info.psttHelloGreeting->idAdam               ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleDirectoryGreeting           , tKeyHelloGreeting                  , flagsSay , ifcIDsNIPpREDEFINED_HELP72 , 0 , info.psttHelloGreeting                   ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttZipAt                        && info.psttZipAt->idAdam                       ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleZipAt                       , tKeyZipAt                          , flagsSay , ifcIDsNIPpREDEFINED_HELPf1 , 0 , info.psttZipAt                           ) ; idBoxLath = 0 ; }
    
                                //FIELDS THAT THE ACCOUNT OWNER IS NOT ALLOWED TO MODIFY
                                flagsSay |= flSAYfIELDeDIT_LOCKED ;
                                if( bAllFields || ( info.psttAddressName                  && info.psttAddressName->idAdam                 ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleAddressName                 , tKeyAddressName                    , flagsSay , ifcIDsNIPpREDEFINED_HELP41 , 0 , info.psttAddressName                     ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttAddressStreet                && info.psttAddressStreet->idAdam               ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleAddressStreet               , tKeyAddressStreet                  , flagsSay , ifcIDsNIPpREDEFINED_HELP51 , 0 , info.psttAddressStreet                   ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttAddressCity                  && info.psttAddressCity->idAdam                 ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleAddressCity                 , tKeyAddressCity                    , flagsSay , ifcIDsNIPpREDEFINED_HELP61 , 0 , info.psttAddressCity                     ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttAddressState                 && info.psttAddressState->idAdam                ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleAddressState                , tKeyAddressState                   , flagsSay , ifcIDsNIPpREDEFINED_HELP71 , 0 , info.psttAddressState                    ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttAddressCountryCode           && info.psttAddressCountryCode->idAdam          ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleAddressCountryCode          , tKeyAddressCountryCode             , flagsSay , ifcIDsNIPpREDEFINED_HELP81 , 0 , info.psttAddressCountryCode              ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttAddressZip                   && info.psttAddressZip->idAdam                  ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleAddressZip                  , tKeyAddressZip                     , flagsSay , ifcIDsNIPpREDEFINED_HELP91 , 0 , info.psttAddressZip                      ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttAddressCountry               && info.psttAddressCountry->idAdam              ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleAddressCountry              , tKeyAddressCountry                 , flagsSay , ifcIDsNIPpREDEFINED_HELPa1 , 0 , info.psttAddressCountry                  ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttAddressStatus                && info.psttAddressStatus->idAdam               ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleAddressStatus               , tKeyAddressStatus                  , flagsSay , ifcIDsNIPpREDEFINED_HELPb1 , 0 , info.psttAddressStatus                   ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttFirstName                    && info.psttFirstName->idAdam                   ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleFirstName                   , tKeyFirstName                      , flagsSay , ifcIDsNIPpREDEFINED_HELPc1 , 0 , info.psttFirstName                       ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttLastName                     && info.psttLastName->idAdam                    ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleLastName                    , tKeyLastName                       , flagsSay , ifcIDsNIPpREDEFINED_HELPd1 , 0 , info.psttLastName                        ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttResidenceCountry             && info.psttResidenceCountry->idAdam            ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleResidenceCountry            , tKeyResidenceCountry               , flagsSay , ifcIDsNIPpREDEFINED_HELPe1 , 0 , info.psttResidenceCountry                ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttCharset                      && info.psttCharset->idAdam                     ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleCharset                     , tKeyCharset                        , flagsSay , ifcIDsNIPpREDEFINED_HELP02 , 0 , info.psttCharset                         ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttPaypalPayerEmail             && info.psttPaypalPayerEmail->idAdam            ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitlePaypalPayerEmail            , tKeyPaypalPayerEmail               , flagsSay , ifcIDsNIPpREDEFINED_HELP12 , 0 , info.psttPaypalPayerEmail                ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttPaypalPayerId                && info.psttPaypalPayerId->idAdam               ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitlePaypalPayerId               , tKeyPaypalPayerId                  , flagsSay , ifcIDsNIPpREDEFINED_HELP22 , 0 , info.psttPaypalPayerId                   ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttPaypalPayerStatus            && info.psttPaypalPayerStatus->idAdam           ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitlePaypalPayerStatus           , tKeyPaypalPayerStatus              , flagsSay , ifcIDsNIPpREDEFINED_HELP32 , 0 , info.psttPaypalPayerStatus               ) ; idBoxLath = 0 ; }
                                if( bAllFields || ( info.psttPaypalProtectionEligibility  && info.psttPaypalProtectionEligibility->idAdam ) ) { meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitlePaypalProtectionEligibility , tKeyPaypalProtectionEligibility    , flagsSay , ifcIDsNIPpREDEFINED_HELP42 , 0 , info.psttPaypalProtectionEligibility     ) ; idBoxLath = 0 ; }
                            }
                        }
                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT72 ) ;
                    }
                }
            }
            else
            {
                TN( tEmailSub , "" ) ; tEmailSub = tSubaccount+tDot+T(psttIdAccount)+T(".doubleblind.1@ideafarm.com") ;

                if( bAllFields ) bSaveSub = bEditSub = 1 ;
                else if( bFieldMore )
                {
                    bFieldMore = 0 ;
                    bSaveSub = bEditSub = 1 ;
                }

                if( bSaveSub )
                {
                    ZE( stackC* , pStkTitle ) ;
                    ZE( stackC* , pStkFlagOwnedByDirectory      ) ;
                    ZE( stackC* , pStkFlagReplyEndsConversation ) ;
                    ZE( stackC* , pStkNameIn ) ;
                    ZE( stackC* , pStkNameOut ) ;
                    ZE( stackC* , pStkEmailRelay ) ;
                    ZE( stackC* , pStkEmailRelayDrawings ) ;
                    ZE( stackC* , pStkAutoresponse ) ;
                    ZE( stackC* , pStkRecipe ) ;
                    ZE( stackC* , pStkEmailPenpalExactOr ) ;
                    ZE( stackC* , pStkEmailPenpalContainsOr ) ;
                    ZE( stackC* , pStkEmailPenpalContainsAnd ) ;

                    etThread( tinP , pStkTitle                     , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkTitle                     ) ;
                    etThread( tinP , pStkFlagOwnedByDirectory      , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkFlagOwnedByDirectory      ) ;
                    etThread( tinP , pStkFlagReplyEndsConversation , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkFlagReplyEndsConversation ) ;
                    etThread( tinP , pStkNameIn                    , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkNameIn                    ) ;
                    etThread( tinP , pStkNameOut                   , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkNameOut                   ) ;
                    etThread( tinP , pStkEmailRelay                , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkEmailRelay                ) ;
                    etThread( tinP , pStkEmailRelayDrawings        , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_countT      ) ; ___( pStkEmailRelayDrawings        ) ;
                    etThread( tinP , pStkAutoresponse              , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkAutoresponse              ) ;
                    etThread( tinP , pStkRecipe                    , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkRecipe                    ) ;
                    etThread( tinP , pStkEmailPenpalExactOr        , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkEmailPenpalExactOr        ) ;
                    etThread( tinP , pStkEmailPenpalContainsOr     , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkEmailPenpalContainsOr     ) ;
                    etThread( tinP , pStkEmailPenpalContainsAnd    , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkEmailPenpalContainsAnd    ) ;

                    if
                    (
                        pStkTitle                      &&
                        pStkFlagOwnedByDirectory       &&
                        pStkFlagReplyEndsConversation  &&
                        pStkNameIn                     &&
                        pStkNameOut                    &&
                        pStkEmailRelay                 &&
                        pStkEmailRelayDrawings         &&
                        pStkAutoresponse               &&
                        pStkRecipe                     &&
                        pStkEmailPenpalExactOr         &&
                        pStkEmailPenpalContainsOr      &&
                        pStkEmailPenpalContainsAnd
                    )
                    {
                        countT cFlavors = swKVP.cFlavorsF( tinP ) ;
                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        {
                            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;

                            ZE( boolT , bArea ) ;
                            ZE( boolT , bCount ) ;
                            ZE( stackC* , pStko ) ;
                            if( psttLeverKVP )
                            {
                                     if( 1 == etThread.strIdF( tinP , tKeyTitle                     , psttLeverKVP ) )   pStko = pStkTitle                     ;
                                else if( 1 == etThread.strIdF( tinP , tKeyFlagOwnedByDirectory      , psttLeverKVP ) )   pStko = pStkFlagOwnedByDirectory      ;
                                else if( 1 == etThread.strIdF( tinP , tKeyFlagReplyEndsConversation , psttLeverKVP ) )   pStko = pStkFlagReplyEndsConversation ;
                                else if( 1 == etThread.strIdF( tinP , tKeyNameIn                    , psttLeverKVP ) )   pStko = pStkNameIn                    ;
                                else if( 1 == etThread.strIdF( tinP , tKeyNameOut                   , psttLeverKVP ) )   pStko = pStkNameOut                   ;
                                else if( 1 == etThread.strIdF( tinP , tKeyEmailRelay                , psttLeverKVP ) )   pStko = pStkEmailRelay                ;
                                else if( 1 == etThread.strIdF( tinP , tKeyEmailRelayDrawings        , psttLeverKVP ) ) { pStko = pStkEmailRelayDrawings        ; bCount = 1 ; }
                                else if( 1 == etThread.strIdF( tinP , tKeyAutoresponse              , psttLeverKVP ) ) { pStko = pStkAutoresponse              ; bArea  = 1 ; }
                                else if( 1 == etThread.strIdF( tinP , tKeyRecipe                    , psttLeverKVP ) )   pStko = pStkRecipe                    ;
                                else if( 1 == etThread.strIdF( tinP , tKeyEmailPenpalExactOr        , psttLeverKVP ) )   pStko = pStkEmailPenpalExactOr        ;
                                else if( 1 == etThread.strIdF( tinP , tKeyEmailPenpalContainsOr     , psttLeverKVP ) )   pStko = pStkEmailPenpalContainsOr     ;
                                else if( 1 == etThread.strIdF( tinP , tKeyEmailPenpalContainsAnd    , psttLeverKVP ) )   pStko = pStkEmailPenpalContainsAnd    ;
                            }
    
                            if( pStko )
                            {
                                strokeS*& zsttv = *(strokeS**)&(countT&)swKVP ;
                                if( bCount )
                                {
                                    if( zsttv )
                                    {
                                        countT vv = etThread.strDigitsToSCountF( tinP , zsttv ) ;
                                        if( vv ) *pStko << vv ;
                                    }
                                }
                                else
                                {
                                    if( zsttv && !bArea ) { etThread.strTrimF( tinP , zsttv , 0 , T(TbLACKnEWlINE) ) ; ___( zsttv ) ; }
                                    strokeS* psttc = psttOldC( tinP , etThread , zsttv ) ; ___( psttc ) ;
                                    *pStko << psttc ;
                                }
                            }
                        }
                    }

                    if( *pStkTitle && *pStkNameIn && *pStkNameOut )
                    {
                        ZE( strokeS* , psttTitle ) ;
                        ZE( strokeS* , psttNameIn ) ;
                        ZE( strokeS* , psttNameOut ) ;
                        *pStkTitle   >> psttTitle   ; ___( psttTitle   ) ;
                        *pStkNameIn  >> psttNameIn  ; ___( psttNameIn  ) ;
                        *pStkNameOut >> psttNameOut ; ___( psttNameOut ) ;

                        flagsT flagsMode = fliSUBACCOUNTmODE_OWNERcONFIRMED ;
                        if( *pStkFlagOwnedByDirectory )
                        {
                            ZE( strokeS* , psttv ) ;
                            *pStkFlagOwnedByDirectory >> psttv ;
                            if( !etThread.strCompareF( tinP , psttv , T("yes") ) ) flagsMode |= fliSUBACCOUNTmODE_OWNEDbYdIRECTORYoRhELLO ;
                        }
                        if( *pStkFlagReplyEndsConversation )
                        {
                            ZE( strokeS* , psttv ) ;
                            *pStkFlagReplyEndsConversation >> psttv ;
                            if( !etThread.strCompareF( tinP , psttv , T("yes") ) ) flagsMode |= fliSUBACCOUNTmODE_RELAYrEPLYeNDScONVERSATION ;
                        }

                        subaccountS info( tinP , etThread , idAccount , idSub , psttTitle , psttNameIn , psttNameOut , flagsMode ) ;
                        etThread.delF( tinP , psttTitle ) ;
                        etThread.delF( tinP , psttNameIn ) ;
                        etThread.delF( tinP , psttNameOut ) ;

                        pushFieldValuesF( tinP , *info.pStkEmailRelay             , *pStkEmailRelay             ) ;
                        if( *pStkEmailRelayDrawings ) *pStkEmailRelayDrawings >> info.cEmailRelayDrawings ; //DROP DOWN MENU WILL NOT APPEAR IF < 2 RELAYS
                        pushFieldValuesF( tinP , *info.pStkAutoresponse           , *pStkAutoresponse           ) ;
                        pushFieldValuesF( tinP , *info.pStkRecipe                 , *pStkRecipe                 ) ;
                        pushFieldValuesF( tinP , *info.pStkEmailPenpalExactOr     , *pStkEmailPenpalExactOr     ) ;
                        pushFieldValuesF( tinP , *info.pStkEmailPenpalContainsOr  , *pStkEmailPenpalContainsOr  ) ;
                        pushFieldValuesF( tinP , *info.pStkEmailPenpalContainsAnd , *pStkEmailPenpalContainsAnd ) ;
                    }

                    { _IO_ etThread( tinP , pStkTitle                      ) ; }
                    { _IO_ etThread( tinP , pStkFlagOwnedByDirectory       ) ; }
                    { _IO_ etThread( tinP , pStkFlagReplyEndsConversation  ) ; }
                    { _IO_ etThread( tinP , pStkNameIn                     ) ; }
                    { _IO_ etThread( tinP , pStkNameOut                    ) ; }
                    { _IO_ etThread( tinP , pStkEmailRelay                 ) ; }
                    { _IO_ etThread( tinP , pStkEmailRelayDrawings         ) ; }
                    { _IO_ etThread( tinP , pStkAutoresponse               ) ; }
                    { _IO_ etThread( tinP , pStkRecipe                     ) ; }
                    { _IO_ etThread( tinP , pStkEmailPenpalExactOr         ) ; }
                    { _IO_ etThread( tinP , pStkEmailPenpalContainsOr      ) ; }
                    { _IO_ etThread( tinP , pStkEmailPenpalContainsAnd     ) ; }
                }

                if( bSpamSub )
                {
                    subaccountS sub( tinP , etThread , idAccount , idSub , flSUBACCOUNT_QUERYeMAILpENPALeXACToR ) ;

                    TN( tSpammer , "" ) ;

                    if( sub.pStkEmailPenpalExactOr ) while( *sub.pStkEmailPenpalExactOr )
                    {
                        ZE( strokeS* , psttw ) ;
                        *sub.pStkEmailPenpalExactOr >> psttw ;
                        tSpammer = T(psttw) ;
                        etThread.delF( tinP , psttw ) ;
                        break ;
                    }

                    TN( tSay , "" ) ; tSay = T(

                        "Subject: Complaint of abuse\r\n"
                        "\r\n"
                        "\"")+T(psttEmail)+T("\" reports that \"")+tSpammer+T("\" has abused the subaccount that is managed by IdeaFarm " "(tm) Directory for his exclusive use."

                    ) ;

                    etThread.boxPutF( tinP , T("//smtp/" ifcEMAIL_WEBsITEcOMPLAINTfORWARDER "/" ifcEMAIL_WEBmASTER) , tSay , tSay.csF( tinP ) ) ;
                    //bDeleteSub = 1 ;
                }

                if( bDeleteSub )
                {
                    socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                    sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
                
                    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
                    sOut << (countT)FINGERnEG_LISTsERVERcMD ;
                    sOut << (countT)1 ;
                    sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_DELETEsUBACCOUNTdESCRIPTION ;
                    sOut << idAccount ;
                    sOut << idSub ;
                    sock.writeF( tinP , sOut ) ;
                
                    soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                    sock.readF( tinP , sIn ) ;
                
                    ZE( countT , finger ) ;
                    sIn >> finger ;
                    __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
                
                    ZE( countT , idFormat ) ;
                    sIn >> idFormat ;
                    __( idFormat - 1 ) ;
                
                    ZE( boolT , bDone ) ;
                    sIn >> bDone ;
                    __Z( bDone ) ;
                }
                else if( bEditSub )
                {
                    bShowAll = 0 ;
                    subaccountS info( tinP , etThread , idAccount , idSub ) ;

                    if( !POOP && F(info.flagsMode) & fliSUBACCOUNTmODE_OWNERcONFIRMED && !( F(info.flagsMode) & fliSUBACCOUNTmODE_DELETED ) )
                    {
                        const boolT bAllFieldsOccupied = 

                            *info.pStkEmailRelay                     &&
                            *info.pStkAutoresponse                   &&
                            *info.pStkRecipe                         &&
                            *info.pStkEmailPenpalExactOr             &&
                            *info.pStkEmailPenpalContainsOr          &&
                            *info.pStkEmailPenpalContainsAnd

                        ;

                        meP.pushSnipF( tinP , stBodyP , idSnipParagraph ) ;
                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT91 ) ;
                        meP.pushSnipF( tinP , stBodyP , tEmailSub ) ;
                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTa1 ) ;
                        meP.pushSnipF( tinP , stBodyP , tSubaccount ) ;
                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTb1 ) ;
                        if( !bAllFieldsOccupied && !bAllFields ) { meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTc1 ) ; }
                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTd1 ) ;

                        flagsT flagsSay = flSAYfIELDeDIT_WOTH ;
                        ZE( countT   , cExtra    ) ;
                        ZE( countT   , idBoxLath ) ;
                        ZE( osTextT* , postsw    ) ;
                        ZE( countT , cNew ) ;
                        meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleTitle , tKeyTitle , flagsSay , ifcIDsNIPpREDEFINED_HELP4 , 0 , info.psttTitle ) ;

                        flagsSay |= flSAYfIELDeDIT_CHECKBOX ;
                        idBoxLath = 0 ;
                        meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleFlagOwnedByDirectory , tKeyFlagOwnedByDirectory , flagsSay , ifcIDsNIPpREDEFINED_HELP31 , 0 , (strokeS*)!!( F(info.flagsMode) & fliSUBACCOUNTmODE_OWNEDbYdIRECTORYoRhELLO ) ) ;
                        idBoxLath = 0 ;
                        meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleFlagReplyEndsConversation , tKeyFlagReplyEndsConversation , flagsSay , ifcIDsNIPpREDEFINED_HELP31 , 0 , (strokeS*)!!( F(info.flagsMode) & fliSUBACCOUNTmODE_RELAYrEPLYeNDScONVERSATION ) ) ;
                        flagsSay &= ~( F(flSAYfIELDeDIT_CHECKBOX) ) ;

                        idBoxLath = 0 ;
                        meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleNameIn , tKeyNameIn , flagsSay , ifcIDsNIPpREDEFINED_HELP5 , 0 , info.psttNameIn ) ;
                        idBoxLath = 0 ;
                        meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleNameOut , tKeyNameOut , flagsSay , ifcIDsNIPpREDEFINED_HELP6 , 0 , info.psttNameOut ) ;

                        TN( tCol2 , "" ) ;

                        flagsSay |= flSAYfIELDeDIT_MOREaLLOWED ;
                        PROLOGeDIT( EmailRelay )
                        ZE( countT , idRow ) ;
                        const countT cRelays = cNew ;
                        while( *info.pStkEmailRelay )
                        {
                            SETcOL2EMAILrELAY( info.cEmailRelayDrawings )

                            ZE( strokeS* , psttEmailRelay ) ;
                            *info.pStkEmailRelay >> psttEmailRelay ; ___( psttEmailRelay ) ;
                            meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleEmailRelay , tKeyEmailRelay , flagsSay , ifcIDsNIPpREDEFINED_HELP7 , ifcIDsNIPpREDEFINED_HELPe , psttEmailRelay , tCol2 ) ;
                            if( F(flagsSay) & flSAYfIELDeDIT_WOTH ) flagsSay &= ~F(flSAYfIELDeDIT_WOTH) ;
                            etThread.delF( tinP , psttEmailRelay ) ;

                            if( idRow == 2 ) tCol2 = T("") ;
                        }
                        while( cExtra -- )
                        {
                            SETcOL2EMAILrELAY( info.cEmailRelayDrawings )
                            meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleEmailRelay , tKeyEmailRelay , flagsSay , ifcIDsNIPpREDEFINED_HELP8 , ifcIDsNIPpREDEFINED_HELPe , 0 , tCol2 ) ;
                        }

                        flagsSay |= flSAYfIELDeDIT_AREA ;
                        flagsSay &= ~F(flSAYfIELDeDIT_MOREaLLOWED) ;
                        PROLOGeDIT( Autoresponse )
                        while( *info.pStkAutoresponse )
                        {
                            ZE( strokeS* , psttAutoresponse ) ;
                            *info.pStkAutoresponse >> psttAutoresponse ; ___( psttAutoresponse ) ;
                            meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleAutoresponse , tKeyAutoresponse , flagsSay , ifcIDsNIPpREDEFINED_HELP9 , 0 , psttAutoresponse ) ;
                            if( F(flagsSay) & flSAYfIELDeDIT_WOTH ) flagsSay &= ~F(flSAYfIELDeDIT_WOTH) ;
                            etThread.delF( tinP , psttAutoresponse ) ;
                        }
                        EPILOGeDIT( Autoresponse , ifcIDsNIPpREDEFINED_HELP9 , 0 , 0 )
                        flagsSay |= flSAYfIELDeDIT_MOREaLLOWED ;
                        flagsSay &= ~F(flSAYfIELDeDIT_AREA) ;

                        if( idAccount == 1 )
                        {
                            PROLOGeDIT( Recipe )
                            while( *info.pStkRecipe )
                            {
                                ZE( strokeS* , psttRecipe ) ;
                                *info.pStkRecipe >> psttRecipe ; ___( psttRecipe ) ;
                                meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleRecipe , tKeyRecipe , flagsSay , ifcIDsNIPpREDEFINED_HELPa , ifcIDsNIPpREDEFINED_HELPf , psttRecipe ) ;
                                if( F(flagsSay) & flSAYfIELDeDIT_WOTH ) flagsSay &= ~F(flSAYfIELDeDIT_WOTH) ;
                                etThread.delF( tinP , psttRecipe ) ;
                            }
                            EPILOGeDIT( Recipe , ifcIDsNIPpREDEFINED_HELPa , ifcIDsNIPpREDEFINED_HELPf , 0 )
                        }

                        PROLOGeDIT( EmailPenpalExactOr )
                        while( *info.pStkEmailPenpalExactOr )
                        {
                            ZE( strokeS* , psttEmailPenpalExactOr ) ;
                            *info.pStkEmailPenpalExactOr >> psttEmailPenpalExactOr ; ___( psttEmailPenpalExactOr ) ;
                            meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleEmailPenpalExactOr , tKeyEmailPenpalExactOr , flagsSay , ifcIDsNIPpREDEFINED_HELPb , ifcIDsNIPpREDEFINED_HELP01 , psttEmailPenpalExactOr ) ;
                            if( F(flagsSay) & flSAYfIELDeDIT_WOTH ) flagsSay &= ~F(flSAYfIELDeDIT_WOTH) ;
                            etThread.delF( tinP , psttEmailPenpalExactOr ) ;
                        }
                        EPILOGeDIT( EmailPenpalExactOr , ifcIDsNIPpREDEFINED_HELPb , ifcIDsNIPpREDEFINED_HELP01 , 0 )

                        PROLOGeDIT( EmailPenpalContainsOr )
                        while( *info.pStkEmailPenpalContainsOr )
                        {
                            ZE( strokeS* , psttEmailPenpalContainsOr ) ;
                            *info.pStkEmailPenpalContainsOr >> psttEmailPenpalContainsOr ; ___( psttEmailPenpalContainsOr ) ;
                            meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleEmailPenpalContainsOr , tKeyEmailPenpalContainsOr , flagsSay , ifcIDsNIPpREDEFINED_HELPc , ifcIDsNIPpREDEFINED_HELP11 , psttEmailPenpalContainsOr ) ;
                            if( F(flagsSay) & flSAYfIELDeDIT_WOTH ) flagsSay &= ~F(flSAYfIELDeDIT_WOTH) ;
                            etThread.delF( tinP , psttEmailPenpalContainsOr ) ;
                        }
                        EPILOGeDIT( EmailPenpalContainsOr , ifcIDsNIPpREDEFINED_HELPc , ifcIDsNIPpREDEFINED_HELP11 , 0 )

                        PROLOGeDIT( EmailPenpalContainsAnd )
                        while( *info.pStkEmailPenpalContainsAnd )
                        {
                            ZE( strokeS* , psttEmailPenpalContainsAnd ) ;
                            *info.pStkEmailPenpalContainsAnd >> psttEmailPenpalContainsAnd ; ___( psttEmailPenpalContainsAnd ) ;
                            meP.sayFieldEditF( tinP , stBodyP , idBoxLath , tTitleEmailPenpalContainsAnd , tKeyEmailPenpalContainsAnd , flagsSay , ifcIDsNIPpREDEFINED_HELPd , ifcIDsNIPpREDEFINED_HELP21 , psttEmailPenpalContainsAnd ) ;
                            if( F(flagsSay) & flSAYfIELDeDIT_WOTH ) flagsSay &= ~F(flSAYfIELDeDIT_WOTH) ;
                            etThread.delF( tinP , psttEmailPenpalContainsAnd ) ;
                        }
                        EPILOGeDIT( EmailPenpalContainsAnd , ifcIDsNIPpREDEFINED_HELPd , ifcIDsNIPpREDEFINED_HELP21 , 0 )
                    }

                    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT62 ) ;
                }
            }

            if( bShowAll )
            {
                {
                    socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                    sock.connectF( tinP , homeS::homeIF().idPortListServerEmailIdAccount ) ;
                
                    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
                    sOut << (countT)FINGERnEG_LISTsERVERcMD ;
                    sOut << (countT)1 ;
                    sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKeMAILfROMiDaCCOUNT ;
                    sOut << idAccount ;
                    sock.writeF( tinP , sOut ) ;
                
                    soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                    sock.readF( tinP , sIn ) ;
                
                    ZE( countT , finger ) ;
                    sIn >> finger ;
                    __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
                
                    ZE( countT , idFormat ) ;
                    sIn >> idFormat ;
                    __( idFormat - 1 ) ;
                
                    ZE( strokeS* , psttEmailOwner ) ;
                    sIn >> psttEmailOwner ; ___( psttEmailOwner ) ;
                    __( tinP.pEtScratch->strCompareF( tinP , psttEmail , psttEmailOwner ) ) ;
                    tinP.pEtScratch->delF( tinP , psttEmailOwner ) ;
                }

                if( !POOP )
                {
                    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT2 ) ;
                    meP.pushSnipF( tinP , stBodyP , psttIdAccount ) ;
                    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT3 ) ;
                    meP.pushSnipF( tinP , stBodyP , psttEmail ) ;
                    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT4 ) ;
    
                    {
                        accountS info( tinP , etThread , idAccount ) ;
                        if( !POOP )
                        {
                            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT04 ) ;
                            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT34 ) ;
                            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTe3 ) ;
                            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT44 ) ;
                            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT14 ) ;
                            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT63 ) ;
                            meP.pushSnipF( tinP , stBodyP , psttEmail ) ;
                            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT73 ) ;

                            ZE( osTextT* , postsw ) ;

                            const boolT bNoFieldsOccupied = 
    
                                ( !info.psttAddressName                 || !info.psttAddressName->idAdam                  ) &&
                                ( !info.psttAddressStreet               || !info.psttAddressStreet->idAdam                ) &&
                                ( !info.psttAddressCity                 || !info.psttAddressCity->idAdam                  ) &&
                                ( !info.psttAddressState                || !info.psttAddressState->idAdam                 ) &&
                                ( !info.psttAddressCountryCode          || !info.psttAddressCountryCode->idAdam           ) &&
                                ( !info.psttAddressZip                  || !info.psttAddressZip->idAdam                   ) &&
                                ( !info.psttAddressCountry              || !info.psttAddressCountry->idAdam               ) &&
                                ( !info.psttAddressStatus               || !info.psttAddressStatus->idAdam                ) &&
                                ( !info.psttFirstName                   || !info.psttFirstName->idAdam                    ) &&
                                ( !info.psttLastName                    || !info.psttLastName->idAdam                     ) &&
                                ( !info.psttResidenceCountry            || !info.psttResidenceCountry->idAdam             ) &&
                                ( !info.psttZipAt                       || !info.psttZipAt->idAdam                        ) &&
                                ( !info.psttCharset                     || !info.psttCharset->idAdam                      ) &&
                                ( !info.psttPaypalPayerEmail            || !info.psttPaypalPayerEmail->idAdam             ) &&
                                ( !info.psttPaypalPayerId               || !info.psttPaypalPayerId->idAdam                ) &&
                                ( !info.psttPaypalPayerStatus           || !info.psttPaypalPayerStatus->idAdam            ) &&
                                ( !info.psttPaypalProtectionEligibility || !info.psttPaypalProtectionEligibility->idAdam  ) &&
                                ( !info.psttDirectoryGreeting           || !info.psttDirectoryGreeting->idAdam            ) &&
                                ( !info.psttHelloGreeting               || !info.psttHelloGreeting->idAdam                )
    
                            ;

                            if( bNoFieldsOccupied )
                            {
                                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT34 ) ;
                                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT24 ) ;
                                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT44 ) ;
                            }
                            else
                            {
                                {
                                    TN( tMode , F(info.flagsMode) & fliACCOUNTmODE_LISTmEdIRECTORY
                                        ? "i am listed in " postIFD "<BR>"
                                        : "i am not listed in " postIFD "<BR>"
                                    ) ;
    
                                    meP.pushSnipF( tinP , stBodyP , tMode ) ;
                                }
                                {
                                    TN( tMode , F(info.flagsMode) & fliACCOUNTmODE_LISTmEhELLO
                                        ? "i am listed in " postIFH "<BR>"
                                        : "i am not listed in " postIFH "<BR>"
                                    ) ;
    
                                    meP.pushSnipF( tinP , stBodyP , tMode ) ;
                                }
                                meP.sayFieldF( tinP , stBodyP , tTitleDirectoryGreeting               , info.psttDirectoryGreeting               ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleHelloGreeting                   , info.psttHelloGreeting                   ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleAddressName                     , info.psttAddressName                     ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleAddressStreet                   , info.psttAddressStreet                   ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleAddressCity                     , info.psttAddressCity                     ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleAddressState                    , info.psttAddressState                    ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleAddressCountryCode              , info.psttAddressCountryCode              ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleAddressZip                      , info.psttAddressZip                      ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleAddressCountry                  , info.psttAddressCountry                  ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleAddressStatus                   , info.psttAddressStatus                   ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleFirstName                       , info.psttFirstName                       ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleLastName                        , info.psttLastName                        ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleResidenceCountry                , info.psttResidenceCountry                ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleZipAt                           , info.psttZipAt                           ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleCharset                         , info.psttCharset                         ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitlePaypalPayerEmail                , info.psttPaypalPayerEmail                ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitlePaypalPayerId                   , info.psttPaypalPayerId                   ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitlePaypalPayerStatus               , info.psttPaypalPayerStatus               ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitlePaypalProtectionEligibility     , info.psttPaypalProtectionEligibility     ) ;
                            }

                            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT83 ) ;
                        }
                    }

                    //CONoUTrAW( "compiling report\r\n" ) ;
                    {
                        //CONoUTrAW( "querying enumeration of idSub\r\n" ) ;
                        TN( tcr , "\r\n" ) ;

                        stkIdSubC stkIdSub( tinP , idAccount ) ;
                        while( stkIdSub )
                        {
                            ZE( countT , idSub ) ;
                            stkIdSub >> idSub ;
                            //CONoUTrAW3( "enumeration [idSub]: " , idSub , "\r\n" ) ;
    
                            subaccountS info( tinP , etThread , idAccount , idSub ) ;
                            if( !POOP && F(info.flagsMode) & fliSUBACCOUNTmODE_OWNERcONFIRMED && !( F(info.flagsMode) & fliSUBACCOUNTmODE_DELETED ) )
                            {
                                {
                                    ZE( pbRefC* , prPostsEmailSub ) ;
                                    etThread.strMakeF( tinP , LF , prPostsEmailSub , TF4(idSub,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+tSuffix , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsEmailSub ) ;

                                    ZE( pbRefC* , prPostsIdSub ) ;
                                    etThread.strMakeF( tinP , LF , prPostsIdSub , TF4(idSub,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36) , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPostsIdSub ) ;
                
                                    if( prPostsEmailSub && prPostsIdSub )
                                    {
                                        meP.pushSnipF( tinP , stBodyP , idSnipParagraph ) ;
                                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTe ) ;
                                        meP.pushSnipF( tinP , stBodyP , *prPostsEmailSub ) ;
                                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNTf ) ;
                                        meP.pushSnipF( tinP , stBodyP , *prPostsIdSub ) ;
                                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT01 ) ;

                                        if( !( F(info.flagsMode) & fliSUBACCOUNTmODE_OWNEDbYdIRECTORYoRhELLO ) )
                                        {
                                            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT11 ) ;
                                            meP.pushSnipF( tinP , stBodyP , *prPostsIdSub ) ;
                                            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT21 ) ;
                                        }

                                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT31 ) ;
                                        meP.pushSnipF( tinP , stBodyP , *prPostsIdSub ) ;
                                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT41 ) ;
                                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT51 ) ;
                                        meP.pushSnipF( tinP , stBodyP , *prPostsIdSub ) ;
                                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT61 ) ;
                                        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT71 ) ;
                                    }
                                    DEL( prPostsEmailSub ) ;
                                    DEL( prPostsIdSub ) ;
                                }
        
                                ZE( osTextT* , postsw ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleTitle   , info.psttTitle   ) ;
    
                                if( F(info.flagsMode) & fliSUBACCOUNTmODE_OWNEDbYdIRECTORYoRhELLO ) meP.pushSnipF( tinP , stBodyP , T("directory clicker<BR>") ) ;
    
                                {
                                    TN( tMode , F(info.flagsMode) & fliSUBACCOUNTmODE_RELAYrEPLYeNDScONVERSATION
                                        ? "reply from relay ends conversation<BR>"
                                        : "reply from relay continues conversation<BR>"
                                    ) ;
    
                                    meP.pushSnipF( tinP , stBodyP , tMode ) ;
                                }

                                meP.sayFieldF( tinP , stBodyP , tTitleNameIn  , info.psttNameIn  ) ;
                                meP.sayFieldF( tinP , stBodyP , tTitleNameOut , info.psttNameOut ) ;
    
                                const countT cRelays = *info.pStkEmailRelay ;
                                while( *info.pStkEmailRelay )
                                {
                                    ZE( strokeS* , psttEmailRelay ) ;
                                    *info.pStkEmailRelay >> psttEmailRelay ; ___( psttEmailRelay ) ;
                                    meP.sayFieldF( tinP , stBodyP , tTitleEmailRelay , psttEmailRelay ) ;
                                    etThread.delF( tinP , psttEmailRelay ) ;
                                }
    
                                if( cRelays )
                                {
                                    if( info.cEmailRelayDrawings )
                                    {
                                        ZE( strokeS* , psttw ) ;
                                        etThread.strMakeF( tinP , LF , psttw , TF2(info.cEmailRelayDrawings,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ; ___( psttw ) ;
                                        TN( tTitlew , "relay random drawings" ) ;
                                        if( psttw ) { meP.sayFieldF( tinP , stBodyP , tTitlew , psttw ) ; }
                                        etThread.delF( tinP , psttw ) ;
                                    }
                                    else
                                    {
                                        meP.pushSnipF( tinP , stBodyP , idSnipTagOn ) ;
                                        meP.pushSnipF( tinP , stBodyP , T("relayed to all<BR>") ) ;
                                        meP.pushSnipF( tinP , stBodyP , idSnipTagOff ) ;
                                    }
                                }
    
                                while( *info.pStkAutoresponse )
                                {
                                    ZE( strokeS* , psttAutoresponse ) ;
                                    *info.pStkAutoresponse >> psttAutoresponse ; ___( psttAutoresponse ) ;
                                    meP.sayFieldF( tinP , stBodyP , tTitleAutoresponse , psttAutoresponse ) ;
                                    etThread.delF( tinP , psttAutoresponse ) ;
                                }
    
                                while( *info.pStkRecipe )
                                {
                                    ZE( strokeS* , psttRecipe ) ;
                                    *info.pStkRecipe >> psttRecipe ; ___( psttRecipe ) ;
                                    meP.sayFieldF( tinP , stBodyP , tTitleRecipe , psttRecipe ) ;
                                    etThread.delF( tinP , psttRecipe ) ;
                                }
    
                                while( *info.pStkEmailPenpalExactOr )
                                {
                                    ZE( strokeS* , psttEmailPenpalExactOr ) ;
                                    *info.pStkEmailPenpalExactOr >> psttEmailPenpalExactOr ; ___( psttEmailPenpalExactOr ) ;
                                    meP.sayFieldF( tinP , stBodyP , tTitleEmailPenpalExactOr , psttEmailPenpalExactOr ) ;
                                    etThread.delF( tinP , psttEmailPenpalExactOr ) ;
                                }
    
                                while( *info.pStkEmailPenpalContainsOr )
                                {
                                    ZE( strokeS* , psttEmailPenpalContainsOr ) ;
                                    *info.pStkEmailPenpalContainsOr >> psttEmailPenpalContainsOr ; ___( psttEmailPenpalContainsOr ) ;
                                    meP.sayFieldF( tinP , stBodyP , tTitleEmailPenpalContainsOr , psttEmailPenpalContainsOr ) ;
                                    etThread.delF( tinP , psttEmailPenpalContainsOr ) ;
                                }
    
                                while( *info.pStkEmailPenpalContainsAnd )
                                {
                                    ZE( strokeS* , psttEmailPenpalContainsAnd ) ;
                                    *info.pStkEmailPenpalContainsAnd >> psttEmailPenpalContainsAnd ; ___( psttEmailPenpalContainsAnd ) ;
                                    meP.sayFieldF( tinP , stBodyP , tTitleEmailPenpalContainsAnd , psttEmailPenpalContainsAnd ) ;
                                    etThread.delF( tinP , psttEmailPenpalContainsAnd ) ;
                               }
                            }
    
                            meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT81 ) ;
                        }
                    }
                    meP.pushSnipF( tinP , stBodyP , idSnipEnd ) ;
                }
            }
        }
    }

    etThread.delF( tinP , psttEmail ) ;
    etThread.delF( tinP , psttIdAccount ) ;
}

#undef SETcOL2EMAILrELAY


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000a9.myaccountsettingscbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000aa.myaccountmoneycbf BEGIN
#define DDNAME       "3func.330000aa.myaccountmoneycbf"
#define DDNUMB      (countT)0x330000aa
#define IDFILE      (countT)0x989


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT myAccountMoneyCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    ZE( strokeS* , psttEmail ) ;
    ZE( countT   , idAccount ) ;
    {
        sessionC& session = sessionsP( tinP , nnPeerP ) ;
        session.getEmailF( tinP , psttEmail ) ; ___( psttEmail ) ;
        idAccount = session.getIdAccountF( tinP ) ;
    }

    if( !psttEmail ){ meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_MYaCCOUNT1 ) ; }
    else
    {
        //OBSOLETED BY TOOL TO IMPERSONATE PAYPAL NOTIFIER
        //REMOVE IN PRODUCTION
        //{
        //    countT cToDo = 0x10 ;
        //    while( cToDo -- )
        //    {
        //        ZE( countT  , timeN1 ) ;
        //        ZE( sCountT , timeN2 ) ;
        //        etThread.osTimeNowUniqueF( tinP , timeN1 , timeN2 ) ;
        //        {
        //            countT pczTime[] = { timeN1 , timeN2 , 0 } ;
        //            CONoUTrAW( T("time: ")+T(pczTime)+T("\r\n") ) ;
        //        }
        //
        //        count8S c8n( 0x11 , 0x22 , 0x33 , 0x44 ) ;
        //
        //        ZE( countT  , moneyT1 ) ;
        //        ZE( sCountT , moneyT2 ) ;
        //        etThread.osTimeSubtractF( tinP , moneyT1 , moneyT2 , ( TUCK >> 1 ) * TICK , 0 ) ;
        //
        //        sessionC& session = sessionsP( tinP , nnPeerP ) ;
        //        countT idAccCommission = session.getIdAccountCommissionF( tinP ) ;
        //
        //        depositS info( tinP , ifcIDaCCbUCKEToWNER_IFO  , ifcIDbUCKET_CENTRALbANK , ifcIDpRODUCTcENTRALbANK_EXCHANGEmEDIA , idAccount , c8n/*pczNote*/ , timeN1 , timeN2 , 1/*idDeposit*/ , idAccCommission , moneyT1 , moneyT2 ) ;
        //    }
        //}

        bucketTotalC  infoTotal(  tinP , ifcIDaCCbUCKEToWNER_IFO  , ifcIDbUCKET_CENTRALbANK , ifcIDpRODUCTcENTRALbANK_EXCHANGEmEDIA , idAccount ) ;
        bucketDetailC infoDetail( tinP , ifcIDaCCbUCKEToWNER_IFO  , ifcIDbUCKET_CENTRALbANK , ifcIDpRODUCTcENTRALbANK_EXCHANGEmEDIA , idAccount ) ;

        TN( tSay , "" ) ; tSay = T("<PRE>total: ")+TF2(infoTotal.moneyT1,flFORMAT_NObIGITvALUES)+T(",")+TF2((sCountT)infoTotal.moneyT2,flFORMAT_NObIGITvALUES)+T("\r\n\r\n") ;
        meP.pushSnipF( tinP , stBodyP , tSay ) ;

        TN( tcr , "\r\n" ) ;
        for( countT offd = 0 ; offd < infoDetail.cDeposits ; offd ++ )
        {
            ZE( strokeS* , psttw ) ;
            infoDetail.ppDetail[ offd ]->psttF( tinP , etThread , psttw ) ;
            TN( tSay , "" ) ; tSay = T(psttw)+tcr ;
            etThread.delF( tinP , psttw ) ;
            meP.pushSnipF( tinP , stBodyP , tSay ) ;
        }

        tSay = T("</PRE>\r\n") ;
        meP.pushSnipF( tinP , stBodyP , tSay ) ;
    }
    etThread.delF( tinP , psttEmail ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000aa.myaccountmoneycbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ab.listinginspectlistscbf BEGIN
#define DDNAME       "3func.330000ab.listinginspectlistscbf"
#define DDNUMB      (countT)0x330000ab
#define IDFILE      (countT)0x98a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/sCountT listingInspectListsCBF( tinS& tinP , aptC& aptP , listWalkArgOldS& argP , const countT* pczListNameP )/*1*/
{
    _IO_
    grabitC& grabitListKidP = *(grabitC*)argP.pcUtility[ 0 ] ;

    ZE( sCountT , sgn ) ;
    if( aptP )
    {
        countT idName = APT( listC , aptP ).nameF() ;
        sgn = argP.idNameSpec - idName ;
        if( !sgn )
        {
            grabitListKidP.aimF( tinP , flGRABITcaIMmASK_null , &APT( listC , aptP ).flagsRefF() ) ;
            *(aptC*)&argP.pcUtility[ 1 ] = aptP ;
//            argP.pcUtility[ 2 ] = (countT)&APT( listC , aptP ).idNameKidDefaultLath ;
            argP.flagsInspect |= flAPTiNSPECT_ABORT | flAPTiNSPECT_DOnOTuNGRABhERE ;
            argP.pcUtility[ 3 ] = 1 ; //bExisted
        }
    }
    return sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ab.listinginspectlistscbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ac.listingattachlistcbf BEGIN
#define DDNAME       "3func.330000ac.listingattachlistcbf"
#define DDNUMB      (countT)0x330000ac
#define IDFILE      (countT)0x98b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT listingAttachListCBF( tinS& tinP , aptC& aptP , countT& idNameDefaultLathP , listWalkArgOldS& argP , const countT* pczListNameP )/*1*/
{
    _IO_
    if( argP.idTypeAttach )
    {
        grabitC& grabitListKidP = *(grabitC*)argP.pcUtility[ 0 ] ;
    
        __( !argP.idNameSpec ) ;
        __( !( argP.idNameSpec >> sizeof( countT ) * SB - 1 ) ) ; //NAME VALUE MUST HAVE HIGH ORDER BIT SET; THIS CODING STANDARD IS SO THAT NAME VALUES CAN BE DISTINGUISHED FROM POINTERS
        __( idNameDefaultLathP != BM_HIGH && idNameDefaultLathP != - 1 ) ;
        idNameDefaultLathP = - 1 ;
    
        //{
        //    puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
        //    CONoUTrAW( T("attaching listC to ")+T(pczListNameP)+T(" with name ")+TF2(argP.idNameSpec,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
        //}

        THREADmODE2oN( flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP | flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc )
        byteT* pba = (byteT*)new( 0 , tinP , LF ) listC( tinP , argP.idNameSpec ) ; ___( pba ) ;
        THREADmODE2rESTORE
        aptP = pba ;
        if( aptP )
        {
            grabitListKidP.aimF( tinP , flGRABITcaIMmASK_null , &APT( listC , aptP ).flagsRefF() ) ; 
            *(aptC*)&argP.pcUtility[ 1 ] = aptP ;
//            argP.pcUtility[ 2 ] = (countT)&APT( listC , aptP ).idNameKidDefaultLath ;
            grabitListKidP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ac.listingattachlistcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ad.listwalkdeleteallcbf BEGIN
#define DDNAME       "3func.330000ad.listwalkdeleteallcbf"
#define DDNUMB      (countT)0x330000ad
#define IDFILE      (countT)0x98c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkDeleteAllCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    return tinP.ta.pushed.u.listWalk.cbf.pListingP ? flLISTwALKcALLbACKrETURNcODE_DELETE : flLISTwALKcALLbACKrETURNcODE_null ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ad.listwalkdeleteallcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ae.listwalkattachlistifcbf BEGIN
#define DDNAME       "3func.330000ae.listwalkattachlistifcbf"
#define DDNUMB      (countT)0x330000ae
#define IDFILE      (countT)0x98d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

listC* pNewF( tinS& tinP , listC** ppPreP , const countT idNameWantP )
{
    ZE( listC* , pNew ) ;
    if( !ppPreP ) { pNew = new( 0 , tinP , LF ) listC( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , idNameWantP ) ; ___( pNew ) ; }
    else
    {
        for( countT offi = 0 ; ppPreP[ offi ] ; offi ++ )
        {
            if( !ppPreP[ offi + 1 ] ) //IF offi POINTS TO LEAF
            {
                pNew = ppPreP[ offi ] ;
                       ppPreP[ offi ] = 0 ;
                break ;
            }
        }

        if( pNew )
        {
            *pNew = *tinP.ta.pushed.u.listWalk.cbf.pDadP ;
            *pNew = idNameWantP ;

            __( tinP.ta.pushed.u.listWalk.cbf.pNewP ) ;
            if( !tinP.ta.pushed.u.listWalk.cbf.pNewP ) tinP.ta.pushed.u.listWalk.cbf.pNewP = pNew ;
        }
    }

    return pNew ;
}

/*1*/flagsT listWalkAttachListIfCBF( tinS& tinP )/*1*/
{
    _IO_

    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    listingC* pListing          = tinP.ta.pushed.u.listWalk.cbf.pListingP ;
    handleC*  ppHand[ 2 ]       = { tinP.ta.pushed.u.listWalk.walk.pHandleLoP , tinP.ta.pushed.u.listWalk.walk.pHandleHiP } ;
    countT&   offWoth           = *tinP.ta.pushed.u.listWalk.walk.pOffWothP ;

    listC**   ppPreP            = tinP.ta.pushed.u.listWalk.cbf.ppPreallocatedListsP ;

    countT    idNameWantP       =            tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] ;
    flagsT    flagsP            =            tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] ;
    listC*&   pListFoundP       = *(listC**)&tinP.ta.pushed.u.listWalk.util.pcP[ 2 ] ;

    flagsT flagsListWalkRetCode = flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE ;
    if( !pListing )
    {
        if( !( F(flagsP) & flLISToPEN_IFeXISTS ) )
        {
            _IO_
            listC* pNew = pNewF( tinP , ppPreP , idNameWantP ) ;
            pNew->openF( tinP , *ppHand[ !offWoth ] , 0 , tinP.ta.retained.u.listWalk.walk.idGrabLayer ) ;
            pListFoundP = pNew ;
        }
    }
    else
    {
        aptC aptListing( tinP , pListing ) ;
        __( !listingC::bIsListingIF( tinP , aptListing ) ) ;

        if
        (
            !POOP
            && ( listingC::bIsListingIF( tinP , aptListing , fliLISTINGc_MIXINlIST ) || listingC::bIsListingIF( tinP , aptListing , fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM ) )
        )
        {
            countT idNameAt = pListing->nameF() ;
            if( idNameWantP == idNameAt )
            {
                if( !( F(flagsP) & flLISToPEN_IFnOTeXISTS ) ) pListFoundP = (listC*)pListing ;
                else                                          tinP.ta.pushed.u.listWalk.walk.flagsWalkP &= ~( F(flLISTwALK_DOnOTuNGRABoOTHaTeNDoFwALK) ) ;

                flagsListWalkRetCode |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
            }
            else if( idNameWantP < idNameAt )
            {
                if( F(flagsP) & flLISToPEN_IFeXISTS ) tinP.ta.pushed.u.listWalk.walk.flagsWalkP &= ~( F(flLISTwALK_DOnOTuNGRABoOTHaTeNDoFwALK) ) ;
                else
                {
                    _IO_
                    listC* pNew = pNewF( tinP , ppPreP , idNameWantP ) ;
                    byteT* pbh = (byteT*)ppHand[ !offWoth ] ;
                    {
                        _IO_
                        DELzOMBIE( ppHand[ !offWoth ] ) ;
                    }
                    ppHand[ !offWoth ] = new( 0 , tinP , pbh , SIZEOF_handleC ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                    {
                        _IO_
                        pNew->openF( tinP , *ppHand[ !offWoth ] , 0 , tinP.ta.retained.u.listWalk.walk.idGrabLayer ) ;
                    }
                    pListFoundP = pNew ;
                }

                flagsListWalkRetCode |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
            }
        }
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flagsListWalkRetCode ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ae.listwalkattachlistifcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000af.listwalkqueryfromtextcbf BEGIN
#define DDNAME       "3func.330000af.listwalkqueryfromtextcbf"
#define DDNUMB      (countT)0x330000af
#define IDFILE      (countT)0x98e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkQueryFromTextCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    flagsT flagsRC = flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE ;
    listingC* pListing = tinP.ta.pushed.u.listWalk.cbf.pListingP ;

    if( !pListing )
    {
        tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] = tinP.ta.pushed.u.listWalk.cbf.pDadP->dispenseNameF() ;
        ___( new( 0 , tinP , LF ) list_blob_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] , LF , (osTextT*)tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] ) ) ;
    }
    else if
    (
        ( pListing->flagsF() & fliLISTINGc_maskTypeBits ) == ( fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM )
        && pListing->idTypeDatumF() == ifcIDtYPEmIXINdATUM_blob
    )
    {
        osTextT* postMe = (osTextT*)tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] ;
        osTextT* postHe = (osTextT*)*(list_blob_C*)pListing ;

        if( !thirdC::c_strcmpIF( tinP , postHe , postMe ) )
        {
            tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] = pListing->nameF() ;
            flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
        }
        else if( (sCountT)0 < thirdC::c_strcmpIF( tinP , postHe , postMe ) )
        {
            tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] = tinP.ta.pushed.u.listWalk.cbf.pDadP->dispenseNameF() ;
            ___( new( 0 , tinP , LF ) list_blob_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] , LF , postMe )  ); 
            flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
        }
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flagsRC ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000af.listwalkqueryfromtextcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b0.listwalkqueryfromidcbf BEGIN
#define DDNAME       "3func.330000b0.listwalkqueryfromidcbf"
#define DDNUMB      (countT)0x330000b0
#define IDFILE      (countT)0x98f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkQueryFromIdCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    flagsT flagsRC = flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE ;
    listingC* pListing = tinP.ta.pushed.u.listWalk.cbf.pListingP ;

    if
    (
        pListing
        && ( pListing->flagsF() & fliLISTINGc_maskTypeBits ) == ( fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM )
        && pListing->idTypeDatumF() == ifcIDtYPEmIXINdATUM_blob
    )
    {
        if( tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] == pListing->nameF() )
        {
            new( 0 , tinP , (byteT*)&tinP.ta.pushed.u.listWalk.util.pcP[ 2 ] , tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] ) blobVSP( (osTextT*)*(list_blob_C*)pListing , vspDatumBlobCBF , (countT)pListing ) ;
            flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
        }
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flagsRC ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b0.listwalkqueryfromidcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b1.listwalkforgettextcbf BEGIN
#define DDNAME       "3func.330000b1.listwalkforgettextcbf"
#define DDNUMB      (countT)0x330000b1
#define IDFILE      (countT)0x990


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkForgetTextCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    flagsT flagsRC = flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE ;
    listingC* pListing = tinP.ta.pushed.u.listWalk.cbf.pListingP ;

    if
    (
        pListing
        && ( pListing->flagsF() & fliLISTINGc_maskTypeBits ) == ( fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM )
        && pListing->idTypeDatumF() == ifcIDtYPEmIXINdATUM_blob
    )
    {
        if( !thirdC::c_strcmpIF( tinP , (osTextT*)tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] , (osTextT*)*(list_blob_C*)pListing ) ) flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT | flLISTwALKcALLbACKrETURNcODE_DELETE ;
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flagsRC ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b1.listwalkforgettextcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b2.listwalkforgetidcbf BEGIN
#define DDNAME       "3func.330000b2.listwalkforgetidcbf"
#define DDNUMB      (countT)0x330000b2
#define IDFILE      (countT)0x991


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkForgetIdCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    flagsT flagsRC = flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE ;
    listingC* pListing = tinP.ta.pushed.u.listWalk.cbf.pListingP ;

    if
    (
        pListing
        && ( pListing->flagsF() & fliLISTINGc_maskTypeBits ) == ( fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM )
        && pListing->idTypeDatumF() == ifcIDtYPEmIXINdATUM_blob
    )
    {
        if( tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] == pListing->nameF() ) flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT | flLISTwALKcALLbACKrETURNcODE_DELETE ;
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flagsRC ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b2.listwalkforgetidcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b3.listwalkfieldeditcbf BEGIN
#define DDNAME       "3func.330000b3.listwalkfieldeditcbf"
#define DDNUMB      (countT)0x330000b3
#define IDFILE      (countT)0x992


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkFieldEditCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    countT    idCallP  = tinP.ta.pushed.u.listWalk.cbf.idCallP ;
    listingC* pListingP = tinP.ta.pushed.u.listWalk.cbf.pListingP ;

    flagsT&                  flagsWalkP   =                          tinP.ta.pushed.u.listWalk.walk.flagsWalkP ;
    fieldEditParamOutC*&     pOutP        =   *(fieldEditParamOutC**)tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] ;
    const fieldEditParamInC& inP          =     *(fieldEditParamInC*)tinP.ta.pushed.u.listWalk.util.pcP[ 1 ] ;
    fieldEditParamOutC**&    ppOutNextP   = *(fieldEditParamOutC***)&tinP.ta.pushed.u.listWalk.util.pcP[ 2 ] ;
    countT&                  cKeepP       =                          tinP.ta.pushed.u.listWalk.util.pcP[ 3 ] ;
    countT&                  cNotDeletedP =                          tinP.ta.pushed.u.listWalk.util.pcP[ 4 ] ;
    countT&                  cDeletedP    =                          tinP.ta.pushed.u.listWalk.util.pcP[ 5 ] ;
    const countT             idLineNewP   =                          tinP.ta.pushed.u.listWalk.util.pcP[ 6 ] ;
    const countT             idiFileNewP  =                          tinP.ta.pushed.u.listWalk.util.pcP[ 7 ] ;

    flagsT flagsRC =

           F(inP.flags) & flFIELDeDIT_MODEaLL
        || F(inP.flags) & flFIELDeDIT_MODEpUSHfIFO
        || F(inP.flags) & flFIELDeDIT_MODEpUSHsINK
        || inP.pBool_blob_no
        || inP.pBool_blob_ok
        || inP.pBool_countTstrz_no
        || inP.pBool_countTstrz_ok
        || inP.pBool_countT_no
        || inP.pBool_countT_ok
        || inP.pBool_listingC_ptr_no
        || inP.pBool_listingC_ptr_ok

        ? flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE
        : flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE | flLISTwALKcALLbACKrETURNcODE_QUIT
    ;

    static countT idInLath ;
    countT idIn = 1 + incv02AM( idInLath ) ;
    if( idIn == 2 )
    {
        countT foo = 2 ;
    }

    //FOR DEBUGGING
    //if( F(inP.flags) & flFIELDeDIT_PUSH )
    //{
    //    CONoUTrAW9( "pushing [cValue,pbzValue,pczValue,pListingValue]: " , inP.cValue , " " , inP.pbzValue , " " , inP.pczValue , " " , inP.pListingValue , "\r\n" ) ;
    //}

    countVSP     vspcNew ;
    blobVSP      vspbzNew ;
    countStrzVSP vspczNew ;
    listingVSP   vspListingNew ;

    const boolT bEarlyPush =
           !( F(inP.flags) & flFIELDeDIT_MODEpUSHiFnOTeXIST )
        && !( F(inP.flags) & flFIELDeDIT_MODEpUSHfIFO       )
        && !( F(inP.flags) & flFIELDeDIT_MODEpUSHsINK       )
    ;

    // **** EARLY PUSH ****
    if( bEarlyPush )
    {
        if( F(inP.flags) & flFIELDeDIT_PUSHnULLcOUNT )
        {
            flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
            listing_countT_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countT_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , 0 ) ; ___( pNew ) ;
            if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNT ) )
            {
                countVSP vsp( (countT*)*pNew , vspDatumCountCBF , (countT)pNew ) ;
                vspcNew = vsp ;
            }
        }
        else if( F(inP.flags) & flFIELDeDIT_PUSHnULLbLOB )
        {
            flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
            listing_blob_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_blob_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , idLineNewP , idiFileNewP , 0 ) ; ___( pNew ) ;
            if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_BLOB ) )
            {
                blobVSP vsp( (osTextT*)*pNew , vspDatumBlobCBF , (countT)pNew ) ;
                vspbzNew = vsp ;
            }
        }
        else if( F(inP.flags) & flFIELDeDIT_PUSHnULLcOUNTsTRZ )
        {
            flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
            listing_countTstrz_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countTstrz_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , 0 ) ; ___( pNew ) ;
            if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNTsTRZ ) )
            {
                countStrzVSP vsp( (countT*)*pNew , vspDatumCountStrzCBF , (countT)pNew ) ;
                vspczNew = vsp ;
            }
        }
        else if( F(inP.flags) & flFIELDeDIT_PUSH )
        {
            flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
            if( inP.postzIdSerialSpace )
            {
                ZE( countT , idSerialNew ) ;
                {
                    puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                    idSerialNew =  tinP.pEther->ifcGetNextSerialNumberF( tinP , inP.postzIdSerialSpace ) ;
                }
                __Z( idSerialNew ) ;

                if( !POOP )
                {
                    listing_countT_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countT_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , idSerialNew ) ; ___( pNew ) ;
                    if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNT ) )
                    {
                        countVSP vsp( (countT*)*pNew , vspDatumCountCBF , (countT)pNew ) ;
                        vspcNew = vsp ;
                    }
                }
            }
            else if( inP.cValue )
            {
                listing_countT_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countT_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , inP.cValue ) ; ___( pNew ) ;

                //if( tinP.pEther ) etherC::etRockIF( tinP ).traceF( tinP , T("listWalkFieldEditCBF pushing countT [listing_countT_C*,countT*,countT]:   ")+TF2((countT)pNew,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)(countT*)*pNew,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)*(countT*)*pNew,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNT ) )
                {
                    countVSP vsp( (countT*)*pNew , vspDatumCountCBF , (countT)pNew ) ;
                    vspcNew = vsp ;
                }
            }
            else if( inP.pbzValue || inP.cbzValue )
            {
                listing_blob_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_blob_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , idLineNewP , idiFileNewP , inP.pbzValue , inP.cbzValue ) ; ___( pNew ) ;
                if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_BLOB ) )
                {
                    blobVSP vsp( (osTextT*)*pNew , vspDatumBlobCBF , (countT)pNew ) ;
                    vspbzNew = vsp ;
                }
            }
            else if( inP.pczValue )
            {
                listing_countTstrz_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countTstrz_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , inP.pczValue ) ; ___( pNew ) ;
                if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNTsTRZ ) )
                {
                    countStrzVSP vsp( (countT*)*pNew , vspDatumCountStrzCBF , (countT)pNew ) ;
                    vspczNew = vsp ;
                }
            }
            else if( inP.pListingValue )
            {
                listing_listingVSP_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_listingVSP_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , *inP.pListingValue ) ; ___( pNew ) ;
                if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_LISTINGsp ) )
                {
                    listingVSP vsp( pNew , vspDatumListingCBF , (countT)pNew ) ;
                    vspListingNew = vsp ;
                }
            }
        }
    }

    countVSP     vspcOld ;
    blobVSP      vspbzOld ;
    countStrzVSP vspczOld ;
    listingVSP   vspListingOld ;
    if( !pListingP )    
    {
        // **** WALK EPILOG ****
        if
        (
            !bEarlyPush
            &&
            (
                !( F(inP.flags) & flFIELDeDIT_MODEpUSHiFnOTeXIST )
                ||
                idCallP == 1
            )
            &&
            (
                !( F(inP.flags) & flFIELDeDIT_MODEpUSHsINK )
                ||
                !( F(inP.flags) & flFIELDeDIT_MODEuNIQUE )
                ||
                !( F(flagsWalkP) & flLISTwALK_MATCHsEEN )
            )
        )
        {
            if( F(inP.flags) & flFIELDeDIT_PUSHnULLcOUNT )
            {
                flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
                listing_countT_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countT_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , 0 ) ; ___( pNew ) ;
                if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNT ) )
                {
                    countVSP vsp( (countT*)*pNew , vspDatumCountCBF , (countT)pNew ) ;
                    vspcNew = vsp ;
                }
            }
            else if( F(inP.flags) & flFIELDeDIT_PUSHnULLbLOB )
            {
                flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
                listing_blob_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_blob_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , idLineNewP , idiFileNewP , 0 ) ; ___( pNew ) ;
                if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_BLOB ) )
                {
                    blobVSP vsp( (osTextT*)*pNew , vspDatumBlobCBF , (countT)pNew ) ;
                    vspbzNew = vsp ;
                }
            }
            else if( F(inP.flags) & flFIELDeDIT_PUSHnULLcOUNTsTRZ )
            {
                flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
                listing_countTstrz_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countTstrz_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , 0 ) ; ___( pNew ) ;
                if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNTsTRZ ) )
                {
                    countStrzVSP vsp( (countT*)*pNew , vspDatumCountStrzCBF , (countT)pNew ) ;
                    vspczNew = vsp ;
                }
            }
            else if( F(inP.flags) & flFIELDeDIT_PUSH )
            {
                flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;

                if( inP.postzIdSerialSpace )
                {
                    ZE( countT , idSerialNew ) ;
                    {
                        puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                        idSerialNew =  tinP.pEther->ifcGetNextSerialNumberF( tinP , inP.postzIdSerialSpace ) ;
                    }
                    __Z( idSerialNew ) ;
    
                    if( !POOP )
                    {
                        listing_countT_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countT_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , idSerialNew ) ; ___( pNew ) ;
                        if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNT ) )
                        {
                            countVSP vsp( (countT*)*pNew , vspDatumCountCBF , (countT)pNew ) ;
                            vspcNew = vsp ;
                        }
                    }
                }
                else if( inP.cValue )
                {
                    listing_countT_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countT_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , inP.cValue ) ; ___( pNew ) ;
                    if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNT ) )
                    {
                        countVSP vsp( (countT*)*pNew , vspDatumCountCBF , (countT)pNew ) ;
                        vspcNew = vsp ;
                    }
                }
                else if( inP.pbzValue || inP.cbzValue )
                {
                    listing_blob_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_blob_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , idLineNewP , idiFileNewP , inP.pbzValue , inP.cbzValue ) ; ___( pNew ) ;
                    if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_BLOB ) )
                    {
                        blobVSP vsp( (osTextT*)*pNew , vspDatumBlobCBF , (countT)pNew ) ;
                        vspbzNew = vsp ;
                    }
                }
                else if( inP.pczValue )
                {
                    listing_countTstrz_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countTstrz_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , inP.pczValue ) ; ___( pNew ) ;
                    if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNTsTRZ ) )
                    {
                        countStrzVSP vsp( (countT*)*pNew , vspDatumCountStrzCBF , (countT)pNew ) ;
                        vspczNew = vsp ;
                    }
                }
                else if( inP.pListingValue )
                {
                    listing_listingVSP_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_listingVSP_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , *inP.pListingValue ) ; ___( pNew ) ;
                    if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_LISTINGsp ) )
                    {
                        listingVSP vsp( pNew , vspDatumListingCBF , (countT)pNew ) ;
                        vspListingNew = vsp ;
                    }
                }
            }
        }
    }
    else
    {
        if( F(inP.flags) & flFIELDeDIT_PURGE )
        {
            flagsRC &= ~( F(flLISTwALKcALLbACKrETURNcODE_QUIT) ) ;

            if( cKeepP ) cKeepP -- ;
            else         flagsRC |= flLISTwALKcALLbACKrETURNcODE_DELETE ;
        }

        // **** SINK ****
        if( F(inP.flags) & flFIELDeDIT_MODEpUSHsINK )
        {
            flagsT flagsi = pListingP->flagsF() ;
            if( flagsi & fliLISTINGc_MIXINdATUM )
            {
                ZE( countT*    , pcValue ) ;
                ZE( osTextT*   , pbzValue ) ;
                ZE( countT*    , pczValue ) ;
                listingVSP         vspListingValue ;
                if( !( flagsi & fliLISTINGc_MIXINlIST ) )
                {
                    switch( pListingP->idTypeDatumF() ) //CS:CODEsYNC: 00104b0 21e0006 21e0002 21e0008 21e0009 220000e
                    {
                        case ifcIDtYPEmIXINdATUM_countT      : { pcValue         =     (countT*)*(listing_countT_C*)pListingP ; break ; }
                        case ifcIDtYPEmIXINdATUM_blob        : { pbzValue        =      (osTextT*)*(listing_blob_C*)pListingP ; break ; }
                        case ifcIDtYPEmIXINdATUM_countTstrz  : { pczValue        = (countT*)*(listing_countTstrz_C*)pListingP ; break ; }
                        case ifcIDtYPEmIXINdATUM_listingVSP  : { vspListingValue =          *(listing_listingVSP_C*)pListingP ; break ; }
                        default                              : { BLAMMO                                                       ; break ; }
                    }
                }
                else
                {
                    switch( pListingP->idTypeDatumF() ) //CS:CODEsYNC: 00104b0 21e0006 21e0002 21e0008 21e0009 220000e
                    {
                        case ifcIDtYPEmIXINdATUM_countT      : { pcValue         =     (countT*)*(list_countT_C*)pListingP ; break ; }
                        case ifcIDtYPEmIXINdATUM_blob        : { pbzValue        =      (osTextT*)*(list_blob_C*)pListingP ; break ; }
                        case ifcIDtYPEmIXINdATUM_countTstrz  : { pczValue        = (countT*)*(list_countTstrz_C*)pListingP ; break ; }
                        case ifcIDtYPEmIXINdATUM_listingVSP  : { vspListingValue =          *(list_listingVSP_C*)pListingP ; break ; }
                        default                              : { BLAMMO                                                    ; break ; }
                    }
                }

                if
                (
                    !( F(flagsWalkP) & flLISTwALK_MATCHsEEN )
                    &&
                    (
                        ( inP.cValue && pcValue && inP.cValue == *pcValue )
                        ||
                        ( inP.pbzValue && pbzValue && !thirdC::c_strcmpIF( tinP , inP.pbzValue , pbzValue ) )
                        ||
                        ( inP.pczValue && pczValue && !thirdC::c_strcmpIF( tinP , inP.pczValue , pczValue ) )
                        ||
                        ( inP.pListingValue && (const listingC*)vspListingValue && !( *(const listing_listingVSP_C*)inP.pListingValue - *(const listing_listingVSP_C*)(const listingC*)vspListingValue ) )
                    )
                )
                flagsWalkP |= flLISTwALK_MATCHsEEN ;

                if( F(inP.flags) & flFIELDeDIT_PUSHnULLcOUNT )
                {
                    flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
                    listing_countT_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countT_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , 0 ) ; ___( pNew ) ;
                    if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNT ) )
                    {
                        countVSP vsp( (countT*)*pNew , vspDatumCountCBF , (countT)pNew ) ;
                        vspcNew = vsp ;
                    }
                }
                else if( F(inP.flags) & flFIELDeDIT_PUSHnULLbLOB )
                {
                    flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
                    listing_blob_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_blob_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , idLineNewP , idiFileNewP , 0 ) ; ___( pNew ) ;
                    if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_BLOB ) )
                    {
                        blobVSP vsp( (osTextT*)*pNew , vspDatumBlobCBF , (countT)pNew ) ;
                        vspbzNew = vsp ;
                    }
                }
                else if( F(inP.flags) & flFIELDeDIT_PUSHnULLcOUNTsTRZ )
                {
                    flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
                    listing_countTstrz_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countTstrz_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , 0 ) ; ___( pNew ) ;
                    if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNTsTRZ ) )
                    {
                        countStrzVSP vsp( (countT*)*pNew , vspDatumCountStrzCBF , (countT)pNew ) ;
                        vspczNew = vsp ;
                    }
                }
                else if
                (
                    ( F(inP.flags) & flFIELDeDIT_PUSH )
                    &&
                    (
                        !( F(inP.flags) & flFIELDeDIT_MODEuNIQUE )
                        ||
                        !( F(flagsWalkP) & flLISTwALK_MATCHsEEN )
                    )
                )
                {
                    if(      inP.cValue        && ( ifcIDtYPEmIXINdATUM_countT      < pListingP->idTypeDatumF() || ( pcValue        && inP.cValue < *pcValue                                                                                             ) ) )
                    {
                        flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
                        listing_countT_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countT_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , inP.cValue ) ; ___( pNew ) ;
                        if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNT ) )
                        {
                            countVSP vsp( (countT*)*pNew , vspDatumCountCBF , (countT)pNew ) ;
                            vspcNew = vsp ;
                        }
                    }
                    else if( inP.pbzValue    && ( ifcIDtYPEmIXINdATUM_blob < pListingP->idTypeDatumF() || ( pbzValue     && 0 > thirdC::c_strcmpIF( tinP , inP.pbzValue , pbzValue )                                                      ) ) )
                    {
                        flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
                        listing_blob_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_blob_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , idLineNewP , idiFileNewP , inP.pbzValue ) ; ___( pNew ) ;
                        if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_BLOB ) )
                        {
                            blobVSP vsp( (osTextT*)*pNew , vspDatumBlobCBF , (countT)pNew ) ;
                            vspbzNew = vsp ;
                        }
                    }
                    else if( inP.pczValue      && ( ifcIDtYPEmIXINdATUM_countTstrz  < pListingP->idTypeDatumF() || ( pczValue       && 0 > thirdC::c_strcmpIF( tinP , inP.pczValue , pczValue )                                                          ) ) )
                    {
                        flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
                        listing_countTstrz_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_countTstrz_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , inP.pczValue ) ; ___( pNew ) ;
                        if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNTsTRZ ) )
                        {
                            countStrzVSP vsp( (countT*)*pNew , vspDatumCountStrzCBF , (countT)pNew ) ;
                            vspczNew = vsp ;
                        }
                    }
                    else if( inP.pListingValue && ( ifcIDtYPEmIXINdATUM_listingVSP   < pListingP->idTypeDatumF() || ( (const listingC*)vspListingValue && 0 > *(const listing_listingVSP_C*)inP.pListingValue - *(const listing_listingVSP_C*)(const listingC*)vspListingValue ) ) )
                    {
                        flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
                        listing_listingVSP_C* pNew = new( 0 , tinP , idLineNewP , idiFileNewP ) listing_listingVSP_C( tinP , *tinP.ta.pushed.u.listWalk.cbf.pDadP , *inP.pListingValue ) ; ___( pNew ) ;
                        if( F(inP.flags) & flFIELDeDIT_MODEqUERYnEW && ( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_LISTINGsp ) )
                        {
                            listingVSP vsp( pNew , vspDatumListingCBF , (countT)pNew ) ;
                            vspListingNew = vsp ;
                        }
                    }
                }
            }
        }

        // **** REMEMBER THE CURSORED VALUE ****
        {
            flagsT flagsi = pListingP->flagsF() ;
            if( flagsi & fliLISTINGc_MIXINdATUM )
            {
                if( !( flagsi & fliLISTINGc_MIXINlIST ) )
                {
                    switch( pListingP->idTypeDatumF() ) //CS:CODEsYNC: 00104b0 21e0006 21e0002 21e0008 21e0009 220000e
                    {
                        case ifcIDtYPEmIXINdATUM_countT     : { if( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNT     ) { countT*    pValue   =     (countT*)*(listing_countT_C*)pListingP ; if( pValue                    && ( !inP.pBool_countT_ok       || boolC::orIF( inP.pBool_countT_ok       ,                           *pValue ) ) && ( !inP.pBool_countT_no       || !boolC::orIF( inP.pBool_countT_no       ,                           *pValue ) ) ) { countVSP     vsp( pValue   , vspDatumCountCBF     , (countT)pListingP                 ) ; vspcOld       = vsp ; /*if( tinP.pEther ) etherC::etRockIF( tinP ).traceF( tinP , T("listWalkFieldEditCBF cursored countT [listing_countT_C*,countT*,countT]:   ")+TF2((countT)pListingP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)(countT*)*(listing_countT_C*)pListingP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(*(countT*)*(listing_countT_C*)pListingP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;*/ } } break ; }
                        case ifcIDtYPEmIXINdATUM_blob       : { if( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_BLOB      ) { osTextT*   pValue   =      (osTextT*)*(listing_blob_C*)pListingP ; if( pValue                    && ( !inP.pBool_blob_ok         || boolC::orIF( inP.pBool_blob_ok         ,                            pValue ) ) && ( !inP.pBool_blob_no         || !boolC::orIF( inP.pBool_blob_no         ,                            pValue ) ) ) { blobVSP      vsp( pValue   , vspDatumBlobCBF      , (countT)pListingP                 ) ; vspbzOld      = vsp ; } } break ; }
                        case ifcIDtYPEmIXINdATUM_countTstrz : { if( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNTsTRZ ) { countT*    pValue   = (countT*)*(listing_countTstrz_C*)pListingP ; if( pValue                    && ( !inP.pBool_countTstrz_ok   || boolC::orIF( inP.pBool_countTstrz_ok   ,                            pValue ) ) && ( !inP.pBool_countTstrz_no   || !boolC::orIF( inP.pBool_countTstrz_no   ,                            pValue ) ) ) { countStrzVSP vsp( pValue   , vspDatumCountStrzCBF , (countT)pListingP                 ) ; vspczOld      = vsp ; } } break ; }
                        case ifcIDtYPEmIXINdATUM_listingVSP : { if( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_LISTINGsp ) { listingVSP vspValue =          *(listing_listingVSP_C*)pListingP ; if( (const listingC*)vspValue && ( !inP.pBool_listingC_ptr_ok || boolC::orIF( inP.pBool_listingC_ptr_ok , (countT)(const listingC*)vspValue ) ) && ( !inP.pBool_listingC_ptr_no || !boolC::orIF( inP.pBool_listingC_ptr_no , (countT)(const listingC*)vspValue ) ) ) { listingVSP   vsp( vspValue , vspDatumListingCBF   , (countT)(const listingC*)vspValue ) ; vspListingOld = vsp ; } } break ; }
                        default                             : { BLAMMO                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ; break ; }
                    }
                }
                else
                {
                    switch( pListingP->idTypeDatumF() ) //CS:CODEsYNC: 00104b0 21e0006 21e0002 21e0008 21e0009 220000e
                    {
                        case ifcIDtYPEmIXINdATUM_countT     : { if( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNT     ) { countT*    pValue   =        (countT*)*(list_countT_C*)pListingP ; if( pValue                    && ( !inP.pBool_countT_ok       || boolC::orIF( inP.pBool_countT_ok       ,                           *pValue ) ) && ( !inP.pBool_countT_no       || !boolC::orIF( inP.pBool_countT_no       ,                           *pValue ) ) ) { countVSP     vsp( pValue   , vspDatumCountCBF     , (countT)pListingP                 ) ; vspcOld       = vsp ; /*if( tinP.pEther ) etherC::etRockIF( tinP ).traceF( tinP , T("listWalkFieldEditCBF cursored countT [listing_countT_C*,countT*,countT]:   ")+TF2((countT)pListingP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)(countT*)*(listing_countT_C*)pListingP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(*(countT*)*(listing_countT_C*)pListingP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;*/ } } break ; }
                        case ifcIDtYPEmIXINdATUM_blob       : { if( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_BLOB      ) { osTextT*   pValue   =         (osTextT*)*(list_blob_C*)pListingP ; if( pValue                    && ( !inP.pBool_blob_ok         || boolC::orIF( inP.pBool_blob_ok         ,                            pValue ) ) && ( !inP.pBool_blob_no         || !boolC::orIF( inP.pBool_blob_no         ,                            pValue ) ) ) { blobVSP      vsp( pValue   , vspDatumBlobCBF      , (countT)pListingP                 ) ; vspbzOld      = vsp ; } } break ; }
                        case ifcIDtYPEmIXINdATUM_countTstrz : { if( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_COUNTsTRZ ) { countT*    pValue   =    (countT*)*(list_countTstrz_C*)pListingP ; if( pValue                    && ( !inP.pBool_countTstrz_ok   || boolC::orIF( inP.pBool_countTstrz_ok   ,                            pValue ) ) && ( !inP.pBool_countTstrz_no   || !boolC::orIF( inP.pBool_countTstrz_no   ,                            pValue ) ) ) { countStrzVSP vsp( pValue   , vspDatumCountStrzCBF , (countT)pListingP                 ) ; vspczOld      = vsp ; } } break ; }
                        case ifcIDtYPEmIXINdATUM_listingVSP : { if( !F(inP.flagsTypeMask) || F(inP.flagsTypeMask) & flFIELDeDITtYPEmASK_LISTINGsp ) { listingVSP vspValue =             *(list_listingVSP_C*)pListingP ; if( (const listingC*)vspValue && ( !inP.pBool_listingC_ptr_ok || boolC::orIF( inP.pBool_listingC_ptr_ok , (countT)(const listingC*)vspValue ) ) && ( !inP.pBool_listingC_ptr_no || !boolC::orIF( inP.pBool_listingC_ptr_no , (countT)(const listingC*)vspValue ) ) ) { listingVSP   vsp( vspValue , vspDatumListingCBF   , (countT)(const listingC*)vspValue ) ; vspListingOld = vsp ; } } break ; }
                        default                             : { BLAMMO                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ; break ; }
                    }
                }
            }
        }
    }

    if( (const countT*)vspcOld || (const osTextT*)vspbzOld || (const countT*)vspczOld || (const listingC*)vspListingOld )
    {
        if( F(inP.flags) & flFIELDeDIT_DELETE )
        {
            flagsRC |= F(inP.flags) & flFIELDeDIT_MODEaLL
                ? flLISTwALKcALLbACKrETURNcODE_DELETE
                : flLISTwALKcALLbACKrETURNcODE_DELETE | flLISTwALKcALLbACKrETURNcODE_QUIT
            ;
        }

        if( F(inP.flags) & flFIELDeDIT_QUERY && !( F(inP.flags) & flFIELDeDIT_MODEaLL ) )
        {
            flagsRC |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
        }
    }

    // **** REPORT OLD AND NEW VALUES ****
    countVSP*     ppvspc[]       = { &vspcNew       , &vspcOld       } ;
    blobVSP*      ppvspbz[]      = { &vspbzNew      , &vspbzOld      } ;
    countStrzVSP* ppvspcz[]      = { &vspczNew      , &vspczOld      } ;
    listingVSP*   ppvspListing[] = { &vspListingNew , &vspListingOld } ;

    for( countT offi = 0 ; offi < sizeof ppvspc / sizeof ppvspc[ 0 ] ; offi ++ )
    {
        if( (const voidT*)*ppvspc[ offi ] || (const voidT*)*ppvspbz[ offi ] || (const voidT*)*ppvspcz[ offi ] || (const voidT*)*ppvspListing[ offi ] )
        {
            if( F(inP.flags) & flFIELDeDIT_QUERY )
            {
                THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                {
                    puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                                        
                    if( !pOutP )
                    {
                        pOutP = new( 0 , tinP , idLineNewP , idiFileNewP ) fieldEditParamOutC ; ___( pOutP ) ;
                        __Z( pOutP ) ;
                        if( pOutP )
                        {
                            ppOutNextP = &pOutP->pNext ;
                            pOutP->idPlate        = idCallP ;
                            pOutP->vspCount       = *ppvspc[       offi ] ;
                            pOutP->vspBlob        = *ppvspbz[      offi ] ;
                            pOutP->vspCountString = *ppvspcz[      offi ] ;
                            pOutP->vspListing     = *ppvspListing[ offi ] ;
                        }
                    }
                    else
                    {
                        __Z( ppOutNextP ) ;
                        if( ppOutNextP )
                        {
                            __( !!*ppOutNextP ) ;
                            *ppOutNextP = new( 0 , tinP , idLineNewP , idiFileNewP ) fieldEditParamOutC ; ___( *ppOutNextP ) ;
                            __( !*ppOutNextP ) ;
                            if( *ppOutNextP )
                            {
                                (*ppOutNextP)->idPlate        = idCallP ;
                                (*ppOutNextP)->vspCount       = *ppvspc[       offi ] ;
                                (*ppOutNextP)->vspBlob        = *ppvspbz[      offi ] ;
                                (*ppOutNextP)->vspCountString = *ppvspcz[      offi ] ;
                                (*ppOutNextP)->vspListing     = *ppvspListing[ offi ] ;
                                  ppOutNextP                  = &(*ppOutNextP)->pNext ;
                            }
                        }
                    }
                }
                THREADmODE2rESTORE
            }
        }
    }

    if( !pListingP ) ;
    else if( F(flagsRC) & flLISTwALKcALLbACKrETURNcODE_DELETE ) cDeletedP    ++ ;
    else                                                        cNotDeletedP ++ ;
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flagsRC ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b3.listwalkfieldeditcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b4.listwalklintcbf BEGIN
#define DDNAME       "3func.330000b4.listwalklintcbf"
#define DDNUMB      (countT)0x330000b4
#define IDFILE      (countT)0x993


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkLintCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    listingC* pListingP = tinP.ta.pushed.u.listWalk.cbf.pListingP ;

    //CS:CODEsYNC: 330e6010 320000b4
    countT& idUpdateBegunP     = tinP.ta.retained.u.listWalk.util.pcP[ 0 ] ; // LATH ENCOUNTERED VALUE OF A FIELD NAMED LISTnAME_IDuPDATEbEGUN
    countT& idUpdateCompletedP = tinP.ta.retained.u.listWalk.util.pcP[ 1 ] ; // LATH ENCOUNTERED VALUE OF A FIELD NAMED LISTnAME_IDuPDATEcOMPLETED

    flagsT flrc = flLISTwALKcALLbACKrETURNcODE_null ;
    //CONoUTrAW9( "listWalkLintCBF/+ [pListingP,flrc,idUpdateBegunP,idUpdateCompletedP]: " , pListingP , " " , flrc , " " , idUpdateBegunP , " " , idUpdateCompletedP , "\r\n" ) ;
    if( pListingP )
    {
        if( !listingC::bIsListingIF( tinP , aptC( tinP , pListingP ) ) )
        {
            CONoUTrAW( "EXCEPTION: An apartment was encountered that does not contain a valid listingC object.  quitting\r\n" ) ;
            __1
            flrc |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
        }
        else
        {
            ZE( countT* , pczName ) ;
            pListingP->nameF( tinP , pczName ) ; // ___( pczName ) ;

            if( pListingP->idTypeDatumF() )
            {
                datumC* pDatum = pListingP->flagsF() & fliLISTINGc_MIXINlIST
                    ? (datumC*)( (listC*)pListingP + 1 )
                    : (datumC*)(         pListingP + 1 )
                ;

                if( pDatum->getBitsF() & fliDATUMc_INDEXED ) { CONoUTrAW( " unindexing a datumC\r\n" ) ; }

                pDatum->unIndexF( tinP , flUNiNDEXf_IFiNDEXED ) ;

                if( pDatum->getBitsF() & fliDATUMc_INDEXED ) { BLAMMO ; } //U::REMOVE WHEN CONFIDENT
            }

            ZE( countT* , pcValue ) ;
            ZE( osTextT* , postValue ) ;
            ZE( countT* , pczValue ) ;
            flagsT flagsi = pListingP->flagsF() ;
            if( flagsi & fliLISTINGc_MIXINdATUM )
            {
                if( !( flagsi & fliLISTINGc_MIXINlIST ) )
                {
                    //CONoUTrAW( T("listing with datum [pczName]: ")+TF2(pczName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
                    switch( pListingP->idTypeDatumF() ) //CS:CODEsYNC: 00104b0 21e0006 21e0002 21e0008 21e0009 220000e
                    {
                        case ifcIDtYPEmIXINdATUM_countT     :
                        {
                            pcValue = (countT*)*(listing_countT_C*)pListingP ;
                            countT idName = pListingP->nameF() ;
                            switch( idName )
                            {
                                case LISTnAME_IDuPDATEbEGUN     : { idUpdateBegunP     = *pcValue ; /* CONoUTrAW3( "    [idUpdateBegun]: " , *pcValue , "\r\n" ) ;*/ break ; }
                                case LISTnAME_IDuPDATEcOMPLETED : { idUpdateCompletedP = *pcValue ; /* CONoUTrAW3( "[idUpdateCompleted]: " , *pcValue , "\r\n" ) ;*/ break ; }
                            }
                            break ;
                        }
                        case ifcIDtYPEmIXINdATUM_blob       : { postValue =      (osTextT*)*(listing_blob_C*)pListingP ; break ; }
                        case ifcIDtYPEmIXINdATUM_countTstrz : { pczValue  = (countT*)*(listing_countTstrz_C*)pListingP ; break ; }
                        case ifcIDtYPEmIXINdATUM_listingVSP : {                                                          break ; }
                        default                             : { BLAMMO                                                 ; break ; }
                    }
                }
                else
                {
                    //CONoUTrAW( T("LIST with datum [pczName]: ")+TF2(pczName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
                    if( flagsi & fliLISTINGc_RECORD && ( idUpdateBegunP || idUpdateCompletedP ) )
                    {
                        CONoUTrAW5( "marked record [idUpdateBegunP,idUpdateCompletedP]: " , idUpdateBegunP , " " , idUpdateCompletedP , "\r\n" ) ;
                        if( idUpdateBegunP != idUpdateCompletedP )
                        {
                            CONoUTrAW( "this record is dirty.  delete has been requested\r\n" ) ;
                            flrc |= flLISTwALKcALLbACKrETURNcODE_DELETE ;
                        }
                        idUpdateBegunP = idUpdateCompletedP = 0 ;
                    }

                    switch( pListingP->idTypeDatumF() ) //CS:CODEsYNC: 00104b0 21e0006 21e0002 21e0008 21e0009 220000e
                    {
                        case ifcIDtYPEmIXINdATUM_countT     : { pcValue   =        (countT*)*(list_countT_C*)pListingP ; break ; }
                        case ifcIDtYPEmIXINdATUM_blob       : { postValue =         (osTextT*)*(list_blob_C*)pListingP ; break ; }
                        case ifcIDtYPEmIXINdATUM_countTstrz : { pczValue  =    (countT*)*(list_countTstrz_C*)pListingP ; break ; }
                        case ifcIDtYPEmIXINdATUM_listingVSP : {                                                          break ; }
                        default                             : { BLAMMO                                                 ; break ; }
                    }
                }
            }
            else
            {
                if( !( flagsi & fliLISTINGc_MIXINlIST ) )
                {
                    //CONoUTrAW( T("listing [pczName]: ")+TF2(pczName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
                }
                else
                {
                    //CONoUTrAW( T("LIST [pczName]: ")+TF2(pczName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
                }
            }

            if( flagsi & fliLISTINGc_MIXINlIST && flagsi & fliLISTINGc_RECORD && ( idUpdateBegunP || idUpdateCompletedP ) )
            {
                //CONoUTrAW5( "marked record [idUpdateBegunP,idUpdateCompletedP]: " , idUpdateBegunP , " " , idUpdateCompletedP , "\r\n" ) ;
                if( idUpdateBegunP != idUpdateCompletedP )
                {
                    CONoUTrAW( "this record is dirty.  delete has been requested\r\n" ) ;
                    flrc |= flLISTwALKcALLbACKrETURNcODE_DELETE ;
                }
                idUpdateBegunP = idUpdateCompletedP = 0 ;
            }

            if( pcValue && pcValue[ - 1 ] )
            {
                CONoUTrAW3( " resetting cRef of " , pcValue[ - 1 ] , " for a countT datum\r\n" ) ;
                pcValue[ - 1 ] = 0 ; //CS:CODEsYNC: 2200010 2220003
            }

            if( postValue && ((countT*)postValue)[ - 2 ] )
            {
                CONoUTrAW3( " resetting cRef of " , ((countT*)postValue)[ - 2 ] , " for a blob datum\r\n" ) ;
                ((countT*)postValue)[ - 2 ] = 0 ; //CS:CODEsYNC: 2200010 2240003
            }

            if( pczValue && pczValue[ - 2 ] )
            {
                CONoUTrAW3( " resetting cRef of " , pczValue[ - 2 ] , " for a countT string datum\r\n" ) ;
                pczValue[ - 2 ] = 0 ; //CS:CODEsYNC: 2200010 2240003
            }
            //{ puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ; PUSE( tinP , *(byteT**)&pczName ) ; }
            tinP.tlsDelF( *(byteT**)&pczName ) ;
        }
    }
    //CONoUTrAW9( "listWalkLintCBF/- [pListingP,flrc,idUpdateBegunP,idUpdateCompletedP]: " , pListingP , " " , flrc , " " , idUpdateBegunP , " " , idUpdateCompletedP , "\r\n" ) ;
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flrc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b4.listwalklintcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b5.listwalkenumeratecbf BEGIN
#define DDNAME       "3func.330000b5.listwalkenumeratecbf"
#define DDNUMB      (countT)0x330000b5
#define IDFILE      (countT)0x994


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkEnumerateCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    listingC* pListingP  =               tinP.ta.pushed.u.listWalk.cbf.pListingP ;
    datumS*&  pDatumP    =   *(datumS**)&tinP.ta.pushed.u.listWalk.util.pcP[ 0 ] ;

    flagsT flrc = flLISTwALKcALLbACKrETURNcODE_null ;
    if( pListingP )
    {
        ZE( countT* , pczName ) ;
        tinP.ta.pushed.u.listWalk.cbf.pDadP->nameF( tinP , pczName ) ; // ___( pczName ) ;
        switch( pczName[ tinP.ta.pushed.u.listWalk.walk.offStretchBegin ] )
        {
            case LISTnAME_STRETCHbEGINcOUNT :
            {
                ZE( countT , vv ) ;
                etherC::strSquishIF( tinP , vv , pczName + tinP.ta.pushed.u.listWalk.walk.offStretchBegin ) ;

                datumS* pDatumSave = pDatumP ;
                                     pDatumP = new( 0 , tinP , LF ) datumS( tinP , vv ) ; ___( pDatumP ) ;

                if( pDatumSave ) pDatumP->pNext = pDatumSave ;

                break ;
            }
            case LISTnAME_STRETCHbEGINoStEXTsTRZ :
            {
                puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;

                ZE( osTextT* , postv ) ;
                etherC::strSquishIF( tinP , postv , pczName + tinP.ta.pushed.u.listWalk.walk.offStretchBegin , tinP.ta.pushed.u.listWalk.walk.offStretchEnd - tinP.ta.pushed.u.listWalk.walk.offStretchBegin - 1 ) ;

                datumS* pDatumSave = pDatumP ;
                                     pDatumP = new( 0 , tinP , LF ) datumS( tinP , postv ) ; ___( pDatumP ) ;

                if( pDatumSave ) pDatumP->pNext = pDatumSave ;

                PUSE( tinP , postv ) ;

                break ;
            }
            case LISTnAME_STRETCHbEGINcOUNTsTRZ :
            {
                puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;

                ZE( countT* , pczv ) ;
                etherC::strSquishOldIF( tinP , pczv , pczName + tinP.ta.pushed.u.listWalk.walk.offStretchBegin , tinP.ta.pushed.u.listWalk.walk.offStretchEnd - tinP.ta.pushed.u.listWalk.walk.offStretchBegin - 1 ) ;

                datumS* pDatumSave = pDatumP ;
                                     pDatumP = new( 0 , tinP , LF ) datumS( tinP , pczv ) ; ___( pDatumP ) ;

                if( pDatumSave ) pDatumP->pNext = pDatumSave ;

                PUSE( tinP , *(byteT**)&pczv ) ;

                break ;
            }
        }
        //{ puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ; PUSE( tinP , *(byteT**)&pczName ) ; }
        tinP.tlsDelF( *(byteT**)&pczName ) ;
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flrc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b5.listwalkenumeratecbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b6.gossipcbf BEGIN
#define DDNAME       "3func.330000b6.gossipcbf"
#define DDNUMB      (countT)0x330000b6
#define IDFILE      (countT)0x995


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/boolT gossipCBF( tinS& tinP , assViewC& assViewP , associateC& vieweeP , associateC& viewerP , const countT cArgP , staqC* const pStqWalkerP )/*1*/
{
    countT*     pcArg       =      (countT*)cArgP      ;
    associateC& originP     = *(associateC*)pcArg[ 0 ] ;
    countT      idTypeP     =               pcArg[ 1 ] ;
    countT      idMsgP      =               pcArg[ 2 ] ;
    countT      cArgCallerP =               pcArg[ 3 ] ;

    return vieweeP.hearGossipF( tinP , originP , idTypeP , idMsgP , cArgCallerP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b6.gossipcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b7.unregisterobsoletedriversf BEGIN
#define DDNAME       "3func.330000b7.unregisterobsoletedriversf"
#define DDNUMB      (countT)0x330000b7
#define IDFILE      (countT)0x996


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//CODEsYNC: 1050104 10200dc

/*1*/voidT unregisterObsoleteDriversF( tinS& tinP , thirdC& thirdP , const osTextT* const postNameNewP )/*1*/
{
    stackC stDriver( tinP , thirdP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_byteT ) ;
    thirdP.osDriversF( tinP , stDriver , T("IdeaFarm.H")+TF2(etherC::ifc_idHomeIdisk_IF(),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".") ) ; //U::FUNCTION CHANGED; NOW RETURNS -ALL- DRIVERS, NOT JUST INACTIVE
    while( stDriver )
    {
        ZE( osTextT* , postn ) ;
        stDriver >> postn ;

        ZE( countT , idHomeOld ) ;
        ZE( countT , idAdamOld ) ;
        ZE( countT , idVersionOld ) ;
        tinP.pEther->osDriverParseNameF( tinP , idHomeOld , idAdamOld , idVersionOld , T(postn) ) ;

        ZE( countT , idHomeNew ) ;
        ZE( countT , idAdamNew ) ;
        ZE( countT , idVersionNew ) ;
        tinP.pEther->osDriverParseNameF( tinP , idHomeNew , idAdamNew , idVersionNew , T(postNameNewP) ) ;

        if( idAdamOld == idAdamNew && idVersionOld != idVersionNew )
        {
            IFsCRATCH
            {
                SCOOPS
                ((thirdC&)*tinP.pEtScratch).osDriverUnregisterF( tinP , T(postn) ) ; //DONE WOTH BECAUSE FIRING MIGHT TIME OUT OR BLAMMO
                if( POOP ) { POOPR ; }
                ((thirdC&)*tinP.pEtScratch).osDriverFireF( tinP , T(postn) ) ;
                if( POOP ) { POOPR ; }
            }
        }

        thirdP.delF( tinP , postn ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b7.unregisterobsoletedriversf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b8.tinwalkerf BEGIN
#define DDNAME       "3func.330000b8.tinwalkerf"
#define DDNUMB      (countT)0x330000b8
#define IDFILE      (countT)0x997


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT tinWalkerF( tinS& tinP , tinS& tinFocusP , countT& cArgP )/*1*/
{
    if( tinP.osTid != tinFocusP.osTid )
    {
        //CONoUTrAW( "freezing " ) ;
        //CONoUTrAW( tinFocusP.postThreadName ) ;
        //CONoUTrAW( "\r\n" ) ;

        thirdC::dosSuspendThreadIF( tinP , tinFocusP.osTid ) ;
    }

    if( cArgP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b8.tinwalkerf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b9.writehtmlfilesf BEGIN
#define DDNAME       "3func.330000b9.writehtmlfilesf"
#define DDNUMB      (countT)0x330000b9
#define IDFILE      (countT)0x998


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT writeHtmlFilesF( tinS& tinP , etherC& ether , const boolT bOneFileP , const strokeS* const psttLikeLocalP , const strokeS* const psttLikeP , const strokeS* const psttTitleP , const strokeS* const psttOldCopyrightP , htmlS*& pHtmlRootP , const countT cSonsP , countT cOpenTriesP )/*1*/
{
    if( ether ) return ;
    __Z( psttLikeP ) ;
    __Z( psttTitleP ) ;
    __Z( pHtmlRootP ) ;
    if( ether ) return ;

    ZE( strokeS* , psttLikeLocal ) ;
    if( psttLikeLocalP ) { ether.strMakeF( tinP , LF , psttLikeLocal , psttLikeLocalP ) ; ___( psttLikeLocal ) ; }
    else
    {
        countT ids = ether.strIdF( tinP , S1C('/') , psttLikeP ) ;
        __Z( ids ) ;
        __( ids == psttLikeP->idAdam ) ;
        ZE( countT , idl ) ;
        ether.strSubstringF( tinP , psttLikeLocal , ids , idl , psttLikeP ) ; ___( psttLikeLocal ) ;
    }

    ZE( strokeS* , psttLikeShort ) ;
    //ether.strReplaceF( tinP , psttLikeShort , psttLikeP , T("www.ideafarm.com///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/") , T("www.ideafarm.com/") ) ;
    ether.strReplaceF( tinP , psttLikeShort , psttLikeP , T("www.ideafarm.com///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/") , T("") ) ;

    TN( tLog , "///d/ideafarm.log.html" ) ;
    //etherC::ifcSayIF( T("writeHtmlFilesF/about to write each html file") , flSAY_APPEND | flSAY_LOG ) ;
    ZE( countT , idLathI ) ;
    ZE( htmlS* , pHtml ) ;
    ZE( htmlS* , pHtmlDownFrom ) ;
    ZE( boolT , fDown ) ;
    pHtml = pHtmlRootP ;
    stackC stOneFile( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_count3S  ) ;
    while( !STOP && pHtml )
    {
        if( !fDown )
        {
            if( pHtml->psttName )
            {
                //etherC::ifcSayIF( T("writeHtmlFilesF/file/\"")+T(pHtml->psttName)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
                ZE( countT , idSon ) ;
                ZE( boolT , fPrevious2 ) ;
                ZE( strokeS* , psttStack ) ;
                ether.strMakeF( tinP , LF , psttStack , T("") , cSonsP * 0x1000 ) ;
                ZE( htmlS* , pHtmlKid ) ;
                pHtmlKid = pHtml->pU ;
                __Z( pHtmlKid ) ;
                while( !ether && pHtmlKid )
                {
                    if( pHtmlKid->postIdea )
                    {
                        if( !fPrevious2 ) fPrevious2 = 1 ;
                        else              ether.strFuseF( tinP , psttStack , T("\r\n") ) ; ___( psttStack ) ;
                        //if( pHtmlKid->psttName ) { ether.strFuseF( tinP , psttStack , T("<A HREF=\"http://")+T(psttLikeShort)+T(".")+T(pHtmlKid->psttName)+T(/*".html"*/ ".0" "\">")+T(pHtmlKid->postIdea)+T("</A>") ) ; ___( psttStack ) ; }
                        if( pHtmlKid->psttName ) { ether.strFuseF( tinP , psttStack , T("<A HREF=\"")+T(psttLikeShort)+T(".")+T(pHtmlKid->psttName)+T(/*".html"*/ ".0.html" "\">")+T(pHtmlKid->postIdea)+T("</A>") ) ; ___( psttStack ) ; }
                        else                     { ether.strFuseF( tinP , psttStack ,                                                                                       T(pHtmlKid->postIdea)           ) ; ___( psttStack ) ; }
                    }
                    pHtmlKid = pHtmlKid->pR ;
                }

                ZE( strokeS* , psttDad ) ;
                if( pHtml->psttName && pHtml->psttName->idAdam )
                {
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;

                    countT idd = ether.strIdF( tinP , countTC( 1 ) , sttq , S1C('.') , pHtml->psttName , 0 , - 1 ) ;
                    if( idd )
                    {
                        __( idd == 1 ) ;
                        idd -- ;
                        countT idf = 1 ;
                        ether.strSubstringF( tinP , psttDad , idf , idd , pHtml->psttName ) ; ___( psttDad ) ;
                    }
                }

                if( !pHtml->psttName->idAdam ) { ether.strMakeF( tinP , LF , pHtml->postIdea , psttTitleP ) ; ___( pHtml->postIdea ) ; }
                ether.strReverseF( tinP , psttStack , 0 , T("\r\n") ) ; ___( psttStack ) ;

                //OLD: ZE( strokeS* , psttFinal ) ;
                //OLD: {
                //OLD:     TN( tBody , "" ) ; tBody = T(psttStack) ;
                //OLD:     TN( tTitle , pHtml->postIdea ) ;
                //OLD: 
                //OLD:     TN( tHtml , "" ) ; tHtml = TEXThTMLhEADER( tTitle ) + TEXThTMLbODYpREFIX + tBody + TEXThTMLbODYsUFFIX ;
                //OLD:     ether.strMakeF( tinP , LF , psttFinal , TEXThTTPhEADER(tHtml.csF(tinP)) + tHtml ) ; ___( psttFinal ) ;
                //OLD: }

                //OLD: if( !bOneFileP )
                //OLD: {
                //OLD:     strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                //OLD:     strokeS* psttd = psttFinal ; psttFinal = 0 ;
                //OLD:     countT idf = ether.strIdF( tinP , T("<!--") , psttd ) ;
                //OLD:     ZE( countT , idl ) ;
                //OLD:     ether.strSubstringF( tinP , psttFinal , idf , idl , psttd ) ; ___( psttFinal ) ;
                //OLD:     ether.delF( tinP , psttd ) ;
                //OLD: }

                //OLD: ZE( osTextT* , postFinal ) ;
                //OLD: countT costFinal = ether.strMakeF( tinP , LF , postFinal , psttFinal ) ; ___( postFinal ) ;
                //OLD: ether.delF( tinP , psttFinal ) ;

                TN( tDad  , "" ) ; tDad = T(psttDad) ;
                TN( tTitle , pHtml->postIdea ) ;
                TN( tBody , "" ) ; tBody = T(psttStack) ;
                ether.delF( tinP , psttStack ) ;
                ether.delF( tinP , psttDad ) ;

                //IMAGE LAYOUT
                // costDad
                // postDad
                // costTitle
                // postTitle
                // costBody
                // postBody

                ZE( byteT* , pbFinal ) ;
                countT cbaFinal = 3 * ( sizeof( countT ) + 1 ) + tDad.csF( tinP ) + tTitle.csF( tinP ) + tBody.csF( tinP ) ;
                ether.newF( tinP , LF , pbFinal , cbaFinal ) ; ___( pbFinal ) ;
                if( pbFinal )
                {
                    ZE( countT , offo ) ;
                    *(countT*)( pbFinal + offo ) =   tDad.csF( tinP ) ; offo += sizeof( countT ) ; ether.memCopyF( tinP , pbFinal + offo , tDad   ,   tDad.csF( tinP ) ) ; offo +=   tDad.csF( tinP ) ; pbFinal[ offo ++ ] = 0 ;
                    *(countT*)( pbFinal + offo ) = tTitle.csF( tinP ) ; offo += sizeof( countT ) ; ether.memCopyF( tinP , pbFinal + offo , tTitle , tTitle.csF( tinP ) ) ; offo += tTitle.csF( tinP ) ; pbFinal[ offo ++ ] = 0 ;
                    *(countT*)( pbFinal + offo ) =  tBody.csF( tinP ) ; offo += sizeof( countT ) ; ether.memCopyF( tinP , pbFinal + offo , tBody  ,  tBody.csF( tinP ) ) ; offo +=  tBody.csF( tinP ) ; pbFinal[ offo ++ ] = 0 ;
                    __( offo - cbaFinal ) ;
                }

                textC tFile = T(psttLikeLocal) + ( pHtml->psttName->idAdam ? T(".")+T(pHtml->psttName) : T("") ) + ( bOneFileP ? T("") : T(".0.html") ) ;
                if( !bOneFileP )
                {
                    ether.boxPutF( tinP , tFile , pbFinal , cbaFinal , cOpenTriesP ) ;
                    ether.delF( tinP , pbFinal ) ;
                }
                else
                {
                    ZE( count3S* , pc3b ) ;
                    ether.newF( tinP , LF , pc3b ) ; ___( pc3b ) ;
                    if( pc3b )
                    {
                        ZE( strokeS* , psttName ) ;
                        ether.strMakeF( tinP , LF , psttName , tFile ) ; ___( psttName ) ;
                        pc3b->c1 = (countT)psttName ;
                        pc3b->c2 = cbaFinal ;
                        pc3b->c3 = (countT)pbFinal ;
                        stOneFile << pc3b ;
                    }
                }
            }
        }

        if( !fDown )
        {
                 if( pHtml->pU ) pHtml = pHtml->pU ;
            else if( pHtml->pR ) pHtml = pHtml->pR ;
            else
            {
                fDown = 1 ;
                pHtmlDownFrom = pHtml ;
                if( pHtml->pL ) pHtml = pHtml->pL ;
                else            pHtml = pHtml->pD ;
            }
        }
        else
        {
            if( pHtml->pR && pHtml->pR != pHtmlDownFrom ) { fDown = 0 ;             pHtml = pHtml->pR ; }    
            else if( pHtml->pL )                          { pHtmlDownFrom = pHtml ; pHtml = pHtml->pL ; }
            else                                          { pHtmlDownFrom = pHtml ; pHtml = pHtml->pD ; }
        }
    }
    __( STOP ) ;

    if( bOneFileP && stOneFile )
    {
        countT cba = sizeof( countT ) ;
        {
            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            do
            {
                count3S* pc3b = (count3S*)stOneFile.downF( tinP , handle ) ;
                if( pc3b && pc3b->c1 && pc3b->c3 ) cba += sizeof( strokeS ) * ( CSpREFIX + ((strokeS*)pc3b->c1)->idAdam ) + sizeof( countT ) + pc3b->c2 ;
                else                               __1
            }
            while( ~handle ) ;
        }

        ZE( byteT* , pba ) ;
        ether.newF( tinP , LF , pba , cba ) ; ___( pba ) ;

        if( pba )
        {
            *(countT*)pba = ifcIDfILEtYPE_PACKED ;
            countT off = sizeof( countT ) ;
            while( stOneFile )
            {
                ZE( count3S* , pc3b ) ;
                stOneFile >> pc3b ;
                if( pc3b && pc3b->c1 && pc3b->c3 )
                {
                    strokeS* psttName   = (strokeS*)pc3b->c1 ;
                    countT   costFinal  =           pc3b->c2 ;
                    osTextT* postFinal  = (osTextT*)pc3b->c3 ;

                    countT cbn = sizeof( strokeS ) * ( CSpREFIX + psttName->idAdam ) ;
                    ether.memCopyF( tinP , pba + off , (byteT*)psttName , cbn ) ;
                    off += cbn ;
                    ether.delF( tinP , psttName ) ;

                    ether.memCopyF( tinP , pba + off , (byteT*)&costFinal , sizeof costFinal ) ;
                    off += sizeof( countT ) ;

                    if( costFinal )
                    {
                        ether.memCopyF( tinP , pba + off , postFinal , costFinal ) ;
                        off += costFinal ;
                    }
                    ether.delF( tinP , postFinal ) ;
                }
                ether.delF( tinP , pc3b ) ;
            }
        }

        ether.boxPutF( tinP , psttLikeLocal , pba , cba , cOpenTriesP ) ;
        ether.delF( tinP , pba ) ;
    }

    ether.delF( tinP , psttLikeLocal ) ;
    ether.delF( tinP , psttLikeShort ) ;
    if( psttOldCopyrightP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000b9.writehtmlfilesf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ba.newsonf BEGIN
#define DDNAME       "3func.330000ba.newsonf"
#define DDNUMB      (countT)0x330000ba
#define IDFILE      (countT)0x999


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT newSonF( tinS& tinP , etherC& ether , const htmlS* const pHtmlP , const strokeS* const psttP , htmlS*& pHtmlRootP )/*1*/
{
    if( ether ) return ;
    __Z( psttP ) ;
    __Z( pHtmlP ) ;
    if( ether ) return ;

    ZE( htmlS* , pHtml ) ;
    pHtml = (htmlS*)pHtmlP ;
    if( !pHtml->pU )
    {
        pHtml->pU = new( 0 , tinP , LF ) htmlS( tinP , ether , pHtmlRootP ) ; ___( pHtml->pU ) ;
        __( !pHtml->pU ) ;
        if( pHtml->pU ) pHtml->pU->pD = pHtml ;
        pHtml = pHtml->pU ;
    }
    else
    {
        pHtml = pHtml->pU ;
        while( pHtml->pR ) pHtml = pHtml->pR ;
        pHtml->pR = new( 0 , tinP , LF ) htmlS( tinP , ether , pHtmlRootP ) ; ___( pHtml->pR ) ;
        if( pHtml->pR ) pHtml->pR->pL = pHtml ;
        pHtml = pHtml->pR ;
    }

    if( pHtml ) { ether.strMakeF( tinP , LF , pHtml->postIdea , psttP ) ; ___( pHtml->postIdea ) ; }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ba.newsonf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000bb.rpttreef BEGIN
#define DDNAME       "3func.330000bb.rpttreef"
#define DDNUMB      (countT)0x330000bb
#define IDFILE      (countT)0x99a


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//HANDY FOR DEBUGGING
#if defined( NEVERdEFINED )

/*1*/voidT rptTreeF( tinS& tinP , etherC& ether , htmlS* pHtmlP , countT& idLevelP )/*1*/
{
    ZE( countT , ids ) ;
    htmlS* pc = pHtmlP ;
    while( !ether && pc )
    {
        ether.strokeF( tinP , TF3(idLevelP,0,8)+TPS("-",idLevelP,S1C('-'))+TF3(++ids,0,8)+(pc->postIdea?T(pc->postIdea):T("<null>"))+T("\r\n") ) ;
        if( pc->pU )
        {
            idLevelP ++ ;
            rptTreeF( tinP , ether , pc->pU , idLevelP ) ;
            idLevelP -- ;
        }
        pc = pc->pR ;
    }
}
#endif


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000bb.rpttreef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000bc.cellscancalendarf BEGIN
#define DDNAME       "3func.330000bc.cellscancalendarf"
#define DDNUMB      (countT)0x330000bc
#define IDFILE      (countT)0x99b


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT cellScanCalendarF( tinS& tinP , etherC& ether , strokeS*& psttP , const countT oScanP , const countT oDayP , const countT oTodayP , const countT cColP , countT time2P , strokeS** ppsttDayOfWeekP , strokeS** ppsttMonthP )/*1*/
{
    time2P &= 0xffffff00 ;
    time2P |= oDayP ;

    TN( tOld , "" ) ;
    {
        ZE( countT , ms ) ;
        ZE( countT , ss ) ;
        ZE( countT , mm ) ;
        ZE( countT , hh ) ;
        ZE( countT , da ) ;
        ZE( countT , mo ) ;
        ZE( sCountT , ye ) ;
        ZE( countT , dow ) ;
        { ZE( countT , time1 ) ; ether.osTimeToOldTimeF( tinP , ms , ss , mm , hh , da , mo , ye , dow , time1 , time2P , flOStIMEfROMoLDtIME_OLDtIMEiSutc ) ; }
        tOld = T(ppsttDayOfWeekP[dow])+TF4(da+1,flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2,0xa)+T(ppsttMonthP[mo])+TF4((ye+1)%100,flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2,0xa) ;
    }

    if( oDayP == oTodayP )
    {
        switch( oScanP )
        {
            case 0  : { ether.strFuseF( tinP , psttP , TPS("@",cColP,S1C('@')) ) ; break ; }
            case 1  : { ether.strFuseF( tinP , psttP , T("@")+TF3(time2P,flFORMAT_NObIGITvALUES,cColP-1) ) ; break ; }
            case 2  : { ether.strFuseF( tinP , psttP , T("@")+tOld+TP("",cColP-tOld.csF(tinP)-1) ) ; break ; }
            default : { ether.strFuseF( tinP , psttP , TP("@",cColP) ) ; break ; }
        }
    }
    else if( oDayP == oTodayP + 8 )
    {
        switch( oScanP )
        {
            case 0  : { ether.strFuseF( tinP , psttP , TPS("@",cColP,S1C('@')) ) ; break ; }
            case 1  : { ether.strFuseF( tinP , psttP , T("|")+TF3(time2P,flFORMAT_NObIGITvALUES,cColP-1) ) ; break ; }
            case 2  : { ether.strFuseF( tinP , psttP , T("|")+tOld+TP("",cColP-tOld.csF(tinP)-1) ) ; break ; }
            default : { ether.strFuseF( tinP , psttP , TP("|",cColP) ) ; break ; }
        }
    }
    else if( oDayP == oTodayP + 9 && oTodayP % 8 != 7 )
    {
        switch( oScanP )
        {
            case 0  : { ether.strFuseF( tinP , psttP , TPS("@",cColP,S1C('-')) ) ; break ; }
            case 1  : { ether.strFuseF( tinP , psttP , T("|")+TF3(time2P,flFORMAT_NObIGITvALUES,cColP-1) ) ; break ; }
            case 2  : { ether.strFuseF( tinP , psttP , T("|")+tOld+TP("",cColP-tOld.csF(tinP)-1) ) ; break ; }
            default : { ether.strFuseF( tinP , psttP , TP("|",cColP) ) ; break ; }
        }
    }
    else if( oDayP == oTodayP + 1 && oTodayP % 8 != 7 )
    {
        switch( oScanP )
        {
            case 0  : { ether.strFuseF( tinP , psttP , TPS("@",cColP,S1C('-')) ) ; break ; }
            case 1  : { ether.strFuseF( tinP , psttP , T("@")+TF3(time2P,flFORMAT_NObIGITvALUES,cColP-1) ) ; break ; }
            case 2  : { ether.strFuseF( tinP , psttP , T("@")+tOld+TP("",cColP-tOld.csF(tinP)-1) ) ; break ; }
            default : { ether.strFuseF( tinP , psttP , TP("@",cColP) ) ; break ; }
        }
    }
    else
    {
        switch( oScanP )
        {
            case 0  : { ether.strFuseF( tinP , psttP , TPS("+",cColP,S1C('-')) ) ; break ; }
            case 1  : { ether.strFuseF( tinP , psttP , T("|")+TF3(time2P,flFORMAT_NObIGITvALUES,cColP-1) ) ; break ; }
            case 2  : { ether.strFuseF( tinP , psttP , T("|")+tOld+TP("",cColP-tOld.csF(tinP)-1) ) ; break ; }
            default : { ether.strFuseF( tinP , psttP , TP("|",cColP) ) ; break ; }
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000bc.cellscancalendarf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000bd.cellscanclockf BEGIN
#define DDNAME       "3func.330000bd.cellscanclockf"
#define DDNUMB      (countT)0x330000bd
#define IDFILE      (countT)0x99c


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT cellScanClockF( tinS& tinP , etherC& ether , strokeS*& psttP , const countT oScanP , const countT oTickP , const countT oTickNowP , const countT cColP )/*1*/
{
    countT time1 = oTickP << 0x18 ;

    TN( tOld , "" ) ;
    {
        ZE( countT , ms ) ;
        ZE( countT , ss ) ;
        ZE( countT , mm ) ;
        ZE( countT , hh ) ;
        ZE( countT , da ) ;
        ZE( countT , mo ) ;
        ZE( sCountT , ye ) ;
        ZE( countT , dow ) ;
        { ZE( sCountT , time2 ) ; ether.osTimeToOldTimeF( tinP , ms , ss , mm , hh , da , mo , ye , dow , time1 , time2 , flOStIMEfROMoLDtIME_OLDtIMEiSutc ) ; }
        tOld = TF4(hh,flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa)+T(":")+TF4(mm,flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa)+T(":")+TF4(ss,flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ;
    }

    if( oTickP == oTickNowP )
    {
        switch( oScanP )
        {
            case 0  : { ether.strFuseF( tinP , psttP , TPS("@",cColP,S1C('@')) ) ; break ; }
            case 1  : { ether.strFuseF( tinP , psttP , T("@")+TF3(oTickP,0,cColP-1) ) ; break ; }
            case 2  : { ether.strFuseF( tinP , psttP , T("@")+tOld+TP("",cColP-tOld.csF(tinP)-1) ) ; break ; }
            default : { ether.strFuseF( tinP , psttP , TP("@",cColP) ) ; break ; }
        }
    }
    else if( oTickP == oTickNowP + 0x10 )
    {
        switch( oScanP )
        {
            case 0  : { ether.strFuseF( tinP , psttP , TPS("@",cColP,S1C('@')) ) ; break ; }
            case 1  : { ether.strFuseF( tinP , psttP , T("|")+TF3(oTickP,0,cColP-1) ) ; break ; }
            case 2  : { ether.strFuseF( tinP , psttP , T("|")+tOld+TP("",cColP-tOld.csF(tinP)-1) ) ; break ; }
            default : { ether.strFuseF( tinP , psttP , TP("|",cColP) ) ; break ; }
        }
    }
    else if( oTickP == oTickNowP + 0x11 && oTickNowP % 0x10 != 0xf )
    {
        switch( oScanP )
        {
            case 0  : { ether.strFuseF( tinP , psttP , TPS("@",cColP,S1C('-')) ) ; break ; }
            case 1  : { ether.strFuseF( tinP , psttP , T("|")+TF3(oTickP,0,cColP-1) ) ; break ; }
            case 2  : { ether.strFuseF( tinP , psttP , T("|")+tOld+TP("",cColP-tOld.csF(tinP)-1) ) ; break ; }
            default : { ether.strFuseF( tinP , psttP , TP("|",cColP) ) ; break ; }
        }
    }
    else if( oTickP == oTickNowP + 1 && oTickNowP % 0x10 != 0xf )
    {
        switch( oScanP )
        {
            case 0  : { ether.strFuseF( tinP , psttP , TPS("@",cColP,S1C('-')) ) ; break ; }
            case 1  : { ether.strFuseF( tinP , psttP , T("@")+TF3(oTickP,0,cColP-1) ) ; break ; }
            case 2  : { ether.strFuseF( tinP , psttP , T("@")+tOld+TP("",cColP-tOld.csF(tinP)-1) ) ; break ; }
            default : { ether.strFuseF( tinP , psttP , TP("@",cColP) ) ; break ; }
        }
    }
    else
    {
        switch( oScanP )
        {
            case 0  : { ether.strFuseF( tinP , psttP , TPS("+",cColP,S1C('-')) ) ; break ; }
            case 1  : { ether.strFuseF( tinP , psttP , T("|")+TF3(oTickP,0,cColP-1) ) ; break ; }
            case 2  : { ether.strFuseF( tinP , psttP , T("|")+tOld+TP("",cColP-tOld.csF(tinP)-1) ) ; break ; }
            default : { ether.strFuseF( tinP , psttP , TP("|",cColP) ) ; break ; }
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000bd.cellscanclockf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000be.translatestatedrivenserverf BEGIN
#define DDNAME       "3func.330000be.translatestatedrivenserverf"
#define DDNUMB      (countT)0x330000be
#define IDFILE      (countT)0x99d


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT translateStateDrivenServerF( tinS& tinP , etherC& etherP , byteT* pbToP , countT cbToP , const byteT* pbFromP , countT cbFromP , byteT* pbToVaryingP , countT cbToVaryingP , const byteT* pbFromVaryingP , countT cbFromVaryingP , countT cArgP )/*1*/
{
    if( cbToP )
    {
        if( cbToP == cbFromP ) etherP.memCopyF( tinP , pbToP , pbFromP , cbToP ) ;
        else                   etherP.memSetF(  tinP , pbToP           , cbToP ) ;
    }

    if( tinP.pAdamGlobal1->pTranslateStateCallerCBF ) (*tinP.pAdamGlobal1->pTranslateStateCallerCBF)( tinP , etherP , 0 , 0 , 0 , 0 , pbToVaryingP , cbToVaryingP , pbFromVaryingP , cbFromVaryingP , cArgP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000be.translatestatedrivenserverf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000bf.writelinesnipf BEGIN
#define DDNAME       "3func.330000bf.writelinesnipf"
#define DDNUMB      (countT)0x330000bf
#define IDFILE      (countT)0x99e


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT writeLineSnipF( tinS& tinP , etherC& etherP , strokeS* psttIdiP , strokeS* psttIdModuleP , const strokeS* const psttP )/*1*/
{
    countT cLines = etherP.strCLinesF( tinP , psttP ) ;
    ZE( osTextT* , postd ) ;
    countT costd = etherP.strMakeF( tinP , LF , postd , T("#define ClINESiNdEF 0x")+TF2(cLines,flFORMAT_FOREIGN)+T("\r\n") ) ; ___( postd ) ;
    etherP.boxPutF( tinP , T("///ideafarm/precious/domains/com/ideafarm/city/library/snip/1snip.")+T(psttIdiP)+T(".")+T(psttIdModuleP)+T(".ClINESiNdEF") , postd , costd ) ;
    etherP.delF( tinP , postd ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000bf.writelinesnipf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c0.pushlabelsf BEGIN
#define DDNAME       "3func.330000c0.pushlabelsf"
#define DDNUMB      (countT)0x330000c0
#define IDFILE      (countT)0x99f


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT pushLabelsF( tinS& tinP , etherC& ether , stackC& stP , countT& offoP , count01T& cbDataP , soulC& soulP , switchC& swOffP , strokeS*& psttlP )/*1*/
{
    ZE( strokeS* , psttw ) ;
    soulP >> psttw ; ___( psttw ) ;

    ZE( count2S* , pc2s ) ;
    ether.newF( tinP , LF , pc2s ) ; ___( pc2s ) ;
    if( pc2s )
    {
        countT offoSave = offoP ;
        pc2s->c2 = pc2s->c1 = 0 ;
        ether.dnsLabelsF( tinP , (byteT*&)pc2s->c1 , pc2s->c2 , psttw , swOffP , psttlP ) ; ___( (byteT*&)pc2s->c1 ) ;
        stP << pc2s ;
        offoP += pc2s->c2 ;
        cbDataP += (count01T)pc2s->c2 ;

        psttlP = psttw ;
        swOffP = offoSave ;
        psttlP = 0 ;
    }
    ether.delF( tinP , psttw ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c0.pushlabelsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c1.endsf BEGIN
#define DDNAME       "3func.330000c1.endsf"
#define DDNUMB      (countT)0x330000c1
#define IDFILE      (countT)0x9a0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT endsF( tinS& tinP , etherC& ether , countT& idcInP , countT& idrInP , countT& idcOutP , countT& idrOutP , const countT cP , const countT idColP , const countT idRowP , const countT cColP , const countT cRowP , const countT cHandP , const countT idHandP )/*1*/
{
    IFbEcAREFUL
    {
        if( ether ) return ;
    }

    ORIGIN

    measureT mRatio = (measureT)cP / ( (measureT)MAXcOUNTT + 1  ) ; // PORTION OF THE FULL ARC THAT HAS BEEN SWEPT

    measureT mRad0 = mRatio * 2 * PI  ; // RELATIVE TO RIGHT SIDE EXTREMUM; INCREASING COUNTERCLOCKWISE
    measureT mRad  = 3 * PI / 2 - mRad0 ; // RELATIVE TO BASE SIDE EXTREMUM; INCREASING CLOCKWISE

    measureT mCos = thirdC::mathCosIF( tinP , mRad ) ;
    measureT mSin = thirdC::mathSinIF( tinP , mRad ) ;
    measureT mTan = mSin / mCos ;
    measureT mNat = mCos / mSin ;

    ZE( measureT , mIdcb ) ; // "b" IS FOR "BOX", I.E. FOR THE POINT ON THE PERIMETER BOX
    ZE( measureT , mIdrb ) ;
    countT offPhase = offTICK( cP ) / 0x20 ;
    switch( offPhase )
    {
        case 0 : { mIdcb = mIdco - mCc * mNat / 2 ; mIdrb = mIdro - mCr        / 2 ; break ; }
        case 1 : { mIdcb = mIdco - mCc        / 2 ; mIdrb = mIdro - mCr * mTan / 2 ; break ; }
        case 2 : { mIdcb = mIdco - mCc        / 2 ; mIdrb = mIdro - mCr * mTan / 2 ; break ; }
        case 3 : { mIdcb = mIdco + mCc * mNat / 2 ; mIdrb = mIdro + mCr        / 2 ; break ; }
        case 4 : { mIdcb = mIdco + mCc * mNat / 2 ; mIdrb = mIdro + mCr        / 2 ; break ; }
        case 5 : { mIdcb = mIdco + mCc        / 2 ; mIdrb = mIdro + mCr * mTan / 2 ; break ; }
        case 6 : { mIdcb = mIdco + mCc        / 2 ; mIdrb = mIdro + mCr * mTan / 2 ; break ; }
        case 7 : { mIdcb = mIdco - mCc * mNat / 2 ; mIdrb = mIdro - mCr        / 2 ; break ; }
    }

    measureT mIn  = (measureT)( idHandP - 1 ) / (measureT)cHandP ;
    measureT mOut = (measureT)( idHandP     ) / (measureT)cHandP ;

    idcInP  = mIdco + ( mIdcb - mIdco ) * mIn  + 0.5 ;
    idrInP  = mIdro + ( mIdrb - mIdro ) * mIn  + 0.5 ;
    idcOutP = mIdco + ( mIdcb - mIdco ) * mOut + 0.5 ;
    idrOutP = mIdro + ( mIdrb - mIdro ) * mOut + 0.5 ;

    if( tinP.fingerprint ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c1.endsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c2.getstrokes BEGIN
#define DDNAME       "3func.330000c2.getstrokes"
#define DDNUMB      (countT)0x330000c2
#define IDFILE      (countT)0x9a1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT _export getStrokeS( strokeS& sttP , const byteT* const pbP , countT& offbiP )/*1*/
{
    countT bAdamTiny   = valueInF( pbP , offbiP , 1                    ) ;
    countT bAlphabet1  = valueInF( pbP , offbiP , 1                    ) ;
    countT cBytesNote  = valueInF( pbP , offbiP , 3                    ) ;
    sttP.idAdam = valueInF( pbP , offbiP , bAdamTiny ? 8 : 0x20 ) ;

    sttP.idCaste = sc_cALPHABET1 ;
    if( !bAlphabet1 )
    {
        sttP.idCaste &= ~( 0xfff ) ;
        sttP.idCaste |= valueInF( pbP , offbiP , 0xc ) ;

        if( sttP.idCaste == sc_cADAM ) sttP.registerF() ;
    }

    sttP.cNote = 0 ;
    if( cBytesNote ) sttP.cNote = valueInF( pbP , offbiP , cBytesNote * SB ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c2.getstrokes END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c3.adjustoldpairf BEGIN
#define DDNAME       "3func.330000c3.adjustoldpairf"
#define DDNUMB      (countT)0x330000c3
#define IDFILE      (countT)0x9a2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT adjustOldPairF( countT& idP , plateS*& ppP , countT idSlotTargetP , const countT idActionP )/*1*/
{
    switch( idActionP )
    {
        case ifcIDaCTIONsTACKaDJUSTrEFS_DELETED :
        {
            if( idP > idSlotTargetP ) -- idP ;
            else if( idP == idSlotTargetP )
            {
                if( (ppP)->ppU )
                {
                    ppP = (ppP)->ppU ;
                    -- idP ;
                }
                else if( (ppP)->ppD ) ppP = (ppP)->ppD ;
                else
                {
                    ppP = 0 ;
                    idP = 0 ;
                }
            }
            break ;
        }
        case ifcIDaCTIONsTACKaDJUSTrEFS_NEWaBOVE :
        {
            if( idP >= idSlotTargetP ) ++ idP ;
            break ;
        }
        case ifcIDaCTIONsTACKaDJUSTrEFS_NEWbELOW :
        {
            if( idP > idSlotTargetP ) ++ idP ;
            break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c3.adjustoldpairf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c4.translatestatedefaultf BEGIN
#define DDNAME       "3func.330000c4.translatestatedefaultf"
#define DDNUMB      (countT)0x330000c4
#define IDFILE      (countT)0x9a3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT translateStateDefaultF( tinS& tinP , etherC& etherP , byteT* pbToP , countT cbToP , const byteT* pbFromP , countT cbFromP , byteT* pbToVaryingP , countT cbToVaryingP , const byteT* pbFromVaryingP , countT cbFromVaryingP , countT cArgP )/*1*/
{
    _IO_
    if( cbToP )
    {
        if( cbToP == cbFromP )               etherP.memCopyF( tinP , pbToP        , pbFromP        , cbToP ) ;
        else                                 etherP.memSetF(  tinP , pbToP                         , cbToP ) ;
    }

    if( cbToVaryingP )
    {
        if( cbToVaryingP == cbFromVaryingP ) etherP.memCopyF( tinP , pbToVaryingP , pbFromVaryingP , cbToVaryingP ) ;
        else                                 etherP.memSetF(  tinP , pbToVaryingP                  , cbToVaryingP ) ;
    }

    if( cArgP ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c4.translatestatedefaultf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c5.bodyf BEGIN
#define DDNAME       "3func.330000c5.bodyf"
#define DDNUMB      (countT)0x330000c5
#define IDFILE      (countT)0x9a4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT bodyF( tinS& tinP , etherC& etherP , strokeS*& psttP , const strokeS& sttP )/*1*/
{
    if( sttP.idCaste == sc_cADAM && !psttP )
    {
        ZE( soulC* , psFeatures ) ;
        sttP.featuresF( tinP , psFeatures ) ;
    
        {
            ZE( countT , idCaste ) ;
            ZE( countT , idAdam ) ;
            *psFeatures >> idCaste ;
            *psFeatures >> idAdam ;
        }
    
        TN( tBody , "" ) ;
        if( psFeatures )
        {
            ZE( soulC* , psFeature ) ;
            etherP( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            if( psFeature )
            {
                while( (countT)*psFeatures )
                {
                    ZE( countT , idTypeItem ) ;
                    psFeatures->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                    if( idTypeItem != ifcIDtYPEsOULiTEM_soulC ) break ;
    
                    *psFeatures >> *psFeature ;
    
                    idTypeItem = 0 ;
                    const byteT* pb_idType = psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                    if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                    {
                        ZE( countT , idType ) ;
                        *psFeature >> idType ;
    
                        switch( idType )
                        {
                            case ifcIDtYPEfEATUREsADAM_BODY :
                            {
                                ZE( countT , idTypeItem ) ;
                                psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                                if( idTypeItem == ifcIDtYPEsOULiTEM_strokeSptr ) *psFeature >> psttP ;
                                break ;
                            }
                        }
                    }
                    psFeature->removeAllF( tinP ) ;
                }
            }
            etherP( tinP , psFeature ) ;
        }
        etherP( tinP , psFeatures ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c5.bodyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c6.joyposf BEGIN
#define DDNAME       "3func.330000c6.joyposf"
#define DDNUMB      (countT)0x330000c6
#define IDFILE      (countT)0x9a5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT joyPosF( tinS& tinP , measureT* pmxP , const countT cmxP , const countT idJoyP )/*1*/
{
    __Z( pmxP ) ;
    __( cmxP - 7 ) ;

    countT idTool = idJoyP == 1 ? ifcIDtYPEtOOL_JOY1pOSITION : ifcIDtYPEtOOL_JOY2pOSITION ;

    countT pxNew[ 7 ] =
    {
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_17[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_27[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_37[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_47[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_57[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_67[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_77[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ]
    }
    ;

    countT pxMin[ 7 ] =
    {
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_17Min[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_27Min[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_37Min[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_47Min[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_57Min[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_67Min[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_77Min[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ]
    }
    ;

    countT pxMax[ 7 ] =
    {
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_17Max[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_27Max[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_37Max[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_47Max[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_57Max[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_67Max[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
        tinP.pAdamGlobal1->_backOldC_.rowBack.ro.pcToolState_77Max[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ]
    }
    ;

    for( countT off = 0 ; off < 7 ; off ++ )
    {
        countT range = pxMax[ off ] - pxMin[ off ] ;
        pmxP[ off ] = !range
            ? 0.0
            : (measureT)( pxNew[ off ] - pxMin[ off ] ) / (measureT)range
        ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c6.joyposf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c7.homeoldcbf BEGIN
#define DDNAME       "3func.330000c7.homeoldcbf"
#define DDNUMB      (countT)0x330000c7
#define IDFILE      (countT)0x9a6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

#if defined( NEVERdEFINED )

/*1*/voidT homeOldCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    sessionC& session = sessionsP( tinP , nnPeerP ) ;

    //POPUP( T(psttUrlP) ) ;

    //CS:CODEsYNC: 1d20003: FACES (BUY CATALOG PAGES)
    osTextT* ppostKey[] =
    {
        postFACEkEY_POWERtOOLS   ,
        postFACEkEY_COVER        ,
        postFACEkEY_WORK         ,
        postFACEkEY_DIRECTORY    ,
        postFACEkEY_TRUST        ,
        postFACEkEY_EMAIL        ,
        postFACEkEY_BASICPACKAGE ,
        postFACEkEY_DEPOSIT      ,
        postFACEkEY_MISSION      ,
        postFACEkEY_PEOPLE       ,
    } ;

    //CS:CODEsYNC: 1d20003: FACES (BUY CATALOG PAGES)
    osTextT* ppostTitle[] =
    {
        postIFPTS                    ,
        "Cover Letter"               ,
        postIFW                      ,
        postIFD                      ,
        postIFA                      ,
        postIFPE                     ,
        postIFCBPP                   ,
        postIFCCB " Deposit Account" ,
        postIFC " Mission Statement" ,
        "Who We Are"                 ,
    } ;
    
    const countT cFaces = sizeof ppostKey / sizeof ppostKey[ 0 ] ;

    {
        ZE( countT , idFace ) ;
        {
            TN( tKeyFace   , "face" ) ;
            TN( tValueFace , "" ) ;
    
            countT cFlavors = swKVP.cFlavorsF( tinP ) ;
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            {
                psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
    
                ZE( textC* , ptv ) ;
                if( !etThread.strCompareF( tinP , psttLeverKVP , tKeyFace ) ) ptv = &tValueFace ;
    
                if( ptv ) *ptv = T((strokeS*)(countT)swKVP) ;
            }
    
            if( tValueFace.csF( tinP ) )
            {
                for( countT offf = 0 ; offf < cFaces ; offf ++ )
                {
                    if( !etThread.strCompareF( tinP , tValueFace , T(ppostKey[offf]) ) )
                    {
                        idFace = offf + 1 ;
                        break ;
                    }
                }
            }
        }
    
        {
            session.psttLeverUrl = (strokeS*)psttUrlP ;
            count8S& c8s = *(count8S*)&(countT&)session.swPageState ;
            if( idFace ) c8s.c1 = idFace ;
            else
            {
                if( !c8s.c1 ) c8s.c1 = 1 ;
                idFace = c8s.c1 ;
            }
        }
    
        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOME1 ) ;
    
        ZE( pbRefC* , prPosts ) ;
        {
            TN( tBegin , "<OPTION VALUE=\"" ) ;

            TN( tq , "\"" ) ;
            TN( tClose , ">" ) ;

            TN( tEnd , "</OPTION>\r\n" ) ;    
    
            TN( tSelected , " SELECTED" ) ;
            ZE( strokeS* , psttw ) ;
            etThread.strMakeF( tinP , LF , psttw , 0 , TOCK ) ; ___( psttw ) ;
    
            for( countT offf = 0 ; offf < cFaces ; offf ++ )
            {
                etThread.strFuseF( tinP , psttw , tBegin ) ;
                etThread.strFuseF( tinP , psttw , T(ppostKey[offf]) ) ;
                etThread.strFuseF( tinP , psttw , tq ) ;
                if( offf + 1 == idFace ) etThread.strFuseF( tinP , psttw , tSelected ) ;
                etThread.strFuseF( tinP , psttw , tClose ) ;
                etThread.strFuseF( tinP , psttw , T(ppostTitle[offf]) ) ;
            }
    
            etThread.strMakeF( tinP , LF , prPosts , psttw , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            etThread.delF( tinP , psttw ) ;
        }
    
        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        DEL( prPosts ) ;
    
        meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOME2 ) ;
    
        switch( idFace )
        {
            //CS:CODEsYNC: 1d20003: FACES (BUY CATALOG PAGES)
            case 1 :
            {
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOMEfACE1pART1 ) ;
                break ;
            }
            case 2 :
            {
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOMEfACE2pART1 ) ;
                break ;
            }
            case 3 :
            {
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOMEfACE3pART1 ) ;
                break ;
            }
            case 4 :
            {
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOMEfACE4pART1 ) ;
                break ;
            }
            case 5 :
            {
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOMEfACE5pART1 ) ;
                break ;
            }
            case 6 :
            {
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOMEfACE6pART1 ) ;
                break ;
            }
            case 7 :
            {
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOMEfACE7pART1 ) ;
                break ;
            }
            case 8 :
            {
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOMEfACE8pART1 ) ;
                break ;
            }
            case 9 :
            {
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOMEfACE9pART1 ) ;
                break ;
            }
            case 0xa :
            {
                meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HOMEfACEapART1 ) ;
                break ;
            }
        }
    }
}

#endif


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c7.homeoldcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c8.push_pstt_f BEGIN
#define DDNAME       "3func.330000c8.push_pstt_f"
#define DDNUMB      (countT)0x330000c8
#define IDFILE      (countT)0x9a7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT push_pstt_F( tinS& tinP , stackC* const pStkP , soulC& sInP )/*1*/
{
    ZE( countT , cPlates ) ;
    sInP >> cPlates ;
        
    while( cPlates -- )
    {
        ZE( strokeS* , psttw ) ;
        sInP >> psttw ;             ___( psttw ) ;
        if( pStkP )                 *pStkP << psttw ;
        else                        PUSE( tinP , *(byteT**)&psttw ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c8.push_pstt_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c9.highdigitf BEGIN
#define DDNAME       "3func.330000c9.highdigitf"
#define DDNUMB      (countT)0x330000c9
#define IDFILE      (countT)0x9a8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT highDigitF( tinS& tinP , etherC& ether , countT& digitP , countT& fractionP , const countT radixP , countT cBitsMaxP , const boolT bHighP )/*1*/
{
    if( ether ) return 0 ;
    __( digitP ) ;
    if( ether ) return 0 ;

    _IO_
    // THIS FUNCTION REMOVES SEVERAL MOST SIGNIFICANT BITS FROM fractionP
    // IT EVALUATES TO THE NUMBER OF BITS REMOVED

    switch( radixP )
    {
        case 0x02 : { if( !cBitsMaxP || cBitsMaxP > 1 ) cBitsMaxP = 1 ; break ; }
        case 0x04 : { if( !cBitsMaxP || cBitsMaxP > 2 ) cBitsMaxP = 2 ; break ; }
        case 0x08 : { if( !cBitsMaxP || cBitsMaxP > 3 ) cBitsMaxP = 3 ; break ; }
        case 0x10 : { if( !cBitsMaxP || cBitsMaxP > 4 ) cBitsMaxP = 4 ; break ; }
        case 0x20 : { if( !cBitsMaxP || cBitsMaxP > 5 ) cBitsMaxP = 5 ; break ; }
        case 0x40 : { if( !cBitsMaxP || cBitsMaxP > 6 ) cBitsMaxP = 6 ; break ; }
        default :   { __1 break ; }
    }
    // NOW cBitsMaxP HOLDS THE EXACT NUMBER OF BITS TO EXTRACT
    // THESE BITS ARE THE LOW ORDER BITS OF THE DIGIT, UNLESS bHighP IS SET
    // THE BITS ARE ALWAYS TAKEN FROM THE HIGH END OF fractionP (REGARDLESS OF bHighP)

    // GET THE BITS    
    digitP = fractionP >> 0x18 - cBitsMaxP ;
    if( bHighP )
    {
        switch( radixP )
        {
            case 0x02 : { break ; }
            case 0x04 : { if( cBitsMaxP < 2 ) digitP <<= 2 - cBitsMaxP ; break ; }
            case 0x08 : { if( cBitsMaxP < 3 ) digitP <<= 3 - cBitsMaxP ; break ; }
            case 0x10 : { if( cBitsMaxP < 4 ) digitP <<= 4 - cBitsMaxP ; break ; }
            case 0x20 : { if( cBitsMaxP < 5 ) digitP <<= 5 - cBitsMaxP ; break ; }
            case 0x40 : { if( cBitsMaxP < 6 ) digitP <<= 6 - cBitsMaxP ; break ; }
            default :   { __1 break ; }
        }
    }

    fractionP <<= cBitsMaxP ;
    fractionP &= 0xffffff ;

    return cBitsMaxP ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000c9.highdigitf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ca.cbpdf BEGIN
#define DDNAME       "3func.330000ca.cbpdf"
#define DDNUMB      (countT)0x330000ca
#define IDFILE      (countT)0x9a9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT cbpdF( const countT radixP )/*1*/
{
         if( radixP == 0x02 ) return 1 ;
    else if( radixP == 0x04 ) return 2 ;
    else if( radixP == 0x08 ) return 3 ;
    else if( radixP == 0x10 ) return 4 ;
    else if( radixP == 0x20 ) return 5 ;
    else if( radixP == 0x40 ) return 6 ;
    else                      return 0 ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ca.cbpdf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000cb.stridnewf BEGIN
#define DDNAME       "3func.330000cb.stridnewf"
#define DDNUMB      (countT)0x330000cb
#define IDFILE      (countT)0x9aa


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//U: MOVE THIS INTO etherC

/*1*/countT strIdNewF( const countT* const pczP , const countT findThisP )/*1*/
{
    ZE( countT , idf ) ;
    if( pczP )
    {
        ZE( countT , off ) ;
        while( pczP[ off ] )
        {
            if( pczP[ off ] == findThisP )
            {
                idf = off + 1 ;
                break ;
            }
            else off ++ ;
        }
    }
    return idf ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000cb.stridnewf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000cc.subtract_nicnamec_f BEGIN
#define DDNAME       "3func.330000cc.subtract_nicnamec_f"
#define DDNUMB      (countT)0x330000cc
#define IDFILE      (countT)0x9ab


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtract_nicNameC_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
        if( !c1P || !c2P ) return 0 ;
    }

    ZE( sCountT , scSgn ) ;
    if( pEther )
    {
        etherC& ether = *(etherC*)pEther ;
        scSgn = ether.strCompareF( tinP , (countT*)c1P , (countT*)c2P , processGlobal1I.cb_nicNameC_ / sizeof( countT ) , 0 , 0 , 0 , 1 ) ; //ASSUME: nicNameC SIZE IS AN INTEGRAL MULTIPLE OF THE SIZE OF countT
    }
    else
    {
        const countT* pc1 = (countT*)c1P ;
        const countT* pc2 = (countT*)c2P ;
        sCountT off = processGlobal1I.cb_nicNameC_ / sizeof( countT ) - 1 ;
        while( off >= 0 && !scSgn )
        {
                 if( pc1[ off ] < pc2[ off ] ) scSgn = - 1 ;
            else if( pc1[ off ] > pc2[ off ] ) scSgn =   1 ;

            off -- ;
        }
    }

    if( c3P ) ;
    return scSgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000cc.subtract_nicnamec_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000cd.subtractbytestringsf BEGIN
#define DDNAME       "3func.330000cd.subtractbytestringsf"
#define DDNUMB      (countT)0x330000cd
#define IDFILE      (countT)0x9ac


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractByteStringsF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
    }

    ZE( sCountT , scSgn ) ;
    scSgn = thirdC::c_strcmpIF( tinP , (byteT*)c1P , (byteT*)c2P ) ;

    if( pEther && c3P ) ;
    return scSgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000cd.subtractbytestringsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ce.subtractblobsf BEGIN
#define DDNAME       "3func.330000ce.subtractblobsf"
#define DDNUMB      (countT)0x330000ce
#define IDFILE      (countT)0x9ad


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractBlobsF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
    }

    boolT bVarLen = !c3P ;

    byteT* pb1 = bVarLen ? (byteT*)c1P + sizeof( countT ) : (byteT*)c1P ;
    byteT* pb2 = bVarLen ? (byteT*)c2P + sizeof( countT ) : (byteT*)c2P ;

    countT cb1 = bVarLen ? *(countT*)c1P : c3P ;
    countT cb2 = bVarLen ? *(countT*)c2P : c3P ;

    countT cbm = cb1 ;    
    if( cbm > cb2 ) cbm = cb2 ;

    ZE( sCountT , scSgn ) ;
    if( cbm ) scSgn = thirdC::c_memcmpIF( tinP , pb1 , pb2 , cbm ) ;

    if( !scSgn )
    {
             if( cb1 < cb2 ) scSgn = - 1 ;
        else if( cb1 > cb2 ) scSgn =   1 ;
    }

    if( pEther ) ;
    return scSgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ce.subtractblobsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000cf.subtract_times_f BEGIN
#define DDNAME       "3func.330000cf.subtract_times_f"
#define DDNUMB      (countT)0x330000cf
#define IDFILE      (countT)0x9ae


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtract_timeS_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
        if( !c1P || !c2P ) return 0 ;
    }

    ZE( sCountT , scSgn ) ;
    if( pEther )
    {
        etherC& ether = *(etherC*)pEther ;
        scSgn = ether.strCompareF( tinP , (countT*)c1P , (countT*)c2P , sizeof( timeS ) / sizeof( countT ) , 0 , 0 , 0 , 1 ) ; //ASSUME: timeS SIZE IS AN INTEGRAL MULTIPLE OF THE SIZE OF countT
    }
    else
    {
        const countT* pc1 = (countT*)c1P ;
        const countT* pc2 = (countT*)c2P ;
        sCountT off = sizeof( timeS ) / sizeof( countT ) - 1 ;
        while( off >= 0 && !scSgn )
        {
                 if( pc1[ off ] < pc2[ off ] ) scSgn = - 1 ; //U::WILL THIS HANDLE NEGATIVE time2 VALUES CORRECTLY?
            else if( pc1[ off ] > pc2[ off ] ) scSgn =   1 ;

            off -- ;
        }
    }

    if( c3P ) ;
    return scSgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000cf.subtract_times_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d0.subtractcountstringsf BEGIN
#define DDNAME       "3func.330000d0.subtractcountstringsf"
#define DDNUMB      (countT)0x330000d0
#define IDFILE      (countT)0x9af


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractCountStringsF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
    }

    ZE( sCountT , scSgn ) ;
    if( pEther ) scSgn = ((etherC*)pEther)->strCompareF( tinP , (countT*)c1P , (countT*)c2P ) ;

    if( c3P ) scSgn = - scSgn ;
    return scSgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d0.subtractcountstringsf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d1.subtract_platec_f BEGIN
#define DDNAME       "3func.330000d1.subtract_platec_f"
#define DDNUMB      (countT)0x330000d1
#define IDFILE      (countT)0x9b0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtract_plateC_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
        if( !c1P || !c2P ) return 0 ;
    }

    return *(plateC*)c1P - *(plateC*)c2P ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d1.subtract_platec_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d2.subtractf BEGIN
#define DDNAME       "3func.330000d2.subtractf"
#define DDNUMB      (countT)0x330000d2
#define IDFILE      (countT)0x9b1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
    }

    if( pEther )
    {
        etherC& ether = *(etherC*)pEther ;
    }

    ZE( sCountT , sgn ) ;
         if( c1P > c2P ) sgn =   1 ;
    else if( c1P < c2P ) sgn = - 1 ;

    if( tinP.fingerprint && c3P ) ;
    return sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d2.subtractf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d3.subtractlb_countt_f BEGIN
#define DDNAME       "3func.330000d3.subtractlb_countt_f"
#define DDNUMB      (countT)0x330000d3
#define IDFILE      (countT)0x9b2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractLB_countT_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    _IO_

    ZE( countT , rc ) ;
    countT* pc1 = (countT*)c1P ;
    countT* pc2 = (countT*)c2P ;
    countT  c1  = - 1 ;
    countT  c2  = - 1 ;
    c1  = *pc1 ;
    c2  = *pc2 ;
    boolT bTest1 = c1 > c2 ;
    if( bTest1 )
        rc = 1 ;
    else
    {
        boolT bTest2 = c1 < c2 ;
        if( bTest2 )
            rc = - 1 ;
        else
            rc = 0 ;
    }

    //U::PRODUCDTION: countT rc = *(countT*)c1P > *(countT*)c2P ? 1 : ( *(countT*)c1P < *(countT*)c2P ? - 1 : 0 ) ;
    return rc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d3.subtractlb_countt_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d4.subtractlb_countt_ptr_f BEGIN
#define DDNAME       "3func.330000d4.subtractlb_countt_ptr_f"
#define DDNUMB      (countT)0x330000d4
#define IDFILE      (countT)0x9b3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractLB_countT_ptr_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    _IO_
    countT rc = ((etherC*)pEther)->strCompareF( tinP , (countT*)*(countT*)c1P , (countT*)*(countT*)c2P ) ;
    return rc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d4.subtractlb_countt_ptr_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d4.subtractlb_nicnamec_ptr_f BEGIN
#define DDNAME       "3func.330000d4.subtractlb_nicnamec_ptr_f"
#define DDNUMB      (countT)0x330000d4
#define IDFILE      (countT)0x9b3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractLB_nicNameC_ptr_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    _IO_
    countT rc = ((etherC*)pEther)->strCompareF( tinP , (countT*)*(countT*)c1P , (countT*)*(countT*)c2P , processGlobal1I.cb_nicNameC_ / sizeof( countT ) , 0 , 0 , 0 , 1 ) ; //ASSUME: nicNameC SIZE IS AN INTEGRAL MULTIPLE OF THE SIZE OF countT
    return rc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d4.subtractlb_nicnamec_ptr_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d5.subtractlb_countt_ptr_lenprefixed_f BEGIN
#define DDNAME       "3func.330000d5.subtractlb_countt_ptr_lenprefixed_f"
#define DDNUMB      (countT)0x330000d5
#define IDFILE      (countT)0x9b5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractLB_countT_ptr_lenPrefixed_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    if( c3P ) ;

    if( !(countT*)*(countT*)c1P )
    {
        if( (countT*)*(countT*)c2P ) return - 1 ;
        else                         return 0 ;
    }
    else if( !(countT*)*(countT*)c2P ) return 1 ;
    else if( *(countT*)*(countT*)c1P < *(countT*)*(countT*)c2P ) return - 1 ;
    else if( *(countT*)*(countT*)c1P > *(countT*)*(countT*)c2P ) return   1 ;
    else return ((etherC*)pEther)->strCompareF( tinP , (countT*)*(countT*)c1P + 1 , (countT*)*(countT*)c2P + 1 , *(countT*)*(countT*)c1P ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d5.subtractlb_countt_ptr_lenprefixed_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d6.subtractlb_strokes_ptr_f BEGIN
#define DDNAME       "3func.330000d6.subtractlb_strokes_ptr_f"
#define DDNUMB      (countT)0x330000d6
#define IDFILE      (countT)0x9b6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractLB_strokeS_ptr_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    _IO_
    strokeS* pstt1 = (strokeS*)*(countT*)c1P ;
    strokeS* pstt2 = (strokeS*)*(countT*)c2P ;

    sCountT scSign = !pstt1 && !pstt2
        ? 0
        : pstt1 && pstt2
            ? ((etherC*)pEther)->strCompareF( tinP , pstt1 , pstt2 )
            : pstt1
                ? 1
                : - 1
    ;
    return scSign ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d6.subtractlb_strokes_ptr_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d7.subtractlb_blob_ptr_f BEGIN
#define DDNAME       "3func.330000d7.subtractlb_blob_ptr_f"
#define DDNUMB      (countT)0x330000d7
#define IDFILE      (countT)0x9b7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractLB_blob_ptr_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    _IO_
    countT rc = c3P 
        ? thirdC::c_memcmpIF( tinP , (byteT*)*(countT*)c1P , (byteT*)*(countT*)c2P , c3P )
        : thirdC::c_strcmpIF( tinP , (byteT*)*(countT*)c1P , (byteT*)*(countT*)c2P )
    ;
    return rc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d7.subtractlb_blob_ptr_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d8.subtractlb_ostextt_ptr_f BEGIN
#define DDNAME       "3func.330000d8.subtractlb_ostextt_ptr_f"
#define DDNUMB      (countT)0x330000d8
#define IDFILE      (countT)0x9b8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractLB_osTextT_ptr_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    _IO_
    countT rc = thirdC::c_strcmpIF( tinP , (osTextT*)*(countT*)c1P , (osTextT*)*(countT*)c2P ) ;
    return rc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d8.subtractlb_ostextt_ptr_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d9.subtractlb_ptrstrokes_ptr_f BEGIN
#define DDNAME       "3func.330000d9.subtractlb_ptrstrokes_ptr_f"
#define DDNUMB      (countT)0x330000d9
#define IDFILE      (countT)0x9b9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractLB_ptrStrokeS_ptr_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    _IO_
    countT rc = ((etherC*)pEther)->strCompareF( tinP , (const strokeS**)*(countT*)c1P , (const strokeS**)*(countT*)c2P ) ;
    return rc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000d9.subtractlb_ptrstrokes_ptr_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000da.subtractlb_ptrstrokes_ptr_lenprefixed_f BEGIN
#define DDNAME       "3func.330000da.subtractlb_ptrstrokes_ptr_lenprefixed_f"
#define DDNUMB      (countT)0x330000da
#define IDFILE      (countT)0x9ba


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractLB_ptrStrokeS_ptr_lenPrefixed_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    if( c3P ) ;

    if( !(countT*)*(countT*)c1P )
    {
        if( (countT*)*(countT*)c2P ) return - 1 ;
        else                         return 0 ;
    }
    else if( !(countT*)*(countT*)c2P ) return 1 ;
    else if( *(countT*)*(countT*)c1P < *(countT*)*(countT*)c2P ) return - 1 ;
    else if( *(countT*)*(countT*)c1P > *(countT*)*(countT*)c2P ) return   1 ;
    else return ((etherC*)pEther)->strCompareF( tinP , (const strokeS**)( (countT*)*(countT*)c1P + 1 ) , (const strokeS**)( (countT*)*(countT*)c2P + 1 ) , *(countT*)*(countT*)c1P ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000da.subtractlb_ptrstrokes_ptr_lenprefixed_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000db.subtractlb_platec_ptr_f BEGIN
#define DDNAME       "3func.330000db.subtractlb_platec_ptr_f"
#define DDNUMB      (countT)0x330000db
#define IDFILE      (countT)0x9bb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractLB_plateC_ptr_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    _IO_
    plateC* pPlate1 = (plateC*)*(countT*)c1P ;
    plateC* pPlate2 = (plateC*)*(countT*)c2P ;

    sCountT scSign = !pPlate1 && !pPlate2
        ? 0
        : pPlate1 && pPlate2
            ? *pPlate1 - *pPlate2
            : pPlate1
                ? 1
                : - 1
    ;
    return scSign ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000db.subtractlb_platec_ptr_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000dc.subtract1220008f BEGIN
#define DDNAME       "3func.330000dc.subtract1220008f"
#define DDNUMB      (countT)0x330000dc
#define IDFILE      (countT)0x9bc


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtract1220008F( tinS& tinP , countT& pEtherP , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
        if( !pEtherP || !c1P || !c2P ) return 0 ;
    }

    etherC& ether = *(etherC*)pEtherP ;
    if( c3P ) ;
    return ether.strCompareF( tinP , (countT*)c1P , (countT*)c2P , 2 ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000dc.subtract1220008f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000dd.dttellcopydonef BEGIN
#define DDNAME       "3func.330000dd.dttellcopydonef"
#define DDNUMB      (countT)0x330000dd
#define IDFILE      (countT)0x9bd


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT dtTellCopyDoneF( countT c_thisP )/*1*/
{
    tinS& tinP = *(tinS*)c_thisP ;

    //if( tinP.pTinOld )
    //{
    //    conGF( "dtCopy              [new,old]: " ) ;
    //    conGF( NAME( tinP.idTinNamed ) ) ;
    //    conGF( " " ) ;
    //    conGF( NAME( tinP.pTinOld->idTinNamed ) ) ;
    //    conGF( "\r\n" ) ;
    //}

    if( tinP.pTinOld ) putNegAM( tinP.pTinOld->fingerprint , FINGERnEG_TINs ) ;             //MY ELDER IS READY TO BECOME ACTIVE
    putNegAM( tinP.fingerprint , FINGERnEG_TINszOMBIE ) ;                                   //I AM ABOUT TO BECOME RETIRED

    if( tinP.pTinOld )
    {
        //conGF( "dtCopy pTinF() [before,after]: " ) ;
        //conGF( NAME( pTinF()->idTinNamed ) ) ;
    
        if( tinP.idTinNamed == ifcIDtINnAMED_tinEarlyLateMain ) bTlsEarlyLateIF() = 1 ;
        //if( tinP.idTinNamed == ifcIDtINnAMED_tinEarlyLateMain ) bTlsEarlyLateI = 1 ;

        pTinF() = tinP.pTinOld ;                                                            // I BECOME RETIRED HERE
    
        //conGF( " " ) ;
        //conGF( NAME( pTinF()->idTinNamed ) ) ;
        //conGF( "\r\n" ) ;
    }

    return 0 ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000dd.dttellcopydonef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000de.cttellcopydonef BEGIN
#define DDNAME       "3func.330000de.cttellcopydonef"
#define DDNUMB      (countT)0x330000de
#define IDFILE      (countT)0x9be


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT ctTellCopyDoneF( countT c_thisP )/*1*/
{
    tinS& tinP = *(tinS*)c_thisP ;

    //if( tinP.pTinOld )
    //{
    //    conGF( "ctCopy              [old,new]: " ) ;
    //    conGF( NAME( tinP.pTinOld->idTinNamed ) ) ;
    //    conGF( " " ) ;
    //    conGF( NAME( tinP.idTinNamed ) ) ;
    //    conGF( "\r\n" ) ;
    //}

    if( tinP.pTinOld ) putNegAM( tinP.pTinOld->fingerprint , FINGERnEG_TINszOMBIE ) ;       //MY ELDER IS NOW RETIRED
    putNegAM( tinP.fingerprint , FINGERnEG_TINs ) ;                                         //I AM ABOUT TO BECOME ACTIVE

    if( tinP.pTinOld )
    {
        //conGF( "ctCopy pTinF() [before,after]: " ) ;
        //conGF( NAME( pTinF()->idTinNamed ) ) ;
    
        pTinF() = &tinP ;                                                                   // I BECOME ACTIVE HERE
    
        //conGF( " " ) ;
        //conGF( NAME( pTinF()->idTinNamed ) ) ;
        //conGF( "\r\n" ) ;
    }

    return 0 ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000de.cttellcopydonef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000df.ccf BEGIN
#define DDNAME       "3func.330000df.ccf"
#define DDNUMB      (countT)0x330000df
#define IDFILE      (countT)0x9bf


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT ccF( tinS& tinP , etherC& ether , switchC& swP )/*1*/
{
    if( ether ) return 0 ;

    countT cc = 1 ;
    const countT cFlavors = swP.cFlavorsF( tinP ) ;
    if( cFlavors )
    {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            countT* pcPart = (countT*)swP.leverF( tinP , idf ) ;
            countT  ccOne = ether.strBodyLengthF( tinP , pcPart ) ;
            cc += 2 + ccOne ;
        }
    }

    return cc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000df.ccf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e0.subtractblobs_skeyf BEGIN
#define DDNAME       "3func.330000e0.subtractblobs_skeyf"
#define DDNUMB      (countT)0x330000e0
#define IDFILE      (countT)0x9c0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractBlobs_sKeyF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    IFbEcAREFUL
    {
    }

    if( !c3P                   ) { BLAMMO ; }
    if( c3P != CBtABsORTkEY    ) { BLAMMO ; }
    if( c3P % sizeof( countT ) ) { BLAMMO ; }

    countT* pc1 = (countT*)c1P ;
    countT* pc2 = (countT*)c2P ;

    ZE( sCountT , scSgn ) ;
    countT cck = c3P / sizeof( countT ) ;    
    for( countT off = 0 ; off < cck && !scSgn ; off ++ ) scSgn = pc1[ off ] - pc2[ off ] ;

    if( tinP.fingerprint && pEther ) ;
    return scSgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e0.subtractblobs_skeyf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e1.subtractlb_soulc_ptr_f BEGIN
#define DDNAME       "3func.330000e1.subtractlb_soulc_ptr_f"
#define DDNUMB      (countT)0x330000e1
#define IDFILE      (countT)0x9c1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT subtractLB_soulC_ptr_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    _IO_
    countT rc = *(soulC*)*(countT*)c1P - *(soulC*)*(countT*)c2P ;
    return rc ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e1.subtractlb_soulc_ptr_f END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e2.bhitf BEGIN
#define DDNAME       "3func.330000e2.bhitf"
#define DDNUMB      (countT)0x330000e2
#define IDFILE      (countT)0x9c2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/boolT bHitF( const countT idP , const countT* const pcP )/*1*/
{
    ZE( boolT , bHit ) ;
    if( pcP )
    {
        ZE( countT , off ) ;
        for(;;)
        {
            if( !pcP[ off ] ) break ;
            else if( pcP[ off ] == idP )
            {
                bHit ++ ;
                break ;
            }
            else off ++ ;
        }
    }
    return bHit ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e2.bhitf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e2.subtractstringsinjotf BEGIN
#define DDNAME       "3func.330000e2.subtractstringsinjotf"
#define DDNUMB      (countT)0x330000e2
#define IDFILE      (countT)0x9c2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/countT _export subtractStringsInJotF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
{
    etherC& etherP = *(etherC*)pEther ;
    jotC&   jotP   = *(jotC*)c3P ;

    countT idBook1 = jotP.peekIdBookF( tinP , c1P ) ;
    countT idBook2 = jotP.peekIdBookF( tinP , c2P ) ;

    ZE( sCountT , sgn ) ;
    if( idBook1 == idBook2 )
    {
        const byteT* pbz1 = jotP[ c1P ] ;
        const byteT* pbz2 = jotP[ c2P ] ;

        sgn = ((etherC*)pEther)->strCompareEncodedF( tinP , pbz1 , pbz2 ) ;
    }
    else
    {
        ZE( byteT* , pbCopy1 ) ;
        {
            const byteT* const pbz1 = jotP[ c1P ] ;

            countT cba1 = CBeNCODINGrEF( pbz1 ) + 2 * sizeof( countT ) ; // STRING 1 IS COPIED RATHER THAN STRING 2 BECAUSE 1 WILL BE MORE CORRELATED (LONG RUNS OF THE SAME VALUE) SO PERHAPS NEW/DEL WILL BE LESS COSTLY THAN IF 2 WAS COPIED

            ((etherC*)pEther)->newF( tinP , LF , pbCopy1 , cba1 ) ; ___( pbCopy1 ) ;
            thirdC::c_memcpyIF( tinP , pbCopy1 , pbz1 , cba1 ) ;
        }

        const byteT* const pbz2 = jotP[ c2P ] ;
        sgn = ((etherC*)pEther)->strCompareEncodedF( tinP , pbCopy1 , pbz2 ) ;

        ((etherC*)pEther)->delF( tinP , pbCopy1 ) ;
    }

    return -sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e2.subtractstringsinjotf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e3.flagsupf BEGIN
#define DDNAME       "3func.330000e3.flagsupf"
#define DDNUMB      (countT)0x330000e3
#define IDFILE      (countT)0x9c4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//NAMED THIS WAY TO PERMIT FUTURE GENERALIZATION TO N-POWER EXPLOSION

/*1*/flagsT flagsUpF( const countT idrMeP , const countT idrToP , const countT idrMaxP )/*1*/
{
    ZE( flagsT , flagsUp ) ;
    if( idrMeP < idrToP && idrToP <= idrMaxP )
    {
        countT idStep = 1 ;
        countT power = 2 ;
        for(;;)
        {
            countT min = power * idrMeP ;
            if( idrToP < min ) break ;
            countT max = power * ( idrMeP + 1 ) - 1 ;

            if( min <= idrToP && idrToP <= max )
            {
                countT minUpR = power * idrMeP + ( power >> 1 ) ;
                flagsUp = minUpR <= idrToP ? 2 : 1 ; //2: POP UP RIGHT; 1: POP UP LEFT

                break ;
            }

            idStep ++ ;
            power <<= 1 ;
        }
    }

    return flagsUp ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e3.flagsupf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e7.strcompareprivatef BEGIN
#define DDNAME       "3func.330000e7.strcompareprivatef"
#define DDNUMB      (countT)0x330000e7
#define IDFILE      (countT)0x9c5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/sCountT strComparePrivateF( const strokeS* const pstt1P , const strokeS* const pstt2P )/*1*/
{
    if( !pstt1P || !pstt2P ) return 0 ;

    //PRIVATE UTILITY FUNCTION
    //ASSUME: pstt1P LACKS A PREFIX; pstt2P DOES HAVE A PREFIX

    ZE( sCountT , sgn ) ;
    for( countT off = 0 ; off < pstt2P->idAdam && !sgn ; off ++ )
    {
        sgn = pstt1P[ off ] - pstt2P[ CSpREFIX + off ] ;
    }
    return sgn ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e7.strcompareprivatef END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e8.phtmlf BEGIN
#define DDNAME       "3func.330000e8.phtmlf"
#define DDNUMB      (countT)0x330000e8
#define IDFILE      (countT)0x9c6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/htmlS* pHtmlF( tinS& tinP , etherC& ether , const strokeS* const psttNameP , htmlS*& pHtmlRootP )/*1*/
{
    if( ether ) return 0 ;
    __Z( psttNameP ) ;
    __Z( pHtmlRootP ) ;
    if( ether ) return 0 ;

    ZE( htmlS* , pHtml ) ;
    pHtml = pHtmlRootP ;
    if( psttNameP->idAdam )
    {
        countT idf = 1 ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , psttw ) ;
        while( !ether && idf )
        {
            if( !pHtml->pU )
            {
                pHtml->pU = new( 0 , tinP , LF ) htmlS( tinP , ether , pHtmlRootP ) ; ___( pHtml->pU ) ;
                __( !pHtml->pU ) ;
                if( pHtml->pU )
                {
                    pHtml->pU->pD = pHtml ;
                    pHtml = pHtml->pU ;
                }
            }
            else pHtml = pHtml->pU ;
            __Z( pHtml ) ;
            ether.strSubstringF( tinP , psttw , idf , sttq , S1C('.') , psttNameP ) ; ___( psttw ) ;
            countT id = ether.strDigitsToSCountF( tinP , psttw ) ;
            if( !id )
            {
                etherC::ifcSayIF( T("10300b5: sin: indented too much: \"")+T(psttNameP)+T("\"\r\n") , flSAY_APPEND | flSAY_LOG ) ;
            }
            ether.delF( tinP , psttw ) ;

            if( id ) while( !ether && -- id )
            {
                if( pHtml->pR ) pHtml = pHtml->pR ;
                else
                {
                    pHtml->pR = new( 0 , tinP , LF ) htmlS( tinP , ether , pHtmlRootP ) ; ___( pHtml->pR ) ;
                    __( !pHtml->pR ) ;
                    if( pHtml->pR )
                    {
                        pHtml->pR->pL = pHtml ;
                        pHtml = pHtml->pR ;
                    }
                }
                __Z( pHtml ) ;
            }
        }
    }

    if( pHtml && !pHtml->psttName ) { ether.strFuseF( tinP , pHtml->psttName , psttNameP ) ; ___( pHtml->psttName ) ; /* ether.strMakeF( tinP , LF , pHtml->postName , pHtml->psttName ) ; */ }

    return pHtml ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e8.phtmlf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e9.renderhandlerideafarmlogof BEGIN
#define DDNAME       "3func.330000e9.renderhandlerideafarmlogof"
#define DDNUMB      (countT)0x330000e9
#define IDFILE      (countT)0x9c7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

#if defined( NEVERdEFINED )

measureT mScale ; //U: THIS IS OBVIOUSLY A KLUGE

/*1*/boolT renderHandlerIdeaFarmLogoF( tinS& tinP , etherC& ether , windowOldC& wP , const countT cArgP )/*1*/
{
    static countT idString ;

    switch( psttSnipP[ CSpREFIX - 1 + idsP ].idCaste )
    {
        case scOld_FORaDAMtOuSE : { idString = psttSnipP[ CSpREFIX - 1 + idsP ].idAdam ; break ; }
        case sc_cALPHABET1 :
        {
            switch( idString )
            {
                case 1 :
                {
                    static measureT mIdColCenter ;
                    static measureT mIdRowCenter ;
                    if( idsP == 1 )
                    {
                        mIdColCenter = paperP.mIdCol ;
                        mIdRowCenter = paperP.mIdRow ;
                    }
        
                    measureT ptArcStart = 1.0 / 8.0 ; //"PER TUCK".  THE WOTH STROKE WILL BE AT START. 0 IS AT BOTTOM
                    measureT ptArcEnd   = 7.0 / 8.0 ;
                    boolT br = 0 ;              //"REVERSE". INDICATES WHICH WAY TO GO AROUND THE CIRCLE (NORMAL IS CLOCKWISE)
        
                    measureT ptString = (measureT)( idsP - 1 ) / (measureT)( psttSnipP->idAdam - 1 ) ;
                    ZE( measureT , ptArcLen ) ;
                    if( !br ) ptArcLen = ptArcStart <= ptArcEnd   ? ptArcEnd   - ptArcStart : 1.0 - ptArcStart + ptArcEnd   ;
                    else      ptArcLen = ptArcEnd   <= ptArcStart ? ptArcStart - ptArcEnd   : 1.0 - ptArcEnd   + ptArcStart ;
        
                    measureT ptOnCircle = br ? ptArcStart - ptString * ptArcLen : ptArcStart + ptString * ptArcLen ;
        
                    measureT mOsAngle = osAngleF( ptOnCircle + 0.5 ) ;
                    *(measureT*)&paperP.pPulp->stqr_mCosHotAngle[ 1 ] = thirdC::mathCosIF( tinP , mOsAngle + PI / 2 ) ;
                    *(measureT*)&paperP.pPulp->stqr_mSinHotAngle[ 1 ] = thirdC::mathSinIF( tinP , mOsAngle + PI / 2 ) ;

                    paperP.mIdCol = mIdColCenter + 200 * mScale * thirdC::mathCosIF( tinP , ptOnCircle * 2 * PI + PI / 2 ) ;
                    paperP.mIdRow = mIdRowCenter - 200 * mScale * thirdC::mathSinIF( tinP , ptOnCircle * 2 * PI + PI / 2 ) ;
        
                    break ;
                }
                case 2 :
                {
                    static measureT mIdColCenter ;
                    static measureT mIdRowCenter ;
                    if( idsP == 1 )
                    {
                        mIdColCenter = paperP.mIdCol ;
                        mIdRowCenter = paperP.mIdRow ;
                    }
        
                    measureT ptArcStart = 1.0 / 8.0 ; //"PER TUCK".  THE WOTH STROKE WILL BE AT START. 0 IS AT BOTTOM
                    measureT ptArcEnd   = 7.0 / 8.0 ;
                    boolT br = 1 ;              //"REVERSE". INDICATES WHICH WAY TO GO AROUND THE CIRCLE (NORMAL IS CLOCKWISE)
        
                    measureT ptString = (measureT)( idsP - 1 ) / (measureT)( psttSnipP->idAdam - 1 ) ;
                    ZE( measureT , ptArcLen ) ;
                    if( !br ) ptArcLen = ptArcStart <= ptArcEnd   ? ptArcEnd   - ptArcStart : 1.0 - ptArcStart + ptArcEnd   ;
                    else      ptArcLen = ptArcEnd   <= ptArcStart ? ptArcStart - ptArcEnd   : 1.0 - ptArcEnd   + ptArcStart ;
        
                    measureT ptOnCircle = br ? ptArcStart - ptString * ptArcLen : ptArcStart + ptString * ptArcLen ;
        
                    measureT mOsAngle = osAngleF( ptOnCircle ) ;
                    *(measureT*)&paperP.pPulp->stqr_mCosHotAngle[ 1 ] = thirdC::mathCosIF( tinP , mOsAngle + PI / 2 ) ;
                    *(measureT*)&paperP.pPulp->stqr_mSinHotAngle[ 1 ] = thirdC::mathSinIF( tinP , mOsAngle + PI / 2 ) ;

                    paperP.mIdCol = mIdColCenter + 200 * mScale * thirdC::mathCosIF( tinP , ptOnCircle * 2 * PI + PI / 2 ) ;
                    paperP.mIdRow = mIdRowCenter - 200 * mScale * thirdC::mathSinIF( tinP , ptOnCircle * 2 * PI + PI / 2 ) ;
        
                    break ;
                }
            }
            break ;
        }
    }

    if( tinP.fingerprint && ether && cArgP ) ;
    return 0 ;
}

#endif


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000e9.renderhandlerideafarmlogof END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ea.tmgrabtabf BEGIN
#define DDNAME       "3func.330000ea.tmgrabtabf"
#define DDNUMB      (countT)0x330000ea
#define IDFILE      (countT)0x9c8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/**/

/*1*/TASK( tmGrabTabF )/*1*/
if( pTaskP && pTaskP->c1 ) sadamsC::pSadamsIF( tinP )->tabFreshF( tinP , etThread , ifcIDtYPEtABfRESH_JUMP , (sadamC*)pTaskP->c1 ) ;
DONE( tmGrabTabF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ea.tmgrabtabf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000eb.vspdatumcountcbf BEGIN
#define DDNAME       "3func.330000eb.vspdatumcountcbf"
#define DDNUMB      (countT)0x330000eb
#define IDFILE      (countT)0x9c9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT vspDatumCountCBF( tinS& tinP , byteT* pbvspP , countT idEventP , countT cRefOldP , countT cRefNewLaterP , countT cArgP )/*1*/
{
    switch( idEventP )
    {
        case ifcIDeVENTvsp_CT     :
        case ifcIDeVENTvsp_DT     : { break ; }
        case ifcIDeVENTvsp_WrEFcT :
        {
            if( !cRefOldP )
            {
                listingC* pListing = (listingC*)cArgP ;
                if( pListing->flagsF() & fliLISTINGc_MIXINlIST )
                {
                    list_countT_C* pl = (list_countT_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_countT ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->unIndexF( tinP ) ;
                    THREADmODE2rESTORE
                }
                else
                {
                    listing_countT_C* pl = (listing_countT_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_countT ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->unIndexF( tinP ) ;
                    THREADmODE2rESTORE
                }
            }
            break ;
        }
        case ifcIDeVENTvsp_WrEFdT :
        {
            if( cRefOldP == 1 )
            {
                listingC* pListing = (listingC*)cArgP ;
                if( pListing->flagsF() & fliLISTINGc_MIXINlIST )
                {
                    list_countT_C* pl = (list_countT_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_countT ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->indexF( tinP ) ;
                    THREADmODE2rESTORE
                }
                else
                {
                    listing_countT_C* pl = (listing_countT_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_countT ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->indexF( tinP ) ;
                    THREADmODE2rESTORE
                }
            }
            break ;
        }
        default :
        {
            __( idEventP ) ;
            __1 ;
            break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000eb.vspdatumcountcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ec.vspdatumcountstrzcbf BEGIN
#define DDNAME       "3func.330000ec.vspdatumcountstrzcbf"
#define DDNUMB      (countT)0x330000ec
#define IDFILE      (countT)0x9ca


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT vspDatumCountStrzCBF( tinS& tinP , byteT* pbvspP , countT idEventP , countT cRefOldP , countT cRefNewLaterP , countT cArgP )/*1*/
{
    switch( idEventP )
    {
        case ifcIDeVENTvsp_CT     :
        case ifcIDeVENTvsp_DT     : { break ; }
        case ifcIDeVENTvsp_WrEFcT :
        {
            if( !cRefOldP )
            {
                listingC* pListing = (listingC*)cArgP ;
                if( pListing->flagsF() & fliLISTINGc_MIXINlIST )
                {
                    list_countTstrz_C* pl = (list_countTstrz_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_countTstrz ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->unIndexF( tinP ) ;
                    THREADmODE2rESTORE
                }
                else
                {
                    listing_countTstrz_C* pl = (listing_countTstrz_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_countTstrz ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->unIndexF( tinP ) ;
                    THREADmODE2rESTORE
                }
            }
            break ;
        }
        case ifcIDeVENTvsp_WrEFdT :
        {
            if( cRefOldP == 1 )
            {
                listingC* pListing = (listingC*)cArgP ;
                if( pListing->flagsF() & fliLISTINGc_MIXINlIST )
                {
                    list_countTstrz_C* pl = (list_countTstrz_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_countTstrz ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->indexF( tinP ) ;
                    THREADmODE2rESTORE
                }
                else
                {
                    listing_countTstrz_C* pl = (listing_countTstrz_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_countTstrz ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->indexF( tinP ) ;
                    THREADmODE2rESTORE
                }
            }
            break ;
        }
        default :
        {
            __( idEventP ) ;
            __1 ;
            break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ec.vspdatumcountstrzcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ed.vspdatumblobcbf BEGIN
#define DDNAME       "3func.330000ed.vspdatumblobcbf"
#define DDNUMB      (countT)0x330000ed
#define IDFILE      (countT)0x9cb


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT vspDatumBlobCBF( tinS& tinP , byteT* pbvspP , countT idEventP , countT cRefOldP , countT cRefNewLaterP , countT cArgP )/*1*/
{
    switch( idEventP )
    {
        case ifcIDeVENTvsp_CT     :
        case ifcIDeVENTvsp_DT     : { break ; }
        case ifcIDeVENTvsp_WrEFcT :
        {
            if( !cRefOldP )
            {
                listingC* pListing = (listingC*)cArgP ;
                if( pListing->flagsF() & fliLISTINGc_MIXINlIST )
                {
                    list_blob_C* pl = (list_blob_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_blob ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->unIndexF( tinP ) ;
                    THREADmODE2rESTORE
                }
                else
                {
                    listing_blob_C* pl = (listing_blob_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_blob ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->unIndexF( tinP ) ;
                    THREADmODE2rESTORE
                }
            }
            break ;
        }
        case ifcIDeVENTvsp_WrEFdT :
        {
            if( cRefOldP == 1 )
            {
                listingC* pListing = (listingC*)cArgP ;
                if( pListing->flagsF() & fliLISTINGc_MIXINlIST )
                {
                    list_blob_C* pl = (list_blob_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_blob ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->indexF( tinP ) ;
                    THREADmODE2rESTORE
                }
                else
                {
                    listing_blob_C* pl = (listing_blob_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_blob ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->indexF( tinP ) ;
                    THREADmODE2rESTORE
                }
            }
            break ;
        }
        default :
        {
            __( idEventP ) ;
            __1 ;
            break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ed.vspdatumblobcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ee.vspdatumlistingcbf BEGIN
#define DDNAME       "3func.330000ee.vspdatumlistingcbf"
#define DDNUMB      (countT)0x330000ee
#define IDFILE      (countT)0x9cc


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT vspDatumListingCBF( tinS& tinP , byteT* pbvspP , countT idEventP , countT cRefOldP , countT cRefNewLaterP , countT cArgP )/*1*/
{
    switch( idEventP )
    {
        case ifcIDeVENTvsp_CT     :
        case ifcIDeVENTvsp_DT     : { break ; }
        case ifcIDeVENTvsp_WrEFcT :
        {
            if( !cRefOldP )
            {
                listingC* pListing = (listingC*)cArgP ;
                if( pListing->flagsF() & fliLISTINGc_MIXINlIST )
                {
                    list_listingVSP_C* pl = (list_listingVSP_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_listingVSP ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->unIndexF( tinP ) ;
                    THREADmODE2rESTORE
                }
                else
                {
                    listing_listingVSP_C* pl = (listing_listingVSP_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_listingVSP ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->unIndexF( tinP ) ;
                    THREADmODE2rESTORE
                }
            }
            break ;
        }
        case ifcIDeVENTvsp_WrEFdT :
        {
            if( cRefOldP == 1 )
            {
                listingC* pListing = (listingC*)cArgP ;
                if( pListing->flagsF() & fliLISTINGc_MIXINlIST )
                {
                    list_listingVSP_C* pl = (list_listingVSP_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_listingVSP ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->indexF( tinP ) ;
                    THREADmODE2rESTORE
                }
                else
                {
                    listing_listingVSP_C* pl = (listing_listingVSP_C*)pListing ;
                    __( pl->idTypeDatumF() - ifcIDtYPEmIXINdATUM_listingVSP ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
                    pl->indexF( tinP ) ;
                    THREADmODE2rESTORE
                }
            }
            break ;
        }
        default :
        {
            __( idEventP ) ;
            __1 ;
            break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ee.vspdatumlistingcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ef.diskwalkrenameforarchivalcbf BEGIN
#define DDNAME       "3func.330000ef.diskwalkrenameforarchivalcbf"
#define DDNUMB      (countT)0x330000ef
#define IDFILE      (countT)0x9cd


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
i rename each file with a nonconforming name so that its name conforms to the ideafarm file name specification format 3
 ideafarm file name format specification
  example of format 1: !ideafarm.1.000b3577.bb88e99f.blabla.test
  example of format 2: !ideafarm.2.000b3577.bb88e99f.leafdir.!s.blabla.test
   all occurances of "!" in the old name are changed to "!!"
   "!s": "short file name"
    this is the name of the file with the path removed
    it has nothing to do with the 8.3 encoded name in some file systems
  example of format 3: !ideafarm. 3.000b3577.bb88e99f.3c1f01ba.leafdir.!.blabla.test
   !ideafarm. 3.[time].[cid].[leafdir].!.[shortfilename]
  example of format 4: !ideafarm.4.20130423@1824.000b3577.bb88e99f.3c1f01ba.leafdir.!.blabla.test
   !ideafarm.4.[overridetime].[filetime].[cid].[leafdir].!.[shortfilename]
   [overridetime]: is a time specified in [shortfilename]
    it is removed from [shortfilename] and placed into early position so that it controls sorting
    if no override filetime is found in the name then the file time, converted to foreign datetime format, is used
*/
/**/

/*1*/boolT diskWalkRenameForArchivalCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloFilesP , const countT* const pModuloDirsP )/*1*/
{
    _IO_
    ZE( boolT , bDoIt ) ;
    if( postNameP && postNameP[ thirdC::c_strlenIF( tinP , postNameP ) - 1 ] != '\\' && tinP.pEther ) // IF NOT A DIRECTORY
    {
        diskWalkCopyInfoS& infoP = *(diskWalkCopyInfoS*)pcArgP ;

        bDoIt = infoP.pCbf
            ? (*infoP.pCbf)( tinP , cDirsP , cFilesP , bQuitP , postNameP , pcArgP )
            : 1
        ;

        //U::EDIT TO MAP EACH OCCURANCE OF "!" TO "!!"

        if( bDoIt )
        {
            etherC& etThread = *tinP.pEther ;
            TN( tIdeaFarmDot9Dot , "!ideafarm.9.2.00000000.00000001." ) ;                                   //U:: idOwner IS HARDCODED HERE TO ".2.00000000.00000001." (FOREIGN ORDERING)
            TN( tOld , ifFileNameC( tinP , etThread , postNameP ) ) ;                                       // OLD IFC FILE NAME
            TN( tSlash , "/" ) ;
            if( !etThread.strIdF( tinP , tSlash+tIdeaFarmDot9Dot , tOld ) )
            {
                osTextT* postzToP         = (osTextT*)infoP.pcArgApp[ 0 ] ;
                textC**  pptSpecP         =  (textC**)infoP.pcArgApp[ 1 ] ;
                countT   cSpecP           =           infoP.pcArgApp[ 2 ] ;
                textC&   tDateAtTimeLathP =  *(textC*)infoP.pcArgApp[ 3 ] ;
                countT&  idSequenceLathP  = *(countT*)infoP.pcArgApp[ 4 ] ;

                if( cSpecP < 0xe ) { BLAMMO ; }
                textC& tSssDotDateAtTimeDotDateAtTimeDot = *pptSpecP[ 0x03 ] ;
                textC& tSssDotDateAtTimeDot              = *pptSpecP[ 0x04 ] ;
                textC& tSssDateAtTimeDotDateAtTimeDot    = *pptSpecP[ 0x05 ] ;
                textC& tSssDateAtTimeDot                 = *pptSpecP[ 0x06 ] ;
                textC& tSssMMDDYYHHMM                    = *pptSpecP[ 0x07 ] ;
                textC& tDot                              = *pptSpecP[ 0x08 ] ;
                textC& tSDS                              = *pptSpecP[ 0x09 ] ;
                textC& tSDDS                             = *pptSpecP[ 0x0a ] ;
                textC& tNewPrefix                        = *pptSpecP[ 0x0b ] ;
                textC& tDotTypeData                      = *pptSpecP[ 0x0c ] ;
                textC& tDotTypeMetaDotHashedName         = *pptSpecP[ 0x0d ] ;
                textC& tDotTypeMetaDotCurrentName        = *pptSpecP[ 0x0e ] ;
                textC& tDotTypeMetaDotPathRoot           = *pptSpecP[ 0x0f ] ;
                textC& tDotTypeMetaDotPathLeaf           = *pptSpecP[ 0x10 ] ;
                textC& tAt                               = *pptSpecP[ 0x11 ] ;
                textC& t20                               = *pptSpecP[ 0x12 ] ;

                if( postzToP )
                {
                    TN( tTo , ifFileNameC( tinP , etThread , postzToP ) ) ;                                       // DESTINATION FOLDER

                    static infoFileS* pInfo ;
                    //U::ZE( infoFileS* , pInfo ) ;
                    {
                        handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                        etThread.fileOpenF( tinP , hFile , countTC() , tOld , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_NOcACHE | flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_DOnOTrEGISTER | flOPENdETAILS_LOCnONE , ifcOPENhOW_nFeO ) ;
                        etThread.diskFileQueryF( tinP , pInfo , hFile ) ; ___( pInfo ) ;
                    }

                    {
                        TN( tPath , "" ) ;
                        TN( tShort , "" ) ;
                        {
                            ZE( strokeS* , psttPath ) ;
                            ZE( strokeS* , psttShort ) ;
                            etThread.strBisectF( tinP , psttPath , psttShort , tOld , tSlash , - 1 , flSTRbISECT_null ) ; ___( psttPath ) ; ___( psttShort ) ;
                            tPath  = T(psttPath) ;
                            tShort = T(psttShort) ;
                            etThread.delF( tinP , psttPath ) ;
                            etThread.delF( tinP , psttShort ) ;
                        }

                        TN( tPathRoot , "" ) ;
                        TN( tPathLeaf , "" ) ;
                        {
                            ZE( strokeS* , psttPathRoot ) ;
                            ZE( strokeS* , psttPathLeaf ) ;
                            etThread.strBisectF( tinP , psttPathRoot , psttPathLeaf , tPath , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathLeaf ) ; ___( psttPathRoot ) ;
                            tPathRoot  = T(psttPathRoot) ;
                            tPathLeaf  = T(psttPathLeaf) ;
                            etThread.delF( tinP , psttPathLeaf ) ;
                            etThread.delF( tinP , psttPathRoot ) ;
                        }

                        TN( tDateAtTimeFromFileMeta , "" ) ;
                        {
                            ZE( countT , ms ) ;
                            ZE( countT , ss ) ;
                            ZE( countT , mm ) ;
                            ZE( countT , hh ) ;
                            ZE( countT , da ) ;
                            ZE( countT , mo ) ;
                            ZE( sCountT , ye ) ;
                            ZE( countT , dow ) ;
                            etThread.osTimeToOldTimeF( tinP , ms , ss , mm , hh , da , mo , ye , dow , pInfo->timeWritten1 , pInfo->timeWritten2 ) ;
    
                            tDateAtTimeFromFileMeta =
    
                                 TF4(1+ye,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,4,0xa)
                                +TF4(1+mo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)
                                +TF4(1+da,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)
                                +S1C('@')
                                +TF4(hh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)
                                +TF4(mm,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)
    
                            ;
                        }

                        TN( tDotExt , "" ) ;
                        {
                            ZE( strokeS* , psttnu ) ;
                            ZE( strokeS* , psttDotExt ) ;
                            etThread.strBisectF( tinP , psttnu , psttDotExt , tShort , tDot , - 1 , flSTRbISECT_PREPENDdELIMITER ) ; ___( psttnu ) ; ___( psttDotExt ) ;
                            tDotExt = T(psttDotExt) ;
                            etThread.delF( tinP , psttnu ) ;
                            etThread.delF( tinP , psttDotExt ) ;
                        }

                        if( tShort.csF( tinP ) )
                        {
                            if( 1 != etThread.strIdF( tinP , tNewPrefix , tShort ) )
                            {
                                TN( tTimePair , "" ) ;
                                TN( tSequenceNumber , "001" ) ;
                                {
                                    countT idf = 1 ;
                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                    TN( tDot , "." ) ;
                                    TN( tDotHeyDot , ".!." ) ;
                                    TN( tPrefix6   , "!ideafarm.6." ) ;

                                    countT idHit = etThread.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tPrefix6 , tShort ) ;

                                    if( idHit != 1 )
                                    {
                                        //etThread.traceF( tinP , T("[tShort]: ")+tShort ) ;                             
                                        //etThread.traceF( tinP , T("[tPatt2]: ")+tSssDotDateAtTimeDotDateAtTimeDot ) ;                             

                                        idf = 1 ;
                                        idHit = etThread.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tSssDotDateAtTimeDotDateAtTimeDot , tShort ) ;
                                        if( idHit )
                                        {
                                            ZE( strokeS* , psttDoubleTime ) ;
                                            countT idl = idf - 1 ;
                                            countT idf = idHit ;
                                            etThread.strSubstringF( tinP , psttDoubleTime , idf , idl , tShort ) ; ___( psttDoubleTime ) ;
                                            tTimePair = T(psttDoubleTime) ;
                                            etThread.delF( tinP , psttDoubleTime ) ;
                                        }
                                        else
                                        {
                                            idf = 1 ;
                                            idHit = etThread.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tSssDateAtTimeDotDateAtTimeDot , tShort ) ;
                                            if( idHit == 1 )
                                            {
                                                ZE( strokeS* , psttDoubleTime ) ;
                                                countT idl = idf - 1 ;
                                                countT idf = idHit ;
                                                //etThread.traceF( tinP , T("[idf,idl]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idl,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                etThread.strSubstringF( tinP , psttDoubleTime , idf , idl , tShort ) ; ___( psttDoubleTime ) ;
                                                tTimePair = tDot+T(psttDoubleTime) ;
                                                etThread.delF( tinP , psttDoubleTime ) ;
                                            }
                                            else
                                            {
                                                idf = 1 ;
                                                idHit = etThread.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tSssDotDateAtTimeDot , tShort ) ;
                                                if( idHit )
                                                {
                                                    ZE( strokeS* , psttSingleTime ) ;
                                                    countT idl = idf - 1 ;
                                                    countT idf = idHit ;
                                                    etThread.strSubstringF( tinP , psttSingleTime , idf , idl , tShort ) ; ___( psttSingleTime ) ;
                                                    tTimePair = T(psttSingleTime)+tDateAtTimeFromFileMeta+tDot ;
                                                    etThread.delF( tinP , psttSingleTime ) ;
                                                }
                                                else
                                                {
                                                    idf = 1 ;
                                                    idHit = etThread.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tSssDateAtTimeDot , tShort ) ;
                                                    if( idHit == 1 )
                                                    {
                                                        ZE( strokeS* , psttSingleTime ) ;
                                                        countT idl = idf - 1 ;
                                                        countT idf = idHit ;
                                                        etThread.strSubstringF( tinP , psttSingleTime , idf , idl , tShort ) ; ___( psttSingleTime ) ;
                                                        tTimePair = tDot+T(psttSingleTime)+tDateAtTimeFromFileMeta+tDot ;
                                                        etThread.delF( tinP , psttSingleTime ) ;
                                                    }
                                                    else
                                                    {
                                                        idf = 1 ;
                                                        idHit = etThread.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tSssMMDDYYHHMM , tShort ) ;
                                                        if( idHit == 1 )
                                                        {
                                                            ZE( strokeS* , psttMMDDYYHHMM ) ;
                                                            countT idl = idf - 1 ;
                                                            countT idf = idHit ;
                                                            etThread.strSubstringF( tinP , psttMMDDYYHHMM , idf , idl , tShort ) ; ___( psttMMDDYYHHMM ) ;

                                                            ZE( strokeS* , psttSingle ) ;
                                                            etThread.strMakeF( tinP , LF , psttSingle , t20                               , TUCK ) ; ___( psttSingle ) ; // TUCK IS WAY MORE THAN NEEDED
                                                            etThread.strFuseF( tinP , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x04 ] ) ;
                                                            etThread.strFuseF( tinP , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x05 ] ) ;
                                                            etThread.strFuseF( tinP , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x00 ] ) ;
                                                            etThread.strFuseF( tinP , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x01 ] ) ;
                                                            etThread.strFuseF( tinP , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x02 ] ) ;
                                                            etThread.strFuseF( tinP , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x03 ] ) ;
                                                            etThread.strFuseF( tinP , psttSingle , tAt                               ) ;
                                                            etThread.strFuseF( tinP , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x06 ] ) ;
                                                            etThread.strFuseF( tinP , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x07 ] ) ;
                                                            etThread.strFuseF( tinP , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x08 ] ) ;
                                                            etThread.strFuseF( tinP , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x09 ] ) ;

                                                            tTimePair = tDot+T(psttSingle)+tDot+tDateAtTimeFromFileMeta+tDot ;
                                                            etThread.delF( tinP , psttMMDDYYHHMM ) ;
                                                        }
                                                        else
                                                        {
                                                            tTimePair = tDot+tDateAtTimeFromFileMeta+tDot+tDateAtTimeFromFileMeta+tDot ;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else                            // I HAVE A PREFIX
                                    {
                                        TN( tTimeFromPrefix , "" ) ;
                                        {
                                            ZE( strokeS* , psttTimeFromPrefix ) ;
                                            countT idl = idf + 0xc ;
                                            etThread.strSubstringF( tinP , psttTimeFromPrefix , idf , idl , tShort ) ; ___( psttTimeFromPrefix ) ;
                                            tTimeFromPrefix = T(psttTimeFromPrefix) ;
                                            etThread.delF( tinP , psttTimeFromPrefix ) ;
                                        }

                                        TN( tSequenceNumberFromPrefix , "" ) ;
                                        {
                                            ZE( strokeS* , psttSequenceNumberFromPrefix ) ;
                                            countT idl = ++ idf + 2 ;
                                            etThread.strSubstringF( tinP , psttSequenceNumberFromPrefix , idf , idl , tShort ) ; ___( psttSequenceNumberFromPrefix ) ;
                                            tSequenceNumberFromPrefix = T(psttSequenceNumberFromPrefix) ;
                                            etThread.delF( tinP , psttSequenceNumberFromPrefix ) ;
                                        }
                                        tSequenceNumber = tSequenceNumberFromPrefix ;

                                        idHit = etThread.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tDotHeyDot , tShort ) ;
                                        if( !idHit )
                                        {
                                            tTimePair = tDot+tTimeFromPrefix+tDot+tDateAtTimeFromFileMeta+tDot ;
                                        }
                                        else                        // I HAVE A DOT HEY DOT
                                        {
                                            countT idfSave = -- idf ;                             
                                            countT idHit2 = etThread.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tSssDotDateAtTimeDotDateAtTimeDot , tShort ) ;
                                            if( idHit2 )            // I HAVE A DOUBLE TIME AFTER HEY                                                  
                                            {
                                                ZE( strokeS* , psttDoubleTime ) ;
                                                countT idl = idf - 1 ;
                                                countT idf = idHit2 ;
                                                etThread.strSubstringF( tinP , psttDoubleTime , idf , idl , tShort ) ; ___( psttDoubleTime ) ;
                                                tTimePair = T(psttDoubleTime) ;
                                                etThread.delF( tinP , psttDoubleTime ) ;
                                            }
                                            else
                                            {
                                                idf = idfSave ;
                                                idHit2 = etThread.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tSssDotDateAtTimeDot , tShort ) ;
                                                if( idHit2 )            // I HAVE A SINGLE TIME AFTER HEY                                                  
                                                {
                                                    ZE( strokeS* , psttSingleTime ) ;
                                                    countT idl = idf - 1 ;
                                                    countT idf = idHit2 ;
                                                    etThread.strSubstringF( tinP , psttSingleTime , idf , idl , tShort ) ; ___( psttSingleTime ) ;
                                                    tTimePair = T(psttSingleTime)+tDateAtTimeFromFileMeta+tDot ;
                                                    etThread.delF( tinP , psttSingleTime ) ;
                                                }
                                                else                    // THERE IS NO TIME AFTER HEY
                                                {
                                                    tTimePair = tDot+tTimeFromPrefix+tDot+tDateAtTimeFromFileMeta+tDot ;
                                                }
                                            }
                                        }
                                    }

                                    if( tTimePair.csF( tinP ) > 2 )
                                    {
                                        ZE( strokeS* , psttSansDots ) ;
                                        countT idf = 2 ;
                                        countT idl = tTimePair.csF( tinP) - 1 ;
                                        etThread.strSubstringF( tinP , psttSansDots , idf , idl , tTimePair ) ; ___( psttSansDots ) ;
                                        tTimePair = T(psttSansDots) ;
                                        etThread.delF( tinP , psttSansDots ) ;
                                    }
                                }

                                TN( tNewFileData , "" ) ;
                                TN( tNewFileMetaHashedName , "" ) ;
                                TN( tNewFileMetaCurrentName , "" ) ;
                                TN( tNewFileMetaPathRoot , "" ) ;
                                TN( tNewFileMetaPathLeaf , "" ) ;
                                {
                                    TN( tHash , "" ) ;
                                    {
                                        hasherC hasher( tinP , etThread ) ;
                                        hasher.eatF( tinP , tShort , tShort.csF( tinP ) ) ;

                                        ZE( strokeS* , psttHash ) ;
                                        hasher.queryStringF( tinP , psttHash ) ; ___( psttHash ) ;
                                        tHash = T(psttHash) ;
                                        etThread.delF( tinP , psttHash ) ;
                                    }

                                    ZE( countT , idSeq ) ;
                                    do
                                    {
                                        //U:: 20200405@1155: CONJ: CAN ELIMINATE THE tSequenceNumber SEQUENCE NUMBER AND ALSO SHORTEN THE idSeq RENDERING TO 3 BIGITS: CONJ: THERE IS NO NEED TO PRESERVE tSequenceNumber; ITS ONLY PURPOSE IS TO ENSURE THAT THERE ARE NO FILE COLLISIONS
                                        //U:: LOOK: WHAT IS THE ORIGIN OF THE tSequenceNumber VALUE?: IT IS FROM A FORMAT 6 NAME
                                        //U:: DECISION: FOR THE NEXT FORMAT REVISION, ELIMINATE tSequenceNumber AND SHORTEN THE RENDERING OF idSeq TO 3 OR 4

                                        //20200410@1946: MIGRATE FROM FORMAT 8 TO FORMAT 9 BY EDITING THE FOLLOWING CODE

                                        TN( tPart1 , "" ) ; tPart1 = tTo+tNewPrefix+tTimePair+tDot+tHash+tDot+TF3(++idSeq,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,3) ;

                                        tNewFileData            = tPart1+tDotTypeData+tDotExt       ;
                                        tNewFileMetaHashedName  = tPart1+tDotTypeMetaDotHashedName  ;
                                        tNewFileMetaCurrentName = tPart1+tDotTypeMetaDotCurrentName ;
                                        tNewFileMetaPathRoot    = tPart1+tDotTypeMetaDotPathRoot    ;
                                        tNewFileMetaPathLeaf    = tPart1+tDotTypeMetaDotPathLeaf    ;
                                    }
                                    while
                                    (
                                           etThread.diskFileExistsF( tinP , tNewFileData            )
                                        || etThread.diskFileExistsF( tinP , tNewFileMetaHashedName  )
                                        || etThread.diskFileExistsF( tinP , tNewFileMetaCurrentName )
                                        || etThread.diskFileExistsF( tinP , tNewFileMetaPathRoot    )
                                        || etThread.diskFileExistsF( tinP , tNewFileMetaPathLeaf    )
                                    ) ;
                                }

                                etThread.traceF( tinP , tNewFileData+T("    ")+tOld , flTRACE_null , ifcIDtRACEdIVERT_8 ) ;

                                etThread.traceF( tinP , tNewFileMetaHashedName ) ;
                                etThread.traceF( tinP , tNewFileMetaCurrentName ) ;

                                etThread.diskMoveFileOrDirF( tinP , tNewFileData            , tOld ) ;
                                etThread.boxPutF(            tinP , tNewFileMetaHashedName  , tShort    , tShort.csF(    tinP ) ) ;
                                etThread.boxPutF(            tinP , tNewFileMetaCurrentName , tShort    , tShort.csF(    tinP ) ) ;
                                etThread.boxPutF(            tinP , tNewFileMetaPathRoot    , tPathRoot , tPathRoot.csF( tinP ) ) ;
                                etThread.boxPutF(            tinP , tNewFileMetaPathLeaf    , tPathLeaf , tPathLeaf.csF( tinP ) ) ;
                            }
                        }
                    }
                }
            }
        }
    }

    return bDoIt ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ef.diskwalkrenameforarchivalcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f0.tmpoolflushf BEGIN
#define DDNAME       "3func.330000f0.tmpoolflushf"
#define DDNUMB      (countT)0x330000f0
#define IDFILE      (countT)0x9ce


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/**/

/*1*/TASK( tmPoolFlushF )/*1*/
if( pTaskP )
{
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    while( !ether && !etThread && !processGlobal1I._poolC_bQuitFlushing )
    {
        processGlobal4I._poolC_grab_pPool.grabF( tinP , TAG( TAGiDnULL ) ) ;

        processGlobal1I._poolC_idFlushLath ++ ;

        poolC* pCursor = processGlobal1I._poolC_pPool ;
        while( pCursor )
        {
            pCursor->flushF( tinP ) ;
            pCursor = pCursor->pNext ;
        }

        processGlobal4I._poolC_grab_pPool.ungrabF( tinP ) ;

        ++ s ; ether.osSleepF( tinP , TOCK ) ;
    }

    processGlobal4I._poolC_grab_pPool.grabF( tinP , TAG( TAGiDnULL ) ) ;
    processGlobal1I._poolC_bQuitFlushing -- ;
    processGlobal4I._poolC_grab_pPool.ungrabF( tinP ) ;
}
DONE( tmPoolFlushF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f0.tmpoolflushf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f1.tmputeditionf BEGIN
#define DDNAME       "3func.330000f1.tmputeditionf"
#define DDNUMB      (countT)0x330000f1
#define IDFILE      (countT)0x9cf


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/**/

/*1*/TASK( tmPutEditionF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
{
    boolT&  bQuitP    = *(boolT*)pTaskP->c1 ;
    countT& cWorkersP = *(boolT*)pTaskP->c2 ;

    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    while( !bQuitP )
    {
        ++ s ; ether.osSleepF( tinP , TOCK >> 2 ) ;
    }

    dec02AM( cWorkersP ) ;
}
DONE( tmPutEditionF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f1.tmputeditionf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f3.tmdisplayf BEGIN
#define DDNAME       "3func.330000f3.tmdisplayf"
#define DDNUMB      (countT)0x330000f3
#define IDFILE      (countT)0x9d0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/**/

boolT bDebug33118 ;

/*1*/TASK( tmDisplayF )/*1*/

etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ; //U::TO FIND A BUG

if( pTaskP && pTaskP->c1 )
{
    displayC& displayP  = *(displayC*)pTaskP->c1 ;
    signC&    sgnReadyP =    *(signC*)pTaskP->c2 ;

    displayP.stuff.pTinWindow = &tinP ;

    if( bDebug33118 ) displayP.positionF( tinP , flDISPLAYpOSITION_CREATEwINDOW , 0x80 , 0x80 , 0x0 , 0x10 ) ;
    else              displayP.positionF( tinP , flDISPLAYpOSITION_CREATEwINDOW ) ;

    ((thirdC&)etThread).winShowWindowF( tinP , displayP , idcWINsHOW_SHOW ) ;

    sgnReadyP.giveF( tinP ) ;

    displayP.liveF( tinP ) ;

    etherC::etherFireImpersonateMonitorIF( tinP ) ;
}
DONE( tmDisplayF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f3.tmdisplayf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f4.tmciof BEGIN
#define DDNAME       "3func.330000f4.tmciof"
#define DDNUMB      (countT)0x330000f4
#define IDFILE      (countT)0x9d1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/**/

/*1*/TASK( tmCioF )/*1*/
if( pTaskP && pTaskP->c2 && pTaskP->c4 && pTaskP->c5 )
{
    const boolT& bQuitP        = pTaskP->c1 ? *(const boolT*)pTaskP->c1 : (const countT&)ether ;
    stackC&      stOutP        =                   *(stackC*)pTaskP->c2 ;
    countT*&     pcArgP        =                  *(countT**)pTaskP->c3 ;
    cioGetFT&    pCioGetFP     =                 *(cioGetFT*)pTaskP->c4 ;
    batonC&      b_pIfcRelayFP =                   *(batonC*)pTaskP->c5 ;

    //CONoUTrAW( "tmCioF: beginning to work (calling relayF)\r\n" ) ;
    etThread.relayF( tinP , bQuitP , stOutP , pcArgP , pCioGetFP , b_pIfcRelayFP ) ;

    while( stOutP )
    {
        ZE( soulC* , psPayload ) ;
        stOutP >> *(countT*)&psPayload ;
        //CONoUTrAW3( "*cio_pStkOutI AFTER PUL2 ----: " , stOutP , "\r\n" ) ; //U::
        DEL( psPayload ) ;
    }
}
DONE( tmCioF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f4.tmciof END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f5.tmrelayblowteatf BEGIN
#define DDNAME       "3func.330000f5.tmrelayblowteatf"
#define DDNUMB      (countT)0x330000f5
#define IDFILE      (countT)0x9d2


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/

/**/

/*1*/TASK( tmRelayBlowTeatF )/*1*/
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
{
    socketC& sockP           = *(socketC*)pTaskP->c1 ;
    boolT&   bQuitWoConnectP =   *(boolT*)pTaskP->c2 ;
    stackC&  stRelayOutP     =  *(stackC*)pTaskP->c3 ;

    TN( tTM , "IdeaFarm " "(tm)" ) ;
    ZE( countT , idWrap ) ;

    {
        ZE( soulC* , psWrap ) ;
        etThread( tinP , psWrap , TAG( TAGiDnULL ) ) ;
        if( psWrap )
        {
            tinP.pEther->traceF( tinP , T("identifying myself as ")+TF2(processGlobal1I.idAdamRoot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" to teat") ) ;
            *psWrap << processGlobal1I.idAdamRoot ;
            sockP.writeF( tinP , *psWrap ) ;
        }
        etThread( tinP , psWrap ) ;
    }

    while( !bQuitWoConnectP && !etThread && !stRelayOutP.third )
    {
        //etThread.traceF( tinP , T("waiting for push") ) ;
        stRelayOutP.waitF( tinP ) ;
        //etThread.traceF( tinP , T("waited  for push") ) ;
        while( !bQuitWoConnectP && stRelayOutP )
        {
            ZE( soulC* , psWrap ) ;
            stRelayOutP >> *(countT*)&psWrap ;
            if( *psWrap )
            {
                //etThread.traceF( tinP , T("writing wrap to teat") ) ;
                sockP.writeF( tinP , *psWrap ) ;
            }
            etThread( tinP , psWrap ) ;
        }
    }
}
DONE( tmRelayBlowTeatF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f5.tmrelayblowteatf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f6.logtallyif BEGIN
#define DDNAME       "3func.330000f6.logtallyif"
#define DDNUMB      (countT)0x330000f6
#define IDFILE      (countT)0x9d3


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

osTextT* ppostQuiet[] =
{
    "clock("                                    ,
    "CloseHandle("                              ,
    "CreateFileMappingNuma("                    ,
    "CreateThread("                             ,
    "DuplicateHandle("                          ,
    "FindNextChangeNotification("               ,
    "FlushViewOfFile("                          ,
    "GetCurrentProcess("                        ,
    "GetCurrentProcessId("                      ,
    "GetCurrentThread("                         ,
    "GetCurrentThreadId("                       ,
    "GetLastError("                             ,
    "GetPriorityClass("                         ,
    "GetProcessAffinityMask("                   ,
    "GetStdHandle("                             ,
    "GetThreadPriority("                        ,
    "InitializeSecurityDescriptor("             ,
    "IsBadWritePtr("                            ,
    "mem"                                       ,
    "ReadFile("                                 ,
    "recv("                                     ,
    "ResumeThread("                             ,
    "SetErrorMode("                             ,
    "SetLastError("                             ,
    "SetSecurityDescriptorDacl("                ,
    "SetSecurityDescriptorSacl("                ,
    "SetThreadPriority("                        ,
    "Sleep("                                    ,
    "str"                                       ,
    "time("                                     ,
    "timeGetTime("                              ,
    "WaitForSingleObject("                      ,
    "WriteFile("                                ,
    "WSASetLastError("                          ,
}
;

/*1*/voidT _export logTallyIF( countT tallyP , countT idLineP , countT idiFileP , boolT bFailP , countT idTallyP , const osTextT* const postP )/*1*/
{
    //ZE( boolT , bQuiet ) ;
    //{
    //    for( countT offi = 0 ; offi < sizeof ppostQuiet / sizeof ppostQuiet[ 0 ] ; offi ++ )
    //    {
    //        boolT bMatch = 1 ;
    //        ZE( countT , offi2 ) ;
    //        while( ppostQuiet[ offi ][ offi2 ] && postP[ offi2 ] )
    //        {
    //            if( postP[ offi2 ] != ppostQuiet[ offi ][ offi2 ] )
    //            {
    //                bMatch = 0 ;
    //                break ;
    //            }
    //            offi2 ++ ;
    //        }
    //
    //        if( bMatch )
    //        {
    //            bQuiet = 1 ;
    //            break ;
    //        }
    //    }
    //}
    //
    //if( !bQuiet )
    //{
    //    OStEXT( ostoBuf , TUCK << 1 )
    //    OStEXTAK( ostoBuf , "logTallyIF [tally,idiFile,idLine,bFail,idTally,expression]: " ) ;
    //    OStEXTC( ostoBuf , tallyP , ' ' ) ;
    //    OStEXTAK( ostoBuf , " " ) ;
    //    OStEXTC( ostoBuf , idiFileP , ' ' ) ;
    //    OStEXTAK( ostoBuf , " " ) ;
    //    OStEXTC( ostoBuf , idLineP , ' ' ) ;
    //    OStEXTAK( ostoBuf , " " ) ;
    //    OStEXTC( ostoBuf , !!bFailP , 0 ) ;
    //    OStEXTAK( ostoBuf , " " ) ;
    //    OStEXTC( ostoBuf , idTallyP , ' ' ) ;
    //    OStEXTAK( ostoBuf , " \"" ) ;
    //    OStEXTA( ostoBuf , postP ) ;
    //    OStEXTAK( ostoBuf , "\"\r\n" ) ;
    //    CONoUTrAW( ostoBuf ) ;
    //    LOGrAW( ostoBuf ) ;
    //}
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f6.logtallyif END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f7.emitwordif BEGIN
#define DDNAME       "3func.330000f7.emitwordif"
#define DDNUMB      (countT)0x330000f7
#define IDFILE      (countT)0x9d4


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT _export emitWordIF( tinS& tinP , const countT idLineP , const countT idFileP )/*1*/
{


    if( F(tinP.flagsThreadMode1) & flTHREADmODE1_ALLOWeMITwORD )
    {
       homeS* ph = &homeS::homeIF() ;
       if( F(processGlobal1I.flCt) & flCTdTg_bksWord  && !( F(processGlobal1I.flDt) & flCTdTg_bksWord  ) && ph && !( F(ph->flags) & flHOMEs_EXCEPTIONhASoCCURRED ) )
       {
           const countT word = 

               ( idLineP                   & 0x1fff )
               |
               ( idFileP                   & 0x1fff ) << 0xd
               |
               ( tinP.monitor.idThread     & 0x7    ) << 0x1a
               |
               ( tinP.pAdamGlobal1->idCell & 0x7    ) << 0x1d

           ;

           processGlobal3S::_processGlobal3I_IF().bksWord.writeF(  tinP , (byteT*)&word , sizeof word , 0                 , 0                            , flBOOKScwRITE_ALLoRnONE ) ;
       }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f7.emitwordif END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f8.emitwordif BEGIN
#define DDNAME       "3func.330000f8.emitwordif"
#define DDNUMB      (countT)0x330000f8
#define IDFILE      (countT)0x9d5


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT _export emitWordIF( const countT idLineP , const countT idFileP )/*1*/
{
    TINSL

    if( F(tinP.flagsThreadMode1) & flTHREADmODE1_ALLOWeMITwORD )
    {
       homeS* ph = &homeS::homeIF() ;
       if( F(processGlobal1I.flCt) & flCTdTg_bksWord  && !( F(processGlobal1I.flDt) & flCTdTg_bksWord  ) && ph && !( F(ph->flags) & flHOMEs_EXCEPTIONhASoCCURRED ) )
       {
           const countT word = 

               ( idLineP                   & 0x1fff )
               |
               ( idFileP                   & 0x1fff ) << 0xd
               |
               ( tinP.monitor.idThread     & 0x7    ) << 0x1a
               |
               ( tinP.pAdamGlobal1->idCell & 0x7    ) << 0x1d

           ;

           processGlobal3S::_processGlobal3I_IF().bksWord.writeF(  tinP , (byteT*)&word , sizeof word , 0                 , 0                            , flBOOKScwRITE_ALLoRnONE ) ;
       }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f8.emitwordif END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f9.unwrapcircleif BEGIN
#define DDNAME       "3func.330000f9.unwrapcircleif"
#define DDNUMB      (countT)0x330000f9
#define IDFILE      (countT)0x9d6


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT _export unwrapCircleIF( tinS& tinP , byteT* const pbOutP , const countT cbOutP , const byteT* const pbInP , const countT cbInP , const countT offCursorP )/*1*/
{
    IFbEcAREFUL
    {
        if( POOP ) return ;
        __NZ( cbOutP < cbInP ) ;
        __NZ( offCursorP > cbInP ) ;
        if( POOP ) return ;
    }

    _IO_

    const byteT* pbi = pbInP + offCursorP ;
    byteT*       pbo = pbOutP ;
    if( offCursorP < cbInP )
    {
        countT cbDo = cbInP - offCursorP ;
        thirdC::c_memcpyIF( tinP , pbo , pbi , cbDo ) ;
        pbo += cbDo ;
    }

    countT cbDo = offCursorP ;
    pbi = pbInP ;
    thirdC::c_memcpyIF( tinP , pbo , pbi , cbDo ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000f9.unwrapcircleif END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000fa.emitwordsif BEGIN
#define DDNAME       "3func.330000fa.emitwordsif"
#define DDNUMB      (countT)0x330000fa
#define IDFILE      (countT)0x9d7


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT _export emitWordsIF( tinS& tinP , const countT idLineP , const countT idFileP , const countT* const pcSuffixP , const countT ccSuffixP )/*1*/
{


    if( F(tinP.flagsThreadMode1) & flTHREADmODE1_ALLOWeMITwORD )
    {
       homeS* ph = &homeS::homeIF() ;
       if( F(processGlobal1I.flCt) & flCTdTg_bksWords && !( F(processGlobal1I.flDt) & flCTdTg_bksWords ) && ph && !( F(ph->flags) & flHOMEs_EXCEPTIONhASoCCURRED ) )
       {
           const countT word = 

               ( idLineP                   & 0x1fff )
               |
               ( idFileP                   & 0x1fff ) << 0xd
               |
               ( tinP.monitor.idThread     & 0x7    ) << 0x1a
               |
               ( tinP.pAdamGlobal1->idCell & 0x7    ) << 0x1d

           ;

           processGlobal3S::_processGlobal3I_IF().bksWords.writeF( tinP , (byteT*)&word , sizeof word , (byteT*)pcSuffixP , sizeof( countT ) * ccSuffixP , flBOOKScwRITE_ALLoRnONE ) ;
       }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000fa.emitwordsif END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000fb.listwalkresetindexbitscbf BEGIN
#define DDNAME       "3func.330000fb.listwalkresetindexbitscbf"
#define DDNUMB      (countT)0x330000fb
#define IDFILE      (countT)0x9d8


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/flagsT listWalkResetIndexBitsCBF( tinS& tinP )/*1*/
{
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    listingC* pListing = tinP.ta.pushed.u.listWalk.cbf.pListingP ;

    if( pListing && pListing->idTypeDatumF() )
    {
        datumC* pDatum = pListing->flagsF() & fliLISTINGc_MIXINlIST
            ? (datumC*)( (listC*)pListing + 1 )
            : (datumC*)(         pListing + 1 )
        ;

        pDatum->resetIndexBitF() ;
    }
    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    return flLISTwALKcALLbACKrETURNcODE_null ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000fb.listwalkresetindexbitscbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000fc.emailzipconfirmationcbf BEGIN
#define DDNAME       "3func.330000fc.emailzipconfirmationcbf"
#define DDNUMB      (countT)0x330000fc
#define IDFILE      (countT)0x9d9


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT emailZipConfirmationCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    count8S&      c8pP                                               =        *(count8S*)cArgP ;
    countT&       cLeverPasswordP                                    =       *(countT*)c8pP.c3 ;
    switchStackC& swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP = *(switchStackC*)c8pP.c4 ;

    //swKVP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    //countT cFlavors = swKVP.cFlavorsF( tinP ) ;
    //etThread.traceF(   tinP , TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" KV's received:") ) ;
    //for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    //{
    //    psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
    //    strokeS* psttv = (strokeS*)(countT)swKVP ;
    //
    //    etThread.traceF( tinP           , T("KV:  ")+T(psttLeverKVP)+T(":  \"")+T(psttv)+T("\"") ) ;
    //}
    //swKVP.ungrabF( tinP ) ;

    TN( tKeyPass , "pass" ) ;

    TN( tPass , "" ) ;
    swKVP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    psttLeverKVP = tKeyPass ; tPass = T((strokeS*)(countT)swKVP) ;
    swKVP.ungrabF( tinP ) ;

    countT password = etThread.strDigitsToSCountF( tinP , tPass ) ;

    swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP.grabF( tinP , TAG( TAGiDnULL ) ) ;

    if( swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP.idSlotOfLeverF( tinP , password ) )
    {
        cLeverPasswordP = password ;

        if( swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP == 5 )
        {
            ZE( strokeS* , psttPeer    ) ;
            ZE( strokeS* , psttDelete  ) ;
            ZE( strokeS* , psttEmail   ) ;
            ZE( strokeS* , psttZip     ) ;
            ZE( strokeS* , psttCountry ) ;
            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP >> psttCountry ;
            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP >> psttZip     ;
            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP >> psttEmail   ;
            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP >> psttDelete  ;
            swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP >> psttPeer    ;

            IFsCRATCH
            {
                SCOOPS

                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                tinP.pEtScratch->boxZapF( tinP , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/unconfirmed.email/ip.")+T(psttPeer) , 1 ) ;
                THREADmODE1rESTORE

                if( POOP ) { POOPR ; }
            }

            boolT bDelete = psttDelete && !etThread.strCompareF( tinP , psttDelete , T("yes") ) ;
            if( bDelete ) meP.pushSnipF( tinP , stBodyP , T(psttEmail)+T(", has been unregistered, effective immediately.  Sorry to see you go!  (If you change your mind, just register again.)\r\n") ) ;
            else          meP.pushSnipF( tinP , stBodyP , T(psttEmail)+T(" is now registered for Wo'O's Table in ")+T(psttZip)+T(".  Come.  Eat with us!<p>To update (or delete), simply register again.\r\n") ) ;

            ZE( countT , finger ) ;
            putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEcONFIRMEDeMAIL ) ;

            soulC rec( tinP , TAG( TAGiDnULL ) ) ;
            rec << finger ;
            rec << (countT)1 ;          // IDfORMAT
            rec << psttPeer ;
            rec << psttDelete ;
            rec << psttEmail ;
            rec << psttZip ;
            rec << psttCountry ;

            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            TN( tHost , "" ) ;
            {
                ZE( strokeS* , psttHost ) ;
                etThread.sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
                if( !psttHost ) etThread.traceF( tinP , T("error: reverse DNS lookup on myself failed 82") ) ;
                else            tHost = T(psttHost) ;
                etThread.delF( tinP , psttHost ) ;
                if( !tHost.csF( tinP ) ) tHost = T("factories") ;
            }

            TN( tShort , "" ) ;
            {
                ZE( strokeS* , psttFile ) ;
                etThread.boxPutUniqueF( tinP , psttFile , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/confirmed.email/email.")+tHost , WS( rec ) ) ; ___( psttFile ) ;

                ZE( strokeS* , psttnu ) ;
                ZE( strokeS* , psttShort ) ;
                etThread.strBisectF( tinP , psttnu , psttShort , psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                tShort = T(psttShort) ;
                etThread.delF( tinP , psttnu ) ;
                etThread.delF( tinP , psttShort ) ;
                etThread.delF( tinP , psttFile ) ;
            }

            textC tTime( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

            TN( tBody ,

                bDelete
                ?
                    "Subject: Wo'O's Table:  Your email has been unregistered, effective immediately.\r\n"
                    "\r\n"
                    "Sorry to see you go!  If you change your mind, just register again.\r\n"
                    "\r\n"
                :    
                    "Subject: Wo'O's Table:  Your email is now registered.\r\n"
                    "\r\n"
                    "Thank you for deciding to participate in Wo'O's Table.\r\n"
                    "The following information has been registered:\r\n"
                    "\r\n"

            ) ;

            tBody += T("email:  ")+T(psttEmail)+T("\r\n") ;

            if( !bDelete )
            {
                tBody += T("postal code:  ")+T(psttZip)+T("\r\n") ;
                tBody += T("country:  ")+T(psttCountry)+T("\r\n") ;
            }

            tBody += T("\r\nreference:  ")+tShort+T("\r\n") ;
            tBody += T("time:  ")+tTime+T("\r\n") ;

            etThread.boxPutF( tinP , T("smtp.mailgun.org[admin]/b42/smtp/")+tHost+T("@ideafarm.com/")+T(psttEmail)+T("//wo@ideafarm.com/ideafarm.factory.reports@gmail.com") , tBody ) ;

            etThread.delF( tinP , psttPeer    ) ;
            etThread.delF( tinP , psttDelete  ) ;
            etThread.delF( tinP , psttEmail   ) ;
            etThread.delF( tinP , psttZip     ) ;
            etThread.delF( tinP , psttCountry ) ;

            THREADmODE1rESTORE
        }
        else meP.pushSnipF( tinP , stBodyP , T("Something went wrong.  I recognized your password but could not find your email and postal code.  Please register your email again.\r\n") ) ;

        swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP.purgeF( tinP ) ;
    }
    else meP.pushSnipF( tinP , stBodyP , T("I did not recognize the password in the link that you clicked.  (This will happen if the server serving you this page was restarted.)  Please submit your email and postal code again.\r\n\r\nIf you receive this error more than once, request support by emailing support@ideafarm.com .\r\n") ) ;

    swsUnconfirmedPeerDeleteEmailZipCountryByPasswordP.ungrabF( tinP ) ;

    //etThread.traceF( tinP , T("nnPeerP: ")+T(nnPeerP) ) ;
    //etThread.traceF( tinP , T("psttUrlP:  ")+T(psttUrlP) ) ;
    //etThread.traceF( tinP , T("psttPeerAgentP:  ")+T(psttPeerAgentP) ) ;
    //etThread.traceF( tinP , T("postBodyP:  ")+T(postBodyP) ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000fc.emailzipconfirmationcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000fd.homecbf BEGIN
#define DDNAME       "3func.330000fd.homecbf"
#define DDNUMB      (countT)0x330000fd
#define IDFILE      (countT)0x9da


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/


#define ifcIDhTTPlOADmODE_NObALANCE         1
#define ifcIDhTTPlOADmODE_bALANCE           2


/*1*/voidT homeCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    _IO_

    etThread.traceF( tinP , T("[psttNameP]:    ")+T(psttNameP) ) ;
    /***************************************************************************************************/
    /***************************************************************************************************/
    /***************************************************************************************************/
    /****                                                                                           ****/
    /****  RECEIVE QUERY PARAMETERS                                                                 ****/
    /****                                                                                           ****/
    /***************************************************************************************************/
    /***************************************************************************************************/
    /***************************************************************************************************/

    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;
    boolT bRedirect = !etThread.strCompareF( tinP , psttNameP , T("/home.force.redirect") ) ;
    if( !bRedirect )
    {
        TN( tKeyRedirect   , "redirect" ) ;
        TN( tValueRedirect , "" ) ;
        TN( tYes , "yes" ) ;

        textC* pptKey[] =
        {
            &tKeyRedirect ,
        } ;

        textC* pptValue[] =
        {
            &tValueRedirect ,
        } ;

        countT cFlavors = swKVP.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;

            for( countT offk = 0 ; offk < sizeof pptKey / sizeof pptKey[ 0 ] ; offk ++ )
            {
                if( !etThread.strCompareF( tinP , psttLeverKVP , *pptKey[ offk ] ) ) *pptValue[ offk ] = T((strokeS*)(countT)swKVP) ;
            }
        }

        bRedirect = !etThread.strCompareF( tinP , tValueRedirect , tYes ) ;
    }

#if defined( NEVERdEFINED )
    if( !bRedirect )
    {
        TlIST( tListWoMoreFileLong ) ;
        tListWoMoreFileLong += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(nnPeerP) ;
        tListWoMoreFileLong += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(nnPeerP) ;
        tListWoMoreFileLong += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(nnPeerP) ;

        TN( tSay , "home not redirected, so wo more request allowed" ) ;
        etThread.boxPutF( tinP , tListWoMoreFileLong , tSay , tSay.csF( tinP ) ) ;

        etThread.traceF( tinP , T("displaying captcha") ) ;

        tSay = T(

            "<!doctype html>\r\n"
            "<head>\r\n"
                "<title>Wo'O's Table Captcha</title>\r\n"
                "<meta name=\"description\" content=\"Wo'O's Table Captcha\">\r\n"
                "<meta name=\"keywords\" content=\"conversation chat Wo'O's Table uncensored\">\r\n"
            "</head>\r\n"
            "<body style=\"background-color:#000 ; color:#ff6 ; font-family: sans-serif ;\">\r\n"
                "<a href=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/home.force.redirect\"></a>\r\n"          //THESE ARE TRAPS TO ENSURE THAT BOT DOES NOT "ACTIVATE" THE BUTTON
                "<a href=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/home.force.redirect.1\"></a>\r\n"
                "<a href=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/home.force.redirect.2\"></a>\r\n"
                "<a href=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/home.force.redirect.3\"></a>\r\n"
                "<a href=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/home.force.redirect.4\"></a>\r\n"
                "<a href=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/home.force.redirect.5\"></a>\r\n"
                "<a href=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/home.force.redirect.6\"></a>\r\n"
                "<a href=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/home.force.redirect.7\"></a>\r\n"
                "<a href=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/home.force.redirect.8\"></a>\r\n"
                "<br>\r\n"
                "Please prove that you are a human by clicking this button:\r\n"
                "<p>\r\n"
                "<form action=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/?redirect=yes\" id=\"captcha\" method=\"post\" name=\"captcha\">\r\n"
                    "<input id=\"submitcaptcha\" name=\"submitcaptcha\" type=\"submit\" value=\"Click if you're human.\"/>\r\n"
                "</form>\r\n"
                "<p>\r\n"
                "Do not refresh this page!\r\n"
                "Refreshing this page will cause you to be \"blocked\" for an indefinite period from viewing this web site.\r\n"
                "The IDEAFARM.COM servers will only allow one more request from your IP address.\r\n"
                "This is to eliminate computer generated requests, including attacks on our servers.\r\n"
                "<p>\r\n"
                "If you get blocked, use another computer and then post a request for help on the Wo'O's Table Talk page.\r\n"
                "<p>\r\n"
                "If you are still blocked, try yet another computer and be sure to use a current version of the Firefox browser.\r\n"
                "Then please report your experience on the Talk page, so that the problem can be fixed for you and others.\r\n"
            "</body>\r\n"

        ) ;

        ZE( pbRefC* , prPosts ) ;
        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        DEL( prPosts ) ;
    }
    else
#endif

    {
#if defined( NEVERdEFINED )
        TlIST( tListBlockFileLong ) ;
        tListBlockFileLong += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(nnPeerP) ;
        tListBlockFileLong += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(nnPeerP) ;
        tListBlockFileLong += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(nnPeerP) ;

        TlIST( tListHumanFileLong ) ;
        tListHumanFileLong += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(nnPeerP) ;
        tListHumanFileLong += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(nnPeerP) ;
        tListHumanFileLong += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(nnPeerP) ;

        IFsCRATCH
        {
            SCOOPS
            tinP.pEtScratch->diskMoveFileOrDirF( tinP , tListHumanFileLong , tListBlockFileLong , 1 ) ;
            if( POOP ) { POOPR }
        }
#endif

        etThread.traceF( tinP , T("redirecting") ) ;

        replyP.idSnipHttpPrefix = ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP ;

        static boolT idLoadMode ;
        if( !idLoadMode )
        {
            ZE( strokeS* , psttHttpLoadMode ) ; etThread.querySettingF( tinP , psttHttpLoadMode , T("!ipdos.serve.http.load.mode")  ) ; ___( psttHttpLoadMode ) ;
            idLoadMode = bSandbox || ( psttHttpLoadMode && !etThread.strCompareF( tinP , psttHttpLoadMode , T("nobalance") ) )
                ? ifcIDhTTPlOADmODE_NObALANCE
                : ifcIDhTTPlOADmODE_bALANCE
            ;
            etThread.delF( tinP , psttHttpLoadMode ) ;
        }

        static countT offi ;

        static countT pIdSnipNoBalance[] =
        {
            ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY1
        } ;

        static countT pIdSnipBalance[] =
        {
            // 20200312@1643: THESE COMMENTS ARE OBSOLETE
            // 1: CRAFTWORK
            // 2: WINDOWS SERVER 2016 SERVES MULTIMEDIA FROM ARCHIVE
            // 3: STANDALONE TEST (SERVES HTTP WITHOUT HELP FROM OTHER SERVERS)
            // 4: GORILLA

            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY2 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY3 ,
            ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY4 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY5 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY6 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY7 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY8 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY9 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY10 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY11 ,  //10-16 SERVERS DON'T EXIST, BUT I DISCOVER THEIR NONRESPONSIVENESS JUST AS I WOULD DISCOVER AN EXISTING SERVER THAT BECOMES UNRESPONSIVE.  I DO THIS TO TEST MY ABILITY TO HANDLE A SERVER THAT GOES DOWN
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY12 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY13 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY14 ,        //U:: ENABLE WO OR MORE OF THESE TO CRAFT AND TEST CODE THAT DETECTS AND SKIPS OFFLINE SERVER
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY15 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY16 ,
        } ;

        //idLoadMode = ifcIDhTTPlOADmODE_NObALANCE ; //REMOVE IN PRODUCTION

        ZE( countT* , pIdSnip ) ;
        ZE( countT  , cIdSnip ) ;
        if( idLoadMode == ifcIDhTTPlOADmODE_NObALANCE )
        {
            pIdSnip = pIdSnipNoBalance ;
            cIdSnip = sizeof pIdSnipNoBalance / sizeof pIdSnipNoBalance[ 0 ] ;
        }
        else
        {
            pIdSnip = pIdSnipBalance ;
            cIdSnip = sizeof pIdSnipBalance / sizeof pIdSnipBalance[ 0 ] ;
        }

        countT cTries = cIdSnip ; // I WILL TRY EVERY SERVER AND THEN GIVE UP
        for(;;)
        {
            ZE( countT , idSnipLocation ) ;
            {
                ZE( pbRefC* , prPostsHttpLocation ) ;
                {
                    idSnipLocation = pIdSnip[ ( offi ++ ) % cIdSnip ] ;
                    meP.getSnipF( tinP , prPostsHttpLocation , idSnipLocation ) ; ___( prPostsHttpLocation ) ;
                }

                countT costLocation = COSTS( *prPostsHttpLocation ) ;

                TN( tNameDNS , "" ) ;
                {
                    // "http://factory 2.ideafarm.com/home.3.html"

                    ZE( strokeS* , psttLocation ) ;
                    etThread.strMakeFromOsTextF( tinP , psttLocation , POSTS( *prPostsHttpLocation ) ) ; ___( psttLocation ) ;
                    etThread.traceF( tinP , T("location [psttLocation]: ")+T(psttLocation) ) ;

                    ZE( strokeS* , pstt1w ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    etThread.strWordsF( tinP , pstt1w , psttLocation , sttq , T("/") ) ; ___( pstt1w ) ;
                    etThread.delF( tinP , psttLocation ) ;
                    countT cSkip = 1 ;
                    FORsTRINGSiN1( pstt1w )
                    {
                        //etThread.traceF( tinP , T("word [psttc1]: ")+T(psttc1) ) ;

                        if( cSkip -- ) ;
                        else
                        {
                            tNameDNS = T(psttc1) ;
                            break ;
                        }
                    }
                    etThread.delF( tinP , pstt1w ) ;
                }
                DEL( prPostsHttpLocation ) ;

                TN( tNameNetBIOS , "" ) ;
                {
                    ZE( strokeS* , pstt1w ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    etThread.strWordsF( tinP , pstt1w , tNameDNS , sttq , T(".") ) ; ___( pstt1w ) ;
                    FORsTRINGSiN1( pstt1w )
                    {
                        //etThread.traceF( tinP , T("word [psttc1]: ")+T(psttc1) ) ;

                        tNameNetBIOS = T(psttc1) ;
                        break ;
                    }
                    etThread.delF( tinP , pstt1w ) ;
                }

                etThread.traceF( tinP , T("[tNameDNS]:     ")+tNameDNS ) ;
                etThread.traceF( tinP , T("[tNameNetBIOS]: ")+tNameNetBIOS ) ;
                etThread.traceF( tinP , T("[meP]: ")+(textC&)meP ) ;

                if( etThread.strCompareF( tinP , tNameNetBIOS , (textC&)meP ) )
                {
                    etThread.traceF( tinP , T("verifying that ")+tNameDNS+T(" is responsive") ) ;
                    IFsCRATCH
                    {
                        SCOOPS

                        ZE( osTextT* , pbi ) ;
                        ZE( countT   , cbi ) ;
                        tinP.pEtScratch->boxGetShadowF( tinP , pbi , cbi , tNameDNS+T("//http/deadman1") , 1 , TUCK >> 2 ) ; ___( pbi ) ; //U:: 20190903@2233: BLAMMO IN HERE

                        if( POOP )
                        {
                            POOPR ;
                            etThread.traceF( tinP , T("unresponsive http server (impotence) [tNameDNS]: ")+tNameDNS ) ;
                            idSnipLocation = 0 ;
                        }
                        else if( !pbi || !cbi || etThread.strCompareF( tinP , T(pbi) , T("IdeaFarm (tm)") ) )
                        {
                            etThread.traceF( tinP , T("unresponsive http server (unexpected text) [tNameDNS]: ")+tNameDNS ) ;
                            idSnipLocation = 0 ;
                        }
                        else
                        {
                            //etThread.traceF( tinP , T("deadman received [pbi]: ")+T(pbi) ) ;
                        }
                        etThread.delF( tinP , pbi ) ;
                    }
                    etThread.traceF( tinP , idSnipLocation ? T("verified  that ")+tNameDNS+T(" is responsive") : T("error: ")+tNameDNS+T(" is NOT responsive") ) ;
                }
            }

            if( idSnipLocation )
            {
                replyP.idSnipHttpLocation = idSnipLocation ;
                break ;
            }
            else if( !( -- cTries ) ) break ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000fd.homecbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000fe.rebootcbf BEGIN
#define DDNAME       "3func.330000fe.rebootcbf"
#define DDNUMB      (countT)0x330000fe
#define IDFILE      (countT)0x9db


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/


/*1*/voidT rebootCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    etThread.traceF( tinP , T("reboot command received via http [nnPeerP]: ")+T(nnPeerP) ) ;
    replyP.flagsHttpReply |= flHTTPrEPLY_OSfIRE ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000fe.rebootcbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ff.talkCbf BEGIN
#define DDNAME       "3func.330000ff.talkCbf"
#define DDNUMB      (countT)0x330000ff
#define IDFILE      (countT)0x9dc


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT talkCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    _IO_

    //if( psttKVReportP && psttKVReportP->idAdam ) etThread.traceF( tinP , psttKVReportP ) ;

    TN( tDot , "." ) ;

    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW1bEFOREtITLE ) ;
    {
        TN( tSay , "Wo'O's Table (tm)\r\n" ) ;

        ZE( pbRefC* , prPosts ) ;
        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        DEL( prPosts ) ;
    }
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW2aFTERtITLE ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW3sCRIPTbEGIN ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW4sCRIPTeND ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW5hEADeND ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_BODYrAWbEGIN ) ;

    ZE( boolT , bBlocked ) ;
    {
        TN( tPattern , "blocked.ip." ) ; tPattern += T(nnPeerP)+T(".*") ;
        patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

        TlIST( tListPathBlocked ) ;
        {
            TN( tSuffix , "d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/blocked.ip/" ) ;
            TlISTlOAD( tListPathBlocked , meP.tListFactoryF() , tSuffix ) ;
        }

        FORsTRINGSiN1( (strokeS*)tListPathBlocked )
        {
            if( bBlocked ) break ;

            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            do
            {
                ZE( infoFileS* , pInfo ) ;
                IFsCRATCH
                {
                    SCOOPS
                    tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , psttc1 , &pat ) ;
                    if( POOP )
                    {
                        POOPR
                        etThread.traceF( tinP , T("disk or file error 1633") ) ;
                        break ;
                    }
                }

                if( !pInfo || !pInfo->psttIfoName )
                {
                    DEL( pInfo ) ;
                    break ;
                }
                else
                {
                    ZE( countT , timeE1 ) ;
                    ZE( sCountT , timeE2 ) ;
                    etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                    etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , pInfo->timeCreated1 , pInfo->timeCreated2 ) ;
                    //etThread.traceF( tinP , T("age: ")+TT(timeE1,timeE2) ) ;

                    if( timeE2 || timeE1 > TICK )
                    {
                        IFsCRATCH
                        {
                            SCOOPS
                            tinP.pEtScratch->diskFileOrDirDeleteF( tinP , pInfo->psttIfoName , flFILEoRdIRdELETE_null , 1 ) ;
                            if( POOP ) { POOPRqUIET }
                        }
                    }
                    else
                    {
                        bBlocked = 1 ;
                        DEL( pInfo ) ;
                        break ;
                    }
                }
                DEL( pInfo ) ;
            }
            while( ~hFind && !POOP ) ;
        }
    }

    if( bBlocked )
    {
        TN( tSay ,

            "<h1>Wo'O's Table Talk:  An Uncensored English Language Open Public Forum for Respectful Conversation</h1>\r\n"
            "<p>\r\n"
            "Your IP address is currently blcoked.\r\n"
            "Try again after a TICK (about 6 foreign minutes).\r\n"
            "<p>\r\n"

        ) ;

        ZE( pbRefC* , prPosts ) ;
        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        DEL( prPosts ) ;
    }
    else
    {
        boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****  RECEIVE QUERY PARAMETERS                                                                 ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        TN( tKeySubscriberId        , "subscriberid"       ) ;
        TN( tKeySecret              , "secret"             ) ;
        TN( tKeySpeech              , "speech"             ) ;
        TN( tKeySpeechAnon          , "speechanon"         ) ;
        TN( tKeyProposedTopic       , "proposedtopic"      ) ;
        TN( tKeyFilenameTopic       , "filenametopic"      ) ;
        TN( tKeyFilenameSpeechAnon  , "filenamespeechanon" ) ;

        TN( tValueSubscriberId        , "" ) ;
        TN( tValueSecret              , "" ) ;
        TN( tValueSpeech              , "" ) ;
        TN( tValueSpeechAnon          , "" ) ;
        TN( tValueProposedTopic       , "" ) ;
        TN( tValueFilenameTopic       , "" ) ;
        TN( tValueFilenameSpeechAnon  , "" ) ;

        textC* pptKey[] =
        {
            &tKeySubscriberId        ,
            &tKeySecret              ,
            &tKeySpeech              ,
            &tKeySpeechAnon          ,
            &tKeyProposedTopic       ,
            &tKeyFilenameTopic       ,
            &tKeyFilenameSpeechAnon  ,
        } ;

        textC* pptValue[] =
        {
            &tValueSubscriberId        ,
            &tValueSecret              ,
            &tValueSpeech              ,
            &tValueSpeechAnon          ,
            &tValueProposedTopic       ,
            &tValueFilenameTopic       ,
            &tValueFilenameSpeechAnon  ,
        } ;

        countT cFlavors = swKVP.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;

            //{
            //    ZE( pbRefC* , prPosts ) ;
            //
            //    TN( tSay , "" ) ; tSay = T("<p>\r\n")+T(psttLeverKVP)+T(":    ")+T((strokeS*)(countT)swKVP) ;
            //    etThread.traceF( tinP , tSay ) ;
            //
            //    etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            //    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            //    DEL( prPosts ) ;
            //}

            for( countT offk = 0 ; offk < sizeof pptKey / sizeof pptKey[ 0 ] ; offk ++ )
            {
                if( !etThread.strCompareF( tinP , psttLeverKVP , *pptKey[ offk ] ) ) *pptValue[ offk ] = T((strokeS*)(countT)swKVP) ;
            }
        }

        //etThread.traceF( tinP , tKeySpeech            +T(":    ")+tValueSpeech       ) ;

        count04T subscriberIdTry = etThread.strDigitsToSCountF( tinP , tValueSubscriberId , 0x3e ) ; //U:: THIS WILL ONLY WORK IF THE ID IS <= MAXCOUNTT
        countT   secretTry       = etThread.strDigitsToSCountF( tinP , tValueSecret       , 0x3e ) ;

        TN( tTopicGuide , "short & neutral" ) ;

        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****  VALIDATE THE ID AND SECRET                                                               ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        //VALIDATE THE SECRET
        ZE( boolT , bSecretIsOK ) ;
        TN( tBadge                   , "" ) ;
        TN( tLoginNnPeer             , "" ) ;
        TN( tLoginPaypalPayerEmail   , "" ) ;
        TN( tLoginZipUse             , "" ) ;
        TN( tLoginIdSubscriber0      , "" ) ;
        TN( tLoginFirstName          , "" ) ;
        TN( tLoginLastName           , "" ) ;
        TN( tLoginAddressName        , "" ) ;
        TN( tLoginAddressStreet      , "" ) ;
        TN( tLoginAddressCity        , "" ) ;
        TN( tLoginAddressState       , "" ) ;
        TN( tLoginAddressCountryCode , "" ) ;
        TN( tLoginAddressCountry     , "" ) ;
        TN( tLoginAddressZip         , "" ) ;
        TN( tLoginAddressStatus      , "" ) ;
        if( tValueSubscriberId.csF( tinP ) && tValueSecret.csF( tinP ) )
        {
            TN( tb4 , "    " ) ;
            etThread.traceF( tinP , T("[tValueSubscriberId,tValueSecret]:    ")+tb4+tValueSubscriberId+tb4+tValueSecret ) ;

            TN( tn , "" ) ;
            TN( tPattern , "subscription.table.live.*" ) ;
            TN( tRegister , "register" ) ;
            patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

            TlIST( tListPathSubscriptions ) ;
            {
                TN( tSuffix , "d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/subscriptions/" ) ;
                TlISTlOAD( tListPathSubscriptions , meP.tListFactoryF() , tSuffix ) ;
            }

            FORsTRINGSiN1( (strokeS*)tListPathSubscriptions )
            {
                if( bSecretIsOK ) break ;  //U:: THIS WILL GIVE FALSE "OK" IF THE CURRENT PATH DOES NOT CONTAIN ALL RECORDS FOR THIS ID ; THE CURE FOR THIS WOULD BE TO HEAL THE SUBSCRIPTION PATHS

                handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                do
                {
                    if( bSecretIsOK ) break ;  //U:: THIS WILL GIVE FALSE "OK" IF THE CURRENT PATH DOES NOT CONTAIN ALL RECORDS FOR THIS ID ; THE CURE FOR THIS WOULD BE TO HEAL THE SUBSCRIPTION PATHS

                    etThread.traceF( tinP , T(" inspecting folder:    ")+T(psttc1) ) ;

                    ZE( infoFileS* , pInfo ) ;
                    IFsCRATCH
                    {
                        SCOOPS
                        tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , psttc1 , &pat ) ;
                        if( POOP )
                        {
                            POOPR
                            etThread.traceF( tinP , T("disk or file error 1714") ) ;
                            break ;
                        }
                    }

                    if( !pInfo || !pInfo->psttIfoName )
                    {
                        etThread.traceF( tinP , T("  no more files in this folder:    ")+T(psttc1) ) ;
                        DEL( pInfo ) ;
                        break ;
                    }
                    else
                    {
                        fileNameC fn( tinP , etThread , pInfo->psttIfoName ) ;
                        etThread.traceF( tinP , T("  found 1:    ")+T(fn) ) ;

                        IFsCRATCH
                        {
                            SCOOPS

                            soulC rec( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                            tinP.pEtScratch->boxGetShadowF( tinP , rec , pInfo->psttIfoName ) ;

                            if( POOP )
                            {
                                POOPRqUIET
                                etThread.traceF( tinP , T("   file error: could not get shadow [filename]:    ")+T(pInfo->psttIfoName) ) ;
                            }
                            else
                            {
                                ZE( countT , finger ) ;
                                rec >> finger ;

                                ZE( countT , idFormat ) ;
                                rec >> idFormat ;

                                ZE( countT , timeS1 ) ;
                                rec >> timeS1 ;

                                ZE( sCountT , timeS2 ) ;
                                rec >> *(countT*)&timeS2 ;

                                ZE( strokeS* , psttAction ) ;
                                rec >> psttAction ; ___( psttAction ) ;
                                etThread.traceF( tinP , T("action: ")+T(psttAction) ) ;
                                boolT bOn = !etThread.strCompareF( tinP , psttAction , tRegister ) ;
                                etThread.delF( tinP , psttAction ) ;

                                ZE( strokeS* , psttNnPeer ) ;
                                rec >> psttNnPeer ; ___( psttNnPeer ) ;
                                tLoginNnPeer = bOn ? T(psttNnPeer) : tn ;
                                etThread.delF( tinP , psttNnPeer ) ;

                                ZE( strokeS* , psttValuePaypalPayerEmail ) ;
                                rec >> psttValuePaypalPayerEmail ; ___( psttValuePaypalPayerEmail ) ;
                                tLoginPaypalPayerEmail = bOn ? T(psttValuePaypalPayerEmail) : tn ;
                                etThread.delF( tinP , psttValuePaypalPayerEmail ) ;

                                ZE( strokeS* , psttZipUse ) ;
                                rec >> psttZipUse ; ___( psttZipUse ) ;
                                tLoginZipUse = bOn ? T(psttZipUse) : tn ;
                                etThread.delF( tinP , psttZipUse ) ;

                                ZE( strokeS* , psttValueRewardBoxHidden ) ;
                                rec >> psttValueRewardBoxHidden ; ___( psttValueRewardBoxHidden ) ;
                                etThread.delF( tinP , psttValueRewardBoxHidden ) ;

                                ZE( strokeS* , psttValueRewardBox ) ;
                                rec >> psttValueRewardBox ; ___( psttValueRewardBox ) ;
                                etThread.delF( tinP , psttValueRewardBox ) ;

                                ZE( strokeS* , psttValueTransType ) ;
                                rec >> psttValueTransType ; ___( psttValueTransType ) ;
                                etThread.delF( tinP , psttValueTransType ) ;

                                ZE( strokeS* , psttValueTransId ) ;
                                rec >> psttValueTransId ; ___( psttValueTransId ) ;
                                etThread.delF( tinP , psttValueTransId ) ;

                                ZE( count04T , idSubscriber ) ;
                                rec >> ((countT*)&idSubscriber)[ 0 ] ;
                                rec >> ((countT*)&idSubscriber)[ 1 ] ;
                                tLoginIdSubscriber0 = bOn ? TF4(((countT*)&idSubscriber)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e) : tn ;

                                //etThread.traceF( tinP , T("[tLoginIdSubscriber0]:    ")+tLoginIdSubscriber0 ) ;

                                ZE( countT , secret ) ;
                                rec >> secret ;

                                if( subscriberIdTry == idSubscriber )
                                {
                                    bSecretIsOK = !bOn ? 0 : secretTry == secret ;
                                    if( bOn ) etThread.traceF( tinP , T(bSecretIsOK?"secret is aok [secretTry]:    ":"secret is NOT ok [secretTry]:    ")+TF4(secretTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+T("    ")+TF4(secret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e) ) ;
                                }

                                ZE( strokeS* , psttValueFirstName ) ;
                                rec >> psttValueFirstName ; ___( psttValueFirstName ) ;
                                tLoginFirstName = bOn ? T(psttValueFirstName) : tn ;
                                etThread.delF( tinP , psttValueFirstName ) ;

                                ZE( strokeS* , psttValueLastName ) ;
                                rec >> psttValueLastName ; ___( psttValueLastName ) ;
                                tLoginLastName = bOn ? T(psttValueLastName) : tn ;
                                etThread.delF( tinP , psttValueLastName ) ;

                                ZE( strokeS* , psttValueAddressName ) ;
                                rec >> psttValueAddressName ; ___( psttValueAddressName ) ;

                                tLoginAddressName = T(psttValueAddressName) ;
                                etThread.delF( tinP , psttValueAddressName ) ;

                                ZE( strokeS* , psttValueAddressStreet ) ;
                                rec >> psttValueAddressStreet ; ___( psttValueAddressStreet ) ;
                                tLoginAddressStreet = bOn ? T(psttValueAddressStreet) : tn ;
                                etThread.delF( tinP , psttValueAddressStreet ) ;

                                ZE( strokeS* , psttValueAddressCity ) ;
                                rec >> psttValueAddressCity ; ___( psttValueAddressCity ) ;
                                tLoginAddressCity = bOn ? T(psttValueAddressCity) : tn ;
                                etThread.delF( tinP , psttValueAddressCity ) ;

                                ZE( strokeS* , psttValueAddressState ) ;
                                rec >> psttValueAddressState ; ___( psttValueAddressState ) ;
                                tLoginAddressState = bOn ? T(psttValueAddressState) : tn ;
                                etThread.delF( tinP , psttValueAddressState ) ;

                                ZE( strokeS* , psttValueAddressCountryCode ) ;
                                rec >> psttValueAddressCountryCode ; ___( psttValueAddressCountryCode ) ;
                                tLoginAddressCountryCode = bOn ? T(psttValueAddressCountryCode) : tn ;
                                etThread.delF( tinP , psttValueAddressCountryCode ) ;

                                ZE( strokeS* , psttValueAddressCountry ) ;
                                rec >> psttValueAddressCountry ; ___( psttValueAddressCountry ) ;
                                tLoginAddressCountry = bOn ? T(psttValueAddressCountry) : tn ;
                                etThread.delF( tinP , psttValueAddressCountry ) ;

                                ZE( strokeS* , psttValueAddressZip ) ;
                                rec >> psttValueAddressZip ; ___( psttValueAddressZip ) ;
                                tLoginAddressZip = bOn ? T(psttValueAddressZip) : tn ;
                                etThread.delF( tinP , psttValueAddressZip ) ;

                                ZE( strokeS* , psttValueAddressStatus ) ;
                                rec >> psttValueAddressStatus ; ___( psttValueAddressStatus ) ;
                                tLoginAddressStatus = bOn ? T(psttValueAddressStatus) : tn ;
                                etThread.delF( tinP , psttValueAddressStatus ) ;

                                if( POOP )
                                {
                                    POOPRqUIET
                                    etThread.traceF( tinP , T("file error: unexpected file contents [filename]:    ")+T(pInfo->psttIfoName) ) ;
                                }
                            }
                        }
                    }
                    DEL( pInfo ) ;
                }
                while( ~hFind && !POOP ) ;
            }

            if( !bSecretIsOK )
            {
                tLoginNnPeer             =
                tLoginPaypalPayerEmail   =
                tLoginZipUse             =
                tLoginIdSubscriber0      =
                tLoginFirstName          =
                tLoginLastName           =
                tLoginAddressName        =
                tLoginAddressStreet      =
                tLoginAddressCity        =
                tLoginAddressState       =
                tLoginAddressCountryCode =
                tLoginAddressCountry     =
                tLoginAddressZip         =
                tLoginAddressStatus      = tn ;

                etThread.traceF( tinP , T("secret is wrong") ) ;
            }
            else
            {
                // GENERATE A RANDOM BADGE THAT WILL BE HONORED ONLY WHEN SUBMITTED BY THE nicNamePeer THAT JUST PRESENTED CREDENTIALS
                // THIS PASSCODE PERMITS etherDoHttpJobF TO SERVE THE CORRECT FLAVOR (LOGGED IN OR NOT) FROM CACHE

                {
                    ZE( countT , badge ) ;
                    ZE( boolT , bOk ) ;
                    do
                    {
                        badge = meP.ruF() * (measure04T)MAXcOUNTT ;
                        bOk = meP.createBadgeF( tinP , badge , nnPeerP ) ;
                    }
                    while( !bOk ) ;
                    tBadge = TF2(badge,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
                }
                etThread.traceF( tinP , T("talkCBF / secret is ok [badge]:    ")+tBadge ) ;
            }
        }

        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****  FILE ANONYMOUS SPEECH OR NEWLY SELECTED TOPIC                                            ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        if( bSecretIsOK )
        {
            if( tValueFilenameSpeechAnon.csF( tinP ) )
            {
                TN( tLoginSpeechAnon      , "" ) ;
                TN( tLoginSpeechAnonClean , "" ) ;
                nicNameC nnPeerAnon ;
                IFsCRATCH
                {
                    soulC rec( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;

                    TlIST( tListSaidAnonFileLong ) ;
                    {
                        TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said.anon/")+tValueFilenameSpeechAnon ;
                        TlISTlOAD( tListSaidAnonFileLong , meP.tListFactoryF() , tSuffix ) ;
                    }

                    tinP.pEtScratch->boxGetF( tinP , rec , tListSaidAnonFileLong , 1 , 1 ) ;
                    if( POOP ) { POOPRqUIET }
                    else
                    {
                        ZE( countT , finger ) ;
                        rec >> finger ;

                        ZE( countT , idFormat ) ;
                        rec >> idFormat ;

                        ZE( countT , timeS1 ) ;
                        rec >> timeS1 ;

                        ZE( sCountT , timeS2 ) ;
                        rec >> *(countT*)&timeS2 ;

                        ZE( strokeS* , psttTimeForeign ) ;
                        rec >> psttTimeForeign ; ___( psttTimeForeign ) ;
                        etThread.delF( tinP , psttTimeForeign ) ;

                        ZE( strokeS* , psttValueSpeech ) ;
                        rec >> psttValueSpeech ; ___( psttValueSpeech ) ;
                        tLoginSpeechAnon = T(psttValueSpeech) ;
                        etThread.delF( tinP , psttValueSpeech ) ;

                        ZE( strokeS* , psttSpeechClean ) ;
                        rec >> psttSpeechClean ; ___( psttSpeechClean ) ;
                        tLoginSpeechAnonClean = T(psttSpeechClean) ;
                        etThread.delF( tinP , psttSpeechClean ) ;

                        rec >> nnPeerAnon ;

                        if( POOP )
                        {
                            POOPRqUIET
                            etThread.traceF( tinP , T("talkCBF: file error: unexpected contents [tValueFilenameSpeechAnon]:    ")+tValueFilenameSpeechAnon ) ;
                        }
                    }
                }

                if( tLoginSpeechAnonClean.csF( tinP ) )
                {
                    ZE( countT , timeN1 ) ;
                    ZE( sCountT , timeN2 ) ;
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;

                    textC tTimeForeign( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

                    ZE( countT , finger ) ;
                    putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEsAID ) ;

                    soulC said( tinP , TAG( TAGiDnULL ) ) ;
                    said << finger ;
                    said << (countT)4 ;             // IDfORMAT
                    said << timeN1 ;
                    said << (countT)timeN2 ;
                    said << (strokeS*)tTimeForeign ;
                    said << (strokeS*)T("anonymous") ;
                    said << (strokeS*)tLoginSpeechAnon ;
                    said << (strokeS*)tLoginSpeechAnonClean ;
                    said << (strokeS*)tLoginIdSubscriber0 ;
                    said << (strokeS*)tLoginPaypalPayerEmail ;
                    said << (strokeS*)tLoginFirstName ;
                    said << (strokeS*)tLoginLastName ;
                    said << (strokeS*)tLoginAddressName ;
                    said << (strokeS*)tLoginZipUse ;
                    said << (strokeS*)tLoginNnPeer ;
                    said << nnPeerAnon ;
                    said << (strokeS*)tLoginAddressStreet ;
                    said << (strokeS*)tLoginAddressCity ;
                    said << (strokeS*)tLoginAddressState ;
                    said << (strokeS*)tLoginAddressCountryCode ;
                    said << (strokeS*)tLoginAddressCountry ;
                    said << (strokeS*)tLoginAddressZip ;
                    said << (strokeS*)tLoginAddressStatus ;

                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                    TN( tHost , "" ) ;
                    {
                        ZE( strokeS* , psttHost ) ;
                        etThread.sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
                        if( !psttHost ) etThread.traceF( tinP , T("error: reverse DNS lookup on myself failed 1241") ) ;
                        else            tHost = T(psttHost) ;
                        etThread.delF( tinP , psttHost ) ;
                        if( !tHost.csF( tinP ) ) tHost = T("factories") ;
                    }

                    TN( tShort , "" ) ;
                    {
                        TlIST( tListSaidFileLong ) ;
                        {
                            TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said/said.table")+T(bSandbox?".sandbox.@1@.":".live.@1@.")+T(nnPeerP)+tDot+TF4(((countT*)&subscriberIdTry)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+TF4(((countT*)&subscriberIdTry)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+tHost ;
                            TlISTlOAD( tListSaidFileLong , meP.tListFactoryF() , tSuffix ) ;
                        }
 
                        ZE( strokeS* , psttFile ) ;
                        etThread.boxPutUniqueF( tinP , psttFile , tListSaidFileLong , WS( said ) ) ; ___( psttFile ) ;
                        FORsTRINGSiN1( psttFile )
                        {
                            //etThread.traceF( tinP , T("wrote   ")+T(psttc1) ) ;

                            if( !tShort.csF( tinP ) )
                            {
                                ZE( strokeS* , psttnu ) ;
                                ZE( strokeS* , psttShort ) ;
                                etThread.strBisectF( tinP , psttnu , psttShort , psttc1 , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                                tShort = T(psttShort) ;
                                etThread.delF( tinP , psttnu ) ;
                                etThread.delF( tinP , psttShort ) ;
                            }
                        }

                        etThread.delF( tinP , psttFile ) ;
                    }

                    TN( tBody ,

                        "Subject: Wo'O's Table:  You just posted this (from an anonymous poster) on Wo'O's Table Talk.\r\n"
                        "\r\n"
                        "\r\n"

                    ) ;

                    tBody += T("your post:\r\n\r\n")+tLoginSpeechAnonClean+T("\r\n\r\n") ;

                    tBody += T("\r\nreference:  ")+tShort+T("\r\n") ;
                    tBody += T("time:  ")+tTimeForeign+T("\r\n") ;

                    TN( tEmailSandboxMe , "ideafarmcity@gmail.com" ) ;
                    textC& tToUse = bSandbox
                        ? tEmailSandboxMe
                        : tLoginPaypalPayerEmail
                    ;

                    //U:: DO THIS ASYNCHRONOUSLY SO FAILURE IS HANDLED GRACEFULLY
                    etThread.boxPutF( tinP , T("smtp.mailgun.org[admin]/b42/smtp/")+tHost+T("@ideafarm.com/")+tToUse+T("//wo@ideafarm.com/ideafarm.factory.reports@gmail.com") , tBody ) ;

                    THREADmODE1rESTORE
                }
            }
        }

        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****  DISPLAY PAGE TITLE                                                                       ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        {
            TN( tSay ,

                "<h1>Wo'O's Table Talk:  An Uncensored English Language Open Public Forum for Respectful Conversation</h1>\r\n"

            ) ;

            ZE( pbRefC* , prPosts ) ;
            etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            DEL( prPosts ) ;
        }

        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****  DISPLAY (HIDDEN) SUBSCRIBERID AND SECRET SO AVAILABLE TO IFRAME                          ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        {
            TN( tSay , "" ) ; tSay = T(

                "<span hidden id=\"hiddensubscriberid\">")+tValueSubscriberId+T("</span>\r\n"
                "<span hidden id=\"hiddensecret\">")+tValueSecret+T("</span>\r\n"
                "<span hidden id=\"hiddenbadge\">")+tBadge+T("</span>\r\n"

            ) ;

            ZE( pbRefC* , prPosts ) ;
            etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            DEL( prPosts ) ;
        }

        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****  DISPLAY FORMS TO CERTIFY ANONYMOUS SPEECH                                                ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        ZE( boolT , bTopicIsFresh ) ;
        if( bSecretIsOK )
        {
            stackC stSaidAnonFileShort( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKrEVERSE , ifcSTACKtYPE_PTR_strokeS , ifcIDgRABlAYER_7BASEmISC1 ) ;
            {
                TN( tPattern , "" ) ; tPattern = T("said.anon.table")+T(bSandbox?".sandbox.*":".live.*") ;
                patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

                TlIST( tListSaidAnonPath ) ;
                {
                    TN( tSuffix , "d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said.anon/" ) ;
                    TlISTlOAD( tListSaidAnonPath , meP.tListFactoryF() , tSuffix ) ;
                }

                FORsTRINGSiN1( (strokeS*)tListSaidAnonPath )
                {
                    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                    do
                    {
                        ZE( infoFileS* , pInfo ) ;
                        IFsCRATCH
                        {
                            SCOOPS
                            tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , psttc1 , &pat ) ;
                            if( POOP )
                            {
                                POOPR
                                etThread.traceF( tinP , T("disk or file error 1294") ) ;
                                break ;
                            }
                        }

                        if( !pInfo || !pInfo->psttIfoName )
                        {
                            DEL( pInfo ) ;
                            break ;
                        }
                        else
                        {
                            ZE( strokeS* , psttShort ) ;
                            {
                                ZE( strokeS* , psttnu ) ;
                                etThread.strBisectF( tinP , psttnu , psttShort , pInfo->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                                etThread.delF( tinP , psttnu ) ;
                            }

                            ZE( countT , ids ) ;
                            stSaidAnonFileShort.sinkF( tinP , ids , psttShort , flSTACKsINK_UNIQUE ) ;
                            if( !ids ) etThread.delF( tinP , psttShort ) ;
                        }
                        DEL( pInfo ) ;
                    }
                    while( ~hFind && !POOP ) ;
                }
            }

            {
                TN( tb , " " ) ;
                TN( tb4 , "    " ) ;
                if( !stSaidAnonFileShort )
                {
                    //TN( tSay , "<p>\r\nNo anonymous posts are awaiting certification.\r\n" ) ;
                    //
                    //ZE( pbRefC* , prPosts ) ;
                    //etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
                    //
                    //if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                    //DEL( prPosts ) ;
                }
                else
                {
                    {
                        TN( tSay , "" ) ; tSay = T(

                            "<p>\r\n"
                            "<details>\r\n"
                                "<summary>\r\n"
                                    "Click this line before certifying.\r\n"
                                "</summary>\r\n"
                                "<p>\r\n"
                                "<h2>Certificate</h2>\r\n"
                                "<p>\r\n"
                                "I, ")+tLoginFirstName+T(" ")+tLoginLastName+T(", hereby certify that the anonymous post that I select below contains no speech other than speech that is fully protected by the First Amendment.\r\n"
                                "It does not contain OBSCENITY.\r\n"
                                "It does not create a CLEAR AND PRESENT DANGER.\r\n"
                                "It does not contain speech that is a CRIME under the laws of California or of the United States of America.\r\n"
                                "I also certify that it is not off-topic and will not otherwise DISRUPT the conversation, and that in making this determination I have not considered either viewpoint or words used.\r\n"
                            "</details>\r\n"
                            "<p>\r\n"

                        ) ;

                        ZE( pbRefC* , prPosts ) ;
                        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

                        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                        DEL( prPosts ) ;
                    }

                    while( stSaidAnonFileShort )
                    {
                        ZE( strokeS* , psttShort ) ;
                        stSaidAnonFileShort >> psttShort ;

                        TlIST( tListSaidAnonFileLong ) ;
                        {
                            TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said.anon/")+T(psttShort) ;
                            TlISTlOAD( tListSaidAnonFileLong , meP.tListFactoryF() , tSuffix ) ;
                        }

                        TN( tLoginTimeForeign , "" ) ;
                        TN( tLoginSpeech , "" ) ;
                        IFsCRATCH
                        {
                            soulC said( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                            tinP.pEtScratch->boxGetShadowF( tinP , said , tListSaidAnonFileLong ) ;

                            if( POOP ) { POOPRqUIET }
                            else
                            {
                                ZE( countT , finger ) ;
                                said >> finger ;

                                ZE( countT , idFormat ) ;
                                said >> idFormat ;

                                ZE( countT , timeS1 ) ;
                                said >> timeS1 ;

                                ZE( sCountT , timeS2 ) ;
                                said >> *(countT*)&timeS2 ;

                                ZE( strokeS* , psttTimeForeign ) ;
                                said >> psttTimeForeign ; ___( psttTimeForeign ) ;
                                tLoginTimeForeign = T(psttTimeForeign) ;
                                etThread.delF( tinP , psttTimeForeign ) ;

                                ZE( strokeS* , psttValueSpeech ) ;
                                said >> psttValueSpeech ; ___( psttValueSpeech ) ;
                                etThread.delF( tinP , psttValueSpeech ) ;

                                ZE( strokeS* , psttSpeechClean ) ;
                                said >> psttSpeechClean ; ___( psttSpeechClean ) ;
                                tLoginSpeech = T(psttSpeechClean) ;
                                etThread.delF( tinP , psttSpeechClean ) ;

                                nicNameC nnPeer ;
                                said >> nnPeer ;

                                if( POOP )
                                {
                                    POOPRqUIET
                                    etThread.traceF( tinP , T("talkCBF: file error: unexpected contents [filename]:    ")+T(psttShort) ) ;
                                }
                            }
                        }

                        TN( tOut , "" ) ; tOut = T(

                            "<p>\r\n"
                            "<table>\r\n"
                                "<tr>\r\n"
                                    "<td valign=\"center\">\r\n"
                                        "<form action=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/talk\" id=\"certify\" method=\"post\" name=\"certify\">\r\n"
                                            "<input id=\"filenamespeechanon\" name=\"filenamespeechanon\" type=\"hidden\" value=\"")+T(psttShort)+T("\"/>\r\n"
                                            "<input id=\"subscriberid\" name=\"subscriberid\" type=\"hidden\" value=\"")+tValueSubscriberId+T("\"/>\r\n"
                                            "<input id=\"secret\" name=\"secret\" type=\"hidden\" value=\"")+tValueSecret+T("\"/>\r\n"
                                            "<input id=\"badge\" name=\"badge\" type=\"hidden\" value=\"")+tBadge+T("\"/>\r\n"
                                            "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Certify\"/>\r\n"
                                        "</form>\r\n"
                                    "</td>\r\n"
                                    "<td valign=\"center\">\r\n"
                                        "<span style=\"color:Cyan\">")+tLoginTimeForeign+T(": </span>")+tLoginSpeech+T("\r\n"
                                    "</td>\r\n"
                                "</tr>\r\n"
                            "</table>\r\n"

                        ) ;

                        ZE( pbRefC* , prPosts ) ;
                        etThread.strMakeF( tinP , LF , prPosts , T("<p>\r\n")+tOut+T("\r\n") , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
                        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                        DEL( prPosts ) ;

                        etThread.delF( tinP , psttShort ) ;
                    }
                }
            }

            if( POOP )
            {
                POOPR
                etThread.traceF( tinP , T("disk or file error 985") ) ;
            }
        }

        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****  DISPLAY INSTRUCTIONS FOR POSTING                                                         ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        {
            TN( tSay ,

                "<p>\r\n"
                "<details>\r\n"
                    "<summary>\r\n"
                        "Click this line to view a list of features and benefits enjoyed by subscribers.\r\n"
                    "</summary>\r\n"
                    "<p>\r\n"
                    "<hr>\r\n"
                    "<p>\r\n"
                    "<h2>Features of Subscribing Today</h2>\r\n"
                    "<p>\r\n"
                    "<ul>\r\n"
                    "<li>Your posts appear immediately.\r\n"
                    "<li>You can propose a new topic.\r\n"
                    "<li>You can select the new topic.\r\n"
                    "<li>A copy of each of your posts will be emailed to you.\r\n"
                    "<li>Subscribers can earn \"rewards\" (referral commissions) by giving privacy-encoded links to others.\r\n"
                    "<br>(Nonsubscribers must distribute a link that reveals their email address.)\r\n"
                    "<li>Subscribers are trusted; \"rewards\" are advanced immediately.\r\n"
                    "<br>(Nonsubscribers must wait 30 days.)\r\n"
                    "<li>Today's low subscription price will rise as the Wo'O's Table community grows.\r\n"
                    "</ul>\r\n"
                    "<p>\r\n"
                    "<h2>Benefits of Subscribing Today</h2>\r\n"
                    "<p>\r\n"
                    "<ul>\r\n"
                    "<li>Any subscriber can \"certify\" (approve) a pending anonymous post.\r\n"
                    "<li>Subscribers moderate the conversation by deescalating and guiding, not by censoring or silencing.\r\n"
                    "<li>Anonymous people can say practically anything and be heard and receive feedback.\r\n"
                    "<li>No one is silenced or censored.\r\n"
                    "<li>No one can control the topics discussed, the viewpoints expressed, or the words used.\r\n"
                    "<li>Be heard!\r\n"
                    "<li>Find new friends!\r\n"
                    "<li>Make money!\r\n"
                    "<li>Lock in the low introductory subscription price by subscribing today!\r\n"
                    "</ul>\r\n"
                    "<p>\r\n"
                    "<a href=\"https://ideafarm.com/\" target=\"_blank\" rel=\"noopener\">Click this line to subscribe now (on the IDEAFARM.COM home page).</a>\r\n"
                    "<p>\r\n"
                    "<hr>\r\n"
                "</details>\r\n"
                "<p>\r\n"

            ) ;

            ZE( pbRefC* , prPosts ) ;
            etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            DEL( prPosts ) ;
        }

        {
            TN( tSay ,

                "<p>\r\n"
                "<details>\r\n"
                    "<summary>\r\n"
                        "Click this line before posting.\r\n"
                    "</summary>\r\n"
                    "<p>\r\n"
                    "<hr>\r\n"
                    "<p>\r\n"
                    "By posting here, you agree to California (Santa Clara County) jurisdiction.\r\n"
                    "You may post any speech that is protected by the First Amendment, including hate speech, commercial solicitation, and nondisruptive heckling.\r\n"
                    "However, disruptive behavior will be prosecuted.\r\n"
                    "<em>Penal Code 403: \"Every person who... willfully disturbs or breaks up any assembly or meeting... is guilty of a misdemeanor.\"</em>\r\n"
                    "What you say cannot be unsaid.\r\n"
                    "This is a permanent speech record that will not be altered except on court order.\r\n"
                    "<p>\r\n"
                    "This is a forum for respectful conversation.\r\n"
                    "If a topic is being actively discussed, do not post off topic.\r\n"
                    "(A topic is active if the \"Topic:\" line does not indicate \"Open!\".)\r\n"
                    "Do not post at all unless you will remain here to participate in any ensuing discussion.\r\n"
                    "<p>\r\n"
                    "You may express any viewpoint, and you may use any words to express that viewpoint.\r\n"
                    "(Viewpoints and the words chosen will never be deemed \"disruptive\" per se.)\r\n"
                    "But posting off-topic is disruptive, as is excessive posting.\r\n"
                    "(Your posting is excessive if the frequency of your posts is turning the \"conversation\" into a monologue or is impeding others from participating.)\r\n"
                    "<p>\r\n"
                    "<hr>\r\n"
                "</details>\r\n"
                "<p>\r\n"

            ) ;

            ZE( pbRefC* , prPosts ) ;
            etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            DEL( prPosts ) ;
        }

        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****                                                                                           ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****  3:  FILE SPEECH OR PROPOSED TOPIC                                                        ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        {
            if( subscriberIdTry )
            {
                if( !bSecretIsOK )
                {
                    ZE( pbRefC* , prPosts ) ;
                    etThread.strMakeF( tinP , LF , prPosts , T("<span style=\"color:red\">The secret \"")+tValueSecret+T("\" is wrong.  Your IP address is now blocked for a TICK (about 6 foreign minutes).</span>") , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
                    etThread.traceF( tinP , T("set error message: secret is wrong") ) ;

                    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                    DEL( prPosts ) ;

                    TlIST( tListBlockedFileLong ) ;
                    {
                        TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/blocked.ip/blocked.ip.@1@.")+T(nnPeerP)+tDot+TF4(((countT*)&subscriberIdTry)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+TF4(((countT*)&subscriberIdTry)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e) ;
                        TlISTlOAD( tListBlockedFileLong , meP.tListFactoryF() , tSuffix ) ;
                    }

                    TN( tBlocked , "blocked" ) ;
                    ZE( strokeS* , psttFile ) ;
                    etThread.boxPutUniqueF( tinP , psttFile , tListBlockedFileLong , tBlocked , tBlocked.csF( tinP ) ) ; ___( psttFile ) ;
                    //FORsTRINGSiN1( psttFile )
                    //{
                    //    etThread.traceF( tinP , T("wrote   ")+T(psttFile) ) ;
                    //}
                    etThread.delF( tinP , psttFile ) ;
                }
                else if( tValueSpeech.csF( tinP ) )
                {
                    TN( tSpeechClean , "" ) ;                //SANITIZE THE SPEECH TO SUPPRESS ALL HTML
                    {
                        ZE( strokeS* , psttRaw ) ;
                        etThread.strMakeF( tinP , LF , psttRaw , tValueSpeech ) ; ___( psttRaw ) ;

                        ZE( strokeS* , psttClean ) ;
                        etThread.strReplaceAnyF( tinP , psttClean , psttRaw , T("<>") , tDot ) ; ___( psttClean ) ;
                        etThread.delF( tinP , psttRaw ) ;

                        tSpeechClean = T(psttClean) ;
                        etThread.delF( tinP , psttClean ) ;
                    }

                    ZE( countT , timeN1 ) ;
                    ZE( sCountT , timeN2 ) ;
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;

                    textC tTimeForeign( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

                    ZE( countT , finger ) ;
                    putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEsAID ) ;

                    TN( tFlags , "" ) ;
                    soulC said( tinP , etThread , TAG( TAGiDnULL ) ) ;
                    said << finger ;
                    said << (countT)4 ;             // IDfORMAT
                    said << timeN1 ;
                    said << (countT)timeN2 ;
                    said << (strokeS*)tTimeForeign ;
                    said << (strokeS*)tFlags ;                          // FORMAT 4
                    said << (strokeS*)tValueSpeech ;
                    said << (strokeS*)tSpeechClean ;
                    said << (strokeS*)tLoginIdSubscriber0 ;
                    said << (strokeS*)tLoginPaypalPayerEmail ;
                    said << (strokeS*)tLoginFirstName ;
                    said << (strokeS*)tLoginLastName ;
                    said << (strokeS*)tLoginAddressName ;
                    said << (strokeS*)tLoginZipUse ;
                    said << (strokeS*)tLoginNnPeer ;
                    said << nnPeerP ;                                   // FORMAT 2
                    said << (strokeS*)tLoginAddressStreet ;
                    said << (strokeS*)tLoginAddressCity ;
                    said << (strokeS*)tLoginAddressState ;
                    said << (strokeS*)tLoginAddressCountryCode ;
                    said << (strokeS*)tLoginAddressCountry ;
                    said << (strokeS*)tLoginAddressZip ;
                    said << (strokeS*)tLoginAddressStatus ;

                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                    TN( tHost , "" ) ;
                    {
                        ZE( strokeS* , psttHost ) ;
                        etThread.sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
                        if( !psttHost ) etThread.traceF( tinP , T("error: reverse DNS lookup on myself failed 792") ) ;
                        else            tHost = T(psttHost) ;
                        etThread.delF( tinP , psttHost ) ;
                        if( !tHost.csF( tinP ) ) tHost = T("factories") ;
                    }

                    TN( tShort , "" ) ;
                    {
                        TlIST( tListSaidFileLong ) ;
                        {
                            TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said/said.table")+T(bSandbox?".sandbox.@1@.":".live.@1@.")+T(nnPeerP)+tDot+TF4(((countT*)&subscriberIdTry)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+TF4(((countT*)&subscriberIdTry)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+tHost ;
                            TlISTlOAD( tListSaidFileLong , meP.tListFactoryF() , tSuffix ) ;
                        }

                        ZE( strokeS* , psttFile ) ;
                        etThread.boxPutUniqueF( tinP , psttFile , tListSaidFileLong , WS( said ) ) ; ___( psttFile ) ;
                        FORsTRINGSiN1( psttFile )
                        {
                            //etThread.traceF( tinP , T("wrote   ")+T(psttFile) ) ;

                            if( !tShort.csF( tinP ) )
                            {
                                ZE( strokeS* , psttnu ) ;
                                ZE( strokeS* , psttShort ) ;
                                etThread.strBisectF( tinP , psttnu , psttShort , psttc1 , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                                tShort = T(psttShort) ;
                                etThread.delF( tinP , psttnu ) ;
                                etThread.delF( tinP , psttShort ) ;
                                etThread.delF( tinP , psttFile ) ;
                            }
                        }
                    }

                    TN( tBody ,

                        "Subject: Wo'O's Table:  You just posted this on Wo'O's Table Talk.\r\n"
                        "\r\n"
                        "\r\n"

                    ) ;

                    tBody += T("your post:\r\n\r\n")+tValueSpeech+T("\r\n\r\n") ;

                    tBody += T("\r\nreference:  ")+tShort+T("\r\n") ;
                    tBody += T("time:  ")+tTimeForeign+T("\r\n") ;

                    TN( tEmailSandboxMe , "ideafarmcity@gmail.com" ) ;
                    textC& tToUse = bSandbox
                        ? tEmailSandboxMe
                        : tLoginPaypalPayerEmail
                    ;

                    etThread.boxPutF( tinP , T("smtp.mailgun.org[admin]/b42/smtp/")+tHost+T("@ideafarm.com/")+tToUse+T("//wo@ideafarm.com/ideafarm.factory.reports@gmail.com") , tBody ) ;

                    THREADmODE1rESTORE
                }
                else if( tValueProposedTopic.csF( tinP ) && etThread.strCompareF( tinP , tTopicGuide , tValueProposedTopic ) )
                {
                    TN( tProposedTopicClean , "" ) ;                //SANITIZE THE SPEECH TO SUPPRESS ALL HTML
                    {
                        ZE( strokeS* , psttRaw ) ;
                        etThread.strMakeF( tinP , LF , psttRaw , tValueProposedTopic ) ; ___( psttRaw ) ;

                        ZE( strokeS* , psttClean ) ;
                        etThread.strReplaceAnyF( tinP , psttClean , psttRaw , T("<>") , tDot ) ; ___( psttClean ) ;
                        etThread.delF( tinP , psttRaw ) ;

                        tProposedTopicClean = T(psttClean) ;
                        etThread.delF( tinP , psttClean ) ;
                    }

                    ZE( countT , timeN1 ) ;
                    ZE( sCountT , timeN2 ) ;
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;

                    textC tTimeForeign( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

                    ZE( countT , finger ) ;
                    putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEsAIDtOPIC ) ;

                    TN( tFlags , "" ) ;
                    soulC said( tinP , TAG( TAGiDnULL ) ) ;
                    said << finger ;
                    said << (countT)4 ;             // IDfORMAT
                    said << timeN1 ;
                    said << (countT)timeN2 ;
                    said << (strokeS*)tTimeForeign ;
                    said << (strokeS*)tFlags ;                          // FORMAT 4
                    said << (strokeS*)tValueProposedTopic ;
                    said << (strokeS*)tProposedTopicClean ;
                    said << (strokeS*)tLoginIdSubscriber0 ;
                    said << (strokeS*)tLoginPaypalPayerEmail ;
                    said << (strokeS*)tLoginFirstName ;
                    said << (strokeS*)tLoginLastName ;
                    said << (strokeS*)tLoginAddressName ;
                    said << (strokeS*)tLoginZipUse ;
                    said << (strokeS*)tLoginNnPeer ;
                    said << nnPeerP ;                                   // FORMAT 2
                    said << (strokeS*)tLoginAddressStreet ;
                    said << (strokeS*)tLoginAddressCity ;
                    said << (strokeS*)tLoginAddressState ;
                    said << (strokeS*)tLoginAddressCountryCode ;
                    said << (strokeS*)tLoginAddressCountry ;
                    said << (strokeS*)tLoginAddressZip ;
                    said << (strokeS*)tLoginAddressStatus ;

                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                    TN( tHost , "" ) ;
                    {
                        ZE( strokeS* , psttHost ) ;
                        etThread.sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
                        if( !psttHost ) etThread.traceF( tinP , T("error: reverse DNS lookup on myself failed 691") ) ;
                        else            tHost = T(psttHost) ;
                        etThread.delF( tinP , psttHost ) ;
                        if( !tHost.csF( tinP ) ) tHost = T("factories") ;
                    }

                    TN( tShort , "" ) ;
                    {
                        TlIST( tListPTopicFileLong ) ;
                        {
                            TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/ptopic/ptopic.table")+T(bSandbox?".sandbox.@1@.":".live.@1@.")+T(nnPeerP)+tDot+TF4(((countT*)&subscriberIdTry)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+TF4(((countT*)&subscriberIdTry)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+tHost ;
                            TlISTlOAD( tListPTopicFileLong , meP.tListFactoryF() , tSuffix ) ;
                        }

                        ZE( strokeS* , psttFile ) ;
                        etThread.boxPutUniqueF( tinP , psttFile , tListPTopicFileLong , WS( said ) ) ; ___( psttFile ) ;
                        FORsTRINGSiN1( psttFile )
                        {
                            //etThread.traceF( tinP , T("wrote   ")+T(psttFile) ) ;

                            if( !tShort.csF( tinP ) )
                            {
                                ZE( strokeS* , psttnu ) ;
                                ZE( strokeS* , psttShort ) ;
                                etThread.strBisectF( tinP , psttnu , psttShort , psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                                tShort = T(psttShort) ;
                                etThread.delF( tinP , psttnu ) ;
                                etThread.delF( tinP , psttShort ) ;
                            }
                        }
                        etThread.delF( tinP , psttFile ) ;
                    }

                    TN( tBody ,

                        "Subject: Wo'O's Table:  You just proposed this topic on Wo'O's Table Talk.\r\n"
                        "\r\n"
                        "\r\n"

                    ) ;

                    tBody += T("your proposed topic:\r\n\r\n")+tValueProposedTopic+T("\r\n\r\n") ;

                    tBody += T("\r\nreference:  ")+tShort+T("\r\n") ;
                    tBody += T("time:  ")+tTimeForeign+T("\r\n") ;

                    TN( tEmailSandboxMe , "ideafarmcity@gmail.com" ) ;
                    textC& tToUse = bSandbox
                        ? tEmailSandboxMe
                        : tLoginPaypalPayerEmail
                    ;

                    etThread.boxPutF( tinP , T("smtp.mailgun.org[admin]/b42/smtp/")+tHost+T("@ideafarm.com/")+tToUse+T("//wo@ideafarm.com/ideafarm.factory.reports@gmail.com") , tBody ) ;

                    THREADmODE1rESTORE
                }
            }
        }

        if( !bSecretIsOK )
        {
            /***************************************************************************************************/
            /****                                                                                           ****/
            /****  DISPLAY FORM TO SPEAK ANONYMOUSLY                                                        ****/
            /****                                                                                           ****/
            /***************************************************************************************************/

            {
                ZE( pbRefC* , prPosts ) ;
                TN( tSay , "<p><form action=\"https://" ) ;
                if( bSandbox ) tSay += T(postCRAFTWORKfACTORY"." ) ;
                tSay += T(
                    
                    "ideafarm.com/talk\" id=\"newpost\" method=\"post\" name=\"mypost\">\r\n"
                    "<table>\r\n"
                        "<tr>\r\n"
                            "<td valign=\"center\">\r\n"
                                "<label for=\"speechanon\">Anyone can speak anonymously:</label>\r\n"
                            "</td>\r\n"
                            "<td valign=\"center\">\r\n"
                                "<textarea id=\"speechanon\" name=\"speechanon\" rows=\"1\" cols=\"100\" maxlength=\"100\" onkeydown=\"getKeyCodeAnonF( event ) ; sayLengthAnonF()\">Be respectful and lawful.  What is said cannot be unsaid.</textarea>\r\n"
                            "</td>\r\n"
                            "<td valign=\"center\">\r\n"
                                "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Speak!\"/>\r\n"
                            "</td>\r\n"
                            "<td valign=\"center\">\r\n"
                                "Remaining:\r\n"
                                "<span id=\"sayremaininganon\"></span>\r\n"
                            "</td>\r\n"
                        "</tr>\r\n"
                    "</table>\r\n"
                    "</form>\r\n"

                ) ;

                etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

                if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                DEL( prPosts ) ;
            }

            /***************************************************************************************************/
            /****                                                                                           ****/
            /****  FILE ANONYMOUS SPEECH                                                                    ****/
            /****                                                                                           ****/
            /***************************************************************************************************/

            if( tValueSpeechAnon.csF( tinP ) )
            {
                ZE( boolT , bBlocked2 ) ;
                ZE( boolT , bBlocked3 ) ;
                {
                    TlIST( tListSaidAnonPath ) ;
                    {
                        TN( tSuffix , "d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said.anon/" ) ;
                        TlISTlOAD( tListSaidAnonPath , meP.tListFactoryF() , tSuffix ) ;
                    }
     
                    {
                        // said.anon.table.sandbox.000b418c.c3aab58a.326b92eb.86800000.44d30000.5639f662.0.0.factory 1
                        // said.anon.table.sandbox.????????.????????.????????.????????.????????.nnPeerP .*") ;

                        TN( tPattern , "" ) ; tPattern += T("said.anon.table")+T(bSandbox?".sandbox.":".live.")+T("????????.????????.????????.????????.????????.")+T(nnPeerP)+T(".*") ;
                        patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

                        FORsTRINGSiN1( (strokeS*)tListSaidAnonPath )
                        {
                            if( bBlocked2 ) break ;

                            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                            do
                            {
                                ZE( infoFileS* , pInfo ) ;
                                IFsCRATCH
                                {
                                    SCOOPS
                                    tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , psttc1 , &pat ) ;
                                    if( POOP )
                                    {
                                        POOPR
                                        etThread.traceF( tinP , T("disk or file error 681") ) ;
                                        break ;
                                    }
                                }

                                if( !pInfo || !pInfo->psttIfoName )
                                {
                                    DEL( pInfo ) ;
                                    break ;
                                }
                                else bBlocked2 = 1 ;
                                DEL( pInfo ) ;
                            }
                            while( ~hFind && !POOP ) ;
                        }
                    }

                    if( !bBlocked2 )
                    {
                        FORsTRINGSiN1( (strokeS*)tListSaidAnonPath )
                        {
                            if( bBlocked3 ) break ;

                            ZE( countT , cFiles ) ;
                            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                            do
                            {
                                ZE( infoFileS* , pInfo ) ;
                                IFsCRATCH
                                {
                                    SCOOPS
                                    tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , psttc1 ) ;
                                    if( POOP )
                                    {
                                        POOPR
                                        etThread.traceF( tinP , T("disk or file error 656") ) ;
                                        break ;
                                    }
                                }

                                if( !pInfo || !pInfo->psttIfoName )
                                {
                                    DEL( pInfo ) ;
                                    break ;
                                }
                                else
                                {
                                    if( ++ cFiles > 0x10 )
                                    {
                                        bBlocked3 = 1 ;
                                        break ;
                                    }
                                }
                                DEL( pInfo ) ;
                            }
                            while( ~hFind && !POOP ) ;
                        }
                    }
                }

                if( bBlocked2 )
                {
                    TN( tSay ,

                        "<p>\r\n"
                        "<span style=\"color:red\">\r\n"
                        "Your IP address already has an anonymous post awaiting certification.\r\n"
                        "Try again after you see that your previous post has been certified.\r\n"
                        "</span>\r\n"
                        "<p>\r\n"

                    ) ;

                    ZE( pbRefC* , prPosts ) ;
                    etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

                    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                    DEL( prPosts ) ;
                }
                else if( bBlocked3 )
                {
                    TN( tSay ,

                        "<p>\r\n"
                        "<span style=\"color:red\">\r\n"
                        "There are already too many anonymous posts awaiting certification.\r\n"
                        "Please try again later.\r\n"
                        "</span>\r\n"
                        "<p>\r\n"
                        "<span style=\"color:red\">\r\n"
                        "Note:  This might be due to a distributed bot attack on the IDEAFARM.COM servers.\r\n"
                        "There isn't really any effective way to defend against such attacks except to disable anonymous posting.\r\n"
                        "Please consider subscribing so that you don't need to post anonymously.\r\n"
                        "Subscribers enjoy significant benefits.\r\n"
                        "</span>\r\n"
                        "<p>\r\n"

                    ) ;

                    ZE( pbRefC* , prPosts ) ;
                    etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

                    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                    DEL( prPosts ) ;
                }
                else
                {
                    {
                        TN( tSay ,

                            "<p>\r\n"
                            "<span style=\"color:cyan\">\r\n"
                            "Your anonymous post will appear as soon as a subscriber certifies that it contains only speech that is fully protected by the First Amendment and is not disruptive (off topic).\r\n"
                            "</span>\r\n"
                            "<p>\r\n"

                        ) ;

                        ZE( pbRefC* , prPosts ) ;
                        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

                        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                        DEL( prPosts ) ;
                    }

                    TN( tSpeechClean , "" ) ;                //SANITIZE THE SPEECH TO SUPPRESS ALL HTML
                    {
                        ZE( strokeS* , psttRaw ) ;
                        etThread.strMakeF( tinP , LF , psttRaw , tValueSpeechAnon ) ; ___( psttRaw ) ;

                        ZE( strokeS* , psttClean ) ;
                        etThread.strReplaceAnyF( tinP , psttClean , psttRaw , T("<>") , tDot ) ; ___( psttClean ) ;
                        etThread.delF( tinP , psttRaw ) ;

                        tSpeechClean = T(psttClean) ;
                        etThread.delF( tinP , psttClean ) ;
                    }

                    ZE( countT , timeN1 ) ;
                    ZE( sCountT , timeN2 ) ;
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;

                    textC tTimeForeign( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

                    ZE( countT , finger ) ;
                    putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEsAIDaNON ) ;

                    soulC said( tinP , TAG( TAGiDnULL ) ) ;
                    said << finger ;
                    said << (countT)1 ;             // IDfORMAT
                    said << timeN1 ;
                    said << (countT)timeN2 ;
                    said << (strokeS*)tTimeForeign ;
                    said << (strokeS*)tValueSpeechAnon ;
                    said << (strokeS*)tSpeechClean ;
                    said << nnPeerP ;

                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                    TN( tHost , "" ) ;
                    {
                        ZE( strokeS* , psttHost ) ;
                        etThread.sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
                        if( !psttHost ) etThread.traceF( tinP , T("error: reverse DNS lookup on myself failed 493") ) ;
                        else            tHost = T(psttHost) ;
                        etThread.delF( tinP , psttHost ) ;
                        if( !tHost.csF( tinP ) ) tHost = T("factories") ;
                    }

                    TN( tShort , "" ) ;                                                                                                                 // said.anon.table.sandbox.000b418c.c3aab58a.326b92eb.86800000.44d30000.5639f662.0.0.factory 1
                    {
                        TlIST( tListSaidAnonFileLong ) ;
                        {
                            TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said.anon/said.anon.table")+T(bSandbox?".sandbox.@1@.":".live.@1@.")+T(nnPeerP)+tDot+TF4(((countT*)&subscriberIdTry)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+TF4(((countT*)&subscriberIdTry)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+tHost ;
                            TlISTlOAD( tListSaidAnonFileLong , meP.tListFactoryF() , tSuffix ) ;
                        }

                        ZE( strokeS* , psttFile ) ;
                        etThread.boxPutUniqueF( tinP , psttFile , tListSaidAnonFileLong , WS( said ) ) ; ___( psttFile ) ;
                        FORsTRINGSiN1( psttFile )
                        {
                            //etThread.traceF( tinP , T("wrote   ")+T(psttFile) ) ;

                            if( !tShort.csF( tinP ) )
                            {
                                ZE( strokeS* , psttnu ) ;
                                ZE( strokeS* , psttShort ) ;
                                etThread.strBisectF( tinP , psttnu , psttShort , psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                                tShort = T(psttShort) ;
                                etThread.delF( tinP , psttnu ) ;
                                etThread.delF( tinP , psttShort ) ;
                            }
                        }
                        etThread.delF( tinP , psttFile ) ;
                    }

                    THREADmODE1rESTORE
                }
            }

            /***************************************************************************************************/
            /****                                                                                           ****/
            /****  DISPLAY FORM TO LOG IN                                                                   ****/
            /****                                                                                           ****/
            /***************************************************************************************************/

            {
                ZE( pbRefC* , prPosts ) ;
                TN( tSay , "<form action=\"https://" ) ;
                if( bSandbox ) tSay += T(postCRAFTWORKfACTORY"." ) ;
                tSay += T(
                    
                    "ideafarm.com/talk\" id=\"login\" method=\"get\" name=\"login\">\r\n"
                    "<table>\r\n"
                        "<tr>\r\n"
                            "<td valign=\"center\">\r\n"
                                "If you are a subscriber, please log in:\r\n"
                            "</td>\r\n"
                            "<td valign=\"center\">\r\n"
                                "<label for=\"subscriberid\">Subscriber ID:</label><br>\r\n"
                                "<input id=\"subscriberid\" name=\"subscriberid\" type=\"text\" value=\"\"/>\r\n"
                            "</td>\r\n"
                            "<td valign=\"center\">\r\n"
                                "<label for=\"secret\">Secret:</label><br>\r\n"
                                "<input id=\"secret\" name=\"secret\" type=\"password\" value=\"\"/>\r\n"
                                "<br><input type=\"checkbox\" onclick=\"togglePasswordDisplayF()\">Show Secret\r\n"
                            "</td>\r\n"
                            "<td valign=\"center\">\r\n"
                                "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Log In!\"/>\r\n"
                            "</td>\r\n"
                        "</tr>\r\n"
                    "</table>\r\n"
                    "</form>\r\n"

                ) ;

                etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

                if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                DEL( prPosts ) ;
            }

            /***************************************************************************************************/
            /****                                                                                           ****/
            /****  DISPLAY SCRIPT                                                                           ****/
            /****                                                                                           ****/
            /***************************************************************************************************/

            {
                ZE( pbRefC* , prPosts ) ;
                TN( tSay , "" ) ; tSay = T(
                    
                    "<script>\r\n"
                        "var strBoxAnon   = \"\" ;\r\n"
                        "var costBoxAnon  = 0 ;\r\n"
                        "var lathKeyAnon  = 0 ;\r\n"
                        "var bWothAnon    = 1 ;\r\n"
                        "function onLoadDoF() { sayLengthAnonF() ; }\r\n"
                        "function sayLengthAnonF()\r\n"
                        "{\r\n"
                            "strBoxAnon  = document.getElementById( \"speechanon\" ).value ;\r\n"
                            "costBoxAnon = strBoxAnon.length ;\r\n"
                            "var bValidBackspace = costBoxAnon && lathKeyAnon == 8 ;\r\n"
                            "var bValidNewChar   = costBoxAnon < 100 && lathKeyAnon != 8 ;\r\n"
                            "if( lathKeyAnon != 46 && ( bValidNewChar || bValidBackspace ) )\r\n"   //IGNORES DELETE KEY (46) SINCE DON'T KNOW WHAT WAS DELETED
                            "{\r\n"
                                "var deltaLength = 1 ;\r\n"
                                "if( bWothAnon ) { bWothAnon = 0 ; deltaLength = 0 ; }\r\n"
                                "if( lathKeyAnon == 8 ) deltaLength = - 1 ;\r\n"
                                "costBoxAnon += deltaLength ;\r\n"
                                "document.getElementById( \"sayremaininganon\" ).innerHTML = 100 - costBoxAnon ;\r\n"
                            "}\r\n"
                        "}\r\n"
                        "function getKeyCodeAnonF( eventP )\r\n"
                        "{\r\n"
                            "lathKeyAnon = eventP.keyCode ;\r\n"
                        "}\r\n"
                        "function togglePasswordDisplayF()\r\n"
                        "{\r\n"
                            "var inPassword = document.getElementById( \"secret\" ) ;\r\n"
                            "if( inPassword.type === \"password\" ) { inPassword.type = \"text\"     ; }\r\n"
                            "else                                   { inPassword.type = \"password\" ; }\r\n"
                        "}\r\n"
                    "</script>\r\n"

                ) ;

                etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

                if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                DEL( prPosts ) ;
            }
        }
        else
        {
            /***************************************************************************************************/
            /****                                                                                           ****/
            /****  DISPLAY FORM TO POST SPEECH                                                              ****/
            /****                                                                                           ****/
            /***************************************************************************************************/

            {
                ZE( pbRefC* , prPosts ) ;
                TN( tSay , "<form action=\"https://" ) ;
                if( bSandbox ) tSay += T(postCRAFTWORKfACTORY"." ) ;
                tSay += T(
                    
                    "ideafarm.com/talk\" id=\"newpost\" method=\"post\" name=\"mypost\">\r\n"
                    "<input id=\"subscriberid\" name=\"subscriberid\" type=\"hidden\" value=\"")+tValueSubscriberId+T("\"/>\r\n"
                    "<input id=\"secret\" name=\"secret\" type=\"hidden\" value=\"")+tValueSecret+T("\"/>\r\n"
                    "<input id=\"badge\" name=\"badge\" type=\"hidden\" value=\"")+tBadge+T("\"/>\r\n"
                    "<table>\r\n"
                        "<tr>\r\n"
                            "<td valign=\"center\">\r\n"
                                "<label for=\"speech\">What you say will appear immediately:</label>\r\n"
                            "</td>\r\n"
                            "<td valign=\"center\">\r\n"
                                "<textarea id=\"speech\" name=\"speech\" rows=\"4\" cols=\"100\" maxlength=\"5000\" onfocus=\"/*refocusIfSpeechF()*/\" onkeydown=\"/*refocusIfSpeechF() ;*/ getKeyCodeF( event ) ; sayLengthSpeechF()\">Be respectful and lawful.  What is said cannot be unsaid.</textarea>\r\n"
                            "</td>\r\n"
                            "<td valign=\"center\">\r\n"
                                "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Speak!\"/>\r\n"
                            "</td>\r\n"
                            "<td valign=\"center\">\r\n"
                                "Remaining:\r\n"
                                "<span id=\"sayremainingspeech\"></span>\r\n"
                            "</td>\r\n"
                        "</tr>\r\n"
                    "</table>\r\n"
                    "</form>\r\n"
                    "<span id=\"subscriberidspeecherror\" style=\"color:red\"></span>\r\n"

                ) ;

                etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

                if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                DEL( prPosts ) ;
            }

            /***************************************************************************************************/
            /****                                                                                           ****/
            /****  SET bTopicIsFresh BY INSPECTING said FILES                                               ****/
            /****                                                                                           ****/
            /***************************************************************************************************/

            {
                TN( tPattern , "" ) ; tPattern = T("said.table")+T(bSandbox?".sandbox.*":".live.*") ;
                patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

                TlIST( tListSaidPath ) ;
                {
                    TN( tSuffix , "d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said/" ) ;
                    TlISTlOAD( tListSaidPath , meP.tListFactoryF() , tSuffix ) ;
                }
 
                FORsTRINGSiN1( (strokeS*)tListSaidPath )
                {
                    if( bTopicIsFresh ) break ;

                    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                    do
                    {
                        ZE( infoFileS* , pInfo ) ;
                        IFsCRATCH
                        {
                            SCOOPS
                            tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , psttc1 , &pat ) ;
                            if( POOP )
                            {
                                POOPR
                                etThread.traceF( tinP , T("disk or file error 334") ) ;
                                break ;
                            }
                        }

                        if( !pInfo || !pInfo->psttIfoName )
                        {
                            DEL( pInfo ) ;
                            break ;
                        }
                        else
                        {
                            ZE( countT , timeE1 ) ;
                            ZE( sCountT , timeE2 ) ;
                            etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                            etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , pInfo->timeCreated1 , pInfo->timeCreated2 ) ;
                            //etThread.traceF( tinP , T("age: ")+TT(timeE1,timeE2) ) ;

                            if( !timeE2 && timeE1 < TICK ) bTopicIsFresh = 1 ;
                        }
                        DEL( pInfo ) ;
                    }
                    while( ~hFind && !POOP && !bTopicIsFresh ) ;
                }
            }

            //etThread.traceF( tinP , T(bTopicIsFresh?"set TOPIC IS FRESH":"SET TOPIC IS *** NOT *** FRESH") ) ;

            /***************************************************************************************************/
            /****                                                                                           ****/
            /****  DISPLAY FORM TO PROPOSE TOPIC                                                            ****/
            /****                                                                                           ****/
            /***************************************************************************************************/

            {
                TN( tSay , "<p>\r\n<form action=\"https://" ) ;
                if( bSandbox ) tSay += T(postCRAFTWORKfACTORY"." ) ;
                tSay += T(

                    "ideafarm.com/talk\" id=\"proposedtopicform\" method=\"post\" name=\"proposedtopicform\">\r\n"
                    "<input id=\"subscriberid\" name=\"subscriberid\" type=\"hidden\" value=\"")+tValueSubscriberId+T("\"/>\r\n"
                    "<input id=\"secret\" name=\"secret\" type=\"hidden\" value=\"")+tValueSecret+T("\"/>\r\n"
                    "<input id=\"badge\" name=\"badge\" type=\"hidden\" value=\"")+tBadge+T("\"/>\r\n"
                    "<table>\r\n"
                        "<tr>\r\n"
                            "<td valign=\"center\">\r\n"
                                "<label for=\"proposedtopic\">Propose a topic:</label>\r\n"
                            "</td>\r\n"
                            "<td valign=\"center\">\r\n"
                                "<input type=\"text\" id=\"proposedtopic\" name=\"proposedtopic\" maxlength=\"40\" onfocus=\"/*refocusIfTopicF()*/\" onkeydown=\"/*refocusIfTopicF() ;*/ getKeyCodeTopicF( event ) ; sayLengthTopicF()\" value=\"")+tTopicGuide+T("\">\r\n"
                            "</td>\r\n"
                            "<td valign=\"center\">\r\n"
                                "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Propose\"/>\r\n"
                            "</td>\r\n"
                            "<td valign=\"center\">\r\n"
                                "Remaining:\r\n"
                                "<span id=\"sayremainingtopic\"></span>\r\n"
                            "</td>\r\n"
                        "</tr>\r\n"
                    "</table>\r\n"
                    "</form>\r\n"
                    "<span id=\"subscriberidtopicerror\" style=\"color:red\"></span>\r\n"
                    "<p>\r\n"

                ) ;

                ZE( pbRefC* , prPosts ) ;
                etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

                if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                DEL( prPosts ) ;
            }

            /***************************************************************************************************/
            /****                                                                                           ****/
            /****  DISPLAY SCRIPT                                                                           ****/
            /****                                                                                           ****/
            /***************************************************************************************************/

            {
                ZE( pbRefC* , prPosts ) ;
                TN( tSay , "" ) ; tSay = T(
                    
                    "<script>\r\n"
                        "var strBox       = \"\" ;\r\n"
                        "var strBoxTopic  = \"\" ;\r\n"
                        "var costBox      = 0 ;\r\n"
                        "var costBoxTopic = 0 ;\r\n"
                        "var lathKey      = 0 ;\r\n"
                        "var lathKeyTopic = 0 ;\r\n"
                        "var bWoth        = 1 ;\r\n"
                        "var bWothTopic   = 1 ;\r\n"
                        "function onLoadDoF() { sayLengthSpeechF() ; sayLengthTopicF() ; focusOnLoadF() ; }\r\n"
                        "function sayLengthSpeechF()\r\n"
                        "{\r\n"
                            "strBox = document.getElementById( \"speech\" ).value ;\r\n"
                            "costBox = strBox.length ;\r\n"
                            "var bValidBackspace = costBox && lathKey == 8 ;\r\n"
                            "var bValidNewChar   = costBox < 5000 && lathKey != 8 ;\r\n"
                            "if( lathKey != 46 && ( bValidNewChar || bValidBackspace ) )\r\n"   //IGNORES DELETE KEY (46) SINCE DON'T KNOW WHAT WAS DELETED
                            "{\r\n"
                                "var deltaLength = 1 ;\r\n"
                                "if( bWoth ) { bWoth = 0 ; deltaLength = 0 ; }\r\n"
                                "if( lathKey == 8 ) deltaLength = - 1 ;\r\n"
                                "costBox += deltaLength ;\r\n"
                                "document.getElementById( \"sayremainingspeech\" ).innerHTML = 5000 - costBox ;\r\n"
                            "}\r\n"
                        "}\r\n"
                        "function sayLengthTopicF()\r\n"
                        "{\r\n"
                            "strBoxTopic  = document.getElementById( \"proposedtopic\" ).value ;\r\n"
                            "costBoxTopic = strBoxTopic.length ;\r\n"
                            "var bValidBackspace = costBoxTopic && lathKeyTopic == 8 ;\r\n"
                            "var bValidNewChar   = costBoxTopic < 40 && lathKeyTopic != 8 ;\r\n"
                            "if( lathKeyTopic != 46 && ( bValidNewChar || bValidBackspace ) )\r\n"   //IGNORES DELETE KEY (46) SINCE DON'T KNOW WHAT WAS DELETED
                            "{\r\n"
                                "var deltaLength = 1 ;\r\n"
                                "if( bWothTopic ) { bWothTopic = 0 ; deltaLength = 0 ; }\r\n"
                                "if( lathKeyTopic == 8 ) deltaLength = - 1 ;\r\n"
                                "costBoxTopic += deltaLength ;\r\n"
                                "document.getElementById( \"sayremainingtopic\" ).innerHTML = 40 - costBoxTopic ;\r\n"
                            "}\r\n"
                        "}\r\n"
                        "function getKeyCodeF( eventP )\r\n"
                        "{\r\n"
                            "lathKey = eventP.keyCode ;\r\n"
                        "}\r\n"
                        "function getKeyCodeTopicF( eventP )\r\n"
                        "{\r\n"
                            "lathKeyTopic = eventP.keyCode ;\r\n"
                        "}\r\n"
                        "function refocusIfSpeechF()\r\n"
                        "{\r\n"
                            "strId  = document.getElementById( \"subscriberidspeech\" ).value ;\r\n"
                            "costId = strId.length ;\r\n"
                            "if( costId )\r\n"
                            "{\r\n"
                                "document.getElementById( \"subscriberidspeecherror\" ).innerHTML = \"\" ;\r\n"
                            "}\r\n"
                            "else\r\n"
                            "{\r\n"
                                "document.getElementById( \"subscriberidspeech\" ).focus() ;\r\n"
                                "document.getElementById( \"subscriberidspeecherror\" ).innerHTML = \"Subscriber ID is blank.\" ;\r\n"
                            "}\r\n"
                        "}\r\n"
                        "function refocusIfTopicF()\r\n"
                        "{\r\n"
                            "strId  = document.getElementById( \"subscriberidtopic\" ).value ;\r\n"
                            "costId = strId.length ;\r\n"
                            "if( costId )\r\n"
                            "{\r\n"
                                "document.getElementById( \"subscriberidtopicerror\" ).innerHTML = \"\" ;\r\n"
                            "}\r\n"
                            "else\r\n"
                            "{\r\n"
                                "document.getElementById( \"subscriberidtopic\" ).focus() ;\r\n"
                                "document.getElementById( \"subscriberidtopicerror\" ).innerHTML = \"Subscriber ID is blank.\" ;\r\n"
                            "}\r\n"
                        "}\r\n"
                        "function focusOnLoadF()\r\n"
                        "{\r\n"
                            "strId  = document.getElementById( \"subscriberidspeech\" ).value ;\r\n"
                            "costId = strId.length ;\r\n"
                            "if( costId )\r\n"
                            "{\r\n"
                                "document.getElementById( \"subscriberidspeecherror\" ).innerHTML = \"\" ;\r\n"
                                "document.getElementById( \"speech\" ).focus() ;\r\n"
                            "}\r\n"
                            "else\r\n"
                            "{\r\n"
                                "document.getElementById( \"subscriberidspeech\" ).focus() ;\r\n"
                            "}\r\n"
                        "}\r\n"
                    "</script>\r\n"

                ) ;

                etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

                if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                DEL( prPosts ) ;
            }
        }

        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****  1:  EXTRACT TOPIC FROM YOUNGEST TOPIC FILE                                               ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        TN( tTopic , "" ) ;
        {
            stackC stNewTopicFileShort( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKrEVERSE , ifcSTACKtYPE_PTR_strokeS , ifcIDgRABlAYER_7BASEmISC1 ) ;
            {
                TN( tPattern , "" ) ; tPattern = T("newTopic")+T(bSandbox?".sandbox.*":".live.*") ;
                patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

                TlIST( tListNewTopicPath ) ;
                {
                    TN( tSuffix , "d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/newTopic/" ) ;
                    TlISTlOAD( tListNewTopicPath , meP.tListFactoryF() , tSuffix ) ;
                }

                FORsTRINGSiN1( (strokeS*)tListNewTopicPath )
                {
                    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                    do
                    {
                        ZE( infoFileS* , pInfo ) ;
                        IFsCRATCH
                        {
                            SCOOPS
                            tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , psttc1 , &pat ) ;
                            if( POOP )
                            {
                                POOPR
                                etThread.traceF( tinP , T("disk or file error 126") ) ;
                                break ;
                            }
                        }

                        if( !pInfo || !pInfo->psttIfoName )
                        {
                            DEL( pInfo ) ;
                            break ;
                        }
                        else
                        {
                            ZE( strokeS* , psttShort ) ;
                            {
                                ZE( strokeS* , psttnu ) ;
                                etThread.strBisectF( tinP , psttnu , psttShort , pInfo->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                                etThread.delF( tinP , psttnu ) ;
                            }

                            ZE( countT , ids ) ;
                            stNewTopicFileShort.sinkF( tinP , ids , psttShort , flSTACKsINK_UNIQUE ) ;
                            if( !ids ) etThread.delF( tinP , psttShort ) ;
                        }
                        DEL( pInfo ) ;
                    }
                    while( ~hFind && !POOP ) ;
                }
            }

            TN( tb4 , "    " ) ;
            while( stNewTopicFileShort )
            {
                ZE( strokeS* , psttShort ) ;
                stNewTopicFileShort >> psttShort ;

                TlIST( tListNewTopicFileLong ) ;
                {
                    TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/newTopic/")+T(psttShort) ;
                    TlISTlOAD( tListNewTopicFileLong , meP.tListFactoryF() , tSuffix ) ;
                }

                IFsCRATCH
                {
                    SCOOPS

                    soulC newTopic( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                    tinP.pEtScratch->boxGetShadowF( tinP , newTopic , tListNewTopicFileLong ) ;

                    if( POOP ) { POOPRqUIET }
                    else
                    {
                        ZE( countT , finger ) ;
                        newTopic >> finger ;

                        ZE( countT , idFormat ) ;
                        newTopic >> idFormat ;

                        ZE( countT , timeS1 ) ;
                        newTopic >> timeS1 ;

                        ZE( sCountT , timeS2 ) ;
                        newTopic >> *(countT*)&timeS2 ;

                        ZE( strokeS* , psttTimeForeign ) ;
                        newTopic >> psttTimeForeign ; ___( psttTimeForeign ) ;
                        etThread.delF( tinP , psttTimeForeign ) ;

                        ZE( strokeS* , psttValueTopic ) ;
                        newTopic >> psttValueTopic ; ___( psttValueTopic ) ;
                        tTopic = T(psttValueTopic) ;
                        etThread.delF( tinP , psttValueTopic ) ;

                        if( POOP )
                        {
                            POOPRqUIET
                            etThread.traceF( tinP , T("talkCBF: file error: unexpected contents [filename]:    ")+T(psttShort) ) ;
                        }
                    }
                }

                etThread.delF( tinP , psttShort ) ;

                break ;
            }
        }

        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****  0:  DISPLAY TALK                                                                         ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        if( !tTopic.csF( tinP ) ) tTopic = T("Open!") ;

        {
            TN( tQuery , bSecretIsOK ? "?secretisok=yes&badge=" : "?secretisok=no" ) ;
            if( bSecretIsOK ) tQuery += tBadge ;

            TN( tSay , "" ) ; tSay = T(

                "<p>\r\n"
                "<h2>Topic: <span id=\"showtopic\" style=\"color:cyan\">")+tTopic+T("</span></h2>\r\n"
                "<p>\r\n"
                "<iframe src=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/talk.body")+tQuery+T("\" title=\"Wo'O's Table Talk Current Conversation\" style=\"width:100% ; border:none \" height=\"1000px\">Your browser does not support the iframe tag.</iframe>\r\n"

            ) ;

            ZE( pbRefC* , prPosts ) ;
            etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            DEL( prPosts ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.330000ff.talkCbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000100.testCbf BEGIN
#define DDNAME       "3func.33000100.testCbf"
#define DDNUMB      (countT)0x33000100
#define IDFILE      (countT)0x9dd


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT testCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW1bEFOREtITLE ) ;
    {
        TN( tSay , "Wo'O's Table (tm)\r\n" ) ;

        ZE( pbRefC* , prPosts ) ;
        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        DEL( prPosts ) ;
    }
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW2aFTERtITLE ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW3sCRIPTbEGIN ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW4sCRIPTeND ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW5hEADeND ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_BODYrAWbEGIN ) ;

    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;
    TN( tTopicGuide , "short & neutral" ) ;
    TN( tValueSubscriberId , "" ) ;
    TN( tValueSecret , "" ) ;

    {
        ZE( pbRefC* , prPosts ) ;
        TN( tSay , "<p><form action=\"https://" ) ;
        if( bSandbox ) tSay += T(postCRAFTWORKfACTORY"." ) ;
        tSay += T(
            
            "ideafarm.com/talk\" id=\"newpost\" method=\"post\" name=\"mypost\">\r\n"
            "<table>\r\n"
                "<tr>\r\n"
                    "<td valign=\"center\">\r\n"
                        "<textarea id=\"speechanon\" name=\"speechanon\" rows=\"1\" cols=\"100\" maxlength=\"100\" onkeydown=\"getKeyCodeAnonF( event ) ; sayLengthAnonF()\">Be respectful and lawful.  What is said cannot be unsaid.</textarea>\r\n"
                    "</td>\r\n"
                    "<td valign=\"center\">\r\n"
                        "Remaining:\r\n"
                        "<span id=\"sayremaininganon\"></span>\r\n"
                    "</td>\r\n"
                "</tr>\r\n"
                "<tr>\r\n"
                    "<td valign=\"center\">\r\n"
                        "<textarea id=\"speech\" name=\"speech\" rows=\"4\" cols=\"100\" maxlength=\"5000\" onkeydown=\"getKeyCodeF( event ) ; sayLengthSpeechF()\">Be respectful and lawful.  What is said cannot be unsaid.</textarea>\r\n"
                    "</td>\r\n"
                    "<td valign=\"center\">\r\n"
                        "Remaining:\r\n"
                        "<span id=\"sayremainingspeech\"></span>\r\n"
                    "</td>\r\n"
                "</tr>\r\n"
                "<tr>\r\n"
                    "<td valign=\"center\">\r\n"
                        "<input type=\"text\" id=\"proposedtopic\" name=\"proposedtopic\" maxlength=\"40\" onkeydown=\"getKeyCodeTopicF( event ) ; sayLengthTopicF()\" value=\"")+tTopicGuide+T("\">\r\n"
                    "</td>\r\n"
                    "<td valign=\"center\">\r\n"
                        "Remaining:\r\n"
                        "<span id=\"sayremainingtopic\"></span>\r\n"
                    "</td>\r\n"
                "</tr>\r\n"
            "</table>\r\n"
            "</form>\r\n"
            "<p>\r\n"
            "<script>\r\n"
                "var strBoxAnon   = \"\" ;\r\n"
                "var costBoxAnon  = 0 ;\r\n"
                "var lathKeyAnon  = 0 ;\r\n"
                "var bWothAnon    = 1 ;\r\n"
                "var strBox       = \"\" ;\r\n"
                "var strBoxTopic  = \"\" ;\r\n"
                "var costBox      = 0 ;\r\n"
                "var costBoxTopic = 0 ;\r\n"
                "var lathKey      = 0 ;\r\n"
                "var lathKeyTopic = 0 ;\r\n"
                "var bWoth        = 1 ;\r\n"
                "var bWothTopic   = 1 ;\r\n"
                "function getKeyCodeAnonF( eventP )\r\n"
                "{\r\n"
                    "lathKeyAnon = eventP.keyCode ;\r\n"
                "}\r\n"
                "function getKeyCodeF( eventP )\r\n"
                "{\r\n"
                    "lathKey = eventP.keyCode ;\r\n"
                "}\r\n"
                "function getKeyCodeTopicF( eventP )\r\n"
                "{\r\n"
                    "lathKeyTopic = eventP.keyCode ;\r\n"
                "}\r\n"
                "function onLoadDoF() { sayLengthAnonF() ; sayLengthSpeechF() ; sayLengthTopicF() ; }\r\n"
                "function sayLengthAnonF()\r\n"
                "{\r\n"
                    "strBoxAnon  = document.getElementById( \"speechanon\" ).value ;\r\n"
                    "costBoxAnon = strBoxAnon.length ;\r\n"
                    "var bValidBackspace = costBoxAnon && lathKeyAnon == 8 ;\r\n"
                    "var bValidNewChar   = costBoxAnon < 100 && lathKeyAnon != 8 ;\r\n"
                    "if( lathKeyAnon != 46 && ( bValidNewChar || bValidBackspace ) )\r\n"   //IGNORES DELETE KEY (46) SINCE DON'T KNOW WHAT WAS DELETED
                    "{\r\n"
                        "var deltaLength = 1 ;\r\n"
                        "if( bWothAnon ) { bWothAnon = 0 ; deltaLength = 0 ; }\r\n"
                        "if( lathKeyAnon == 8 ) deltaLength = - 1 ;\r\n"
                        "costBoxAnon += deltaLength ;\r\n"
                        "document.getElementById( \"sayremaininganon\" ).innerHTML = 100 - costBoxAnon ;\r\n"
                    "}\r\n"
                "}\r\n"
                "function sayLengthSpeechF()\r\n"
                "{\r\n"
                    "strBox = document.getElementById( \"speech\" ).value ;\r\n"
                    "costBox = strBox.length ;\r\n"
                    "var bValidBackspace = costBox && lathKey == 8 ;\r\n"
                    "var bValidNewChar   = costBox < 5000 && lathKey != 8 ;\r\n"
                    "if( lathKey != 46 && ( bValidNewChar || bValidBackspace ) )\r\n"   //IGNORES DELETE KEY (46) SINCE DON'T KNOW WHAT WAS DELETED
                    "{\r\n"
                        "var deltaLength = 1 ;\r\n"
                        "if( bWoth ) { bWoth = 0 ; deltaLength = 0 ; }\r\n"
                        "if( lathKey == 8 ) deltaLength = - 1 ;\r\n"
                        "costBox += deltaLength ;\r\n"
                        "document.getElementById( \"sayremainingspeech\" ).innerHTML = 5000 - costBox ;\r\n"
                    "}\r\n"
                "}\r\n"
                "function sayLengthTopicF()\r\n"
                "{\r\n"
                    "strBoxTopic  = document.getElementById( \"proposedtopic\" ).value ;\r\n"
                    "costBoxTopic = strBoxTopic.length ;\r\n"
                    "var bValidBackspace = costBoxTopic && lathKeyTopic == 8 ;\r\n"
                    "var bValidNewChar   = costBoxTopic < 40 && lathKeyTopic != 8 ;\r\n"
                    "if( lathKeyTopic != 46 && ( bValidNewChar || bValidBackspace ) )\r\n"   //IGNORES DELETE KEY (46) SINCE DON'T KNOW WHAT WAS DELETED
                    "{\r\n"
                        "var deltaLength = 1 ;\r\n"
                        "if( bWothTopic ) { bWothTopic = 0 ; deltaLength = 0 ; }\r\n"
                        "if( lathKeyTopic == 8 ) deltaLength = - 1 ;\r\n"
                        "costBoxTopic += deltaLength ;\r\n"
                        "document.getElementById( \"sayremainingtopic\" ).innerHTML = 40 - costBoxTopic ;\r\n"
                    "}\r\n"
                "}\r\n"
            "</script>\r\n"

        ) ;

        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        DEL( prPosts ) ;
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000100.testCbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000101.talkAnonCbf BEGIN
#define DDNAME       "3func.33000101.talkAnonCbf"
#define DDNUMB      (countT)0x33000101
#define IDFILE      (countT)0x9de


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

//20200715@2331: THIS IS OBSOLETE.  ALL FUNCTIONALITY FOR ANONYMOUS POSTS IS NOW IN talkCBF

/*1*/voidT talkAnonCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    //if( psttKVReportP && psttKVReportP->idAdam ) etThread.traceF( tinP , psttKVReportP ) ;

    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW1bEFOREtITLE ) ;
    {
        TN( tSay , "Wo'O's Table (tm)\r\n" ) ;

        ZE( pbRefC* , prPosts ) ;
        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        DEL( prPosts ) ;
    }
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW2aFTERtITLE ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW3sCRIPTbEGIN ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW4sCRIPTeND ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW5hEADeND ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_BODYrAWbEGIN ) ;

    ZE( boolT , bBlocked ) ;
    {
        TN( tPath , "////factory 2/d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/blocked.ip/" ) ;
        TN( tPattern , "blocked.ip." ) ; tPattern += T(nnPeerP)+T(".*") ;
        patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        do
        {
            ZE( infoFileS* , pInfo ) ;
            etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tPath , &pat ) ;

            if( !pInfo || !pInfo->psttIfoName )
            {
                DEL( pInfo ) ;
                break ;
            }
            else
            {
                ZE( countT , timeE1 ) ;
                ZE( sCountT , timeE2 ) ;
                etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , pInfo->timeCreated1 , pInfo->timeCreated2 ) ;
                etThread.traceF( tinP , T("age: ")+TT(timeE1,timeE2) ) ;

                if( timeE2 || timeE1 > TICK ) etThread.diskFileOrDirDeleteF( tinP , pInfo->psttIfoName , flFILEoRdIRdELETE_null , 1 ) ;
                else                          bBlocked = 1 ;
            }
            DEL( pInfo ) ;
        }
        while( ~hFind && !POOP ) ;
    }

    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

    if( bBlocked )
    {
        TN( tSay ,

            "<h1>Wo'O's Table Talk:  Anonymous posts awaiting certification</h1>\r\n"
            "<p>\r\n"
            "Your IP address is currently blcoked.\r\n"
            "Try again after a TICK (about 6 foreign minutes).\r\n"
            "<p>\r\n"

        ) ;

        ZE( pbRefC* , prPosts ) ;
        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        DEL( prPosts ) ;
    }
    else
    {
        {
            TN( tSay ,

                "<h1>Wo'O's Table Talk:  Anonymous posts awaiting certification</h1>\r\n"
                "<p>\r\n"
                "The anonymous posts listed here are awaiting certification by a subscriber.\r\n"
                "<p>\r\n"

            ) ;

            ZE( pbRefC* , prPosts ) ;
            etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            DEL( prPosts ) ;
        }

        TN( tKeySubscriberId , "subscriberid" ) ;
        TN( tKeySecret       , "secret"       ) ;
        TN( tKeySpeech       , "speechanon"   ) ;
        TN( tKeyFileName     , "filename"     ) ;

        TN( tValueSubscriberId , "" ) ;
        TN( tValueSecret       , "" ) ;
        TN( tValueSpeech       , "" ) ;
        TN( tValueFileName     , "" ) ;

        textC* pptKey[] =
        {
            &tKeySubscriberId ,
            &tKeySecret       ,
            &tKeySpeech       ,
            &tKeyFileName     ,
        } ;

        textC* pptValue[] =
        {
            &tValueSubscriberId ,
            &tValueSecret       ,
            &tValueSpeech       ,
            &tValueFileName     ,
        } ;

        countT cFlavors = swKVP.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;

            //{
            //    ZE( pbRefC* , prPosts ) ;
            //
            //    TN( tSay , "" ) ; tSay = T("<p>\r\n")+T(psttLeverKVP)+T(":    ")+T((strokeS*)(countT)swKVP) ;
            //    etThread.traceF( tinP , tSay ) ;
            //
            //    etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            //    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            //    DEL( prPosts ) ;
            //}

            for( countT offk = 0 ; offk < sizeof pptKey / sizeof pptKey[ 0 ] ; offk ++ )
            {
                if( !etThread.strCompareF( tinP , psttLeverKVP , *pptKey[ offk ] ) ) *pptValue[ offk ] = T((strokeS*)(countT)swKVP) ;
            }
        }

        if( tValueSubscriberId.csF( tinP ) ) etThread.traceF( tinP , tKeySubscriberId+T(":    ")+tValueSubscriberId ) ;
        if( tValueSecret.csF(       tinP ) ) etThread.traceF( tinP , tKeySecret      +T(":    ")+tValueSecret       ) ;
        if( tValueSpeech.csF(       tinP ) ) etThread.traceF( tinP , tKeySpeech      +T(":    ")+tValueSpeech       ) ;
        if( tValueFileName.csF(     tinP ) ) etThread.traceF( tinP , tKeyFileName    +T(":    ")+tValueFileName     ) ;

        count04T subscriberIdTry = etThread.strDigitsToSCountF( tinP , tValueSubscriberId , 0x3e ) ; //U:: THIS WILL ONLY WORK IF THE ID IS <= MAXCOUNTT
        countT   secretTry       = etThread.strDigitsToSCountF( tinP , tValueSecret       , 0x3e ) ;

        //VALIDATE THE SECRET
        ZE( boolT , bSecretIsOK ) ;
        TN( tSaidNnPeer             , "" ) ;
        TN( tSaidPaypalPayerEmail   , "" ) ;
        TN( tSaidZipUse             , "" ) ;
        TN( tSaidIdSubscriber0      , "" ) ;
        TN( tSaidFirstName          , "" ) ;
        TN( tSaidLastName           , "" ) ;
        TN( tSaidAddressName        , "" ) ;
        TN( tSaidAddressStreet      , "" ) ;
        TN( tSaidAddressCity        , "" ) ;
        TN( tSaidAddressState       , "" ) ;
        TN( tSaidAddressCountryCode , "" ) ;
        TN( tSaidAddressCountry     , "" ) ;
        TN( tSaidAddressZip         , "" ) ;
        TN( tSaidAddressStatus      , "" ) ;
        if( subscriberIdTry && secretTry )
        {
            TN( tPath , "////factory 2/d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/subscriptions/" ) ;
            TN( tPattern , "subscription.table.live.*" ) ;
            patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            do
            {
                ZE( infoFileS* , pInfo ) ;
                etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tPath , &pat ) ;

                if( !pInfo || !pInfo->psttIfoName )
                {
                    DEL( pInfo ) ;
                    break ;
                }
                else
                {
                    fileNameC fn( tinP , etThread , pInfo->psttIfoName ) ;
                    etThread.traceF( tinP , T("found 1:    ")+T(fn) ) ;

                    soulC rec( tinP , TAG( TAGiDnULL ) ) ;
                    etThread.boxGetShadowF( tinP , rec , pInfo->psttIfoName ) ;

                    ZE( countT , finger ) ;
                    rec >> finger ;

                    ZE( countT , idFormat ) ;
                    rec >> idFormat ;

                    ZE( countT , timeS1 ) ;
                    rec >> timeS1 ;

                    ZE( sCountT , timeS2 ) ;
                    rec >> *(countT*)&timeS2 ;

                    ZE( strokeS* , psttAction ) ;
                    rec >> psttAction ; ___( psttAction ) ;
                    etThread.delF( tinP , psttAction ) ;

                    ZE( strokeS* , psttNnPeer ) ;
                    rec >> psttNnPeer ; ___( psttNnPeer ) ;
                    tSaidNnPeer = T(psttNnPeer) ;
                    etThread.delF( tinP , psttNnPeer ) ;

                    ZE( strokeS* , psttValuePaypalPayerEmail ) ;
                    rec >> psttValuePaypalPayerEmail ; ___( psttValuePaypalPayerEmail ) ;
                    tSaidPaypalPayerEmail = T(psttValuePaypalPayerEmail) ;
                    etThread.delF( tinP , psttValuePaypalPayerEmail ) ;

                    ZE( strokeS* , psttZipUse ) ;
                    rec >> psttZipUse ; ___( psttZipUse ) ;
                    tSaidZipUse = T(psttZipUse) ;
                    etThread.delF( tinP , psttZipUse ) ;

                    ZE( strokeS* , psttValueRewardBoxHidden ) ;
                    rec >> psttValueRewardBoxHidden ; ___( psttValueRewardBoxHidden ) ;
                    etThread.delF( tinP , psttValueRewardBoxHidden ) ;

                    ZE( strokeS* , psttValueRewardBox ) ;
                    rec >> psttValueRewardBox ; ___( psttValueRewardBox ) ;
                    etThread.delF( tinP , psttValueRewardBox ) ;

                    ZE( strokeS* , psttValueTransType ) ;
                    rec >> psttValueTransType ; ___( psttValueTransType ) ;
                    etThread.delF( tinP , psttValueTransType ) ;

                    ZE( strokeS* , psttValueTransId ) ;
                    rec >> psttValueTransId ; ___( psttValueTransId ) ;
                    etThread.delF( tinP , psttValueTransId ) ;

                    ZE( count04T , idSubscriber ) ;
                    rec >> ((countT*)&idSubscriber)[ 0 ] ;
                    rec >> ((countT*)&idSubscriber)[ 1 ] ;
                    tSaidIdSubscriber0 = TF4(((countT*)&idSubscriber)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e) ;

                    etThread.traceF( tinP , T("[tSaidIdSubscriber0]:    ")+tSaidIdSubscriber0 ) ;

                    ZE( countT , secret ) ;
                    rec >> secret ;

                    if( subscriberIdTry == idSubscriber )
                    {
                        bSecretIsOK = secretTry == secret ;                 //U::DO THIS ONLY IF THIS RECORD IS NOT AN "UNSUBSCRIBE"
                        etThread.traceF( tinP , T(bSecretIsOK?"secret is OK":"secret is NOT ok") ) ;
                    }

                    ZE( strokeS* , psttValueFirstName ) ;
                    rec >> psttValueFirstName ; ___( psttValueFirstName ) ;
                    tSaidFirstName = T(psttValueFirstName) ;
                    etThread.delF( tinP , psttValueFirstName ) ;

                    ZE( strokeS* , psttValueLastName ) ;
                    rec >> psttValueLastName ; ___( psttValueLastName ) ;
                    tSaidLastName = T(psttValueLastName) ;
                    etThread.delF( tinP , psttValueLastName ) ;

                    ZE( strokeS* , psttValueAddressName ) ;
                    rec >> psttValueAddressName ; ___( psttValueAddressName ) ;
                    tSaidAddressName = T(psttValueAddressName) ;
                    etThread.delF( tinP , psttValueAddressName ) ;

                    ZE( strokeS* , psttValueAddressStreet ) ;
                    rec >> psttValueAddressStreet ; ___( psttValueAddressStreet ) ;
                    tSaidAddressStreet = T(psttValueAddressStreet) ;
                    etThread.delF( tinP , psttValueAddressStreet ) ;

                    ZE( strokeS* , psttValueAddressCity ) ;
                    rec >> psttValueAddressCity ; ___( psttValueAddressCity ) ;
                    tSaidAddressCity = T(psttValueAddressCity) ;
                    etThread.delF( tinP , psttValueAddressCity ) ;

                    ZE( strokeS* , psttValueAddressState ) ;
                    rec >> psttValueAddressState ; ___( psttValueAddressState ) ;
                    tSaidAddressState = T(psttValueAddressState) ;
                    etThread.delF( tinP , psttValueAddressState ) ;

                    ZE( strokeS* , psttValueAddressCountryCode ) ;
                    rec >> psttValueAddressCountryCode ; ___( psttValueAddressCountryCode ) ;
                    tSaidAddressCountryCode = T(psttValueAddressCountryCode) ;
                    etThread.delF( tinP , psttValueAddressCountryCode ) ;

                    ZE( strokeS* , psttValueAddressCountry ) ;
                    rec >> psttValueAddressCountry ; ___( psttValueAddressCountry ) ;
                    tSaidAddressCountry = T(psttValueAddressCountry) ;
                    etThread.delF( tinP , psttValueAddressCountry ) ;

                    ZE( strokeS* , psttValueAddressZip ) ;
                    rec >> psttValueAddressZip ; ___( psttValueAddressZip ) ;
                    tSaidAddressZip = T(psttValueAddressZip) ;
                    etThread.delF( tinP , psttValueAddressZip ) ;

                    ZE( strokeS* , psttValueAddressStatus ) ;
                    rec >> psttValueAddressStatus ; ___( psttValueAddressStatus ) ;
                    tSaidAddressStatus = T(psttValueAddressStatus) ;
                    etThread.delF( tinP , psttValueAddressStatus ) ;
                }
                DEL( pInfo ) ;
            }
            while( ~hFind && !POOP ) ;
        }

        if( !bSecretIsOK )
        {
            ZE( pbRefC* , prPosts ) ;
            TN( tSay , "<form action=\"https://" ) ;
            if( bSandbox ) tSay += T(postCRAFTWORKfACTORY"." ) ;
            tSay += T(
                
                "ideafarm.com/talk.anonymous\" id=\"idsecret\" method=\"get\" name=\"idsecret\">\r\n"
                "<table>\r\n"
                    "<tr>\r\n"
                        "<td valign=\"center\">\r\n"
                            "<label for=\"subscriberid\">Subscriber ID:</label><br>\r\n"
                            "<input id=\"subscriberid\" name=\"subscriberid\" type=\"text\" value=\"\"/>\r\n"
                        "</td>\r\n"
                        "<td valign=\"center\">\r\n"
                            "<label for=\"secret\">Secret:</label><br>\r\n"
                            "<input id=\"secret\" name=\"secret\" type=\"password\" value=\"\"/>\r\n"
                        "</td>\r\n"
                        "<td valign=\"center\">\r\n"
                            "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Validate\"/>\r\n"
                        "</td>\r\n"
                    "</tr>\r\n"
                "</table>\r\n"
                "</form>\r\n"

            ) ;

            etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            DEL( prPosts ) ;
        }
        else
        {
            TN( tSay , "" ) ; tSay = T(

                "<h2>Certificate</h2>\r\n"
                "<p>\r\n"
                "I, ")+tSaidFirstName+T(" ")+tSaidLastName+T(", hereby certify that the anonymous post that I select below contains no speech other than speech that is fully protected by the First Amendment.\r\n"
                "It does not contain OBSCENITY.\r\n"
                "It does not create a CLEAR AND PRESENT DANGER.\r\n"
                "It does not contain speech that is a CRIME under the laws of California or of the United States of America.\r\n"
                "I also certify that it is not off-topic and will not otherwise DISRUPT the conversation, and that in making this determination I have not considered either viewpoint or words used.\r\n"
                "<p>\r\n"

            ) ;

            ZE( pbRefC* , prPosts ) ;
            etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            DEL( prPosts ) ;
        }
    }
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000101.talkAnonCbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000102.talkBodyCbf BEGIN
#define DDNAME       "3func.33000102.talkBodyCbf"
#define DDNUMB      (countT)0x33000102
#define IDFILE      (countT)0x9df


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT talkBodyCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    _IO_

    //etThread.traceF( tinP , T("talkBodyCBF / 7") ) ; //U:: TO FIND A BUG
    //etThread.traceF( tinP , T("[psttNameP]:    ")+T(psttNameP) ) ;
    //if( psttKVReportP && psttKVReportP->idAdam ) etThread.traceF( tinP , T("body received query: ")+T(psttKVReportP) ) ;

    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

    /***************************************************************************************************/
    /***************************************************************************************************/
    /***************************************************************************************************/
    /****                                                                                           ****/
    /****  RECEIVE QUERY PARAMETERS                                                                 ****/
    /****                                                                                           ****/
    /***************************************************************************************************/
    /***************************************************************************************************/
    /***************************************************************************************************/

    TN( tDot , "." ) ;
    TN( tKeySubscriberId        , "subscriberid"       ) ;
    TN( tKeySecret              , "secret"             ) ;
    TN( tKeySelectTopicShort    , "filenametopic"      ) ;
    TN( tKeyDadSecretIsOk       , "secretisok"         ) ;

    TN( tValueSubscriberId        , "" ) ;
    TN( tValueSecret              , "" ) ;
    TN( tValueSelectTopicShort    , "" ) ;
    TN( tValueDadSecretIsOk       , "" ) ;

    textC* pptKey[] =
    {
        &tKeySubscriberId        ,
        &tKeySecret              ,
        &tKeySelectTopicShort    ,
        &tKeyDadSecretIsOk       ,
    } ;

    textC* pptValue[] =
    {
        &tValueSubscriberId        ,
        &tValueSecret              ,
        &tValueSelectTopicShort    ,
        &tValueDadSecretIsOk       ,
    } ;

    countT cFlavors = swKVP.cFlavorsF( tinP ) ;
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    {
        psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;

        //{
        //    ZE( pbRefC* , prPosts ) ;
        //
        //    TN( tSay , "" ) ; tSay = T("<p>\r\n")+T(psttLeverKVP)+T(":    ")+T((strokeS*)(countT)swKVP) ;
        //    etThread.traceF( tinP , tSay ) ;
        //
        //    etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        //    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        //    DEL( prPosts ) ;
        //}

        for( countT offk = 0 ; offk < sizeof pptKey / sizeof pptKey[ 0 ] ; offk ++ )
        {
            if( !etThread.strCompareF( tinP , psttLeverKVP , *pptKey[ offk ] ) ) *pptValue[ offk ] = T((strokeS*)(countT)swKVP) ;
        }
    }

    boolT bDadSecretIsOk = !etThread.strCompareF( tinP , tValueDadSecretIsOk , T("yes") ) ;

    count04T subscriberIdTry = etThread.strDigitsToSCountF( tinP , tValueSubscriberId , 0x3e ) ; //U:: THIS WILL ONLY WORK IF THE ID IS <= MAXCOUNTT
    countT   secretTry       = etThread.strDigitsToSCountF( tinP , tValueSecret       , 0x3e ) ;

    //etThread.traceF( tinP , T("talkBodyCBF / 6") ) ; //U:: TO FIND A BUG
    ZE( boolT , bSecretIsOK ) ;
    TN( tLoginNnPeer             , "" ) ;
    TN( tLoginPaypalPayerEmail   , "" ) ;
    TN( tLoginZipUse             , "" ) ;
    TN( tLoginIdSubscriber0      , "" ) ;
    TN( tLoginFirstName          , "" ) ;
    TN( tLoginLastName           , "" ) ;
    TN( tLoginAddressName        , "" ) ;
    TN( tLoginAddressStreet      , "" ) ;
    TN( tLoginAddressCity        , "" ) ;
    TN( tLoginAddressState       , "" ) ;
    TN( tLoginAddressCountryCode , "" ) ;
    TN( tLoginAddressCountry     , "" ) ;
    TN( tLoginAddressZip         , "" ) ;
    TN( tLoginAddressStatus      , "" ) ;
    if( subscriberIdTry && secretTry )
    {
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****  VALIDATE THE ID AND SECRET                                                               ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        //VALIDATE THE SECRET

        TlIST( tListPath ) ;
        {
            TN( tSuffix , "d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/subscriptions/" ) ;
            TlISTlOAD( tListPath , meP.tListFactoryF() , tSuffix ) ;
        }

        strokeS* psttListPath = tListPath ;

        FORsTRINGSiN1( psttListPath )
        {
            IFsCRATCH
            {
                SCOOPS

                TN( tPath , psttc1 ) ;
                TN( tPattern , "subscription.table.live.*" ) ;
                patternC pat( tinP , *tinP.pEtScratch , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                do
                {
                    ZE( infoFileS* , pInfo ) ;
                    tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , tPath , &pat ) ;

                    if( POOP )
                    {
                        POOPR
                        etThread.traceF( tinP , T("disk or file error 842") ) ;
                    }
                    else if( !pInfo || !pInfo->psttIfoName )
                    {
                        DEL( pInfo ) ;
                        break ;
                    }
                    else
                    {
                        fileNameC fn( tinP , *tinP.pEtScratch , pInfo->psttIfoName ) ;
                        //etThread.traceF( tinP , T("found 1:    ")+T(fn) ) ;

                        {
                            soulC rec( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                            tinP.pEtScratch->boxGetShadowF( tinP , rec , pInfo->psttIfoName ) ;

                            if( POOP )
                            {
                                POOPR
                                etThread.traceF( tinP , T("disk or file error 1032") ) ;
                            }
                            else
                            {
                                ZE( countT , finger ) ;
                                rec >> finger ;

                                ZE( countT , idFormat ) ;
                                rec >> idFormat ;

                                ZE( countT , timeS1 ) ;
                                rec >> timeS1 ;

                                ZE( sCountT , timeS2 ) ;
                                rec >> *(countT*)&timeS2 ;

                                ZE( strokeS* , psttAction ) ;
                                rec >> psttAction ; ___( psttAction ) ;
                                etThread.delF( tinP , psttAction ) ;

                                ZE( strokeS* , psttNnPeer ) ;
                                rec >> psttNnPeer ; ___( psttNnPeer ) ;
                                tLoginNnPeer = T(psttNnPeer) ;
                                etThread.delF( tinP , psttNnPeer ) ;

                                ZE( strokeS* , psttValuePaypalPayerEmail ) ;
                                rec >> psttValuePaypalPayerEmail ; ___( psttValuePaypalPayerEmail ) ;
                                tLoginPaypalPayerEmail = T(psttValuePaypalPayerEmail) ;
                                etThread.delF( tinP , psttValuePaypalPayerEmail ) ;

                                ZE( strokeS* , psttZipUse ) ;
                                rec >> psttZipUse ; ___( psttZipUse ) ;
                                tLoginZipUse = T(psttZipUse) ;
                                etThread.delF( tinP , psttZipUse ) ;

                                ZE( strokeS* , psttValueRewardBoxHidden ) ;
                                rec >> psttValueRewardBoxHidden ; ___( psttValueRewardBoxHidden ) ;
                                etThread.delF( tinP , psttValueRewardBoxHidden ) ;

                                ZE( strokeS* , psttValueRewardBox ) ;
                                rec >> psttValueRewardBox ; ___( psttValueRewardBox ) ;
                                etThread.delF( tinP , psttValueRewardBox ) ;

                                ZE( strokeS* , psttValueTransType ) ;
                                rec >> psttValueTransType ; ___( psttValueTransType ) ;
                                etThread.delF( tinP , psttValueTransType ) ;

                                ZE( strokeS* , psttValueTransId ) ;
                                rec >> psttValueTransId ; ___( psttValueTransId ) ;
                                etThread.delF( tinP , psttValueTransId ) ;

                                ZE( count04T , idSubscriber ) ;
                                rec >> ((countT*)&idSubscriber)[ 0 ] ;
                                rec >> ((countT*)&idSubscriber)[ 1 ] ;
                                tLoginIdSubscriber0 = TF4(((countT*)&idSubscriber)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e) ;

                                //etThread.traceF( tinP , T("[tLoginIdSubscriber0]:    ")+tLoginIdSubscriber0 ) ;

                                ZE( countT , secret ) ;
                                rec >> secret ;

                                if( subscriberIdTry == idSubscriber )
                                {
                                    bSecretIsOK = secretTry == secret ;                 //U::DO THIS ONLY IF THIS RECORD IS NOT AN "UNSUBSCRIBE"
                                    //etThread.traceF( tinP , T(bSecretIsOK?"secret is OK":"secret is NOT ok") ) ;
                                }

                                ZE( strokeS* , psttValueFirstName ) ;
                                rec >> psttValueFirstName ; ___( psttValueFirstName ) ;
                                tLoginFirstName = T(psttValueFirstName) ;
                                etThread.delF( tinP , psttValueFirstName ) ;

                                ZE( strokeS* , psttValueLastName ) ;
                                rec >> psttValueLastName ; ___( psttValueLastName ) ;
                                tLoginLastName = T(psttValueLastName) ;
                                etThread.delF( tinP , psttValueLastName ) ;

                                ZE( strokeS* , psttValueAddressName ) ;
                                rec >> psttValueAddressName ; ___( psttValueAddressName ) ;

                                tLoginAddressName = T(psttValueAddressName) ;
                                etThread.delF( tinP , psttValueAddressName ) ;

                                ZE( strokeS* , psttValueAddressStreet ) ;
                                rec >> psttValueAddressStreet ; ___( psttValueAddressStreet ) ;
                                tLoginAddressStreet = T(psttValueAddressStreet) ;
                                etThread.delF( tinP , psttValueAddressStreet ) ;

                                ZE( strokeS* , psttValueAddressCity ) ;
                                rec >> psttValueAddressCity ; ___( psttValueAddressCity ) ;
                                tLoginAddressCity = T(psttValueAddressCity) ;
                                etThread.delF( tinP , psttValueAddressCity ) ;

                                ZE( strokeS* , psttValueAddressState ) ;
                                rec >> psttValueAddressState ; ___( psttValueAddressState ) ;
                                tLoginAddressState = T(psttValueAddressState) ;
                                etThread.delF( tinP , psttValueAddressState ) ;

                                ZE( strokeS* , psttValueAddressCountryCode ) ;
                                rec >> psttValueAddressCountryCode ; ___( psttValueAddressCountryCode ) ;
                                tLoginAddressCountryCode = T(psttValueAddressCountryCode) ;
                                etThread.delF( tinP , psttValueAddressCountryCode ) ;

                                ZE( strokeS* , psttValueAddressCountry ) ;
                                rec >> psttValueAddressCountry ; ___( psttValueAddressCountry ) ;
                                tLoginAddressCountry = T(psttValueAddressCountry) ;
                                etThread.delF( tinP , psttValueAddressCountry ) ;

                                ZE( strokeS* , psttValueAddressZip ) ;
                                rec >> psttValueAddressZip ; ___( psttValueAddressZip ) ;
                                tLoginAddressZip = T(psttValueAddressZip) ;
                                etThread.delF( tinP , psttValueAddressZip ) ;

                                ZE( strokeS* , psttValueAddressStatus ) ;
                                rec >> psttValueAddressStatus ; ___( psttValueAddressStatus ) ;
                                tLoginAddressStatus = T(psttValueAddressStatus) ;
                                etThread.delF( tinP , psttValueAddressStatus ) ;
                            }
                        }

                        if( POOP )
                        {
                            POOPR
                            etThread.traceF( tinP , T("disk or file error 918") ) ;
                        }
                    }
                    DEL( pInfo ) ;
                }
                while( !bSecretIsOK && ~hFind && !POOP ) ;
            }
        }
    }

    //etThread.traceF( tinP , T("talkBodyCBF / 5") ) ; //U:: TO FIND A BUG
    if( tValueSelectTopicShort.csF( tinP ) )
    {
        TlIST( tListSelectTopicLong ) ;
        {
            TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/ptopic/")+tValueSelectTopicShort ;
            TlISTlOAD( tListSelectTopicLong , meP.tListFactoryF() , tSuffix ) ;
        }

        TN( tNewTopic , "" ) ;
        IFsCRATCH
        {
            SCOOPS

            {
                soulC rec( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                tinP.pEtScratch->boxGetF( tinP , rec , tListSelectTopicLong , 1 , 1 ) ;
                if( POOP )
                {
                    POOPR
                    etThread.traceF( tinP , T("disk or file error 699") ) ;
                }
                else
                {
                    ZE( countT , finger ) ;
                    rec >> finger ;

                    ZE( countT , idFormat ) ;
                    rec >> idFormat ;

                    ZE( countT , timeS1 ) ;
                    rec >> timeS1 ;

                    ZE( sCountT , timeS2 ) ;
                    rec >> *(countT*)&timeS2 ;

                    ZE( strokeS* , psttTimeForeign ) ;
                    rec >> psttTimeForeign ; ___( psttTimeForeign ) ;
                    etThread.delF( tinP , psttTimeForeign ) ;

                    if( idFormat >= 4 )
                    {
                        ZE( strokeS* , psttFlags ) ;
                        rec >> psttFlags ; ___( psttFlags ) ;
                        etThread.delF( tinP , psttFlags ) ;
                    }

                    ZE( strokeS* , psttValueTopic ) ;
                    rec >> psttValueTopic ; ___( psttValueTopic ) ;
                    etThread.delF( tinP , psttValueTopic ) ;

                    ZE( strokeS* , psttTopicClean ) ;
                    rec >> psttTopicClean ; ___( psttTopicClean ) ;
                    tNewTopic = T(psttTopicClean) ;
                    etThread.delF( tinP , psttTopicClean ) ;

                    ZE( strokeS* , psttSaidIdSubscriber0 ) ;
                    rec >> psttSaidIdSubscriber0 ; ___( psttSaidIdSubscriber0 ) ;
                    etThread.delF( tinP , psttSaidIdSubscriber0 ) ;

                    ZE( strokeS* , psttSaidPaypalPayerEmail ) ;
                    rec >> psttSaidPaypalPayerEmail ; ___( psttSaidPaypalPayerEmail ) ;
                    etThread.delF( tinP , psttSaidPaypalPayerEmail ) ;

                    ZE( strokeS* , psttSaidFirstName ) ;
                    rec >> psttSaidFirstName ; ___( psttSaidFirstName ) ;
                    etThread.delF( tinP , psttSaidFirstName ) ;

                    ZE( strokeS* , psttSaidLastName ) ;
                    rec >> psttSaidLastName ; ___( psttSaidLastName ) ;
                    etThread.delF( tinP , psttSaidLastName ) ;

                    ZE( strokeS* , psttSaidAddressName ) ;
                    rec >> psttSaidAddressName ; ___( psttSaidAddressName ) ;
                    etThread.delF( tinP , psttSaidAddressName ) ;

                    ZE( strokeS* , psttSaidZipUse ) ;
                    rec >> psttSaidZipUse ; ___( psttSaidZipUse ) ;
                    etThread.delF( tinP , psttSaidZipUse ) ;

                    ZE( strokeS* , psttSaidNnPeer ) ;
                    rec >> psttSaidNnPeer ; ___( psttSaidNnPeer ) ;
                    etThread.delF( tinP , psttSaidNnPeer ) ;

                    nicNameC nnPeer ;
                    rec >> nnPeer ;

                    ZE( strokeS* , psttSaidAddressStreet ) ;
                    rec >> psttSaidAddressStreet ; ___( psttSaidAddressStreet ) ;
                    etThread.delF( tinP , psttSaidAddressStreet ) ;

                    ZE( strokeS* , psttSaidCity ) ;
                    rec >> psttSaidCity ; ___( psttSaidCity ) ;
                    etThread.delF( tinP , psttSaidCity ) ;

                    ZE( strokeS* , psttSaidState ) ;
                    rec >> psttSaidState ; ___( psttSaidState ) ;
                    etThread.delF( tinP , psttSaidState ) ;

                    ZE( strokeS* , psttSaidCountryCode ) ;
                    rec >> psttSaidCountryCode ; ___( psttSaidCountryCode ) ;
                    etThread.delF( tinP , psttSaidCountryCode ) ;
                }

                if( POOP )
                {
                    POOPR
                    etThread.traceF( tinP , T("disk or file error 677") ) ;
                }
            }

            if( POOP )
            {
                POOPR
                etThread.traceF( tinP , T("disk or file error 803") ) ;
            }
        }

        //etThread.traceF( tinP , T("new topic:    ")+tNewTopic ) ;

        if( tNewTopic.csF( tinP ) )
        {
            ZE( countT , timeN1 ) ;
            ZE( sCountT , timeN2 ) ;
            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;

            textC tTimeForeign( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

            soulC newTopic( tinP , TAG( TAGiDnULL ) ) ;
            {
                ZE( countT , finger ) ;
                putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEnEWtOPICcERTIFIED ) ;

                newTopic << finger ;
                newTopic << (countT)1 ;             // IDfORMAT
                newTopic << timeN1 ;
                newTopic << (countT)timeN2 ;
                newTopic << (strokeS*)tTimeForeign ;
                newTopic << (strokeS*)tNewTopic ;
                newTopic << (strokeS*)tLoginIdSubscriber0 ;
                newTopic << (strokeS*)tLoginPaypalPayerEmail ;
                newTopic << (strokeS*)tLoginFirstName ;
                newTopic << (strokeS*)tLoginLastName ;
                newTopic << (strokeS*)tLoginAddressName ;
                newTopic << (strokeS*)tLoginZipUse ;
                newTopic << (strokeS*)tLoginNnPeer ;
                newTopic << (strokeS*)tLoginNnPeer ;
                newTopic << (strokeS*)tLoginAddressStreet ;
                newTopic << (strokeS*)tLoginAddressCity ;
                newTopic << (strokeS*)tLoginAddressState ;
                newTopic << (strokeS*)tLoginAddressCountryCode ;
                newTopic << (strokeS*)tLoginAddressCountry ;
                newTopic << (strokeS*)tLoginAddressZip ;
                newTopic << (strokeS*)tLoginAddressStatus ;
            }

            soulC said( tinP , TAG( TAGiDnULL ) ) ;
            {
                ZE( countT , finger ) ;
                putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEsAID ) ;

                TN( tFlags , "" ) ;
                said << finger ;
                said << (countT)4 ;             // IDfORMAT
                said << timeN1 ;
                said << (countT)timeN2 ;
                said << (strokeS*)tTimeForeign ;
                said << (strokeS*)tFlags ;                          // FORMAT 4
                said << (strokeS*)T("") ;
                said << (strokeS*)( T("topic: ")+tNewTopic ) ;
                said << (strokeS*)tLoginIdSubscriber0 ;
                said << (strokeS*)tLoginPaypalPayerEmail ;
                said << (strokeS*)tLoginFirstName ;
                said << (strokeS*)tLoginLastName ;
                said << (strokeS*)tLoginAddressName ;
                said << (strokeS*)tLoginZipUse ;
                said << (strokeS*)tLoginNnPeer ;
                said << nnPeerP ;                                   // FORMAT 2
                said << (strokeS*)tLoginAddressStreet ;
                said << (strokeS*)tLoginAddressCity ;
                said << (strokeS*)tLoginAddressState ;
                said << (strokeS*)tLoginAddressCountryCode ;
                said << (strokeS*)tLoginAddressCountry ;
                said << (strokeS*)tLoginAddressZip ;
                said << (strokeS*)tLoginAddressStatus ;
            }

            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            TN( tHost , "" ) ;
            {
                ZE( strokeS* , psttHost ) ;
                etThread.sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
                if( !psttHost ) etThread.traceF( tinP , T("error: reverse DNS lookup on myself failed 591") ) ;
                else            tHost = T(psttHost) ;
                etThread.delF( tinP , psttHost ) ;
                if( !tHost.csF( tinP ) ) tHost = T("factories") ;
            }

            ZE( boolT , bFail ) ;
            IFsCRATCH
            {
                SCOOPS

                TlIST( tList ) ;
                {
                    TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said/said.table")+T(bSandbox?".sandbox.@1@.":".live.@1@.")+T(nnPeerP)+tDot+TF4(((countT*)&subscriberIdTry)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+TF4(((countT*)&subscriberIdTry)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+tHost ;
                    TlISTlOAD( tList , meP.tListFactoryF() , tSuffix ) ;
                }

                ZE( strokeS* , psttFile ) ;
                tinP.pEtScratch->boxPutUniqueF( tinP , psttFile , tList , WS( said ) ) ; ___( psttFile ) ;

                if( POOP )
                {
                    POOPR
                    etThread.traceF( tinP , T("disk or file error 526") ) ;
                    bFail |= 1 ;
                }
                else
                {
                    //FORsTRINGSiN1( psttFile )
                    //{
                    //    //etThread.traceF( tinP , T("wrote   ")+T(psttFile) ) ;
                    //}
                }

                etThread.delF( tinP , psttFile ) ;
            }

            TN( tShort , "" ) ;
            IFsCRATCH
            {
                TlIST( tList ) ;
                {
                    TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/newTopic/newTopic")+T(bSandbox?".sandbox.@1@.":".live.@1@.")+T(nnPeerP)+tDot+TF4(((countT*)&subscriberIdTry)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+TF4(((countT*)&subscriberIdTry)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e)+tDot+tHost ;
                    TlISTlOAD( tList , meP.tListFactoryF() , tSuffix ) ;
                }

                ZE( strokeS* , psttFile ) ;
                tinP.pEtScratch->boxPutUniqueF( tinP , psttFile , tList , WS( newTopic ) ) ; ___( psttFile ) ;

                if( POOP )
                {
                    POOPR
                    etThread.traceF( tinP , T("disk or file error 517") ) ;
                    bFail |= 2 ;
                }
                else
                {
                    //FORsTRINGSiN1( psttFile )
                    //{
                    //    //etThread.traceF( tinP , T("wrote   ")+T(psttFile) ) ;
                    //}

                    ZE( strokeS* , psttnu ) ;
                    ZE( strokeS* , psttShort ) ;
                    etThread.strBisectF( tinP , psttnu , psttShort , psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                    tShort = T(psttShort) ;
                    etThread.delF( tinP , psttnu ) ;
                    etThread.delF( tinP , psttShort ) ;
                    etThread.delF( tinP , psttFile ) ;
                }
            }

            TN( tBody , "" ) ;
            if( bFail )
            {
                tBody = T(

                    "Subject: Wo'O's Table:  Oops!  I could not process your new topic on Wo'O's Table Talk.\r\n"
                    "\r\n"
                    "\r\n"

                ) ;
            }
            else
            {
                tBody = T(

                    "Subject: Wo'O's Table:  You just set this new topic on Wo'O's Table Talk.\r\n"
                    "\r\n"
                    "\r\n"

                ) ;
            }

            tBody += T("your selected new topic:\r\n\r\n")+tNewTopic+T("\r\n\r\n") ;
            tBody += T("\r\nreference:  ")+tShort+T("\r\n") ;
            tBody += T("time:  ")+tTimeForeign+T("\r\n") ;

            TN( tEmailSandboxMe , "ideafarmcity@gmail.com" ) ;
            textC& tToUse = bSandbox
                ? tEmailSandboxMe
                : tLoginPaypalPayerEmail
            ;

            etThread.boxPutF( tinP , T("smtp.mailgun.org[admin]/b42/smtp/")+tHost+T("@ideafarm.com/")+tToUse+T("//wo@ideafarm.com/ideafarm.factory.reports@gmail.com") , tBody ) ;

            THREADmODE1rESTORE
        }
    }

    //etThread.traceF( tinP , T("talkBodyCBF / 4") ) ; //U:: TO FIND A BUG
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW1bEFOREtITLE ) ;
    {
        TN( tSay , "Wo'O's Table (tm)\r\n" ) ;

        ZE( pbRefC* , prPosts ) ;
        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        DEL( prPosts ) ;
    }
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW2aFTERtITLE ) ;

    {
        TN( tSay , "<meta http-equiv=\"refresh\" content=\"2\"/>\r\n" ) ;

        ZE( pbRefC* , prPosts ) ;
        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        DEL( prPosts ) ;
    }

    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW3sCRIPTbEGIN ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW4sCRIPTeND ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW5hEADeND ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_BODYrAWbEGIN ) ;

    ZE( countT , timeN1 ) ;
    ZE( sCountT , timeN2 ) ;
    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;

    {
        TN( tHost , "" ) ;
        {
            ZE( strokeS* , psttHost ) ;
            etThread.sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
            if( !psttHost ) etThread.traceF( tinP , T("error: reverse DNS lookup on myself failed") ) ;
            else            tHost = T(psttHost) ;
            etThread.delF( tinP , psttHost ) ;
            if( !tHost.csF( tinP ) ) tHost = T("factories") ;
        }

        static countT idInLath ;
        countT idIn = 1 + incv02AM( idInLath ) ;
        TN( tb4 , "    " ) ;
        TN( tSuffix , "" ) ; tSuffix = tb4+tHost+tb4+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;   //U:: THIS IS FOR DEBUGGING ; REMOVE AFTER DEVELOPMENT

        textC tTimeForeign( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

        TN( tSay , "" ) ; tSay = tTimeForeign + tSuffix ;

        ZE( pbRefC* , prPosts ) ;
        etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        DEL( prPosts ) ;
    }

    TlIST( tListSaidPath ) ;
    {
        TN( tSuffix , "d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said/" ) ;
        TlISTlOAD( tListSaidPath , meP.tListFactoryF() , tSuffix ) ;
    }

    //etThread.traceF( tinP , T("talkBodyCBF / 3") ) ; //U:: TO FIND A BUG
    stackC stFileShortSaid( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKrEVERSE , ifcSTACKtYPE_PTR_strokeS , ifcIDgRABlAYER_7BASEmISC1 ) ;
    countT  timeA1 = MAXcOUNTT  ; // AGE OF THE YOUNGEST POST ; "A": "AGE"
    sCountT timeA2 = MAXscOUNTT ; // AGE OF THE YOUNGEST POST
    ZE( countT , cFiles ) ;
    IFsCRATCH
    {
        SCOOPS

        FORsTRINGSiN1( (strokeS*)tListSaidPath )
        {
            TN( tPattern , "" ) ; tPattern = T("said.table")+T(bSandbox?".sandbox.*":".live.*") ;
            patternC pat( tinP , *tinP.pEtScratch , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            do
            {
                ZE( infoFileS* , pInfo ) ;
                tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , psttc1 , &pat ) ;

                if( POOP )
                {
                    POOPRqUIET
                    //etThread.traceF( tinP , T("disk or file error 425") ) ;
                }
                else if( !pInfo || !pInfo->psttIfoName )
                {
                    DEL( pInfo ) ;
                    break ;
                }
                else
                {
                    cFiles ++ ;
                    countT  timeE1 = timeN1 ;
                    sCountT timeE2 = timeN2 ;
                    etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , pInfo->timeCreated1 , pInfo->timeCreated2 ) ;
                    //etThread.traceF( tinP , T("age: ")+TT(timeE1,timeE2) ) ;
                    if( timeA2 > timeE2 || timeA1 > timeE1 )
                    {
                        timeA1 = timeE1 ;
                        timeA2 = timeE2 ;
                    }

                    ZE( strokeS* , psttShort ) ;
                    {
                        ZE( strokeS* , psttnu ) ;
                        etThread.strBisectF( tinP , psttnu , psttShort , pInfo->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                        etThread.delF( tinP , psttnu ) ;
                    }

                    ZE( countT , ids ) ;
                    stFileShortSaid.sinkF( tinP , ids , psttShort , flSTACKsINK_UNIQUE ) ;
                    if( !ids ) etThread.delF( tinP , psttShort ) ;
                }
                DEL( pInfo ) ;
            }
            while( ~hFind && !POOP ) ;
        }
    }
    //etThread.traceF( tinP , T("age of youngest post: ")+TT(timeA1,timeA2) ) ;

    ZE( countT  , seconds ) ;
    ZE( countT  , minutes ) ;
    ZE( countT  , hours   ) ;
    ZE( countT  , days    ) ;
    ZE( countT  , months  ) ;
    ZE( sCountT , years   ) ;
    if( cFiles ) etThread.osTimeToOldTimeF( tinP , countTC() , seconds , minutes , hours , days , months , years , countTC() , timeA1 , timeA2 , flOStIMEfROMoLDtIME_OLDtIMEiSutc ) ;

    const countT minAllowed = 1 ; // 2 IN PRODUCTION
    if( cFiles && !years && !months && !days && !hours && minutes < minAllowed )
    {
        {
            countT allSeconds = seconds + minutes * 60 ;
            countT secondsRemaining = 60 * minAllowed - allSeconds ;

            TN( tSay , "" ) ; tSay = T(

                "<span id=\"topiccountdown\">: Topic is now <span id=\"currenttopic\" style=\"color:cyan\"></span> and will become unlocked in ")+TF4(secondsRemaining,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T(" seconds.</span>\r\n<p>\r\n"
                "<script>\r\n"
                    "document.getElementById( 'currenttopic' ).innerHTML = window.parent.document.getElementById( 'showtopic' ).innerHTML ;\r\n"
                "</script>\r\n"

            ) ;

            ZE( pbRefC* , prPosts ) ;
            etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            DEL( prPosts ) ;
        }

        //THIS IS A WORKAROUND TO UNDESIRABLE BROWSER BEHAVIOR, BUT IT MIGHT NOT BE REALLY NEEDED.  (SEE THE REQUEST QUERY STRING for /talk.body)
        //if( !tValueDadSecretIsOk.csF( tinP ) )  //CS:CODEsYNC: DUPLICATE 33000102 33000102
        //{
        //    TN( tSay , "" ) ; tSay = T(
        //
        //        "<p>\r\n"
        //        "<form action=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/talk.body\" id=\"fixit\" method=\"get\" name=\"fixit\">\r\n"
        //            "<input id=\"secretisok\" name=\"secretisok\" type=\"hidden\" value=\"yes\"/>\r\n"
        //            "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Please click.\"/>\r\n"
        //        "</form>\r\n"
        //        "<p>\r\n"
        //
        //    ) ;
        //
        //    ZE( pbRefC* , prPosts ) ;
        //    etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        //
        //    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        //    DEL( prPosts ) ;
        //}
    }
    else
    {
        {

            countT allSeconds = seconds + minutes * 60 ;
            countT secondsRemaining = 60 * minAllowed - allSeconds ;

            TN( tSay , "" ) ; tSay = T("<script> window.parent.document.getElementById( 'showtopic' ).innerHTML = 'Open!' ; </script>\r\n<p>\r\n") ;

            ZE( pbRefC* , prPosts ) ;
            etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            DEL( prPosts ) ;
        }

        IFsCRATCH
        {
            SCOOPS

            TN( tPattern , "" ) ; tPattern = T("newTopic")+T(bSandbox?".sandbox.*":".live.*") ;
            patternC pat( tinP , *tinP.pEtScratch , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

            TlIST( tListPath ) ;
            {
                TN( tSuffix , "d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/newTopic/" ) ;
                TlISTlOAD( tListPath , meP.tListFactoryF() , tSuffix ) ;
            }

            FORsTRINGSiN1( (strokeS*)tListPath )
            {
                handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                do
                {
                    ZE( infoFileS* , pInfo ) ;
                    tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , psttc1 , &pat ) ;

                    if( POOP )
                    {
                        POOPRqUIET
                        //etThread.traceF( tinP , T("disk or file error 337") ) ;
                    }
                    else if( !pInfo || !pInfo->psttIfoName )
                    {
                        DEL( pInfo ) ;
                        break ;
                    }
                    else
                    {
                        tinP.pEtScratch->diskFileOrDirDeleteF( tinP , pInfo->psttIfoName , flFILEoRdIRdELETE_null , 1 ) ;
                        if( POOP )
                        {
                            POOPRqUIET ;
                            //etThread.traceF( tinP , T("disk or file error 427") ) ;
                        }
                    }
                    DEL( pInfo ) ;
                }
                while( ~hFind && !POOP ) ;
            }
        }

        //THIS IS A WORKAROUND TO UNDESIRABLE BROWSER BEHAVIOR, BUT IT MIGHT NOT BE REALLY NEEDED.  (SEE THE REQUEST QUERY STRING for /talk.body)
        //if( !tValueDadSecretIsOk.csF( tinP ) )  //CS:CODEsYNC: DUPLICATE 33000102 33000102
        //{
        //    TN( tSay , "" ) ; tSay = T(
        //
        //        "<p>\r\n"
        //        "<form action=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/talk.body\" id=\"fixit\" method=\"get\" name=\"fixit\">\r\n"
        //            "<input id=\"secretisok\" name=\"secretisok\" type=\"hidden\" value=\"yes\"/>\r\n"
        //            "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Please click.\"/>\r\n"
        //        "</form>\r\n"
        //        "<p>\r\n"
        //
        //    ) ;
        //
        //    ZE( pbRefC* , prPosts ) ;
        //    etThread.strMakeF( tinP , LF , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        //
        //    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        //    DEL( prPosts ) ;
        //}

        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /****                                                                                           ****/
        /****  2:  DISPLAY FORM TO SELECT EACH PROPOSED TOPIC                                           ****/
        /****                                                                                           ****/
        /***************************************************************************************************/
        /***************************************************************************************************/
        /***************************************************************************************************/

        if( bDadSecretIsOk || bSecretIsOK /*&& !bTopicIsFresh*/ ) // bTopicIsFresh IS NOT SET (FOR SPEED, TO AVOID DISK READS), SO I CAN'T CHECK IT HERE
        {
            IFsCRATCH
            {
                SCOOPS

                TN( tPattern , "" ) ; tPattern = T("ptopic.table")+T(bSandbox?".sandbox.*":".live.*") ;
                patternC pat( tinP , *tinP.pEtScratch , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

                TlIST( tListPTopicPath ) ;
                {
                    TN( tSuffix , "d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/ptopic/" ) ;
                    TlISTlOAD( tListPTopicPath , meP.tListFactoryF() , tSuffix ) ;
                }

                stackC stFilePTopic( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKrEVERSE , ifcSTACKtYPE_PTR_strokeS , ifcIDgRABlAYER_7BASEmISC1 ) ;
                FORsTRINGSiN1( (strokeS*)tListPTopicPath )
                {
                    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                    do
                    {
                        ZE( infoFileS* , pInfo ) ;
                        tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , psttc1 , &pat ) ;

                        if( POOP )
                        {
                            POOPR
                            etThread.traceF( tinP , T("disk or file error 295") ) ;
                        }
                        else if( !pInfo || !pInfo->psttIfoName )
                        {
                            DEL( pInfo ) ;
                            break ;
                        }
                        else
                        {
                            ZE( strokeS* , psttShort ) ;
                            {
                                ZE( strokeS* , psttnu ) ;
                                etThread.strBisectF( tinP , psttnu , psttShort , pInfo->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                                etThread.delF( tinP , psttnu ) ;
                            }

                            ZE( countT , ids ) ;
                            stFilePTopic.sinkF( tinP , ids , psttShort , flSTACKsINK_UNIQUE ) ;
                            if( !ids ) etThread.delF( tinP , psttShort ) ;
                        }
                        DEL( pInfo ) ;
                    }
                    while( ~hFind && !POOP ) ;
                }

                TN( tb4 , "    " ) ;
                while( stFilePTopic )
                {
                    ZE( strokeS* , psttShort ) ;
                    stFilePTopic >> psttShort ;

                    TlIST( tListSelectTopicLong ) ;
                    {
                        TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/ptopic/")+T(psttShort) ;
                        TlISTlOAD( tListSelectTopicLong , meP.tListFactoryF() , tSuffix ) ;
                    }

                    TN( tPTopicTimeForeign , "" ) ;
                    TN( tPTopicTopic , "" ) ;
                    TN( tPTopicIdSubscriber0 , "" ) ;
                    TN( tPTopicFirstName , "" ) ;
                    TN( tPTopicLastName , "" ) ;
                    TN( tPTopicZipUse , "" ) ;
                    TN( tPTopicCity , "" ) ;
                    TN( tPTopicCountryCode , "" ) ;
                    TN( tPTopicFlags , "" ) ;
                    {
                        soulC said( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                        tinP.pEtScratch->boxGetShadowF( tinP , said , tListSelectTopicLong , 1 ) ;

                        if( POOP )
                        {
                            POOPR
                            etThread.traceF( tinP , T("disk or file error 315") ) ;
                        }
                        else
                        {
                            ZE( countT , finger ) ;
                            said >> finger ;

                            ZE( countT , idFormat ) ;
                            said >> idFormat ;

                            ZE( countT , timeS1 ) ;
                            said >> timeS1 ;

                            ZE( sCountT , timeS2 ) ;
                            said >> *(countT*)&timeS2 ;

                            ZE( strokeS* , psttTimeForeign ) ;
                            said >> psttTimeForeign ; ___( psttTimeForeign ) ;
                            tPTopicTimeForeign = T(psttTimeForeign) ;
                            etThread.delF( tinP , psttTimeForeign ) ;

                            if( idFormat >= 4 )
                            {
                                ZE( strokeS* , psttFlags ) ;
                                said >> psttFlags ; ___( psttFlags ) ;
                                tPTopicFlags = T(psttFlags) ;
                                etThread.delF( tinP , psttFlags ) ;
                            }

                            ZE( strokeS* , psttValueTopic ) ;
                            said >> psttValueTopic ; ___( psttValueTopic ) ;
                            etThread.delF( tinP , psttValueTopic ) ;

                            ZE( strokeS* , psttTopicClean ) ;
                            said >> psttTopicClean ; ___( psttTopicClean ) ;
                            tPTopicTopic = T(psttTopicClean) ;
                            etThread.delF( tinP , psttTopicClean ) ;

                            ZE( strokeS* , psttSaidIdSubscriber0 ) ;
                            said >> psttSaidIdSubscriber0 ; ___( psttSaidIdSubscriber0 ) ;
                            tPTopicIdSubscriber0 = T(psttSaidIdSubscriber0) ;
                            etThread.delF( tinP , psttSaidIdSubscriber0 ) ;

                            ZE( strokeS* , psttSaidPaypalPayerEmail ) ;
                            said >> psttSaidPaypalPayerEmail ; ___( psttSaidPaypalPayerEmail ) ;
                            etThread.delF( tinP , psttSaidPaypalPayerEmail ) ;

                            ZE( strokeS* , psttSaidFirstName ) ;
                            said >> psttSaidFirstName ; ___( psttSaidFirstName ) ;
                            tPTopicFirstName = T(psttSaidFirstName) ;
                            etThread.delF( tinP , psttSaidFirstName ) ;

                            ZE( strokeS* , psttSaidLastName ) ;
                            said >> psttSaidLastName ; ___( psttSaidLastName ) ;
                            tPTopicLastName = T(psttSaidLastName) ;
                            etThread.delF( tinP , psttSaidLastName ) ;

                            ZE( strokeS* , psttSaidAddressName ) ;
                            said >> psttSaidAddressName ; ___( psttSaidAddressName ) ;
                            etThread.delF( tinP , psttSaidAddressName ) ;

                            ZE( strokeS* , psttSaidZipUse ) ;
                            said >> psttSaidZipUse ; ___( psttSaidZipUse ) ;
                            tPTopicZipUse = T(psttSaidZipUse) ;
                            etThread.delF( tinP , psttSaidZipUse ) ;

                            ZE( strokeS* , psttSaidNnPeer ) ;
                            said >> psttSaidNnPeer ; ___( psttSaidNnPeer ) ;
                            etThread.delF( tinP , psttSaidNnPeer ) ;

                            nicNameC nnPeer ;
                            said >> nnPeer ;

                            ZE( strokeS* , psttSaidAddressStreet ) ;
                            said >> psttSaidAddressStreet ; ___( psttSaidAddressStreet ) ;
                            etThread.delF( tinP , psttSaidAddressStreet ) ;

                            ZE( strokeS* , psttSaidCity ) ;
                            said >> psttSaidCity ; ___( psttSaidCity ) ;
                            tPTopicCity = T(psttSaidCity) ;
                            etThread.delF( tinP , psttSaidCity ) ;

                            ZE( strokeS* , psttSaidState ) ;
                            said >> psttSaidState ; ___( psttSaidState ) ;
                            etThread.delF( tinP , psttSaidState ) ;

                            ZE( strokeS* , psttSaidCountryCode ) ;
                            said >> psttSaidCountryCode ; ___( psttSaidCountryCode ) ;
                            tPTopicCountryCode = T(psttSaidCountryCode) ;
                            etThread.delF( tinP , psttSaidCountryCode ) ;
                        }
                    }

                    if( POOP )
                    {
                        POOPR
                        etThread.traceF( tinP , T("disk or file error 227") ) ;
                    }

                    //TN( tOutFlags , "" ) ;
                    //if( !tinP.pEtScratch->strCompareF( tinP , tPTopicFlags , T("anonymous") ) ) tOutFlags = T(" (anonymous) ") ; // FOR FUTURE USE.  CURRENT CODE DOES NOT SUPPORT ANONYMOUS TOPIC PROPOSALS

                    TN( tOut , "" ) ; tOut = T(

                        "<p>\r\n"
                        "<table>\r\n"
                            "<tr>\r\n"
                                "<td valign=\"center\">\r\n"
                                    "<form action=\"https://")+T(bSandbox?postCRAFTWORKfACTORY".":"")+T("ideafarm.com/talk.body\" id=\"launchtopic\" method=\"get\" name=\"launchtopic\">\r\n"
                                        "<input id=\"filenametopic\" name=\"filenametopic\" type=\"hidden\" value=\"")+T(psttShort)+T("\"/>\r\n"
                                        "<input id=\"subscriberid\" name=\"subscriberid\" type=\"hidden\" value=\"\"/>\r\n"
                                        "<input id=\"secret\" name=\"secret\" type=\"hidden\" value=\"\"/>\r\n"
                                        "<input id=\"newtopic\" name=\"newtopic\" type=\"hidden\" value=\"")+tPTopicTopic+T("\"/>\r\n"
                                        "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Change Topic\" onclick=\" window.parent.document.getElementById( 'showtopic' ).innerHTML = '")+tPTopicTopic+T("' ; \"/>\r\n"
                                    "</form>\r\n"
                                    "<script>\r\n"
                                        "document.getElementById( 'subscriberid'   ).innerHTML = window.parent.document.getElementById( 'hiddensubscriberid' ).innerHTML ;\r\n"
                                        "document.getElementById( 'secret' ).innerHTML = window.parent.document.getElementById( 'hiddensecret' ).innerHTML ;\r\n"
                                    "</script>\r\n"
                                "</td>\r\n"
                                "<td>\r\n"
                                    )+tPTopicTopic+T(
                                "</td>\r\n"
                            "</tr>\r\n"
                        "</table>\r\n"

                    ) ;

                    ZE( pbRefC* , prPosts ) ;
                    etThread.strMakeF( tinP , LF , prPosts , T("<p>\r\n")+tOut+T("\r\n") , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
                    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
                    DEL( prPosts ) ;

                    etThread.delF( tinP , psttShort ) ;
                }

                if( POOP )
                {
                    POOPR
                    etThread.traceF( tinP , T("disk or file error 137") ) ;
                }
            }
        }
    }

    //etThread.traceF( tinP , T("talkBodyCBF / 2") ) ; //U:: TO FIND A BUG
    IFsCRATCH
    {
        SCOOPS

        TN( tb4 , "    " ) ;
        while( stFileShortSaid )
        {
            //etThread.traceF( tinP , T("talkBodyCBF / 2.4") ) ; //U:: TO FIND A BUG
            ZE( strokeS* , psttShort ) ;
            stFileShortSaid >> psttShort ;

            TlIST( tListSaidFile ) ;
            {
                TN( tSuffix , "" ) ; tSuffix = T("d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said/")+T(psttShort) ;
                TlISTlOAD( tListSaidFile , meP.tListFactoryF() , tSuffix ) ;
            }

            //etThread.traceF( tinP , T("talkBodyCBF / 2.3") ) ; //U:: TO FIND A BUG
            TN( tSaidTimeForeign , "" ) ;
            TN( tSaidSpeech , "" ) ;
            TN( tSaidIdSubscriber0 , "" ) ;
            TN( tSaidFirstName , "" ) ;
            TN( tSaidLastName , "" ) ;
            TN( tSaidZipUse , "" ) ;
            TN( tSaidCity , "" ) ;
            TN( tSaidCountryCode , "" ) ;
            TN( tSaidFlags , "" ) ;
            {
                //etThread.traceF( tinP , T("talkBodyCBF / 2.2") ) ; //U:: TO FIND A BUG
                soulC said( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                tinP.pEtScratch->boxGetShadowF( tinP , said , tListSaidFile , 1 ) ;

                if( POOP )
                {
                    POOPR
                    etThread.traceF( tinP , T("disk or file error 149") ) ;
                }
                else
                {
                    //etThread.traceF( tinP , T("talkBodyCBF / 2.1") ) ; //U:: TO FIND A BUG
                    ZE( countT , finger ) ;
                    said >> finger ;

                    ZE( countT , idFormat ) ;
                    said >> idFormat ;

                    ZE( countT , timeS1 ) ;
                    said >> timeS1 ;

                    ZE( sCountT , timeS2 ) ;
                    said >> *(countT*)&timeS2 ;

                    ZE( strokeS* , psttTimeForeign ) ;
                    said >> psttTimeForeign ; ___( psttTimeForeign ) ;
                    tSaidTimeForeign = T(psttTimeForeign) ;
                    etThread.delF( tinP , psttTimeForeign ) ;

                    if( idFormat >= 4 )
                    {
                        ZE( strokeS* , psttFlags ) ;
                        said >> psttFlags ; ___( psttFlags ) ;
                        tSaidFlags = T(psttFlags) ;
                        etThread.delF( tinP , psttFlags ) ;
                    }

                    ZE( strokeS* , psttValueSpeech ) ;
                    said >> psttValueSpeech ; ___( psttValueSpeech ) ;
                    etThread.delF( tinP , psttValueSpeech ) ;

                    ZE( strokeS* , psttSpeechClean ) ;
                    said >> psttSpeechClean ; ___( psttSpeechClean ) ;
                    tSaidSpeech = T(psttSpeechClean) ;
                    etThread.delF( tinP , psttSpeechClean ) ;

                    ZE( strokeS* , psttSaidIdSubscriber0 ) ;
                    said >> psttSaidIdSubscriber0 ; ___( psttSaidIdSubscriber0 ) ;
                    tSaidIdSubscriber0 = T(psttSaidIdSubscriber0) ;
                    etThread.delF( tinP , psttSaidIdSubscriber0 ) ;

                    ZE( strokeS* , psttSaidPaypalPayerEmail ) ;
                    said >> psttSaidPaypalPayerEmail ; ___( psttSaidPaypalPayerEmail ) ;
                    etThread.delF( tinP , psttSaidPaypalPayerEmail ) ;

                    ZE( strokeS* , psttSaidFirstName ) ;
                    said >> psttSaidFirstName ; ___( psttSaidFirstName ) ;
                    tSaidFirstName = T(psttSaidFirstName) ;
                    etThread.delF( tinP , psttSaidFirstName ) ;
                    //etThread.traceF( tinP , T("talkBodyCBF: tSaidFirstName: ")+tSaidFirstName ) ; //U::

                    ZE( strokeS* , psttSaidLastName ) ;
                    said >> psttSaidLastName ; ___( psttSaidLastName ) ;
                    tSaidLastName = T(psttSaidLastName) ;
                    etThread.delF( tinP , psttSaidLastName ) ;

                    ZE( strokeS* , psttSaidAddressName ) ;
                    said >> psttSaidAddressName ; ___( psttSaidAddressName ) ;
                    etThread.delF( tinP , psttSaidAddressName ) ;

                    ZE( strokeS* , psttSaidZipUse ) ;
                    said >> psttSaidZipUse ; ___( psttSaidZipUse ) ;
                    tSaidZipUse = T(psttSaidZipUse) ;
                    etThread.delF( tinP , psttSaidZipUse ) ;

                    ZE( strokeS* , psttSaidNnPeer ) ;
                    said >> psttSaidNnPeer ; ___( psttSaidNnPeer ) ;
                    etThread.delF( tinP , psttSaidNnPeer ) ;

                    nicNameC nnPeer ;
                    said >> nnPeer ;

                    ZE( strokeS* , psttSaidAddressStreet ) ;
                    said >> psttSaidAddressStreet ; ___( psttSaidAddressStreet ) ;
                    etThread.delF( tinP , psttSaidAddressStreet ) ;

                    ZE( strokeS* , psttSaidCity ) ;
                    said >> psttSaidCity ; ___( psttSaidCity ) ;
                    tSaidCity = T(psttSaidCity) ;
                    etThread.delF( tinP , psttSaidCity ) ;

                    ZE( strokeS* , psttSaidState ) ;
                    said >> psttSaidState ; ___( psttSaidState ) ;
                    etThread.delF( tinP , psttSaidState ) ;

                    ZE( strokeS* , psttSaidCountryCode ) ;
                    said >> psttSaidCountryCode ; ___( psttSaidCountryCode ) ;
                    tSaidCountryCode = T(psttSaidCountryCode) ;
                    etThread.delF( tinP , psttSaidCountryCode ) ;
                    //etThread.traceF( tinP , T("talkBodyCBF / 2.0") ) ; //U:: TO FIND A BUG
                }
            }

            if( POOP )
            {
                POOPR
                etThread.traceF( tinP , T("disk or file error 58") ) ;
            }

            TN( tOutFlags , "" ) ;
            if( !etThread.strCompareF( tinP , tSaidFlags , T("anonymous") ) ) tOutFlags = T(" (anonymous) ") ;

            TN( tOut , "" ) ; tOut = T("<span style=\"color:Cyan ; font-size: 0.5em ;\">")+tSaidTimeForeign+tb4+tSaidCountryCode+tb4+tSaidZipUse+tb4+tSaidCity+tb4+tSaidIdSubscriber0+tb4+tSaidFirstName+tb4+tSaidLastName+tOutFlags+T(": </span>")+tSaidSpeech ;

            ZE( pbRefC* , prPosts ) ;
            etThread.strMakeF( tinP , LF , prPosts , T("<p>\r\n")+tOut+T("\r\n") , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            DEL( prPosts ) ;

            etThread.delF( tinP , psttShort ) ;
        }

        if( POOP )
        {
            POOPR
            etThread.traceF( tinP , T("disk or file error 13") ) ;
        }
    }

    //etThread.traceF( tinP , T("talkBodyCBF / 1") ) ; //U:: TO FIND A BUG
    if( tValueSelectTopicShort.csF( tinP ) ) //DO THIS IFF AM RESPONDING TO A FORM (IT DOES NOT WORK WITH FIREFOX.  THE GOAL WAS TO PREVENT BROWSER FROM REPEATEDLY RESENDING THE QUERY, WHICH INTERFERES WITH CACHEING)
    {
        replyP.idSnipHttpPrefix   = ifcIDsNIPpREDEFINED_HTTPfAILmOVED            ;
        replyP.idSnipHttpLocation = ifcIDsNIPpREDEFINED_REDIRECTlOCATIONtALKbODY ;

        strokeS*& psttLeverUrl = meP.psttLeverUrlMapF() ;
        switchC&  swMapUrl     = meP.swMapUrlF() ;

        TN( tUrlOld , "" ) ; tUrlOld = T(psttNameP)+T("?")+T(psttQueryKVP) ;
        TN( tUrlNew , "" ) ; tUrlNew = T(psttNameP)+T("?secretisok=yes") ;

        swMapUrl.grabF( tinP , TAG( TAGiDnULL ) ) ;

        psttLeverUrl = tUrlOld ;
        strokeS*& psttUrlNew = *(strokeS**)&(countT&)swMapUrl ;
        etThread.delF( tinP , psttUrlNew ) ;
        etThread.strMakeF( tinP , LF , psttUrlNew , tUrlNew ) ; ___( psttUrlNew ) ;

        swMapUrl.ungrabF( tinP ) ;

        etThread.traceF( tinP , T("talkBodyCBF / updated swMapUrl [tUrlOld]:    ")+tUrlOld ) ;
        etThread.traceF( tinP , T("talkBodyCBF / updated swMapUrl [tUrlNew]:    ")+tUrlNew ) ;
    }
    //etThread.traceF( tinP , T("talkBodyCBF / 0") ) ; //U:: TO FIND A BUG
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000102.talkBodyCbf END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000103.noteFromSnailMailerCBF BEGIN
#define DDNAME       "3func.33000103.noteFromSnailMailerCBF"
#define DDNUMB      (countT)0x33000103
#define IDFILE      (countT)0x9e0


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/

/*1*/voidT noteFromSnailMailerCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/
{
    ZE( boolT , bValid ) ;
    ZE( boolT , bGot ) ;
    TN( tValidationRequest , "" ) ;
    TN( tValidationReply   , "" ) ;
    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

   //20200731@1556: CHANGED FROM HTTP/1.0 TO HTTP/1.1 WITHOUT ANALYSIS
    //OLD FORMAT: GET /cgi-bin/webscr?cmd=_notify-validate&mc_gross=1.00&protection_eligibility=Eligible&address_status=confirmed&payer_id=4QLHUR4EYW37J&address_street=1+Main+St&payment_date=17%3A04%3A06+Jun+04%2C+2020+PDT&payment_status=Completed&charset=windows-1252&address_zip=95131&first_name=John&mc_fee=0.33&address_country_code=US&address_name=John+Doe&notify_version=3.9&subscr_id=I-1CXF383WH8P0&payer_status=verified&business=sb-znjve1276155%40business.example.com&address_country=United+States&address_city=San+Jose&verify_sign=AEHpL6M1JS9Z4r02TsvVIey5ocFqAgLcANkEe9kVFcJG4kqTWCtTJprq&payer_email=sb-prtxq883780%40personal.example.com&txn_id=1XX85736SF014420R&payment_type=instant&btn_id=4125335&last_name=Doe&address_state=CA&receiver_email=sb-znjve1276155%40business.example.com&payment_fee=0.33&receiver_id=755UKLGFJ8XU2&txn_type=subscr_payment&item_name=Wo%27O%27s+Table+Registration+and+Subscription&mc_currency=USD&item_number=20200604&residence_country=US&test_ipn=1&transaction_subject=Wo%27O%27s+Table+Registration+and+Subscription&payment_gross=1.00&ipn_track_id=92fb2ec1f693b HTTP/1.1
    //THIS WORKS IN FIREFOX BROWSER: https://www.sandbox.paypal.com:443/cgi-bin/webscr?cmd=_notify-validate&mc_gross=1.00&protection_eligibility=Eligible&address_status=confirmed&payer_id=4QLHUR4EYW37J&address_street=1+Main+St&payment_date=15%3A55%3A04+Jun+04%2C+2020+PDT&payment_status=Completed&charset=windows-1252&address_zip=95131&first_name=John&mc_fee=0.33&address_country_code=US&address_name=John+Doe&notify_version=3.9&subscr_id=I-DEKU4NNTHS0H&payer_status=verified&business=sb-znjve1276155%40business.example.com&address_country=United+States&address_city=San+Jose&verify_sign=AS.sXmO3SZlbZsuBgmx57wrfjxyDAk855hu6vdRmhFRd0mqr2l3hMU7l&payer_email=sb-prtxq883780%40personal.example.com&txn_id=5W609239EF681420H&payment_type=instant&btn_id=4125335&last_name=Doe&address_state=CA&receiver_email=sb-znjve1276155%40business.example.com&payment_fee=0.33&receiver_id=755UKLGFJ8XU2&txn_type=subscr_payment&item_name=Wo'O's+Table+Registration+and+Subscription&mc_currency=USD&item_number=20200604&residence_country=US&test_ipn=1&transaction_subject=Wo'O's+Table+Registration+and+Subscription&payment_gross=1.00&ipn_track_id=5075e5b427054 HTTP/1.1

    LOGrAW( "\r\n---- postBodyP (BEGIN) -----------------------------------------------------------------\r\n" ) ;
    LOGrAW( postBodyP ) ;
    LOGrAW( "\r\n---- postBodyP (END) -----------------------------------------------------------------\r\n" ) ;

    {
        //U::COMMENT THIS OUT IN PRODUCTION AFTER CONFIDENT IN PROD FUNCTION
        LOGrAW( "\r\n---- tValidationRequest GOOD (BEGIN) -----------------------------------------------------------------\r\n" ) ;
        LOGrAW( tValidationRequest ) ;
        LOGrAW( "\r\n---- tValidationRequest GOOD (END) -----------------------------------------------------------------\r\n" ) ;
        LOGrAW( "\r\n---- tValidationReply GOOD (BEGIN) -----------------------------------------------------------------\r\n" ) ;
        LOGrAW( tValidationReply ) ;
        LOGrAW( "\r\n---- tValidationReply GOOD (END) -----------------------------------------------------------------\r\n" ) ;

        TN( tKeyAddressCity                     , "address_city"           ) ;
        TN( tKeyAddressCountry                  , "address_country"        ) ;
        TN( tKeyAddressCountryCode              , "address_country_code"   ) ;
        TN( tKeyAddressName                     , "address_name"           ) ;
        TN( tKeyAddressState                    , "address_state"          ) ;
        TN( tKeyAddressStatus                   , "address_status"         ) ;
        TN( tKeyAddressStreet                   , "address_street"         ) ;
        TN( tKeyAddressZip                      , "address_zip"            ) ;
        TN( tKeyCharset                         , "charset"                ) ;
        TN( tKeyFirstName                       , "first_name"             ) ;
        TN( tKeyLastName                        , "last_name"              ) ;
        TN( tKeyPaypalPayerEmail                , "payer_email"            ) ;
        TN( tKeyPaypalPayerId                   , "payer_id"               ) ;
        TN( tKeyPaypalPayerStatus               , "payer_status"           ) ;
        TN( tKeyPaypalProtectionEligibility     , "protection_eligibility" ) ;
        TN( tKeyResidenceCountry                , "residence_country"      ) ;

        TN( tKeyPaypalPaymentFee                , "payment_fee"            ) ;
        TN( tKeyPaypalPaymentGross              , "payment_gross"          ) ;
        TN( tKeyPaypalPaymentStatus             , "payment_status"         ) ;
        TN( tKeyPaypalCustom                    , "custom"                 ) ;
        TN( tKeyIdTest                          , "ifcidtest"              ) ;

        TN( tKeyRewardBoxHidden                 , "option_selection2"      ) ;
        TN( tKeyRewardBox                       , "option_selection1"      ) ;

        TN( tKeyTransType                       , "txn_type"               ) ;
        TN( tKeyTransId                         , "txn_id"                 ) ;
        TN( tKeyItemNumber                      , "item_number"            ) ;

        TN( tValueAddressCity                   , "" ) ;
        TN( tValueAddressCountry                , "" ) ;
        TN( tValueAddressCountryCode            , "" ) ;
        TN( tValueAddressName                   , "" ) ;
        TN( tValueAddressState                  , "" ) ;
        TN( tValueAddressStatus                 , "" ) ;
        TN( tValueAddressStreet                 , "" ) ;
        TN( tValueAddressZip                    , "" ) ;
        TN( tValueCharset                       , "" ) ;
        TN( tValueFirstName                     , "" ) ;
        TN( tValueLastName                      , "" ) ;
        TN( tValuePaypalPayerEmail              , "" ) ;
        TN( tValuePaypalPayerId                 , "" ) ;
        TN( tValuePaypalPayerStatus             , "" ) ;
        TN( tValuePaypalProtectionEligibility   , "" ) ;
        TN( tValueResidenceCountry              , "" ) ;

        TN( tValuePaypalPaymentFee              , "" ) ;
        TN( tValuePaypalPaymentGross            , "" ) ;
        TN( tValuePaypalPaymentStatus           , "" ) ;
        TN( tValuePaypalCustom                  , "" ) ;
        TN( tValueIdTest                        , "" ) ;

        TN( tValueRewardBoxHidden               , "" ) ;
        TN( tValueRewardBox                     , "" ) ;

        TN( tValueTransType                     , "" ) ;
        TN( tValueTransId                       , "" ) ;
        TN( tValueItemNumber                    , "" ) ;

        textC* pptKey[] =
        {
            //CS:CODEsYNC: 1d20005 1d20005 1d20005
            &tKeyAddressCity                    ,
            &tKeyAddressCountry                 ,
            &tKeyAddressCountryCode             ,
            &tKeyAddressName                    ,
            &tKeyAddressState                   ,
            &tKeyAddressStatus                  ,
            &tKeyAddressStreet                  ,
            &tKeyAddressZip                     ,
            &tKeyCharset                        ,
            &tKeyFirstName                      ,
            &tKeyLastName                       ,
            &tKeyPaypalPayerEmail               ,
            &tKeyPaypalPayerId                  ,
            &tKeyPaypalPayerStatus              ,
            &tKeyPaypalProtectionEligibility    ,
            &tKeyResidenceCountry               ,

            //CS:B
            &tKeyPaypalPaymentFee               ,
            &tKeyPaypalPaymentGross             ,
            &tKeyPaypalPaymentStatus            ,
            &tKeyPaypalCustom                   ,
            &tKeyIdTest                         ,

            &tKeyRewardBoxHidden                ,
            &tKeyRewardBox                      ,

            &tKeyTransType                      ,
            &tKeyTransId                        ,
            &tKeyItemNumber                     ,
        } ;

        textC* pptValue[] =
        {
            //CS:CODEsYNC: 1d20005 1d20005 1d20005
            &tValueAddressCity                   ,
            &tValueAddressCountry                ,
            &tValueAddressCountryCode            ,
            &tValueAddressName                   ,
            &tValueAddressState                  ,
            &tValueAddressStatus                 ,
            &tValueAddressStreet                 ,
            &tValueAddressZip                    ,
            &tValueCharset                       ,
            &tValueFirstName                     ,
            &tValueLastName                      ,
            &tValuePaypalPayerEmail              ,
            &tValuePaypalPayerId                 ,
            &tValuePaypalPayerStatus             ,
            &tValuePaypalProtectionEligibility   ,
            &tValueResidenceCountry              ,

            //CS:B
            &tValuePaypalPaymentFee              ,
            &tValuePaypalPaymentGross            ,
            &tValuePaypalPaymentStatus           ,
            &tValuePaypalCustom                  ,
            &tValueIdTest                        ,

            &tValueRewardBoxHidden               ,
            &tValueRewardBox                     ,

            &tValueTransType                     ,
            &tValueTransId                       ,
            &tValueItemNumber                    ,
        } ;

        countT cFlavors = swKVP.cFlavorsF( tinP ) ;
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;

            for( countT offk = 0 ; offk < sizeof pptKey / sizeof pptKey[ 0 ] ; offk ++ )
            {
                if( !etThread.strCompareF( tinP , psttLeverKVP , *pptKey[ offk ] ) ) *pptValue[ offk ] = T((strokeS*)(countT)swKVP) ;
            }
        }
    }

    LOGrAW3( "noteFromSnailMailerCBF [bValid]:    " , bValid , "\r\n" ) ;
    LOGrAW( "\r\n---- psttKVReportP (BEGIN) -----------------------------------------------------------------\r\n" ) ;
    LOGrAW( T(psttKVReportP) ) ;
    LOGrAW( "\r\n---- psttKVReportP (END) -----------------------------------------------------------------\r\n" ) ;
}


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000103.noteFromSnailMailerCBF END
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000104.tmchttpserverworkerf BEGIN
#define DDNAME       "3func.33000104.tmchttpserverworkerf"
#define DDNUMB      (countT)0x33000104
#define IDFILE      (countT)0x9e1


//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

/*
*/
/**/


/*1*/TASK( tmcHttpServerWorkerF )/*1*/
TELL( "preparing for work" ) ;

if( pTaskP && pTaskP->c1 )
{
    stackC& stJobP = *(stackC*)pTaskP->c1 ;

    while( !ether )
    {
        etThread.traceF( tinP , T("waiting for a push to stJobP"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
        stJobP.waitF( tinP ) ;
        etThread.traceF( tinP , T("waited for a push to stJobP"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
        stJobP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        etThread.traceF( tinP , T("grabbed stJobP"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

        if( !stJobP )
        {
            etThread.traceF( tinP , T("immediately ungrabbed stJobP because it is empty"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
            stJobP.ungrabF( tinP ) ;
        }
        else
        {
            //taskDrivenServerJobS jobCopy = *(taskDrivenServerJobS*)&(countT&)stJobP[ 1 ] ; //U:: TO FIND A BUG
            //etThread.traceF( tinP , T("tmcHttpServerWorkerF popping a job [jobCopy[2]]:    ")+TF2(((countT*)&jobCopy)[2],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            byteT _pbaJob[ sizeof( taskDrivenServerJobS ) ] ;
            byteT* pbJob = _pbaJob ;
            stJobP >> pbJob ;

            etThread.traceF( tinP , T("ungrabbed stJobP after popping a job"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
            stJobP.ungrabF( tinP ) ;

            if( !pbJob )
            {
                etThread.traceF( tinP , T("doing nothing sincd !pbJob"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
            }
            else
            {
                taskDrivenServerJobS& jobP = *(taskDrivenServerJobS*)_pbaJob ;

                etThread.osTimeNowF( tinP , jobP.timeJobPopped1 , jobP.timeJobPopped2 ) ;

                TESTsCRATCH ;
                TELL( "TASKdRIVENsERVER: setting up" )

                //etThread.traceF( tinP , T("U:: tmcHttpServerWorkerF / before grabbing") ) ;
                //tinP.pc Utility[ 0 ] = 0x12345678 ;
                //tinP.pc Utility[ 2 ] = ((countT*)&jobP)[ 2 ] ;
                //tinP.pc Utility[ 3 ] = ((countT*)&jobCopy)[ 2 ] ;

                etThread.traceF( tinP , T("grabbing jobP.sw_pso"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                jobP.sw_pso.grabF( tinP , TAG( TAGiDnULL ) ) ;
                etThread.traceF( tinP , T("grabbed jobP.sw_pso"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                //tinP.pc Utility[ 3 ] = 0 ;
                //tinP.pc Utility[ 2 ] = 0 ;
                //tinP.pc Utility[ 1 ] = 0 ;
                //tinP.pc Utility[ 0 ] = 0 ;

                jobP.lever_idSession = jobP.idSession ;
                socketC*& psoP = (socketC*&)(countT&)jobP.sw_pso ;
                jobP.sw_pso.ungrabF( tinP ) ;

                //etThread.traceF( tinP , T("U:: tmcHttpServerWorkerF / after ungrab") ) ;
                __Z( psoP ) ;

                sessionC& sessionP = jobP.sessions.registerConnectionF( tinP , jobP.nnPeer , /*psttPeerP*/T("notQueried") ) ;
                if( etThread ) { BLAMMO ; }
                else
                {
                    etThread.traceF( tinP , T("preparing to service psoP"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    //etThread.traceF( tinP , T("TASKdRIVENsERVER [cSession]:    ")+TF2(jobP.cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    psoP->etherF( tinP , *tinP.pEtScratch ) ;

                    ZE( countT , idPortMeP ) ;
                    nicNameC nnMeP ;
                    IFsCRATCH
                    {
                        SCOOPS
                        psoP->myNameF( tinP , idPortMeP , nnMeP ) ;
                        if( POOP ) { POOPR ; }

                        /* THIS IS TOO SLOW (2 TOCKS)                                             */
                        /* ZE( strokeS* , psttPeerP ) ;                                           */
                        /* {                                                                      */
                        /*     if( nnPeerP.pcId[ 0 ] )                                            */
                        /*     {                                                                  */
                        /*         TELL( "querying dns for peer name string" ) ;                  */
                        /*         tinP.pEtScratch->sockPsttHostF( tinP , psttPeerP , nnPeerP ) ; */
                        /*         TELL( "returned from querying dns for peer name string" ) ;    */
                        /*     }                                                                  */
                        /*     if( POOP ) { POOPR }                                               */
                        /* }                                                                      */
                    }

                    TELL( "TASK: entering application code" )

                    {
                        _IO_

                        etThread.osTimeNowF( tinP , jobP.timeDoJob1 , jobP.timeDoJob2 ) ;
                        {
                            _IO_
                            etThread.traceF( tinP , T("calling etherDoHttpJobF"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                            etThread.etherDoHttpJobF( tinP , jobP , psoP , sessionP , idPortMeP , nnMeP ) ;
                            etThread.traceF( tinP , T("called etherDoHttpJobF"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        }

                        {
                            _IO_
                            jobP.sw_pso.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        }
                        {
                            _IO_
                            DEL( psoP ) ;
                        }
                        {
                            _IO_
                            jobP.lever_idSession = jobP.idSession ;
                        }
                        {
                            _IO_
                            if( (countT)&psoP == (countT)&(countT&)jobP.sw_pso ) jobP.sw_pso.freeF( tinP ) ;
                            else                                                 __1
                        }
                        jobP.sw_pso.ungrabF( tinP ) ;
                    }

                    etThread.traceF( tinP , T("decrementing cSession"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    jobP.sessions.unregisterConnectionF( tinP , jobP.nnPeer ) ;
                    jobP.sw_cSessionWithPeer.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    jobP.lever_nnPeer = jobP.nnPeer ;
                    -- jobP.sw_cSessionWithPeer ;
                    jobP.sw_cSessionWithPeer.ungrabF( tinP ) ;
                    etThread.traceF( tinP , T("decremented cSession"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                    /*etThread.delF( tinP , psttPeerP ) ;*/

                    //etThread.traceF( tinP , T("DONE [cSession]:    ")+TF2(jobP.cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    taskDrivenServerJobS* pDoomed = &jobP ;
                    dec02AM( jobP.cSession ) ;
                    DELzOMBIE( pDoomed ) ;
                }
            }
        }
    }
}

DONE( tmcHttpServerWorkerF )


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

#undef IDFILE
#undef DDNUMB
#undef DDNAME
//SOURCE: \ideafarm.home.1\precious\domains\com\ideafarm\city\library\dictionary\3func.33000* : 3func.33000104.tmchttpserverworkerf END
