
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    UNGRABrELAYlISTS

    }
        }
            case IDtYPErELAYpOPcLIENTwORK_EXPLODE1 : { idPortTimeC nt ; idptSelectPeerIF( tinP , nt , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_IMPLODE  , flSELECTpEER_DUPLICATEiSoK ) ; if( idptPeerP == nt ) idptPeerP = 0 ; }
            case IDtYPErELAYpOPcLIENTwORK_EXPLODE2 : { idPortTimeC nt ; idptSelectPeerIF( tinP , nt , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_EXPLODE1 , flSELECTpEER_DUPLICATEiSoK ) ; if( idptPeerP == nt ) idptPeerP = 0 ; }
            case IDtYPErELAYpOPcLIENTwORK_LEFT     : { idPortTimeC nt ; idptSelectPeerIF( tinP , nt , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_EXPLODE2 , flSELECTpEER_DUPLICATEiSoK ) ; if( idptPeerP == nt ) idptPeerP = 0 ; }
            case IDtYPErELAYpOPcLIENTwORK_RIGHT    : { idPortTimeC nt ; idptSelectPeerIF( tinP , nt , stIdptOpenP , idptP , stIdptGossipP , IDtYPErELAYpOPcLIENTwORK_LEFT     , flSELECTpEER_DUPLICATEiSoK ) ; if( idptPeerP == nt ) idptPeerP = 0 ; }
        {
        switch( idMyWorkP ) // idptP IS SET IFF A DISTINCT RELAY EXISTS
    {
    if( !( F(flagsP) & flSELECTpEER_DUPLICATEiSoK ) )

    }
        }
            case  IDtYPErELAYpOPcLIENTwORK_RIGHT    : {                                    idptPeerP = cRelays > 1 ? *(idPortTimeC*)&stIdptOpenP[ ideMe < cRelays ? ideMe + 1 : 1       ] : idptNull ; break ; }
            case  IDtYPErELAYpOPcLIENTwORK_LEFT     : {                                    idptPeerP = cRelays > 1 ? *(idPortTimeC*)&stIdptOpenP[ ideMe > 1       ? ideMe - 1 : cRelays ] : idptNull ; break ; }
            case  IDtYPErELAYpOPcLIENTwORK_EXPLODE2 : { if( stIdptOpenP >= ideMe * 2 + 1 ) idptPeerP =               *(idPortTimeC*)&stIdptOpenP[ ideMe * 2 + 1                         ]            ; break ; }
            case  IDtYPErELAYpOPcLIENTwORK_EXPLODE1 : { if( stIdptOpenP >= ideMe * 2     ) idptPeerP =               *(idPortTimeC*)&stIdptOpenP[ ideMe * 2                             ]            ; break ; }
            case  IDtYPErELAYpOPcLIENTwORK_IMPLODE  : { if(           1 != ideMe         ) idptPeerP =               *(idPortTimeC*)&stIdptOpenP[ ideMe / 2                             ]            ; break ; }
        {
        switch( idMyWorkP ) // idptP IS SET IFF A DISTINCT RELAY EXISTS
        idPortTimeC idptNull ;
    {
    if( ideMe )

    }
        if( !bFound ) ideMe = 0 ;
        UNGRABrELAYlISTS
        }
            while( !stIdptOpenP.third && ~hDown ) ;
            }
                }
                    break ;
                    bFound = 1 ;
                {
                if( idpt == idptP ) //THIS LOOKS AT idPort; SINK LOOKS AT TIME
                idPortTimeC& idpt = *(idPortTimeC*)&stIdptOpenP.downF( tinP , hDown ) ;
                ideMe ++ ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( stIdptOpenP )
        GRABrELAYlISTS
        ZE( boolT , bFound ) ;
    {
    if( !ideMe ) //WILL BE TRUE IF I HAVE JUST RESTAMPED MYSELF

    }
        }
            while( !stIdptOpenP.third && ~hDown ) ;
            }
                tinP.pEther->traceF( tinP , T("idptSelectPeerIF: open [idPlate,idpt]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((nicNameC&)idpt)+T(" ( ")+TF2((countT)idpt,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ; //U:: TO FIND A BUG
                idPortTimeC& idpt = *(idPortTimeC*)&stIdptOpenP.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , idPlate ) ;
        {
        if( stIdptOpenP )

        tinP.pEther->traceF( tinP , T("idptSelectPeerIF: open list [cRelays,ideMe]:    ")+TF2(cRelays,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(ideMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG
    {
    if( F(flagsP) & flSELECTpEER_TRACE )

    }
        }
            while( !stIdptGossipP.third && ~hDown ) ;
            }
                tinP.pEther->traceF( tinP , T("idptSelectPeerIF: gossip [idPlate,idpt]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((nicNameC&)idpt)+T(" ( ")+TF2((countT)idpt,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ; //U:: TO FIND A BUG
                idPortTimeC& idpt = *(idPortTimeC*)&stIdptGossipP.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , idPlate ) ;
        {
        if( stIdptGossipP )

        tinP.pEther->traceF( tinP , T("idptSelectPeerIF: gossip list") ) ; //U:: TO FIND A BUG
    {
    if( F(flagsP) & flSELECTpEER_TRACE )

    countT ideMe = stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
    countT cRelays = stIdptOpenP ;

    GRABrELAYlISTS

    if( stIdptOpenP.third ) { BLAMMO ; }
    if( idptPeerP ) { BLAMMO ; }
    _IO_     TLNA( "idptSelectPeerIF" )

    }
        if( POOP ) return ;
        //FV( flSELECTpEER , flagsP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT relayC::idptSelectPeerIF( tinS& tinP , idPortTimeC& idptPeerP , stackC& stIdptOpenP , idPortTimeC& idptP , stackC& stIdptGossipP , const countT idMyWorkP , const flagsT flagsP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

