
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        }
            c_strcpyIF( tinP , postP , ostot ) ;

            if( info.symACHnAME ) OStEXTA( ostot , info.symACHnAME )
            OStEXTAL( ostot , postLikeP , costPrefix )
            OStEXT( ostot , 0x200 )

            countT costPrefix = postEnd - postLikeP + 1 ;
            postEnd = c_strrchrIF( tinP , postLikeP , '\\' ) ;
            ZE( osTextT* , postEnd ) ;
        {
        if( !POOP && fFound )

        }
            #endif

                }
                    else                                                                                                                      { BOSpOOP ; }
                    if( tinP.brcLath == ERROR_FILE_NOT_FOUND || tinP.brcLath == ERROR_PATH_NOT_FOUND || tinP.brcLath == ERROR_NO_MORE_FILES ) tinP.bosFail = 0 ;

                    tinP.brcLath = save_brcLath ;
                    tinP.bosFail = save_bosFail ;
                    handleP.closeIfF() ;
                    countT save_brcLath = tinP.brcLath ;
                    countT save_bosFail = tinP.bosFail ;
                    fFound = 0 ;
                {
                if( tinP.bosFail )

                }
                    fFound = !tinP.bosFail ;
                    BOS( WHATsfr , BOSoK , FindNextFile( (HANDLE)pOsh->hFind.osF( ifcIDtYPEhANDLE_FILEfINDbASE ) , &info ) )
                {
                else
                }
                    if( ~pOsh->hFind ) fFound = 1 ;
                    pOsh->hFind.osF( ifcIDtYPEhANDLE_FILEfINDbASE , (countT)tinP.brcRaw ) ;
                    BOS( WHATsfr , BOShANDLE , FindFirstFile( postLikeP , &info ) )
                {
                if( bWoth )
                //CS:CODEsYNCH: DUPLICATE CODE 3600101d 35001186

            #elif defined( __NT__ )
            #ifdef __OS2__
        {

        c_memsetIF( tinP , (byteT*)&info , sizeof info ) ;
        #endif
            WIN32_FIND_DATA info ;
        #elif defined( __NT__ )
        #ifdef __OS2__
        ZE( boolT , fFound ) ;
    {
    else
    }
        }
            c_strcpyIF( tinP , postP , ostot ) ;

            if( posti ) OStEXTA( ostot , posti )
            OStEXTAL( ostot , postLikeP , costPrefix )
            OStEXT( ostot , 0x200 )

            countT costPrefix = postEnd - postLikeP + 1 ;
            postEnd = c_strrchrIF( tinP , postLikeP , '\\' ) ;
            ZE( osTextT* , postEnd ) ;

            posti[ costi ] = 0 ;
            countT rc = thirdC::s_readIF( tinP , posti , costi , pOsh->hSockCloak ) ;
            osTextT* posti = processGlobal3I.heap.newF( tinP , LF , costi + 1 ) ;
        {
        else
        if( !costi || costi > TUCK << 2 ) handleP.closeIfF() ;

        countT rc = thirdC::s_readIF( tinP , (byteT*)&costi , sizeof costi , pOsh->hSockCloak ) ;
        ZE( countT , costi ) ;
    {
    if( bCloaked )

    }
        }
            thirdC::s_writeIF( tinP , pOsh->hSockCloak , postLikeP , costLike ) ;
            thirdC::s_writeIF( tinP , pOsh->hSockCloak , (byteT*)&costLike , sizeof costLike ) ;
            countT costLike = thirdC::c_strlenIF( tinP , postLikeP ) ;

            thirdC::s_writeIF( tinP , pOsh->hSockCloak , (byteT*)&idFormat , sizeof idFormat ) ;
            countT idFormat = 1 ;

            thirdC::s_writeIF( tinP , pOsh->hSockCloak , (byteT*)&finger , sizeof finger ) ;
            countT finger = FINGERnEG_CLOAKsIMPLEcONNECTION ;

            thirdC::s_writeIF( tinP , pOsh->hSockCloak , (byteT*)&idTypeConnection , sizeof idTypeConnection ) ;
            countT idTypeConnection = ifcIDtYPEcLOAKcONNECTION_SIMPLE ;

            thirdC::s_connectIF( tinP , countTC() , pOsh->hSockCloak , homeS::homeIF().idPortCloak ) ;

            thirdC::s_socketIF( tinP , pOsh->hSockCloak , ifcSOCKETtYPE_STREAM ) ;
        {
        if( bCloaked )

        }
            handleP.osF( ifcIDtYPEhANDLE_FILEfIND , (countT)pOsh ) ;
            pOsh = new( 0 , tinP , pba , cba ) diskFindHandleS( tinP ) ;
        {
        if( pba )
        byteT* pba = processGlobal3I.heap.newF( tinP , LF , cba ) ;
        countT cba = sizeof( diskFindHandleS ) ;
    {
    else
    if( ~handleP ) pOsh = (diskFindHandleS*)handleP.osF( ifcIDtYPEhANDLE_FILEfIND ) ;
    boolT bWoth = !handleP ;
    ZE( diskFindHandleS* , pOsh ) ;
    //CS:CODEsYNC: DUPLICATE CODE 3600101d 35001186

    }
        }
            bCloaked = 1 ;
            POOPRqUIET
        {
        if( POOP )

        thirdC::dosFindFileOrDirSimpleIF( tinP , postf , sizeof postf , hFind , postLikeP , flDOSfINDfILEoRdIR_DOnOTtESTwATER ) ;
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        postf[ 0 ] = 0 ;
        osTextT postf[ TUCK << 1 ] ;

        SCOOP
        poopC poop ;
    {
    //CS:CODEsYNC: DUPLICATE CODE 3600101d 35001186
    if( !( F(flagsP) & flDOSfINDfILEoRdIR_DOnOTtESTwATER ) )
    ZE( boolT , bCloaked ) ;

    _INoLD_

    }
        if( POOP ) return ;
        #endif
            __( sizeof( countT ) != sizeof( HANDLE ) || fnu ) ;
        #elif defined( __NT__ )
        #ifdef __OS2__
        ZE( boolT , fnu ) ;
        //U::__( !postLikeP[ 3 ] ) ;
        if( POOP ) return ;
        __( !postLikeP[ 2 ] ) ;
        if( POOP ) return ;
        __( postLikeP[ 1 ] - ':' ) ;
        if( POOP ) return ;
        __( postLikeP[ 0 ] < 'a' || postLikeP[ 0 ] > 'z' ) ;
        __( !postLikeP[ 0 ] ) ;
        __( !!*postP ) ;     //CALLER MUST INSPECT THIS TO DETERMINE WHETHER AN OBJECT WAS FOUND
        if( POOP ) return ;
        //FV(flDOSfINDfILEoRdIR,flagsP) ;
        __Z( postLikeP ) ;
        __( costaP <= costMax ) ;
        __Z( costMax ) ;
        __Z( postP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
    const countT costMax = dosQuerySysInfoMaxPathLengthIF( tinP ) ;
{
/*1*/voidT thirdC::dosFindFileOrDirSimpleIF( tinS& tinP , osTextT* const postP , const countT costaP , handleC& handleP , const osTextT* const postLikeP , const flagsT flagsP )/*1*/

#endif
    #define symACHnAME         cFileName
#elif defined( __NT__ )
#ifdef __OS2__

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

