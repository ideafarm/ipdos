
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        c_strcpyIF( tinP , postP , ostot ) ;

        if( info.symACHnAME ) OStEXTA( ostot , info.symACHnAME )
        OStEXTAL( ostot , postLikeP , costPrefix )
        OStEXT( ostot , 0x200 )

        countT costPrefix = postEnd - postLikeP + 1 ;
        postEnd = c_strrchrIF( tinP , postLikeP , '\\' ) ;
        ZE( osTextT* , postEnd ) ;
    {
    if( !POOP && fFound )

    }
        #endif

            }
                handleP.closeIfF() ;
                fFound = 0 ;
                tinP.bosFail = 0 ;
            {
            if( tinP.bosFail && ( tinP.brcLath == ERROR_FILE_NOT_FOUND || tinP.brcLath == ERROR_PATH_NOT_FOUND || tinP.brcLath == ERROR_NO_MORE_FILES ) )

            }
                }
                    fFound = !tinP.bosFail ;
                    BOS( WHATsfr , BOSoK , FindNextFile( (HANDLE)pOsh->oshFind , &info ) )
                {
                if( pOsh )
                diskFindHandleS* pOsh = (diskFindHandleS*)handleP.osF( ifcIDtYPEhANDLE_FILEfIND ) ;
            {
            else
            }
                }
                    }
                        fFound = 1 ;
                        handleP.osF( ifcIDtYPEhANDLE_FILEfIND , (countT)pOsh ) ;
                        pOsh->oshFind = tinP.brcRaw ;
                    {
                    else
                    }
                        processGlobal3I.heap.delF( tinP , pba ) ;
                        DELzOMBIE( pOsh ) ;
                    {
                    if( tinP.brcRaw == (countT)INVALID_HANDLE_VALUE )
                    BOS( WHATsfr , BOShANDLE , FindFirstFile( postLikeP , &info ) )

                    diskFindHandleS* pOsh = new( 0 , tinP , pba , cba ) diskFindHandleS ;
                {
                if( pba )
                byteT* pba = processGlobal3I.heap.newF( tinP , LF , cba ) ;
                countT cba = sizeof( diskFindHandleS ) ;
            {
            if( !handleP )
            //CS:CODEsYNCH: DUPLICATE CODE 3600101d 35001186

        #elif defined( __NT__ )
        #ifdef __OS2__
    {

    c_memsetIF( tinP , (byteT*)&info , sizeof info ) ;
    #endif
        WIN32_FIND_DATA info ;
    #elif defined( __NT__ )
    #ifdef __OS2__
    ZE( boolT , fFound ) ;

    _INoLD_

    }
        if( POOP ) return ;
        #endif
            __( sizeof( countT ) != sizeof( HANDLE ) || fnu ) ;
        #elif defined( __NT__ )
        #ifdef __OS2__
        ZE( boolT , fnu ) ;
        //U::__( !postLikeP[ 3 ] ) ;
        if( POOP ) return ;
        __( !postLikeP[ 2 ] ) ;
        if( POOP ) return ;
        __( postLikeP[ 1 ] - ':' ) ;
        if( POOP ) return ;
        __( postLikeP[ 0 ] < 'a' || postLikeP[ 0 ] > 'z' ) ;
        __( !postLikeP[ 0 ] ) ;
        __( !!*postP ) ;     //CALLER MUST INSPECT THIS TO DETERMINE WHETHER AN OBJECT WAS FOUND
        if( POOP ) return ;
        __Z( postLikeP ) ;
        __( costaP <= costMax ) ;
        __Z( costMax ) ;
        __Z( postP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
    const countT costMax = dosQuerySysInfoMaxPathLengthIF( tinP ) ;
{
/*1*/voidT thirdC::dosFindFileOrDirSimpleIF( tinS& tinP , osTextT* const postP , const countT costaP , handleC& handleP , const osTextT* const postLikeP )/*1*/

#endif
    #define symACHnAME         cFileName
#elif defined( __NT__ )
#ifdef __OS2__

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

