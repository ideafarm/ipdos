
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    /**/etherP.traceF( tinP , T("loadIF / -") ) ;
    }
        DELzOMBIE( pSw_jbr ) ;
        }
            /**/etherP.traceF( tinP , T("stuffed pSoulLinkP") ) ;
            }
                }
                    etherP.delF( tinP , psttText ) ;
                    *pSoulLinkP << psttText ;
                    etherP.traceF( tinP , T("loadIF: export: stuffing *pSoulLinkP [idf,idType,hashv,hashId,pstText]: ")+T("    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(hashv,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(hashId,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttText) ) ; //U;; TO FIND A BUG
                    etherP.strDecodeF( tinP , psttText , pbzEncoded ) ; ___( psttText ) ;
                    ZE( strokeS* , psttText ) ;
                    __Z( pbzEncoded ) ;
                    const byteT* pbzEncoded = idType == ifcIDtYPEbRANCHs_strokeSstr ? (const byteT*)pageEncoded : 0 ;
                    PSP( pageEncoded , jbrText ) ;

                    *pSoulLinkP << hashId ;
                    *pSoulLinkP << hashv ;
                    }
                        jbrText = B(brc).value  ;
                        hashId  = B(brc).hashId ;
                        hashv   = B(brc).hashv  ;
                        idType  = B(brc).idType ;
                        BSP( brc , jbrc ) ;
                    {
                    ZE( countT , jbrText ) ;
                    ZE( countT , hashId ) ;
                    ZE( countT , hashv ) ;
                    ZE( countT , idType ) ;
                {
                if( !POOP )
                __Z( jbrc ) ;
                countT jbrc = *pSw_jbr ;
                *pSoulLinkP << psttzLabelShort ;
                etherP.traceF( tinP , T("loadIF: stuffing *pSoulLinkP [idf,psttzLabelShort]: ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttzLabelShort) ) ; //U;; TO FIND A BUG
                psttzLabelShort = (strokeS*)pSw_jbr->leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            etherP.traceF( tinP , T("loadIF: stuffing *pSoulLinkP [pSw_jbr->cFlavors]: ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U;; TO FIND A BUG
            *pSoulLinkP << cFlavors ;
            countT cFlavors = pSw_jbr->cFlavorsF( tinP ) ; //U:: 20160429@1510: pSw_jbr NULL DURING QUIT
            TN( tb , " " ) ;

            }
                *pSoulLinkP << (countT)1 ; // idFormat
                *pSoulLinkP << finger ;
                putNegAM( *(countT*)&finger , FINGERnEG_KTlINKfILEiNNER ) ;
                ZE( countT , finger ) ;
                *pSoulLinkP << (osTextT*)T(" >> IdeaFarm (tm) - (c) Wo'O Ideafarm - ideafarm.com << ") ;
            {
            /**/etherP.traceF( tinP , T("stuffing pSoulLinkP") ) ;
        {                                         //EXPORT [psttLabelShort,hashv,hashId] TO A FILE SO THAT OTHER KT CAN REFERENCE THE LABELS IN THE INSTANT KT
        if( !POOP && pSoulLinkP && pSw_jbr ) // pSw_jbr NULL TEST ADDED 20160429@1518 WITHOUT ANALYSIS

        }
            /**/etherP.traceF( tinP , tTraceWhat+T("-") ) ;
            DELzOMBIE( pSwHashId ) ;
            /**/etherP.traceF( tinP , T("deleting pSwHashId") ) ;

            }
                /**/etherP.traceF( tinP , T("deleted pBarryUtility") ) ;
                DELzOMBIE( tinP.pBarryUtility ) // USED TO DELETE HERE BUT REMOVED TO SUPPORT bRepeat
                /**/etherP.traceF( tinP , T("deleting pBarryUtility") ) ;
            {
            if( bDeleteBarryAsZombie )

            /**/etherP.traceF( tinP , tTraceWhat+T("- / after loop") ) ;
            }
                if( POOP ) etherP.traceF( tinP , T("poop at loop - [idBranch]: ")+TF3(idBranch,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9) ) ;
        
                }
                    else jbrc = 0 ;
                    }
                        if( !bFound ) jbrc = 0 ;
        
                        }
                            }
                                break ;
                                bFound = 1 ;
                                jbrc = B(brc).jbrRight ;
                            {
                            if( B(brc).jbrRight )
                            BSP( brc , jbrc ) ;
        
                            if( POOP ) break ;
                            __Z( jbrc ) ;
                            stq_jbrDad >> jbrc ;
                            jbrc = 0 ;
                        {
                        while( stq_jbrDad )
                        ZE( boolT , bFound ) ;
                    {
                    else if( stq_jbrDad )
                    else if( jbrRightc ) jbrc = jbrRightc ;
                    }
                        jbrc = jbrUpc ;
                        stq_jbrDad << jbrc ;
                    {
                    if( jbrUpc )

                    }
                        jbrRightc = B(brc).jbrRight ;
                        jbrUpc    = B(brc).jbrUp    ;
                        BSP( brc , jbrc ) ;
                    {
                    ZE( countT , jbrRightc ) ;
                    ZE( countT , jbrUpc ) ;

                    }
                        }
                            if( !B(brc).hashv || ( offPass && !B(brc).hashId ) ) etherP.traceF( tinP , T("branch [idBranch,hashv,hashId]: ")+TP("",stq_jbrDad)+TF3(idBranch,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("    ")+TF3(B(brc).hashv,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("    ")+TF3(B(brc).hashId,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9) ) ;
                        {
                        if( B(brc).idType == ifcIDtYPEbRANCHs_strokeSstr )
                        BSP( brc , jbrc ) ;
                    {
        
                    if( POOP ) break ;
        
                    }
                        }
                            etherP.delF( tinP , psttLabelWordElement ) ;
                            etherP.delF( tinP , psttLabelWordLever ) ;
                            etherP.delF( tinP , psttLabelWordBox ) ;
                            etherP.delF( tinP , psttLabelLong ) ;
                            etherP.delF( tinP , psttLabelWordLever ) ;
                            }
                                }
                                    etherP.delF( tinP , psttTextGot ) ;
                                    etherP.delF( tinP , psttFileTinyGot ) ;

                                    }
                                        B(brc).value  = (countT)pbEncoded ;
                                        B(brc).idType = ifcIDtYPEbRANCHs_strokeSstr ;
                                        BSP( brc , jbrc ) ;

                                        if( POOP ) etherP.delF( tinP , pbEncoded ) ;

                                        etherP.strEncodeF( tinP , pbEncoded , tTextNew ) ; ___( pbEncoded ) ;
                                        ZEJ( byteT* , pbEncoded , jotP ) ;
                                    {

                                    etherP.traceF( tinP , T("new text:   \"")+tTextNew+T("\"") ) ;

                                    ;
                                        : T("<a href=\"http://")+tUri+(!psttLabelWordElement?tn:T("#")+T(psttLabelWordElement))+T("\"><span style=\"color:#c80\" onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'Click to jump from this IdeaFarm (tm) Knowledge Tree to the one at ")+tHost+T("!' , 0 )\">")+tDisplay+T("</span></a>")
                                        ? T("please report this error:  could not resolve reference")
                                    TN( tTextNew , "" ) ; tTextNew = !bGotIt
                                    TN( tn , "" ) ;

                                    ;
                                        : T(psttTextGot)
                                        ? tNoteFromCloud
                                    TN( tDisplay , "" ) ; tDisplay = tNoteFromCloud.csF( tinP )

                                    //
                                    // EXAMPLE: <a href="http://test.ideafarm.com/pages/index.z.black.a1587c89.10000000.html#here"><span style="color:#c80" onmouseout="sayMessageF( 0 , 16000 )" onmouseover="sayMessageF( 'Click to jump from this IdeaFarm (tm) Knowledge Tree to another one!' , 0 )">20100815: 22222222222222222222222</span></a>
                                    //
                                    // BUILD THE REPLACEMENT BRANCH TEXT (HTML HYPERTEXT LINK)

                                    etherP.traceF( tinP , T("uri" ":   \"")+tUri+T("\"") ) ;
                                    }
                                        tUri += T(".z.black.")+TF3(hashvGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+sttDot+TF3(hashIdGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".html") ;
                                        strokeS sttDot( '.' ) ;

                                        }
                                            etherP.delF( tinP , psttw ) ;

                                            }
                                                default : {         tUri += !idf ? T("/pages/")+T(psttw) : tSlash+T(psttw) ; break ; }
                                                case 3  : {                                                                  break ; }
                                                case 2  :
                                                case 1  : { tHost = tUri = T(psttw)                                        ; break ; }
                                            {
                                            switch( ++ idWord )

                                            etherP.strSubstringF( tinP , psttw , idf , sttq , sttSlash , psttLabelWordBox ) ; ___( psttw ) ;
                                            ZE( strokeS* , psttw ) ;
                                        {
                                        while( idf )
                                        ZE( countT , idWord ) ;
                                        TN( tSlash , "/" ) ;
                                        strokeS sttSlash( '/' ) ;
                                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                        countT idf = 1 ;
                                    {
                                    TN( tHost , "" ) ;
                                    TN( tUri , "" ) ;
                                    // BUILD THE URI

                                    }
                                        etherP.traceF( tinP , T("got trimmed [text]:   \"")+T(psttTextGot)+T("\"") ) ;
                                        }
                                            etherP.delF( tinP , psttd ) ;
                                            etherP.strSubstringF( tinP , psttTextGot , idf , sttq , sttMark01 , psttd ) ; ___( psttTextGot ) ;

                                                             psttTextGot = 0 ;
                                            strokeS* psttd = psttTextGot ;
                                        {
                                        if( etherP.strIdF( tinP , idf , sttq , sttMark01 , psttTextGot , idl , 1 ) )
                                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                        ZE( countT , idl ) ;
                                        countT idf = 1 ;
                                    {
                                    if( psttTextGot )
                                    // TRIM THE TEXT

                                    etherP.traceF( tinP , T("got   [note]: \"")+tNoteFromCloud+T("\"") ) ;
                                    etherP.traceF( tinP , T("got   [text]: \"")+T(psttTextGot)+T("\"") ) ;
                                    etherP.traceF( tinP , T("got [hashId]: ")+TF2(hashIdGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    etherP.traceF( tinP , T("got  [hashv]: ")+TF2(hashvGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    etherP.traceF( tinP , T("got   [tiny]: \"")+T(psttFileTinyGot)+T("\"") ) ;
                                {
                                if( !POOP )

                                }
                                    __1
                                    etherP.traceF( tinP , T("loadIF: error: could not find far label [box,label]:    ")+T(psttLabelWordBox)+T("    ")+T(psttLabelWordLever) ) ;
                                {
                                if( !bGotIt )

                                }
                                    }
                                        }
                                            }
                                                etherP.delF( tinP , psttText ) ;

                                                }
                                                    bGotIt = 1 ;
                                                                  psttText = 0 ;
                                                    psttTextGot = psttText ;
                                                    hashIdGot   = hashId ;
                                                    hashvGot    = hashv  ;
                                                {
                                                if( bFound )

                                                /**/etherP.traceF( tinP , T("inner [text]:   \"")+T(psttText)+T("\"") ) ;
                                                soulLinkInner >> psttText ; ___( psttText ) ;
                                                ZE( strokeS* , psttText ) ;

                                                /**/etherP.traceF( tinP , T("inner [hashId]:   ")+TF2(hashId,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                soulLinkInner >> hashId ;
                                                ZE( countT , hashId ) ;

                                                /**/etherP.traceF( tinP , T("inner [hashv]:   ")+TF2(hashv,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                soulLinkInner >> hashv ;
                                                ZE( countT , hashv ) ;

                                                etherP.delF( tinP , psttLabelShort ) ;
                                                if( !etherP.strCompareF( tinP , psttLabelShort , psttLabelWordLever ) ) bFound = 1 ;

                                                /**/etherP.traceF( tinP , T("inner [label]:   \"")+T(psttLabelShort)+T("\"") ) ;
                                                soulLinkInner >> psttLabelShort ; ___( psttLabelShort ) ;
                                                ZE( strokeS* , psttLabelShort ) ;
                                            {
                                            while( soulLinkInner && !bFound )
                                            ZE( boolT , bFound ) ;

                                            /**/etherP.traceF( tinP , T("inner [cFlavors]:   ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            soulLinkInner >> cFlavors ;
                                            ZE( countT , cFlavors ) ;

                                            }
                                                /**/etherP.traceF( tinP , T("inner [idFormat]:   ")+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                soulLinkInner >> idFormat ;
                                                ZE( countT , idFormat ) ;

                                                /**/etherP.traceF( tinP , T("inner [finger]:   ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                soulLinkInner >> finger ;
                                                ZE( countT , finger ) ;

                                                etherP.delF( tinP , postTM ) ;
                                                /**/etherP.traceF( tinP , T("inner [tm]:   \"")+T(postTM)+T("\"") ) ;
                                                soulLinkInner >> postTM ; ___( postTM ) ;
                                                ZE( osTextT* , postTM ) ;
                                            {
                                        {
                                        if( soulLinkInner )

                                        }
                                            soulLinkOuter >> soulLinkInner ;

                                            /**/etherP.traceF( tinP , T("outer [fileTiny]:   \"")+T(psttFileTinyGot)+T("\"") ) ;
                                            }
                                                etherP.delF( tinP , psttFolderFile ) ;

                                                }
                                                    etherP.strSubstringF( tinP , psttFileTinyGot , idHit , countTC() , psttFolderFile ) ; ___( psttFileTinyGot ) ;
                                                    idHit ++ ;
                                                {
                                                if( idHit )
                                                countT idHit = etherP.strIdF( tinP , strokeS( '/' ) , psttFolderFile , - 1 ) ;

                                                /**/etherP.traceF( tinP , T("outer [folderFile]:   \"")+T(psttFolderFile)+T("\"") ) ;
                                                soulLinkOuter >> psttFolderFile ; ___( psttFolderFile ) ;
                                                ZE( strokeS* , psttFolderFile ) ;
                                            {

                                            }
                                                /**/etherP.traceF( tinP , T("outer [idFormat]:   ")+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                soulLinkOuter >> idFormat ;
                                                ZE( countT , idFormat ) ;

                                                /**/etherP.traceF( tinP , T("outer [finger]:   ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                soulLinkOuter >> finger ;
                                                ZE( countT , finger ) ;

                                                etherP.delF( tinP , postTM ) ;
                                                /**/etherP.traceF( tinP , T("outer [tm]:   \"")+T(postTM)+T("\"") ) ;
                                                soulLinkOuter >> postTM ; ___( postTM ) ;
                                                ZE( osTextT* , postTM ) ;
                                            {
                                        {
                                        if( soulLinkOuter )

                                        }
                                            etherP.delF( tinP , pbLink ) ;
                                            if( pbLink ) soulLinkOuter.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbLink , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;

                                            if( pbLink ) ; etherP.boxPutF( tinP , T("///d/tmp/x/verify.soul.not.html") , pbLink , cbLink ) ; //U:: TO FIND A BUG

                                            }
                                                }
                                                    etherP.traceF( tinP , T("error:  could not get page linkage from ")+tBox ) ;
                                                    POOPR ;
                                                {
                                                if( POOP )
                                                tinP.pEtScratch->boxGetShadowF( tinP , pbLink , cbLink , tBox ) ; ___( pbLink ) ;
                                                SCOOPS
                                            {
                                            IFsCRATCH
                                            TN( tBox , "" ) ; tBox = T(psttLabelWordBox)+T(".link.pages.soul.not.html") ;
                                            ZE( countT , cbLink ) ;
                                            ZE( byteT* , pbLink ) ;
                                        {
                                        soulC soulLinkOuter( tinP , TAG( TAGiDnULL ) ) ;
                                    {
                                    soulC soulLinkInner( tinP , TAG( TAGiDnULL ) ) ;
                                {
                                ZE( boolT    , bGotIt ) ;
                                ZE( strokeS* , psttTextGot ) ;
                                ZE( strokeS* , psttFileTinyGot ) ;
                                ZE( countT   , hashIdGot ) ;
                                ZE( countT   , hashvGot ) ;

                                }
                                    }
                                        etherP.delF( tinP , psttp ) ;
                                        etherP.traceF( tinP , T("soulIdFragCloud [psttp]: ")+T(psttp) ) ;

                                        }
                                            break ;
                                            etherP.delF( tinP , psttp ) ;
                                            etherP.delF( tinP , postNote ) ;
                                            etherP.traceF( tinP , T("soulIdFragCloud [psttp]: ")+T(psttp) ) ;

                                            }
                                                else tNoteFromCloud = T(postNote) ;
                                                else if( !postNote || !*postNote ) tNoteFromCloud = T("Please report this error:  Note text in ")+T(psttp)+T(" is null length") ;
                                                }
                                                    tNoteFromCloud = T("Please report this error:  Could not get note text from ")+T(psttp) ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                tinP.pEtScratch->boxGetShadowF( tinP , postNote , costNote , psttp ) ; ___( postNote ) ;
                                                SCOOPS
                                            {
                                            IFsCRATCH
                                            ZE( countT , costNote ) ;
                                            ZE( byteT* , postNote ) ;

                                            etherP.traceF( tinP , T("retrieving note from [psttp]: \"")+T(psttp)+T("\"") ) ;
                                        {
                                        else if( bFound )
                                        }
                                            if( !etherP.strCompareF( tinP , psttp , psttLabelWordElement ) ) bFound = 1 ;
                                        {
                                        if( bLabelShort )

                                        soulIdFragCloud >> psttp ; ___( psttp ) ;
                                        ZE( strokeS* , psttp ) ;

                                        bLabelShort = !bLabelShort ;
                                    {
                                    while( soulIdFragCloud ) //U:: OBTAIN THE CONTENTS OF THE MATCHING NOTE FILE
                                    ZE( boolT , bFound ) ;
                                    ZE( boolT , bLabelShort ) ;

                                    }
                                        etherP.delF( tinP , pbLink ) ;
                                        else soulIdFragCloud.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbLink , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                                        }
                                            tNoteFromCloud = T("Please report this error:  Could not get frag note linkage from ")+tBox ;
                                            POOPR ;
                                        {
                                        if( POOP )

                                        tinP.pEtScratch->boxGetShadowF( tinP , pbLink , cbLink , tBox ) ; ___( pbLink ) ;
                                        ZE( countT , cbLink ) ;
                                        ZE( byteT* , pbLink ) ;

                                        TN( tBox , "" ) ; tBox = T(psttLabelWordBox)+T(".link.frag.notes.soul.not.html") ;

                                        SCOOPS
                                    {
                                    IFsCRATCH
                                    soulC soulIdFragCloud( tinP , TAG( TAGiDnULL ) ) ;
                                {
                                if( psttLabelWordElement )
                                TN( tNoteFromCloud , "" ) ;

                                etherP.traceF( tinP , T("link label [label,box]:    \"")+T(psttLabelWordLever)+T("\"")+T("    \"")+T(psttLabelWordBox)+T(".link.pages.soul.not.html")+T("\"") ) ;
                            {
                            else
                            }
                                }
                                    etherP.traceF( tinP , T("setting reference [jbrHe,psttzLabelShort,psttRefHtmlId]:")+TF2(*pSw_jbr,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    \"")+T(psttzLabelShort)+T("\"    \"")+T(B(brc).psttRefHtmlId)+T("\"") ) ;
                                    B(brc).value = *pSw_jbr ; // jbrzHe        (THIS LINE OVERWRITES pbEncoded WHICH IS NOW A ZOMBIE POINTER
                                                           psttLabelWordElement = 0 ;
                                    B(brc).psttRefHtmlId = psttLabelWordElement  ;
                                    psttzLabelShort      = psttLabelWordLever ;
                                {
                                else
                                }
                                    __1                                                                                                       //20180420@1949: COMMENTED OUT WITHOUT ANALYSIS TO HANDLE MISSING LABEL
                                    etherP.traceF( tinP , T("error: could not find reference \"")+T(psttLabelLong)+T("\"") ) ;
                                    B(brc).value = 0 ;        // jbrzHe        (THIS LINE OVERWRITES pbEncoded WHICH IS NOW A ZOMBIE POINTER
                                {
                                if( !pSw_jbr->idSlotOfLeverF( tinP , (countT)psttLabelWordLever ) )
                                BSP( brc , jbrc ) ;

                                __Z( pSw_jbr ) ;
                            {
                            if( !psttLabelWordBox )

                            etherP.traceF( tinP , T("loadIF: label word [element]:   ")+T(psttLabelWordElement) ) ;
                            etherP.traceF( tinP , T("loadIF: label word   [lever]:   ")+T(psttLabelWordLever  ) ) ;
                            etherP.traceF( tinP , T("loadIF: label word     [box]:   ")+T(psttLabelWordBox    ) ) ;
                            etherP.strTrimF( tinP , psttLabelWordBox , 0 , 0 , T("\"") ) ;

                            }
                                etherP.delF( tinP , pstt1LabelLongWords ) ;
                                }
                                    }
                                        else if( !psttLabelWordElement ) { etherP.strMakeF( tinP , LF , psttLabelWordElement , psttc1 ) ; ___( psttLabelWordElement ) ; }
                                        else if( !psttLabelWordLever   ) { etherP.strMakeF( tinP , LF , psttLabelWordLever   , psttc1 ) ; ___( psttLabelWordLever   ) ; }
                                             if( !psttLabelWordBox     ) { etherP.strMakeF( tinP , LF , psttLabelWordBox     , psttc1 ) ; ___( psttLabelWordBox     ) ; }
                                    {
                                    else
                                    }
                                        else if( !psttLabelWordElement ) { etherP.strMakeF( tinP , LF , psttLabelWordElement , psttc1 ) ; ___( psttLabelWordElement ) ; }
                                             if( !psttLabelWordLever   ) { etherP.strMakeF( tinP , LF , psttLabelWordLever   , psttc1 ) ; ___( psttLabelWordLever   ) ; }
                                    {
                                    else if( !bFarLabel )
                                    if( !etherP.strCompareF( tinP , psttc1 , T("!link") ) ) bFarLabel = 1 ;

                                    etherP.traceF( tinP , T("loadIF: labelLong word:    ")+T(psttc1) ) ;
                                {
                                FORsTRINGSiN1( pstt1LabelLongWords )
                                ZE( boolT , bFarLabel ) ;
                                etherP.strWordsF( tinP , pstt1LabelLongWords , psttLabelLong , sttq , T(",") , flSTRwORDS_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1LabelLongWords ) ;
                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                ZE( strokeS* , pstt1LabelLongWords ) ;
                            {
                            ZE( strokeS* , psttLabelWordElement ) ;
                            ZE( strokeS* , psttLabelWordLever ) ;
                            ZE( strokeS* , psttLabelWordBox ) ;

                            }
                                etherP.traceF( tinP , T("loadIF: [psttLabelLong]:    ")+T(psttLabelLong) ) ;

                                etherP.delF( tinP , pbEncoded ) ;
                                etherP.strDecodeF( tinP , psttLabelLong , (byteT*)valuec ) ; ___( psttLabelLong ) ;
                                byteT* pbEncoded = (byteT*)valuec ;
                            {
                            ZE( strokeS* , psttLabelLong ) ;

                            // 
                            // FOR !link  LABELS, THE INSTANT BRANCH WILL BECOME OF TYPE ifcIDtYPEbRANCHs_strokeSstr, WITH A GENERATED STRING VALUE (AN HTML HYPERTEXT LINK)
                            // FOR NORMAL LABELS, THE INSTANT BRANCH WILL REMAIN OF TYPE ifcIDtYPEbRANCHs_branchSptr
                            // 
                            // SEMANTICS

                            //
                            //  !link,"archiveview.ideafarm.com//http/201x/3/index",archive                   ACTUAL EXAMPLE (FOM ARCHIVE TOC KT)
                            //  !link,"test.ideafarm.com//http/index",label@htmlId                            POINTS TO A FOREIGN LABEL, TO BE RESOLVED USING THE SPECIFIED LINK FILE
                            //  label                                                                         POINTS TO A LABEL WITHIN THE INSTANT KT
                            //
                            // LABEL FORMATS
                        {                                                 //I NOW SUPPORT !link REFERENCES, WHICH HAS TO BE DONE ON LATH PASS SINCE I NEED THE HASH VALUES
                        else if( idTypec == ifcIDtYPEbRANCHs_branchSptr ) //REPLACING REFERENCES COULD BE DONE ON EITHER PASS ; DONE HERE TO BALANCE MEMORY USAGE (barryC IS USED ON THE OTHER PASS)
                        }
                            }
                                B(brc).hashId = ++ *pSwHashId ;
                                cLeverHash = B(brc).hashv ;
                            {
                            else
                            if( !cCollisions || !stHashCollisions( B(brc).hashv ) ) B(brc).hashId = 1 ;
                            BSP( brc , jbrc ) ;
                        {
                        if( idTypec == ifcIDtYPEbRANCHs_strokeSstr )

                        }
                            valuec  = B(brc).value  ;
                            idTypec = B(brc).idType ;
                            BSP( brc , jbrc ) ;
                        {
                        ZE( countT , valuec ) ;
                        ZE( countT , idTypec ) ;
                    {
                    else
                    }
                        else                                               B(brc).hashF( tinP , jbrc , *tinP.pBarryUtility , stHashCollisions ) ;
                        if( B(brc).idType != ifcIDtYPEbRANCHs_strokeSstr ) B(brc).hashv = 0xeeeeeeee ; //U::TO FIND A BUG

                        BSP( brc , jbrc ) ;
                    {
                    if( !offPass )
        
                    }
                        }
                            }
                                break ;
                                __1
                                etherP.traceF( tinP , T("unexpected type [idType]: ")+TF3(B(brc).idType,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9) ) ;
                            {
                            default :
                            }
                                break ;
                            {
                            case ifcIDtYPEbRANCHs_branchSptr :
                            case ifcIDtYPEbRANCHs_strokeSstr :
                        {
                        switch( B(brc).idType )

                        BSP( brc , jbrc ) ;
                    {

                    //}
                    //    //LOGrAW5( "loadIF [idThread,idBranch]:    " , tinP.monitor.idThread , "    " , idBranch , "\r\n" ) ;
                    //
                    //    //etherP.traceF( tinP , T("loadIF [idBranch]: ")+TF2(idBranch,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , flTRACE_null , ifcIDtRACEdIVERT_8 ) ;
                    //
                    //    //if( !( F(tinP.flagsThreadMode2) & flTHREADmODE2_INoUTcHATTER ) ) { THREADmODE2oN( flTHREADmODE2_INoUTcHATTER ); }
                    //{
                    //if( !offPass && idBranch >= 0x13aa0 ) //U:: TO FIND A BUG, WE TRACE: loadIF / setting hashv / [idBranch]: aaa31
        
                    /*if( !( idBranch % ( TUCK << 4 ) ) )*/ etherP.traceF( tinP , tTraceWhat+T("[idBranch]: ")+TF2(idBranch,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    ++ idBranch ;

                    _IO_
                {
                else
                }
                    jbrc = 0 ;
                    etherP.traceF( tinP , T("setting jbrc to ze [idBranch before incrementing]: ")+TF3(idBranch,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9) ) ;
                {
                if( !(const byteT*)jotP[ jbrc & ~NM_HIGH ] )
            {
            while( !POOP && !bQuitP && jbrc )
            switchC* pSwHashId = !cCollisions ? 0 : new( 0 , tinP , pbSwHashId , sizeof pbSwHashId ) switchC( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cLeverHash ) ;
            ZE( countT , cLeverHash ) ;
            byteT pbSwHashId[ sizeof( switchC ) ] ;
            const countT cCollisions = !offPass ? 0 : stHashCollisions ;
            countT jbrc = 2 | jotP.tagHighNibbleF() ;
            ZE( countT , idBranch ) ;
            staqC stq_jbrDad( tinP ) ;

            }
                }
                    while( !bQuitP ) ;
                    }
                        }
                            }
                                etherP.delF( tinP , psttzLabelShort ) ;
                                *pSw_jbr = *(countT*)(const byteT*)pi ;

                                }
                                    break ;
                                    __1
                                    etherP.delF( tinP , psttzLabelShort ) ;
                                    /**/etherP.traceF( tinP , T("error: label is not unique [label]: \"")+T(psttzLabelShort)+T("\"") ) ;                         //U:: TEST ERRORS SUCH AS THIS TO ENSURE THAT SOFTWARE DOESN'T CRASH
                                {
                                if( jbrSwitched )

                                countT& jbrSwitched = *pSw_jbr ;
                            {
                            else
                            if( !psttzLabelShort ) { etherP.strDecodeF( tinP , psttzLabelShort , pi ) ; ___( psttzLabelShort ) ; }
                        {
                        else
                        if( !(const byteT*)pi ) break ;
                        pi = jotReferences ;
                        pageC pi( tinP , jotReferences , 0 ) ;
                    {
                    do
                {
                if( pSw_jbr )
                pSw_jbr = new( 0 , tinP , pb_sw_jbr , sizeof pb_sw_jbr ) switchC( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLabelShort ) ;
            {
            if( offPass )

            }
                }
                    bDeleteBarryAsZombie = 1 ;
                    /**/etherP.traceF( tinP , T("constructed  barryC instance") ) ;
                    tinP.pBarryUtility = new( 0 , tinP , pb_barryHash , sizeof pb_barryHash ) barryC( tinP ) ; //TO ALLOW APP TO PRECONSTRUCT barryC
                    /**/etherP.traceF( tinP , T("constructing barryC instance") ) ;
                {
                else
                if( tinP.pBarryUtility ) tinP.pBarryUtility->setF( tinP ) ; // ALLOW CALLER TO PRECONSTRUCT barryC INSTANCE SO THAT INABILITY TO CT CAN BE DETECTED EARLIER (barryC HAS A HUGE MEMORY FOOTPRINT)
            {
            if( !offPass )
            ZE( boolT , bDeleteBarryAsZombie ) ;

            byteT pb_sw_jbr[    sizeof( switchC ) ] ;
            byteT pb_barryHash[ sizeof( barryC  ) ] ;
        
            /**/etherP.traceF( tinP , tTraceWhat+T("+") ) ;
            TN( tTraceWhat , !offPass ? "loadIF / setting hashv / " : "loadIF / setting hashId and setting reference jPointers / " ) ;
        {
        for( countT offPass = 0 ; !bQuitP && offPass <= 1 ; offPass ++ )
        stackC stHashCollisions( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE ) ;
    {
    ZE( switchC* , pSw_jbr ) ;
    ZE( strokeS* , psttzLabelShort ) ;

    }
        }
            __( bFail ) ;
            }
                }
                    }
                        }
                            stCursor[ 1 ] = jNew ; jNew = 0 ;
                
                            B(brLeft).jbrRight = jNew ;
                            __NZ( B(brLeft).jbrRight ) ;
                            BSP( brLeft , stCursor[ 1 ] ) ;
                
                            if( idLevel < idLevelLath ) stCursor.purgeF( tinP , idLevel ) ;
                        {
                        else
                        }
                            stCursor << jNew ; jNew = 0 ;
                
                            }
                                B(brDown).jbrUp = jNew ;
                                __NZ( B(brDown).jbrUp ) ;
                                BSP( brDown , stCursor[ 1 ] ) ;
                            {
                            if( idLevelLath )
                        {
                        if( idLevel == idLevelLath + 1 )
                    {
                    if( !POOP )

                    else { __1 }
                    }
                        if( POOP ) etherP.delF( tinP , pbEncoded ) ;

                        etherP.delF( tinP , psttLabelShort ) ;

                        etherP.traceF( tinP , T("loadIF new reference [jNew,psttLabelShort]: ")+TF2(jNew,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+T(psttLabelShort) ) ;

                        }
                            new( 0 , tinP , (byteT*)(const byteT*)pageNew , pageNew ) branchS( (countT)pbEncoded , !bNoRefs ? ifcIDtYPEbRANCHs_branchSptr : ifcIDtYPEbRANCHs_strokeSstr ) ;
                            PSP( pageNew , jNew ) ;
                        {
                        if( !POOP )

                        __Z( jNew ) ;
                        jNew = jotP.writeF( tinP , 0 , sizeof( branchS ) ) ;
                        jNewLag = jNew ;

                        etherP.strEncodeF( tinP , pbEncoded , psttLabelShort ) ; ___( pbEncoded ) ;
                        ZE( byteT* , pbEncoded ) ;

                        csttTrimmedP += psttLabelShort->idAdam ;
                    {
                    else if( psttLabelShort )
                    }
                        etherP.delF( tinP , psttLabelShort ) ;
                        }
                            }
                                jotReferences.writeF( tinP , (byteT*)&jNew , sizeof jNew ) ; // jotReferences WILL CONTAIN A SEQUENCE OF [psttLabelShort,jNew] PAIRS
                                etherP.strEncodeF( tinP , pbEncoded , psttLabelShort ) ; ___( pbEncoded ) ;
                                ZEJ( byteT* , pbEncoded , jotReferences ) ;
                            {
                            if( psttLabelShort )
                            pbEncoded = 0 ;
                        {
                        else
                        if( POOP ) etherP.delF( tinP , pbEncoded ) ;

                        etherP.delF( tinP , pstttBranch ) ;

                        etherP.traceF( tinP , T("loadIF new branch   [jNew,pstttBranch]: ")+TF2(jNew,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+T(pstttBranch) ) ;

                        }
                            new( 0 , tinP , (byteT*)(const byteT*)pageNew , pageNew ) branchS( (countT)pbEncoded ) ;
                            PSP( pageNew , jNew ) ;
                        {
                        if( !POOP )

                        __Z( jNew ) ;
                        jNew = jotP.writeF( tinP , 0 , sizeof( branchS ) ) ;
                        jNewLag = jNew ;

                        etherP.strEncodeF( tinP , pbEncoded , pstttBranch ) ; ___( pbEncoded ) ;
                        ZEJ( byteT* , pbEncoded , jotP ) ;

                        { countT offw = CSpREFIX + idMark ; etherP.strConvertToUpperCaseF( tinP , pstttBranch[ offw ] , pstttBranch[ offw ] ) ; } //CAPITALIZE WOTH STROKE IN THE BODY
                        csttTrimmedP += pstttBranch->idAdam ;

                        }
                            if( cFoundMark ) idMark = etherP.strIdF( tinP , sttMark01 , pstttBranch , 1 ) ;

                            if( cFoundLit )     etherP.strReplaceF( tinP , pstttBranch , 0 , tmff , tBackSlash   , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // SHOW ALL LITERAL BACKSLASH
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbh  , tme2 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\h"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbw  , tmd2 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\w"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tby  , tmc2 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\y"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbz  , tmb2 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\z"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tb9  , tma2 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\9"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tb8  , tm92 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\8"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tb7  , tm82 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\7"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tb6  , tm72 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\6"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tb5  , tm62 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\5"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tb4  , tm52 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\4"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tb3  , tm42 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\3"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tb2  , tm32 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\2"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tb1  , tm22 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\1"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tb0  , tm12 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\0"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbn  , tm02 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\n"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbi  , tmf1 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\i"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbk  , tme1 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\k"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbd  , tmd1 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\d"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbr  , tmc1 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\r"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbx  , tmb1 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\x"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbo  , tma1 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\o"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbt  , tm91 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\t"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbl  , tm81 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\l"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbp  , tm71 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\p"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbe  , tm61 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\e"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbc  , tm51 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\c"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbv  , tm41 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\v"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbs  , tm31 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\s"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tba  , tm21 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\a"
                                                etherP.strReplaceF( tinP , pstttBranch , 0 , tbf  , tm11 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\f"
                            countT cFoundMark = etherP.strReplaceF( tinP , pstttBranch , 0 , tbm  , tm01 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\m"
                            countT cFoundLit  = etherP.strReplaceF( tinP , pstttBranch , 0 , tbb  , tmff , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // HIDE ALL LITERAL BACKSLASH
                        {
                        ZE( countT , idMark ) ;
                        //ENCODE ESCAPE CHARACTERS
                    {
                    if( pstttBranch )
                    ZE( countT , jNewLag ) ;
                    ZE( countT , jNew ) ;
                
                    }
                        break ;
                        bFail = 1 ;
                    {
                    if( idLevel > idLevelLath + 1 ) // CAN SPECIFY KID OF LATH BRANCH, BUT NO HIGHER

                    etherP.traceF( tinP , T("loadIfIF [idLevel,psttLabelShort,pstttBranch]: ")+TF2(idLevel,flFORMAT_NObIGITvALUES)+T(" \"")+T(psttLabelShort)+T("\" \"")+T(pstttBranch)+T("\"\r\n") ) ;

                    }
                        }
                            else                                 etherP.delF( tinP , psttLabelShort   ) ;
                            if( psttLabelShort && psttLabelShort->idAdam ) etherP.delF( tinP , pstttBranch ) ;
                            etherP.strTrimF( tinP , psttLabelShort , 0 , tBlank ) ; ___( psttLabelShort ) ;
                            etherP.strSubstringF( tinP , psttLabelShort , idf , countTC() , pstttBranch ) ; ___( psttLabelShort ) ;
                            countT idf = 2 ;
                        {
                        else if( !idColon2 && pstttBranch->idAdam > 1 )                                                                             // IF THIS LOOKS LIKE A REFERENCE TO A LABELED BRANCH
                        }
                            }
                                }
                                    etherP.delF( tinP , pstttAfterLabelShort ) ;
                                    etherP.delF( tinP , psttLabelShort ) ;
                                {
                                else 
                                }
                                                  pstttAfterLabelShort = 0 ;
                                    pstttBranch = pstttAfterLabelShort ;
                                    etherP.delF( tinP , pstttBranch ) ;
                                    //etherP.strokeF( tinP , T("[psttLabelShort,pstttAfterLabelShort]: \"")+T(psttLabelShort)+T("\" \"")+T(pstttAfterLabelShort)+T("\"\r\n") ) ;
                                {
                                if( pstttAfterLabelShort && pstttAfterLabelShort->idAdam )
                                etherP.strTrimF( tinP , pstttAfterLabelShort , 0 , tBlank ) ; ___( pstttAfterLabelShort ) ;
                                etherP.strSubstringF( tinP , pstttAfterLabelShort , idf , countTC() , pstttBranch ) ; ___( pstttAfterLabelShort ) ;
                                idf = idColon2 + 1 ;
                            {
                            ZE( strokeS* , pstttAfterLabelShort ) ;

                            etherP.strSubstringF( tinP , psttLabelShort , idf , idl , pstttBranch ) ; ___( psttLabelShort ) ;
                            countT idl = idColon2 - 1 ;
                            countT idf = 2 ;
                        {
                        if( idColon2 > 2 && idColon2 < pstttBranch->idAdam )                                                                        // IF THIS LOOKS LIKE A LABELED BRANCH
                        const countT idColon2 = etherP.strIdF( tinP , sttColon , pstttBranch , 2 ) ;
                    {
                    if( pstttBranch->idAdam && pstttBranch[ CSpREFIX ] == sttColon )
                    ZE( strokeS* , psttLabelShort ) ;

                    etherP.delF( tinP , psttLine ) ;
                    etherP.strTrimF( tinP , pstttBranch , psttLine , tBlank ) ; ___( pstttBranch ) ;
                    ZE( strokeS* , pstttBranch ) ;
                
                    }
                        break ;
                        bFail = 1 ;
                    {
                    if( !idLevel ) //NULL LINE OR LINE OF BLANKS

                    countT idLevel = etherP.strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , tBlank , psttLine , 0 , 1 , flSTRiDaNY_NOT ) ;
                    countT idf = 1 ;

                    countT idLevelLath = stCursor ;

                    etherP.traceF( tinP , psttLine ) ;
                    etherP.strDecodeF( tinP , psttLine , pbzEncoded ) ; ___( psttLine ) ;
                    ZE( strokeS* , psttLine ) ;
                {
                if( !POOP )

                }
                    /*if( idFieldIn == 1 || !( cRemain % TUCK ) )*/ etherP.traceF( tinP , tTraceWhat+T(" [cRemain]: ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    countT cRemain = idFieldIn == 1 ? cFieldsIn : cFieldsIn - idFieldIn ;
                {

                __( !cbIn ) ;
                __( flagsIn - flSOULiTEM_null ) ;
                __( idTypeIn - ifcIDtYPEsOULiTEM_strokeSptr ) ;
                byteT* pbzEncoded = soulLinesP.pbFieldF( tinP , idTypeIn , flagsIn , cbIn , idFieldIn ) ;
                ZE( countT , cbIn     ) ;
                ZE( flagsT , flagsIn  ) ;
                ZE( countT , idTypeIn ) ;

                }
                    countT foo = 2 ;
                {
                if( idFieldIn == 0x1806a ) // ITERATION 0x1806b FAILS IN strEncodeF
                //U:: TO FIND A BUG
            {
            for( countT idFieldIn = 1 ; !bQuitP && idFieldIn <= cFieldsIn ; idFieldIn ++ )
            TN( tTraceWhat , "loadIF / constructing tree from text lines in soulC / " ) ;
            countT cFieldsIn = soulLinesP ;
            boolT bNoRefs = !!( F(flagsP) & flBRANCHslOADf_NOrEFERENCES ) ;
            ZE( boolT , bFail ) ;

            TN( tmff , ""     ) ; tmff = T("")+S2(0xff,sc_MARK) ;
            TN( tme2 , ""     ) ; tme2 = T("")+S2(0x2e,sc_MARK) ;
            TN( tmd2 , ""     ) ; tmd2 = T("")+S2(0x2d,sc_MARK) ;
            TN( tmc2 , ""     ) ; tmc2 = T("")+S2(0x2c,sc_MARK) ;
            TN( tmb2 , ""     ) ; tmb2 = T("")+S2(0x2b,sc_MARK) ;
            TN( tma2 , ""     ) ; tma2 = T("")+S2(0x2a,sc_MARK) ;
            TN( tm92 , ""     ) ; tm92 = T("")+S2(0x29,sc_MARK) ;
            TN( tm82 , ""     ) ; tm82 = T("")+S2(0x28,sc_MARK) ;
            TN( tm72 , ""     ) ; tm72 = T("")+S2(0x27,sc_MARK) ;
            TN( tm62 , ""     ) ; tm62 = T("")+S2(0x26,sc_MARK) ;
            TN( tm52 , ""     ) ; tm52 = T("")+S2(0x25,sc_MARK) ;
            TN( tm42 , ""     ) ; tm42 = T("")+S2(0x24,sc_MARK) ;
            TN( tm32 , ""     ) ; tm32 = T("")+S2(0x23,sc_MARK) ;
            TN( tm22 , ""     ) ; tm22 = T("")+S2(0x22,sc_MARK) ;
            TN( tm12 , ""     ) ; tm12 = T("")+S2(0x21,sc_MARK) ;
            TN( tm02 , ""     ) ; tm02 = T("")+S2(0x20,sc_MARK) ;
            TN( tmf1 , ""     ) ; tmf1 = T("")+S2(0x1f,sc_MARK) ;
            TN( tme1 , ""     ) ; tme1 = T("")+S2(0x1e,sc_MARK) ;
            TN( tmd1 , ""     ) ; tmd1 = T("")+S2(0x1d,sc_MARK) ;
            TN( tmc1 , ""     ) ; tmc1 = T("")+S2(0x1c,sc_MARK) ;
            TN( tmb1 , ""     ) ; tmb1 = T("")+S2(0x1b,sc_MARK) ;
            TN( tma1 , ""     ) ; tma1 = T("")+S2(0x1a,sc_MARK) ;
            TN( tm91 , ""     ) ; tm91 = T("")+S2(0x19,sc_MARK) ;
            TN( tm81 , ""     ) ; tm81 = T("")+S2(0x18,sc_MARK) ;
            TN( tm71 , ""     ) ; tm71 = T("")+S2(0x17,sc_MARK) ;
            TN( tm61 , ""     ) ; tm61 = T("")+S2(0x16,sc_MARK) ;
            TN( tm51 , ""     ) ; tm51 = T("")+S2(0x15,sc_MARK) ;
            TN( tm41 , ""     ) ; tm41 = T("")+S2(0x14,sc_MARK) ;
            TN( tm31 , ""     ) ; tm31 = T("")+S2(0x13,sc_MARK) ;
            TN( tm21 , ""     ) ; tm21 = T("")+S2(0x12,sc_MARK) ;
            TN( tm11 , ""     ) ; tm11 = T("")+S2(0x11,sc_MARK) ;
            TN( tm01 , ""     ) ; tm01 = T("")+sttMark01 ;
            TN( tbz  , "\\z"  ) ; // ZIP FILE NAME
            TN( tby  , "\\y"  ) ; // MISCELLANEOUS FILE NAME
            TN( tbx  , "\\x"  ) ; // LONE PARAGRAPH: FOR THIS BRANCH'S PAGE, REDUCE MAX LEVEL BY 1 SO THAT ONLY A SINGLE PARAGRAPH OF THESIS SENTENCES APPEARS
            TN( tbw  , "\\w"  ) ; // SOIL FILE NAME
            TN( tbv  , "\\v"  ) ; // VIDEO MOVIE FILE NAME
            TN( tbu  , ""     ) ; // RESERVED
            TN( tbt  , "\\t"  ) ; // URL SCHOLARLY TREATISE
            TN( tbs  , "\\s"  ) ; // SNAPSHOT PHOTO FILE NAME
            TN( tbr  , "\\r"  ) ; // FLAG: RAW: DO NOT CAPITALIZE AND DO NOT APPEND A PERIOD
            TN( tbq  , ""     ) ; // RESERVED
            TN( tbp  , "\\p"  ) ; // TEXT PDF FILE NAME
            TN( tbo  , "\\o"  ) ; // URL OTHER
            TN( tbn  , "\\n"  ) ; // NULL
            TN( tbm  , "\\m"  ) ; // MARK
            TN( tbl  , "\\l"  ) ; // URL LAW
            TN( tbk  , "\\k"  ) ; // SUPPRESS KID PAGE
            TN( tbj  , ""     ) ; // RESERVED
            TN( tbi  , "\\i"  ) ; // ICON OR OTHER IMAGE FILE NAME (CONTENT EXPLICITLY SPECIFIED BY AUTHOR, IN CONTRAST TO THE ICONS THAT putFileIF USES AUTOMATICALLY E.G. TO INDICATE THE TYPE OF ANCHOR)
            TN( tbh  , "\\h"  ) ; // "HERE"
            TN( tbg  , "\\g"  ) ; // RESERVED (IF EVER NEED A "GO" MARK TO CAUSE INSERTION OF "#foo" TO GO TO THE ID MARK INSERTED IN OBEDIENCE TO \h
            TN( tbf  , "\\f"  ) ; // FILE NAME
            TN( tbe  , "\\e"  ) ; // TEXT EMAIL FILE NAME
            TN( tbd  , "\\d"  ) ; // SUPPRESS NEW PARAGRAPH
            TN( tbc  , "\\c"  ) ; // TEXT ASCII FILE NAME
            TN( tbb  , "\\\\" ) ;
            TN( tba  , "\\a"  ) ; // AUDIO FILE NAME
            TN( tb9  , "\\9"  ) ; // FLAG: INCLUDE IFF idEditionP == 9
            TN( tb8  , "\\8"  ) ; // FLAG: INCLUDE IFF idEditionP == 8
            TN( tb7  , "\\7"  ) ; // FLAG: INCLUDE IFF idEditionP == 7
            TN( tb6  , "\\6"  ) ; // FLAG: INCLUDE IFF idEditionP == 6
            TN( tb5  , "\\5"  ) ; // FLAG: INCLUDE IFF idEditionP == 5
            TN( tb4  , "\\4"  ) ; // FLAG: INCLUDE IFF idEditionP == 4
            TN( tb3  , "\\3"  ) ; // FLAG: INCLUDE IFF idEditionP == 3 
            TN( tb2  , "\\2"  ) ; // FLAG: INCLUDE IFF idEditionP == 2
            TN( tb1  , "\\1"  ) ; // FLAG: INCLUDE IFF idEditionP == 1
            TN( tb0  , "\\0"  ) ; // FLAG: INCLUDE IFF idEditionP == 0 (BRANCHES MARKED WITH THIS FLAG ARE COMMENTS SINCE idEditionP CANNOT BE 0)
            TN( tBackSlash , "\\"   ) ;
            TN( tBlank , " "   ) ;
            strokeS sttColon( ':' ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        {
        stackC  stCursor( tinP , etherP , TAG( TAGiDnULL ), flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY , ifcSTACKtYPE_countT ) ;
    {
    strokeS sttMark01( 0x10 , sc_MARK ) ;
    jotC jotReferences( tinP , "branchs.loadif.references" , flJOTc_WRITE | flJOTc_DELETE | flJOTc_PRIVATE ) ;
    /**/etherP.traceF( tinP , T("loadIF / +") ) ;

    _IO_

    // ----- CONSTRUCT A TREE OF branchS INSTANCES THAT CONTAINS INCOMPLETELY CONSTRUCTED REFERENCE BRANCHES

    }
        if( POOP ) return ;
        FV( flBRANCHslOADf , flagsP ) ;
        __Z( soulLinesP ) ;
        __NZ( csttTrimmedP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT branchS::loadIF( tinS& tinP , etherC& etherP , const boolT& bQuitP , jotC& jotP , countT& csttTrimmedP , soulC& soulLinesP , const flagsT flagsP , soulC* pSoulLinkP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

