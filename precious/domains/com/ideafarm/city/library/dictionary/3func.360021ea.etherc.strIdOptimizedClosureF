
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idHit ;

    if( bChatter ) traceF( tinP , T("returning [idHit,idFirstP:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idFirstP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    }
        }
            if( !idHit && pstMatchP ) pstMatchP->purgeF( tinP , cPlatesWas ) ;

            }
                }
                    patch_cNote   = ( - 1 ) ;
                    patch_idAdam  = ( - 1 ) ;

                    }
                        }
                            }
                                }
                                    }
                                        patch_cNote  -- ;
                                        patch_idAdam -- ;
                                    {
                                    else
                                    }
                                        patch_cNote  =   1 ;
                                        patch_idAdam = - 1 ;                                        // END BY IGNORING THE SUBEXPRESSION
                                    {
                                    if( patch_cNote == cMinMe )

                                        break ;
                                    if( patch_idAdam == - 1 || ( patch_idAdam == cMinMe && F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) )
                                {
                                else
                                }
                                    }
                                        if( cMaxMe < patch_idAdam ) break ;

                                        patch_cNote  ++ ;
                                        patch_idAdam ++ ;
                                    {
                                    else
                                    if( patch_idAdam == - 1 ) patch_idAdam = patch_cNote = cMinMe ;

                                        break ;
                                    if( patch_idAdam == cMaxMe )
                                {
                                else if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG )
                                }
                                    flagsMe = flagsMeSave ;
                                    restore_cNote  = restore_idAdam = - 1 ;
                                    patch_cNote  = restore_cNote   ;
                                    patch_idAdam = restore_idAdam  ;
                                {
                                else if( restore_idAdam != - 1 || restore_cNote != - 1 )
                                }
                                    patch_cNote = patch_idAdam = cLength - 1 ;   //ASSUME: THIS ASSUMES THAT WHAT IS BEING REPEATED IS OF LENGTH 1

                                    stTryLength >> cLength ;
                                    ZE( countT , cLength ) ;
                                {
                                if( stTryLength ) //CS:CODEsYNCH:PSEUDODUPLICATE 51012003 51012003
                                _IO_
                            {

                            idFirstP = idfSave ;

                                break ;
                            if( idHit && ( !idFirstP || !( F(flagsP) & flSTRiDoPTIMIZEDcLOSURE_NOlEFTOVERS ) ) )

                            }
                                else if( foth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("----    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb43+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                else if( reth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("----    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb42+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                else if( ooth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("----    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb41+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                     if( woth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("----    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            if( bChatter )
             
                            }
                                //U:: idHit = strIdOptimizedClosureF( tinP , pstMatchP , flagsMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , flagsP , pFlagsOverrideP ? ( ++ pFlagsOverrideP ) -- : 0 , pcMinOverrideP ? ( ++ pcMinOverrideP ) -- : 0 , pcMaxOverrideP ? ( ++ pcMaxOverrideP ) -- : 0 , idLastP , idP ) ;
                                idHit = strIdOptimizedClosureF( tinP , pstMatchP , flagsMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , flagsP , pFlagsOverrideP ? ( ++ pFlagsOverrideP ) -- : 0 , pcMinOverrideP ? ( ++ pcMinOverrideP ) -- : 0 , pcMaxOverrideP ? ( ++ pcMaxOverrideP ) -- : 0 , idLastP , idP ) ;
                                _IO_
                            {

                                  //strIdOptimizedClosureF( tinP , pstMatchP , flagsMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , flagsP , pFlagsOverrideP                                 , pcMinOverrideP                                , pcMaxOverrideP                                , idLastP , idP )
                                  //THE NEXT LINE SHOWS MY OWN PARAMETERS SO THAT THEY CAN BE EASILY COMPARED WITH WHAT I PASS AS ARGUMENTS TO THE RECURSION CALL

                            }
                                else if( foth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("++++    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb43+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                else if( reth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("++++    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb42+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                else if( ooth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("++++    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb41+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                     if( woth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("++++    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            if( bChatter )
                            ++ idCall ;

                            countT idfSave = idFirstP ;
                        {
                        for(;;)
                        _IO_
                    {
                    TN( tb43 , "                                                    " ) ;
                    TN( tb42 , "                                    " ) ;
                    TN( tb41 , "                    " ) ;
                    TN( tb4  , "    " ) ;
                    static countT idCall ;
                    ZE( countT , csttOptimal ) ;

                    }
                        patch_cNote = patch_idAdam = cLength - 1 ;   //ASSUME: THIS ASSUMES THAT WHAT IS BEING REPEATED IS OF LENGTH 1

                        stTryLength >> cLength ;
                        ZE( countT , cLength ) ;

                        }
                            restore_cNote  = patch_cNote  ;
                            restore_idAdam = patch_idAdam ;
                        {
                        if( restore_idAdam == - 1 && restore_cNote == - 1 )
                    {
                    if( stTryLength ) //CS:CODEsYNCH:PSEUDODUPLICATE 51012003 51012003
                    countT restore_cNote  = - 1 ;  // "
                    countT restore_idAdam = - 1 ;  //THIS IS THE PATCH REQUEST VALUE SO WILL NEVER OCCUR DURING PATCH OPTIMIZATION

                    else patch_idAdam = patch_cNote = cMaxMe ;                                  //MAXIMAL CLOSURE BEHAVIOR (WILL DECREASE THE LENGTH FROM THIS MAXIMUM UNTIL FIND A HIT
                    }
                        }
                            patch_cNote  =   1 ;
                            patch_idAdam = - 1 ;                                                // BEGIN BY IGNORING THE SUBEXPRESSION
                        {
                        else
                        if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) patch_cNote = patch_idAdam = cMinMe ;
                    {
                    if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG )                      //MINIMAL CLOSURE BEHAVIOR (WILL INCREASE THE LENGTH FROM THIS MINIMUM UNTIL FIND A HIT
                    _IO_
                {
                if( !POOP )

                delF( tinP , psttAfter ) ;
                delF( tinP , psttBefore ) ;

                }
                    }
                        }
                            flagsMe |= F(flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE) ;
                            flagsMeSave = flagsMe ;
                        {
                        if( stTryLength )

                        }
                            while( !stIdHitAfter.third && ~hDown ) ;
                            }
                                if( cLengthTry ) stTryLength << cLengthTry ;

                                countT cLengthTry = 1 + idTryLath - idTryWoth ;
                                countT idTryLath  = idHitAfter - 1 ;
                                countT idHitAfter = stIdHitAfter.downF( tinP , hDown ) ;
                            {
                            do
                            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                            countT idTryWoth = idHitBefore + psttBefore->idAdam ;
                            stIdHitBefore >> idHitBefore ;
                            ZE( countT , idHitBefore ) ;
                        {
                        while( stIdHitBefore )
                    {
                    else if( idBefore && idAfter )
                    }
                        }
                            flagsMe |= F(flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE) ;
                            flagsMeSave = flagsMe ;
                        {
                        if( stTryLength && !bTryIgnore )

                        }
                            else                            bTryIgnore = 1 ;
                            if( psttBigP->idAdam > idLath ) stTryLength << psttBigP->idAdam - idLath ;
                            countT idLath = idHit - 1 + psttBefore->idAdam ;

                            stIdHitBefore >> idHit ;
                            ZE( countT , idHit ) ;
                        {
                        while( stIdHitBefore )
                        ZE( boolT , bTryIgnore ) ;
                    {
                    else if( idBefore && !idAfter )
                    }
                        }
                            flagsMe |= F(flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE) ;
                            flagsMeSave = flagsMe ;
                        {
                        if( stTryLength && !bTryIgnore )

                        }
                            else            bTryIgnore = 1 ;
                            if( idHit > 1 ) stTryLength << idHit - 1 ;

                            stIdHitAfter >> idHit ;
                            ZE( countT , idHit ) ;
                        {
                        while( stIdHitAfter )
                        ZE( boolT , bTryIgnore ) ;
                    {
                    else if( !idBefore && idAfter )
                    }
                        flagsMe |= F(flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE) ;
                        flagsMeSave = flagsMe ;
                        stTryLength << psttBigP->idAdam ;
                    {
                    if( !idBefore && !idAfter )
                    _IO_
                {
                ZE( flagsT , flagsMeSave ) ;
                stackC stTryLength( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_countT ) ;

                }
                    while( idHit && idf ) ;
                    }
                        }
                            stIdHitAfter << idHit ;
                            if( bChatter ) traceF( tinP , T("after: found in big at [idHit]:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        if( idHit )
                        idHit = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , psttAfter , psttBigP , 0 , 1 ) ;
                    {
                    do
                    idf = 1 ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    ZE( countT , idHit ) ;

                    if( bChatter ) traceF( tinP , T("this is after the patch [idf,idl,string]:    ")+TF2(c2f.c1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(c2f.c2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttAfter) ) ;
                    strSubstringF( tinP , psttAfter , idf , idl , psttSmallP ) ; ___( psttAfter ) ;
                    countT idl = c2f.c2 ;
                    countT idf = c2f.c1 ;

                    count2S& c2f = *(count2S*)&stFixedSmall[ idAfter ] ;
                    _IO_
                {
                if( idAfter )
                stackC stIdHitAfter( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_countT ) ;
                ZE( strokeS* , psttAfter  ) ;

                }
                    while( idHit && idf ) ;
                    }
                        }
                            stIdHitBefore << idHit ;
                            if( bChatter ) traceF( tinP , T("before: found in big at [idHit,idLath]:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            countT idLath = idf ? idf - 1 : psttBigP->idAdam ;
                        {
                        if( idHit )
                        idHit = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , psttBefore , psttBigP , 0 , 1 ) ;
                    {
                    do
                    idf = 1 ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    ZE( countT , idHit ) ;

                    if( bChatter ) traceF( tinP , T("this is before the patch [idf,idl,string]:    ")+TF2(c2f.c1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(c2f.c2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttBefore) ) ;
                    strSubstringF( tinP , psttBefore , idf , idl , psttSmallP ) ; ___( psttBefore ) ;
                    countT idl = c2f.c2 ;
                    countT idf = c2f.c1 ;

                    count2S& c2f = *(count2S*)&stFixedSmall[ idBefore ] ;
                    _IO_
                {
                if( idBefore )
                stackC stIdHitBefore( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_countT ) ;
                ZE( strokeS* , psttBefore ) ;

                if( bChatter ) traceF( tinP , T("patch [idBefore,idAfter]:")+tb4+TF2(idBefore,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idAfter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                }
                    while( !stFixedSmall.third && ~hDown && !idAfter ) ;
                    }
                        else if(            c2f.c2   < idsPatch ) idBefore = idPlate ;
                             if( idsPatch < c2f.c1              ) idAfter  = idPlate ;

                        count2S& c2f = *(count2S*)&stFixedSmall.downF( tinP , hDown ) ;
                        ++ idPlate ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    ZE( countT , idPlate ) ;
                    TN( tb4 , "    " ) ;
                    _IO_
                {
                if( stFixedSmall )
                ZE( countT , idAfter ) ;
                ZE( countT , idBefore ) ;

                if( bChatter ) traceF( tinP , T("patch [idsPatch,flagsMe,cMinMe,cMaxMe]:")+tb4+TF2(idsPatch,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(flagsMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cMinMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cMaxMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                TN( tb4 , "    " ) ;

                ;
                    : psttBigP->idAdam - 1
                    ? *pcMaxOverrideP & ~BM_HIGH
                countT cMaxMe = pcMaxOverrideP && *pcMaxOverrideP && ( *pcMaxOverrideP & ~BM_HIGH ) < ( psttBigP->idAdam - 1 )          // "- 1" IS BECAUSE THIS IS MAX REPEAT COUNT TO TRY, AND "REPEAT COUNT" IS NET ( REPEATING 3 TIMES MEANS 4 CONSECUTIVE OCCURANCES

                ;
                    : 0
                    ? *pcMinOverrideP & ~BM_HIGH
                countT cMinMe = pcMinOverrideP && *pcMinOverrideP

                if( pcMaxOverrideP && *pcMaxOverrideP ) { __Z( *pcMaxOverrideP & BM_HIGH ) ; }      //ENFORCES THE USE OF BM_HIGH ; CODE WOULD WORK CORRECTLY WITHOUT THAT BIT EXCEPT WHEN THE VALUE 0 IS INTENDED AS A VALUE RATHER THAN AS A TRMINATOR ; SO ENFORCEMENT IS DONE TO PREVENT BUGS THAT ARE DIFFICULT TO ANALYZE
                if( pcMinOverrideP && *pcMinOverrideP ) { __Z( *pcMinOverrideP & BM_HIGH ) ; }      //ENFORCES THE USE OF BM_HIGH ; CODE WOULD WORK CORRECTLY WITHOUT THAT BIT EXCEPT WHEN THE VALUE 0 IS INTENDED AS A VALUE RATHER THAN AS A TRMINATOR ; SO ENFORCEMENT IS DONE TO PREVENT BUGS THAT ARE DIFFICULT TO ANALYZE

                //U::FV(flSTRiDoPTIMIZEDcLOSURE,flagsMe) ;

                ;
                    : flagsP
                    ? *pFlagsOverrideP
                flagsT flagsMe = pFlagsOverrideP && *pFlagsOverrideP

                ___( patch_cNote   - ( - 1 )        ) ;
                ___( patch_idCaste - sc_ccSSSrEPEAT ) ;
                ___( patch_idAdam  - ( - 1 )        ) ;

                countT& patch_cNote   = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].cNote   ;
                countT& patch_idCaste = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].idCaste ;
                countT& patch_idAdam  = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].idAdam  ;
                _IO_
            {
            else
            }
                }
                    idFirstP = idfSave ;
                    idHit = 0 ;
                {
                if( idHit && idFirstP && F(flagsP) & flSTRiDoPTIMIZEDcLOSURE_NOlEFTOVERS )
                idHit = strIdF( tinP , pstMatchP , flagsMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , idLastP , idP ) ;
                countT idfSave = idFirstP ;
            {
            if( !idsPatch )

            }
                else if(  woth_idsPatch != idsPatch &&  ooth_idsPatch != idsPatch &&  reth_idsPatch != idsPatch && !foth_idsPatch ) foth_idsPatch = idsPatch ;
                else if(  woth_idsPatch != idsPatch &&  ooth_idsPatch != idsPatch && !reth_idsPatch                               ) reth_idsPatch = idsPatch ;
                else if(  woth_idsPatch != idsPatch && !ooth_idsPatch                                                             ) ooth_idsPatch = idsPatch ;
                     if( !woth_idsPatch                                                                                           ) woth_idsPatch = idsPatch ;
            {
            if( idsPatch )
            static countT foth_idsPatch ;
            static countT reth_idsPatch ;
            static countT ooth_idsPatch ;
            static countT woth_idsPatch ;

            }
                }
                    }
                        break ;
                        idsPatch = idsIn ;
                    {
                    if( psttSmallP[ CSpREFIX - 1 + idsIn ] == sttPatchRequest )
                {
                else                                                  for( countT idsIn = 1                  ; idsIn <= psttSmallP->idAdam ; idsIn ++ )
                }
                    }
                        break ;
                        idsPatch = idsIn ;
                    {
                    if( psttSmallP[ CSpREFIX - 1 + idsIn ] == sttPatchRequest )
                {
                if( F(flagsP) & flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT ) for( countT idsIn = psttSmallP->idAdam ; idsIn                       ; idsIn -- )
                ZE( countT , offo ) ;
                strokeS sttPatchRequest( - 1 , sc_ccSSSrEPEAT , - 1 ) ;
            {
            ZE( countT , idsPatch ) ;

            countT cPlatesWas = pstMatchP ? *pstMatchP : 0 ;
            _IO_
        {
        if( bAllFixedFound )

        }
            while( !stFixedSmall.third && ~hDown ) ;
            }
                if( !bAllFixedFound ) break ;

                delF( tinP , psttd ) ;
                delF( tinP , psttf ) ;

                }
                    bAllFixedFound = 0 ;
                    if( bChatter ) traceF( tinP , T("a fixed small was not found, inspecting left to right, in big [text,dump]:    \"")+T(psttf)+T("\"    ")+T(psttd) ) ;
                {
                if( !idHit )
                countT idHit = strIdF( tinP , 0 , flSTRmATCH_null , idfBig , sttq , tWrapped , psttBigP , 0 , 1 ) ;

                TN( tWrapped , "" ) ; tWrapped = tn+S2(sa_SSSaND,sc_ccSSS)+T(psttf)+S2(sa_SSSaNDeND,sc_ccSSS) ;
                TN( tn , "" ) ;

                }
                    traceF( tinP , T("fixed small [idf,idl,text,dump]:    ")+TF2(c2f.c1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(c2f.c2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    \"")+T(psttf)+T("\"    ")+T(psttd) ) ;
                    strDumpStrokesIF( tinP , psttd , psttf ) ; ___( psttd ) ;
                {
                if( bChatter )

                ZE( strokeS* , psttd ) ;

                strSubstringF( tinP , psttf , idf , idl , psttSmallP ) ; ___( psttf ) ;
                countT idl = c2f.c2 ;
                countT idf = c2f.c1 ;
                ZE( strokeS* , psttf ) ;

                count2S& c2f = *(count2S*)&stFixedSmall.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idfBig = 1 ;
            TN( tb4 , "    " ) ;
            _IO_
        {
        if( stFixedSmall )
        boolT bAllFixedFound = 1 ;
        _IO_
    {                                                                               //U:: REMOVE THE OOTH TEST ; IT IS INCORRECT
    if( csttMin <= psttBigP->idAdam /*&& psttBigP->idAdam <= csttMax*/ )            // THE OOTH TEST IS DISABLED BECAUSE, LIKE OTHER strId FUNCTIONS, I LOOK FOR A MATCH *WITHIN* psttBigP
    ZE( countT , idHit ) ;

    strExpressionLengthMinMaxF( tinP , csttMin , csttMax , stFixedSmall , countTC( 1 ) , psttSmallP , flagsP , pFlagsOverrideP , pcMinOverrideP , pcMaxOverrideP ) ;
    ZE( countT , csttMax ) ;
    ZE( countT , csttMin ) ;
    stackC stFixedSmall( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB | flSTACKc_FIFO , 2 * sizeof( countT ) ) ;

    }
        delF( tinP , psttd ) ;
        traceF( tinP , T("pattern:    ")+T(psttd) ) ;
        strDumpStrokesIF( tinP , psttd , psttSmallP ) ; ___( psttd ) ;
        ZE( strokeS* , psttd ) ;
    {
    if( bChatter )

    boolT bChatter = 0 ; //0 IN PRODUCTION

    _IO_

    }
        if( POOP ) return 0 ;
        }
            __( F( pstMatchP->flagsF( tinP ) ) & flSTACKc_FIFO ) ; // IF FIFO THEN WILL CONTAIN INCORRECT CONTENTS
        {
        if( pstMatchP )
        __Z( psttBigP->idAdam ) ;
        __Z( psttSmallP->idAdam ) ;
        if( POOP ) return 0 ;
        __Z( idP ) ;
        //U::FV(flSTRiDoPTIMIZEDcLOSURE,flagsP) ;
        __Z( psttBigP ) ;
        __Z( psttSmallP ) ;
        __Z( idFirstP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/countT etherC::strIdOptimizedClosureF( tinS& tinP , stackC* const pstMatchP , const flagsT flagsMatchP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* psttSmallP , const strokeS* psttBigP , const flagsT flagsP , const flagsT* pFlagsOverrideP , const countT* pcMinOverrideP , const countT* pcMaxOverrideP , const countT idLastP , sCountT idP )/*1*/

/**/                                          
*/
  if 2, then caller wants the ooth match, etc.
  normally 1, which means that the caller wants the woth match in psttBigP
 idP
  this is the lath position that will be inspected when looking for a match
  the position in psttBigP to end the search
 idLastP
   the effect of that example is that a match requires either 0 occurrances or at most 8 occurrances, and minimal closure is done
    then 1, then 2, ... then 7, but no more, even if psttBigP is very long
    then 0 is tried
    ignore is tried
   example: BM_HIGH | 7 , flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG , not flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE:
  whether "ignore" is tried is not affected
   for example, if the element contains BM_HIGH | 7, then optimization will search only 7 or fewer repeats (8 or fewer occurances)
  the value of each element, ignoring the high bit, overrides the default repeat maximum (which is psttBigP->idAdam - 2)
  if not 0 then must point to a null terminated array of countT values, and each of these values must have the high bit set (using BM_HIGH)
  may be 0
 pcMaxOverrideP
   the effect of that example is that a match requires either 0 occurrances or at least 8 occurrances, and minimal closure is done
    then 8, then 9, then 0xa, ...
    then 7 is tried
    ignore is tried
   example: BM_HIGH | 7 , flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG , not flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE:
  whether "ignore" is tried is not affected
   for example, if the element contains BM_HIGH | 7, then optimization will search only 7 or more repeats (8 or more occurances)
  the value of each element, ignoring the high bit, overrides the default repeat minimum (which is 0)
  if not 0 then must point to a null terminated array of countT values, and each of these values must have the high bit set (using BM_HIGH)
  may be 0
 pcMinOverrideP
  for example, optimization of the woth "closure iteration" value encountered (normally the leftmost) is controlled by the woth element of the array
  all other valid flags override the corresponding flag in flagsP for the "closure iteration" occurance that corresponds to each element of the array
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT in these values is ignored (has no effect)
  if not 0 then must point to a null terminated array of flagsT values, and each of these nonze values must be a valid flSTRiDoPTIMIZEDcLOSURE constant
  may be 0
 pFlagsOverrideP
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT only changes the order in which the "closure iteration" strokeS's are iterated
  the match evaluation is always done left to right, i.e. from the beginning of psttSmallP to the end
   for simple searches, this search order does not affect the result
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT indicates that the leftmost occurance changes the most rapidly during the search
  controls how i search
 flagsP
  the string to search within
 psttBigP
   to optimize closure, i call myself recursively for each occurrance, and for each occurance, i try every "repeat value" in a range until i either match or exhaust the range
   the special stroke value is S3(-1,sc_ccSSSrEPEAT,-1)
   to be a regular expression, must begin with S2(sa_SSSaND,sc_ccSSS)
  normally, an IPDOS (tm) regular expression  
  if it does not contain a particular special strokeS value, then i am just a thin wrapper for strIdF
  a search specification string
 psttSmallP
  a quote strokeS to use to delimit literals, or strokeS( 0 , sc_IGNOREqUOTES )
 sttQuoteP
  this is the woth position that will be inspected when looking for a match
  the position in psttBigP to start the search
 idFirstP
 tinP
parameters
 in such a search, the '*' will match 0 or more of any character but will not consume literal matches that follow the '*' in the search string
for example, i am used to conduct searches semantically equivalent to the '*' wildcard in a windows file name search
if psttSmallP is an IPDOS (tm) regular expression that contains "closure iteration" values, then i call myself recursively to search for a match, using flags that specify how i am to search
if psttSmallP does not contain a special strokeS value that requests "closure iteration", then i am just a thin wraper for strIdF
i evaluate to the id of the woth strokeS in psttBigP that matches psttSmallP
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
