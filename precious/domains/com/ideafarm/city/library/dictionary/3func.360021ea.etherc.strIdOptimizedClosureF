
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idHit ;

    if( !idHit && pstMatchP ) pstMatchP->purgeF( tinP , cPlatesWas ) ;

    }
        }
            patch_cNote   = ( - 1 ) ;
            patch_idAdam  = ( - 1 ) ;

            }
                }
                    }
                        patch_cNote  -- ;
                        patch_idAdam -- ;
                    {
                    else
                    }
                        patch_cNote  =   1 ;
                        patch_idAdam = - 1 ;                                        // END BY IGNORING THE SUBEXPRESSION
                    {
                    if( patch_cNote == cMinMe )

                        break ;
                    if( patch_idAdam == - 1 || ( patch_idAdam == cMinMe && F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) )
                {
                else
                }
                    }
                        patch_cNote  ++ ;
                        patch_idAdam ++ ;
                    {
                    else
                    if( patch_idAdam == - 1 ) patch_idAdam = patch_cNote = cMinMe ;

                        break ;
                    if( patch_idAdam == cMaxMe )
                {
                if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG )

                idFirstP = idfSave ;

                    break ;
                if( idHit )                                                         //U:: TO FIND A BUG:  COMBINE THESE OO TESTS AND USE A SINGLE LINE

                idHit = strIdOptimizedClosureF( tinP , pstMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , flagsP , ( ++ pFlagsOverrideP ) -- , ( ++ pcMinOverrideP ) -- , ( ++ pcMaxOverrideP ) -- , idLastP , idP ) ;

                countT idfSave = idFirstP ;
            {
            for(;;)
            ZE( countT , csttOptimal ) ;

            else patch_idAdam = patch_cNote = cMaxMe ;                                  //MAXIMAL CLOSURE BEHAVIOR (WILL DECREASE THE LENGTH FROM THIS MAXIMUM UNTIL FIND A HIT
            }
                }
                    patch_cNote  =   1 ;
                    patch_idAdam = - 1 ;                                                // BEGIN BY IGNORING THE SUBEXPRESSION
                {
                else
                if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) patch_cNote = patch_idAdam = cMinMe ;
            {
            if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG )                      //MINIMAL CLOSURE BEHAVIOR (WILL INCREASE THE LENGTH FROM THIS MINIMUM UNTIL FIND A HIT
        {
        if( !POOP )

        ;
            : psttBigP->idAdam - 2
            ? *pcMaxOverrideP & ~BM_HIGH
        countT cMaxMe = pcMaxOverrideP && *pcMaxOverrideP

        ;
            : 0
            ? *pcMinOverrideP & ~BM_HIGH
        countT cMinMe = pcMinOverrideP && *pcMinOverrideP

        if( pcMaxOverrideP && *pcMaxOverrideP ) { __Z( *pcMaxOverrideP & BM_HIGH ) ; }      //ENFORCES THE USE OF BM_HIGH ; CODE WOULD WORK CORRECTLY WITHOUT THAT BIT EXCEPT WHEN THE VALUE 0 IS INTENDED AS A VALUE RATHER THAN AS A TRMINATOR ; SO ENFORCEMENT IS DONE TO PREVENT BUGS THAT ARE DIFFICULT TO ANALYZE
        if( pcMinOverrideP && *pcMinOverrideP ) { __Z( *pcMinOverrideP & BM_HIGH ) ; }      //ENFORCES THE USE OF BM_HIGH ; CODE WOULD WORK CORRECTLY WITHOUT THAT BIT EXCEPT WHEN THE VALUE 0 IS INTENDED AS A VALUE RATHER THAN AS A TRMINATOR ; SO ENFORCEMENT IS DONE TO PREVENT BUGS THAT ARE DIFFICULT TO ANALYZE

        //U::FV(flSTRiDoPTIMIZEDcLOSURE,flagsMe) ;

        ;
            : flagsP
            ? *pFlagsOverrideP
        flagsT flagsMe = pFlagsOverrideP && *pFlagsOverrideP

        ___( patch_cNote   - ( - 1 )        ) ;
        ___( patch_idCaste - sc_ccSSSrEPEAT ) ;
        ___( patch_idAdam  - ( - 1 )        ) ;

        countT& patch_cNote   = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].cNote   ;
        countT& patch_idCaste = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].idCaste ;
        countT& patch_idAdam  = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].idAdam  ;

        countT& patch_cNoteB   = *(countT*)&psttSmallP[ CSpREFIX - 1 + 0xb ].cNote   ;
        countT& patch_idCasteB = *(countT*)&psttSmallP[ CSpREFIX - 1 + 0xb ].idCaste ;
        countT& patch_idAdamB  = *(countT*)&psttSmallP[ CSpREFIX - 1 + 0xb ].idAdam  ;
        //U:: TO FIND A BUG

        countT& patch_cNote2   = *(countT*)&psttSmallP[ CSpREFIX - 1 + 2 ].cNote   ;
        countT& patch_idCaste2 = *(countT*)&psttSmallP[ CSpREFIX - 1 + 2 ].idCaste ;
        countT& patch_idAdam2  = *(countT*)&psttSmallP[ CSpREFIX - 1 + 2 ].idAdam  ;
        //U:: TO FIND A BUG
    {
    else
    if( !idsPatch ) idHit = strIdF( tinP , pstMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , idLastP , idP ) ;
    ZE( countT , idHit ) ;

    }
        }
            }
                break ;
                idsPatch = idsIn ;
            {
            if( psttSmallP[ CSpREFIX - 1 + idsIn ] == sttPatchRequest )
        {
        else                                                  for( countT idsIn = 1                  ; idsIn <= psttSmallP->idAdam ; idsIn ++ )
        }
            }
                break ;
                idsPatch = idsIn ;
            {
            if( psttSmallP[ CSpREFIX - 1 + idsIn ] == sttPatchRequest )
        {
        if( F(flagsP) & flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT ) for( countT idsIn = psttSmallP->idAdam ; idsIn                       ; idsIn -- )
        ZE( countT , offo ) ;
        strokeS sttPatchRequest( - 1 , sc_ccSSSrEPEAT , - 1 ) ;
    {
    ZE( countT , idsPatch ) ;

    countT cPlatesWas = pstMatchP ? *pstMatchP : 0 ;

    }
        if( POOP ) return 0 ;
        __Z( psttBigP->idAdam ) ;
        __Z( psttSmallP->idAdam ) ;
        if( POOP ) return 0 ;
        __Z( idP ) ;
        //U::FV(flSTRiDoPTIMIZEDcLOSURE,flagsP) ;
        __Z( psttBigP ) ;
        __Z( psttSmallP ) ;
        __Z( idFirstP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/countT etherC::strIdOptimizedClosureF( tinS& tinP , stackC* pstMatchP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* psttSmallP , const strokeS* psttBigP , const flagsT flagsP , const flagsT* pFlagsOverrideP , const countT* pcMinOverrideP , const countT* pcMaxOverrideP , const countT idLastP , sCountT idP )/*1*/

/**/                                          
*/
  if 2, then caller wants the ooth match, etc.
  normally 1, which means that the caller wants the woth match in psttBigP
 idP
  this is the lath position that will be inspected when looking for a match
  the position in psttBigP to end the search
 idLastP
   the effect of that example is that a match requires either 0 occurrances or at most 8 occurrances, and minimal closure is done
    then 1, then 2, ... then 7, but no more, even if psttBigP is very long
    then 0 is tried
    ignore is tried
   example: BM_HIGH | 7 , flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG , not flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE:
  whether "ignore" is tried is not affected
   for example, if the element contains BM_HIGH | 7, then optimization will search only 7 or fewer repeats (8 or fewer occurances)
  the value of each element, ignoring the high bit, overrides the default repeat maximum (which is psttBigP->idAdam - 2)
  if not 0 then must point to a null terminated array of countT values, and each of these values must have the high bit set (using BM_HIGH)
  may be 0
 pcMaxOverrideP
   the effect of that example is that a match requires either 0 occurrances or at least 8 occurrances, and minimal closure is done
    then 8, then 9, then 0xa, ...
    then 7 is tried
    ignore is tried
   example: BM_HIGH | 7 , flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG , not flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE:
  whether "ignore" is tried is not affected
   for example, if the element contains BM_HIGH | 7, then optimization will search only 7 or more repeats (8 or more occurances)
  the value of each element, ignoring the high bit, overrides the default repeat minimum (which is 0)
  if not 0 then must point to a null terminated array of countT values, and each of these values must have the high bit set (using BM_HIGH)
  may be 0
 pcMinOverrideP
  for example, optimization of the woth "closure iteration" value encountered (normally the leftmost) is controlled by the woth element of the array
  all other valid flags override the corresponding flag in flagsP for the "closure iteration" occurance that corresponds to each element of the array
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT in these values is ignored (has no effect)
  if not 0 then must point to a null terminated array of flagsT values, and each of these nonze values must be a valid flSTRiDoPTIMIZEDcLOSURE constant
  may be 0
 pFlagsOverrideP
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT only changes the order in which the "closure iteration" strokeS's are iterated
  the match evaluation is always done left to right, i.e. from the beginning of psttSmallP to the end
   for simple searches, this search order does not affect the result
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT indicates that the leftmost occurance changes the most rapidly during the search
  controls how i search
 flagsP
  the string to search within
 psttBigP
   to optimize closure, i call myself recursively for each occurrance, and for each occurance, i try every "repeat value" in a range until i either match or exhaust the range
   the special stroke value is S3(-1,sc_ccSSSrEPEAT,-1)
   to be a regular expression, must begin with S2(sa_SSSaND,sc_ccSSS)
  normally, an IPDOS (tm) regular expression  
  if it does not contain a particular special strokeS value, then i am just a thin wrapper for strIdF
  a search specification string
 psttSmallP
  a quote strokeS to use to delimit literals, or strokeS( 0 , sc_IGNOREqUOTES )
 sttQuoteP
  this is the woth position that will be inspected when looking for a match
  the position in psttBigP to start the search
 idFirstP
 tinP
parameters
 in such a search, the '*' will match 0 or more of any character but will not consume literal matches that follow the '*' in the search string
for example, i am used to conduct searches semantically equivalent to the '*' wildcard in a windows file name search
if psttSmallP is an IPDOS (tm) regular expression that contains "closure iteration" values, then i call myself recursively to search for a match, using flags that specify how i am to search
if psttSmallP does not contain a special strokeS value that requests "closure iteration", then i am just a thin wraper for strIdF
i evaluate to the id of the woth strokeS in psttBigP that matches psttSmallP
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
