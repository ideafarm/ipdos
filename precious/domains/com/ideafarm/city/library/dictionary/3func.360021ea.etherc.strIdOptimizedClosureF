
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idHit ;

    }
        }
            patch_cNote   = ( - 1 ) ;
            patch_idAdam  = ( - 1 ) ;

            }
                }
                    }
                        patch_cNote  -- ;
                        patch_idAdam -- ;
                    {
                    else
                    }
                        patch_cNote  =   1 ;
                        patch_idAdam = - 1 ;                                        // END BY IGNORING THE SUBEXPRESSION
                    {
                    if( !patch_cNote )

                        break ;
                    if( patch_idAdam == - 1 || ( !patch_idAdam && F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) )
                {
                else
                }
                    }
                        patch_cNote  ++ ;
                        patch_idAdam ++ ;
                    {
                    else
                    if( patch_idAdam == - 1 ) patch_idAdam = patch_cNote = 0 ;

                        break ;
                    if( patch_idAdam == psttBigP->idAdam - 2 )
                {
                if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG )

                idFirstP = idfSave ;

                    break ;
                if( idHit )                                                         //U:: TO FIND A BUG:  COMBINE THESE OO TESTS AND USE A SINGLE LINE

                idHit = strIdOptimizedClosureF( tinP , idFirstP , sttQuoteP , psttSmallP , psttBigP , flagsP , ( ++ pFlagsOverrideP ) -- , idLastP , idP ) ;

                countT idfSave = idFirstP ;
            {
            for(;;)
            ZE( countT , csttOptimal ) ;

            else patch_idAdam = patch_cNote = psttBigP->idAdam - 2 ;                //MAXIMAL CLOSURE BEHAVIOR (WILL DECREASE THE LENGTH FROM THIS MAXIMUM UNTIL FIND A HIT
            }
                }
                    patch_cNote  =   1 ;
                    patch_idAdam = - 1 ;                                                // BEGIN BY IGNORING THE SUBEXPRESSION
                {
                else
                if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) patch_cNote = patch_idAdam = 0 ;
            {
            if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG )                   //MINIMAL CLOSURE BEHAVIOR (WILL INCREASE THE LENGTH FROM THIS MINIMUM UNTIL FIND A HIT
        {
        if( !POOP )

        //U::FV(flSTRiDoPTIMIZEDcLOSURE,flagsMe) ;

        ;
            : flagsP
            ? *pFlagsOverrideP
        flagsT flagsMe = pFlagsOverrideP && *pFlagsOverrideP

        ___( patch_cNote   - ( - 1 )        ) ;
        ___( patch_idCaste - sc_ccSSSrEPEAT ) ;
        ___( patch_idAdam  - ( - 1 )        ) ;

        countT& patch_cNote   = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].cNote   ;
        countT& patch_idCaste = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].idCaste ;
        countT& patch_idAdam  = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].idAdam  ;

        countT& patch_cNoteB   = *(countT*)&psttSmallP[ CSpREFIX - 1 + 0xb ].cNote   ;
        countT& patch_idCasteB = *(countT*)&psttSmallP[ CSpREFIX - 1 + 0xb ].idCaste ;
        countT& patch_idAdamB  = *(countT*)&psttSmallP[ CSpREFIX - 1 + 0xb ].idAdam  ;
        //U:: TO FIND A BUG

        countT& patch_cNote2   = *(countT*)&psttSmallP[ CSpREFIX - 1 + 2 ].cNote   ;
        countT& patch_idCaste2 = *(countT*)&psttSmallP[ CSpREFIX - 1 + 2 ].idCaste ;
        countT& patch_idAdam2  = *(countT*)&psttSmallP[ CSpREFIX - 1 + 2 ].idAdam  ;
        //U:: TO FIND A BUG
    {
    else
    if( !idsPatch ) idHit = strIdF( tinP , idFirstP , sttQuoteP , psttSmallP , psttBigP , idLastP , idP ) ;
    ZE( countT , idHit ) ;

    }
        }
            }
                break ;
                idsPatch = idsIn ;
            {
            if( psttSmallP[ CSpREFIX - 1 + idsIn ] == sttPatchRequest )
        {
        else                                                  for( countT idsIn = 1                  ; idsIn <= psttSmallP->idAdam ; idsIn ++ )
        }
            }
                break ;
                idsPatch = idsIn ;
            {
            if( psttSmallP[ CSpREFIX - 1 + idsIn ] == sttPatchRequest )
        {
        if( F(flagsP) & flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT ) for( countT idsIn = psttSmallP->idAdam ; idsIn                       ; idsIn -- )
        ZE( countT , offo ) ;
        strokeS sttPatchRequest( - 1 , sc_ccSSSrEPEAT , - 1 ) ;
    {
    ZE( countT , idsPatch ) ;

    }
        if( POOP ) return 0 ;
        __Z( psttBigP->idAdam ) ;
        __Z( psttSmallP->idAdam ) ;
        if( POOP ) return 0 ;
        __Z( idP ) ;
        //U::FV(flSTRiDoPTIMIZEDcLOSURE,flagsP) ;
        __Z( psttBigP ) ;
        __Z( psttSmallP ) ;
        __Z( idFirstP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/countT etherC::strIdOptimizedClosureF( tinS& tinP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* psttSmallP , const strokeS* psttBigP , const flagsT flagsP , const flagsT* pFlagsOverrideP , const countT idLastP , sCountT idP )/*1*/

/**/                                          
*/
  if 2, then caller wants the ooth match, etc.
  normally 1, which means that the caller wants the woth match in psttBigP
 idP
  this is the lath position that will be inspected when looking for a match
  the position in psttBigP to end the search
 idLastP
  for example, optimization of the woth "closure iteration" value encountered (normally the leftmost) is controlled by the woth element of the array
  all other valid flags override the corresponding flag in flagsP for the "closure iteration" occurance that corresponds to each element of the array
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT in these values is ignored (has no effect)
  if not 0 then must point to a null terminated array of flagsT values, and each of these nonze values must be a valid flSTRiDoPTIMIZEDcLOSURE constant
  may be 0
 pFlagsOverrideP
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT only changes the order in which the "closure iteration" strokeS's are iterated
  the match evaluation is always done left to right, i.e. from the beginning of psttSmallP to the end
   for simple searches, this search order does not affect the result
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT indicates that the leftmost occurance changes the most rapidly during the search
  controls how i search
 flagsP
  the string to search within
 psttBigP
   to optimize closure, i call myself recursively for each occurrance, and for each occurance, i try every "repeat value" in a range until i either match or exhaust the range
   the special stroke value is S3(-1,sc_ccSSSrEPEAT,-1)
   to be a regular expression, must begin with S2(sa_SSSaND,sc_ccSSS)
  normally, an IPDOS (tm) regular expression  
  if it does not contain a particular special strokeS value, then i am just a thin wrapper for strIdF
  a search specification string
 psttSmallP
  a quote strokeS to use to delimit literals, or strokeS( 0 , sc_IGNOREqUOTES )
 sttQuoteP
  this is the woth position that will be inspected when looking for a match
  the position in psttBigP to start the search
 idFirstP
 tinP
parameters
 in such a search, the '*' will match 0 or more of any character but will not consume literal matches that follow the '*' in the search string
for example, i am used to conduct searches semantically equivalent to the '*' wildcard in a windows file name search
if psttSmallP is an IPDOS (tm) regular expression that contains "closure iteration" values, then i call myself recursively to search for a match, using flags that specify how i am to search
if psttSmallP does not contain a special strokeS value that requests "closure iteration", then i am just a thin wraper for strIdF
i evaluate to the id of the woth strokeS in psttBigP that matches psttSmallP
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
