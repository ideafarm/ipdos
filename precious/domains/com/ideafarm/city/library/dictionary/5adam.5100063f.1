
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    display.set_pDeviceCBF_F( tinP , pDeviceNewCBF , cArgNew , pDeviceOldCBF , cArgOld ) ;
    ZE( countT     , cArgNew       ) ;
    ZE( deviceCBFT , pDeviceNewCBF ) ;

    etherC::loafIF( tinP ) ;

    display.set_pDeviceCBF_F( tinP , pDeviceOldCBF , cArgOld , deviceCBF , (countT)&eye ) ;
    ZE( countT     , cArgOld       ) ;
    ZE( deviceCBFT , pDeviceOldCBF ) ;

    display += eye ;

    eye += surf ;

    }
        eye.moveF( tinP , vDeltaAt , aBad , aBad , aBad ) ;
        vectorOldC vDeltaAt( tinP , etThread ) ;
        }
            aBad = 0 ;
            //aBad = PI * 5.0 / 4.0 ;
            aBad = etThread.strDigitsToMeasureF( tinP , tStr , 0 , 0 ) ;
            TN( tStr , "100+^e65191.-" ) ;
        {
        ZE( measureT , aBad ) ;
    {
    eyeC eye( tinP , etThread ) ;

    surf += paper ;
    surfC surf( tinP , etThread , 0 , surfaceCBF , (countT)&sin ) ;
    surfS sin ;

    displayC& display = *pDisplay ;
{
if( pDisplay )
displayC* pDisplay = displayC::pDisplayIF() ;

}
    etThread.delF( tinP , psttSay ) ;
    paper.strokeF( tinP , psttSay ) ;

    #endif


        }
            scSize += DELTA ;

            APPENDcc( psttSay , sc_ccLINEpEL ,   scSize , - scSize ) ;
            APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_ORANGE , 0 ) ;
            APPENDcc( psttSay , sc_ccLINEpEL ,   0      , - scSize ) ;
            APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_BROWN , 0 ) ;
            APPENDcc( psttSay , sc_ccLINEpEL , - scSize , - scSize ) ;
            APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_C4 , 0 ) ;
            APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ;
            APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_P4 , 0 ) ;
            APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   scSize ) ;
            APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_Y4 , 0 ) ;
            APPENDcc( psttSay , sc_ccLINEpEL ,   0      ,   scSize ) ;
            APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_B4 , 0 ) ;
            APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   scSize ) ;
            APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_G4 , 0 ) ;
            APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;
            APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_R4 , 0 ) ;

            APPENDcc( psttSay , sc_ccMOVEpEL , - ( DELTA >> 1 ) , - ( DELTA >> 1 ) ) ;
        {
        while( cDo -- )
        sCountT scSize = SIZE ;
        APPENDmm( psttSay , sc_mmMOVEtO  , 0.5 , 0.5 ) ;
        countT cDo = 0x8 ;

    #else

        APPENDmm( psttSay , sc_mmLINEtO , 0.0 , 0.0 ) ;
        APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_Y4 , 0 ) ;
        APPENDmm( psttSay , sc_mmLINEtO , 0.0 , 1.0 ) ;
        APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_B4 , 0 ) ;
        APPENDmm( psttSay , sc_mmLINEtO , 1.0 , 1.0 ) ;
        APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_G4 , 0 ) ;
        APPENDmm( psttSay , sc_mmLINEtO , 1.0 , 0.0 ) ;
        APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_R4 , 0 ) ;
        APPENDmm( psttSay , sc_mmMOVEtO , 0.0 , 0.0 ) ;

    #if defined( NEVERdEFINED )

    APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;
    APPENDcc( psttSay , sc_cPUSHiDgRID , 3 , 0 ) ;

    etThread.strMakeF( tinP , LF , psttSay , 0 , TOCK ) ; ___( psttSay ) ;
    ZE( strokeS* , psttSay ) ;
{
paperC paper( tinP , etThread , TUCK , TUCK ) ;

TODO

#define SIZE ( TUCK >> 1 )
#define DELTA 0x40

}
    return 0 ;

    }
        }
            break ;

            tinP.pEther->etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
            eye.moveF( tinP , vDeltaAt , - PI / ( TUCK << 2 ) , - PI / ( TUCK << 2 ) , - PI / ( TUCK << 2 ) ) ;
            tinP.pEther->etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
            vectorOldC vDeltaAt( tinP , *tinP.pEther ) ;

            eyeC& eye = *(eyeC*)cArgP ;
        {
        case ifcIDeVENTdEVICEc_TICK :
    {
    switch( idEventP )
{
countT deviceCBF( tinS& tinP , deviceC& deviceP , const countT idEventP , const countT cArgP )

}
    toP.z += sinP.oz ;
    toP.y += sinP.oy ;
    toP.x += sinP.ox ;
    // SHIFTING

    toP.z *= sinP.sz ;
    toP.y *= sinP.sy ;
    toP.x *= sinP.sx ;
    // SCALING

    }
        toP.z = - mx * tinP.brcm04Raw + mz * m1 ;
        toP.x =   mx * m1 + mz * tinP.brcm04Raw ;
        
        BOSmEASURE04( WHATgbo , sin( sinP.ah ) )
        measure04T m1 = tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , cos( sinP.ah ) )

        measureT mz = toP.z ;
        measureT mx = toP.x ;
    {
    // HEADING

    }
        toP.z =   my * tinP.brcm04Raw + mz * m1 ;
        toP.y =   my * m1 - mz * tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , sin( - sinP.ae ) )
        measure04T m1 = tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , cos( - sinP.ae ) )

        measureT mz = toP.z ;
        measureT my = toP.y ;
    {
    // ELEVATION

    }
        toP.z = 0.0 ;
        toP.y = - rx * tinP.brcm04Raw + ry * m1 ;
        toP.x =   rx * m1 + ry * tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , sin( sinP.ab ) )
        measure04T m1 = tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , cos( sinP.ab ) )
    {
    // BANK

    measureT ry = (sCountT)( fromP.y - sinP.cy ) ;
    measureT rx = (sCountT)( fromP.x - sinP.cx ) ;

    surfS& sinP = *(surfS*)cArgP ;

    TINSL
{
voidT surfaceCBF( mPoint3S& toP , const cPoint2S& fromP , const countT cArgP )

;
}
    }
    {
    ab( 0.0 )
    ae( 0.0 ) ,
    ah( 0.0 ) ,
    sz( 1.0 ) ,
    sy( 1.0 ) ,
    sx( 1.0 ) ,
    oz( TUCK ) ,
    oy( 0 ) ,
    ox( 0 ) ,
    cy( 0 ) ,
    cx( 0 ) ,
    inline surfS( voidT ) :

    measureT ab ; //"a":"angle" ; "b":"bank"
    measureT ae ; //"a":"angle" ; "e":"elevation"
    measureT ah ; //"a":"angle" ; "h":"heading"

    measureT sz ;
    measureT sy ;
    measureT sx ; //"s":"scale"

    sCountT oz ;
    sCountT oy ;
    sCountT ox ; //"o":"origin"

    countT cy ;
    countT cx ; //"c":"center" 
{
struct surfS

/*1*/WAKEsHOW( "tool.benchmark.drawing.speed" )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

