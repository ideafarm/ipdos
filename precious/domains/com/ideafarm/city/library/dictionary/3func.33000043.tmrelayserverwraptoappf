
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmRelayServerWrapToAppF )
}
    }
        }
            }
                etThread.delF( tinP , pc2WrapRef ) ;
                etThread( tinP , *(soulC**)&pc2WrapRef->c1 ) ;
            {
            if( 1 == decv02AM( pc2WrapRef->c2 ) )

            }
                }
                    }
                        bQuitP = 1 ;
                        etThread.traceF( tinP , T("could not write soul") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    psoP->writeF( tinP , *(soulC*)pc2WrapRef->c1 ) ;
                    scoopC scoop( tinP , LF , psoP->etherF( tinP ) ) ;
                    etThread.traceF( tinP , T("writing soul") ) ;

                    }
                        }
                            idPortTimeC idptOrigin = idPortTimeC::fieldF( tinP , sWrap , ifcIDfIELDwRAP_IDPToRIGIN ) ;
                        {
                        if( idType == ifcIDtYPEwRAP_GIFT )
                        countT idType = sWrap.cFieldF( tinP , ifcIDfIELDwRAP_IDtYPE ) ;
                        soulC& sWrap = *(soulC*)pc2WrapRef->c1 ;
                    {
                    //CONoUTrAW( "tmRelayServerWrapToAppF: trapping a bug\r\n" ) ;
                    //U::TO TRAP A BUG

                    //if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATORrEGISTRATION ) { CONoUTrAW( "tmRelayServerWrapToAppF: survived filters; writing to client\r\n" ) ; } //U::
                {
                if( bWrite )
    
                }
                    stChannelExcludeP.ungrabF( tinP ) ;
                    }
                        while( !stChannelExcludeP.third && ~hDown ) ;
                        }
                            }
                                break ;
                                bWrite = 0 ;
                            {
                            if( !etThread.strCompareF( tinP , pczChannel , pczTest , 0 , ccTestMax , pcFilter , ccFilter ) )
        
                            countT   ccFilter  =             pc4c->c4 ;
                            countT*& pcFilter  = *(countT**)&pc4c->c3 ;
                            countT   ccTestMax =             pc4c->c2 ;
                            countT*& pczTest   = *(countT**)&pc4c->c1 ;
                            count4S*& pc4c = *(count4S**)&stChannelExcludeP.downF( tinP , hDown ) ;
                        {
                        do
                        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( stChannelExcludeP )
                    stChannelExcludeP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( bWrite )
    
                stChannelIncludeP.ungrabF( tinP ) ;
                }
                    while( !stChannelIncludeP.third && ~hDown ) ;
                    }
                        }
                            break ;
                            bWrite = 1 ;
                        {
                        if( !etThread.strCompareF( tinP , pczChannel , pczTest , 0 , ccTestMax , pcFilter , ccFilter ) )
    
                        countT   ccFilter  =             pc4c->c4 ;
                        countT*& pcFilter  = *(countT**)&pc4c->c3 ;
                        countT   ccTestMax =             pc4c->c2 ;
                        countT*& pczTest   = *(countT**)&pc4c->c1 ;
                        count4S*& pc4c = *(count4S**)&stChannelIncludeP.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    bWrite = 0 ;
                {
                if( stChannelIncludeP )
                stChannelIncludeP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                boolT bWrite = 1 ;

                //if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATORrEGISTRATION ) { CONoUTrAW( "tmRelayServerWrapToAppF: this push is on the mediator reg channel\r\n" ) ; } //U::
    
                countT* pczChannel = (countT*)((soulC*)pc2WrapRef->c1)->pbFieldF( tinP , countTC() , countTC() , countTC() , ifcIDfIELDwRAP_CHANNEL ) ;
            {
            if( !bQuitP )

            stWrapRefP >> *(countT*)&pc2WrapRef ;
            ZE( count2S* , pc2WrapRef ) ;
        {
        while( stWrapRefP )

        if( bQuitP ) break ;
            { tinP.pEther->traceF( tinP , T("tmRelayServerWrapToAppF: see a push for ifcIDaDAM_CONSOLE") ) ; }
        if( idAdamClient == ifcIDaDAM_CONSOLE )
        stWrapRefP.waitF( tinP ) ;
    {
    while( !ether && !bQuitP && !etThread && !stWrapRefP.third )

    countT        idAdamClient         =                 pTaskP->c6 ;
    stackC&       stChannelExcludeP    =       *(stackC*)pTaskP->c5 ;
    stackC&       stChannelIncludeP    =       *(stackC*)pTaskP->c4 ;
    stackC&       stWrapRefP           =       *(stackC*)pTaskP->c3 ;
    socketC*&     psoP                 =     *(socketC**)pTaskP->c2 ;
    boolT&        bQuitP               =        *(boolT*)pTaskP->c1 ;    
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
/*1*/TASK( tmRelayServerWrapToAppF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

