
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


    }
        if( tinP.fingerprint ) ;                                                        \
                                                                                        \
        }                                                                               \
            }                                                                           \
                break ;                                                                 \
                slP << value ;                                                          \
            {                                                                           \
            case ifcIDcMDbASE_CMDdEFAULT :                                              \
            }                                                                           \
                break ;                                                                 \
                slP.flags = save ;                                                      \
                slP << (baseSoilXxxxC*)this ;                                           \
                slP.flags &= ~( F(flSOUL_LIVE) ) ;                                      \
                flagsT save = slP.flags ;                                               \
            {                                                                           \
            case ifcIDcMDbASE_REFERENCE :                                               \
            }                                                                           \
                break ;                                                                 \
            {                                                                           \
            case ifcIDcMDbASE_TOCK :                                                    \
            }                                                                           \
                break ;                                                                 \
            {                                                                           \
            case ifcIDcMDbASE_TICK :                                                    \
            }                                                                           \
                break ;                                                                 \
                slP << (strokeS*)T(#classP) ;                                           \
            {                                                                           \
            case ifcIDcMDbASE_CLASSnAME :                                               \
        {                                                                               \
        switch( idCmdBase )                                                             \
        slP >> idCmdBase ;                                                              \
        ZE( countT , idCmdBase ) ;                                                    \
                                                                                        \
        }                                                                               \
            if( pMeI != (baseSoilXxxxC*)this ) { BLAMMO ; }                             \
            slP >> pMeI ;                                                               \
            ZE( baseSoilXxxxC* , pMeI ) ;                                             \
        {                                                                               \
    {                                                                                   \
    voidT classP::operator ()( tinS& tinP , soulC& slP )                                \
                                                                                        \
    }                                                                                   \
        return *this ;                                                                  \
        if( slP ) ;                                                                     \
    {                                                                                   \
    const baseSoilXxxxC& classP::operator >>( soulC& slP ) const                        \
                                                                                        \
    }                                                                                   \
        return *this ;                                                                  \
        if( slP ) ;                                                                     \
    {                                                                                   \
    baseSoilXxxxC& classP::operator >>( soulC& slP )                                    \
                                                                                        \
    }                                                                                   \
        return *this ;                                                                  \
        if( slP ) ;                                                                     \
    {                                                                                   \
    baseSoilXxxxC& classP::operator <<( soulC& slP )                                    \
                                                                                        \
    }                                                                                   \
        return value ;                                                                  \
    {                                                                                   \
    classP::operator typeP( voidT )                                                     \
                                                                                        \
    }                                                                                   \
        return *this ;                                                                  \
        value = valueP ;                                                                \
    {                                                                                   \
    classP& classP::operator =( const typeP valueP )                                    \
                                                                                        \
    }                                                                                   \
        }                                                                               \
            }                                                                           \
                tinP.pEther->memCopyF( tinP , *(osTextT**)&postName , postNameP , 1 + costName ) ;   \
                tinP.pEther->newF( tinP , LF , *(osTextT**)&postName , 1 + costName ) ; ___( postName ) ; \
                countT costName = thirdC::c_strlenIF( tinP , postNameP ) ;              \
            {                                                                           \
            if( tinP.pEther )                                                           \
            TINSL                                                                       \
        {                                                                               \
        if( postNameP )                                                                 \
    {                                                                                   \
    value( 0 )                                                                          \
    postName( 0 ) ,                                                                     \
    baseSoilXxxxC( postOldClassNameI , postName ) ,                                     \
    classP::classP( const osTextT* const postNameP ) :                                  \
                                                                                        \
    NEWdELcLASSb( classP )                                                              \
                                                                                        \
    static const osTextT* const classP::postOldClassNameI = #classP ;                   \
                                                                                        \
#define VARIABLEfUNCTIONdEFS(classP,typeP)                                              \

// IF _INoLD_ _OUT_ ARE ADDED TO THESE FUNCTION DEFS, NULL this WILL NOT BE DETECTED BECAUSE "VARIABLEfUNCTIONdEFS" MUST BE INVOKED IN A 3func.34* SOURCE FILE (BECAUSE I REFERENCE NEWdELcLASSb, WHICH DEFINES NONMEMBER FUNCTIONS)

/*1*//*VARIABLEfUNCTIONdEFS*//*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

