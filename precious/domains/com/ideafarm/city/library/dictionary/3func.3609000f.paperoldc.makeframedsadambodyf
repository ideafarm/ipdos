
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    tinP.pAdamGlobal5->frPaper.grab.ungrabF( tinP ) ;


                                                          ether.strFuseF( tinP , psttFramedP ,    S2(0,scOld_POPrENDERsTROKEoVERRIDE) ) ;                                       //AAAA-
                                                          ether.strFuseF( tinP , psttFramedP ,    S3(0.0,scOld_mmMOVEpELtO,0.0) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,    S2(0,scOld_cOVERRIDEnEXTsTROKE) ) ;                                           //BBBB-
                                                          ether.strFuseF( tinP , psttFramedP ,        S2(0,scOld_POPfRAME) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,            S2(0,scOld_POPoFFfRAME) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,            S2(0,scOld_POPfRAME) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,                S2(0,scOld_POPfRAMEdETACH) ) ;
    }
                                                          ether.strFuseF( tinP , psttFramedP ,                S2(0,scOld_POPrIPPLES) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,                S2(0,scOld_POPrIPPLESoNLYoFFoN) ) ;
    {
    if( !bPee )
    }
                                                          ether.strFuseF( tinP , psttFramedP ,                S2(0,scOld_POPcOLOR) ) ;
    {
    if( !( sadamP.features.fc.rgbFrame & 0xff000000 ) )
                                                          ether.strFuseF( tinP , psttFramedP ,                S2(0,scOld_POPsIDES) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,                S3(0.0,scOld_mmLINEtO,0.0) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,                S3(0.0,scOld_mmLINEtO,1.0) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,                S3(1.0,scOld_mmLINEtO,1.0) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,                S3(1.0,scOld_mmLINEtO,0.0) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,                S3(0.0,scOld_mmMOVEtO,0.0) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,                S2(sadamP.pStrike->sc.cSidesFrame,scOld_cPUSHsIDES) ) ;
    }
                                                          ether.strFuseF( tinP , psttFramedP ,                S2(sadamP.features.fc.rgbFrame,scOld_cPUSHcOLOR) ) ;
    {
    if( !( sadamP.features.fc.rgbFrame & 0xff000000 ) )
    }
                                                          ether.strFuseF( tinP , psttFramedP ,                S2(0,scOld_PUSHrIPPLESoNLYoN) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,                S2(0,scOld_cPUSHrIPPLES) ) ;
    {
    if( !bPee )
                                                          ether.strFuseF( tinP , psttFramedP ,                S2(0,scOld_FRAMEdETACH) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,            S3(mColsHot-1.0,scOld_mmFRAMEpEL,mRowsHot-1.0) ) ;                        //FRAME TO WHERE I WANT THE FRAME RECTANGLE TO BE
                                                          ether.strFuseF( tinP , psttFramedP ,            S3(mColsToHot-mColsLeft,scOld_mmMOVEpEL,mRowsToHot-mRowsDown) ) ;                             //MOVE TO LOWER LEFT CORNER OF FRAME
                                                          ether.strFuseF( tinP , psttFramedP ,            S3(0.0,scOld_mmMOVEpELtO,0.0) ) ;                                         //MOVE TO LOWER LEFT CORNER OF FRAME
                                                          ether.strFuseF( tinP , psttFramedP ,            S2(2,scOld_cOVERRIDEnEXTsTROKE) ) ;                                       //AAAA
                                                          ether.strFuseF( tinP , psttFramedP ,            S2(0,scOld_PUSHoVERRIDEcOLrOW) ) ;                                        //BBBB+  (POSITION AFTER RENDERING BODY)
                                                          ether.strFuseF( tinP , psttFramedP ,            psttBodyP ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,            S2(0,scOld_PUSHoVERRIDEcOLrOW) ) ;                                        //AAAA+  (POSITION BEFORE RENDERING BODY)
                                                          ether.strFuseF( tinP , psttFramedP ,            S2(0,scOld_cPUSHoFFfRAME) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,        S2(0,scOld_POPfRAMEdETACH) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,    S3(1.0,scOld_mmFRAMEtO,1.0) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,    S3(0.0,scOld_mmMOVEtO,0.0) ) ;
                                                          ether.strFuseF( tinP , psttFramedP ,    S2(0,scOld_FRAMEdETACH) ) ;
                                                          //RELATIVE FRAME (0 IS CURRENT):        ?   ?   0   1
                                                          //                                      |       |   |
                                                          //                                      |       |   +ENCLOSUREfRAME
                                                          //                                      |       +COPYoFtARGETfRAME
                                                          //                                      +TARGETfRAME


    boolT bPee = !!( F(sadamP.features.fc.flagsFrame) & flFEATUREsADAMfRAME_PEEoN ) ;

    sadamP.pStrike->sc.cSidesFrame = CpOLYGONsIDESdEFAULT * ( psttBodyP->idAdam ? psttBodyP->idAdam : 1 ) ;
    ether.strMakeF( tinP , psttFramedP , 0 , psttBodyP->idAdam + 0x27 ) ; ___( psttFramedP ) ;

    //LOGrAW( tSay ) ;
    //tSay = TF1(sadamP.features.fc.idAdam)+T(": HOT RECTANGLE COLUMNS: ")+TF1(sadamP.pStrike->sc.mIdColHot)+T(" for ")+TF1(sadamP.pStrike->sc.mColsHot)+T(" cols\r\n") ;
 
    //LOGrAW( tSay ) ; //U::
    //TN( tSay , "" ) ; tSay = T("RENDER 2: set sadamP.pStrike->sc.mIdRowHot to ")+TF1(sadamP.pStrike->sc.mIdRowHot)+T("\r\n") ;

    sadamP.pStrike->sc.mRowsHot   = mRowsHot  ;
    sadamP.pStrike->sc.mColsHot   = mColsHot  ;
    sadamP.pStrike->sc.mIdRowHot -= mRowsDown ;
    sadamP.pStrike->sc.mIdColHot -= mColsLeft ;

    measureT mRowsToHot = sadamP.pStrike->sc.mIdRowHot - sf.mIdRow ;
    measureT mColsToHot = sadamP.pStrike->sc.mIdColHot - sf.mIdCol ; // FOR GLYPHS SUCH AS 'i', THE HOT AREA IS AT AN OFFSET UPWARD AND RIGHTWARD FROM THE LOWER LEFT CORNER OF THE STROKING FRAME
    const strokingFrameS& sf = sadamP.pStrike->sc.pPaper->sfF( tinP , 0 ) ;

    measureT mRowsHot  = sadamP.pStrike->sc.mRowsHot + mRowsDown + mRowsUp    ;
    measureT mColsHot  = sadamP.pStrike->sc.mColsHot + mColsLeft + mColsRight ;

    measureT mRowsUp    = mRowsEach * ( 1 + cFrameNestUpP    ) ;
    measureT mColsRight = mColsEach * ( 1 + cFrameNestRightP ) ;

    measureT mRowsDown  = mRowsEach * ( 1 + cFrameNestDownP  ) ;
    measureT mColsLeft  = mColsEach * ( 1 + cFrameNestLeftP  ) ;

    measureT mRowsEach = 1.0 + sadamP.pStrike->sc.mRowsMarginSadamFrame ;
    measureT mColsEach = 1.0 + sadamP.pStrike->sc.mColsMarginSadamFrame ;
    
    sadamP.pStrike->sc.mRowsMarginSadamFrame = x1.pPulp->rCache.mRowsMarginSadamFrame ;
    sadamP.pStrike->sc.mColsMarginSadamFrame = x1.pPulp->rCache.mColsMarginSadamFrame ;

    tinP.pAdamGlobal5->frPaper.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        if( POOP ) return ;
        __( psttFramedP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT paperOldC::makeFramedSadamBodyF( tinS& tinP , strokeS*& psttFramedP , sadamC& sadamP , const strokeS* const psttBodyP , const countT cFrameNestDownP , const countT cFrameNestLeftP , const countT cFrameNestUpP , const countT cFrameNestRightP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

