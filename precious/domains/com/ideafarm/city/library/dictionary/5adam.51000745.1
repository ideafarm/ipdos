
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS5bOOKbYhASHbYTE3 napped") ) ;
        ++ s ; ether.osSleepF( tinP , TOCK << 2 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE3 napping [cIn,cOut]:    ")+TF2(cIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        while( !ether && ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                THREADmODE1rESTORE
                }
                    etThread.traceF( tinP , T("all workers are gone") ) ;
                    }
                        ++ s ; etThread.osSleepF( tinP , TOCK ) ;
                    {
                    while( ws.cWorkers )
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    etThread.traceF( tinP , T("waiting for workers") ) ;
                    ws.bFireWorkers = 1 ;

                    THREADmODE1rESTORE
                    }
                        }
                            }
                                ++ s ; etThread.osSleepF( tinP , TOCK >> 3 ) ;
                                etThread.traceF( tinP , T("waiting for queue to shrink [cPending]:    ")+TF2(ws.st_pPageEvent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            while( ws.st_pPageEvent > CwORKERS )
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {                                                         // QUEUE LENGTH SHOULD ALSO BE KEPT SMALL FOR QUIT QUALITY, SINCE ALL QUEUED EVENTS MUST BE PROCESSED BEFORE I CAN DIE
                        if( ws.st_pPageEvent > ( CwORKERS << 1 ) )                // THE QUEUE LENGTH MUST BE SMALL SO THAT IT IS IMPOSSIBLE FOR A QUEUED ITEM TO BE IN A BOOK OTHER THAN THE BOOK IMMEDIATELY PRECEDING THE BOOK BEING READ, ASSUMING THAT I ONLY KEEP WO INACTIVE BOOK

                        bPrefix = !bPrefix ;

                        else          pbi = 0 ;
                        if( bDelete ) PUSE( tinP , *(byteT**)&pbi ) ;

                        ;
                            : sizeof( countT )
                            ? *(countT*)pbi
                        cbi = bPrefix

                        }
                            //if( ws.idIn < TUCK || !( ws.idIn % TUCK ) ) etThread.traceF( tinP , T("[ws.idIn,cOutputFlavors]:    ")+TF2(ws.idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ws.swBooksByByte.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            ++ ws.idIn ;
                            cIn ++ ;
                            ws.st_pPageEvent << *(countT*)&pPageEvent ;

                            __( (countT)*pPageEvent - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                            }
                                break ;
                                hRead = hReadSave ;
                                cbi = cbiSave ;

                                THREADmODE3rESTORE
                                DEL( pPageEvent ) ;
                                THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                                BLAMMO ;                                                //SHOULD BE IMPOSSIBLE SINCE "ALL OR NONE" USED FOR WRITING BOOKTOGETHER AND I'VE ALREADY READ THE PREFIX
                            {
                            if( !(const byteT*)*pPageEvent )

                            THREADmODE3rESTORE
                            bksAccessEventsIn.readF( tinP , *pPageEvent , hRead , flBOOKScrEAD_null , 0 , &hCursor , idCursor ) ;
                            pPageEvent = new( 0 , tinP , LF ) pageC( tinP , bksAccessEventsIn , cbi ) ; ___( pPageEvent ) ;
                            THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                            ZE( pageC* , pPageEvent ) ;
                        {
                        else
                        }
                            __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                            }
                                break ;
                                hRead = hReadSave ;
                                cbi = cbiSave ;
                            {
                            if( !pbi )
                            bDelete = bksAccessEventsIn.readF( tinP , pbi , cbi , hRead , flBOOKScrEAD_STILLhUNGRYiSoK , 0 , &hCursor , idCursor ) ;
                        {
                        if( bPrefix )
                        ZE( boolT , bDelete ) ;

                        HANDLEaPPnOTEScOUNTcLASS ch = hRead ;

                        handleC hReadSave = hRead ;
                        countT cbiSave = cbi ;
                    {
                    while( !bQuit && !POOP )
                    boolT bPrefix = 1 ;
                    countT cbi = sizeof( countT ) ;
                    ZE( const byteT* , pbi ) ;

                    // *****************************************************************************************************************************************************************************************************************************************************
                    // *****************************************************************************************************************************************************************************************************************************************************
                    // ********                    *************************************************************************************************************************************************************************************************************************
                    // ********  EAT BOOK ENTRIES  *************************************************************************************************************************************************************************************************************************
                    // ********                    *************************************************************************************************************************************************************************************************************************
                    // *****************************************************************************************************************************************************************************************************************************************************
                    // *****************************************************************************************************************************************************************************************************************************************************

                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                    handleC hCursor( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKSrEADcURSOR ) ;
                    handleC hRead( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
                    //etThread.traceF( tinP , T("sort by byte / enering loop to read events") ) ;

                    }
                        etThread.osThreadF( tinP , countTC() , tmWorkerF , 0 , flTHREADlAUNCH_INHERITjOTrEGISTRATIONS , TOCK , (countT)&ws , (countT)&bksAccessEventsIn ) ;
                        inc02AM( ws.cWorkers ) ;
                    {
                    while( cDo -- )
                    countT cDo = CwORKERS ;
                    //etThread.traceF( tinP , T("sort by byte / launching workers") ) ;

                    workS ws( tinP , etThread ) ;
                    //etThread.traceF( tinP , T("sort by byte / ct ws") ) ;

                    TN( tb4 , "    " ) ;
                    booksC bksAccessEventsIn( tinP , TAG( TAGiDnULL ) , tShorter , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_null , 0 , 1 , 0 , 0 , 0 , 0 , &bQuit ) ;
                    //etThread.traceF( tinP , T("sort by byte / ct bksAccessEvents") ) ;

                    }
                        etThread.delF( tinP , psttCursor2 ) ;
                        etThread.delF( tinP , psttCursor1 ) ;
                        idCursor = BM_HIGH | etThread.strDigitsToSCountF( tinP , psttCursor1 , 0 , 0 ) << 8 | etThread.strDigitsToSCountF( tinP , psttCursor2 , 0 , 0 ) ;
                        //etThread.traceF( tinP , T("[psttCursor2]:    ")+T(psttCursor2) ) ;
                        //etThread.traceF( tinP , T("[psttCursor1]:    ")+T(psttCursor1) ) ;

                        etThread.strWordF( tinP , psttCursor2 , tShorter , sttq , strokeS( '.' ) , 5 , 0 ) ; ___( psttCursor2 ) ;
                        etThread.strWordF( tinP , psttCursor1 , tShorter , sttq , strokeS( '.' ) , 4 , 0 ) ; ___( psttCursor1 ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        ZE( strokeS* , psttCursor2 ) ;
                        ZE( strokeS* , psttCursor1 ) ;
                    {
                    ZE( countT , idCursor ) ;

                    //etThread.traceF( tinP , T("[tShorter]:    ")+tShorter ) ;

                    }
                        etThread.delF( tinP , psttShorter ) ;
                        tShorter = T(psttShorter) ;
                        etThread.delF( tinP , psttnu ) ;
                        etThread.strBisectF( tinP , psttShorter , psttnu , tShort , tDot , 6 , flSTRbISECT_null ) ; ___( psttShorter ) ; ___( psttnu ) ;
                        ZE( strokeS* , psttnu ) ;
                        ZE( strokeS* , psttShorter ) ;
                    {
                    TN( tShorter , "" ) ;            // bksAccessEvents.3.hash12.00.00.accessEvents

                    //etThread.traceF( tinP , T("[tShort]:    ")+tShort ) ;

                    }
                        etThread.delF( tinP , psttShort ) ;
                        tShort = T(psttShort) ;
                        etThread.delF( tinP , psttnu ) ;
                        etThread.strBisectF( tinP , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShort , "" ) ;            // bksAccessEvents.3.hash12.00.00.accessEvents.booksC.1.book.00000001.00000001.bookC
                {
                if( !bDir )
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;

                TN( tIfoName , pInfo->psttIfoName ) ;
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tLike ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    {
    while( !bQuit && !POOP )
    const boolT& bQuit = *(const boolT*)&(const countT&)ether ;

    ZE( countT , idIn ) ;
    TN( tDot , "." ) ;
    TN( tSlash , "/" ) ;
    TN( tLike , "" ) ; tLike = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/")+tUser+T("/" ifcSTR( ifcIDmEMORYsPACE_APPLICATION ) "/stateSpaces/ffffefff/bksAccessEvents.3.hash12.??.??.accessEvents.booksC.1.book.00000001.00000001.bookC") ;
    TN( tUser , thirdC::postUserNameIF() ) ;
{

ether.ifcHireF( tinP , T("ifcIDaDAM_ACCESSeVENTS5bOOKbYhASHbYTE3") , ifcIDaDAM_ACCESSeVENTS6bOOKbYcONTAINERuRI , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

TODO

DONE( tmWorkerF )
}
    dec02AM( wsP.cWorkers ) ;
    _OUT_

    }
        _OUT_
        }
            _OUT_
            THREADmODE1rESTORE
            }
                _OUT_
                wsP.st_pPageEvent.ungrabF( tinP ) ;
                }
                    _OUT_
                    wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    }
                        _OUT_
                        THREADmODE3rESTORE
                        DEL( pPageEvent ) ;
                        THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )

                        }
                            }
                                _OUT_

                                wsP.swBooksByByte.ungrabF( tinP ) ;

                                inc02AM( cOut ) ;

                                booksOut.writeF( tinP , (byteT*)&cbo , sizeof cbo , WS( sBookEntryInOut ) , flBOOKScwRITE_ALLOWoDDlENGTH | flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ELSEfILLtOeND , 0 ) ;
                                countT cbo = sBookEntryInOut.cbF( tinP ) ;

                                //etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS5bOOKbYhASHbYTE3: writing an event") ) ;

                                booksC& booksOut = *(booksC*)&(countT&)wsP.swBooksByByte ;

                                }
                                    }
                                        booksC* pBooks = new( 0 , tinP , pba , sizeof( booksC ) ) booksC( tinP , TAG( TAGiDnULL ) , tBooksOut , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER , TOCK >> 2 ) ; ___( pBooks ) ; // ">> 4" IS TOO SMALL FOR AN EVENT THAT NEEDS MORE THAN DOUBLE

                                        TN( tBooksOut , "" ) ; tBooksOut = T("bksAccessEvents.4.hash123.")+TF3(cByteIn1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,2)+tDot+TF3(cByteIn2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,2)+tDot+TF3(wsP.lever_cByte,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,2)+T(".accessEvents") ;
                                    {
                                    if( !POOP )

                                    __Z( pba ) ;
                                    byteT* pba = (byteT*)&(countT&)wsP.swBooksByByte ;
                                {
                                if( !wsP.swBooksByByte.idSlotOfLeverF( tinP , wsP.lever_cByte ) )
                                wsP.lever_cByte = hashUri >> 0x10 & 0xff ;
                                wsP.swBooksByByte.grabF( tinP , TAG( TAGiDnULL ) ) ;

                                inc02AM( wsP.pczTallyByDuck[ timeW2 >> 8 & 0xff ] ) ;

                                _INoLD_
                            {
                            else
                            if( getNegAM( finger ) != FINGERnEG_ACCESSeVENTiDjOTfORmOstsTRINGS || idFormat != 1 ) etThread.traceF( tinP , T("unexpected format [finger,idFormat]:    ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            sCountT timeW2   = sBookEntryInOut.cFieldF( tinP , 4 ) ;
                            countT  hashUri  = sBookEntryInOut.cFieldF( tinP , 3 ) ;
                            countT  idFormat = sBookEntryInOut.cFieldF( tinP , 2 ) ;
                            countT  finger   = sBookEntryInOut.cFieldF( tinP , 1 ) ;

                            }
                                etThread.delF( tinP , pbPageCopy ) ;
                                }
                                    sBookEntryInOut.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbPageCopy , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;

                                    bksAccessEventsP.unlockF( tinP ) ;
                                    etThread.memCopyF( tinP , pbPageCopy , pbzPage , cbzPage ) ;
                                    const byteT* pbzPage = *pPageEvent ;
                                    bksAccessEventsP.lockF( tinP , TAG( TAGiDnULL ) ) ;
                                {
                                if( !POOP )

                                __Z( pbPageCopy ) ;
                                etThread.newF( tinP , LF , pbPageCopy , cbzPage ) ; ___( pbPageCopy ) ;
                                ZE( byteT* , pbPageCopy ) ;

                                countT cbzPage = *pPageEvent ;
                            {
                            soulC sBookEntryInOut( tinP , TAG( TAGiDnULL ) ) ;
                        {

                        _INoLD_
                    {
                    if( pPageEvent )

                    wsP.st_pPageEvent.ungrabF( tinP ) ;
                    wsP.st_pPageEvent >> *(countT*)&pPageEvent ;
                    ZE( pageC* , pPageEvent ) ;
                    _INoLD_
                {
                while( wsP.st_pPageEvent )
                wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;

                _INoLD_
            {
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            _INoLD_
        {
        else
        }
            //etThread.traceF( tinP , T("napped") ) ;
            ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //etThread.traceF( tinP , T("napping") ) ;

            if( wsP.bFireWorkers ) break ;
        {
        if( !wsP.st_pPageEvent )
        _INoLD_
    {
    while( !etThread && !POOP )

    //etThread.traceF( tinP , T("[cByteIn1,cByteIn2]:    ")+TF2(cByteIn1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cByteIn2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    }
        etThread.delF( tinP , pstt1w ) ;
        }
            }
                break ;
                cByteIn2 = etThread.strDigitsToSCountF( tinP , psttc1 , 0 , 1 ) ;
            {
            else if( idw == 5 )
            }
                cByteIn1 = etThread.strDigitsToSCountF( tinP , psttc1 , 0 , 1 ) ;
            {
            if( ++ idw == 4 )
        {
        FORsTRINGSiN1( pstt1w )
        ZE( countT , idw ) ;
        etThread.strWordsF( tinP , pstt1w , tNameShort , sttq , tDot ) ; ___( pstt1w ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , pstt1w ) ;

        //etThread.traceF( tinP , T("[tNameShort]:    ")+tNameShort ) ;

        TN( tNameShort , bksAccessEventsP.postNameShortF() ) ;
    {
    ZE( countT , cByteIn2 ) ;
    ZE( countT , cByteIn1 ) ;
    TN( tDot , "." ) ;
    TN( tb4 , "    " ) ;

    booksC& bksAccessEventsP = *(booksC*)pTaskP->c2 ;
    workS&  wsP              =  *(workS*)pTaskP->c1 ;
    _INoLD_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )

}
    }
        __Z( pczTallyByDuck ) ;
        etherP.delF( tinP , pcZe ) ;
        }
            bkTallyByDuck.readF( tinP , *(const byteT**)&pczTallyByDuck , cbzi , offi ) ;
            ZE( countT , offi ) ;
            countT cbzi = cbZe ;

            bkTallyByDuck.writeF( tinP , flResult , (byteT*)pcZe , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLoRnONE ) ; //FORMATS IFF NOT YET FORMATTED
            countT cb1 = cbZe ;
            ZE( flagsT , flResult ) ;

            thirdC::c_memsetIF( tinP , (byteT*)pcZe , cbZe ) ;
            const countT cbZe = sizeof( countT ) * TUCK ;
        {
        if( pcZe )
        etherP.newF( tinP , LF , pcZe , TUCK ) ; ___( pcZe ) ;
        ZE( countT* , pcZe ) ;
    {                               // INITIALIZE bkTallyByDuck
{
swBooksByByte(            tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , lever_cByte , 0 , sizeof( booksC ) , ifcIDgRABlAYER_7BASEmISC3 )
lever_cByte( 0 ) ,
sws_idJotContainerByHash( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , leverHashContainer , flSTACKc_null , ifcSTACKtYPE_countT , ifcIDgRABlAYER_7BASEmISC3 ) ,
leverHashContainer( 0 ) ,
idOut( 0 ) ,
idIn( 0 ) ,
cWorkers( 0 ) ,
bFireWorkers( 0 ) ,
st_pPageEvent( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_countT ) ,

pczTallyByDuck( 0 ) ,
bkTallyByDuck( tinP , TAG( TAGiDnULL ) , "bkTallyByDuck" , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE , sizeof( countT ) * TUCK ) ,

jhsOther(      tinP , "jotAccessEvents.hash.string.other"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [STRING]; WO JOT PER UNIQUE STRING
jhsBrowser(    tinP , "jotAccessEvents.hash.string.browser" , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsQuery(      tinP , "jotAccessEvents.hash.string.query"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsUri(        tinP , "jotAccessEvents.hash.string.uri"     , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
workS::workS( tinS& tinP , etherC& etherP ) :

}
    swBooksByByte.ungrabF( tinP ) ;

    //tinP.pEther->traceF( tinP , T("destroyed  all output books [idOut,cFlavors,heap.cNew-cDel]:    ")+TF2(idOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(processGlobal3S::_processGlobal3I_IF().heap.cNewF()-processGlobal3S::_processGlobal3I_IF().heap.cDelF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    swBooksByByte.freeAllF( tinP ) ;

    }
        //tinP.pEther->traceF( tinP , T("destroying a book [idf,cFlavors]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        //tinP.pcUtility[ 0 ] -- ; //U:: TO FIND A BUG
        DELzOMBIE( pBooks ) ;
        //tinP.pcUtility[ 0 ] ++ ; //U:: TO FIND A BUG
        booksC* pBooks = (booksC*)&(countT&)swBooksByByte ;
        lever_cByte = swBooksByByte.leverF( tinP , idf ) ;
        //tinP.pEther->traceF( tinP , T("destroying a book [idf,cFlavors]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )

    //tinP.pEther->traceF( tinP , T("destroying all output books [idOut,cFlavors]:    ")+TF2(idOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    countT cFlavors = swBooksByByte.cFlavorsF( tinP ) ;

    swBooksByByte.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT workS::destroyBooksF( tinS& tinP )

}
    destroyBooksF( tinP ) ;
    TINSL
{
workS::~workS( voidT )

countT cOut ;
countT cIn ;

;
}
    voidT destroyBooksF( tinS& tinP ) ;
    workS( tinS& tinP , etherC& etherP ) ;
    ~workS( voidT ) ;

    switchC       swBooksByByte ;
    countT        lever_cByte ;

    switchStackC  sws_idJotContainerByHash ;
    countT        leverHashContainer ;

    countT        idOut ;
    countT        idIn ;
    countT        cWorkers ;
    boolT         bFireWorkers ;

    stackC        st_pPageEvent ;

    countT*       pczTallyByDuck ;
    bookC         bkTallyByDuck ;

    jotC          jhsOther   ;
    jotC          jhsBrowser ;
    jotC          jhsQuery   ;          //CS:CODEsYNC: 73a 740 (THESE MUST BE CT IN THE SAME ORDER SO THAT THE SAME TAG VALES ARE ASSIGNED
    jotC          jhsUri     ;          // EVERY JOT INSTANCE CONTAINS HASH PREFIXED STRINGS TO KEEP CODE SIMPLE EVEN THOUGH THE HASH IS NOT USEFUL FOR THE STRINGS IN jhsOther
{
struct workS

#define CwORKERS        ( TUCK >> 4 )

//I AM STEP 3: INPUT: BYTE2 SORT; OUTPUT: BYTE3 SORT

/*1*/WAKEhIDE( "ifcIDaDAM_ACCESSeVENTS5bOOKbYhASHbYTE3" )/*1*/
/**/
*/
 if this happens, all page books must be manually deleted and then regenerated (by editing my code to make me enabled during the initial reading)
 it is critically important to never fire me when new events have been booked but i have not yet "page booked" them
 i enable myself only after reading all existing booked events, when i nap for the woth time
during initialization, i assume that all existing booked events have already been "page booked' and ignore them
 on output, each access event is written to a book dedicated to the corresponding idJot pair that identifies [container] [uri]
 the idJot values identify strings that i place into jotC instances
 on output, each access event soulC contains idJot values rather than string values
 on input, each access event soulC is self sufficient in that it contains string values
i "divide and conquer" by distributing access events to a dedicated booksC instance for each hash of [container] || [uri]
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
