
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    sDone_tmJobDoerMake.waitF( tinP ) ;
    sDone_tmJobDoerQuick.waitF( tinP ) ;

    }
        etThread = 0 ;
        }
            }
                }
                    else                                        sJobsQuick << pc8Job ;
                    if( pc8Job->c2 == ifcCMDsERVICEwINDOW_make ) sJobsMake  << pc8Job ;
                    pc8Job->c8 = ++ idJobLast ;
                    *(nicNameC&)&pc8Job->c4 = idhPeer ;
                    pc8Job->c3 = cmd.c3 ;
                    pc8Job->c2 = cmd.c2 ;
                    pc8Job->c1 = cmd.c1 ;
                {
                if( pc8Job )
                etThread.newF( tinP , LF , pc8Job ) ; ___( pc8Job ) ;
                ZE( count8S* , pc8Job ) ;
            {
            if( !ether )

            }
                DEL( pso ) ;
                __( sizeof cmd - pso->readF( tinP , (byteT*)&cmd , sizeof cmd ) ) ;

                { ZE( countT , idpPeer ) ; pso->peerNameF( tinP , idpPeer , idhPeer ) ; }
            {
            else
            }
                break ;
                DEL( pso ) ;
            {
            if( ether || etThread )
            nicNameC idhPeer ;
            count3S cmd ;
            socket.acceptF( tinP , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            ZE( socketC* , pso ) ;
        {
        while( !ether && !etThread )
        socket.listenF( tinP ) ;
        countT idPort = socket.bindF( tinP , ifcPORToLD1cOMMAND ) ;
        socketC socket( tinP , etThread , TAG( TAGiDnULL ) ) ;
    {
    while( !ether && !etThread )
    ZE( countT , idJobLast ) ;
    etThread.etherCryF( tinP ) ;

    { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmJobDoerF , &sDone_tmJobDoerQuick , flTHREADlAUNCH_null , 0 , (countT)&sJobsQuick ) ; }
    { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmJobDoerF , &sDone_tmJobDoerMake  , flTHREADlAUNCH_null , 0 , (countT)&sJobsMake  ) ; }
    signC  sDone_tmJobDoerQuick( tinP , TAG( TAGiDnULL ) ) ;
    signC  sDone_tmJobDoerMake( tinP , TAG( TAGiDnULL ) ) ;
    stackC sJobsQuick( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_count8S ) ;
    stackC sJobsMake( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_count8S ) ;

    etThread.strokeF( tinP , T("IdeaFarm " "(tm) City Servant\r\ni obey commands\r\n") ) ;
{
else
}
    etThread.strokeF( tinP , T("Another ")+textIdFileC(tinP,DDNAME)+T(" appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tinP , TAG( TAGiDnULL ) , T("4e30104") ) ;

TODO

DONE( tmJobDoerF )
}
    }
        }
            }
                etThread = 0 ;
                etThread.delF( tinP , pc8Job ) ;
                etThread.delF( tinP , psttPrefix ) ;
                etThread.delF( tinP , psttParameter ) ;

                }
                    }
                        break ;
                    {
                    default :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_qmall :
                    }
                        break ;

                        //etThread.osSessionF( tinP , countTC() , pid , T("///d/ideafarm.work/backed.up.never/gen/exe/01000020.ipdos-we") , T("6c30104") , 100 , 100 , 600 , 300 ) ;
                        ZE( countT , pid ) ;

                        }
                            etThread.delF( tinP , psttp ) ;
                            etThread = 0 ;
                            etThread.diskMoveFileOrDirF( tinP , t7use , T("///d/ideafarm.work/backed.up.never/gen/exe/")+T(psttp)+T(".ipdos-wd") ) ;
                            etThread = 0 ;
                            etThread.diskFileOrDirDeleteF( tinP , t7use , flFILEoRdIRdELETE_null , 1 ) ;
                            textC t7use = T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/7use/")+T(psttp)+T(".ipdos-wd") ;
                            makeF( tinP , etThread , sReply , psttp , T(psttPrefix)+T(psttp)+T(" ") ) ;
                            etThread.strFromF( tinP , psttp , idAdam ) ;
                            ZE( strokeS* , psttp ) ;
                        {
                        for( countT idAdam = idMin ; !ether && idAdam <= idMax ; idAdam ++ )

                        if( idMin == 0x4010000 ) idMin ++ ;
                        //idMax = 0x401000f ;
                        //idMin = 0x4010001 ;
                        etThread.boxMenuIdRangeF( tinP , idMin , idMax , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/5adam.????104") , 0x100000 , S1C('/') ) ;
                        ZE( countT , idMax ) ;
                        ZE( countT , idMin ) ;
                    {
                    case ifcCMDsERVICEwINDOW_mall :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_qmake :
                    }
                        break ;
                        makeF( tinP , etThread , sReply , psttParameter , psttPrefix ) ;
                    {
                    case ifcCMDsERVICEwINDOW_make  :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_qhire :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_hire  :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_qsub  :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_sub   :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_qwho  :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_who   :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_q7use :
                    }
                        break ;

                        if( bReply ) { textC txt = T(psttPrefix)+T("(done)\r\n") ; sReply.writeF( tinP , (osTextT*)txt ) ; }

                        etThread.osProcessF( value , idDeathType , tinP , T("01000020.ipdos-we") , T("1c30104 !faceHear ///ideafarm/ephemeral/domains/com/ideafarm/city/park/7use/")+tIdi+T(".ipdos-wd") ) ;
                        ZE( countT , idDeathType ) ;
                        ZE( countT , value ) ;
                        etThread.diskHoverF( tinP , T("///d/ideafarm.work/backed.up.never/gen/exe/") ) ;
                        if( bReply ) { textC txt = T(psttPrefix)+T("(step 3 of 3)\r\n") ; sReply.writeF( tinP , (osTextT*)txt ) ; }
                        etThread.delF( tinP , post ) ;
                        etThread.boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/7use/")+tIdi+T(".ipdos-wd") , post , cost ) ;
                        if( bReply ) { textC txt = T(psttPrefix)+T("(step 2 of 3)\r\n") ; sReply.writeF( tinP , (osTextT*)txt ) ; }
                        etThread.boxGetShadowF( tinP , post , cost , T("///d/ideafarm.work/backed.up.never/gen/exe/")+tIdi+T(".ipdos-wd") , 1 ) ; ___( post ) ;
                        ZE( countT , cost ) ;
                        ZE( osTextT* , post ) ;

                        if( bReply ) { textC txt = T(psttPrefix)+T("(step 1 of 3)\r\n") ; sReply.writeF( tinP , (osTextT*)txt ) ; }

                        TN( tIdi , psttParameter ) ;
                    {
                    case ifcCMDsERVICEwINDOW_7use  :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_qtest :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_test  :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_qgett :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_gett  :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_qput  :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_qget  :
                    }
                        break ;
                    {
                    case ifcCMDsERVICEwINDOW_qnew  :
                    }
                        break ;

                        if( bReply ) { textC txt = T(psttPrefix)+T("(done) ")+tIdi+T("\r\n") ; sReply.writeF( tinP , (osTextT*)txt ) ; }

                        etThread.delF( tinP , psttNew ) ;
                        }
                            etThread.boxPutF( tinP , psttNew , (byteT*)&parameter , sizeof parameter ) ;
                            etThread.strReplaceF( tinP , psttNew , 0 , T("/dictionary.okr/") , T("/dictionary.okw/") ) ;
                            etThread.boxPutF( tinP , psttNew , (byteT*)&parameter , sizeof parameter ) ;
                            etThread.strReplaceF( tinP , psttNew , 0 , T("/dictionary/") , T("/dictionary.okr/") ) ;
                        {
                        etThread.delF( tinP , post ) ;
                        etThread.boxPutF( tinP , psttNew , post , cost ) ;
                        if( bReply ) { textC txt = T(psttPrefix)+T("(step 4 of 4) ")+tIdi+T("\r\n") ; sReply.writeF( tinP , (osTextT*)txt ) ; }
                        etThread.boxGetShadowF( tinP , post , cost , tDict+T("adam.0000104") , 1 ) ; ___( post ) ;
                        ZE( countT , cost ) ;
                        ZE( osTextT* , post ) ;
                        if( bReply ) { textC txt = T(psttPrefix)+T("(step 3 of 4) ")+tIdi+T("\r\n") ; sReply.writeF( tinP , (osTextT*)txt ) ; }

                        etThread.delF( tinP , psttIdi ) ;
                        TN( tIdi , psttIdi ) ;
                        }
                            etThread.boxPutF( tinP , tFileLast , (byteT*)&idNew , sizeof idNew ) ;
                            }
                                etThread.strMakeF( tinP , psttNew , tDict + T("adam.") + T(psttIdi ) ) ; ___( psttNew ) ;
                                etThread.strFromF( tinP , psttIdi , idNew , flFORMAT_UNSIGNED | flFORMAT_FILLzE , 7 ) ; ___( psttIdi ) ;
                                if( bReply ) { textC txt = T(psttPrefix)+T("(redoing step 2 of 4)\r\n") ; sReply.writeF( tinP , (osTextT*)txt ) ; }
                                idNew = idNewF( tinP , etThread , tFileLast , 1 ) ;
                                etThread.delF( tinP , psttIdi ) ;
                                etThread.delF( tinP , psttNew ) ;
                            {
                            if( etThread.diskFileExistsF( tinP , psttNew ) ) // ASSUME: THIS IS THE ONLY INSTANCE OF 4e30104 THAT CAN SEE THE tDict DIRECTORY
                            etThread.strMakeF( tinP , psttNew , tDict + T("adam.") + T(psttIdi) ) ; ___( psttNew ) ;
                            etThread.strFromF( tinP , psttIdi , idNew , flFORMAT_UNSIGNED | flFORMAT_FILLzE , 7 ) ; ___( psttIdi ) ;
                            if( bReply ) { textC txt = T(psttPrefix)+T("(step 2 of 4)\r\n") ; sReply.writeF( tinP , (osTextT*)txt ) ; }
                            countT idNew = idNewF( tinP , etThread , tFileLast ) ;
                            TN( tFileLast , "///ideafarm/ephemeral/domains/com/ideafarm/city/settings/4e30104.idLast" ) ;
                        {
                        ZE( strokeS* , psttNew ) ;
                        ZE( strokeS* , psttIdi ) ;
                        if( bReply ) { textC txt = T(psttPrefix)+T("(step 1 of 4)\r\n") ; sReply.writeF( tinP , (osTextT*)txt ) ; }
                    {
                    case ifcCMDsERVICEwINDOW_new   :
                {
                switch( idCmd )

                else                             bReply = 0 ;
                if( nicNameReply && idPortReply ) sReply.connectF( tinP , idPortReply , nicNameReply ) ;
                boolT bReply = 1 ;
                socketC sReply( tinP , etThread , TAG( TAGiDnULL ) ) ;

                stringsFromJobF( tinP , etThread , psttPrefix , psttParameter , pc8Job ) ;
                ZE( strokeS* , psttParameter ) ;
                ZE( strokeS* , psttPrefix ) ;

                const countT  idJob       = pc8Job->c8 ;
                const nicNameC nicNameReply = *(nicNameC*)&pc8Job->c4 ;
                const countT  parameter   = pc8Job->c3 ;
                const countT  idCmd       = pc8Job->c2 ;
                const countT  idPortReply = pc8Job->c1 ;
            {
            if( pc8Job )

            }
                sJobs.ungrabF( tinP ) ;

                while( handle && !ether && !etThread ) ;
                }
                    }
                        while( handle2 && !etThread ) ;
                        }
                            if( pc8JobQueued && *(nicNameC*)&pc8JobQueued->c4 == *pIdhDead ) pc8JobQueued->c2 = 0 ;
                            pc8JobQueued = (count8S*)sJobs.downF( tinP , handle2 ) ;
                            ZE( count8S* , pc8JobQueued ) ;
                        {
                        do
                        ZE( countT , handle2 ) ;
                    {
                    if( pIdhDead )
                    nicNameC* pIdhDead = sDeadHosts.downF( tinP , handle ) ;
                {
                if( !etThread && sDeadHosts ) do
                // ZE OUT idCmd FOR JOBS BELONGING TO DEAD HOSTS

                while( handle && !ether && !etThread ) ;
                }
                    }
                        etThread.delF( tinP , psttParameter ) ;
                        etThread.delF( tinP , psttPrefix ) ;
                        etThread.delF( tinP , psttIdSlot ) ;
                        }
                            sDeadHosts << new( 0 , tinP , LF ) nicNameC( *(nicNameC*)&pc8JobQueued->c4 ) ;
                            etThread = 0 ;
                        {
                        if( etThread )
                        { textC txt = T(psttPrefix )+T("queued at position ")+T(psttIdSlot )+T("\r\n") ; sReply.writeF( tinP , (osTextT*)txt ) ; }
                        sReply.connectF( tinP , pc8JobQueued->c1 , *(nicNameC*)&pc8JobQueued->c4 ) ;
                        socketC sReply( tinP , etThread , TAG( TAGiDnULL ) ) ;

                        stringsFromJobF( tinP , etThread , psttPrefix , psttParameter , pc8JobQueued ) ; ___( psttPrefix ) ; ___( psttParameter ) ;
                        ZE( strokeS* , psttParameter ) ;
                        ZE( strokeS* , psttPrefix ) ;

                        etThread.strFromF( tinP , psttIdSlot , idSlot ) ; ___( psttIdSlot ) ;
                        ZE( strokeS* , psttIdSlot ) ;
                    {
                    if( pc8JobQueued && pc8JobQueued->c1 && *(nicNameC*)&pc8JobQueued->c4 )
                    pc8JobQueued = (count8S*)sJobs.downF( tinP , handle ) ;
                    ZE( count8S* , pc8JobQueued ) ;
                    ++ idSlot ;
                {
                do
                ZE( countT , idSlot ) ;
                stackC sDeadHosts( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_nicNameC ) ;
                // SEND QUEUE POSITION NOTICES

                handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                sJobs.grabF( tinP , TAG( TAGiDnULL ) ) ; ;
            {
            if( sJobs )

            sJobs >> pc8Job ;
            ZE( count8S* , pc8Job ) ;
        {
        else
        if( !sJobs ) etThread.osSleepF( tinP , TOCK ) ;
    {
    while( !ether && !etThread )

    TN( tDict , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/" ) ;

    stackC& sJobs = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmJobDoerF )

}
    return idNew ;

    }
        idNew ++ ;
        __( idMin - 0x4010000 ) ;
        etThread.boxMenuIdRangeF( tinP , idMin , idNew , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/5adam.????104") , 0x100000 , S1C('/') ) ;
        ZE( countT , idMin ) ;
    {
    if( !idNew )

    }
        etThread.delF( tinP , pbi ) ;
        }
            idNew ++ ;
            etThread.memCopyF( tinP , (byteT*)&idNew , pbi , cbi ) ;
        {
        else if( cbi == sizeof idNew )
             if( etThread              ) etThread = 0 ;
        etThread.boxGetF( tinP , pbi , cbi , psttFileLastP , 1 ) ; ___( pbi ) ;
        ZE( countT , cbi ) ;
        ZE( byteT* , pbi ) ;
    {
    if( !bScanP )

    ZE( countT , idNew ) ;

    if( etThread ) return 0 ;
{
countT idNewF( tinS& tinP , etherC& etThread , const strokeS* const psttFileLastP , const boolT bScanP = 0 )

}
    etThread.delF( tinP , psttOldCmd ) ;

    etThread.strFuseF( tinP , psttPrefixP , T("job ")+TF1(idJob)+T(" \"")+T(psttOldCmd)+( parameter ? T(" ")+T(psttParameterP) : T("") )+T("\" ") ) ; ___( psttPrefixP ) ;

    etThread.strFromF( tinP , psttParameterP , parameter ) ;

    }
        default                       : { etThread.strMakeF( tinP , psttOldCmd , T(""     ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_qmall : { etThread.strMakeF( tinP , psttOldCmd , T("?mall") ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_mall  : { etThread.strMakeF( tinP , psttOldCmd , T("mall" ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_qhire : { etThread.strMakeF( tinP , psttOldCmd , T("?hire") ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_hire  : { etThread.strMakeF( tinP , psttOldCmd , T("hire" ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_qsub  : { etThread.strMakeF( tinP , psttOldCmd , T("?sub" ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_sub   : { etThread.strMakeF( tinP , psttOldCmd , T("sub"  ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_qwho  : { etThread.strMakeF( tinP , psttOldCmd , T("?who" ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_who   : { etThread.strMakeF( tinP , psttOldCmd , T("who"  ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_q7use : { etThread.strMakeF( tinP , psttOldCmd , T("?7use") ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_7use  : { etThread.strMakeF( tinP , psttOldCmd , T("7use" ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_qtest : { etThread.strMakeF( tinP , psttOldCmd , T("?test") ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_test  : { etThread.strMakeF( tinP , psttOldCmd , T("test" ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_qgett : { etThread.strMakeF( tinP , psttOldCmd , T("?gett") ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_gett  : { etThread.strMakeF( tinP , psttOldCmd , T("gett" ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_qmake : { etThread.strMakeF( tinP , psttOldCmd , T("?make") ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_make  : { etThread.strMakeF( tinP , psttOldCmd , T("make" ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_qput  : { etThread.strMakeF( tinP , psttOldCmd , T("?put" ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_put   : { etThread.strMakeF( tinP , psttOldCmd , T("put"  ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_qget  : { etThread.strMakeF( tinP , psttOldCmd , T("?get" ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_get   : { etThread.strMakeF( tinP , psttOldCmd , T("get"  ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_qnew  : { etThread.strMakeF( tinP , psttOldCmd , T("?new" ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_new   : { etThread.strMakeF( tinP , psttOldCmd , T("new"  ) ) ; ___( psttOldCmd ) ; break ; }
        case ifcCMDsERVICEwINDOW_q     : { etThread.strMakeF( tinP , psttOldCmd , T("?"    ) ) ; ___( psttOldCmd ) ; break ; }
    {
    switch( idCmd )
    ZE( strokeS* , psttOldCmd ) ;

    const countT  idJob       = pc8JobP->c8 ;
    const nicNameC nicNameReply = *(nicNameC*)&pc8JobP->c4 ;
    const countT  parameter   = pc8JobP->c3 ;
    const countT  idCmd       = pc8JobP->c2 ;
    const countT  idPortReply = pc8JobP->c1 ;
{
voidT stringsFromJobF( tinS& tinP , etherC& etThread , strokeS*& psttPrefixP , strokeS*& psttParameterP , const count8S* const pc8JobP )

}
    //etThread.osProcessF( value , idDeathType , tinP , T("wlib.exe") , tLibArg ) ;
    //textC tLibArg = T("-q -n -b ")+tIdi+T("w.lib +")+tIdi+T(".ipdos-wd") ;
    //NOT NEEDED.  DOES NOT WORK

    #endif

    }
        { textC txt = T(psttPrefixP)+T("(done)\r\n") ; sReplyP.writeF( tinP , (osTextT*)txt ) ; }
        etThread.osProcessF( value , idDeathType , tinP , T("wlink.exe") , tLinkArg ) ;
        textC tLinkArg = T("system nt_dll op q name \\ideafarm.work\\backed.up.never\\gen\\exe\\")+tIdi+T(".ipdos-wd file ")+tIdi+T(".obj library \\ideafarm.work\\backed.up.never\\gen\\exe\\ifcbasew.lib") ;
        ZE( countT , idDeathType ) ;
        ZE( countT , value ) ;
        etThread.diskHoverF( tinP , tDirw+T("/") ) ;
        { textC txt = T(psttPrefixP)+T("(step a of a)\r\n") ; sReplyP.writeF( tinP , (osTextT*)txt ) ; }
    {
    else
    }
        { textC txt = T(psttPrefixP)+T("(aborted)\r\n") ; sReplyP.writeF( tinP , (osTextT*)txt ) ; }
        }
            ((thirdC&)etThread).logF( tinP , T("strBadCodeLineF could not process ")+tIdi) ;
            sReplyP.writeF( tinP , (osTextT*)T("||||\r\nno more information is available\r\n||||") ) ;
        {
        else
        }
            etThread.delF( tinP , psttbcl ) ;
            sReplyP.writeF( tinP , (osTextT*)T(psttbcl) ) ;
        {
        if( psttbcl )
        etThread.strBadCodeLineF( tinP , psttbcl , tIdi ) ;
        ZE( strokeS* , psttbcl ) ;

        ((thirdC&)etThread).logF( tinP , T("4e30104: MAKE FAILED: ")+T(psttPrefixP)) ;

        etThread = 0 ;
    {
    if( etThread )

    etThread.delF( tinP , post ) ;
    ((thirdC&)etThread).osCompileF( tinP , post ) ;
    etThread.strMakeF( tinP , post , tIdi ) ;
    etThread.diskHoverF( tinP , tDir+T("/") ) ;
    etThread.diskMakeDirIfNeededF( tinP , tDirw+T("/") ) ;
    { textC txt = T(psttPrefixP)+T("(step 9 of a)\r\n") ; sReplyP.writeF( tinP , (osTextT*)txt ) ; }

    #if defined( NEVERdEFINED )
    // THE COMPILE AND LINK CODE HERE IS OBSOLETE AND WOULD NEED TO BE REWRITTEN TO USE THE CURRENT API'S FOR COMPILE AND LINK

    }
        __( idDeathType ) ;
        __( value ) ;
        etThread.osProcessF( value , idDeathType , tinP , T("///d/ideafarm.work/backed.up.never/gen/exe/released.i00005/01000030.ipdos-we") , T("5c30104 !faceHear ")+tIdi ) ;
        ZE( countT , idDeathType ) ;
        ZE( countT , value ) ;
        { textC txt = T(psttPrefixP)+T("(step 8 of a)\r\n") ; sReplyP.writeF( tinP , (osTextT*)txt ) ; }
    {

    cost = 0 ;
    etThread.delF( tinP , post ) ;
    etThread.boxPutF( tinP , tCpp , post , cost ) ;
    { textC txt = T(psttPrefixP)+T("(step 7 of a)\r\n") ; sReplyP.writeF( tinP , (osTextT*)txt ) ; }
    etThread.delF( tinP , psttAll ) ;
    cost = etThread.strMakeF( tinP , post , psttAll ) ; ___( post ) ;
    { textC txt = T(psttPrefixP)+T("(step 6 of a)\r\n") ; sReplyP.writeF( tinP , (osTextT*)txt ) ; }

    etThread.delF( tinP , psttBody ) ;
    etThread.strMakeF( tinP , psttAll , T("#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.h\"\r\n#include \"\\ideafarm.home.1\\ephemeral\\domains\\com\\ideafarm\\city\\workshop\\snip\\1snip.005000a.lines.adam.")+tIdi+T( "\"\r\n//SOURCE: adam.")+tIdi+T(" BEGIN\r\n#define DDNAME \"adam.")+tIdi+T("\"\r\n#define DDNUMB 0x")+tIdiR+T("\r\n")+T(psttBody)+T("\r\n#undef DDNUMB\r\n#undef DDNAME\r\n//SOURCE: adam.")+tIdi+T(" END\r\n") ) ; ___( psttAll ) ;
    ZE( strokeS* , psttAll ) ;
    { textC txt = T(psttPrefixP)+T("(step 5 of a)\r\n") ; sReplyP.writeF( tinP , (osTextT*)txt ) ; }

    etThread.strReverseF( tinP , psttBody , 0 , T("\r\n") ) ; ___( psttBody ) ;
    { textC txt = T(psttPrefixP)+T("(step 4 of a)\r\n") ;sReplyP.writeF( tinP , (osTextT*)txt ) ; }
    cost = 0 ;
    etThread.delF( tinP , post ) ;
    etThread.strMakeF( tinP , psttBody , T(post) ) ; ___( psttBody ) ;
    ZE( strokeS* , psttBody ) ;
    { textC txt = T(psttPrefixP)+T("(step 3 of a)\r\n") ; sReplyP.writeF( tinP , (osTextT*)txt ) ; }
    etThread.boxGetShadowF( tinP , post , cost , tRaw , 1 ) ; ___( post ) ;
    ZE( countT , cost ) ;
    ZE( osTextT* , post ) ;
    { textC txt = T(psttPrefixP)+T("(step 2 of a)\r\n") ; sReplyP.writeF( tinP , (osTextT*)txt ) ; }

    textC tDirw = tDir+T("/windows") ;
    textC tDir = tGen+tIdi ;
    textC tCpp = tGen+tIdi+T("/")+tIdi+T(".cpp") ;
    textC tRaw = tDic+T("adam.")+tIdi ;
    TN( tDic  , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/" ) ;
    TN( tGen  , "///d/ideafarm.work/backed.up.never/gen/" ) ;    

    }
        etThread.delF( tinP , psttw ) ;
        tIdiR = T(psttw) ;
        etThread.strReverseF( tinP , psttw ) ; ___( psttw ) ;
        etThread.strMakeF( tinP , psttw , psttParameterP ) ; ___( psttw ) ;
        ZE( strokeS* , psttw ) ;
    {
    TN( tIdiR , "" ) ;
    TN( tIdi  , psttParameterP ) ;
{
voidT makeF( tinS& tinP , etherC& etThread , socketC& sReplyP , const strokeS* const psttParameterP , const strokeS* const psttPrefixP )
//U: DUPLICATE CODE: 4e30104 AND 007001f

/*1*/WAKEhIDE( "" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

