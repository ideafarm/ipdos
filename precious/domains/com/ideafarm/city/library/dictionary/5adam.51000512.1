
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.delF( tinP , pbOut ) ;
}
    etThread.delF( tinP , pcCode ) ;
    etThread.delF( tinP , pbIn ) ;
    
    etThread.boxPutF( tinP , T("///d/test.in.")+TF1(idCycle) , pbIn , cbIn ) ;
    
    etThread.strokeF( tinP , T("\r\ndecoding done\r\n") ) ;
    dad( tinP , pbIn , cbIn , pcCode , ccCode ) ; ___( pbIn ) ;
    ZE( countT , cbIn ) ;
    ZE( byteT* , pbIn ) ;
    
    etThread.boxPutF( tinP , T("///d/test.codes.")+TF1(++idCycle) , (byteT*)pcCode , ccCode * sizeof( count01T ) ) ;
    
    etThread.strokeF( tinP , T("\r\nencoding done; score: ")+TF1(score)+T(" of ")+TF1(ccCode-cProlog)+T(" (")+TF1((countT)(score*TOCK/(ccCode-cProlog)))+T("%%)\r\n") ) ;
    countT score = etThread.tallyF( tinP , pcCode + cProlog , ccCode - cProlog ) ;
    const countT cProlog = 0x200 ; //THE WOTH SECTION IS LIKELY TO CONTAIN MOST OF THE VALUE CONSTANTS SO IT IS EXCLUDED FROM THE EVALUATION
    
    mom( tinP , pcCode , ccCode , pbOut , cbOut ) ; ___( pcCode ) ;
    ZE( countT    , ccCode ) ;
    ZE( count01T* , pcCode ) ;
{
while( !ether )
ZE( countT , idCycle ) ;

CONoUTrAW3( "test cbOut:\r\n" , cbOut , "\r\n" ) ;
etThread.boxGetShadowF( tinP , pbOut , cbOut , T("///d/test") ) ; ___( pbOut ) ; //ANY FILE OF ANY SIZE
ZE( countT , cbOut ) ;
ZE( byteT* , pbOut ) ;

dadC dad( tinP , etThread , TAG( TAGiDnULL ) ) ;
momC mom( tinP , etThread , TAG( TAGiDnULL ) ) ;

TODO

/*1*/WAKEhIDE( "example.other.snip.00300a3.spouseC" )/*1*/
/**/
*/
  a "finite snippet" is a snippet that does not extend backward in time all the way to the beginning of the code stream
 the code for any finite snippet of the byteT stream is "lossy"; it does not contain all information needed to decode it 
 with the entire code stream, decoding is trivial
 it is impossible to decode a portion of the code stream using that information alone
 the codes for a current snip of the byteT stream refer back to prior codes in the byteT stream
the key concept is that of infinite referback
the stream of count01T codes has properties that are desirable for security
any arbitrary stream of byteT values can be converted into and then recovered from a stream of count01T values
i demonstrate marriage model security
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

