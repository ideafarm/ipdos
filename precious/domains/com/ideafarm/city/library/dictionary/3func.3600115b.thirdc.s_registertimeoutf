
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pks ;
    tinP.pAdamGlobal1->_thirdC_.pSwKillSocket->ungrabF( tinP ) ;
    }
        }
            pks->timeExpire2 = timeEN2 ;
            pks->timeExpire1 = timeEN1 ;
        {
        if( timeEN2 < pks->timeExpire2 || ( timeEN2 == pks->timeExpire2 && timeEN1 < pks->timeExpire1 ) )
        osTimeSubtractF( tinP , timeEN1 , timeEN2 , pks->timeExpire1 , pks->timeExpire2 ) ;
        sCountT timeD2 = timeEN2 ;
        countT  timeD1 = timeEN1 ;
        osTimeAddIF( tinP , timeEN1 , timeEN2 , time1P , time2P ) ;
        osTimeNowF( tinP , timeEN1 , timeEN2 ) ;
        ZE( sCountT , timeEN2 ) ;
        ZE( countT  , timeEN1 ) ; //"en": "expire new"
    {
    else
    }
        osTimeAddIF( tinP , pks->timeExpire1 , pks->timeExpire2 , time1P , time2P ) ;
        osTimeNowF( tinP , pks->timeExpire1 , pks->timeExpire2 ) ;
    {
    if( !incv02AM( pks->cRef ) )
    pks = (killSocketS*)&(countT&)*tinP.pAdamGlobal1->_thirdC_.pSwKillSocket ;
    tinP.pAdamGlobal1->_thirdC_.cLever_pSwKillSocket = (countT)&handleP ;
    tinP.pAdamGlobal1->_thirdC_.pSwKillSocket->grabF( tinP , TAG( TAGiDnULL ) ) ;
    ZE( killSocketS* , pks ) ;
    SCOOP
{
/*1*/killSocketS* thirdC::s_registerTimeoutF( tinS& tinP , const handleC& handleP , const countT time1P , const sCountT time2P )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

