
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
#endif

    //OUT

    }
        }
            third.pcFunctionTime2[   idFile ] = 0 ;
            third.pcFunctionTime1[   idFile ] = 0 ;
            third.pcFunctionExits[   idFile ] = 0 ;
            third.pcFunctionEntries[ idFile ] = 0 ;
        {
        for( countT idFile = 1 ; idFile <= cSourceFiles ; idFile ++ )

        memCopyF( tinP , (byteT*)pcRaceId , (byteT*)pcRaceIdP , sizeof( countT ) * ( ccRaceId + 1 ) ) ;
        newF( tinP , LF , pcRaceId , ccRaceId + 1 ) ; ___( pcRaceId ) ;
        countT ccRaceId = strBodyLengthF( tinP , pcRaceIdP ) ;
    {
    if( pcRaceIdP )

    delF( tinP , pcRaceId ) ;
    }
        delF( tinP , pcRace ) ;
        }
            delF( tinP , pcPart ) ;
            ifcDatumF( tinP , flDATUM1_CLASStIMER , flDATUM2_countT , cActive , pcPart , (byteT*)( pcRace + 5 ) , cActive * 5 * sizeof( countT ) ) ;

            }
                memCopyF( tinP , (byteT*)( pcPart + 3 ) , (byteT*)pcRaceId , sizeof( countT ) * ( ccRaceId + 1 ) ) ;
                pcPart[ 2 ] = 1 + !!( F(flagsWatch) & flWATCH_EMPLOYERS ) ;
                pcPart[ 1 ] = 1 ;
                pcPart[ 0 ] = 0x2600301 ;
            {
            if( pcPart )
            newF( tinP , LF , pcPart , 4 + ccRaceId ) ; ___( pcPart ) ;
            countT ccRaceId = strBodyLengthF( tinP , pcRaceId ) ;
            ZE( countT* , pcPart ) ;
        {
        if( cActive ) // KEEP THIS CODE IN SYNC WITH 3f30104

        }
            pcRaceFun += 5 ;
            *pcRaceFun = processGlobal8I.source.idFileImmutableF( tinP , *pcRaceFun ) ;
        {
        for( countT ida = 1 ; ida <= cActive ; ida ++ ) // WE DO THIS SEPARATELY SO processGlobal8I.source.idFileImmutableF IS NOT INCLUDED IN DATA
        pcRaceFun = pcRace ? pcRace + 5 : 0 ;

        }
            pcRaceFun += 5 ;

            pcRaceFun[ 4 ] = third.pcFunctionTime2[   idFile ] ;
            pcRaceFun[ 3 ] = third.pcFunctionTime1[   idFile ] ;
            pcRaceFun[ 2 ] = third.pcFunctionExits[   idFile ] ;
            pcRaceFun[ 1 ] = third.pcFunctionEntries[ idFile ] ;
            pcRaceFun[ 0 ] = idFile ;

            cActive ++ ;

            if( !third.pcFunctionEntries[ idFile ] ) continue ;
        {
        for( countT idFile = 1 ; idFile <= cSourceFiles ; idFile ++ )

        ZE( countT , cActive ) ;
        countT* pcRaceFun = pcRace ? pcRace + 5 : 0 ;
        newF( tinP , LF , pcRace , ( 1 + cSourceFiles ) * 5 ) ; ___( pcRace ) ;
        ZE( countT* , pcRace ) ;
    {
    if( pcRaceId )
    const countT cSourceFiles = processGlobal8I.source.cFilesF( tinP ) ;

    //IN_E

    //}
    //    if( POOP ) return ;
    //    __( pcRaceIdP && !*pcRaceIdP ) ;
    //    if( POOP ) return ;
    //{
    //IFbEcAREFUL

#if defined( NEVERdEFINED )

    if( tinP.fingerprint && pcRaceIdP ) ;
    BLAMMO ; //U:: REDESIGN THIS SUBSYSTEM
    SCOOP
{
/*1*/voidT etherC::ifcRaceIdF( tinS& tinP , const countT* const pcRaceIdP )/*1*/

/**/
*/
   for maximum speed, this is not enforced
  if not 0 then pcRaceIdP[ 0 ] must be nonze
  if 0 then this etherC object becomes untimed
  can be 0
  the current race is ended by flushing race totals to city center and a new race is begun
 pcRaceIdP
 tinP
arguments
the part number of the datum is { 0x1030062 , 1 , 1 + F(flagsWatch) & flWATCH_EMPLOYERS } followed by pcRaceIdP
 for max speed when updating counters, this function is not serialized w.r.t. the code that updates timing counters
counter values will be inconsistent if they are being incremented while this function is being evaluated
this function does not execute prolog and epilog overhead code
   it would not normally make sense to specify the same pcRaceIdP value in both calls
  if pcRaceIdP is not null then statistics will be sent and a new race will be begun immediately
  if pcRaceidP is null then the statistics will be sent to city center and no new race will be begun
 then call this function again
 then, execute the code that you want to collect time information about
 first, call it with a pcRaceIdP value that you make up (not null)
to run a race, call this function twice
resets counters after writing datum containing them
 U: write an example for this once races are supported
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.1030062.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$ifcRaceIdF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

