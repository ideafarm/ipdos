
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS6bOOKbYcONTAINERuRI napped") ) ;
        ++ s ; ether.osSleepF( tinP , TOCK << 2 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS6bOOKbYcONTAINERuRI napping [cIn,cOut]:    ")+TF2(cIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        if( bQuit ) break ;

        while( !bQuit && ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                }
                    etThread.traceF( tinP , T("all workers are gone") ) ;
                    }
                        ++ s ; etThread.osSleepF( tinP , TOCK >> 2 ) ;
                    {
                    while( ws.cWorkers )
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    etThread.traceF( tinP , T("waiting for workers") ) ;
                    ws.bFireWorkers = 1 ;

                    THREADmODE1rESTORE
                    }
                        }
                            }
                                ++ s ; etThread.osSleepF( tinP , TOCK >> 3 ) ;
                                etThread.traceF( tinP , T("waiting for queue to shrink [cPending]:    ")+TF2(ws.st_pPageEvent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            while( ws.st_pPageEvent > TUCK )
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( ws.st_pPageEvent > ( TUCK << 1 ) )                // THE QUEUE LENGTH MUST BE SMALL SO THAT IT IS IMPOSSIBLE FOR A QUEUED ITEM TO BE IN A BOOK OTHER THAN THE BOOK IMMEDIATELY PRECEDING THE BOOK BEING READ, ASSUMING THAT I ONLY KEEP WO INACTIVE BOOK

                        bPrefix = !bPrefix ;

                        else          pbi = 0 ;
                        if( bDelete ) PUSE( tinP , *(byteT**)&pbi ) ;

                        ;
                            : sizeof( countT )
                            ? *(countT*)pbi
                        cbi = bPrefix

                        }
                            //if( ws.idIn < TUCK || !( ws.idIn % TUCK ) ) etThread.traceF( tinP , T("[ws.idIn,cOutputFlavors]:    ")+TF2(ws.idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ws.swBooksByIdjContainerIdjUri.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            ++ ws.idIn ;
                            cIn ++ ;
                            ws.st_pPageEvent << *(countT*)&pPageEvent ;

                            __( (countT)*pPageEvent - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                            }
                                break ;
                                hRead = hReadSave ;
                                cbi = cbiSave ;

                                THREADmODE3rESTORE
                                DEL( pPageEvent ) ;
                                THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                                BLAMMO ;                                                //SHOULD BE IMPOSSIBLE SINCE "ALL OR NONE" USED FOR WRITING BOOKTOGETHER AND I'VE ALREADY READ THE PREFIX
                            {
                            if( !(const byteT*)*pPageEvent )

                            THREADmODE3rESTORE
                            bksAccessEventsIn.readF( tinP , *pPageEvent , hRead , flBOOKScrEAD_null , &bQuit , &hCursor , idCursor ) ;
                            pPageEvent = new( 0 , tinP , LF ) pageC( tinP , bksAccessEventsIn , cbi ) ; ___( pPageEvent ) ;
                            THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                            ZE( pageC* , pPageEvent ) ;
                        {
                        else
                        }
                            __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                            }
                                break ;
                                hRead = hReadSave ;
                                cbi = cbiSave ;
                            {
                            if( !pbi )
                            bDelete = bksAccessEventsIn.readF( tinP , pbi , cbi , hRead , flBOOKScrEAD_STILLhUNGRYiSoK , &bQuit , &hCursor , idCursor ) ;
                        {
                        if( bPrefix )
                        ZE( boolT , bDelete ) ;

                        HANDLEaPPnOTEScOUNTcLASS ch = hRead ;

                        handleC hReadSave = hRead ;
                        countT cbiSave = cbi ;
                    {
                    while( !bQuit && !POOP )
                    boolT bPrefix = 1 ;
                    countT cbi = sizeof( countT ) ;
                    ZE( const byteT* , pbi ) ;

                    // *****************************************************************************************************************************************************************************************************************************************************
                    // *****************************************************************************************************************************************************************************************************************************************************
                    // ********                    *************************************************************************************************************************************************************************************************************************
                    // ********  EAT BOOK ENTRIES  *************************************************************************************************************************************************************************************************************************
                    // ********                    *************************************************************************************************************************************************************************************************************************
                    // *****************************************************************************************************************************************************************************************************************************************************
                    // *****************************************************************************************************************************************************************************************************************************************************

                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                    handleC hCursor( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKSrEADcURSOR ) ;
                    handleC hRead( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
                    //etThread.traceF( tinP , T("book by uri / enering loop to read events") ) ;

                    }
                        etThread.osThreadF( tinP , countTC() , tmWorkerF , 0 , flTHREADlAUNCH_INHERITjOTrEGISTRATIONS , TOCK , (countT)&ws , (countT)&bksAccessEventsIn ) ;
                        inc02AM( ws.cWorkers ) ;
                    {
                    while( cDo -- )
                    countT cDo = 0x10 ;
                    //etThread.traceF( tinP , T("book by uri / launching workers") ) ;

                    workS ws( tinP , etThread ) ;
                    //etThread.traceF( tinP , T("book by uri / ct ws") ) ;

                    TN( tb4 , "    " ) ;
                    booksC bksAccessEventsIn( tinP , TAG( TAGiDnULL ) , tShorter , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_null , 0 , 4 , 0 , 0 , 0 , 0 , &bQuit ) ;
                    //etThread.traceF( tinP , T("book by uri / ct bksAccessEvents") ) ;

                    }
                        etThread.delF( tinP , psttCursor3 ) ;
                        etThread.delF( tinP , psttCursor2 ) ;
                        etThread.delF( tinP , psttCursor1 ) ;
                        idCursor = BM_HIGH | etThread.strDigitsToSCountF( tinP , psttCursor1 , 0 , 0 ) << 0x10 | etThread.strDigitsToSCountF( tinP , psttCursor2 , 0 , 0 ) << 8 | etThread.strDigitsToSCountF( tinP , psttCursor3 , 0 , 0 ) ;
                        //etThread.traceF( tinP , T("[psttCursor3]:    ")+T(psttCursor3) ) ;
                        //etThread.traceF( tinP , T("[psttCursor2]:    ")+T(psttCursor2) ) ;
                        //etThread.traceF( tinP , T("[psttCursor1]:    ")+T(psttCursor1) ) ;

                        etThread.strWordF( tinP , psttCursor3 , tShorter , sttq , strokeS( '.' ) , 6 , 0 ) ; ___( psttCursor3 ) ;
                        etThread.strWordF( tinP , psttCursor2 , tShorter , sttq , strokeS( '.' ) , 5 , 0 ) ; ___( psttCursor2 ) ;
                        etThread.strWordF( tinP , psttCursor1 , tShorter , sttq , strokeS( '.' ) , 4 , 0 ) ; ___( psttCursor1 ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        ZE( strokeS* , psttCursor3 ) ;
                        ZE( strokeS* , psttCursor2 ) ;
                        ZE( strokeS* , psttCursor1 ) ;
                    {
                    ZE( countT , idCursor ) ;

                    //etThread.traceF( tinP , T("[tShorter]:    ")+tShorter ) ;

                    }
                        etThread.delF( tinP , psttShorter ) ;
                        tShorter = T(psttShorter) ;
                        etThread.delF( tinP , psttnu ) ;
                        etThread.strBisectF( tinP , psttShorter , psttnu , tShort , tDot , 7 , flSTRbISECT_null ) ; ___( psttShorter ) ; ___( psttnu ) ;
                        ZE( strokeS* , psttnu ) ;
                        ZE( strokeS* , psttShorter ) ;
                    {
                    TN( tShorter , "" ) ;            // bksAccessEvents.4.hash123.00.00.00.accessEvents
                {
                if( !bDir )

                }
                    etThread.delF( tinP , psttShort ) ;
                    tShort = T(psttShort) ;
                    etThread.delF( tinP , psttnu ) ;
                    etThread.strBisectF( tinP , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                    ZE( strokeS* , psttShort ) ;
                    ZE( strokeS* , psttnu ) ;
                {
                TN( tShort , "" ) ;            // bksAccessEvents.4.hash123.00.00.00.accessEvents.booksC.1.book.00000001.00000001.bookC

                const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;

                TN( tIfoName , pInfo->psttIfoName ) ;
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirOldF( tinP , pInfo , hFind , tLike ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    {
    while( !bQuit && !POOP )
    const boolT& bQuit = *(const boolT*)&(const countT&)ether ;

    ZE( countT , idIn ) ;
    TN( tDot , "." ) ;
    TN( tSlash , "/" ) ;
    TN( tLike , "" ) ; tLike = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/")+tUser+T("/" ifcSTR( ifcIDmEMORYsPACE_APPLICATION ) "/stateSpaces/ffffefff/bksAccessEvents.4.hash123.??.??.??.accessEvents.booksC.1.book.00000001.00000001.bookC") ;
    TN( tUser , thirdC::postUserNameIF() ) ;
{

ether.ifcHireF( tinP , T("ifcIDaDAM_ACCESSeVENTS6bOOKbYcONTAINERuRI") , ifcIDaDAM_ACCESSeVENTS7rEPORTbYcONTAINERuRI , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; // flHIRE_DISPLAYaUTO CAN BE COMMENTED OUT TO AVOID WDW FOR ROOT CLOUD INSTANCE WHICH IS USUALLY NOT INTERESTING

TODO

DONE( tmWorkerF )
}
    dec02AM( wsP.cWorkers ) ;
    _OUT_

    }
        _OUT_
        }
            _OUT_
            THREADmODE1rESTORE
            }
                _OUT_
                wsP.st_pPageEvent.ungrabF( tinP ) ;
                }
                    _OUT_
                    wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    }
                        _OUT_
                        THREADmODE3rESTORE
                        DEL( pPageEvent ) ;
                        THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )

                        }
                            }
                                _OUT_

                                wsP.swBooksByIdjContainerIdjUri.ungrabF( tinP ) ;

                                inc02AM( cOut ) ;

                                booksOut.writeF( tinP , (byteT*)&cbo , sizeof cbo , WS( sBookEntryOut ) , flBOOKScwRITE_ALLOWoDDlENGTH | flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ELSEfILLtOeND , 0 ) ;
                                countT cbo = sBookEntryOut.cbF( tinP ) ;

                                //etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS6bOOKbYcONTAINERuRI: writing an event") ) ;

                                booksC& booksOut = *(booksC*)&(countT&)wsP.swBooksByIdjContainerIdjUri ;

                                }
                                    }
                                        booksC* pBooks = new( 0 , tinP , pba , sizeof( booksC ) ) booksC( tinP , TAG( TAGiDnULL ) , tBooksOut , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER , TOCK >> 0 ) ; ___( pBooks ) ;

                                        TN( tBooksOut , "" ) ; tBooksOut = T("bksAccessEvents.5.containerUri.")+TF3(idjContainer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+tDot+TF3(idjUri,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ;
                                    {
                                    if( !POOP )

                                    __Z( pba ) ;
                                    byteT* pba = (byteT*)&(countT&)wsP.swBooksByIdjContainerIdjUri ;
                                {
                                if( !wsP.swBooksByIdjContainerIdjUri.idSlotOfLeverF( tinP , (countT)wsP.lever_pbIdjContainerIdjUri ) )
                                wsP.lever_pbIdjContainerIdjUri = (const byteT*)&c2lever ;
                                count2S c2lever( idjUri , idjContainer ) ;                                          // CONTAINER IS HIGH ORDER BECAUSE IT VARIES LESS, SO MISMATCH WILL BE DETECTED FASTER BY switchC, WHICH WILL COMPARE THE LEVER BYTES FROM LOW ORDER TO HIGH ORDER
                                wsP.swBooksByIdjContainerIdjUri.grabF( tinP , TAG( TAGiDnULL ) ) ;

                                sBookEntryOut << cbReply ;
                                sBookEntryOut << code ;
                                sBookEntryOut << idjQuery ;
                                sBookEntryOut << idjBucket ;
                                sBookEntryOut << idjMethod ;
                                sBookEntryOut << idjProtocol ;
                                sBookEntryOut << idjBrowser ;
                                sBookEntryOut << nnHe ;
                                sBookEntryOut << timeW2 ;
                                sBookEntryOut << timeW1 ;
                                sBookEntryOut << idFormat ;
                                sBookEntryOut << fingerOut ;
                                soulC sBookEntryOut( tinP , TAG( TAGiDnULL ) ) ;

                                putNegAM( fingerOut , FINGERnEG_ACCESSeVENTiDjOTfORaLLsTRINGS ) ;
                                ZE( countT , fingerOut ) ;

                                inc02AM( wsP.pczTallyByDuck[ timeW2 >> 8 & 0xff ] ) ;

                                _INoLD_
                            {
                            else
                            if( getNegAM( finger ) != FINGERnEG_ACCESSeVENTiDjOTfORmOstsTRINGS || idFormat != 1 ) etThread.traceF( tinP , T("unexpected format [finger,idFormat]:    ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            sBookEntryIn >> cbReply      ;
                            sBookEntryIn >> code         ;
                            sBookEntryIn >> idjQuery     ;
                            sBookEntryIn >> idjUri       ;
                            sBookEntryIn >> idjContainer ;
                            sBookEntryIn >> idjBucket    ;
                            sBookEntryIn >> idjMethod    ;
                            sBookEntryIn >> idjProtocol  ;
                            sBookEntryIn >> idjBrowser   ;
                            sBookEntryIn >> nnHe         ;
                            sBookEntryIn >> timeW2       ;
                            sBookEntryIn >> timeW1       ;
                            sBookEntryIn >> hashUri      ;
                            sBookEntryIn >> idFormat     ;
                            sBookEntryIn >> finger       ;

                            ZE( countT , cbReply      ) ;
                            ZE( countT , code         ) ;
                            ZE( countT , idjQuery     ) ;
                            ZE( countT , idjUri       ) ;
                            ZE( countT , idjContainer ) ;
                            ZE( countT , idjBucket    ) ;
                            ZE( countT , idjMethod    ) ;
                            ZE( countT , idjProtocol  ) ;
                            ZE( countT , idjBrowser   ) ;
                            nicNameC nnHe ;
                            ZE( countT , timeW2       ) ;
                            ZE( countT , timeW1       ) ;
                            ZE( countT , hashUri      ) ;
                            ZE( countT , idFormat     ) ;
                            ZE( countT , finger       ) ;

                            //    sBookEntryOut << cbReply ;                          // f CB REPLY BODY
                            //    sBookEntryOut << code ;                             // e HTTP RESPONSE CODE
                            //    sBookEntryOut << pidj[ 4 ] ;                        // d QUERY
                            //    sBookEntryOut << pidj[ 3 ] ;                        // c URI
                            //    sBookEntryOut << pidj[ 2 ] ;                        // b CONTAINER
                            //    sBookEntryOut << pidj[ 1 ] ;                        // a BUCKET
                            //    sBookEntryOut << pidj[ 0 ] ;                        // 9 METHOD
                            //    sBookEntryOut << pidj[ 5 ] ;                        // 8 PROTOCOL
                            //    sBookEntryOut << pidj[ 6 ] ;                        // 7 BROWSER
                            //    sBookEntryOut << nnHe ;                             // 6 
                            //    sBookEntryOut << *(countT*)&timeW2 ;                // 5 
                            //    sBookEntryOut << timeW1 ;                           // 4 
                            //    sBookEntryOut << ph[ 3 ] ;                          // 3 URI HASH:  THIS IS AN OPTIMIZATION TO AVOID MULTIPLE RETRIEVALS FROM jotC AS PROCESSING PROCEEDS THROUGH SORTING TO FINAL OUTPUT
                            //    sBookEntryOut << (countT)1 ;                        // 2 
                            //    sBookEntryOut << finger ;       finger = 0 ;        // 1 
                            //
                            // RECORD LAYOUT (FROM 745)

                            }
                                etThread.delF( tinP , pbPageCopy ) ;
                                }
                                    sBookEntryIn.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbPageCopy , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;

                                    bksAccessEventsP.unlockF( tinP ) ;
                                    etThread.memCopyF( tinP , pbPageCopy , pbzPage , cbzPage ) ;
                                    const byteT* pbzPage = *pPageEvent ;
                                    bksAccessEventsP.lockF( tinP , TAG( TAGiDnULL ) ) ;
                                {
                                if( !POOP )

                                __Z( pbPageCopy ) ;
                                etThread.newF( tinP , LF , pbPageCopy , cbzPage ) ; ___( pbPageCopy ) ;
                                ZE( byteT* , pbPageCopy ) ;

                                countT cbzPage = *pPageEvent ;
                            {
                            soulC sBookEntryIn( tinP , TAG( TAGiDnULL ) ) ;
                        {

                        _INoLD_
                    {
                    if( pPageEvent )

                    wsP.st_pPageEvent.ungrabF( tinP ) ;
                    wsP.st_pPageEvent >> *(countT*)&pPageEvent ;
                    ZE( pageC* , pPageEvent ) ;
                    _INoLD_
                {
                while( wsP.st_pPageEvent )
                wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;

                _INoLD_
            {
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            _INoLD_
        {
        else
        }
            //etThread.traceF( tinP , T("napped") ) ;
            ++ s ; etThread.osSleepF( tinP , TOCK >> 2 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //etThread.traceF( tinP , T("napping") ) ;

            if( wsP.bFireWorkers ) break ;
        {
        if( !wsP.st_pPageEvent )
        _INoLD_
    {
    while( !etThread && !POOP )

    TN( tDot , "." ) ;
    TN( tb4 , "    " ) ;

    booksC& bksAccessEventsP = *(booksC*)pTaskP->c2 ;
    workS&  wsP              =  *(workS*)pTaskP->c1 ;
    _INoLD_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )

}
    __Z( pczTallyByDuck ) ;
    etherP.delF( tinP , pcZe ) ;
    }
        bkTallyByDuck.readF( tinP , *(const byteT**)&pczTallyByDuck , cbzi , offi ) ;
        ZE( countT , offi ) ;
        countT cbzi = cbZe ;

        bkTallyByDuck.writeF( tinP , flResult , (byteT*)pcZe , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLoRnONE ) ; //FORMATS IFF NOT YET FORMATTED
        countT cb1 = cbZe ;
        ZE( flagsT , flResult ) ;

        thirdC::c_memsetIF( tinP , (byteT*)pcZe , cbZe ) ;
        const countT cbZe = sizeof( countT ) * TUCK ;
    {
    if( pcZe )
    etherP.newF( tinP , LF , pcZe , TUCK ) ; ___( pcZe ) ;
    ZE( countT* , pcZe ) ;
{
swBooksByIdjContainerIdjUri( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , lever_pbIdjContainerIdjUri , 2 * sizeof( countT ) , 0 , sizeof( booksC ) , ifcIDgRABlAYER_7BASEmISC3 )
st_idjUri( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_countT ) ,
idOut( 0 ) ,
idIn( 0 ) ,
cWorkers( 0 ) ,
bFireWorkers( 0 ) ,
st_pPageEvent( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_countT ) ,

pczTallyByDuck( 0 ) ,
bkTallyByDuck( tinP , TAG( TAGiDnULL ) , "bkTallyByDuck" , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE , sizeof( countT ) * TUCK ) ,

jhsOther(      tinP , "jotAccessEvents.hash.string.other"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [STRING]; WO JOT PER UNIQUE STRING
jhsBrowser(    tinP , "jotAccessEvents.hash.string.browser" , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsQuery(      tinP , "jotAccessEvents.hash.string.query"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsUri(        tinP , "jotAccessEvents.hash.string.uri"     , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
workS::workS( tinS& tinP , etherC& etherP ) :

}
    swBooksByIdjContainerIdjUri.ungrabF( tinP ) ;

    //tinP.pEther->traceF( tinP , T("destroyed  all output books [idOut,cFlavors,heap.cNew-cDel]:    ")+TF2(idOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(processGlobal3S::_processGlobal3I_IF().heap.cNewF()-processGlobal3S::_processGlobal3I_IF().heap.cDelF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    swBooksByIdjContainerIdjUri.freeAllF( tinP ) ;

    }
        //tinP.pEther->traceF( tinP , T("destroying a book [idf,cFlavors]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        //tinP.pcUtility[ 0 ] -- ; //U:: TO FIND A BUG
        DELzOMBIE( pBooks ) ;
        //tinP.pcUtility[ 0 ] ++ ; //U:: TO FIND A BUG
        booksC* pBooks = (booksC*)&(countT&)swBooksByIdjContainerIdjUri ;
        lever_pbIdjContainerIdjUri = (const byteT*)swBooksByIdjContainerIdjUri.leverF( tinP , idf ) ;
        //tinP.pEther->traceF( tinP , T("destroying a book [idf,cFlavors]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )

    //tinP.pEther->traceF( tinP , T("destroying all output books [idOut,cFlavors]:    ")+TF2(idOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    countT cFlavors = swBooksByIdjContainerIdjUri.cFlavorsF( tinP ) ;

    swBooksByIdjContainerIdjUri.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT workS::destroyBooksF( tinS& tinP )

}
    //tinP.pEther->traceF( tinP , T("~workS: called  destroyBooksF") ) ;
    destroyBooksF( tinP ) ;
    //tinP.pEther->traceF( tinP , T("~workS: calling destroyBooksF") ) ;
    TINSL
{
workS::~workS( voidT )

countT cOut ;
countT cIn ;

;
}
    voidT destroyBooksF( tinS& tinP ) ;
    workS( tinS& tinP , etherC& etherP ) ;
    ~workS( voidT ) ;

    switchC       swBooksByIdjContainerIdjUri ;
    const byteT*  lever_pbIdjContainerIdjUri ;

    stackC        st_idjUri ;

    countT        idOut ;
    countT        idIn ;
    countT        cWorkers ;
    boolT         bFireWorkers ;

    stackC        st_pPageEvent ;

    countT*       pczTallyByDuck ;
    bookC         bkTallyByDuck ;

    jotC          jhsOther   ;
    jotC          jhsBrowser ;
    jotC          jhsQuery   ;          //CS:CODEsYNC: 73a 740 (THESE MUST BE CT IN THE SAME ORDER SO THAT THE SAME TAG VALES ARE ASSIGNED
    jotC          jhsUri     ;          // EVERY JOT INSTANCE CONTAINS HASH PREFIXED STRINGS TO KEEP CODE SIMPLE EVEN THOUGH THE HASH IS NOT USEFUL FOR THE STRINGS IN jhsOther
{
struct workS

//I AM STEP 2: INPUT: BYTE1 SORT; OUTPUT: BYTE2 SORT

/*1*/WAKEhIDE( "ifcIDaDAM_ACCESSeVENTS6bOOKbYcONTAINERuRI" )/*1*/
/**/
*/
 if this happens, all page books must be manually deleted and then regenerated (by editing my code to make me enabled during the initial reading)
 it is critically important to never fire me when new events have been booked but i have not yet "page booked" them
 i enable myself only after reading all existing booked events, when i nap for the woth time
during initialization, i assume that all existing booked events have already been "page booked' and ignore them
 on output, each access event is written to a book dedicated to the corresponding idJot pair that identifies [container] [uri]
 the idJot values identify strings that i place into jotC instances
 on output, each access event soulC contains idJot values rather than string values
 on input, each access event soulC is self sufficient in that it contains string values
i "divide and conquer" by distributing access events to a dedicated booksC instance for each hash of [container] || [uri]
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
