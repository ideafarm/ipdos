
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        if( delta == 1 ) break ;
        }
            }
                bOneMoreGood = 1 ;
                value = highestGood ;
            {
            if( highestGood + delta == lowestBad )

            }
                }
                    bOneMoreGood = 1 ;
                    value = lowestBad ; //U: WHY CAN THIS OCCUR?
                {
                if( value > lowestBad )
                value -= delta ;
                if( lowestBad > value || !lowestBad ) lowestBad = value ;
            {
            else
            }
                if( value > lowestBad ) value = lowestBad ; //U: WHY CAN THIS OCCUR?
                value += delta ;
                if( highestGood < value ) highestGood = value ;
                valueGoodLag = value ;
                if( value == valueGoodLag ) break ;
                if( bOneMoreGood ) break ;

                mostRecentGood = value ;
            {
            if( (*pTrialFP)( tinP , pEther , value , pMemory ) )

            if( mostRecentGood == value ) break ; // I AM CYCLING
        {
        while( !pEtherP || !*pEtherP )
        ZE( boolT , bOneMoreGood ) ;
        ZE( countT , valueGoodLag ) ;
        value = ( lowestBad + highestGood ) / 2 ;
        if( !delta ) delta = 1 ;
        delta = ( lowestBad - highestGood ) / 0x10 ;
    {
    while( !pEtherP || !*pEtherP )
    ZE( countT , delta ) ;
    mostRecentGood = 0 ;

    }
        }
            break ;
            value = highestGood ;
        {
        if( highestGood << 1 == lowestBad )

        }
            value >>= 1 ;
            if( lowestBad > value || !lowestBad ) lowestBad = value ;
        {
        else
        }
            value <<= 1 ;
            if(  highestGood < value ) highestGood = value ;
            mostRecentGood = value ;
        {
        if( (*pTrialFP)( tinP , pEther , value , pMemory ) )

        if( mostRecentGood == value ) break ; // I AM CYCLING
    {
    while( !pEtherP || !*pEtherP )

    ZE( countT , mostRecentGood ) ;
    ZE( boolT , bOk ) ;
    ZE( countT , lowestBad ) ;
    ZE( countT , highestGood ) ;

    value = (countT)( - 1 ) / 2 ;
    if( ( pEtherP && *pEtherP ) || !bZeOk ) return ;
    if( pEtherP ) __Z( bZeOk ) ;
    countT bZeOk = (*pTrialFP)( tinP , pEther , value , pMemory ) ;
    countT pMemory = (countT)pMemoryP ;
    countT pEther = (countT)pEtherP ;
    value = 0 ;

    }
        if( !pTrialFP ) return ;
        if( pEtherP && *pEtherP ) return ;
        if( pEtherP ) __Z( pTrialFP ) ;
        if( pEtherP && *pEtherP ) return ;
    {
    IFbEcAREFUL

    // 4. CHECK ALL POIN_PETS IN THE RANGE
    // 3. REPEAT 2 UNTIL RANGE IS LESS THAN 0x10 POINTS
    // 2. SEARCH BY CHECKING 0x10 EQUALLY SPACED POINTS
    // 1. SEARCH BY DOUBLING AND HALVING UNTIL HAVE A BOUNDING RANGE WHERE HIGH = 2 * LOW
    // ALGORITHM:
    //U: CRAFT CODE TO IMPLEMENT STEPS 2-9
{
value( 0 )
/*1*/maxC::maxC( tinS& tinP , etherC* pEtherP , ifc3FT pTrialFP , voidT* const pMemoryP )/*1*/ :
/**/
*/
 pMemoryP
 pTrialFP
 pEtherP
arguments
 }
 return value < 0x100 ;
 POOPIE
 pInfo->cba = value ;
 infoS* pInfo = (infoS*)pMemoryP ;
 countT& value = *(countT*)pValueP ;
 if( !pValueP || !pMemoryP ) return 0 ;
 {
 countT bOkF( countT& pEtherP , countT& pValueP , countT& pMemoryP )
in your callback function, cast parameters as in this example
your callback function will continue to be called many times after it is first successful, in order to explore the entire countT domain
in general, you should detect and undo the previous trial if it was successful, just before trying again
pTrialFP is a user supplied callback function of type ifc3FT that will be called to try the task or test the condition
pEtherP can be 0
an object of this class can find the maximum countT value for which some condition is true or task is successful
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.1180001.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

