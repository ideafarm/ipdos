
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            etThread.delF( tinP , psttFile ) ;

            DEL( prPosts ) ;
            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            etThread.strMakeF( tinP , prPosts , T("<p>\r\n")+tOut+T("\r\n") , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            ZE( pbRefC* , prPosts ) ;

            }
                ) ;

                    "</table>\r\n"
                        "</tr>\r\n"
                            "</td>\r\n"
                                "<span style=\"color:Cyan\">")+tSaidTimeForeign+T(": </span>")+tSaidSpeech+T("\r\n"
                            "<td valign=\"center\">\r\n"
                            "</td>\r\n"
                                "</form>\r\n"
                                    "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Certify\"/>\r\n"
                                    "<input id=\"secret\" name=\"secret\" type=\"hidden\" value=\"")+tValueSecret+T("\"/>\r\n"
                                    "<input id=\"subscriberid\" name=\"subscriberid\" type=\"hidden\" value=\"")+tValueSubscriberId+T("\"/>\r\n"
                                    "<input id=\"filename\" name=\"filename\" type=\"hidden\" value=\"")+T(psttFile)+T("\"/>\r\n"
                                "<form action=\"https://")+T(bSandbox?"factory1.":"")+T("ideafarm.com/talk.anonymous\" id=\"certify\" method=\"post\" name=\"certify\">\r\n"
                            "<td valign=\"center\">\r\n"
                        "<tr>\r\n"
                    "<table>\r\n"
                    "<p>\r\n"

                tOut = T(
            {
            else
            }
                tOut = T("<span style=\"color:Cyan\">")+tSaidTimeForeign+T(": </span>")+tLoginToView ;
            {
            if( !bSecretIsOK )
            TN( tOut , "" ) ;

            }
                said >> nnPeer ;
                nicNameC nnPeer ;

                etThread.delF( tinP , psttSpeechClean ) ;
                tSaidSpeech = T(psttSpeechClean) ;
                said >> psttSpeechClean ; ___( psttSpeechClean ) ;
                ZE( strokeS* , psttSpeechClean ) ;

                etThread.delF( tinP , psttValueSpeech ) ;
                said >> psttValueSpeech ; ___( psttValueSpeech ) ;
                ZE( strokeS* , psttValueSpeech ) ;

                etThread.delF( tinP , psttTimeForeign ) ;
                tSaidTimeForeign = T(psttTimeForeign) ;
                said >> psttTimeForeign ; ___( psttTimeForeign ) ;
                ZE( strokeS* , psttTimeForeign ) ;

                said >> *(countT*)&timeS2 ;
                ZE( sCountT , timeS2 ) ;

                said >> timeS1 ;
                ZE( countT , timeS1 ) ;

                said >> idFormat ;
                ZE( countT , idFormat ) ;

                said >> finger ;
                ZE( countT , finger ) ;

                etThread.boxGetShadowF( tinP , said , psttFile ) ;
                soulC said( tinP , TAG( TAGiDnULL ) ) ;
            {
            TN( tSaidSpeech , "" ) ;
            TN( tSaidTimeForeign , "" ) ;

            stFile >> psttFile ;
            ZE( strokeS* , psttFile ) ;
        {
        while( stFile )
        TN( tLoginToView , "To view the anonymous post, you must provide your ID and secret." ) ;
        TN( tb4 , "    " ) ;
        TN( tb , " " ) ;

        }
            while( ~hFind && !POOP ) ;
            }
                DEL( pInfo ) ;
                }
                    if( !ids ) etThread.delF( tinP , psttFile ) ; //SHOULD BE IMPOSSIBLE
                    stFile.sinkF( tinP , ids , psttFile , flSTACKsINK_UNIQUE|flSTACKsINK_REVERSE ) ;
                    ZE( countT , ids ) ;

                    etThread.strMakeF( tinP , psttFile , pInfo->psttIfoName ) ; ___( psttFile ) ;
                    ZE( strokeS* , psttFile ) ;
                {
                else
                }
                    break ;
                    DEL( pInfo ) ;
                {
                if( !pInfo || !pInfo->psttIfoName )

                etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tPath , &pat ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            do
            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
            TN( tPattern , "" ) ; tPattern = T("said.anon.table")+T(bSandbox?".sandbox.*":".live.*") ;
            TN( tPath , "////factory3/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said.anon/" ) ;
        {
        stackC stFile( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS , ifcIDgRABlAYER_7BASEmISC1 ) ;

        }
            }
                THREADmODE1rESTORE

                etThread.boxPutF( tinP , T("smtp.mailgun.org[admin]/b42/smtp/")+tHost+T("@ideafarm.com/")+tToUse+T("//wo@ideafarm.com/ideafarm.factory.reports@gmail.com") , tBody ) ;

                ;
                    : tSaidPaypalPayerEmail
                    ? tEmailSandboxMe
                textC& tToUse = bSandbox
                TN( tEmailSandboxMe , "ideafarmcity@gmail.com" ) ;

                tBody += T("time:  ")+tTimeForeign+T("\r\n") ;
                tBody += T("\r\nreference:  ")+tShort+T("\r\n") ;

                tBody += T("your post:\r\n\r\n")+tValueSpeech+T("\r\n\r\n") ;

                ) ;

                    "\r\n"
                    "\r\n"
                    "Subject: Wo'O's Table:  You just posted this on Wo'O's Table Talk.\r\n"

                TN( tBody ,

                }
                    etThread.delF( tinP , psttFile ) ;
                    etThread.delF( tinP , psttShort ) ;
                    etThread.delF( tinP , psttnu ) ;
                    tShort = T(psttShort) ;
                    etThread.strBisectF( tinP , psttnu , psttShort , psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                    ZE( strokeS* , psttShort ) ;
                    ZE( strokeS* , psttnu ) ;

                    etThread.traceF( tinP , T("wrote   ")+T(psttFile) ) ;
                    etThread.boxPutUniqueF( tinP , psttFile , tFile , WS( said ) ) ; ___( psttFile ) ;
                    ZE( strokeS* , psttFile ) ;

                    TN( tFile , "" ) ; tFile = T("////factory3/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said/said.table")+T(bSandbox?".sandbox.":".live.")+T("@1@")+T(".")+tHost ;
                {
                TN( tShort , "" ) ;

                }
                    if( !tHost.csF( tinP ) ) tHost = T("factories") ;
                    etThread.delF( tinP , psttHost ) ;
                    else       tHost = T(psttHost) ;
                    if( POOP ) { POOPR ; }
                    tinP.pEtScratch->sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
                    ZE( strokeS* , psttHost ) ;

                    SCOOPS
                {
                IFsCRATCH
                TN( tHost , "" ) ;

                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                said << (strokeS*)tSaidAddressStatus ;
                said << (strokeS*)tSaidAddressZip ;
                said << (strokeS*)tSaidAddressCountry ;
                said << (strokeS*)tSaidAddressCountryCode ;
                said << (strokeS*)tSaidAddressState ;
                said << (strokeS*)tSaidAddressCity ;
                said << (strokeS*)tSaidAddressStreet ;
                said << nnPeerAnon ;
                said << (strokeS*)tSaidNnPeer ;
                said << (strokeS*)tSaidZipUse ;
                said << (strokeS*)tSaidAddressName ;
                said << (strokeS*)tSaidLastName ;
                said << (strokeS*)tSaidFirstName ;
                said << (strokeS*)tSaidPaypalPayerEmail ;
                said << (strokeS*)tSaidIdSubscriber0 ;
                said << (strokeS*)tSaidSpeechAnonClean ;
                said << (strokeS*)tSaidSpeechAnon ;
                said << (strokeS*)T("anonymous") ;
                said << (strokeS*)tTimeForeign ;
                said << (countT)timeN2 ;
                said << timeN1 ;
                said << (countT)4 ;             // IDfORMAT
                said << finger ;
                soulC said( tinP , TAG( TAGiDnULL ) ) ;

                putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEsAID ) ;
                ZE( countT , finger ) ;

                textC tTimeForeign( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

                etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT , timeN1 ) ;
            {
            if( tSaidSpeechAnonClean.csF( tinP ) )

            }
                }
                    }
                        rec >> nnPeerAnon ;

                        etThread.delF( tinP , psttSpeechClean ) ;
                        tSaidSpeechAnonClean = T(psttSpeechClean) ;
                        rec >> psttSpeechClean ; ___( psttSpeechClean ) ;
                        ZE( strokeS* , psttSpeechClean ) ;

                        etThread.delF( tinP , psttValueSpeech ) ;
                        tSaidSpeechAnon = T(psttValueSpeech) ;
                        rec >> psttValueSpeech ; ___( psttValueSpeech ) ;
                        ZE( strokeS* , psttValueSpeech ) ;

                        etThread.delF( tinP , psttTimeForeign ) ;
                        rec >> psttTimeForeign ; ___( psttTimeForeign ) ;
                        ZE( strokeS* , psttTimeForeign ) ;

                        rec >> *(countT*)&timeS2 ;
                        ZE( sCountT , timeS2 ) ;

                        rec >> timeS1 ;
                        ZE( countT , timeS1 ) ;

                        rec >> idFormat ;
                        ZE( countT , idFormat ) ;

                        rec >> finger ;
                        ZE( countT , finger ) ;
                    {
                {
                else
                if( POOP ) { POOPR ; }
                tinP.pEtScratch->boxGetF( tinP , rec , tValueFileName , 1 , 1 ) ;
                soulC rec( tinP , TAG( TAGiDnULL ) ) ;

                SCOOPS
            {
            IFsCRATCH
            nicNameC nnPeerAnon ;
            TN( tSaidSpeechAnonClean , "" ) ;
            TN( tSaidSpeechAnon      , "" ) ;
        {
        if( tValueFileName.csF( tinP ) && bSecretIsOK )

        }
            THREADmODE1rESTORE

            }
                etThread.delF( tinP , psttFile ) ;
                etThread.delF( tinP , psttShort ) ;
                etThread.delF( tinP , psttnu ) ;
                tShort = T(psttShort) ;
                etThread.strBisectF( tinP , psttnu , psttShort , psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttnu ) ;

                etThread.traceF( tinP , T("wrote   ")+T(psttFile) ) ;
                etThread.boxPutUniqueF( tinP , psttFile , tFile , WS( said ) ) ; ___( psttFile ) ;
                ZE( strokeS* , psttFile ) ;

                TN( tFile , "" ) ; tFile = T("////factory3/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said.anon/said.anon.table")+T(bSandbox?".sandbox.":".live.")+T("@1@")+T(".")+tHost ;
            {
            TN( tShort , "" ) ;

            }
                if( !tHost.csF( tinP ) ) tHost = T("factories") ;
                etThread.delF( tinP , psttHost ) ;
                else       tHost = T(psttHost) ;
                if( POOP ) { POOPR ; }
                tinP.pEtScratch->sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
                ZE( strokeS* , psttHost ) ;

                SCOOPS
            {
            IFsCRATCH
            TN( tHost , "" ) ;

            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            said << nnPeerP ;
            said << (strokeS*)tSpeechClean ;
            said << (strokeS*)tValueSpeech ;
            said << (strokeS*)tTimeForeign ;
            said << (countT)timeN2 ;
            said << timeN1 ;
            said << (countT)1 ;             // IDfORMAT
            said << finger ;
            soulC said( tinP , TAG( TAGiDnULL ) ) ;

            putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEsAIDaNON ) ;
            ZE( countT , finger ) ;

            textC tTimeForeign( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;

            }
                etThread.delF( tinP , psttClean ) ;
                tSpeechClean = T(psttClean) ;

                etThread.delF( tinP , psttRaw ) ;
                etThread.strReplaceAnyF( tinP , psttClean , psttRaw , T("<>") , T(".") ) ; ___( psttClean ) ;
                ZE( strokeS* , psttClean ) ;

                etThread.strMakeF( tinP , psttRaw , tValueSpeech ) ; ___( psttRaw ) ;
                ZE( strokeS* , psttRaw ) ;
            {
            TN( tSpeechClean , "" ) ;                //SANITIZE THE SPEECH TO SUPPRESS ALL HTML
        {
        if( tValueSpeech.csF( tinP ) )

        }
            DEL( prPosts ) ;
            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

            etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            ZE( pbRefC* , prPosts ) ;

            ) ;

                "<p>\r\n"
                "I also certify that it is not off-topic and will not otherwise DISRUPT the conversation, and that in making this determination I have not considered either viewpoint or words used.\r\n"
                "It does not contain speech that is a CRIME under the laws of California or of the United States of America.\r\n"
                "It does not create a CLEAR AND PRESENT DANGER.\r\n"
                "It does not contain OBSCENITY.\r\n"
                "I, ")+tSaidFirstName+T(" ")+tSaidLastName+T(", hereby certify that the anonymous post that I select below contains no speech other than speech that is fully protected by the First Amendment.\r\n"
                "<p>\r\n"
                "<h2>Certificate</h2>\r\n"

            TN( tSay , "" ) ; tSay = T(
        {
        else
        }
            DEL( prPosts ) ;
            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

            etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

            ) ;

                "</form>\r\n"
                "</table>\r\n"
                    "</tr>\r\n"
                        "</td>\r\n"
                            "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Validate\"/>\r\n"
                        "<td valign=\"center\">\r\n"
                        "</td>\r\n"
                            "<input id=\"secret\" name=\"secret\" type=\"password\" value=\"\"/>\r\n"
                            "<label for=\"secret\">Secret:</label><br>\r\n"
                        "<td valign=\"center\">\r\n"
                        "</td>\r\n"
                            "<input id=\"subscriberid\" name=\"subscriberid\" type=\"text\" value=\"\"/>\r\n"
                            "<label for=\"subscriberid\">Subscriber ID:</label><br>\r\n"
                        "<td valign=\"center\">\r\n"
                    "<tr>\r\n"
                "<table>\r\n"
                "ideafarm.com/talk.anonymous\" id=\"idsecret\" method=\"get\" name=\"idsecret\">\r\n"
                
            tSay += T(
            if( bSandbox ) tSay += T("factory1." ) ;
            TN( tSay , "<form action=\"https://" ) ;
            ZE( pbRefC* , prPosts ) ;
        {
        if( !bSecretIsOK )

        }
            while( ~hFind && !POOP ) ;
            }
                DEL( pInfo ) ;
                }
                    etThread.delF( tinP , psttValueAddressStatus ) ;
                    tSaidAddressStatus = T(psttValueAddressStatus) ;
                    rec >> psttValueAddressStatus ; ___( psttValueAddressStatus ) ;
                    ZE( strokeS* , psttValueAddressStatus ) ;

                    etThread.delF( tinP , psttValueAddressZip ) ;
                    tSaidAddressZip = T(psttValueAddressZip) ;
                    rec >> psttValueAddressZip ; ___( psttValueAddressZip ) ;
                    ZE( strokeS* , psttValueAddressZip ) ;

                    etThread.delF( tinP , psttValueAddressCountry ) ;
                    tSaidAddressCountry = T(psttValueAddressCountry) ;
                    rec >> psttValueAddressCountry ; ___( psttValueAddressCountry ) ;
                    ZE( strokeS* , psttValueAddressCountry ) ;

                    etThread.delF( tinP , psttValueAddressCountryCode ) ;
                    tSaidAddressCountryCode = T(psttValueAddressCountryCode) ;
                    rec >> psttValueAddressCountryCode ; ___( psttValueAddressCountryCode ) ;
                    ZE( strokeS* , psttValueAddressCountryCode ) ;

                    etThread.delF( tinP , psttValueAddressState ) ;
                    tSaidAddressState = T(psttValueAddressState) ;
                    rec >> psttValueAddressState ; ___( psttValueAddressState ) ;
                    ZE( strokeS* , psttValueAddressState ) ;

                    etThread.delF( tinP , psttValueAddressCity ) ;
                    tSaidAddressCity = T(psttValueAddressCity) ;
                    rec >> psttValueAddressCity ; ___( psttValueAddressCity ) ;
                    ZE( strokeS* , psttValueAddressCity ) ;

                    etThread.delF( tinP , psttValueAddressStreet ) ;
                    tSaidAddressStreet = T(psttValueAddressStreet) ;
                    rec >> psttValueAddressStreet ; ___( psttValueAddressStreet ) ;
                    ZE( strokeS* , psttValueAddressStreet ) ;

                    etThread.delF( tinP , psttValueAddressName ) ;
                    tSaidAddressName = T(psttValueAddressName) ;
                    rec >> psttValueAddressName ; ___( psttValueAddressName ) ;
                    ZE( strokeS* , psttValueAddressName ) ;

                    etThread.delF( tinP , psttValueLastName ) ;
                    tSaidLastName = T(psttValueLastName) ;
                    rec >> psttValueLastName ; ___( psttValueLastName ) ;
                    ZE( strokeS* , psttValueLastName ) ;

                    etThread.delF( tinP , psttValueFirstName ) ;
                    tSaidFirstName = T(psttValueFirstName) ;
                    rec >> psttValueFirstName ; ___( psttValueFirstName ) ;
                    ZE( strokeS* , psttValueFirstName ) ;

                    }
                        etThread.traceF( tinP , T(bSecretIsOK?"secret is OK":"secret is NOT ok") ) ;
                        bSecretIsOK = secretTry == secret ;                 //U::DO THIS ONLY IF THIS RECORD IS NOT AN "UNSUBSCRIBE"
                    {
                    if( subscriberIdTry == idSubscriber )

                    rec >> secret ;
                    ZE( countT , secret ) ;

                    etThread.traceF( tinP , T("[tSaidIdSubscriber0]:    ")+tSaidIdSubscriber0 ) ;

                    tSaidIdSubscriber0 = TF4(((countT*)&idSubscriber)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e) ;
                    rec >> ((countT*)&idSubscriber)[ 1 ] ;
                    rec >> ((countT*)&idSubscriber)[ 0 ] ;
                    ZE( count04T , idSubscriber ) ;

                    etThread.delF( tinP , psttValueTransId ) ;
                    rec >> psttValueTransId ; ___( psttValueTransId ) ;
                    ZE( strokeS* , psttValueTransId ) ;

                    etThread.delF( tinP , psttValueTransType ) ;
                    rec >> psttValueTransType ; ___( psttValueTransType ) ;
                    ZE( strokeS* , psttValueTransType ) ;

                    etThread.delF( tinP , psttValueRewardBox ) ;
                    rec >> psttValueRewardBox ; ___( psttValueRewardBox ) ;
                    ZE( strokeS* , psttValueRewardBox ) ;

                    etThread.delF( tinP , psttValueRewardBoxHidden ) ;
                    rec >> psttValueRewardBoxHidden ; ___( psttValueRewardBoxHidden ) ;
                    ZE( strokeS* , psttValueRewardBoxHidden ) ;

                    etThread.delF( tinP , psttZipUse ) ;
                    tSaidZipUse = T(psttZipUse) ;
                    rec >> psttZipUse ; ___( psttZipUse ) ;
                    ZE( strokeS* , psttZipUse ) ;

                    etThread.delF( tinP , psttValuePaypalPayerEmail ) ;
                    tSaidPaypalPayerEmail = T(psttValuePaypalPayerEmail) ;
                    rec >> psttValuePaypalPayerEmail ; ___( psttValuePaypalPayerEmail ) ;
                    ZE( strokeS* , psttValuePaypalPayerEmail ) ;

                    etThread.delF( tinP , psttNnPeer ) ;
                    tSaidNnPeer = T(psttNnPeer) ;
                    rec >> psttNnPeer ; ___( psttNnPeer ) ;
                    ZE( strokeS* , psttNnPeer ) ;

                    etThread.delF( tinP , psttAction ) ;
                    rec >> psttAction ; ___( psttAction ) ;
                    ZE( strokeS* , psttAction ) ;

                    rec >> *(countT*)&timeS2 ;
                    ZE( sCountT , timeS2 ) ;

                    rec >> timeS1 ;
                    ZE( countT , timeS1 ) ;

                    rec >> idFormat ;
                    ZE( countT , idFormat ) ;

                    rec >> finger ;
                    ZE( countT , finger ) ;

                    etThread.boxGetShadowF( tinP , rec , pInfo->psttIfoName ) ;
                    soulC rec( tinP , TAG( TAGiDnULL ) ) ;

                    etThread.traceF( tinP , T("found 1:    ")+T(fn) ) ;
                    fileNameC fn( tinP , etThread , pInfo->psttIfoName ) ;
                {
                else
                }
                    break ;
                    DEL( pInfo ) ;
                {
                if( !pInfo || !pInfo->psttIfoName )

                etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tPath , &pat ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            do
            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
            TN( tPattern , "subscription.table.live.*" ) ;
            TN( tPath , "////factory3/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/subscriptions/" ) ;
        {
        if( subscriberIdTry && secretTry )
        TN( tSaidAddressStatus      , "" ) ;
        TN( tSaidAddressZip         , "" ) ;
        TN( tSaidAddressCountry     , "" ) ;
        TN( tSaidAddressCountryCode , "" ) ;
        TN( tSaidAddressState       , "" ) ;
        TN( tSaidAddressCity        , "" ) ;
        TN( tSaidAddressStreet      , "" ) ;
        TN( tSaidAddressName        , "" ) ;
        TN( tSaidLastName           , "" ) ;
        TN( tSaidFirstName          , "" ) ;
        TN( tSaidIdSubscriber0      , "" ) ;
        TN( tSaidZipUse             , "" ) ;
        TN( tSaidPaypalPayerEmail   , "" ) ;
        TN( tSaidNnPeer             , "" ) ;
        ZE( boolT , bSecretIsOK ) ;
        //VALIDATE THE SECRET

        countT   secretTry       = etThread.strDigitsToSCountF( tinP , tValueSecret       , 0x3e ) ;
        count04T subscriberIdTry = etThread.strDigitsToSCountF( tinP , tValueSubscriberId , 0x3e ) ; //U:: THIS WILL ONLY WORK IF THE ID IS <= MAXCOUNTT

        if( tValueFileName.csF(     tinP ) ) etThread.traceF( tinP , tKeyFileName    +T(":    ")+tValueFileName     ) ;
        if( tValueSpeech.csF(       tinP ) ) etThread.traceF( tinP , tKeySpeech      +T(":    ")+tValueSpeech       ) ;
        if( tValueSecret.csF(       tinP ) ) etThread.traceF( tinP , tKeySecret      +T(":    ")+tValueSecret       ) ;
        if( tValueSubscriberId.csF( tinP ) ) etThread.traceF( tinP , tKeySubscriberId+T(":    ")+tValueSubscriberId ) ;

        }
            }
                if( !etThread.strCompareF( tinP , psttLeverKVP , *pptKey[ offk ] ) ) *pptValue[ offk ] = T((strokeS*)(countT)swKVP) ;
            {
            for( countT offk = 0 ; offk < sizeof pptKey / sizeof pptKey[ 0 ] ; offk ++ )

            //}
            //    DEL( prPosts ) ;
            //    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            //    etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            //
            //    etThread.traceF( tinP , tSay ) ;
            //    TN( tSay , "" ) ; tSay = T("<p>\r\n")+T(psttLeverKVP)+T(":    ")+T((strokeS*)(countT)swKVP) ;
            //
            //    ZE( pbRefC* , prPosts ) ;
            //{

            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swKVP.cFlavorsF( tinP ) ;

        } ;
            &tValueFileName     ,
            &tValueSpeech       ,
            &tValueSecret       ,
            &tValueSubscriberId ,
        {
        textC* pptValue[] =

        } ;
            &tKeyFileName     ,
            &tKeySpeech       ,
            &tKeySecret       ,
            &tKeySubscriberId ,
        {
        textC* pptKey[] =

        TN( tValueFileName     , "" ) ;
        TN( tValueSpeech       , "" ) ;
        TN( tValueSecret       , "" ) ;
        TN( tValueSubscriberId , "" ) ;

        TN( tKeyFileName     , "filename"     ) ;
        TN( tKeySpeech       , "speechanon"   ) ;
        TN( tKeySecret       , "secret"       ) ;
        TN( tKeySubscriberId , "subscriberid" ) ;

        boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

        }
            DEL( prPosts ) ;
            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

            etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            ZE( pbRefC* , prPosts ) ;

            ) ;

                "<p>\r\n"
                "The anonymous posts listed here are awaiting approval by a subscriber.\r\n"
                "<p>\r\n"
                "<h1>Wo'O's Table Talk:  Anonymous posts awaiting approval</h1>\r\n"

            TN( tSay ,
        {
    {
    else
    }
        DEL( prPosts ) ;
        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

        etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        ZE( pbRefC* , prPosts ) ;

        ) ;

            "<p>\r\n"
            "Try again after a TICK (about 6 foreign minutes).\r\n"
            "Your IP address is currently blcoked.\r\n"
            "<p>\r\n"
            "<h1>Wo'O's Table Talk:  Anonymous posts awaiting approval</h1>\r\n"

        TN( tSay ,
    {
    if( bBlocked )

    }
        while( ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                else                          bBlocked = 1 ;
                if( timeE2 || timeE1 > TICK ) etThread.diskFileOrDirDeleteF( tinP , pInfo->psttIfoName , flFILEoRdIRdELETE_null , 1 ) ;

                etThread.traceF( tinP , T("age: ")+TT(timeE1,timeE2) ) ;
                etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , pInfo->timeCreated1 , pInfo->timeCreated2 ) ;
                etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                ZE( sCountT , timeE2 ) ;
                ZE( countT , timeE1 ) ;
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tPath , &pat ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        TN( tPattern , "blocked.ip." ) ; tPattern += T(nnPeerP)+T(".*") ;
        TN( tPath , "////factory3/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/blocked.ip/" ) ;
    {
    ZE( boolT , bBlocked ) ;

    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW ) ;

    //if( psttKVReportP && psttKVReportP->idAdam ) etThread.traceF( tinP , psttKVReportP ) ;
{
/*1*/voidT talkAnonCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttUrlP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

