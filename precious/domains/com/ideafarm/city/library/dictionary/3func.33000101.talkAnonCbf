
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            etThread.delF( tinP , psttFile ) ;

            DEL( prPosts ) ;
            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            etThread.strMakeF( tinP , prPosts , T("<p>\r\n")+tOut+T("\r\n") , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            ZE( pbRefC* , prPosts ) ;

            TN( tOut , "" ) ; tOut = T("<span style=\"color:Cyan\">")+tSaidTimeForeign+T(": </span>")+tSaidSpeech ;

            }
                said >> nnPeer ;
                nicNameC nnPeer ;

                etThread.delF( tinP , psttSpeechClean ) ;
                tSaidSpeech = T(psttSpeechClean) ;
                said >> psttSpeechClean ; ___( psttSpeechClean ) ;
                ZE( strokeS* , psttSpeechClean ) ;

                etThread.delF( tinP , psttValueSpeech ) ;
                said >> psttValueSpeech ; ___( psttValueSpeech ) ;
                ZE( strokeS* , psttValueSpeech ) ;

                etThread.delF( tinP , psttTimeForeign ) ;
                tSaidTimeForeign = T(psttTimeForeign) ;
                said >> psttTimeForeign ; ___( psttTimeForeign ) ;
                ZE( strokeS* , psttTimeForeign ) ;

                said >> *(countT*)&timeS2 ;
                ZE( sCountT , timeS2 ) ;

                said >> timeS1 ;
                ZE( countT , timeS1 ) ;

                said >> idFormat ;
                ZE( countT , idFormat ) ;

                said >> finger ;
                ZE( countT , finger ) ;

                etThread.boxGetShadowF( tinP , said , psttFile ) ;
                soulC said( tinP , TAG( TAGiDnULL ) ) ;
            {
            TN( tSaidSpeech , "" ) ;
            TN( tSaidTimeForeign , "" ) ;

            stFile >> psttFile ;
            ZE( strokeS* , psttFile ) ;
        {
        while( stFile )
        TN( tb4 , "    " ) ;

        }
            while( ~hFind && !POOP ) ;
            }
                DEL( pInfo ) ;
                }
                    if( !ids ) etThread.delF( tinP , psttFile ) ; //SHOULD BE IMPOSSIBLE
                    stFile.sinkF( tinP , ids , psttFile , flSTACKsINK_UNIQUE|flSTACKsINK_REVERSE ) ;
                    ZE( countT , ids ) ;

                    etThread.strMakeF( tinP , psttFile , pInfo->psttIfoName ) ; ___( psttFile ) ;
                    ZE( strokeS* , psttFile ) ;
                {
                else
                }
                    break ;
                    DEL( pInfo ) ;
                {
                if( !pInfo || !pInfo->psttIfoName )

                etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tPath , &pat ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            do
            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
            TN( tPattern , "" ) ; tPattern = T("said.anon.table")+T(bSandbox?".sandbox.*":".live.*") ;
            TN( tPath , "////factory3/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said.anon/" ) ;
        {
        stackC stFile( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS , ifcIDgRABlAYER_7BASEmISC1 ) ;

        }
            THREADmODE1rESTORE

            }
                etThread.delF( tinP , psttFile ) ;
                etThread.delF( tinP , psttShort ) ;
                etThread.delF( tinP , psttnu ) ;
                tShort = T(psttShort) ;
                etThread.strBisectF( tinP , psttnu , psttShort , psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttnu ) ;

                etThread.traceF( tinP , T("wrote   ")+T(psttFile) ) ;
                etThread.boxPutUniqueF( tinP , psttFile , tFile , WS( said ) ) ; ___( psttFile ) ;
                ZE( strokeS* , psttFile ) ;

                TN( tFile , "" ) ; tFile = T("////factory3/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said.anon/said.anon.table")+T(bSandbox?".sandbox.":".live.")+T("@1@")+T(".")+tHost ;
            {
            TN( tShort , "" ) ;

            }
                if( !tHost.csF( tinP ) ) tHost = T("factories") ;
                etThread.delF( tinP , psttHost ) ;
                else       tHost = T(psttHost) ;
                if( POOP ) { POOPR ; }
                tinP.pEtScratch->sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
                ZE( strokeS* , psttHost ) ;

                SCOOPS
            {
            IFsCRATCH
            TN( tHost , "" ) ;

            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            said << nnPeerP ;
            said << (strokeS*)tSpeechClean ;
            said << (strokeS*)tValueSpeech ;
            said << (strokeS*)tTimeForeign ;
            said << (countT)timeN2 ;
            said << timeN1 ;
            said << (countT)1 ;             // IDfORMAT
            said << finger ;
            soulC said( tinP , TAG( TAGiDnULL ) ) ;

            putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEsAIDaNON ) ;
            ZE( countT , finger ) ;

            textC tTimeForeign( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;

            }
                etThread.delF( tinP , psttClean ) ;
                tSpeechClean = T(psttClean) ;

                etThread.delF( tinP , psttRaw ) ;
                etThread.strReplaceAnyF( tinP , psttClean , psttRaw , T("<>") , T(".") ) ; ___( psttClean ) ;
                ZE( strokeS* , psttClean ) ;

                etThread.strMakeF( tinP , psttRaw , tValueSpeech ) ; ___( psttRaw ) ;
                ZE( strokeS* , psttRaw ) ;
            {
            TN( tSpeechClean , "" ) ;                //SANITIZE THE SPEECH TO SUPPRESS ALL HTML
        {
        if( tValueSpeech.csF( tinP ) )

        etThread.traceF( tinP , tKeySpeech      +T(":    ")+tValueSpeech       ) ;

        }
            }
                if( !etThread.strCompareF( tinP , psttLeverKVP , *pptKey[ offk ] ) ) *pptValue[ offk ] = T((strokeS*)(countT)swKVP) ;
            {
            for( countT offk = 0 ; offk < sizeof pptKey / sizeof pptKey[ 0 ] ; offk ++ )

            //}
            //    DEL( prPosts ) ;
            //    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            //    etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            //
            //    etThread.traceF( tinP , tSay ) ;
            //    TN( tSay , "" ) ; tSay = T("<p>\r\n")+T(psttLeverKVP)+T(":    ")+T((strokeS*)(countT)swKVP) ;
            //
            //    ZE( pbRefC* , prPosts ) ;
            //{

            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swKVP.cFlavorsF( tinP ) ;

        } ;
            &tValueSpeech       ,
        {
        textC* pptValue[] =

        } ;
            &tKeySpeech       ,
        {
        textC* pptKey[] =

        TN( tValueSpeech       , "" ) ;

        TN( tKeySpeech       , "speechanon" ) ;

        boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

        }
            DEL( prPosts ) ;
            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

            etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            ZE( pbRefC* , prPosts ) ;

            ) ;

                "<p>\r\n"
                "The anonymous posts listed here are awaiting approval by a subscriber.\r\n"
                "<p>\r\n"
                "<h1>Wo'O's Table Talk:  Anonymous posts awaiting approval</h1>\r\n"

            TN( tSay ,
        {
    {
    else
    }
        DEL( prPosts ) ;
        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

        etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        ZE( pbRefC* , prPosts ) ;

        ) ;

            "<p>\r\n"
            "Try again after a TICK (about 6 foreign minutes).\r\n"
            "Your IP address is currently blcoked.\r\n"
            "<p>\r\n"
            "<h1>Wo'O's Table Talk:  Anonymous posts awaiting approval</h1>\r\n"

        TN( tSay ,
    {
    if( bBlocked )

    }
        while( ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                else                          bBlocked = 1 ;
                if( timeE2 || timeE1 > TICK ) etThread.diskFileOrDirDeleteF( tinP , pInfo->psttIfoName , flFILEoRdIRdELETE_null , 1 ) ;

                etThread.traceF( tinP , T("age: ")+TT(timeE1,timeE2) ) ;
                etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , pInfo->timeCreated1 , pInfo->timeCreated2 ) ;
                etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                ZE( sCountT , timeE2 ) ;
                ZE( countT , timeE1 ) ;
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tPath , &pat ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        TN( tPattern , "blocked.ip." ) ; tPattern += T(nnPeerP)+T(".*") ;
        TN( tPath , "////factory3/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/blocked.ip/" ) ;
    {
    ZE( boolT , bBlocked ) ;

    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW ) ;

    //if( psttKVReportP && psttKVReportP->idAdam ) etThread.traceF( tinP , psttKVReportP ) ;
{
/*1*/voidT talkAnonCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttUrlP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

