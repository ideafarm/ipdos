
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            DEL( prPosts ) ;
            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

            etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            ZE( pbRefC* , prPosts ) ;

            ) ;

                "<p>\r\n"
                "I also certify that it is not off-topic and will not otherwise DISRUPT the conversation, and that in making this determination I have not considered either viewpoint or words used.\r\n"
                "It does not contain speech that is a CRIME under the laws of California or of the United States of America.\r\n"
                "It does not create a CLEAR AND PRESENT DANGER.\r\n"
                "It does not contain OBSCENITY.\r\n"
                "I, ")+tSaidFirstName+T(" ")+tSaidLastName+T(", hereby certify that the anonymous post that I select below contains no speech other than speech that is fully protected by the First Amendment.\r\n"
                "<p>\r\n"
                "<h2>Certificate</h2>\r\n"

            TN( tSay , "" ) ; tSay = T(
        {
        else
        }
            DEL( prPosts ) ;
            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

            etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

            ) ;

                "</form>\r\n"
                "</table>\r\n"
                    "</tr>\r\n"
                        "</td>\r\n"
                            "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Validate\"/>\r\n"
                        "<td valign=\"center\">\r\n"
                        "</td>\r\n"
                            "<input id=\"secret\" name=\"secret\" type=\"password\" value=\"\"/>\r\n"
                            "<label for=\"secret\">Secret:</label><br>\r\n"
                        "<td valign=\"center\">\r\n"
                        "</td>\r\n"
                            "<input id=\"subscriberid\" name=\"subscriberid\" type=\"text\" value=\"\"/>\r\n"
                            "<label for=\"subscriberid\">Subscriber ID:</label><br>\r\n"
                        "<td valign=\"center\">\r\n"
                    "<tr>\r\n"
                "<table>\r\n"
                "ideafarm.com/talk.anonymous\" id=\"idsecret\" method=\"get\" name=\"idsecret\">\r\n"
                
            tSay += T(
            if( bSandbox ) tSay += T("factory1." ) ;
            TN( tSay , "<form action=\"https://" ) ;
            ZE( pbRefC* , prPosts ) ;
        {
        if( !bSecretIsOK )

        }
            while( ~hFind && !POOP ) ;
            }
                DEL( pInfo ) ;
                }
                    etThread.delF( tinP , psttValueAddressStatus ) ;
                    tSaidAddressStatus = T(psttValueAddressStatus) ;
                    rec >> psttValueAddressStatus ; ___( psttValueAddressStatus ) ;
                    ZE( strokeS* , psttValueAddressStatus ) ;

                    etThread.delF( tinP , psttValueAddressZip ) ;
                    tSaidAddressZip = T(psttValueAddressZip) ;
                    rec >> psttValueAddressZip ; ___( psttValueAddressZip ) ;
                    ZE( strokeS* , psttValueAddressZip ) ;

                    etThread.delF( tinP , psttValueAddressCountry ) ;
                    tSaidAddressCountry = T(psttValueAddressCountry) ;
                    rec >> psttValueAddressCountry ; ___( psttValueAddressCountry ) ;
                    ZE( strokeS* , psttValueAddressCountry ) ;

                    etThread.delF( tinP , psttValueAddressCountryCode ) ;
                    tSaidAddressCountryCode = T(psttValueAddressCountryCode) ;
                    rec >> psttValueAddressCountryCode ; ___( psttValueAddressCountryCode ) ;
                    ZE( strokeS* , psttValueAddressCountryCode ) ;

                    etThread.delF( tinP , psttValueAddressState ) ;
                    tSaidAddressState = T(psttValueAddressState) ;
                    rec >> psttValueAddressState ; ___( psttValueAddressState ) ;
                    ZE( strokeS* , psttValueAddressState ) ;

                    etThread.delF( tinP , psttValueAddressCity ) ;
                    tSaidAddressCity = T(psttValueAddressCity) ;
                    rec >> psttValueAddressCity ; ___( psttValueAddressCity ) ;
                    ZE( strokeS* , psttValueAddressCity ) ;

                    etThread.delF( tinP , psttValueAddressStreet ) ;
                    tSaidAddressStreet = T(psttValueAddressStreet) ;
                    rec >> psttValueAddressStreet ; ___( psttValueAddressStreet ) ;
                    ZE( strokeS* , psttValueAddressStreet ) ;

                    etThread.delF( tinP , psttValueAddressName ) ;
                    tSaidAddressName = T(psttValueAddressName) ;
                    rec >> psttValueAddressName ; ___( psttValueAddressName ) ;
                    ZE( strokeS* , psttValueAddressName ) ;

                    etThread.delF( tinP , psttValueLastName ) ;
                    tSaidLastName = T(psttValueLastName) ;
                    rec >> psttValueLastName ; ___( psttValueLastName ) ;
                    ZE( strokeS* , psttValueLastName ) ;

                    etThread.delF( tinP , psttValueFirstName ) ;
                    tSaidFirstName = T(psttValueFirstName) ;
                    rec >> psttValueFirstName ; ___( psttValueFirstName ) ;
                    ZE( strokeS* , psttValueFirstName ) ;

                    }
                        etThread.traceF( tinP , T(bSecretIsOK?"secret is OK":"secret is NOT ok") ) ;
                        bSecretIsOK = secretTry == secret ;                 //U::DO THIS ONLY IF THIS RECORD IS NOT AN "UNSUBSCRIBE"
                    {
                    if( subscriberIdTry == idSubscriber )

                    rec >> secret ;
                    ZE( countT , secret ) ;

                    etThread.traceF( tinP , T("[tSaidIdSubscriber0]:    ")+tSaidIdSubscriber0 ) ;

                    tSaidIdSubscriber0 = TF4(((countT*)&idSubscriber)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e) ;
                    rec >> ((countT*)&idSubscriber)[ 1 ] ;
                    rec >> ((countT*)&idSubscriber)[ 0 ] ;
                    ZE( count04T , idSubscriber ) ;

                    etThread.delF( tinP , psttValueTransId ) ;
                    rec >> psttValueTransId ; ___( psttValueTransId ) ;
                    ZE( strokeS* , psttValueTransId ) ;

                    etThread.delF( tinP , psttValueTransType ) ;
                    rec >> psttValueTransType ; ___( psttValueTransType ) ;
                    ZE( strokeS* , psttValueTransType ) ;

                    etThread.delF( tinP , psttValueRewardBox ) ;
                    rec >> psttValueRewardBox ; ___( psttValueRewardBox ) ;
                    ZE( strokeS* , psttValueRewardBox ) ;

                    etThread.delF( tinP , psttValueRewardBoxHidden ) ;
                    rec >> psttValueRewardBoxHidden ; ___( psttValueRewardBoxHidden ) ;
                    ZE( strokeS* , psttValueRewardBoxHidden ) ;

                    etThread.delF( tinP , psttZipUse ) ;
                    tSaidZipUse = T(psttZipUse) ;
                    rec >> psttZipUse ; ___( psttZipUse ) ;
                    ZE( strokeS* , psttZipUse ) ;

                    etThread.delF( tinP , psttValuePaypalPayerEmail ) ;
                    tSaidPaypalPayerEmail = T(psttValuePaypalPayerEmail) ;
                    rec >> psttValuePaypalPayerEmail ; ___( psttValuePaypalPayerEmail ) ;
                    ZE( strokeS* , psttValuePaypalPayerEmail ) ;

                    etThread.delF( tinP , psttNnPeer ) ;
                    tSaidNnPeer = T(psttNnPeer) ;
                    rec >> psttNnPeer ; ___( psttNnPeer ) ;
                    ZE( strokeS* , psttNnPeer ) ;

                    etThread.delF( tinP , psttAction ) ;
                    rec >> psttAction ; ___( psttAction ) ;
                    ZE( strokeS* , psttAction ) ;

                    rec >> *(countT*)&timeS2 ;
                    ZE( sCountT , timeS2 ) ;

                    rec >> timeS1 ;
                    ZE( countT , timeS1 ) ;

                    rec >> idFormat ;
                    ZE( countT , idFormat ) ;

                    rec >> finger ;
                    ZE( countT , finger ) ;

                    etThread.boxGetShadowF( tinP , rec , pInfo->psttIfoName ) ;
                    soulC rec( tinP , TAG( TAGiDnULL ) ) ;

                    etThread.traceF( tinP , T("found 1:    ")+T(fn) ) ;
                    fileNameC fn( tinP , etThread , pInfo->psttIfoName ) ;
                {
                else
                }
                    break ;
                    DEL( pInfo ) ;
                {
                if( !pInfo || !pInfo->psttIfoName )

                etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tPath , &pat ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            do
            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
            TN( tPattern , "subscription.table.live.*" ) ;
            TN( tPath , "////factory2/d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/subscriptions/" ) ;
        {
        if( subscriberIdTry && secretTry )
        TN( tSaidAddressStatus      , "" ) ;
        TN( tSaidAddressZip         , "" ) ;
        TN( tSaidAddressCountry     , "" ) ;
        TN( tSaidAddressCountryCode , "" ) ;
        TN( tSaidAddressState       , "" ) ;
        TN( tSaidAddressCity        , "" ) ;
        TN( tSaidAddressStreet      , "" ) ;
        TN( tSaidAddressName        , "" ) ;
        TN( tSaidLastName           , "" ) ;
        TN( tSaidFirstName          , "" ) ;
        TN( tSaidIdSubscriber0      , "" ) ;
        TN( tSaidZipUse             , "" ) ;
        TN( tSaidPaypalPayerEmail   , "" ) ;
        TN( tSaidNnPeer             , "" ) ;
        ZE( boolT , bSecretIsOK ) ;
        //VALIDATE THE SECRET

        countT   secretTry       = etThread.strDigitsToSCountF( tinP , tValueSecret       , 0x3e ) ;
        count04T subscriberIdTry = etThread.strDigitsToSCountF( tinP , tValueSubscriberId , 0x3e ) ; //U:: THIS WILL ONLY WORK IF THE ID IS <= MAXCOUNTT

        if( tValueFileName.csF(     tinP ) ) etThread.traceF( tinP , tKeyFileName    +T(":    ")+tValueFileName     ) ;
        if( tValueSpeech.csF(       tinP ) ) etThread.traceF( tinP , tKeySpeech      +T(":    ")+tValueSpeech       ) ;
        if( tValueSecret.csF(       tinP ) ) etThread.traceF( tinP , tKeySecret      +T(":    ")+tValueSecret       ) ;
        if( tValueSubscriberId.csF( tinP ) ) etThread.traceF( tinP , tKeySubscriberId+T(":    ")+tValueSubscriberId ) ;

        }
            }
                if( !etThread.strCompareF( tinP , psttLeverKVP , *pptKey[ offk ] ) ) *pptValue[ offk ] = T((strokeS*)(countT)swKVP) ;
            {
            for( countT offk = 0 ; offk < sizeof pptKey / sizeof pptKey[ 0 ] ; offk ++ )

            //}
            //    DEL( prPosts ) ;
            //    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
            //    etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            //
            //    etThread.traceF( tinP , tSay ) ;
            //    TN( tSay , "" ) ; tSay = T("<p>\r\n")+T(psttLeverKVP)+T(":    ")+T((strokeS*)(countT)swKVP) ;
            //
            //    ZE( pbRefC* , prPosts ) ;
            //{

            psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swKVP.cFlavorsF( tinP ) ;

        } ;
            &tValueFileName     ,
            &tValueSpeech       ,
            &tValueSecret       ,
            &tValueSubscriberId ,
        {
        textC* pptValue[] =

        } ;
            &tKeyFileName     ,
            &tKeySpeech       ,
            &tKeySecret       ,
            &tKeySubscriberId ,
        {
        textC* pptKey[] =

        TN( tValueFileName     , "" ) ;
        TN( tValueSpeech       , "" ) ;
        TN( tValueSecret       , "" ) ;
        TN( tValueSubscriberId , "" ) ;

        TN( tKeyFileName     , "filename"     ) ;
        TN( tKeySpeech       , "speechanon"   ) ;
        TN( tKeySecret       , "secret"       ) ;
        TN( tKeySubscriberId , "subscriberid" ) ;

        }
            DEL( prPosts ) ;
            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

            etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            ZE( pbRefC* , prPosts ) ;

            ) ;

                "<p>\r\n"
                "The anonymous posts listed here are awaiting certification by a subscriber.\r\n"
                "<p>\r\n"
                "<h1>Wo'O's Table Talk:  Anonymous posts awaiting certification</h1>\r\n"

            TN( tSay ,
        {
    {
    else
    }
        DEL( prPosts ) ;
        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

        etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        ZE( pbRefC* , prPosts ) ;

        ) ;

            "<p>\r\n"
            "Try again after a TICK (about 6 foreign minutes).\r\n"
            "Your IP address is currently blcoked.\r\n"
            "<p>\r\n"
            "<h1>Wo'O's Table Talk:  Anonymous posts awaiting certification</h1>\r\n"

        TN( tSay ,
    {
    if( bBlocked )

    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

    }
        while( ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                else                          bBlocked = 1 ;
                if( timeE2 || timeE1 > TICK ) etThread.diskFileOrDirDeleteF( tinP , pInfo->psttIfoName , flFILEoRdIRdELETE_null , 1 ) ;

                etThread.traceF( tinP , T("age: ")+TT(timeE1,timeE2) ) ;
                etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , pInfo->timeCreated1 , pInfo->timeCreated2 ) ;
                etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                ZE( sCountT , timeE2 ) ;
                ZE( countT , timeE1 ) ;
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tPath , &pat ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        TN( tPattern , "blocked.ip." ) ; tPattern += T(nnPeerP)+T(".*") ;
        TN( tPath , "////factory2/d/ideafarm.home.101/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/blocked.ip/" ) ;
    {
    ZE( boolT , bBlocked ) ;

    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_BODYrAWbEGIN ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW5hEADeND ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW4sCRIPTeND ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW3sCRIPTbEGIN ) ;
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW2aFTERtITLE ) ;
    }
        DEL( prPosts ) ;
        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

        etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        ZE( pbRefC* , prPosts ) ;

        TN( tSay , "Wo'O's Table (tm)\r\n" ) ;
    {
    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW1bEFOREtITLE ) ;

    //if( psttKVReportP && psttKVReportP->idAdam ) etThread.traceF( tinP , psttKVReportP ) ;
{
/*1*/voidT talkAnonCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/

//20200715@2331: THIS IS OBSOLETE.  ALL FUNCTIONALITY FOR ANONYMOUS POSTS IS NOW IN talkCBF

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

