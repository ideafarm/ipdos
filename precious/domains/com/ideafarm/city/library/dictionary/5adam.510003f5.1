
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    }
        ether.osSleepF( tinP , TOCK ) ;

        }
            }
                etThread.delF( tinP , postl ) ;
                etThread.boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/html/race.list.html") , postl , costl ) ;
                etThread.delF( tinP , psttl ) ;
                countT costl = etThread.strMakeF( tinP , LF , postl , psttl ) ; ___( postl ) ;
                ZE( osTextT* , postl ) ;

                }
                    etThread.strFuseF( tinP , psttl , T("</PRE></BODY>") ) ; ___( psttl ) ;

                    }
                        etThread.delF( tinP , psttLink ) ;
                        etThread.delF( tinP , psttFile ) ;
                        if( !bGross && !bNet ) { etThread.strFuseF( tinP , psttl , t1+T(psttFile)+t2+T(psttLink)+t3 ) ; ___( psttl ) ; }
                        boolT bNet   = !etThread.strCompareF( tinP , psttFile , tn ) ;
                        boolT bGross = !etThread.strCompareF( tinP , psttFile , tg ) ;

                        etThread.strReplaceF( tinP , psttLink , 0        , t2d , tnd ) ;
                        etThread.strReplaceF( tinP , psttLink , psttFile , t1d , tgd ) ;
                        ZE( strokeS* , psttLink ) ;

                        st_psttFile >> psttFile ;
                        ZE( strokeS* , psttFile ) ;
                    {
                    while( !ether && !etThread && st_psttFile )
                    etThread.strFuseF( tinP , psttl , t1+tN+t2+tn+t3 ) ; ___( psttl ) ;
                    etThread.strFuseF( tinP , psttl , t1+tG+t2+tg+t3 ) ; ___( psttl ) ;

                    TN( t2d , ".1030062.1.2." ) ;
                    TN( t1d , ".1030062.1.1." ) ;
                    TN( tnd , ".net." ) ;
                    TN( tgd , ".gross." ) ;
                    TN( tn , "net" ) ;
                    TN( tg , "gross" ) ;
                    TN( t3 , "</A>\r\n" ) ;
                    TN( t2 , ".html\">" ) ;
                    TN( t1 , "<A HREF=\"http://city.center.ideafarm.com///ideafarm/ephemeral/domains/com/ideafarm/gen/html/race." ) ;

                    0x4000 + 0x100 * st_psttFile ) ; ___( psttl ) ;

                        "</HEAD>" postHTMLbODYpART1) ,
                        "<HEAD><TITLE>")+tTitleList+T("</TITLE>\r\n"
                        T("<!-- ")+TF3(tTitleList.csF(tinP),flFORMAT_FILLzE,8)+T(" --><!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\r\n"

                    etThread.strMakeF( tinP , LF , psttl ,
                    TN( tTitleList , "speed race list" ) ;
                {
                ZE( strokeS* , psttl ) ;
            {

            }
                etThread.delF( tinP , pstt1mIndex ) ;
                }
                    else st_psttFile << psttw ;
                    if( bList || bGross || bNet ) etThread.delF( tinP , psttw ) ;
                    boolT bNet   = !etThread.strCompareF( tinP , psttw , tNet   ) ;
                    boolT bGross = !etThread.strCompareF( tinP , psttw , tGross ) ;
                    boolT bList  = !etThread.strCompareF( tinP , psttw , tList  ) ;
                    etThread.strSubstringF( tinP , psttw , idf , sttq , T(".html") , psttc2 ) ; ___( psttw ) ;
                    etThread.delF( tinP , psttw ) ;
                    etThread.strSubstringF( tinP , psttw , idf , sttq , T("/html/race.") , psttc2 ) ; ___( psttw ) ;
                    countT idf = 1 ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , psttw ) ;
                {
                FORsTRINGSiN2( pstt1mIndex )
                etThread.boxMenuF( tinP , soul1mIndex , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/html/race.*.html") ) ; ___( pstt1mIndex ) ;
                ZE( strokeS* , pstt1mIndex ) ;
                strokeS sttSlash('/') ;
                TN( tNet   , "total.net" ) ;
                TN( tGross , "total.gross" ) ;
                TN( tList  , "list" ) ;
            {
            stackC st_psttFile( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;

            etThread.delF( tinP , pcRace2 ) ;
            etThread.delF( tinP , pcRace1 ) ;
            writeRacePageF( tinP , etThread , pcRace2 , cSourceFiles , tN ) ;
            writeRacePageF( tinP , etThread , pcRace1 , cSourceFiles , tG ) ;
            TN( tN , "total.net" ) ;
            TN( tG , "total.gross" ) ;

            etThread.delF( tinP , pstt1m ) ;
            }
                etThread.delF( tinP , pbf ) ;

                }
                    }
                        pcco ++ ;
                        pcci ++ ;
                        etThread.osTimeAddF( tinP , time1o , time2o , time1i , time2i ) ;
                        sCountT& time2o       = (sCountT&)*(pcco ++) ;
                        countT&  time1o       =           *(pcco ++) ;
                        const sCountT& time2i = (sCountT&)*(pcci ++) ;
                        const countT&  time1i =           *(pcci ++) ;
                        *(pcco ++)            =           *(pcci ++) ;
                        *(pcco ++)            =           *(pcci ++) ;
                    {
                    for( countT idf = 1 ; idf <= cSourceFiles ; idf ++ )
                          countT* pcco = ( pcRaceId[ 3 ] == 2 ? pcRace2 : pcRace1 ) + 6 ; // GROSS VS NET
                    const countT* pcci =                                  pcRace    + 6 ;

                    __(  pcRaceId[ 3 ] > 2 ) ;
                    __( !pcRaceId[ 3 ] ) ;

                    etThread.strokeF( tinP , tRaceId+T(" -\r\n") ) ;
                    writeRacePageF( tinP , etThread , pcRace , cSourceFiles , tRaceId ) ;
                    etThread.strokeF( tinP , tRaceId+T(" +\r\n") ) ;
                    }
                        tRaceId = TF3(pcRaceId[0],flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T(".")+TF3(pcRaceId[1],flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T(".")+TF5(pcRaceId+2,0,0,0,psttDot) ;
                        strokeS* psttDot = tDot ;
                        TN( tDot , "." ) ;
                    {
                    TN( tRaceId , "" ) ;
                {
                else
                if( ccRaceImplied != ccRace ) etThread.strokeF( tinP , T("skipping a race file because it is not of the expected size\r\n") ) ;

                __Z( ccRaceId ) ;
                __Z( pcRaceId ) ;
                countT  ccRaceImplied = cbf / sizeof( countT ) - ccRaceId - 1 ;
                countT* pcRace   = pcRaceId + ccRaceId + 1 ;
                countT  ccRaceId = etThread.strBodyLengthF( tinP , pcRaceId ) ;
                countT* pcRaceId = (countT*)pbf ;

                etThread.boxGetShadowF( tinP , pbf , cbf , psttc1 ) ; ___( pbf ) ;
                ZE( countT , cbf ) ;
                ZE( byteT* , pbf ) ;
            {
            FORsTRINGSiN1( pstt1m )

            etThread.strokeF( tinP , T("starting to write ")+TF1(cToDo)+T(" race reports\r\n") ) ;

            countT cToDo = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/3f30104/races/" "*") ) ; ___( pstt1m ) ;
            ZE( strokeS* , pstt1m ) ;

            etThread.memSetF( tinP , (byteT*)pcRace2 , ccRace * sizeof( countT ) ) ;
            etThread.memSetF( tinP , (byteT*)pcRace1 , ccRace * sizeof( countT ) ) ;
            etThread.newF( tinP , LF , pcRace2 , ccRace ) ;
            etThread.newF( tinP , LF , pcRace1 , ccRace ) ;
            ZE( countT* , pcRace2 ) ; // TOTAL OVER RACES FOR WHICH  bWatchEmployers
            ZE( countT* , pcRace1 ) ; // TOTAL OVER RACES FOR WHICH !bWatchEmployers
        {
        if( idCycle == 1 || bNewTick )

        time2last = time2 ;
        time1last = time1 ;

        const boolT bNewDayEnd    = bNewHour && offHOUR( time1 ) == 0x5 ;
        const boolT bNewStrongEnd = bNewDay && ( offDAY( time2 ) == 0x6 || offDAY( time2 ) == 0xe ) ;

        const boolT bNewTick      = bNewHour   || offTICK(   time1 ) != offTICK(   time1last ) ;
        const boolT bNewHour      = bNewDay    || offHOUR(   time1 ) != offHOUR(   time1last ) ;
        const boolT bNewDay       = bNewStrong || offDAY(    time2 ) != offDAY(    time2last ) ;
        const boolT bNewStrong    = bNewQtr    || offSTRONG( time2 ) != offSTRONG( time2last ) ;
        const boolT bNewQtr       = bNewDuck   || offQTR(    time2 ) != offQTR(    time2last ) ;
        const boolT bNewDuck      =               offDUCK(   time2 ) != offDUCK(   time2last ) ;

        etThread.osTimeNowF( tinP , time1 , time2 ) ;
        ZE( sCountT , time2 ) ;
        ZE( countT , time1 ) ;
        idCycle ++ ;
    {
    while( !ether && !etThread )
    ZE( countT , idCycle ) ;

    etThread.osTimeNowF( tinP , time1last , time2last ) ;
    ZE( sCountT , time2last ) ;
    ZE( countT , time1last ) ;
    ZE( strokeS* , psttw ) ;

    const countT ccRace = ( 1 + cSourceFiles ) * 5 ;
    const countT cSourceFiles = processGlobal8I.source.cFilesF( tinP ) ;

    etThread.strokeF( tinP , T("IdeaFarm " "(tm) City Race Reporter\r\ni report race results\r\n") ) ;
{
else
}
    etThread.strokeF( tinP , T("Another ")+textIdFileC( tinP , DDNAME )+T(" appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tinP , TAG( TAGiDnULL ) , T("7f30104") ) ;

TODO

}
    etThread.delF( tinP , posth ) ;
    etThread.boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/html/race.")+T(psttRaceIdP)+T(".html") , posth , costh ) ;
    etThread.delF( tinP , psttb ) ;

    ) ; ___( posth ) ;

        T(psttb)+T("</PRE></BODY>")
        "</HEAD>" postHTMLbODYpART1)+
        "<HEAD><TITLE>")+tTitle+T("</TITLE>\r\n"
        T("<!-- ")+TF3(tTitle.csF(tinP),flFORMAT_FILLzE,8)+T(" --><!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\r\n"

    countT costh = etThread.strMakeF( tinP , LF , posth ,
    ZE( osTextT* , posth ) ;

    textC tTitle = T("Race ")+T(psttRaceIdP)+T(" Statistics Since IFC System Restart") ;

    etThread.strFuseF( tinP , psttb , T("\r\n\r\n")+TT(time1Total,time2Total)+T("  ")+TF3(cEntriesTotal,0,8)+T("  ")+TF3(cExitsTotal,0,8)+T("  ")+TF1(cFunctionsTotal)+T(" functions\r\n") ) ; ___( psttb ) ;
    }
        etThread.delF( tinP , pc5rf ) ;
        }
            cExitsTotal   += pc5rf->c4 ;
            cEntriesTotal += pc5rf->c3 ;
            etThread.osTimeAddF( tinP , time1Total , time2Total , pc5rf->c1 , (sCountT)pc5rf->c2 ) ;
            cFunctionsTotal ++ ;

            etThread.strFuseF( tinP , psttb , TT(pc5rf->c1,(sCountT)pc5rf->c2)+T("  ")+TF3(pc5rf->c3,0,8)+T("  ")+TF3(pc5rf->c4,0,8)+T("  ")+TF3(processGlobal8I.source.idFileImmutableF(tinP,pc5rf->c5),flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T("  ")+T(processGlobal8I.source.postFileTitleF(tinP,pc5rf->c5))+T("\r\n") ) ; ___( psttb ) ;
        {
        if( pc5rf )
        stFun >> pc5rf ;
        ZE( count5S* , pc5rf ) ;
    {
    while( !ether && !etThread && stFun )
    etherC& ether = etThread.etPrimeIF( tinP ) ;

    ZE( sCountT , time2Total ) ;
    ZE( countT  , time1Total ) ;
    ZE( countT  , cExitsTotal ) ;
    ZE( countT  , cEntriesTotal ) ;
    ZE( countT  , cFunctionsTotal ) ;

    etThread.strMakeF( tinP , LF , psttb , TPS("totalTime",0x17,S1C('-'))+T("  ")+TPS("cIn",0x8,S1C('-'))+T("  ")+TPS("cOut",0x8,S1C('-'))+T("  ")+TPS("id",0x7,S1C('-'))+T("  ")+TPS("title",0x40,S1C('-'))+T("\r\n\r\n") , 0x1000 + 0x100 * cSourceFilesP ) ; ___( psttb ) ;
    ZE( strokeS* , psttb ) ;

    }
        }
            }
                }
                    { ZE( countT , ids ) ; stFun.sinkF( tinP , ids , pc5rf , 0 , subtractFun_F ) ; }

                    pc5rf->c5 = idf ;
                    pc5rf->c4 = cExits ;
                    pc5rf->c3 = cEntries ;
                    pc5rf->c2 = (countT)time2 ;
                    pc5rf->c1 = time1 ;
                {
                if( pc5rf )
                etThread.newF( tinP , LF , pc5rf ) ;
                ZE( count5S* , pc5rf ) ;
            {
            if( cEntries )

            pcc ++ ;
            sCountT time2    = (sCountT)*(pcc ++) ;
            countT  time1    =          *(pcc ++) ;
            countT  cExits   =          *(pcc ++) ;
            countT  cEntries =          *(pcc ++) ;
        {
        for( countT idf = 1 ; idf <= cSourceFilesP ; idf ++ )
        const countT* pcc = pcRaceP + 6 ;
    {
    stackC stFun( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count5S ) ;

    if( etThread ) return ;
{
voidT writeRacePageF( tinS& tinP , etherC& etThread , const countT* const pcRaceP , const countT cSourceFilesP , const strokeS* const psttRaceIdP )

}
    return (countT)scDiff ;

    }
        }
            scDiff = - ( timeA2 ? timeA2 : (sCountT)timeA1 ) ;
            etThread.osTimeSubtractF( tinP , timeA1 , timeA2 , timeB1 , timeB2 ) ;
            sCountT timeB2 = (sCountT)pc5B->c2 ;
            countT  timeB1 =          pc5B->c1 ;
            sCountT timeA2 = (sCountT)pc5A->c2 ;
            countT  timeA1 =          pc5A->c1 ;
        {
        if( pc5A && pc5B )

        count2S* pc5B = (count2S*)cBP ;    
        count2S* pc5A = (count2S*)cAP ;    

        etherC& etThread = *(etherC*)pEtThreadP ;
    {
    if( pEtThreadP )
    ZE( sCountT , scDiff ) ;
{
countT subtractFun_F( tinS& tinP , countT& pEtThreadP , countT& cAP , countT& cBP )

/*1*/WAKEhIDE( "city.race.reporter" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

