
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //ctCheckF() ;

    //tinP.cGrabitC_registered ++ ; //TO FIND A BUG
    registerDoneF( tinP , idLineP , idiFileP ) ;

    }
        if( pcGOT ) *pcGOT = tinP.osTid ;

        //}
        //    emitWordsIF( tinP , ifcLINE , IDFILE , pcSuffix , 4 ) ;
        //    countT pcSuffix[] = { 3 , (countT)pbo , offo , 0x1111 } ; //0x1111: "just set bit to 1"  ;  "3" IS LENGTH PREFIX
        //{                                                                                           //U::TO FIND A BUG
        //if( tinP.pAdamGlobal1->idAdam == ifcIDaDAM_PISS )

        //}
        //    }
        //        countT foo = 2 ;
        //    {
        //    if( !processGlobal1I.pcTrace2[ offTraceMe ] )
        //
        //    //processGlobal1I.pcTrace7[ offTraceMe ] = idiFileP ;
        //    //processGlobal1I.pcTrace6[ offTraceMe ] = idLineP ;
        //    processGlobal1I.pcTrace7[ offTraceMe ] = savebyte2 ;
        //    processGlobal1I.pcTrace6[ offTraceMe ] = savebyte1 ;
        //    processGlobal1I.pcTrace5[ offTraceMe ] = tinP.monitor.idThread ;
        //    processGlobal1I.pcTrace4[ offTraceMe ] = offo ;
        //    processGlobal1I.pcTrace3[ offTraceMe ] = (countT)pbo ;
        //    processGlobal1I.pcTrace2[ offTraceMe ] = *pbo ;
        //    processGlobal1I.pcTrace1[ offTraceMe ] = 1 ;            // 1:GRAB 2:UNGRAB
        //{
        //if( offTraceMe < sizeof processGlobal1I.pcTrace1 / sizeof processGlobal1I.pcTrace1[ 0 ] )
        //countT offTraceMe = incv02AM( processGlobal1I.cTrace ) ;
        //TO FIND A BUG

        tinP.cGrabitC_set ++ ; //U:: TO FIND A BUG
        tinP.cYield = 0 ;
        countT cYield = tinP.cYield ;
        //savebyte2 = *pbo ;

        //}
        //    *pcBlammo = 7 ;
        //    ZE( countT* , pcBlammo ) ;
        //
        //    LOGrAW3(    "grabitC::grabF [*pcKey]: " , *pcKey , "\r\n" ) ;
        //    CONoUTrAW3( "grabitC::grabF [*pcKey]: " , *pcKey , "\r\n" ) ;
        //{
        //if( !*pbo ) //TO FIND A BUG

        }
            }
                }
                    thirdC::osThreadYieldIF( tinP , idLineP , idiFileP , pbBitsP , msNap ) ;
                {
                while( btsAM( pbo , offo ) )
            {
            else
            }
                }
                    thirdC::osThreadYieldIF( tinP , idLineP , idiFileP , pbBitsP , msNap ) ;
                {
                while( btsKeyedAM( pbo , *pcKey , offo , tinP.monitor.idThread ) )
            {
            if( pcKey )
        {

        // savebyte1 = *pbo ;
        tinP.cYield = 0 ;
        idiFileGrabber = idiFileP ; //SINCE THESE VALUES ARE RETAINED WHEN NOT GRABBED, THE MONITOR CAN SEE WHICH GRAB LINES ARE CURRENTLY ACTIVE
        idLineGrabber  = idLineP ; //THESE ARE INFORMATORY ONLY; THEY ARE NOT RESET; THEY ARE OVERWRITTEN HERE
    
        //byteT savebyte2 ;
        //byteT savebyte1 ;

        }
            thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
            idDesire = thirdC::dosPriorityIF( tinP ) ;
        {
        if( !( F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERtHREADS ) && F(flagsCt2) & flGRABITc_DESIREcHANGEoNdEMAND )

        registerBegunF( tinP , idLineP , idiFileP ) ;
    {
    else
    }
        ++ *pcGR ;
        registerBegunF( tinP , idLineP , idiFileP , flBASEgRABcrEGISTERbEGUN_RECURSING ) ;

        }
            if( !( *pbo & mask ) ) { BLAMMO ; }     // AND THIS OBJECT'S GRABBED BIT SHOULD BE SET
            byteT mask = (byteT)( 1 << offo ) ;
        {

        if( !pcGR ) { BLAMMO ; }                    // THEN I SHOULD HAVE SET pcGR TO HOLD A RECURSION COUNT
    {
    if( pcGOT && *pcGOT == tinP.osTid )             // IF I HAVE ALREADY GRABBED AND AM RECURSING

    ;
        : poff_cGrabberRecurse                                    
        ? (countT*)( (byteT*)this + (countT)poff_cGrabberRecurse )
    countT* pcGR = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES                                       // countT CONTAINING THE RECURSION COUNTER

    ;
        :                                   poff_cGrabberOsTid
        ? (countT*)( (byteT*)this + (countT)poff_cGrabberOsTid )
    countT* pcGOT = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES                                      // countT CONTAINING THE osTid THAT HAS THE BIT

    ;
        : poff_key
        ? (countT*)( (byteT*)this + (countT)poff_key )
    countT* pcKey = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES

    ;
        : poff_bo
        ? (byteT*)this + (countT)poff_bo
    byteT* pbo = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES                                         // byteT CONTAINING THE BIT TO BE GRABBED

    if( tinP.idDesire != ifcTHREADpRIORITY_SPINLOCK ) { BLAMMO ; }

    _IO_

    SCOOP
{
/*1*/voidT grabitC::grabF( tinS& tinP , const countT idLineP , const countT idiFileP , const byteT* const pbBitsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

