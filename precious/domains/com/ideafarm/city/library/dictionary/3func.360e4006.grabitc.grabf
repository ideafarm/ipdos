
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
    _OUT_   //U::

    ctCheckF() ;

    tinP.cGrabitC_registered ++ ; //U:: TO FIND A BUG
    registerDoneF( tinP , idLineP , idiFileP ) ;

    _INoLD_
    {
    }
    _OUT_   //U::

    }
        }
        _OUT_   //U::
        if( pcGOT ) *pcGOT = tinP.osTid ;

        //}
        //    emitWordsIF( tinP , ifcLINE , IDFILE , pcSuffix , 4 ) ;
        //    countT pcSuffix[] = { 3 , (countT)pbo , offo , 0x1111 } ; //0x1111: "just set bit to 1"  ;  "3" IS LENGTH PREFIX
        //{                                                                                           //U::TO FIND A BUG
        //if( tinP.pAdamGlobal1->idAdam == ifcIDaDAM_PISS )

        }
            }
                countT foo = 2 ;
            {
            if( !processGlobal1I.pcTrace2[ offTraceMe ] )

            //processGlobal1I.pcTrace7[ offTraceMe ] = idiFileP ;
            //processGlobal1I.pcTrace6[ offTraceMe ] = idLineP ;
            processGlobal1I.pcTrace7[ offTraceMe ] = savebyte2 ;
            processGlobal1I.pcTrace6[ offTraceMe ] = savebyte1 ;
            processGlobal1I.pcTrace5[ offTraceMe ] = tinP.monitor.idThread ;
            processGlobal1I.pcTrace4[ offTraceMe ] = offo ;
            processGlobal1I.pcTrace3[ offTraceMe ] = (countT)pbo ;
            processGlobal1I.pcTrace2[ offTraceMe ] = *pbo ;
            processGlobal1I.pcTrace1[ offTraceMe ] = 1 ;            // 1:GRAB 2:UNGRAB
        {
        if( offTraceMe < sizeof processGlobal1I.pcTrace1 / sizeof processGlobal1I.pcTrace1[ 0 ] )
        countT offTraceMe = incv02AM( processGlobal1I.cTrace ) ;
        //U:: TO FIND A BUG

        _INoLD_
        {       //U::
        }
        _OUT_   //U::

        tinP.cGrabitC_set ++ ; //U:: TO FIND A BUG
        tinP.cYield = 0 ;
        countT cYield = tinP.cYield ;
        /*byteT*/ savebyte2 = *pbo ;

        _INoLD_
        {       //U::
        }
        _OUT_   //U::

        }
            *pcBlammo = 7 ;
            ZE( countT* , pcBlammo ) ;

            LOGrAW3(    "grabitC::grabF [*pcKey]: " , *pcKey , "\r\n" ) ;
            CONoUTrAW3( "grabitC::grabF [*pcKey]: " , *pcKey , "\r\n" ) ;
        {
        if( !*pbo ) //U::TO FIND A BUG

        }
            }
                thirdC::osThreadYieldIF( tinP , idLineP , idiFileP , pbBitsP , msNap ) ;
            {
            while( btsAM( pbo , offo ) )
        {
        else
        }
            }
                thirdC::osThreadYieldIF( tinP , idLineP , idiFileP , pbBitsP , msNap ) ;
            {
            while( btsKeyedAM( pbo , *pcKey , offo , tinP.monitor.idThread ) )
        {
        if( pcKey )

        /*byteT*/ savebyte1 = *pbo ;
        tinP.cYield = 0 ;
        idiFileGrabber = idiFileP ; //SINCE THESE VALUES ARE RETAINED WHEN NOT GRABBED, THE MONITOR CAN SEE WHICH GRAB LINES ARE CURRENTLY ACTIVE
        idLineGrabber  = idLineP ; //THESE ARE INFORMATORY ONLY; THEY ARE NOT RESET; THEY ARE OVERWRITTEN HERE
    
        _INoLD_
        {       //U::
        byteT savebyte2 ;
        byteT savebyte1 ;
        }
        _OUT_   //U::

        }
            thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
            idDesire = thirdC::dosPriorityIF( tinP ) ;
        {
        if( !( F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERtHREADS ) && F(flagsCt2) & flGRABITc_DESIREcHANGEoNdEMAND )

        registerBegunF( tinP , idLineP , idiFileP ) ;
        _INoLD_
        {       //U::
    {
    else
    }
        }
        _OUT_   //U::
        ++ *pcGR ;
        registerBegunF( tinP , idLineP , idiFileP , flBASEgRABcrEGISTERbEGUN_RECURSING ) ;
        _INoLD_
        {       //U::

        }
            if( !( *pbo & mask ) ) { BLAMMO ; }     // AND THIS OBJECT'S GRABBED BIT SHOULD BE SET
            byteT mask = (byteT)( 1 << offo ) ;
        {

        if( !pcGR ) { BLAMMO ; }                    // THEN I SHOULD HAVE SET pcGR TO HOLD A RECURSION COUNT
    {
    if( pcGOT && *pcGOT == tinP.osTid )             // IF I HAVE ALREADY GRABBED AND AM RECURSING

    _INoLD_
    {
    }
    _OUT_   //U::

    _INoLD_
    {

    ;
        : poff_cGrabberRecurse                                    
        ? (countT*)( (byteT*)this + (countT)poff_cGrabberRecurse )
    countT* pcGR = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES                                       // countT CONTAINING THE RECURSION COUNTER

    ;
        :                                   poff_cGrabberOsTid
        ? (countT*)( (byteT*)this + (countT)poff_cGrabberOsTid )
    countT* pcGOT = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES                                      // countT CONTAINING THE osTid THAT HAS THE BIT

    ;
        : poff_key
        ? (countT*)( (byteT*)this + (countT)poff_key )
    countT* pcKey = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES

    ;
        : poff_bo
        ? (byteT*)this + (countT)poff_bo
    byteT* pbo = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES                                         // byteT CONTAINING THE BIT TO BE GRABBED

    if( tinP.idDesire != ifcTHREADpRIORITY_SPINLOCK ) { BLAMMO ; }

    _INoLD_

    SCOOP
{
/*1*/voidT grabitC::grabF( tinS& tinP , const countT idLineP , const countT idiFileP , const byteT* const pbBitsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

