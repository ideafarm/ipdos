
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        }
            }
                else etRock.traceF( tinP , T("cloudC: hired  adam    ")+T(psttAdamHireAfterP) ) ;
                }
                    etRock.traceF( tinP , T("cloudC: could not hire adam    ")+T(psttAdamHireAfterP) ) ;
                    POOPR
                {
                if( POOP )

                etScratch.ifcHireF( tinP , T("cloudC::cloudC") , idAdam , 0 , flHIRE_WAIT | flHIRE_DISPLAYaUTO , 0 , 0 , 1 ) ;
                etRock.traceF( tinP , T("cloudC: hiring adam    ")+T(psttAdamHireAfterP) ) ;
            {
            else
            if( !idAdam ) etRock.traceF( tinP , T("cloudC: cannot hire adam ")+T(psttAdamHireAfterP)+T(" because idAdam is 0") ) ;

            countT idAdam = etScratch.strDigitsToSCountF( tinP , psttAdamHireAfterP ) ;
        {
        if( psttAdamHireAfterP && psttAdamHireAfterP->idAdam )

        etherC& etScratch = *tinP.pEtScratch ;

        SCOOPS
    {
    IFsCRATCH

    }
        ether.delF( tinP , psttFromMapped ) ;
        ether.delF( tinP , psttToMapped ) ;

        }
            }
                etRock.traceF( tinP , T("cloudC: moved  local container    ")+T(psttLocalContainerP)+T("    to:    ")+T(psttNewUnique) ) ;
                ether.delF( tinP , psttNewUnique ) ;
                ether.diskMoveFileOrDirUniqueF( tinP , psttNewUnique , psttLocalContainerP ) ;
                ether.strMakeF( tinP , psttNewUnique , psttPourLocalAfterContainerP , TUCK ) ; ___( psttNewUnique ) ;       //A:ASSUME: TUCK IS LARGE ENOUGH TO HOLD THE UNIQUE STRING
                ZE( strokeS* , psttNewUnique ) ;
                etRock.traceF( tinP , T("cloudC: moving local container    ")+T(psttLocalContainerP)+T("    to:    ")+T(psttPourLocalAfterContainerP) ) ;
            {
            else
            if( !ether.diskFileExistsF( tinP , psttLocalContainerP ) ) etRock.traceF( tinP , T("cloudC: moving local container    ")+T(psttLocalContainerP)+T(": does not exist so nothing moved") ) ;
        {
        else
        }
            etRock.traceF( tinP , T("cloudC: error: move must be to the same file system instance (hard drive [to,from]:     ")+T(psttToMapped)+T("    ")+T(psttFromMapped) ) ;
        {
        )
            ||  psttFromMapped[ CSpREFIX + 3 ].idAdam != psttToMapped[ CSpREFIX + 3 ].idAdam
            ||  psttFromMapped[ CSpREFIX + 4 ].idAdam != '/'
            ||  psttFromMapped[ CSpREFIX + 2 ].idAdam != '/'
            ||  psttFromMapped[ CSpREFIX + 1 ].idAdam != '/'
            ||  psttFromMapped[ CSpREFIX + 0 ].idAdam != '/'
            ||  psttFromMapped->idAdam < 5
            || !psttFromMapped
            ||  psttToMapped[   CSpREFIX + 4 ].idAdam != '/'
            ||  psttToMapped[   CSpREFIX + 2 ].idAdam != '/'
            ||  psttToMapped[   CSpREFIX + 1 ].idAdam != '/'
            ||  psttToMapped[   CSpREFIX + 0 ].idAdam != '/'
            ||  psttToMapped->idAdam < 5
               !psttToMapped
        (
        if

        ether.diskMapFileNameF( tinP , psttFromMapped , psttLocalContainerP ) ; ___( psttFromMapped) ;
        ZE( strokeS* , psttFromMapped ) ;

        ether.diskMapFileNameF( tinP , psttToMapped , psttPourLocalAfterContainerP ) ; ___( psttToMapped) ;
        ZE( strokeS* , psttToMapped ) ;
    {
    if( psttPourLocalAfterContainerP && psttPourLocalAfterContainerP->idAdam )

    ether.delF( tinP , psttLocalContainerMapped ) ;
    }
        if( !POOP ) break ;

        ether.delF( tinP , postBufferC ) ;
        ether.delF( tinP , postBufferM ) ;

        }
            }
                }
                    ++ s ; ether.osSleepF( tinP , TOCK << 4 ) ;
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                    etRock.traceF( tinP , T("cloudC: 0: walk FAILED  to nix ; i will retry after napping 01 tock") ) ;
                    POOPR
                {
                else
                }
                    break ;
                    etRock.traceF( tinP , T("cloudC: 0: walk FAILED  to nix") ) ;
                {
                else if( !bRetry )
                }
                    break ;
                    etRock.traceF( tinP , T("cloudC: 0: walked  to nix") ) ;

                    }
                        }
                            ether.delF( tinP , psttfn ) ;
        
                            ether.diskFileOrDirDeleteF( tinP , T(psttLocalContainerMapped)+T(psttfn) , flFILEoRdIRdELETE_null , cTriesWhenDeletingLocalP ) ;
                            ether.traceF( tinP , T("!nixLocal \"")+T(psttfn)+T("\"") ) ;
        
                            sDoomedFileNames >> psttfn ; ___( psttfn ) ;
                            ZE( strokeS* , psttfn ) ;
                        {
                        else while( sDoomedFileNames )
                        if( !bPull ) deleteRemoteFilesF( tinP , psttCloudContainerP , sDoomedFileNames ) ;
                    {
                    if( sDoomedFileNames )
                {
                if( !POOP )

                else        kvFileMetaByNameRemote.walkF( tinP , stThis , stKidsDone , postBufferM , costBuffers , countTC() , walkRemoteToNixCBF , pcArg , &bQuit ) ;
                if( bPull ) kvFileMetaByNameLocal.walkF(  tinP , stThis , stKidsDone , postBufferM , costBuffers , countTC() , walkLocalToNixCBF  , pcArg , &bQuit ) ;

                etRock.traceF( tinP , T( F(flagsCt) & flCLOUDc_DELETEiFmASTERnOTeXIST ? "cloudC: 1: walking to nix if master not exist" :  "cloudC: 1: walking to nix if master exist" ) ) ;

                sDoomedFileNames.removeAllF( tinP ) ;

                sStaleFileNameCbUsed.removeAllF( tinP ) ;
                ether.memSetF( tinP , postBufferC , costBuffers , 0 ) ;
                ether.memSetF( tinP , postBufferM , costBuffers , 0 ) ;
                stKidsDone.purgeF( tinP ) ;
                stThis.purgeF(     tinP ) ;
                //20170328@1818: ADDED WITHOUT ANALYSIS, TO MAKE SIMILAR TO COPY OPERATION
    
                bHandle.ungrabF( tinP ) ;
                openF( tinP , idCloud , tBuilding , tUser , tPassword ) ;
                hCloud.closeIfF() ;
                bHandle.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            while( !bQuit )
        {
        if( !POOP && ( F(flagsCt) & flCLOUDc_DELETEiFmASTERnOTeXIST || F(flagsCt) & flCLOUDc_DELETEiFmASTEReXIST ) )

        }
            }
                }
                    ++ s ; etPrime.osSleepF( tinP , TOCK << 4 ) ;
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                    etRock.traceF( tinP , T("cloudC: 1: walk FAILED  to freshen ; i will retry after napping 01 tock") ) ;
                    POOPR
                {
                else
                }
                    break ;
                    etRock.traceF( tinP , T("cloudC: 1: walk FAILED  to freshen") ) ;
                {
                else if( !bRetry )
                }
                    break ;
                    etRock.traceF( tinP , T("cloudC: 1: walked  to freshen") ) ;

                    }
                        __( sRename ) ;
                    {
                    else
                    }
                        }
                            ether.delF( tinP , psttfnOld ) ;
                            ether.delF( tinP , psttfnNew ) ;

                            ether.diskMoveFileOrDirF(   tinP , psttfnNew , psttfnOld ) ; //IT WOULD BE NICE TO BE ABLE TO DO THIS ATOMICALLY
                            ether.diskFileOrDirDeleteF( tinP , psttfnNew ) ;             //IT WOULD BE NICE TO BE ABLE TO DO THIS ATOMICALLY

                            etRock.traceF( tinP , psttfnOld ) ;
                            etRock.traceF( tinP , psttfnNew ) ;
                            etRock.traceF( tinP , T("cloudC: renaming (all or none) [new,old]:") ) ;

                            sRename >> psttfnOld ; ___( psttfnOld ) ;
                            sRename >> psttfnNew ; ___( psttfnNew ) ;
                            ZE( strokeS* , psttfnOld ) ;
                            ZE( strokeS* , psttfnNew ) ;
                        {
                        while( sRename )
                        etRock.traceF( tinP , T("cloudC: 2: all freshens succeeded, so renaming newly received local files from temporary names to intened names") ) ;
                    {
                    if( F(flagsCt) & flCLOUDc_COPYaLLoRnONE )
                {
                if( !POOP )

                //etRock.traceF( tinP , T("cloudC: 3 waited  for all freshen tokens to be returned if any are still being used") ) ;
                }
                    }
                        ++ s ; etRock.osSleepF( tinP , TOCK >> 2 ) ;
                        //etRock.traceF( tinP , T("cloudC: 3: waiting for all freshen tokens to be returned") ) ;
                    {
                    while( cTokensFree < cTokensExist )

                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                {
                //etRock.traceF( tinP , T("cloudC: 3: waiting for all freshen tokens to be returned if any are still being used") ) ;

                }
                    }
                        break ; // *this WILL BE IMPOTENT IF A pushFileF HAS FAILED
                        else if(            POOP ) etRock.traceF( tinP , T("cloudC: 4: breaking because cloudC is impotent") ) ;
                        else if( etPrime         ) etRock.traceF( tinP , T("cloudC: 4: breaking because i have been fired") ) ;
                             if( etPrime && POOP ) etRock.traceF( tinP , T("cloudC: 4: breaking because i have been fired and also cloudC is impotent") ) ;
                    {
                    if( etPrime || POOP )

                    }
                        ether.osThreadF( TaRG1( tmFreshenFileF ) , (countT)this , (countT)&cTokensFree , (countT)psttCloudContainerP , (countT)psttLocalContainerMapped , (countT)psttfn , (countT)&batConnect , offs , (countT)&sRename ) ;

                        *ppsFreshen[ offs ] >> psttfn ; ___( psttfn ) ;
                        ZE( strokeS* , psttfn ) ;

                        }
                            bHandle.ungrabF( tinP ) ;
                            openF( tinP , idCloud , tBuilding , tUser , tPassword ) ;
                            hCloud.closeIfF() ;
                            bHandle.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            etherC::etRockIF( tinP ).traceF( tinP , T("obtaining fresh authorization") ) ;

                            bWoth = 0 ;
                        {
                        if( bWoth || offs >= 0x1c )

                        if( !decv02AM( cTokensFree ) ) { BLAMMO ; }

                        }
                            etRock.traceF( tinP , TF3(cRemaining,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+T(" file names remain to be processed in group ")+TF2(offs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            countT cRemaining = *ppsFreshen[ offs ] ;
                        {

                        }
                            break ;
                            if( POOP    ) etRock.traceF( tinP , T("cloudC: quitting early because *this is impotent") ) ;
                            if( etPrime ) etRock.traceF( tinP , T("cloudC: quitting early because this process has been fired") ) ;
                        {
                        if( etPrime || POOP )

                        while( !etPrime && !cTokensFree ) { ++ s ; etPrime.osSleepF( tinP , TOCK >> 2 ) ; }
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    while( *ppsFreshen[ offs ] )
                    boolT bWoth = 1 ;

                    etRock.traceF( tinP , T("for group ")+TF2(offs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(", ")+TF2(cTokensExist,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" simultaneous file transfers will be allowed") ) ;
                    }
                        }
                            break ;
                            //etRock.traceF( tinP , T("cloudC: decremented number of simultaneous transfers allowed [offs,cTokensExist]: ")+TF2(offs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" , ")+TF2(cTokensExist,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            if( !decv02AM( cTokensFree ) ) { BLAMMO ; }
                            cTokensExist -- ;
                        {
                        case 0x1e : // FILE SIZE   BYTES
                        //case 0x18 : // FILE SIZE  16777216 BYTES  (THIS IS SUPPRESSED BECAUSE SOME THROTTLING BY NETWORKS APPEARS TO BE PER THREAD, SO MORE WORK IS ALLOWED IF 2 FILES ARE TRANSFERRED SIMULTANEOUSLY
                        case 0x16 : // FILE SIZE   4194304 BYTES
                        case 0x14 : // FILE SIZE   1048576 BYTES
                        //O: TUNE THESE CASE VALUES SO THAT cTokensExist IS REDUCED INCREMENTALLY AS FILE SIZE INCREASES SO THAT  cTokensExist == 1 FOR LARGE FILES
                        //CS: CODEsYNC: 36138003 36138003
                    {
                    if( !etPrime && cTokensExist > 1 ) switch( offs )  // CONDITIONALLY REDUCE cTokensExist BY 1 SO THAT IT DECREASES TO 1 FOR LARGE FILES ; "cTokensExist > 1" IS DEFENSIVE CODING TO ENSURE IS NEVER REDUCED BELOW 1

                    }
                        while( !etPrime && !cTokensFree ) { ++ s ; etPrime.osSleepF( tinP , TOCK >> 2 ) ; }
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    {

                    etRock.traceF( tinP , T("cloudC: 5: processing ")+TF2((countT)*ppsFreshen[offs],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" file names in group ")+TF2(offs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( cStale ) for( countT offs = 0 ; !etPrime && offs < sizeof ppsFreshen / sizeof ppsFreshen[ 0 ] ; offs ++ )
                soulC sRename( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.cloudc.rename" ) ;
                countT cTokensFree = cTokensExist ;
                countT cTokensExist = 4 ; //CS: CODEsYNC: 36138003 36138003
                batonC batConnect( tinP , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) ;

                // THE PARTICULAR VALUES ARE HARDCODED AND ARE SELECTED SO THAT THE NUMBER OF SIMULTANEOUS TRANSFERS ARE MINIMIZED SUCH THAT THE NETWORK CONNECTION IS FULLY UTILIZED

                // THIS REDUCES THE NUMBER OF SIMULTANEOUS TRANSFERS ALLOWED
                // WHEN offs HAS BEEN INCREMENTED TO PARTICULAR VALUES, cTokensExist AND cTokensFree ARE BOTH DECREMENTED IN A WAY THAT ENSURES THAT cTokensFree IS NEVER NEGATIVE

                // THE ACTION OF THE LAUNCHER AND THE LAUNCHED THREADS CAUSES cTokensFree TO VARY WITHIN [0,cTokensExist]
                // cTokensExist IS THE NUMBER OF SIMULTANEOUS TRANSFERS THAT WILL BE ALLOWED FOR THAT FILE SIZE RANGE

                // THE TRANSFER THREAD WILL DO ITS WORK AND THEN INCREMENT cTokensFree, CONCEPTUALLY TO FREE ITS TOKEN SO THAT ANOTHER TRANSFER THREAD CAN BE LAUNCHED
                // THEN, BEFORE LAUNCHING EACH TRANSFER THREAD, cTokensFree IS DECREMENTED
                // THE TRANSFER THREAD LAUNCHER BLOCKS UNTIL cTokensFree != 0
                // cTokensFree IS INITIALIZED TO cTokensExist
                // cTokensExist IS INITIALIZED TO THE NUMBER OF TOKENS THAT WILL EXIST FOR THE SMALLEST FILES (E.G. offs == 0)

                // offs IS THE OFFSET INTO ppsFreshen SO INDICATES THE SIZE RANGE CURRENTLY BEING PROCESSED
                // FILES ARE ROUGH SORTED BY SIZE AND ARE PROCESSED IN INCREASING ORDER OF SIZE RANGE
                // EACH ELEMENT OF ppsFreshen IS ASSOCIATED WITH A PARTICULAR OO POWER FILE SIZE RANGE
                // TOKENS ARE USED TO CONTROL THE NUMBER OF WORKER THREADS, EACH OF WHICH IS TRANSFERING WO FILE
                // HOW TOKENS WORK

                }
                    etRock.traceF( tinP , (strokeS*)( T("cloudC: 5.5: group ")+TF2(offs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" contains ")+TF2((countT)*ppsFreshen[offs],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" files to be freshened.") ) ) ;
                {
                if( cStale ) for( countT offs = 0 ; offs < sizeof ppsFreshen / sizeof ppsFreshen[ 0 ] ; offs ++ )

                bHandle.ungrabF( tinP ) ;
                openF( tinP , idCloud , tBuilding , tUser , tPassword ) ;
                hCloud.closeIfF() ;
                bHandle.grabF( tinP , TAG( TAGiDnULL ) ) ;

                etRock.traceF( tinP , T("cloudC: 6: sorted all file names listed in sStaleFileNameCbUsed by file size") ) ;
                }
                    ether.delF( tinP , psttfn ) ;
                    *ppsFreshen[ offs ] << psttfn ;
                    //etRock.traceF( tinP , TF2(offs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    }
                        if( !( cbMax <<= 1 ) ) break ;
                        offs ++ ;
                    {
                    while( cbMax < cbUsed )
                    countT cbMax = 1 ;
                    ZE( countT , offs ) ;

                    //etRock.traceF( tinP , TF3(cbUsed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF4(cbUsed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0x10,0xa)+tShort ) ;
                    TN( tShort , psttfn ) ;

                    sStaleFileNameCbUsed >> cbUsed ;
                    ZE( countT , cbUsed ) ;

                    sStaleFileNameCbUsed >> psttfn ; ___( psttfn ) ;
                    ZE( strokeS* , psttfn ) ;

                    }
                        //}
                        //    countT foo = 2 ;
                        //{
                        //if( cRemaining == 0x35126 )
                        //TO FIND A BUG 20150521@1156 VISIBLE PROGRESS STOPS AT THIS POINT
                    
                        if( !( cRemaining % ( TUCK << 4 ) ) ) etRock.traceF( tinP , TF3(cRemaining,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+T(" file names remain to be sorted") ) ;
                        countT cRemaining = (countT)sStaleFileNameCbUsed >> 1 ;
                    {
                {
                if( cStale ) while( sStaleFileNameCbUsed )

                etRock.traceF( tinP , T("cloudC: 7: sorting ")+TF3(cStale,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+T(" file names listed in sStaleFileNameCbUsed by file size") ) ;

                const countT cStale = (countT)sStaleFileNameCbUsed >> 1 ;

                __NZ( (countT)sStaleFileNameCbUsed % 2 ) ; // sStaleFileNameCbUsed CONTAINS A [name,cbUsed] PAIR FOR EACH STALE FILE

                } ;
                    &sStaleFileNameCbUsed_02 ,
                    &sStaleFileNameCbUsed_f1 ,
                    &sStaleFileNameCbUsed_e1 ,
                    &sStaleFileNameCbUsed_d1 ,
                    &sStaleFileNameCbUsed_c1 ,
                    &sStaleFileNameCbUsed_b1 ,
                    &sStaleFileNameCbUsed_a1 ,
                    &sStaleFileNameCbUsed_91 ,
                    &sStaleFileNameCbUsed_81 ,
                    &sStaleFileNameCbUsed_71 ,
                    &sStaleFileNameCbUsed_61 ,
                    &sStaleFileNameCbUsed_51 ,
                    &sStaleFileNameCbUsed_41 ,
                    &sStaleFileNameCbUsed_31 ,
                    &sStaleFileNameCbUsed_21 ,
                    &sStaleFileNameCbUsed_11 ,
                    &sStaleFileNameCbUsed_01 ,
                    &sStaleFileNameCbUsed_f0 ,
                    &sStaleFileNameCbUsed_e0 ,
                    &sStaleFileNameCbUsed_d0 ,
                    &sStaleFileNameCbUsed_c0 ,
                    &sStaleFileNameCbUsed_b0 ,
                    &sStaleFileNameCbUsed_a0 ,
                    &sStaleFileNameCbUsed_90 ,
                    &sStaleFileNameCbUsed_80 ,
                    &sStaleFileNameCbUsed_70 ,
                    &sStaleFileNameCbUsed_60 ,
                    &sStaleFileNameCbUsed_50 ,
                    &sStaleFileNameCbUsed_40 ,
                    &sStaleFileNameCbUsed_30 ,
                    &sStaleFileNameCbUsed_20 ,
                    &sStaleFileNameCbUsed_10 ,
                    &sStaleFileNameCbUsed_00 ,
                {
                soulC* ppsFreshen[] =

                soulC sStaleFileNameCbUsed_02( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.02" ) ;
                soulC sStaleFileNameCbUsed_f1( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.f1" ) ;
                soulC sStaleFileNameCbUsed_e1( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.e1" ) ;
                soulC sStaleFileNameCbUsed_d1( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.d1" ) ;
                soulC sStaleFileNameCbUsed_c1( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.c1" ) ;
                soulC sStaleFileNameCbUsed_b1( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.b1" ) ;
                soulC sStaleFileNameCbUsed_a1( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.a1" ) ;
                soulC sStaleFileNameCbUsed_91( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.91" ) ;
                soulC sStaleFileNameCbUsed_81( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.81" ) ;
                soulC sStaleFileNameCbUsed_71( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.71" ) ;
                soulC sStaleFileNameCbUsed_61( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.61" ) ;
                soulC sStaleFileNameCbUsed_51( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.51" ) ;
                soulC sStaleFileNameCbUsed_41( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.41" ) ;
                soulC sStaleFileNameCbUsed_31( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.31" ) ;
                soulC sStaleFileNameCbUsed_21( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.21" ) ;
                soulC sStaleFileNameCbUsed_11( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.11" ) ;
                soulC sStaleFileNameCbUsed_01( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.01" ) ;
                soulC sStaleFileNameCbUsed_f0( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.f0" ) ;
                soulC sStaleFileNameCbUsed_e0( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.e0" ) ;
                soulC sStaleFileNameCbUsed_d0( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.d0" ) ;
                soulC sStaleFileNameCbUsed_c0( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.c0" ) ;
                soulC sStaleFileNameCbUsed_b0( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.b0" ) ;
                soulC sStaleFileNameCbUsed_a0( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.a0" ) ;
                soulC sStaleFileNameCbUsed_90( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.90" ) ;
                soulC sStaleFileNameCbUsed_80( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.80" ) ;
                soulC sStaleFileNameCbUsed_70( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.70" ) ;
                soulC sStaleFileNameCbUsed_60( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.60" ) ;
                soulC sStaleFileNameCbUsed_50( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.50" ) ;
                soulC sStaleFileNameCbUsed_40( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.40" ) ;
                soulC sStaleFileNameCbUsed_30( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.30" ) ;
                soulC sStaleFileNameCbUsed_20( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.20" ) ;
                soulC sStaleFileNameCbUsed_10( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.10" ) ;
                soulC sStaleFileNameCbUsed_00( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen.00" ) ;

                // FILES OF SIZE <= 2**1 WILL BE REGISTERED INTO THE 10 ELEMENT, ETC.
                // FILES OF SIZE <= 2**0 WILL BE REGISTERED INTO THE 00 ELEMENT
                // THIS COVERS THE RANGE OF POSSIBLE FILE SIZES, SINCE Rackspace.com FILES ARE LIMITED TO 4 GB
                // EACH IS ASSOCIATED WITH A POWER OF 2, FROM 0 TO f1
                // THESE WILL BE USED TO OO POWER SORT THE FILES BY SIZE

                }
                    continue ;

                    ++ s ; ether.osSleepF( tinP , TOCK << 4 ) ;
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                    etRock.traceF( tinP , T("cloudC: 8: could not walk to freshen ; will retry after napping for 01 tocks") ) ;
                    POOPR
                {
                else
                }
                    break ;
                    etRock.traceF( tinP , T("cloudC: 8: could not walk to freshen") ) ;
                {
                else if( !bRetry )
                if( !POOP ) etRock.traceF( tinP , T("cloudC: 8: walked to freshen ; sStaleFileNameCbUsed is now loaded") ) ;

                else        kvFileMetaByNameLocal.walkF(  tinP , stThis , stKidsDone , postBufferM , costBuffers , countTC() , walkToFreshenCBF , pcArg , &bQuit ) ;
                if( bPull ) kvFileMetaByNameRemote.walkF( tinP , stThis , stKidsDone , postBufferM , costBuffers , countTC() , walkToFreshenCBF , pcArg , &bQuit ) ;

                etRock.traceF( tinP , T("cloudC: 3 walking to freshen") ) ;
                sStaleFileNameCbUsed.removeAllF( tinP ) ;
                ether.memSetF( tinP , postBufferC , costBuffers , 0 ) ;
                ether.memSetF( tinP , postBufferM , costBuffers , 0 ) ;
                stKidsDone.purgeF( tinP ) ;
                stThis.purgeF(     tinP ) ;
            {
            while( !bQuit )

            etRock.traceF( tinP , T( bPull ? "cloudC: master is remote: i will update local to match remote" : "cloudC: master is local: i will update remote to match local" ) ) ;
        {
        if( !POOP && !( F(flagsCt) & flCLOUDc_NOcOPY ) && !( F(flagsCt) & flCLOUDc_DELETEiFmASTEReXIST ) ) // IF DELETE IF MASTER EXISTS THEN NOcOPY FLAG IS IMPLIED (IT WOULD NEVER MAKE SENSE TO COPY MASTER TO SLAVE AND THEN DELETE SLAVE IF MASTER EXISTS; NOTHING WOULD BE ACCOMPLISHED BY THE COPY)

        countT pcArg[] = { 0 , (countT)this , (countT)postBufferM , (countT)postBufferC , costBuffers , (countT)&kvFileMetaByNameRemote , (countT)&kvFileMetaByNameLocal , (countT)pCloudUpdateCBFP , (countT)pcArgUpdateP , (countT)pCloudNixCBFP , (countT)pcArgNixP , (countT)psttCloudContainerP , (countT)psttLocalContainerMapped , idDoIfDiffer , (countT)&sStaleFileNameCbUsed , (countT)&sDoomedFileNames } ;
                        // 0   1              2                     3                     4             5                                 6                                7                          8                      9                       a                   b                             c                             d              e                              f

        // pcArg[ 0 ] IS RESERVED FOR USE BY keyValuePairsC::walkF, WHICH WILL PUT A jotC* INTO IT SO THAT MY WALK CBF'S CAN ACCESS THE jotC THAT CONTAINS THE METADATA

        keyValuePairsC& kvFileMetaByNameLocal = *(keyValuePairsC*)pb_kvFileMetaByNameLocal ;
        keyValuePairsC& kvFileMetaByNameRemote = *(keyValuePairsC*)pb_kvFileMetaByNameRemote ;

        soulC sStaleFileNameCbUsed( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.to.freshen" ) ;
        stackC stKidsDone( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWzE , ifcSTACKtYPE_countT ) ;
        stackC stThis(     tinP , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE                    , ifcSTACKtYPE_countT ) ;
        soulC sDoomedFileNames( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.doomed.file.names" ) ;

        ether.memSetF( tinP , postBufferC , costBuffers , 0 ) ;
        ether.memSetF( tinP , postBufferM , costBuffers , 0 ) ;
        ether.newF( tinP , LF , postBufferC , costBuffers ) ; ___( postBufferC ) ;
        ether.newF( tinP , LF , postBufferM , costBuffers ) ; ___( postBufferM ) ;
        const countT   costBuffers = TOCK ;                          //TOCK IS USED JUST TO ELIMINATE SUPPORT ISSUES FOR FOOLS WHO USE HUGELY LONG FILE NAMES
        ZE( osTextT* , postBufferC ) ; // 'C': "copy"
        ZE( osTextT* , postBufferM ) ; // 'M': "master"

        }
            }
                }
                    ++ s ; ether.osSleepF( tinP , TOCK << 4 ) ;
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                    kvFileMetaByNameLocal.purgeF( tinP ) ;

                    etRock.traceF( tinP , T("cloudC: call to walkLocalToLoadKvF failed ; will retry after napping 01 tock") ) ;
                    POOPR
                {
                else
                }
                    break ;
                {
                else if( !bRetry )
                if( !POOP ) break ;

                walkLocalToLoadKvF( tinP , ether , bQuit , kvFileMetaByNameLocal , psttLocalContainerMapped , psttLocalContainerMapped , psttLikeP , cbMinP , cbMaxP , flagsCt ) ;
            {
            while( !bQuit )

            //}
            //    etRock.traceF( tinP , T("cloudC: fixed  bad file names, if any, in ")+T(psttLocalContainerMapped) ) ;
            //    ether.disk FixBadFileNamesF( tinP , psttLocalContainerMapped , flETHERfIXnAMES_RECURSE ) ;
            //    etRock.traceF( tinP , T("cloudC: fixing bad file names, if any, in ")+T(psttLocalContainerMapped) ) ;
            //{
            //else
            //20170413@1404: THIS IS OBSOLETE NOW THAT FILESETS ARE USED FOR ARCHIVAL ("!ideafarm.8.2.00000000.00000001.*")

            }
                etRock.traceF( tinP , T("cloudC: renamed  all files to hash in ")+T(psttLocalContainerMapped) ) ;
                etRock.traceF( tinP , T("cloudC: U::DEVELOP THE RENAMING FUNCTION AND CALL HERE") ) ;
                etRock.traceF( tinP , T("cloudC: renaming all files to hash in ")+T(psttLocalContainerMapped) ) ;
            {
            else if( F(flagsCt) & flCLOUDc_RENAMEtOhASH )
            if( bPull ) etRock.traceF( tinP , T("cloudC: warning: i am not checking for bad file names since i am pulling (into ")+T(psttLocalContainerMapped)+T(" ) ; when pulling, i assume that the names in the cloud are as desired, even if they are invalid for a subsequent push") ) ;

            keyValuePairsC& kvFileMetaByNameLocal = *(keyValuePairsC*)pb_kvFileMetaByNameLocal ;
            flagsState |= flCLOUDsTATE_CTkVlOCAL ;
            new( 0 , tinP , pb_kvFileMetaByNameLocal , sizeof pb_kvFileMetaByNameLocal ) keyValuePairsC( tinP , T("kv.cloud.file.meta.by.name.")+T(psttNameP)+T(".local") , flKEYvALUEpAIRSc_WRITE | flKEYvALUEpAIRSc_PURGEoNcT | flKEYvALUEpAIRSc_PURGEoNdT , 0 , 0x18 ) ;
        {
        if( !POOP && !( F(flagsCt) & flCLOUDc_DOnOTlOADlOCAL ) )

        const boolT bPull = F(flagsCt) & flCLOUDc_REMOTEiSmASTER ;

        }
            }
                }
                    ++ s ; ether.osSleepF( tinP , TOCK << 4 ) ;
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                    kvFileMetaByNameRemote.purgeF( tinP ) ;
                    etRock.traceF( tinP , T("cloudC: 9: load FAILED remote list ; will retry after napping 01 tock") ) ;
                    POOPR
                {
                else
                }
                    break ;
                    etRock.traceF( tinP , T("cloudC: 9: load FAILED remote list") ) ;
                {
                else if( !bRetry )
                }
                    break ;
                    etRock.traceF( tinP , T("cloudC: 9: loaded remote list; contains ")+TF2(cRemote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" (")+TF4(cRemote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(") files ") ) ;
                {
                if( !POOP )

                }
                    else              cRemote += cRemoteNew ;
                    if( !cRemoteNew ) break ;
                    countT cRemoteNew = listFilesF( tinP , psttCloudContainerP , tMarker , psttLikeP , cbMinP , cbMaxP ) ;
                {
                while( !bQuit && !POOP )
                ZE( countT , cRemote ) ;
                TN( tMarker , "" ) ;
                etRock.traceF( tinP , T("cloudC: a: loading remote list") ) ;
        
                bHandle.ungrabF( tinP ) ;
                openF( tinP , idCloud , tBuilding , tUser , tPassword ) ;
                hCloud.closeIfF() ;
                bHandle.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            while( !bQuit )

            keyValuePairsC& kvFileMetaByNameRemote = *(keyValuePairsC*)pb_kvFileMetaByNameRemote ;
            flagsState |= flCLOUDsTATE_CTkVrEMOTE ;
            new( 0 , tinP , pb_kvFileMetaByNameRemote , sizeof pb_kvFileMetaByNameRemote ) keyValuePairsC( tinP , T("kv.cloud.file.meta.by.name.")+T(psttNameP)+T(".cloud") , flKEYvALUEpAIRSc_WRITE | flKEYvALUEpAIRSc_PURGEoNcT | flKEYvALUEpAIRSc_PURGEoNdT , 0 , 0x18 ) ;
        {
        if( !POOP && !( F(flagsCt) & flCLOUDc_DOnOTlOADrEMOTE ) )

        }
            continue ;
            ++ s ; ether.osSleepF( tinP , TOCK << 4 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;

            etRock.traceF( tinP , T("cloudC: b: open remote FAILED remote list ; will retry after napping 01 tock") ) ;
            POOPR
        {
        else
        }
            break ;
            etRock.traceF( tinP , T("cloudC: b: open remote FAILED") ) ;
        {
        else if( !bRetry )
        if( !POOP ) /*etRock.traceF( tinP , T("cloudC: b: open remote aok") )*/ ;

        openF( tinP , idCloud , tBuilding , tUser , tPassword ) ;
    {
    while( !bQuit && !POOP )      // RETRY LOOP: LOOPS ONLY TO RETRY ON FAILURE

    if( psttAdamHireAfterP && psttAdamHireAfterP->idAdam ) etRock.traceF( tinP , T("cloudC: afterward, will hire adam    ")+T(psttAdamHireAfterP)+T("    and will wait for that adam to die") ) ;

    if( psttPourLocalAfterContainerP && psttPourLocalAfterContainerP->idAdam ) etRock.traceF( tinP , T("cloudC: afterward, will pour local container    ")+T(psttLocalContainerP)+T("    to:    ")+T(psttPourLocalAfterContainerP) ) ;

    if( psttLocalContainerP ) { ether.diskMapFileNameF( tinP , psttLocalContainerMapped , psttLocalContainerP ) ; ___( psttLocalContainerMapped ) ; }
    ZE( strokeS* , psttLocalContainerMapped ) ;

    const boolT  bRetry = &ether == tinP.pEtScratch ;
    const boolT& bQuit = etPrime ;
    etherC& etPrime = etherC::etPrimeIF() ;
    etherC& etRock = etherC::etRockIF( tinP ) ;

    _INoLD_

    }
        if( POOP ) return ;
        __NZ( !psttLocalContainerP && ( !( F(flagsP) & flCLOUDc_DOnOTlOADlOCAL ) || !( F(flagsP) & flCLOUDc_NOcOPY ) ) ) ;
        __Z( psttCloudContainerP ) ;
        __Z( psttPasswordP ) ;
        __Z( psttUserP ) ;
        __Z( psttBuildingP ) ;
        __Z( idCloudP ) ;
        FV( flCLOUDc , flagsP ) ;
        __Z( idDoIfDifferP ) ; //U::DEFINE AND USE A MACRO TO VALIDATE THAT THE VALUE IS IN [min,max]
        __Z( psttNameP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    const countT* pIdSubType = &(const countT&)poop ; //U::TO FIND A BUG

    SCOOP
{
tHost(                      tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                          )
tUrlCloudAgent(             tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                          ) ,
tReplyCode404_NotFound(     tinP , TAG( TAGiDnULL ) , flTEXTc_null , "HTTP/1.1 404 Not Found"    ) ,
tReplyCode401_Unauthorized( tinP , TAG( TAGiDnULL ) , flTEXTc_null , "HTTP/1.1 401 Unauthorized" ) ,
tReplyCode204_NoContent(    tinP , TAG( TAGiDnULL ) , flTEXTc_null , "HTTP/1.1 204 No Content"   ) ,
tReplyCode202_Accepted(     tinP , TAG( TAGiDnULL ) , flTEXTc_null , "HTTP/1.1 202 Accepted"     ) ,
tReplyCode201_Created(      tinP , TAG( TAGiDnULL ) , flTEXTc_null , "HTTP/1.1 201 Created"      ) ,
tReplyCode200_OK(           tinP , TAG( TAGiDnULL ) , flTEXTc_null , "HTTP/1.1 200 OK"           ) ,
idDoIfDiffer( idDoIfDifferP ) ,
flagsState( flCLOUDsTATE_null ) ,
flagsCt( flagsP ) ,
bHandle(                    tinP , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) ,
hCloud(                     tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_CLOUD ) ,
tPassword(                  tinP , TAG( TAGiDnULL ) , flTEXTc_null , psttPasswordP ) ,
tUser(                      tinP , TAG( TAGiDnULL ) , flTEXTc_null , psttUserP ) ,
tBuilding(                  tinP , TAG( TAGiDnULL ) , flTEXTc_null , psttBuildingP ) ,
idCloud( idCloudP ) ,
poop( (poopC&)(const poopC&)ether ) ,
ether( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ,
/*1*/cloudC::cloudC( tinS& tinP , const strokeS* const psttNameP , const countT idDoIfDifferP , const flagsT flagsP , const countT idCloudP , const strokeS* const psttBuildingP , const strokeS* const psttUserP , const strokeS* const psttPasswordP , const strokeS* const psttCloudContainerP , const strokeS* const psttLocalContainerP , const strokeS* const psttLikeP , const countT cbMinP , const countT cbMaxP , const countT cTriesWhenDeletingLocalP , cloudUpdateCBFT pCloudUpdateCBFP , countT* const pcArgUpdateP , cloudNixCBFT pCloudNixCBFP , countT* const pcArgNixP , const strokeS* const psttPourLocalAfterContainerP , const strokeS* const psttAdamHireAfterP ) :/*1*/

#define CtOKENSfRESHENfILE 2
//SHOULD BE 2 IN PRODUCTION

DONE( tmFreshenFileF )
etThread.traceF( tinP , T("freshen thread exiting") ) ;
}
    inc02AM( cTokensFreeP ) ;

    }
        etRock.traceF( tinP , T("[poopCloud]: ")+TF3((countT)poopCloud,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,8)+T(" ; !uploading / called  pushFileF [expCbUsed,cbUsedHigh,name]: ")+TF4(offsP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(" , ")+T(" \"")+tShort+T("\"") /*, flTRACE_NOpREFIX*/ ) ;
        cloudP.pushFileF( tinP , batConnectP , psttzCloudContainerP , tShort , psttzLocalContainerP ) ;
        etRock.traceF( tinP , T("[poopCloud]: ")+TF3((countT)poopCloud,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,8)+T(" ; !uploading / calling pushFileF [expCbUsed,cbUsedHigh,name]: ")+TF4(offsP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(" , ")+T(" \"")+tShort+T("\"") /*, flTRACE_NOpREFIX*/ ) ;
    {
    else
    }
        }
            etRock.traceF( tinP , T("[poopCloud]: ")+TF3((countT)poopCloud,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,8)+T(" ; !downloading / made   ghost \"")+tShort+T("\"") ) ;
            { fileC fg( tinP , (strokeS*)( T(psttzLocalContainerP)+tShort ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_DOnOTrEGISTER /*flOPENdETAILS_null*/ , ifcOPENhOW_nCeR ) ; }
            etRock.traceF( tinP , T("[poopCloud]: ")+TF3((countT)poopCloud,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,8)+T(" ; !downloading / making ghost \"")+tShort+T("\"") ) ;
        {
        else
        }
            etRock.traceF( tinP , T("[poopCloud]: ")+TF3((countT)poopCloud,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,8)+T(" ; !downloading / called  pullFileF \"")+tShort+T("\"") ) ;
            cloudP.pullFileF( tinP , sRenameP , T(psttzLocalContainerP)+tShort , psttzCloudContainerP , tShort ) ;
            etRock.traceF( tinP , T("[poopCloud]: ")+TF3((countT)poopCloud,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,8)+T(" ; !downloading / calling pullFileF \"")+tShort+T("\"") ) ;
        {
        if( !bWoGhost )

        boolT bWoGhost = bGhost && bGhostF( tinP , tShort ) ;
    {
    if( bPull )

    etThread.delF( tinP , psttShortP ) ;
    TN( tShort , psttShortP ) ;

    const boolT bGhost = F(cloudP.flagsCtF()) & flCLOUDc_GHOST ;
    const boolT bPull  = F(cloudP.flagsCtF()) & flCLOUDc_REMOTEiSmASTER ;

    poopC& poopCloud = cloudP ;

    soulC&   sRenameP             =  *(soulC*)pTaskP->c8 ;
    countT   offsP                =           pTaskP->c7 ;
    batonC&  batConnectP          = *(batonC*)pTaskP->c6 ;
    strokeS* psttShortP           = (strokeS*)pTaskP->c5 ;
    strokeS* psttzLocalContainerP = (strokeS*)pTaskP->c4 ;
    strokeS* psttzCloudContainerP = (strokeS*)pTaskP->c3 ;
    countT&  cTokensFreeP         = *(countT*)pTaskP->c2 ;
    cloudC&  cloudP               = *(cloudC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c8 )
TASK( tmFreshenFileF )

}
    etRock.traceF( tinP , T("cloudC: 6 loaded  kvP from ")+T(psttLocalContainerP) ) ;
    }
        }
            else etRock.traceF( tinP , T("cloudC: i was only able to calculate hash for ")+TF2(cFileOrDirDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" (")+TF4(cFileOrDirDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0x10,0xa)+T(") local files ; i will make another pass to process the remaining files") ) ;
            }
                break ;
                etRock.traceF( tinP , T("cloudC: calculated hash for ")+TF2(cFileOrDirDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" (")+TF4(cFileOrDirDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(") local files") ) ;
            {
            if( !bFail )

            }
                ++ s ; etRock.osSleepF( tinP , TOCK >> 2 ) ;
            {
            while( cHashers )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;

            // ***********************************************************************************************    WAIT FOR HASH THREADS TO DIE    ***************************************************************

            if( bFail ) continue ;

            }
                jotShort.resetLathReadF() ;

                }
                    }
                        }
                            }
                                }
                                    }
                                        break ;

                                        //}
                                        //    }
                                        //        etherP.osThreadF( TaRG1( tmHasherF ) , (countT)pcArg ) ;
                                        //
                                        //        pcArg[ 8 ] = (countT)&cFileOrDirDone         ;
                                        //        pcArg[ 7 ] = (countT)&kvP                    ;
                                        //        pcArg[ 6 ] = (countT)psttLocalContainerP     ;
                                        //        pcArg[ 5 ] = (countT)psttLocalContainerRootP ;
                                        //        pcArg[ 4 ] = (countT)pInfo                   ;
                                        //        pcArg[ 3 ] = (countT)&cHashers               ;
                                        //        pcArg[ 2 ] = (countT)&bFail                  ;
                                        //        pcArg[ 1 ] = (countT)&bQuitP                 ;
                                        //        pcArg[ 0 ] = (countT)&etherP                 ;
                                        //   {
                                        //    if( pcArg )
                                        //    etherP.newF( tinP , LF , pcArg , 9 ) ; ___( pcArg ) ;
                                        //    ZE( countT* , pcArg ) ;
                                        //{
                                        //else
                                        }
                                            DEL( pInfo ) ;
                                            hasherF( tinP                         ,          etherP ,          bQuitP ,          bFail ,          cHashers ,         pInfo ,         psttLocalContainerRootP ,         psttLocalContainerP ,          kvP ,          cFileOrDirDone ) ;
                                        {
                                        //if( pInfo->cbUsed < TOCK << 4 )
                                        inc02AM( cHashers ) ;

                                        }
                                            ++ s ; etRock.osSleepF( tinP , TOCK >> 2 ) ;
                                        {
                                        while( cHashers == cHashersMax )
                                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                                    {
                                    else
                                    }
                                        break ;
                                        bFail = 1 ;
                                        etRock.traceF( tinP , T("exception: could not get info for local file: ")+tLong ) ;
                                        POOPR
                                    {
                                    if( POOP )

                                    }
                                        __Z( pInfo->psttIfoName ) ;
                                    {
                                    if( pInfo )
                                    __Z( pInfo ) ;
                                    if( pInfo && !pInfo->psttIfoName ) { etScratch.strMakeF( tinP , pInfo->psttIfoName , tLong ) ; ___( pInfo->psttIfoName ) ; }

                                    etScratch.diskFileQueryF( tinP , pInfo , myFile ) ; ___( pInfo ) ;
                                    fileC myFile( tinP , (const strokeS*)tLong , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 ) ;
                                {
                                while( !bQuitP && !etPrime && !etherP && !POOP )

                                TN( tLong , (const strokeS*)( T(psttLocalContainerP)+T(postShort) ) ) ;
                            {
                            ZE( infoFileS* , pInfo ) ;
                        {
                        else
                        }
                            walkLocalToLoadKvF( tinP , etherP , bQuitP , kvP , tKid , psttLocalContainerRootP , psttLikeP , cbMinP , cbMaxP , flagsCtP ) ;
                            TN( tKid , psttLocalContainerP ) ; tKid += T(postShort) ;
                        {
                        if( !offPass )
                    {
                    else
                    if( !postShort ) break ;

                    cRemaining -- ;
                    if( !( cRemaining % ( TUCK << 4 ) ) ) etRock.traceF( tinP , T("[cRemaining]: ")+TF2(cRemaining,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    const osTextT* postShort = pageShort ;
                    pageC pageShort = jotShort ;
                {
                while( !bQuitP && !etPrime && !etherP && !POOP && !bFail )

                jotC& jotShort = !offPass ? jotDir1 : jotFile1 ;
                etRock.traceF( tinP , T(!offPass?"calling myself recursively for each directory":"calculating hash for each file") ) ;
                countT cRemaining = !offPass ? jotDir1.cElementsF() : jotFile1.cElementsF() ;
            {
            for( countT offPass = 0 ; offPass <= 1 && !bFail ; offPass ++ )
            ZE( countT , cFileOrDirDone ) ;
            ZE( countT , cHashers ) ;

            // ***********************************************************************************************    WRITE HASH FOR EACH FILE TO KV    ***************************************************************

            }
                if( bFail ) continue ;

                }
                    jot2.resetLathReadF() ;
                    jot1.resetLathReadF() ;

                    }
                        }
                            break ;
                            bFail ++ ;
                        {
                        else if( thirdC::c_strcmpIF( tinP , post1 , post2 ) )
                        else if( !post1 || !post2 ) { BLAMMO ; } // SHOULD BE IMPOSSIBLE ;
                             if( !post1 && !post2 ) break ;

                        const osTextT* post2 = page2 ;
                        const osTextT* post1 = page1 ;
                        pageC page2 = jot2 ;
                        pageC page1 = jot1 ;

                        cRemaining -- ;
                        if( !( cRemaining % ( TUCK << 4 ) ) ) etRock.traceF( tinP , T("[cRemaining]: ")+TF2(cRemaining,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    while( !bQuitP && !etPrime && !etherP && !POOP )

                    jotC& jot2 = !offPass ? jotDir2 : jotFile2 ;
                    jotC& jot1 = !offPass ? jotDir1 : jotFile1 ;
                    etRock.traceF( tinP , T(!offPass?"verifying that both directory lists are identical":"verifying that both file lists are identical") ) ;
                    countT cRemaining = !offPass ? jotDir1.cElementsF() : jotFile1.cElementsF() ;
                {
                for( countT offPass = 0 ; offPass <= 1 && !bFail ; offPass ++ )

                // ***********************************************************************************************    VERIFY THAT EACH JOT PAIR IS IDENTICAL    ***************************************************************

                if( jotDir1.cElementsF() != jotDir2.cElementsF() || jotFile1.cElementsF() != jotFile2.cElementsF() ) continue ;
                etRock.traceF( tinP , T("verifying that both lists have the same number of file names") ) ;
            {
            if( bVerify )

            if( bFail ) continue ;

            if( bQuitP || etPrime || etherP ) break ;

            }
                while( ~hFind && !bQuitP && !POOP && !bFail ) ;
                }
                    }
                        DEL( pInfo ) ;
                        }
                            jotFile.writeF( tinP , tShort , tShort.csF( tinP ) + 1 ) ;

                            }
                                cFilesRemaining -- ;
                                if( !( cFilesRemaining % ( TUCK << 4 ) ) ) etRock.traceF( tinP , T("[cFilesRemaining]: ")+TF2(cFilesRemaining,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            else
                            }
                                if( !( cFiles % ( TUCK << 4 ) ) ) etRock.traceF( tinP , tShort ) ;
                                cFiles ++ ;
                            {
                            if( !offPass )
                        {
                        )
                            (    !cbMaxP       ||    (    !pInfo->cbUsedHigh     &&              pInfo->cbUsed <= cbMaxP    )                  )
                            &&
                            (    !cbMinP       ||          pInfo->cbUsedHigh     ||    cbMinP <= pInfo->cbUsed                                 )
                            &&
                            (    !psttLikeP    ||          !psttLikeP->idAdam    ||    etherP.strFileMatchF( tinP , psttLikeP , tShort )       )
                        (
                        else if
                        }
                            etherP.traceF( tinP , T("ignoring !writing metafile [tShort]:  ")+tShort ) ;
                        {
                        else if( etherP.strIdF( tinP , T(".!writing.") , tShort ) )          // THE META FILE IS IGNORED, BUT THE PARTIALLY WRITTEN DATA FILE WILL BE INCLUDED
                        }
                            if( etherP.strCompareF( tinP , tShort , tDotSlash ) && etherP.strCompareF( tinP , tShort , tDotDotSlash ) ) jotDir.writeF( tinP , tShort , tShort.csF( tinP ) + 1 ) ;
                        {
                        if( bDir )

                        }
                            etherP.delF( tinP , psttShort ) ;
                            tShort = T(psttShort) ;
                            etherP.delF( tinP , psttnu ) ;
                            if( etherP.strCompareF( tinP , psttnu , psttLocalContainerP ) ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE
                            etherP.strBisectF( tinP , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShort , "" ) ;

                        const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;

                        //etRock.traceF( tinP , T("cloudC: [file]: ")+tIfoName ) ;
                        TN( tIfoName , pInfo->psttIfoName ) ;
                    {
                    else
                    }
                        break ;
                        DEL( pInfo ) ;
                    {
                    if( !pInfo || !pInfo->psttIfoName )

                    }
                        break ;
                        ++ s ; etPrime.osSleepF( tinP , TOCK ) ;
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        etRock.traceF( tinP , T("error: while accumulating local file names, could not access ")+tDisk+T(".  will retry after napping 1 tock") ) ; ;
                        bFail ++ ;
                        DEL( pInfo ) ;
                        POOPR
                    {
                    if( !etScratch.diskIdF( tinP , tDisk ) || POOP )

                    etScratch.diskFindFileOrDirF( tinP , pInfo , hFind , tLike ) ; //20160814@1946: SILENTLY FAILED.  HOW: DISCONNECT USB CABLE FROM EXTERNAL DRIVE. NO IMPOTENCE; CONJ: JUST RETURNS NULL pInfo OR pInfo->psttIfoName
                    ZE( infoFileS* , pInfo ) ;

                    }
                        break ;
                        ++ s ; etPrime.osSleepF( tinP , TOCK ) ;
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        etRock.traceF( tinP , T("error: while accumulating local file names, could not access ")+tDisk+T(".  will retry after napping 1 tock") ) ; ;
                        bFail ++ ;
                        POOPR
                    {
                    if( !etScratch.diskIdF( tinP , tDisk ) || POOP )
                {
                do
                handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                jotC& jotFile = !offPass ? jotFile1 : jotFile2 ;
                jotC& jotDir  = !offPass ? jotDir1  : jotDir2  ;

                countT cFilesRemaining = !offPass ? 0 : cFiles ;
                etRock.traceF( tinP , T("accumulating list ")+T(!offPass?"1 (of 2)":"2 (of 2)")+T(" of file names") ) ;
            {
            for( countT offPass = 0 ; offPass <= !!bVerify && !bFail ; offPass ++ )
            ZE( countT , cFiles ) ;

            // ***********************************************************************************************    LOAD jotDir jotFile (list of directory names, list of file names)   ***************************************************************

            ZE( boolT , bFail ) ;

            etherP.delF( tinP , psttu ) ;

            jotC jotFile2( tinP , T("walklocal.file.2.")+T(psttu) , flJOTc_DELETE | flJOTc_WRITE ) ;
            jotC jotDir2(  tinP , T("walklocal.dir.2." )+T(psttu) , flJOTc_DELETE | flJOTc_WRITE ) ;
            jotC jotFile1( tinP , T("walklocal.file.1.")+T(psttu) , flJOTc_DELETE | flJOTc_WRITE ) ;
            jotC jotDir1(  tinP , T("walklocal.dir.1." )+T(psttu) , flJOTc_DELETE | flJOTc_WRITE ) ;

            etherP.strUniqueF( tinP , psttu ) ; ___( psttu ) ;
            ZE( strokeS* , psttu ) ;
        {
        while( !etPrime && !etherP && !bQuitP )  // RETRIES UNTIL SUCCESSFULLY PROCESSES ALL FILES
        etRock.traceF( tinP , T("cloudC when calculating the md5 hash of each local file, i will use up to this many threads [cHashersMax]: ")+TF2(cHashersMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        const boolT bVerify = !( F(flagsCtP) & flCLOUDc_DOnOTvERIFYlOCALlIST ) ;
        const countT cHashersMax = thirdC::osProcessorsIF( tinP ) << 1 ;
        TN( tDotDotSlash , "../" ) ;
        TN( tDotSlash , "./" ) ;
        TN( tSlash , "/" ) ;
        TN( tLike  , ""  ) ; tLike = T(psttLocalContainerP)+T("*") ;

        }
            etRock.traceF( tinP , T("[tDisk]: ")+tDisk ) ;
            etherP.delF( tinP , psttDisk ) ;
            tDisk = T(psttDisk) ;
            }
                etherP.delF( tinP , psttm ) ;
                etherP.strSubstringF( tinP , psttDisk , idf , idl , psttm ) ; ___( psttDisk ) ;
                countT idl = 5 ;
                countT idf = 1 ;
                etherP.diskMapFileNameF( tinP , psttm , psttLocalContainerP ) ; ___( psttm ) ; //THIS SHOULD BE REDUNDANT SINCE cloudC CODE SHOULD ALWAYS BE GIVEN MAPPED FILE NAMES
                ZE( strokeS* , psttm ) ;
            {
            ZE( strokeS* , psttDisk ) ;
        {
        TN( tDisk , "" ) ;

        //etRock.traceF( tinP , T("[pIdPoop]: ")+TF3((countT)pIdPoop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ) ;
        //const countT* pIdPoop = &(const countT&)poopScratch ;
        //const poopC& poopScratch = etScratch ;

        etherC& etPrime   = etherC::etPrimeIF( tinP ) ;
        etherC& etScratch = *tinP.pEtScratch ;

        SCOOPS
    {
    IFsCRATCH

    etRock.traceF( tinP , T("cloudC: 7 loading kvP from ")+T(psttLocalContainerP) ) ;

    etherC& etRock = etherC::etRockIF( tinP ) ;
{
voidT walkLocalToLoadKvF( tinS& tinP , etherC& etherP , const boolT& bQuitP , keyValuePairsC& kvP , const strokeS* const psttLocalContainerP , const strokeS* const psttLocalContainerRootP , const strokeS* const psttLikeP , const countT cbMinP , const countT cbMaxP , const flagsT flagsCtP )

}
    return 0 ;

    }
        }
            sDoomedFileNamesP << (strokeS*)T(postBufferCP) ;
        {
        if( !pCloudNixCBFP || (*pCloudNixCBFP)( tinP , *tinP.pEther , cloudP , T(postBufferCP) , pcArgNixP ) )
    {
    if( !POOP && bNix )

    }
        }
            if( pMetaLocal && pMetaRemote && *pMetaLocal == *pMetaRemote ) bNix = !bNix ;
        {
        else
        }
            if( pMetaLocal                                               ) bNix = !bNix ;
        {
        if( bNixIfNotExist )

        const metaS* pMetaRemote    = (const metaS*)(const byteT*)pageMetaRemote ;
        const metaS* pMetaLocal     = (const metaS*)(const byteT*)pageMetaLocal  ;

        pageC        pageMetaRemote = kvFileMetaByNameRemoteP( tinP , postBufferMP , 0 , thirdC::c_strlenIF( tinP , postBufferMP ) * SB ) ;
        pageC        pageMetaLocal  = kvFileMetaByNameLocalP(  tinP , postBufferMP , 0 , thirdC::c_strlenIF( tinP , postBufferMP ) * SB ) ;
    {
    boolT bNix = bNixIfNotExist ;

    const boolT bNixIfNotExist = !!( F(cloudP.flagsCtF()) & flCLOUDc_DELETEiFmASTERnOTeXIST ) ;

    }
        if( !( idIn % ( TUCK << 4 ) ) ) etCloud.traceF( tinP , T("!cloud: ")+TF3(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+T(" ")+T(postBufferCP) ) ;
        countT idIn = ++ idInLath ;
        static countT idInLath ;
    {

    //}
    //    etCloud.traceF( tinP , T("!cloud: ")+TF3(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+T(" ")+T(postBufferCP) , flagst ) ;
    //
    //    ;
    //        : flTRACE_NOpREFIX | flTRACE_NOcONSOLE
    //        ? flTRACE_NOpREFIX
    //    flagsT flagst = !( idIn % ( TUCK << 4 ) )
    //
    //    countT idIn = ++ idInLath ;
    //    static countT idInLath ;
    //{

    etherC& etCloud = cloudP ;

    for( countT offr = 0 ; postBufferMP[ offr ] ; offr ++ ) postBufferCP[ offr ] = reverseBitsF( postBufferMP[ offr ] ) ;

    thirdC::c_strcpyIF( tinP , postBufferCP , postBufferMP ) ;

    const metaS&         metaCloud               = *(const metaS*)(const byteT*)pageMetaCloud ;
    pageC                pageMetaCloud           = jotMetaCloudP[ cArg1P ] ;

    soulC&               sDoomedFileNamesP       =            *(soulC*)(&cArg2P)[ 0xf ] ;
    soulC&               sStaleFileNameCbUsedP   =            *(soulC*)(&cArg2P)[ 0xe ] ;
    const countT         idDoIfDifferP           =                     (&cArg2P)[ 0xd ] ;
    const strokeS* const psttLocalContainerP     =     (const strokeS*)(&cArg2P)[ 0xc ] ;
    const strokeS* const psttCloudContainerP     =     (const strokeS*)(&cArg2P)[ 0xb ] ;
    countT*              pcArgNixP               =            (countT*)(&cArg2P)[ 0xa ] ;
    cloudNixCBFT         pCloudNixCBFP           = (cloudNixCBFT)(&cArg2P)[ 0x9 ] ;
    countT*              pcArgUpdateP            =            (countT*)(&cArg2P)[ 0x8 ] ;
    cloudUpdateCBFT      pCloudUpdateCBFP        =    (cloudUpdateCBFT)(&cArg2P)[ 0x7 ] ;
    keyValuePairsC&      kvFileMetaByNameLocalP  =   *(keyValuePairsC*)(&cArg2P)[ 0x6 ] ;
    keyValuePairsC&      kvFileMetaByNameRemoteP =   *(keyValuePairsC*)(&cArg2P)[ 0x5 ] ;
    const countT         costBuffersP            =                     (&cArg2P)[ 0x4 ] ;
          osTextT*       postBufferCP            =           (osTextT*)(&cArg2P)[ 0x3 ] ;
    const osTextT*       postBufferMP            =     (const osTextT*)(&cArg2P)[ 0x2 ] ;

    if( POOP ) return 0 ;
    __Z( cArg1P ) ;

    SCOOPO( cloudP )
    cloudC&              cloudP                  =           *(cloudC*)(&cArg2P)[ 0x1 ] ;
    jotC&                jotMetaCloudP           =             *(jotC*)(&cArg2P)[ 0x0 ] ;
{
countT walkRemoteToNixCBF( tinS& tinP , countT& cArg1P , countT& cArg2P )

}
    return 0 ;

    }
        }
            sDoomedFileNamesP << (strokeS*)T(postBufferCP) ;
        {
        if( !pCloudNixCBFP || (*pCloudNixCBFP)( tinP , *tinP.pEther , cloudP , T(postBufferCP) , pcArgNixP ) )
    {
    if( !POOP && bNix )

    }
        }
            if( pMetaRemote && pMetaLocal && *pMetaLocal == *pMetaRemote ) bNix = !bNix ;
        {
        else
        }
            if( pMetaRemote                                              ) bNix = !bNix ;
        {
        if( bNixIfNotExist )

        const metaS* pMetaRemote    = (const metaS*)(const byteT*)pageMetaRemote ;
        const metaS* pMetaLocal     = (const metaS*)(const byteT*)pageMetaLocal  ;

        pageC        pageMetaRemote = kvFileMetaByNameRemoteP( tinP , postBufferMP , 0 , thirdC::c_strlenIF( tinP , postBufferMP ) * SB ) ;
        pageC        pageMetaLocal  = kvFileMetaByNameLocalP(  tinP , postBufferMP , 0 , thirdC::c_strlenIF( tinP , postBufferMP ) * SB ) ;
    {
    boolT bNix = bNixIfNotExist ;

    const boolT bNixIfNotExist = !!( F(cloudP.flagsCtF()) & flCLOUDc_DELETEiFmASTERnOTeXIST ) ;

    }
        if( !( idIn % ( TUCK << 4 ) ) ) etCloud.traceF( tinP , T("!cloud: ")+TF3(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+T(" ")+T(postBufferCP) ) ;
        countT idIn = ++ idInLath ;
        static countT idInLath ;
    {

    //}
    //    etCloud.traceF( tinP , T("!cloud: ")+TF3(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+T(" ")+T(postBufferCP) , flagst ) ;
    //
    //    ;
    //        : flTRACE_NOpREFIX | flTRACE_NOcONSOLE
    //        ? flTRACE_NOpREFIX
    //    flagsT flagst = !( idIn % ( TUCK << 4 ) )
    //
    //    countT idIn = ++ idInLath ;
    //    static countT idInLath ;
    //{

    etherC& etCloud = cloudP ;

    for( countT offr = 0 ; postBufferMP[ offr ] ; offr ++ ) postBufferCP[ offr ] = reverseBitsF( postBufferMP[ offr ] ) ;

    thirdC::c_strcpyIF( tinP , postBufferCP , postBufferMP ) ;

    const metaS&         metaCloud               = *(const metaS*)(const byteT*)pageMetaCloud ;
    pageC                pageMetaCloud           = jotMetaCloudP[ cArg1P ] ;

    soulC&               sDoomedFileNamesP       =            *(soulC*)(&cArg2P)[ 0xf ] ;
    soulC&               sStaleFileNameCbUsedP   =            *(soulC*)(&cArg2P)[ 0xe ] ;
    const countT         idDoIfDifferP           =                     (&cArg2P)[ 0xd ] ;
    const strokeS* const psttLocalContainerP     =     (const strokeS*)(&cArg2P)[ 0xc ] ;
    const strokeS* const psttCloudContainerP     =     (const strokeS*)(&cArg2P)[ 0xb ] ;
    countT*              pcArgNixP               =            (countT*)(&cArg2P)[ 0xa ] ;
    cloudNixCBFT         pCloudNixCBFP           =       (cloudNixCBFT)(&cArg2P)[ 0x9 ] ;
    countT*              pcArgUpdateP            =            (countT*)(&cArg2P)[ 0x8 ] ;
    cloudUpdateCBFT      pCloudUpdateCBFP        =    (cloudUpdateCBFT)(&cArg2P)[ 0x7 ] ;
    keyValuePairsC&      kvFileMetaByNameLocalP  =   *(keyValuePairsC*)(&cArg2P)[ 0x6 ] ;
    keyValuePairsC&      kvFileMetaByNameRemoteP =   *(keyValuePairsC*)(&cArg2P)[ 0x5 ] ;
    const countT         costBuffersP            =                     (&cArg2P)[ 0x4 ] ;
          osTextT*       postBufferCP            =           (osTextT*)(&cArg2P)[ 0x3 ] ;
    const osTextT*       postBufferMP            =     (const osTextT*)(&cArg2P)[ 0x2 ] ;

    if( POOP ) return 0 ;
    __Z( cArg1P ) ;

    SCOOPO( cloudP )
    cloudC&              cloudP                  =           *(cloudC*)(&cArg2P)[ 0x1 ] ;
    jotC&                jotMetaCloudP           =             *(jotC*)(&cArg2P)[ 0x0 ] ;
{
countT walkLocalToNixCBF( tinS& tinP , countT& cArg1P , countT& cArg2P )

}
    return 0 ;

    }
        }
            sStaleFileNameCbUsedP << metaWalk.cbUsed ;
            sStaleFileNameCbUsedP << (strokeS*)tShort ;

            //etCloud.traceF( tinP , T("stale:  ")+tShort ) ;
        {
        if( !pCloudUpdateCBFP || (*pCloudUpdateCBFP)( tinP , *tinP.pEther , cloudP , tShort , pcArgUpdateP ) )
    {
    if( !POOP && bDo )
    
    }
        }
            if( pMetaTo && *pMetaTo == metaWalk ) bDo = 0 ;
        {
        else
        }
            if( pMetaTo && !pMetaTo->cbUsed ) bDo = 0 ;
        {
        if( bGhost && bGhostF( tinP , tShort ) )

        const metaS* pMetaTo    = (const metaS*)(const byteT*)pageMetaTo ;
        pageC        pageMetaTo = ( bPull ? kvFileMetaByNameLocalP : kvFileMetaByNameRemoteP )( tinP , postBufferMP , 0 , thirdC::c_strlenIF( tinP , postBufferMP ) * SB ) ;
    {
    boolT bDo = 1 ;

    }
        if( !( idIn % ( TUCK << 4 ) ) ) etCloud.traceF( tinP , T(bPull?"!remote: ":"!local: ")+TF3(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+T(" ")+tShort ) ;
        countT idIn = ++ idInLath ;
        static countT idInLath ;
    {

    TN( tShort , "" ) ; tShort = T(postBufferCP) ;

    for( countT offr = 0 ; postBufferMP[ offr ] ; offr ++ ) postBufferCP[ offr ] = reverseBitsF( postBufferMP[ offr ] ) ;

    thirdC::c_strcpyIF( tinP , postBufferCP , postBufferMP ) ;

    etherC& etCloud = cloudP ;

    const metaS&         metaWalk               = *(const metaS*)(const byteT*)pageMetaWalk ;
    pageC                pageMetaWalk           = jotMetaWalkP[ cArg1P ] ;

    soulC&               sStaleFileNameCbUsedP   =            *(soulC*)(&cArg2P)[ 0xe ] ;
    const strokeS* const psttLocalContainerP     =     (const strokeS*)(&cArg2P)[ 0xc ] ;
    const strokeS* const psttCloudContainerP     =     (const strokeS*)(&cArg2P)[ 0xb ] ;
    countT*              pcArgNixP               =            (countT*)(&cArg2P)[ 0xa ] ;
    cloudNixCBFT         pCloudNixCBFP           =       (cloudNixCBFT)(&cArg2P)[ 0x9 ] ;
    countT*              pcArgUpdateP            =            (countT*)(&cArg2P)[ 0x8 ] ;
    cloudUpdateCBFT      pCloudUpdateCBFP        =    (cloudUpdateCBFT)(&cArg2P)[ 0x7 ] ;
    keyValuePairsC&      kvFileMetaByNameLocalP  =   *(keyValuePairsC*)(&cArg2P)[ 0x6 ] ;
    keyValuePairsC&      kvFileMetaByNameRemoteP =   *(keyValuePairsC*)(&cArg2P)[ 0x5 ] ;
    const countT         costBuffersP            =                     (&cArg2P)[ 0x4 ] ;
          osTextT*       postBufferCP            =           (osTextT*)(&cArg2P)[ 0x3 ] ;
    const osTextT*       postBufferMP            =     (const osTextT*)(&cArg2P)[ 0x2 ] ;

    if( POOP ) return 0 ;
    __Z( cArg1P ) ;

    const boolT bGhost = F(cloudP.flagsCtF()) & flCLOUDc_GHOST          ;
    const boolT bPull  = F(cloudP.flagsCtF()) & flCLOUDc_REMOTEiSmASTER ;

    SCOOPO( cloudP )
    cloudC&              cloudP                  =           *(cloudC*)(&cArg2P)[ 0x1 ] ;
    jotC&                jotMetaWalkP            =             *(jotC*)(&cArg2P)[ 0x0 ] ;
{
countT walkToFreshenCBF( tinS& tinP , countT& cArg1P , countT& cArg2P )

DONE( tmHasherF )
}
    etherP.delF( tinP , pcArgP ) ;
    DEL( pInfoP ) ;
    hasherF( tinP , etherP , bQuitP , cFailP , cHashersP , pInfoP , psttLocalContainerRootP , psttLocalContainerP , kvP , cFileOrDirDoneP ) ;

    countT&              cFileOrDirDoneP         =         *(countT*)pcArgP[ 8 ] ;
    keyValuePairsC&      kvP                     = *(keyValuePairsC*)pcArgP[ 7 ] ;
    const strokeS* const psttLocalContainerP     =   (const strokeS*)pcArgP[ 6 ] ;
    const strokeS* const psttLocalContainerRootP =   (const strokeS*)pcArgP[ 5 ] ;
    const infoFileS*     pInfoP                  =       (infoFileS*)pcArgP[ 4 ] ;
    countT&              cHashersP               =         *(countT*)pcArgP[ 3 ] ;
    countT&              cFailP                  =         *(countT*)pcArgP[ 2 ] ;
    const boolT&         bQuitP                  =          *(boolT*)pcArgP[ 1 ] ;
    etherC&              etherP                  =         *(etherC*)pcArgP[ 0 ] ;

    countT* pcArgP = (countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmHasherF )

}
    dec02AM( cHashersP ) ;
    }
        etherP.delF( tinP , postShort ) ;

        }
            }
                }
                    break ;
                    inc02AM( cFileOrDirDoneP ) ;
                    kvP.newF( tinP , LF , postShort , 0 , costShort * SB , (byteT*)&meta , sizeof meta ) ;

                    etherP.traceF( tinP , T("localFile : ")+tPseudoPath+tShort , flTRACE_null , ifcIDtRACEdIVERT_8 ) ; //U:: SUPPRESS THIS UNLESS FLAG IS SET BY THE CONSTRUCTOR CALLER
                {
                else                    
                if( POOP ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE

                }
                    etherP.delF( tinP , pbBuffer ) ;

                    hasher.queryF( tinP , (byteT*)meta.pcHashMd5 , sizeof meta.pcHashMd5 ) ;

                    }
                        continue ;
                        etherP.delF( tinP , pbBuffer ) ;
                        ++ s ; etPrime.osSleepF( tinP , TOCK ) ;
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        etRock.traceF( tinP , T("cloudC: could not read file to accumulate its hash ; will retry after napping 1 tock") ) ;
                        POOPR
                    {
                    if( POOP )

                    }
                        hasher.eatF( tinP , pbBuffer , cbNow ) ;
                        etScratch.fileReadF( tinP , pbBuffer , cbNow , fi ) ;

                        cDoLo -= cbNow ;
                        if( cDoLo < cbNow ) cDoHi -- ;

                        if( !cDoHi && cbNow > cDoLo ) cbNow = cDoLo ;
                        countT cbNow = cbChunk ;
                    {
                    while( !POOP && ( cDoHi || cDoLo ) )
                    hasherC hasher( tinP , etherP ) ;

                    countT cDoHi = 0   ;
                    countT cDoLo = pInfoP->cbUsed ;

                    }
                        continue ;
                        ++ s ; etPrime.osSleepF( tinP , TOCK ) ;
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        etRock.traceF( tinP , T("cloudC: could not obtain pool drop for hash buffer ; will retry after napping 1 tock") ) ;
                        POOPR
                    {
                    if( POOP )

                    __Z( pbBuffer ) ;
                    etherP.newF( tinP , LF , pbBuffer , cbChunk ) ; ___( pbBuffer ) ;
                    ZE( byteT* , pbBuffer ) ;

                    ;
                        : TOCK
                        ? pInfoP->cbUsed
                    countT cbChunk = pInfoP->cbUsed < TOCK

                    }
                        continue ;
                        ++ s ; etPrime.osSleepF( tinP , TOCK ) ;
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        etRock.traceF( tinP , T("cloudC: could not open file to calculate its hash ; will retry after napping 1 tock") ) ;
                        POOPR
                    {
                    if( POOP )

                    fileC fi( tinP , pInfoP->psttIfoName , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 ) ;
                {
                //OBTAIN md5 HASH

                meta.cbUsed = pInfoP->cbUsed ;
                metaS meta( tinP ) ;
            {
            while( !POOP && !etherP && !bQuitP && !bFailP && !etPrime )
        {
        else
        }
            inc02AM( cFileOrDirDoneP ) ;
        {
        if( kvP.queryF( tinP , postShort , 0 , costShort * SB ) )

        for( countT offr = 0 ; offr < costShort ; offr ++ ) postShort[ offr ] = reverseBitsF( postShort[ offr ] ) ;
        countT costShort = etherP.strMakeF( tinP , postShort , tPseudoPath+tShort ) ; ___( postShort ) ;
        ZE( osTextT* , postShort ) ;
                    
        }
            }
                etherP.delF( tinP , psttpp ) ;
                tPseudoPath = T(psttpp) ;
                etherP.strSubstringF( tinP , psttpp , idf , idl , psttLocalContainerP ) ; ___( psttpp ) ;
                ZE( countT , idl ) ;
                countT idf = psttLocalContainerRootP->idAdam + 1 ;
                ZE( strokeS* , psttpp ) ;
            {
            if( !POOP && psttLocalContainerRootP->idAdam != psttLocalContainerP->idAdam )

            __NZ( 1 != etherP.strIdF( tinP , psttLocalContainerRootP , psttLocalContainerP ) ) ;
        {
        TN( tPseudoPath , "" ) ;

        }
            etherP.delF( tinP , psttShort ) ;
            tShort = T(psttShort) ;
            etherP.delF( tinP , psttnu ) ;
            etherP.strBisectF( tinP , psttnu , psttShort , pInfoP->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
            ZE( strokeS* , psttShort ) ;
            ZE( strokeS* , psttnu ) ;
        {
        TN( tShort , "" ) ;

        TN( tSlash , "/" ) ;
        TN( tIfoName , pInfoP->psttIfoName ) ;
        //etRock.traceF( tinP , T("hasherF [idIn]: ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        etherC& etPrime   = etherC::etPrimeIF( tinP ) ;
        etherC& etRock    = etherC::etRockIF( tinP ) ;
        etherC& etScratch = *tinP.pEtScratch ;

        SCOOPS
    {
    IFsCRATCH
{
voidT hasherF( tinS& tinP , etherC& etherP , const boolT& bQuitP , countT& bFailP , countT& cHashersP , const infoFileS* pInfoP , const strokeS* const psttLocalContainerRootP , const strokeS* const psttLocalContainerP , keyValuePairsC& kvP , countT& cFileOrDirDoneP )

}
    ;

        !thirdC::c_strstrIF( tinP , postShortP , postLook4 )
        !thirdC::c_strstrIF( tinP , postShortP , postLook3 ) &&
        !thirdC::c_strstrIF( tinP , postShortP , postLook2 ) &&
        !thirdC::c_strstrIF( tinP , postShortP , postLook1 ) &&
                                    postShortP               &&

    return
{
boolT bGhostF( tinS& tinP , const osTextT* const postShortP )

const osTextT postLook4[] = ".!.narrative."    ;
const osTextT postLook3[] = ".!.day.title.ttt" ;
const osTextT postLook2[] = ".!.note."         ;
const osTextT postLook1[] = ".!.transcript."   ;
// MOST COMMON WOTH

/**/
*/
 each recursion consumes 4 slots in the jot registry
the depth of local directory nesting that i can accommodate is limited by CsLOTSjOTrEGISTRY
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

