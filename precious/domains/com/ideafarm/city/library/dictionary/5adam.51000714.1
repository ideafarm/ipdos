
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

while( ~hFindDir && !ether && !POOP ) ;
}
    DEL( pInfoDir ) ;

    }
        }
            while( ~hFindFile && !ether && !POOP ) ;
            }
                DEL( pInfoFile ) ;

                }
                    }
                        }
                            while( ~hFindFileZap && !ether && !POOP ) ;
                            }
                                DEL( pInfoFileZap ) ;

                                }
                                    }
                                        etThread.diskFileOrDirDeleteF( tinP , tIfoName ) ;
                                    {
                                    if( !bDir )

                                    const boolT bDir = pInfoFileZap->psttIfoName[ CSpREFIX - 1 + pInfoFileZap->psttIfoName->idAdam ].idAdam == '/' ;
                                    TN( tIfoName , pInfoFileZap->psttIfoName ) ;
                                {
                                if( pInfoFileZap && pInfoFileZap->psttIfoName )

                                etThread.diskFindFileOrDirOldF( tinP , pInfoFileZap , hFindFileZap , tLongMetaDotStar ) ; ___( pInfoFileZap ) ;
                                ZE( infoFileS* , pInfoFileZap ) ;
                            {
                            do
                            handleC hFindFileZap( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                            etThread.diskMoveFileOrDirF( tinP , tPathDir+tShortDir+TF3(++idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+tDot+tName , tIfoName ) ;

                            etThread.traceF( tinP , tShortFile+tb8+tName ) ;

                            }
                                etThread.delF( tinP , postName ) ;
                                tName = T(postName) ;
                                etThread.boxGetShadowF( tinP , postName , costName , tFileMetaNameLong ) ; ___( postName ) ;
                                ZE( countT   , costName ) ;
                                ZE( osTextT* , postName ) ;
                            {
                            else
                            if( !etThread.diskFileExistsF( tinP , tFileMetaNameLong ) ) etThread.traceF( tinP , T("error / file does not exist: ")+tFileMetaNameLong ) ;
                            TN( tName , "" ) ;

                            TN( tFileMetaNameLong , "" ) ; tFileMetaNameLong = tPathDir+tShortDir+tShortFileMetaName ;

                            etThread.delF( tinP , psttShortFileRoot ) ;
                            TN( tLongMetaDotStar , "" ) ; tLongMetaDotStar = tPathDir+tShortDir+T(psttShortFileRoot)+tMetaDotStar ;
                            TN( tShortFileMetaName , "" ) ; tShortFileMetaName = T(psttShortFileRoot)+tMetaDotCurrentName ;

                            etThread.strSubstringF( tinP , psttShortFileRoot , idf , idHit , tShortFile ) ; ___( psttShortFileRoot ) ;
                            countT idf = 1 ;
                            ZE( strokeS* , psttShortFileRoot ) ;
                        {
                        if( idHit )
                        countT idHit = etThread.strIdF( tinP , tDotDataDot , tShortFile ) ;

                        etThread.traceF( tinP , tShortFile ) ;
                    {
                    if( !bDir )

                    }
                        etThread.delF( tinP , psttShortFile ) ;
                        tShortFile = T(psttShortFile) ;
                        etThread.delF( tinP , psttnu ) ;
                        etThread.strBisectF( tinP , psttnu , psttShortFile , pInfoFile->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShortFile ) ;
                        ZE( strokeS* , psttShortFile ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShortFile , "" ) ;

                    const boolT bDir = pInfoFile->psttIfoName[ CSpREFIX - 1 + pInfoFile->psttIfoName->idAdam ].idAdam == '/' ;
                    TN( tIfoName , pInfoFile->psttIfoName ) ;
                {
                else
                }
                    break ;
                    DEL( pInfoFile ) ;
                {
                if( !pInfoFile || !pInfoFile->psttIfoName )

                etThread.diskFindFileOrDirOldF( tinP , pInfoFile , hFindFile , tPathDir+tShortDir+tLikeFile ) ; ___( pInfoFile ) ;
                ZE( infoFileS* , pInfoFile ) ;
            {
            do
            handleC hFindFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            ZE( countT , idFile ) ;

            etThread.traceF( tinP , tShortDir ) ;
        {
        if( bDir && etThread.strCompareF( tinP , tDotSlash , tShortDir ) && etThread.strCompareF( tinP , tDotDotSlash , tShortDir ) )

        }
            etThread.delF( tinP , psttShortDir ) ;
            tShortDir = T(psttShortDir) ;
            etThread.delF( tinP , psttnu ) ;
            etThread.strBisectF( tinP , psttnu , psttShortDir , pInfoDir->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShortDir ) ;
            ZE( strokeS* , psttShortDir ) ;
            ZE( strokeS* , psttnu ) ;
        {
        TN( tShortDir , "" ) ;

        const boolT bDir = pInfoDir->psttIfoName[ CSpREFIX - 1 + pInfoDir->psttIfoName->idAdam ].idAdam == '/' ;
        TN( tIfoName , pInfoDir->psttIfoName ) ;
    {
    else
    }
        break ;
        DEL( pInfoDir ) ;
    {
    if( !pInfoDir || !pInfoDir->psttIfoName )

    etThread.diskFindFileOrDirOldF( tinP , pInfoDir , hFindDir , tPathDir+tLikeDir ) ; ___( pInfoDir ) ;
    ZE( infoFileS* , pInfoDir ) ;
{
do
handleC hFindDir( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

TN( tDot , "." ) ;
TN( tDotDotSlash , "../" ) ;
TN( tDotSlash , "./" ) ;
TN( tb8 , "        " ) ;
TN( tMetaDotStar , "meta.*" ) ;
TN( tMetaDotCurrentName , "meta.currentname" ) ;
TN( tDotDataDot , ".data." ) ;
TN( tSlash , "/" ) ;
TN( tLikeFile , "!ideafarm.8.2.00000000.00000001.*.data.*" ) ;
TN( tLikeDir , "*" ) ;
TN( tPathDir , "///w/archive.snap.renamed/" ) ;

TODO

/*1*/WAKEsHOWtEXT( "tool.file.rename.data.discard.meta" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
