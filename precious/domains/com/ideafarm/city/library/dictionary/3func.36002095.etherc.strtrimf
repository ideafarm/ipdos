
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return csttFromBeginning ;

    delF( tinP , psttDoomedList ) ;
    delF( tinP , psttOld ) ;

    }
        delF( tinP , psttTrimmed ) ;
        }
            if( idd ) { strFuseF( tinP , psttP , psttItemDelimiterP ) ; ___( psttP ) ; }
            strFuseF( tinP , psttP , psttTrimmed ) ; ___( psttP ) ;
        {
        if( psttTrimmed && psttTrimmed->idAdam )

        }
            delF( tinP , psttw2 ) ;

            else           { strSubstringF( tinP , psttTrimmed , countTC( 1 ) , cWanted , psttw2 ) ; ___( psttTrimmed ) ; }
            if( !cWanted ) { psttTrimmed = psttw2 ; psttw2 = 0 ; }

            }
                break ;
                cWanted = idd - 1 ;
                if( idf1 ) continue ;
                if( !idd ) break ;
                countT idd = strIdAnyF( tinP , 0 , flSTRmATCH_null , idf1 , sttq1 , psttDoomedList , psttw2 ) ;
            {
            while( !POOP )
            ZE( countT , cWanted ) ;
            strokeS sttq1( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf1 = 1 ;
        {
        if( psttw2 )
        ZE( strokeS* , psttTrimmed ) ;

        // psttw2: LEADING DOOMED HAVE BEEN REMOVED
        delF( tinP , psttw ) ;
        }
            }
                strSubstringF( tinP , psttw2 , idf1 , countTC() , psttw ) ; ___( psttw2 ) ;

                }
                    csttFromBeginning = idf1 - 1 ;
                    bWoth = 0 ;
                {
                if( bWoth )
            {
            else
            }
                strMakeF( tinP , psttw2 , T("") ) ; ___( psttw2 ) ;

                }
                    csttFromBeginning = psttw->idAdam ;
                    bWoth = 0 ;
                {
                if( bWoth )
            {
            if( !idf1 )

            countT idf1 = strIdAnyF( tinP , 0 , flSTRmATCH_null , countTC( 1 ) , sttq1 , psttDoomedList , psttw , 0 , 1 , flSTRiDaNY_NOT ) ;
            strokeS sttq1 = sttq ;
        {
        if( psttw )
        ZE( strokeS* , psttw2 ) ;

        // psttw: CURRENT LINE TO PROCESS
        }
            psttw = psttOld ; psttOld = 0 ;
            idf = 0 ;
        {
        else
        if( psttItemDelimiterP ) { strSubstringF( tinP , psttw , idf , sttq , psttItemDelimiterP , psttOld , 0 ) ; ___( psttw ) ; }
        ZE( strokeS* , psttw ) ;

        // idd: ID OF NEXT DELIMITER
        if( psttItemDelimiterP ) { countT idf1 = idf ; strokeS sttq1 = sttq ; idd = strIdF( tinP , 0 , flSTRmATCH_null , idf1 , sttq1 , psttItemDelimiterP , psttOld ) ; }
        ZE( countT , idd ) ;
    {
    while( !POOP && idf ) 
    boolT bWoth = 1 ;
    ZE( countT , csttFromBeginning ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    countT idf = 1 ;
    POSTPONEtEST( psttP ) ;
    strMakeF( tinP , psttP , T("") , psttOld ? psttOld->idAdam : 0 ) ; // CALLER MUST TAG ___( psttP ) ;

    }
        delF( tinP , psttd ) ;
        else       { strMakeF( tinP , psttOld , T("") ) ; ___( psttOld ) ; }
        if( iddl ) { strSubstringF( tinP , psttOld , idf , iddl , psttd ) ; ___( psttOld ) ; }
        iddl -- ;
        countT idf = 1 ;
        psttOld = 0 ;
        psttd = psttOld ;
        ZE( strokeS* , psttd ) ;
        if( iddl != cs - cd + 1 ) break ;
        countT iddl = strIdF( tinP , 0 , flSTRmATCH_null , countTC( 1 ) , sttq , psttItemDelimiterP ,  psttOld , 0 , - 1 ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        if( cs < cd ) break ;
        countT cd = psttItemDelimiterP ? psttItemDelimiterP->idAdam : 0 ;
        countT cs = psttOld ? psttOld->idAdam : 0 ;
    {
    if( psttItemDelimiterP ) while( !POOP )
    // REMOVE ANY TRAILING DELIMITERS

    __NZ( psttP ) ;
    }
        psttP = 0 ;
        psttOld = psttP ;
    {
    else
    if( psttOldP ) { strMakeF( tinP , psttOld , psttOldP ) ; ___( psttOld ) ; }
    ZE( strokeS* , psttOld ) ;

    else                  { strMakeF( tinP , psttDoomedList , T(psttItemDelimiterP?TbLACKeXCLUDINGnEWlINE:TbLACK) ) ; ___( psttDoomedList ) ; }
    if( psttDoomedListP ) { strFuseF( tinP , psttDoomedList , psttDoomedListP                                     ) ; ___( psttDoomedList ) ; }
    ZE( strokeS* , psttDoomedList ) ;

    _IO_

    }
        if( POOP ) return 0 ;
        __NZ( sttNewP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/countT etherC::strTrimF( tinS& tinP , strokeS*& psttP , const strokeS* const psttOldP , const strokeS* const psttItemDelimiterP , const strokeS* const psttDoomedListP , const strokeS sttNewP )/*1*/

//U:: 20130108@2102: THIS DOES NOT WORK.  SEE ADAM 51000675

/**/
*/
 sttNewP
 psttDoomedListP
 psttItemDelimiterP
 psttOldP
 psttP
arguments
sttNewP: this is not used, and must be 0
  spaces (' '), tabs ('\t'), and end of file marks ('\x1a') are removed
 if 0 then T(" \t\x1a") is used
psttDoomedListP: strokes that will be removed from the beginning and end of each line
 if 0 then T("\r\n") is used
psttItemDelimiterP: delimits each line
psttOldP: can be 0
  \<A HREF=\"5.ba10104.1.1.0.html\"\>ba10104:  WAKEsHOW( "example.simplest.func.10300a4.etherC.strTrimF" )\</A\>
 simplest
examples
\<A HREF=\"5.10300a4.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strTrimF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

