
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;

BOSpOOP
BOS( WHATgbo , BOSoK , TextOut( oshdc , 0x100 , 0x100 , bOk ? "done" : "fail" , 4 ) )

#endif

    #endif
        LOGrAW9( "SMALL SIMPLE  [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;
    #else
        LOGrAW9( "SMALL COMPLEX [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;
    #if defined( COMPLEX )

#else

    #endif
        LOGrAW9( "BIG   SIMPLE  [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;
    #else
        LOGrAW9( "BIG   COMPLEX [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;
    #if defined( COMPLEX )

#if defined( BIG )

const countT cLines = ( cSize - 1 ) * cGlyph ;

//Beep( TUCK << 2 , TUCK ) ;

tinP.pEther->osTimeSubtractF( tinP , timeE1 , timeE2 , timeS1 , timeS2 ) ;
tinP.pEther->osTimeNowF( tinP , timeE1 , timeE2 ) ;
ZE( sCountT , timeE2 ) ;
ZE( countT , timeE1 ) ;

boolT bOk = tinP.brcRaw ;
BOSpOOP
BOS( WHATgbo , BOSoK , PolyPolyline( oshdc , ppt , (DWORD*)pcSize , cGlyph ) )

tinP.pEther->osTimeNowF( tinP , timeS1 , timeS2 ) ;
ZE( sCountT , timeS2 ) ;
ZE( countT , timeS1 ) ;

//Beep( TUCK << 1 , TUCK ) ;

BOSpOOP
BOS( WHATgbo , BOSoK , Rectangle( oshdc , rectClient.left , rectClient.top , rectClient.right , rectClient.bottom ) )

//BOSpOOP
//BOS( WHATgbo , BOSoK , SetROP2( oshdc , R2_XORPEN ) )

BOSdOnOTtEST( WHATgbo , SelectObject( oshdc , oshp ) )
BOSdOnOTtEST( WHATgbo , SelectObject( oshdc , oshb ) )

HPEN   oshp = (HPEN)tinP.brcRaw ;
BOSpOOP
BOS( WHATgbo , BOSoK , CreatePen( PS_SOLID , 1 , 0xffffff ) )
HBRUSH oshb = (HBRUSH)tinP.brcRaw ;
BOSpOOP
BOS( WHATgbo , BOSoK , CreateSolidBrush( 0 ) )

}
    }

        #endif

            case 0 : { ppt[ offp ].x = ppt[ offp - 1 ].x ; ppt[ offp ].y = ppt[ offp - 1 ].y + 1 ; break ; }
            case 3 : { ppt[ offp ].x = 0x10              ; ppt[ offp ].y = ppt[ offp - 1 ].y     ; break ; }
            case 2 : { ppt[ offp ].x = ppt[ offp - 1 ].x ; ppt[ offp ].y = ppt[ offp - 1 ].y + 1 ; break ; }
            case 1 : { ppt[ offp ].x = 0x20              ; ppt[ offp ].y = ppt[ offp - 1 ].y     ; break ; }

        #else

            case 0 : { ppt[ offp ].x = ppt[ offp - 1 ].x ; ppt[ offp ].y = ppt[ offp - 1 ].y + 1 ; break ; }
            case 3 : { ppt[ offp ].x = 0x10              ; ppt[ offp ].y = ppt[ offp - 1 ].y     ; break ; }
            case 2 : { ppt[ offp ].x = ppt[ offp - 1 ].x ; ppt[ offp ].y = ppt[ offp - 1 ].y + 1 ; break ; }
            case 1 : { ppt[ offp ].x = 0x410             ; ppt[ offp ].y = ppt[ offp - 1 ].y     ; break ; }

        #if defined( BIG )
    {
    else switch( offp % 4 )
    }
        ppt[ offp ].y = 0x10 ;
        ppt[ offp ].x = 0x10 ;
    {
    if( !( offp % cSize ) )
{
for( countT offp = 0 ; offp < sizeof ppt / sizeof ppt[ 0 ] ; offp ++ )

for( countT offs = 0 ; offs < cGlyph ; offs ++ ) pcSize[ offs ] = cSize ;

}
    }
        pRootI->letRefF() ;
        BOSpOOP
        BOS( WHATgbo , BOSoK , GetClientRect( (HWND)((const handleC&)*pRootI).osF( ifcIDtYPEhANDLE_WINDOW ) , &rectClient ) )
        oshdc = (HDC)hDraw.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) ;
        handleC& hDraw = pRootI->hDrawWindowF() ;
    {
    if( pRootI )
    windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
{
RECT  rectClient ;
ZE( HDC , oshdc ) ;

TODO

const countT cSize = cpt / cGlyph ;
const countT cpt = sizeof ppt / sizeof ppt[ 0 ] ;
countT pcSize[ cGlyph ] ;

#endif

    POINT        ppt[ cGlyph << 4 ] ;
    const countT cGlyph = 0x4e200 - 1 ;

#else

    POINT        ppt[ cGlyph << 8 ] ;
    const countT cGlyph = 0x4e20 - 1 ;

#if defined( COMPLEX )
//LIMIT IS 0x4e200 WITH "<< 4"; LIMIT IS 0x4e20 WITH "<< 8"

//#define COMPLEX
//#define BIG

/*1*/WAKEsHOW( "tool.benchmark.glyph.drawing.speed" )/*1*/
/**/
*/
 | 
 | BIG   COMPLEX [cSize,cLines,timeE1,cLines/timeE1]: 001 0e1dd4 a477d 5
 | BIG   SIMPLE  [cSize,cLines,timeE1,cLines/timeE1]: 01 00e394 eb2ec 5
 | SMALL COMPLEX [cSize,cLines,timeE1,cLines/timeE1]: 001 0e1dd4 aa154 21
 | SMALL SIMPLE  [cSize,cLines,timeE1,cLines/timeE1]: 01 00e394 b5d24 11
 | 
output
when the lines are long, they take 3x time to draw
i use "raw" win32 calls, and can draw 11 (17_9) short lines per time (per 1/50,000 sec)
i have oo modes, selected by defining or leaving undefined BIG COMPLEX
i can be used to measure the speed of drawing lines in a glyph
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

