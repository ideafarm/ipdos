
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


    }
        tinP.ta.retained.u.listWalk.walk.pPoolRecord = 0 ;                                                                                                            \
                                                                                                                                                                    \
        }                                                                                                                                                           \
            DEL( pPuseIndex ) ;                                                                                                                                     \
            PUSE( tinP , *(byteT**)&pczV ) ;                                                                                                                        \
            puseC puseat( tinP , 0 , ifcIDpOOL_ADAMtEMP ) ;                                                                                                             \
        {                                                                                                                                                           \
                                                                                                                                                                    \
        }                                                                                                                                                           \
            { puseC puseat( tinP , 0 , ifcIDpOOL_ADAMtEMP ) ; PUSE( tinP , *(byteT**)&pczIKV ) ; }                                                                      \
                                                                                                                                                                    \
            }                                                                                                                                                       \
                }                                                                                                                                                   \
                    pczIKV[ ccDoomed ] = 0 ;                                                                                                                        \
                    ccDoomed -- ;                                                                                                                                   \
                {                                                                                                                                                   \
                while( ccDoomed > 1 && F(flLISTwALKrETURNcODE_LISTINGdELETED) & listC::deleteIF( tinP , pczIKV , flLISTdELETE_IFeMPTY ) )                           \
                countT ccDoomed = ccIKV ;                                                                                                                           \
                                                                                                                                                                    \
                thirdC::c_memcpyIF( tinP , (byteT*)( pczIKV + ccIK ) , (byteT*)pczV  , sizeof( countT ) * ( ccV      + 1 ) ) ;                                      \
                thirdC::c_memcpyIF( tinP , (byteT*)  pczIKV          , (byteT*)pczIK , sizeof( countT ) *   ccIK           ) ;                                      \
            {                                                                                                                                                       \
            if( !bFail )                                                                                                                                            \
                                                                                                                                                                    \
            }                                                                                                                                                       \
                __Z( pczIKV ) ;                                                                                                                                     \
                PUSE.newF( tinP , LF , *(byteT**)&pczIKV , sizeof( countT ) * ( ccIKV + 1 ) ) ; ___( pczIKV ) ;                                                     \
                puseC puseat( tinP , 0 , ifcIDpOOL_ADAMtEMP ) ;                                                                                                         \
            {                                                                                                                                                       \
            countT ccIKV = ccIK + ccV ;                                                                                                                             \
            countT ccV   = thirdC::c_strlenIF( tinP , pczV  ) ;                                                                                                     \
            countT ccIK  = thirdC::c_strlenIF( tinP , pczIK ) ;                                                                                                     \
            ZE( countT* , pczIKV ) ;                                                                                                                                \
        {                                                                                                                                                           \
        if( !bFail )                                                                                                                                                \
                                                                                                                                                                    \
        }                                                                                                                                                           \
            DELlIST( fieldEditParamOutC , pOut ) ;                                                                                                                  \
            puseC puseat( tinP , 0 , ifcIDpOOL_ADAMtEMP ) ;                                                                                                             \
        {                                                                                                                                                           \
                                                                                                                                                                    \
        }                                                                                                                                                           \
            }                                                                                                                                                       \
                listC::fieldIF( tinP , pOut , hIKV , pczField , _1_deleteC() + _1_ok_equal_C( recordP ) , LF ) ;                                                    \
                countT pczField[] = { LISTnAME_RECORD , 0 } ;                                                                                                       \
            {                                                                                                                                                       \
            if( !bFail )                                                                                                                                            \
                                                                                                                                                                    \
            if( bOpenIK ) hIKP.closeIfF() ;                                                                                                                         \
            if( bFail && bSmelly ) { __1 }                                                                                                                          \
            if( !hIKV ) bFail = 1 ;                                                                                                                                 \
            listC::openIF( tinP , hIKV , hIKP , pczV , flLISToPEN_IFeXISTS ) ;                                                                                      \
            handleC hIKV( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;                                                                                     \
        {                                                                                                                                                           \
        if( !bFail )                                                                                                                                                \
        ZE( fieldEditParamOutC* , pOut ) ;                                                                                                                          \
                                                                                                                                                                    \
        }                                                                                                                                                           \
            if( bFail && bSmelly ) { __1 }                                                                                                                          \
            if( !hIKP ) bFail = 1 ;                                                                                                                                 \
            listC::openIF( tinP , hIKP , pczIK , flLISToPEN_IFeXISTS ) ;                                                                                            \
            THREADmODE2rESTORE                                                                                                                                      \
            listC::dictionaryReplaceOsTextIF( tinP , pczIK ) ;                                                                                                      \
            THREADmODE2oN( flTHREADmODE2_ALLOWdICTIONARYwHILEgRABBING )                                                                                             \
        {                                                                                                                                                           \
        if( bOpenIK )                                                                                                                                               \
        countT pczIK[] = { LISTnAME_ROOT , LISTnAME_ROOTsYSTEM3 , LISTnAME_FIELDvALUEiNDEX , (countT)postMasterPool , LISTnAME_INDEXaPPLICATION , idKeyInIndex , 0 } ; \
        ZE( boolT , bFail ) ;                                                                                                                                       \
                                                                                                                                                                    \
        }                                                                                                                                                           \
            THREADmODE2rESTORE                                                                                                                                      \
            }                                                                                                                                                       \
                }                                                                                                                                                   \
                    DELzOMBIE( pvspPostKey ) ;                                                                                                                      \
                    idKeyInIndex = dictionaryQueryFromTextIF( tinP , *pvspPostKey ) ;                                                                               \
                {                                                                                                                                                   \
                if( !bLiteralKey )                                                                                                                                  \
                                                                                                                                                                    \
                }                                                                                                                                                   \
                    ___( pPuseIndex ) ;                                                                                                                             \
                    puseC puseat( tinP , 0 , ifcIDpOOL_ADAMtEMP ) ;                                                                                                     \
                {                                                                                                                                                   \
                                                                                                                                                                    \
                ;                                                                                                                                                   \
                    : new( 0 , tinP , LF ) puseC( tinP , 0 , idStateSpace == ifcIDsTATEsPACE_SINGLEaDAM( tinP ) || idStateSpace == ifcIDsTATEsPACE_SCRATCH ? ifcIDpOOL_ADAMtEMP : ifcIDpOOL_HOMEtEMP ) \
                    ? new( 0 , tinP , LF ) puseC( puseIndexP )                                                                                                      \
                pPuseIndex = !bOpenIK                                                                                                                               \
                puseat.doNothingWhenDieF() ;                                                                                                                        \
                puseC puseat( tinP , 0 , ifcIDpOOL_ADAMtEMP ) ;                                                                                                         \
                                                                                                                                                                    \
                }                                                                                                                                                   \
                    *pvspPostKey = dictionaryQueryFromIdIF( tinP , idKeyP ) ;                                                                                       \
                    pvspPostKey = new( 0 , tinP , pbvsp , sizeof pbvsp ) blobVSP ;                                                                                  \
                {                                                                                                                                                   \
                if( !bLiteralKey )                                                                                                                                  \
                ZE( blobVSP* , pvspPostKey ) ;                                                                                                                      \
                byteT pbvsp[ sizeof( blobVSP ) ] ;                                                                                                                  \
                boolT bLiteralKey = LISTnAME_min <= idKeyP && idKeyP << LISTnAME_max ;                                                                              \
            {                                                                                                                                                       \
            THREADmODE2oN( flTHREADmODE2_ALLOWdICTIONARYwHILEgRABBING )                                                                                             \
        {                                                                                                                                                           \
        if( !bOpenIK || thirdC::c_strcmpIF( tinP , postMasterPool , "adam.temp" ) )                                                                                 \
        countT idKeyInIndex = idKeyP ;                                                                                                                              \
        ZE( puseC* , pPuseIndex ) ;                                                                                                                                 \
        puseC puseMaster( tinP , *tinP.pPoolUse ) ;                                                                                                                 \
                                                                                                                                                                    \
        const countT idStateSpace = PUSE.idStateSpaceF() ;                                                                                                          \
        ;                                                                                                                                                           \
            : PUSE.postNameF( tinP )                                                                                                                                \
            ? 0                                                                                                                                                     \
        const osTextT* postMasterPool = !bOpenIK                                                                                                                    \
                                                                                                                                                                    \
        boolT bSmelly = !( F(flagsP) & flUNiNDEXf_IFiNDEXED ) ;                                                                                                     \
        boolT bOpenIK = !hIKP ;                                                                                                                                     \
                                                                                                                                                                    \
        }                                                                                                                                                           \
            etherC::strStretchIF( tinP , pczV , 0 , valueP , cNetP ) ; ___( pczV ) ;                                                                                \
            puseC puseat( tinP , 0 , ifcIDpOOL_ADAMtEMP ) ;                                                                                                             \
        {                                                                                                                                                           \
        ZE(  countT* , pczV ) ;                                                                                                                                     \
                                                                                                                                                                    \
        tinP.ta.retained.u.listWalk.walk.pPoolRecord = &PUSE ;                                                                                                        \
                                                                                                                                                                    \
        }                                                                                                                                                           \
            if( POOP ) return ;                                                                                                                                     \
            FV( flUNiNDEXf , flagsP ) ;                                                                                                                             \
            if( bCareful != - 1 ) { __( bCareful ) ; }                                                                                                              \
            countT bCareful = (expCarefulP) ;                                                                                                                       \
            if( POOP ) return ;                                                                                                                                     \
            __( !!tinP.ta.retained.u.listWalk.walk.pPoolRecord ) ;                                                                                                    \
            __Z( idKeyP ) ;                                                                                                                                         \
            if( POOP ) return ;                                                                                                                                     \
        {                                                                                                                                                           \
        IFbEcAREFUL                                                                                                                                                 \
    {                                                                                                                                                               \
    voidT listC::unIndexIF( tinS& tinP , puseC& puseIndexP , handleC& hIKP , const countT idKeyP , const typeP valueP , const countT cNetP , const listingC& recordP , const listingC& datumP , const flagsT flagsP ) \
                                                                                                                                                                    \
#define FD_UNiNDEXif(typeP,expCarefulP)                                                                                                                             \

/*1*//*FD_UNiNDEXif(typeP,expCarefulP)*//*1*/

/**/
*/
 flagsP
   the full record would then be displayed for all "checked" bodies, using the record references already retrieved
   these bodies would be displayed to the user, who would "check" which ones he is interested in
   the query would retrieve all [recordP,datumP] pairs for emails which contained a body that contained the word "awesome"
   in this example, each email record contains fields such as body, subject, from, to, cc, bcc, time
  application example: find the full text body of all emails that contain the word "awesome", display it, and if approved, retrieve the entire reocrd for that email
  the listing that contains the datum to be indexed
 datumP
  application example: find all families that contain a child named "Theresa"
  this is a record that contains a field with the specified value
  the list (record) that contains the list (field) that contains the datum to be indexed
 recordP
  this value is assumed to be present as a listing within the field
  this is the value to be indexed
 valueP
   it is the lath element of the fully qualified name of the list that contains the datum listing
   this is the value passed into fieldIF when the datum that is being indexed was created
  the name of the field
 idKeyP
    the cost of being specific to a field is small since it is cheap to open a handle to the overall index
    it might have been intentional, on the theory that it makes unindexing of a set of values for a specific field fast
    perhaps this was just an artifact of convenience while coding
   2011.12.27: not sure why it is this way
  note that this handle is to the index for a specific field rather than to the whole index
  as of this writing, no application of this ability to do global unindexing is expected
  non null value is allowed only to make this definition similar in power to indexIF
  may be null
 hIKP
  if !hIKP then specify puseC()
 puseIndexP
 tinP
args
i remove an index entry for a particular value of a particular field in a particular record
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

