
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bHandled ;
    paperOldC::ungrabIF( tinP ) ; //U::TO FIND A BUG
    //tinP.pAdamGlobal5->frPaper.grab.ungrabF( tinP ) ;
    //}
    //    LOGrAW( ostoSay ) ;
    //    OStEXTAK( ostoSay , " -----------------------------------------------------------------------------------------------------------------------\r\n" ) ;
    //    OStEXTC(  ostoSay , idIn , 0 ) ;
    //    OStEXTAK( ostoSay , "/- [idIn]: " ) ;
    //    OStEXTA(  ostoSay , postIdType ) ;
    //    OStEXTAK( ostoSay , " | doF/" ) ;
    //    OStEXTA(  ostoSay , tinP.postThreadName ) ;
    //    OStEXT(   ostoSay , TUCK << 2 ) ;
    //{
    //if( idTypeCallP != ifcIDtYPEsTROKEcALLbACK_ANIMATE && idTypeCallP != ifcIDtYPEsTROKEcALLbACK_MOUSE && idTypeCallP != ifcIDtYPEsTROKEcALLbACK_VOLATILEtEXTcHANGING && idTypeCallP != ifcIDtYPEsTROKEcALLbACK_VOLATILEtEXTcHANGED && idTypeCallP != ifcIDtYPEsTROKEcALLbACK_TABaRRIVING && idTypeCallP != ifcIDtYPEsTROKEcALLbACK_TABlEAVING )

    //if( bGoItRender ) tinP.pAdamGlobal5->frPaper.grab.ungrabF( tinP ) ;

    }
        DELzOMBIE( pStrike ) ;
        DELzOMBIE( pStrike ) ;

        if( F(flags) & flSADAMc_OWNtAB ) flags |= flSADAMc_TABwAShERE ;

        else flags &= ~( F(flSADAMc_TABwAShERE) ) ;
        }
            flags |=      flSADAMc_TABwAShERE    ;
            flags &= ~( F(flSADAMc_OWNtAB) ) ;
        {
        if( F(flags) & flSADAMc_OWNtAB )
    {
    if( bDeleteStrike )

    }
        (*features.fc.pSadamEpilogCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotesP , *this ) ;
        _IO_
    {
    if( pStrike && F(features.fc.flagsCallBack) & flFEATUREsADAMcALLbACK_EXISTS && features.fc.pSadamEpilogCBF )

    }
        pStrike->sc.pPaper->renderVolatilesF( tinP , *this , phCloneP , flSTRIKEvOLATILE_LOADpOSITION ) ;
    {
    if( idTypeCallP == ifcIDtYPEsTROKEcALLbACK_STRIKE )

    }
        }
            if( F(pStrike->sc.flagsHighlighted) & flSADAMhIGHLIGHT_DOWN ) pStrike->sc.pPaper->sadamHighlightF( tinP , *this , flSADAMhIGHLIGHT_DOWN ) ;
    
            }
                pStrike->sc.pPaper->sadamHighlightF( tinP , *this , flSADAMhIGHLIGHT_FLYOVER ) ;
                pStrike->sc.flags &= ~( F(flSTRIKEs_FLY) ) ;
            {
            if( F(pStrike->sc.flags) & flSTRIKEs_FLY )
    
            pStrike->sc.flags &= ~( F(flSTRIKEs_DRAG) ) ;
        {
        if( pStrike )
    {
    if( bStrikeKilled )

    }
        }
            break ;
            if( features.fc.pSadamAnimateCBF ) (*features.fc.pSadamAnimateCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotesP , *this ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_VOLATILEtEXTcHANGED  :
        case ifcIDtYPEsTROKEcALLbACK_VOLATILEtEXTcHANGING :
        case ifcIDtYPEsTROKEcALLbACK_ANIMATE              :
        }
            break ;

            }
                }
                    vb.ppsttSpec = &features.psttDefaultHighlightTabOwnerOff ;
                    if( !vb.flags ) new( 0 , tinP , (byteT*)&vb , features.pswVolBody->cbDataF() ) vBodyS ;
                    vBodyS& vb = *(vBodyS*)&(countT&)*features.pswVolBody ;
                    features.cLeverVolBody = IDVB_SYShIGHLIGHToWNtAB ;
                {
                pStrike->sc.pPaper->sadamHighlightF( tinP , *this , flSADAMhIGHLIGHT_OWNtAB ) ; //PROVISIONAL; CAN BE USED UNTIL eyeOldC IS USED; THEN WILL NEED TO USE SOMETHING THAT DOES NOT REQUIRE FLOODFILL
    
                }
                    (*features.fc.pSadamTabCBF)( tinP , etherP , ifcIDtYPEsTROKEcALLbACK_TABlEAVING , idEventP , pcNotesP , *this ) ;
                    if( F(features.fc.flagsAdam) & flFEATUREsADAMaDAM_TABhEREsUPPRESSEShOTkEYS ) backOldC::setModeFlagsIF( tinP , flPAPERbACKmODE_null , flPAPERbACKmODE_SUPPRESShOTkEYS ) ; //U::CONJ: BUG: THIS SHOULD BE DONE EVEN IF THERE ISN'T A CBF
                    _IO_
                {
                if( features.fc.pSadamTabCBF )

                //LOGrAWtID( TTtOCK(timeN1,timeN2)+T(" TABlEAVING/idAdam: ")+TF1(features.fc.idAdam)+T(" ")+T(features.fc.postOldComment) ) ;
                //etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                //ZE( sCountT , timeN2 ) ;
                //ZE( countT , timeN1 ) ;
            {
            if( bAlreadyOwnedTab )

            flags &= ~( F(flSADAMc_OWNtAB|flSADAMc_TABwAShERE) ) ;
            boolT bAlreadyOwnedTab = F(flags) & flSADAMc_OWNtAB ;
        {
        case ifcIDtYPEsTROKEcALLbACK_TABlEAVING :
        }
            break ;

            //}
            //    LOGrAW( tSay ) ;
            //    TN( tSay , "" ) ; tSay = T("\r\n")+TTtOCK(timeN1,timeN2)+T(" ")+T(tinP.postThreadName)+T(" TABaRRIVING (already owned so doing nada/idAdam: ")+TF1(features.fc.idAdam)+T("\r\n") ;
            //    etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            //    ZE( sCountT , timeN2 ) ;
            //    ZE( countT , timeN1 ) ;
            //{
            //else

            }
                }
                    vb.ppsttSpec = &features.psttDefaultHighlightTabOwnerOn ;
                    if( !vb.flags ) new( 0 , tinP , (byteT*)&vb , features.pswVolBody->cbDataF() ) vBodyS ;
                    vBodyS& vb = *(vBodyS*)&(countT&)*features.pswVolBody ;
                    features.cLeverVolBody = IDVB_SYShIGHLIGHToWNtAB ;
                {
                //THIS SNIPPET IS EXERCISED BUT DOES NOTHING BECAUSE ps ttDefaultHighlightTabOwnerOn IS NULL STRING

                pStrike->sc.pPaper->sadamHighlightF( tinP , *this , flSADAMhIGHLIGHT_OWNtAB ) ; //PROVISIONAL; CAN BE USED UNTIL eyeOldC IS USED; THEN WILL NEED TO USE SOMETHING THAT DOES NOT REQUIRE FLOODFILL
    
                }
                    (*features.fc.pSadamTabCBF)( tinP , etherP , ifcIDtYPEsTROKEcALLbACK_TABaRRIVING , idEventP , pcNotesP , *this ) ;

                    if( F(features.fc.flagsAdam) & flFEATUREsADAMaDAM_TABhEREsUPPRESSEShOTkEYS ) backOldC::setModeFlagsIF( tinP , flPAPERbACKmODE_SUPPRESShOTkEYS , flPAPERbACKmODE_null ) ; //U::CONJ: BUG: THIS SHOULD BE DONE EVEN IF THERE ISN'T A CBF

                    _IO_
                {
                if( features.fc.pSadamTabCBF )

                //LOGrAWtID( TTtOCK(timeN1,timeN2)+T(" TABaRRIVING/idAdam: ")+TF1(features.fc.idAdam)+T(" ")+T(features.fc.postOldComment) ) ;
                //etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                //ZE( sCountT , timeN2 ) ;
                //ZE( countT , timeN1 ) ;
            {
            if( !bAlreadyOwnedTab )

            flags |= flSADAMc_OWNtAB ;
            boolT bAlreadyOwnedTab = F(flags) & flSADAMc_OWNtAB ;
        {
        case ifcIDtYPEsTROKEcALLbACK_TABaRRIVING :
        }
            break ;

            }
                }
                    }
                        }
                            }
                                }
                                    etherP( tinP , psReport ) ;
                                    }
                                        etherP.cioPutF( tinP , etherC::etPrimeIF( tinP ) , features.pczChannelOut , *psReport ) ;
    
                                        *psReport << idRow ;
                                        *psReport << idCol ;
                                        *psReport << idAction ;
                                        *psReport << idTool ;
                                        //*psReport << (countT)0 ; //U::idsP
                                        //*psReport << (countT)0 ; //U::idSnipP
                                        *psReport << idTypeCallP ;
                                    {
                                    if( psReport )
                                    etherP( tinP , psReport , TAG( TAGiDnULL ) ) ;
                                    ZE( soulC* , psReport ) ;
                                {
                                if( F(features.fc.flagsCio) & flFEATUREsADAMcIO_EXISTS && features.pczChannelOut )
    
                                }
                                    bHandled = (*features.fc.pSadamIfHitCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotesP , *this ) ;
                                    _IO_
                                {
                                if( F(features.fc.flagsCallBack) & flFEATUREsADAMcALLbACK_EXISTS && features.fc.pSadamIfHitCBF )
                            {
                            if( bDo )
    
                            }
                                }
                                    break ;
                                    }
                                        }
                                            case ifcIDtYPEtOOL_MOUSEpOSITION     : { if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_TOOLpOSITION     ) { bDo = 1 ; } break ; }
                                            case ifcIDtYPEtOOL_MOUSEbUTTONrIGHT  : { if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_TOOLbUTTONrIGHT  ) { bDo = 1 ; } break ; }
                                            case ifcIDtYPEtOOL_MOUSEbUTTONcENTER : { if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_TOOLbUTTONcENTER ) { bDo = 1 ; } break ; }
                                            case ifcIDtYPEtOOL_MOUSEbUTTONlEFT   : { if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_TOOLbUTTONlEFT   ) { bDo = 1 ; } break ; }
                                        {
                                        switch( idTool )
                                    {
                                    if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_ACTIONmOVE )
    
                                    //LOGrAW( tSay ) ;
                                    //TN( tSay , "" ) ; tSay = T("\r\n")+TTtOCK(timeN1,timeN2)+T(" ")+T(tinP.postThreadName)+T(" MOUSEmOVE/idAdam: ")+TF1(features.fc.idAdam)+T("\r\n") ;
                                    //etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                                    //ZE( sCountT , timeN2 ) ;
                                    //ZE( countT , timeN1 ) ;
    
                                    if( bIn && features.fc.pSadamFlyoverCBF ) (*features.fc.pSadamFlyoverCBF)( tinP , etherP , ifcIDtYPEsTROKEcALLbACK_FLYOVER , idEventP , pcNotesP , *this ) ;
                                {
                                case ifcIDtYPEaCTION_MOVE :
                                }
                                    break ;
                                    }
                                        }
                                            case ifcIDtYPEtOOL_MOUSEpOSITION     : { if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_TOOLpOSITION     ) { bDo = 1 ; } break ; }
                                            case ifcIDtYPEtOOL_MOUSEbUTTONrIGHT  : { if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_TOOLbUTTONrIGHT  ) { bDo = 1 ; } break ; }
                                            case ifcIDtYPEtOOL_MOUSEbUTTONcENTER : { if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_TOOLbUTTONcENTER ) { bDo = 1 ; } break ; }
                                            case ifcIDtYPEtOOL_MOUSEbUTTONlEFT   : { if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_TOOLbUTTONlEFT   ) { bDo = 1 ; } break ; }
                                        {
                                        switch( idTool )
                                    {
                                    if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_ACTIONuP )
                                {
                                case ifcIDtYPEaCTION_UP :
                                }
                                    break ;
    
                                    if( idTool == ifcIDtYPEtOOL_MOUSEbUTTONlEFT && features.fc.idTabClass && bIn ) sadamsC::pSadamsIF( tinP )->tabFreshF( tinP , etherP , ifcIDtYPEtABfRESH_JUMP , this ) ;
    
                                    }
                                        }
                                            case ifcIDtYPEtOOL_MOUSEpOSITION     : { if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_TOOLpOSITION     ) { bDo = 1 ; } break ; }
                                            case ifcIDtYPEtOOL_MOUSEbUTTONrIGHT  : { if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_TOOLbUTTONrIGHT  ) { bDo = 1 ; } break ; }
                                            case ifcIDtYPEtOOL_MOUSEbUTTONcENTER : { if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_TOOLbUTTONcENTER ) { bDo = 1 ; } break ; }
                                            case ifcIDtYPEtOOL_MOUSEbUTTONlEFT   : { if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_TOOLbUTTONlEFT   ) { bDo = 1 ; } break ; }
                                        {
                                        switch( idTool )
                                    {
                                    if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_ACTIONdOWN )
                                {
                                case ifcIDtYPEaCTION_DOWN :
                            {
                            switch( idAction )
                            ZE( boolT , bDo ) ;
                        {
                        if( bIn || F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_OUTSIDE )
    
                        }
                            }
                                //LOGrAW7( "drag [idAdam,mIdColMoveTo,mIdRowMoveTo]: " , features.fc.idAdam , " " , pStrike->sc.mIdColMoveTo , " " , pStrike->sc.mIdRowMoveTo , "\r\n" ) ;
                                pStrike->sc.mIdRowMoveTo = idRow - pStrike->sc.mOffDragRow ;
                                pStrike->sc.mIdColMoveTo = idCol - pStrike->sc.mOffDragCol ;
                            {
                            else if( F(pStrike->sc.flags) & flSTRIKEs_DRAG && idTool == ifcIDtYPEtOOL_MOUSEpOSITION )
                            }
                                }
                                    }
                                        (*features.fc.pSadamInOutQueryCBF)( tinP , etherP , ifcIDtYPEsTROKEcALLbACK_DRAGeND , idEventP , pcNotes , *this ) ;
                                        countT pcNotes[] = { (countT)&bIn , idCol , idRow , 0 } ;
                                    {
                                    if( features.fc.pSadamDragCBF )
    
                                    pStrike->sc.flags &= ~( F(flSTRIKEs_DRAG) ) ;
                                {
                                else if( idAction == ifcIDtYPEaCTION_UP )
                                }
                                    }
                                        (*features.fc.pSadamInOutQueryCBF)( tinP , etherP , ifcIDtYPEsTROKEcALLbACK_DRAGbEGIN , idEventP , pcNotes , *this ) ;
                                        countT pcNotes[] = { (countT)&bIn , idCol , idRow , 0 } ;
                                    {
                                    if( features.fc.pSadamDragCBF )

                                    //LOGrAW7( "right button down [idAdam,mOffDragCol,mOffDragRow]: " , features.fc.idAdam , " " , pStrike->sc.mOffDragCol , " " , pStrike->sc.mOffDragRow , "\r\n" ) ;
    
                                    pStrike->sc.mOffDragRow = idRow - pStrike->sc.sf.mIdRow ;
                                    pStrike->sc.mOffDragCol = idCol - pStrike->sc.sf.mIdCol ;
                                    pStrike->sc.flags |= flSTRIKEs_DRAG ;
                                {
                                if( idAction == ifcIDtYPEaCTION_DOWN && bIn )
                            {
                            if( idTool == ifcIDtYPEtOOL_MOUSEbUTTONrIGHT )
                        {
                        if( pStrike->sc.idNestWothRender == 1 && F(features.fc.flagsDraggable) & flFEATUREsADAMdRAGGABLE_EXISTS )
    
                        }
                            }
                                pStrike->sc.pPaper->sadamHighlightF( tinP , *this , flSADAMhIGHLIGHT_FLYOVER ) ;

                                else      pStrike->sc.flags &= ~( F(flSTRIKEs_FLY) ) ;
                                if( bIn ) pStrike->sc.flags |=      flSTRIKEs_FLY ;
                            {
                            if( !( F(pStrike->sc.flags) & flSTRIKEs_FLY ) != !bIn )
                        {
                        if( F(features.fc.flagsFlyoverHighlight) & flFEATUREsADAMfLYOVERhIGHLIGHT_EXISTS && !( F(pStrike->sc.flags) & flSTRIKEs_DRAG ) )
    
                        }
                            (*features.fc.pSadamInOutQueryCBF)( tinP , etherP , ifcIDtYPEsTROKEcALLbACK_INoUTqUERY , idEventP , pcNotes , *this ) ;
                            countT pcNotes[] = { 1 , 3 , (countT)&bIn , idCol , idRow , 0 } ;
                        {
                        if( features.fc.pSadamInOutQueryCBF )
                        //DUPLICATEcODE
    
                        ;
                        )
                            (sCountT)idRow <= R( pStrike->sc.mIdRowHot ) - 1.0 + R( pStrike->sc.mRowsHot )
                            (sCountT)idRow >= R( pStrike->sc.mIdRowHot )                                   &&
                            (sCountT)idCol <= R( pStrike->sc.mIdColHot ) - 1.0 + R( pStrike->sc.mColsHot )    &&
                            (sCountT)idCol >= R( pStrike->sc.mIdColHot )                                   &&
                            pStrike->sc.pPaper->bShowF( tinP )                                             &&
                        (
                        boolT bIn =
                    {
                    if( pcNotesP[ 0 ] == 1 && pcNotesP[ 1 ] == 4 ) //U::CONJ: THIS TEST IS OBSOLETE
                {
                if( pStrike->sc.pPaper->bToolFilterAllowsF( tinP , idTool , idAction , features.fc.idAdam , features.fc.idToolFilterList ) )

                const countT& idRow    = pcNotesP[ 5 ] ;
                const countT& idCol    = pcNotesP[ 4 ] ;
                const countT& idAction = pcNotesP[ 3 ] ;
                const countT& idTool   = pcNotesP[ 2 ] ;
            {
            if( F(features.fc.flagsMouse) & flFEATUREsADAMmOUSE_EXISTS && pStrike->sc.pPaper->bShowF( tinP ) )
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;

            }
                }
                    }
                        }
                            etherP( tinP , psReport ) ;
                            }
                                etherP.cioPutF( tinP , etherC::etPrimeIF( tinP ) , features.pczChannelOut , *psReport ) ;
    
                                }
                                    *psReport << pmxP[ 6 ] ;
                                    *psReport << pmxP[ 5 ] ;
                                    *psReport << pmxP[ 4 ] ;
                                    *psReport << pmxP[ 3 ] ;
                                    *psReport << pmxP[ 2 ] ;
                                    *psReport << pmxP[ 1 ] ;
                                    *psReport << pmxP[ 0 ] ;
                                {
                                if( pmxP )
                                *psReport << idAction ;
                                *psReport << idTool ;
                                //*psReport << (countT)0 ; //U::idsP ;
                                //*psReport << (countT)0 ; //U::idSnipP ;
                                *psReport << idTypeCallP ;
    
                                const measureT* pmxP   = idAction == ifcIDtYPEaCTION_MOVE ? (const measureT*)pcNotesP[ 4 ] : 0 ;
                            {
                            if( psReport )
                            etherP( tinP , psReport , TAG( TAGiDnULL ) ) ;
                            ZE( soulC* , psReport ) ;
                        {
                        if( F(features.fc.flagsCio) & flFEATUREsADAMcIO_EXISTS && features.pczChannelOut )
    
                        }
                            bHandled = (*features.fc.pSadamIfHitCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotesP , *this ) ;
                            _IO_
                        {
                        if( F(features.fc.flagsCallBack) & flFEATUREsADAMcALLbACK_EXISTS && features.fc.pSadamIfHitCBF )
                    {
                    if( pcNotesP[ 0 ] == 1 && pcNotesP[ 1 ] >= 2 && pcNotesP[ 1 ] <= 4 ) //U::INSPECT WHAT THIS CODE LINE SHOULD BE
                {
                if( pStrike->sc.pPaper->bToolFilterAllowsF( tinP , idTool , idAction , features.fc.idAdam , features.fc.idToolFilterList ) )

                const countT& idAction = pcNotesP[ 3 ] ;
                const countT& idTool   = pcNotesP[ 2 ] ;
            {
            if( F(features.fc.flagsJoyStick) & flFEATUREsADAMjOYsTICK_EXISTS && pStrike->sc.pPaper->bShowF( tinP ) )
        {
        case ifcIDtYPEsTROKEcALLbACK_JOYsTICK :
        }
            break ;

            }
                }
                    }
                        (*features.fc.pSadamHotKeyCBF)( tinP , etherP , ifcIDtYPEsTROKEcALLbACK_HOTkEY , idEventP , pcNotesP , *this ) ;
                        //LOGrAW( "KEYBOARD: calling hot key cbf\r\n" ) ;
                    {
                    )
                        )
                            ( F(flags) & flSADAMc_OWNtAB && ( idTool == ifcIDtYPEtOOL_ENTER || idTool == ifcIDtYPEtOOL_ENTERnUM ) )
                            ||
                            idTool == features.fc.assignedHotKey
                        (
                        features.fc.pSadamHotKeyCBF &&
                        idAction == ifcIDtYPEaCTION_DOWN &&
                        !( F(tinP.pAdamGlobal1->_backOldC_.rowBack.ro.flagsPaperBackMode) & flPAPERbACKmODE_SUPPRESShOTkEYS ) &&
                    (
                    if
                    //EXAMPLE: A HOTKEY THAT JUMPS THE TAB TO A PROMPT WILL NOT ALSO BE APPENDED TO THE PROMPT'S VALUE
                    //DONE LATH SO REGULAR KEY PROCESSING IS NOT EFFECTIVE FOR THE HOTKEY PRESS
    
                    }
                        }
                            }
                                }
                                    etherP( tinP , psReport ) ;
                                    }
                                        etherP.cioPutF( tinP , etherC::etPrimeIF( tinP ) , features.pczChannelOut , *psReport ) ;
    
                                        *psReport << idAction ;
                                        *psReport << idTool ;
                                        //*psReport << (countT)0 ; //U::idsP
                                        //*psReport << (countT)0 ; //U::idSnipP
                                        *psReport << idTypeCallP ;
                                    {
                                    if( psReport )
                                    etherP( tinP , psReport , TAG( TAGiDnULL ) ) ;
                                    ZE( soulC* , psReport ) ;
                                {
                                if( F(features.fc.flagsCio) & flFEATUREsADAMcIO_EXISTS && features.pczChannelOut )
    
                                }
                                    bHandled = (*features.fc.pSadamIfHitCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotesP , *this ) ;
                                    _IO_
                                {
                                if( F(features.fc.flagsCallBack) & flFEATUREsADAMcALLbACK_EXISTS && features.fc.pSadamIfHitCBF )
                            {
                            if( bDo )
    
                            }
                                }
                                    break ;
                                    if( F(features.fc.flagsKeyboard) & flFEATUREsADAMkEYBOARD_ACTIONuP ) bDo = 1 ;
                                {
                                case ifcIDtYPEaCTION_UP :
                                }
                                    break ;
                                    if( F(features.fc.flagsKeyboard) & flFEATUREsADAMkEYBOARD_ACTIONdOWN ) bDo = 1 ;
                                {
                                case ifcIDtYPEaCTION_DOWN :
                            {
                            switch( idAction )
                            ZE( boolT , bDo ) ;
                        {
                        )
                            F(flags) & flSADAMc_OWNtAB
                            ||
                            F(features.fc.flagsKeyboard) & flFEATUREsADAMkEYBOARD_OUTSIDE
                        (
                        if
                    {
                    if( F(features.fc.flagsKeyboard) & flFEATUREsADAMkEYBOARD_EXISTS )
                {
                if( pStrike->sc.pPaper->bToolFilterAllowsF( tinP , idTool , idAction , features.fc.idAdam , features.fc.idToolFilterList ) )

                const countT& idAction = pcNotesP[ 3 ] ;
                const countT& idTool   = pcNotesP[ 2 ] ;
            {
            if( pcNotesP[ 0 ] == 1 && pcNotesP[ 1 ] == 2 && pStrike->sc.pPaper->bShowF( tinP ) )
        {
        case ifcIDtYPEsTROKEcALLbACK_KEYBOARD :
        }
            break ;


            //if( bDebugTrace ) { LOGrAWtID( T("ifcIDtYPEsTROKEcALLbACK_STRIKE/- \"")+T(features.fc.postOldComment)+T("\"") ) ; }

            //if( !bErase ) { TN( tSay , "" ) ; tSay = T("sadam ")+TF1(features.fc.idAdam)+T(": \"")+features.psttBody+T("\"\r\n") ; LOGrAW( tSay ) ; }
            paper.renderEndF() ;
            //LOGrAW( tSay ) ; //U::
            //TN( tSay , "" ) ; tSay = T("STRIKE ")+TF1(features.fc.idAdam)+T(" ")+TF1(pStrike->sc.id Render)+T("/-: pStrike->sc.pPaper->pPulp->mIdColNow is ")+TF1(pStrike->sc.pPaper->pPulp->mIdColNow)+T("\r\n") ;

            if( bErase ) bDeleteStrike = 1 ;

            if( F(features.fc.flagsCallBack) & flFEATUREsADAMcALLbACK_EXISTS && features.fc.pSadamAfterRenderCBF ) (*features.fc.pSadamAfterRenderCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotesP , *this ) ;

            etherP.delF( tinP , psttFramedBody ) ;
            }
                //U::CONJ: BUG: SHOULD STRIKE VOLATILE VALUE HERE

                pStrike->sc.pPaper->x1.pPulp->x1.back.wrapRenderOverrideF( tinP , psttFramedBody , phCloneP , pczIdAdamSnap , !bErase ? flPULPmODE_null : flPULPmODE_SUPPRESSpELcOLORcHANGES , flPULPmODE_null ) ;

                }
                    }
                        }
                            //LOGrAW5( "STRIKE [mIdColMoveTo,mIdRowMoveTo]: " , pStrike->sc.mIdColMoveTo , " " , pStrike->sc.mIdRowMoveTo , "\r\n" ) ;
                            pStrike->sc.mIdRowMoveTo = sf.mIdRow + mRowsMove ;
                            pStrike->sc.mIdColMoveTo = sf.mIdCol + mColsMove ;
                
                            pStrike->sc.mRowsMoved = 0.0 ;
                            pStrike->sc.mColsMoved = 0.0 ;
                        {
                        if( mColsMove || mRowsMove )
                        measureT mRowsMove  = pStrike->sc.mRowsMoved ;
                        measureT mColsMove  = pStrike->sc.mColsMoved ;
                        //LOGrAW5( "STRIKE retrieving and resetting pStrike->sc.m*Moved [pStrike->sc.mColsMoved,pStrike->sc.mRowsMoved]: " , pStrike->sc.mColsMoved , " " , pStrike->sc.mRowsMoved , "\r\n" ) ;
                    {
                    if( bRestoreMove )

                    thirdC::c_memcpyIF( tinP , (byteT*)&pStrike->sc.sfDad , (byteT*)&sfd , sizeof pStrike->sc.sfDad ) ;
                    thirdC::c_memcpyIF( tinP , (byteT*)&pStrike->sc.sf    , (byteT*)&sf  , sizeof pStrike->sc.sf    ) ;

                    const strokingFrameS& sfd = pStrike->sc.pPaper->sfF( tinP , 1 ) ;
                    const strokingFrameS& sf  = pStrike->sc.pPaper->sfF( tinP , 0 ) ;
                {
                else
                }
                    pStrike->sc.mRowsMoved = 0.0 ;
                    pStrike->sc.mColsMoved = 0.0 ;
                {
                if( bErase )
            {
            
            //LOGrAW( "STRIKE: preparing to render\r\n" ) ; //U::

            else                                                           pStrike->sc.pPaper->makeFramedSadamBodyF( tinP , psttFramedBody , *this , features.psttBody , cFrameNestDown , cFrameNestLeft , cFrameNestUp , cFrameNestRight ) ; ___( psttFramedBody ) ;
            if( !( F(features.fc.flagsFrame) & flFEATUREsADAMfRAME_EXISTS ) ) { etherP.strMakeF( tinP , LF , psttFramedBody , features.psttBody ) ; ___( psttFramedBody ) ; }
            ZE( strokeS* , psttFramedBody ) ;

            //LOGrAW( "STRIKE: perhaps adjusting hot rect for frame\r\n" ) ; //U::

            }
                //LOGrAW( tSay ) ; //U::
                //TN( tSay , "" ) ; tSay = T("STRIKE: set pStrike->sc.mIdRowHot to ")+TF1(pStrike->sc.mIdRowHot)+T("\r\n") ;
                }
                    pStrike->sc.pPaper->x1.pPulp->boundingRectF( tinP , pStrike->sc.mIdColHot , pStrike->sc.mIdRowHot , pStrike->sc.mColsHot , pStrike->sc.mRowsHot , features.psttBody , phCloneP , pczIdAdamSnap , flBOUND_OIL ) ;
                    pStrike->sc.mRowsHot = pStrike->sc.mColsHot = pStrike->sc.mIdRowHot = pStrike->sc.mIdColHot = 0.0 ;
                
                    pStrike->sc.pPaper->x1.pPulp->x1.back.wrapRenderOverrideF( tinP , T("\r\n") , phCloneP , pczIdAdamSnap , flPULPmODE_null , flPULPmODE_null ) ;
                    //LOGrAW( "STRIKE: wrap detected; going to new line and getting hot rect again\r\n" ) ; //U::
                {
                if( pStrike->sc.pPaper->x1.pPulp->boundingRectF( tinP , pStrike->sc.mIdColHot , pStrike->sc.mIdRowHot , pStrike->sc.mColsHot , pStrike->sc.mRowsHot , features.psttBody , phCloneP , pczIdAdamSnap , flBOUND_OIL ) )
                pStrike->sc.mRowsHot = pStrike->sc.mColsHot = pStrike->sc.mIdRowHot = pStrike->sc.mIdColHot = 0.0 ;

                strokingFrameS& sfw = *(strokingFrameS*)&pulp.stqr_strokingFrame[ 2 + pulp.rCache.offFrame + pulp.rCache.offFrameWrap ] ;
                pulpOldC& pulp = *pStrike->sc.pPaper->x1.pPulp ;
            {
            countT pczIdAdamSnap[] = { features.fc.idAdam , 0 } ;
            //LOGrAW( "STRIKE: getting hot rect and detecting wrap\r\n" ) ; //U::

            TN( tBody , "" ) ;
            ZE( countT , cFrameNestRight ) ;
            ZE( countT , cFrameNestUp ) ;
            ZE( countT , cFrameNestLeft ) ;
            ZE( countT , cFrameNestDown ) ;
            ZE( boolT , bRestoreMove ) ;

            pStrike->sc.pPaper = &paper ;
            features.fc.cyclesPerDragRedraw = 4 ;
            features.fc.idIntercom = 0 ;

            paper.renderStartF() ;
            flags &= ~( F(flSADAMc_DESTROYED) ) ;

            else          pStrike = new( 0 , tinP , pbStrike , sizeof pbStrike ) strikeS( tinP ) ;
            if( pStrike ) bErase = 1 ;
            ZE( boolT , bErase ) ;

            strokeS& sttr = *(strokeS*)pcNotesP[ 1 ] ;
            paperOldC& paper =  *(paperOldC*)pcNotesP[ 0 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_STRIKE :
        }
            break ;

            }
                if( features.fc.pSadamAnimateCBF ) (*features.fc.pSadamAnimateCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotesP , *this ) ;
                bStrikeKilled = 1 ;
                pStrike->sc.flags &= ~( F(flSTRIKEs_AWAKE) ) ;
            {
            if( F(pStrike->sc.flags) & flSTRIKEs_AWAKE )
            //CODEsYNC: PSEUDOdUPLICATE CODE 0b50007 0b50007
        {
        case ifcIDtYPEsTROKEcALLbACK_SLEEP :
        }
            break ;

            }
                if( features.fc.pSadamAnimateCBF ) (*features.fc.pSadamAnimateCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotesP , *this ) ;
                pStrike->sc.flags |= flSTRIKEs_AWAKE ;
            {
            if( !( F(pStrike->sc.flags) & flSTRIKEs_AWAKE ) )

            }
                }
                    }
                        (*features.fc.pSadamFlyoverCBF)( tinP , etherP , ifcIDtYPEsTROKEcALLbACK_FLYOVER , idEventP , pcNotes , *this ) ;
                        countT pcNotes[] = { 1 , 4 , ifcIDtYPEtOOL_MOUSEpOSITION , ifcIDtYPEaCTION_MOVE , idCol , idRow , 0 } ;
                    {
                    if( features.fc.pSadamFlyoverCBF )

                    pStrike->sc.pPaper->sadamHighlightF( tinP , *this , flSADAMhIGHLIGHT_FLYOVER ) ;

                    pStrike->sc.flags |= flSTRIKEs_FLY ;
                {
                else
                if( !bIn ) pStrike->sc.flags &= ~( F(flSTRIKEs_FLY) ) ;

                }
                    (*features.fc.pSadamInOutQueryCBF)( tinP , etherP , ifcIDtYPEsTROKEcALLbACK_INoUTqUERY , idEventP , pcNotes , *this ) ;
                    countT pcNotes[] = { 1 , 3 , (countT)&bIn , idCol , idRow , 0 } ;
                {
                if( features.fc.pSadamInOutQueryCBF )
                //DUPLICATEcODE

                ;
                )
                    idRow <= R( pStrike->sc.mIdRowHot ) - 1.0 + R( pStrike->sc.mRowsHot )
                    idRow >= R( pStrike->sc.mIdRowHot )                                   &&
                    idCol <= R( pStrike->sc.mIdColHot ) - 1.0 + R( pStrike->sc.mColsHot ) &&
                    idCol >= R( pStrike->sc.mIdColHot )                                   &&
                    pStrike->sc.pPaper->bShowF( tinP )                                       &&
                (
                boolT bIn =
                sCountT idRow = pStrike->sc.pPaper->rowBackF().ro.pcToolState_22[ ifcIDtYPEtOOL_MOUSEpOSITION - ifcIDtYPEtOOL_x2Begin - 1 ] ;
                sCountT idCol = pStrike->sc.pPaper->rowBackF().ro.pcToolState_12[ ifcIDtYPEtOOL_MOUSEpOSITION - ifcIDtYPEtOOL_x2Begin - 1 ] ;
            {
            if( F(features.fc.flagsFlyoverHighlight) & flFEATUREsADAMfLYOVERhIGHLIGHT_EXISTS && !( F(pStrike->sc.flags) & flSTRIKEs_DRAG ) )
        {
        case ifcIDtYPEsTROKEcALLbACK_WAKE :
        }
            break ;

            }
                //LOGrAW( tSay ) ; //U::
                //TN( tSay , "" ) ; tSay = T("doF destroy/-/idAdam,b OwnTab,b TabWasHere: ")+TF1(features.fc.idAdam)+T(" ")+TF1(F(flags)&flSADAMc_OWNtAB)+T(" ")+TF1(F(flags)&flSADAMc_TABwAShERE)+T("\r\n") ;

                }
                    }
                        bDeleteStrike = 1 ;
                        //LOGrAW( "DESTROY: zapping my sadamState structure\r\n" ) ;

                        if( features.fc.pSadamAnimateCBF ) (*features.fc.pSadamAnimateCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotesP , *this ) ;
            
                        }
                            if( features.fc.pSadamAnimateCBF ) (*features.fc.pSadamAnimateCBF)( tinP , etherP , ifcIDtYPEsTROKEcALLbACK_SLEEP , idEventP , pcNotesP , *this ) ;
                            bStrikeKilled = 1 ;
                            pStrike->sc.flags &= ~( F(flSTRIKEs_AWAKE) ) ;
                        {
                        if( F(pStrike->sc.flags) & flSTRIKEs_AWAKE )
                        //CODEsYNC: PSEUDOdUPLICATE CODE 0b50007 0b50007
    
                        if( F(flags) & flSADAMc_OWNtAB && F(features.fc.flagsAdam) & flFEATUREsADAMaDAM_TABhEREsUPPRESSEShOTkEYS ) backOldC::setModeFlagsIF( tinP , flPAPERbACKmODE_null , flPAPERbACKmODE_SUPPRESShOTkEYS ) ;
            
                        if( F(features.fc.flagsCallBack) & flFEATUREsADAMcALLbACK_EXISTS && features.fc.pSadamBeforeDestroyCBF ) (*features.fc.pSadamBeforeDestroyCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotesP , *this ) ;
                    {
                    if( pStrike )
    
                    //LOGrAW3( "destroyed [idAdam]: " , features.fc.idAdam , "\r\n" ) ;

                    flags |= flSADAMc_DESTROYED ;
                {
                if( !( F(flags) & flSADAMc_DESTROYED ) ) //I WILL NORMALLY BE CALLED OO TIMES BECAUSE THE APP WILL HAVE OO REFERENCES TO ME; BAD STYLE APP MIGHT HAVE AN ARBITRARY NUMBER OF REFERENCES TO ME
                //LOGrAW( tSay ) ; //U::
                //TN( tSay , "" ) ; tSay = T("doF destroy/+/idAdam,b OwnTab,b TabWasHere: \"")+T(pStrike?features.fc.postOldComment:"")+T("\" ")+TF1(F(flags)&flSADAMc_OWNtAB)+T(" ")+TF1(F(flags)&flSADAMc_TABwAShERE)+T("\r\n") ;
            {
            //if( &w P.papers.selectF( tinP , ifcIDcMDpAPERsELECT_QUERYrENDER ) == pStrike->sc.pPaper )
        {
        case ifcIDtYPEsTROKEcALLbACK_DESTROY :
        }
            break ;
            }
                (*features.fc.pSadamIntercomCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotesP , *this ) ;
                _IO_
            {
            if( features.fc.idIntercom && features.fc.pSadamIntercomCBF )
        {
        case ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE8 :
        case ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE7 :
        case ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE6 :
        case ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE5 :
        case ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE4 :
        case ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE3 :
        case ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE2 :
        case ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 :
    {
    switch( idTypeCallP )
    ZE( boolT , bHandled ) ;

    //}
    //    LOGrAW( tSay ) ; //U::
    //    TN( tSay , "" ) ; tSay = T("doF (idAdam,postOldComment,idTypeCall,idAdam,b OwnTab,b TabWasHere: ")+TF1(features.fc.idAdam)+T(processGlobal3I.mapSadamCall(idTypeCallP))+T(" \"")+T(pStrike?features.fc.postOldComment:"")+T("\" ")+TF1(pStrike?F(flags)&flSADAMc_OWNtAB:0)+T(" ")+TF1(F(flags)&flSADAMc_TABwAShERE)+T("\r\n") ;
    //{
    //)
    //    idTypeCallP != ifcIDtYPEsTROKEcALLbACK_MOUSE
    //    idTypeCallP != ifcIDtYPEsTROKEcALLbACK_KEYBOARD  &&
    //    idTypeCallP != ifcIDtYPEsTROKEcALLbACK_ANIMATE  &&
    //(
    //if

    }
        (*features.fc.pSadamPrologCBF)( tinP , etherP , idTypeCallP , idEventP , pcNotesP , *this ) ;
        _IO_
    {
    if( pStrike && F(features.fc.flagsCallBack) & flFEATUREsADAMcALLbACK_EXISTS && features.fc.pSadamPrologCBF )

    if( idTypeCallP == ifcIDtYPEsTROKEcALLbACK_STRIKE && pStrike ) pStrike->sc.pPaper->eraseGlyphF( tinP , *this , idEventP , phCloneP ) ;

    ZE( boolT , bDeleteStrike ) ;
    ZE( boolT , bStrikeKilled ) ;

    //if( idTypeCallP != ifcIDtYPEsTROKEcALLbACK_ANIMATE ) { TN( tSay , "" ) ; tSay = T("idAdam ")+TF1(features.fc.idAdam)+T(" \"")+T(processGlobal3I.mapSadamCall(idTypeCallP))+T("\"\r\n") ; LOGrAW( tSay ) ; }

    //}
    //    if( idTypeCallP != ifcIDtYPEsTROKEcALLbACK_ANIMATE ) { LOGrAWtID( T("vtTest: idAdam ")+TF1(features.fc.idAdam)+T(" \"")+T(processGlobal3I.mapSadamCall(idTypeCallP))+T("\"") ) ; }
    //{
    //if( !thirdC::c_strcmpIF( tinP , features.fc.postOldComment , "vtTest" ) && !etherC::ether_cUtility_IF( tinP ) )

    //if( bGoItStrike ) tinP.pAdamGlobal5->frPaper.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    //const boolT bGoItStrike = idTypeCallP == ifcIDtYPEsTROKEcALLbACK_STRIKE || idTypeCallP == ifcIDtYPEsTROKEcALLbACK_DESTROY ;
    //tinP.pAdamGlobal5->frPaper.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;

    paperOldC::grabIF( tinP , TAG( TAGiDnULL ) ) ; //U::TO FIND A BUG

    //}
    //    LOGrAW( ostoSay ) ;
    //    OStEXTAK( ostoSay , " +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n" ) ;
    //    OStEXTC(  ostoSay , idIn , 0 ) ;
    //    OStEXTAK( ostoSay , "/+ [idIn]: " ) ;
    //    OStEXTA(  ostoSay , postIdType ) ;
    //    OStEXTAK( ostoSay , " | doF/" ) ;
    //    OStEXTA(  ostoSay , tinP.postThreadName ) ;
    //    OStEXT(   ostoSay , TUCK << 2 ) ;
    //{
    //if( idTypeCallP != ifcIDtYPEsTROKEcALLbACK_ANIMATE && idTypeCallP != ifcIDtYPEsTROKEcALLbACK_MOUSE && idTypeCallP != ifcIDtYPEsTROKEcALLbACK_VOLATILEtEXTcHANGING && idTypeCallP != ifcIDtYPEsTROKEcALLbACK_VOLATILEtEXTcHANGED && idTypeCallP != ifcIDtYPEsTROKEcALLbACK_TABaRRIVING && idTypeCallP != ifcIDtYPEsTROKEcALLbACK_TABlEAVING )
    //countT idIn = 1 + incv02AM( idInLath ) ;
    //static countT idInLath ;
    //U::

    const osTextT* postIdType = processGlobal3S::_processGlobal3I_IF().mapSadamCall( idTypeCallP ) ;


    _IO_

    }
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/boolT sadamC::doF( tinS& tinP , etherC& etherP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const handleC* const phCloneP )/*1*/

//IF "doF" IS SPECIFIED AS A SADAM FEATURE, IT WILL NOT BE FOUND IN THE ADAM DLL BECAUSE THE NAME CONFLICTS WITH THE ENTRY POINT EXPORTED BY THE BASE DLL (THIS MODULE)
//THE UNDERSCORE PREVENTS COLLISION WITH A CALLBACK FUNCTION SPECIFIED AS A SADAM FEATURE
//THIS COMMENT MIGHT BE OBSOLETE NOW THAT s adamStateOldS::do CBF -> sadamC::doF

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

