
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            pPoint[ offo ].y = paperP.pPoint[ offo ].y * mrRow ;
            pPoint[ offo ].x = paperP.pPoint[ offo ].x * mrCol ;
        {
        for( countT offo = 0 ; offo < cPoint ; offo ++ )

        measureT mrRow = (measureT)deviceP.cRowF() / (measureT)cRowP ;
        measureT mrCol = (measureT)deviceP.cColF() / (measureT)cColP ;
    {
    else
    if( cColP == deviceP.cColF() && cRowP == deviceP.cRowF() ) thirdC::c_memcpyIF( tinP , (byteT*)pPoint , (byteT*)paperP.pPoint , sizeof( POINT ) * cPoint ) ;
    //A:ASSUME: sizeof( POINT ) == sizeof( cPoint2S ) AND FORMAT IS IDENTICAL

    thirdC::c_memcpyIF( tinP , (byteT*)pcSize , (byteT*)paperP.pcSize , sizeof( countT ) * cGlyph ) ;

    PUSE.newF( tinP , LF , *(byteT**)&pPoint , sizeof( POINT ) * paperP.cPoint ) ; ___( pPoint ) ;
    PUSE.newF( tinP , LF , *(byteT**)&pcSize , sizeof( countT ) * paperP.cGlyph ) ; ___( pcSize ) ;
{
rgbOverride( 0 )
offop( 0 ) ,
offos( 0 ) ,
pPoint( 0 ) ,
cPoint( paperP.cPoint ) ,
pcSize( 0 ) ,
cGlyph( paperP.cGlyph ) ,
/*1*/pelS::pelS( tinS& tinP , const paperS& paperP , const countT cColP , const countT cRowP , const deviceC& deviceP ) :/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

