
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

//==============================================================================================================================================================
//==== BELOW THIS LINE: DAYTIME WORK ===========================================================================================================================
//==============================================================================================================================================================

REST

for( off = 0 ; off < sizeof ppsttQOD / sizeof ppsttQOD[ 0 ] ; off ++ ) etThread.delF( tinP , ppsttQOD[ off ] ) ;
for( off = 0 ; off < sizeof ppsttDOS / sizeof ppsttDOS[ 0 ] ; off ++ ) etThread.delF( tinP , ppsttDOS[ off ] ) ;
for( off = 0 ; off < sizeof ppsttSOQ / sizeof ppsttSOQ[ 0 ] ; off ++ ) etThread.delF( tinP , ppsttSOQ[ off ] ) ;

DEL( eventS::pBatClass ) ;

}
    DEL( pe ) ;
    stEvent >> *(countT*)&pe ;
    ZE( eventS* , pe ) ;
{
while( stEvent )

b_idhLever.ungrabF( tinP ) ;
swSession.ungrabF( tinP ) ;
}
    }
        }
            DEL( ps )
            sessionS* ps = (sessionS*)(countT)swSession ;
            idhLever = *pn ;
        {
        if( pn )
        nicNameC* pn = (nicNameC*)swSession.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swSession.cFlavorsF( tinP ) ;
{
swSession.grabF( tinP , TAG( TAGiDnULL ) ) ;
b_idhLever.grabF( tinP , TAG( TAGiDnULL ) ) ; //U:: SHOULD NOT BE NEEDED AS cSessions SHOULD BE 0

b_idrLever.ungrabF( tinP ) ;
}
    DEL( pNapBlab ) ;
    napkinC*& pNapBlab = *(napkinC**)&(countT&)swPNapBlab ;
    idrLever = swPNapBlab.leverF( tinP , idf ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
countT cFlavors = swPNapBlab.cFlavorsF( tinP ) ;
b_idrLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

}
    while( cBlabThreads ) { ++ s ; etThread.osSleepF( tinP , TOCK ) ; }
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{
TELL( "cleaning up" ) ;

etThread.ifcDrivenServerF( tinP , i1 , i2 ) ;
serverInfo2S i2( ifcIDpORT_HTTP , flSOCKETc_null , TF2(thirdC::third_idAdamRootI_IF( tinP ),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , 0 , (countT)&c8p , 0 , - 1 , 1 , sizeof( stateS ) , translateStateF ) ;
serverInfo1S i1( &pbdVarying , b_pbdVarying , bHandedOff , sgnIdPortReplaced , tmcF , countTC() , ether ) ;
TELL( "serving the HTTP port" ) ;

//U::HIRE( T("port.05.http") , 0x401043b , 0x1000000 , 0/*x40104c5*/ , 0x1000000 )
TELL( "hiring my gorilla 5c40104" ) ;

etThread.ifcChatF( tinP , (countT)&c8p , DDNUMB , jobFillCourseF ) ;
TELL( "preparing to accept chat clients" ) ;

//ether.osSleepF( tinP , TOCK * 0x40 ) ;
//TELL( "napping for 04 tocks to give chat server time to catch up" ) ;

}
    etThread.delF( tinP , pstt1m ) ;
    }
        else stEvent << (countT)pe ;
        }
            DEL( pe ) ;
            *tinP.zEtScratch = 0 ;
        {
        if( !pe || *tinP.zEtScratch )
        eventS* pe = new( 0 , tinP , LF ) eventS( tinP , etThread , etUsesPoolPrime , lake , sIn , idEvent ) ;

        tinP.zEtScratch->delF( tinP , psttw ) ;
        countT idEvent = tinP.zEtScratch->strDigitsToSCountF( tinP , psttw , 0 , 1 ) ;
        tinP.zEtScratch->strWordF( tinP , psttw , psttc1 , sttq , sDot , - 1 ) ; ___( psttw ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , psttw ) ;

        strokeS* psttOwner = (strokeS*)sIn.pbFieldF( tinP , idType , flags , cbd , 3 ) ; //CODE SYNCH: a340104 a340104
        ZE( countT , cbd ) ;
        ZE( flagsT , flags ) ;
        ZE( countT , idType ) ;
        
        tinP.zEtScratch->boxGetShadowF( tinP , sIn , psttc1 , 1 ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    {
    FORsTRINGSiN1( pstt1m )
    strokeS sDot( '.' ) ;
    *tinP.zEtScratch = 0 ;

    etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/events/*") ) ; ___( pstt1m ) ;
    ZE( strokeS* , pstt1m ) ;
{
eventS::pBatClass = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) ) ;
TELL( "preloading events" ) ;

etThread.osThreadF( tinP , countTC() , tmPourF  , 0 , flTHREADlAUNCH_null , 0 , (countT)&stNnPrivate2A , (countT)&stNnPrivate2B ) ;
etThread.osThreadF( tinP , countTC() , tmPourF  , 0 , flTHREADlAUNCH_null , 0 , (countT)&stNnPrivate1A , (countT)&stNnPrivate1B ) ;
etThread.osThreadF( tinP , countTC() , tmCatchF , 0 , flTHREADlAUNCH_null , 0 , (countT)&stNnPrivate2A , ifcPORToLD2_ENABLEpRIVATEhTTP2 ) ;
etThread.osThreadF( tinP , countTC() , tmCatchF , 0 , flTHREADlAUNCH_null , 0 , (countT)&stNnPrivate1A , ifcPORToLD2_ENABLEpRIVATEhTTP1 ) ;

etThread.ifcCallWhenFiredF( tinP , callWhenFiredF , &cArgWhenFired ) ;
countT cArgWhenFired = (countT)&c8p ;

count8S c8p( (countT)&c8p1 , (countT)&c8p2 , (countT)&c8p3 , (countT)&c8p4 , (countT)&c8p5 , (countT)&c8p6 , (countT)&c8p7 ) ;
c8p6.c5 = (countT)&bFileStats ;
c8p6.c4 = (countT)&bNewBlabRoom ;
c8p6.c3 = (countT)&cBlabThreads ;
c8p6.c2 = (countT)&bQuitBlabbing ;
c8p5.c8 = (countT)&bnnPeer ;
c8p5.c7 = (countT)&etUsesPoolPrime ;
c8p5.c6 = (countT)&stEvent ;
c8p5.c5 = (countT)&bLogin ;
c8p5.c4 = (countT)&ru ;
c8p5.c1 = (countT)&swPNapBlab ;
c8p4.c8 = (countT)&idrLever ;
c8p4.c7 = (countT)&b_idrLever ;
c8p4.c6 = (countT)&stNnPrivate2B ;
c8p4.c5 = (countT)&stNnPrivate2A ;
c8p4.c4 = (countT)&stNnPrivate1B ;
c8p4.c3 = (countT)&stNnPrivate1A ;
c8p3.c8 = (countT)ppsttQOD ;
c8p3.c7 = (countT)ppsttDOS ;
c8p3.c6 = (countT)ppsttSOQ ;
c8p2.c1 = (countT)&swSession ;
c8p1.c8 = (countT)&b_idhLever ;
c8p1.c7 = (countT)&idhLever ;
c8p1.c6 = (countT)&lake ;
c8p1.c3 = (countT)&dict ;
c8p1.c2 = (countT)&b_pbdVarying ;
c8p1.c1 = (countT)&pbdVarying ;
count8S c8p7 ;
count8S c8p6 ;
count8S c8p5 ;
count8S c8p4 ;
count8S c8p3 ;
count8S c8p2 ;
count8S c8p1 ;

batonC bFileStats( tinP , TAG( TAGiDnULL ) ) ;
batonC bNewBlabRoom( tinP , TAG( TAGiDnULL ) ) ;
ZE( countT , cBlabThreads ) ;
ZE( boolT , bQuitBlabbing ) ;
switchC swPNapBlab( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idrLever ) ;
ZE( countT , idrLever ) ;
batonC b_idrLever( tinP , TAG( TAGiDnULL ) ) ;
batonC bnnPeer( tinP , TAG( TAGiDnULL ) , T("ideafarm/domains/com/domain/ideafarm/files/peers") ) ;
etherC etUsesPoolPrime( tinP , TAG( TAGiDnULL ) ) ;
stackC stEvent( tinP , etThread , TAG( TAGiDnULL ) ) ;
batonC bLogin( tinP , TAG( TAGiDnULL ) ) ;
ranUniC ru( MAXcOUNTT ) ;
stackC stNnPrivate2B( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ;
stackC stNnPrivate2A( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ;
stackC stNnPrivate1B( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ;
stackC stNnPrivate1A( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ;
switchC swSession( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idhLever ) ;
batonC b_idhLever( tinP , TAG( TAGiDnULL ) ) ;
nicNameC idhLever ;

dictionary1C dict( tinP , etThread ) ;
TELL( "preparing for work/ct dictionary" ) ;

etThread.strMakeF( tinP , LF , ppsttQOD[ 3 ] , T("fo'qu reaping") ) ; ___( ppsttQOD[ 3 ] ) ;
etThread.strMakeF( tinP , LF , ppsttQOD[ 2 ] , T("re'qu tending") ) ; ___( ppsttQOD[ 2 ] ) ;
etThread.strMakeF( tinP , LF , ppsttQOD[ 1 ] , T("oo'qu sowing" ) ) ; ___( ppsttQOD[ 1 ] ) ;
etThread.strMakeF( tinP , LF , ppsttQOD[ 0 ] , T("wo'qu fallow" ) ) ; ___( ppsttQOD[ 0 ] ) ;
for( off = 0 ; off < sizeof ppsttQOD / sizeof ppsttQOD[ 0 ] ; off ++ ) ppsttQOD[ off ] = 0 ;
strokeS* ppsttQOD[ 4 ] ;

etThread.strMakeF( tinP , LF , ppsttDOS[ 7 ] , T("ta'da") ) ; ___( ppsttDOS[ 7 ] ) ;
etThread.strMakeF( tinP , LF , ppsttDOS[ 6 ] , T("ve'da") ) ; ___( ppsttDOS[ 6 ] ) ;
etThread.strMakeF( tinP , LF , ppsttDOS[ 5 ] , T("se'da") ) ; ___( ppsttDOS[ 5 ] ) ;
etThread.strMakeF( tinP , LF , ppsttDOS[ 4 ] , T("fi'da") ) ; ___( ppsttDOS[ 4 ] ) ;
etThread.strMakeF( tinP , LF , ppsttDOS[ 3 ] , T("fo'da") ) ; ___( ppsttDOS[ 3 ] ) ;
etThread.strMakeF( tinP , LF , ppsttDOS[ 2 ] , T("re'da") ) ; ___( ppsttDOS[ 2 ] ) ;
etThread.strMakeF( tinP , LF , ppsttDOS[ 1 ] , T("oo'da") ) ; ___( ppsttDOS[ 1 ] ) ;
etThread.strMakeF( tinP , LF , ppsttDOS[ 0 ] , T("wo'da") ) ; ___( ppsttDOS[ 0 ] ) ;
for( off = 0 ; off < sizeof ppsttDOS / sizeof ppsttDOS[ 0 ] ; off ++ ) ppsttDOS[ off ] = 0 ;
strokeS* ppsttDOS[ 8 ] ;

etThread.strMakeF( tinP , LF , ppsttSOQ[ 7 ] , T("ta'str") ) ; ___( ppsttSOQ[ 7 ] ) ;
etThread.strMakeF( tinP , LF , ppsttSOQ[ 6 ] , T("ve'str") ) ; ___( ppsttSOQ[ 6 ] ) ;
etThread.strMakeF( tinP , LF , ppsttSOQ[ 5 ] , T("se'str") ) ; ___( ppsttSOQ[ 5 ] ) ;
etThread.strMakeF( tinP , LF , ppsttSOQ[ 4 ] , T("fi'str") ) ; ___( ppsttSOQ[ 4 ] ) ;
etThread.strMakeF( tinP , LF , ppsttSOQ[ 3 ] , T("fo'str") ) ; ___( ppsttSOQ[ 3 ] ) ;
etThread.strMakeF( tinP , LF , ppsttSOQ[ 2 ] , T("re'str") ) ; ___( ppsttSOQ[ 2 ] ) ;
etThread.strMakeF( tinP , LF , ppsttSOQ[ 1 ] , T("oo'str") ) ; ___( ppsttSOQ[ 1 ] ) ;
etThread.strMakeF( tinP , LF , ppsttSOQ[ 0 ] , T("wo'str") ) ; ___( ppsttSOQ[ 0 ] ) ;
for( countT off = 0 ; off < sizeof ppsttSOQ / sizeof ppsttSOQ[ 0 ] ; off ++ ) ppsttSOQ[ off ] = 0 ;
strokeS* ppsttSOQ[ 8 ] ;
//PSEUDODUPLICATED CODE: 1030117 a340104

lakeC lake( tinP , etThread ) ;
TELL( "preparing for work/ct lake" ) ;

ZE( boolT , bHandedOff ) ;
batonC b_pbdVarying( tinP , TAG( TAGiDnULL ) ) ;
ZE( byteT* , pbdVarying ) ;
signC sgnIdPortReplaced( tinP , TAG( TAGiDnULL ) ) ;

//etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;

TELL( "preparing for work" ) ;
TODO

}
    return 0 ;
    if( tinP.fingerprint ) ;
    bQuitBlabbing = 1 ;
    PARAMS( cArgP )
{
countT callWhenFiredF( tinS& tinP , countT& cArgP )

DONE( tmPourF )
}
    }
        }
            ++ s ; ether.osSleepF( tinP , TICK ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        stNnPrivateB.ungrabF( tinP ) ;
        stNnPrivateA.ungrabF( tinP ) ;

        }
            while( !etThread && !stNnPrivateA.third && ~hUp ) ;
            }
                __Z( ids ) ;
                stNnPrivateB.sinkF( tinP , ids , nn , flSTACKsINK_UNIQUE ) ;
                ZE( countT , ids ) ;
                stNnPrivateA.extractF( 0 , tinP ) ;
                nicNameC& nn = *(nicNameC*)&stNnPrivateA.upF( tinP , hUp ) ;
            {
            do
            handleC hUp( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( stNnPrivateA )

        stNnPrivateA.grabF( tinP , TAG( TAGiDnULL ) ) ;
        stNnPrivateB.purgeF( tinP ) ;
        stNnPrivateB.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    while( !ether && !etThread )

    stackC& stNnPrivateB = *(stackC*)pTaskP->c2 ;
    stackC& stNnPrivateA = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmPourF )

DONE( tmCatchF )
}
    }
        etThread.delF( tinP , pbr ) ;

        }
            stNnPrivateA.ungrabF( tinP ) ;
            while( cnn -- ) stNnPrivateA.sinkF( tinP , countTC() , pnn[ cnn ] , flSTACKsINK_UNIQUE ) ;
            stNnPrivateA.grabF( tinP , TAG( TAGiDnULL ) ) ;
            countT    cnn = cbr / sizeof( nicNameC ) ;
            nicNameC* pnn = (nicNameC*)pbr ;

            stNnPrivateA.sinkF( tinP , countTC() , nnPeer , flSTACKsINK_UNIQUE ) ; //NEEDED AT A LIBRARY: CONJ: PROXYING (nnPeer NOT IN LIST pnn)
            //etThread.strokeF( tinP , T("sinking nn values for nnPeer ")+T(nnPeer)+T("\r\n") ) ;
        {
        if( pbr && cbr && !( cbr % sizeof( nicNameC ) ) )
    
        sockd.readF( tinP , pbr , cbr , idp , nnPeer ) ; ___( pbr ) ;
        nicNameC nnPeer ;
        ZE( countT , idp ) ;
        ZE( countT , cbr ) ;
        ZE( byteT* , pbr ) ;
    {
    while( !ether && !etThread )
    sockd.bindF( tinP , idPort ) ;
    socketC sockd( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    countT  idPort       =           pTaskP->c2 ;
    stackC& stNnPrivateA = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmCatchF )

DONEdRIVENsERVER( tmcF )
DEL( pso ) ; //U::
}

    *tinP.zEtScratch = 0 ; //U:DEBUGlEAK
    etThread = 0 ; //U:DEBUGlEAK
    //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/a") , flSAY_APPEND | flSAY_LOG ) ;
    TELL( "cleaning up" ) ;
    //}
    //    ++ s ; etThread.osSleepF( tinP , TOCK * 8 ) ; // THIS IS USED INSTEAD OF shutdown TO GIVE PACKETS TIME TO REACH THE PEER; IT IS DONE THIS WAY TO AVOID HAVING THE "SHUTDOWN" CONCEPT IN THE IFC API
    //    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    //{
    //TELL( "sleeping so client can close connection wo'th" ) ;
    //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/b") , flSAY_APPEND | flSAY_LOG ) ;

    }
        //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/c") , flSAY_APPEND | flSAY_LOG ) ;
        etThread.delF( tinP , psttGoodBye ) ;
        etThread.delF( tinP , psttLogInNow ) ;
        }
            etThread.delF( tinP , psttLog ) ;
            //etThread.ifcSayF( tinP , psttLog , flSAY_APPEND | flSAY_LOG ) ;
            etThread.strConcatenateF( tinP , psttLog , stPhrases ) ; ___( psttLog ) ;
            stPhrases << psttOldC( tinP , etThread , T(" (http client ")+TF1(++idClient) ) ;
            ZE( strokeS* , psttLog ) ;
        {
        if( nicNamePeer != nicNameC( NICnAMElOCAL ) ) //NOT GORILLA f94

        etThread.delF( tinP , psttPeer ) ;
        etThread.delF( tinP , pcIdName ) ;
        //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/d") , flSAY_APPEND | flSAY_LOG ) ;

        }
            stPhrases << psttOldC( tinP , etThread , T("notPaid") ) ;
            stPhrases << psttOldC( tinP , etThread , T(" (")+T(nicNamePeer)+T(")\r\n") ) ;
            stPhrases << psttOldC( tinP , etThread , T("peer: \"")+T(psttPeer)+T("\"") ) ;

            REPLY( T("For IdeaFarm " "(tm) City Residents Only!") , T("</PRE>The requested page is served only to residents of IdeaFarm " "(tm) City.  (If you were logged in, your session was terminated automatically if it was inactive for ")+TF1((countT)(TIMEtIMEOUT/TICK))+T(" ticks.)  To log in, or to become a resident, click \"login\" above this paragraph.  The Residency Tax is 12 cents US per day.  Payment of the tax is effective immediately.<PRE>") )

            *tinP.zEtScratch = 0 ;
            //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/e") , flSAY_APPEND | flSAY_LOG ) ;
        {
        else if( bNotPaid )
        }
            stPhrases << psttOldC( tinP , etThread , T("timeout") ) ;
            stPhrases << psttOldC( tinP , etThread , T(" (")+T(nicNamePeer)+T(")\r\n") ) ;
            stPhrases << psttOldC( tinP , etThread , T("peer: \"")+T(psttPeer)+T("\"") ) ;

            REPLY( T("Your Session Timed Out") , T("") )

            *tinP.zEtScratch = 0 ;
            //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/f") , flSAY_APPEND | flSAY_LOG ) ;
        {
        else if( bTimeout ) //THIS DOES NOT EVER HAPPEN
        }
            stPhrases << psttOldC( tinP , etThread , T("notFound") ) ;
            stPhrases << psttOldC( tinP , etThread , T(" (")+T(nicNamePeer)+T(")\r\n") ) ;
            stPhrases << psttOldC( tinP , etThread , T("peer: \"")+T(psttPeer)+T("\"") ) ;

            REPLY( T("Page Not Found") , T("</PRE>The requested page is not currently available, probably because the preceding page that you were viewing just became obsolete.  Please reload the preceding page and then try again.<PRE>") )

            *tinP.zEtScratch = 0 ;
            //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/g") , flSAY_APPEND | flSAY_LOG ) ;
        {
        if( bNotFound )
        //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/h") , flSAY_APPEND | flSAY_LOG ) ;

        }
            }
                if( ~handle ) lake.readCloseF( tinP , handle ) ;

                }
                    }
                        REPLY( T(postTitle) , T(postBody) )
    
                        osTextT* postBody  = (byteT*)&costBody + sizeof( countT ) ;
                        countT&  costBody  = *(countT*)( postTitle + costTitle + 1 ) ;
                        osTextT* postTitle = (byteT*)&costTitle + sizeof( countT ) ;
                        countT&  costTitle = *(countT*)( postDad + costDad + 1 ) ;
                        osTextT* postDad   = pbi + sizeof( countT ) ;
                        countT&  costDad   = *(countT*)pbi ;
    
                        // postBody (null terminated)
                        // costBody
                        // postTitle (null terminated)
                        // costTitle
                        // postDad (null terminated)
                        // costDad
                        //IMAGE LAYOUT OF pbi
                    {
                    else
                    }
                        if( bHttpWoZe ) pbi[ 7 ] = '1' ;
                        pso->writeF( tinP , pbi , cbi ) ;
                        if( bHttpWoZe ) pbi[ 7 ] = '0' ;
                    {
                    if( bRaw )
                {
                else
                else if( !pbi ) bNotFound = 1 ;
                bNotPaid = 1 ;
                )
                    )
                        ( pcIdName[ 1 ] != 1 && pcIdName[ 1 ] != 3 && pcIdName[ 1 ] != 0x41 && pcIdName[ 1 ] != 0x44 && pcIdName[ 1 ] != 0x45 && pcIdName[ 1 ] != 0x46 && pcIdName[ 1 ] != 0x48 )
                        pcIdName[ 0 ] != 1                                                                      ||
                    ( 
                    ( pcIdName[ 0 ] != 2 || ( pcIdName[ 1 ] != 2 && pcIdName[ 1 ] != 3 ) || pcIdName[ 2 ] )     &&
                    !bPaid1                                                                                     &&
                    tInOut.csF( tinP ) == 2                                                                     &&
                    !bNotPaidIsOk                                                                               &&
                (
                if
                boolT bPaid2 = stNnPrivate2A( nicNamePeer ) || stNnPrivate2B( nicNamePeer ) ;
                boolT bPaid1 = stNnPrivate1A( nicNamePeer ) || stNnPrivate1B( nicNamePeer ) ;
                TELL( "writing the requested fish image" ) ;
        
                //}
                //    lake.readF( tinP , pbi , cbi , handle , count3S( 1 , 1 ) , cSkip ) ; //SERVE HOME PAGE IF THE SPECIFIED PAGE IS NOT FOUND
                //    cSkip = 0 ;
                //{
                //if( !pbi )

                const boolT bRaw = pcIdName[ 0 ] == 2 && ( pcIdName[ 1 ] == 2 || pcIdName[ 1 ] == 3 ) ;

                if( *pcIdName ) lake.readF( tinP , pbi , cbi , handle , pcIdName , cSkip ) ;
                //etThread.ifcSayF( tinP , T("retrieving ")+T(pcIdName) , flSAY_APPEND | flSAY_LOG ) ;
                ZE( countT , cSkip ) ;
                handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FISH ) ;

                ZE( countT , cbi ) ;
                ZE( osTextT* , pbi ) ;
                TELL( "retrieving the requested fish from the lake" ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/i") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else
            }
                }
                    etThread.delF( tinP , psttc ) ;
                    etThread.delF( tinP , psttTZ ) ;
    
                    )
                        )+T(psttc)
                        "</FORM><P><PRE>"
                        "<BR><INPUT TYPE=submit VALUE=\"Register!\">"
                        "<BR>note: <TEXTAREA ROWS=16 COLS=64 NAME=note>. c\r\n.  bc\r\n.   bbc\r\n.   bbb\r\n.   bba\r\n.  bb\r\n.  ba\r\n. b\r\n. a\r\n.sample kt (to be written and read from the bottom up.)</TEXTAREA>"
                        "<BR>how2gettherefromwest: <INPUT TYPE=text SIZE=64 NAME=how2gettherefromwest>"
                        "<BR>how2gettherefromsouth: <INPUT TYPE=text SIZE=64 NAME=how2gettherefromsouth>"
                        "<BR>how2gettherefromeast: <INPUT TYPE=text SIZE=64 NAME=how2gettherefromeast>"
                        "<BR>how2gettherefromnorth: <INPUT TYPE=text SIZE=64 NAME=how2gettherefromnorth>"
                        "<BR>crossstreet: <INPUT TYPE=text SIZE=32 NAME=crossstreet>"
                        "<BR>where (country/state/metro/city/street/curbno/aptno): / <INPUT TYPE=text SIZE=16 NAME=country> / <INPUT TYPE=text SIZE=16 NAME=state> / <INPUT TYPE=text SIZE=16 NAME=metro> / <INPUT TYPE=text SIZE=16 NAME=city> / <INPUT TYPE=text SIZE=32 NAME=street> / <INPUT TYPE=text SIZE=8 NAME=curbno> / <INPUT TYPE=text SIZE=8 NAME=aptno>"
                        "<BR>status: <SELECT NAME=status size=4><OPTION VALUE=\"tentative\" SELECTED>tentative<OPTION VALUE=\"ifnorain\">if no rain<OPTION VALUE=\"firm\">firm<OPTION VALUE=\"canceled\">canceled</SELECT>"
                        "<BR>title: <INPUT TYPE=text SIZE=64 NAME=title>"
                        "<BR>type: <INPUT TYPE=text SIZE=64 NAME=type VALUE=\"Evening of Community in IdeaFarm " "(tm) City\">"
                        "<BR>duration (ticks): <INPUT TYPE=text SIZE=16 NAME=duration>"
                        "<BR>ifc time (time.day): <INPUT TYPE=text SIZE=8 NAME=ifctime1 VALUE=\"")+t_ifctime1_Value+T("\"> : <INPUT TYPE=text SIZE=8 NAME=ifctime2 VALUE=\"")+t_ifctime2_Value+T("\">"
                        "<BR>time (hh:mm): <INPUT TYPE=text SIZE=2 MAXLENGTH=2 NAME=hh> : <INPUT TYPE=text SIZE=2 MAXLENGTH=2 NAME=mi> <SELECT NAME=ampm24 size=3><OPTION VALUE=\"AM\">AM<OPTION VALUE=\"PM\">PM<OPTION VALUE=\"24\" SELECTED>24</SELECT>"
                        "date (yyyy/mm/dd): <INPUT TYPE=text SIZE=4 MAXLENGTH=4 NAME=yy> / <INPUT TYPE=text SIZE=2 MAXLENGTH=2 NAME=mm> / <INPUT TYPE=text SIZE=2 MAXLENGTH=2 NAME=dd>"
                        "<P><FORM ACTION=\"calendar.html\" METHOD=GET>"
                        "</PRE><B>Instructions:</B> To solicit reservations before actually scheduling the event, leave the date and time fields blank.  Since we're all new at writing numbers the IFC way (radix 16, right to left, etc.), enter your numeric values conventionally (NOT the IFC way) on this form."
    
                    REPLY( T("Register Your Event!") , T(
                    //PSEUDODUPLICATED CODE: a340104 a340104
    
                    }
                        }
                            etThread.strFuseF( tinP , psttTZ , t1+TF1(idz)+t2+T(tzs.postShort) ) ;
                            const timeZoneSpecS& tzs = timeZoneSpecF( tinP , idz ) ;
                        {
                        for( countT idz = 1 ; idz <= ctz ; idz ++ )
                        countT ctz = cTimeZonesF( tinP ) ;
                        TN( t2 , "\">" ) ;
                        TN( t1 , "<OPTION VALUE=\"" ) ;
    
                        etThread.strMakeF( tinP , LF , psttTZ , T("") , 0x10000 ) ; ___( psttTZ ) ;
                    {
                    ZE( strokeS* , psttTZ ) ;
    
                    getCalendarF( tinP , etThread , psttc , lake ) ; ___( psttc ) ;
                    ZE( strokeS* , psttc ) ;
                {
                else
                if( tInOut.csF( tinP ) == 2 && !bPaid1 && !bPaid2 && !bNotPaidIsOk ) bNotPaid = 1 ;
                boolT bPaid2 = stNnPrivate2A( nicNamePeer ) || stNnPrivate2B( nicNamePeer ) ;
                boolT bPaid1 = stNnPrivate1A( nicNamePeer ) || stNnPrivate1B( nicNamePeer ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/j") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_NEWeVENT )
            }
                etThread.delF( tinP , psttTZ ) ;
                }
                    etThread.delF( tinP , pstte ) ;
                    etThread.delF( tinP , psttc ) ;

                    )
                        )+T(psttc)
                        "\r\n<HR>"
                        "\r\n<A HREF=\"newevent.html\">new</A>\r\n"
                        tTZF+tExplain+T(pstte)+T(
                        
    
                    REPLY( T("Calendar") ,

                    ) ;

                        "<PRE>"
                        "</OL>"
                        "<LI>YES, and you can count on me to be there to assist during the event"
                        "<LI>YES"
                        "<LI>PROBABLY YES"
                        "<LI>UNDECIDED"
                        "<LI>PROBABLY NO"
                        "<LI>NO"
                        "<OL>"
                        "  From LEFT to RIGHT, the meaning of the dot is:"
                        "  If you are logged in, you can place a dot in wo of se places to indicate whether you expect to participate in each event."
                        "</PRE>Please use this page to keep event organizers informed about your plans to attend each event."

                    TN( tExplain , 

                    }
                        tTZF = T("<FORM ACTION=\"calendar.html\" METHOD=GET><SELECT NAME=timezone>")+T(psttTZ)+T("</SELECT><INPUT TYPE=submit VALUE=\"Set My Time Zone\"></FORM>Time Zone: ")+T(timeZoneSpecF(tinP,idTimeZone).postShort)+T("\r\nCurrent Local Time: ")+tNowLocal+T("\r\n\r\nJoin us in myTimeZone blab at 7:30 PM local time on the following se'da days for\r\nan hour of community to begin our day of rest:\r\n\r\n")+tCommunityDays ;

                        }
                            tNowLocal += TF4(dL+1,flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)+tb+TF4(hhL,flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa)+T(":")+TF4(mmL,flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ;
        
                            }
                                case 11 : { tNowLocal += T(" dec ") ; break ; }
                                case 10 : { tNowLocal += T(" nov ") ; break ; }
                                case 9  : { tNowLocal += T(" oct ") ; break ; }
                                case 8  : { tNowLocal += T(" sep ") ; break ; }
                                case 7  : { tNowLocal += T(" aug ") ; break ; }
                                case 6  : { tNowLocal += T(" jul ") ; break ; }
                                case 5  : { tNowLocal += T(" jun ") ; break ; }
                                case 4  : { tNowLocal += T(" may ") ; break ; }
                                case 3  : { tNowLocal += T(" apr ") ; break ; }
                                case 2  : { tNowLocal += T(" mar ") ; break ; }
                                case 1  : { tNowLocal += T(" feb ") ; break ; }
                                case 0  : { tNowLocal += T(" jan ") ; break ; }
                            {
                            switch( mL )
        
                            tNowLocal += TF4(yL+1,flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa) ;
        
                            }
                                case 6 : { tNowLocal += T("sat, ") ; break ; }
                                case 5 : { tNowLocal += T("fri, ") ; break ; }
                                case 4 : { tNowLocal += T("thu, ") ; break ; }
                                case 3 : { tNowLocal += T("wed, ") ; break ; }
                                case 2 : { tNowLocal += T("tue, ") ; break ; }
                                case 1 : { tNowLocal += T("mon, ") ; break ; }
                                case 0 : { tNowLocal += T("sun, ") ; break ; }
                            {
                            switch( dowL )
    
                            ((thirdC&)etThread).osTimeOldUtcToOldLocalF( tinP , msL , ssL , mmL , hhL , dL , mL , yL , dowL , msU , ssU , mmU , hhU , dU , mU , yU , dowU , idTimeZone ) ;
                            ZE( countT , dowL ) ;
                            ZE( sCountT , yL ) ;
                            ZE( countT , mL ) ;
                            ZE( countT , dL ) ;
                            ZE( countT , hhL ) ;
                            ZE( countT , mmL ) ;
                            ZE( countT , ssL ) ;
                            ZE( countT , msL ) ;
    
                            etThread.osTimeToOldTimeF( tinP , msU , ssU , mmU , hhU , dU , mU , yU , dowU , timeN1 , timeN2 , flOStIMEfROMoLDtIME_OLDtIMEiSutc ) ;
                            ZE( countT , dowU ) ;
                            ZE( sCountT , yU ) ;
                            ZE( countT , mU ) ;
                            ZE( countT , dU ) ;
                            ZE( countT , hhU ) ;
                            ZE( countT , mmU ) ;
                            ZE( countT , ssU ) ;
                            ZE( countT , msU ) ;
                        {
                        TN( tNowLocal , "" ) ;

                        }
                            }
                                timeC2 ++ ;
                                }
                                    cListed ++ ;
                                    tCommunityDays += tb4+tDate + tc ;
                                    tDate += TF4(dC+1,flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa) ;
                
                                    }
                                        case 11 : { tDate += T(" dec ") ; break ; }
                                        case 10 : { tDate += T(" nov ") ; break ; }
                                        case 9  : { tDate += T(" oct ") ; break ; }
                                        case 8  : { tDate += T(" sep ") ; break ; }
                                        case 7  : { tDate += T(" aug ") ; break ; }
                                        case 6  : { tDate += T(" jul ") ; break ; }
                                        case 5  : { tDate += T(" jun ") ; break ; }
                                        case 4  : { tDate += T(" may ") ; break ; }
                                        case 3  : { tDate += T(" apr ") ; break ; }
                                        case 2  : { tDate += T(" mar ") ; break ; }
                                        case 1  : { tDate += T(" feb ") ; break ; }
                                        case 0  : { tDate += T(" jan ") ; break ; }
                                    {
                                    switch( mC )
                
                                    tDate += TF4(yC+1,flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa) ;
                
                                    }
                                        case 6 : { tDate += T("sat, ") ; break ; }
                                        case 5 : { tDate += T("fri, ") ; break ; }
                                        case 4 : { tDate += T("thu, ") ; break ; }
                                        case 3 : { tDate += T("wed, ") ; break ; }
                                        case 2 : { tDate += T("tue, ") ; break ; }
                                        case 1 : { tDate += T("mon, ") ; break ; }
                                        case 0 : { tDate += T("sun, ") ; break ; }
                                    {
                                    switch( dowC )
                                    TN( tDate , "" ) ;

                                    etThread.osTimeToOldTimeF( tinP , msC , ssC , mmC , hhC , dC , mC , yC , dowC , timeC1 , timeC2 , flOStIMEfROMoLDtIME_OLDtIMEiSutc ) ;
                                    ZE( countT , dowC ) ;
                                    ZE( sCountT , yC ) ;
                                    ZE( countT , mC ) ;
                                    ZE( countT , dC ) ;
                                    ZE( countT , hhC ) ;
                                    ZE( countT , mmC ) ;
                                    ZE( countT , ssC ) ;
                                    ZE( countT , msC ) ;
                                {
                                if( ( timeC2 & 7 ) == 5 ) // SE'DA (MEETING OCCURS AT 1930 LOCAL TIME ON SE'DA, TO BEGIN THE SABBATH)
                            {
                            while( cListed < 3 )

                            sCountT timeC2 = timeN2 - 9 ; //ENSURES THAT I LIST AT LEAST WO PAST COMMUNITY MEETING DAY
                            ZE( countT , timeC1 ) ;
                            ZE( countT , cListed ) ;
                            TN( tc , "\r\n" ) ;
                            TN( tb4 , "    " ) ;
                        {
                        TN( tCommunityDays , "" ) ;

                        etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                        ZE( sCountT , timeN2 ) ;
                        ZE( countT , timeN1 ) ;
                    {
                    if( pSession )
                    TN( tTZF , "" ) ;

                    }
                        stEvent.ungrabF( tinP ) ;
                        }
                            while( !etThread && !stEvent.third && ~hUp ) ;
                            }
                                }
                                    }
                                        }
                                            etThread.strFuseF( tinP , pstte , T("\r\n") ) ;
                                            for( countT idi = 1 ; idi <= idMax ; idi ++ ) etThread.strFuseF( tinP , pstte , TF1(pcTally[idi-1])+tb ) ;
                                            TN( tb , " " ) ;
                                            countT idMax = sizeof pcTally / sizeof pcTally[ 0 ] ;
    
                                            etThread.delF( tinP , pstt1m ) ;
                                            }
                                                }
                                                    if( idInterest && idInterest <= sizeof pcTally / sizeof pcTally[ 0 ] ) pcTally[ idInterest - 1 ] ++ ;
                                                    countT idInterest = *(countT*)pbi ;
                                                {
                                                else
                                                if( *tinP.zEtScratch || cbi != sizeof idInterest ) *tinP.zEtScratch = 0 ;
                                                
                                                tinP.zEtScratch->boxGetShadowF( tinP , pbi , cbi , psttc1 ) ;
                                                ZE( countT , cbi ) ;
                                                ZE( byteT* , pbi ) ;
                                            {
                                            FORsTRINGSiN1( pstt1m )
                                            etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/participants/participant.$.")+TF1(pe->idMe)+td+T("*") ) ; ___( pstt1m ) ;
                                            ZE( strokeS* , pstt1m ) ;
                                            countT pcTally[ 6 ] = { 0 , 0 , 0 , 0 , 0 , 0 } ;
                                        {
                                        if( !tinP.zEtScratch->strCompareF( tinP , pSession->psttEmail , pe->psttOwner ) || !tinP.zEtScratch->strCompareF( tinP , pSession->psttEmail , tWo ) )
                                        etThread.strFuseF( tinP , pstte , T("<FORM ACTION=\"calendar.html\" METHOD=GET><INPUT TYPE=HIDDEN NAME=idevent VALUE=\"")+TF1(pe->idMe)+T("\"><INPUT TYPE=RADIO NAME=interest VALUE=1")+(idInterest==1?tChecked:tNull)+T("><INPUT TYPE=RADIO NAME=interest VALUE=2")+(idInterest==2?tChecked:tNull)+T("><INPUT TYPE=RADIO NAME=interest VALUE=3")+(idInterest==3?tChecked:tNull)+T("><INPUT TYPE=RADIO NAME=interest VALUE=4")+(idInterest==4?tChecked:tNull)+T("><INPUT TYPE=RADIO NAME=interest VALUE=5")+(idInterest==5?tChecked:tNull)+T("><INPUT TYPE=RADIO NAME=interest VALUE=6")+(idInterest==6?tChecked:tNull)+T("><INPUT TYPE=SUBMIT VALUE=\"Update!\"></FORM>") ) ;
                                    {
                                    else
                                    if( !pSession ) etThread.strFuseF( tinP , pstte , T("\r\n") ) ;

                                    etThread.strFuseF( tinP , pstte , T("\r\n<A HREF=\"7.1.")+TF1(pe->idMe)+T(".1.0.html\">")+TT4(pe->timeE1,pe->timeE2,4,6)+T("</A>")+T(" (")+tOld+T(") ")+T(pe->psttOldCountry)+tbsb+T(pe->psttState)+tbsb+T(pe->psttMetro)+tbsb+T(pe->psttOldCity)+tbsb+T(pe->psttType) ) ;
                                    TN( tChecked , " CHECKED" ) ;
                                    TN( tNull , "" ) ;

                                    }
                                        else                                        idInterest = *(countT*)pbi ;
                                        if( *tinP.zEtScratch || cbi != sizeof idInterest ) *tinP.zEtScratch = 0 ;
                                        tinP.zEtScratch->boxGetShadowF( tinP , pbi , cbi , T("///ideafarm/ephemeral/domains/com/ideafarm/participants/participant.$.")+TF1(pe->idMe)+td+T(pSession->psttEmail) , 1 ) ;
                                        ZE( countT , cbi ) ;
                                        ZE( byteT* , pbi ) ;
                                    {
                                    if( pSession )
                                    ZE( countT , idInterest ) ;
                                    TN( td , ".$." ) ;

                                    }
                                        tOld += TF4(dEL+1,flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)+tb+TF4(hhEL,flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa)+T(":")+TF4(mmEL,flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ;
    
                                        }
                                            case 11 : { tOld += T(" dec ") ; break ; }
                                            case 10 : { tOld += T(" nov ") ; break ; }
                                            case 9  : { tOld += T(" oct ") ; break ; }
                                            case 8  : { tOld += T(" sep ") ; break ; }
                                            case 7  : { tOld += T(" aug ") ; break ; }
                                            case 6  : { tOld += T(" jul ") ; break ; }
                                            case 5  : { tOld += T(" jun ") ; break ; }
                                            case 4  : { tOld += T(" may ") ; break ; }
                                            case 3  : { tOld += T(" apr ") ; break ; }
                                            case 2  : { tOld += T(" mar ") ; break ; }
                                            case 1  : { tOld += T(" feb ") ; break ; }
                                            case 0  : { tOld += T(" jan ") ; break ; }
                                        {
                                        switch( mEL )
    
                                        tOld += TF4(yEL+1,flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa) ;
    
                                        }
                                            case 6 : { tOld += T("sat, ") ; break ; }
                                            case 5 : { tOld += T("fri, ") ; break ; }
                                            case 4 : { tOld += T("thu, ") ; break ; }
                                            case 3 : { tOld += T("wed, ") ; break ; }
                                            case 2 : { tOld += T("tue, ") ; break ; }
                                            case 1 : { tOld += T("mon, ") ; break ; }
                                            case 0 : { tOld += T("sun, ") ; break ; }
                                        {
                                        switch( dowEL )
                                    {
                                    else
                                    if( !pe->timeE2 ) tOld = T("pending sufficient interest") ;
                                    TN( tOld , "" ) ;

                                    if( pe->timeE2 ) ((thirdC&)etThread).osTimeOldUtcToOldLocalF( tinP , msEL , ssEL , mmEL , hhEL , dEL , mEL , yEL , dowEL , msE , ssE , mmE , hhE , dE , mE , yE , dowE , idTimeZone ) ;
                                    ZE( countT , dowEL ) ;
                                    ZE( sCountT , yEL ) ;
                                    ZE( countT , mEL ) ;
                                    ZE( countT , dEL ) ;
                                    ZE( countT , hhEL ) ;
                                    ZE( countT , mmEL ) ;
                                    ZE( countT , ssEL ) ;
                                    ZE( countT , msEL ) ;

                                    if( pe->timeE2 ) etThread.osTimeToOldTimeF( tinP , msE , ssE , mmE , hhE , dE , mE , yE , dowE , pe->timeE1 , pe->timeE2 , flOStIMEfROMoLDtIME_OLDtIMEiSutc ) ;
                                    ZE( countT , dowE ) ;
                                    ZE( sCountT , yE ) ;
                                    ZE( countT , mE ) ;
                                    ZE( countT , dE ) ;
                                    ZE( countT , hhE ) ;
                                    ZE( countT , mmE ) ;
                                    ZE( countT , ssE ) ;
                                    ZE( countT , msE ) ;
                                {
                                if( pe )
                                eventS* pe = (eventS*)stEvent.upF( tinP , hUp ) ;
                                TN( tbsb , " / " ) ;
                                TN( tb , " " ) ;
                            {
                            do
                            handleC hUp( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            TN( tWo , ifcEMAIL_OLDfROM ) ;
                        {
                        if( stEvent )
                        stEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        etThread.strMakeF( tinP , LF , pstte , T("") , 0x10000 ) ; ___( pstte ) ;
                    {
                    ZE( strokeS* , pstte ) ;
                    const countT idTimeZone = pSession ? pSession->idTimeZone : 1 ;
                    TN( tc , "\r\n" ) ;
                    TN( tb4 , "    " ) ;
                    TN( tb  , " " ) ;
    
                    getCalendarF( tinP , etThread , psttc , lake ) ; ___( psttc ) ;
                    ZE( strokeS* , psttc ) ;
                {
                else
                }
                    }
                        REPLYrEDIRECT( T("calendar.html") , T("**** Calendar ****") , T("</PRE>Your HTTP client is being redirected to remove your new data from the url.<PRE>") )

                        eventS::pBatClass->ungrabF( tinP ) ;

                        else stEvent << (countT)pe ;
                        }
                            DEL( pe ) ;
                            *tinP.zEtScratch = 0 ;
                        {
                        if( !pe || *tinP.zEtScratch )
                        eventS* pe = new( 0 , tinP , LF ) eventS( tinP , etThread , etUsesPoolPrime , lake , sOut , idEvent ) ;

                        tinP.zEtScratch->delF( tinP , psttw ) ;
                        countT idEvent = tinP.zEtScratch->strDigitsToSCountF( tinP , psttw , 0 , 1 ) ;
                        tinP.zEtScratch->delF( tinP , psttnu ) ;
                        tinP.zEtScratch->strWordF( tinP , psttw , psttnu , sttq , S1C('.') , - 1 ) ; ___( psttw ) ;
                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                        ZE( strokeS* , psttw ) ;
                        tinP.zEtScratch->boxPutGenerationF( tinP , psttnu , T("///ideafarm/ephemeral/domains/com/ideafarm/events/event") , 0x10000 , WS( sOut ) ) ; ___( psttnu ) ;
                        ZE( strokeS* , psttnu ) ;
                        TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/events/" ) ; tFile += TF3(timeE2,flFORMAT_FOREIGN|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+td+TF3(timeE1,flFORMAT_FOREIGN|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+td+TF3(timeN2,flFORMAT_FOREIGN|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+td+TF3(timeN1,flFORMAT_FOREIGN|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+td+T(tinP.osTid) ;
                        TN( td , "." ) ;
                        
                        tinP.zEtScratch->osTimeNowF( tinP , timeN1 , timeN2 ) ;
                        ZE( sCountT , timeN2 ) ;
                        ZE( countT , timeN1 ) ;

                        eventS::pBatClass->grabF( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    else
                    }
                        etThread.delF( tinP , psttc ) ;

                        )
                            )+T(psttc)
                            "</FORM><P><PRE>"
                            "<BR><INPUT TYPE=submit VALUE=\"Register!\">"
                            "<BR>note: <INPUT TYPE=textarea ROWS=64 COLS=128 NAME=note VALUE=\"")+t_note_Value+T("\">"
                            "<BR>how2gettherefromwest: <INPUT TYPE=text SIZE=64 NAME=how2gettherefromwest VALUE=\"")+t_how2west_Value+T("\">"
                            "<BR>how2gettherefromsouth: <INPUT TYPE=text SIZE=64 NAME=how2gettherefromsouth VALUE=\"")+t_how2south_Value+T("\">"
                            "<BR>how2gettherefromeast: <INPUT TYPE=text SIZE=64 NAME=how2gettherefromeast VALUE=\"")+t_how2east_Value+T("\">"
                            "<BR>how2gettherefromnorth: <INPUT TYPE=text SIZE=64 NAME=how2gettherefromnorth VALUE=\"")+t_how2north_Value+T("\">"
                            "<BR>crossstreet: <INPUT TYPE=text SIZE=32 NAME=crossstreet VALUE=\"")+t_cross_Value+T("\">"
                            "<BR>where (country/state/metro/city/street/curbno/aptno): / <INPUT TYPE=text SIZE=16 NAME=country VALUE=\"")+t_country_Value+T("\"> / <INPUT TYPE=text SIZE=16 NAME=state VALUE=\"")+t_state_Value+T("\"> / <INPUT TYPE=text SIZE=16 NAME=metro VALUE=\"")+t_metro_Value+T("\"> / <INPUT TYPE=text SIZE=16 NAME=city VALUE=\"")+t_city_Value+T("\"> / <INPUT TYPE=text SIZE=32 NAME=street VALUE=\"")+t_street_Value+T("\"> / <INPUT TYPE=text SIZE=8 NAME=curbno VALUE=\"")+t_curbno_Value+T("\"> / <INPUT TYPE=text SIZE=8 NAME=aptno VALUE=\"")+t_aptno_Value+T("\">"
                            "<BR>status: <SELECT NAME=status SIZE=5><OPTION VALUE=\"?\">?<OPTION VALUE=\"tentative\">tentative<OPTION VALUE=\"ifnorain\">if no rain<OPTION VALUE=\"firm\">firm<OPTION VALUE=\"canceled\">canceled</SELECT>"
                            "<BR>title: <INPUT TYPE=text SIZE=64 NAME=title VALUE=\"")+t_title_Value+T("\">"
                            "<BR>type: <INPUT TYPE=text SIZE=64 NAME=type VALUE=\"")+t_type_Value+T("\">"
                            "<BR>duration (ticks): <INPUT TYPE=text SIZE=16 NAME=duration VALUE=\"")+t_duration_Value+T("\">"
                            "<BR>ifc time (time.day): <INPUT TYPE=text SIZE=8 NAME=ifctime1 VALUE=\"")+t_ifctime1_Value+T("\"> : <INPUT TYPE=text SIZE=8 NAME=ifctime2 VALUE=\"")+t_ifctime2_Value+T("\">"
                            "<BR>time (hh:mm): <INPUT TYPE=text SIZE=4 NAME=hh VALUE=\"")+t_hh_Value+T("\"> : <INPUT TYPE=text SIZE=4 NAME=mi VALUE=\"")+t_mi_Value+T("\"> <SELECT NAME=ampm24 SIZE=4><OPTION VALUE=\"?\">?<OPTION VALUE=\"AM\">AM<OPTION VALUE=\"PM\">PM<OPTION VALUE=\"24\">24</SELECT>"
                            "date (yy/mm/dd): <INPUT TYPE=text SIZE=4 NAME=yy VALUE=\"")+t_yy_Value+T("\"> / <INPUT TYPE=text SIZE=4 NAME=mm VALUE=\"")+t_mm_Value+T("\"> / <INPUT TYPE=text SIZE=4 NAME=dd VALUE=\"")+t_dd_Value+T("\">"
                            "<P><FORM ACTION=\"calendar.html\" METHOD=GET>"
                            "<B>Instructions:</B> To solicit reservations before actually scheduling the event, leave the date and time fields blank.  Since we're all new at writing numbers the IFC way (radix 16, right to left, etc.), enter your numeric values conventionally (NOT the IFC way) on this form.<HR>This form contains wo or more errors.  Please check all fields, make corrections, and resubmit.<HR>"
                            "<FORM ACTION=\"calendar.html\" METHOD=GET><SELECT NAME=timezone SIZE=5>")+T(psttTZ)+T("</SELECT><INPUT TYPE=submit VALUE=\"Set My Time Zone\"></FORM>"
                            "</PRE>"
        
                        REPLY( T("Register Your Event!") , T(
                        //PSEUDODUPLICATED CODE: a340104 a340104

                        getCalendarF( tinP , etThread , psttc , lake ) ; ___( psttc ) ;
                        ZE( strokeS* , psttc ) ;

                        *tinP.zEtScratch = 0 ;
                    {
                    if( *tinP.zEtScratch )

                    sOut << (strokeS*)t_note_Value ;
                    sOut << (strokeS*)t_how2west_Value ;
                    sOut << (strokeS*)t_how2south_Value ;
                    sOut << (strokeS*)t_how2east_Value ;
                    sOut << (strokeS*)t_how2north_Value ;
                    sOut << (strokeS*)t_cross_Value ;
                    sOut << (strokeS*)t_aptno_Value ;
                    sOut << (strokeS*)t_curbno_Value ;
                    sOut << (strokeS*)t_street_Value ;
                    sOut << (strokeS*)t_city_Value ;
                    sOut << (strokeS*)t_metro_Value ;
                    sOut << (strokeS*)t_state_Value ;
                    sOut << (strokeS*)t_country_Value ;
                    sOut << (strokeS*)t_status_Value ;
                    sOut << (strokeS*)t_title_Value ;
                    sOut << (strokeS*)t_type_Value ;
                    sOut << (strokeS*)t_duration_Value ;
                    sOut << ( pSession ? pSession->psttEmail : (strokeS*)0 ) ; //CODE SYNCH: a340104 a340104
                    sOut << (countT)timeE2 ;
                    sOut << timeE1 ;
                    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;

                    }
                        }
                            if( !timeE1 ) timeE2 ++ ;
                            timeE1 = ( timeE1 & tickMask ) + timeUp ;
                        {
                        else
                        if( timeFuzz < 0x800000 ) timeE1 &= tickMask ;
                        countT timeFuzz = timeE1 & fuzzMask ;
                        countT timeUp   = 0x01000000 ;
                        countT tickMask = 0xff000000 ;
                        countT fuzzMask = 0x00ffffff ; //ASSUME: sizeof( countT ) == 4
                    {
                    //U::MOVE THIS INTO ETHER OR THIRD
                    //ROUND TO THE NEAREST TICK

                    }
                        tinP.zEtScratch->osTimeFromOldTimeF( tinP , timeE1 , timeE2 , yU , mU , dU , hhU , mmU , ssU , msU ) ;
    
                        ) ;
                        
                            pSession ? pSession->idTimeZone : 1
                            0 ,
                            yIn ,
                            mIn ,
                            dIn ,
                            hhIn ,
                            mmIn ,
                            0 ,
                            0 ,
                            dowU ,
                            yU ,
                            mU ,
                            dU ,
                            hhU ,
                            mmU ,
                            ssU ,
                            msU ,
                        
                        ((thirdC&)etScratch).osTimeOldUtcFromOldLocalF( tinP ,
                        ZE( countT  , dowU ) ;
                        ZE( sCountT , yU ) ;
                        ZE( countT  , mU ) ;
                        ZE( countT  , dU ) ;
                        ZE( countT  , hhU ) ;
                        ZE( countT  , mmU ) ;
                        ZE( countT  , ssU ) ;
                        ZE( countT  , msU ) ;
    
                        //etThread.strokeF( tinP , T("in: ")+TF4(yIn,flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T(" / ")+TF4(mIn,flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T(" / ")+TF4(dIn,flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T(" ; ")+TF4(hhIn,flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T(":")+TF4(mmIn,flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n") ) ;
    
                        sCountT yIn = tinP.zEtScratch->strDigitsToSCountF( tinP , t_yy_Value , 0xa , 1 ) ;
                        countT  mIn = tinP.zEtScratch->strDigitsToSCountF( tinP , t_mm_Value , 0xa , 1 ) - 1 ;
                        countT  dIn = tinP.zEtScratch->strDigitsToSCountF( tinP , t_dd_Value , 0xa , 1 ) - 1 ;
                        countT  hhIn = tinP.zEtScratch->strDigitsToSCountF( tinP , t_hh_Value , 0xa , 1 ) ;
                        countT  mmIn = tinP.zEtScratch->strDigitsToSCountF( tinP , t_mi_Value , 0xa , 1 ) ;
                    {
                    else if( t_mi_Value.csF( tinP ) && t_hh_Value.csF( tinP ) && t_dd_Value.csF( tinP ) && t_mm_Value.csF( tinP ) && t_yy_Value.csF( tinP ) )
                    }
                        timeE2 = tinP.zEtScratch->strDigitsToSCountF( tinP , t_ifctime2_Value ) ;
                        timeE1 = tinP.zEtScratch->strDigitsToSCountF( tinP , t_ifctime1_Value ) ;
                    {
                    if( t_ifctime1_Value.csF( tinP ) && t_ifctime2_Value.csF( tinP ) )
                    ZE( sCountT , timeE2 ) ;
                    ZE( countT , timeE1 ) ;

                    if( t_tz_Value.csF( tinP ) && pSession ) pSession->idTimeZone = tinP.zEtScratch->strDigitsToSCountF( tinP , t_tz_Value ) ;
                {
                else if( tblKeyValue.cRowsF( tinP ) > 2 ) // IF I HAVE RECEIVED AN EVENT FORM
                }
                    REPLYrEDIRECT( T("calendar.html") , T("**** Calendar ****") , T("</PRE>Your HTTP client is being redirected to remove your new data from the url.<PRE>") )

                    if( pSession ) tinP.zEtScratch->boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/participants/participant.$.")+TF1(idEvent)+td+T(pSession->psttEmail) , (byteT*)&idInterest , sizeof idInterest ) ;
                    TN( td , ".$." ) ;
                    countT idInterest = tinP.zEtScratch->strDigitsToSCountF( tinP , t_interest_Value ) ;
                    countT idEvent    = tinP.zEtScratch->strDigitsToSCountF( tinP , t_idevent_Value  ) ;
                {
                else if( tblKeyValue.cRowsF( tinP ) == 2 ) // IF I HAVE RECEIVED AN EVENT INTEREST FORM
                }
                    REPLYrEDIRECT( T("calendar.html") , T("**** Calendar ****") , T("</PRE>Your HTTP client is being redirected to remove your new data from the url.<PRE>") )
                    }
                        etThread.boxPutF( tinP , tFile , tData , tData.csF( tinP ) ) ;
                        TN( tData , "" ) ; tData = TF1(pSession->idTimeZone) ;
                        TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/timeZone/" ) ; tFile += T(pSession->psttEmail) ;

                        pSession->idTimeZone = tinP.zEtScratch->strDigitsToSCountF( tinP , t_tz_Value ) ;
                    {
                    if( t_tz_Value.csF( tinP ) && pSession )
                {
                if( tblKeyValue.cRowsF( tinP ) == 1 ) // IF I HAVE RECEIVED A TIMEZONE FORM

                }
                    }
                        etThread.strFuseF( tinP , psttTZ , t1+TF1(idz)+(pSession&&pSession->idTimeZone==idz?t2s:t2)+T(tzs.postShort) ) ;
                        const timeZoneSpecS& tzs = timeZoneSpecF( tinP , idz ) ;
                    {
                    for( countT idz = 1 ; idz <= ctz ; idz ++ )
                    countT ctz = cTimeZonesF( tinP ) ;
                    TN( t2s , "\" SELECTED>" ) ;
                    TN( t2  , "\">" ) ;
                    TN( t1 , "<OPTION VALUE=\"" ) ;

                    etThread.strMakeF( tinP , LF , psttTZ , T("") , 0x10000 ) ; ___( psttTZ ) ;
                {
                ZE( strokeS* , psttTZ ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/k") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_CALENDAR )
            }
                ) )
                    "<PRE>"
                    "<P><B>If you are desperate or in crisis:</B> If your marital, monetary, or other personal circumstances are desperate, seek help, either from professional counselors or from family or friends.  Take full advantange of social services offered by governmental agencies for which you are eligible.  <B>Wo'O Ideafarm is NOT qualified and NOT licensed as a marital, psychiatric, or financial counselor.</B>  Some of the marketing resources of IdeaFarm (tm) City are used to find people who are in desperate circumstances and who might benefit from residency in IdeaFarm " "(tm) City.  But remember that Wo'O Ideafarm is not taking into consideration your personal circumstances; that is why you <B>MUST</B> not view him as your counselor or as advising you on what you should do.  It is <B>your</B> responsibility, and that of your counselor, to determine whether and how you should apply his ideas in your life."
                    "<P><B>Minors must be supervised:</B> If you are less than 18 years old, tell your parents that you are visiting, or are a resident of, IdeaFarm " "(tm) City.  This is for your protection, and it is also the right thing to do."
                    "<P><B>You are visiting a foreign country:</B> IdeaFarm " "(tm) City is a sovereign \"place\" on the Internet.  While in IdeaFarm " "(tm) City, you are neither protected by, nor subject to, the laws of the territorial government from which you obtain access to the Internet, except insofar as those laws apply on foreign soixlOld.  Be careful, alert, and respectful, just as you would when visiting any other foreign country."
                    "</PRE><H2>Warnings!</H2>"

                REPLY( T("Warnings") , T(
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/l") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_WARNINGS )
            }
                else                                                            REPLY( T("Blab Room ")+TF1(idRoomBlab)+T(" Does Not Exist")      , T("</PRE>Blab room ")+TF1(idRoomBlab)+T(" does not exist.  Each blab room is identified by a number.  To enter a blab room you must know its number, unless a link to it has been provided.  (The \"open blab\" and \"residentsOnly blab\" links in the header of every page at this site are examples; those links take you to blab rooms 1 and 2, respectively.)<PRE>") )
                if( etThread.diskFileExistsF( tinP , TbLABaRC( idRoomBlab ) ) ) REPLYrEDIRECT( T("blab.")+TF1(idRoomBlab)+T(".html") , T("**** Blab Room ")+TF1(idRoomBlab)+T(" ****") , T("</PRE>Your HTTP client is being redirected to remove your blab text from the url.<PRE>") )
            {
            else if( idRequestType == ifcIDrEQtYPE_BLABrEDIRECT          )
            else if( idRequestType == ifcIDrEQtYPE_HELP6                 ) REPLY( T("Who Can I Meet at www.ideafarm.com?")      , T("</PRE>You can meet others who are interested in lifelong marriage in deep love and in living intelligently, morally, richly, and simply.<PRE>") )
            else if( idRequestType == ifcIDrEQtYPE_HELP5                 ) REPLY( T("What Can I Buy at www.ideafarm.com?")      , T("</PRE>You can purchase residency for 12 cents US per day (8 $US for 64 days).<PRE>") )
            else if( idRequestType == ifcIDrEQtYPE_HELP4                 ) REPLY( T("What Can I Download at www.ideafarm.com?") , T("</PRE>You can download the complete IdeaFarm " "(tm) Piggyback Operating System, which runs on top of Windows 2000/XP and installs as a Service that you can easily start, stop, and remove.<PRE>") )
            else if( idRequestType == ifcIDrEQtYPE_HELP3                 ) REPLY( T("What Can I Learn at www.ideafarm.com?")    , T("</PRE>You can learn about Deep Love.  You can learn how to craft C++ software.  You can learn why Microsoft's monopoly is over.<PRE>") )
            else if( idRequestType == ifcIDrEQtYPE_HELP2                 ) REPLY( T("What Can I Read at www.ideafarm.com?")     , T("</PRE>You can read the entire system source code for the IdeaFarm (tm) Piggyback Operating System.  You can read the Constitutional Declaration of IdeaFarm " "(tm) City.  You can read the writings of its founder.<PRE>") )
            else if( idRequestType == ifcIDrEQtYPE_HELP1                 ) REPLY( T("What Can I Do at www.ideafarm.com?")       , T("</PRE>You can visit a worldwide online community, meet its residents, citizens, and other visitors, and discuss the ideas of its founder.<PRE>") )
            else if( idRequestType == ifcIDrEQtYPE_AFTERpAY              ) REPLY( T("How to Log In for the Wo'th Time")         , T("</PRE>Thank you for paying your Residency Tax.  A passcode has been emailed to you.  You can use that passcode immediately to enter IdeaFarm " "(tm) City.<PRE>") )
            else if( idRequestType == ifcIDrEQtYPE_BEFOREbLABBING        ) REPLY( T("Read This Before Blabbing!") , T("</PRE>Every visitor is invited to blab with us!<P><OL><LI>If you are intimidated, remember that LOVE CONQUERS FEAR.<LI>Speak your truth, as clearly as you can.  But also be interested in what others say.<LI>Wo'O Ideafarm reads blab but does not participate.  He provides the blab page for his students, i.e. for you and all visitors to this web site.<LI>This blab page is for students of IdeaFarm " "(tm) City to get to know each other and to discuss the ideas presented here.  Please maintain a good ratio of intelligent discussion to small talk!<LI>Show respect and demonstrate deep love!</OL><PRE>") )
            else if( idRequestType == ifcIDrEQtYPE_FINGERlIFT            ) REPLY( T("Lift a Finger and Change your World!") , T("</PRE>I, a citizen, resident, or friend of IdeaFarm (tm) City, do now declare and resolve that today...<OL><LI>... I will think and act boldly as if I KNOW FOR CERTAIN that God will provide for my needs.<LI>... I will view every encounter with another person as an opportunity to GIVE, with no thought of what he or she will do for ME.<LI>...I will forget about myself while working and become immersed in the act of using my mind, my heart, and my muscles to do the job right, with skill, efficiency, and love of craft.<LI>... I will keep my beliefs to myself at all times other than those moments when I am more tolerant of, and interested in, the beliefs of others than in my own beliefs.<LI>... I will lift my finger once today to help someone else change the world for the better.</OL><P>Do you know of another person who shares the IdeaFarm (tm) City core value of Deep Love?  Invite that person to join you in open blab to discuss the establishment of IdeaFarm " "(tm) City.  To succeed, we just need lots of people to be aware of our project and to each lift a finger!<PRE>") )
            else if( idRequestType == ifcIDrEQtYPE_COPYRIGHTS            ) REPLY( T("Copyrights Notice") , T("</PRE>(c) Wo'O Ideafarm.  All rights reserved.  All data entered, including conversational text, become the property of Wo'O Ideafarm.<P>\"Cloning\" creative work is theft.  If the idea, design, format, etc., that you use took much time, effort, experimentation, and/or expense to develop, don't you think that you owe something to the originator?<P>IdeaFarm (tm) City is the product of a man who worked very hard for 30 years to educate himself, to capture an inspiration, and then to develop that inspiration into what you see today.  Along the way, his project cost him his beloved wife.  It cost him his Ph.D. degree.  He had to give up sex, which he enjoyed very much.  He lost his family life when his oo children, young teenagers, most needed him to be around.  He lost his extended family life, as his entire family shunned him.  He lost his professional associates and colleagues, who all decided that his professional ship was sinking and that they'd better jump ship.  Alone, with significant health problems, he persevered, narrowly avoiding the loss of his work, and narrowly avoiding death several times.  At wo time, his only copy of his completed dissertation research, from which IdeaFarm " "(tm) City springs, was on a computer disk drive that had failed.  He sent it off to a company whom he paid $750 and who, fortunately, was able to recover his data.<P>Don't you think that you should respect his copyrights?  Please respect them, and if somewo emerges in the market who has ripped Wo'O off, boycott the ripoff product!<PRE>") )
            }
                }
                    etThread = 0 ;
                    stPhrases << psttOldC( tinP , etThread , T(" blab") ) ;

                    REPLY( tTitle , tBody )
                    }
                        etThread.delF( tinP , psttBlab ) ;
                        tBody += T(psttBlab) ;
                        etThread.delF( tinP , pbCircle ) ;
                        blabF( tinP , etThread , psttBlab , pbCircle + offBegin , cbCircle - offBegin ) ; ___( psttBlab ) ;
                        ZE( strokeS* , psttBlab ) ;

                        b_idrLever.ungrabF( tinP ) ;
                        etThread.etherSnapCyrcleOldF( tinP , pbCircle , cbCircle , offBegin , pNapBlab , TbLAB( idRoomBlab ) , CBbLAB ) ;
                        napkinC*& pNapBlab = *(napkinC**)&(countT&)swPNapBlab ;
                        idrLever = idRoomBlab ;
                        b_idrLever.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        ZE( countT , offBegin ) ;
                        ZE( countT , cbCircle ) ;
                        ZE( byteT* , pbCircle ) ;
                    {
                    TELL( "snapping the blab circle" )
                    tBody = T(ppsttDOS[oDay])+T(" ")+T(ppsttSOQ[oStrong])+T(" ")+T(ppsttQOD[oQtr])+T("\r\n")+TT4(timeN1,timeN2,3,6)+T("\r\n<A HREF=\"beforeblabbing.html\">readBeforeBlabbing!</A>\r\n")+(pSession?T("<A HREF=\"newblabroom.html\">newRoom</A>\r\ngo to room: <FORM METHOD=GET><INPUT TYPE=text SIZE=8 NAME=idroomblab></FORM>\r\n"):T(""))+T("\r\n<FORM METHOD=GET>")+(idRoomBlab<0x1000?T("<INPUT TYPE=text SIZE=16 NAME=fullName VALUE=\"")+tFullNameValue+T("\">: "):T(""))+T("<INPUT TYPE=text SIZE=")+T(idRoomBlab==1?"64":"128")+T(" NAME=blab VALUE=\"\">")+(idRoomBlab<0x1000?T("<INPUT TYPE=submit VALUE=\"blab!\">"):T(""))+T("</FORM><P><pre>") ;
                    TN( tBody , "" ) ;

                    }
                        }
                            case 0x1100 : { tTitle += T(" (Global Real Time Chat for Residents)") ; break ; }
                            case 1 : { tTitle += T(" (Global Real Time Chat for All)") ; break ; }
                        {
                        switch( idRoomBlab )
                        tTitle = T("IdeaFarm " "(tm) City Blab Room ")+TF1(idRoomBlab) ;
                    {
                    else
                    if( pSession && idRoomBlab - pSession->idTimeZone == 0x2100 ) tTitle = T(timeZoneSpecF(tinP,pSession->idTimeZone).postShort)+T(" Time Zone Resident Blab") ;
                    TN( tTitle , "" ) ;
                    TELL( "writing blab 2 reply" ) ;
    
                    countT oQtr    = offQTR(    timeN2 ) ;
                    countT oStrong = offSTRONG( timeN2 ) ;
                    countT oDay    =            timeN2 % 8 ;
                    //PSEUDODUPLICATED CODE: 1030117 a340104
    
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;

                    // 00000002  ON DEMAND ROOMS
                    // 00000001  RESERVED FOR FUTURE USE
                    // 0031      RESERVED FOR FUTURE USE
                    // 0021      TIME ZONE RESIDENT CHAT
                    // 0011      GLOBAL RESIDENT CHAT
                    // 0001      RESERVED FOR FUTURE USE
                    // 1         OPEN (FOREIGNERS CAN ACCESS)
                    // 0         ILLEGAL
                    // OFFSET
                    //ALLOCATION OF THE NAME SPACE
                {
                else
                if( tInOut.csF( tinP ) == 2 && !bPaid1 && !bPaid2 && !bNotPaidIsOk && idRoomBlab >= 0x1000 ) bNotPaid = 1 ;
                boolT bPaid2 = stNnPrivate2A( nicNamePeer ) || stNnPrivate2B( nicNamePeer ) ;
                boolT bPaid1 = stNnPrivate1A( nicNamePeer ) || stNnPrivate1B( nicNamePeer ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/n") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_BLAB )
            }
                }
                    etThread = 0 ;
                    stPhrases << psttOldC( tinP , etThread , T(" sticky") ) ;

                    REPLY( T("Your New Sticky Note Setting") , T("</PRE>")+tCurrent+T("<P><B>Explanation:</B>The best way to learn about sticky notes is to play with this feature.  Select \"sticky\" several times while viewing this page.  Do you see that there is a single line text entry box that appears in wo of re places?  If you put text into that box, your text will be remembered and will still be there the next time that you log in.  Possible uses:<P><UL><LI>Store your favorite URL's or the URL that you want to continue to read next time that you log in.<LI>Paste in the local time of an event for which you want to print the detail page.<LI>Add a \"TO:\" or \"ATTN:\" line to pages that you are printing for somewo else.<LI>Any other use.  The server does not use this field; it just remembers it for you.</UL><PRE>") )
                    TELL( "writing sticky reply" ) ;

                    }
                        }
                            case 4 : { tCurrent = T("Your sticky note will now appear at the foot of each page.") ; break ; }
                            case 3 : { tCurrent = T("Your sticky note will now appear immediately below the page header.") ; break ; }
                            case 2 : { tCurrent = T("Your sticky note will now appear above the page header.") ; break ; }
                            case 1 : { tCurrent = T("Your sticky note will now be invisible, but it will still be retained and will be there when you make it visible again.") ; break ; }
                        {
                        switch( pSession->idModeStickyNote )
                    {
                    if( pSession )
                    TN( tCurrent , "" ) ;

                    }
                        *tinP.zEtScratch = 0 ;
                        tinP.zEtScratch->boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/stickynotemode/")+T(pSession->psttEmail) , (byteT*)&pSession->idModeStickyNote , 1 , 1 ) ;
                        if( ++ pSession->idModeStickyNote > 4 ) pSession->idModeStickyNote = 1 ;
                    {
                    if( pSession && !tblKeyValue.cRowsF( tinP ) )
                {
                else
                if( tInOut.csF( tinP ) == 2 && !bPaid1 && !bPaid2 && !bNotPaidIsOk ) bNotPaid = 1 ;
                boolT bPaid2 = stNnPrivate2A( nicNamePeer ) || stNnPrivate2B( nicNamePeer ) ;
                boolT bPaid1 = stNnPrivate1A( nicNamePeer ) || stNnPrivate1B( nicNamePeer ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/o") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_STICKY )
            }
                }
                    bFileStats.ungrabF( tinP ) ;
                    etThread.boxPutF( tinP , tTally , (byteT*)&tally , sizeof tally ) ;
                    tally ++ ;
                    etThread.delF( tinP , posti ) ;
                    else if( posti && costi == sizeof( tally ) ) tally = *(countT*)posti ;
                    if( *tinP.zEtScratch ) *tinP.zEtScratch = 0 ;
                    ZE( countT , tally ) ;
                    tinP.zEtScratch->boxGetShadowF( tinP , posti , costi , tTally , 1 ) ; ___( posti ) ;
                    bFileStats.grabF( tinP , TAG( TAGiDnULL ) ) ;

                    costi = 0 ;
                    etThread.delF( tinP , posti ) ;
                    REPLY( T(psttFile) , T(posti) )
                    etThread.boxGetShadowF( tinP , posti , costi , tFile , 1 ) ; ___( posti ) ;
                    ZE( countT   , costi ) ;
                    ZE( osTextT* , posti ) ;
                {
                else
                if( !etThread.diskFileExistsF( tinP , tFile ) ) bNotFound = 1 ;
                TN( tTally , "" ) ; tTally = T("///ideafarm/ephemeral/domains/com/ideafarm/tally/")+T(psttFile) ;
                TN( tFile  , "" ) ; tFile  = T("///ideafarm/ephemeral/domains/com/ideafarm/file/")+T(psttFile) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_FILE )
            }
                }
                    etThread = 0 ;
                    stPhrases << psttOldC( tinP , etThread , T(" disclosure") ) ;

                    REPLY( T("Financial Disclosure") , T("</PRE>This disclosure of the financial state of Wo'O Ideafarm is required by the Constitution of IdeaFarm (tm) City.  Wo'O Ideafarm has a net worth of approximately negative 6 thousand $US.  This excludes two items of his intellectual property, IdeaFarm (tm) Operating System, and IdeaFarm (tm) City.  The Constitution of IdeaFarm (tm) City bars him from transfering these properties except to his successor as Governing Proprietor of IdeaFarm " "(tm) City.  For these reasons, these two properties cannot be sold and thus have no market value.<PRE>") )
                    TELL( "writing disclosure reply" ) ;
                {
                else
                if( tInOut.csF( tinP ) == 2 && !bPaid1 && !bPaid2 && !bNotPaidIsOk ) bNotPaid = 1 ;
                boolT bPaid2 = stNnPrivate2A( nicNamePeer ) || stNnPrivate2B( nicNamePeer ) ;
                boolT bPaid1 = stNnPrivate1A( nicNamePeer ) || stNnPrivate1B( nicNamePeer ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/p") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_DISCLOSURE )
            }
                }
                    etThread = 0 ;
                    stPhrases << psttOldC( tinP , etThread , T(" roster") ) ;

                    etThread.delF( tinP , psttBody ) ;
                    REPLY( T("IdeaFarm " "(tm) City Roster") , tHead+T(psttBody) )

                    etThread.delF( tinP , pstt1m ) ;
                    }
                        tinP.zEtScratch->strFuseF( tinP , psttBody , TT4(timeN1,timeN2,3,6)+tBar+TF1(idType)+tb+TF1(days)+tb+TT(timeN1,timeN2)+tb+TT(timeEO1,timeEO2)+tb+TF1(bExpired)+tb+TT(timeEN1,timeEN2)+tc ) ;

                        sJournal >> *(countT*)&timeEN2 ;
                        ZE( sCountT , timeEN2 ) ;

                        sJournal >> timeEN1 ;
                        ZE( countT , timeEN1 ) ;

                        sJournal >> bExpired ;
                        ZE( countT , bExpired ) ;

                        sJournal >> *(countT*)&timeEO2 ;
                        ZE( sCountT , timeEO2 ) ;

                        sJournal >> timeEO1 ;
                        ZE( countT , timeEO1 ) ;

                        sJournal >> *(countT*)&timeN2 ;
                        ZE( sCountT , timeN2 ) ;

                        sJournal >> timeN1 ;
                        ZE( countT , timeN1 ) ;

                        sJournal >> days ;
                        ZE( countT , days ) ;

                        sJournal >> idType ;
                        ZE( countT , idType ) ; //1 is c.1.1; 2 is d.1.1

                        sJournal >> idFormat ;
                        ZE( countT , idFormat ) ;

                        tinP.zEtScratch->boxGetShadowF( tinP , sJournal , psttc1 ) ;
                        soulC sJournal( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    FORsTRINGSiN1( pstt1m )
                    TN( tb , " " ) ;
                    TN( tc , "\r\n" ) ;
                    TN( tBar , "| " ) ;
                    etThread.strMakeF( tinP , LF , psttBody , T("") , cEvents * 0x80 ) ; ___( psttBody ) ;
                    ZE( strokeS* , psttBody ) ;
                    countT cEvents = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/account.event/")+T(pSession->psttEmail)+T("/*") , 0 , 0x1000 ) ; ___( pstt1m ) ;
                    ZE( strokeS* , pstt1m ) ;

                    TN( tHead , "" ) ; tHead = T(ppsttDOS[oDay])+T(" ")+T(ppsttSOQ[oStrong])+T(" ")+T(ppsttQOD[oQtr])+T("\r\n")+TT4(timeN1,timeN2,3,6)+T("\r\n\r\n") ;
                    TELL( "writing reply" ) ;
    
                    countT oQtr    = offQTR(    timeN2 ) ;
                    countT oStrong = offSTRONG( timeN2 ) ;
                    countT oDay    =            timeN2 % 8 ;
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                else
                if( !pSession || ( tInOut.csF( tinP ) == 2 && !bPaid1 && !bPaid2 && !bNotPaidIsOk ) ) bNotPaid = 1 ;
                boolT bPaid2 = stNnPrivate2A( nicNamePeer ) || stNnPrivate2B( nicNamePeer ) ;
                boolT bPaid1 = stNnPrivate1A( nicNamePeer ) || stNnPrivate1B( nicNamePeer ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/q") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_ME )
            }
                }
                    etThread = 0 ;
                    stPhrases << psttOldC( tinP , etThread , T(" roster") ) ;

                    REPLY( T("IdeaFarm " "(tm) City Roster") , tBody )

                    etThread.delF( tinP , pstt1m ) ;
                    }
                        tinP.zEtScratch->delF( tinP , pstti ) ;
                        else if( posti && costi ) tBody += T(pstti)+T("\r\n") ;
                        if( *tinP.zEtScratch ) *tinP.zEtScratch = 0 ;
                        tinP.zEtScratch->strToHtmlF( tinP , pstti , T(posti) ) ; ___( pstti ) ;
                        ZE( strokeS* , pstti ) ;
                        tinP.zEtScratch->boxGetShadowF( tinP , posti , costi , psttc1 ) ; ___( posti ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;

                        if( tinP.zEtScratch->strIdF( tinP , tEmailWo , psttc1 ) ) continue ;
                    {
                    FORsTRINGSiN1( pstt1m )
                    TN( tEmailWo , "/" ifcEMAIL_OLDfROM "" ) ;
                    etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/humanname/*") , 0 , 0x1000 ) ; ___( pstt1m ) ;
                    ZE( strokeS* , pstt1m ) ;

                    tBody += T("citizens:\r\n\"Wo'O Ideafarm\" <" ifcEMAIL_OLDfROM ">\r\n \r\nother residents:\r\n") ;
                    TN( tBody , "" ) ; tBody = T(ppsttDOS[oDay])+T(" ")+T(ppsttSOQ[oStrong])+T(" ")+T(ppsttQOD[oQtr])+T("\r\n")+TT4(timeN1,timeN2,3,6)+T("\r\n\r\n\r\n</PRE><P>Do not spam us!  Do not disclose this list to nonresidents, and do not use it improperly!  Announcements that are of general interest should NOT be sent via email.  Instead, send announcements to Wo'O Ideafarm, who will assist you in getting the word out in the least obnoxious way possible!<P><PRE>") ;
                    TELL( "writing roster reply" ) ;
    
                    countT oQtr    = offQTR(    timeN2 ) ;
                    countT oStrong = offSTRONG( timeN2 ) ;
                    countT oDay    =            timeN2 % 8 ;
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                else
                if( tInOut.csF( tinP ) == 2 && !bPaid1 && !bPaid2 && !bNotPaidIsOk ) bNotPaid = 1 ;
                boolT bPaid2 = stNnPrivate2A( nicNamePeer ) || stNnPrivate2B( nicNamePeer ) ;
                boolT bPaid1 = stNnPrivate1A( nicNamePeer ) || stNnPrivate1B( nicNamePeer ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/r") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_ROSTER )
            }
                }
                    etThread = 0 ;
                    stPhrases << psttOldC( tinP , etThread , T(" statistics") ) ;

                    REPLY( T("IdeaFarm " "(tm) City Statistics") , tBody )
                    tBody += T("http clients: ")+TF1(idClient)+T("\r\n") ;
                    TN( tBody , "" ) ; tBody = T(ppsttDOS[oDay])+T(" ")+T(ppsttSOQ[oStrong])+T(" ")+T(ppsttQOD[oQtr])+T("\r\n")+TT4(timeN1,timeN2,3,6)+T("\r\n\r\n\r\n<P><pre>") ;
                    TELL( "writing statistics reply" ) ;
    
                    countT oQtr    = offQTR(    timeN2 ) ;
                    countT oStrong = offSTRONG( timeN2 ) ;
                    countT oDay    =            timeN2 % 8 ;
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                else
                if( tInOut.csF( tinP ) == 2 && !bPaid1 && !bPaid2 && !bNotPaidIsOk ) bNotPaid = 1 ;
                boolT bPaid2 = stNnPrivate2A( nicNamePeer ) || stNnPrivate2B( nicNamePeer ) ;
                boolT bPaid1 = stNnPrivate1A( nicNamePeer ) || stNnPrivate1B( nicNamePeer ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/s") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_STATISTICS )
            }
                etThread = 0 ;
                etThread.delF( tinP , postxTinyPage ) ;
                stPhrases << psttOldC( tinP , etThread , T(" tinyPage") ) ;
                if( bHttpWoZe ) postxTinyPage[ 7 ] = '1' ;
                //etThread.strokeF( tinP , T(USCORE79 "\r\n")+T(postxTinyPage)+T("\r\n" USCORE79 "\r\n") ) ;
                pso->writeF( tinP , postxTinyPage , costxTinyPage ) ;
                if( bHttpWoZe ) postxTinyPage[ 7 ] = '0' ;
                TELL( "writing tinyPage reply" ) ;

                }
                    costxTinyPage = etThread.strMakeF( tinP , LF , postxTinyPage , t0+tnf ) ; ___( postxTinyPage ) ;
                    textC t0 = T("HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: ")+TF4(tnf.csF(tinP),flFORMAT_FILLzE|flFORMAT_NObASE|flFORMAT_FOREIGN,8,0xa)+T("\r\n\r\n") ;

                    // <form action=\"http://www.ideafarm.com/phorm\" method=\"post\"><input type=\"text\" id=\"cmd\" name=\"cmd\" size=\"4\"></form>
                    // <a href=\"http://www.google.com/\">google</a>
                    //THESE SNIPPETS HAVE BEEN TESTED; THEY WORK ON THE AUDIOVOX 9000: 

                    tnf += TT4(timeN1,timeN2,3,6)+T("<br/>")+T(ppsttDOS[oDay])+T(" ")+T(ppsttSOQ[oStrong])+T(" ")+T(ppsttQOD[oQtr])+T("; ")+T(bDeleted?"deadman reset":"deadman not reset")+T("</body></html>") ;

                    ) ;
                
                        "<body>\r\n"
                        "</head>\r\n"
                        "<title>IdeaFarm City</title>\r\n"
                        "<head>\r\n"
                        "<html xmlns=\"http://www.w3.org/1999/xhtml\">\r\n"
                        "<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.0//EN\" \"http://www.wapforum.org/DTD/xhtml-mobile10.dtd\">\r\n"
                        "<?xml version=\"1.0\"?>\r\n"
                
                    TN( tnf ,
                {
                ZE( countT   , costxTinyPage ) ;
                ZE( osTextT* , postxTinyPage ) ;

                }
                    bDeleted = !*tinP.zEtScratch ;
                    tinP.zEtScratch->diskFileOrDirDeleteF( tinP , tDead , flFILEoRdIRdELETE_null , 1 ) ;
                    *tinP.zEtScratch = 0 ;
                {
                if( etThread.diskFileExistsF( tinP , tDead ) )
                TN( tDead , "///d/ideafarm.deadman.delete.me.to.avoid.reboot" ) ;
                ZE( boolT , bDeleted ) ;

                countT oQtr    = offQTR(    timeN2 ) ;
                countT oStrong = offSTRONG( timeN2 ) ;
                countT oDay    =            timeN2 % 8 ;
                //PSEUDODUPLICATED CODE: 1030117 a340104

                etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT , timeN1 ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/t") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_TINYpAGE )
            }
                etThread.osFireF( tinP ) ;
                etThread = 0 ;
                stPhrases << psttOldC( tinP , etThread , T(" rebootNotification") ) ;
                REPLY( T("Reboot Notice") , T("</PRE>This server is now being rebooted.<PRE>") )
                TELL( "writing reboot confirmation reply" ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/u") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_OSfIRE )
            }
                stPhrases << psttOldC( tinP , etThread , T(" logOutNotification") ) ;
                REPLY( T("Logout Successful") , T("</PRE>You have been logged out.  Thank you for participating in the community life of IdeaFarm (tm) City.  If you would like to make a personal commitment to the core values of IdeaFarm " "(tm) City, consider becoming a citizen!<PRE>") )

                b_idhLever.ungrabF( tinP ) ;

                else                                                          tInOut = T("in") ;
                if( swSession.idSlotOfLeverF( tinP , (countT)&nicNamePeer ) ) tInOut = T("out") ;

                DEL( *(sessionS**)&pSession )
                swSession.freeF( tinP ) ;
                idhLever = nicNamePeer ;
                b_idhLever.grabF( tinP , TAG( TAGiDnULL ) ) ;
                TELL( "writing logout confirmation reply" ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/v") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_LOGOUT )
            }
                }
                    stPhrases << psttOldC( tinP , etThread , T(" login") ) ;

                    )
                        "<PRE>")
                        "  Prepay Codes expire eventually, so should be used as soon as is convenient."
                        "<P><B>prepay code</B>: If you have been given a Prepay Code, you (or anywo) can use it wo time to purchase something that you would otherwise be asked to pay for."
                        "  Do not ever enter it on a page whose URL does not begin with \"ideafarm.com\" or \"www.ideafarm.com\"."
                        "  Keep it secret and enter it when prompted."
                        "<P><B>passcode</B>: When an IdeaFarm " "(tm) City account is set up for you, a numeric passcode will be generated randomly and permanently assigned to you."
                        "  If you have multiple email addresses, use your most permanent wo."
                        "<P><B>email</B>: All IdeaFarm " "(tm) City accounting uses your email address to identify you."
                        "  IdeaFarm " "(tm) City is an ANTI-SPAM site."
                        "  If you ever feel that you have been spammed, raise the issue in open blab or in residentsOnly blab."
                        "  In particular, you will not receive marketing or promotional emails."
                        "  </B>IdeaFarm " "(tm) Operations will only use your personal information to respond to your requests for service and to conduct city business."
                        "  <B>The verified name and email address of each resident is listed in the roster, which can be viewed by every resident when logged in."
                        "<P><B>PRIVACY POLICY:</B>: No information about you is used, sold, or otherwise disclosed, with the following important exception."
                        )+T(
                            :T("")
                            ?T("<HR>The passcode that you entered does not match the passcode that is on file for your email address.  Please try again.<HR>")
                        (bPasscodeRejected
                        "</FORM>")+
                        "<BR><INPUT TYPE=submit VALUE=\"log me in!\">"
                        "<BR>prepay code: <INPUT TYPE=text SIZE=16 NAME=prepaycode>"
                        "<BR>passcode: <INPUT TYPE=password SIZE=16 NAME=passcode>"
                        "email: <INPUT TYPE=text SIZE=32 NAME=email VALUE=\"")+tEmailValue+T("\">"
                        "<P><FORM METHOD=GET>"
                        "  Leave the other oo fields blank unless you have a passcode and/or a prepay code."
                        "  Please enter your email address."
                        "  <P>"
                        "  Or, telephone Wo'O Ideafarm at US 650-759-5306."
                        "  For quick help, use the \"open\" chat room to ask somewo to help you."
                        "</PRE>"

                    REPLY( T("Login") , T(
                    TELL( "writing login confirmation reply" ) ;
                {
                else
                }
                    stPhrases << psttOldC( tinP , etThread , T(" login") ) ;
                    else                    REPLY( T("Invitation to Residency"      ) , T("</PRE><!-- Begin PayPal Logo --><FORM ACTION=\"https://secure.paypal.com/cgi-bin/webscr\" METHOD=\"POST\"><INPUT TYPE=\"hidden\" NAME=\"cmd\" VALUE=\"_xclick\"><INPUT TYPE=\"hidden\" NAME=\"business\" VALUE=\"" ifcEMAIL_OLDfROM "\"><INPUT TYPE=\"hidden\" NAME=\"return\" VALUE=\"http://www.ideafarm.com/afterpay.html\"><INPUT TYPE=\"hidden\" NAME=\"item_name\" VALUE=\"Residency Tax (64 days at 12 cents per day)\"><INPUT TYPE=\"hidden\" NAME=\"item_number\" VALUE=\"c.1.1\"><INPUT TYPE=\"hidden\" NAME=\"amount\" VALUE=\"8.00\"><INPUT TYPE=\"submit\" VALUE=\"Residency Tax (64 days at 12 cents per day)\"></FORM><!-- End PayPal Logo --><H2>Welcome!</H2><P>You have arrived at the gates of IdeaFarm (tm) City.  I hope that your journey was pleasant, and look forward to listening to your tale as we celebrate your arrival.<P>All who enter the city must pay the Residency Tax.  Residency does <B>not</B> imply allegiance to IdeaFarm " "(tm) City, or even that you agree with our culture.  But residents must respect that culture while in the city.  There is ze""ro tolerance for acts that undermine our culture; such acts will result in immediate termination of residency.  The Residency Tax is not refundable.<P>To immediately obtain a passcode via email, click \"Residency Tax\" above.<P>Wo'O Ideafarm<BR>Governing Proprietor<BR>IdeaFarm " "(tm) City<BR>Federal Constitutional Protectorate of the USA<PRE>") )
                    if( bResidencyExpired ) REPLY( T("Invitation to Renew Residency") , T("</PRE><!-- Begin PayPal Logo --><FORM ACTION=\"https://secure.paypal.com/cgi-bin/webscr\" METHOD=\"POST\"><INPUT TYPE=\"hidden\" NAME=\"cmd\" VALUE=\"_xclick\"><INPUT TYPE=\"hidden\" NAME=\"business\" VALUE=\"" ifcEMAIL_OLDfROM "\"><INPUT TYPE=\"hidden\" NAME=\"return\" VALUE=\"http://www.ideafarm.com/afterpay.html\"><INPUT TYPE=\"hidden\" NAME=\"item_name\" VALUE=\"Residency Tax (64 days at 12 cents per day)\"><INPUT TYPE=\"hidden\" NAME=\"item_number\" VALUE=\"c.1.1\"><INPUT TYPE=\"hidden\" NAME=\"amount\" VALUE=\"8.00\"><INPUT TYPE=\"submit\" VALUE=\"Residency Tax (64 days at 12 cents per day)\"></FORM><!-- End PayPal Logo -->Your residency has expired.  Please pay your Residency Tax by clicking \"Residency Tax\" above.<PRE>") )
                    TELL( "asking for a tax payment" ) ;
                {
                else if( bNoPasscodeOnFile || bResidencyExpired )
                }
                    stPhrases << psttOldC( tinP , etThread , T(" passcode sent") ) ;
                    REPLY( T("Passcode Sent Via Email" ) , T("</PRE><H2>Your Passcode Has Been Sent To You!</H2><P>A passcode has been emailed to you.  You can use it immediately to login as a resident of IdeaFarm " "(tm) City.  Welcome!<PRE>") )
                    TELL( "directing user to check email to get new passcode" ) ;
                {
                if( bPrepaidOk )
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/w") , flSAY_APPEND | flSAY_LOG ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_LOGIN )
            }
                stPhrases << psttOldC( tinP , etThread , T(" logInNotification") ) ;
                REPLY( T("Login Successful") , T("</PRE>You have been logged in.  Please be sure to log out when you are no longer using, or supervising the use of, this computer.  If you have an account with the IdeaFarm " "(tm) City central bank, logging out is important to prevent someone else from spending your money.<PRE>") )
                TELL( "writing login confirmation reply" ) ;
            {
            if( bLoggedIn )
            //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/x") , flSAY_APPEND | flSAY_LOG ) ;

            }
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/y") , flSAY_APPEND | flSAY_LOG ) ;
                }
                    bLoggedIn = 1 ;
                    stPhrases << psttOldC( tinP , etThread , T(" login:\"")+tEmailValue+T("\"") ) ;
                    }
                        b_idhLever.ungrabF( tinP ) ;

                        else                                                          tInOut = T("in") ;
                        if( swSession.idSlotOfLeverF( tinP , (countT)&nicNamePeer ) ) tInOut = T("out") ;
    
                        swSession = (countT)pSession ;
                        *(sessionS**)&pSession = psn ; psn = 0 ;

                        DEL( *(sessionS**)&pSession )
                        swSession = 0 ;
    
                        idhLever = nicNamePeer ;
                        b_idhLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

                        //etThread.strokeF( tinP , T("new session record created for nn ")+T(nicNamePeer)+T("; lath time is ")+TT(psn->timeLath1,psn->timeLath2)+T(" ; login time is ")+TT(psn->timeLogin1,psn->timeLogin2)+T("\r\n") ) ;
                    {
                    if( psn )

                    sessionS* psn = new( 0 , tinP , LF ) sessionS( tinP , *tinP.zEtScratch , tEmailValue , psttHumanName , psttStickyNote , idModeStickyNote , idTimeZone ) ;

                    }
                        }
                            etThread.boxPutF( tinP , tFile , tData , tData.csF( tinP ) ) ;
                            TN( tData , "" ) ; tData = TF1(idTimeZone) ;
                        {
                        if( bMod )
                        
                        else                                                  bMod = 0 ;
                        if( !idTimeZone || idTimeZone > cTimeZonesF( tinP ) ) idTimeZone = 1 ;

                        }
                            etThread.delF( tinP , posti ) ;
                            idTimeZone = etThread.strDigitsToSCountF( tinP , T(posti) ) ;
                            etThread.boxGetShadowF( tinP , posti , costi , tFile ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;
                        {
                        if( etThread.diskFileExistsF( tinP , tFile ) )
                        boolT bMod = 1 ;
                        TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/timeZone/" ) ; tFile += tEmailValue ;
                    {
                    ZE( countT , idTimeZone ) ;

                    }
                        else idModeStickyNote = 1 ;
                        }
                            etThread.delF( tinP , posti ) ;
                            if( costi == 1 ) idModeStickyNote = *posti ;
                            etThread.boxGetShadowF( tinP , posti , costi , tFile ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;
                        {
                        if( etThread.diskFileExistsF( tinP , tFile ) )
                        TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/stickynotemode/" ) ; tFile += tEmailValue ;
                    {
                    ZE( countT , idModeStickyNote ) ;

                    }
                        else { etThread.strMakeF( tinP , LF , psttStickyNote , T("(you can put stickynotes here)") ) ; ___( psttStickyNote ) ; }
                        }
                            etThread.delF( tinP , posti ) ;
                            etThread.strMakeF( tinP , LF , psttStickyNote , T(posti) ) ; ___( psttStickyNote ) ;
                            etThread.boxGetShadowF( tinP , posti , costi , tFile ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;
                        {
                        if( etThread.diskFileExistsF( tinP , tFile ) )
                        TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/stickynote/" ) ; tFile += tEmailValue ;
                    {
                    ZE( strokeS* , psttStickyNote ) ;

                    }
                        else { etThread.strMakeF( tinP , LF , psttHumanName , T("(not available)") ) ; ___( psttHumanName ) ; }
                        }
                            etThread.delF( tinP , posti ) ;
                            etThread.strMakeF( tinP , LF , psttHumanName , T(posti) ) ; ___( psttHumanName ) ;
                            etThread.boxGetShadowF( tinP , posti , costi , tFile ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;
                        {
                        if( etThread.diskFileExistsF( tinP , tFile ) )
                        TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/humanname/" ) ; tFile += tEmailValue ;
                    {
                    ZE( strokeS* , psttHumanName ) ;
                {
                if( bOk )
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/z") , flSAY_APPEND | flSAY_LOG ) ;

                }
                    tinP.zEtScratch->delF( tinP , pbi ) ;
                    }
                        }
                            flagsAlert |= flALERT_RESIDENCYeXPIRED ;
                            bResidencyExpired = 1 ;
                            bOk = 0 ;
                        {
                        if( timeN.time2 > timeE2 || ( timeN.time2 == timeE2 && timeN.time1 > timeE1 ) )
                        sCountT& timeE2 = ((sCountT*)pbi)[ 1 ] ;
                        countT&  timeE1 =  ((countT*)pbi)[ 0 ] ;
                    {
                    else
                    }
                        flagsAlert |= flALERT_RESIDENCYeXPIRED ;
                        bResidencyExpired = 1 ;
                        bOk = 0 ;
                        *tinP.zEtScratch = 0 ;
                    {
                    if( *tinP.zEtScratch )
                    tinP.zEtScratch->boxGetShadowF( tinP , pbi , cbi , tFile , 1 ) ; ___( pbi ) ;
                    ZE( countT , cbi ) ;
                    ZE( byteT* , pbi ) ;

                    etThread.osTimeNowF( tinP , timeN.time1 , timeN.time2 ) ;
                    timeS timeN ;
                    tFile += tEmailValue ;
                    TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/resident.until/" ) ;
                {
                if( bOk )
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/A") , flSAY_APPEND | flSAY_LOG ) ;

                bLogin.ungrabF( tinP ) ;
                }
                    etThread.delF( tinP , pstt1m ) ;
                    }
                        etThread.delF( tinP , psttPaid ) ;
                        etThread.delF( tinP , psttItemNumber ) ;

                        }
                            }
                                }
                                    }
                                        bPrepaidOk = 1 ;

                                        }
                                            etThread.boxPutF( tinP , tFile , sJournal ) ;
                                            TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/account.event/" ) ; tFile += tEmailValue+T("/")+TF3(timeN2,flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+td+TF3(timeN1,flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+td+TF1(tinP.osTid) ;
                                            TN( td , "." ) ;
                                            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                                            ZE( sCountT , timeN2 ) ;
                                            ZE( countT , timeN1 ) ;
                                        {
                                        etThread.boxPutF( tinP , tClaim , sArc ) ;
    
                                        sArc << (strokeS*)tEmailValue ;
    
                                        else             etThread.boxPutF( tinP , psttc1 , sArc ) ;
                                        if( bExhausted ) etThread.boxZapF( tinP , psttc1 ) ;
                                    {
                                    if( !etThread && !*tinP.zEtScratch )

                                    }
                                        flagsAlert |= flALERT_RESIDENTuNTILeMAILED ;
                                        SENDmAIL( T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+tEmailValue+T("//" ifcEMAIL_OLDfROM "/")+T(psttPaid) , tNote )
                                        TELL( "sending email (residency tax paid until)" ) ;
                                        ;
                    
                                            "Residency tax payments can be made at any time to extend your residency.\r\n")
                                            "\r\n"
                                            "Your tax has now been paid to ")+TT(timeN.time1,timeN.time2)+T(" .\r\n"
                                            "\r\n    ")+T(psttPaid)+T("\r\n\r\n"
                                            "A residency tax payment for ")+TF1(days)+T(" days was prepaid for you by\r\n"
                                            "Thank you for choosing to reside in IdeaFarm " "(tm) City.\r\n"
                                            "\r\n"
                                            T("Subject: Residency Tax Paid For You\r\n"
                    
                                        TN( tNote , "" ) ; tNote =
                
                                        sJournal << (countT)timeN.time2 ; //NEW EXPIRY time2
                                        sJournal << timeN.time1 ; //NEW EXPIRY time1
                                        tinP.zEtScratch->boxPutF( tinP , tFile , (byteT*)&timeN , sizeof timeN ) ;
                                        etThread.osTimeAddF( tinP , timeN.time1 , timeN.time2 , 0 , days ) ;
            
                                        }
                                            tinP.zEtScratch->delF( tinP , pbi ) ;
                                            else sJournal << (countT)1 ; //bExpired
                                            }
                                                sJournal << (countT)0 ; //bExpired
                                                timeN.time2 = timeE2 ;
                                                timeN.time1 = timeE1 ;
                                            {
                                            if( timeN.time2 < timeE2 || ( timeN.time2 == timeE2 && timeN.time1 < timeE1 ) )
                                            sJournal << (countT)timeE2 ; //OLD time2
                                            sJournal << timeE1 ; //OLD time1
                                            sCountT& timeE2 = ((sCountT*)pbi)[ 1 ] ;
                                            countT&  timeE1 =  ((countT*)pbi)[ 0 ] ;
                                            tinP.zEtScratch->boxGetShadowF( tinP , pbi , cbi , tFile ) ; ___( pbi ) ;
                                            ZE( countT , cbi ) ;
                                            ZE( byteT* , pbi ) ;
                                        {
                                        if( tinP.zEtScratch->diskFileExistsF( tinP , tFile ) )
                                        sJournal << (countT)timeN.time2 ; //CURRENT time2
                                        sJournal << timeN.time1 ; //CURRENT time1
                                        etThread.osTimeNowF( tinP , timeN.time1 , timeN.time2 ) ;
                                        timeS timeN ;
                                        tFile += tEmailValue ;
                                        TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/resident.until/" ) ;
                                        sJournal << days ; // NUMBER OF DAYS PURCHASED
                                        sJournal << (countT)( bDog ? 4 : 5 ) ; //idType
                                        sJournal << (countT)1 ; //idFormat
                                        countT days = 0x80 ;
                                    {
                                    soulC sJournal( tinP , TAG( TAGiDnULL ) ) ;
            
                                    }
                                        flagsAlert |= flALERT_PLEASEsEThUMANnAME ;
                                        tinP.zEtScratch->boxPutF( tinP , tFile , tEmailValue , tEmailValue.csF( tinP ) ) ;
                                        tFile += tEmailValue ;
                                        TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/humanname/" ) ;
                                    {
            
                                    }
                                        }
                                            flagsAlert |= flALERT_NEWpASSCODEeMAILED ;
                                            SENDmAIL( T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+tEmailValue+T("//" ifcEMAIL_OLDfROM "") , tNote )
                                            TELL( "sending email (new passcode)" ) ;
                                            ;
                    
                                                "passcode: ")+tp+T("\r\n") ;
                                                "email:    ")+tEmailValue+T("\r\n"
                                                "\r\n"
                                                "You can log in immediately, using:\r\n"
                                                "Your email address is your resident id.\r\n"
                                                "Welcome, new resident of IdeaFarm " "(tm) City!\r\n"
                                                "\r\n"
                                                T("Subject: Your Password\r\n"
                    
                                            TN( tNote , "" ) ; tNote =
                
                                            tinP.zEtScratch->boxPutF( tinP , tFile , tp , tp.csF( tinP ) ) ;
                                            TN( tp , "" ) ; tp = TF1( (countT)(measureT)ru ) ;
                                            while( cTries -- ) (measureT)ru ;
                                            countT cTries = 0x10 ;
                                        {
                                        if( !tinP.zEtScratch->diskFileExistsF( tinP , tFile ) )
                                        tFile += tEmailValue ;
                                        TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/passcode/" ) ;
                                    {
                                {
                                if( !etThread && !*tinP.zEtScratch )

                                sArc << psttPaid ;
                                sArc << cTimesUseable ;
                                sArc << (countT)timeE2 ;
                                sArc << timeE1 ;
                                sArc << psttItemNumber ;
                                sArc << idFormat ;
                                soulC sArc( tinP , TAG( TAGiDnULL ) ) ;

                                if( cTimesUseable ) cTimesUseable -- ;
                                boolT bExhausted = cTimesUseable == 1 ;

                                }
                                    flagsAlert |=  flALERT_PREPAYCODEaCCEPTED2 ;
                                    flagsAlert &= ~flALERT_PREPAYCODErEJECTED ;
                                {
                                else
                                }
                                    etThread.osTimeAddF( tinP , timeE1 , timeE2 , 0 , 0x8 ) ;
                                    etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                                    timeE2 = timeE1 = 0 ;

                                    etThread.osThreadF( tinP , countTC() , tmPayBirdDogsF , 0 , flTHREADlAUNCH_null , 0 , (countT)(strokeS*)psttOldC( tinP , etThread , tPrepaycodeValue ) ) ;
                                    flagsAlert |= flALERT_BIRDdOGSpAID ;
                                    flagsAlert |=  flALERT_PREPAYCODEaCCEPTED1 ;
                                    flagsAlert &= ~flALERT_PREPAYCODErEJECTED ;
                                {
                                if( bDog )
                                boolT bDog = !etThread.strCompareF( tinP , psttItemNumber , T("01.1.1") ) ;
                            {
                            else if( !etThread.strCompareF( tinP , psttItemNumber , T("e.1.1") ) || !etThread.strCompareF( tinP , psttItemNumber , T("01.1.1") ) )
                            if( etThread.diskFileExistsF( tinP , tClaim ) ) ;

                            }
                                etThread.delF( tinP , psttOldClaim ) ;
                                tClaim = T(psttOldClaim) + T(".$.") + tEmailValue ;
                                etThread.strReplaceF( tinP , psttOldClaim , psttc1 , T("/prepaycode/") , T("/prepaycode.claim/") ) ; ___( psttOldClaim ) ;
                                ZE( strokeS* , psttOldClaim ) ;
                            {
                            TN( tClaim , "" ) ;
                        {
                        else
                        }
                            etThread.delF( tinP , psttArc ) ;
                            etThread.diskMoveFileOrDirF( tinP , psttArc , psttc1 ) ;
                            etThread.strReplaceF( tinP , psttArc , psttc1 , T("/prepaycode/") , T("/prepaycode.expired/") ) ; ___( psttArc ) ;
                            ZE( strokeS* , psttArc ) ;
                        {
                        if( timeN2 < 0 )

                        }
                            etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeN1 , timeN2 ) ;
                            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                        {
                        if( timeE1 || timeE2 )
                        ZE( sCountT , timeN2 ) ;
                        ZE( countT , timeN1 ) ;

                        }
                            }
                                break ;
                                __1
                                __( idFormat ) ;
                            {
                            default :
                            }
                                break ;

                                sIn >> psttPaid ; ___( psttPaid ) ;
                                sIn >> cTimesUseable ;
                                sIn >> *(countT*)&timeE2 ;
                                sIn >> timeE1 ;
                                sIn >> psttItemNumber ; ___( psttItemNumber ) ;
                            {
                            case 1 :
                        {
                        switch( idFormat )
                        ZE( strokeS* , psttPaid ) ;
                        ZE( countT  , cTimesUseable ) ;
                        ZE( sCountT , timeE2 ) ;
                        ZE( countT  , timeE1 ) ;
                        ZE( strokeS* , psttItemNumber ) ;

                        sIn >> idFormat ;
                        ZE( countT , idFormat ) ;

                        etThread.boxGetShadowF( tinP , sIn , psttc1 ) ;
                        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    FORsTRINGSiN1( pstt1m )
                    flagsAlert |= flALERT_PREPAYCODErEJECTED ; //WILL BE RESET IF ACCEPTED
                    TN( tEmailWo , "/" ifcEMAIL_OLDfROM "" ) ;
                    etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/prepaycode/")+tPrepaycodeValue , 0 , 1 ) ; ___( pstt1m ) ;
                    ZE( strokeS* , pstt1m ) ;
                {
                if( tPrepaycodeValue.csF( tinP ) && !bPasscodeRejected )
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/B") , flSAY_APPEND | flSAY_LOG ) ;

                }
                    tinP.zEtScratch->delF( tinP , pbi ) ;
                    }
                        flagsAlert |= flALERT_PASSCODErEJECTED ;
                        bPasscodeRejected = 1 ;
                    {
                    else
                    else if( !tinP.zEtScratch->strCompareF( tinP , T(pbi) , tPasscodeValue ) ) bOk = 1 ;
                    }
                        flagsAlert |= flALERT_NOpASSCODEoNfILE ;
                        bNoPasscodeOnFile = 1 ;
                        *tinP.zEtScratch = 0 ;
                    {
                    if( *tinP.zEtScratch )
                    tinP.zEtScratch->boxGetShadowF( tinP , pbi , cbi , tFile , 1 ) ; ___( pbi ) ;
                    ZE( countT , cbi ) ;
                    ZE( byteT* , pbi ) ;

                    tFile += tEmailValue ;
                    TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/passcode/" ) ;
                {
                ZE( boolT , bOk ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/C") , flSAY_APPEND | flSAY_LOG ) ;

                bLogin.grabF( tinP , TAG( TAGiDnULL ) ) ;
                //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/D") , flSAY_APPEND | flSAY_LOG ) ;
            {
            if( idRequestType == ifcIDrEQtYPE_LOGIN && tEmailValue.csF( tinP ) )
            ZE( boolT , bPrepaidOk ) ;
            //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/E") , flSAY_APPEND | flSAY_LOG ) ;

            }
                }
                    SETvAR( t_interest , t_interest_Value )
                    SETvAR( t_idevent , t_idevent_Value )
                    SETvAR( t_note , t_note_Value )
                    SETvAR( t_how2west , t_how2west_Value )
                    SETvAR( t_how2south , t_how2south_Value )
                    SETvAR( t_how2east , t_how2east_Value )
                    SETvAR( t_how2north , t_how2north_Value )
                    SETvAR( t_cross , t_cross_Value )
                    SETvAR( t_aptno , t_aptno_Value )
                    SETvAR( t_curbno , t_curbno_Value )
                    SETvAR( t_street , t_street_Value )
                    SETvAR( t_city , t_city_Value )
                    SETvAR( t_metro , t_metro_Value )
                    SETvAR( t_state , t_state_Value )
                    SETvAR( t_country , t_country_Value )
                    SETvAR( t_status , t_status_Value )
                    SETvAR( t_title , t_title_Value )
                    SETvAR( t_type , t_type_Value )
                    SETvAR( t_duration , t_duration_Value )
                    SETvAR( t_tz , t_tz_Value )
                    SETvAR( t_ifctime2 , t_ifctime2_Value )
                    SETvAR( t_ifctime1 , t_ifctime1_Value )
                    SETvAR( t_mi , t_mi_Value )
                    SETvAR( t_hh , t_hh_Value )
                    SETvAR( t_dd , t_dd_Value )
                    SETvAR( t_mm , t_mm_Value )
                    SETvAR( t_yy , t_yy_Value )
                    SETvAR( tPrepaycode , tPrepaycodeValue )
                    SETvAR( tPasscode , tPasscodeValue )
                    SETvAR( tEmail , tEmailValue )
                    SETvAR( tFullName , tFullNameValue )
                    }
                    {
                    else if( !etThread.strCompareF( tinP , tDefect , tblKeyValue._CT1_07F( idr , 1 ) ) )
                    }
                        }
                            idRequestType = ifcIDrEQtYPE_BLABrEDIRECT ;
                            idRoomBlab = tinP.zEtScratch->strDigitsToSCountF( tinP , psttv ) ;
                            __( idRequestType - ifcIDrEQtYPE_BLAB ) ;
                        {
                        if( psttv && psttv->idAdam )
                        strokeS* psttv = tblKeyValue._CT1_07F( idr , 2 ) ;
                    {
                    else if( !etThread.strCompareF( tinP , tIdRoomBlab , tblKeyValue._CT1_07F( idr , 1 ) ) )
                    }
                        }
                            idRequestType = ifcIDrEQtYPE_BLABrEDIRECT ;
                            __( idRequestType - ifcIDrEQtYPE_BLAB ) ;

                            }
                                etThread.etherWaitCyrcleOldF( tinP , *pNapBlab ) ;
                                thirdC::thirdWriteToCyrcleOldIF( tinP , *pNapBlab , tSay , tSay.csF( tinP ) + 1 ) ;
                            {
                            if( pNapBlab )

                            b_idrLever.ungrabF( tinP ) ;
                            napkinC*& pNapBlab = *(napkinC**)&(countT&)swPNapBlab ;
                            idrLever = idRoomBlab ;
                            b_idrLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

                            TN( tSay , "" ) ; tSay = tFullNameValue+T(": ")+T(psttv)+T("\r\n") ;
                            if( pSession ) tFullNameValue = T(pSession->psttHumanName) ;
                            TELL( "writing the blab to a blab circle" ) ;
                        {
                        if( psttv && psttv->idAdam )
                        strokeS* psttv = tblKeyValue._CT1_07F( idr , 2 ) ;
                    {
                    if( !etThread.strCompareF( tinP , tBlab , tblKeyValue._CT1_07F( idr , 1 ) ) )
                    //etThread.strokeF( tinP , T("key: \"")+T(tblKeyValue._CT1_07F( idr , 1 ))+T("\"\r\n") ) ;
                {
                for( countT idr = 1 ; idr <= cRows ; idr ++ )
                //etThread.strokeF( tinP , T("cRows: ")+TF1(cRows)+T("\r\n") ) ;
                countT cRows = tblKeyValue.cRowsF( tinP ) ;
                TN( tPrepaycode , "prepaycode" ) ;
                TN( tPasscode , "passcode" ) ;
                TN( tEmail , "email" ) ;
                TN( tDefect , "defect" ) ;
                TN( tFullName , "fullName" ) ;
                TN( tIdRoomBlab , "idroomblab" ) ;
                TN( tBlab , "blab" ) ;
        
                //!tblKeyValue ;
            {
            if( !*tinP.zEtScratch && tblKeyValue.cRowsF( tinP ) )
            //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/F") , flSAY_APPEND | flSAY_LOG ) ;

            TN( t_interest , "interest" ) ;
            TN( t_idevent , "idevent" ) ;
            TN( t_note , "note" ) ;
            TN( t_how2west , "how2gettherefromwest" ) ;
            TN( t_how2south , "how2gettherefromsouth" ) ;
            TN( t_how2east , "how2gettherefromeast" ) ;
            TN( t_how2north , "how2gettherefromnorth" ) ;
            TN( t_cross , "crossstreet" ) ;
            TN( t_aptno , "aptno" ) ;
            TN( t_curbno , "curbno" ) ;
            TN( t_street , "street" ) ;
            TN( t_city , "city" ) ;
            TN( t_metro , "metro" ) ;
            TN( t_state , "state" ) ;
            TN( t_country , "country" ) ;
            TN( t_status , "status" ) ;
            TN( t_title , "title" ) ;
            TN( t_type , "type" ) ;
            TN( t_duration , "duration" ) ;
            TN( t_tz , "timezone" ) ;
            TN( t_ifctime2 , "ifctime2" ) ;
            TN( t_ifctime1 , "ifctime1" ) ;
            TN( t_mi , "mi" ) ;
            TN( t_hh , "hh" ) ;
            TN( t_dd , "dd" ) ;
            TN( t_mm , "mm" ) ;
            TN( t_yy , "yy" ) ;

            TN( t_interest_Value , "" ) ;
            TN( t_idevent_Value , "" ) ;
            TN( t_note_Value , "" ) ;
            TN( t_how2west_Value , "" ) ;
            TN( t_how2south_Value , "" ) ;
            TN( t_how2east_Value , "" ) ;
            TN( t_how2north_Value , "" ) ;
            TN( t_cross_Value , "" ) ;
            TN( t_aptno_Value , "" ) ;
            TN( t_curbno_Value , "" ) ;
            TN( t_street_Value , "" ) ;
            TN( t_city_Value , "" ) ;
            TN( t_metro_Value , "" ) ;
            TN( t_state_Value , "" ) ;
            TN( t_country_Value , "" ) ;
            TN( t_status_Value , "" ) ;
            TN( t_title_Value , "" ) ;
            TN( t_type_Value , "" ) ;
            TN( t_duration_Value , "" ) ;
            TN( t_tz_Value , "" ) ;
            TN( t_ifctime2_Value , "" ) ;
            TN( t_ifctime1_Value , "" ) ;
            TN( t_mi_Value , "" ) ;
            TN( t_hh_Value , "" ) ;
            TN( t_dd_Value , "" ) ;
            TN( t_mm_Value , "" ) ;
            TN( t_yy_Value , "" ) ;

            TN( tFullNameValue , "" ) ;
            TN( tPrepaycodeValue , "" ) ;
            TN( tPasscodeValue , "" ) ;
            TN( tEmailValue , "" ) ;
            ZE( boolT , bNoPasscodeOnFile ) ;
            ZE( boolT , bResidencyExpired ) ;
            ZE( boolT , bPasscodeRejected ) ;
            ZE( boolT , bLoggedIn ) ;
            stPhrases << psttOldC( tinP , etThread , T(pcIdName) ) ;
            stPhrases << psttOldC( tinP , etThread , T(" (")+T(nicNamePeer)+T(")\r\n") ) ;
            stPhrases << psttOldC( tinP , etThread , T("peer: \"")+T(psttPeer)+T("\"") ) ;
            //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/G") , flSAY_APPEND | flSAY_LOG ) ;
        {
        else
        }
            flagsAlert |= flALERT_NOTfOUND ;
            bNotFound = 1 ;
            //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/H") , flSAY_APPEND | flSAY_LOG ) ;
        {
        else if( *tinP.zEtScratch )
        if( etThread ) ;
        //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/I") , flSAY_APPEND | flSAY_LOG ) ;

        strokeS* psttGoodBye  = psttOldC( tinP , etThread , T("Goodbye!") ) ; ___( psttGoodBye ) ;
        strokeS* psttLogInNow = psttOldC( tinP , etThread , T("Log In Now!") ) ; ___( psttLogInNow ) ;

        ZE( boolT , bNotPaid ) ;
        ZE( boolT , bNotFound ) ;
        TELL( "preparing to compose a reply" ) ;
        //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/J") , flSAY_APPEND | flSAY_LOG ) ;
    
        etThread.delF( tinP , psttStickyNote ) ;
        }
            if( pSession ) tInOut = T("out") ;

            }
                }
                    }
                        }
                            *tinP.zEtScratch = 0 ;
                            tinP.zEtScratch->boxZapF( tinP , tFile , 1 ) ;
                        {
                        else
                        if( pSession->psttStickyNote && pSession->psttStickyNote->idAdam ) tinP.zEtScratch->boxPutF( tinP , tFile , T(pSession->psttStickyNote) , pSession->psttStickyNote->idAdam ) ;
                        TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/stickynote/" ) ; tFile += T(pSession->psttEmail) ;

                        psttStickyNote = 0 ;
                        pSession->psttStickyNote = psttStickyNote ;
                        etThread.delF( tinP , pSession->psttStickyNote ) ;
                    {
                    if( psttStickyNote )

                    pSession->timeLath2 = timeN2 ;
                    pSession->timeLath1 = timeN1 ;
                {
                else
                }
                    DEL( *(sessionS**)&pSession )
                    b_idhLever.ungrabF( tinP ) ;
                    swSession = 0 ;
                    idhLever = nicNamePeer ;
                    b_idhLever.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    bTimeout = 1 ;
                    flagsAlert |= flALERT_TIMEOUT ;
                    //etThread.strokeF( tinP , T("TIMEOUTr\n") ) ;
                {
                if( timeE2 || timeE1 > TIMEtIMEOUT )
                //etThread.strokeF( tinP , T("session record found for nn ")+T(nicNamePeer)+T("; lath time is ")+TT(pSession->timeLath1,pSession->timeLath2)+T(" ; stale time is ")+TT(timeE1,timeE2)+T("\r\n") ) ;
                etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , pSession->timeLath1 , pSession->timeLath2 ) ;
            {
            else
            if( !pSession ) /*etThread.strokeF( tinP , T("session record NOT FOUND for nn ")+T(nicNamePeer)+T("\r\n") )*/ ;

            sCountT timeE2 = timeN2 ;
            countT timeE1 = timeN1 ;

            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
        {
        if( idsnu )
        b_idhLever.ungrabF( tinP ) ;
        countT idsnu = swSession.idSlotOfLeverF( tinP , (countT)&nicNamePeer ) ;
        b_idhLever.grabF( tinP , TAG( TAGiDnULL ) ) ;
        ZE( boolT , bTimeout ) ;
        TN( tInOut , "in" ) ;
        //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/K") , flSAY_APPEND | flSAY_LOG ) ;

        }
            tinP.zEtScratch->strokeF( tinP , T("readRequest just returned, and *tinP.zEtScratch is IMPOTENT; resetting\r\n") ) ;
            *tinP.zEtScratch = 0 ;
        {
        if( *tinP.zEtScratch )
        //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/L") , flSAY_APPEND | flSAY_LOG ) ;
        countT idRequestType = readRequestF( tinP , etThread , *tinP.zEtScratch , bNotPaidIsOk , *pso , bMore , bHttpWoZe , pcIdName , tblKeyValue , std_pstt , psttPeer , nicNamePeer , dict , psttStickyNote , stPhrases , psttFile , flagsAlert , bnnPeer , idRoomBlab , *(sessionS**)&pSession , cArg ) ; ___( psttStickyNote ) ;
        ZE( sessionS* const , pSession ) ;
        //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/M") , flSAY_APPEND | flSAY_LOG ) ;
        ZE( countT , idRoomBlab ) ;
        ZE( flagsT , flagsAlert ) ;
        ZE( strokeS* , psttFile ) ;
        ZE( strokeS* , psttStickyNote ) ;
        ZE( boolT , bNotPaidIsOk ) ;
        TELL( "reading a request" ) ;
        ZE( boolT , bHttpWoZe ) ;
        stackC std_pstt( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
        ZE( strokeS* , psttPeer ) ;
    
        tblKeyValue.newColF( tinP , T("value") ) ;
        tblKeyValue.newColF( tinP , T("key") ) ;
        tableC tblKeyValue( tinP , etThread , T("keyValue") ) ;

        b_pbdVarying.ungrabF( tinP ) ;
        }
            TN( t_cHamburgers , "" ) ; t_cHamburgers = TF3(++state.cHamburgers,0,8) ;
            TN( t_idMe        , "" ) ; t_idMe        = TF3(state.idMe,0,8) ;
            stateS& state = *(stateS*)pbdVarying ;
        {
        if( pbdVarying )
        b_pbdVarying.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        etThread.newF( tinP , LF , pcIdName , CCiDnAMEmAX + 1 ) ; ___( pcIdName ) ;
        ZE( countT* , pcIdName ) ;
    
        nicNameC nicNamePeer ;
        stackC stPhrases( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
        TELL( "preparing to read a request" ) ;
        //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/N") , flSAY_APPEND | flSAY_LOG ) ;
    {
    while( !etThread && !*tinP.zEtScratch && bMore )
    boolT bMore = 1 ;
    //etText.ifcSayF( tinP , T("tmcF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/O") , flSAY_APPEND | flSAY_LOG ) ;
    etherC& etText = etherC::etTextIF( tinP ) ;

    PARAMS( cArg )
{
if( cArg )
TELL( "preparing for work" ) ;
TASKdRIVENsERVER( tmcF )
countT idClient ;

DONE( tmSendEmailF )
}
    etThread.delF( tinP , postb ) ;
    etThread.delF( tinP , psttFile ) ;
    etThread.boxPutF( tinP , psttFile , postb , costb ) ;
    etThread.delF( tinP , psttBody ) ;
    countT costb = etThread.strMakeF( tinP , LF , postb , psttBody ) ; ___( postb ) ;
    ZE( osTextT* , postb ) ;

    strokeS* psttBody = (strokeS*)pTaskP->c2 ;
    strokeS* psttFile = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmSendEmailF )

}
    TELL( "blabF: ----" )
    etThread.strConcatenateF( tinP , psttP , st_psttb ) ;
    if( pbc != pbe ) { BLAMMO ; }
    }
        st_psttb << psttOldC( tinP , etThread , T(pbData) ) ;
        if( cbDataVerify != cbData ) BLAMMO ;

        countT&            cbDataVerify = *(countT*)pbc ; pbc += sizeof( countT ) ;
        const byteT* const pbData       =           pbc ; pbc += cbData ;
        countT&            cbData       = *(countT*)pbc ; pbc += sizeof( countT ) ;
    {
    while( pbc < pbe )
    stackC st_psttb( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

    const byteT* const pbe = pbCircleP + cbCyrcleOldP ;
    const byteT*       pbc = pbCircleP ;
    _IO_
    TELL( "blabF: ++++" )
{
voidT blabF( tinS& tinP , etherC& etThread , strokeS*& psttP , const byteT* const pbCircleP , const countT cbCyrcleOldP )

}
    return idRequestType ;
    if( psttPeerP && flagsAlertP ) ;
    //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/0") , flSAY_APPEND | flSAY_LOG ) ;

    etThread.delF( tinP , psttName ) ;
    etThread.delF( tinP , psttAction ) ;
    }
        }
            tinP.zEtScratch->delF( tinP , psttNameTrimmed ) ;

            if( offi < CCiDnAMEmAX ) pcIdNameP[ offi ++ ] = 0 ;
            }
                tinP.zEtScratch->delF( tinP , psttw ) ;
                else __1
                }
                    }
                        __( !pcIdNameP[ offi ++ ] ) ;
                        tinP.zEtScratch->delF( tinP , psttw2 ) ;
                        pcIdNameP[ offi ] = dictP( psttw2 ) ;
                        tinP.zEtScratch->strSubstringF( tinP , psttw2 , idf2 , idl2 , psttw ) ; ___( psttw2 ) ;
                        ZE( strokeS* , psttw2 ) ;
                        ZE( countT , idl2 ) ;
                        countT idf2 = 2 ;
                    {
                    else
                    if( 1 != tinP.zEtScratch->strIdF( tinP , sttDollar , psttw ) ) pcIdNameP[ offi ++ ] = tinP.zEtScratch->strDigitsToSCountF( tinP , psttw ) ;
                {
                if( offi < CCiDnAMEmAX - 1 )
                tinP.zEtScratch->strSubstringF( tinP , psttw , idf , sttq , sttDot , psttNameTrimmed ) ; ___( psttw ) ;            // "$foo"
                ZE( strokeS* , psttw ) ;
            {
            while( !*tinP.zEtScratch && idf )
            strokeS sttDollar( '$' ) ;
            strokeS sttDot( '.' ) ;
            idf = 1 ;
            ZE( countT , offi ) ;

            tinP.zEtScratch->strSubstringF( tinP , psttNameTrimmed , idf , idl , psttName ) ; ___( psttNameTrimmed ) ;      // "1.2.$foo.4"
            ZE( strokeS* , psttNameTrimmed ) ;
            countT idl = idDot0 ? idDot0 - 1 : 0 ;
            idf = 2 ;

            __( psttName->idAdam - 6 - idDot0 ) ;
            countT idDot0 = tinP.zEtScratch->strIdF( tinP , countTC( 1 ) , sttq , tDot0 , psttName , 0 , - 1 ) ;
            TN( tDot0 , ".0.html" ) ; // ".html" WAS ADDED LATE SO THAT Internet Explorer CAN VIEW THE FILES OFFLINE (IT IS TOO STUPID TO PROCESS THE HTTP HEADER LINES)
            idf = 1 ;
        {
        else
        else if( idRequestType >= ifcIDrEQtYPE_HELP1 && idRequestType <= ifcIDrEQtYPE_HELP6 ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_AFTERpAY       ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_ME             ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_ROSTER         ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_STATISTICS     ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_BEFOREbLABBING ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_FINGERlIFT     ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_FILE           ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_STICKY         ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_DISCLOSURE     ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_NEWeVENT       ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_CALENDAR       ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_WARNINGS       ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_COPYRIGHTS     ) pcIdNameP[ 0 ] = 0 ;
        else if( idRequestType == ifcIDrEQtYPE_BLAB           ) pcIdNameP[ 0 ] = 0 ;
        }
            pcIdNameP[ 2 ] = 0 ;
            pcIdNameP[ 1 ] = 1 ;
            pcIdNameP[ 0 ] = 1 ;
        {
        else if( psttName->idAdam == 1 )
        if( idRequestType != ifcIDrEQtYPE_FISH ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;
        __( tinP.zEtScratch->strIdF( tinP , sttSlash , psttName ) - 1 ) ;                                                  // "/1.2.$foo.4.0.html"
        __( !psttName->idAdam ) ;
    {
    if( !*tinP.zEtScratch && !etThread )
    __Z( psttName ) ; // WILL BE NULL IF CLIENT CLOSES WITHOUT TELLING ME TO CLOSE
    //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/1") , flSAY_APPEND | flSAY_LOG ) ;

    etThread.delF( tinP , psttKV ) ;
    }
        tinP.zEtScratch->delF( tinP , pstt1e ) ;
        }
            if( !( -- cLimit ) ) break ; //TO REDUCE VULNERABILITY TO ATTACK

            }
                }
                    if( !tinP.zEtScratch->strCompareF( tinP , psttv , T("ab94" ) ) ) bNotPaidIsOkP = 1 ;
                {
                else if( !tinP.zEtScratch->strCompareF( tinP , psttk , T("secret") ) )
                }
                    else if( !tinP.zEtScratch->strCompareF( tinP , psttv , T("whoCanIMeet"     ) ) ) idRequestType = ifcIDrEQtYPE_HELP6 ;
                    else if( !tinP.zEtScratch->strCompareF( tinP , psttv , T("whatCanIBuy"     ) ) ) idRequestType = ifcIDrEQtYPE_HELP5 ;
                    else if( !tinP.zEtScratch->strCompareF( tinP , psttv , T("whatCanIDownload") ) ) idRequestType = ifcIDrEQtYPE_HELP4 ;
                    else if( !tinP.zEtScratch->strCompareF( tinP , psttv , T("whatCanILearn"   ) ) ) idRequestType = ifcIDrEQtYPE_HELP3 ;
                    else if( !tinP.zEtScratch->strCompareF( tinP , psttv , T("whatCanIRead"    ) ) ) idRequestType = ifcIDrEQtYPE_HELP2 ;
                         if( !tinP.zEtScratch->strCompareF( tinP , psttv , T("whatCanIDo"      ) ) ) idRequestType = ifcIDrEQtYPE_HELP1 ;
                {
                else if( !tinP.zEtScratch->strCompareF( tinP , psttk , T("help") ) )
                }
                    tinP.zEtScratch->strMakeF( tinP , LF , psttStickyNoteP , T(psttv) ) ; ___( psttStickyNoteP ) ;
                    __NZ( psttStickyNoteP ) ;
                {
                if( !tinP.zEtScratch->strCompareF( tinP , psttk , T("stickynote") ) )

                tblKeyValueP.newObjectF( tinP , psttv ) ;
                tblKeyValueP.newObjectF( tinP , psttk ) ;
                tblKeyValueP.newEventF( tinP ) ;
        
                }
                    std_psttP << psttv ;
                    tinP.zEtScratch->strTrimF( tinP , psttv , 0 , T(TbLACKnEWlINE) ) ;
                {
                if( psttv )
                std_psttP << psttk ;
                tinP.zEtScratch->strTrimF( tinP , psttk , 0 , T(TbLACKnEWlINE) ) ;
            {
            else
            if( *tinP.zEtScratch ) *tinP.zEtScratch = 0 ;
        
            //tinP.zEtScratch->strokeF( tinP , T("key, value: \"")+T(psttk)+T("\"  \"")+T(psttv)+T("\"\r\n") ) ;
            if( psttv ) { tinP.zEtScratch->strFromUrlF( tinP , psttv ) ; ___( psttv ) ; }
            tinP.zEtScratch->strFromUrlF( tinP , psttk ) ; ___( psttk ) ;
        
            if( idf ) { tinP.zEtScratch->strSubstringF( tinP , psttv , idf , sttq , sttEq , psttc1 ) ; ___( psttv ) ; }
            tinP.zEtScratch->strSubstringF( tinP , psttk , idf , sttq , sttEq , psttc1 ) ; ___( psttk ) ;
            ZE( strokeS* , psttv ) ;
            ZE( strokeS* , psttk ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        FORsTRINGSiN1( pstt1e )
        countT cLimit = 0x20 ;
        strokeS sttEq( '=' ) ;
        tinP.zEtScratch->strWordsOldF( tinP , pstt1e , psttKV , sttq , T("&") ) ; ___( pstt1e ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , pstt1e ) ;
        //tinP.zEtScratch->strokeF( tinP , T("psttKVdecoded: \"")+T(psttKVdecoded)+T("\"\r\n") ) ;

        //U: COMMENTED OUT CAUSE HACKERS CAN OVERLOAD: tinP.zEtScratch->osThreadF( tinP , countTC() , tmEmailDataF , 0 , flTHREADlAUNCH_null , 0 , (countT)(strokeS*)psttOldC( tinP , *tinP.zEtScratch , psttName ) , (countT)psttKVdecoded , (countT)(strokeS*)psttOldC( tinP , *tinP.zEtScratch , T(nicNamePeerP) ) ) ;
        tinP.zEtScratch->strUrlDecodeF( tinP , psttKVdecoded , psttKV ) ; ___( psttKVdecoded ) ;
        ZE( strokeS* , psttKVdecoded ) ;
    {
    if( !*tinP.zEtScratch && psttKV ) // STORE THE KEY/VALUE PAIRS
    //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/2") , flSAY_APPEND | flSAY_LOG ) ;

    }
        etThread.strMakeF( tinP , LF , psttKV , ( psttw ? T(psttw)+T("&") : T("") )+tBody ) ; ___( psttKV ) ; //ASSUME: psttKV IS OF FORM T("aaaa=1111&bbbb=2222&cccc=3333&dddd=4444")
        psttKV = 0 ;
        strokeS* psttw = psttKV ;
        TN( tBody , "" ) ; tBody = T(postBody) ;

        //etThread.strokeF( tinP , T("HTTP1.1KV\r\n"USCORE79 "\r\n")+T(postBody)+T("\r\n" USCORE79 "\r\n") ) ;
        if( postBody ) postBody[ costBody ] = 0 ;
        sInP.readF( tinP , postBody , costBody ) ;
        etThread.newF( tinP , LF , postBody , costBody + 1 ) ;
        ZE( osTextT* , postBody ) ;
    {
    if( !*tinP.zEtScratch && costBody ) // HTTP/1.1 KEYvALUE PAIRS
    //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/3") , flSAY_APPEND | flSAY_LOG ) ;

    }
        tinP.zEtScratch->delF( tinP , psttw ) ;
        tinP.zEtScratch->strWordF( tinP , psttKV   , psttw , sttq , sttQuest , 2 ) ; ___( psttKV   ) ;
        tinP.zEtScratch->strWordF( tinP , psttName , psttw , sttq , sttQuest , 1 ) ; ___( psttName ) ;
        psttName = 0 ;
        strokeS* psttw = psttName ;
        //etThread.strokeF( tinP , T("HTTP1.0KV\r\n"USCORE79 "\r\n")+T(psttName)+T("\r\n" USCORE79 "\r\n") ) ;
    {
    if( tinP.zEtScratch->strIdF( tinP , T("?") , psttName ) ) // HTTP/1.0 KEYvALUE PAIRS
    ZE( strokeS* , psttKV ) ;
    //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/4") , flSAY_APPEND | flSAY_LOG ) ;

    }
        //etThread.strokeF( tinP , T("nnPeer: ")+T(idClient)+T(" ")+T(nicNamePeerP)+T("\r\n") ) ;
        //etThread.ifcSayF( tinP , T("a340104/client: ")+T(++idClient)+T(" ")+T(nicNamePeerP)+T(" \"")+T(psttName)+T("\"\r\n") , flSAY_APPEND | flSAY_LOG ) ;
    {
    if( nicNamePeerP != nnRoot )
    nicNameC nnRoot( 0x40ef0525 ) ;    // ifc5: 64.239.5.37
    //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/5") , flSAY_APPEND | flSAY_LOG ) ;

    }
        //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/6") , flSAY_APPEND | flSAY_LOG ) ;
        tinP.zEtScratch->delF( tinP , psttl ) ;
        }
            break ;
            tinP.zEtScratch->delF( tinP , psttl ) ;
        {
        else
        }
            tinP.zEtScratch->delF( tinP , psttValue ) ;
            tinP.zEtScratch->delF( tinP , psttKey ) ;
            }
                idRequestType = ifcIDrEQtYPE_TINYpAGE ;
            {
            else if( !tinP.zEtScratch->strCompareF( tinP , tNumSoftKeys , psttKey ) )
            }
                if( tinP.zEtScratch->strIdF( tinP , tClose , psttValue ) ) bMoreP = 0 ;
            {
            else if( !tinP.zEtScratch->strCompareF( tinP , tConnection    , psttKey ) )
                 if( !tinP.zEtScratch->strCompareF( tinP , tContentLength , psttKey ) ) costBody = tinP.zEtScratch->strDigitsToSCountF( tinP , psttValue , 0xa , 1 ) ;
            tinP.zEtScratch->strSubstringF( tinP , psttValue , idf , idl , psttl ) ; ___( psttValue ) ;
            ZE( countT , idl ) ;
            tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttKey ) ; ___( psttKey ) ;
            tinP.zEtScratch->strSubstringF( tinP , psttKey , idf , sttq , tColonWhite , psttl , 1 ) ; ___( psttKey ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttValue ) ;
            ZE( strokeS* , psttKey ) ;
        {
        else if( psttl && psttl->idAdam ) // HEADER LINE ASSUMED TO BE OF THE FORM, FOR EXAMPLE,  "Content-Length:1234"
        }
            }
                }
                    idRoomBlabP = idrNew ;
                    idRequestType = ifcIDrEQtYPE_BLABrEDIRECT ;
    
                    }
                        bNewBlabRoom.ungrabF( tinP ) ;
                        }
                            }
                                break ;
                                etThread.boxPutF( tinP , tFile , tEntry , tEntry.csF( tinP ) ) ;
                                TN( tEntry , "IdeaFarm " "(tm) City blab room " ) ; tEntry += TF1(idrNew)+T("\r\nwrite down this room number because you will need its number in order to enter it again\r\nthis room was created by ")+(pSessionP?T(pSessionP->psttHumanName):T("<noName>"))+T(" <")+(pSessionP?T(pSessionP->psttEmail):T(""))+T("> at ")+TT(timeN1,timeN2)+T("\r\nit will become frozen eventually when it is no longer active\r\nit will eventually (after not less than 01 ducks from the time of creation) become linked to the city historical archive and visible to all residents\r\nsee \"copyrights\" above\r\n" USCORE79 "\r\n") ;
                                etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                                ZE( sCountT , timeN2 ) ;
                                ZE( countT , timeN1 ) ;
                            {
                            if( !etThread.diskFileExistsF( tinP , tFile ) )
                            TN( tFile , "" ) ; tFile = TbLABaRC( idrNew ) ;
                            while( idrNew < 0x20000000 ) idrNew = ru ;
                        {
                        while( !etThread && !*tinP.zEtScratch )
                        bNewBlabRoom.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    ZE( countT , idrNew ) ;
                {
                else
                if( !pSessionP ) ; //U::
            {
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tNewBlabRoom , psttName ) )
            }
                idRequestType = ifcIDrEQtYPE_FILE ;
                tinP.zEtScratch->strWordF( tinP , psttFileP , psttName , sttq , S1C('/') , - 1 ) ; ___( psttFileP ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttw ) ;

                idRequestType = ifcIDrEQtYPE_BLAB ;
            {
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tFileSlash , psttName ) )
            }
                if( !bIsLoadedF( tinP , *(count8S*)cParmP , idRoomBlabP ) ) loadBlabArchiveF( tinP , etThread , idRoomBlabP , cParmP ) ;

                }
                    idRequestType = ifcIDrEQtYPE_BLABrEDIRECT ;
                    idRoomBlabP += pSessionP->idTimeZone ;
                {
                if( idRoomBlabP == 0x1200 && pSessionP )

                tinP.zEtScratch->delF( tinP , psttw ) ;
                idRoomBlabP = tinP.zEtScratch->strDigitsToSCountF( tinP , psttw ) ;
                tinP.zEtScratch->strWordF( tinP , psttw , psttName , sttq , S1C('.') , 2 ) ; ___( psttw ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttw ) ;

                idRequestType = ifcIDrEQtYPE_BLAB ;
            {
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tBlabDot        , psttName ) )
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tLogout         , psttName ) ) idRequestType = ifcIDrEQtYPE_LOGOUT ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tLogin          , psttName ) ) idRequestType = ifcIDrEQtYPE_LOGIN ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tAfterPay       , psttName ) ) idRequestType = ifcIDrEQtYPE_AFTERpAY ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tMe             , psttName ) ) idRequestType = ifcIDrEQtYPE_ME ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tRoster         , psttName ) ) idRequestType = ifcIDrEQtYPE_ROSTER ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tStatistics     , psttName ) ) idRequestType = ifcIDrEQtYPE_STATISTICS ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tBeforeBlabbing , psttName ) ) idRequestType = ifcIDrEQtYPE_BEFOREbLABBING ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tFingerLift     , psttName ) ) idRequestType = ifcIDrEQtYPE_FINGERlIFT ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tSticky         , psttName ) ) idRequestType = ifcIDrEQtYPE_STICKY ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tDisclosure     , psttName ) ) idRequestType = ifcIDrEQtYPE_DISCLOSURE ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tNewEvent       , psttName ) ) idRequestType = ifcIDrEQtYPE_NEWeVENT ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tCalendar       , psttName ) ) idRequestType = ifcIDrEQtYPE_CALENDAR ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tWarnings       , psttName ) ) idRequestType = ifcIDrEQtYPE_WARNINGS ;
            else if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) , 1 == tinP.zEtScratch->strIdF( tinP , idf , sttq , tCopyrights     , psttName ) ) idRequestType = ifcIDrEQtYPE_COPYRIGHTS ;
                 if( idf = 1 , sttq = S2(0,sc_IGNOREqUOTES) ,      tinP.zEtScratch->strIdF( tinP , idf , sttq , T("!fire")      , psttName ) ) idRequestType = ifcIDrEQtYPE_OSfIRE ;
            countT idf = 1 ;
            tinP.zEtScratch->delF( tinP , psttw ) ;
            bHttpWoZeP = !tinP.zEtScratch->strIdF( tinP , tHttp11 , psttw ) ;
            bMoreP = 0 ; //U::TO WORKAROUND SUSPECTED IE BUG SEEN AT BELLEVUE LIBRARY COMPUTERS (STUCK IN readPrivateF WAITING FOR IE TO SEND ANOTHER REQUEST LINE)
            bMoreP = !!tinP.zEtScratch->strIdF( tinP , tHttp11 , psttw ) ;
            tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttw ) ; ___( psttw ) ;
            tinP.zEtScratch->strWordF( tinP , psttw , psttl , sttq , sttb , 3 ) ; ___( psttw ) ;
            ZE( strokeS* , psttw ) ;
            stPhrasesP << psttOldC( tinP , etThread , T(" name: \"")+T(psttName)+T("\"\r\n") ) ;
            //etThread.strokeF( tinP , T(" name: \"")+T(psttName)+T("\"\r\n") ) ;
            tinP.zEtScratch->strWordF( tinP , psttName , psttl , sttq , sttb , 2 ) ; ___( psttName ) ;
            tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttAction ) ; ___( psttAction ) ;
            stPhrasesP << psttOldC( tinP , etThread , T(" action: \"")+T(psttAction)+T("\"") ) ;
            tinP.zEtScratch->strWordF( tinP , psttAction , psttl , sttq , sttb , 1 ) ; ___( psttAction ) ;
        {
        if( !psttAction ) // IF WO'TH LINE
        //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/7") , flSAY_APPEND | flSAY_LOG ) ;

        if( *tinP.zEtScratch ) break ;
        //if( nicNamePeerP != nicNameC( NICnAMElOCAL ) ) etThread.strokeF( tinP , T("|||| ")+T(psttl)+T(" ||||\r\n") ) ;
        //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/8/\"")+T(psttl)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
        sInP.readWoLineF( tinP , psttl , 0x200 ) ; ___( psttl ) ;
        ZE( strokeS* , psttl ) ;
        //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/9") , flSAY_APPEND | flSAY_LOG ) ;
    {
    while( !*tinP.zEtScratch && !etThread )
    ZE( countT , costBody ) ;
    ZE( strokeS* , psttName ) ;
    ZE( strokeS* , psttAction ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    strokeS sttSlash( '/' ) ;
    strokeS sttQuest( '?' ) ;
    strokeS sttb( ' ' ) ;
    //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/99") , flSAY_APPEND | flSAY_LOG ) ;

    TN( tLogout , "/logout.html" ) ;
    TN( tLogin , "/login.html" ) ;
    TN( tAfterPay , "/afterpay.html" ) ;
    TN( tMe , "/me.html" ) ;
    TN( tRoster , "/roster.html" ) ;
    TN( tStatistics , "/statistics.html" ) ;
    TN( tBeforeBlabbing , "/beforeblabbing.html" ) ;
    TN( tNewBlabRoom , "/newblabroom.html" ) ;
    TN( tFingerLift , "/fingerlift.html" ) ;
    TN( tSticky , "/sticky.html" ) ;
    TN( tDisclosure , "/disclosure.html" ) ;
    TN( tNewEvent , "/newevent.html" ) ;
    TN( tCalendar , "/calendar.html" ) ;
    TN( tWarnings , "/warnings.html" ) ;
    TN( tCopyrights , "/copyrights.html" ) ;
    TN( tFileSlash , "/file/" ) ;
    TN( tBlabDot , "/blab." ) ;
    TN( tHttp11 , "http/1.1" ) ;
    TN( tLog   , "///d/log." ) ; tLog += T(DDNUMB) ;
    TN( tClose , "close" ) ;
    TN( tNumSoftKeys , "x-up-devcap-numsoftkeys" ) ;
    TN( tConnection , "connection" ) ;
    TN( tContentLength , "content-length" ) ;
    TN( tColonWhite , ": " ) ;
    //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/999") , flSAY_APPEND | flSAY_LOG ) ;

    etThread.osThreadF( tinP , countTC() , tmPeerNameF , 0 , flTHREADlAUNCH_null , 0 , (countT)pnnPeer , (countT)&bnnPeerP ) ;
    if( pnnPeer ) *pnnPeer = nicNamePeerP ;
    etThread.newF( tinP , LF , pnnPeer ) ; ___( pnnPeer ) ;
    ZE( nicNameC* , pnnPeer ) ;

    b_idhLever.ungrabF( tinP ) ;
    pSessionP = (sessionS*)(countT)swSession ;
    idhLever = nicNamePeerP ;
    b_idhLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

    { ZE( countT , idp ) ; sInP.peerNameF( tinP , idp , nicNamePeerP ) ; }
    //static countT idClient ;
    //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/9999") , flSAY_APPEND | flSAY_LOG ) ;

    countT idRequestType = ifcIDrEQtYPE_FISH ;

    PARAMS( cParmP )

    __( bHttpWoZeP ) ;
    __( bMoreP - 1 ) ;
    //etText.ifcSayF( tinP , T("readRequestF/etThread:")+TF1(etThread)+T("/etScratch:")+TF1(etScratch)+T("/99999") , flSAY_APPEND | flSAY_LOG ) ;
    //etherC& etText = etherC::etTextIF( tinP ) ;
{
countT readRequestF( tinS& tinP , etherC& etThread , boolT& bNotPaidIsOkP , socketC& sInP , boolT& bMoreP , boolT& bHttpWoZeP , countT* pcIdNameP , tableC& tblKeyValueP , stackC& std_psttP , strokeS*& psttPeerP , nicNameC& nicNamePeerP , dictionary1C& dictP , strokeS*& psttStickyNoteP , stackC& stPhrasesP , strokeS*& psttFileP , const flagsT flagsAlertP , batonC& bnnPeerP , countT& idRoomBlabP , sessionS*& pSessionP , const countT cParmP )
*/
 terminate pcIdNameP with a 0
  if     begin with '$': look up the word in the dictionary; if not found, use -1
  if not begin with '$': else        : - 1
  if not begin with '$': if <= 8 char: convert the word to a countT 
 convert each '.' delimited word to a countT value and place that value in pcIdNameP[]
 obtain the request that is either "/ " or "/aaaaaaaa.bbbbbbbb.cccccccc.<...>.zzzzzzzz.0 "
 read at least the wo'th line of the request
 captures domain name of peer
pseudocode
i evaluate to idRequestType
/*

}
    if( !etThread ) *p_bArchive = 1 ;

    etThread.etherWaitCyrcleOldF( tinP , *pNapBlab ) ;
    }
        }
            etThread.delF( tinP , postl ) ;
            if( postl ) thirdC::thirdWriteToCyrcleOldIF( tinP , *pNapBlab , postl , costl + 1 ) ;
            etThread.delF( tinP , psttl ) ;
            countT costl = etThread.strMakeF( tinP , LF , postl , T(psttl)+tc ) ; ___( postl ) ;
            ZE( osTextT* , postl ) ;
            st_psttb >> psttl ;
            ZE( strokeS* , psttl ) ;
        {
        while( st_psttb && !etThread )
        TN( tc , "\r\n" ) ;
    
        }
            etThread.delF( tinP , pstta ) ;
            while( !etThread && idf ) ;
            }
                st_psttb << psttl ;
                etThread.strSubstringLineF( tinP , psttl , idf , sttq , pstta ) ; ___( psttl ) ;
                ZE( strokeS* , psttl ) ;
            {
            do
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        
            etThread.delF( tinP , posta ) ;
            etThread.strMakeF( tinP , LF , pstta , T(posta) ) ; ___( pstta ) ;
            ZE( strokeS* , pstta ) ;
            etThread.boxGetShadowF( tinP , posta , costa , TbLABaRC( idRoomBlabP ) ) ; ___( posta ) ;
            ZE( countT , costa ) ;
            ZE( osTextT* , posta ) ;
        {
        stackC st_psttb( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE|flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    {
    if( etThread.diskFileExistsF( tinP , TbLABaRC( idRoomBlabP ) ) )

    }
        while( !pNapBlab ) { ++ s ; etThread.osSleepF( tinP , TUCK * 0x40 ) ; }
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    etThread.osThreadF( tinP , countTC() , tmBlabF , 0 , flTHREADlAUNCH_null , 0 , cParmP , idRoomBlabP , (countT)p_bArchive ) ;
    }
        inc02AM( cBlabThreads ) ;
        *p_bArchive = 0 ;
    {
    if( !etThread )

    etThread.newF( tinP , LF , p_bArchive ) ; ___( p_bArchive ) ;
    ZE( boolT* , p_bArchive ) ;

    b_idrLever.ungrabF( tinP ) ;
    napkinC*& pNapBlab = *(napkinC**)&(countT&)swPNapBlab ;

    idrLever = idRoomBlabP ;
    b_idrLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

    TELL( "preloading blab circle from archive file" ) ;
    PARAMS( cParmP )

    etThread.strokeF( tinP , T("loading ")+TF1(idRoomBlabP)+T("\r\n") ) ;
{
voidT loadBlabArchiveF( tinS& tinP , etherC& etThread , const countT idRoomBlabP , const countT cParmP )

DONE( tmBlabF )
OUT
}
    dec02AM( cBlabThreads ) ;
    etThread.delF( tinP , *(boolT**)&pTaskP->c3 ) ;
    TELL( "cleaning up" )

    etThread.etherReadFromCyrcleOldF( tinP , pNapBlab , cirBlabF , cParm , bQuitBlabbing , TbLAB( pTaskP->c2 ) , CBbLAB ) ;
U::NEED TO PASS IN A bitsC REFERENCE
    TELL( "calling etherReadFromCyrcleOldF" )

    b_idrLever.ungrabF( tinP ) ;
    napkinC*& pNapBlab = *(napkinC**)&(countT&)swPNapBlab ;
    idrLever = pTaskP->c2 ;
    b_idrLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

    countT cParm = (countT)&c3p ;
    count3S c3p( pTaskP->c1 , pTaskP->c2 , pTaskP->c3 ) ;

    PARAMS( pTaskP->c1 )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
IN_
TASK( tmBlabF )

}
    return bLoaded ;

    b_idrLever.ungrabF( tinP ) ;
    boolT bLoaded = !!(countT)swPNapBlab ;
    idrLever = idRoomP ;
    b_idrLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

    PARAMS( (countT)&c8pP )
{
boolT bIsLoadedF( tinS& tinP , count8S& c8pP , const countT idRoomP )

}
    if( ~handle ) lakeP.readCloseF( tinP , handle ) ;
    psttP = psttOldC( tinP , etThread , T(postf) ) ;
    lakeP.readF( tinP , postf , costf , handle , pcName , cSkip ) ;

    countT pcName[] = { 3 , 1 , 0 } ;
    ZE( countT   , cSkip ) ;
    ZE( countT   , costf ) ;
    ZE( osTextT* , postf ) ;
    handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FISH ) ;
{
voidT getCalendarF( tinS& tinP , etherC& etThread , strokeS*& psttP , lakeC& lakeP )

#define ifcIDrEQtYPE_FILE                     0x1c
#define ifcIDrEQtYPE_ME                       0x1b
#define ifcIDrEQtYPE_STICKY                   0x1a
#define ifcIDrEQtYPE_NEWeVENT                 0x19
#define ifcIDrEQtYPE_CALENDAR                 0x18
#define ifcIDrEQtYPE_WARNINGS                 0x17
#define ifcIDrEQtYPE_AFTERpAY                 0x16
#define ifcIDrEQtYPE_ROSTER                   0x15
#define ifcIDrEQtYPE_STATISTICS               0x14
#define ifcIDrEQtYPE_HELP6                    0x13
#define ifcIDrEQtYPE_HELP5                    0x12
#define ifcIDrEQtYPE_HELP4                    0x11
#define ifcIDrEQtYPE_HELP3                    0x10
#define ifcIDrEQtYPE_HELP2                    0xf
#define ifcIDrEQtYPE_HELP1                    0xe
#define ifcIDrEQtYPE_BEFOREbLABBING           0xd
#define ifcIDrEQtYPE_FINGERlIFT               0xc
#define ifcIDrEQtYPE_BLABrEDIRECT             0xa
#define ifcIDrEQtYPE_DISCLOSURE               9
#define ifcIDrEQtYPE_COPYRIGHTS               8
#define ifcIDrEQtYPE_BLAB                     6
#define ifcIDrEQtYPE_TINYpAGE                 5
#define ifcIDrEQtYPE_OSfIRE                   4
#define ifcIDrEQtYPE_LOGOUT                   3
#define ifcIDrEQtYPE_LOGIN                    2
#define ifcIDrEQtYPE_FISH                     1

DONE( tmEmailDataF )
}
    etThread.delF( tinP , psttKVdecoded ) ;
    etThread.delF( tinP , psttName ) ;
    etThread.delF( tinP , psttNicName ) ;
    etThread.boxPutF( tinP , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/" ifcEMAIL_OLDfROM "") , tNote ) ;
    TN( tNote , "Subject: !IFC FORM DATA\r\n\r\npage: " ) ; tNote += T("peer: ")+T(psttNicName)+T("\r\n\r\npage: ")+T(psttName)+T("\r\n\r\nKEY/VALUE PAIRS: \"")+T(psttKVdecoded)+T("\"\r\n") ;
    etThread.ifcSayF( tinP , T("a340104: ")+T(psttName)+T(" KEY/VALUE PAIRS: \"")+T(psttKVdecoded)+T("\"\r\n") , flSAY_APPEND | flSAY_LOG ) ;

    strokeS* psttNicName   = (strokeS*)pTaskP->c3 ;
    strokeS* psttKVdecoded = (strokeS*)pTaskP->c2 ;
    strokeS* psttName      = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmEmailDataF )

DONE( tmPeerNameF )
}
    etThread.delF( tinP , pnnPeer ) ;
    bnnPeer.ungrabF( tinP ) ;
    }
        etThread.delF( tinP , psttp ) ;
        else etThread.boxPutF( tinP , tFile , T(psttp) , psttp->idAdam ) ;
        }
            etThread.boxPutF( tinP , tFile , tFailed , tFailed.csF( tinP ) ) ;
            TN( tFailed , "[lookupFailed]" ) ;
            *tinP.zEtScratch = 0 ;
        {
        if( *tinP.zEtScratch || !psttp )
        tinP.zEtScratch->sockPsttHostF( tinP , psttp , *pnnPeer ) ; ___( psttp ) ;
        ZE( strokeS* , psttp ) ;
    {
    if( !etThread.diskFileExistsF( tinP , tFile ) )
    bnnPeer.grabF( tinP , TAG( TAGiDnULL ) ) ;
    TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/peers/" ) ; tFile += textC( tinP , TAG( TAGiDnULL ) , *pnnPeer , flFORMAT_FOREIGN|flFORMAT_FILLzE , 8 ) ;

    batonC&   bnnPeer =  *(batonC*)pTaskP->c2 ;
    nicNameC* pnnPeer = (nicNameC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmPeerNameF )

DONE( tmPayBirdDogsF )
}
    etThread.delF( tinP , psttPrepayCode ) ;

    etThread.delF( tinP , pstt1m ) ;
    }
        etThread.delF( tinP , psttEmail ) ;

        }
            etThread.delF( tinP , pbi ) ;
            }
                }
                    etThread.boxPutF( tinP , tFile , sJournal ) ;
                    TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/account.event/" ) ; tFile += T(psttEmail)+T("/")+TF3(timeN2,flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+td+TF3(timeN1,flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+td+TF1(tinP.osTid) ;
                    TN( td , "." ) ;
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                sJournal << (countT)timeN.time2 ; //NEW EXPIRY time2
                sJournal << timeN.time1 ; //NEW EXPIRY time1
                sJournal << (countT)0 ; //bExpired

                etThread.boxPutF( tinP , tFile , (byteT*)&timeN , sizeof timeN ) ;
                timeN.time2 = timeE2 + 1 ;
                timeN.time1 = timeE1 ;
            {
            if( timeN.time2 < timeE2 || ( timeN.time2 == timeE2 && timeN.time1 < timeE1 ) )
            sJournal << (countT)timeE2 ; //OLD time2
            sJournal << timeE1 ; //OLD time1
            sCountT& timeE2 = ((sCountT*)pbi)[ 1 ] ;
            countT&  timeE1 =  ((countT*)pbi)[ 0 ] ;
            etThread.boxGetShadowF( tinP , pbi , cbi , tFile ) ; ___( pbi ) ;
            ZE( countT , cbi ) ;
            ZE( byteT* , pbi ) ;
            sJournal << (countT)timeN.time2 ; //CURRENT time2
            sJournal << timeN.time1 ; //CURRENT time1
            sJournal << (countT)1 ; // NUMBER OF DAYS PURCHASED
            sJournal << (countT)3 ; //idType
            sJournal << (countT)1 ; //idFormat
            soulC sJournal( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( etThread.diskFileExistsF( tinP , tFile ) )
        etThread.osTimeNowF( tinP , timeN.time1 , timeN.time2 ) ;
        timeS timeN ;
        tFile += T(psttEmail) ;
        TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/resident.until/" ) ;

        etThread.strSubstringF( tinP , psttEmail , idf , sttq , tDelim , psttc1 ) ; ___( psttEmail ) ;
        etThread.delF( tinP , psttEmail ) ;
        etThread.strSubstringF( tinP , psttEmail , idf , sttq , tDelim , psttc1 ) ; ___( psttEmail ) ;
        TN( tDelim , ".$." ) ;
        countT idf = 1 ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , psttEmail ) ;
    {
    FORsTRINGSiN1( pstt1m )
    etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/prepaycode.claim/")+T(psttPrepayCode)+T(".$.*") ) ; ___( pstt1m ) ;
    ZE( strokeS* , pstt1m ) ;
    //U:: WILL ONLY CREDIT THE WOTH 0001 DOGS

    strokeS* psttPrepayCode = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmPayBirdDogsF )

}
    if( tBody.csF( tinP ) ) { etThread.strMakeF( tinP , LF , psttAlertP , tBody ) ; ___( psttAlertP ) ; }

    }
        APPENDaLERTiF( flALERT_NOpASSCODEoNfILE            , "No Passcode On File"             , "No passcode is on file for the email address that you entered.  This is normal if you have never logged in before.  If you have, and you have received a passcode via email, please contact Wo'O Ideafarm." )
        APPENDaLERTiF( flALERT_PASSCODErEJECTED            , "Passcode Rejected"               , "A passcode that differs from what you entered is on file for the email address that you entered.  If you have forgotten your passcode, please contact Wo'O Ideafarm." )
        APPENDaLERTiF( flALERT_PREPAYCODErEJECTED          , "Prepay Code Rejected"            , "The prepay code that you entered is invalid or has expired or has been exhausted.  Please contact Wo'O Ideafarm to request a prepaycode." )
        APPENDaLERTiF( flALERT_PREPAYCODEaCCEPTED2         , "Prepay Code Accepted"            , "The prepay code that you entered has been accepted." )
        APPENDaLERTiF( flALERT_PREPAYCODEaCCEPTED1         , "Prepay Code Accepted"            , "The prepay code that you entered has been accepted.  All prior users of this code will receive 1 day of additional residency.  Pass this code along to others, and you will all receive days of free residency as you help build IdeaFarm " "(tm) City!  The code will become inactive if 8 days pass without it being used." )
        APPENDaLERTiF( flALERT_BIRDdOGSpAID                , "Prior Users of Your Prepay Code" , "All prior users of the prepaycode that you just used will have time added to their residency.  You also will receive added time for each subsequent use of this code." )
        APPENDaLERTiF( flALERT_NEWpASSCODEeMAILED          , "New Passcode Emailed"            , "A passcode has been emailed to you.  It can be used immediately." )
        APPENDaLERTiF( flALERT_PLEASEsEThUMANnAME          , "Your True Name Please"           , "Your true name is needed to set up your residency properly.  IdeaFarm " "(tm) City is not a secret society; the true name and email of each resident is listed in the roster.  When residency is established using a PayPal payment, the true name is captured from the payment system.  Since you used a prepay code, this could not be done, so please email your true name to Wo'O Ideafarm." )
        APPENDaLERTiF( flALERT_RESIDENTuNTILeMAILED        , "Residency Extended Notice Sent"  , "Your residency has been extended.  An email containing details has been sent to you." )
        APPENDaLERTiF( flALERT_RESIDENCYeXPIRED            , "Residency Expired"               , "Your residency is expired.  Please contact Wo'O Ideafarm or just pay your residency tax." )
        APPENDaLERTiF( flALERT_TIMEOUT                     , "Session Timeout"                 , (osTextT*)t4 )
        APPENDaLERTiF( flALERT_NOTfOUND                    , "Page Not Found"                  , "The page that you requested is not currently available.  This can occur for several reasons.  Please retry.  If necessary, wait a tick and retry.  If the problem persists, please contact Wo'O Ideafarm <" ifcEMAIL_OLDfROM ">." )
        TN( t4    , "Your login session was terminated because it was inactive for " ) ; t4 += TF1((countT)(TIMEtIMEOUT/TICK))+T(" ticks.  This is done to prevent somewo else from impersonating you.  Please login again.") ;
        TN( t3    , "</B>: " ) ;
        TN( t2    , "<B>"    ) ;
        TN( t1    , "<P>"    ) ;
        TN( tNull , ""       ) ;
    {
    TN( tBody , "" ) ;
{
voidT psttAlertF( tinS& tinP , etherC& etThread , strokeS*& psttAlertP , const flagsT flagsAlertP )

#define APPENDaLERTiF(maskP,postBoldP,postNormalP) if( flagsAlertP & (maskP) ) tBody += (tBody.csF(tinP)?t1:tNull)+t2+T(postBoldP)+t3+T(postNormalP) ;

}
    return 0 ;
    }
        TELL( "cirBlabF: ----" )

        }
            etherP.fileWriteF( tinP , hFile , pbP , cbP - 1 ) ;
            etherP.fileSetPtrF( tinP , hFile , flSETfILEpTR_END , c2z ) ;
            count2S c2z ;
            etherP.fileOpenF( tinP , hFile , countTC() , TbLABaRC( c3p.c2 ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeO , 0x100000 ) ;
            handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
        {
        if( bArchive )
    
        //CONoUTrAW( pbP ) ;
        TELL( "cirBlabF: ++++" )
        boolT& bArchive = *(boolT*)c3p.c3 ;
        PARAMS( c3p.c1 )
        count3S& c3p = *(count3S*)cParmP ;
    {
    _IO_
{
countT cirBlabF( tinS& tinP , etherC& etherP , countT& cParmP , const byteT* const pbP , const countT cbP )

//==============================================================================================================================================================
//==== ABOVE THIS LINE: DAYTIME WORK ===========================================================================================================================
//==============================================================================================================================================================


//==============================================================================================================================================================
//==== BELOW THIS LINE: MOONLIGHT WORK =========================================================================================================================
//==============================================================================================================================================================

}
    if( ether && *tinP.zEtScratch && cArgP && c8argP.c1 && sNotesTextP && sNotesDataP && idChatSessionP ) ;

    }
        }
            break ;
            else __1
            }
                b_idhLever.ungrabF( tinP ) ;
                }
                    if( ps ) sDataP << ps->psttEmail ;
                    sessionS* ps = (sessionS*)(countT)swSession ;
                {
                else
                if( !swSession ) sDataP << (strokeS*)0 ;
                idhLever = nicNameAt ;
                b_idhLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

                sOrderP >> nicNameAt ;
                nicNameC nicNameAt ;
            {
            if( !etThread.strCompareF( tinP , psttOldCmd , T("!emailFromNicName") ) )
        {
        case 1 :
    {
    switch( idCourseP )

    sOrderP >> psttOldCmd ; ___( psttOldCmd ) ;
    ZE( strokeS* , psttOldCmd ) ;

    __( idAdamP - DDNUMB ) ;
    PARAMS( cArgP )
{
voidT jobFillCourseF( tinS& tinP , etherC& ether , etherC& etThread , soulC& sDataP , soulC& sNotesTextP , soulC& sNotesDataP , const countT idCourseP , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

//==============================================================================================================================================================
//==== ABOVE THIS LINE: MOONLIGHT WORK =========================================================================================================================
//==============================================================================================================================================================


//==============================================================================================================================================================
//==== BELOW THIS LINE: PROCESS STATE CODE =====================================================================================================================
//==============================================================================================================================================================

TRANSLATEsTATEdRIVENsERVER_END
    state.idMe ++ ;
TRANSLATEsTATEdRIVENsERVER_MIDDLE
    case 1 : { state.idMe        = stateOther.idMe        ; }
    case 2 : { state.cHamburgers = stateOther.cHamburgers ; }
TRANSLATEsTATEdRIVENsERVER_BEGIN( stateS , 2 )

;
}
    countT cHamburgers ;
    countT idMe ;
    countT idVersion ;
{
struct stateS

//==============================================================================================================================================================
//==== ABOVE THIS LINE: PROCESS STATE CODE =====================================================================================================================
//==============================================================================================================================================================

}
    timeLath2 = timeLogin2 ;
    timeLath1 = timeLogin1 ;
    etherP.osTimeNowF( tinP , timeLogin1 , timeLogin2 ) ;
{
idTimeZone( idTimeZoneP )
timeLath2( 0 ) ,
timeLath1( 0 ) ,
timeLogin2( 0 ) ,
timeLogin1( 0 ) ,
idModeStickyNote( idModeStickyNoteP ) ,
psttStickyNote( psttOldC( tinP , etherP , psttStickyNoteP?psttStickyNoteP:0 ) ) ,
psttHumanName( psttOldC( tinP , etherP , psttHumanNameP ) ) ,
psttEmail( psttOldC( tinP , etherP , psttEmailP ) ) ,
sessionS::sessionS( tinS& tinP , etherC& etherP , const strokeS* const psttEmailP , const strokeS* const psttHumanNameP , const strokeS* const psttStickyNoteP , const countT idModeStickyNoteP , const countT idTimeZoneP ) :

}
    PUSE( tinP , (voidT*)psttStickyNote ) ;
    PUSE( tinP , (voidT*)psttHumanName ) ;
    PUSE( tinP , (voidT*)psttEmail ) ;
    TINSL
{
sessionS::~sessionS( voidT )

NEWdELcLASSuSEnORMALpOOLoLD( sessionS , ifciDtYPEdROPnOTE_classDefinedInAdamDefinition2 )

}
    grab.ungrabF( tinP ) ;
{
voidT eventS::ungrabF( tinS& tinP )

}
    grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT eventS::grabF( tinS& tinP )

}
    ether.lakeFishFromPackF( tinP , lakeP , pbPack , cbPack , 0 ) ;
    __( etUsesPoolPrime ) ;
    ether.boxZapF( tinP , tShort ) ;
    etUsesPoolPrime.boxGetShadowF( tinP , pbPack , cbPack , tShort ) ; ___( pbPack ) ;

    ether.delF( tinP , psttf ) ;
    ether.boxZapF( tinP , psttf ) ;

    ether.delF( tinP , psttKTnote ) ;
    //CAN BE RETRIEVED USING URL="http://www.ideafarm.com/7.1.<idMe>.0.html"
    ether.boxPutHtmlFromKnowledgeTreeBaseF( tinP , 1 , tShort , tLong , T("myTitle") , T("myCopyright") , psttf ) ;
    TN( tLong  , WWWiDEAFARMcOM "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/packs/7.1." ) ; tLong  += TF1(idMe) ;
    TN( tShort ,                "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/packs/7.1." ) ; tShort += TF1(idMe) ;
    TN( tPack , "///ideafarm/ephemeral/domains/com/ideafarm/tmp/pack/pack." ) ; tPack += TF1(tinP.osTid) ;
    ether.delF( tinP , postKT ) ;
    ether.boxPutUniqueF( tinP , psttf , T("///ideafarm/ephemeral/domains/com/ideafarm/tmp/base/base") , postKT , costKT ) ; ___( psttf ) ;
    ZE( strokeS* , psttf ) ;

    ether.delF( tinP , psttKT ) ;
    countT costKT = ether.strMakeF( tinP , LF , postKT , psttKT ) ; ___( postKT ) ;
    ZE( osTextT* , postKT ) ;

    //ether.boxPutF( tinP , T("///d/note2.base") , T(psttKT) , psttKT?psttKT->idAdam:0 ) ;

    ether.strReverseF( tinP , psttKT , 0 , T("\r\n") , 0 , 0 , psttKTnote?psttKTnote->idAdam:0 ) ;

    //ether.strokeF( tinP , psttKT ) ;
    //ether.strokeF( tinP , T("KT:---------------------------------------------------------------------\r\n") ) ;

    ether.strFuseF( tinP , psttKT , tb+T("from west          : ")+T(psttWest) ) ;
    ether.strFuseF( tinP , psttKT , tb+T("from south         : ")+T(psttSouth)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("from east          : ")+T(psttEast)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("from north         : ")+T(psttNorth)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("status             : ")+T(psttStatus)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("duration           : ")+T(psttDuration)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("owner              : ")+T(psttOwner)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("title              : ")+T(psttTitle)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("cross street       : ")+T(psttOldCross)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("street/curbno/aptno: ")+T(psttStreet)+tbsb+T(psttOldCurbno)+tbsb+T(psttAptno)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("city               : ")+T(psttOldCity)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("metro              : ")+T(psttMetro)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("state              : ")+T(psttState)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("country            : ")+T(psttOldCountry)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("type               : ")+T(psttType)+tc ) ;
    ether.strFuseF( tinP , psttKT , tb+T("time               : ")+TT4(timeE1,timeE2,4,6)+tc ) ;
    ether.strFuseF( tinP , psttKT , T(psttKTnote)+tc ) ;
    ether.strFuseF( tinP , psttKT , T("Event In IdeaFarm " "(tm) City!\r\n") ) ; //NEVER USED, BUT WILL APPEAR AS THE WINDOW TITLE
    ether.strMakeF( tinP , LF , psttKT , T("") , 0x10000 ) ; ___( psttKT ) ;
    ZE( strokeS* , psttKT ) ;
    TN( tp , "." ) ;
    TN( tc , "\r\n" ) ;
    TN( tbsb , " / " ) ;
    TN( tb , " " ) ;

    //ether.boxPutF( tinP , T("///d/note1.base") , T(psttKTnote) , psttKTnote?psttKTnote->idAdam:0 ) ;
    ether.strReverseF( tinP , psttKTnote , 0 , T("\r\n") ) ;

    ether.delF( tinP , psttw ) ;
    ether.strReplaceF( tinP , psttKTnote , T(" ")+T(psttw) , T("\r\n.") , T("\r\n ") , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttKTnote ) ;
    ZE( strokeS* , psttKTnote ) ;

    ether.strSubstringF( tinP , psttw , idf , idl , psttNote ) ; ___( psttw ) ;
    ZE( strokeS* , psttw ) ;
    ZE( countT , idl ) ;
    countT idf = 2 ;
    __( 1 != ether.strIdF( tinP , T(".") , psttNote ) ) ;

    soulP >> psttNote ;
    soulP >> psttWest ;
    soulP >> psttSouth ;
    soulP >> psttEast ;
    soulP >> psttNorth ;
    soulP >> psttOldCross ;
    soulP >> psttAptno ;
    soulP >> psttOldCurbno ;
    soulP >> psttStreet ;
    soulP >> psttOldCity ;
    soulP >> psttMetro ;
    soulP >> psttState ;
    soulP >> psttOldCountry ;
    soulP >> psttStatus ;
    soulP >> psttTitle ;
    soulP >> psttType ;
    soulP >> psttDuration ;
    soulP >> psttOwner ;
    soulP >> *(countT*)&timeE2 ;
    soulP >> timeE1 ;
{
pcRootLink( 0 )
cbPack( 0 ) ,
pbPack( 0 ) ,
psttNote( 0 ) ,
psttWest( 0 ) ,
psttSouth( 0 ) ,
psttEast( 0 ) ,
psttNorth( 0 ) ,
psttOldCross( 0 ) ,
psttAptno( 0 ) ,
psttOldCurbno( 0 ) ,
psttStreet( 0 ) ,
psttOldCity( 0 ) ,
psttMetro( 0 ) ,
psttState( 0 ) ,
psttOldCountry( 0 ) ,
psttStatus( 0 ) ,
psttTitle( 0 ) ,
psttType( 0 ) ,
psttDuration( 0 ) ,
psttOwner( 0 ) ,
timeE2( 0 ) ,
timeE1( 0 ) ,
idMe( idMeP ) ,
grab( tinP , TAG( TAGiDnULL ) ) ,
etUsesPoolPrime( etUsesPoolPrimeP ) ,
ether( etherP ) ,
eventS::eventS( tinS& tinP , etherC& etherP , etherC& etUsesPoolPrimeP , lakeC& lakeP , soulC& soulP , const countT idMeP ) :

}
    etUsesPoolPrime.delF( tinP , pbPack ) ;
    ether.delF( tinP , psttNote ) ;
    ether.delF( tinP , psttWest ) ;
    ether.delF( tinP , psttSouth ) ;
    ether.delF( tinP , psttEast ) ;
    ether.delF( tinP , psttNorth ) ;
    ether.delF( tinP , psttOldCross ) ;
    ether.delF( tinP , psttAptno ) ;
    ether.delF( tinP , psttOldCurbno ) ;
    ether.delF( tinP , psttStreet ) ;
    ether.delF( tinP , psttOldCity ) ;
    ether.delF( tinP , psttMetro ) ;
    ether.delF( tinP , psttState ) ;
    ether.delF( tinP , psttOldCountry ) ;
    ether.delF( tinP , psttStatus ) ;
    ether.delF( tinP , psttTitle ) ;
    ether.delF( tinP , psttType ) ;
    ether.delF( tinP , psttDuration ) ;
    ether.delF( tinP , psttOwner ) ;
    TINSL
{
eventS::~eventS( voidT )

NEWdELcLASSb( eventS )

batonC* eventS::pBatClass ;

;
}
    sessionS( tinS& tinP , etherC& etherP , const strokeS* const psttEmailP , const strokeS* const psttHumanNameP , const strokeS* const psttStickyNoteP , const countT idModeStickyNoteP , const countT idTimeZoneP ) ;
    ~sessionS( voidT ) ;
    NEWdELcLASSpROTOS( sessionS , etherC , thirdC )

    countT   idTimeZone ;
    //PREFERENCES

    countT   idModeStickyNote ;
    strokeS* psttStickyNote ;
    strokeS* psttHumanName ;
    strokeS* psttEmail ;

    sCountT  timeLath2 ;
    countT   timeLath1 ;
    sCountT  timeLogin2 ;
    countT   timeLogin1 ;
{
struct sessionS
*/
session management is integrated with the port.05 server because sessions are begun and ended using a port.05 client
all state information for each host session is kept in wo sessionS object
each logged in interval is called a host session
each host is either logged in or logged out
/*

;
}
    voidT ungrabF( tinS& tinP ) ;
    voidT grabF( tinS& tinP ) ;
    eventS( tinS& tinP , etherC& etherP , etherC& etUsesPoolPrimeP , lakeC& lakeP , soulC& soulP , const countT idMeP ) ;
    ~eventS( voidT ) ;
    NEWdELcLASSpROTOS( eventS , etherC , thirdC )

    countT*  pcRootLink ;
    countT   cbPack ;
    byteT*   pbPack ;
    strokeS* psttNote ;
    strokeS* psttWest ;
    strokeS* psttSouth ;
    strokeS* psttEast ;
    strokeS* psttNorth ;
    strokeS* psttOldCross ;
    strokeS* psttAptno ;
    strokeS* psttOldCurbno ;
    strokeS* psttStreet ;
    strokeS* psttOldCity ;
    strokeS* psttMetro ;
    strokeS* psttState ;
    strokeS* psttOldCountry ;
    strokeS* psttStatus ;
    strokeS* psttTitle ;
    strokeS* psttType ;
    strokeS* psttDuration ;
    strokeS* psttOwner ;
    sCountT  timeE2 ;
    countT   timeE1 ;

    countT  idMe ;

    public :

    grabS         grab ;
    etherC&       etUsesPoolPrime ;
    etherC&       ether ;

    private :

    static batonC* pBatClass ;
{
struct eventS
*/
 loading of the html kt pack into the lake
 conversion of the kt base string into a html kt pack
 conversion of strokeS* string data to numeric values
value added includes
these objects must be kept coherent with their backing files
each object caches information implied by the backing disk file
/*

    batonC&       bFileStats                 =       *(batonC*)c8p6.c5 ;
    batonC&       bNewBlabRoom               =       *(batonC*)c8p6.c4 ;                                                               \
    countT&       cBlabThreads               =       *(countT*)c8p6.c3 ;                                                               \
    boolT&        bQuitBlabbing              =        *(boolT*)c8p6.c2 ;                                                               \
    batonC&       bnnPeer                    =       *(batonC*)c8p5.c8 ;                                                               \
    etherC&       etUsesPoolPrime            =       *(etherC*)c8p5.c7 ;                                                               \
    stackC&       stEvent                    =       *(stackC*)c8p5.c6 ;                                                               \
    batonC&       bLogin                     =       *(batonC*)c8p5.c5 ;                                                               \
    ranUniC&      ru                         =      *(ranUniC*)c8p5.c4 ;                                                               \
    switchC&      swPNapBlab                 =      *(switchC*)c8p5.c1 ;                                                               \
    countT&       idrLever                   =       *(countT*)c8p4.c8 ;                                                               \
    batonC&       b_idrLever                 =       *(batonC*)c8p4.c7 ;                                                               \
    stackC&       stNnPrivate2B              =       *(stackC*)c8p4.c6 ;                                                               \
    stackC&       stNnPrivate2A              =       *(stackC*)c8p4.c5 ;                                                               \
    stackC&       stNnPrivate1B              =       *(stackC*)c8p4.c4 ;                                                               \
    stackC&       stNnPrivate1A              =       *(stackC*)c8p4.c3 ;                                                               \
    strokeS**     ppsttQOD                   =      (strokeS**)c8p3.c8 ;                                                               \
    strokeS**     ppsttDOS                   =      (strokeS**)c8p3.c7 ;                                                               \
    strokeS**     ppsttSOQ                   =      (strokeS**)c8p3.c6 ;                                                               \
    switchC&      swSession                  =      *(switchC*)c8p2.c1 ;                                                               \
    batonC&       b_idhLever                 =       *(batonC*)c8p1.c8 ;                                                               \
    nicNameC&     idhLever                   =     *(nicNameC*)c8p1.c7 ;                                                               \
    lakeC&        lake                       =        *(lakeC*)c8p1.c6 ;                                                               \
    dictionary1C&  dict                       =  *(dictionary1C*)c8p1.c3 ;                                                               \
    batonC&       b_pbdVarying               =       *(batonC*)c8p1.c2 ;                                                               \
    byteT*&       pbdVarying                 =       *(byteT**)c8p1.c1 ;                                                               \
                                                                                                                                       \
    count8S&      c8p7                       =      *(count8S*)c8p.c7 ;                                                                \
    count8S&      c8p6                       =      *(count8S*)c8p.c6 ;                                                                \
    count8S&      c8p5                       =      *(count8S*)c8p.c5 ;                                                                \
    count8S&      c8p4                       =      *(count8S*)c8p.c4 ;                                                                \
    count8S&      c8p3                       =      *(count8S*)c8p.c3 ;                                                                \
    count8S&      c8p2                       =      *(count8S*)c8p.c2 ;                                                                \
    count8S&      c8p1                       =      *(count8S*)c8p.c1 ;                                                                \
    count8S&      c8p                        =      *(count8S*)cArgP ;                                                                 \
                                                                                                                                       \
#define PARAMS(cArgP)                                                                                                                  \

#define fliSESSION_ENDED      0x00000002
#define fliSESSION_CONFIRMED  0x00000001

#define TbLABaRC(idRoomBlabP) T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(DDNUMB)+T("/arc.blab.")+(idRoomBlabP?TF1(idRoomBlabP):T("*"))
#define CBbLAB 0x10000
#define TbLAB(idRoomBlabP) T("napBlab.")+TF1(idRoomBlabP)
#define CCiDnAMEmAX 0x10
#define COSTiN 0x1000
#define CsLOTpSO 0x4

    }
        etThread.delF( tinP , postr ) ;                                                                                    \
        if( bHttpWoZe ) postr[ 7 ] = '1' ;                                                                                  \
        pso->writeF( tinP , postr , costr ) ;                                                                              \
        if( bHttpWoZe ) postr[ 7 ] = '0' ;                                                                                  \
                                                                                                                            \
        }                                                                                                                   \
            ___( postr ) ;                                                                                                 \
            costr = etThread.strMakeF( tinP , LF , postr , TEXThTTPhEADERrEDIRECT(0,tUrlP) ) ;                                   \
            TN( tHtml , "" ) ; tHtml = TEXThTMLhEADER( _tTitle ) + TEXThTMLbODYpREFIX + tBodyP + TEXThTMLbODYsUFFIX ; */     \
            ZE( strokeS* , psttAlert ) ;                                                                                  \
            /* TN( _tTitle , "" ) ; _tTitle = tTitleP ;                                                                       \
        {                                                                                                                   \
        ZE( countT   , costr ) ;                                                                                         \
        ZE( osTextT* , postr ) ;                                                                                         \
    {                                                                                                                       \
                                                                                                                            \
#define REPLYrEDIRECT(tUrlP,tTitleP,tBodyP)                                                                                 \

    }
        etThread.delF( tinP , postr ) ;                                                                                    \
        if( bHttpWoZe ) postr[ 7 ] = '1' ;                                                                                  \
        pso->writeF( tinP , postr , costr ) ;                                                                              \
        if( bHttpWoZe ) postr[ 7 ] = '0' ;                                                                                  \
                                                                                                                            \
        }                                                                                                                   \
            ___( postr ) ;                                                                                                 \
            costr = etThread.strMakeF( tinP , LF , postr , TEXThTTPhEADER(tHtml.csF(tinP)) + tHtml ) ;                           \
            etThread.delF( tinP , psttAlert ) ;                                                                             \
            TN( tHtml , "" ) ; tHtml = TEXThTMLhEADER( _tTitle ) + TEXThTMLbODYpREFIX + tBodyP + TEXThTMLbODYsUFFIX ;        \
            psttAlertF( tinP , etThread , psttAlert , flagsAlert ) ;                                                        \
            ZE( strokeS* , psttAlert ) ;                                                                                  \
            TN( _tTitle , "" ) ; _tTitle = tTitleP ;                                                                          \
        {                                                                                                                   \
        ZE( countT   , costr ) ;                                                                                         \
        ZE( osTextT* , postr ) ;                                                                                         \
    {                                                                                                                       \
                                                                                                                            \
#define REPLY(tTitleP,tBodyP)                                                                                               \

    "note immediately to the \"abuse\" or \"fraud\" address listed below.\r\n"
    "If you suspect that someone else is entering your email address in order to harass you or to defraud you, please forward this\r\n"      \
    "\r\n"                                                                                                                                   \
    "web page.  If you did not do this, or if you would like to cancel your login, do -not- reply to this note.\r\n"                         \
    "You received this note because your email address was entered, presumably by you, at the top of the http://www.ideafarm.com\r\n"        \
    "\r\n"                                                                                                                                   \
    "you will be allowed to pass through the gate, into the city.\r\n"                                                                       \
    "Please click the \"Reply\" button to complete your login at the gate of IdeaFarm " "(tm) City.  As soon as your reply is received,\r\n"    \
                                                                                                                                             \
#define postEMAILsECTIONbODY_4_EXPLANATION                                                                                                   \

    "(b) To complete your log in, click \"Reply\".\r\n"
    "\r\n"                                                                                                                                   \
    "(a) If you did not expect to receive this, DO NOT REPLY.\r\n"                                                                           \
    "\r\n"                                                                                                                                   \
    "Do either (a) -or- (b): \r\n"                                                                                                           \
                                                                                                                                             \
#define postEMAILsECTIONbODY_3_INSTRUCTIONS                                                                                                  \

    "</HEAD>\r\n")
    (tTitleP)+T(USCORE79 USCORE79)+T("</TITLE>\r\n"                                                                         \
    T(pSession?")____":"____")+                                                                                             \
    (pSession?T(timeZoneSpecF(tinP,pSession->idTimeZone).postShort):T(""))+                                                 \
    T(pSession?" in IdeaFarm " "(tm) City (":"")+                                                                              \
    T(pSession?pSession->psttHumanName:(idRequestType==ifcIDrEQtYPE_LOGOUT?psttGoodBye:psttLogInNow))+                      \
    "<TITLE>")+                                                                                                             \
    "<HEAD>\r\n"                                                                                                            \
    "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\r\n"                                                              \
    T("<!-- ")+TF3((tTitleP).csF(tinP),flFORMAT_FILLzE,8)+T(" -->\r\n"                                                    \
    /*THE LEADING 4 STROKES CAUSE 4 BYTES TO BE RESERVED IN THE HTML FILE FOR A countT VALUE*/                              \
                                                                                                                            \
#define TEXThTMLhEADER(tTitleP)                                                                                             \

    "\r\n")
    /*"Content-Length: 0\r\n"*/                                                                                             \
    "Location: ")+tUrlP+T("\r\n"                                                                                            \
    T("HTTP/1.1 302 See Other\r\n"                                                                                          \
                                                                                                                            \
#define TEXThTTPhEADERrEDIRECT(cbBodyP,tUrlP)                                                                               \

    (psttAlert?T("</PRE>")+T(psttAlert)+T("<P><HR><PRE>"):T(""))
    )+                                                                                                                      \
            : T("")                                                                                                         \
            )                                                                                                               \
                    : T("")                                                                                                 \
                    ? T("<FORM METHOD=GET><INPUT TYPE=text SIZE=128 NAME=stickynote VALUE=\"")+T(pSession->psttStickyNote)+T("\"></FORM>") \
                pSession->idModeStickyNote == 3                                                                             \
            ? (                                                                                                             \
        pSession                                                                                                            \
    )+(                                                                                                                     \
    "<HR>"                                                                                                                  \
    "<HR>chat rooms: <A HREF=\"blab.4.html\">orchidsAndOnions</A>  <A HREF=\"blab.3.html\">governorsOffice</A>  <A HREF=\"blab.1.html\">open</A>  <A HREF=\"blab.0011.html\">residentsOnly</A>  <A HREF=\"blab.0021.html\">myTimeZone</A>\r\n" \
    "<A HREF=\"copyrights.html\">copyrights</A>  <A HREF=\"disclosure.html\">disclosure</A>  <A HREF=\"1.74.0.html\">purchase</A>  <A HREF=\"statistics.html\">statistics</A>  <A HREF=\"1.44.0.html\">community</A>  <A HREF=\"1.54.0.html\">work</A>  <A HREF=\"sticky.html\">sticky</A>\r\n" \
    "<HR><A HREF=\"/\">home</A>  <A HREF=\"warnings.html\">warnings</A>  <A HREF=\"log")+tInOut+T(".html\">log")+tInOut+T("</A>  <A HREF=\"roster.html\">roster</A>  <A HREF=\"me.html\">me</A>  <A HREF=\"fingerlift.html\">fingerLift</A>  <A HREF=\"1.84.0.html\">taCommandments</A>  <A HREF=\"1.64.0.html\">song</A>  <A HREF=\"calendar.html\">calendar</A>\r\n" \
    "IdeaFarm " "(tm) City - Federal Constitutional Protectorate of the United States of America\r\n"                          \
    T("<HR>Freedom    Profit    Strength    Sustainability    Family    Equality    Truth     Jesus\r\n"                    \
    )+                                                                                                                      \
            : T("")                                                                                                         \
            )                                                                                                               \
                    : T("")                                                                                                 \
                    ? T("<FORM METHOD=GET><INPUT TYPE=text SIZE=128 NAME=stickynote VALUE=\"")+T(pSession->psttStickyNote)+T("\"></FORM>") \
                pSession->idModeStickyNote == 2                                                                             \
            ? (                                                                                                             \
        pSession                                                                                                            \
    )+(                                                                                                                     \
    "<BODY><PRE>"                                                                                                           \
    T(                                                                                                                      \
                                                                                                                            \
#define TEXThTMLbODYpREFIX                                                                                                  \

    T("</BODY>")
    )+                                                                                                                      \
            : T("")                                                                                                         \
            )                                                                                                               \
                    : T("")                                                                                                 \
                    ? T("<FORM METHOD=GET><INPUT TYPE=text SIZE=128 NAME=stickynote VALUE=\"")+T(pSession->psttStickyNote)+T("\"></FORM>") \
                pSession->idModeStickyNote == 4                                                                             \
            ? (                                                                                                             \
        pSession                                                                                                            \
    )+(                                                                                                                     \
    T("</PRE>"                                                                                                              \
                                                                                                                            \
#define TEXThTMLbODYsUFFIX                                                                                                  \

    "\r\n")
    "Content-Length: ")+TF4(cbBodyP,flFORMAT_FILLzE|flFORMAT_NObASE|flFORMAT_FOREIGN,8,0xa)+T("\r\n"                      \
    "Content-Type: text/html\r\n"                                                                                           \
    "Pragma: no-cache\r\n"                                                                                                  \
    "Cache-Control: no-cache\r\n"                                                                                           \
    T("HTTP/1.1 200 OK\r\n"                                                                                                 \
                                                                                                                            \
#define TEXThTTPhEADER(cbBodyP)                                                                                             \

#define TIMEtIMEOUT ( TICK * 0x10 )

    }
        etThread.osThreadF( tinP , countTC() , tmSendEmailF , 0 , flTHREADlAUNCH_null , 0 , (countT)psttFile , (countT)psttBody ) ; \
                                                                                                                                    \
        strokeS* psttBody  = psttOldC( tinP , etThread , psttBodyP ) ;                                                                 \
        strokeS* psttFile  = psttOldC( tinP , etThread , psttFileP ) ;                                                                 \
        strokeS* psttBodyP = tBody ;                                                                                                \
        strokeS* psttFileP = tFile ;                                                                                                \
        TN( tBody , "" ) ; tBody = tBodyP ;                                                                                         \
        TN( tFile , "" ) ; tFile = tFileP ;                                                                                         \
    {                                                                                                                               \
                                                                                                                                    \
#define SENDmAIL(tFileP,tBodyP)                                                                                                     \

    }
        if( psttv && psttv->idAdam ) tValP = T(psttv) ;                                 \
        /*etThread.strokeF( tinP , T("kv: \"")+tKeyP+T("\": \"")+T(psttv)+T("\"\r\n") ) ;*/ \
        strokeS* psttv = tblKeyValue._CT1_07F( idr , 2 ) ;                              \
    {                                                                                   \
    else if( !etThread.strCompareF( tinP , tKeyP , tblKeyValue._CT1_07F( idr , 1 ) ) )  \
                                                                                        \
#define SETvAR(tKeyP,tValP)                                                             \

//#define flALERT_                        0x80000000
//#define flALERT_                        0x40000000
//#define flALERT_                        0x20000000
//#define flALERT_                        0x10000000
//#define flALERT_                        0x08000000
//#define flALERT_                        0x04000000
//#define flALERT_                        0x02000000
//#define flALERT_                        0x01000000
//#define flALERT_                        0x00800000
//#define flALERT_                        0x00400000
//#define flALERT_                        0x00200000
//#define flALERT_                        0x00100000
//#define flALERT_                        0x00080000
//#define flALERT_                        0x00040000
//#define flALERT_                        0x00020000
//#define flALERT_                        0x00010000
//#define flALERT_                        0x00008000
//#define flALERT_                        0x00004000
//#define flALERT_                        0x00002000
//#define flALERT_                        0x00001000
//#define flALERT_                        0x00000800
#define flALERT_NOpASSCODEoNfILE            0x00000800
#define flALERT_PASSCODErEJECTED            0x00000400
#define flALERT_PREPAYCODErEJECTED          0x00000200
#define flALERT_PREPAYCODEaCCEPTED2         0x00000100
#define flALERT_PREPAYCODEaCCEPTED1         0x00000080
#define flALERT_BIRDdOGSpAID                0x00000040
#define flALERT_NEWpASSCODEeMAILED          0x00000020
#define flALERT_PLEASEsEThUMANnAME          0x00000010
#define flALERT_RESIDENTuNTILeMAILED        0x00000008
#define flALERT_RESIDENCYeXPIRED            0x00000004
#define flALERT_TIMEOUT                     0x00000002
#define flALERT_NOTfOUND                    0x00000001
#define flALERT_null                        0x00000000
//CODEsYNCH: a340104 a340104

/*1*/WAKEhIDE( "port.05.http" )/*1*/
/**/
*/
\<A HREF=\"5.a340104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

