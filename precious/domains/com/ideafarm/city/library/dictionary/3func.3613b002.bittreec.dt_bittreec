
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_
    dtF( tinP ) ;
    _INoLD_
    TINSL
{
/*1*/bitTreeC::~bitTreeC( voidT )/*1*/


    }
        }                                                                                                                               \
            tinP.pEther->traceF( tinP , tSay ) ;                                                                                        \
            }                                                                                                                           \
                tSay += T(*pbc&mask?"1":"0") ;                                                                                          \
                                                                                                                                        \
                byteT  mask   = (byteT)( 1 << offBB ) ;                                                                                 \
                countT offBB  =               offb % SB  ;      /* "offBB" : "offset of bit in byte"    */                              \
                byteT* pbc    = pp.pbBuffer + offb / SB  ;                                                                              \
            {                                                                                                                           \
            for( countT offb = 0 ; offb < pp.offBit ; offb ++ )                                                                         \
            TN( tSay , "" ) ;                                                                                                           \
                                                                                                                                        \
            /* DISPLAY THE WOTH offBitP BITS IN pbBufferP */                                                                            \
        {                                                                                                                               \
        else                                                                                                                            \
        }                                                                                                                               \
            (*pp.pCBF)( tinP , ( !pp.pcDatum ? cnu : *pp.pcDatum ) , *pp.pcArg ) ; /* pcArg == 0 IS ALLOWED */                          \
            ZE( countT , cnu ) ;                                                                                                        \
        {                                                                                                                               \
        if( pp.pCBF )                                                                                                                   \
    {                                                                                                                                   \
    if( !cKidsDone )                                                                                                                    \
                                                                                                                                        \
#define REPORT                                                                                                                          \

#define UP(zwP) BhIDE( BM_HIGH , PtHIS->p##zwP )

#define ESCAPE ( BkEEP( BM_HIGH , PtHIS->p1 ) )

#define COMPLETEnAME ( BkEEP( BM_HIGH , PtHIS->p0 ) )

#define PtHIS ( pbRawBegin ? pp.pThis : !pp.idThis ? (bitNodeS*)0 : ( (bitNodeS*)(const byteT*)(*pNapkins)[ - 1 + pp.idThis ] ) )

#define OFFlEVEL ( (countT)*pp.pstThis )

    }
        *pp.pstKidsDone >> cnu ;                                                                        \
        ZE( countT , cnu ) ;                                                                            \
                                                                                                        \
        }                                                                                               \
            *pp.pstThis >> pp.idThis ;                                                                  \
            pp.idThis = 0 ;                                                                             \
        {                                                                                               \
        else                                                                                            \
        }                                                                                               \
            *pp.pstThis >> *(countT*)&pp.pThis ;                                                        \
            pp.pThis = 0 ;                                                                              \
        {                                                                                               \
        if( pbRawBegin )                                                                                \
    {                                                                                                   \
                                                                                                        \
#define UNCLIMB                                                                                         \

    }
        else             pp.idThis =            BhIDE( BM_HIGH , PtHIS->p##zwP ) ;                      \
        if( pbRawBegin ) pp.pThis  = (bitNodeS*)BhIDE( BM_HIGH , PtHIS->p##zwP ) ;                      \
                                                                                                        \
        *pp.pstKidsDone << (countT)0 ;                                                                  \
                                                                                                        \
        ) ;                                                                                             \
                : pp.idThis                                                                             \
                ? (countT)pp.pThis                                                                      \
            pbRawBegin                                                                                  \
        (                                                                                               \
        *pp.pstThis <<                                                                                  \
    {                                                                                                   \
                                                                                                        \
#define CLIMB(zwP)                                                                                      \


    }
        pp.offBit ++ ;                                                      \
        *pbc |= mask ;                                                      \
        byteT  mask  = (byteT)( 1 << offBB )  ;                             \
        countT offBB =               pp.offBit % SB ;                       \
        byteT* pbc   = pp.pbBuffer + pp.offBit / SB ;                       \
    {                                                                       \
                                                                            \
#define SETbUFFERbIT                                                        \

    }
        pp.offBit ++ ;                                                      \
        *pbc &= ~mask ;                                                     \
        byteT  mask  = (byteT)( 1 << offBB )  ;                             \
        countT offBB =               pp.offBit % SB ;                       \
        byteT* pbc   = pp.pbBuffer + pp.offBit / SB ;                       \
    {                                                                       \
                                                                            \
#define RESETbUFFERbIT                                                      \

    }
        *pbc &= ~mask ;                                                     \
        byteT  mask  = (byteT)( 1 << offBB )  ;                             \
        countT offBB =               pp.offBit % SB ;                       \
        byteT* pbc   = pp.pbBuffer + pp.offBit / SB ;                       \
        pp.offBit -- ;                                                      \
    {                                                                       \
                                                                            \
#define ERASEbUFFERbIT                                                      \

// THESE DEFINES ARE ONLY FOR THE bitTreeC MODULE AND MUST BE UNDEFINED AT THE END OF THE LATH DEFINITION

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

