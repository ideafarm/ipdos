
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        delF( tinP , psttOutP ) ;_WQ
        ___( psttOutP ) ;_WQ
        *pSoulP << psttOutP ;_WQ
    {
    if( pSoulP && *pSoulP ) // EVEN IF I AM NOT THE WO WHO PUSHED THE CONTENT

    while( psttic < psttie ) ;_WQ
    }
        if( !psttic ) break ;

        }
            }
                psttoe = psttoc   + cstta    ;_WQ
                psttoc = psttOutP + CSpREFIX ;_WQ
                SETpREFIX( psttOutP , 0 , cstta )
            {
            if( !POOP )
            __Z( psttOutP ) ;_WQ
            POSTPONEtEST( psttOutP ) ;_WQ
            third.newF( tinP , LF , psttOutP , CSpREFIX + cstta ) ; //CALLER MUST TAG ___( psttOutP ) ;_WQ

            ;_WQ
                    : CSTTsOULfUSEdEFAULT
                    ? csttExtraP
                : csttExtraP
                    : csttExtraP
                    ? CSpREFIX + psttie - psttic + csttPrefixNullsP + csttSuffixNullsP + csttExtraP
                ? psttic
            countT cstta = !pSoulP
        {
        if( !psttOutP )
        // ALLOCATE AN OUTPUT STRING (ALWAYS DONE, EVEN IF NO INPUT

        }
            }
                psttoe = psttoc = 0 ;_WQ
                delF( tinP , psttOutP ) ;_WQ
                ___( psttOutP ) ;_WQ
                if( pGrabP ) pGrabP->ungrabF( tinP ) ;_WQ
                *pSoulP << psttOutP ;_WQ
                if( pGrabP ) pGrabP->grabF( tinP , TAG( TAGiDnULL ) ) ;_WQ
            {
            else
            }
                break ;
                __1 ;_WQ
            {
            if( !pSoulP )
        {
        )
            )
                csttSuffixNullsP
                ||
                ( psttic && psttic < psttie )
                ||
                csttPrefixNullsP
            (
            &&
            psttoc
        (
        if                               // IF HAVE OUTPUT AND STILL HAVE MORE INPUT TO PROCESS
        // MOVE OUTPUT TO FIFO SOUL

        }
            }
                else                        { __1 }
                else if( csttSuffixNullsP ) { csttSuffixNullsP -- ; *( psttoc ++ ) = sttn           ; }
                else if( psttic < psttie  )                         *( psttoc ++ ) = *( psttic ++ ) ;
                     if( csttPrefixNullsP ) { csttPrefixNullsP -- ; *( psttoc ++ ) = sttn           ; }
            {
            while( cDo -- )

            psttOutP[ 0 ].idAdam += cDo ;_WQ
            psttOutP[ 2 ].idAdam -= cDo ;_WQ

            ;_WQ
                : co
                ? ci
            countT cDo = ci < co
            countT ci = psttie - psttic + csttPrefixNullsP + csttSuffixNullsP ;_WQ
            countT co = psttoe - psttoc ;_WQ
            // APPEND THE STRING BODY

            cToDoPrefix          -= csttAte ;_WQ
            psttOutP[ 2 ].idAdam -= csttAte ;_WQ
            psttOutP->idAdam     += csttAte ;_WQ
            psttoc               += csttAte ;_WQ
            SETpREFIXpARTIALmIDDLE( csttAte , psttoc , csttBody , 0 , psttoe - psttoc , CSpREFIX - cToDoPrefix )
            ZE( countT , csttAte ) ;_WQ
            // APPEND THE STRING PREFIX
        {
        if( psttoc && psttic )
        // FILL UP THE OUTPUT STRING
    {
    do

    strokeS sttn( (countT)0 , sc_NULL ) ;_WQ

    strokeS*       psttoe = !psttoc   ? 0 : psttoc              + psttOutP[ 2 ].idAdam ;_WQ
    strokeS*       psttoc = !psttOutP ? 0 : psttOutP + CSpREFIX + psttOutP->idAdam ;_WQ
    const strokeS* psttie = !psttic   ? 0 : psttic              + psttInP->idAdam ;_WQ
    const strokeS* psttic = !psttInP  ? 0 : psttInP  + CSpREFIX ;_WQ

    const countT csttBody = csttPrefixNullsP + psttInP->idAdam + csttSuffixNullsP ;_WQ
    countT cToDoPrefix = CSpREFIX ;_WQ

    _INoLD_

    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{

/*1*/voidT etherC::strFuseSeparateF( tinS& tinP , strokeS*& psttOutP , const strokeS* const psttInP , countT csttPrefixNullsP , countT csttSuffixNullsP , soulC* pSoulP , grabC* pGrabP , const countT csttExtraP )/*1*/

/**/
*/
  if not 0 then *pGrabP will be grabbed when *pSoulP is being accessed
  can be 0
 pGrabP
  the result will either be in psttOutP or in *pSoulP
  if not 0 then *pSoulP will be used as a fifo buffer to store the result
  if 0 then psttOutP must either be 0 or contain enough room for the result to be appended
  can be 0
 pSoulP
  each word in pstt1P will be suffixed with this many nulls
 csttSuffixNullsP
  each word in pstt1P will be prefixed with this many nulls
 csttPrefixNullsP
 csttExtraP
 psttInP
 psttOutP
arguments
U: enforce the usage of csttExtraP
 this was causing memory overwrites, so cExtra in the internal prefixes is now 0
U:: NO LONGER TRUE: in the internal prefixes, cExtra = - 1
use FORsTRINGSiN1, possibly nested, to process strings of strings
any level of nesting is possible
use this to build strings of strings
like strFuseF except that the prefix at the beginning of psttInP is retained
  \<A HREF=\"5.fa10104.1.1.0.html\"\>fa10104:  WAKEsHOW( "example.simplest.func.10300be.etherC.strFuseSeparateF" )\</A\>
  \<A HREF=\"5.0b10104.1.1.0.html\"\>0b10104:  WAKEsHOW( "example.simplest.func.10300be.etherC.strFuseSeparateF" )\</A\>
 simplest
examples
\<A HREF=\"5.10300be.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strFuseSeparateF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

