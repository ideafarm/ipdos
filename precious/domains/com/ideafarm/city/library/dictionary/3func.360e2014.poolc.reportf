
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_
    }
        walkF( tinP , slotsWalkTallyCBF , cArg ) ;
        countT cArg = (countT)pcArg ;
        countT pcArg[] = { (countT)&pczLeverP , (countT)&swTallyP } ;
    {
    if( tinP.pEther )
    _INoLD_

    }
        if( POOP ) return ;
        __( swTallyP.cbDataF() - 4 * sizeof( countT ) ) ;
        __Z( tinP.pEther ) ; // *tinP.pEther RATHER THAN A  etherC& PARAMETER IS USED SO THAT IN THE FUTURE I CAN DO SOMETHING USEFUL WHEN NO INSTANCE OF etherC EXISTS
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT poolC::reportF( tinS& tinP , const countT*& pczLeverP , switchC& swTallyP )/*1*/

}
    }
        }
            }
                }
                    if( !pcTally[ 3 ] ) pcTally[ 3 ] = pcTally[ 2 ] = -1 ;
                    pcTally[ 1 ] += cbSlot ;
                    pcTally[ 0 ] ++ ;

                    countT* pcTally = &(countT&)swTallyP ;

                    pczLeverP = pczLever ;
                    countT pczLever[] = { -1 , -1 , cbSlot , cSlots , 0 } ;
                {
                else                                            // IF SLOT IS NOT OWNED (AVAILABLE)
                }
                    if(                  pcTally[ 3 ] < cbSlot ) pcTally[ 3 ] = cbSlot ;        // MAXIMUM SLOT SIZE
                    if( !pcTally[ 2 ] || pcTally[ 2 ] > cbSlot ) pcTally[ 2 ] = cbSlot ;        // MINIMUM SLOT SIZE
                    pcTally[ 1 ] += cbSlot ;
                    pcTally[ 0 ] ++ ;

                    countT* pcTally = &(countT&)swTallyP ;

                    pczLeverP = pczLever ;
                    countT pczLever[] = { pn->idiFileTagged , pn->idLineTagged , pn->idiFileTagged2 , pn->idLineTagged2 , 0 } ;

                    const dropNoteS* pn = pNotesP + offb ;
                {
                if( pbBitsOwnedP[ offByte ] >> offBit & 1 )     // IF SLOT IS OWNED (IN USE)

                countT offBit  = offb % SB ;
                countT offByte = offb / SB ;
            {
            for( countT offb = 0 ; offb < cSlots ; offb ++ )

            countT cbSlot = 1 << pHeadP->expCbSlot ;
        {
        //if( cFound )

        //}
        //    if( pbBitsOwnedP[ offByte ] >> offBit & 1 ) cFound ++ ;
        //
        //    countT offBit  = offb % SB ;
        //    countT offByte = offb / SB ;
        //{
        //for( countT offb = 0 ; offb < cSlots ; offb ++ )
        //ZE( countT , cFound ) ;
        countT cSlots = 1 << pHeadP->expSlots ;

        switchC& swTallyP  = *(switchC*)pcArgP[ 1 ] ;
        countT*& pczLeverP = *(countT**)pcArgP[ 0 ] ;
        countT*  pcArgP    = (countT*)cArgP ;
    {
    if( tinP.pEther && cArgP && pNotesP )
{
voidT slotsWalkTallyCBF( tinS& tinP , countT& cArgP , const sexHeadS* pHeadP , const byteT* pbBitsOwnedP , const dropNoteS* pNotesP , const byteT* pbDataP )

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

