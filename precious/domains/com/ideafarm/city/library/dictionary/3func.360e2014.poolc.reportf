
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    walkF( tinP , slotsWalkTallyCBF , cArg ) ;
    countT cArg = (countT)pcArg ;
    countT pcArg[] = { (countT)&etherP , (countT)&pczLeverP , (countT)&swTallyP } ;
    _IO_

    }
        if( POOP ) return ;
        __( swTallyP.cbDataF() - 4 * sizeof( countT ) ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT poolC::reportF( tinS& tinP , etherC& etherP , const countT*& pczLeverP , switchC& swTallyP )/*1*/

}
    }
        }
            }
                }
                    if( !pcTally[ 3 ] ) pcTally[ 3 ] = pcTally[ 2 ] = -1 ;
                    pcTally[ 1 ] += cbSlot ;
                    pcTally[ 0 ] ++ ;

                    countT* pcTally = &(countT&)swTallyP ;

                    pczLeverP = pczLever ;
                    countT pczLever[] = { -1 , -1 , cbSlot , cSlots , 0 } ;
                {
                else                                            // IF SLOT IS NOT OWNED (AVAILABLE)
                }
                    if(                  pcTally[ 3 ] < cbSlot ) pcTally[ 3 ] = cbSlot ;        // MAXIMUM SLOT SIZE
                    if( !pcTally[ 2 ] || pcTally[ 2 ] > cbSlot ) pcTally[ 2 ] = cbSlot ;        // MINIMUM SLOT SIZE
                    pcTally[ 1 ] += cbSlot ;
                    pcTally[ 0 ] ++ ;

                    countT* pcTally = &(countT&)swTallyP ;

                    pczLeverP = pczLever ;
                    countT pczLever[] = { pn->idiFileTagged , pn->idLineTagged , pn->idiFileTagged2 , pn->idLineTagged2 , 0 } ;

                    const dropNoteS* pn = pNotesP + offb ;
                {
                if( pbBitsOwnedP[ offByte ] >> offBit & 1 )     // IF SLOT IS OWNED (IN USE)

                countT offBit  = offb % SB ;
                countT offByte = offb / SB ;
            {
            for( countT offb = 0 ; offb < cSlots ; offb ++ )

            countT cbSlot = 1 << pHeadP->expCbDrop ;
        {
        //if( cFound )

        //}
        //    if( pbBitsOwnedP[ offByte ] >> offBit & 1 ) cFound ++ ;
        //
        //    countT offBit  = offb % SB ;
        //    countT offByte = offb / SB ;
        //{
        //for( countT offb = 0 ; offb < cSlots ; offb ++ )
        //ZE( countT , cFound ) ;
        countT cSlots = 1 << pHeadP->expSlots ;

        switchC& swTallyP  = *(switchC*)pcArgP[ 2 ] ;
        countT*& pczLeverP = *(countT**)pcArgP[ 1 ] ;
        etherC&  etherP    =  *(etherC*)pcArgP[ 0 ] ;
        countT*  pcArgP    = (countT*)cArgP ;
    {
    if( cArgP && pNotesP )
{
voidT slotsWalkTallyCBF( tinS& tinP , countT& cArgP , const sexHeadS* pHeadP , const byteT* pbBitsOwnedP , const dropNoteS* pNotesP , const byteT* pbDataP )

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

