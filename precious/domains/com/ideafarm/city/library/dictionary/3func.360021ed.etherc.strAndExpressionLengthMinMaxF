
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    idsP = idsLath ;

    }
        idfFixed = 0 ;
        stFixedSmallP << (byteT*)&c2f ;
        count2S c2f( idfFixed , idsLath - 1 ) ;
    {
    if( idfFixed )

    }
        if( bArmPossibleIgnore ) bArmPossibleIgnore -- ;

        }
            repeatMin = repeatMax = 0 ;
            ;
                : csttMaxP + repeatMax + 1 ;                            // CAN OVERFLOW FOR BAD FORM PARAMETER VALUES (HIGH VALUES OTHER THAN -1)
                ? - 1
            if( csttMaxP != - 1     ) csttMaxP = repeatMax == - 1
            if( !bArmPossibleIgnore ) csttMinP += repeatMin + 1 ;

            }
                idfFixed = 0 ;
                }
                    stFixedSmallP << (byteT*)&c2f ;
                    count2S c2f( idfFixed , idsi - 1 ) ;
                {
                if( idfFixed < idsi )
            {
            if( bArmPossibleIgnore || repeatMin != repeatMax )
        {
        else
        }
            }
                idfFixed = 0 ;
                }
                    stFixedSmallP << (byteT*)&c2f ;
                    count2S c2f( idfFixed , idsi - 1 ) ;
                {
                if( idfFixed < idsi )
            {
            if( bPushFixedIf )

            }
                if( csttMaxP != - 1     ) csttMaxP += idRepeatMax ;
                if( !bArmPossibleIgnore ) csttMinP += idRepeatMin ;

                if( idRepeatMin != idRepeatMax ) bPushFixedIf = 1 ;
            {
            else
            }
                else cIgnore += idRepeatMax ;
                }
                    offPatch ++ ;

                    if( bArmPossibleIgnore || repeatMin != repeatMax ) bPushFixedIf = 1 ;

                    ;
                        : 0
                            : pcMaxOverrideP[ offPatch ] & ~BM_HIGH
                            ? - 1
                        ? pcMaxOverrideP[ offPatch ] == - 1
                    repeatMax = pcMaxOverrideP && pcMaxOverrideP[ offPatch ]

                    ;
                        : 0
                        ? pcMinOverrideP[ offPatch ] & ~BM_HIGH
                    repeatMin = pcMinOverrideP && pcMinOverrideP[ offPatch ]

                    if( pFlagsOverrideP && pFlagsOverrideP[ offPatch ] && !( F(pFlagsOverrideP[ offPatch ]) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) ) bArmPossibleIgnore = 2 ;
                {
                if( idRepeatMax == - 1 )                                                //U:: THIS CODE IS INCORRECT IN THAT IT FAILS TO HANDLE "DO NOT IGNORE" FLAG AND ALSO FAILS TO HANDLE IGNORE POSSIBILITY
            {
            if( idRepeatMin == - 1 )
            ZE( boolT , bPushFixedIf ) ;

            countT idRepeatMax = psttRegExpP[ CSpREFIX - 1 + idsi ].cNote  ;
            countT idRepeatMin = psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam ;
            repeatMin = repeatMax = 0 ;
        {
        else if( psttRegExpP[ CSpREFIX - 1 + idsi ].idCaste == sc_ccSSSrEPEAT )
        }
            repeatMin = repeatMax = 0 ;
            ;
                : csttMaxP + repeatMax + 1 ;                            // CAN OVERFLOW FOR BAD FORM PARAMETER VALUES (HIGH VALUES OTHER THAN -1)
                ? - 1
            if( csttMaxP != - 1     ) csttMaxP = repeatMax == - 1
            if( !bArmPossibleIgnore ) csttMinP += repeatMin + 1 ;                                                               //U:: THIS IS INCORRECT WHEN THE "OR BLOCK" CONTAINS AN "AND BLOCK"
            idsi = strIdLathExpressionF( tinP , psttRegExpP , idsi ) ;

            }
                idfFixed = 0 ;
                }
                    stFixedSmallP << (byteT*)&c2f ;
                    count2S c2f( idfFixed , idsi - 1 ) ;
                {
                if( idfFixed < idsi )
            {
            if( idfFixed && ( bArmPossibleIgnore || repeatMin != repeatMax ) )
        {
        else if( psttRegExpP[ CSpREFIX - 1 + idsi ].idCaste == sc_ccSSS && psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam == sa_SSSoR )
        }
            idfFixed = 0 ;
            }
                stFixedSmallP << (byteT*)&c2f ;
                count2S c2f( idfFixed , idsi - 1 ) ;
            {
            if( idfFixed < idsi )

            repeatMin = repeatMax = 0 ;
        {
        else if( psttRegExpP[ CSpREFIX - 1 + idsi ].idCaste == sc_ccSSS && ( psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam == sa_SSSrEPORTmATCH || psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam == sa_SSSrEPORTmATCHeND ) )
        }
            repeatMin = repeatMax = 0 ;

            ;
                : csttMaxP + csttMax2 * ( repeatMax + 1 ) ;                            // CAN OVERFLOW FOR BAD FORM PARAMETER VALUES (HIGH VALUES OTHER THAN -1)
                ? - 1
            if( csttMaxP != - 1     ) csttMaxP = repeatMax == - 1
            if( !bArmPossibleIgnore ) csttMinP += csttMin2 * ( repeatMin + 1 ) ;

            }
                idfFixed = 0 ;
                }
                    stFixedSmallP << (byteT*)&c2f ;
                    count2S c2f( idfFixed , idsi - 1 ) ;
                {
                if( idfFixed < idsi )
            {
            if( idfFixed && ( bArmPossibleIgnore || csttMin2 != csttMax2 ) )

            strAndExpressionLengthMinMaxF( tinP , csttMin2 , csttMax2 , stFixedSmallP , idsInspect , psttRegExpP , flagsOptimizeP , pFlagsOverrideP , pcMinOverrideP , pcMaxOverrideP ) ;
            countT idsInspect = idsi ;
            ZE( countT , csttMax2 ) ;
            ZE( countT , csttMin2 ) ;
        {
        else if( psttRegExpP[ CSpREFIX - 1 + idsi ].idCaste == sc_ccSSS && psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam == sa_SSSaND )
        }
            repeatMin = repeatMax = 0 ;

            idsi = strIdLathExpressionF( tinP , psttRegExpP , idsi ) ;

            idfFixed = 0 ;
            cIgnore -- ;
        {
        if( cIgnore )

        if( !idfFixed ) idfFixed = idsi ;                           // PRESUMED TO BE THE BEGINNING OF A FIXED LENGTH SUBSTRING
    {
    for( countT idsi = idsP + 1 ; idsi < idsLath ; idsi ++ )
    ZE( countT , idfFixed ) ;
    ZE( countT , repeatMax ) ;
    ZE( countT , repeatMin ) ;
    ZE( boolT  , bArmPossibleIgnore ) ;
    ZE( countT , cIgnore ) ;
    ZE( countT , offPatch ) ;
    const countT idsLath = strIdLathExpressionF( tinP , psttRegExpP , idsP ) ;

    }
        if( POOP ) return ;
        __( psttRegExpP[ CSpREFIX - 1 + idsP ].idAdam  - sa_SSSaND ) ;
        __( psttRegExpP[ CSpREFIX - 1 + idsP ].idCaste - sc_ccSSS  ) ;
        if( POOP ) return ;
        __Z( psttRegExpP ) ;
        __Z( idsP ) ;
        __NZ( csttMaxP ) ;
        __NZ( csttMinP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT etherC::strAndExpressionLengthMinMaxF( tinS& tinP , countT& csttMinP , countT& csttMaxP , stackC& stFixedSmallP , countT& idsP , const strokeS* const psttRegExpP , const flagsT flagsOptimizeP , const flagsT* pFlagsOverrideP , const countT* pcMinOverrideP , const countT* pcMaxOverrideP )/*1*/

/**/
*/
    this is not currently enforced but might be in the future
   if contains regular expressions, must begin with sa_SSSaND
  must be a valid search pattern
 psttRegExpP
  will point to the matching sa_SSSaNDeND
  must point to an sa_SSSaND
  must not be 0
 idsP
  will be the maximum number of strokes that the AND subexpression at idsP will consume
  must be 0
 csttMaxP
  will be the minimum number of strokes that the AND subexpression at idsP will consume
  must be 0
 csttMinP
 tinP
parameters
i return the minimum and maximum number of strokes that can be consumed by the subexpression at idsP
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
