
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        }
            DEL( pSw ) ;
            }
                }
                    etThread.strokeF( tinP , T("\r\n") ) ;
                    for( countT off = 0 ; off < CsAMPLES ; off ++ ) etThread.strokeF( tinP , TF3(pcTally[off],flFORMAT_UNSIGNED,9) ) ;
                    etThread.strokeF( tinP , TF4(idLine&0xfff,flFORMAT_UNSIGNED|flFORMAT_NObASE,5,0xa)+TF3(idiFile,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+tb+TF4(idLineNote&0xfff,flFORMAT_UNSIGNED|flFORMAT_NObASE,5,0xa)+TF3(idiFileNote,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+tb+TF3(idAdamRoot,flFORMAT_UNSIGNED,8)+TF3(idProcessOld,flFORMAT_UNSIGNED,9)+TP(processGlobal4I.mapdropNoteType(idType),processGlobal4I.mapdropNoteType.costMaxF())+tb ) ;
                    countT idType             = c7lever.c7 ;
                    countT idProcessOld          = c7lever.c6 ;
                    countT idAdamRoot = c7lever.c5 ;
                    countT idiFileNote        = c7lever.c4 ;
                    countT idLineNote         = c7lever.c3 ;
                    countT idiFile            = c7lever.c2 ;
                    countT idLine             = c7lever.c1 ;
                {
                if( bSuspectF( pcTally ) )
                countT* pcTally = &(countT&)*pSw ;
                c7lever = *(count7S*)pSw->leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors && !ether ; idf ++ )
            countT cFlavors = pSw->cFlavorsF( tinP ) ;
        {
        if( pSw )
        switchC*& pSw = *(switchC**)&(countT&)sw_pSw ;
        etThread.strokeF( tinP , T("\r\n" USCORE127 "\r\n")+T(psttIdName)+tc+TPS("",127,sttd)+T("\r\n\r\n")+T("line ")+TPS("file",7,sttd)+tb+T("linn ")+TPS("filn",7,sttd)+tb+TPS("adam",7,sttd)+tb+TPS("process",8,sttd)+tb+TPS("type",processGlobal4I.mapdropNoteType.costMaxF(),sttd)+tb+TPS("tallies",9*CsAMPLES-1,sttd)+tc ) ;
        psttIdName = (strokeS*)sw_pSw.leverF( tinP , idp ) ;
    {
    for( countT idp = 1 ; idp <= cPools ; idp ++ )
    countT cPools = sw_pSw.cFlavorsF( tinP ) ;
    strokeS sttd( '-' ) ;
    TN( tc , "\r\n" ) ;
    TN( tb , " " ) ;
{
if( !ether )

}
    etThread.strokeF( tinP , T("\r") ) ;
    }
        ++ s ; ether.osSleepF( tinP , TICK , 0 , flSLEEP_TALK ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( idSample < CsAMPLES )

    }
        }
            }
                }
                    etThread.delF( tinP , psttName ) ;
                    }
                        etThread.delF( tinP , psttIdName ) ;
                        }
                            sIn2.removeAllF( tinP ) ;
                            }
                                etThread.strokeF( tinP , T("\r        \r") ) ;
                                }
                                    etThread.delF( tinP , pcInfo ) ;
                                    }
                                        pcTally[ idSample - 1 ] ++ ;
                                        countT* pcTally = &(countT&)*pSw ;
                                        c7lever = *(count7S*)pcInfo ;
                                    {
                                    if( pcInfo )
                                    sIn2.shiftRightF( tinP , pcInfo , ccInfo ) ; ___( pcInfo ) ;
                                    ZE( countT  , ccInfo ) ;
                                    ZE( countT* , pcInfo ) ;
                                    if( !( (countT)sIn2 % 0x1000 ) ) etThread.strokeF( tinP , T("\r        \r")+TF1((countT)sIn2) ) ;
                                {
                                while( (countT)sIn2 && !ether )
                            {
                            if( idReply == ifcIDrEPLYmONITOR_POOLoLDwALK1 && !ether )
                            sIn2 >> idReply ;
                            ZE( countT , idReply ) ;
                            sock.readF( tinP , sIn2 ) ;
                            
                            sOut.removeAllF( tinP ) ;
                            sock.writeF( tinP , sOut ) ;
                            sOut << psttName ;
                            sOut << idMemorySpace ;
                            sOut << (countT)ifcIDcMDmONITOR_POOLoLDwALK1 ;
                        {
                        if( pSw )
                        if( !pSw ) { pSw = new( 0 , tinP , LF ) switchC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , (byteT*)&c7lever , sizeof c7lever , CsAMPLES * sizeof( countT ) ) ; ___( pSw ) ; }
                        switchC*& pSw = *(switchC**)&(countT&)sw_pSw ;
                        etThread.strMakeF( tinP , LF , psttIdName , TF1(idMemorySpace)+T("!")+T(psttName) ) ; ___( psttIdName ) ;
                        etThread.strokeF( tinP , T("sample ")+TF1(idSample)+T(" for ")+TF1(idMemorySpace)+T(" \"")+T(psttName)+T("\"\r\n") ) ;
                    {
                    //if( etThread.strIdF( tinP , T("1050104") , psttName ) )
                    //if( !etThread.strIdF( tinP , T("fooey") , psttName ) )
    
                    sIn >> psttName ; ___( psttName ) ;
                    ZE( strokeS* , psttName ) ;
                {
                while( cNames -- && !ether )
                sIn >> cNames ;
                ZE( countT , cNames ) ;
                sIn >> idMemorySpace ;
                ZE( countT , idMemorySpace ) ;
            {
            while( cSpaces -- && !ether )
            sIn >> cSpaces ;
            ZE( countT , cSpaces ) ;
        {
        if( idReply == ifcIDrEPLYmONITOR_POOLoLDnAMES && !ether )
        sIn >> idReply ;
        ZE( countT , idReply ) ;
        
        sock.readF( tinP , sIn ) ;
        soulC sIn2( tinP , TAG( TAGiDnULL ) ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
        sOut.removeAllF( tinP ) ;
        sock.writeF( tinP , sOut ) ;
        soulC sOut( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDmONITOR_POOLoLDnAMES ) ;
        sock.connectF( tinP , ifcIDpORT_DOOR ) ;
        socketC sock( tinP , etThread , TAG( TAGiDnULL ) ) ;
    {
{
for( countT idSample = 1 ; idSample <= CsAMPLES && !ether ; idSample ++ )
count7S c7lever ;
switchC sw_pSw( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttIdName ) ;
ZE( strokeS* , psttIdName ) ;
etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;

TODO

}
    return bSuspect ;

    }
        }
            break ;
            bSuspect = 0 ;
        {
        if( pcTallyP[ off ] <= pcTallyP[ off - 1 ] )
    {
    for( countT off = 1 ; off < CsAMPLES ; off ++ )

    boolT bSuspect = 1 ;
{
boolT bSuspectF( const countT* const pcTallyP )

#define CsAMPLES 0x4

#include postADAMhEADER

/*1*/WAKEhIDE( "tool.monitor.query.2.leak.finder" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

