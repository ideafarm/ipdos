
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

//==============================================================================================================================================================
//==== BELOW THIS LINE: DAYTIME WORK ===========================================================================================================================
//==============================================================================================================================================================

REST

TELL( "cleaning up" ) ;
etThread.ifcDrivenServerF( tinP , i1 , i2 ) ;
etThread.osThreadAdamF( tinP , ifcIDaDAM_ROOTmAILoUT ) ;
//etThread.ifcHireF( tinP , T("ifcIDaDAM_ROOTsMTPsERVER") , ifcIDaDAM_ROOTmAILoUT , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
serverInfo2S i2( 0x19 , TF2(thirdC::third_idAdamRootI_IF( tinP ),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , 0 , (countT)&c8p , 0 , 1 , 0 , 0 ) ;
serverInfo1S i1( &pbdVarying , &b_pbdVarying , bHandedOff , sgnIdPortReplaced , tmcSmtpF , countTC() , ether , time1idleTimeoutRead , time1idleTimeoutWrite ) ;
ZE( countT , time1idleTimeoutWrite ) ;
ZE( countT , time1idleTimeoutRead ) ;

c8p.c2 = (countT)&c8p2 ;
c8p.c1 = (countT)&c8p1 ;
count8S c8p ;

c8p2.c3 = (countT)&bFileIdRelay ;
c8p2.c2 = (countT)&tFileIdRelay ;
c8p2.c1 = (countT)&idRelayLath ;
count8S c8p2 ;

c8p1.c8 = (countT)&bFileIdPenpal ;
c8p1.c7 = (countT)&tFileIdPenpal ;
c8p1.c6 = (countT)&idPenpalLath ;
c8p1.c5 = (countT)&bPrepayCode ;
c8p1.c4 = (countT)&ru ;
c8p1.c3 = (countT)&stNicNameSpammer ;
c8p1.c2 = (countT)&b_pbdVarying ;
c8p1.c1 = (countT)&pbdVarying ;
count8S c8p1 ;

}
    etThread.delF( tinP , pbi ) ;
    if( pbi && cbi == sizeof idRelayLath ) idRelayLath = *(byteT*)pbi ;
    etThread.boxGetShadowF( tinP , pbi , cbi , tFileIdRelay ) ; ___( pbi ) ;
    ZE( countT , cbi ) ;
    ZE( byteT* , pbi ) ;
{
if( etThread.diskFileExistsF( tinP , tFileIdRelay ) )
ZE( countT , idRelayLath ) ;
batonC bFileIdRelay( tinP , TAG( TAGiDnULL ) ) ;
TN( tFileIdRelay , "" ) ; tFileIdRelay = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/txt.email.incoming.idrelaylath.txt") ;

}
    etThread.delF( tinP , pbi ) ;
    if( pbi && cbi == sizeof idPenpalLath ) idPenpalLath = *(byteT*)pbi ;
    etThread.boxGetShadowF( tinP , pbi , cbi , tFileIdPenpal ) ; ___( pbi ) ;
    ZE( countT , cbi ) ;
    ZE( byteT* , pbi ) ;
{
if( etThread.diskFileExistsF( tinP , tFileIdPenpal ) )
ZE( countT , idPenpalLath ) ;
batonC bFileIdPenpal( tinP , TAG( TAGiDnULL ) ) ;
TN( tFileIdPenpal , "" ) ; tFileIdPenpal = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/txt.email.incoming.idpenpallath.txt") ;

batonC bPrepayCode( tinP , TAG( TAGiDnULL ) ) ;
ranUniC ru( MAXcOUNTT ) ;
//U::stackC stNicNameSpammer( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC , 0 , 0 , T("///d/")+TF1(DDNUMB)+T(".stNicNameSpammer") ) ; //U::PUT THIS FILE INTO A DIRECTORY WITHIN THE HOME
stackC stNicNameSpammer( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ; //U::SOUL FILE DOES NOT WORK (REGRESSION PROBLEM)

ZE( boolT , bHandedOff ) ;
batonC b_pbdVarying( tinP , TAG( TAGiDnULL ) ) ;

ZE( byteT* , pbdVarying ) ;
signC sgnIdPortReplaced( tinP , TAG( TAGiDnULL ) ) ;

TODO

DONEdRIVENsERVER( tmcSmtpF )
}
    TELL( "cleaning up this thread" ) ;

    }
        }
            }
                _OUT_
                }
                    POOPR
                {
                if( POOP )
    
                }
                    _OUT_
                    tinP.pEtScratch->delF( tinP , psttPeer ) ;
                    TELL( "cleaning up this session" ) ;
                    }
                        TELL( "end of handler loop" ) ;
                        _OUT_
                        *tinP.pEtScratch = etScratchSave ;
                        //tinP.pEtScratch->ifcSayIF( stPhrases , flSAY_APPEND | flSAY_LOG ) ;
                        *tinP.pEtScratch = 0 ;
                        countT etScratchSave = *tinP.pEtScratch ;
                        etThread.delF( tinP , psttSource ) ;
                        }
                            _OUT_
                            pso->writeF( tinP , (osTextT*)tErrWrite , tErrWrite.csF( tinP ) ) ;
                            TN( tErrWrite , "" ) ; tErrWrite = T("554 ")+tErrAll ;
                            POOPR
                            _INoLD_
                        {
                        else
                        if( !POOP && !etThread ) pso->writeF( tinP , "250 ok\r\n" ) ;
                        TELL( "writing aok or error say" ) ;
    
                        etThread.delF( tinP , psttOutToPenpal ) ;
                        tinP.pEtScratch->delF( tinP , psttBodyWothTock ) ;
                        tinP.pEtScratch->delF( tinP , psttSoixlOld ) ;
                        tinP.pEtScratch->delF( tinP , psttHeader ) ;
                        }
                            _OUT_
                            }
                                _OUT_
                                }
                                    _OUT_
                                    etThread( tinP , pStkSetting ) ;
                                    while( ~hWalk ) ;
                                    }
                                        TELL( "end of loop" ) ;
                                        if( POOP ) { POOPR } ;

                                        }
                                            _OUT_
                                            tErrAll += tErr ;
                                            logSmtpF( tinP , etThread , tErr , c3r.c3 , c3r.c2 ) ;
                
                                            //etThread.ifcSayIF( T(nicNamePeer)+T(" ")+T(psttPeer)+T(": ERROR: ")+tErr+tcr , flSAY_APPEND | flSAY_LOG ) ;
                    
                                            if( F(flError) & flERROR_COULDnOThANDLErECIPIENT ) tErr += T(postERROR_COULDnOThANDLErECIPIENT ) ;
                                            if( F(flError) & flERROR_ANONYMOUSpEEER          ) tErr += T(postERROR_ANONYMOUSpEEER          ) ;
                                            if( F(flError) & flERROR_PARSEhEADERPARAMiSnULL  ) tErr += T(postERROR_PARSEhEADERPARAMiSnULL  ) ;
                                            if( F(flError) & flERROR_PARSEhEADERlINEiSnULL   ) tErr += T(postERROR_PARSEhEADERlINEiSnULL   ) ;
                                            if( F(flError) & flERROR_FILEiStOObIG            ) tErr += T(postERROR_FILEiStOObIG            ) ;
                                            if( F(flError) & flERROR_COULDnOTgETfILEiNFO     ) tErr += T(postERROR_COULDnOTgETfILEiNFO     ) ;
                                            if( F(flError) & flERROR_COULDnOToPENfILES       ) tErr += T(postERROR_COULDnOToPENfILES       ) ;
                                            if( F(flError) & flERROR_SOIXLoLDbADbEGINNING        ) tErr += T(postERROR_SOIXLoLDbADbEGINNING        ) ;
                                            if( F(flError) & flERROR_SOIXLoLDtOOlARGE            ) tErr += T(postERROR_SOIXLoLDtOOlARGE            ) ;
                                            if( F(flError) & flERROR_HEADERtOOlARGE          ) tErr += T(postERROR_HEADERtOOlARGE          ) ;
                                            if( F(flError) & flERROR_FALSEsENDER             ) tErr += T(postERROR_FALSEsENDER             ) ;
                                            if( F(flError) & flERROR_HIDDENsENDER            ) tErr += T(postERROR_HIDDENsENDER            ) ;
                                            if( F(flError) & flERROR_RELAY                   ) tErr += T(postERROR_RELAY                   ) ;
                                            if( F(flError) & flERROR_FROMvALUESdIFFER        ) tErr += T(postERROR_FROMvALUESdIFFER        ) ;
                                            if( F(flError) & flERROR_DATAlINEtOOlONG         ) tErr += T(postERROR_DATAlINEtOOlONG         ) ;
                                            if( F(flError) & flERROR_NOdATA                  ) tErr += T(postERROR_NOdATA                  ) ;
                                            if( F(flError) & flERROR_NOvALIDrECIPIENTS       ) tErr += T(postERROR_NOvALIDrECIPIENTS       ) ;
                                            if( F(flError) & flERROR_SECRETsENDER            ) tErr += T(postERROR_SECRETsENDER            ) ;
                                            TN( tErr , "" ) ;
                                            TELL( "building error say" ) ;
    
                                            etThread.delF( tinP , psttSubject ) ;
                                            etThread.delF( tinP , psttFrom ) ;
                                            }
                                                _OUT_
                                                }
                                                    _OUT_

                                                    if( bEditArchive ) tinP.pEtScratch->osEditF( tinP , tFileArchive , 1 ) ;

                                                    }
                                                        }
                                                            DEL( pInfo ) ;
                                                            }
                                                                }
                                                                    tinP.pEtScratch->delF( tinP , posti ) ;
                                                                    }
                                                                        }
                                                                            cToDo -= cNibble ;
                                                                            tinP.pEtScratch->fileWriteF( tinP , hFileArchive , posti , cNibble ) ;
                                                                            tinP.pEtScratch->fileReadF( tinP , posti , cNibble , hFileBody ) ;
                                                                            countT cNibble = costa < cToDo ? costa : cToDo ;
                                                                        {
                                                                        while( cToDo )
                                                                    {
                                                                    if( posti )
                                                                    tinP.pEtScratch->newF( tinP , LF , posti , costa ) ; ___( posti ) ;
                                                                    ZE( osTextT* , posti ) ;
                                                        
                                                                    const countT costa = TOCK < cToDo ? TOCK : cToDo ;
                                                                    countT cToDo = pInfo->cbUsed ;
            
                                                                    }
                                                                        tinP.pEtScratch->fileWriteF( tinP , hFileArchive , (osTextT*)tAll , tAll.csF( tinP ) ) ;
                                                                        if( psttSoixlOld && psttSoixlOld->idAdam ) tAll += T(psttSoixlOld)+T("\r\n") ;
                                                                        TN( tAll , "" ) ; tAll = T(psttHeader) ;
                                                                    {
                                                                {
                                                                else                                    
                                                                }
                                                                    DEL( pInfo ) ;
                                                                    flError |= flERROR_FILEiStOObIG ;
                                                                {
                                                                if( POOP )
                                                                __( pInfo->cbUsedHigh ) ;
                                                            {
                                                            else
                                                            if( POOP ) flError |= flERROR_COULDnOTgETfILEiNFO ;
                                                            tinP.pEtScratch->diskFileQueryF( tinP , pInfo , hFileBody ) ; ___( pInfo ) ;
                                                            ZE( infoFileS* , pInfo ) ;
                                                        {
                                                        else
                                                        if( POOP ) flError |= flERROR_COULDnOToPENfILES ;
            
                                                        { _INoLD_ tinP.pEtScratch->fileOpenF( tinP , hFileArchive , countTC() , tFileArchive , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nCeF ) ; _OUT_ }
                                                        handleC hFileArchive( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                                                    {
        
                                                    { _INoLD_ tinP.pEtScratch->fileOpenF( tinP , hFileBody , countTC() , tFileBody , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ; _OUT_ }
                                                    handleC hFileBody( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
        
                                                    }
                                                        etThread.delF( tinP , psttu ) ;
                                                        tFileArchive = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/accounts/")+TF4(c3r.c3,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T("/subaccounts/")+TF4(c3r.c2,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T("/in/")+T("txt.email.")+T(psttu)+T(".txt") ;
                                                        etThread.strUniqueF( tinP , psttu ) ; ___( psttu ) ;
                                                        ZE( strokeS* , psttu ) ;
                                                    {
                                                    TN( tFileArchive , "" ) ;
                                                    _INoLD_
                                                {
                                                if( bArchive )
                                                TELL( "archiving" ) ;
        
    // END ********************************************************************************************************************************************
                                                }
                                                    _OUT_
                                                    }
                                                        //LOGrAW( tName+tcr ) ;
                                                        etThread.delF( tinP , pstt1f ) ;
                                                        etThread.boxPutF( tinP , tName , (byteT*)pstt1f , 0 , 0 , flOPENdETAILS_null , flBOXcpUTf_FILEnAME ) ;
                                                        TN( tName , "" ) ; tName = T("//smtp/")+tFromDisplay+T("/")+tRelayTo ;
        
                                                        //LOGrAW( T("idPenpal:")+TF2(idPenpal,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" ; tFromDisplay: \"")+tFromDisplay+T("\"\r\n") ) ;
                                                        TN( tFromDisplay , "" ) ; tFromDisplay = (!idPenpal?T(""):TF4(idPenpal,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T("."))+TF4(c3r.c2,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(".")+TF4(c3r.c3,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(ifcEMAIL_DOUBLEbLINDsUFFIX "") ;
        
                                                        if( bContentIsPlain ) etThread.strFuseSeparateF( tinP , pstt1f , tFoot ) ;
                                                        //LOGrAW3( "bContentIsPlain: " , bContentIsPlain , "\r\n" ) ;
                                                        etThread.strFuseSeparateF( tinP , pstt1f , tFileBody ) ;
                                                        etThread.strFuseSeparateF( tinP , pstt1f , T("!literal:")+tHeadRetain+T("\r\n") , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 2 * CSpREFIX + tFileBody.csF( tinP ) + tFoot.csF( tinP ) ) ; ___( pstt1f ) ;
                                                        ZE( strokeS* , pstt1f ) ;
    
                                                        //LOGrAW( T("tRelayTo: \"")+tRelayTo+T("\"\r\n") ) ; //U::
            
                                                        countT idPenpal = bNewConversation ? 0 : queryIdAccountFromEmailF( tinP , psttFrom ) ;
                                                        //LOGrAW3( "inspecting bNewConversation, which is " , bNewConversation , "\r\n" ) ;
                                                    {
                                                    if( tRelayTo.csF( tinP ) )
                    
                                                    }
                                                        }
                                                            }
                                                                info.pStkEmailRelay->purgeF( tinP ) ;
                                                                }
                                                                    }
                                                                        else                                   tRelayTo += tSlash ;
                                                                        if( !( -- info.cEmailRelayDrawings ) ) break ;
                                                                        tRelayTo += T(psttzw) ;
                                                                    {
                                                                    if( psttzw->idAdam && !etThread.strIdF( tinP , tBan , psttzw ) && !(countT)ru )
                                                                    etThread.strConvertToLowerCaseF( tinP , psttzw ) ;
                                                                    strokeS*& psttzw = (strokeS*&)(countT&)info.pStkEmailRelay->downF( tinP , hWalk ) ;
                                                                {
                                                                while( !POOP )
                                                                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                                ranUniC ru( cRelays ) ;
                                                            {
                                                            else
                                                            }
                                                                }
                                                                    etThread.delF( tinP , psttw ) ;
                                                                    if( !etThread.strIdF( tinP , tBan , psttw ) ) tRelayTo += T(psttw)+T(*info.pStkEmailRelay?"/":"") ;
                                                                    etThread.strConvertToLowerCaseF( tinP , psttw ) ;
                                                                    *info.pStkEmailRelay >> psttw ; ___( psttw ) ;
                                                                    ZE( strokeS* , psttw ) ;
                                                                {
                                                                if( info.pStkEmailRelay ) while( *info.pStkEmailRelay )
                                                            {
                                                            if( !info.cEmailRelayDrawings ) // 0:ALL
                                                            tRelayTo = T("//") ;
                                                            TN( tSlash , "/" ) ;
                                                            TN( tBan , "@ideafarm.com" ) ;
    
                                                            if( info.cEmailRelayDrawings > cRelays - 1 ) info.cEmailRelayDrawings = cRelays - 1 ; // SHOULD NEVER BE NEEDED
                                                        {
                                                        if( cRelays )
                                                        const countT cRelays = *info.pStkEmailRelay ;
    
                                                        subaccountS info( tinP , etThread , c3r.c3 , c3r.c2 , flSUBACCOUNT_QUERYeMAILrELAY | flSUBACCOUNT_QUERYrELAYdRAWINGS ) ;
                                                    {
                                                    if( !tRelayTo.csF( tinP ) )
    
                                                    //}
                                                    //    //else { LOGrAW( "INCOMING RECEIVED FROM SOMEONE OTHER THAN OWNER OF THIS RELAY ACCOUNT\r\n" ) ; }
                                                    //    }
                                                    //        if( tBcc.csF( tinP ) ) tRelayTo += T("//")+tBcc ;
                                                    //        if( tCc.csF( tinP )  ) tRelayTo += T(tRelayTo.csF(tinP)?"//":"/")+tCc  ;
                                                    //        tRelayTo = tTo ;
                                                    //        //CORRECT FORMAT: to OR to//cc OR to//cc//bcc OR /cc OR /cc//bcc OR //bcc
                                                    //
                                                    //        LOGrAW( T("t:Bcc \"")+tBcc+T("\"\r\n") ) ; //U::
                                                    //        LOGrAW( T("t:Cc  \"")+tCc+T("\"\r\n") ) ; //U::
                                                    //        LOGrAW( T("t:To  \"")+tTo+T("\"\r\n") ) ; //U::
                                                    //
                                                    //        }
                                                    //            etThread.delF( tinP , pstt1w ) ;
                                                    //            }
                                                    //                }
                                                    //                    }
                                                    //                        break ;
                                                    //                        tBcc += tBcc.csF( tinP ) ? T("/")+T(psttc1) : T(psttc1) ;
                                                    //                        idArm = - 1 ;
                                                    //                    {
                                                    //                    case 3 :
                                                    //                    }
                                                    //                        break ;
                                                    //                        tCc += tCc.csF( tinP ) ? T("/")+T(psttc1) : T(psttc1) ;
                                                    //                        idArm = - 1 ;
                                                    //                    {
                                                    //                    case 2 :
                                                    //                    }
                                                    //                        break ;
                                                    //                        tTo += tTo.csF( tinP ) ? T("/")+T(psttc1) : T(psttc1) ;
                                                    //                        idArm = - 1 ;
                                                    //                    {
                                                    //                    case 1 :
                                                    //                    }
                                                    //                        break ;
                                                    //
                                                    //                        else if( !tinP.pEtScratch->strCompareF( tinP , psttc1 , T("bcc") ) ) idArm = 3 ;
                                                    //                        else if( !tinP.pEtScratch->strCompareF( tinP , psttc1 , T("cc" ) ) ) idArm = 2 ;
                                                    //                             if( !tinP.pEtScratch->strCompareF( tinP , psttc1 , T("to" ) ) ) idArm = 1 ;
                                                    //                    {
                                                    //                    case 0 :
                                                    //                    }
                                                    //                        break ;
                                                    //                        if( !tinP.pEtScratch->strCompareF( tinP , psttc1 , T(";") ) ) idArm = 0 ;
                                                    //                    {
                                                    //                    case - 1 :
                                                    //                {
                                                    //                switch( idArm )
                                                    //
                                                    //                }
                                                    //                    }
                                                    //                        break ;
                                                    //                        flError |= flERROR_SOIXLoLDbADbEGINNING ;
                                                    //                    {
                                                    //                    else
                                                    //                    if( !tinP.pEtScratch->strCompareF( tinP , psttc1 , T("!SOIXLoLD") ) ) continue ;
                                                    //                {
                                                    //                if( BwOTHsTRING1 )
                                                    //            {
                                                    //            FORsTRINGSiN1( pstt1w )
                                                    //            ZE( countT , idArm ) ;
                                                    //            tinP.pEtScratch->strWordsOldF( tinP , pstt1w , psttSoixlOld , sttq ) ; ___( pstt1w ) ;
                                                    //            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                    //            ZE( strokeS* , pstt1w ) ;
                                                    //        {
                                                    //        TN( tBcc , "" ) ;
                                                    //        TN( tCc , "" ) ;
                                                    //        TN( tTo , "" ) ;
                                                    //
                                                    //        LOGrAW( "INCOMING RECEIVED FROM OWNER INTO HIS RELAY ACCOUNT\r\n" ) ;
                                                    //        bNewConversation = 1 ;
                                                    //    {
                                                    //    if( tEmailOwner.csF( tinP ) && !tinP.pEtScratch->strCompareF( tinP , tEmailOwner , psttFrom ) )
                                                    //
                                                    //    }
                                                    //        etThread.delF( tinP , psttw ) ;
                                                    //        tEmailOwner = T(psttw) ;
                                                    //        queryEmailFromIdAccountF( tinP , psttw , c3r.c3 ) ; ___( psttw ) ;
                                                    //        ZE( strokeS* , psttw ) ;
                                                    //    {
                                                    //    TN( tEmailOwner , "" ) ;
                                                    //{
                                                    //COMMENTED OUT TO ELIMINATE ANY DIFFERENCE IN BEHAVIOR W.R.T. ACCT OWNER; ACCT OWNER CONCEPT IS NOW MERELY THE IDENTITY OF THE PERSON WHO IS ALLOWED TO EDIT THE ACCOUNT SETTINGS; OWNER'S EMAIL IS NOT TREATED ANY DIFFERENTLY IN HANDLING AN EMAIL ITEM
                                                    ZE( boolT , bNewConversation ) ;
                                                    TN( tRelayTo , "" ) ;
                                                    _INoLD_
                                                    TELL( "obeying relay specs" ) ;
                                                {
                                                else
    // INCOMING INTO RELAY ********************************************************************************************************************************************
                                                }
                                                    _OUT_
                                                    //LOGrAW( tName+tcr ) ;
                                                    etThread.delF( tinP , pstt1f ) ;
                                                    etThread.boxPutF( tinP , tName , (byteT*)pstt1f , 0 , 0 , flOPENdETAILS_null , flBOXcpUTf_FILEnAME ) ;
                                                    TN( tName , "" ) ; tName = T("//smtp/")+TF4(c3r.c2,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(".")+TF4(c3r.c3,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(ifcEMAIL_DOUBLEbLINDsUFFIX "/")+T(psttOutToPenpal) ;
    
                                                    if( bContentIsPlain ) etThread.strFuseSeparateF( tinP , pstt1f , tFoot ) ;
                                                    //LOGrAW3( "bContentIsPlain: " , bContentIsPlain , "\r\n" ) ;
                                                    etThread.strFuseSeparateF( tinP , pstt1f , tFileBody ) ;
                                                    etThread.strFuseSeparateF( tinP , pstt1f , T("!literal:")+tHeadRetain+T("\r\n") , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 2 * CSpREFIX + tFileBody.csF( tinP ) + tFoot.csF( tinP ) ) ; ___( pstt1f ) ;
                                                    ZE( strokeS* , pstt1f ) ;
                                                    TN( tFoot , "!literal:\r\nhttp://ideafarm.com/double.blind.relay.password.email\r\n" ) ;
                                                    _INoLD_
                                                    TELL( "from relay, so sending to penpal" ) ;
                                                {
                                                else if( psttOutToPenpal ) //ITEM IS OUTGOING FROM RELAY AND THERE IS A PENPAL ON THE SUBACCOUNT, SO SEND TO THE PENPAL
    // ORIGINAL OUT THROUGH RELAY TO PENPAL ********************************************************************************************************************************************
                                                }
                                                    _OUT_
                                                    //LOGrAW( tName+tcr ) ;
                                                    etThread.delF( tinP , pstt1f ) ;
                                                    etThread.boxPutF( tinP , tName , (byteT*)pstt1f , 0 , 0 , flOPENdETAILS_null , flBOXcpUTf_FILEnAME ) ;
                                                    TN( tName , "" ) ; tName = T("//smtp/")+TF4(c3r.c2,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(".")+TF4(c3r.c3,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(ifcEMAIL_DOUBLEbLINDsUFFIX "/")+tEmailOwner ;
    
                                                    }
                                                        etThread.delF( tinP , psttw ) ;
                                                        tEmailOwner = T(psttw) ;
                                                        queryEmailFromIdAccountF( tinP , psttw , c3r.c3 ) ; ___( psttw ) ;
                                                        ZE( strokeS* , psttw ) ;
                                                    {
                                                    TN( tEmailOwner , "" ) ;
    
                                                    if( bContentIsPlain ) etThread.strFuseSeparateF( tinP , pstt1f , tFoot ) ;
                                                    //LOGrAW3( "bContentIsPlain: " , bContentIsPlain , "\r\n" ) ;
                                                    etThread.strFuseSeparateF( tinP , pstt1f , tFileBody ) ;
                                                    etThread.strFuseSeparateF( tinP , pstt1f , T("!literal:")+tHeadRetain+T("\r\n") , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 2 * CSpREFIX + tFileBody.csF( tinP ) + tFoot.csF( tinP ) ) ; ___( pstt1f ) ;
                                                    ZE( strokeS* , pstt1f ) ;
                                                    TN( tFoot , "!literal:\r\nhttp://ideafarm.com/double.blind.relay.password.email\r\n" ) ;
                                                    _INoLD_
                                                    TELL( "sending error notification to owner" ) ;
                                                {
                                                else if( !etThread.strCompareF( tinP , psttFrom , T(ifcEMAIL_MAILoUT) ) )
    // ERROR NOTIFICATION OUT TO OWNER ********************************************************************************************************************************************
                                                }
                                                    _OUT_
                                                    tinP.pEtScratch->delF( tinP , psttOrigin ) ;
                                                    }
                                                        //LOGrAW( tName+tcr ) ;
                                                        etThread.delF( tinP , pstt1f ) ;
                                                        etThread.boxPutF( tinP , tName , (byteT*)pstt1f , 0 , 0 , flOPENdETAILS_null , flBOXcpUTf_FILEnAME ) ;
                                                        TN( tName , "" ) ; tName = T("//smtp/")+tPrefix+TF4(c3r.c2,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(".")+TF4(c3r.c3,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(ifcEMAIL_DOUBLEbLINDsUFFIX "/")+T(psttOrigin) ;
    
                                                        }
                                                            }
                                                                tPrefix = TF4(idAcc,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(".") ;
                                                                }
                                                                    BLAMMO ;
                                                                    //LOGrAW( T("could not get idAcc for \"")+T(psttFrom)+T("\"\r\n") ) ;
                                                                {
                                                                if( !idAcc )
                                                                countT idAcc = queryIdAccountFromEmailF( tinP , psttFrom ) ;
                                                            {
                                                            if( !( F(info.flagsMode) & fliSUBACCOUNTmODE_RELAYrEPLYeNDScONVERSATION ) )
                                                            subaccountS info( tinP , etThread , c3r.c3 , c3r.c2 , flSUBACCOUNT_QUERYfLAGSmODE ) ;
                                                        {
                                                        TN( tPrefix , "" ) ;
    
                                                        if( bContentIsPlain ) etThread.strFuseSeparateF( tinP , pstt1f , tFoot ) ;
                                                        //LOGrAW3( "bContentIsPlain: " , bContentIsPlain , "\r\n" ) ;
                                                        etThread.strFuseSeparateF( tinP , pstt1f , tFileBody ) ;
                                                        etThread.strFuseSeparateF( tinP , pstt1f , T("!literal:")+tHeadRetain+T("\r\n") , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 2 * CSpREFIX + tFileBody.csF( tinP ) + tFoot.csF( tinP ) ) ; ___( pstt1f ) ;
                                                        ZE( strokeS* , pstt1f ) ;
                                                    {
                                                    else if( psttOrigin && psttOrigin->idAdam )
                                                    if( POOP ) POOPR
                                                    queryEmailFromIdAccountF( tinP , psttOrigin , c3r.c1 ) ;
                                                    ZE( strokeS* , psttOrigin ) ;
    
                                                    _INoLD_
                                                    TELL( "replying to idAccount identified in address" ) ;
                                                {
                                                if( c3r.c1 )
    // REPLY BACK THROUGH RELAY ********************************************************************************************************************************************
    
                                                TN( tFoot , "!literal:\r\nhttp://ideafarm.com/double.blind.relay.password.email\r\n" ) ;
            
                                                //LOGrAW( T("[tHeadRetain]: \"")+tHeadRetain+T("\"\r\n") ) ; //U::
                                                }
                                                    _OUT_
                                                    }
                                                        }
                                                            while( ~hWalk ) ;
                                                            }
                                                                tHeadRetain += T(psttzKey)+T(": ")+T(psttzv)+T("\r\n") ;
                                                                strokeS* psttzv = (strokeS*)swsKeyValues.downF( tinP , hWalk ) ;
                                                            {
                                                            do
                                                            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                        {
                                                        if( swsKeyValues )
        
                                                        continue ;
                                                        )
                                                            tinP.pEtScratch->strCompareF( tinP , psttzKey , t3 )
                                                            tinP.pEtScratch->strCompareF( tinP , psttzKey , t2 ) &&
                                                            tinP.pEtScratch->strCompareF( tinP , psttzKey , t1 ) &&
                                                        (
                                                        if
                                                        psttzKey = (strokeS*)swsKeyValues.leverF( tinP , idf ) ;
                                                    {
                                                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                    countT cFlavors = swsKeyValues.cFlavorsF( tinP ) ;
                                                    TN( t3 , "content-type" ) ;
                                                    TN( t2 , "mime-version" ) ;
                                                    TN( t1 , "subject" ) ;
                                                    _INoLD_
                                                {
                                                TN( tHeadRetain , "" ) ;
                                                TELL( "preparing to relay" ) ;
    // PREPARATIONS TO RELAY ********************************************************************************************************************************************
    
                                                }
                                                    }
                                                        etThread.delF( tinP , psttw ) ;
                                                        }
                                                            //LOGrAW( tName+tcr ) ;
                                                            etThread.boxPutF( tinP , tName , tOut , tOut.csF( tinP ) ) ;
                                                            TN( tName , "" ) ; tName = T("//smtp/")+TF4(c3r.c2,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(".")+TF4(c3r.c3,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(ifcEMAIL_DOUBLEbLINDsUFFIX "/")+T(psttFrom) ;
                                                            TN( tOut , psttw ) ;
                                                        {
                                                        if( psttw && psttw->idAdam )
                                                        //CONoUTrAW( T("QQQQ ********  autoresponse: \"")+T(psttw)+T("\"\r\n") ) ;
                                                        *info.pStkAutoresponse >> psttw ; ___( psttw ) ;
                                                        ZE( strokeS* , psttw ) ;
                                                    {
                                                    if( info.pStkAutoresponse ) while( *info.pStkAutoresponse )
                                                    subaccountS info( tinP , etThread , c3r.c3 , c3r.c2 , flSUBACCOUNT_QUERYaUTORESPONSE ) ;
                                                {
                                                boolT bArchive = 1 ;
                                                TELL( "obeying autoresponder specs" ) ;
    // AUTORESPONDER ********************************************************************************************************************************************
    
                                                }
                                                    etThread.delF( tinP , psttw ) ;
                                                    }
                                                        }
                                                            //LOGrAW( tName+tcr ) ;
                                                            etThread.boxPutF( tinP , tName , tRpt , tRpt.csF( tinP ) ) ;
                                                            TN( tName , "" ) ; tName = T("//smtp/" ifcEMAIL_AUTOrESPONDERnEWeMAILsUBACCOUNT "/")+T(psttFrom) ;
          
                                                            }
                                                                }
                                                                    }
                                                                        tRpt += tcr ;
        
                                                                        }
                                                                            etThread.delF( tinP , psttw ) ;
                                                                            if( psttw->idAdam ) tRpt += T("email penpal (contains and): \"")+T(psttw)+T("\"\r\n") ;
                                                                            *info.pStkEmailPenpalContainsAnd >> psttw ; ___( psttw ) ;
                                                                            ZE( strokeS* , psttw ) ;
                                                                        {
                                                                        if( info.pStkEmailPenpalContainsAnd ) while( *info.pStkEmailPenpalContainsAnd )
        
                                                                        }
                                                                            etThread.delF( tinP , psttw ) ;
                                                                            if( psttw->idAdam ) tRpt += T("email penpal (contains or): \"")+T(psttw)+T("\"\r\n") ;
                                                                            *info.pStkEmailPenpalContainsOr >> psttw ; ___( psttw ) ;
                                                                            ZE( strokeS* , psttw ) ;
                                                                        {
                                                                        if( info.pStkEmailPenpalContainsOr ) while( *info.pStkEmailPenpalContainsOr )
        
                                                                        }
                                                                            etThread.delF( tinP , psttw ) ;
                                                                            if( psttw->idAdam ) tRpt += T("email penpal (exact or): \"")+T(psttw)+T("\"\r\n") ;
                                                                            *info.pStkEmailPenpalExactOr >> psttw ; ___( psttw ) ;
                                                                            ZE( strokeS* , psttw ) ;
                                                                        {
                                                                        if( info.pStkEmailPenpalExactOr ) while( *info.pStkEmailPenpalExactOr )
        
                                                                        }
                                                                            etThread.delF( tinP , psttw ) ;
                                                                            if( psttw->idAdam ) tRpt += T("recipe: \"")+T(psttw)+T("\"\r\n") ;
                                                                            *info.pStkRecipe >> psttw ; ___( psttw ) ;
                                                                            ZE( strokeS* , psttw ) ;
                                                                        {
                                                                        if( info.pStkRecipe ) while( *info.pStkRecipe )
        
                                                                        }
                                                                            etThread.delF( tinP , psttw ) ;
                                                                            if( psttw->idAdam ) tRpt += T("autoresponse: \"")+T(psttw)+T("\"\r\n") ;
                                                                            *info.pStkAutoresponse >> psttw ; ___( psttw ) ;
                                                                            ZE( strokeS* , psttw ) ;
                                                                        {
                                                                        if( info.pStkAutoresponse ) while( *info.pStkAutoresponse )
        
                                                                        }
                                                                            etThread.delF( tinP , psttw ) ;
                                                                            if( psttw->idAdam ) tRpt += T("email relay: \"")+T(psttw)+T("\"\r\n") ;
                                                                            *info.pStkEmailRelay >> psttw ; ___( psttw ) ;
                                                                            ZE( strokeS* , psttw ) ;
                                                                        {
                                                                        if( info.pStkEmailRelay ) while( *info.pStkEmailRelay )
        
                                                                        if( info.psttNameOut && info.psttNameOut->idAdam ) tRpt += T("name displayed to others : \"")+T(info.psttNameOut)+T("\"\r\n") ;
            
                                                                        if( info.psttNameIn && info.psttNameIn->idAdam ) tRpt += T("name displayed to relay recipient : \"")+T(info.psttNameIn)+T("\"\r\n") ;
            
                                                                        if( info.psttTitle && info.psttTitle->idAdam ) tRpt += T("(")+T(info.psttTitle)+T(")\r\n") ;
            
                                                                        tRpt += TF4(idSub,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+tSuffix ;
                                                                    {
                                                                    if( !POOP )
        
                                                                    subaccountS info( tinP , etThread , idAccountFrom , idSub ) ;
        
                                                                    stkIdSub >> idSub ;
                                                                    ZE( countT , idSub ) ;
                                                                {
                                                                while( stkIdSub )
        
                                                                stkIdSubC stkIdSub( tinP , idAccountFrom ) ;
                                                            {
        
                                                            }
                                                                //CONoUTrAW3( "[cDone]: " , cDone , "\r\n" ) ;
                                                                sIn >> cDone ;
                                                                ZE( countT , cDone ) ;
                                                                    
                                                                __( idFormat - 1 ) ;
                                                                sIn >> idFormat ;
                                                                ZE( countT , idFormat ) ;
                                                                    
                                                                __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
                                                                sIn >> finger ;
                                                                ZE( countT , finger ) ;
                                                                    
                                                                sock.readF( tinP , sIn ) ;
                                                                soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                                                                    
                                                                sock.writeF( tinP , sOut ) ;
                                                                sOut << idAccountFrom ;
                                                                sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_CONFIRMoWNERaLLsUBACCOUNTS ;
                                                                sOut << (countT)1 ;
                                                                sOut << (countT)FINGERnEG_LISTsERVERcMD ;
                                                                soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
                                                                    
                                                                sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
                                                                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                                            {
                                                            //FLAG ALL SUBACCOUNTS AS OWNER CONFIRMED
        
                                                            }
                                                                }
                                                                    //CONoUTrAW3( "[bDone]: " , bDone , "\r\n" ) ;
                                                                    __Z( bDone ) ;
                                                                    sIn >> bDone ;
                                                                    ZE( boolT , bDone ) ;
                                                                
                                                                    __( idFormat - 1 ) ;
                                                                    sIn >> idFormat ;
                                                                    ZE( countT , idFormat ) ;
                                                                
                                                                    __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
                                                                    sIn >> finger ;
                                                                    ZE( countT , finger ) ;
                                                                
                                                                    sock.readF( tinP , sIn ) ;
                                                                    soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                                                                
                                                                    sock.writeF( tinP , sOut ) ;
                                                                    sOut << (strokeS*)0 ; //psttPaypalProtectionEligibility ;
                                                                    sOut << (strokeS*)0 ; //psttPaypalPayerStatus ;
                                                                    sOut << (strokeS*)0 ; //psttPaypalPayerId ;
                                                                    sOut << (strokeS*)0 ; //psttPaypalPayerEmail ;
                                                                    sOut << (strokeS*)0 ; //psttCharset ;
                                                                    sOut << (strokeS*)0 ; //psttZipAt ;
                                                                    sOut << (strokeS*)0 ; //psttResidenceCountry ;
                                                                    sOut << (strokeS*)0 ; //psttLastName ;
                                                                    sOut << (strokeS*)0 ; //psttFirstName ;
                                                                    sOut << (strokeS*)0 ; //psttAddressStatus ;
                                                                    sOut << (strokeS*)0 ; //psttAddressCountry ;
                                                                    sOut << (strokeS*)0 ; //psttAddressZip ;
                                                                    sOut << (strokeS*)0 ; //psttAddressCountryCode ;
                                                                    sOut << (strokeS*)0 ; //psttAddressState ;
                                                                    sOut << (strokeS*)0 ; //psttAddressCity ;
                                                                    sOut << (strokeS*)0 ; //psttAddressStreet ;
                                                                    sOut << (strokeS*)0 ; //psttAddressName ;
                                                                    sOut << (countT)( flagsMode | fliACCOUNTmODE_OWNERcONFIRMED ) ;
                                                                    sOut << idAccountFrom ;
                                                                    sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_SETaCCOUNTdESCRIPTION ;
                                                                    sOut << (countT)1 ;
                                                                    sOut << (countT)FINGERnEG_LISTsERVERcMD ;
                                                                    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
                                                                    
                                                                    sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
                                                                    socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                                                {
                                                                if( !( flagsMode & fliACCOUNTmODE_OWNERcONFIRMED ) )
        
                                                                }
                                                                    //CONoUTrAW3( "[flagsMode]: " , flagsMode , "\r\n" ) ;
                                                                    if( bExists ) sIn >> flagsMode ;
        
                                                                    sIn >> bExists ;
                                                                    ZE( boolT , bExists ) ;
                                                                    
                                                                    __( idFormat - 1 ) ;
                                                                    sIn >> idFormat ;
                                                                    ZE( countT , idFormat ) ;
                                                                    
                                                                    __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
                                                                    sIn >> finger ;
                                                                    ZE( countT , finger ) ;
                                                                    
                                                                    sock.readF( tinP , sIn ) ;
                                                                    soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                                                                    
                                                                    sock.writeF( tinP , sOut ) ;
                                                                    sOut << idAccountFrom ;
                                                                    sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_QUERYaCCOUNTdESCRIPTION ;
                                                                    sOut << (countT)1 ;
                                                                    sOut << (countT)FINGERnEG_LISTsERVERcMD ;
                                                                    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
                                                                    
                                                                    sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
                                                                    socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                                                {
                                                                ZE( flagsT , flagsMode ) ;
                                                            {
                                                            //FLAG THIS ACCOUNT AS "OWNER CONFIRMED"
        
                                                            TN( tSuffix , "" ) ; tSuffix = tDot+TF4(idAccountFrom,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(ifcEMAIL_DOUBLEbLINDsUFFIX "\r\n") ;
        
                                                            const countT idAccountFrom = queryIdAccountFromEmailF( tinP , psttFrom ) ;
        
                                                            TN( tcr , "\r\n" ) ;
                                                            TN( tDot , "." ) ;
            
                                                            ) ;
            
                                                                "\r\n"
                                                                "Here is a list of all of the IdeaFarm " "(tm) Password Email addresses that are active\r\nfor you:\r\n"
                                                                "\r\n"
                                                                "Subject: IdeaFarm " "(tm) Password Email: Your active accounts listed\r\n"
            
                                                            TN( tRpt ,
                                                        {
                                                        else if( !etThread.strCompareF( tinP , psttw , T("!enableRelaysForSender") ) )
                                                        //}
                                                        //    }
                                                        //        etThread.boxPutF( tinP , T("//smtp/hello@ideafarm.com/")+T(psttFrom) , tSay , tSay.csF( tinP ) ) ;
                                                        //    
                                                        //        ) ;
                                                        //        
                                                        //            "!formEnd;\r\n"
                                                        //            "!lastNameContains:  []\r\n"
                                                        //            "!lastNameExact:     []\r\n"
                                                        //            "!firstNameContains: []\r\n"
                                                        //            "!firstNameExact:    []\r\n"
                                                        //            "!formBegin:search;\r\n"
                                                        //            "\r\n"
                                                        //            "Click your Reply button; then insert your search values between the square brackets below.  All fields are case insensitive.\r\n"
                                                        //            "\r\n"
                                                        //            "Subject: IdeaFarm " "(tm) Hello <> Search Form\r\n"
                                                        //        tSay = T(
                                                        //    {                                                            
                                                        //    if( bDefaultReply )
                                                        //
                                                        //    }
                                                        //        while( idf ) ;
                                                        //        }
                                                        //            }
                                                        //                etThread.delF( tinP , psttw ) ;
                                                        //                }
                                                        //                    }
                                                        //                        etThread.delF( tinP , pstt1l ) ;
                                                        //                        }
                                                        //                            }
                                                        //                                }
                                                        //                                    etThread.delF( tinP , psttw ) ;
                                                        //                                    etThread.delF( tinP , psttw2 ) ;
                                                        //                                    }
                                                        //                                        }
                                                        //                                            }
                                                        //                                                etThread.delF( tinP , psttw3 ) ;
                                                        //                                                }
                                                        //                                                    }
                                                        //                                                        }
                                                        //                                                            etThread.delF( tinP , psttListEntry ) ;
                                                        //                                                            etThread.delF( tinP , psttSubEmail ) ;
                                                        //                                            
                                                        //                                                            }
                                                        //                                                                etThread.boxPutF( tinP , T("//smtp/")+T(psttSubEmail)+T("/")+T(psttFrom) , tOpener , tOpener.csF( tinP ) ) ;
                                                        //                                            
                                                        //                                                                ;
                                                        //                                            
                                                        //                                                                    "\r\n")+T(info.psttHelloGreeting)
                                                        //                                                                    "--------------------------------------------------------\r\n"
                                                        //                                                                    "Autoresponse from your IdeaFarm " "(tm) Hello correspondent:\r\n"
                                                        //                                                                    "--------------------------------------------------------\r\n"
                                                        //                                                                    "\r\n"
                                                        //                                                                    "\r\n"
                                                        //                                            
                                                        //                                                                if( info.psttHelloGreeting && info.psttHelloGreeting->idAdam ) tOpener += T(
                                                        //                                            
                                                        //                                                                ) ;
                                                        //                                            
                                                        //                                                                    "  Your reply will be relayed to the IdeaFarm " "(tm) Hello correspondent that you selected."
                                                        //                                                                    "Begin your conversation by replying to this note."
                                                        //                                                                    "\r\n"
                                                        //                                                                    "  You may report this possible security compromise of your email or of your account by logging in to IDEAFARM.COM.\r\n"
                                                        //                                                                    "If this was done without your knowledge, you do not need to do anything."
                                                        //                                                                    "\r\n"
                                                        //                                                                    "    ")+T(psttListEntry)+T("\r\n"
                                                        //                                                                    "\r\n"
                                                        //                                                                    "This was sent to you because you, or someone impersonating you, sent an email to hello@ideafarm.com that requested that IdeaFarm " "(tm) Hello put you into contact with a listed person:\r\n"
                                                        //                                                                    "\r\n"
                                                        //                                                                    "Subject: IdeaFarm " "(tm) Hello <> The new conversation that you requested.\r\n"
                                                        //                                            
                                                        //                                                                TN( tOpener , "" ) ; tOpener = T(
                                                        //                                                            {
                                                        //                                            
                                                        //                                                            etThread.strMakeF( tinP , psttSubEmail , TF4(idSubOfClickee,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+tDot+TF4(idAccClickee,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T(".doubleblind.1@ideafarm.com") ) ; ___( psttSubEmail ) ;
                                                        //                                                            TN( tDot , "." ) ;
                                                        //                                            
                                                        //                                                            ZE( strokeS* , psttSubEmail ) ;
                                                        //                                            
                                                        //                                                            }
                                                        //                                                                STRfUSEsAFE( psttListEntry , info.psttZipAt  )
                                                        //                                                                STRfUSEsAFE( psttListEntry , psttSep )
                                                        //                                                                STRfUSEsAFE( psttListEntry , info.psttResidenceCountry )
                                                        //                                                                STRfUSEsAFE( psttListEntry , psttSep )
                                                        //                                                                STRfUSEsAFE( psttListEntry , info.psttAddressName )
                                                        //                                                                STRfUSEsAFE( psttListEntry , psttSep )
                                                        //                                                                STRfUSEsAFE( psttListEntry , info.psttAddressCity )
                                                        //                                                                STRfUSEsAFE( psttListEntry , psttSep )
                                                        //                                                                STRfUSEsAFE( psttListEntry , info.psttAddressZip )
                                                        //                                                                STRfUSEsAFE( psttListEntry , psttSep )
                                                        //                                                                STRfUSEsAFE( psttListEntry , info.psttAddressCountryCode )
                                                        //                                                                strokeS* psttSep = tSep ;
                                                        //                                                                TN( tSep , " <> " ) ;
                                                        //                                                
                                                        //                                                                etThread.strMakeF( tinP , psttListEntry , 0 , TOCK ) ; ___( psttListEntry ) ;
                                                        //                                            
                                                        //                                                            {
                                                        //                                                            ZE( strokeS* , psttListEntry ) ;
                                                        //                                                            accountS info( tinP , etThread , idAccClickee , flACCOUNT1_null , flACCOUNT2_QUERYfLAGSmODE | flACCOUNT2_QUERYaDDRESScOUNTRYcODE | flACCOUNT2_QUERYaDDRESSzIP | flACCOUNT2_QUERYaDDRESScITY | flACCOUNT2_QUERYaDDRESSnAME | flACCOUNT2_QUERYrESIDENCEcOUNTRY | flACCOUNT2_QUERYzIPaT | flACCOUNT2_QUERYdIRECTORYgREETING ) ;
                                                        //                                                        {
                                                        //                                                        else
                                                        //                                                        if( !idSubOfClickee ) tSay += T(" The server unexpectedly was not able to create a subaccount for you.") ;
                                                        //                                            
                                                        //                                                        }
                                                        //                                                            }
                                                        //                                                                *newSub.pStkEmailRelay << psttEmailClickee ;
                                                        //                                                
                                                        //                                                                *newSub.pStkEmailPenpalExactOr << psttw ; psttw = 0 ;
                                                        //                                                                etThread.strMakeF( tinP , psttw , psttFrom ) ; ___( psttw ) ;
                                                        //                                                                ZE( strokeS* , psttw ) ;
                                                        //                                                
                                                        //                                                                subaccountS newSub( tinP , etThread , idAccClickee , idSubOfClickee , TF2(idAccClicker,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , T("IdeaFarm " "(tm) Directory Clicker") , T("IdeaFarm " "(tm) Directory Clickee") , fliSUBACCOUNTmODE_OWNERcONFIRMED | fliSUBACCOUNTmODE_OWNEDbYdIRECTORYoRhELLO | fliSUBACCOUNTmODE_RELAYrEPLYeNDScONVERSATION ) ;
                                                        //                                                                // fliSUBACCOUNTmODE_RELAYrEPLYeNDScONVERSATION MAKES THE CONVERSATION CLEANER SINCE ALL ITEMS REFER TO THE SAME EMAIL ADDRESS; THE PREFIX TO IDENTIFY THE RESPONDING RELAY IS NOT NEEDED BECAUSE THERE IS ALWAYS EXACTLY ONE RELAY
                                                        //                                                            {
                                                        //                                                            else
                                                        //                                                            }
                                                        //                                                                etThread.boxPutF( tinP , T("//smtp/hello@ideafarm.com/")+T(psttFrom)+T("///" ifcEMAIL_ERRORnOTIFIER) , tSay , tSay.csF( tinP ) ) ;
                                                        //                                                            
                                                        //                                                                ) ;
                                                        //                                                                
                                                        //                                                                    "Somewo at IdeaFarm " "(tm) Operations made boo boo #855.  Your command was not obeyed.  This has been reported.\r\n"
                                                        //                                                                    "\r\n"
                                                        //                                                                    "Subject: IdeaFarm " "(tm) Hello <> Oops!\r\n"
                                                        //
                                                        //                                                                tSay = T(
                                                        //                                                            {
                                                        //                                                            if( !psttEmailClickee )
                                                        //                                            
                                                        //                                                            }
                                                        //                                                                sIn >> psttEmailClickee ; ___( psttEmailClickee ) ;
                                                        //                                                            
                                                        //                                                                __( idFormat - 1 ) ;
                                                        //                                                                sIn >> idFormat ;
                                                        //                                                                ZE( countT , idFormat ) ;
                                                        //                                                            
                                                        //                                                                __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
                                                        //                                                                sIn >> finger ;
                                                        //                                                                ZE( countT , finger ) ;
                                                        //                                                            
                                                        //                                                                sock.readF( tinP , sIn ) ;
                                                        //                                                                soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                                                        //                                                            
                                                        //                                                                sock.writeF( tinP , sOut ) ;
                                                        //                                                                sOut << idAccClickee ;
                                                        //                                                                sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKeMAILfROMiDaCCOUNT ;
                                                        //                                                                sOut << (countT)1 ;
                                                        //                                                                sOut << (countT)FINGERnEG_LISTsERVERcMD ;
                                                        //                                                                soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
                                                        //                                                            
                                                        //                                                                sock.connectF( tinP , homeS::homeIF().idPortListServerEmailIdAccount ) ;
                                                        //                                                                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                                        //                                                            {
                                                        //                                                            ZE( strokeS* , psttEmailClickee ) ;
                                                        //                                                        {
                                                        //                                                        if( !idSubOfClickee )
                                                        //                                                
                                                        //                                                        }
                                                        //                                                            tSay += T(" ]") ;
                                                        //                                                            }
                                                        //                                                                }
                                                        //                                                                    if( idSubOfClickee ) break ;
                                                        //                                                    
                                                        //                                                                    }
                                                        //                                                                        }
                                                        //                                                                            break ;
                                                        //                                                                            tSay += T(" FOUND") ;
                                                        //                                                                            idSubOfClickee = idSub ;
                                                        //                                                                        {
                                                        //                                                                        if( !etThread.strCompareF( tinP , psttw , psttFrom ) )
                                                        //                                                                        etThread.strConvertToLowerCaseF( tinP , psttw ) ;
                                                        //                                                                        *sub.pStkEmailPenpalExactOr >> psttw ;
                                                        //                                                                        ZE( strokeS* , psttw ) ;
                                                        //                                                                    {
                                                        //                                                                    while( *sub.pStkEmailPenpalExactOr )
                                                        //                                                                {
                                                        //                                                                if( F(sub.flagsMode) & fliSUBACCOUNTmODE_OWNEDbYdIRECTORYoRhELLO && !( F(sub.flagsMode) & fliSUBACCOUNTmODE_DELETED ) && sub.pStkEmailPenpalExactOr )
                                                        //                                                    
                                                        //                                                                tSay += T("{")+TF2(sub.flagsMode,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("}") ;
                                                        //                                                                subaccountS sub( tinP , etThread , idAccClickee , idSub , flSUBACCOUNT_QUERYfLAGSmODE | flSUBACCOUNT_QUERYeMAILpENPALeXACToR ) ;
                                                        //                                                    
                                                        //                                                                tSay += tb+TF2(idSub,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
                                                        //                                                                stkIdSub >> idSub ;
                                                        //                                                                ZE( countT , idSub ) ;
                                                        //                                                            {
                                                        //                                                            while( stkIdSub )
                                                        //                                                            stkIdSubC stkIdSub( tinP , idAccClickee ) ;
                                                        //                                                        {
                                                        //                                                        ZE( countT , idSubOfClickee ) ;
                                                        //                                                
                                                        //                                                        TN( tb , " " ) ;
                                                        //                                                        TN( tSay , "idSub list: [" ) ;
                                                        //                                                    {
                                                        //                                                    else
                                                        //                                                    }
                                                        //                                                        etThread.boxPutF( tinP , T("//smtp/hello@ideafarm.com/")+T(psttFrom) , tSay , tSay.csF( tinP ) ) ;
                                                        //                                                    
                                                        //                                                        ) ;
                                                        //                                                        
                                                        //                                                            "IdeaFarm " "(tm) Hello thinks that you selected yourself, so is doing nothing in response to that selection other than sending this notice to you.\r\n"
                                                        //                                                            "\r\n"
                                                        //                                                            "Subject: IdeaFarm " "(tm) Hello <> Oops!\r\n"
                                                        //
                                                        //                                                        tSay = T(
                                                        //                                                    {
                                                        //                                                    if( idAccClickee == idAccClicker )
                                                        //                                                    //CS:CODEsYNC: b750104 1d20005
                                                        //
                                                        //                                                    //CONoUTrAW( T("******************* CONTACT: ")+TF4(idAccClickee,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,0,36)+T("\r\n") ) ;
                                                        //                                                {
                                                        //                                                if( !etThread.strCompareF( tinP , psttw3 , tY ) )
                                                        //                                                etThread.strConvertToLowerCaseF( tinP , psttw3 ) ;
                                                        //                                                etThread.strSubstringF( tinP , psttw3 , idf , idl , psttc1 ) ; ___( psttw3 ) ;
                                                        //                                                countT idl = idv2 - 1 ;
                                                        //                                                countT idf = idv1 + 1 ;
                                                        //                                                ZE( strokeS* , psttw3 ) ;
                                                        //                                            {
                                                        //                                            if( idv1 && idv1 + 1 < idv2 )
                                                        //
                                                        //                                            countT idv2 = etThread.strIdF( tinP , tClose , psttc1 ) ;
                                                        //                                            countT idv1 = etThread.strIdF( tinP , tOpen  , psttc1 ) ;
                                                        //                                        {
                                                        //                                        if( idAccClickee )
                                                        //
                                                        //                                        countT idAccClickee = etThread.strDigitsToSCountF( tinP , psttw2 , 36 ) ;
                                                        //                                        etThread.strSubstringF( tinP , psttw2 , idf2 , sttq2 , tDot , psttw ) ; ___( psttw2 ) ;  // "123"
                                                        //                                        etThread.delF( tinP , psttw2 ) ;
                                                        //                                    {
                                                        //                                    if( !etThread.strCompareF( tinP , tContact , psttw2 ) )
                                                        //                                    etThread.strSubstringF( tinP , psttw2 , idf2 , sttq2 , tDot , psttw ) ; ___( psttw2 ) ;  // "contact"
                                                        //                                    strokeS sttq2( 0 , sc_IGNOREqUOTES ) ;
                                                        //                                    countT idf2 = 1 ;
                                                        //                                    ZE( strokeS* , psttw2 ) ;
                                                        //
                                                        //                                    etThread.strSubstringF( tinP , psttw , idf , idl , psttc1 ) ; ___( psttw ) ;   // "contact:123"
                                                        //                                    countT idl = idk2 - 1 ;
                                                        //                                    countT idf = idk1 + 1 ;
                                                        //                                    ZE( strokeS* , psttw ) ;
                                                        //                                {
                                                        //                                if( idk1 && idk1 + 1 < idk2 )
                                                        //                                countT idk2 = etThread.strIdF( tinP , tColon   , psttc1 ) ;
                                                        //                                countT idk1 = etThread.strIdF( tinP , tExclaim , psttc1 ) ;
                                                        //                            {
                                                        //                        {
                                                        //                        FORsTRINGSiN1( pstt1l )
                                                        //                        etThread.strWordsOldF( tinP , pstt1l , psttBodyWothTock , sttq , T("\r\n") ) ; ___( pstt1l ) ;
                                                        //                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                        //                        ZE( strokeS* , pstt1l ) ;
                                                        //                    {
                                                        //                    //CAPTURE THE VALUES
                                                        //
                                                        //                    if( bDefaultReply ) bDefaultReply = 0 ;
                                                        //                {
                                                        //                if( psttw && psttw->idAdam )
                                                        //
                                                        //                etThread.strSubstringF( tinP , psttw , idf , sttq , tTagEnd , psttBodyWothTock ) ; ___( psttw ) ;
                                                        //                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                        //            {
                                                        //            if( idf )
                                                        //
                                                        //            etThread.delF( tinP , psttw ) ;
                                                        //            etThread.strSubstringF( tinP , psttw , idf , sttq , tTagBeginContact , psttBodyWothTock ) ; ___( psttw ) ;
                                                        //            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                        //            ZE( strokeS* , psttw ) ;
                                                        //        {
                                                        //        do
                                                        //        idf = 1 ;
                                                        //        countT idAccClicker = queryIdAccountFromEmailF( tinP , psttFrom ) ;
                                                        //        //PROCES FORMS: CONTACT
                                                        //
                                                        //        while( idf ) ;
                                                        //        }
                                                        //            }
                                                        //                etThread.delF( tinP , psttw ) ;
                                                        //                }
                                                        //                    etThread.boxPutF( tinP , T("//smtp/hello@ideafarm.com/")+T(psttFrom) , tSay , tSay.csF( tinP ) ) ;
                                                        //                
                                                        //                    etThread.delF( tinP , psttForm ) ;
                                                        //                    ) ;
                                                        //                    
                                                        //                        "!formEnd;\r\n"
                                                        //                        )+T(psttForm)+T(
                                                        //                        "!formBegin:contact;\r\n"
                                                        //                        "\r\n"
                                                        //                        "lastNameContains:  \"")+tLathNameContainsValue+T("\"\r\n"
                                                        //                        "lastNameExact:     \"")+tLathNameExactValue+T("\"\r\n"
                                                        //                        "firstNameContains: \"")+tWothNameContainsValue+T("\"\r\n"
                                                        //                        "firstNameExact:    \"")+tWothNameExactValue+T("\"\r\n"
                                                        //                        "\r\n"
                                                        //                        "The search specifications used to compile this form for you were:\r\n"
                                                        //                        "\r\n"
                                                        //                        "Click your Reply button; then insert the letter 'y' (without quotes) within the square brackets next to each person that you want to contact.\r\n"
                                                        //                        "\r\n"
                                                        //                        "Subject: IdeaFarm " "(tm) Hello <> Say Hello Form\r\n"
                                                        //
                                                        //                    tSay = T(
                                                        //
                                                        //                    }
                                                        //                        etThread( tinP , pStkIdAcc ) ;
                                                        //                        }
                                                        //                            }
                                                        //                                }
                                                        //                                    STRfUSEsAFE( psttForm , psttCRLF )
                                                        //                                    }
                                                        //                                        STRfUSEsAFE( psttForm , info.psttZipAt )
                                                        //                                        STRfUSEsAFE( psttForm , psttSep )
                                                        //                                    {
                                                        //                                    if( info.psttZipAt && info.psttZipAt->idAdam )
                                                        //                                    STRfUSEsAFE( psttForm , info.psttResidenceCountry )
                                                        //                                    STRfUSEsAFE( psttForm , psttSep )
                                                        //                                    STRfUSEsAFE( psttForm , info.psttAddressName )
                                                        //                                    STRfUSEsAFE( psttForm , psttSep )
                                                        //                                    STRfUSEsAFE( psttForm , info.psttAddressCity )
                                                        //                                    STRfUSEsAFE( psttForm , psttSep )
                                                        //                                    STRfUSEsAFE( psttForm , info.psttAddressZip )
                                                        //                                    STRfUSEsAFE( psttForm , psttSep )
                                                        //                                    STRfUSEsAFE( psttForm , info.psttAddressCountryCode )
                                                        //                                    STRfUSEsAFE( psttForm , (strokeS*)T(":[] ") )
                                                        //                                    STRfUSEsAFE( psttForm , (strokeS*)TF2(idAcc,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) )
                                                        //                                    STRfUSEsAFE( psttForm , (strokeS*)T("!contact.") )
                                                        //
                                                        //                                    if( bContinue ) continue ;
                                                        //                                    etThread.delF( tinP , psttLowerLathName ) ;
                                                        //                                    etThread.delF( tinP , psttLowerWothName ) ;
                                                        //
                                                        //                                    if( tLathNameContainsValue.csF( tinP ) &&     !etThread.strIdF( tinP , tLathNameContainsValue , psttLowerLathName ) ) bContinue = 1 ;
                                                        //                                    if( tLathNameExactValue.csF(    tinP ) && etThread.strCompareF( tinP , tLathNameExactValue    , psttLowerLathName ) ) bContinue = 1 ;
                                                        //                                    if( tWothNameContainsValue.csF( tinP ) &&     !etThread.strIdF( tinP , tWothNameContainsValue , psttLowerWothName ) ) bContinue = 1 ;
                                                        //                                    if( tWothNameExactValue.csF(    tinP ) && etThread.strCompareF( tinP , tWothNameExactValue    , psttLowerWothName ) ) bContinue = 1 ;
                                                        //                                    ZE( boolT , bContinue ) ;
                                                        //
                                                        //                                    etThread.strConvertToLowerCaseF( tinP , psttLowerLathName , info.psttLastName ) ; ___( psttLowerLathName ) ;
                                                        //                                    etThread.strConvertToLowerCaseF( tinP , psttLowerWothName , info.psttFirstName ) ; ___( psttLowerWothName ) ;
                                                        //                                    ZE( strokeS* , psttLowerLathName ) ;
                                                        //                                    ZE( strokeS* , psttLowerWothName ) ;
                                                        //
                                                        //                                    //TN( tLathNameContainsValue , "" ) ;
                                                        //                                    //TN( tLathNameExactValue    , "" ) ;
                                                        //                                    //TN( tWothNameContainsValue , "" ) ;
                                                        //                                    //TN( tWothNameExactValue    , "" ) ;
                                                        //                                    //U::
                                                        //
                                                        //                                {
                                                        //                                //U::if( F(info.flagsMode) & fliACCOUNTmODE_LISTmEhELLO )
                                                        //                                if( F(info.flagsMode) & fliACCOUNTmODE_LISTmEhELLO )
                                                        //                    
                                                        //                                accountS info( tinP , etThread , idAcc , flACCOUNT1_null , flACCOUNT2_QUERYfLAGSmODE | flACCOUNT2_QUERYaDDRESScOUNTRYcODE | flACCOUNT2_QUERYaDDRESSzIP | flACCOUNT2_QUERYaDDRESScITY | flACCOUNT2_QUERYaDDRESSnAME | flACCOUNT2_QUERYrESIDENCEcOUNTRY | flACCOUNT2_QUERYzIPaT | flACCOUNT2_QUERYfIRSTnAME | flACCOUNT2_QUERYlASTnAME ) ;
                                                        //                    
                                                        //                                *pStkIdAcc >> idAcc ;
                                                        //                                ZE( countT , idAcc ) ;
                                                        //                            {
                                                        //                            while( *pStkIdAcc )
                                                        //                            etThread.strMakeF( tinP , psttForm , 0 , TOCK ) ; ___( psttForm ) ;
                                                        //                            
                                                        //                            strokeS* psttCRLF = tcr ;
                                                        //                            TN( tcr    , "\r\n" ) ;
                                                        //                            strokeS* psttSep = tSep ;
                                                        //                            TN( tSep , " <> " ) ;
                                                        //                    
                                                        //                            }
                                                        //                                }
                                                        //                                    *pStkIdAcc << idAcc ;
                                                        //                                    sIn >> idAcc ;
                                                        //                                    ZE( countT , idAcc ) ;
                                                        //                                {
                                                        //                                while( cIdAccount -- )
                                                        //                        
                                                        //                                //CONoUTrAW3( "[cIdAccount]: " , cIdAccount , "\r\n" ) ;
                                                        //                                sIn >> cIdAccount ;
                                                        //                                ZE( countT , cIdAccount ) ;
                                                        //                        
                                                        //                                __( idFormat - 1 ) ;
                                                        //                                sIn >> idFormat ;
                                                        //                                ZE( countT , idFormat ) ;
                                                        //                            
                                                        //                                __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
                                                        //                                sIn >> finger ;
                                                        //                                ZE( countT , finger ) ;
                                                        //                            
                                                        //                                sock.readF( tinP , sIn ) ;
                                                        //                                soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                                                        //                            
                                                        //                                sock.writeF( tinP , sOut ) ;
                                                        //                                sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT ;
                                                        //                                sOut << (countT)1 ;
                                                        //                                sOut << (countT)FINGERnEG_LISTsERVERcMD ;
                                                        //                                soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
                                                        //                            
                                                        //                                sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
                                                        //                                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                                        //                            {
                                                        //                        {
                                                        //                        if( pStkIdAcc )
                                                        //                    
                                                        //                        etThread( tinP , pStkIdAcc , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY ) ; ___( pStkIdAcc ) ;
                                                        //                        ZE( stackC* , pStkIdAcc ) ;
                                                        //                    {
                                                        //                    ZE( strokeS* , psttForm ) ;
                                                        //
                                                        //                    }
                                                        //                        etThread.delF( tinP , pstt1l ) ;
                                                        //                        }
                                                        //                            }
                                                        //                                }
                                                        //                                    }
                                                        //                                        }
                                                        //                                            etThread.delF( tinP , psttw ) ;
                                                        //                                            *pto = T(psttw) ;
                                                        //                                            etThread.strConvertToLowerCaseF( tinP , psttw ) ;
                                                        //                                            etThread.strSubstringF( tinP , psttw , idf , idl , psttc1 ) ; ___( psttw ) ;
                                                        //                                            countT idl = idv2 - 1 ;
                                                        //                                            countT idf = idv1 + 1 ;
                                                        //                                            ZE( strokeS* , psttw ) ;
                                                        //                                        {
                                                        //                                        if( idv1 && idv1 + 1 < idv2 )
                                                        //
                                                        //                                        countT idv2 = etThread.strIdF( tinP , tClose , psttc1 ) ;
                                                        //                                        countT idv1 = etThread.strIdF( tinP , tOpen  , psttc1 ) ;
                                                        //                                    {
                                                        //                                    if( pto )
                                                        //
                                                        //                                    }
                                                        //                                        etThread.delF( tinP , psttw ) ;
                                                        //                                        else if( !etThread.strCompareF( tinP , psttw , tLathNameContainsKey ) ) pto = &tLathNameContainsValue ;
                                                        //                                        else if( !etThread.strCompareF( tinP , psttw , tLathNameExactKey    ) ) pto = &tLathNameExactValue ;
                                                        //                                        else if( !etThread.strCompareF( tinP , psttw , tWothNameContainsKey ) ) pto = &tWothNameContainsValue ;
                                                        //                                             if( !etThread.strCompareF( tinP , psttw , tWothNameExactKey    ) ) pto = &tWothNameExactValue ;
                                                        //
                                                        //                                        etThread.strSubstringF( tinP , psttw , idf , idl , psttc1 ) ; ___( psttw ) ;
                                                        //                                        countT idl = idk2 - 1 ;
                                                        //                                        countT idf = idk1 + 1 ;
                                                        //                                        ZE( strokeS* , psttw ) ;
                                                        //                                    {
                                                        //                                    ZE( textC* , pto ) ;
                                                        //                                {
                                                        //                                if( idk1 && idk1 + 1 < idk2 )
                                                        //                                countT idk2 = etThread.strIdF( tinP , tColon   , psttc1 ) ;
                                                        //                                countT idk1 = etThread.strIdF( tinP , tExclaim , psttc1 ) ;
                                                        //                            {
                                                        //                        {
                                                        //                        FORsTRINGSiN1( pstt1l )
                                                        //                        etThread.strWordsOldF( tinP , pstt1l , psttBodyWothTock , sttq , T("\r\n") ) ; ___( pstt1l ) ;
                                                        //                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                        //                        ZE( strokeS* , pstt1l ) ;
                                                        //                    {
                                                        //                    //CAPTURE THE VALUES
                                                        //
                                                        //                    if( bDefaultReply ) bDefaultReply = 0 ;
                                                        //                {
                                                        //                if( psttw && psttw->idAdam )
                                                        //
                                                        //                etThread.strSubstringF( tinP , psttw , idf , sttq , tTagEnd , psttBodyWothTock ) ; ___( psttw ) ;
                                                        //                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                        //            {
                                                        //            if( idf )
                                                        //
                                                        //            etThread.delF( tinP , psttw ) ;
                                                        //            etThread.strSubstringF( tinP , psttw , idf , sttq , tTagBeginSearch , psttBodyWothTock ) ; ___( psttw ) ;
                                                        //            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                        //            ZE( strokeS* , psttw ) ;
                                                        //        {
                                                        //        do
                                                        //        countT idf = 1 ;
                                                        //        //PROCESS FORMS: SEARCH
                                                        //
                                                        //        debugF() ;
                                                        //
                                                        //        TN( tY , "y" ) ;
                                                        //        TN( tContact , "contact" ) ;
                                                        //        TN( tClose , "]" ) ;
                                                        //        TN( tOpen , "[" ) ;
                                                        //        TN( tColon , ":" ) ;
                                                        //        TN( tDot , "." ) ;
                                                        //        TN( tExclaim , "!" ) ;
                                                        //        TN( tLathNameContainsKey    , "lastNameContains" ) ;
                                                        //        TN( tLathNameExactKey       , "lastNameExact" ) ;
                                                        //        TN( tWothNameContainsKey    , "firstNameContains" ) ;
                                                        //        TN( tWothNameExactKey       , "firstNameExact" ) ;
                                                        //        TN( tLathNameContainsValue  , "" ) ;
                                                        //        TN( tLathNameExactValue     , "" ) ;
                                                        //        TN( tWothNameContainsValue  , "" ) ;
                                                        //        TN( tWothNameExactValue     , "" ) ;
                                                        //        TN( tTagBeginContact        , "!formBegin:contact;" ) ;
                                                        //        TN( tTagBeginSearch         , "!formBegin:search;" ) ;
                                                        //        TN( tTagEnd                 , "!formEnd;"          ) ;
                                                        //    {
                                                        //    if( psttBodyWothTock )
                                                        //    boolT bDefaultReply = 1 ;
                                                        //    TN( tSay , "" ) ;
                                                        //{
                                                        //else if( !etThread.strCompareF( tinP , psttw , T("!inspectbodyhello") ) )
                                                        //SUPPORT FOR hello@ideafarm.com COMMENTED OUT DUE TO DECISION TO NOT PROVIDE ANY FUNCTIONALITY TO ANONYMOUS INTERNET USERS
                                                        if( !etThread.strCompareF( tinP , psttw , T("!edit") ) ) bEditArchive = 1 ;
                                                    {
                                                    if( psttw && psttw->idAdam )
                                                    //CONoUTrAW( T("QQQQ ******** recipe: \"")+T(psttw)+T("\"\r\n") ) ;
                                                    *info.pStkRecipe >> psttw ; ___( psttw ) ;
                                                    ZE( strokeS* , psttw ) ;
                                                {
                                                if( info.pStkRecipe ) while( *info.pStkRecipe )
                                                ZE( boolT , bEditArchive ) ;
                                                subaccountS info( tinP , etThread , c3r.c3 , c3r.c2 , flSUBACCOUNT_QUERYrECIPE ) ;
                                                TELL( "obeying recipes" ) ;
                                                _INoLD_
    // RECIPES ********************************************************************************************************************************************
                                            {
                                            else
                                            }
                                                break ;
                                                if( POOP ) { POOPR } ;
        
                                                _OUT_
                                                etThread.delF( tinP , psttSubject ) ;
                                                etThread.delF( tinP , psttFrom ) ;
        
                                                flError |= flERROR_FALSEsENDER ;
                                                __1
                                                _INoLD_
                                                TELL( "false sender" ) ;
                                            {
                                            else if( bCheckFromInBody && tinP.pEtScratch->strCompareF( tinP , psttFrom , psttSource ) )
                                            }
                                                break ;
                                                if( POOP ) { POOPR } ;
        
                                                _OUT_
                                                etThread.delF( tinP , psttSubject ) ;
                                                etThread.delF( tinP , psttFrom ) ;
        
                                                flError |= flERROR_HIDDENsENDER ;
                                                __1
                                                _INoLD_
                                                TELL( "from is null" ) ;
                                            {
                                            if( !psttFrom )
                                            TELL( "inspecting psttFrom" ) ;
                                        {
                                        else
                                        }
                                            _OUT_
                                            etThread.delF( tinP , psttSubject ) ;
                                            etThread.delF( tinP , psttFrom ) ;
    
                                            flError |= flERROR_COULDnOThANDLErECIPIENT ;
                                            __1
                                            _INoLD_
                                            POOPR
                                            TELL( "resetting poop" ) ;
                                        {
                                        if( POOP )
                                        TELL( "inspecting poop after kv" ) ;
    
                                        }
                                            _OUT_
                                            }
                                                //}
                                                //    while( ~hWalk ) ;
                                                //    }
                                                //        LOGrAW( T("\"")+T(psttzKey)+T("\" : \"")+T(psttzv)+T("\"\r\n") ) ;
                                                //        strokeS* psttzv = (strokeS*)swsKeyValues.downF( tinP , hWalk ) ;
                                                //    {
                                                //    do
                                                //    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                //{
                                                //if( swsKeyValues )
    
                                                }
                                                    }
                                                        while( !bContentIsPlain && ~hWalk ) ;
                                                        }
                                                            tinP.pEtScratch->delF( tinP , psttw ) ;
                                                            bContentIsPlain = 1 ;
                                                            )
                                                                tinP.pEtScratch->strIdF( tinP , T("charset=us-ascii") , psttw )
                                                                tinP.pEtScratch->strIdF( tinP , T("text/plain"      ) , psttw ) &&
                                                            (
                                                            if
    
                                                            tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttw , psttzv ) ; ___( psttw ) ;
                                                            ZE( strokeS* , psttw ) ;
                                                            strokeS* psttzv = (strokeS*)swsKeyValues.downF( tinP , hWalk ) ;
                                                        {
                                                        do
                                                        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                    {
                                                    if( swsKeyValues )
                                                {
                                                if( !tinP.pEtScratch->strCompareF( tinP , psttzKey , T("content-type") ) )
    
                                                psttzKey = (strokeS*)swsKeyValues.leverF( tinP , idf ) ;
                                            {
                                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                            countT cFlavors = swsKeyValues.cFlavorsF( tinP ) ;
                                            TELL( "inspecting kv" ) ;
                                            _INoLD_
                                        {
                                        //U::SET psttFrom psttSubject HERE
                                        ZE( boolT , bContentIsPlain ) ;
    
                                        //LOGrAW3( "parseHeaderF returned and now poop is " , POOP , "\r\n" ) ;
                                        parseHeaderF( tinP , *tinP.pEtScratch , flError , swsKeyValues , psttzKey , psttFrom , psttSubject , psttHeader ) ; ___( psttFrom ) ; ___( psttSubject ) ;

                                        //LOGrAW3( "calling parseHeaderF; poop is " , POOP , "\r\n" ) ;
                                        switchStackC swsKeyValues( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , flSTACKc_null , psttzKey , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
                                        ZE( strokeS* , psttzKey ) ;
                                        
                                        ZE( strokeS* , psttSubject ) ; //U::OBSOLETED BY swsKeyValues
                                        ZE( strokeS* , psttFrom ) ;    //U::OBSOLETED BY swsKeyValues
    
                                        count3S& c3r = *(count3S*)&stRecipient.downF( tinP , hWalk ) ;
                                        TELL( "loop beginning for a recipient" ) ;
                                        _INoLD_
                                    {
                                    do
                                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    const countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;

                                    etThread( tinP , pStkSetting , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkSetting ) ;
                                    ZE( stackC* , pStkSetting ) ;
                                    TELL( "allocating pStkSetting" ) ;

                                    _INoLD_
                                {
                                if( !etThread && stRecipient )
                                TELL( "inspecting stRecipient" ) ;
                                //LOGrAW3( "stRecipient is " , stRecipient , "\r\n" ) ;
                                _INoLD_
                            {
                            TELL( "writing the received item to disk" ) ;
                            //LOGrAW( "writing received item to disk\r\n" ) ;
                            _INoLD_
                        {
                        if( !POOP && !etThread )
                        TN( tErrAll , "" ) ;
                        TELL( "cleaning up after handling this mail from transaction" ) ;
                        //LOGrAW3( "1: poop is " , POOP , "\r\n" ) ;
    
                        if( !stRecipient ) flError |= flERROR_NOvALIDrECIPIENTS ;
                        if( !psttSource    ) flError |= flERROR_SECRETsENDER ;
    
                        if( psttSource && !psttSource->idAdam ) etThread.delF( tinP , psttSource ) ;
                
                        //LOGrAW( T("received soixlOld:\r\n\"")+T(psttSoixlOld)+T("\"\r\n") ) ;
                        //LOGrAW( T("received header:\r\n\"")+T(psttHeader)+T("\"\r\n") ) ;
                        TELL( "after reading data" ) ;
    
                        }
                            _OUT_
                            tinP.pEtScratch->delF( tinP , posti ) ;
    
                            }
                                if( !bData ) flError |= flERROR_NOdATA ;
                                }
                                    }
                                        break ;
                                        flError |= flERROR_DATAlINEtOOlONG ;
                                    {
                                    else
                                    }
                                        }
                                            }
                                                break ;
                                                if( !bData ) bData = 1 ;
                                                etThread.fileWriteF( tinP , hFileBody , posti , offi ) ;

                                                }
                                                    tinP.pEtScratch->strFuseF( tinP , psttBodyWothTock , T(posti) ) ;
                                                    posti[ offi ] = 0 ;
                                                {
                                                if( offi <= psttBodyWothTock[ 2 ].idAdam )
                                            {
                                            default :
                                            }
                                                break ;
                                                if( POOP ) flError |= flERROR_SOIXLoLDtOOlARGE ;
                                                tinP.pEtScratch->strFuseF( tinP , psttSoixlOld , T(posti) ) ;
                                                posti[ offi ] = 0 ;
                                            {
                                            case 2 :
                                            }
                                                break ;
                                                if( POOP ) flError |= flERROR_HEADERtOOlARGE ;
                                                tinP.pEtScratch->strFuseF( tinP , psttHeader , T(posti) ) ;
                                                posti[ offi ] = 0 ;
                                            {
                                            case 1 :
                                        {
                                        switch( idPhase )
    
                                        posti[ offi ++ ] = '\n' ;
                                        posti[ offi ++ ] = '\r' ;
                                    {
                                    if( offi < costa - 2 )
    
                                    }
                                        }
                                            ;
                                                : 3
                                                ? 2
                                            idPhase = offi > 6 && posti[ 0 ] == '!' && posti[ 1 ] == 'S' && posti[ 2 ] == 'O' && posti[ 3 ] == 'I' && posti[ 4 ] == 'L' && posti[ 5 ] == ' '
                                            bInspectNewParagraph = 0 ;
                                        {
                                        if( bInspectNewParagraph )
    
                                        }
                                            else        for( countT off2 = 0 ; off2 < offi ; off2 ++ ) posti[ off2 ] = posti[ off2 + 1 ] ;
                                            if( !offi ) break ;
                                            offi -- ;
                                        {
                                        if( posti[ 0 ] == '.' )
                                    {
                                    else
                                    }
                                        else if( idPhase == 2 ) idPhase = 3 ;
                                             if( idPhase == 1 ) bInspectNewParagraph = 1 ;
                                    {
                                    if( !offi )
    
                                    //}
                                    //    LOGrAW3( "phase " , idPhase , T(" | ")+tLog+T("\r\n") ) ;
                                    //    }
                                    //        etThread.delF( tinP , psttTrunc ) ;
                                    //        tLog = T(psttTrunc) ;
                                    //        tinP.pEtScratch->strSubstringF( tinP , psttTrunc , idf , idl , T(posti) ) ; ___( psttTrunc ) ;
                                    //        countT idl = TUCK ;
                                    //        countT idf = 1 ;
                                    //        ZE( strokeS* , psttTrunc ) ;
                                    //        LOGrAW3( "line of length " , tLog.csF( tinP ) , " will be truncated for display in this log\r\n" ) ;
                                    //    {
                                    //    if( tLog.csF( tinP ) > TUCK )
                                    //    TN( tLog , "" ) ; tLog = T(posti) ;
                                    //{
                                    posti[ offi ] = 0 ;
                                    //U::
                                    
                                    }
                                        break ;
                                        flError |= flERROR_DATAlINEtOOlONG ;
                                    {
                                    if( POOP )
                                    __( offi == costa ) ;

                                    pso->readWoLineF( tinP , offi , posti , costa ) ;
                                    ZE( countT   , offi ) ;
                                {
                                for(;;)
                                ZE( boolT , bInspectNewParagraph ) ;
                                countT idPhase = 1 ; // 1:HEADER ; 2:SOIXLoLD ; 3:BODY
                                ZE( boolT , bData ) ;
                                { _INoLD_ etThread.fileOpenF( tinP , hFileBody , countTC() , tFileBody , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nCeF ) ; _OUT_ }
                                handleC hFileBody( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
    
                                //A:ASSUME: INCOMING DATA BEGINS WITH A HEADER LINE
                            {
                            if( posti )
                            tinP.pEtScratch->newF( tinP , LF , posti , costa ) ; ___( posti ) ;
                            const countT costa = TOCK * 0x10 ;
                            ZE( osTextT* , posti ) ;
    
                            tinP.pEtScratch->strMakeF( tinP , psttBodyWothTock , 0 , TOCK ) ; ___( psttBodyWothTock ) ;
                            tinP.pEtScratch->strMakeF( tinP , psttSoixlOld , 0 , TOCK ) ; ___( psttSoixlOld ) ;
                            tinP.pEtScratch->strMakeF( tinP , psttHeader , 0 , TOCK ) ; ___( psttHeader ) ;
    
                            // CAPACITY CONSTRAINT: LINE MUST BE LESS THAN 01 TOCK; NO LIMIT ON NUMBER OF LINES
                            // APPROACH
                            _INoLD_
                        {
                        if( !POOP )
                        ZE( strokeS* , psttBodyWothTock ) ;
                        ZE( strokeS* , psttSoixlOld ) ;
                        ZE( strokeS* , psttHeader ) ;
                        TELL( "reading data" ) ;
    
                        }
                            etThread.delF( tinP , psttu ) ;
                            tFileBody = T("///ideafarm/ephemeral/domains/com/ideafarm/ipdos/tmp/")+T(psttu) ;
                            etThread.strUniqueF( tinP , psttu ) ; ___( psttu ) ;
                            ZE( strokeS* , psttu ) ;
                        {
                        TN( tFileBody , "" ) ;
    
                        pso->writeF( tinP , "354 Start mail input; end with <CRLF>.<CRLF>\r\n" ) ;
                        TELL( "asking peer to send data" ) ;
    
                        __Z( stRecipient ) ;
    
                        }
                            __1 ;
                            flError |= flERROR_SECRETsENDER ;
                        {
                        if( !psttSource )
                        TELL( "detecting secret sender or no recipients" ) ;
                
                        }
                            break ;
                            etThread.delF( tinP , psttOutToPenpal ) ;
                            etThread.delF( tinP , psttSource ) ;
                        {
                        if( bQuit )

                        }
                            _OUT_
                            tinP.pEtScratch->delF( tinP , psttTo ) ;
                            }
                                pso->writeF( tinP , (osTextT*)tErr , tErr.csF( tinP ) ) ;
                                //TN( tErr , bBadFormat?"553 [bad format: \"":"553 [address does not exist: \"" ) ; tErr += T(psttTo)+T("\"; future connections from you will be denied; contact ideafarm.com to restore your access.]\r\n") ;
                                TN( tErr , bBadFormat?"553 [bad format: \"":"553 [address does not exist: \"" ) ; tErr += T(psttTo)+T("\"; you appear to be a spammer.  if you are, then thank you for working at ze""ro pay as a tester for IdeaFarm " "(tm) Operations.  now, go get a life!]\r\n") ;

                                //LOGrAW( T("email spammer: ")+T(nicNamePeer)+T(" \"")+T(psttPeer)+T("\"\r\n") ) ;
    
                                //etThread.delF( tinP , psttnu ) ;
                                //etThread.boxPutUniqueF( tinP , psttnu , T("///ideafarm/ephemeral/domains/com/ideafarm/ipdos/attackers/")+T(nicNamePeer)+T("/")+TF2(etherC::ifc_idAdamRootI_IF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("/attack") , tBody , tBody.csF( tinP ) ) ;
                                //ZE( strokeS* , psttnu ) ;
    
                                TN( tBody , "" ) ; tBody = TF2(etherC::ifc_idAdamRootI_IF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcr+T("1\r\n")+T(psttTo)+tcr+T(psttSource) ;
                                TN( tcr , "\r\n" ) ;
    
                                POOPR
                                TELL( "writing error message after rcpt to parsing failure indicated attack" ) ;
                            {
                            else
                            }
                                pso->writeF( tinP , "250 ok\r\n" ) ;
                                TELL( "writing ok after parsing rcpt to cmd" ) ;
                            {
                            if( !POOP )
                
                            }
                                //}
                                //    LOGrAW5( "refused receipt to [cPassSubAccount,cPassAccount]: " , cPassSubAccount , "." , cPassAccount ,  "\r\n" ) ;
                                //{
                                //else
                                }
                                    //LOGrAW5( "accepted receipt to [cPassSubAccount,cPassAccount]: " , cPassSubAccount , "." , cPassAccount ,  "\r\n" ) ;
                                    stRecipient << (byteT*)&count3S( cPassIdPenpal , cPassSubAccount , cPassAccount ) ;
                                {
                                if( !POOP )

                                }
                                    else                { __( !bValidPenpalEmailF(  tinP , etThread , psttOutToPenpal , cPassAccount , cPassSubAccount , psttSource    ) ) ; ___( psttOutToPenpal ) ; }
                                    if( cPassIdPenpal ) { __( !bValidIdPenpalF(     tinP , etThread , cPassAccount , cPassSubAccount , cPassIdPenpal ) ) ; }
                                                          __( !bValidSubaccountF(   tinP            , cPassAccount , cPassSubAccount                 ) ) ;
                                                          __( !bValidAccountF(      tinP            , cPassAccount                                   ) ) ;
                                {
                                else
                                if( POOP ) bBadFormat = 1 ;
                                etThread.strConvertToLowerCaseF( tinP , psttSource ) ;

                                if( cPassAccount == 0xc24f6da9 ) cPassAccount = 1 ; //LEGACY iDaCCOUNT FOR WO IDEAFARM; THIS IS DONE TO AVOID CHANGING PUBLISHED EMAIL SUBACCOUNTS WHERE IT IS DIFFICULT TO CHANGE (I.E. IANA PORT REGISTRY)
        
                                tinP.pEtScratch->delF( tinP , psttw1 ) ;
        
                                }
                                    __Z( cPassSubAccount ) ;
                                    __Z( cPassAccount ) ;
                                    tinP.pEtScratch->delF( tinP , pstt1w ) ;
                                    }
                                        }
                                            break ;
                                            }
                                                }
                                                    *pco = tinP.pEtScratch->strDigitsToSCountF( tinP , psttc2 ) ;
    
                                                    }
                                                        case 3 : { pco = &cPassAccount    ; break ; }
                                                        case 2 : { pco = &cPassSubAccount ; break ; }
                                                        case 1 : { pco = &cPassIdPenpal   ; break ; }
                                                    {
                                                    switch( idWord ++ )
                                                    ZE( countT* , pco ) ;
                
                                                    __( !tinP.pEtScratch->strIsDigitsF( tinP , psttc2 ) ) ;                           // REJECT IF NOT ALL DIGITS
                                                {
                                                FORsTRINGSiN2( pstt1w )
    
                                                countT idWord = 4 - cWords ;
                                            {
                                            if( !POOP )
    
                                            __( cWords > 3 ) ;
                                            __( cWords < 2 ) ;
                                            idFormat = 0 ;
                                        {
                                        default : //ADDRESS IS OF FORM [item].[subacct].[acct] OR [subacct].[acct]
                                        }
                                            break ;
                                            }
                                                }
                                                    if( idWord ++ == 4 ) break ;
    
                                                    else { __( tinP.pEtScratch->strCompareF( tinP , psttc2 , T("double" "blind") ) ) ; }
                                                    }
                                                        *pco = tinP.pEtScratch->strDigitsToSCountF( tinP , psttc2 , 36 ) ;
        
                                                        }
                                                            case 3 : { pco = &cPassAccount    ; break ; }
                                                            case 2 : { pco = &cPassSubAccount ; break ; }
                                                            case 1 : { pco = &cPassIdPenpal     ; break ; }
                                                        {
                                                        switch( idWord )
                                                        ZE( countT* , pco ) ;
                    
                                                        __( !tinP.pEtScratch->strIsDigitsF( tinP , psttc2 , 36 ) ) ;                           // REJECT IF NOT ALL DIGITS
                                                    {
                                                    if( idWord <= 3 )
                                                {
                                                FORsTRINGSiN2( pstt1w )
    
                                                countT idWord = 6 - cWords ; // 1 OR 2
                                            {
                                            if( !POOP )
    
                                            __( cWords > 5 ) ;
                                            __( cWords < 4 ) ;
                                        {
                                        case 0x1 : //ADDRESS IS OF FORM [item].[subacct].[acct].[descriptive].[format] OR [subacct].[acct].[descriptive].[format]
                                    {
                                    switch( idFormat )
    
                                    }
                                        if( BlATHsTRING1 ) idFormat =  tinP.pEtScratch->strDigitsToSCountF( tinP , psttc1 , 36 ) ; // RADIX 36 IS USED BECAUSE EMAIL ADDRESSES ARE CASE INSENSITIVE
                                    {
                                    FORsTRINGSiN1( pstt1w )
    
                                    // " ifcEMAIL_OLDfROM "
    
                                    const countT cWords = tinP.pEtScratch->strWordsOldF( tinP , pstt1w , psttw1 , sttq , T(".") ) ; ___( pstt1w ) ;
                                    ZE( strokeS* , pstt1w ) ;
                                    count3S c3email ;
                                    //LOGrAW( T("parsing \"")+T(psttw1)+T("\"\r\n") ) ;
                                {
                                ZE( countT , idFormat        ) ; // 4
                                ZE( countT , cPassAccount    ) ; // 3
                                ZE( countT , cPassSubAccount ) ; // 2
                                ZE( countT , cPassIdPenpal   ) ; // 1
        
                                tinP.pEtScratch->strWordF( tinP , psttw1 , psttTo , sttq , sttAt , 1 ) ; ___( psttw1 ) ;                       // "123.456" or "123.456.789" (PLUS OPTIONAL double blind.[idFormat])
                                                                                                      
                                //sttq = ze ;
                                tinP.pEtScratch->delF( tinP , psttw1 ) ;
                                __( tinP.pEtScratch->strCompareF( tinP , psttw1 , tIfc ) ) ;                                           // "ideafarm.com" == ?
                                tinP.pEtScratch->strWordF( tinP , psttw1 , psttTo , sttq , sttAt , 2 ) ; ___( psttw1 ) ;                       // "ideafarm.com"
                                //sttq = ze ;
                            {
                            TELL( "parsing an ideafarm.com mail box" ) ;

                            //}
                            //    tinP.pEtScratch->strMakeF( tinP , psttTo , T(ifcEMAIL_HELLO) ) ; ___( psttTo ) ;
                            //    tinP.pEtScratch->delF( tinP , psttTo ) ;
                            //{
                            //if( !tinP.pEtScratch->strCompareF( tinP , psttTo , T("hello@ideafarm.com") ) )
                            //SUPPORT FOR hello@ideafarm.com COMMENTED OUT DUE TO DECISION TO NOT PROVIDE ANY FUNCTIONALITY TO ANONYMOUS INTERNET USERS
                            //CS:CODEsYNC: b750104 3a50104
                            //MAPPING GLOBAL ALIASES
                
                            tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttTo ) ; ___( psttTo ) ;                                     // "123@ideafarm.com"
                            tinP.pEtScratch->strTrimF( tinP , psttTo , 0 , T(TbLACKnEWlINE) , T("<>") ) ; ___( psttTo ) ;                                 // "123@IDEAFARM.COM"
                            }
                                __( psttTo[ CSpREFIX - 1 + psttTo->idAdam ].idAdam - '>' ) ;                          // REJECT <@WINNIE:123@IDEAFARM.COM>
                                __( psttTo[ CSpREFIX                        ].idAdam - '<' ) ;
                            {
                            if( !POOP )
                            __( psttTo && psttTo->idAdam < 2 ) ;
                            __Z( psttTo ) ;
                            tinP.pEtScratch->strTrimF( tinP , psttTo , 0 , T(TbLACKnEWlINE) , T(" ") ) ; ___( psttTo ) ;                                  // "<123@IDEAFARM.COM>"
                            tinP.pEtScratch->delF( tinP , psttl ) ;
                            tinP.pEtScratch->strWordF( tinP , psttTo , psttl , sttq , sttColon , 2 ) ; ___( psttTo ) ;                     // " <123@IDEAFARM.COM> "
                            //sttq = ze ;
                            ZE( strokeS* , psttTo ) ;
                            ZE( boolT , bBadFormat ) ;
                
                            tinP.pEtScratch->delF( tinP , psttw1 ) ;
                            tinP.pEtScratch->delF( tinP , psttw2 ) ;
                            __( tinP.pEtScratch->strCompareF( tinP , psttw2 , tTo ) ) ;                                            // "to" == ?
                            tinP.pEtScratch->strWordF( tinP , psttw2 , psttw1 , sttq , sttSpace , 2 ) ; ___( psttw2 ) ;                    // "to"
                            tinP.pEtScratch->delF( tinP , psttw2 ) ;
                            __( tinP.pEtScratch->strCompareF( tinP , psttw2 , tRcpt ) ) ;                                          // "rcpt" == ?
                            tinP.pEtScratch->strWordF( tinP , psttw2 , psttw1 , sttq , sttSpace , 1 ) ; ___( psttw2 ) ;                    // "rcpt"
                            //sttq = ze ;
                
                            }
                                break ;
                                bQuit = 1 ;
                                tinP.pEtScratch->delF( tinP , psttl ) ;
                                tinP.pEtScratch->delF( tinP , psttw1 ) ;
                            {
                            if( !tinP.pEtScratch->strCompareF( tinP , psttw1 , tQuit ) )
                
                            }
                                break ;
                                tinP.pEtScratch->delF( tinP , psttl ) ;
                                tinP.pEtScratch->delF( tinP , psttw1 ) ;
                            {
                            if( !tinP.pEtScratch->strCompareF( tinP , psttw1 , tData ) )
                            tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttw1 ) ; ___( psttw1 ) ;                                     // "rcpt to"
                            tinP.pEtScratch->strTrimF( tinP , psttw1 , 0 , T(TbLACKnEWlINE) , T(" ") ) ; ___( psttw1 ) ;                                  // "RCPT TO"
                            tinP.pEtScratch->strWordF( tinP , psttw1 , psttl , sttq , sttColon , 1 ) ; ___( psttw1 ) ;                     // " RCPT TO "
                            //sttq = ze ;
                            TELL( "parsing a rcpt to line" ) ;
                
                            }
                                break ;
                                tinP.pEtScratch->delF( tinP , psttl ) ;
                            {
                            if( POOP )
                            //etThread.ifcSayIF( T(nicNamePeer)+T(" ")+T(psttPeer)+T(": |")+T(psttl)+tcr , flSAY_APPEND | flSAY_LOG ) ;
                            pso->readWoLineF( tinP , psttl , TOCK ) ; ___( psttl ) ;
                            TELL( "reading a rcpt to line" ) ;
                            ZE( strokeS* , psttl ) ;
                            _INoLD_
                        {
                        while( !POOP && !etThread )
                        ZE( boolT , bQuit ) ;
                        stackC stRecipient( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO|flSTACKc_BLOB , 3 * sizeof( countT ) ) ;
                
                        }
                            _OUT_
                            }
                                continue ;
                                logSmtpF( tinP , etThread , tError ) ;
                                TN( tError , "bad syntax of sender: " ) ; tError += T(nicNamePeer) ;
                                if( !bNoSpammerSink ) stNicNameSpammer.sinkF( tinP , countTC() , nicNamePeer , flSTACKsINK_UNIQUE ) ;
                                pso->writeF( tinP , "500 [syntax of sender is unacceptable]\r\n" ) ;
                                POOPR
                            {
                            else
                            }
                                pso->writeF( tinP , "250 ok\r\n" ) ;
                                stPhrases << psttp ;
                                strokeS* psttp = psttOldC( tinP , etThread , T("from \"")+T(psttSource)+T("\"") ) ; ___( psttp ) ;
                            {
                            if( !POOP )
            
                            }
                                }
                                    tinP.pEtScratch->delF( tinP , psttw ) ;
                                    }
                                        //LOGrAW( T("From value in body will not be checked because MAIL FROM command specified \"")+T(psttSource)+T("\"\r\n") ) ;
                                        bCheckFromInBody = 0 ;
                                    {
                                    if( tinP.pEtScratch->strIdF( tinP , T("@paypal.com") , psttw ) )
                                    tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttw , psttSource ) ; ___( psttw ) ;
                                    ZE( strokeS* , psttw ) ;
                                {
                                if( !POOP )
                
                                }
                                    if( POOP ) bNoSpammerSink = 1 ;
                                    tinP.pEtScratch->delF( tinP , psttw ) ;
                                    //__( tinP.pEtScratch->strIdF( tinP , T("chibyusa") , psttw ) ) ; //THERESA
                                    //__( tinP.pEtScratch->strIdF( tinP , T("divachild") , psttw ) ) ; //THERESA
                                    //__( tinP.pEtScratch->strIdF( tinP , T("thetinydot") , psttw ) ) ; //JULIA
                                    //__( tinP.pEtScratch->strIdF( tinP , T("mail@tranxact.com") , psttw ) ) ; //DAVID
                                    //__( tinP.pEtScratch->strIdF( tinP , T("ranchlife@js-net.com") , psttw ) ) ; //STEVE
                                    //__( tinP.pEtScratch->strIdF( tinP , T("dduringer@juno.com") , psttw ) ) ; //DAN
                                    //__( tinP.pEtScratch->strIdF( tinP , T("tduringer@juno.com") , psttw ) ) ; //MOM
                                    tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttw , psttSource ) ; ___( psttw ) ;
                                    ZE( strokeS* , psttw ) ;
                                {
                                if( !POOP )
                
                                tinP.pEtScratch->strTrimF( tinP , psttSource , 0 , T(TbLACKnEWlINE) , T("<>") ) ; ___( psttSource ) ;                             // "FOO@bar.com"
                                }
                                    __( psttSource[ CSpREFIX - 1 + psttSource->idAdam ].idAdam - '>' ) ;
                                    __( psttSource[ CSpREFIX                        ].idAdam - '<' ) ;
                                {
                                if( !POOP )
                                __( psttSource->idAdam < 2 ) ;
        
                                }
                                    }
                                        __1 ;
                                        logSmtpF( tinP , etThread , tError ) ;
                                        TN( tError , "relay: " ) ; tError += T(nicNamePeer) ;
                                        flError |= flERROR_RELAY ;
                                    {
                                    if( tinP.pEtScratch->strIdF( tinP , T(":") , psttSource ) )                                                             // REJECT <@WINNIE:FOO@bar.com>
                                {
                                if( !POOP )
                            {
                            if( psttSource )
                            ZE( boolT , bNoSpammerSink ) ;
                
                            __Z( psttSource ) ;
                            tinP.pEtScratch->strTrimF( tinP , psttSource , 0 , T(TbLACKnEWlINE) , T(" ") ) ; ___( psttSource ) ;                              // "<FOO@bar.com>"
                            etThread.delF( tinP , psttl ) ;
                            tinP.pEtScratch->strWordF( tinP , psttSource , psttl , sttq , sttColon , 2 ) ; ___( psttSource ) ;                 // " <FOO@bar.com> "
                            //sttq = ze ;
                
                            tinP.pEtScratch->delF( tinP , psttw1 ) ;
                            tinP.pEtScratch->delF( tinP , psttw2 ) ;
                            __( tinP.pEtScratch->strCompareF( tinP , psttw2 , tFrom ) ) ;                                          // "from" == ?
                            tinP.pEtScratch->strWordF( tinP , psttw2 , psttw1 , sttq , sttSpace , 2 ) ; ___( psttw2 ) ;                    // "from"
                            tinP.pEtScratch->delF( tinP , psttw2 ) ;
                            __( tinP.pEtScratch->strCompareF( tinP , psttw2 , tMail ) ) ;                                          // "mail" == ?
                            tinP.pEtScratch->strWordF( tinP , psttw2 , psttw1 , sttq , sttSpace , 1 ) ; ___( psttw2 ) ;                    // "mail"
                            //sttq = ze ;
                            tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttw1 ) ; ___( psttw1 ) ;                                     // "mail from"
                            tinP.pEtScratch->strTrimF( tinP , psttw1 , 0 , T(TbLACKnEWlINE) , T(" ") ) ; ___( psttw1 ) ;                                  // "MAIL FROM"
                            tinP.pEtScratch->strWordF( tinP , psttw1 , psttl , sttq , sttColon , 1 ) ; ___( psttw1 ) ;                     // " MAIL FROM "
                            TELL( "parsing the mail from line" ) ;
                            //sttq = ze ;
                
                            }
                                tinP.pEtScratch->delF( tinP , psttlLower ) ;
                                }
                                    break ;
                                    pso->writeF( tinP , "221 ok\r\n" ) ;
                                    etThread.delF( tinP , psttlLower ) ;
                                    etThread.delF( tinP , psttl ) ;
                                {
                                if( POOP || !etThread.strCompareF( tinP , psttlLower , tQuit ) )
                                tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttlLower , psttl ) ; ___( psttlLower ) ;        // " mail from : <foo@bar.com> "
                                ZE( strokeS* , psttlLower ) ;
                
                                //etThread.ifcSayIF( T(nicNamePeer)+T(" ")+T(psttPeer)+T(": |")+T(psttl)+tcr , flSAY_APPEND | flSAY_LOG ) ;
                                pso->readWoLineF( tinP , psttl , TOCK ) ; ___( psttl ) ;
                                TELL( "reading the mail from line" ) ;
                            {
                            ZE( strokeS* , psttl ) ;                                                                      // " MAIL FROM : <FOO@bar.com> "
                            _INoLD_
                        {
                        boolT bCheckFromInBody = 1 ;
                        ZE( strokeS* , psttOutToPenpal ) ;
                        ZE( strokeS* , psttSource ) ;
                        ZE( flagsT , flError ) ;
                        _INoLD_
                    {
                    while( !POOP && !ether && !etThread )
                
                    }
                        _OUT_
                        etThread.delF( tinP , psttl ) ;
                        }
                            _OUT_
                            pso->writeF( tinP , "250 ideafarm.com\r\n" ) ;
                            /*__( etThread.strCompareF( tinP , psttw2 , tHelo ) ) ;*/ etThread.delF( tinP , psttw2 ) ; //THIS IS NOT DONE CAUSE NETSCAPE SENDS "EHLO" RATHER THAN "HELO"
                            etThread.strConvertToLowerCaseF( tinP , psttw2 , psttw1 ) ; ___( psttw2 ) ; etThread.delF( tinP , psttw1 ) ;
                            etThread.strWordF( tinP , psttw1 , psttl , sttq , sttSpace , 1 ) ; ___( psttw1 ) ;
                            _INoLD_
                        {
                        if( !POOP )
                        //etThread.ifcSayIF( T(nicNamePeer)+T(" ")+T(psttPeer)+T(": |")+T(psttl)+tcr , flSAY_APPEND | flSAY_LOG ) ;
                        pso->readWoLineF( tinP , psttl , TOCK ) ; ___( psttl ) ;
                        TELL( "reading hello line" ) ;
                        ZE( strokeS* , psttl ) ;
                        _INoLD_
                    {
                    if( !POOP )
                    // "helo" OR "ehlo" ETC: NOT PARSED
                
                    TN( tIfc              , "ideafarm.com"     ) ;
                    TN( tIsp              , "smtp.bayarea.net" ) ; //U: LEARN HOW TO QUERY A DNS FOR THE IP TO USE FOR AN MX RECORD; THEN CONNECT DIRECTLY TO THAT HOST AND ELIMINATE THE USE OF tIsp
                    TN( tData             , "data"             ) ;
                    TN( tTo               , "to"               ) ;
                    TN( tRcpt             , "rcpt"             ) ;
                    TN( tFrom             , "from"             ) ;
                    TN( tQuit             , "quit"             ) ;
                    TN( tMail             , "mail"             ) ;
                    TN( tHelo             , "helo"             ) ;
                    strokeS sttAt(    '@' ) ;
                    strokeS sttDot(   '.' ) ;
                    strokeS sttColon( ':' ) ;
                    strokeS sttSpace( ' ' ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf = 1 ;
                    ZE( strokeS* , psttw3 ) ;
                    ZE( strokeS* , psttw2 ) ;
                    ZE( strokeS* , psttw1 ) ;
                
                    pso->writeF( tinP , "220 mail.ideafarm.com IdeaFarm " "(tm) City smtp mail receiver ready\r\n" ) ;
                    TELL( "writing that i am ready" ) ;
                    _INoLD_
                {
                else
                }
                    logSmtpF( tinP , etThread , tError ) ;
                    pso->writeF( tinP , (osTextT*)tError ) ;
                    TN( tError , "550 You are on the spammer list, you naughty person: " ) ; tError += T(psttSpammer) ;
                {
                if( bSpammer )
            
                etThread.delF( tinP , psttSpammer ) ;
                }
                    //etThread.ifcSayIF( T(nicNamePeer)+T(" ")+T(psttPeer)+T(": ")+T(psttSpammer)+tcr , flSAY_APPEND | flSAY_LOG ) ;
                    stNicNameSpammer.sinkF( tinP , countTC() , nicNamePeer , flSTACKsINK_UNIQUE ) ;
                {
                if( bSpammer )
            
                boolT bSpammer = 0 ; //U:: BLAMMO'D HERE. COMMENTED OUT AS WORKAROUND TO STABILIZE SERVER: etThread.ifcIsSpammerF( tinP , psttSpammer , nicNamePeer ) ; ___( psttSpammer ) ;
                ZE( strokeS* , psttSpammer ) ;
                _INoLD_
            {
            if( !POOP )

            //}
            //   __1 ;
            //    logSmtpF( tinP , etThread , tError ) ;
            //    TN( tError , "anonymous peer: " ) ; tError += T(nicNamePeer) ;
            //{
            //if( !psttPeer )
            //THIS WORKS, BUT SOME LEGITIMATE PEERS (GODADDY?) ARE NOT SERVED
        
            //etThread.ifcSayIF( T(nicNamePeer)+T(" ")+T(psttPeer)+tcr , flSAY_APPEND | flSAY_LOG ) ;
            TN( tLogClients , "///d/ideafarm.log.smtpClients" ) ;
            if( POOP ) { POOPR ; }
            tinP.pEtScratch->sockPsttHostF( tinP , psttPeer , nicNamePeer ) ; ___( psttPeer ) ;
            ZE( strokeS* , psttPeer ) ;
            { ZE( countT , idp ) ; pso->peerNameF( tinP , idp , nicNamePeer ) ; }
            nicNameC nicNamePeer ;
            stackC stPhrases( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
            TN( tcr , "\r\n" ) ;
    
            SCOOPS
        {
        IFsCRATCH
    {

    batonC&      bFileIdRelayP    =      *(batonC*)c8p2.c3 ;
    textC&       tFileIdRelayP    =       *(textC*)c8p2.c2 ;
    countT&      idRelayLathP     =      *(countT*)c8p2.c1 ;
    batonC&      bFileIdPenpalP   =      *(batonC*)c8p1.c8 ;
    textC&       tFileIdPenpalP   =       *(textC*)c8p1.c7 ;
    countT&      idPenpalLathP    =      *(countT*)c8p1.c6 ;
    batonC&      bPrepayCode      =      *(batonC*)c8p1.c5 ;
    ranUniC&     ru               =     *(ranUniC*)c8p1.c4 ;
    stackC&      stNicNameSpammer =      *(stackC*)c8p1.c3 ;
    batonC&      b_pbdVarying     =      *(batonC*)c8p1.c2 ;
    byteT*&      pbdVarying       =      *(byteT**)c8p1.c1 ;

    count8S&     c8p2             =     *(count8S*)c8p.c2 ;
    count8S&     c8p1             =     *(count8S*)c8p.c1 ;
    count8S&     c8p              =     *(count8S*)cArg ;
{
if( cArg )
TELL( "preparing to work for an SMTP client" ) ;
TASKdRIVENsERVER( tmcSmtpF )

}
    }
        etThread.fileWriteF( tinP , hFile , tEntry , tEntry.csF( tinP ) ) ;
        etThread.fileSetPtrF( tinP , hFile , flSETfILEpTR_END , c2p ) ;
        count2S c2p ;
        { _INoLD_ etThread.fileOpenF( tinP , hFile , countTC() , tFileLog , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeO ) ; _OUT_ }
        handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            
        TN( tFileLog , "" ) ; tFileLog = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/accounts/")+TF4(idAccountSP,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T("/subaccounts/")+TF4(idSubAccountSP,flFORMAT_NObIGITvALUES|flFORMAT_NObASE,0,36)+T("/txt.log.smtp.txt") ;
    {
    if( idAccountSP && idSubAccountSP )

    }
        etThread.fileWriteF( tinP , hFile , tEntry , tEntry.csF( tinP ) ) ;
        etThread.fileSetPtrF( tinP , hFile , flSETfILEpTR_END , c2p ) ;
        count2S c2p ;
        { _INoLD_ etThread.fileOpenF( tinP , hFile , countTC() , tFileLog , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeO ) ; _OUT_ }
        handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            
        TN( tFileLog , "" ) ; tFileLog = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/txt.log.smtp.txt") ;
    {

    TN( tEntry , "" ) ; tEntry = TT(timeN1,timeN2)+T("| ")+tP+T("\r\n") ;

    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT  , timeN1 ) ;
{
voidT logSmtpF( tinS& tinP , etherC& etThread , textC& tP , const countT idAccountSP = 0 , const countT idSubAccountSP = 0 )

}
    etherP.delF( tinP , pstt1lines ) ;
    }
        etherP.delF( tinP , psttll ) ;
        }
            etherP.strSubstringF( tinP , psttSubjectP , idf , idl , psttc2 ) ; ___( psttSubjectP ) ;
            ZE( countT , idl ) ;
            countT idf = tSubjectColon.csF( tinP ) + 1 ;
        {
        else if( 1 == etherP.strIdF( tinP , tSubjectColon , psttll ) )
        }
            etherP.delF( tinP , psttw ) ;
            etherP.strTrimF( tinP , psttFromP , psttw , T(TbLACKnEWlINE) , T(" ") ) ; ___( psttFromP ) ;                               // "FOO@bar.com"

            }                                                                                               // "  FOO@bar.com  "
                psttw = psttw2 ; psttw2 = 0 ;
                etherP.delF( tinP , psttw ) ;
                etherP.strSubstringF( tinP , psttw2 , idOpen , sttq , S1C('>') , psttw ) ; ___( psttw2 ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttw2 ) ;
                idOpen ++ ;
            {
            if( idOpen )
            countT idOpen = etherP.strIdF( tinP , T("<") , psttw ) ;
            etherP.strSubstringF( tinP , psttw , idf , idl , psttc2 ) ; ___( psttw ) ;              // "    joe blow <  FOO@bar.com  >    "
            ZE( strokeS* , psttw ) ;
            ZE( countT , idl ) ;
            countT idf = tFromColon.csF( tinP ) + 1 ;
        {
        if( 1 == etherP.strIdF( tinP , tFromColon , psttll ) )
        etherP.strConvertToLowerCaseF( tinP , psttll ) ;
        strokeS* psttll = psttOldC( tinP , etherP , psttc2 ) ; ___( psttll ) ;
    {
    FORsTRINGSiN2( pstt1lines )
    TN( tSubjectColon , "subject:" ) ;
    TN( tFromColon , "from:" ) ;
    //U::OBSOLETED BY swsKeyValueP

    }
        tKey = tValue = tNull ;
        swsKeyValuesP << psttValue ; psttValue = 0 ;
        psttzKeyP = tKey ;
        etherP.strMakeF( tinP , psttValue , tValue ) ; ___( psttValue ) ;
        ZE( strokeS* , psttValue ) ;
    {
    if( tKey.csF( tinP ) )
    //DUPLICATED CODE

    }
        }
            }
                etherP.delF( tinP , psttv ) ;
                }
                    tValue = T(psttv) ;
                    etherP.strTrimF( tinP , psttv , 0 , T(TbLACKnEWlINE) ) ; ___( psttv ) ;
                {
                if( psttv )
                etherP.strSubstringF( tinP , psttv , idf , countTC() , psttc1 ) ; ___( psttv ) ;
                ZE( strokeS* , psttv ) ;
            {
            if( idf )

            etherP.delF( tinP , psttk ) ;
            tKey = T(psttk) ;
            etherP.strTrimF( tinP , psttk , 0 , T(TbLACKnEWlINE) ) ; ___( psttk ) ;
            etherP.delF( tinP , psttLower ) ;
            etherP.strSubstringF( tinP , psttk , idf , sttq , sttColon , psttLower ) ; ___( psttk ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttk ) ;
            etherP.strConvertToLowerCaseF( tinP , psttLower ) ;
            strokeS* psttLower = psttOldC( tinP , etherP , psttc1 ) ; ___( psttLower ) ;

            }
                tKey = tValue = tNull ;
                swsKeyValuesP << psttValue ; psttValue = 0 ;
                psttzKeyP = tKey ;
                etherP.strMakeF( tinP , psttValue , tValue ) ; ___( psttValue ) ;
                ZE( strokeS* , psttValue ) ;
            {
            if( tKey.csF( tinP ) )
            //DUPLICATED CODE
        {
        else //NEW KEY
        }
            }
                etherP.delF( tinP , psttv ) ;
                tValue += T("\r\n ")+T(psttv) ;
                etherP.strTrimF( tinP , psttv , psttc1 , T(TbLACKnEWlINE) ) ; ___( psttv ) ;
                ZE( strokeS* , psttv ) ;
            {
            if( tKey.csF( tinP ) )
        {
        if( psttc1[ CSpREFIX ].idAdam <= ' ' ) //CONTINUATION LINE (BEGINS WITH BLANK OR CONTROL CHAR; TAB CONTROL IS EMITTED BY inbox.com)

        }
            continue ;
            __1
            flErrorP |= flERROR_PARSEhEADERlINEiSnULL ;
        {
        if( !psttc1->idAdam ) //SHOULD BE IMPOSSIBLE
    {
    FORsTRINGSiN1( pstt1lines )
    TN( tNull , "" ) ;
    TN( tValue , "" ) ;
    TN( tKey , "" ) ;
    strokeS sttColon( ':' ) ;

    etherP.strWordsOldF( tinP , pstt1lines , psttP , sttq , T("\r\n") ) ; ___( pstt1lines ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , pstt1lines ) ;

    }
        __1
        flErrorP |= flERROR_PARSEhEADERPARAMiSnULL ;
    {
    if( !psttP )
{
voidT parseHeaderF( tinS& tinP , etherC& etherP , flagsT& flErrorP , switchStackC& swsKeyValuesP , strokeS*& psttzKeyP , strokeS*& psttFromP , strokeS*& psttSubjectP , const strokeS* const psttP )

}
    return !POOP ;

    //else { LOGrAW5( "bValidPenpalEmailF debug [bOkPenpalExactOr,bOkRelay]: " , bOkPenpalExactOr , " " , bOkRelay , "\r\n" ) ; }
    }
        //LOGrAW( T("bValidPenpalEmailF debug (outgoing from relay to penpal) [psttOutToPenpalP]: \"")+T(psttOutToPenpalP)+T("\"\r\n") ) ;
        etThread.strMakeF( tinP , psttOutToPenpalP , tPenpalToList ) ; ___( psttOutToPenpalP ) ;
    {
    if( !POOP && tPenpalToList.csF( tinP ) && !bOkPenpalExactOr && bOkRelay )
    //LOGrAW3( "bValidPenpalEmailF debug [tPenpalToList.csF(tinP)]: " , tPenpalToList.csF( tinP ) , "\r\n" ) ;
    //LOGrAW( T("bValidPenpalEmailF debug [tPenpalToList]: \"")+tPenpalToList+T("\"\r\n") ) ;
    //LOGrAW( T("bValidPenpalEmailF debug [psttSourceP]: \"")+T(psttSourceP)+T("\"\r\n") ) ;

    __( !bOkRelay && !bNoPenpalSpecs && !bOkPenpalExactOr && !bOkPenpalContainsOr && !bOkPenpalContainsAnd ) ;

    }
        }
            etThread.delF( tinP , psttEmailPenpalContainsAnd ) ;
            bOkPenpalContainsAnd = !!tinP.pEtScratch->strIdF( tinP , idf , sttq , psttEmailPenpalContainsAnd , psttSourceP ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;

            etThread.strConvertToLowerCaseF( tinP , psttEmailPenpalContainsAnd ) ;
            *info.pStkEmailPenpalContainsAnd >> psttEmailPenpalContainsAnd ; ___( psttEmailPenpalContainsAnd ) ;
            ZE( strokeS* , psttEmailPenpalContainsAnd ) ;
        {
        while( *info.pStkEmailPenpalContainsAnd && bOkPenpalContainsAnd )

        bOkPenpalContainsAnd = 1 ;
        bNoPenpalSpecs = 0 ;
    {
    if( info.pStkEmailPenpalContainsAnd && *info.pStkEmailPenpalContainsAnd )

    }
        }
            etThread.delF( tinP , psttEmailPenpalContainsOr ) ;

            }
                break ;
                etThread.delF( tinP , psttEmailPenpalContainsOr ) ;
                bOkPenpalContainsOr = 1 ;
            {
            if( tinP.pEtScratch->strIdF( tinP , idf , sttq , psttEmailPenpalContainsOr , psttSourceP ) )
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;

            etThread.strConvertToLowerCaseF( tinP , psttEmailPenpalContainsOr ) ;
            *info.pStkEmailPenpalContainsOr >> psttEmailPenpalContainsOr ; ___( psttEmailPenpalContainsOr ) ;
            ZE( strokeS* , psttEmailPenpalContainsOr ) ;
        {
        while( *info.pStkEmailPenpalContainsOr )

        bNoPenpalSpecs = 0 ;
    {
    if( info.pStkEmailPenpalContainsOr && *info.pStkEmailPenpalContainsOr )

    }
        }
            etThread.delF( tinP , psttEmailPenpalExactOr ) ;
            if( !bOkPenpalExactOr && psttEmailPenpalExactOr ) bOkPenpalExactOr = !tinP.pEtScratch->strCompareF( tinP , psttEmailPenpalExactOr , psttSourceP ) ;
            tPenpalToList += T(psttEmailPenpalExactOr)+T(*info.pStkEmailPenpalExactOr?"/":"") ;
            etThread.strConvertToLowerCaseF( tinP , psttEmailPenpalExactOr ) ;
            *info.pStkEmailPenpalExactOr >> psttEmailPenpalExactOr ; ___( psttEmailPenpalExactOr ) ;
            ZE( strokeS* , psttEmailPenpalExactOr ) ;
        {
        while( *info.pStkEmailPenpalExactOr )

        bNoPenpalSpecs = 0 ;
    {
    if( info.pStkEmailPenpalExactOr && *info.pStkEmailPenpalExactOr )

    TN( tPenpalToList , "" ) ;

    ZE( boolT , bOkPenpalContainsAnd ) ;
    ZE( boolT , bOkPenpalContainsOr ) ;
    ZE( boolT , bOkPenpalExactOr ) ;
    boolT bNoPenpalSpecs = 1 ;

    }
        etThread.delF( tinP , psttEmailRelay ) ;
        if( !bOkRelay && psttEmailRelay ) bOkRelay = !tinP.pEtScratch->strCompareF( tinP , psttEmailRelay , psttSourceP ) ;
        *info.pStkEmailRelay >> psttEmailRelay ; ___( psttEmailRelay ) ;
        ZE( strokeS* , psttEmailRelay ) ;
    {
    if( info.pStkEmailRelay ) while( *info.pStkEmailRelay )
    ZE( boolT , bOkRelay ) ;

    subaccountS info( tinP , etThread , cPassAccountSP , cPassSubaccountSP , flSUBACCOUNT_QUERYeMAILrELAY | flSUBACCOUNT_QUERYeMAILpENPALeXACToR | flSUBACCOUNT_QUERYeMAILpENPALcONTAINSoR | flSUBACCOUNT_QUERYeMAILpENPALcONTAINSaND ) ;

    // 
    // 5. SATISFIES ALL OF THE CONTAINSaND SPECS
    // 
    // 4. SATISFIES WO OF THE CONTAINSoR SPECS
    // 
    // 3. MATCHES WO OF THE EXACT PENPAL SPECS
    // 
    // 2. THERE ARE NO PENPAL SPECS
    // 
    // 1. MATCHES WO OF THE RELAY SPECS
    // 
    // ALLOW INCOMING IF ANY ARE TRUE:
    // 
    //ACCEPTANCE RULES
    
    if( POOP ) return 0 ;
{
boolT bValidPenpalEmailF( tinS& tinP , etherC& etThread , strokeS*& psttOutToPenpalP , const countT cPassAccountSP , countT cPassSubaccountSP , const strokeS* const psttSourceP )

}
    return idAccount ;

    }
        __Z( idAccount ) ;
        sIn >> idAccount ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << psttP ;
        sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKiDaCCOUNTfROMeMAIL ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerEmailIdAccount ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;

        SCOOPS
    {
    IFsCRATCH
    ZE( countT , idAccount ) ;

    if( POOP ) return 0 ;
    __Z( psttP ) ;
    if( POOP ) return 0 ;
{
countT queryIdAccountFromEmailF( tinS& tinP , const strokeS* const psttP )
//DUPLICATE CODE: b750104 e750104

}
    return bOk ;
    etThread.delF( tinP , psttToTest ) ;
    }
        }
            }
                bOk = bOkExactOr || bOkContainsOr || bOkContainsAnd ;
    
                }
                    }
                        if( !bOkContainsAnd ) break ;
                        etThread.delF( tinP , psttw ) ;
                        bOkContainsAnd &= !!etThread.strIdF( tinP , psttw , psttToTest ) ;
                        etThread.strConvertToLowerCaseF( tinP , psttw ) ;
                        *info.pStkEmailPenpalContainsAnd >> psttw ; ___( psttw ) ;
                        ZE( strokeS* , psttw ) ;
                    {
                    while( *info.pStkEmailPenpalContainsAnd )
                    bOkContainsAnd = 1 ;
                {
                if( info.pStkEmailPenpalContainsAnd && *info.pStkEmailPenpalContainsAnd )
                ZE( boolT , bOkContainsAnd ) ;
    
                }
                    if( bOkContainsOr ) break ;
                    etThread.delF( tinP , psttw ) ;
                    bOkContainsOr = !!etThread.strIdF( tinP , psttw , psttToTest ) ;
                    etThread.strConvertToLowerCaseF( tinP , psttw ) ;
                    *info.pStkEmailPenpalContainsOr >> psttw ; ___( psttw ) ;
                    ZE( strokeS* , psttw ) ;
                {
                if( info.pStkEmailPenpalContainsOr ) while( *info.pStkEmailPenpalContainsOr )
                ZE( boolT , bOkContainsOr ) ;
    
                }
                    if( bOkExactOr ) break ;
                    etThread.delF( tinP , psttw ) ;
                    bOkExactOr = !etThread.strCompareF( tinP , psttw , psttToTest ) ;
                    etThread.strConvertToLowerCaseF( tinP , psttw ) ;
                    *info.pStkEmailPenpalExactOr >> psttw ; ___( psttw ) ;
                    ZE( strokeS* , psttw ) ;
                {
                if( info.pStkEmailPenpalExactOr ) while( *info.pStkEmailPenpalExactOr )
                ZE( boolT , bOkExactOr ) ;
    
                bOk = 0 ;
            {
            if( bFilter )
    
            ;
    
                ( info.pStkEmailPenpalContainsAnd   && *info.pStkEmailPenpalContainsAnd )
                ( info.pStkEmailPenpalContainsOr    && *info.pStkEmailPenpalContainsOr  ) ||
                ( info.pStkEmailPenpalExactOr       && *info.pStkEmailPenpalExactOr     ) ||
    
            boolT bFilter =
        {
        else
        if( bRelay ) bOk = 1 ;

        }
            if( bRelay ) break ;
            etThread.delF( tinP , psttw ) ;
            bRelay = !etThread.strCompareF( tinP , psttw , psttToTest ) ;
            etThread.strConvertToLowerCaseF( tinP , psttw ) ;
            *info.pStkEmailRelay >> psttw ; ___( psttw ) ;
            ZE( strokeS* , psttw ) ;
        {
        if( info.pStkEmailRelay ) while( *info.pStkEmailRelay )
        ZE( boolT , bRelay ) ;

        subaccountS info( tinP , etThread , idAccountSP , idSubaccountSP , flSUBACCOUNT_QUERYeMAILrELAY | flSUBACCOUNT_QUERYeMAILpENPALeXACToR | flSUBACCOUNT_QUERYeMAILpENPALcONTAINSoR | flSUBACCOUNT_QUERYeMAILpENPALcONTAINSaND ) ;

        etThread.strConvertToLowerCaseF( tinP , psttToTest ) ;
    {
    if( bOk )
    boolT bOk = psttToTest && psttToTest->idAdam ;

    queryEmailFromIdAccountF( tinP , psttToTest , idPenpalP ) ; ___( psttToTest ) ;
    ZE( strokeS* , psttToTest ) ;
{
boolT bValidIdPenpalF( tinS& tinP , etherC& etThread , const countT idAccountSP , countT idSubaccountSP , const countT idPenpalP )

//U::QUERY THE PENPAL FILTER SETTINGS OF THE TARGET SUBACCOUNT AND TEST THE PROPOSED PENPAL HERE

//ANYONE WHO KNOWS A PAIR OF VALID ACCOUNTS AND THE EMAIL ASSOCIATED WITH WO OF THOSE ACCOUNTS CAN USE THAT ACCOUNT TO SEND EMAIL TO THE OTHER ACCOUNT, EVEN IF THE OTHER ACCOUNT HAS NOT APPROVED ANY PENPALS
//THIS IS A SECURITY HOLE
//THIS FUNCTION NOW MERELY VERIFIES THAT THE ACCOUNT EXISTS
//NOW THERE IS NO REGISTRATION OF APPROVED PENPALS FOR A SUBACCOUNT
//THIS ESSENTIALLY VERIFIED THAT THE SUBACCOUNT OWNER HAS APPROVED THIS INCOMING REPLY
//THIS FUNCTION ORIGINALLY VERIFIED THAT THE PENPAL ID EXISTED FOR THIS SUBACCOUNT

}
    }
        sIn >> psttP ; ___( psttP ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << cPassAccountSP ;
        sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKeMAILfROMiDaCCOUNT ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerEmailIdAccount ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;

        SCOOPS
    {
    IFsCRATCH

    if( POOP ) return ;
    __NZ( psttP ) ;
    if( POOP ) return ;
{
voidT queryEmailFromIdAccountF( tinS& tinP , strokeS*& psttP , const countT cPassAccountSP )
//DUPLICATE CODE: b750104 3a50104 1d20005

}
    return bExisted ;

    }
        if( POOP ) { POOPR ; }
        CONoUTrAW3( "bValidSubaccountF returning " , bExisted , "\r\n" ) ;
        sIn >> bExisted ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << (countT)fliSUBACCOUNTmODE_DELETED        ; //flagsExclude
        sOut << (countT)fliSUBACCOUNTmODE_OWNERcONFIRMED ; //flagsRequire
        sOut << cPassSubaccountSP ;
        sOut << cPassAccountSP ;
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_TESTiDsUB ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;

        SCOOPS
    {
    IFsCRATCH
    ZE( boolT , bExisted ) ;
{
boolT bValidSubaccountF( tinS& tinP , const countT cPassAccountSP , const countT cPassSubaccountSP )

}
    return bValid ;

    }
        PUSE( tinP , *(byteT**)&psttEmail ) ;
        CONoUTrAW( T("with idAccount get [idAccount,email]: ")+TF3(cPassAccountSP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+T(" \"")+T(psttEmail)+T("\"\r\n") ) ; //U::

        else if( psttEmail && psttEmail->idAdam && queryAccountConfirmedF( tinP , cPassAccountSP ) ) bValid = 1 ;
        if( POOP ) { POOPR ; }
        
        sIn >> psttEmail ; ___( psttEmail ) ;
        ZE( strokeS* , psttEmail ) ;
        
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
        
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
        
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
        
        sock.writeF( tinP , sOut ) ;
        sOut << cPassAccountSP ;
        sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKeMAILfROMiDaCCOUNT ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
        
        sock.connectF( tinP , homeS::homeIF().idPortListServerEmailIdAccount ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;

        SCOOPS
    {
    IFsCRATCH
    ZE( boolT , bValid ) ;
{
boolT bValidAccountF( tinS& tinP , const countT cPassAccountSP )

}
    return !!( flagsMode & fliACCOUNTmODE_OWNERcONFIRMED ) ;
    }
        //CONoUTrAW3( "[flagsMode]: " , flagsMode , "\r\n" ) ;
        if( bExists ) sIn >> flagsMode ;

        sIn >> bExists ;
        ZE( boolT , bExists ) ;
                                                            
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
                                                            
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
                                                            
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                                                            
        sock.writeF( tinP , sOut ) ;
        sOut << idAccountSP ;
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_QUERYaCCOUNTdESCRIPTION ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
                                                            
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    ZE( flagsT , flagsMode ) ;
{
boolT queryAccountConfirmedF( tinS& tinP , const countT idAccountSP )

    "view spam or advertising while conducting their daily business.\r\n"
    "government to make use of these sanctions in order to preserve the city as a place where no one is forced against his will to\r\n"      \
    "United States, the full force of U.S. criminal and civil law can be brought to bear.  It is the policy of the IdeaFarm " "(tm) City\r\n"   \
    "City is a Federal Constitutional Protectorate of the United States of America.  In cases involving trespass by a citizen of the\r\n"    \
    "trespass\".  Similarly, you do not have the right to force or trick another person into viewing an advertisement.  IdeaFarm " "(tm)\r\n"   \
    "You do not have the right to send unwanted email to another person.  In IdeaFarm " "(tm) City, this is considered \"idea\r\n"              \
    "\r\n" \
    "approval is automatic once your reply is received.\r\n"                                                                                 \
    "only occasionally.  At other times, a separate confirmation might be requested each time a new mail item arrives.  Normally,\r\n"       \
    "The Postmaster determines confirmation policy on a daily basis.  During periods of rare abuse, confirmation will be requested\r\n"      \
    "\r\n" \
    "to avoid accountability.  False addresses are often used by spammers and larcenists.\r\n"                                               \
    "be able to confirm that the sender's email address indicated in the items is a true address, rather than a false address made up\r\n"   \
    "That mail will not be delivered until you click \"Reply\".  When the IdeaFarm " "(tm) City Postmaster receives your reply, he will\r\n"    \
    "Please click the \"Reply\" button to complete the delivery of the mail that you just sent to someone in IdeaFarm " "(tm) City.\r\n"        \
                                                                                                                                             \
#define postEMAILsECTIONbODY_4_EXPLANATION                                                                                                   \

    "(b) Otherwise, click \"Reply\".\r\n"
    "\r\n"                                                                                                                                   \
    "(a) If you are a spammer, please DO NOT REPLY.\r\n"                                                                                     \
    "\r\n"                                                                                                                                   \
    "Do either (a) -or- (b): \r\n"                                                                                                           \
                                                                                                                                             \
#define postEMAILsECTIONbODY_3_INSTRUCTIONS                                                                                                  \

//  "================================================================================================================================\r\n"

#define ifcIDsETTING_EMAILpENPALcONTAINSaND 0x0c
#define ifcIDsETTING_EMAILpENPALcONTAINSoR  0x0b
#define ifcIDsETTING_EMAILpENPALeXACToR     0x0a
#define ifcIDsETTING_AUTORESPONSE           0x09
#define ifcIDsETTING_RECIPE                 0x08
#define ifcIDsETTING_EMAILrELAY             0x07
#define ifcIDsETTING_NAMEoUT                0x06
#define ifcIDsETTING_NAMEiN                 0x05
#define ifcIDsETTING_TITLE                  0x04
#define ifcIDsETTING_FLAGSmEMBERoF          0x03
#define ifcIDsETTING_IDmODE                 0x02
#define ifcIDsETTING_FLAGSmODE              0x01

#define postERROR_COULDnOThANDLErECIPIENT   "[recipient could not be processed]"
#define postERROR_ANONYMOUSpEEER            "[peer is anonymous]"
#define postERROR_PARSEhEADERlINEiSnULL     "[header line is null]"
#define postERROR_PARSEhEADERPARAMiSnULL    "[header param is null]"
#define postERROR_FILEiStOObIG              "[file is too big]"
#define postERROR_COULDnOTgETfILEiNFO       "[could not get file info]"
#define postERROR_COULDnOToPENfILES         "[could not open files]"
#define postERROR_SOIXLoLDbADbEGINNING          "[soixlOld command paragraph did not begin with !SOIXLoLD]"
#define postERROR_SOIXLoLDtOOlARGE              "[soixlOld too large]"
#define postERROR_HEADERtOOlARGE            "[header too large]"
#define postERROR_FALSEsENDER               "[false senders are not allowed]"
#define postERROR_HIDDENsENDER              "[hidden senders are not allowed]"
#define postERROR_RELAY                     "[relaying not allowed]"
#define postERROR_FROMvALUESdIFFER          "[mail from value differs from value in from header line]"
#define postERROR_DATAlINEtOOlONG           "[a line in the message was too long]"
#define postERROR_NOdATA                    "[the message was of length 0]"
#define postERROR_NOvALIDrECIPIENTS         "[no valid recipient addresses]"
#define postERROR_MULTIPLEfROMiNbODY        "[message body contains more than one From: header]"
#define postERROR_SECRETsENDER              "[secret senders are not allowed]"

#define flERROR_COULDnOThANDLErECIPIENT    0xe20000ff
#define flERROR_ANONYMOUSpEEER             0xe10000ff
#define flERROR_PARSEhEADERPARAMiSnULL     0xe08000ff
#define flERROR_PARSEhEADERlINEiSnULL      0xe04000ff
#define flERROR_FILEiStOObIG               0xe02000ff
#define flERROR_COULDnOTgETfILEiNFO        0xe01000ff
#define flERROR_COULDnOToPENfILES          0xe00800ff
#define flERROR_SOIXLoLDbADbEGINNING           0xe00400ff
#define flERROR_SOIXLoLDtOOlARGE               0xe00200ff
#define flERROR_HEADERtOOlARGE             0xe00100ff
#define flERROR_FALSEsENDER                0xe00080ff
#define flERROR_HIDDENsENDER               0xe00040ff
#define flERROR_RELAY                      0xe00020ff
#define flERROR_FROMvALUESdIFFER           0xe00010ff
#define flERROR_DATAlINEtOOlONG            0xe00008ff
#define flERROR_NOdATA                     0xe00004ff
#define flERROR_NOvALIDrECIPIENTS          0xe00002ff
#define flERROR_SECRETsENDER               0xe00001ff

/*1*/WAKEhIDE( "ifcIDaDAM_ROOTsMTPsERVER" )/*1*/
/**/
*/
  (this can be accomplished manually by deleting the entire list periodically)
 there is no code to remove an ip from the list, once listed
 a single invalid user name instance will result in an ip becoming listed
 listed ip is not allowed to have a session
spam control
 NNNNNNN: receives the mail
 b340104/NNNNNNN: initiate and supervise mail job
 9440104/b340104: initate and supervise mail job   
 b340104/file:   asynch job soul of a ifcIDcMDjOBoRDER_MAIL job (written to 9440104's in box)
 client/b340104: delivers text via telnet to me
pseudocode for how an incoming mail item destined for NNNNNNN@i deafarm.com is handled
i refuse other addresses
i accept incoming mail addressed to nnn@i deafarm.com addresses
\<A HREF=\"5.b340104.1.0.html\"\>definition\</A\>
obsoletes b340104
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

