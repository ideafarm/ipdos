
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
}
    etThread.delF( tinP , psttFile ) ;
    
    }
        b_pStTaskStart.ungrabF( tinP ) ;
        DEL( pStTaskStart ) ;
        b_pStTaskStart.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        sgnDone_tmSaveTick.waitF( tinP ) ;
        etThread.faceStkNotifyAdamF( tinP ) ;
    
        TELL( "cleaning up" ) ;
        }
            }
                ++ s ; etThread.osSleepF( tinP , TOCK ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            TELL( "taking my cycle nap" ) ;
            
            }
                etThread.delF( tinP , psttc ) ;
                etThread.osClipboardLetGoF( tinP ) ;
                if( !bGraphic && ( !psttc || !psttc->idAdam || bLooksLikeTimeF( tinP , etThread , psttc ) ) ) etThread.osClipboardWriteF( tinP , TT4(time1,time2,3,6) ) ;
                boolT bGraphic = etThread.osClipboardFlavorsF( tinP ) && !psttc ;
                etThread.osClipboardReadF( tinP , psttc ) ; ___( psttc ) ;
                etThread.osClipboardGrabF( tinP ) ;
                ZE( strokeS* , psttc ) ;
            {
            TELL( "writing current time to os clipboard" ) ;
            
            etThread.paperTitleF( tinP , T("")+(idTaskCurrent?strokeS(idTaskCurrent):strokeS('.'))+T(" ")+T(ppsttDay[offd])+T(" ")+TT4(time1,time2,3,6) ) ;
            
            }
                }
                    keyTaskNoticeHandlerF( tinP , etThread , psttw , (countT)&c2i ) ;
                    etThread.strMakeF( tinP , psttw , psttOne ) ; ___( psttw ) ;
                    ZE( strokeS* , psttw ) ;
                    psttOne[ CSpREFIX ] = S2( 'f' , scOld_CONTROLkEY ) ;
                    SETpREFIX( psttOne , 1 , 0 ) ;
                    strokeS psttOne[ CSpREFIX + 1 ] ;
                    TELL( "flushing data for the strong just ended" ) ;
                {
                if( offWorkStrongNow - offWorkStrongEarliest )
            
                countT offWorkStrongEarliest = ( timeEarliest2 + 2 ) / 8 ;
                countT offWorkStrongNow      = ( time2         + 2 ) / 8 ;
            {
            if( idTaskEarliest )
            
            countT offd = time2 % 8 ;
            etThread.osTimeNowF( tinP , time1 , time2 ) ;
            ZE( sCountT , time2 ) ;
            ZE( countT , time1 ) ;
            TELL( "preparing for work cycle" ) ;
        {
        while( !ether && !etThread )
    
        //U::{ countT idAdam = 0x4010418 ; etThread.ifcHireF( tinP , T("g orilla.http.ideafarm.2") , idAdam , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ; }
        //U::{ countT idAdam = 0x401049f ; etThread.ifcHireF( tinP , T("clock") , idAdam , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ; }
        TELL( "hiring f94" )

        strokeS* ppsttDay[] = { t1 , t2 , t3 , t4 , t5 , t6 , t7 , t8 } ;
        TN( t8 , "ta'da" ) ;
        TN( t7 , "ve'da" ) ;
        TN( t6 , "se'da" ) ;
        TN( t5 , "fi'da" ) ;
        TN( t4 , "fo'da" ) ;
        TN( t3 , "re'da" ) ;
        TN( t2 , "oo'da" ) ;
        TN( t1 , "wo'da" ) ;
    
        { ZE( countT , tid ) ; etThread.osThreadF( tinP , tid , tmSaveTickF , &sgnDone_tmSaveTick , flTHREADlAUNCH_null , 0 , (countT)&b_pStTaskStart , (countT)&pStTaskStart , (countT)&etThread ) ; }
        signC sgnDone_tmSaveTick( tinP , TAG( TAGiDnULL ) ) ;
    
        etThread.faceStkNotifyAdamF( tinP , keyTaskNoticeHandlerF , (countT)&c2i ) ;
    
        }
            keyTaskNoticeHandlerF( tinP , etThread , psttw , (countT)&c2i ) ;
            etThread.strMakeF( tinP , psttw , psttOne ) ; ___( psttw ) ;
            ZE( strokeS* , psttw ) ;
            psttOne[ CSpREFIX ] = S2( 't' , scOld_CONTROLkEY ) ;
            SETpREFIX( psttOne , 1 , 0 ) ;
            strokeS psttOne[ CSpREFIX + 1 ] ;
        {    
    
        }
            }
                idTaskEarliest = pc3s->c3 ;
                timeEarliest2  = pc3s->c2 ;
                timeEarliest1  = pc3s->c1 ;
            {
            if( pc3s )
            pc3s = (count3S*)(*pStTaskStart)[ - 1 ] ;
    
            }
                idTaskCurrent = pc3s->c3 ;
                timeCurrent2  = pc3s->c2 ;
                timeCurrent1  = pc3s->c1 ;
            {
            if( pc3s )
            count3S* pc3s = (count3S*)(*pStTaskStart)[ 1 ] ;
        {
        if( *pStTaskStart )

        c2i.c2 = (countT)&c8i2 ;
        c2i.c1 = (countT)&c8i1 ;
        count2S c2i ;

        c8i2.c2 = (countT)&state ;    
        c8i2.c1 = (countT)&idTaskEarliest ;
        count8S c8i2 ;

        c8i1.c8 = (countT)&timeEarliest2 ;
        c8i1.c7 = (countT)&timeEarliest1 ;
        c8i1.c6 = (countT)&idTaskCurrent ;
        c8i1.c5 = (countT)&timeCurrent2 ;
        c8i1.c4 = (countT)&timeCurrent1 ;
        c8i1.c3 = (countT)&stDigits ;
        c8i1.c2 = (countT)&pStTaskStart ;
        c8i1.c1 = (countT)&b_pStTaskStart ;
        count8S c8i1 ;
    
        ZE( sCountT , timeEarliest2 ) ;
        ZE( countT , timeEarliest1 ) ;
        ZE( countT , idTaskEarliest ) ;
        ZE( sCountT , timeCurrent2 ) ;
        ZE( countT , timeCurrent1 ) ;
        ZE( countT , idTaskCurrent ) ;
        stackC stDigits( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_ALLOWzE ) ;
    {
    if( pStTaskStart )

    b_pStTaskStart.ungrabF( tinP ) ;
    stackC* pStTaskStart = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count3S , T(psttFile) ) ; ___( pStTaskStart ) ;
    b_pStTaskStart.grabF( tinP , TAG( TAGiDnULL ) ) ;
    batonC b_pStTaskStart( tinP , TAG( TAGiDnULL ) , 0 , flBATONc_ALLOWsLEEPwHILEgRABBED ) ; //LEGACYwORKAROUND:ALLOWsLEEPwHILEgRABBED
    
    etThread.diskMapFileNameF( tinP , psttFile , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/1530104/stTaskStart.vc") ) ;
    etThread.strokeF( tinP , T("IdeaFarm " "(tm) City Timecard\r\n \r\nto switch to a new task, press an UPPER case alphabetic key (A-Z)\r\noptionally, before doing this, enter a task number using radix z_ digits (0-9,a-z)\r\n \r\n") ) ;
    
    TELL( "preparing for work" ) ;

    stateS state( tinP , etThread ) ;
{
etThread.winSetTitleF( tinP , TF1(DDNUMB) ) ; //U::
TODO

DONE( tmSaveTickF )
}
    TELL( "cleaning up" ) ;
    }
        }
            //etThread.beeClickF( tinP , 0x800 , 0x40 ) ;

            b_pStTaskStart.ungrabF( tinP ) ;
            pStTaskStart = new( 0 , tinP , LF ) stackC( tinP , etThreadStack , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count3S , T(psttFile) ) ; ___( pStTaskStart ) ;
            TELL( "reloading from data file" ) ;
            DEL( pStTaskStart ) ;
            b_pStTaskStart.grabF( tinP , TAG( TAGiDnULL ) ) ;
            TELL( "flushing to data file" ) ;
        {
        if( !ether )

        }
            ++ s ; ether.osSleepF( tinP , TOCK * 0x10 , TOCK ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        TELL( "taking my cycle nap" ) ;
    {
    while( !ether && !etThread )

    etherC&   etThreadStack  =   *(etherC*)pTaskP->c3 ;
    stackC*&  pStTaskStart   =  *(stackC**)pTaskP->c2 ;
    batonC&   b_pStTaskStart =   *(batonC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TELL( "preparing for work" ) ;
TASK( tmSaveTickF )

}
    }
        etThread.delF( tinP , psttOneP ) ;
        }
            }
                b_pStTaskStart.ungrabF( tinP ) ;
                newTaskF( tinP , etThread , *pStTaskStart , timeCurrent1 , timeCurrent2 , idTaskCurrent , idType , stDigits ) ;
                b_pStTaskStart.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            else if( idType >= 'A' && idType <= 'Z' )
            }
                }
                    else etThread.strokeF( tinP , T("digit ")+TF4(digit,flFORMAT_NObASE,0,0x24)+T(" ignored\r\n") ) ;
                    }
                        etThread.strokeF( tinP , TF4(digit,flFORMAT_NObASE,0,0x24) ) ;
                        stDigits << digit ;
                    {
                    if( stDigits < 6 )
                    countT digit = idType >= '0' && idType <= '9' ? idType - '0' : idType - 'a' + 0xa ;
                {
                else
                }
                    }
                        }
                            break ;
                            etThread.strokeF( tinP , T("\fan unrecognized control key was pressed\r\n") ) ;
                        {
                        default :
                        }
                            break ;
                            b_pStTaskStart.ungrabF( tinP ) ;

                            etThread.strokeF( tinP , T("total work time budget, actual, variance: ")+TT(time1b,time2b)+T("    ")+TT(time1w,time2w)+T("    ")+TT(time1v,time2v)+T("\r\n") ) ;

                            etThread.osTimeSubtractF( tinP , time1v , time2v , time1b , time2b ) ;
                            sCountT time2v = time2w ;
                            countT  time1v = time1w ;

                            etThread.osTimeAddF( tinP , time1b , time2b , state.timeBudAdj1 , state.timeBudAdj2 ) ;
                            }
                                while( offd -- ) etThread.osTimeAddF( tinP , time1b , time2b , TICK * 0x10 * BUDGETEDwORKhOURSpERwORKdAY , 0 ) ;
                                offd ++ ;
                            {
                            if( offd <= 5 )
                            ZE( sCountT , time2b ) ;
                            ZE( countT , time1b ) ;

                            }
                                etThread.strokeF( tinP , T("\r\n") ) ;
                                if( idTask == idTaskCurrent ) etThread.strokeF( tinP , T(" *") ) ;
                                }
                                    etThread.strokeF( tinP , TT4(time1,time2,3,5) ) ;
                                    else        etThread.strokeF( tinP , TP("",0xd) ) ;
                                    if( idJob ) etThread.strokeF( tinP , T("/")+TF4(idJob,flFORMAT_NObASE,0xc,0x24) ) ;
                                    etThread.strokeF( tinP , T("")+T(post2) ) ;
                                    const osTextT post2[] = { (osTextT)idType , 0 } ;

                                    if( idType != 'O' ) etThread.osTimeAddF( tinP , time1w , time2w , time1 , time2 ) ;

                                    countT idJob  = idTask >> 8 ;
                                    countT idType = idTask & 0xff ;
                                {
                                sCountT time2 = swTime2 ;
                                countT  time1 = swTime1 ;

                                idTask = swTime1.leverF( tinP , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            __( swTime2.cFlavorsF( tinP ) - cFlavors ) ;
                            countT cFlavors = swTime1.cFlavorsF( tinP ) ;
                            ZE( sCountT , time2w ) ;
                            ZE( countT , time1w ) ;

                            }
                                else         etThread.strokeF( tinP , T("\f") ) ;
                                if( bFirst ) bFirst = 0 ;
                                static countT bFirst = 1 ;
                            {

                            }
                                offd = timeE2 % 8 ;
                                etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                                ZE( sCountT , timeE2 ) ;
                                ZE( countT , timeE1 ) ;
                            {
                            else
                            }
                                }
                                    etThread.osTimeAddF( tinP , swTime1 , (sCountT&)(countT&)swTime2 , timeE1 , timeE2 ) ;
                                    etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1 , timeA2 ) ;
                                    offd = timeE2 % 8 ;
                                    etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                                    ZE( sCountT , timeE2 ) ;
                                    ZE( countT , timeE1 ) ;
                                {
                                if( idTask ) // SHOULD NEVER BE 0

                                while( ~hUp ) ;
                                }
                                    }
                                        idTask = pc3s->c3 ;
                                        timeA2  = pc3s->c2 ;
                                        timeA1  = pc3s->c1 ;
                                        }
                                            etThread.osTimeAddF( tinP , swTime1 , (sCountT&)(countT&)swTime2 , timeE1 , timeE2 ) ;
                                            etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1 , timeA2 ) ;
                                            sCountT timeE2 = pc3s->c2 ;
                                            countT  timeE1 = pc3s->c1 ;
                                        {
                                        else
                                        if( bFirst ) bFirst = 0 ;
                                    {
                                    if( pc3s )
                                    count3S* pc3s = (count3S*)pStTaskStart->upF( tinP , hUp ) ;
                                {
                                do
                                handleC hUp( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                boolT bFirst = 1 ;
                                ZE( sCountT , timeA2 ) ;
                                ZE( countT , timeA1 ) ;
                            {
                            if( *pStTaskStart )
                            ZE( countT , offd ) ;
                            switchC swTime2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idTask ) ;
                            switchC swTime1( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idTask ) ;
                            ZE( countT , idTask ) ;
                            b_pStTaskStart.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            //PSEUDODUPLICATED CODE: CASES b t ARE VERY SIMILAR
                        {
                        case 't' : // DISPLAY TOTALS
                        }
                            //INTENTIONALLY CONTINUE INTO 't'
                            b_pStTaskStart.ungrabF( tinP ) ;
                            }
                                idTaskEarliest = idTaskCurrent ;
                                timeEarliest2 = timeCurrent2 ;
                                timeEarliest1 = timeCurrent1 ;
                                newTaskF( tinP , etThread , *pStTaskStart , timeCurrent1 , timeCurrent2 , idTaskCurrent , idTaskCurrent , stDigits ) ;
                            {
                            if( pStTaskStart && idTaskCurrent )
                            pStTaskStart = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count3S , T(psttFile) ) ; ___( pStTaskStart ) ;
                            etThread.delF( tinP , psttg ) ;
                            etThread.strokeF( tinP , T("totals have been moved to \"")+T(psttg)+T("\"\r\n") ) ;
                            etThread.diskFileOrDirDeleteF( tinP , psttFile ) ;
                            etThread.delF( tinP , pbCurrent ) ;
                            etThread.boxPutGenerationF( tinP , psttg , psttFile , CSaLLgENnAMES , pbCurrent , cbCurrent ) ;
                            ZE( strokeS* , psttg ) ;
                            etThread.boxGetShadowF( tinP , pbCurrent , cbCurrent , psttFile ) ; ___( pbCurrent ) ;
                            ZE( countT , cbCurrent ) ;
                            ZE( byteT* , pbCurrent ) ;
                            idTaskEarliest = timeEarliest2 = timeEarliest1 = 0 ;
                            DEL( pStTaskStart ) ;

                            if( idTaskCurrent ) newTaskF( tinP , etThread , *pStTaskStart , timeCurrent1 , timeCurrent2 , idTaskCurrent , idTaskCurrent , stDigits ) ;
                            b_pStTaskStart.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        case 'f' : // FLUSH TOTALS TO ARCHIVE AND RESET THEM TO ZE
                        }
                            break ;
                            b_pStTaskStart.ungrabF( tinP ) ;
                            undoF( tinP , etThread , *pStTaskStart , timeCurrent1 , timeCurrent2 , idTaskCurrent , stDigits ) ;
                            b_pStTaskStart.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        case 'u' : // REMOVES THE MOST RECENT TASK CHANGE RECORD
                        }
                            break ;
                            b_pStTaskStart.ungrabF( tinP ) ;

                            etThread.osTimeSubtractF( tinP , state.timeBudAdj1 , state.timeBudAdj2 , time1b , time2b ) ;
                            state.timeBudAdj2 = time2w ;
                            state.timeBudAdj1 = time1w ;

                            }
                                while( offd -- ) etThread.osTimeAddF( tinP , time1b , time2b , TICK * 0x10 * BUDGETEDwORKhOURSpERwORKdAY , 0 ) ;
                                offd ++ ;
                            {
                            if( offd <= 5 )
                            ZE( sCountT , time2b ) ;
                            ZE( countT , time1b ) ;

                            }
                                etThread.strokeF( tinP , T("\r\n") ) ;
                                if( idTask == idTaskCurrent ) etThread.strokeF( tinP , T(" *") ) ;
                                }
                                    etThread.strokeF( tinP , TT4(time1,time2,3,5) ) ;
                                    else        etThread.strokeF( tinP , TP("",0xd) ) ;
                                    if( idJob ) etThread.strokeF( tinP , T("/")+TF4(idJob,flFORMAT_NObASE,0xc,0x24) ) ;
                                    etThread.strokeF( tinP , T("")+T(post2) ) ;
                                    const osTextT post2[] = { (osTextT)idType , 0 } ;

                                    if( idType != 'O' ) etThread.osTimeAddF( tinP , time1w , time2w , time1 , time2 ) ;

                                    countT idJob  = idTask >> 8 ;
                                    countT idType = idTask & 0xff ;
                                {
                                sCountT time2 = swTime2 ;
                                countT  time1 = swTime1 ;

                                idTask = swTime1.leverF( tinP , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            __( swTime2.cFlavorsF( tinP ) - cFlavors ) ;
                            countT cFlavors = swTime1.cFlavorsF( tinP ) ;
                            ZE( sCountT , time2w ) ;
                            ZE( countT , time1w ) ;

                            }
                                else         etThread.strokeF( tinP , T("\f") ) ;
                                if( bFirst ) bFirst = 0 ;
                                static countT bFirst = 1 ;
                            {

                            }
                                offd = timeE2 % 8 ;
                                etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                                ZE( sCountT , timeE2 ) ;
                                ZE( countT , timeE1 ) ;
                            {
                            else
                            }
                                }
                                    etThread.osTimeAddF( tinP , swTime1 , (sCountT&)(countT&)swTime2 , timeE1 , timeE2 ) ;
                                    etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1 , timeA2 ) ;
                                    offd = timeE2 % 8 ;
                                    etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                                    ZE( sCountT , timeE2 ) ;
                                    ZE( countT , timeE1 ) ;
                                {
                                if( idTask ) // SHOULD NEVER BE 0

                                while( ~hUp ) ;
                                }
                                    }
                                        idTask = pc3s->c3 ;
                                        timeA2  = pc3s->c2 ;
                                        timeA1  = pc3s->c1 ;
                                        }
                                            etThread.osTimeAddF( tinP , swTime1 , (sCountT&)(countT&)swTime2 , timeE1 , timeE2 ) ;
                                            etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1 , timeA2 ) ;
                                            sCountT timeE2 = pc3s->c2 ;
                                            countT  timeE1 = pc3s->c1 ;
                                        {
                                        else
                                        if( bFirst ) bFirst = 0 ;
                                    {
                                    if( pc3s )
                                    count3S* pc3s = (count3S*)pStTaskStart->upF( tinP , hUp ) ;
                                {
                                do
                                handleC hUp( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                boolT bFirst = 1 ;
                                ZE( sCountT , timeA2 ) ;
                                ZE( countT , timeA1 ) ;
                            {
                            if( *pStTaskStart )
                            ZE( countT , offd ) ;
                            switchC swTime2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idTask ) ;
                            switchC swTime1( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idTask ) ;
                            ZE( countT , idTask ) ;
                            b_pStTaskStart.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            //PSEUDODUPLICATED CODE: CASES b t ARE VERY SIMILAR
                        {
                        case 'b' : // SET ADJUSTMENT VALUE SO THAT ADJUSTED BUDGET EQUALS CURRENT TOTAL
                    {
                    switch( idType )
                {
                if( bControl )
            {
            )
                ( idType >= 'a' && idType <= 'z' )
                ( idType >= '0' && idType <= '9' ) ||
            (
            if
            boolT  bControl = psttOneP[ CSpREFIX ].idCaste == scOld_CONTROLkEY ;
            countT idType = psttOneP[ CSpREFIX ].idAdam ;

            stateS&  state          =  *(stateS*)c8i2.c2 ;
            countT&  idTaskEarliest =  *(countT*)c8i2.c1 ;
            sCountT& timeEarliest2  = *(sCountT*)c8i1.c8 ;
            countT&  timeEarliest1  =  *(countT*)c8i1.c7 ;
            countT&  idTaskCurrent  =  *(countT*)c8i1.c6 ;
            sCountT& timeCurrent2   = *(sCountT*)c8i1.c5 ;
            countT&  timeCurrent1   =  *(countT*)c8i1.c4 ;
            stackC&  stDigits       =  *(stackC*)c8i1.c3 ;
            stackC*& pStTaskStart   = *(stackC**)c8i1.c2 ;
            batonC&  b_pStTaskStart =  *(batonC*)c8i1.c1 ;
        {
        if( c2i.c1 && c2i.c2 && c8i1.c1 && c8i1.c2 && c8i1.c3 && c8i1.c4 && c8i1.c5 && c8i1.c6 && c8i1.c7 && c8i1.c8 && c8i2.c1 && c8i2.c2 )
        count8S& c8i2 = *(count8S*)c2i.c2 ;
        count8S& c8i1 = *(count8S*)c2i.c1 ;
        count2S& c2i = *(count2S*)infoP ;
    {
    if( psttOneP && infoP )
{
voidT keyTaskNoticeHandlerF( tinS& tinP , etherC& etThread , strokeS*& psttOneP , const countT infoP )

}
    }
        etThread.beeClickF( tinP , 0x3800 ) ;
        etThread.strokeF( tinP , T(post2)+T("/")+TF4(idJob,flFORMAT_NObASE,8,0x24)+T("    ")+TT4(pc3s->c1,pc3s->c2,3,5)+T("\r\n") ) ;
        const osTextT post2[] = { (osTextT)idTypeP , 0 } ;
        stTaskStartP << pc3s ;
        idTaskCurrentP = pc3s->c3 ;
        timeCurrent2P  = pc3s->c2 ;
        timeCurrent1P  = pc3s->c1 ;
        pc3s->c3 = idJob << 8 | idTypeP ;
        etThread.osTimeNowF( tinP , pc3s->c1 , (sCountT&)pc3s->c2 ) ;
        etThread.memSetF( tinP , (byteT*)pc3s , sizeof( count3S ) ) ;

        if( !( ++ idKey % 0x10 ) ) etThread.strokeF( tinP , T("\f") ) ;
        static countT idKey ;
    {
    if( pc3s )
    etThread.newF( tinP , LF , pc3s ) ; ___( pc3s ) ;
    ZE( count3S* , pc3s ) ;

    }
        idJob += digit ;
        stDigitsP >> digit ;
        ZE( countT , digit ) ;
        else idJob *= 0x24 ;
        }
            etThread.strokeF( tinP , T("\r      \r") ) ;
            bFirst = 0 ;
        {
        if( bFirst )
    {
    while( stDigitsP )
    boolT bFirst = 1 ;
    ZE( countT , idJob ) ;
{
voidT newTaskF( tinS& tinP , etherC& etThread , stackC& stTaskStartP , countT& timeCurrent1P , sCountT& timeCurrent2P , countT& idTaskCurrentP , const countT idTypeP , stackC& stDigitsP )

}
    if( etThread ) ;

    }
        else idTaskCurrentP = timeCurrent2P = timeCurrent1P = 0 ;
        }
            idTaskCurrentP = pc3s->c3 ;
            timeCurrent2P  = pc3s->c2 ;
            timeCurrent1P  = pc3s->c1 ;
        {
        if( pc3s )
        pc3s = (count3S*)stTaskStartP[ 1 ] ;
        etThread.delF( tinP , pc3s ) ;
        count3S* pc3s = (count3S*)stTaskStartP.extractF( tinP , 1 ) ;
    {
    else if( stTaskStartP )
    }
        etThread.strokeF( tinP , T("\b \b") ) ;
        stDigitsP >> digit ;
        ZE( countT , digit ) ;
    {
    if( stDigitsP )
    boolT bFirst = 1 ;
    ZE( countT , idJob ) ;
{
voidT undoF( tinS& tinP , etherC& etThread , stackC& stTaskStartP , countT& timeCurrent1P , sCountT& timeCurrent2P , countT& idTaskCurrentP , stackC& stDigitsP )

}
    ;

        )
            psttP[ CSpREFIX + 8 ] == sDot
            psttP[ CSpREFIX + 5 ] == sAt  &&
            psttP[ CSpREFIX + 2 ] == sDot &&
            0xb == psttP->idAdam &&
        (
        ||
        !etThread.strCompareF( tinP , psttP , T("!time") )

    return

    strokeS sAt  = S1C('@') ;
    strokeS sDot = S1C('.') ;

    if( etThread ) return 0 ;
    __Z( psttP ) ;
    if( etThread ) return 0 ;
{
boolT bLooksLikeTimeF( tinS& tinP , etherC& etThread , const strokeS* const psttP ) //EXAMPLE: T("12.34@56.78")

strokeS* psttFile ;

#define CSaLLgENnAMES 0x10000

#define BUDGETEDwORKhOURSpERwORKdAY 6
//6 is full time (9 foreign hours per day)

}
{
stateC( tinP , etherP , sizeof *this , 0 , translateStateF )
stateS::stateS( tinS& tinP , etherC& etherP ) :

TRANSLATEsTATE_END
    state.idMe ++ ;
TRANSLATEsTATE_MIDDLE
    case 1 : { state.idMe        = stateOther.idMe              ; }
    case 2 : { state.timeBudAdj1 = stateOther.timeBudAdj1 ; state.timeBudAdj2 = stateOther.timeBudAdj2 ; }
TRANSLATEsTATE_BEGIN( stateS , 2 )

;
}
    stateS( tinS& tinP , etherC& etherP ) ;

    sCountT  timeBudAdj2 ;
    countT   timeBudAdj1 ;
    countT   idMe ;
    countT   idVersion ;
{
struct stateS : public stateC

/*1*/WAKEhIDE( "clock" )/*1*/
/**/
*/
  the clipboard contains the text string "!time"
  the clipboard contains a text string that looks like the time string that i write
  the clipboard contains a text string that is of 0 length
  the clipboard does not contain plain text
 i will overwrite the clipboard if it does not contain a graphic and one of these conditions is true
i normally overwrite the contents of the operating system clipboard
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

