
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST


//etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("bye!") ) ;

#endif

if( !bStop ) ether.ifcHireF( tinP , T("f hiring self") , ifcIDaDAM_SCRATCH0f , T("!stop") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

etThread.traceF( tinP , T("[idNumaNode]: ")+TF2(processGlobal1S::_processGlobal1I_IF().idNumaNode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

if( !bStop ) *(countT*)&processGlobal1S::_processGlobal1I_IF().idNumaNode = 0x87654321 ;

}
    }
        }
            break ;
            bStop = 1 ;
        {
        if( !etThread.strCompareF( tinP , psttc1 , T("!stop") ) )
    {
    FORsTRINGSiN1( pzstt1p )
    strokeS*& pzstt1p = etThread.ether_pstt1_processParametersI_F( tinP ) ;
{
ZE( boolT , bStop ) ;



countT rc = bOk ? 0 : GetLastError() ;
static BOOL bOk = QueryWorkingSetEx( GetCurrentProcess() , &info , sizeof info ) ;


info.VirtualAddress = &info ;
thirdC::c_memsetIF( tinP , (byteT*)&info  , sizeof info , 0xbb ) ;
static PSAPI_WORKING_SET_EX_INFORMATION info ;

if( foo ) ;
static countT foo = PSAPI_VERSION ;

}
    }
        }
            CONoUTrAW( ostoSay ) ;
            LOGrAW( ostoSay ) ;

            OStEXTA(  ostoSay , postSay ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , pInfoGrain[ offg ].VirtualAttributes.Node , ' ' ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTCF( ostoSay , pInfoGrain[ offg ].VirtualAddress , '0' ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , offg , ' ' ) ;
            OStEXTAK( ostoSay , "[offg,@,offNode]:    " ) ;
            OStEXT(   ostoSay , TUCK << 1 ) ;
        {
        if( pInfoGrain[ offg ].VirtualAttributes.Node != processGlobal1S::_processGlobal1I_IF().idNumaNode - 1 )

        thirdC::c_strcatIF( tinP , postSay, "\r\n" ) ;
        }
            default                      : { thirdC::c_strcatIF( tinP , postSay, " notRecognized   " ) ; break ; }
            //case PAGE_TARGETS_NO_UPDATE  : { thirdC::c_strcatIF( tinP , postSay, " targetsNoUpdate " ) ; break ; }
            //case PAGE_TARGETS_INVALID    : { thirdC::c_strcatIF( tinP , postSay, " targetsInvalid  " ) ; break ; }
            case PAGE_WRITECOPY          : { thirdC::c_strcatIF( tinP , postSay, " writeCopy       " ) ; break ; }
            case PAGE_READWRITE          : { thirdC::c_strcatIF( tinP , postSay, " readWrite       " ) ; break ; }
            case PAGE_READONLY           : { thirdC::c_strcatIF( tinP , postSay, " readOnly        " ) ; break ; }
            case PAGE_NOACCESS           : { thirdC::c_strcatIF( tinP , postSay, " noAccess        " ) ; break ; }
            case PAGE_EXECUTE_WRITECOPY  : { thirdC::c_strcatIF( tinP , postSay, " executeWriteCopy" ) ; break ; }
            case PAGE_EXECUTE_READWRITE  : { thirdC::c_strcatIF( tinP , postSay, " executeReadWrite" ) ; break ; }
            case PAGE_EXECUTE_READ       : { thirdC::c_strcatIF( tinP , postSay, " executeRead     " ) ; break ; }
            case PAGE_EXECUTE            : { thirdC::c_strcatIF( tinP , postSay, " execute         " ) ; break ; }
        {
        switch( pInfoGrain[ offg ].VirtualAttributes.Win32Protection )
        
        osTextT postSay[ TUCK ] = "" ;

        //ULONG_PTR Valid  :1;
        //ULONG_PTR ShareCount  :3;
        //ULONG_PTR Win32Protection  :11;
        //ULONG_PTR Shared  :1;
        //ULONG_PTR Node  :6;
        //ULONG_PTR Locked  :1;
        //ULONG_PTR LargePage  :1;
        //ULONG_PTR Reserved  :7;
        //ULONG_PTR Bad  :1;


    {
    if( pInfoGrain[ offg ].VirtualAttributes.Valid )
{
for( countT offg = 0 ; offg < cGrains ; offg ++ )

if( cGrains ) ;
static countT cGrains = sizeof pg1.pcInfoGrain / sizeof pg1.pcInfoGrain[ 0 ] ;
static PSAPI_WORKING_SET_EX_INFORMATION* pInfoGrain = (PSAPI_WORKING_SET_EX_INFORMATION*)pg1.pcInfoGrain ;
static processGlobal1S& pg1 = processGlobal1S::_processGlobal1I_IF() ;

#if defined( NEVERdEFINED )

fooF( tinP ) ;

































            }
                if( pfbF ) ;
                static FARPROC pfbF = GetProcAddress( hModule , "SSL_shutdown"     ) ;
                static FARPROC pfaF = GetProcAddress( hModule , "SSL_read"         ) ;
                static FARPROC pf9F = GetProcAddress( hModule , "SSL_write"        ) ;
                static FARPROC pf8F = GetProcAddress( hModule , "SSL_connect"      ) ;
                static FARPROC pf7F = GetProcAddress( hModule , "SSL_set_fd"       ) ;
                static FARPROC pf6F = GetProcAddress( hModule , "SSL_free"         ) ;
                static FARPROC pf5F = GetProcAddress( hModule , "SSL_new"          ) ;
                static FARPROC pf4F = GetProcAddress( hModule , "SSL_CTX_free"     ) ;
                static FARPROC pf3F = GetProcAddress( hModule , "SSL_CTX_new"      ) ;
                static FARPROC pf2F = GetProcAddress( hModule , "SSL_library_init" ) ;
                static FARPROC pf1F = GetProcAddress( hModule , "SSLv23_method"    ) ;
            {                                                                
            else
            if( !hModule ) { BLAMMO ; }

            static HMODULE hModule = LoadLibraryEx( "d:\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\workshop\\openssl\\dll\\ssleay32.dll" , 0 , /*LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR*/0x100 ) ;

    

//#if defined( NEVERdEFINED )

//             LOGrAW( "\r\n\r\n" ) ;
//             LOGrAW( postDllOpenSsl ) ;
//             LOGrAW( "U::TO FIND A BUG, OPENSSL DLL IS NOT LOADED DURING CT OF processGlobal1I:\r\n" ) ;
//             CONoUTrAW( "\r\n" ) ;
//             CONoUTrAW( postDllOpenSsl ) ;
// 
//             thirdC::c_strcatIF( postDllOpenSsl , "precious\\domains\\com\\ideafarm\\city\\workshop\\openssl\\dll\\ssleay32.dll" ) ;







// 
// 
// static countT rc2 = GetLastError() ;
// static countT osh2 = (countT)LoadLibraryEx( "d:\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\workshop\\openssl\\dll\\ssleay32.dll" , 0 , /*LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR*/0x100 ) ;
// static countT rc1 = GetLastError() ;
// static countT osh1 = (countT)LoadLibraryEx( "d:\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\workshop\\openssl\\dll\\libeay32.dll" , 0 , /*LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR*/0x100 ) ;
// 
// 
// //static countT rc = (countT)LoadLibraryEx( "d:\\tmp\\ssleay32.dll" , 0 , /*LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR*/0x100 ) ;
// static countT rc = (countT)LoadLibraryEx( "d:\\tmp\\libeay32.dll" , 0 , /*LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR*/0x100 ) ;

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("loafing!") ) ;

TODO

}
    _OUT_

    thirdC::osTraceWrongNodeIF( tinP , (byteT*)fooF , "adam f fooF" ) ;

    _INoLD_
{
voidT gooF( tinS& tinP )

}
    _OUT_

    thirdC::osTraceWrongNodeIF( tinP , (byteT*)fooF , "adam f fooF" ) ;

    _INoLD_
{
voidT fooF( tinS& tinP )


/*1*/WAKEsHOWtEXT( "was.scratch.f.archived.20180508@1202.scr" )/*1*/
/**/
*/
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

