
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    tinP.pAdamGlobal5->frPaper.grab.ungrabF( tinP ) ;
    setModeFlagsF( tinP , flPAPERbACKmODE_ABSENT , flPAPERbACKmODE_null ) ; //APP CODE MUST EXPLICITLY RESET "ABSENT" FLAG
    thirdC::c_memsetIF( tinP , (byteT*)&rowBack.rw  , sizeof rowBack.rw  ) ;
    tinP.pAdamGlobal5->frPaper.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
cTraceOn( 0 )
bDebug( 0 ) ,
swsSadamToolFilter( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , pbLeverToolFilter , sizeof c2leverToolFilter , flSTACKc_BLOB , sizeof( count3S ) ) ,
pbLeverToolFilter( (const byteT*)&c2leverToolFilter ) ,
mRows( mRowsP ) ,
mCols( mColsP ) ,
mIdRowOrigin( 0.0f ) ,
mIdColOrigin( 0.0f ) ,
stqPelsBack( tinP , sizeof( bitmapOldC ) ) ,
stqr_mIdRowOriginUnder( tinP ) ,
stqr_mIdColOriginUnder( tinP ) ,
papers( tinP , etherP , *this , cPapersP , cArgP , pPaperToBackCBFP , cPaperToBackArgP ) ,
poop( etherP ) ,
ether( etherP ) ,
/*1*/backOldC::backOldC( tinS& tinP , etherC& etherP , const countT cPapersP , const measureT mColsP , const measureT mRowsP , const countT cArgP , paperToBackCBFT pPaperToBackCBFP , countT cPaperToBackArgP ) :/*1*/

//CODEsYNC: 1c60006 1c60003: PAPER LIST IS ASSUMED TO BE INVARIANT UNTIL *this IS DESTROYED

//DERIVED DT MUST CALL dtPrefixF
//DERIVED CT MUST CALL ctSuffixF

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

