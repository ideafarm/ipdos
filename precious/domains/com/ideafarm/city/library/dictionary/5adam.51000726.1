
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.traceF( tinP , T("ok [cDuplicates]:  ")+TF2(cDuplicates,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

}
    ++ s ; ether.osSleepF( tinP , TOCK ) ;
{
while( cWorkers )
sleepC s( tinP , TAG( TAGiDnULL ) ) ;

etThread.delF( tinP , psttYearP ) ;
while( ~hFind && !ether && !POOP ) ;
}
    DEL( pInfo ) ;

    }
        }
            etThread.osThreadF( TaRG1( tmYearF ) , (countT)psttYear , (countT)&cDuplicates ) ;
            inc02AM( cWorkers ) ;
        {
        )
            )
                !etThread.strCompareF( tinP , psttYear , psttYearP )
                ||
                !psttYearP
            (
            &&
            psttYear
        (
        if

        }
            etThread.delF( tinP , psttnu ) ;
            etThread.delF( tinP , psttYearSlash ) ;
            etThread.strBisectF( tinP , psttYear , psttnu , psttYearSlash , tSlash , - 1 ) ; ___( psttnu ) ; ___( psttYear ) ;
            )
                && etThread.strCompareF( tinP , tDotDotSlash , psttYearSlash )
                   etThread.strCompareF( tinP , tDotSlash    , psttYearSlash )
            (
            if

            etThread.delF( tinP , psttnu ) ;
            etThread.strBisectF( tinP , psttnu , psttYearSlash , pInfo->psttIfoName , tSlash , - 2 ) ; ___( psttnu ) ; ___( psttYearSlash ) ;
            ZE( strokeS* , psttYearSlash ) ;
            ZE( strokeS* , psttnu ) ;

            etThread.traceF( tinP , T(pInfo->psttIfoName) ) ;
        {
        if( bDir && etThread.strCompareF( tinP , tDotSlash , pInfo->psttIfoName ) && etThread.strCompareF( tinP , tDotDotSlash , pInfo->psttIfoName ) )
        ZE( strokeS* , psttYear ) ;

        const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
    {
    else
    }
        break ;
        DEL( pInfo ) ;
    {
    if( !pInfo || !pInfo->psttIfoName )

    etThread.diskFindFileOrDirOldF( tinP , pInfo , hFind , tPathArchive+tLike ) ; ___( pInfo ) ;
    ZE( infoFileS* , pInfo ) ;
{
do
handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
TN( tPathArchive , "///d/archive/" ) ;
TN( tDotDotSlash , "../"           ) ;
TN( tDotSlash    , "./"            ) ;
TN( tSlash       , "/"             ) ;
TN( tLike        , "*"             ) ;
ZE( countT , cDuplicates ) ;

etThread.winSetTitleF( tinP , T("20171015@1405:  class!") ) ;

}
    }
        }
            etThread.strMakeF( tinP , LF , psttYearP , psttc1 ) ; ___( psttYearP ) ;
            bArmed = 0 ;
        {
        else if( bArmed )
        if( !etThread.strCompareF( tinP , psttc1 , tArgYear ) ) bArmed = 1 ;
        etThread.traceF( tinP , T("param: ")+T(psttc1) ) ;
    {
    FORsTRINGSiN1( pstt1Param )
    ZE( boolT , bArmed ) ;
    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tinP ) ;
{
TN( tArgYear , "!year" ) ;
ZE( strokeS* , psttYearP ) ;

TODO

DONE( tmYearF )
}
    dec02AM( cWorkers ) ;
    etThread.traceF( tinP , tYearP+T(":  all done") ) ;

    }
        }
            etThread.delF( tinP , psttName ) ;
            }
                etThread.delF( tinP , psttDoomedRoot ) ;

                while( ~hFindFile && !ether && !POOP ) ;
                }
                    DEL( pInfoFile ) ;

                    }
                        }
                            etThread.traceF( tinP , tYearP+T(":      moved :    ")+tShort ) ;
                            etThread.diskMoveFileOrDirF( tinP , tPathDoomed+tShort , tIfoName ) ;
                            etThread.traceF( tinP , tYearP+T(":      moving:    ")+tShort ) ;

                            }
                                etThread.delF( tinP , psttShort ) ;
                                tShort = T(psttShort) ;
                                etThread.delF( tinP , psttPath ) ;
                                tPath = T(psttPath) ;
                                etThread.strBisectF( tinP , psttPath , psttShort , tIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttShort ) ; ___( psttPath ) ;
                                ZE( strokeS* , psttShort ) ;
                                ZE( strokeS* , psttPath ) ;
                            {
                            TN( tShort , "" ) ;
                            TN( tPath , "" ) ;
                        {
                        if( !bDir )

                        const boolT bDir = pInfoFile->psttIfoName[ CSpREFIX - 1 + pInfoFile->psttIfoName->idAdam ].idAdam == '/' ;
                        TN( tIfoName , pInfoFile->psttIfoName ) ;
                    {
                    else
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( !pInfoFile || !pInfoFile->psttIfoName )

                    etThread.diskFindFileOrDirOldF( tinP , pInfoFile , hFindFile , tLike ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                handleC hFindFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                TN( tLike , psttDoomedRoot ) ; tLike += T("*") ;

                etThread.traceF( tinP , tYearP+T(":  doomed:    ")+T(psttDoomedRoot) ) ;
        
                etThread.strSubstringF( tinP , psttDoomedRoot , idf , idHit , psttName ) ; ___( psttDoomedRoot ) ;
                countT idf = 1 ;
                ZE( strokeS* , psttDoomedRoot ) ;
            {
            if( idHit )
            countT idHit = etThread.strIdF( tinP , tDotDataDot , psttName ) ;

            swsDoomed >> psttName ;
            ZE( strokeS* , psttName ) ;
        {
        while( swsDoomed )

        etThread.traceF( tinP , tYearP+T(":  22222222    ")+TF2(cbFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        cbFile = swsDoomed.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swsDoomed.cFlavorsF( tinP ) ;
    TN( tPathDoomed , "///d/tmp/duplicate.content.removed.from.archive/" ) ;

    }
        }
            etThread.delF( tinP , pbBufferOther  ) ;
            etThread.delF( tinP , pbBufferCursor ) ;
            }
                }
                    while( ~hWalkCursor ) ;
                    }
                        etThread.delF( tinP , psttNameCursor ) ;
                        while( ~hWalkOther ) ;
                        }
                            etThread.delF( tinP , psttNameOther ) ;
                            }
                                }
                                    }
                                        inc02AM( cDuplicatesP ) ;
                                        cDoomed ++ ;
                                        etThread.traceF( tinP , tYearP+T(":  [cursor,other]:  ")+T(psttNameCursor)+T("    ")+T(psttNameOther)+T(bSame?"    MATCH":"            different") ) ;
                                    {
                                    else
                                    if( !ids ) etThread.delF( tinP , psttFile ) ;
                                    swsDoomed.sinkF( tinP , ids , psttFile , flSTACKsINK_UNIQUE ) ;
                                    ZE( countT , ids ) ;

                                    etThread.strMakeF( tinP , LF , psttFile , psttNameOther ) ; ___( psttFile ) ;
                                    ZE( strokeS* , psttFile ) ;
                                {
                                if( bSame )

                                }
                                    }
                                        }
                                            break ;
                                            bSame = 0 ;
                                        {
                                        if( etThread.memCompareF( tinP , pbBufferCursor , pbBufferOther , cbChunk ) )
    
                                        etThread.fileReadF( tinP , pbBufferOther  , cbChunk , hFileOther  ) ;
                                        etThread.fileReadF( tinP , pbBufferCursor , cbChunk , hFileCursor ) ;
    
                                        cbToDo -= cbChunk ;
    
                                        ;
                                            : CBbUFFER
                                            ? cbToDo
                                        countT cbChunk = cbToDo < CBbUFFER
                                    {
                                    while( cbToDo )
                                    countT cbToDo = cbFile ;
                                {
                                boolT bSame = 1 ;

                                etThread.fileOpenF( tinP , hFileOther  , countTC() , psttNameOther  ) ;
                                etThread.fileOpenF( tinP , hFileCursor , countTC() , psttNameCursor ) ;

                                handleC hFileOther(  tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                                handleC hFileCursor( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;

                                //etThread.traceF( tinP , tYearP+T(":  [cursor,other]:  ")+T(psttNameCursor)+T("    ")+T(psttNameOther) ) ;
                            {
                            else if( bArmed )
                            if( !etThread.strCompareF( tinP , psttNameOther , psttNameCursor ) ) bArmed = 1 ;

                            etThread.strDecodeF( tinP , psttNameOther , pbEncodedOther ) ; ___( psttNameOther ) ;
                            ZE( strokeS* , psttNameOther ) ;

                            byteT* pbEncodedOther = (byteT*)swsFileNames.downF( tinP , hWalkOther ) ;
                        {
                        do
                        handleC hWalkOther( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        ZE( boolT , bArmed ) ;

                        etThread.strDecodeF( tinP , psttNameCursor , pbEncodedCursor ) ; ___( psttNameCursor ) ;
                        ZE( strokeS* , psttNameCursor ) ;

                        byteT* pbEncodedCursor = (byteT*)swsFileNames.downF( tinP , hWalkCursor ) ;
                    {
                    do
                    handleC hWalkCursor( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    ZE( boolT , cDoomed ) ;

                    etThread.traceF( tinP , tYearP+T(":  [cFlavorsNotStarted,cbFile]:  ")+TF2(cFlavorsNotStarted,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("        ")+TF2(cbFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( swsFileNames > 1 )

                cbFile = swsFileNames.leverF( tinP , idf ) ;

                cFlavorsNotStarted -- ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavorsNotStarted = cFlavors ;
            countT cFlavors = swsFileNames.cFlavorsF( tinP ) ;
            etThread.traceF( tinP , tYearP+T(":  loading doomed file names into swsDoomed") ) ;
            
            }
                while( ~hFind && !ether && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        }
                            swsFileNames << pbEncoded ;
                            etThread.strEncodeF( tinP , pbEncoded , tIfoName ) ; ___( pbEncoded ) ;
                            ZE( byteT* , pbEncoded ) ;

                            cbFile = pInfoFile->cbUsed ;

                            if( pInfoFile->cbUsedHigh ) { BLAMMO ; }
                        {
                        if( !bDir )

                        const boolT bDir = pInfoFile->psttIfoName[ CSpREFIX - 1 + pInfoFile->psttIfoName->idAdam ].idAdam == '/' ;
                        TN( tIfoName , pInfoFile->psttIfoName ) ;

                        if( pInfoFile->cbUsedHigh ) { BLAMMO ; }
                    {
                    else
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( !pInfoFile || !pInfoFile->psttIfoName )

                    etThread.diskFindFileOrDirOldF( tinP , pInfoFile , hFind , tPathYear+tLikeFile ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {                                                                                                                                   //20180702@1707: JPG: (pending)
                do                                                                                                                                  //20180702@1706: AVI (done)
                handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                TN( tLikeFile , "!ideafarm.8.2.00000000.00000001.*.data.mp3" ) ;                            // DONE: JPG    (I ONLY DO WO FILE TYPE AT A TIME (ONLY RUN ME FOR: AVI MP3 JPG AND OTHER TYPES THAT CLEARLY SHOULD NOT BE DUPLICATES.  TTT IS AN EXAMPLE OF A FILE TYPE THAT MIGHT WELL BE INTENTIONALLY DUPLICATED (MANY DAY TITLES ARE "-")
                TN( tPathYear , "///d/archive/" ) ; tPathYear += tYearP+tSlash ;
            {
            etThread.traceF( tinP , tYearP+T(":  loading file names into swsFileNames") ) ;

            etThread.newF( tinP , LF , pbBufferOther  , CBbUFFER ) ; ___( pbBufferOther  ) ;
            etThread.newF( tinP , LF , pbBufferCursor , CBbUFFER ) ; ___( pbBufferCursor ) ;
            ZE( byteT* , pbBufferOther  ) ;
            ZE( byteT* , pbBufferCursor ) ;
            etThread.traceF( tinP , tYearP+T(":  preallocating oo buffers") ) ;
        {
        switchStackC swsFileNames( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cbFile , flSTACKc_null , ifcSTACKtYPE_PTR_byteT ) ;
    {
    TN( tDotDataDot , ".data." ) ;
    TN( tSlash , "/" ) ;
    switchStackC swsDoomed( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cbFile , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    ZE( countT , cbFile ) ;

    }
        etThread.delF( tinP , psttYearP ) ;
        tYearP = T(psttYearP) ;
        strokeS* psttYearP = (strokeS*)pTaskP->c1 ;
    {
    TN( tYearP , "" ) ;
    countT& cDuplicatesP = *(countT*)pTaskP->c2 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmYearF )

ZE( countT , cWorkers ) ;

#define CBbUFFER (TOCK)

/*1*/WAKEsHOWtEXT( "was.scratch.1.archived.20180508@1202.tool.file.delete.duplicate.content.in.archive" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
