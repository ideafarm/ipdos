
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        if( F(pP.flags) & flBRANCHspUTfILEf_BEEP ) etherP.beeClickF( tinP ) ;
        etherP.traceF( tinP , T("put""FileIF/ - edition [idEdition]: ")+TF2(idEdition,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
        etherP.delF( tinP , psttSave ) ;
        etherP.diskHoverF( tinP , psttSave ) ;

        }
            }
                }
                    }
                        idVolume ++ ;
                        idZip = 1 ;
                    {
                    else
                    if( bVolumeOk ) idZip ++ ;
                {
                if( !bLath )

                etherP.delF( tinP , psttArg ) ;
                }
                    etherP.osProcessF( tinP , countTC() , countTC() , value , idDeathType , tExe , psttArg ) ;
                    ZE( countT , idDeathType ) ;
                    ZE( countT , value ) ;
                    }
                        etherP.diskHoverF( tinP , tPathArchive ) ;
                        etherP.osProcessF( tinP , countTC() , countTC() , value , idDeathType , tExe , tArgMove+tb+tFileReadme+tb+tFileShort+T(".html")+tb+tFileShort+T(".*.html") ) ;
                        ZE( countT , idDeathType ) ;
                        ZE( countT , value ) ;
                        TN( tArgMove , "-9rm " ) ; tArgMove += T(osfOut) ;
                        osFileNameC osfOut(  tinP , etherP , T("ideafarm.com.")+tFileShort+T(".kt.")+TF3(idVolume,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,2)+T(".")+TF3(idZip,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,2)+T(".zip") ) ;
                        etherP.diskHoverF( tinP , tFileDir ) ;
                    {
                    if( bLath )
                {
                if( !bQuitP )
                boolT bLath = !stFile ;

                }
                    stFile << (countT)pSizeName ;

                    etherP.strokeF( tinP , TF3(pSizeName->cbUsed,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,8)+T(",")+TF3(pSizeName->cbUsedHigh,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("\r\n") ) ;

                    stLater >> *(countT*)&pSizeName ;
                    ZE( fileSizeNameS* , pSizeName ) ;
                {
                while( stLater )
                CONoUTrAW3( "------------ " , stLater , " LATER:\r\n" ) ;

                }
                    }
                        etherP.strFuseF( tinP , psttArg , tWo ) ;

                        DEL( pSizeName ) ;
                        etherP.osTimeSubtractF( tinP , capRemainLo , capRemainHi , pSizeName->cbUsed , pSizeName->cbUsedHigh ) ;
                        if( idResult != ifcOPENrESULT_EXISTED ) etherP.fileWriteF( tinP , hFile1 , tName+tcr , tName.csF( tinP ) + tcr.csF( tinP ) ) ;
                    {
                    else
                    if( !bOk ) stLater << (countT)pSizeName ;

                    etherP.strokeF( tinP , TF3(capRemainLo,capRemainHi?flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE:flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+(capRemainHi?TF3(capRemainHi,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9):TP("",9))+TF3(pSizeName->cbUsed,pSizeName->cbUsedHigh?flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE:flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+(pSizeName->cbUsedHigh?TF3(pSizeName->cbUsedHigh,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9):TP("",9))+T(idResult==ifcOPENrESULT_EXISTED?"****PACKINGLISTED**** ":bOk?"* ":" ")+TF2(idVolume,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".")+TF2(idZip,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ;

                    ) ;
                        bVolumeOk
                        &&
                        tWo.csF( tinP ) <= psttArg[ 2 ].idAdam
                    (
                    boolT bOk =

                    ) ;
                        ( pSizeName->cbUsedHigh == capRemainHi && pSizeName->cbUsed < capRemainLo )
                        ||
                        ( pSizeName->cbUsedHigh < capRemainHi )
                        ||
                        idResult == ifcOPENrESULT_EXISTED                               // IF stFile IS LOADED WITH A PACKING LIST
                    (
                    bVolumeOk =

                    TN( tWo , " " ) ; tWo += tName ;
                    TN( tName , pSizeName->postOsName ) ;

                    stFile >> *(countT*)&pSizeName ;
                    ZE( fileSizeNameS* , pSizeName ) ;
                {
                while( stFile )
                ZE( boolT , bVolumeOk ) ;

                }
                    DEL( pInfoPack ) ;
                    }
                        }
                            stFile << c_pSizeName ;
                            stHold >> c_pSizeName ;
                            ZE( countT , c_pSizeName ) ;
                        {
                        while( stHold )

                        stListed_postShort.purgeF( tinP ) ;
                        }
                            }
                                stHold << (countT)pSizeName ;
                                etherP.delF( tinP , postShort ) ;
                                stListed_postShort.extractF( (byteT*)&postShort , tinP ) ;
                                ZE( osTextT* , postShort ) ;
                            {
                            else
                            if( !stListed_postShort( pSizeName->postOsName ) ) stLater << (countT)pSizeName ;

                            stFile >> *(countT*)&pSizeName ;
                            ZE( fileSizeNameS* , pSizeName ) ;
                        {
                        while( stFile )
                        stackC stHold( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO|flSTACKc_DOnOTsERIALIZE ) ;

                        }
                            etherP.delF( tinP , pstt1Short ) ;
                            }
                                }
                                    __1 ; //IMPOSSIBLE UNLESS A HUMAN EDITS THE PACKING LIST TO CREATE DUPLICATE LINES
                                    etherP.delF( tinP , postShort ) ;
                                {
                                if( !ids )
                                stListed_postShort.sinkF( tinP , ids , postShort , flSTACKsINK_UNIQUE ) ;
                                ZE( countT , ids ) ;

                                etherP.strMakeF( tinP , postShort , psttc1 ) ; ___( postShort ) ;
                                ZE( osTextT* , postShort ) ;
                            {
                            FORsTRINGSiN1( pstt1Short )

                            }
                                etherP.delF( tinP , psttPack ) ;
                                etherP.strWordsF( tinP , pstt1Short , psttPack , sttq , tcr ) ; ___( pstt1Short ) ;
                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

                                }
                                    etherP.delF( tinP , postPack ) ;
                                    }
                                        etherP.strMakeFromOsTextF( tinP , psttPack , postPack ) ; ___( psttPack ) ;
                                        postPack[ pInfoPack->cbUsed ] = 0 ;
                                        __( cbActual - pInfoPack->cbUsed ) ;
                                        etherP.fileReadF( tinP , postPack , cbActual , hFile1 ) ;
                                        countT cbActual = pInfoPack->cbUsed ;
                                    {
                                    if( postPack )
                                    etherP.newF( tinP , LF , postPack , pInfoPack->cbUsed + 1 ) ; ___( postPack ) ;
                                    ZE( osTextT* , postPack ) ;
                                {
                                ZE( strokeS* , psttPack ) ;
                            {
                            ZE( strokeS* , pstt1Short ) ;
                        {
                        stackC stListed_postShort( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO|flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_byteT ) ;
                    {
                    else
                    if( !pInfoPack->cbUsed ) idResult = 0 ;
                    etherP.diskFileQueryF( tinP , pInfoPack , hFile1 ) ; ___( pInfoPack ) ;
                    ZE( infoFileS* , pInfoPack ) ;

                    CONoUTrAW( "packing list found\r\n" ) ;
                {
                if( idResult == ifcOPENrESULT_EXISTED )
                __NZ( stLater ) ;

                etherP.fileOpenF( tinP , hFile1 , idResult , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/put""FileF/")+tFileDadShort+T("/packing.list.")+TF2(idEdition,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".")+TF2(idVolume,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".")+TF2(idZip,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".txt") , ifcOPENaCCESS_WR , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeO ) ;
                ZE( countT , idResult ) ;
                handleC hFile1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;

                }
                    etherP.strMakeF( tinP , psttArg , tArg , csttAllMax - 1 - tExeOs.csF( tinP ) - tArg.csF( tinP ) ) ; ___( psttArg ) ; // COMMAND LINE LIMIT FOR dosExecPgmF.  LIMIT - COSTeXE - SPACE AFTER EXE - TERMINATOR
                    countT csttAllMax = ( TOCK >> 1 ) - 2 ; // WIN32 DOC CLAIMS LIMIT OF ( TOCK >> 1 ) - 1 EXCLUDING TERMINATOR, BUT THE LIMIT IS REALLY 1 LESS
                    TN( tArg , "-9r " ) ; tArg += T(osfOut2) ;
                    osFileNameC osfOut2(  tinP , etherP , tFileDir+T("ideafarm.com.")+tFileShort+T(".kt.")+TF3(idVolume,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,2)+T(".")+TF3(idZip,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,2)+T(".zip") ) ;
                {
                ZE( strokeS* , psttArg ) ;

                sCountT capRemainHi = 0x1 ;
                countT  capRemainLo = 0x18244F00 ; // 4.7 GB (4700000000_9 BYTES)
                CONoUTrAW( "------------ SORTED:\r\n" ) ;
                if( ( bWoth && bWoth -- ) || !( stFile % TUCK ) ) etherP.traceF( tinP , T("put""FileIF/ + edition ")+TF2(idEdition,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(": zipping [stFile,stLater]: ")+TF2(stFile,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(stLater,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
            {
            while( stFile ) // WHILE I STILL NEED TO EMIT ANOTHER VOLUME
            stackC stLater( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO|flSTACKc_DOnOTsERIALIZE ) ; // USED TO POUR SOME BACK INTO stFile, PRESERVING THE DECREASING ORDER OF FILE SIZE
            boolT bWoth = 1 ;

            pP.pswUrlReferenced->ungrabF( tinP ) ;
            }
                DEL( pInfo ) ;

                }
                    }
                        __Z( ids ) ;
                        stFile.sinkF( tinP , ids , (countT)pSizeName , flSTACKsINK_UNIQUE , subtractSizeNameF ) ; pSizeName = 0 ;
                        ZE( countT , ids ) ;

                        //CONoUTrAW( T(" \"")+T(pSizeName->postOsName)+T("\"\r\n") ) ;
                        //CONoUTrAWb( "[idf,cbUsed,cbUsedHigh]: " , idf , " " , pSizeName->cbUsed , " " , pSizeName->cbUsedHigh , "" ) ;
                    {
                    if( pSizeName )

                    fileSizeNameS* pSizeName = new( 0 , tinP , LF ) fileSizeNameS( tinP , etherP , *pInfo , *pP.ppsttLever ) ; ___( pSizeName ) ;
                {
                if( pInfo )

                THREADmODE1rESTORE
                }
                    if( pInfo && pInfo->psttIfoName ) etherP.delF( tinP , pInfo->psttIfoName ) ;

                    //CONoUTrAW3( " queried file size name [pSizeName]: " , pSizeName , "\r\n" ) ;
                    etherP.diskFileQueryF( tinP , pInfo , hFile1 ) ; ___( pInfo ) ;
                    //CONoUTrAW( " querying file size name\r\n" ) ;
                    OPENfILErEAD1( tPathArchive+T(*pP.ppsttLever) )
                    etherC& etThread = etherP ;
                {
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                ZE( infoFileS* , pInfo ) ;

                etherP.strokeF( tinP , T("[cRemaining,file]: ")+TF2(cFlavors-idf,flFORMAT_NObIGITvALUES)+T(" ")+tPathArchive+T(*pP.ppsttLever)+T("\r\n") ) ;
                *pP.ppsttLever = (strokeS*)pP.pswUrlReferenced->leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors && !bQuitP ; idf ++ )
            countT cFlavors = pP.pswUrlReferenced->cFlavorsF( tinP ) ; 
            pP.pswUrlReferenced->grabF( tinP , TAG( TAGiDnULL ) ) ;

            stackC stFile( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO|flSTACKc_DOnOTsERIALIZE ) ; //WILL CONTAIN fileSizeNameS* POINTERS, IN DECREASING ORDER OF FILE SIZE
            etherP.traceF( tinP , T("put""FileIF/ + edition ")+TF2(idEdition,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(": loading stFile") ) ;

            etherP.diskHoverF( tinP , tPathArchive ) ;
            TN( tPathArchive , "" ) ; tPathArchive = T("///ideafarm/IdeaFarm " "(tm)/Drop Files Here To Archive/" ) ;
            //20130728@1422: DON'T KNOW WHY THE DRIVE LETTER IS HARDCODED: TN( tPathArchive , "" ) ; tPathArchive = T("///d/ideafarm.home.")+TF2(etherP.ifc_idHomeIdisk_IF(),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("/IdeaFarm " "(tm)/Drop Files Here To Archive/" ) ;

            TN( tcr      , "\r\n" ) ;
            TN( tb , " " ) ;
            TN( tArg     , "-9r "  ) ; tArg     += T(osfOut) ;
            osFileNameC osfOut(  tinP , etherP , tFileDir+T("ideafarm.com.")+tFileShort+T(".kt.")+TF3(idVolume,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,2)+T(".")+TF3(idZip,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,2)+T(".zip") ) ;
            countT idZip    = 1 ; // MULTIPLE ZIP FILES ARE NEEDED DUE TO THE CAPACITY LIMIT (TOCK >> 1) OF THE COMMAND LINE ARGUMENT TO osProcessF
            countT idVolume = 1 ; // MULTIPLE VOLUMES ARE NEEDED DUE TO THE CAPACITY LIMIT (4.7 GB) OF A DVD DISK

            TN( tExeOs , osfExe ) ;
            osFileNameC osfExe(  tinP , etherP , tExe ) ;

            }
                etherP.delF( tinP , psttm ) ;
                tExe = T(psttm) ;
                etherP.diskMapFileNameF( tinP , psttm , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/infozip/zip.exe/zip.exe") ) ; ___( psttm ) ;
                ZE( strokeS* , psttm ) ;
            {
            TN( tExe , "" ) ;
        {
        if( !( F(pP.flags) & flBRANCHspUTfILEf_NOzIP ) && !bQuitP )

        }
            etherP.boxPutF( tinP , tFileDir+tFileReadme , tReadme , tReadme.csF( tinP ) ) ;

            ) ;

                "available.\r\n"
                "If you are a new subscriber, ask the publisher whether prior issues are\r\n"
                "\r\n"
                "Copy the volumes of the new issue into the folder that contains prior issues.\r\n"
                "For a periodical, each new issue is shipped as a volume or set of volumes.\r\n"
                "\r\n"
                "Open that folder, and then open the file \"index.html\".\r\n"
                "folder.  The order in which you copy multiple volumes of a set does not matter.\r\n"
                "Copy this entire shipping volume, and all others in the set, into a new\r\n"
                "These files comprise one \"shipping volume\" of a possibly multivolume set.\r\n"
                "\r\n"
                "When this is done, your web browser will appear.\r\n"
                "and video files, and are viewed by opening the file named \"index.html\".\r\n"
                "Knowledge trees are distributed as \"html files\" accompanied by audio\r\n"
                "An IdeaFarm " "(tm) Knowledge Tree is a multimedia hypertext document.\r\n"
                "\r\n"
                "\r\n"
                "IdeaFarm " "(tm) Knowledge Tree\r\n"

            TN( tReadme ,
        {
        TN( tFileReadme , "!readme.txt" ) ;

        etherP.diskHoverF( tinP , tFileDir ) ;
        etherP.diskGetHoverF( tinP , psttSave ) ; ___( psttSave ) ;
        ZE( strokeS* , psttSave ) ;
        //U::MIGRATE THIS INTO A hoverC CLASS EQUIVALENT TO WHAT IS USED IN ELVES

        }
            etherP.delF( tinP , psttDadShort ) ;
            tFileDadShort = T(psttDadShort) ;
            etherP.strWordF( tinP , psttDadShort , tFileDirDad , sttq , strokeS( '/') , - 2 ) ; ___( psttDadShort ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , psttDadShort ) ;

            etherP.delF( tinP , psttPart2 ) ;
            etherP.delF( tinP , psttPart1 ) ;
            tFileShort  = T(psttPart2) ;
            tFileDir    = T(psttPart1)+TF2(idEdition,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("/") ; //20141005@1103: ADDED "|flFORMAT_FOREIGN" W/O ANALYSIS SO THAT DIRECTORIES WILL SORT NICER
            tFileDirDad = T(psttPart1) ;
            etherP.strBisectF( tinP , psttPart1 , psttPart2 , pP.psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPart1 ) ; ___( psttPart2 ) ;
            ZE( strokeS* , psttPart2 ) ;
            ZE( strokeS* , psttPart1 ) ;
        {
        TN( tFileShort , "" ) ;
        TN( tFileDir   , "" ) ;
        TN( tFileDirDad , "" ) ;
        TN( tFileDadShort , "" ) ;
        TN( tFile      , pP.psttFile ) ;

        }
            etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;

            }
                ++ s ; etherP.osSleepF( tinP ) ;
            {
            while( cWorkers )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;

            }
                }
                    if( bWoth ) bWoth = 0 ;
                    etherP.osThreadF( TaRG1( tmPutFileWorkerF ) , (countT)pcArg ) ;

                    etherP.memCopyF( tinP , (byteT*)pcArg , (byteT*)pcFrom , sizeof pcFrom ) ;
                    etherP.newF( tinP , LF , *(byteT**)&pcArg , sizeof pcFrom ) ; ___( pcArg ) ;
                    countT pcFrom[] = { (countT)&cWorkers , (countT)&cPending , (countT)&pP , (countT)&cLeverBranch , (countT)&swFile , (countT)&st_putFileJob , bWoth , (countT)psttTimeStampP , (countT)psttBanner1P , (countT)psttBanner2P , (countT)psttNameSpaceP } ;
                    ZE( countT* , pcArg ) ;

                    inc02AM( cWorkers ) ;
                {
                while( cDo -- )
                boolT bWoth = 1 ;
                etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , cDo ) ;

                //cDo = 1 ;                                          //20171218@1405: cDo = 1 TO FIND A BUG
                countT cDo = thirdC::osProcessorsIF( tinP ) << 1 ; //4->2 IN RESPONSE TO POOL EXHAUSTION 20170607@1650 ; 20171214@2204: << 2 -> >> 1 IN RESPONSE TO POOL EXHAUSTION; 20171229@1632: ">> 1" -> "" AFTER ELIMIMATING baryC PREALLOCATION
            {
            ZE( countT , cWorkers ) ;
        {

        //LOGrAW3( "called  putFileIF for edition " , idEdition , " -\r\n" ) ;
        }
            st_putFileJob << (byteT*)&job ;
            inc02AM( cPending ) ;
            putFileJobS job( idEdition , 0 , 0 , idJot , idJot , idJot ) ;
            countT idJot = jotP.tagHighNibbleF() | idSequenceJotP ;
        {
        ZE( countT , cPending ) ;
        stackC st_putFileJob( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_BLOB /*| flSTACKc_FIFO*/ /*| flSTACKc_XRAY*/ , sizeof( putFileJobS ) ) ;      //20171229@0841: FIFO->LIFO TO REDUCE ADDRESS SPACE USAGE (FIFO RESULTS IN ALL LEAF JOBS BEING ACCUMATED BEFORE ANY ARE DONE)
        //LOGrAW3( "calling putFileIF for edition " , idEdition , " +\r\n" ) ;

        }
            }
                }
                    etherP.diskWalkCopyFileF( tinP , tFileLinkTo , tFileLinkFrom ) ;

                    }
                        etherP.delF( tinP , psttPart2 ) ;
                        etherP.delF( tinP , psttPart1 ) ;
                        tFileLinkTo = T(psttPart1)+TF2(idEdition,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("/")+T(psttPart2)+tFileSuffix ;
                        etherP.strBisectF( tinP , psttPart1 , psttPart2 , pP.psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPart1 ) ; ___( psttPart2 ) ;
                        ZE( strokeS* , psttPart2 ) ;
                        ZE( strokeS* , psttPart1 ) ;
                    {
                    TN( tFileLinkTo  , "" ) ;
                {
                if( etherP.diskFileExistsF( tinP , tFileLinkFrom ) )
                TN( tFileLinkFrom  , "" ) ; tFileLinkFrom = T(pP.psttFile)+tFileSuffix ;
                TN( tFileSuffix    , ppSuffix[ offi ] ) ;
            {
            for( countT offi = 0 ; offi < sizeof ppSuffix / sizeof ppSuffix[ 0 ] ; offi ++ )

            } ;
                ".link.frag.notes.txt"
                ".link.frag.notes.soul.not.html"    ,
                ".link.pages.txt"                   ,
                ".link.pages.soul.not.html"         ,
            {
            osTextT* ppSuffix[] =
        {

        }
            etherP.fileWriteF( tinP , hFile , "\r\n<pre>\r\n" , 9 ) ;
            }
                }
                    default  : { etherP.fileWriteF( tinP , hFile , postSourceP + offi , 1 ) ; break ; }
                    case '>' : { etherP.fileWriteF( tinP , hFile , "&gt;"             , 4 ) ; break ; }
                    case '<' : { etherP.fileWriteF( tinP , hFile , "&lt;"             , 4 ) ; break ; }
                {
                switch( postSourceP[ offi ] )
            {
            for( countT offi = 0 ; offi < costSourceP ; offi ++ )
            etherP.fileWriteF( tinP , hFile , "<pre>\r\n" , 7 ) ;

            etherP.fileOpenF( tinP , hFile , countTC() , tFileSoilTo+T("1.html") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ; // READABLE LIST OF LINKAGE LABELS
            handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;

            }
                etherP.delF( tinP , psttPart2 ) ;
                etherP.delF( tinP , psttPart1 ) ;
                tFileSoilTo = T(psttPart1)+TF2(idEdition,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("/soil/")+T(psttPart2)+T(".") ;
                etherP.strBisectF( tinP , psttPart1 , psttPart2 , pP.psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPart1 ) ; ___( psttPart2 ) ;
                ZE( strokeS* , psttPart2 ) ;
                ZE( strokeS* , psttPart1 ) ;
            {
            TN( tFileSoilTo , "" ) ;
        {                                                                                   // WRITE THE INPUT FILE AS AN HTML FILE SO THAT IT CAN BE VIEWED IN A BROWSER
        if( postSourceP && costSourceP )

        etherP.traceF( tinP , T("put""FileIF/ [psttFile]:    ")+T(pP.psttFile) ) ;
        etherP.traceF( tinP , T("put""FileIF/ + edition [idEdition]: ")+TF2(idEdition,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
    {
    //for( countT idEdition = 1 ; idEdition <= 5 && !bQuitP ; idEdition ++ )
    for( countT idEdition = 3 ; idEdition <= 3 && !bQuitP ; idEdition ++ )

    switchC swFile( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , cLeverBranch ) ;
    ZE( countT , cLeverBranch ) ;

    }
        if( POOP ) return ;
        FV( flBRANCHspUTfILEf , pP.flags ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT branchS::putFileIF( tinS& tinP , etherC& etherP , const boolT& bQuitP , putFileS& pP , jotC& jotP , const countT idSequenceJotP , const strokeS* const psttTimeStampP , const strokeS* const psttBanner1P , const strokeS* const psttBanner2P , const strokeS* const psttNameSpaceP , const osTextT* const postSourceP , const countT costSourceP )/*1*/

DONE( tmPutFileWorkerF )
THREADmODE3rESTORE
}
    dec02AM( cWorkersP ) ;

    tinP.monitor.idWhat2 = 0 ;
    if( bWhereP ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;

    }
        ++ s ; etThread.osSleepF( tinP ) ;

        st_putFileJob_P.ungrabF( tinP ) ;
        }
            st_putFileJob_P.grabF( tinP , TAG( TAGiDnULL ) ) ;

            if( bWhereP ) etThread.traceF( tinP , T("bWhere is set / called  putFileIF") ) ;

            etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_DISABLE ) ;

            dec02AM( cPendingP ) ;
            branchS::putFileIF( tinP , etThread , countTC() , cPendingP , st_putFileJob_P , pP , job.offLevel , job.jMe , job.jDad , job.jGrandDad , cLeverBranchP , swFileP , job.cNest , job.idEdition , psttzTimeStampP , psttzBanner1P , psttzBanner2P , psttzNameSpaceP ) ;
            if( bWhereP ) etThread.traceF( tinP , T("bWhere is set / calling putFileIF") ) ;

            etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_ENABLE ) ;

            st_putFileJob_P.ungrabF( tinP ) ;
            st_putFileJob_P >> pb_job ;
            byteT* pb_job = (byteT*)&job ;
            putFileJobS job ;
        {
        while( st_putFileJob_P )
        st_putFileJob_P.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    while( cPendingP )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    if( bWhereP ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
    tinP.monitor.idWhat2 = - 1 ;

    etThread.delF( tinP , pcArgP ) ;

    if( bWhereP ) etThread.traceF( tinP , T("bWhere is set") ) ;

    //20180119@1634: 0->1 WITHOUT ANALYSIS
    bWhereP = 1 ; //U::20140808@1625: DISABLED PENDING MIGRATION TO NEW BLOB FUNCTIONALITY FOR switchC ; ENABLE AFTER Where HAS BEEN MODIFIED TO CONFORM TO THE NEW FUNCTIONALITY (THE LEVER WILL BE A POINTER RATHER THAN A PLACE WHERE A VALUE IS WRITTEN)

    const strokeS* psttzNameSpaceP =      (strokeS*)pcArgP[ 0xa ] ;
    const strokeS* psttzBanner2P   =      (strokeS*)pcArgP[ 0x9 ] ;
    const strokeS* psttzBanner1P   =      (strokeS*)pcArgP[ 0x8 ] ;
    const strokeS* psttzTimeStampP =      (strokeS*)pcArgP[ 0x7 ] ;
    boolT          bWhereP         =                pcArgP[ 0x6 ] ;
    stackC&        st_putFileJob_P =      *(stackC*)pcArgP[ 0x5 ] ;
    switchC&       swFileP         =     *(switchC*)pcArgP[ 0x4 ] ;
    countT&        cLeverBranchP   =      *(countT*)pcArgP[ 0x3 ] ;
    putFileS&      pP              =    *(putFileS*)pcArgP[ 0x2 ] ;
    countT&        cPendingP       =      *(countT*)pcArgP[ 0x1 ] ;
    countT&        cWorkersP       =      *(countT*)pcArgP[ 0x0 ] ;

    countT*        pcArgP = (countT*)pTaskP->c1 ;

    thirdC::c_memcpyIF( tinP , (byteT*)tinP.ppJot , (byteT*)pTaskP->pTinDad->ppJot , sizeof tinP.ppJot ) ; //U::DEFINE A MACRO "INHERITjOTrEGISTRY"
{
if( pTaskP && pTaskP->c1 )

THREADmODE3oN( idIn == 1 ? flTHREADmODE3_LOGsPINcALLnEST : flTHREADmODE3_null )      //U::TO FIND A BUG: LOTS OF SPINLOCK SPINNING ON THESE THREADS
countT idIn = 1 + incv02AM( idInLath ) ;                                             //U::TO FIND A BUG: LOTS OF SPINLOCK SPINNING ON THESE THREADS
static countT idInLath ;                                                             //U::TO FIND A BUG: LOTS OF SPINLOCK SPINNING ON THESE THREADS

TASK( tmPutFileWorkerF )

}
    return - scSgn ;

    }
        }
            if( !scSgn ) scSgn = thirdC::c_strcmpIF( tinP , pSizeName1P->postOsName , pSizeName2P->postOsName ) ;
            if( !scSgn ) scSgn = pSizeName1P->cbUsed     - pSizeName2P->cbUsed     ;
                         scSgn = pSizeName1P->cbUsedHigh - pSizeName2P->cbUsedHigh ;
        {
        else
        else if( !pSizeName1P &&  pSizeName2P ) scSgn = - 1 ;
        else if(  pSizeName1P && !pSizeName2P ) scSgn =   1 ;
             if( !pSizeName1P && !pSizeName2P )              ;

        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )
    ZE( sCountT , scSgn ) ;

    const fileSizeNameS* const pSizeName2P = (const fileSizeNameS*)c2P ;
    const fileSizeNameS* const pSizeName1P = (const fileSizeNameS*)c1P ;

    }
    {
    IFbEcAREFUL
{
countT subtractSizeNameF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    etherP.strMakeF( tinP , postOsName , psttShortP ) ; ___( postOsName ) ;
{
cbUsedHigh( infoP.cbUsedHigh )
cbUsed( infoP.cbUsed ) ,
postOsName( 0 ) ,
fileSizeNameS::fileSizeNameS( tinS& tinP , etherC& etherP , const infoFileS& infoP , const strokeS* const psttShortP ) :

}
    tinP.pEther->delF( tinP , postOsName ) ;
    TINSL
{
fileSizeNameS::~fileSizeNameS( voidT )

NEWdELcLASS( 1 , fileSizeNameS )

;
}
    fileSizeNameS( tinS& tinP , etherC& etherP , const infoFileS& infoP , const strokeS* const psttShortP ) ;
    ~fileSizeNameS( voidT ) ;
    NEWdELcLASSpROTOS ;

    const countT   cbUsedHigh ;
    const countT   cbUsed ;
    osTextT*       postOsName ;
{
struct _export fileSizeNameS
//U::MOVE TO BASE

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

