
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.loafIF( tinP ) ;

nodeC nodeMe( tinP , etThread ) ;

TODO

}
    }
        ++ s ; ether.osSleepF( tinP , TOCK >> 2 ) ;
    {
    while( cKids )
    bQuit = 1 ;

    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;
    {
    while( !etPrime )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    etherC& etPrime = etherC::etPrimeIF( tinP ) ;

    ether.osThreadF( TaRG1( tmAcceptF      ) , (countT)this , (countT)&bQuit , (countT)&cKids , (countT)&stOpen ) ;
    ether.osThreadF( TaRG1( tmRefreshListF ) , (countT)this , (countT)&bQuit , (countT)&cKids , (countT)&stOpen ) ;
    countT cKids = 2 ;
    ZE( boolT , bQuit ) ;
{
stOpen( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portC ) )
ether( etherP ) ,
nodeC::nodeC( tinS& tinP , etherC& etherP , const countT idTypeP ) :

DONE( tmAcceptF )
}
    dec02AM( cKidsP ) ;

    }
        }
            DEL( psoa ) ;
            etThread.traceF( tinP , T("called  acceptF [psoa]:    ")+TF2((countT)psoa,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            sockListen.acceptF( tinP , psoa , idpHe , nnHe , bRefuse ) ; ___( psoa ) ;
            etThread.traceF( tinP , T("calling acceptF") ) ;
            nicNameC nnHe ;
            ZE( countT , idpHe ) ;

            ZE( socketC* , psoa ) ;
        {
        while( !ether && !POOP && !bQuitP )
        ZE( boolT , bRefuse ) ;

        sockListen.listenF( tinP ) ;

        }
            }
                }
                    break ;
                    etThread.traceF( tinP , T("bound aok [idPortBound]:    ")+TF2(idPortBound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                else
                }
                    etThread.traceF( tinP , T("could not bind [idPortTry]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                {
                if( POOP )
                idPortBound = sockListen.bindF( tinP , idpTry , nicNameC() , 1 , 0 ) ;
            {
            for( countT idpTry = ifcIDpORT_nodeC ; idpTry < ifcIDpORT_nodeC + 0x10 ; idpTry ++ )

            sockListen.etherF( tinP , *tinP.pEtScratch ) ;
            SCOOPS
        {
        IFsCRATCH
        ZE( countT , idPortBound ) ;

        socketC sockListen( tinP , etThread , TAG( TAGiDnULL ) ) ;
    {

    stackC& stOpenP = *(stackC*)pTaskP->c4 ;
    countT& cKidsP  = *(countT*)pTaskP->c3 ;
    boolT&  bQuitP  =  *(boolT*)pTaskP->c2 ;
    nodeC&  nodeP   =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmAcceptF )

DONE( tmRefreshListF )
}
    dec02AM( cKidsP ) ;

    }
        }
            }
                ++ s ; ether.osSleepF( tinP , TOCK ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                stOpenP.ungrabF( tinP ) ;
                stOpenP.purgeF( tinP ) ;
                stOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                while( !stToScan.third && ~hDown ) ;
                }
                    }
                        }
                            }
                                break ;
                                etThread.traceF( tinP , T("connected aok [nnTry,idPortTry]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T((nicNameC&)portHe) ) ;
                            {
                            else
                            }
                                etThread.traceF( tinP , T("could not connect [nnTry,idPortTry]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T((nicNameC&)portHe) ) ;
                                POOPRqUIET
                            {
                            if( POOP )
                            sockScan.connectF( tinP , idpTry , portHe , 1 , TOCK << 0 ) ; //U:: LONGER TIMEOUT FOR GLOBAL TREE

                            socketC sockScan( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                        {
                        for( countT idpTry = ifcIDpORT_nodeC ; idpTry < ifcIDpORT_nodeC + /*U::0x10*/1 ; idpTry ++ )

                        SCOOPS
                    {
                    IFsCRATCH

                    etThread.traceF( tinP , T("stToScan [idPlate,port,v4]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((nicNameC&)portHe)+T("    ")+T(portHe.nnv4F())+T(" ( ")+TF2((countT)portHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ; //U:: TO FIND A BUG
                    portC& portHe = *(portC*)&stToScan.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;

                }
                    //etThread.traceF( tinP , T("local nodes (end)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
                    }
                        }
                            //etThread.traceF( tinP , T("local node [off,nn,nnv4]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nl.pEntry[offi].nn)+tb4+T(nicNameC(nl.pEntry[offi].nnv4)) , flTRACE_null , ifcIDtRACEdIVERT_e ) ;

                            stToScan.sinkF( tinP , countTC() , (byteT*)&portHe , flSTACKsINK_UNIQUE , subtractPortsF ) ;

                            //FROM THAT POINT, THE PROCESSING IS JUST LIKE THE OLD CODE ; THE ROOT PUBLISHES THE OPEN LIST AND THE GOSSIP LIST
                            //RECIPE: SCAN PORTS FOR EACH LISTED HOST UNTIL I FIND AN ANSWER ; THEN REGISTER MYSELF WITH THAT ROOT
                            //FOR A LOCAL BANG RELAY, THE LIST ONLY GIVES ME A WAY TO DISCOVER ROOT
                            //U:: THE LIST ONLY GIVES ME POTENTIAL NODES ; stOpen CANNOT BE LOADED FROM THE LIST

                            //U::ISSUE: HOW TO GET idPort?  CONJ: WILL NEED TO SCAN A RANGE OF PORTS TO FIND BANG RELAY
                            portHe = nicNameC( nl.pEntry[ offi ].nnv4   ) ;
                            portHe =           nl.pEntry[ offi ].nn       ;
                            portC portHe ;
                        {
                        if( nl.pEntry[ offi ].ttl )
                    {
                    for( countT offi = 0 ; offi < nl.cEltsMax ; offi ++ )
                    //etThread.traceF( tinP , T("local nodes (begin)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
                {
                stackC stToScan( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_DOnOTsERIALIZE , sizeof( portC ) ) ;
            {
            while( !ether && !POOP && !bQuitP )
            nodeListS& nl = *(nodeListS*)(byteT*)napNodeList ;
            TN( tb4 , "    " ) ;
        {
        if( !bFail )

        THREADmODE3rESTORE
        }
            bFail = 1 ;
            etThread.traceF( tinP , T("watch must be running for this home; doing nothing") ) ;
            napNodeList.formattingIsDoneF( tinP ) ;
        {
        if( !napNodeList.bFormattedF() )
        napkinC napNodeList( tinP , TAG( TAGiDnULL ) , "ipdos.node.list" , 0 , TOCK , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_null , - 1 , ifcIDmEMORYsPACE_UNIVERSE ) ;
        THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
        ZE( boolT , bFail ) ;
    {

    stackC& stOpenP = *(stackC*)pTaskP->c4 ;
    countT& cKidsP  = *(countT*)pTaskP->c3 ;
    boolT&  bQuitP  =  *(boolT*)pTaskP->c2 ;
    nodeC&  nodeP   =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmRefreshListF )


}
    return sgn ;

    sCountT sgn = c1P && c2P ? *(portC*)c1P - *(portC*)c2P : 0 ;
    _IO_

    }
    {
    IFbEcAREFUL
{
/*1*/countT _export subtractPortsF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
/**/
*/
/*

;
}
    nodeC( tinS& tinP , etherC& etherP , const countT idTypeP = ifcIDtYPEnODE_LOCAL ) ;

    public :

    stackC  stOpen ;
    etherC& ether  ;
{
class nodeC

#define ifcIDtYPEnODE_GLOBAL         2 
#define ifcIDtYPEnODE_LOCAL          1


/*1*/WAKEhIDE( "doodle.nodeC.bang.relay" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

