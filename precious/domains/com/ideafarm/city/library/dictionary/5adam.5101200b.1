
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.loafIF( tinP ) ;

nodeC nodeMe( tinP , etThread ) ;

TODO

}
    }
        ++ s ; ether.osSleepF( tinP , TOCK >> 2 ) ;
    {
    while( cKids )
    bQuit = 1 ;

    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;
    {
    while( !etPrime )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    etherC& etPrime = etherC::etPrimeIF( tinP ) ;

    ether.osThreadF( TaRG1( tmAcceptF      ) , (countT)this , (countT)&bQuit , (countT)&cKids , (countT)&stOpen ) ;
    ether.osThreadF( TaRG1( tmRefreshListF ) , (countT)this , (countT)&bQuit , (countT)&cKids , (countT)&stOpen ) ;
    countT cKids = 2 ;
    ZE( boolT , bQuit ) ;
{
stOpen( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) )
ether( etherP ) ,
nodeC::nodeC( tinS& tinP , etherC& etherP , const countT idTypeP ) :

DONE( tmAcceptF )
}
    dec02AM( cKidsP ) ;

    }
        }
            DEL( psoa ) ;
            //etThread.traceF( tinP , T("called  acceptF [psoa]:    ")+TF2((countT)psoa,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            sockListen.acceptF( tinP , psoa , idpHe , nnHe , bRefuse ) ; ___( psoa ) ;
            //etThread.traceF( tinP , T("calling acceptF") ) ;
            nicNameC nnHe ;
            ZE( countT , idpHe ) ;

            ZE( socketC* , psoa ) ;
        {
        while( !ether && !POOP && !bQuitP )
        ZE( boolT , bRefuse ) ;

        sockListen.listenF( tinP ) ;

        }
            }
                }
                    break ;
                    etThread.traceF( tinP , T("bound aok [idPortBound]:    ")+TF2(idPortBound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                else
                }
                    etThread.traceF( tinP , T("could not bind [idPortTry]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                {
                if( POOP )
                idPortBound = sockListen.bindF( tinP , idpTry , nicNameC() , 1 , 0 ) ;
            {
            for( countT idpTry = ifcIDpORT_nodeC ; idpTry < ifcIDpORT_nodeC + 0x10 ; idpTry ++ )

            sockListen.etherF( tinP , *tinP.pEtScratch ) ;
            SCOOPS
        {
        IFsCRATCH
        ZE( countT , idPortBound ) ;

        socketC sockListen( tinP , etThread , TAG( TAGiDnULL ) ) ;
    {

    stackC& stOpenP = *(stackC*)pTaskP->c4 ;
    countT& cKidsP  = *(countT*)pTaskP->c3 ;
    boolT&  bQuitP  =  *(boolT*)pTaskP->c2 ;
    nodeC&  nodeP   =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmAcceptF )

DONE( tmRefreshListF )
}
    dec02AM( cKidsP ) ;

    }
        }
            }
                ++ s ; ether.osSleepF( tinP , TOCK ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                stOpenP.ungrabF( tinP ) ;
                }
                    while( !stOpenP.third && ~hDown ) ;
                    }
                        etThread.traceF( tinP , T("stOpenP [idPlate,port,v4]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(nnHe)+T("    ")+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ; //U:: TO FIND A BUG
                        nicNameC nnHe = ptHe ;
                        portTimeC& ptHe = *(portC*)&stOpenP.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    ZE( countT , idPlate ) ;
                {

                }
                    while( !stValidated.third && ~hDown ) ;
                    }
                        etThread.traceF( tinP , T("stValidated [idPlate,port,v4,time]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(nnHe)+T("    ")+T(portHe.nnv4F())+T(" ( ")+TF2((countT)portHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )    ")+T(timeHe) ) ; //U:: TO FIND A BUG

                        tFoo = T(timeHe) ;
                        TN( tFoo , "" ) ;

                        timeS timeHe = ptHe ;
                        nicNameC nnHe = portHe ;
                        stOpenP.sinkF( tinP , countTC() , (byteT*)&ptHe , flSTACKsINK_UNIQUE , subtractPortTimeF ) ;

                        ptHe.timeStampIfF( tinP , etThread ) ;
                        portTimeC ptHe = portHe ;

                        portC& portHe = *(portC*)&stValidated.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    ZE( countT , idPlate ) ;
                {
                if( stValidated )

                // AT THIS POINT ALL PLATES IN stOpenP ARE STILL GOOD, AND stValidated ONLY CONTAINS PLATES THAT ARE NOT IN stOpenP
                }
                    while( !stOpenP.third && ~hDown ) ;
                    }
                        }
                            stValidated.extractF( 0 , tinP ) ;
                            //etThread.traceF( tinP , T("extracting from stValidated (not newly open) [port,v4]:    ")/*+T((nicNameC)ptHe)+T("    ")+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )")*/ ) ; //U:: TO FIND A BUG
                        {
                        else                
                        }
                            stOpenP.extractF( 0 , tinP ) ;
                            etThread.traceF( tinP , T("extracting from stOpenP (no longer open) [port,v4]:    ")/*+T((nicNameC)ptHe)+T("    ")+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )")*/ ) ; //U:: TO FIND A BUG
                        {
                        if( !stValidated( (byteT*)&ptHe , subtractPortF ) )
                        portTimeC& ptHe = *(portC*)&stOpenP.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    ZE( countT , idPlate ) ;
                {
                if( stOpenP )
                stOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                //}
                //    stValidated.purgeF( tinP ) ; //U:: TO TEST
                //    etThread.traceF( tinP , T("U:: purging stValidated (to test)") ) ; //U:: TO FIND A BUG
                //{
                //if( stOpenP )

                }
                    while( !stToScan.third && ~hDown ) ;
                    }
                        }
                            }
                                }
                                    break ;
                                    //etThread.traceF( tinP , T("connected aok [nnTry,idPortTry]:    ")+T(nnHe)+tb4+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    nicNameC nnHe = portHe ;
                                    stValidated.sinkF( tinP , countTC() , (byteT*)&portHe , flSTACKsINK_UNIQUE , subtractPortF ) ;
                                    portHe = idpTry ;
                                {
                                else
                                }
                                    //etThread.traceF( tinP , T("could not connect [nnTry,idPortTry]:    ")+T(nnHe)+tb4+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    nicNameC nnHe = portHe ;
                                    POOPRqUIET
                                {
                                if( POOP )
                                sockScan.connectF( tinP , idpTry , portHe , 1 , TUCK >> 4 ) ; //U:: LONGER TIMEOUT FOR GLOBAL TREE

                                socketC sockScan( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                            {
                            for( countT idpTry = ifcIDpORT_nodeC ; idpTry < ifcIDpORT_nodeC + 4 ; idpTry ++ )

                            SCOOPS
                        {
                        IFsCRATCH

                        //etThread.traceF( tinP , T("stToScan [idPlate,port,v4]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((nicNameC&)portHe)+T("    ")+T(portHe.nnv4F()) ) ; //U:: TO FIND A BUG
                        portC& portHe = *(portC*)&stToScan.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    ZE( countT , idPlate ) ;
                {
                if( stToScan )
                stackC stValidated( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_DOnOTsERIALIZE , sizeof( portC ) ) ;

                }
                    //etThread.traceF( tinP , T("local nodes (end)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
                    }
                        }
                            //etThread.traceF( tinP , T("local node [off,nn,nnv4]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nl.pEntry[offi].nn)+tb4+T(nicNameC(nl.pEntry[offi].nnv4)) , flTRACE_null , ifcIDtRACEdIVERT_e ) ;

                            stToScan.sinkF( tinP , countTC() , (byteT*)&portHe , flSTACKsINK_UNIQUE , subtractPortF ) ;

                            //FROM THAT POINT, THE PROCESSING IS JUST LIKE THE OLD CODE ; THE ROOT PUBLISHES THE OPEN LIST AND THE GOSSIP LIST
                            //RECIPE: SCAN PORTS FOR EACH LISTED HOST UNTIL I FIND AN ANSWER ; THEN REGISTER MYSELF WITH THAT ROOT
                            //FOR A LOCAL BANG RELAY, THE LIST ONLY GIVES ME A WAY TO DISCOVER ROOT
                            //U:: THE LIST ONLY GIVES ME POTENTIAL NODES ; stOpen CANNOT BE LOADED FROM THE LIST

                            //U::ISSUE: HOW TO GET idPort?  CONJ: WILL NEED TO SCAN A RANGE OF PORTS TO FIND BANG RELAY
                            portHe = nicNameC( nl.pEntry[ offi ].nnv4   ) ;
                            portHe =           nl.pEntry[ offi ].nn       ;
                            portC portHe ;
                        {
                        if( nl.pEntry[ offi ].ttl )
                    {
                    for( countT offi = 0 ; offi < nl.cEltsMax ; offi ++ )
                    //etThread.traceF( tinP , T("local nodes (begin)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
                {
                stackC stToScan( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_DOnOTsERIALIZE , sizeof( portC ) ) ;
            {
            while( !ether && !POOP && !bQuitP )
            nodeListS& nl = *(nodeListS*)(byteT*)napNodeList ;
            TN( tb4 , "    " ) ;
        {
        if( !bFail )

        THREADmODE3rESTORE
        }
            bFail = 1 ;
            etThread.traceF( tinP , T("watch must be running for this home; doing nothing") ) ;
            napNodeList.formattingIsDoneF( tinP ) ;
        {
        if( !napNodeList.bFormattedF() )
        napkinC napNodeList( tinP , TAG( TAGiDnULL ) , "ipdos.node.list" , 0 , TOCK , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_null , - 1 , ifcIDmEMORYsPACE_UNIVERSE ) ;
        THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
        ZE( boolT , bFail ) ;
    {

    stackC& stOpenP = *(stackC*)pTaskP->c4 ;
    countT& cKidsP  = *(countT*)pTaskP->c3 ;
    boolT&  bQuitP  =  *(boolT*)pTaskP->c2 ;
    nodeC&  nodeP   =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmRefreshListF )


}
    return sgn ;

    sCountT sgn = c1P && c2P ? *(portTimeC*)c1P - *(portTimeC*)c2P : 0 ;
    _IO_

    }
    {
    IFbEcAREFUL
{
/*1*/countT _export subtractPortTimeF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
/**/
*/
/*

}
    return sgn ;

    sCountT sgn = c1P && c2P ? *(portC*)c1P - *(portC*)c2P : 0 ;
    _IO_

    }
    {
    IFbEcAREFUL
{
/*1*/countT _export subtractPortF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
/**/
*/
/*

;
}
    nodeC( tinS& tinP , etherC& etherP , const countT idTypeP = ifcIDtYPEnODE_LOCAL ) ;

    public :

    stackC  stOpen ;
    etherC& ether  ;
{
class nodeC

#define ifcIDtYPEnODE_GLOBAL         2 
#define ifcIDtYPEnODE_LOCAL          1


/*1*/WAKEhIDE( "doodle.nodeC.bang.relay" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

