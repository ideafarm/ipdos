
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.loafIF( tinP ) ;

nodeC nodeMe( tinP , etThread ) ;

TODO

DONE( tmAcceptF )
}
    dec02AM( cKidsP ) ;

    }
        }
            DEL( psoa ) ;
            //etThread.traceF( tinP , T("called  acceptF [psoa]:    ")+TF2((countT)psoa,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            sockListen.acceptF( tinP , psoa , idpHe , nnHe , bRefuse ) ; ___( psoa ) ;
            //etThread.traceF( tinP , T("calling acceptF") ) ;
            nicNameC nnHe ;
            ZE( countT , idpHe ) ;

            ZE( socketC* , psoa ) ;
        {
        while( !ether && !POOP && !bQuitP )
        ZE( boolT , bRefuse ) ;

        sockListen.listenF( tinP ) ;

        }
            }
                }
                    break ;
                    etThread.traceF( tinP , T("bound aok [idPortBound]:    ")+TF2(idPortBound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                else
                }
                    etThread.traceF( tinP , T("could not bind [idPortTry]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                {
                if( POOP )
                idPortBound = sockListen.bindF( tinP , idpTry , nicNameC() , 1 , 0 ) ;
            {
            for( countT idpTry = ifcIDpORT_nodeC ; idpTry < ifcIDpORT_nodeC + 0x10 ; idpTry ++ )

            sockListen.etherF( tinP , *tinP.pEtScratch ) ;
            SCOOPS
        {
        IFsCRATCH
        ZE( countT , idPortBound ) ;

        socketC sockListen( tinP , etThread , TAG( TAGiDnULL ) ) ;
    {

    const countT idModeP =           pTaskP->c5 ;
    stackC&      stOpenP = *(stackC*)pTaskP->c4 ;
    countT&      cKidsP  = *(countT*)pTaskP->c3 ;
    boolT&       bQuitP  =  *(boolT*)pTaskP->c2 ;
    nodeC&       nodeP   =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
TASK( tmAcceptF )

DONE( tmRefreshListF )
}
    dec02AM( cKidsP ) ;

    }
        DEL( pNapNodeList ) ;

        }
            ++ s ; ether.osSleepF( tinP , TOCK ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;

            stOpenP.ungrabF( tinP ) ;
            }
                while( !stOpenP.third && ~hDown ) ;
                }
                    etThread.traceF( tinP , TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(timeHe)+tb4+T(nnHe)+tb4+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ; //U:: TO FIND A BUG
                    const timeS& timeHe = ptHe ;
                    nicNameC nnHe = ptHe ;
                    portTimeC& ptHe = *(portTimeC*)&stOpenP.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;
            {

            }
                while( !stValidated.third && ~hDown ) ;
                }
                    etThread.traceF( tinP , T("stValidated [idPlate,port,v4,time]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(nnHe)+T("    ")+T(portHe.nnv4F())+T(" ( ")+TF2((countT)portHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )    ")+T(timeHe) ) ; //U:: TO FIND A BUG

                    tFoo = T(timeHe) ;
                    TN( tFoo , "" ) ;

                    timeS timeHe = ptHe ;
                    nicNameC nnHe = portHe ;
                    stOpenP.sinkF( tinP , countTC() , (byteT*)&ptHe , flSTACKsINK_UNIQUE , subtractPortTimeF ) ;

                    ptHe.timeStampIfF( tinP , etThread ) ;
                    portTimeC ptHe = portHe ;

                    portC& portHe = *(portC*)&stValidated.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;
            {
            if( stValidated )

            // AT THIS POINT ALL PLATES IN stOpenP ARE STILL GOOD, AND stValidated ONLY CONTAINS PLATES THAT ARE NOT IN stOpenP
            }
                while( !stOpenP.third && ~hDown ) ;
                }
                    }
                        stValidated.extractF( 0 , tinP ) ;
                        //etThread.traceF( tinP , T("extracting from stValidated (not newly open) [port,v4]:    ")/*+T((nicNameC)ptHe)+T("    ")+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )")*/ ) ; //U:: TO FIND A BUG
                    {
                    else                
                    }
                        stOpenP.extractF( 0 , tinP ) ;
                        etThread.traceF( tinP , T("extracting from stOpenP (no longer open) [port,v4]:    ")/*+T((nicNameC)ptHe)+T("    ")+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )")*/ ) ; //U:: TO FIND A BUG
                    {
                    if( !stValidated( (byteT*)&ptHe , subtractPortF ) )
                    portTimeC& ptHe = *(portC*)&stOpenP.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;
            {
            if( stOpenP )
            stOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;

            //}
            //    stValidated.purgeF( tinP ) ; //U:: TO TEST
            //    etThread.traceF( tinP , T("U:: purging stValidated (to test)") ) ; //U:: TO FIND A BUG
            //{
            //if( stOpenP )

            }
                while( !stToScan.third && ~hDown ) ;
                }
                    }
                        }
                            }
                                break ;
                                //etThread.traceF( tinP , T("connected aok [nnTry,idPortTry]:    ")+T(nnHe)+tb4+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                nicNameC nnHe = portHe ;
                                stValidated.sinkF( tinP , countTC() , (byteT*)&portHe , flSTACKsINK_UNIQUE , subtractPortF ) ;
                                portHe = idpTry ;
                            {
                            else
                            }
                                //etThread.traceF( tinP , T("could not connect [nnTry,idPortTry]:    ")+T(nnHe)+tb4+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                nicNameC nnHe = portHe ;
                                POOPRqUIET
                            {
                            if( POOP )
                            sockScan.connectF( tinP , idpTry , portHe , 1 , TUCK >> 4 ) ; //U:: LONGER TIMEOUT FOR GLOBAL TREE

                            socketC sockScan( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                        {
                        for( countT idpTry = ifcIDpORT_nodeC ; idpTry < ifcIDpORT_nodeC + 4 ; idpTry ++ )

                        SCOOPS
                    {
                    IFsCRATCH

                    //etThread.traceF( tinP , T("stToScan [idPlate,port,v4]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((nicNameC&)portHe)+T("    ")+T(portHe.nnv4F()) ) ; //U:: TO FIND A BUG
                    portC& portHe = *(portC*)&stToScan.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;
            {
            if( stToScan )
            stackC stValidated( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_DOnOTsERIALIZE , sizeof( portC ) ) ;

            }
                //etThread.traceF( tinP , T("local nodes (end)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
                }
                    }
                        //etThread.traceF( tinP , T("local node [off,nn,nnv4]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(pNodeList->pEntry[offi].nn)+tb4+T(nicNameC(pNodeList->pEntry[offi].nnv4)) , flTRACE_null , ifcIDtRACEdIVERT_e ) ;

                        stToScan.sinkF( tinP , countTC() , (byteT*)&portHe , flSTACKsINK_UNIQUE , subtractPortF ) ;

                        //FROM THAT POINT, THE PROCESSING IS JUST LIKE THE OLD CODE ; THE ROOT PUBLISHES THE OPEN LIST AND THE GOSSIP LIST
                        //RECIPE: SCAN PORTS FOR EACH LISTED HOST UNTIL I FIND AN ANSWER ; THEN REGISTER MYSELF WITH THAT ROOT
                        //FOR A LOCAL BANG RELAY, THE LIST ONLY GIVES ME A WAY TO DISCOVER ROOT
                        //U:: THE LIST ONLY GIVES ME POTENTIAL NODES ; stOpen CANNOT BE LOADED FROM THE LIST

                        //U::ISSUE: HOW TO GET idPort?  CONJ: WILL NEED TO SCAN A RANGE OF PORTS TO FIND BANG RELAY
                        portHe = nicNameC( pNodeList->pEntry[ offi ].nnv4   ) ;
                        portHe =           pNodeList->pEntry[ offi ].nn       ;
                        portC portHe ;
                    {
                    if( pNodeList->pEntry[ offi ].ttl )
                {
                for( countT offi = 0 ; offi < pNodeList->cEltsMax ; offi ++ )
                //etThread.traceF( tinP , T("local nodes (begin)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
            {
            stackC stToScan( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_DOnOTsERIALIZE , sizeof( portC ) ) ;
        {
        if( !bFail ) while( !ether && !POOP && !bQuitP )

        }
            //THE IDEA IS TO USE DISK TO REMEMBER PORTS SO THAT A NEW NODE CAN CONNECT ITSELF TO OTHER PORTS EVEN IF THE PORTS REGISTERED IN DNS ARE NOT RESPONSIVE
            //REGARDLESS OF MODE, THIS IS A LIST OF PORTS TO SCAN IN THE SEARCH FOR RESPONSIVE NODES
            //AT A MINIMUM, IT WILL CONTAIN spacenn.ideafarm.com ( spaceport.ideafarm.com )
            //U::ALLOCATE pNodeList AND POPULATE IT FROM DNS AND OTHER SOURCES
        {
        else
        }
            if( !bFail ) pNodeList = (nodeListS*)(byteT*)*pNapNodeList ;

            THREADmODE3rESTORE
            }
                bFail = 1 ;
                etThread.traceF( tinP , T("watch must be running for this home; doing nothing") ) ;
                pNapNodeList->formattingIsDoneF( tinP ) ;
            {
            if( !POOP && !pNapNodeList->bFormattedF() )
            __Z( pNapNodeList ) ;
            pNapNodeList = new( 0 , tinP , LF ) napkinC( tinP , TAG( TAGiDnULL ) , "ipdos.node.list.link.local.recent.advertisers" , 0 , TOCK , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_null , - 1 , ifcIDmEMORYsPACE_UNIVERSE ) ; ___( pNapNodeList ) ;
            THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
        {
        if( idModeP == ifcIDmODEnODE_LOCAL )
        ZE( boolT , bFail ) ;
        ZE( nodeListS* , pNodeList ) ;      // ZOMBIE IFF !!pNapNodeList
        ZE( napkinC*   , pNapNodeList ) ;
        TN( tb4 , "    " ) ;
    {

    const countT idModeP =           pTaskP->c5 ;
    stackC&      stOpenP = *(stackC*)pTaskP->c4 ;
    countT&      cKidsP  = *(countT*)pTaskP->c3 ;
    boolT&       bQuitP  =  *(boolT*)pTaskP->c2 ;
    nodeC&       nodeP   =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
TASK( tmRefreshListF )


}
    return sgn ;

    sCountT sgn = c1P && c2P ? *(portTimeC*)c1P - *(portTimeC*)c2P : 0 ;
    _IO_

    }
    {
    IFbEcAREFUL
{
/*1*/countT _export subtractPortTimeF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
/**/
*/
/*

}
    return sgn ;

    sCountT sgn = c1P && c2P ? *(portC*)c1P - *(portC*)c2P : 0 ;
    _IO_

    }
    {
    IFbEcAREFUL
{
/*1*/countT _export subtractPortF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
/**/
*/
/*

}
    }
        ++ s ; ether.osSleepF( tinP , TOCK >> 2 ) ;
    {
    while( cKids )
    bQuit = 1 ;

    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;
    {
    while( !etPrime )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    etherC& etPrime = etherC::etPrimeIF( tinP ) ;

    ether.osThreadF( TaRG1( tmAcceptF      ) , (countT)this , (countT)&bQuit , (countT)&cKids , (countT)&stOpen , idMode ) ;
    ether.osThreadF( TaRG1( tmRefreshListF ) , (countT)this , (countT)&bQuit , (countT)&cKids , (countT)&stOpen , idMode ) ;
    countT cKids = 2 ;
    ZE( boolT , bQuit ) ;
{
stOpen( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) )
idMode( idModeP ) ,
ether( etherP ) ,
nodeC::nodeC( tinS& tinP , etherC& etherP , const countT idModeP ) :

;
}
    nodeC( tinS& tinP , etherC& etherP , const countT idModeP = ifcIDmODEnODE_LOCAL ) ;

    public :

    stackC       stOpen ;
    const countT idMode ;
    etherC&      ether  ;
{
class nodeC

TASK0PROTO( tmRefreshListF ) ;
TASK0PROTO( tmAcceptF ) ;

#define ifcIDmODEnODE_GLOBAL         2 
#define ifcIDmODEnODE_LOCAL          1


/*1*/WAKEhIDE( "doodle.nodeC.bang.relay" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

