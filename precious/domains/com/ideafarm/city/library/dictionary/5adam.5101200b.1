
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.loafIF( tinP ) ;

//G:nodeC nodeMe( tinP , etThread , ifcIDmODEnODE_INTRApROCESS ) ;
//G:nodeC nodeMe( tinP , etThread ) ;

while( cDo -- ) etThread.osThreadF( TaRG1tINYsTACK( tmNodeF ) ) ;
countT cDo = 0x30 ;
//G:countT cDo = 0x20 ;
//G:countT cDo = 0x10 ;
//B:countT cDo = TUCK >> 3 ;
//B:countT cDo = TUCK >> 1 ;
//G:countT cDo = 8 ;

TODO

DONE( tmNodeF )
nodeC nodeMe( tinP , etThread , ifcIDmODEnODE_INTRApROCESS ) ;
TASK( tmNodeF )

DONE( tmAcceptF )
}
    dec02AM( cKidsP ) ;

    }
        }
            stAcceptedP << (countT)psoa ;

            //etThread.traceF( tinP , T("called  acceptF [psoa]:    ")+TF2((countT)psoa,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            sockListen.acceptF( tinP , psoa , idpHe , nnHe , bRefuse ) ; ___( psoa ) ;
            //etThread.traceF( tinP , T("calling acceptF") ) ;
            nicNameC nnHe ;
            ZE( countT , idpHe ) ;

            ZE( socketC* , psoa ) ;
        {
        while( !ether && !POOP && !bQuitP )
        ZE( boolT , bRefuse ) ;

        sockListen.listenF( tinP ) ;

        etThread.osThreadF( TaRG1tINYsTACK( tmRefreshListF ) , (countT)&nodeP , (countT)&bQuitP , (countT)&cKidsP , (countT)&stOpenP , idModeP , (countT)&portMeP ) ; // portMeP IS NOW COMPLETELY KNOWN
        inc02AM( cKidsP ) ;

        }
            }
                }
                    break ;
                    portMeP = idPortBound ;
                    etThread.traceF( tinP , T("bound aok [idPortBound]:    ")+TF2(idPortBound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                else
                }
                    etThread.traceF( tinP , T("could not bind [idPortTry]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                {
                if( POOP )
                idPortBound = sockListen.bindF( tinP , idpTry , nicNameC() , 1 , 0 ) ;
            {
            for( countT idpTry = idpMin ; idpTry <= idpMax ; idpTry ++ )
            countT idpMax = idModeP == ifcIDmODEnODE_INTRApROCESS ? - 1 : ifcIDpORT_nodeC + 0xf ;
            countT idpMin =                                               ifcIDpORT_nodeC ;

            sockListen.etherF( tinP , *tinP.pEtScratch ) ;
            SCOOPS
        {
        IFsCRATCH
        ZE( countT , idPortBound ) ;
        TN( tb4 , "    " ) ;

        socketC sockListen( tinP , etThread , TAG( TAGiDnULL ) ) ;
    {

    portC&       portMeP     =  *(portC*)pTaskP->c7 ;
    const countT idModeP     =           pTaskP->c6 ;
    stackC&      stOpenP     = *(stackC*)pTaskP->c5 ;
    stackC&      stAcceptedP = *(stackC*)pTaskP->c4 ;
    countT&      cKidsP      = *(countT*)pTaskP->c3 ;
    boolT&       bQuitP      =  *(boolT*)pTaskP->c2 ;
    nodeC&       nodeP       =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TASK( tmAcceptF )

DONE( tmObeyF )
}
    dec02AM( cKidsP ) ;

    }
        }
            }
                DEL( psoa ) ;

                }
                    }
                        }
                            etThread.traceF( tinP , T("coding error 85") ) ;
                            POOPRqUIET
                        {
                        if( POOP )

                        }
                            }
                                }
                                    }
                                        break ;

                                        }
                                            etThread.traceF( tinP , T("unexpected command [idCmd]:    ")+TF2(idCmd,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            bBye = 1 ;
                                            POOPRqUIET
                                        {
                                        if( POOP )

                                        __1
                                        __( idCmd ) ;
                                    {
                                    default :
                                    }
                                        break ;

                                        }
                                            etThread.traceF( tinP , T("could not write ifcIDcMDnODE_PINGrEPLY") ) ;
                                            POOPRqUIET
                                        {
                                        if( POOP )

                                        psoa->writeF( tinP , soulo ) ;

                                        soulo << finger ;   // idCmd
                                        finger = ifcIDcMDnODE_PINGrEPLY ;

                                        soulo << finger ;   // idFormat
                                        finger = 1 ;

                                        soulo << finger ;
                                        putNegAM( finger , FINGERnEG_nodeC ) ;
                                        ZE( countT , finger ) ;

                                        soulC soulo( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                    {
                                    case ifcIDcMDnODE_PING :
                                    }
                                        break ;
                                        bBye = 1 ;
                                    {
                                    case ifcIDcMDnODE_BYE :
                                {
                                switch( idCmd )

                                souli >> idCmd ;
                                ZE( countT , idCmd ) ;
                            {
                            else
                            }
                                etThread.traceF( tinP , T("incoming soul contained unexpected fingerprint or idFormat") ) ;
                                bBye = 1 ;
                                POOPRqUIET
                            {
                            if( POOP )

                            __( finger - 1 ) ;
                            souli >> finger ;
                            finger = 0 ;

                            __( getNegAM( finger ) - FINGERnEG_nodeC ) ;
                            souli >> finger ;
                            ZE( countT , finger ) ;
                        {
                        else
                        }
                            etThread.traceF( tinP , T("could not read soul") ) ;
                            bBye = 1 ;
                            POOPRqUIET
                        {
                        if( POOP )

                        psoa->readF( tinP , souli ) ;
                        soulC souli( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;

                        psoa->etherF( tinP , *tinP.pEtScratch ) ;

                        SCOOPS
                    {
                    IFsCRATCH
                {
                while( !bQuitP && !bBye )
                ZE( boolT , bBye ) ;

                socketC* psoa = (socketC*)pc_psoa[ offi ] ;

                //etThread.traceF( tinP , T("serving client ")+TF2(offi+1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" of ")+TF2(cToDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            for( countT offi = 0 ; offi < cToDo ; offi ++ )

            stAcceptedP.ungrabF( tinP ) ;

            }
                while( stAcceptedP ) stAcceptedP >> pc_psoa[ offo ++ ] ;
                ZE( countT , offo ) ;

                etThread.memSetF( tinP , (byteT*)pc_psoa , cToDo * sizeof( countT ) ) ;
            {
            if( !POOP )

            __Z( pc_psoa ) ;
            etThread.newF( tinP , LF , pc_psoa , cToDo ) ; ___( pc_psoa ) ;
            ZE( countT* , pc_psoa ) ;
            countT cToDo = stAcceptedP ;
        {
        else
        }
            stAcceptedP.ungrabF( tinP ) ;
        {
        if( !stAcceptedP )
        stAcceptedP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        stAcceptedP.waitF( tinP ) ;
    {
    while( !ether && !POOP )
    TN( tb4 , "    " ) ;

    portC&       portMeP     =  *(portC*)pTaskP->c7 ;
    const countT idModeP     =           pTaskP->c6 ;
    stackC&      stOpenP     = *(stackC*)pTaskP->c5 ;
    stackC&      stAcceptedP = *(stackC*)pTaskP->c4 ;
    countT&      cKidsP      = *(countT*)pTaskP->c3 ;
    boolT&       bQuitP      =  *(boolT*)pTaskP->c2 ;
    nodeC&       nodeP       =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TASK( tmObeyF )

DONE( tmRefreshListF )
}
    dec02AM( cKidsP ) ;

    }
        DEL( pNapNodeList ) ;

        }
            }
                break ;
                __1
                __( idModeP ) ;
            {
            default :
            }
                break ;
            {
            case ifcIDmODEnODE_GLOBAL :
            }
                break ;
            {
            case ifcIDmODEnODE_LOCAL :
            }
                break ;

                }
                    }
                        break ;

                        nl.pEntry[ offi ].ttl  = 0 ;
                        nl.pEntry[ offi ].port = portC() ;
                        dec02AM( nl.cElts ) ;

                        etThread.traceF( tinP , T("removing myself [nn,nnv4]:    ")+T(nn)+T("    ")+T(nnv4) ) ;
                        nicNameC nnv4 = nl.pEntry[ offi ].port.nnv4F() ;
                        nicNameC nn   = nl.pEntry[ offi ].port ;
                    {
                    if( nl.pEntry[ offi ].port == portMeP )
                {
                for( countT offi = 0 ; offi < nl.cEltsMax ; offi ++ )
                nodeListS& nl = *pNodeList ;
            {
            case ifcIDmODEnODE_INTRApROCESS :
        {
        switch( idModeP )

        }
            ++ s ; ether.osSleepF( tinP , TOCK ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;

            stOpenP.ungrabF( tinP ) ;
            }
                while( !stOpenP.third && ~hDown ) ;
                }
                    etThread.traceF( tinP , TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(timeHe)+tb4+T(nnHe)+tb4+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(bMe?" )  (me)":" )") ) ; //U:: TO FIND A BUG
                    const timeS& timeHe = ptHe ;
                    nicNameC nnHe = ptHe ;

                    boolT bMe = (portC&)ptHe == portMeP ;

                    portTimeC& ptHe = *(portTimeC*)&stOpenP.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;
            {
            if( stOpenP )

            }
                while( !stValidated.third && ~hDown ) ;
                }
                    etThread.traceF( tinP , T("stValidated [idPlate,port,v4,time]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(nnHe)+T("    ")+T(portHe.nnv4F())+T(" ( ")+TF2((countT)portHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )    ")+T(timeHe) ) ; //U:: TO FIND A BUG

                    tFoo = T(timeHe) ;
                    TN( tFoo , "" ) ;

                    timeS timeHe = ptHe ;
                    nicNameC nnHe = portHe ;
                    stOpenP.sinkF( tinP , countTC() , (byteT*)&ptHe , flSTACKsINK_UNIQUE , subtractPortTimeF ) ;

                    ptHe.timeStampIfF( tinP , etThread ) ;
                    portTimeC ptHe = portHe ;

                    portC& portHe = *(portC*)&stValidated.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;
            {
            if( stValidated )

            // AT THIS POINT ALL PLATES IN stOpenP ARE STILL GOOD, AND stValidated ONLY CONTAINS PLATES THAT ARE NOT IN stOpenP
            }
                while( !stOpenP.third && ~hDown ) ;
                }
                    }
                        stValidated.extractF( 0 , tinP ) ;
                        //etThread.traceF( tinP , T("extracting from stValidated (not newly open) [port,v4]:    ")/*+T((nicNameC)ptHe)+T("    ")+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )")*/ ) ; //U:: TO FIND A BUG
                    {
                    else                
                    }
                        stOpenP.extractF( 0 , tinP ) ;
                        etThread.traceF( tinP , T("extracting from stOpenP (no longer open) [port,v4]:    ")/*+T((nicNameC)ptHe)+T("    ")+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )")*/ ) ; //U:: TO FIND A BUG
                    {
                    if( !stValidated( (byteT*)&ptHe , subtractPortF ) )
                    portTimeC& ptHe = *(portC*)&stOpenP.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;
            {
            if( stOpenP )
            stOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;

            //}
            //    stValidated.purgeF( tinP ) ; //U:: TO TEST
            //    etThread.traceF( tinP , T("U:: purging stValidated (to test)") ) ; //U:: TO FIND A BUG
            //{
            //if( stOpenP )

            }
                while( !stToScan.third && ~hDown ) ;
                }
                    }
                        }
                            }
                                //etThread.traceF( tinP , T("connected aok [nnTry,idPortTry]:    ")+T(nnHe)+tb4+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                nicNameC nnHe = portHe ;
                                stValidated.sinkF( tinP , countTC() , (byteT*)&portHe , flSTACKsINK_UNIQUE , subtractPortF ) ;
                                portHe = idpTry ;
                            {
                            if( !bFail )
                        
                            }
                                }
                                    }
                                        }
                                            sockScan.writeF( tinP , soulo ) ;

                                            soulo << finger ;   // idCmd
                                            finger = ifcIDcMDnODE_BYE ;
                                            soulo << finger ;   // idFormat
                                            finger = 1 ;
                                            soulo << finger ;
                                            putNegAM( finger , FINGERnEG_nodeC ) ;
                                            ZE( countT , finger ) ;
                                            soulC soulo( tinP , TAG( TAGiDnULL ) ) ;
                                        {
                                        else
                                        }
                                            etThread.traceF( tinP , T("unexpected contents in incoming soul") ) ;
                                            bFail = 1 ;
                                            POOPRqUIET
                                        {
                                        if( POOP )

                                        __( finger - ifcIDcMDnODE_PINGrEPLY ) ;
                                        souli >> finger ;   //idCmd
                                        finger = 0 ;

                                        __( finger - 1 ) ;
                                        souli >> finger ;   //idFormat
                                        finger = 0 ;

                                        __( getNegAM( finger ) - FINGERnEG_nodeC ) ;
                                        souli >> finger ;
                                        ZE( countT , finger ) ;
                                    {
                                    else
                                    }
                                        etThread.traceF( tinP , T("could not read") ) ;
                                        bFail = 1 ;
                                        POOPRqUIET
                                    {
                                    if( POOP )

                                    sockScan.readF( tinP , souli ) ;
                                    soulC souli( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                {
                                else
                                }
                                    etThread.traceF( tinP , T("could not write") ) ;
                                    bFail = 1 ;
                                    POOPRqUIET
                                {
                                if( POOP )

                                sockScan.writeF( tinP , soulo ) ;
                                //etThread.traceF( tinP , T("writing ifcIDcMDnODE_PING") ) ;
                                SCOOPS
                            {
                            IFsCRATCH

                            soulo << finger ;   // idCmd
                            finger = ifcIDcMDnODE_PING ;
                            soulo << finger ;   // idFormat
                            finger = 1 ;
                            soulo << finger ;
                            putNegAM( finger , FINGERnEG_nodeC ) ;
                            ZE( countT , finger ) ;
                            soulC soulo( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( !bFail )

                        }
                            }
                                //etThread.traceF( tinP , T("could not connect [nnTry,idPortTry]:    ")+T(nnHe)+tb4+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                nicNameC nnHe = portHe ;
                                bFail = 1 ;
                                POOPRqUIET
                            {
                            if( POOP )

                            sockScan.connectF( tinP , idpTry , portHe , 1 , TUCK >> 4 ) ; //U:: LONGER TIMEOUT FOR GLOBAL TREE
                            sockScan.etherF( tinP , *tinP.pEtScratch ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        ZE( boolT , bFail ) ;

                        socketC sockScan( tinP , etThread , TAG( TAGiDnULL ) ) ;
                    {
                    for( countT idpTry = idpMin ; idpTry <= idpMax ; idpTry ++ )
                    countT idpMax = (countT)portHe ? (countT)portHe : ifcIDpORT_nodeC + 3 ;
                    countT idpMin = (countT)portHe ? (countT)portHe : ifcIDpORT_nodeC     ;

                    //etThread.traceF( tinP , T("stToScan [idPlate,port,v4]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((nicNameC&)portHe)+T("    ")+T(portHe.nnv4F()) ) ; //U:: TO FIND A BUG
                    portC& portHe = *(portC*)&stToScan.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;
            {
            if( stToScan )
            stackC stValidated( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_DOnOTsERIALIZE , sizeof( portC ) ) ;

            }
                //etThread.traceF( tinP , T("local nodes (end)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
                }
                    }
                        //etThread.traceF( tinP , T("local node [off,nn,nnv4]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(pNodeList->pEntry[offi].nn)+tb4+T(nicNameC(pNodeList->pEntry[offi].nnv4)) , flTRACE_null , ifcIDtRACEdIVERT_e ) ;

                        stToScan.sinkF( tinP , countTC() , (byteT*)&portHe , flSTACKsINK_UNIQUE , subtractPortF ) ;

                        //FROM THAT POINT, THE PROCESSING IS JUST LIKE THE OLD CODE ; THE ROOT PUBLISHES THE OPEN LIST AND THE GOSSIP LIST
                        //RECIPE: SCAN PORTS FOR EACH LISTED HOST UNTIL I FIND AN ANSWER ; THEN REGISTER MYSELF WITH THAT ROOT
                        //FOR A LOCAL BANG RELAY, THE LIST ONLY GIVES ME A WAY TO DISCOVER ROOT
                        //U:: THE LIST ONLY GIVES ME POTENTIAL NODES ; stOpen CANNOT BE LOADED FROM THE LIST

                        //portHe = nicNameC( pNodeList->pEntry[ offi ].nnv4   ) ;
                        //portHe =           pNodeList->pEntry[ offi ].nn       ;
                        portHe = pNodeList->pEntry[ offi ].port ;
                        portC portHe ;
                    {
                    if( pNodeList->pEntry[ offi ].ttl )
                {
                for( countT offi = 0 ; offi < pNodeList->cEltsMax ; offi ++ )
                //etThread.traceF( tinP , T("local nodes (begin)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
            {
            stackC stToScan( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_DOnOTsERIALIZE , sizeof( portC ) ) ;
        {
        if( !bFail ) while( !ether && !POOP && !bQuitP )

        }
            }
                break ;
                __1
                __( idModeP ) ;
            {
            default :
            }
                break ;

                //THE IDEA IS TO USE DISK TO REMEMBER PORTS SO THAT A NEW NODE CAN CONNECT ITSELF TO OTHER PORTS EVEN IF THE PORTS REGISTERED IN DNS ARE NOT RESPONSIVE
                //REGARDLESS OF MODE, THIS IS A LIST OF PORTS TO SCAN IN THE SEARCH FOR RESPONSIVE NODES
                //AT A MINIMUM, IT WILL CONTAIN spacenn.ideafarm.com ( spaceport.ideafarm.com )
                //U::ALLOCATE pNodeList AND POPULATE IT FROM DNS AND OTHER SOURCES
            {
            case ifcIDmODEnODE_GLOBAL :
            }
                break ;

                if( !bFail ) pNodeList = (nodeListS*)(byteT*)*pNapNodeList ;

                THREADmODE3rESTORE
                }
                    bFail = 1 ;
                    etThread.traceF( tinP , T("watch must be running for this home; doing nothing") ) ;
                    pNapNodeList->formattingIsDoneF( tinP ) ;
                {
                if( !POOP && !pNapNodeList->bFormattedF() )
                __Z( pNapNodeList ) ;
                pNapNodeList = new( 0 , tinP , LF ) napkinC( tinP , TAG( TAGiDnULL ) , "ipdos.node.list.link.local.recent.advertisers" , 0 , TOCK , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_null , - 1 , ifcIDmEMORYsPACE_UNIVERSE ) ; ___( pNapNodeList ) ;
                THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
            {
            case ifcIDmODEnODE_LOCAL :
            }
                break ;

                }
                    }
                        break ;
                        inc02AM( nl.cElts ) ;
                        etThread.traceF( tinP , T("adding myself [nn,nnv4]:    ")+T(nn)+T("    ")+T(nnv4) ) ;
                        nicNameC nnv4 = nl.pEntry[ offi ].port.nnv4F() ;
                        nicNameC nn   = nl.pEntry[ offi ].port ;

                        nl.pEntry[ offi ].port = portMeP ;
                    {
                    if( !setIfZeAM( nl.pEntry[ offi ].ttl , 1 ) )
                {
                for( countT offi = 0 ; offi < nl.cEltsMax ; offi ++ )
                nodeListS& nl = *pNodeList ;

                pNodeList = (nodeListS*)(byteT*)*pNapNodeList ;

                THREADmODE3rESTORE
                }
                    pNapNodeList->formattingIsDoneF( tinP ) ;

                    nl.cEltsMax = ( cbData - sizeof( nodeListS ) + sizeof( nodeEntryS ) ) / sizeof( nodeEntryS ) ;
                    nodeListS& nl = *(nodeListS*)pbData ;

                    etThread.memSetF( tinP , pbData , cbData ) ;
                    countT cbData = *pNapNodeList ;
                    byteT* pbData = *pNapNodeList ;
                {
                if( !POOP && !pNapNodeList->bFormattedF() )
                __Z( pNapNodeList ) ;
                pNapNodeList = new( 0 , tinP , LF ) napkinC( tinP , TAG( TAGiDnULL ) , "ipdos.node.list.intraprocess" , 0 , TOCK , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_null , - 1 , ifcIDmEMORYsPACE_UNIVERSE ) ; ___( pNapNodeList ) ;
                THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
            {
            case ifcIDmODEnODE_INTRApROCESS :
        {
        switch( idModeP )
        ZE( boolT , bFail ) ;
        ZE( nodeListS* , pNodeList ) ;      // ZOMBIE IFF !!pNapNodeList
        ZE( napkinC*   , pNapNodeList ) ;
        TN( tb4 , "    " ) ;
    {

    portC&       portMeP =  *(portC*)pTaskP->c6 ;
    const countT idModeP =           pTaskP->c5 ;
    stackC&      stOpenP = *(stackC*)pTaskP->c4 ;
    countT&      cKidsP  = *(countT*)pTaskP->c3 ;
    boolT&       bQuitP  =  *(boolT*)pTaskP->c2 ;
    nodeC&       nodeP   =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmRefreshListF )


}
    return sgn ;

    sCountT sgn = c1P && c2P ? *(portTimeC*)c1P - *(portTimeC*)c2P : 0 ;
    _IO_

    }
    {
    IFbEcAREFUL
{
/*1*/countT _export subtractPortTimeF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
/**/
*/
/*

}
    return sgn ;

    sCountT sgn = c1P && c2P ? *(portC*)c1P - *(portC*)c2P : 0 ;
    _IO_

    }
    {
    IFbEcAREFUL
{
/*1*/countT _export subtractPortF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
/**/
*/
/*

}
    }
        ++ s ; ether.osSleepF( tinP , TOCK >> 2 ) ;
    {
    while( cKids )
    bQuit = 1 ;

    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;
    {
    while( !etPrime )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    etherC& etPrime = etherC::etPrimeIF( tinP ) ;

    ether.osThreadF( TaRG1tINYsTACK( tmObeyF        ) , (countT)this , (countT)&bQuit , (countT)&cKids , (countT)&stAccepted , (countT)&stOpen , idMode , (countT)&portMe ) ;
    ether.osThreadF( TaRG1tINYsTACK( tmAcceptF      ) , (countT)this , (countT)&bQuit , (countT)&cKids , (countT)&stAccepted , (countT)&stOpen , idMode , (countT)&portMe ) ;
    countT cKids = 2 ;
    ZE( boolT , bQuit ) ;

    }
        portMe = neMe.port.nnv4F() ;
        portMe = neMe.port ;

        }
            neMe.port = nnWo ;

            if( bIgnore ) continue ;

            boolT bIgnore = bv4 ? ~nnv4 : ~nn ;
            nicNameC nnv4 = neMe.port.nnv4F() ;
            nicNameC nn   = neMe.port ;

            boolT bv4     = nnWo.isIPv4F() ;

            //ether.traceF( tinP , T("[nnWo]:    ")+T(nnWo)+T(nnWo.isIPv4F()?"    IPv4":"    IPv6") ) ;
            soulNicName >> nnWo ;
            nicNameC nnWo ;

            }
                if( ~nn && ~nnv4 ) break ;
                nicNameC nnv4 = neMe.port.nnv4F() ;
                nicNameC nn   = neMe.port ;
            {
        {
        while( soulNicName )
        nodeEntryS neMe ;

        }
            ether.delF( tinP , pnnMe ) ;
            }
                else ether.traceF( tinP , T("nodeC / NON-routable    :    ")+T(pnnMe[offi]) ) ;
                }
                    soulNicName << pnnMe[ offi ] ;
                    ether.traceF( tinP ,  T("nodeC / routable unicast:    ")+T(pnnMe[offi]) ) ;
                {
                if( pnnMe[ offi ].isRoutableUnicastF() )
            {
            for( countT offi = 0 ; offi < cnnMe ; offi ++ )
            socketC::nicNameIF( tinP , ether , pnnMe , cnnMe , 0 ) ; ___( pnnMe ) ;
            ZE( countT    , cnnMe ) ;
            ZE( nicNameC* , pnnMe ) ;
        {
        soulC soulNicName( tinP , TAG( TAGiDnULL ) ) ;
    {
{
stOpen(     tinP , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) )
stAccepted( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_countT ) ,
idMode( idModeP ) ,
ether( etherP ) ,
nodeC::nodeC( tinS& tinP , etherC& etherP , const countT idModeP ) :

;
}
    nodeC( tinS& tinP , etherC& etherP , const countT idModeP = ifcIDmODEnODE_LOCAL ) ;

    public :

    portC        portMe     ;
    stackC       stOpen     ;
    stackC       stAccepted ;
    const countT idMode     ;
    etherC&      ether      ;
{
class nodeC

TASK0PROTO( tmRefreshListF ) ;
TASK0PROTO( tmObeyF ) ;
TASK0PROTO( tmAcceptF ) ;

#define ifcIDcMDnODE_PINGrEPLY       3
#define ifcIDcMDnODE_PING            2
#define ifcIDcMDnODE_BYE             1

#define ifcIDmODEnODE_GLOBAL         3 
#define ifcIDmODEnODE_LOCAL          2
#define ifcIDmODEnODE_INTRApROCESS   1


/*1*/WAKEhIDE( "doodle.nodeC.bang.relay" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
