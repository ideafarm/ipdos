
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

while( ~hFind && !ether && !POOP ) ;
}
    DEL( pInfo ) ;
    }
        etThread.delF( tinP , psttShort ) ;
        }
            fileC( tinP , (strokeS*)( tFolderTo+T(psttShort) ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_DOnOTrEGISTER /*flOPENdETAILS_null*/ , ifcOPENhOW_nCeR ) ;
        {

        if( !( idFile % TUCK ) ) etThread.traceF( tinP , psttShort ) ;

        etThread.delF( tinP , psttPath ) ;
        ___( psttShort ) ;
        ___( psttPath ) ;
        etThread.strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
        ZE( strokeS* , psttShort ) ;
        ZE( strokeS* , psttPath ) ;
    {
    if( pInfo && pInfo->psttIfoName && pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam != '/' )
    etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tLike ) ; ___( pInfo ) ;
    ZE( infoFileS* , pInfo ) ;

    idFile ++ ;
{
do
handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
ZE( countT , idFile ) ;
TN( tSlash , "/" ) ;
TN( tFolderTo , "///d/tmp/x/ghost/" ) ;
TN( tLike , "///d/ideafarm.home.101/IdeaFarm (tm)/SYSTEM/Drop Files Here To Archive/*" ) ;

TODO

// OBSOLETED BY 6ef

/*1*/WAKEsHOWtEXT( "tool.make.ghost.copy.of.archive" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

