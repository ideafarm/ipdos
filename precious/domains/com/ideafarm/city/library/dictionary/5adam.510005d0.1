
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

THREADmODE2rESTORE
}
    }
        }
            }
                else       etThread.osThreadF( TaRG1( tmcSerialNumberServeF ) , (countT)pso , (countT)&puseList ) ;
                if( POOP ) { DEL( pso ) ; }
                __( bRefuse ) ;
                socket.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ; ___( pso ) ;
                ZE( boolT , bRefuse ) ;
                ZE( countT , idPortPeer ) ;
                nicNameC nnPeer ;
                ZE( socketC* , pso ) ;
            {
            while( !ether && !POOP )
    
            //etThread.osThreadF( TaRG1( tmTestF ) ) ;
        
            socket.listenF( tinP ) ;
            homeS::homeIF().idPortSerialNumberDispenser = socket.bindF( tinP ) ;
            socketC socket( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
        {
        while( !ether )
    {
    IFsCRATCH
    
    /*PROD*/ ether.osThreadAdamF( tinP , ifcIDaDAM_LISTsERVEReMAILiDaCCOUNT ) ; //PRODUCTION
    
    puseC puseWork( tinP , ifcIDpOOL_ADAMtEMP ) ;
    puseC puseList( tinP , "list.serialname.cref" , flPOOLc_null , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) ) ;
{
THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

TODO

DONE( tmcSerialNumberServeF )

}
    }
        DEL( psoP ) ;
        if( POOP ) POOPR

        }
            psoP->writeF( tinP , sOut ) ;
            }
                }
                    break ;
                    __1 ;
                    __( idCmd ) ;
                {
                default :
                }
                    break ;

                    sOut << idSerial ;
                    }
                        PUSE( tinP , *(byteT**)&pczList ) ;
                        }
                            THREADmODE2rESTORE
                            }
                                idSerial = 1 + incv02AM( C F( listC::countIF( tinP , hRec , "idSerial" ) ) ) ;
                                listC::openIF( tinP , hRec , pczList ) ;
                                handleC hRec( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                            
                                grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;

                                puseC puseList( puseListP ) ;
                            {
                            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                            //CONoUTrAW( T(pczList)+T("\r\n") ) ;
                            etherC::strStretchIF( tinP , pczList , count8S( LISTnAME_ROOTaPPLICATION ) , pczName ) ;
                            pczList[ offo ] = 0 ;
                            for( countT offo = 0 ; offo < ccList ; offo ++ ) pczList[ offo ] = LISTnAME_PLACEhOLDER ;
                        {
                        if( pczList )
                        countT* pczList = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccList + 1 ) ) ; ___( pczList ) ;
                        const countT ccList = 1 + thirdC::c_strlenIF( tinP , pczName ) ;
                    {
                    if( pczName && *pczName )
                    ZE( countT , idSerial ) ;

                    sIn >> pczName ;
                    ZE( countT* , pczName ) ;
                {
                case ifcIDcMDsERIALnUMBERdISPENSER_DISPENSEnAMEcOUNTsTRING :
                }
                    break ;

                    sOut << idSerial ;
                    PUSE( tinP , *(byteT**)&psttName ) ;
                    }
                        PUSE( tinP , *(byteT**)&pczList ) ;
                        }
                            THREADmODE2rESTORE
                            }
                                idSerial = 1 + incv02AM( C F( listC::countIF( tinP , hRec , "idSerial" ) ) ) ;
                                listC::openIF( tinP , hRec , pczList ) ;
                                handleC hRec( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                            
                                grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;

                                puseC puseList( puseListP ) ;
                            {
                            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                            //CONoUTrAW( T(pczList)+T("\r\n") ) ;
                            etherC::strStretchIF( tinP , pczList , count8S( LISTnAME_ROOTaPPLICATION ) , T(psttName) ) ;
                            pczList[ offo ] = 0 ;
                            for( countT offo = 0 ; offo < ccList ; offo ++ ) pczList[ offo ] = LISTnAME_PLACEhOLDER ;
                        {
                        if( pczList )
                        countT* pczList = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccList + 1 ) ) ; ___( pczList ) ;
                        const countT ccList = 1 + psttName->idAdam ;
                    {
                    if( psttName && psttName->idAdam )
                    ZE( countT , idSerial ) ;

                    sIn >> psttName ; ___( psttName ) ;
                    ZE( strokeS* , psttName ) ;
                {
                case ifcIDcMDsERIALnUMBERdISPENSER_DISPENSEnAMEsTROKEsTRING :
            {
            switch( idCmd )

            sOut << (countT)1 ; //idFormat
            sOut << (countT)FINGERnEG_SERIALnUMBERdISPENSERrEPLY ;
            soulC sOut( tinP , TAG( TAGiDnULL ) ) ;

            sIn >> idCmd ;
            ZE( countT , idCmd ) ;

            __( idFormat - 1 ) ;
            sIn >> idFormat ;
            ZE( countT , idFormat ) ;

            __( finger - FINGERnEG_SERIALnUMBERdISPENSERcMD ) ;
            sIn >> finger ;
            ZE( countT , finger ) ;

            if( POOP ) break ;
            psoP->readF( tinP , sIn ) ;
            soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
        {
        while( !ether && !POOP )

        psoP->etherF( tinP , *tinP.pEtScratch ) ;
        SCOOPS
    {
    IFsCRATCH

    puseC&    puseListP =  *(puseC*)pTaskP->c2 ;
    socketC*  psoP      = (socketC*)pTaskP->c1 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmcSerialNumberServeF )

#endif

DONE( tmTestF )
}
    if( idPortP ) ;

    etherC::etherFireImpersonateMonitorIF( tinP ) ; //U::FOR TESTING

    CONoUTrAW( T("[idSerial,serial]: ")+TF3(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+tSerialName+T("\r\n") ) ;
    sIn >> idSerial ;
    ZE( countT , idSerial ) ;

    __( idFormat - 1 ) ;
    sIn >> idFormat ;
    ZE( countT , idFormat ) ;

    __( finger - FINGERnEG_SERIALnUMBERdISPENSERrEPLY ) ;
    sIn >> finger ;
    ZE( countT , finger ) ;

    sock.readF( tinP , sIn ) ;
    soulC sIn( tinP , TAG( TAGiDnULL ) ) ;

    sock.writeF( tinP , sOut ) ;

    sOut << (strokeS*)tSerialName ;
    sOut << (countT)ifcIDcMDsERIALnUMBERdISPENSER_DISPENSEnAMEsTROKEsTRING ;
    sOut << (countT)1 ;
    sOut << (countT)FINGERnEG_SERIALnUMBERdISPENSERcMD ;
    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;

    TN( tSerialName , "serial.number.idAccount" ) ;

    sock.connectF( tinP , homeS::homeIF().idPortSerialNumberDispenser ) ;
    socketC sock( tinP , etThread , TAG( TAGiDnULL ) ) ;

    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 )
TASK( tmTestF )

#if defined( NEVERdEFINED )

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_DOMAINsERIALnUMBERdISPENSER" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

