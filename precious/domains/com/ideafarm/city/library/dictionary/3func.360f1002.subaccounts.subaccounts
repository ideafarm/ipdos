
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    __Z( bOk ) ;
    }
        }
            }
                else       bOk = 1 ;
                if( POOP ) { POOPR ; }

                push_pstt_F( tinP , pStkEmailPenpalContainsAnd , sIn ) ;
                push_pstt_F( tinP , pStkEmailPenpalContainsOr  , sIn ) ;
                push_pstt_F( tinP , pStkEmailPenpalExactOr     , sIn ) ;
                push_pstt_F( tinP , pStkRecipe                 , sIn ) ;
                push_pstt_F( tinP , pStkAutoresponse           , sIn ) ;
                if( !bAll && !( F(flagsThis) & flSUBACCOUNT_QUERYrELAYdRAWINGS ) ) cEmailRelayDrawings = 0 ;
                sIn >> cEmailRelayDrawings ;
                push_pstt_F( tinP , pStkEmailRelay             , sIn ) ;

    
                if( !bAll && !( F(flagsThis) & flSUBACCOUNT_QUERYnAMEoUT ) ) PUSE( tinP , *(byteT**)&psttNameOut ) ;
                sIn >> psttNameOut ; ___( psttNameOut ) ;
    
                if( !bAll && !( F(flagsThis) & flSUBACCOUNT_QUERYnAMEiN ) ) PUSE( tinP , *(byteT**)&psttNameIn ) ;
                sIn >> psttNameIn ; ___( psttNameIn ) ;
    
                if( !bAll && !( F(flagsThis) & flSUBACCOUNT_QUERYtITLE ) ) PUSE( tinP , *(byteT**)&psttTitle ) ;
                sIn >> psttTitle ; ___( psttTitle ) ;
            
                if( !bAll && !( F(flagsThis) & flSUBACCOUNT_QUERYfLAGSmEMBERoF ) ) flagsMemberOf = 0 ;
                sIn >> flagsMemberOf ;
    
                if( !bAll && !( F(flagsThis) & flSUBACCOUNT_QUERYiDmODE ) ) idMode = 0 ;
                sIn >> idMode ;
    
                if( !bAll && !( F(flagsThis) & flSUBACCOUNT_QUERYfLAGSmODE ) ) flagsMode = 0 ;
                sIn >> flagsMode ;
            {
            else
            if( POOP ) { POOPR ; }

            __Z( bSubExists ) ;
            sIn >> bSubExists ;
            ZE( boolT , bSubExists ) ;

            __Z( bAccExists ) ;
            sIn >> bAccExists ;
            ZE( boolT , bAccExists ) ;

            __( idFormat - 1 ) ;
            sIn >> idFormat ;
            ZE( countT , idFormat ) ;
        
            __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
            sIn >> finger ;
            ZE( countT , finger ) ;
        {
        else
        if( POOP ) { POOPR ; }
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << idSub ;
        sOut << idAcc ;
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_QUERYsUBACCOUNTdESCRIPTION ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;

        if( bAll || F(flagsThis) & flSUBACCOUNT_QUERYeMAILpENPALcONTAINSaND ) { (*tinP.pEtScratch)( tinP , pStkEmailPenpalContainsAnd , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkEmailPenpalContainsAnd ) ; }
        if( bAll || F(flagsThis) & flSUBACCOUNT_QUERYeMAILpENPALcONTAINSoR  ) { (*tinP.pEtScratch)( tinP , pStkEmailPenpalContainsOr  , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkEmailPenpalContainsOr  ) ; }
        if( bAll || F(flagsThis) & flSUBACCOUNT_QUERYeMAILpENPALeXACToR     ) { (*tinP.pEtScratch)( tinP , pStkEmailPenpalExactOr     , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkEmailPenpalExactOr     ) ; }
        if( bAll || F(flagsThis) & flSUBACCOUNT_QUERYrECIPE                 ) { (*tinP.pEtScratch)( tinP , pStkRecipe                 , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkRecipe                 ) ; }
        if( bAll || F(flagsThis) & flSUBACCOUNT_QUERYaUTORESPONSE           ) { (*tinP.pEtScratch)( tinP , pStkAutoresponse           , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkAutoresponse           ) ; }
        if( bAll || F(flagsThis) & flSUBACCOUNT_QUERYeMAILrELAY             ) { (*tinP.pEtScratch)( tinP , pStkEmailRelay             , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkEmailRelay             ) ; }

        const boolT bAll = ( flagsThis & ~( F(flSUBACCOUNT_SET) ) ) == flSUBACCOUNT_null ;

        if( POOP ) { POOPR ; }

        SCOOPS
    {
    IFsCRATCH
    ZE( boolT , bOk ) ;

    _IO_

    }
        if( POOP ) return ;
        FV(flSUBACCOUNT,flagsP) ;
        __Z( idSubP ) ;
        __Z( idAccP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    //CONoUTrAWb( "\r\nsubaccountS/ct [idAdam,idThread,idAcc,idSub,flags]: " , tinP.pAdamGlobal1->idAdam , "(" , tinP.monitor.idThread , ") " , idAccP , ":" , idSubP , " " , flagsP , "\r\n" ) ; //U::
    //CONoUTrAW( tinP.postThreadName ) ;
{
pStkEmailPenpalContainsAnd( 0 )
pStkEmailPenpalContainsOr( 0 ) ,
pStkEmailPenpalExactOr( 0 ) ,
pStkRecipe( 0 ) ,
pStkAutoresponse( 0 ) ,
pStkEmailRelay( 0 ) ,
psttNameOut( 0 ) ,
psttNameIn( 0 ) ,
psttTitle( 0 ) ,
cEmailRelayDrawings( 0 ) ,
idMode( 0 ) ,
flagsMemberOf( 0 ) ,
flagsMode( 0 ) ,
flagsThis( flagsP ) ,
idSub( idSubP ) ,
idAcc( idAccP ) ,
/*1*/subaccountS::subaccountS( tinS& tinP , etherC& etherP , const countT idAccP , countT& idSubP , flagsT flagsP ) :/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

