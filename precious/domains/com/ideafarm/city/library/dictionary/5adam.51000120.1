
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    etThread.loafIF( tinP ) ;

    HIRE( T("port..expireTime") , 0x40104ce , 0x40000000 , 0x40104ce , 0x40000000 )
    //ALL OF THE idAdam CASE VALUES ARE OBSOLETED: 0xghij104 -> 0x401jihg -> 0x400jihg -> list.map -> 0x51000zzz
    //ether.osSleepF( tinP , timeS1 ) ;
    //etThread.ifcSayF( tinP , TF1(DDNUMB)+T(": timeS1: ")+TT(timeS1,0)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
    //timeS1 = 0x10bb8ab1 ;
    //countT timeS1 = TICK * 0x10 + ru ;
    //ranUniC ru( TICK ) ;
    //U::

    //U::HIRE( T("port..expireTime") , 0x40103fc , 0x1000000 , 0x40103fc , 0x1000000 )

    etThread.ifcChatF( tinP , 0 , DDNUMB , jobFillCourseF , jobHearOrderF ) ;
    stateS state( tinP , etThread ) ;
{

TODO

STATE0

//==== DAYTIME   WORK (ABOVE THIS LINE) ===================================================================================
//==== MOONLIGHT WORK (BELOW THIS LINE) ===================================================================================


}
    if( ether && *tinP.zEtScratch && sNotesTextP && sNotesDataP && idChatSessionP && sDataP && cArgP && c8argP ) ;

    }
        }
            }
                __1
                __( sOrderP.cFieldF( tinP ) ) ;
            {
            default :
            }
                break ;
    
                etThread.delF( tinP , psttJobType ) ;
    
                else __1
                }
                    sDataP << cBound ;
                    }
                        tinP.zEtScratch->delF( tinP , pstt1f ) ;
                        }
                            cBound ++ ;
                            addTimeF( tinP , *tinP.zEtScratch , idComputer , 0 , 0x100 , 2 ) ;
                            tinP.zEtScratch->diskFileOrDirDeleteF( tinP , psttc2 ) ;
                        {
                        FORsTRINGSiN2( pstt1f )
                        tinP.zEtScratch->diskFindFileOrDirF( tinP , pstt1f , T("///ideafarm/ephemeral/domains/com/ideafarm/payment/")+T(psttEmail)+T(".$note.b.1.1.*") , 0 , 0x10 ) ; //THE MAX IS TO AVOID ATTACK; NO WO WOULD MAKE 01 PAYMENTS WITHOUT BINDING THEM TO A COMPUTER

                        tinP.zEtScratch->delF( tinP , pstt1f ) ;
                        }
                            cBound ++ ;
                            addTimeF( tinP , *tinP.zEtScratch , idComputer , 0 , 0x40 , 1 ) ;
                            tinP.zEtScratch->diskFileOrDirDeleteF( tinP , psttc1 ) ;
                        {
                        FORsTRINGSiN1( pstt1f )
                        tinP.zEtScratch->diskFindFileOrDirF( tinP , pstt1f , T("///ideafarm/ephemeral/domains/com/ideafarm/payment/")+T(psttEmail)+T(".$note.9.1.1.*") , 0 , 0x10 ) ; //THE MAX IS TO AVOID ATTACK; NO WO WOULD MAKE 01 PAYMENTS WITHOUT BINDING THEM TO A COMPUTER
                        ZE( strokeS* , pstt1f ) ;
                    {
                    ZE( countT , cBound ) ;

                    sOrderP >> psttEmail ;
                    sOrderP >> idComputer ;
                    ZE( strokeS* , psttEmail ) ;
                    ZE( countT , idComputer ) ;
                {
                else if( !tinP.zEtScratch->strCompareF( tinP , psttJobType , T("!bindPaymentsToMe") ) )
                }
                    etThread.strokeF( tinP , T("sData << ")+TT(timeR1,timeR2)+T("\r\n") ) ; //U::
                    sDataP << (countT&)timeR2 ;
                    sDataP << timeR1 ;
                    queryTimeF( tinP , *tinP.zEtScratch , timeR1 , timeR2 , idComputer , idType ) ;
                    ZE( sCountT , timeR2 ) ;
                    ZE( countT , timeR1 ) ;

                    sOrderP >> idType ;
                    sOrderP >> idComputer ;
                    ZE( countT , idType ) ;
                    ZE( countT , idComputer ) ;
                {
                else if( !tinP.zEtScratch->strCompareF( tinP , psttJobType , T("!queryTimeRemaining") ) )
                }
                    addTimeF( tinP , *tinP.zEtScratch , idComputer , timeP1 , timeP2 , idType ) ;

                    sOrderP >> (countT&)timeP2 ;
                    sOrderP >> timeP1 ;
                    sOrderP >> idType ;
                    sOrderP >> idComputer ;
                    ZE( sCountT , timeP2 ) ;
                    ZE( countT , timeP1 ) ;
                    ZE( countT , idType ) ;
                    ZE( countT , idComputer ) ;
                {
                if( !tinP.zEtScratch->strCompareF( tinP , psttJobType , T("!addTime") ) )

                sOrderP >> psttJobType ; ___( psttJobType ) ;
                ZE( strokeS* , psttJobType ) ;
            {
            case ifcIDcMDjOBoRDER_NAMED :
        {
        switch( idJobType )
        sOrderP >> idJobType ;
        ZE( countT , idJobType ) ;
    {
    if( idCourseP == 1 )

    __( idAdamP - DDNUMB ) ;
{
voidT jobFillCourseF( tinS& tinP , etherC& ether , etherC& etThread , soulC& sDataP , soulC& sNotesTextP , soulC& sNotesDataP , const countT idCourseP , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

}
    if(  ether && *tinP.zEtScratch && idChatSessionP && sOrderP && cArgP && c8argP ) ;

    __( idAdamP - DDNUMB ) ;
{
voidT jobHearOrderF( tinS& tinP , etherC& ether , etherC& etThread , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

}
    time2P = timeRemaining.time2 ;
    time1P = timeRemaining.time1 ;

    }
        ether.delF( tinP , pbe ) ;
            
        }
            }
                timeRemaining = timeExpires ;
                ether.osTimeSubtractF( tinP , timeExpires.time1 , timeExpires.time2 , timeN1 , timeN2 ) ;
            {
            if( timeExpires.time2 > timeN2 || ( timeExpires.time2 == timeN2 && timeExpires.time1 > timeN1 ) )
            
            ether.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
            
            timeS& timeExpires = *(timeS*)pbe ;
        {
        if( pbe && cbe == sizeof( timeS ) )
            
        ether.boxGetShadowF( tinP , pbe , cbe , tFile ) ; ___( pbe ) ;
        ZE( countT , cbe ) ;
        ZE( byteT* , pbe ) ;
    {
    if( ether.diskFileExistsF( tinP , tFile ) )
    TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF1(DDNUMB)+T("/timeExpire.")+TF1(idComputerP)+T(".")+TF1(idTypeP) ;
            
    timeS timeRemaining ;
{
voidT queryTimeF( tinS& tinP , etherC& ether , countT& time1P , sCountT& time2P , const countT idComputerP , const countT idTypeP )

}
    ether.boxPutF( tinP , tFile , (byteT*)&timeExpires , sizeof timeExpires ) ;
    ether.osTimeAddF( tinP , timeExpires.time1 , timeExpires.time2 , time1P , time2P ) ;

    }
        ether.delF( tinP , pbe ) ;
        }
            if( tef.time2 > timeExpires.time2 || ( tef.time2 == timeExpires.time2 && tef.time1 > timeExpires.time1 ) ) timeExpires = tef ;
            timeS& tef = *(timeS*)pbe ;
        {
        if( pbe && cbe == sizeof( timeS ) )
    
        ether.boxGetShadowF( tinP , pbe , cbe , tFile ) ; ___( pbe ) ;
        ZE( countT , cbe ) ;
        ZE( byteT* , pbe ) ;
    {
    if( ether.diskFileExistsF( tinP , tFile ) )

    ether.osTimeNowF( tinP , timeExpires.time1 , timeExpires.time2 ) ;
    timeS timeExpires ;
    
    TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF1(DDNUMB)+T("/timeExpire.")+TF1(idComputerP)+T(".")+TF1(idTypeP) ;
{
voidT addTimeF( tinS& tinP , etherC& ether , const countT idComputerP , const countT time1P , const sCountT time2P , const countT idTypeP )

/*1*/WAKEhIDE( "port..expireTime" )/*1*/
/**/
*/
for an idComputer.idType i reply with timeExpire
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

