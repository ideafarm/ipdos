
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    traceF( tinP , T("-") ) ;
    _OUT_

    traceF( tinP , T("osMakeHoverFileF /-") ) ;

    __( bFail ) ;
    }
        batUpdate.ungrabF( tinP ) ;
        traceF( tinP , T("0") ) ;

        delF( tinP , pbm ) ;
        traceF( tinP , T("1") ) ;

        }
            }
                THREADmODE1rESTORE
                traceF( tinP , T("2") ) ;
                traceF( tinP , T("osMakeHoverFileF / wrote master file") ) ;
                boxPutF( tinP , tMaster , pbm , cbm ) ;
                traceF( tinP , T("3") ) ;
                traceF( tinP , T("osMakeHoverFileF / writing master file") ) ;
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            {
            if( bModified )
            traceF( tinP , T("4") ) ;

            DEL( pInfo ) ;
            traceF( tinP , T("5") ) ;
            }
                }
                    THREADmODE1rESTORE
                    traceF( tinP , T("osMakeHoverFileF / wrote hover file") ) ;
                    traceF( tinP , T("6") ) ;
                    traceF( tinP , T("osMakeHoverFileF / put     hover file [name]:    ")+tName ) ;
                    if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DEBUG ) ) boxPutF( tinP , tFile , pbm , cbm ) ; //U:: "if(...)" TO FIND A BUG (STUDY WHY SOMETIMES BUILDING HOVERFILE OF MASTER DLL TAKES SO LONG)
                    traceF( tinP , T("osMakeHoverFileF / putting hover file [name]:    ")+tName ) ;
                    TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/")+tName ;
                    traceF( tinP , T("7") ) ;
                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                    traceF( tinP , T("osMakeHoverFileF / writing hover file") ) ;

                    #endif
                    //U::

                    //traceF( tinP , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall5 ;
                            *pbc = 'c' ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall5 , sizeof pbSmall5 ) ;
                        //CONoUTrAW3( "\r        \r    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    traceF( tinP , T("") ) ;
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 0") ) ;
                    
                    //traceF( tinP , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall4 ;
                            *pbc = 'C' ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall4 , sizeof pbSmall4 ) ;
                        //CONoUTrAW3( "\r        \r    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    traceF( tinP , T("") ) ;
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 1") ) ;
                    
                    //traceF( tinP , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall3 ;
                            *pbc = 0 ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall3 , sizeof pbSmall3 ) ;
                        //CONoUTrAW3( "\r        \r    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    traceF( tinP , T("") ) ;
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 2") ) ;
                    
                    //traceF( tinP , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall2 ;
                            *pbc = 0 ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall2 , sizeof pbSmall2 ) ;
                        //CONoUTrAW3( "\r        \r    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    traceF( tinP , T("") ) ;
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 3") ) ;
                    
                    #if defined( NEVERdEFINED )
                    //U::
                    
                    //traceF( tinP , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall8 ;
                            *pbc = (byteT)0 ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall8 , sizeof pbSmall8 ) ;
                        //CONoUTrAW3( "\r        \r0    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    traceF( tinP , T("8") ) ;
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 4") ) ;
                    
                    //traceF( tinP , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall7 ;
                            *pbc = (byteT)0 ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall7 , sizeof pbSmall7 ) ;
                        //CONoUTrAW3( "\r        \r1    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    traceF( tinP , T("9") ) ;
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 5") ) ;
                    
                    //traceF( tinP , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall6 ;
                            thirdC::c_memcpyIF( tinP , pbc + 0xe , tName , tName.csF( tinP ) ) ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall6 , sizeof pbSmall6 ) ;
                        //CONoUTrAW3( "\r        \r2    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    traceF( tinP , T("a") ) ;
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 6") ) ;
                    
                    //traceF( tinP , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall1 ;
                            thirdC::c_memsetIF( tinP , pbc + 1 , sizeof pbSmall1 - 2 , FILLbYTE_HOVERfILEsMUDGE ) ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tinP , pbc , cbm - ( pbc - pbm ) , pbSmall1 , sizeof pbSmall1 ) ;
                        //CONoUTrAW3( "\r             \r3    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    //traceF( tinP , T("\r\n") ) ;
                    byteT* pbc = pbm ;
                    traceF( tinP , T("b") ) ;
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 7") ) ;
                    
                    byteT* const pbe = pbm + cbm ;
                    
                    *pbSmall8 = 'T' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall7 = 'T' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    pbSmall6[ 0x17 ] = '8' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall5 = 'd' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall4 = 'D' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall3 = *pbSmall2 = 'T' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall1 = 0 ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    
                    byteT pbSmall8[] = ".he program encountered a problem at address %08lx and cannot continue" ;
                    byteT pbSmall7[] = ".he instruction at %08lx referenced memory at %08lx\x0aThe memory could not be %s" ;
                    byteT pbSmall6[] = "!postBaseName:ideafarm..1000001.ipdos-wm" ;
                    byteT pbSmall5[] = ".:\\ideafarm.work\\backed.up.never\\gen\\" ;
                    byteT pbSmall4[] = ".:\\ideafarm.work\\backed.up.never\\gen\\" ;
                    byteT pbSmall3[] = { 't' , 'h' , 'e' , ' ' , 'p' , 'r' , 'o' , 'g' , 'r' , 'a' , 'm' , ' ' , 'e' , 'n' , 'c' , 'o' , 'u' , 'n' , 't' , 'e' , 'r' , 'e' , 'd' , ' ' , 'a' , ' ' , 'p' , 'r' , 'o' , 'b' , 'l' , 'e' , 'm' , ' ' , 'a' , 't' , ' ' , 'a' , 'd' , 'd' , 'r' , 'e' , 's' , 's' , ' ' , '%' , '0' , '8' , 'l' , 'x' , ' ' , 'a' , 'n' , 'd' , ' ' , 'c' , 'a' , 'n' , 'n' , 'o' , 't' , ' ' , 'c' , 'o' , 'n' , 't' , 'i' , 'n' , 'u' , 'e' } ;
                    byteT pbSmall2[] = { 't' , 'h' , 'e' , ' ' , 'i' , 'n' , 's' , 't' , 'r' , 'u' , 'c' , 't' , 'i' , 'o' , 'n' , ' ' , 'a' , 't' , ' ' , '%' , '0' , '8' , 'l' , 'x' , ' ' , 'r' , 'e' , 'f' , 'e' , 'r' , 'e' , 'n' , 'c' , 'e' , 'd' , ' ' , 'm' , 'e' , 'm' , 'o' , 'r' , 'y' , ' ' , 'a' , 't' , ' ' , '%' , '0' , '8' , 'l' , 'x' } ;
                    //byteT pbSmall1[] = { 0 , 'M' , 'e' , 's' , 's' , 'a' , 'g' , 'e' , 'B' , 'o' , 'x' , 'E' , 'x' , 'A' , 0 , 'A' , 'p' , 'p' , 'l' , 'i' , 'c' , 'a' , 't' , 'i' , 'o' , 'n' , ' ' , 'E' , 'r' , 'r' , 'o' , 'r' , ':' , ' ' , 0 } ;
                    byteT pbSmall1[] = { 'x' , 'M' , 'e' , 's' , 's' , 'a' , 'g' , 'e' , 'B' , 'o' , 'x' , 'E' , 'x' , 'A' , 0 } ;
                    traceF( tinP , T("c") ) ;

                    //THIS REALLY ONLY NEEDS TO BE DONE FOR 0100002 0100003 (THE HOVER EXE FILES)
                    //SMUDGE "\x00MessageBoxExA\x00Application Error:\x00" TO PREVENT WATCOM'S CODE FROM EMITTING A POPUP WHEN AN EXCEPTION OCCURS
                    //IT ALSO PREDATES THE EXCEPTION HANDLING CODE WITHIN IPDOS (tm), WHICH MIGHT RENDER THE SMUDGING UNNECESSARY
                    //THIS SMUDGING OF MessageBoxExA DATES BACK TO THE MID 1990'S SO MIGHT NOT BE NEEDED ANY LONGER

                    if( pInfo->postImageName ) memCopyF( tinP , pInfo->postImageName , tName , tName.csF( tinP ) ) ; //U::WHY IS THIS 0 STARTING TODAY? 2002.12.26
                    tName = T("ideafarm.")+TF3(idCopy,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) + ( pInfo->bDll?T(".ipdos-wd") : T(".ipdos-we") ) ;
                    TN( tName , "" ) ;
                    traceF( tinP , T("osMakeHoverFileF / patching copy / 8") ) ;
                {
                if( idCopy )
                traceF( tinP , T("e") ) ;

                }
                    traceF( tinP , T("f") ) ;
                    delF( tinP , pstt1w ) ;
                    traceF( tinP , T("g") ) ;
                    }
                        else if( !strCompareF( tinP , psttc2 , tTag ) ) bNext = 1 ;
                        }
                            break ;
                            idCopy = strDigitsToSCountF( tinP , psttc2 ) ;
                        {
                        if( bNext )
                    {
                    FORsTRINGSiN2( pstt1w )
                    traceF( tinP , T("h") ) ;
                    TN( tTag , "!idCopy" ) ;
                    ZE( boolT , bNext ) ;
                    strWordsOldF( tinP , pstt1w , T(pInfo->postDescription) , sttq ) ; ___( pstt1w ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , pstt1w ) ;
                    __( !pInfo->postDescription ) ;
                    traceF( tinP , T("i") ) ;
                {
                ZE( countT , idCopy ) ;
                traceF( tinP , T("j") ) ;
                traceF( tinP , T("osMakeHoverFileF / setting idCopy") ) ;

                }
                    }
                        }
                            bModified = 1 ;
                            thirdC::c_itoaIF( postPatch , idCopyLath , '0' ) ; //U::VERIFY THAT WILL DO UNSIGNED I.E. WILL WORK WHEN HIGH ORDER BIT IS USED

                            THREADmODE1rESTORE
                            boxPutF( tinP , tLath , (byteT*)&idCopyLath , sizeof idCopyLath ) ;
                            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                            idCopyLath ++ ;
                            }
                                traceF( tinP , T("k") ) ;
                                delF( tinP , pbi ) ;
                                traceF( tinP , T("l") ) ;
                                else if( cbi >= sizeof( countT ) ) idCopyLath = *(countT*)pbi ;
                                if( POOP ) { POOPR ; }
                                traceF( tinP , T("m") ) ;
                                THREADmODE1rESTORE
                                traceF( tinP , T("n") ) ;
                                tinP.pEtScratch->boxGetShadowF( tinP , pbi , cbi , tLath , 1 ) ; ___( pbi ) ;
                                traceF( tinP , T("o") ) ;
                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                ZE( countT , cbi ) ;
                                ZE( byteT* , pbi ) ;

                                SCOOPS
                                traceF( tinP , T("p") ) ;
                            {
                            IFsCRATCH
                            ZE( countT , idCopyLath ) ;
                            TN( tLath , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/idCopyLath" ) ;
                            //CS:CODEsYNC: DUPLICATE 33002111 33002134
                            traceF( tinP , T("q") ) ;
                        {
                        if( !thirdC::c_memcmpIF( tinP , postPatch , "00000000000000000000000000000000" , sizeof( countT ) * 2 ) ) //A:ASSUME: sizeof( countT ) IS NOT GREATER THAN 01 BYTES
                        traceF( tinP , T("r") ) ;

                        postPatch += sizeof postTag ;
                        traceF( tinP , T("s") ) ;
                    {
                    if( postPatch )
                    byteT* postPatch = thirdC::c_strstrIF( tinP , pInfo->postDescription , postTag ) ;
                    traceF( tinP , T("t") ) ;

                    osTextT postTag[] = "!idCopy" ;
                    traceF( tinP , T("u") ) ;
                {
                traceF( tinP , T("v") ) ;
                traceF( tinP , T("osMakeHoverFileF / inspecting !idCopy value in description") ) ;

                }
                    while( !POOP && ~handle ) ;
                    }
                        }
                            delF( tinP , psttw ) ;
                            }
                                }
                                    }
                                        traceF( tinP , T("w") ) ;
                                        delF( tinP , postDll ) ;
                                        memCopyF( tinP , postMas , postDll , costDll ) ;
                                        delF( tinP , psttw2 ) ;
                                        countT costDll = strMakeF( tinP , postDll , psttw2 ) ; ___( postDll ) ;
                                        ZE( osTextT* , postDll ) ;
                                        strMakeF( tinP , psttw2 , T("ideafarm.")+TF3(idCopy,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(".ipdos-wd") ) ; ___( psttw2 ) ;
                                        ZE( strokeS* , psttw2 ) ;
                                        traceF( tinP , T("x") ) ;
                                    {
                                    if( idCopy )
                                    countT idCopy = swIdCopy ;
                                    traceF( tinP , T("y") ) ;
                                {
                                if( cName )
                                cName = strDigitsToSCountF( tinP , psttw , 0 , 1 ) ;
                                traceF( tinP , T("z") ) ;
                            {
                            if( strIsDigitsF( tinP , psttw ) )
                            strSubstringF( tinP , psttw , idf , idl , tMas ) ; ___( psttw ) ;
                            ZE( strokeS* , psttw ) ;
                            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                            countT idl = 0x11 ;
                            countT idf = 0xa ;
                            traceF( tinP , T("A") ) ;
                        {
                        if( 0x12 == strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , teMas , tMas ) )
                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                        countT idf = 1 ;
                        traceF( tinP , T("B") ) ;

                        TN( tMas , postMas ) ;
                        osTextT* postMas = (osTextT*)pInfo->pSt_postDllUsed->downF( tinP , handle ) ;
                        traceF( tinP , T("C") ) ;
                        traceF( tinP , T("osMakeHoverFileF / looping to get dll names") ) ;
                    {
                    do
                    handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    TN( teMas , ".ipdos-wm" ) ;
                    traceF( tinP , T("D") ) ;
                {
                if( pInfo->pSt_postDllUsed && *pInfo->pSt_postDllUsed )
                traceF( tinP , T("E") ) ;
            {
            if( pInfo )
            traceF( tinP , T("F") ) ;
            traceF( tinP , T("osMakeHoverFileF / got     image information") ) ;
            third.imageExeDllF( tinP , pInfo , pbm ) ; ___( pInfo ) ;
            traceF( tinP , T("osMakeHoverFileF / getting image information") ) ;
            traceF( tinP , T("G") ) ;
            ZE( imageExeDllC* , pInfo ) ;
            ZE( boolT , bModified ) ;
        {
        else
        }
            bFail = 1 ;
            POOPR ;
        {
        if( POOP )

        THREADmODE1rESTORE
        traceF( tinP , T("H") ) ;
        traceF( tinP , T("osMakeHoverFileF / read    master into memory [cbm]: ")+TF2(cbm,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        boxGetShadowF( tinP , pbm , cbm , tMaster , 1 ) ; ___( pbm ) ;
        traceF( tinP , T("osMakeHoverFileF / reading master into memory") ) ;
        traceF( tinP , T("I") ) ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        ZE( countT , cbm ) ;
        ZE( byteT* , pbm ) ;

        TN( tMaster , "" ) ; tMaster = T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/master/ideafarm.")+TF3(cNameP,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(".ipdos-wm") ;
        traceF( tinP , T("K") ) ;

        }
            traceF( tinP , T("L") ) ;
            THREADmODE1rESTORE
            }
                traceF( tinP , T("M") ) ;
                master.idCopyF( tinP , swIdCopy , cName , b_cName ) ;
                traceF( tinP , T("N") ) ;
                masterOldC master( tinP , *this , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) ) ;
                traceF( tinP , T("O") ) ;
            {
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            traceF( tinP , T("P") ) ;
        {
        traceF( tinP , T("Q") ) ;
        batonC b_cName( tinP , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) ;
        traceF( tinP , T("R") ) ;
        switchC swIdCopy( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_null , cName ) ;
        traceF( tinP , T("S") ) ;
        ZE( countT , cName ) ;

        traceF( tinP , T("T") ) ;
        batUpdate.grabF( tinP , TAG( TAGiDnULL ) ) ;
        traceF( tinP , T("U") ) ;
        batonC batUpdate( tinP , TAG( TAGiDnULL ) , T("ifc.update") , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) ;
        traceF( tinP , T("V") ) ;
    {
    ZE( boolT , bFail ) ;

    traceF( tinP , T("osMakeHoverFileF /+") ) ;

    _INoLD_

    }
        traceF( tinP , T("W") ) ;
        if( POOP ) return ;
        __NZ( bRawNameP ) ; //U:NOT YET SUPPORTED
        __Z( cNameP ) ;
        if( POOP ) return ;
        traceF( tinP , T("X") ) ;
    {
    IFbEcAREFUL
    SCOOP
    traceF( tinP , T("+") ) ;
{
/*1*/voidT etherC::osMakeHoverFileF( tinS& tinP , const countT cNameP , const boolT bRawNameP )/*1*/

/**/
*/
 U: the wo'st type is named using the raw master name and its use list refers to raw master names
 the ze'st type is named using the idCopy value and its use list refers to idCopy names
U:for the specified master file, makes a hover file of wo of oo types
\<A HREF=\"5.103014a.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$osMakeHoverFileF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

