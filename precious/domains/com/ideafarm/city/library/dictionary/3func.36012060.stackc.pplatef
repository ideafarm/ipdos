
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return ppc ;
    _OUTbATONsTACKc_
    if( cPlates < *p_idCursor || ( *p_idCursor && !*p_ppCursor ) ) { BLAMMO ; } //U::

    }
        }
            idP = cPlates + 1 + idP ;
            while( ppc && cSteps -- ) ppc = ppc->ppU ;
            countT cSteps = - 1 - idP ;
            ppc = ppBottom ;
        {
        else
        if( cPlates < - idP ) idP = 0 ;
    {
    else
    }
        }
            }
                }
                    else              while( ppc && scSteps ++ ) ppc = ppc->ppU ;
                    if( scSteps > 0 ) while( ppc && scSteps -- ) ppc = ppc->ppD ;
                    sCountT scSteps = idP - *p_idCursor ;
                    ppc = *p_ppCursor ;
                {
                else
                }
                    while( ppc && cSteps -- ) ppc = ppc->ppD ;
                    countT cSteps = idP - 1 ;
                    ppc = ppTop ;
                {
                if( !*p_idCursor )
            {
            else
            }
                }
                    while( ppc && scSteps ++ ) ppc = ppc->ppU ;
                    countT scSteps = idP - pcTabIdSlot[ oTab ] ; //WILL BE NONPOSITIVE
                    ppc = ppTab[ oTab ] ;
                    if( oTab > cTabs ) BLAMMO ; //U::
                {
                else                // oTab PLATE IS NOT LIGHTER
                }
                    while( ppc && scSteps -- ) ppc = ppc->ppD ;
                    countT scSteps = idP - pcTabIdSlot[ cTabs - 1 ] ;
                    ppc = ppTab[ cTabs - 1 ] ;
                {
                if( oTab == cTabs ) //ALL TABBED PLATES ARE LIGHTER
    
                }
                    else if( pcTabIdSlot[ oTab ] >= idP || ++ oTab == cTabs ) break ;
                    }
                        else oTab -- ;
                        else if( !oTab ) break ;
                        }
                            if( ++ oTab == cTabs ) break ;
                            bUp = 0 ;
                        {
                        if( pcTabIdSlot[ oTab ] < idP )
                    {
                    else if( bUp )
                    if( pcTabIdSlot[ oTab ] == idP ) break ;
                {
                for(;;)
                boolT bUp = 1 ;
                if( oTab >= cTabs ) oTab = cTabs - 1 ;
                countT oTab = idP * cTabs / cPlates ; //ESTIMATED TAB
                // RECIPE: GUESS; GO UP TILL id < idP; GO BACK DOWN TILL id >= idP
                //GOAL: SET oTab TO THE WO'TH TAB AT OR BEYOND idP (GOING DOWN FROM THE TOP OF THE STACK)
            {
            else if( cTabs && idP > cPlates / cTabs )
            }
                else              while( ppc && scSteps ++ ) ppc = ppc->ppU ;
                if( scSteps > 0 ) while( ppc && scSteps -- ) ppc = ppc->ppD ;
                ppc = *p_ppCursor ;
            {
            if( *p_idCursor && - 8 <= scSteps && scSteps <= 8 )
    
            sCountT scSteps = *p_idCursor ? idP - *p_idCursor : 0 ;
    
            }
                newTabsIfF( tinP , 0 , 0 ) ;
                cTabAge = - 1 ;
                flagsState |= flSTACKsTATE_MAINTAINtABS ;
            {
            if( !( F(flagsState) & flSTACKsTATE_MAINTAINtABS ) )
        {
        else
        if( cPlates < idP ) idP = 0 ;
    {
    else if( (sCountT)idP > 0 )
    }

        idP = *p_idLathRef ;
        ppc = *p_ppLathRef ;

        if( *p_ppLathRef && !*p_idLathRef ) setIdLathRefF( tinP ) ;

        LATHrEF
    {
    if( !idP )
    ZE( plateS* , ppc ) ;

    //U::O: IF pXray THEN USE *pXray

    if( cPlates < *p_idCursor || ( *p_idCursor && !*p_ppCursor ) ) { BLAMMO ; } //U::

    CURSOR

    _INbATONsTACKc_
    SCOOP
{
/*1*/plateS* stackC::pPlateF( tinS& tinP , countT& idP )/*1*/

/**/
*/
   example: the plate at the bottom of the stack is referenced by setting idP to -1
  if idP is < 0 then i return that plate (counting up from the bottom of the stack) and set idP to the id of that plate
  if idP is > 0 then i return that plate and leave idP unchanged
   i will search if necessary and set *p_idLathRef
  if idP is 0 then i return the plate last referenced, and set idP to the id of that plate
 idP
 tinP
arguments
for speed, i have no overhead code or serialization code
see operator []
\<A HREF=\"5.1150066.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$pPlateF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

