
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmHireF )
}
    }
        //ether.osThreadF( tinP , countTC() , tmFireMyselfF ) ;
        
        //homeS::homeIF().flags |= flHOMEs_FIREtHIShOME ;
        //CONoUTrAW( "setting flHOMEs_FIREtHIShOME\r\n" ) ;
        //U::TO FIND A BUG
    
        /*PROD*/ /*if( idMe == IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 || idMe == IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0sERVER )*/ ether.ifcHireF( tinP , T("ifcIDaDAM_MONITOR") , ifcIDaDAM_MEMBRANEgLASS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

        //ether.ifcHireF( tinP , T("ifcIDaDAM_MONITOR") , ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE1 , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
        
        //else                                          homeS::homeIF().flags |= flHOMEs_FIREtHIShOME ;
        //else                                          ether.osThreadF( tinP , countTC() , tmFireMyselfF ) ;
        
        // /*if( 1 < etherC::ifc_idHomeIdisk_IF() )*/    ether.ifcHireF( tinP , T("ifcIDaDAM_MONITOR") , ifcIDaDAM_MEMBRANEgLASS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
        //THIS WAS THE PRODUCTION LINE UNTIL 2010.12.23, WHEN LOCAL LIST DEVELOPMENT WAS FINISHED AND DEVELOPMENT RESUMED ON THE RELAY SUBSYSTEM
    
        //ether.osThread AdamF( tinP , ifcIDaDAM_MEMBRANEgLASS ) ;
        
        //ether.ifcHireF( tinP , T("ifcIDaDAM_MONITOR") , 0x4010ffe , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
        
        //else                                             ether.ifcHireF( tinP , T("ifcIDaDAM_MONITOR") , ifcIDaDAM_KERNEL3PANICdOOR , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
        //if( 0xffffff == etherC::ifc_idHomeI_IF() ) ether.ifcHireF( tinP , T("ifcIDaDAM_MONITOR") , ifcIDaDAM_TIMEcARD         , T("!noTells !ignoreFireByOperator")   , flHIRE_DISPLAYaUTO , nicNameC() ) ;
        
        //else                                             ether.ifcHireF( tinP , T("ifcIDaDAM_MONITOR") , ifcIDaDAM_NEWcONSOLE , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
        //if( 0xffffff == etherC::ifc_idHomeI_IF() ) ether.ifcHireF( tinP , T("ifcIDaDAM_MONITOR") , ifcIDaDAM_TIMEcARD   , T("!noTells !ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
    
        
    
        //ether.ifcHireF( tinP , T("ifcIDaDAM_MONITOR") , ifcIDaDAM_HOMEfLAGS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
        // 
        // b. OBJECTIVE: MIGRATE THIS ADAM SET TO THE PRODUCT WHILE ENSURING ROCK SOLID BEHAVIOR IN FIELD
        // a. INCREMENTALLY ADD THE REMAINDER OF THIS ADAM SET TO THE PRODUCT
        // 9. FIELD TEST AND TUNE SO USER CANNOT SEE ANY LOADING OR OTHER EFFECTS OF THE RELAY SUBSYSTEM
        // 8. "TURN ON" RELAY CAPABILITY IN THE PRODUCT
        // 7. LEASE AND CONFIGURE A DEDICATED SERVER TO SERVE AS THE ROOT RELAY
        // 6. ADD RELAY CAPABILITY TO THE PRODUCT
        // 5. TEST AND TUNE THE RELAY SYSTEM
        // 4. REWRITE THE MONITOR (005 CODE INTO 105), ENHANCING TO DETECT CPU SPINS
        // 3. ESTABLISH RELIABLE REVENUE STREAM
        // 2. ESTABLISH QUALITY REPUTATION IN THE MARKET
        // 1. RELEASE A KT VIEWER/EDITOR PRODUCT
        // 
        // PLAN
        // DO NOT DELETE THIS COMMENT; IT POINTS TO THE OLD ADAM CHAIN, WHICH IS ALMOST COMPLETELY DEBUGGED
        // 
        // IT WILL HAVE NO RELAY OR NETWORKING CAPABILITY
        // THIS INITIAL PRODUCT IS ENVISIONED AS LIKE ADOBE ACROBAT BUT FOR KNOWLEDGE TREES
        // COMMENTED OUT WITH INTENT TO REDESIGN THE PACKAGE TO GET STABLE AND QUICK INITIAL PRODUCT
        // CONSOLE ONLY SUPPORTS IO VIA CIO, WHICH IS UNNECESSARILY SLOW FOR LOCAL WORK
        // STATUS: WORKS AOK ON MY COMPUTER BUT PEGS CPU ON DANIEL'S
        // 
        // THIS IS THE OLD PRODUCT, WITH FULL RELAY CAPABILITY INCLUDING CIO SUPPORT FOR CONSOLE IO
    {
    else
    if( idAdamRequested ) ether.ifcHireF( tinP , T("ifcIDaDAM_MONITOR") , idAdamRequested , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

    }
        }
            else if( !etThread.strCompareF( tinP , psttc1 , tTest ) ) bArmed = 1 ;
            }
                break ;
                idAdamRequested = etThread.strDigitsToSCountF( tinP , psttc1 , 0 , 1 ) ;
                bArmed = 0 ;
            {
            if( bArmed )
            etThread.traceF( tinP , T("process parameter: \"")+T(psttc1)+T("\"") ) ;
        {
        FORsTRINGSiN1( pstt1p )
        ZE( boolT , bArmed ) ;

        strokeS*& pstt1p = etThread.ether_pstt1_processParametersI_F( tinP ) ;

        TN( tTest , "!idAdamMonitor" ) ;
    {
    ZE( countT , idAdamRequested ) ;

    }    
        //U:: while( !ether && ( !save || save + 0x10 <= cHamburgersP ) ) ;
        //U:: }
        //U::     CONoUTrAW5( "tmHireF [save,cHamburgersP]: " , save , " " , cHamburgersP , "\r\n" ) ;
        //U::     ++ s ; ether.osSleepF( tinP , TOCK ) ;
        //U::     save = cHamburgersP ;
        //U:: {
        //U:: do
        //U:: ZE( countT , save ) ;
        //U:: //SLEEP TO GIVE TELEMETRY EATERS TIME TO READ ALL TELEMETRY ALREADY BOOKED
        
        ++ s ; ether.osSleepF( tinP , TOCK * 0x4 ) ; //SLEEP TO GIVE INSTALLER TIME TO GO AWAY
    
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    
    //U::if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS ) ) { __( tinP.monitor.idThread - ifcIDtHREADlOW_tmHireF ) ; }

    countT& cHamburgersP = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmHireF )

#endif

    DONE( tmGorillasRawF )
    }
        }
            ++ s ; ether.osSleepF( tinP , TOCK << 1 ) ;
    
            }
                }
                    LOGrAW3( "[idError]: " , idError , "\r\n" ) ;
                    countT idError = tinP.brcRaw ;
                    BOSdOnOTtEST( WHATgbo , GetLastError() )
                {
                else
                }
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , CloseHandle( oshThread ) )
                {
                if( oshThread )
                HANDLE oshThread = (HANDLE)tinP.brcRaw ;
                BOSpOOP
                BOS( WHATgbo , BOSoK , CreateThread( &sa , TOCK , tmGorillaRawF , 0 , 0 , &osTid ) )
                ZE( DWORD , osTid ) ;
                BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                SECURITYaTTRIBUTE_saUNRESTRICTED( 0 ) ;
            {
            while( cDo -- )
            countT cDo = TUCK >> 4 ;
        {
        while( !ether && !POOP )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( pTaskP )
    TASK( tmGorillasRawF )
    }
        return 0 ;
    {
    DWORD WINAPI tmGorillaRawF( VOID* pvP )
    //U::REMOVE IN PRODUCTON ; THIS IS FOR RESOURCE LEAK TESTING

DONE( tmKillYourselfImmediatelyF )

BLAMMO ;
home.flags |= flHOMEs_KILLsELFiMMEDIATELY ;
etThread.traceF( tinP , T("setting flHOMEs_KILLsELFiMMEDIATELY") ) ;

}
    ++ s ; ether.osSleepF( tinP , TICK << 3 ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{

etThread.emailFactoryReportF( tinP , T("dying in 1/2 hour") ) ;

}
    ++ s ; ether.osSleepF( tinP , TICK << 7 ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    if( !cDo ) etThread.emailFactoryReportF( tinP , T("dying in 1/2 day") ) ;
{
while( cDo -- )
countT cDo = 8 ;

homeS& home = homeS::homeIF() ;

etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;

TASK( tmKillYourselfImmediatelyF )
    
DONE( tmTestImpotenceF )

}
    __1
    etThread.emailFactoryReportF( tinP , T("testing impotence") ) ;
{
if( !ether )

++ s ; ether.osSleepF( tinP , TOCK << 4 ) ;
sleepC s( tinP , TAG( TAGiDnULL ) ) ;

etThread.emailFactoryReportF( tinP , T("i will test impotence after napping TOCK << 4") ) ;

TASK( tmTestImpotenceF )

#if defined( NEVERdEFINED )

DONE( tmFireMyselfF )
YELL( "cleaning up")
ether.etherFireImpersonateMonitorIF( tinP ) ;
//CONoUTrAW( "firing myself\r\n" ) ;
YELL( "firing myself")
}
    //++ s ; ether.osSleepF( tinP , TOCK * 0xd /*, 0 , flSLEEP_TALK*/ ) ;
    ++ s ; ether.osSleepF( tinP , TOCK * 0x8 /*, 0 , flSLEEP_TALK*/ ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{
YELL( "napping before firing myself")
etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
TASK( tmFireMyselfF )

DONE( tmFireAllF )
//CONoUTrAW( "tmFireAllF/-" ) ; //U::

}
    }
        }
            }
                }
                    }
                        etRock.traceF( tinP , T("some beating hearts remain [off+1,cHearts,cHeartBeats]:    ")+TF2(off+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(cHearts,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(cHeartBeats,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    {
                    else
                    }
                        break ;
                        etRock.traceF( tinP , T("some hearts remain but none of them are beating [off+1,cHearts]:    ")+TF2(off+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(cHearts,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    {
                    else if( cHeartBeats == pchb[ ( idLook + 1 ) % ( sizeof pchb / sizeof pchb[ 0 ] ) ] )
                    }
                        break ;
                        etRock.traceF( tinP , T("0 hearts remain [off+1]:    ")+TF2(off+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    {
                    if( !cHearts )
                    countT cHeartBeats = home.pFireAll[ off ].cHeartBeats ;
                    countT cHearts     = home.pFireAll[ off ].cHearts ;

                    ++ s ; etThread.osSleepF( tinP , TOCK >> 2 ) ; //PRESUMED DEAD IF STOPPED FOR TOCK >> 2

                    pchb[ ( ++ idLook ) % ( sizeof pchb / sizeof pchb[ 0 ] ) ] = home.pFireAll[ off ].cHeartBeats ;

                    }
                        break ;
                        LOGrAW( "tmFireAllF/etThread is impotent\r\n" ) ;
                    {
                    if( etThread )

                    }
                        break ;
                        LOGrAW( "tmFireAllF/POOP is set\r\n" ) ;
                    {
                    if( POOP )
                {
                for(;;)
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                ZE( countT , idLook ) ;
                etThread.memSetF( tinP , (byteT*)pchb , sizeof pchb ) ;
                //etThread.strokeF( tinP , T("firing group ")+TF1(off+1)+tc ) ;
                home.pFireAll[ off ].bFire ++ ;

                //etThread.beeClickF( tinP , TUCK + 0x10 * off , TOCK * 4 ) ;
                etRock.traceF( tinP , T("firing group [off+1]:    ")+TF2(off+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                //CONoUTrAW3( "firing group " , off + 1 , "\r\n" ) ;
            {
            if( home.pFireAll[ off ].cHearts && home.pFireAll[ off ].cHeartBeats )
        {
        for( countT off = 0 ; off < CfIREaLLrANKS - 1 ; off ++ ) //I DO NOT FIRE THE HIGHEST GROUP, WHICH IS USED ONLY BY ME
        homeS& home = homeS::homeIF() ;
    
        countT pchb[ CfIREaLLsLOTS ] ;
    {
    //CODE SYNC: ec40104 ME
    
    TN( tb , " " ) ;
    TN( tc , "\r\n" ) ;

    }
        }
            etThread.boxPutF( tinP , T("///desk/IdeaFarm " "(tm) Warning (disabled).txt") , postNote , sizeof postNote - 1 ) ;

            } ;

                "Thank you for using IPDOS (tm).\r\n"
                "\r\n"
                "a current version.  This version has been disabled.\r\n"
                "An old version of IPDOS (tm) is active on this computer.  Please download\r\n"
                "\r\n"
                "http://ideafarm.com\r\n"
                "IPDOS (tm)\r\n"
                postIPDOSlONG "\r\n"
            {
            osTextT postNote[] =
        {
        if( home.idVersionIpdosMe && home.idVersionIpdosBan && home.idVersionIpdosMe <= home.idVersionIpdosBan )

        //home.flags |= flHOMEs_SUPPRESStELLS ;

        etRock.traceF( tinP , T("tmFireAllF called  etherFireImpersonateMonitorIF") ) ;
        etherC::etherFireImpersonateMonitorIF( tinP ) ;
        etRock.traceF( tinP , T("tmFireAllF calling etherFireImpersonateMonitorIF") ) ;

        //}
        //    etRock.traceF( tinP , T("tmFireAllF/ perhaps connected to idPortKernelMonitor") ) ;
        //    sockm.connectF( tinP , home.idPortKernelMonitor , socketC::nicNameIF( tinP , etThread , T("10.1.1.1") ) ) ;
        //    socketC sockm( tinP , etThread , TAG( TAGiDnULL ) ) ;
        //
        //    etRock.traceF( tinP , T("tmFireAllF/ awakened ; connecting to idPortKernelMonitor: ")+TF2(home.idPortKernelMonitor,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
        //{   //20160419@1731: ADDED THIS BLOCK AND REMOVED idpKiller VARIABLE WHICH WAS NOT USED; DONE TO FIX QUIT QUALITY ; CONJ: THIS BLOCK WAS ACCIDENTALLY DELETED
        //THIS IS NOT NEEDED BECAUSE sListen IS A QUITTER SOCKET SO tmWatchF WILL CONNECT TO IT

        etRock.traceF( tinP , T("tmFireAllF stopped napping") ) ;

        }
            ether.osSleepF( tinP , TOCK >> 3 ) ;
        {
        )
            && ( !home.idVersionIpdosBan || !home.idVersionIpdosMe || home.idVersionIpdosBan < home.idVersionIpdosMe )
            && !( F(home.flags) & flHOMEs_FIREtHIShOME )
            && !( slab.flagsi & fliSLABs_QUIT )
            && !etThread
            !ether
        (
        while

        etRock.traceF( tinP , T("tmFireAllF is napping; wake me up by setting flHOMEs_FIREtHIShOME") ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        homeS& home = homeS::homeIF() ;
        slabS& slab = slabS::slabF() ;
    {

    //U::if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS ) ) { __( tinP.monitor.idThread - ifcIDtHREADlOW_tmFireAllF ) ; }
    etherC& etRock = etherC::etRockIF( tinP ) ;
{
if( pTaskP )
TASK( tmFireAllF )

DONE( tmEatTelemetryF )
//etThread.traceF( tinP , T("tmEatTelemetryF / 0") ) ;
TELL( "cleaning up 0" )
}
    //etThread.traceF( tinP , T("tmEatTelemetryF / 1") ) ;
    TELL( "cleaning up 1" )
    }
        while( ~hWalk && -- cToDo ) ;
        }
            stPeriodData.extractF( 0 , tinP ) ;
            DELzOMBIE( ppd ) ;
            periodDataS* ppd = (periodDataS*)&stPeriodData.upF( tinP , hWalk ) ;
        {
        do
        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        countT cToDo = stPeriodData ;
    {
    if( stPeriodData )
    //etThread.traceF( tinP , T("tmEatTelemetryF / 2") ) ;
    TELL( "purging period data" )

    //U::sgnDone_tmReportF_.waitF( tinP ) ;
    //etThread.traceF( tinP , T("tmEatTelemetryF / 3") ) ;
    TELL( "waiting for tmReportF to end" )

    //etThread.traceF( tinP , T("tmEatTelemetryF / 4") ) ;
    }
        //etThread.traceF( tinP , T("tmEatTelemetryF / 5") ) ;
        if( idMemorySpaceP == ifcIDmEMORYsPACE_KERNEL ) bksTelemetry.fileFlagsRefF() &= ~flFILEc_DELETE ; // I AM PROBABLY READING THE CURRENT bookC, WHICH IS STILL OPEN FOR WRITING SO CANNOT BE DELETED NOW
        //U::THE NEXT LINE NO LONGER WILL WORK BECAUSE THE DELETE FLAG HAS ALREADY BEEN SPECIFIED WHEN CT fileC ; IT ALSO WOULDN'T WORK BECAUSE IT DOES NOT CHANGE THE FLAGS THAT ARE USED TO CT bookC INSTANCE

        }
            countT foo = 2 ;
        {
        if( idMemorySpaceP == 4 )

        }
            //etThread.traceF( tinP , T("tmEatTelemetryF / 6") ) ;
            }
                //CONoUTrAW( "." ) ;
                ++ s ; etThread.osSleepF( tinP , TOCK >> 2 ) ;
                TELL( "napping for a quarter tock" )
            
                if( bQuitEatingP ) break ;
                }
                    bBookHead = !bBookHead ;
            
                    }
                        else          pbi = 0 ;
                        if( bDelete ) PUSE( tinP , *(byteT**)&pbi ) ;
                        TELL( "maybe deleting hamburger" )
            
                        }
                            cbi = sizeof( telemetryBookHeadS ) ;
    
                            }
                                }
                                    }
                                        break ;
                                        }    
                                            }
                                                memorySpace.grab.ungrabF( tinP ) ;
                                                //etThread.traceF( tinP , T("after  ++++ [swsProcessGlobal3.cFlavors,swsProcessGlobal3] :    ")+TF2(memorySpace.swsProcessGlobal3.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsProcessGlobal3,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etThread.traceF( tinP , T("swsProcessGlobal3 ++++ [cPlatesNew]:    ")+TF2(memorySpace.swsProcessGlobal3,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                memorySpace.swsProcessGlobal3.sinkF( tinP , countTC() , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_processGlobal3EntryS_F ) ;
                                                //etThread.traceF( tinP , T("before ++++ [swsProcessGlobal3.cFlavors,swsProcessGlobal3] :    ")+TF2(memorySpace.swsProcessGlobal3.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsProcessGlobal3,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , note.osPid , 0 } ;
                                                memorySpace.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
                
                                                processGlobal3EntryS entry( tinP , note.osPid , note.pbEarlyGrain , note.cGrains ) ;
                                            {
                                            tellInfoProcessGlobal1S& note = *(tellInfoProcessGlobal1S*)pbNote ;
                                        {
                                        if( told.cbNote == sizeof( tellInfoProcessGlobal1S ) )
                                        TELL( "ifcIDtYPEtELL_PROCESSgLOBAL3scT" )
                                    {
                                    case ifcIDtYPEtELL_PROCESSgLOBAL1scT :
                                    }
                                        break ;
                                        }    
                                            }
                                                memorySpace.grab.ungrabF( tinP ) ;
                                                //etThread.traceF( tinP , T("after  ---- [swsNapkin.cFlavors,swsNapkin] :    ")+TF2(memorySpace.swsNapkin.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsNapkin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                else etThread.traceF( tinP , T("error: entry not found in swsNapkin") ) ;
                                                }
                                                    if( !memorySpace.swsNapkin ) memorySpace.swsNapkin.freeF( tinP ) ;
                                                    memorySpace.swsNapkin.extractF( 0 , tinP ) ;
                                                    //etThread.traceF( tinP , T("swsNapkin ---- [cPlatesOld,ids]:    ")+TF2(memorySpace.swsNapkin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(ids,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( ids )
                                                memorySpace.swsNapkin.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_napkinEntryS_F ) ;
                                                //etThread.traceF( tinP , T("before ---- [swsNapkin.cFlavors,swsNapkin] :    ")+TF2(memorySpace.swsNapkin.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsNapkin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , note.osPid , 0 } ;
                                                memorySpace.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                                ZE( countT , ids ) ;
                        
                                                napkinEntryS entry( tinP , note.osPid , note.postName , note.pbData , note.cbData , note.idLineCt , note.idiFileCt ) ;
                                            {
                                            tellInfoNapkinS& note = *(tellInfoNapkinS*)pbNote ;
                                        {
                                        if( told.cbNote == sizeof( tellInfoNapkinS ) )
                                        TELL( "ifcIDtYPEtELL_NAPKINfORMAT ifcIDtYPEtELL_NAPKINaTTACH" )
                                    {
                                    case ifcIDtYPEtELL_NAPKINdETACH :
                                    }
                                        break ;
                                        }    
                                            }
                                                memorySpace.grab.ungrabF( tinP ) ;
                                                //etThread.traceF( tinP , T("after  ++++ [swsNapkin.cFlavors,swsNapkin] :    ")+TF2(memorySpace.swsNapkin.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsNapkin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etThread.traceF( tinP , T("swsNapkin ++++ [cPlatesNew]:    ")+TF2(memorySpace.swsNapkin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                memorySpace.swsNapkin.sinkF( tinP , countTC() , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_napkinEntryS_F ) ;
                                                //etThread.traceF( tinP , T("before ++++ [swsNapkin.cFlavors,swsNapkin] :    ")+TF2(memorySpace.swsNapkin.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsNapkin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , note.osPid , 0 } ;
                                                memorySpace.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
                
                                                napkinEntryS entry( tinP , note.osPid , note.postName , note.pbData , note.cbData , note.idLineCt , note.idiFileCt ) ;
                                            {
                                            tellInfoNapkinS& note = *(tellInfoNapkinS*)pbNote ;
                                        {
                                        if( told.cbNote == sizeof( tellInfoNapkinS ) )
                                        TELL( "ifcIDtYPEtELL_NAPKINfORMAT ifcIDtYPEtELL_NAPKINaTTACH" )
                                    {
                                    case ifcIDtYPEtELL_NAPKINaTTACH :
                                    case ifcIDtYPEtELL_NAPKINfORMAT :
                                    }
                                        break ;
                                        }    
                                            }
                                                memorySpace.grab.ungrabF( tinP ) ;
                                                //etThread.traceF( tinP , T("after  ---- [swsSex.cFlavors,swsSex] :    ")+TF2(memorySpace.swsSex.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsSex,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                else etThread.traceF( tinP , T("error: entry not found in swsSex") ) ;
                                                }
                                                    if( !memorySpace.swsSex ) memorySpace.swsSex.freeF( tinP ) ;
                                                    memorySpace.swsSex.extractF( 0 , tinP ) ;
                                                    //etThread.traceF( tinP , T("swsSex ---- [cPlatesOld,ids]:    ")+TF2(memorySpace.swsSex,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(ids,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( ids )
                                                memorySpace.swsSex.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_sexEntryS_F ) ;
                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                //etThread.traceF( tinP , T("before ---- [swsSex.cFlavors,swsSex] :    ")+TF2(memorySpace.swsSex.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsSex,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , note.osPid , 0 } ;
                                                memorySpace.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                                ZE( countT , ids ) ;
                        
                                                sexEntryS entry( tinP , note.osPid , note.postName , note.expCbSlot , note.expSlots , note.pSex , note.idLineCt , note.idiFileCt ) ;
                                            {
                                            tellInfoSexS& note = *(tellInfoSexS*)pbNote ;
                                        {
                                        if( told.cbNote == sizeof( tellInfoSexS ) )
                                        TELL( "SEXdT" )
                                    {
                                    case ifcIDtYPEtELL_SEXdT :
                                    }
                                        break ;
            
                                        }
                                            }
                                                memorySpace.grab.ungrabF( tinP ) ;
                                                //etThread.traceF( tinP , T("swsSex ++++ [cPlatesNew]:    ")+TF2(memorySpace.swsSex,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                //etThread.traceF( tinP , T("after  ++++ [swsSex.cFlavors,swsSex] :    ")+TF2(memorySpace.swsSex.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsSex,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                memorySpace.swsSex.sinkF( tinP , countTC() , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_sexEntryS_F ) ;
                                                //etThread.traceF( tinP , T("before ++++ [swsSex.cFlavors,swsSex] :    ")+TF2(memorySpace.swsSex.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsSex,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , note.osPid , 0 } ;
                                                memorySpace.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
                
                                                sexEntryS entry( tinP , note.osPid , note.postName , note.expCbSlot , note.expSlots , note.pSex , note.idLineCt , note.idiFileCt ) ;
                                            {
            
                                            tellInfoSexS& note = *(tellInfoSexS*)pbNote ;
                                        {
                                        if( told.cbNote == sizeof( tellInfoSexS ) )
                                        TELL( "SEXcT" )
                                    {
                                    case ifcIDtYPEtELL_SEXcT :
                                    }
                                        break ;
                                        }    
                                            }
                                                //LOGrAW5( "TINdTP [cFlavors,cPlatesAll]:" , memorySpace.swsTin.cFlavorsF( tinP ) , " " , memorySpace.swsTin.cPlatesAllF( tinP ) , "\r\n" ) ;

                                                //}
                                                //    CONoUTrAW( ostoSay ) ;
                                                //
                                                //    OStEXTAK( ostoSay , "\"\r\n" ) ;
                                                //    OStEXTA(  ostoSay , entry.postThreadName ) ;
                                                //    OStEXTAK( ostoSay , " , \"" ) ;
                                                //    OStEXTC(  ostoSay , entry.osTid , 0 ) ;
                                                //    OStEXTAK( ostoSay , " , " ) ;
                                                //    OStEXTC(  ostoSay , entry.idTin , 0 ) ;
                                                //    OStEXTAK( ostoSay , " , " ) ;
                                                //    OStEXTC(  ostoSay , entry.idThread , 0 ) ;
                                                //    OStEXTAK( ostoSay , "- [idThread,idTin,osTid,postThreadName]: " ) ;
                                                //    OStEXT(  ostoSay , TUCK ) ;
                                                //{
                                                //if( !etThread.strCompareF( tinP , T(entry.postThreadName) , T("tm1F") ) )
        
                                                memorySpace.grab.ungrabF( tinP ) ;

                                                //etThread.traceF( tinP , T("after  ---- [swsTinWhere.cFlavors,swsTinWhere] :    ")+TF2(memorySpace.swsTinWhere.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTinWhere,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etThread.traceF( tinP , T("after  ---- [swsTin.cFlavors     ,swsTin     ] :    ")+TF2(memorySpace.swsTin.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

                                                else etThread.traceF( tinP , T("error: entrty not found in swsTinWhere") ) ;
                                                }
                                                    if( !memorySpace.swsTinWhere ) memorySpace.swsTinWhere.freeF( tinP ) ;
                                                    memorySpace.swsTinWhere.extractF( 0 , tinP ) ;
                                                {
                                                if( ids )
                                                memorySpace.swsTinWhere.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_tinEntryS_F ) ;
                                                ids = 0 ; // memorySpace.swsTin memorySpace.swsTinWhere ARE REDUNDANT SO THAT tmWhereF tmWhereRptF DO NOT TOUCH THE stackC OBJECT THAT tmRptMainF USES

                                                //}
                                                //    while( !ether && ~hDown ) ;
                                                //    }
                                                //        if( !etThread.strCompareF( tinP , T("tmHireF") , T(note.postThreadName) ) ) etThread.traceF( tinP , T("w  [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(wo.idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                //        tinEntryS& wo = *(tinEntryS*)&memorySpace.swsTin.downF( tinP , hDown ) ;
                                                //    {
                                                //    do
                                                //    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                //{
                                                //if( !etThread.strCompareF( tinP , T("tmHireF") , T(note.postThreadName) ) )

                                                else etThread.traceF( tinP , T("error: tinS destruction told but entry not found in swsTin [idThread,postThreadName]: ")+TF2(told.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                }
                                                    if( !memorySpace.swsTin ) memorySpace.swsTin.freeF( tinP ) ;
                                                    memorySpace.swsTin.extractF( 0 , tinP ) ;
                                                    //if( !etThread.strCompareF( tinP , T("tmHireF") , T(note.postThreadName) ) ) etThread.traceF( tinP , T("-- [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(entry.idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                {
                                                if( ids )
                                                memorySpace.swsTin.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_tinEntryS_F ) ;

                                                //}
                                                //    while( !ether && ~hDown ) ;
                                                //    }
                                                //        if( !etThread.strCompareF( tinP , T("tmHireF") , T(note.postThreadName) ) ) etThread.traceF( tinP , T("w  [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(wo.idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                //        tinEntryS& wo = *(tinEntryS*)&memorySpace.swsTin.downF( tinP , hDown ) ;
                                                //    {
                                                //    do
                                                //    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                //{
                                                //if( !etThread.strCompareF( tinP , T("tmHireF") , T(note.postThreadName) ) )

                                                //etThread.traceF( tinP , T("before ---- [swsTinWhere.cFlavors,swsTinWhere] :    ")+TF2(memorySpace.swsTinWhere.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTinWhere,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etThread.traceF( tinP , T("before ---- [swsTin.cFlavors     ,swsTin     ] :    ")+TF2(memorySpace.swsTin.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , told.osPid , told.idThread , 0 } ;
                                                memorySpace.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                                ZE( countT , ids ) ;
                        
                                                etThread.traceF( tinP , T("thread ---- :    ")+TF2(told.idThread,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+T(note.postThreadName) ) ;
                
                                                //if( !etThread.strCompareF( tinP , T("tmHireF") , T(note.postThreadName) ) ) etThread.traceF( tinP , T("-  [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(entry.idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                tinEntryS entry( tinP , note.idSerial , told.osTid , told.osPid , told.idType == ifcIDtYPEtELL_TINdTI , note.ip , note.idTin , told.idThread , note.postThreadName , note.idTinNamed , note.idLineCt , note.idiFileCt ) ;
                                            {
                                            tellInfoTinS& note = *(tellInfoTinS*)pbNote ;
                                        {
                                        if( told.cbNote == sizeof( tellInfoTinS ) )
                                        TELL( "TINdTI TINdTP" )
                                    {
                                    case ifcIDtYPEtELL_TINdTP :
                                    case ifcIDtYPEtELL_TINdTI :
                                    }
                                        break ;
            
                                        }
                                            }
                                                //etThread.traceF( tinP , T("U::: tinS ct told [&told,idThread,postThreadName]: ")+TF2((countT)&told,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(told.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                //LOGrAW5( "TINcTP [cFlavors,cPlatesAll]:" , memorySpace.swsTin.cFlavorsF( tinP ) , " " , memorySpace.swsTin.cPlatesAllF( tinP ) , "\r\n" ) ;

                                                //}
                                                //    CONoUTrAW( ostoSay ) ;
                                                //
                                                //    OStEXTAK( ostoSay , "\"\r\n" ) ;
                                                //    OStEXTA(  ostoSay , entry.postThreadName ) ;
                                                //    OStEXTAK( ostoSay , " , \"" ) ;
                                                //    OStEXTC(  ostoSay , entry.osTid , 0 ) ;
                                                //    OStEXTAK( ostoSay , " , " ) ;
                                                //    OStEXTC(  ostoSay , entry.idTin , 0 ) ;
                                                //    OStEXTAK( ostoSay , " , " ) ;
                                                //    OStEXTC(  ostoSay , entry.idThread , 0 ) ;
                                                //    OStEXTAK( ostoSay , "+ [idThread,idTin,osTid,postThreadName]: " ) ;
                                                //    OStEXT(  ostoSay , TUCK ) ;
                                                //{
                                                //if( !etThread.strCompareF( tinP , T(entry.postThreadName) , T("tm1F") ) )
        
                                                memorySpace.grab.ungrabF( tinP ) ;

                                                //}
                                                //    while( !ether && ~hDown ) ;
                                                //    }
                                                //        if( !etThread.strCompareF( tinP , T("tmHireF") , T(note.postThreadName) ) ) etThread.traceF( tinP , T("w  [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(wo.idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                //        tinEntryS& wo = *(tinEntryS*)&memorySpace.swsTin.downF( tinP , hDown ) ;
                                                //    {
                                                //    do
                                                //    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                //{
                                                //if( !etThread.strCompareF( tinP , T("tmHireF") , T(note.postThreadName) ) )

                                                //etThread.traceF( tinP , T("after  ++++ [swsTinWhere.cFlavors,swsTinWhere] :    ")+TF2(memorySpace.swsTinWhere.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTinWhere,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etThread.traceF( tinP , T("after  ++++ [swsTin.cFlavors     ,swsTin     ] :    ")+TF2(memorySpace.swsTin.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

                                                memorySpace.swsTinWhere.sinkF( tinP , countTC() , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_tinEntryS_F ) ;

                                                //else     { etThread.traceF( tinP , T("++ [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(entry.idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ; }
                                                if( !ids ) { BLAMMO ; }
                                                memorySpace.swsTin.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_tinEntryS_F ) ;
                                                ZE( countT , ids ) ;

                                                //etThread.traceF( tinP , T("before ++++ [swsTinWhere.cFlavors,swsTinWhere] :    ")+TF2(memorySpace.swsTinWhere.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTinWhere,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etThread.traceF( tinP , T("before ++++ [swsTin.cFlavors     ,swsTin     ] :    ")+TF2(memorySpace.swsTin.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , told.osPid , told.idThread , 0 } ;
                                                memorySpace.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;

                                                etThread.traceF( tinP , T("thread ++++ :    ")+TF2(told.idThread,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+T(note.postThreadName) ) ;
                
                                                tinEntryS entry( tinP , note.idSerial , told.osTid , told.osPid , told.idType == ifcIDtYPEtELL_TINcTI , note.ip , note.idTin , told.idThread , note.postThreadName , note.idTinNamed , note.idLineCt , note.idiFileCt ) ;
                                            {
            
                                            tellInfoTinS& note = *(tellInfoTinS*)pbNote ;
                                        {
                                        if( told.cbNote == sizeof( tellInfoTinS ) )
                                        TELL( "TINcTP TINcTI" )
                                    {
                                    case ifcIDtYPEtELL_TINcTI :
                                    case ifcIDtYPEtELL_TINcTP :
                                    }
                                        break ;
                                        //CONoUTrAW( T("log: \"")+T(pbNote)+T("\"\r\n") ) ; //U::
            
                                        stPeriodData.ungrabF( tinP ) ;
                                        //etThread.traceF( tinP , T("after  ++++ [swsLog.cFlavors,swsLog] :    ")+TF2(pd.swsLog.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(pd.swsLog,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                        pd.swsLog << postEntry ; postEntry = 0 ;
                                        //etThread.traceF( tinP , T("before ++++ [swsLog.cFlavors,swsLog] :    ")+TF2(pd.swsLog.cFlavorsF(tinP),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(pd.swsLog,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                        pd.pczLeverThread = pczLever ;
                                        periodDataS& pd = *(periodDataS*)&stPeriodData[ 1 ] ;
                                        stPeriodData.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                        countT pczLever[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , told.idThread , 0 } ;
                                        osTextT* postEntry = postOldC( tinP , etThread , pbNote ) ; ___( postEntry ) ;
                                        TELL( "LOG" )
                                    {
                                    case ifcIDtYPEtELL_LOG :
                                    }
                                        break ;
                                        }
                                            LOGrAW( T("snapshot: \"")+T(pbNote)+T("\"\r\n") ) ; //U::
                                            thirdC::c_strcpyIF( tinP , postSnapShotRequestP , pbNote ) ;
                                        {
                                        if( !setIfZeAM( fliPendingSnapShotRequestP , mask ) )
                                        while( cSpace -- ) mask = mask << 1 | 1 ;
                                        countT cSpace = ifcIDmEMORYsPACE_max - ifcIDmEMORYsPACE_min + 1 ;
                                        ZE( flagsT , mask ) ;

                                        TELL( "SNAPsHOT" )
                                    {
                                    case ifcIDtYPEtELL_SNAPsHOT :
                                {
                                switch( told.idType )

                                //}
                                //    etThread.traceF( tinP , T("telemetry [idType]:    ")+(postSay?T(postSay):TF2(told.idType,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)) ) ;
                                //    const osTextT* postSay = ps3.mapSay( told.idType ) ;
                                //    processGlobal3S& ps3 = processGlobal3S::_processGlobal3I_IF() ;
                                //{
                                //if( bChatter )
                                //
                                //;
                                //    || told.idType == ifcIDtYPEtELL_TINdTI
                                //    || told.idType == ifcIDtYPEtELL_TINdTP
                                //    || told.idType == ifcIDtYPEtELL_TINcTI
                                //       told.idType == ifcIDtYPEtELL_TINcTP
                                //boolT bChatter =
    
                                byteT* pbNote = (byteT*)( &told + 1 ) ;
                            {
                            else
                            }
                                }
                                    }
                                        break ;
                                        etThread.traceF( tinP , T("ifcIDtYPEtELL_GLObEGINdT [osPid]: ")+TF4(told.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
                                    {
                                    case ifcIDtYPEtELL_GLObEGINdT :
                                    }
                                        break ;
                                        if( told.osPid != tinP.osPid ) etThread.osThreadF( TaRG1( tmVultureF ) , told.osPid ) ;
                                        etThread.traceF( tinP , T("ifcIDtYPEtELL_GLObEGINcT [osPid]: ")+TF4(told.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
                                    {
                                    case ifcIDtYPEtELL_GLObEGINcT :
                                {
                                switch( told.idType )
                            {
                            if( !told.cbNote )
        
                            //}
                            //    CONoUTrAW( ostoSay ) ;
                            //
                            //    OStEXTAK( ostoSay , "\r\n" ) ;
                            //    OStEXTA(  ostoSay , processGlobal3S::_processGlobal3I_IF().mapSay( told.idType ) ) ;
                            //    OStEXTAK( ostoSay , " " ) ;
                            //    OStEXTC(  ostoSay , told.idType , 0 ) ;
                            //    OStEXTAK( ostoSay , " " ) ;
                            //    OStEXTC(  ostoSay , told.idTell , 0 ) ;
                            //    OStEXTAK( ostoSay , " bytes [idTell,idType]: " ) ;
                            //    OStEXTC(  ostoSay , cbi , 0 ) ;
                            //    OStEXTAK( ostoSay , " received " ) ;
                            //    OStEXTC(  ostoSay , idCycle , 0 ) ;
                            //    OStEXTAK( ostoSay , " cycle " ) ;
                            //    OStEXTC(  ostoSay , idMemorySpaceP , 0 ) ;
                            //    OStEXTAK( ostoSay , "memory space " ) ;
                            //    OStEXT(   ostoSay , TUCK * 2 ) ;
                            //{
                            //)
                            //    told.idType == ifcIDtYPEtELL_TINdTP
                            //    told.idType == ifcIDtYPEtELL_TINdTI      ||
                            //    told.idType == ifcIDtYPEtELL_TINcTI      ||
                            //    told.idType == ifcIDtYPEtELL_TINcTP      ||
                            //(
                            //if
        
                            stPeriodData.ungrabF( tinP ) ;
                            ++ pd.swEventTally ;
                            pd.cLeverIdType = told.idType ;
                            periodDataS& pd = *(periodDataS*)&stPeriodData[ 1 ] ;
                            stPeriodData.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            TELL( "tallying" )
    
                            __( getNegAM( fingerTail ) - FINGERnEG_BOOK0cwRITEtAIL ) ;
                            if( bQuitEatingP ) break ;
                            while( !fingerTail && !bQuitEatingP ) { ++ s ; thirdC::dosSleepWinkIF( tinP ) ; }
                            countT& fingerTail = *(countT*)( pbi + sizeof( tellS ) + told.cbNote ) ;
        
                            __( getNegAM( told.finger2 ) - FINGERnEG_TELEMETRY2 ) ;
                            __( getNegAM( told.finger1 ) - FINGERnEG_TELEMETRY1 ) ;
                            TELL( "checking fingers" )
                            if( bQuitEatingP ) break ;
                            while( !told.finger2 && !bQuitEatingP ) { ++ s ; thirdC::dosSleepWinkIF( tinP ) ; }
                            tellS& told = *(tellS*)pbi ;
                            TELL( "waiting for finger2 to be set in telemetry" )
        
                            ++ idCycle ;
    
                            //CONoUTrAW5( "tmEatTelemetryF [idMemorySpace,idHamburger]: " , idMemorySpaceP , " " , idHamburger , "\r\n" ) ;
                            countT idHamburger = incv02AM( cHamburgersP ) ; // OPERATOR ++ CAN BE USED FOR SPEED IF ACCURACY IS NOT NEEDED; AS OF THIS WRITING ACCURACY IS NOT NEEDED
                            TELL( "got a hamburger" )
                        {
                        else
                        }
                            cbi = head.cbBooked + sizeof( countT ) ;

                            }
                                __1

                                etThread.delF( tinP , psttd ) ;
                                LOGrAW( T("dump of head:\r\n" DASH79 "\r\n")+T(psttd)+T("\r\n" DASH79 "\r\n") ) ;
                                etThread.strDumpIF( tinP , psttd , (byteT*)&head , sizeof head ) ; ___( psttd ) ;
                                ZE( strokeS* , psttd ) ;

                                LOGrAW9( "tmEatTelemetryF bad header [bBad1,bBad2,bBad3,bBad4]: " , bBad1 , "    " , bBad2 , "    " , bBad3 , "    " , bBad4 , "\r\n" ) ;
                            {
                            if( bBad1 || bBad2 || bBad3 || bBad4 )
        
                            boolT bBad4 = !head.cbBooked ;
                            boolT bBad3 = head.idFormat - ifcIDfORMAT_BOOK0hEAD ;
                            boolT bBad2 = getNegAM( head.finger2 ) - FINGERnEG_BOOK0cwRITEhEAD2 ;
                            boolT bBad1 = getNegAM( head.finger1 ) - FINGERnEG_BOOK0cwRITEhEAD1 ;

                            if( bQuitEatingP ) break ;
                            while( !head.finger2 && !bQuitEatingP ) { ++ s ; thirdC::dosSleepWinkIF( tinP ) ; }
                            telemetryBookHeadS& head = *(telemetryBookHeadS*)pbi ;
                            TELL( "parsing head" )
                        {
                        if( bBookHead )
        
                        __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG
                        //etThread.traceF( tinP , T("tmEatTelemetryF: readF returned telemetry") ) ; //U:: TO FIND A BUG
                        TELL( "readF returned telemetry" )
                    {
                    else
                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;
                        TELL( "readF returned null" )
                    {
                    if( !pbi )
    
                    //etThread.traceF( tinP , T("tmEatTelemetryF / 7") ) ;
                    //tinP.pc Utility[ 0 ] -- ; //U::TO FIND A BUG
                    boolT bDelete = bksTelemetry.readF( tinP , pbi , cbi , hRead , flBOOKScrEAD_STILLhUNGRYiSoK ) ;
                    //etThread.traceF( tinP , T("eating telemetry at [idDebug,off,idBook]:    ")+TF2(idDebug,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(ch.c1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(ch.c2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    HANDLEaPPnOTEScOUNTcLASS ch = hRead ;
                    //tinP.pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
                    //etThread.traceF( tinP , T("tmEatTelemetryF / 8") ) ;
                    TELL( "waiting to read a new telemetry item" )

                    }
                        countT foo = 2 ;
                    {
                    if( ++ idDebug == 0x90 )

                    handleC hReadSave = hRead ;
                    countT cbiSave = cbi ;
                {
                while( !bQuitEatingP && !POOP )
                TELL( "eating 1" )
            {
            while( !bQuitEatingP && !POOP )
            //etThread.traceF( tinP , T("tmEatTelemetryF / 9") ) ;
            ZE( countT , idDebug ) ;
            TELL( "eating 0" )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            ZE( countT , idCycle ) ;
            boolT bBookHead = 1 ;
            countT cbi = sizeof( telemetryBookHeadS ) ;
            ZE( const byteT* , pbi ) ;
            handleC hRead( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
            TELL( "preparing to eat" )
        {
        if( !(const poopC&)bksTelemetry )

        THREADmODE3rESTORE
        booksC bksTelemetry( tinP , TAG( TAGiDnULL ) , "bksTelemetry" , ifcIDsTATEsPACE_MULTIPLEaDAMS , idMemorySpaceP == ifcIDmEMORYsPACE_KERNEL ? flBOOKSc_null : flBOOKSc_USEgRABuNIVERSEoVERRIDE , 0 , 0 , 0 , 0 , 0 , idMemorySpaceP , &bQuitEatingP ) ;
        THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )

        //U:: THE NEXT LINE USED TO SPECIFY THE DELETE FLAG, BUT AS OF 20131222@1558 THIS CAUSES FAILURES ; DELETE FLAG REMOVED WITHOUT ANALYSIS

        TELL( "constructing telemetry books" ) //THE NEXT LINE WILL BLOCK UNTIL A BOOK ENTRY IS WRITTEN , SO I WILL NOT BE ABLE TO QUIT UNTIL THAT HAPPENS
    {

    //U::etThread.osThreadF( tinP , countTC() , tmReportF , &sgnDone_tmReportF_ , flTHREADlAUNCH_null , 0 , (countT)&bQuitEatingP , idMemorySpaceP , (countT)&stPeriodData , (countT)&memorySpace , idMinuteZeP , (countT)&fliPendingSnapShotRequestP , (countT)postSnapShotRequestP , (countT)&bCompileReportP ) ;
    signC sgnDone_tmReportF_( tinP , TAG( TAGiDnULL ) ) ;
    TELL( "launching tmReportF" )

    new( 0 , tinP , (byteT*)&stPeriodData[ 1 ] , sizeof( periodDataS ) ) periodDataS( tinP , etThread ) ;
    stPeriodData << (byteT*)0 ;
    stackC stPeriodData( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB|flSTACKc_ALLOWzE , sizeof( periodDataS ) ) ;
    TELL( "constructing period data structure" )

    swMemorySpaceP.ungrabF( tinP ) ;
    memorySpaceS& memorySpace = *(memorySpaceS*)&(countT&)swMemorySpaceP ;
    cLeverIdMemoryP = idMemorySpaceP ;
    __( !swMemorySpaceP.idSlotOfLeverF( tinP , idMemorySpaceP ) ) ;
    swMemorySpaceP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    TELL( "getting memory space structure" )

    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
    TELL( "setting rush" )

    //if( idMemorySpaceP == ifcIDmEMORYsPACE_KERNEL ) etThread.osThreadF( TaRG1( tmYellF ) ) ;

    //CONoUTrAW3( "tmEatTelemetryF [idMemorySpaceP]: " , idMemorySpaceP , "\r\n" ) ;

    TN( tb4 , "    " ) ;

    tinP.c4Tell.c1 = idMemorySpaceP ;

    etThread.delF( tinP , pcArgP ) ;
    batonC&      bCompileReportP            =  *(batonC*)pcArgP[ 8 ] ;
    osTextT*     postSnapShotRequestP       =  (osTextT*)pcArgP[ 7 ] ;
    flagsT&      fliPendingSnapShotRequestP =  *(flagsT*)pcArgP[ 6 ] ;
    countT&      cHamburgersP               =  *(countT*)pcArgP[ 5 ] ;
    countT       idMinuteZeP                =            pcArgP[ 4 ] ;
    switchC&     swMemorySpaceP             = *(switchC*)pcArgP[ 3 ] ;
    countT&      cLeverIdMemoryP            =  *(countT*)pcArgP[ 2 ] ;
    countT       idMemorySpaceP             =            pcArgP[ 1 ] ;
    boolT&       bQuitEatingP               =   *(boolT*)pcArgP[ 0 ] ;
    countT* pcArgP = (countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmEatTelemetryF )

DONE( tmCloakF )
}
    }
        etThread.traceF( tinP , T("this computer has been told to shut down") ) ;    
        etThread.osFireF( tinP , 1 ) ;
        etThread.traceF( tinP , T("shutting down this computer for security") ) ;    
        etThread.traceF( tinP , T("i have not yet been fired, so cloak's death is unexplained") ) ;
    {
    if( !ether )
    ether.osSleepF( tinP , TOCK ) ;
    etThread.traceF( tinP , T("cloak has died ; napping for a TOCK") ) ;

    //U:: TEST idDeathType AND IF CLOAK WAS MURDERED THEN DON'T NAP BEFORE SHUTTING DOWN
    //U:: BUG: idDeathType IS 0 WHEN CLOAK IS KILLED WITHIN PROCESS EXPLORER
    etThread.traceF( tinP , T("error: cloak has died [idDeathType]:    ")+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;    
    countT idDeathType = etThread.ifcHireF( tinP , T("ifcIDaDAM_MONITOR") , ifcIDaDAM_CLOAK , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO | flHIRE_WAIT , nicNameC() ) ;
    etThread.traceF( tinP , T("hiring cloak") ) ;
{
if( pTaskP )
TASK( tmCloakF )

DONE( tmYellF )
}
    //CONoUTrAW( "tmYell/-\r\n" ) ;

    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;

        //CONoUTrAW( "tmYell/yell/-\r\n" ) ;
        THREADmODE1rESTORE
        YELL( "yippee!" ) ;
        THREADmODE1oN( flTHREADmODE1_YELL )
        //CONoUTrAW( "tmYell/yell/+\r\n" ) ;

        //etThread.beeClickF( tinP ) ;
    {
    while( !ether )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    //CONoUTrAW( "tmYell/+\r\n" ) ;
{
if( pTaskP )
TASK( tmYellF )

DONE( tmVultureF )
}
    }
        CloseHandle( osh ) ;

        etThread.traceF( tinP , T("tmVultureF [osPid,rc]:")+TF4(osPidPrey,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(": process terminated with code    ")+TF2((countT)rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("    ")+TF4((countT)rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
        bOk = GetExitCodeProcess( osh , &rc ) ;
        ZE( DWORD , rc ) ;

        boolT bOk = WaitForSingleObject( osh , INFINITE ) ;
    {
    if( osh )
    HANDLE osh = OpenProcess( PROCESS_TERMINATE | SYNCHRONIZE | PROCESS_QUERY_LIMITED_INFORMATION , 0 , osPidPrey ) ;

    etThread.traceF( tinP , T("tmVultureF [osPid]:")+TF4(osPidPrey,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(": waiting for death") ) ;
    const countT osPidPrey = pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmVultureF )

DONE( tmReportF )
}
    etRock.traceF( tinP , T("tmReportF 0/ ") ) ; //U:: TO FIND A BUG
    }
//#endif
        }
            bCompileReportP.ungrabF( tinP ) ;

            }
                }
                    }
                        //etRock.traceF( tinP , T("tmReportF 1/ ") ) ; //U:: TO FIND A BUG
                        CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  0\r\n" ) ;
                        //CONoUTrAW5( "tmReportF idMemorySpace:" , idMemorySpaceP , " idMinute:" , idMinute , " written\r\n" ) ;

                        PUSE( tinP , pbBookOut ) ;
                        }
                            bkReport.writeF( tinP , pbBookOut , cbBookOut , 0 , 0 , flBOOKScwRITE_HEADfINGER1 | flBOOKScwRITE_HEADiDfORMAT | flBOOKScwRITE_HEADcBdATA | flBOOKScwRITE_HEADfINGER2 | flBOOKScwRITE_TAILfINGER | flBOOKScwRITE_ALLOWoDDlENGTH ) ;

                            //LOGrAW3( "report written to disk []: " , idMemorySpaceP , "\r\n" ) ;
                            //etRock.traceF( tinP , T("tmReportF 2/ ") ) ; //U:: TO FIND A BUG
                        {
                        if( !bQuitMonitorP )

                        }
                            }
                                _OUT_
                                }
                                    etThread.delF( tinP , postr ) ;
                                    etThread.fileWriteF( tinP , hFile1 , postr , costr ) ;
                                        
                                    etThread.delF( tinP , psttr ) ;
                                    countT costr = etThread.strMakeF( tinP , postr , psttr ) ; ___( postr ) ;
                                    ZE( osTextT* , postr ) ;
                                
                                    sRpt >> psttr ; ___( psttr ) ;
                                    ZE( strokeS* , psttr ) ;
                                {
                                while( sRpt )

                                sReports >> sRpt ;
                                soulC sRpt( tinP , TAG( TAGiDnULL ) ) ;
                                _INoLD_
                            {
                            while( sReports && !bQuitMonitorP )
                            OPENfILEwRITE1( tFile )
                        {
                        if( !bQuitMonitorP )

                        //REMOVE: etThread.boxPutF( tinP , tFile , (osTextT*)sReports , sReports.csF( tinP ) ) ;

                        //LOGrAW( "\"\r\n" ) ;
                        //LOGrAW( tFile ) ;
                        //LOGrAW5( "tmReportF idMemorySpace:" , idMemorySpaceP , " idMinute:" , idMinute , " writing file \"" ) ;

                        //CONoUTrAW( "\"\r\n" ) ;
                        //CONoUTrAW( tFile ) ;
                        //CONoUTrAW5( "tmReportF idMemorySpace:" , idMemorySpaceP , " idMinute:" , idMinute , " writing file \"" ) ;
                        CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  1\r\n" ) ;
                        //etRock.traceF( tinP , T("tmReportF 3/ ") ) ; //U:: TO FIND A BUG

                        }
                            if( !fliPendingSnapShotRequestP ) *postSnapShotRequestP = 0 ;

                            }
                                if( oldf == setIfEqualsAM( fliPendingSnapShotRequestP , newf , oldf ) ) break ;
                                flagsT newf = oldf & ~fliMaskPending ;
                                flagsT oldf = fliPendingSnapShotRequestP ;
                            {
                            for(;;)
                        {
                        if( bSnapShot )
                        //etRock.traceF( tinP , T("tmReportF 4/ ") ) ; //U:: TO FIND A BUG

                        tFile += T(".rpt.kernel.idMemorySpace.")+TF3(idMemorySpaceP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,3)+T(".")+TF2(idMinute,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE)+T(".txt") ;
                        else                                                              tFile += T("minute") ;
                        if( bSnapShot || F(home.flagsUtility) & flHOMEsuTILITY_SNAPsHOT ) tFile += textC(ifcIDtEXTgEN_TIMEnOW,tinP,TAG(TAGiDnULL))+T(".")+T(postSnapShotRequestP&&*postSnapShotRequestP?postSnapShotRequestP:"snapshot") ;
                        TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/reports/") ;
                        //etRock.traceF( tinP , T("tmReportF 5/ ") ) ; //U:: TO FIND A BUG

                        //LOGrAW3( "tmReportF 2 [flHOMEsuTILITY_SNAPsHOT]: " , F(home.flagsUtility) & flHOMEsuTILITY_SNAPsHOT , "\r\n" ) ;

                        //20121126@1750: I VAGUELY RECALL THAT I FOUND THIS BUG; HAVEN'T SEEN IT LATELY
                        //U::BUG: boxPutF OCCASIONALLY FAILS: diskMakeDirF/lath prior slash is at position less than 4: "///d/"
                        //etRock.traceF( tinP , T("tmReportF 6/ ") ) ; //U:: TO FIND A BUG

                        sReports << sRptTin ;
                        sReports << sRptNapkin ;
                        sReports << sRptSex ;
                        sReports << sRptAdd ;
                        sReports << sRptLog ;
                        sReports << sRptEvent ;
                        sReports << sRptTitle ;
                        soulC sReports(   tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.reports"    ) ;
                        //etRock.traceF( tinP , T("tmReportF 7/ ") ) ; //U:: TO FIND A BUG
                    {
                    if( !bQuitMonitorP )

                    }
                        etThread.delF( tinP , psttRpt ) ;
                        sRptAdd << (strokeS*)( T("\r\n\r\nProcess [osPid]:    ")+TF2(cLeverGrainCode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF4(cLeverGrainCode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(psttRpt) ) ;

                        etThread.strFuseF( tinP , psttRpt , tcr ) ;
                        }
                            etThread.strFuseF( tinP , psttRpt , T(post2) ) ;
                            osTextT post2[ 2 ] = { pbzGrainCode[ offg ] , 0 } ;

                            }
                                etThread.strFuseF( tinP , psttRpt , TF3(offRow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,3) ) ;
                                }
                                    etThread.strFuseF( tinP , psttRpt , tcr ) ;
                                    offRow ++ ;
                                {
                                if( offg )
                            {
                            if( !( offg % cColsGrainCode ) )
                        {
                        for( countT offg = 0 ; offg < cbGrainCode && !bQuitMonitorP ; offg ++ )
                        ZE( countT , offRow ) ;

                        etThread.strMakeF( tinP , psttRpt , (const strokeS*)T("\r\n\r\n") , cbGrainCode << 1 ) ; ___( psttRpt ) ;
                        ZE( strokeS* , psttRpt ) ;

                        byteT* pbzGrainCode = (byteT*)&(countT&)sw_pbzGrainCode ;
                        cLeverGrainCode = sw_pbzGrainCode.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !bQuitMonitorP ; idf ++ )
                    countT cFlavors = sw_pbzGrainCode.cFlavorsF( tinP ) ;

                    TN( tcr  , "\r\n" ) ;
                    CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  2\r\n" ) ;
                    //etRock.traceF( tinP , T("tmReportF 8/ ") ) ; //U:: TO FIND A BUG

                    stPeriodDataP.ungrabF( tinP ) ;
                    }
                        }
                            sRptLog << (strokeS*)( T("\r\n") ) ;
                            while( ~hWalk ) ;
                            do sRptLog << (strokeS*)( T((osTextT*)pd.swsLog.downF(tinP,hWalk))+T("\r\n") ) ;
                            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            
                            sRptLog << (strokeS*)( T(pd.pczLeverThread)+T(":\r\n\r\n") ) ;
                            pd.pczLeverThread = (const countT*)pd.swsLog.leverF( tinP , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cFlavors && !bQuitMonitorP ; idf ++ )
                        cFlavors = pd.swsLog.cFlavorsF( tinP ) ;

                        sRptEvent << (strokeS*)( TF3(total,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("total\r\n") ) ;
                        }
                            total += tally ;
                            sRptEvent << (strokeS*)( TF3(tally,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T(processGlobal3S::_processGlobal3I_IF().mapSay(idType))+T("\r\n") ) ;
                            countT tally = pd.swEventTally ;
                            countT idType = pd.cLeverIdType = pd.swEventTally.leverF( tinP , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cFlavors && !bQuitMonitorP ; idf ++ )
                        ZE( countT , total ) ;
                        countT cFlavors = pd.swEventTally.cFlavorsF( tinP ) ;

                        periodDataS& pd = *(periodDataS*)&stPeriodDataP[ 2 ] ;
                    {
                    if( stPeriodDataP > 1 && !bQuitMonitorP )

                    //U::CONJ: THIS IS OBSOLETED BY THE PRECEDING SNIP: stPeriodDataP.purgeF( tinP , 0x10 ) ; //U::DESTROY THE periodDataS INSTANCES

                    }
                        while( ~hWalk && -- cToDo ) ;
                        }
                            stPeriodDataP.extractF( 0 , tinP ) ;
                            DELzOMBIE( ppd ) ;
                            periodDataS* ppd = (periodDataS*)&stPeriodDataP.upF( tinP , hWalk ) ;
                        {
                        do
                        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        countT cToDo = stPeriodDataP - CpERIODSrETAIN ;
                    {
                    if( stPeriodDataP > CpERIODSrETAIN )

                    new( 0 , tinP , (byteT*)&stPeriodDataP[ 1 ] , sizeof( periodDataS ) ) periodDataS( tinP , *stPeriodDataP.third.third_pEtherContainsMe_F() ) ;
                    stPeriodDataP << (byteT*)0 ;
                    CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  3\r\n" ) ;

                    stPeriodDataP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  4\r\n" ) ;
                    //etRock.traceF( tinP , T("tmReportF 9/ ") ) ; //U:: TO FIND A BUG
                {
                if( !bQuitMonitorP )

                swTinCopy.freeAllF( tinP ) ;
                //etRock.traceF( tinP , T("tmReportF a/ 0") ) ; //U:: TO FIND A BUG
                }
                    PUSE( tinP , pbBookOut ) ;
                    }
                        //U::__( pbBookOut + cbBookOut - pbc ) ;

                        }
                            countT foo = 2 ;
                        {
                        if( pbBookOut + cbBookOut - pbc )

                        //etRock.traceF( tinP , T("tmReportF a/ 1") ) ; //U:: TO FIND A BUG
                        }
                            }
                                //etRock.traceF( tinP , T("tmReportF a/ 2") ) ; //U:: TO FIND A BUG
                                sRptTin << (strokeS*)( T("\r\n") ) ;
                                }
                                    sRptTin << (strokeS*)( T(ostoRpt) ) ;
                                    OStEXTAK( ostoRpt , "\r\n" ) ;
                                    }
                                        OStEXTA( ostoRpt , postTitle ) ;
                                    {
                                    if( postTitle )
                                    const osTextT* postTitle = processGlobal7S::_processGlobal7I_IF().source.postFileTitleF( tinP , processGlobal7S::_processGlobal7I_IF().source.idFileRankF( tinP , idiFile ) ) ;
                                    OStEXTAK( ostoRpt , "    " ) ;
                                    OStEXTCmIN( ostoRpt , idiFile , 7 ) ;
                                    OStEXTAK( ostoRpt , "." ) ;
                                    OStEXTCmIN( ostoRpt , idLine , 4 ) ;
                                    OStEXTAK( ostoRpt , "'th: " ) ;
                                    OStEXTC( ostoRpt , tinCopy.pIdInNest[ offez ] , ' ' ) ;
                                    OStEXTAK( ostoRpt , " | " ) ;
                                    OStEXTC( ostoRpt , tinCopy.pEIPInNest[ offez ] , ' ' ) ;
                                    OStEXT( ostoRpt , OFFsLOTtINnESTmAX * TUCK )
                                        
                                    countT idiFile = tinCopy.monitor.pLFnest[ offe + 1 ] ;
                                    countT idLine  = tinCopy.monitor.pLFnest[ offe     ] ;
                                    countT offe = ( idn & OFFsLOTtINnESTmAX ) << 1 ;
                                    countT offez = idn & OFFsLOTtINnESTmAX ;
                                {
                                for( countT idn = tinCopy.monitor.cInNest ; idn >= idnf && !bQuitMonitorP ; idn -- )
                                if( (sCountT)idnf < 1 ) idnf = 1 ;
                                countT idnf = tinCopy.monitor.cInNest - OFFsLOTtINnESTmAX ;
                                if( bDash ) sRptTin << (strokeS*)( T(DASH256 "\r\n") ) ;
                                //etRock.traceF( tinP , T("tmReportF a/ 3") ) ; //U:: TO FIND A BUG
                    
                                }
                                    PUSE( tinP , pbCopy ) ;
                                    }
                                        }
                                            }
                                                }
                                                    BLAMMO ;
                                                    //2009.12.20: 105 tmReportF unexpected value [pbg->idTypeCt]: 0
                                                    LOGrAW3( "105 tmReportF unexpected value [pbg->idTypeCt]: " , pbg->idTypeCt , "\r\n" ) ;
                                                {
                                                default :
                                                }
                                                    break ;
                                                    //etRock.traceF( tinP , T("tmReportF a/ 4") ) ; //U:: TO FIND A BUG
                                                    PUSE( tinP , pbCopy ) ;
                                                    }
                                                        }
                                                            countT foo = 2 ; //U::
                    
                                                            grabotC& grabot = *(grabotC*)pbCopy ;
                                                        {
                                                        if( bOk )
                                                        thirdC::dosReadProcessMemoryIF( tinP , pbCopy , sizeof( grabotC ) , bOk , (voidT*)tinCopy.monitor.pPanLifiGrabbing[ 0 ] , tinCopy.osPid ) ;
                                                        ZE( boolT , bOk ) ;
                                                    {
                                                    if( pbCopy )
                                                    PUSE.newF( tinP , LF , pbCopy , sizeof( grabotC ) ) ; ___( pbCopy ) ;
                                                    ZE( byteT* , pbCopy ) ;
                                                    //etRock.traceF( tinP , T("tmReportF a/ 5") ) ; //U:: TO FIND A BUG
                                                {
                                                case ifcIDtYPEdERIVEDbASEgRABc_grabotC :
                                                }
                                                    break ;
                                                    //etRock.traceF( tinP , T("tmReportF a/ 6") ) ; //U:: TO FIND A BUG
                                                    PUSE( tinP , pbCopy ) ;
                                                    }
                                                        }
                                                            countT foo = 2 ; //U::
                    
                                                            grabitC& grabit = *(grabitC*)pbCopy ;
                                                        {
                                                        if( bOk )
                                                        thirdC::dosReadProcessMemoryIF( tinP , pbCopy , sizeof( grabitC ) , bOk , (voidT*)tinCopy.monitor.pPanLifiGrabbing[ 0 ] , tinCopy.osPid ) ;
                                                        ZE( boolT , bOk ) ;
                                                    {
                                                    if( pbCopy )
                                                    PUSE.newF( tinP , LF , pbCopy , sizeof( grabitC ) ) ; ___( pbCopy ) ;
                                                    ZE( byteT* , pbCopy ) ;
                                                    //etRock.traceF( tinP , T("tmReportF a/ 7") ) ; //U:: TO FIND A BUG
                                                {
                                                case ifcIDtYPEdERIVEDbASEgRABc_grabitC :
                                                }
                                                    break ;
                                                    //etRock.traceF( tinP , T("tmReportF a/ 8") ) ; //U:: TO FIND A BUG
                                                    PUSE( tinP , pbCopy ) ;
                                                    //etRock.traceF( tinP , T("tmReportF a/ 9 / 0") ) ; //U:: TO FIND A BUG
                                                    }
                                                        //etRock.traceF( tinP , T("tmReportF a/ 9 / 1") ) ; //U:: TO FIND A BUG
                                                        }
                                                            //etRock.traceF( tinP , T("tmReportF a/ 9 / 2") ) ; //U:: TO FIND A BUG
                                                            }
                                                                //etRock.traceF( tinP , T("tmReportF a/ 9 / 3") ) ; //U:: TO FIND A BUG
                                                                }
                                                                    //etRock.traceF( tinP , T("tmReportF a/ 9 / 4") ) ; //U:: TO FIND A BUG
                                                                    sRptTin << (strokeS*)( T("this is grabbed by a thread that is gone [osTid]: ")+TF1(grab.osTidF())+T("\r\n") ) ;
                                                                    //etRock.traceF( tinP , T("tmReportF a/ 9 / 5") ) ; //U:: TO FIND A BUG
                                                                {
                                                                else
                                                                }
                                                                    //etRock.traceF( tinP , T("tmReportF a/ 9 / 6") ) ; //U:: TO FIND A BUG
                                                                    sRptTin << (strokeS*)( T("this is grabbed by osTid:")+TF1(grab.osTidF())+T(" idAdamRoot:")+TF1(idAdamRoot)+T(" idAdam:")+TF1(idAdam)+T(" idThread:")+TF1(tinCopy.monitor.idThread)+T(" postThreadName:\"")+TF1(tinCopy.postThreadName)+T("\"\r\n") ) ;
                                                                    //etRock.traceF( tinP , T("tmReportF a/ 9 / 7") ) ; //U:: TO FIND A BUG

                                                                    }
                                                                        //etRock.traceF( tinP , T("tmReportF a/ 9 / 8") ) ; //U:: TO FIND A BUG
                                                                        PUSE( tinP , pbCopy ) ;
                                                                        //etRock.traceF( tinP , T("tmReportF a/ 9 / 9") ) ; //U:: TO FIND A BUG
                                                                        }
                                                                            //etRock.traceF( tinP , T("tmReportF a/ 9 / a") ) ; //U:: TO FIND A BUG
                                                                            }
                                                                                //etRock.traceF( tinP , T("tmReportF a/ 9 / b") ) ; //U:: TO FIND A BUG
                                                                                PUSE( tinP , pbCopy ) ;
                                                                                }
                                                                                    //etRock.traceF( tinP , T("tmReportF a/ 9 / c") ) ; //U:: TO FIND A BUG
                                                                                    }
                                                                                        idAdamRoot = pg1.idAdamRoot ;
                                                                                        processGlobal1S& pg1 = *(processGlobal1S*)pbCopy ;
                                                                                    {
                                                                                    if( bOk )
                                                                                    thirdC::dosReadProcessMemoryIF( tinP , pbCopy , sizeof( processGlobal1S ) , bOk , (voidT*)ag1.pProcessGlobal1 , tinCopy.osPid ) ;
                                                                                    ZE( boolT , bOk ) ;
                                                                                    //etRock.traceF( tinP , T("tmReportF a/ 9 / d") ) ; //U:: TO FIND A BUG
                                                                                {
                                                                                if( pbCopy )
                                                                                //etRock.traceF( tinP , T("tmReportF a/ 9 / e") ) ; //U:: TO FIND A BUG
                                                                                PUSE.newF( tinP , LF , pbCopy , sizeof( processGlobal1S ) ) ; ___( pbCopy ) ;
                                                                                ZE( byteT* , pbCopy ) ;
                        
                                                                                idAdam = ag1.idAdam ;
                                                                                adamGlobal1S& ag1 = *(adamGlobal1S*)pbCopy ;
                                                                                //etRock.traceF( tinP , T("tmReportF a/ 9 / f") ) ; //U:: TO FIND A BUG
                                                                            {
                                                                            if( bOk )
                                                                            thirdC::dosReadProcessMemoryIF( tinP , pbCopy , sizeof( adamGlobal1S ) , bOk , (voidT*)tinCopy.pAdamGlobal1 , tinCopy.osPid ) ;
                                                                            ZE( boolT , bOk ) ;
                                                                            //etRock.traceF( tinP , T("tmReportF a/ 9 / g") ) ; //U:: TO FIND A BUG
                                                                        {
                                                                        if( pbCopy )
                                                                        //etRock.traceF( tinP , T("tmReportF a/ 9 / h") ) ; //U:: TO FIND A BUG
                                                                        PUSE.newF( tinP , LF , pbCopy , sizeof( adamGlobal1S ) ) ; ___( pbCopy ) ;
                                                                        ZE( byteT* , pbCopy ) ;
                                                                        //etRock.traceF( tinP , T("tmReportF a/ 9 / i") ) ; //U:: TO FIND A BUG
                                                                    {
                                                                    ZE( countT , idAdam ) ;
                                                                    ZE( countT , idAdamRoot ) ;
                    
                                                                    tinS&   tinCopy     = *(tinS*)( pbFrom + sizeof( copyHeadS ) ) ;
                                                                    copyHeadS& head     = *(copyHeadS*)pbFrom ;
                                                                    byteT* pbFrom = (byteT*)&(countT&)swTinCopy ;
                                                                    cLeverOsTid = grab.osTidF() ;
                                                                    //etRock.traceF( tinP , T("tmReportF a/ 9 / j") ) ; //U:: TO FIND A BUG
                                                                {
                                                                if( swTinCopy.idSlotOfLeverF( tinP , grab.osTidF() ) )
                                                                //etRock.traceF( tinP , T("tmReportF a/ 9 / k") ) ; //U:: TO FIND A BUG
                                                            {
                                                            if( grab.cGrabbedF() )
                    
                                                            grabC& grab = *(grabC*)pbCopy ;
                                                            //etRock.traceF( tinP , T("tmReportF a/ 9 / l") ) ; //U:: TO FIND A BUG
                                                        {
                                                        if( bOk )
                                                        thirdC::dosReadProcessMemoryIF( tinP , pbCopy , sizeof( grabC ) , bOk , (voidT*)tinCopy.monitor.pPanLifiGrabbing[ 0 ] , tinCopy.osPid ) ;
                                                        ZE( boolT , bOk ) ;
                                                        //etRock.traceF( tinP , T("tmReportF a/ 9 / m") ) ; //U:: TO FIND A BUG
                                                    {
                                                    if( pbCopy )
                                                    //etRock.traceF( tinP , T("tmReportF a/ 9 / n") ) ; //U:: TO FIND A BUG
                                                    PUSE.newF( tinP , LF , pbCopy , sizeof( grabC ) ) ; ___( pbCopy ) ;
                                                    ZE( byteT* , pbCopy ) ;
                                                    //etRock.traceF( tinP , T("tmReportF a/ 9 / o") ) ; //U:: TO FIND A BUG
                                                {
                                                case ifcIDtYPEdERIVEDbASEgRABc_grabC :
                                            {
                                            switch( pbg->idTypeCt ) //CS:CODEsYNC: 00104c9 1050104.2
                                        {
                                        if( pbg && !bQuitMonitorP )
                                        //etRock.traceF( tinP , T("tmReportF a/ a") ) ; //U:: TO FIND A BUG
            
                                        }
                                            if( !bOk || getNegAM( recheck ) != FINGERnEG_GRABc ) pbg = 0 ;
                                            thirdC::dosReadProcessMemoryIF( tinP , (byteT*)&recheck , sizeof( recheck ) , bOk , (voidT*)tinCopy.monitor.pPanLifiGrabbing[ 0 ] , tinCopy.osPid ) ;
                                            ZE( countT , recheck ) ;
                                            bOk = 0 ;
                                        {
                                        else
                                        if( !bOk || getNegAM( pbg->finger ) != FINGERnEG_GRABc ) pbg = 0 ;
                                        thirdC::dosReadProcessMemoryIF( tinP , pbCopy , sizeof( baseGrabC ) , bOk , (voidT*)tinCopy.monitor.pPanLifiGrabbing[ 0 ] , tinCopy.osPid ) ;
                                        ZE( boolT , bOk ) ;
            
                                        baseGrabC* pbg = (baseGrabC*)pbCopy ;
                                        //etRock.traceF( tinP , T("tmReportF a/ b") ) ; //U:: TO FIND A BUG
                                    {
                                    if( pbCopy && !bQuitMonitorP )
                                    PUSE.newF( tinP , LF , pbCopy , sizeof( baseGrabC ) ) ; ___( pbCopy ) ;
                                    ZE( byteT* , pbCopy ) ;
            
                                    bDash |= reportGrabF( tinP , sRptTin , T("grabbing:") , pcPanLifi ) ;
                                    //countT pcPanLifi[] = { 0 , tinCopy.monitor.pPanLifiGrabbing[ 1 ] , tinCopy.monitor.pPanLifiGrabbing[ 2 ] } ; // THE PAN IS NOT USED BECAUSE HERE IT IS ALWAYS baseGrabC*, UNLIKE WHAT IS DONE IN THE GRABBED ARRAY
                                    countT pcPanLifi[] = { tinCopy.monitor.pPanLifiGrabbing[ 0 ] , tinCopy.monitor.pPanLifiGrabbing[ 1 ] , tinCopy.monitor.pPanLifiGrabbing[ 2 ] } ;
                                    //etRock.traceF( tinP , T("tmReportF a/ c") ) ; //U:: TO FIND A BUG
                                {
                                if( tinCopy.monitor.pPanLifiGrabbing[ 0 ] && !bQuitMonitorP )
                                //etRock.traceF( tinP , T("tmReportF a/ d") ) ; //U:: TO FIND A BUG
            
                                }
                                    }
                                        }
                                            bDash |= reportGrabF( tinP , sRptTin , T("got     :") , tinCopy.pPanLifiRecurseGrabbedLevel + off , tinCopy.osPid ) ;
                                        {
                                        if( tinCopy.pPanLifiRecurseGrabbedLevel[ off ] )
                                    {
                                    for( countT off = 0 ; off < offEnd ; off += 5 )
                                    const countT offEnd = OFFgRABBEDmAX * 5 ;
                                {
                                if( tinCopy.monitor.cGrabbed )
                    
                                ZE( boolT , bDash ) ;
                            
                                sRptTin << (strokeS*)( TF3(tinCopy.monitor.idThread,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TP(tinCopy.postThreadName,0x10)+T(" ")+TF3(tinCopy.monitor.idStep,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TF3(head.cStepsNew,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+tc4+T(tinCopy.postTell)+T("\r\n" DASH256 "\r\n") ) ;
                    
                                //CONoUTrAW( TF2(idCycle,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(": ")+TF2(head.idAdamRoot,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".")+TF2(head.idAdam,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" ")+T(tinCopy.postThreadName)+T("\r\n") ) ;
                    
                                }
                                    sRptTin << (strokeS*)( T("\r\n")+TF2(head.idAdamRoot,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("/")+TF2(head.idAdam,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n\r\n") ) ;
                    
                                    idAdamLath     = head.idAdam ;
                                    idAdamRootLath = head.idAdamRoot ;
                                {
                                if( idAdamLath != head.idAdam || idAdamRootLath != head.idAdamRoot )
            
                                WRITEaRRAY( pIdProgressNest )                                                                                                                                               /*L*/
                                WRITEaRRAY( pEIPInNest )                                                                                                                                                    /*K*/
                                WRITEaRRAY( pIdInNest )                                                                                                                                                     /*J*/
                                WRITEaRRAY( pFlagsThreadLevelMode )                                                                                                                                         /*I*/
                                WRITEaRRAY( pLFstep )                                                                                                                                                       /*H*/
                                WRITEaRRAYmONITOR( pLFnest )                                                                                                                                                       /*G*/
                
                                costai = 1 + thirdC::c_strlenIF( tinP , tinCopy.postTellIf        ) ; thirdC::c_memcpyIF( tinP , pbc , tinCopy.postTellIf       , costai )  ; pbc += costai ;               /*F*/
                                costai = 1 + thirdC::c_strlenIF( tinP , tinCopy.postTellWait      ) ; thirdC::c_memcpyIF( tinP , pbc , tinCopy.postTellWait     , costai )  ; pbc += costai ;               /*E*/
                                costai = 1 + thirdC::c_strlenIF( tinP , tinCopy.postTell          ) ; thirdC::c_memcpyIF( tinP , pbc , tinCopy.postTell         , costai )  ; pbc += costai ;               /*D*/
                                costai = 1 + tc4.csF( tinP )                                        ; thirdC::c_memcpyIF( tinP , pbc , tc4                      , costai )  ; pbc += costai ;               /*M*/
                                costai = 1 + thirdC::c_strlenIF( tinP , tinCopy.postThreadName    ) ; thirdC::c_memcpyIF( tinP , pbc , tinCopy.postThreadName   , costai )  ; pbc += costai ;               /*C*/
                                ZE( countT , costai ) ;
                
                                thirdC::c_memcpyIF( tinP , pbc , (byteT*)&tinCopy.monitor , sizeof( monitorS ) ) ; pbc += sizeof( monitorS ) ; /*B*/
                                costaVarying += 1 + tc4.csF( tinP ) ;
                                TN( tc4 , "" ) ; tc4 = T("[")+T((countT*)tinCopy.c4Tell)+T("]") ;
                                //etRock.traceF( tinP , T("tmReportF a/ e") ) ; //U:: TO FIND A BUG
                            {
                            if( /*!head.cStepsNew &&*/ !( F(tinCopy.flagsThreadMode2) & flTHREADmODE2_MONITORdOnOTrEPORToNmE ) && !bQuitMonitorP )

                            }
                                CONoUTrAW( os ) ;
                                OStEXTAK( os , "\"\r\n" ) ;
                                OStEXTA(  os , tinCopy.postThreadName ) ;
                                OStEXTAK( os , "\"" ) ;
                                OStEXTC(  os , tinCopy.monitor.idThread , 0 ) ;
                                OStEXTAK( os , "suppressing detail for thread " ) ;
                                OStEXT(  os , TUCK ) ;
                            {
                            if( F(tinCopy.flagsThreadMode2) & flTHREADmODE2_MONITORdOnOTrEPORToNmE )
                
                            tinS&   tinCopy     = *(tinS*)( pbFrom + sizeof( copyHeadS ) ) ;
                            copyHeadS& head     = *(copyHeadS*)pbFrom ;
                            byteT* pbFrom = (byteT*)&(countT&)swTinCopy ;
                            cLeverOsTid = swTinCopy.leverF( tinP , idf ) ;
                            //etRock.traceF( tinP , T("tmReportF a/ f") ) ; //U:: TO FIND A BUG
                        {
                        for( countT idf = 1 ; idf <= cFlavors && !bQuitMonitorP ; idf ++ )
                        ZE( countT , idAdamLath     ) ;
                        ZE( countT , idAdamRootLath ) ;

                        *(countT*)pbc =  timeR2                                                                                                                             ; pbc += sizeof( countT ) ;     /*A*/
                        *(countT*)pbc =  timeR1                                                                                                                             ; pbc += sizeof( countT ) ;     /*A*/
                        *(countT*)pbc = 1  /*IDfORMAT*/                                                                                                                     ; pbc += sizeof( countT ) ;     /*A*/
                        putNegAM( *(countT*)pbc , FINGERnEG_BKmONITOR )                                                                                                     ; pbc += sizeof( countT ) ;     /*A*/
                        //etRock.traceF( tinP , T("tmReportF a/ g") ) ; //U:: TO FIND A BUG
                    {
                    if( pbc && !bQuitMonitorP )
                    //CONoUTrAW3( "[cbBookOut]: " , cbBookOut , "\r\n" ) ;
                    byteT* pbc = pbBookOut ;
                    PUSE.newF( tinP , LF , pbBookOut , cbBookOut ) ; ___( pbBookOut ) ;
                    ZE( byteT* , pbBookOut ) ;
                    //etRock.traceF( tinP , T("tmReportF a/ h") ) ; //U:: TO FIND A BUG

                    ;

                        + costaVarying
                        + sizeof( monitorS ) * (countT)cFlavorsToReport /*B*/
                        4 * sizeof( countT )                    /*A*/

                    cbBookOut =
                    //etRock.traceF( tinP , T("tmReportF a/ i") ) ; //U:: TO FIND A BUG

                    }
                        }
                            ACCsIZE( pIdProgressNest )                                                                                                                                      /*L*/
                            ACCsIZE( pEIPInNest )                                                                                                                                           /*K*/
                            ACCsIZE( pIdInNest )                                                                                                                                            /*J*/
                            ACCsIZE( pFlagsThreadLevelMode )                                                                                                                                /*I*/
                            ACCsIZE( pLFstep )                                                                                                                                              /*H*/
                            ACCsIZEmONITOR( pLFnest )                                                       
            
                            costaVarying += 1 + thirdC::c_strlenIF( tinP , tinCopy.postTellIf     ) ;                                                                                       /*F*/
                            costaVarying += 1 + thirdC::c_strlenIF( tinP , tinCopy.postTellWait   ) ;                                                                                       /*E*/
                            costaVarying += 1 + thirdC::c_strlenIF( tinP , tinCopy.postTell       ) ;                                                                                       /*D*/
                            costaVarying += 1 + tc4.csF( tinP ) ;                                                                                                                           /*M*/
                            costaVarying += 1 + thirdC::c_strlenIF( tinP , tinCopy.postThreadName ) ;                                                                                       /*C*/
                            TN( tc4 , "" ) ; tc4 = T("[")+T((countT*)tinCopy.c4Tell)+T("]") ;
                            cFlavorsToReport ++ ;
                        {
                        if( /*!head.cStepsNew &&*/ !( F(tinCopy.flagsThreadMode2) & flTHREADmODE2_MONITORdOnOTrEPORToNmE ) )

                        tinS&  tinCopy     = *(tinS*)( pbFrom + sizeof( copyHeadS ) ) ;
                        copyHeadS& head    = *(copyHeadS*)pbFrom ;
                        byteT* pbFrom = (byteT*)&(countT&)swTinCopy ;
                        cLeverOsTid = swTinCopy.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !bQuitMonitorP ; idf ++ )
                    ZE( countT , cFlavorsToReport ) ;
                    countT cFlavors = swTinCopy.cFlavorsF( tinP ) ;
                    ZE( countT , costaVarying ) ;
                    //etRock.traceF( tinP , T("tmReportF a/ j") ) ; //U:: TO FIND A BUG
                {
                if( !bQuitMonitorP )
                ZE( countT , cbBookOut ) ;
                ZE( byteT* , pbBookOut ) ;
                CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  5\r\n" ) ;
                //etRock.traceF( tinP , T("tmReportF a/ k") ) ; //U:: TO FIND A BUG

                memorySpaceP.grab.ungrabF( tinP ) ;

                }
                    }
                        }
                            }
                                while( ~hWalk && !bQuitMonitorP ) ;
                                }
                                    PUSE( tinP , pbCopyMetaHead ) ;
                                    PUSE( tinP , pbCopySex ) ;
                                    }
                                        //else if( bChatter ) { CONoUTrAW( "IGNORED sw\r\n" ) ; }
                                        }
                                            }
                                                PUSE( tinP , pbCopyMetaBitsOwned ) ;
                                                }
                                                    //etThread.traceF( tinP , T("from meta head [osPid,expCbSlot,expSlots,cSlotsAvoidLo,cSlotsAvoidHi,postName]:    ")+TF2(entry.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF3(pCopyMetaHead->expCbSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2)+T("    ")+TF3(pCopyMetaHead->expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2)+T("    ")+TF3(pCopyMetaHead->cSlotsAvoidLo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2)+T("    ")+TF3(pCopyMetaHead->cSlotsAvoidHi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2)+T("    ")+T(pCopyMetaHead->postName) ) ;
                                                    //etThread.traceF( tinP , T("[osPid,expCbSlot,expSlots,postName]:    ")+TF2(entry.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(entry.expCbSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(entry.expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(entry.postName) ) ;

                                                    }
                                                        }
                                                            }
                                                                pbzGrainCode[ offg ] = '9' ;    // sexC META
                                                            {
                                                            for( countT offg = offGrainStart ; offg < offGrainEnd ; offg ++ ) 

                                                            countT offGrainEnd   = (countT)pCopySex->pbMetaEnd / cbGrain ;
                                                            countT offGrainStart = (countT)pCopySex->pbMeta    / cbGrain ;
                                                        {
                                                        if( pCopySex->pbMeta < pCopySex->pbMetaEnd && (countT)pCopySex->pbMetaEnd < cbGrainSpace )

                                                        }
                                                            }
                                                                pbzGrainCode[ offg ] = '8' ;    // sexC DATA
                                                            {
                                                            for( countT offg = offGrainStart ; offg < offGrainEnd ; offg ++ ) 

                                                            countT offGrainEnd   = (countT)pCopySex->pbDataEnd / cbGrain ;
                                                            countT offGrainStart = (countT)pCopySex->pbData    / cbGrain ;
                                                        {
                                                        if( pCopySex->pbData < pCopySex->pbDataEnd && (countT)pCopySex->pbDataEnd < cbGrainSpace )

                                                        sRptSex << (strokeS*)( TF3(cOwned,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pCopyMetaHead->expCbSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pCopyMetaHead->expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pCopySex->flagsState,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pCopyMetaHead->cSlotsAvoidLo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pCopyMetaHead->cSlotsAvoidHi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3((countT)pCopySex->pbData,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(" ")+TF3((countT)pCopySex->pbDataEnd,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(" ")+T(pCopyMetaHead->postName)+tcr ) ;

                                                        }
                                                            if( !bIgnoreLo && !bIgnoreHi && pbCopyMetaBitsOwned[ offb / SB ] & mask ) cOwned ++ ;

                                                            if( bIgnoreHi && !( pbCopyMetaBitsOwned[ offb / SB ] & mask ) ) etThread.traceF( tinP , T("error: expected ownership bit not found (high)") ) ;
                                                            if( bIgnoreLo && !( pbCopyMetaBitsOwned[ offb / SB ] & mask ) ) etThread.traceF( tinP , T("error: expected ownership bit not found (low)") ) ;

                                                            boolT bIgnoreHi = offb >= cSlots - pCopyMetaHead->cSlotsAvoidHi ;
                                                            boolT bIgnoreLo = offb <           pCopyMetaHead->cSlotsAvoidLo ;

                                                            byteT mask = (byteT)( 1 << offb % SB ) ;
                                                        {
                                                        for( countT offb = 0 ; offb < cSlots ; offb ++ )
                                                        countT cSlots = 1 << pCopyMetaHead->expSlots ;
                                                        ZE( countT , cOwned ) ;
                                                    {
                                                    if( bGotBits )

                                                    thirdC::dosReadProcessMemoryIF( tinP , pbCopyMetaBitsOwned , cbaMetaBitsOwned , bGotBits , (voidT*)pCopySex->pbzMetaBitsOwned , entry.osPid ) ;
                                                    ZE( boolT , bGotBits ) ;
                                                {
                                                if( pbCopyMetaBitsOwned )

                                                PUSE.newF( tinP , LF , pbCopyMetaBitsOwned , cbaMetaBitsOwned ) ; ___( pbCopyMetaBitsOwned ) ;
                                                countT cbaMetaBitsOwned = 1 + ( 1 << pCopyMetaHead->expSlots ) / SB ;
                                                ZE( byteT* , pbCopyMetaBitsOwned ) ;
                                            {
                                            if( pCopyMetaHead )

                                            }
                                                if( bOk ) pCopyMetaHead = (sexHeadS*)pbCopyMetaHead ; ;
                                                thirdC::dosReadProcessMemoryIF( tinP , pbCopyMetaHead , sizeof( sexHeadS ) , bOk , (voidT*)pCopySex->pzMetaHead , entry.osPid ) ;
                                                ZE( boolT , bOk ) ;
                                            {
                                            ZE( sexHeadS* , pCopyMetaHead ) ;
                                        {
                                        if( pCopySex ) // pCopySex IS EITHER 0 OR A VALID IMAGE OF A sexC (U:: ADD FINGERPRINT CHECK LIKE tinS)
                                            
                                        }
                                            if( bOk ) pCopySex = (sexC*)pbCopySex ; ;
                                            thirdC::dosReadProcessMemoryIF( tinP , pbCopySex , sizeof( sexC ) , bOk , (voidT*)entry.pSex , entry.osPid ) ;
                                            ZE( boolT , bOk ) ;
                                        {
                                        ZE( sexC* , pCopySex ) ;
                                    {
                                    if( pbCopySex && pbCopyMetaHead )
                                    PUSE.newF( tinP , LF , pbCopyMetaHead , sizeof( sexHeadS ) ) ; ___( pbCopyMetaHead ) ;
                                    PUSE.newF( tinP , LF , pbCopySex      , sizeof( sexC     ) ) ; ___( pbCopySex      ) ;
                                    ZE( byteT* , pbCopyMetaHead ) ;
                                    ZE( byteT* , pbCopySex ) ;

                                    byteT* pbzGrainCode = (byteT*)&(countT&)sw_pbzGrainCode ;
                                    if( !sw_pbzGrainCode.idSlotOfLeverF( tinP , cLeverGrainCode ) ) etThread.memSetF( tinP , (byteT*)&(countT&)sw_pbzGrainCode , cbGrainCode , '.' ) ;
                                    cLeverGrainCode = entry.osPid ;

                                    sexEntryS& entry = *(sexEntryS*)&memorySpaceP.swsSex.downF( tinP , hWalk ) ;
                                {
                                do
                                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                        {
                        if( cPlates )
                        sRptSex << (strokeS*)( T("[cPlates]:    ")+TF2(cPlates,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr ) ;
                        countT cPlates = memorySpaceP.swsSex ;
            
                        sRptSex << (strokeS*)( tcr+tcr+textC( tinP , TAG( TAGiDnULL ) , flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED , memorySpaceP.pczLeverAdam , flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED , 0 , 0 , 0 )+tcr+tcr+T("cOwned   expCbSlo expSlots flagsSta cSlotsLo cSlotsHi pbData   pbDataEn postName")+tcr+tcr ) ;
                        memorySpaceP.pczLeverAdam = (countT*)memorySpaceP.swsSex.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !bQuitMonitorP ; idf ++ )
                    sRptSex << (strokeS*)( T("[cFlavors]:    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr+tcr ) ;
                    countT cFlavors = memorySpaceP.swsSex.cFlavorsF( tinP ) ;
                {
                if( !bQuitMonitorP )
                CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  6\r\n" ) ;
                //etRock.traceF( tinP , T("tmReportF b/ ") ) ; //U:: TO FIND A BUG

                }
                    }
                        }
                            }
                                while( ~hWalk && !bQuitMonitorP ) ;
                                }
                                    }
                                        }
                                            pbzGrainCode[ offg ] = '7' ;    // napkinC
                                        {
                                        for( countT offg = offGrainStart ; offg < offGrainEnd ; offg ++ ) 

                                        countT offGrainEnd   = (countT)( entry.pbData + entry.cbData ) / cbGrain ;
                                        countT offGrainStart = (countT)  entry.pbData                  / cbGrain ;
                                    {
                                    if( (countT)entry.pbData + entry.cbData < cbGrainSpace )

                                    sRptNapkin << (strokeS*)( T(entry.postName)+tcr ) ;

                                    byteT* pbzGrainCode = (byteT*)&(countT&)sw_pbzGrainCode ;
                                    if( !sw_pbzGrainCode.idSlotOfLeverF( tinP , cLeverGrainCode ) ) etThread.memSetF( tinP , (byteT*)&(countT&)sw_pbzGrainCode , cbGrainCode , ' ' ) ;
                                    cLeverGrainCode = entry.osPid ;

                                    napkinEntryS& entry = *(napkinEntryS*)&memorySpaceP.swsNapkin.downF( tinP , hWalk ) ;
                                {
                                do
                                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                        {
                        if( cPlates )
                        sRptNapkin << (strokeS*)( T("[cPlates]:    ")+TF2(cPlates,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr ) ;
                        countT cPlates = memorySpaceP.swsNapkin ;
            
                        sRptNapkin << (strokeS*)( tcr+tcr+textC( tinP , TAG( TAGiDnULL ) , flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED , memorySpaceP.pczLeverAdam , flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED , 0 , 0 , 0 )+tcr+tcr+T("postName")+tcr+tcr ) ;
                        memorySpaceP.pczLeverAdam = (countT*)memorySpaceP.swsNapkin.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !bQuitMonitorP ; idf ++ )
                    sRptNapkin << (strokeS*)( T("[cFlavors]:    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr+tcr ) ;
                    countT cFlavors = memorySpaceP.swsNapkin.cFlavorsF( tinP ) ;
                {
                if( !bQuitMonitorP )
                CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  7\r\n" ) ;
                //etRock.traceF( tinP , T("tmReportF c/ ") ) ; //U:: TO FIND A BUG

                }
                    }
                        }
                            }
                                while( ~hWalk && !bQuitMonitorP ) ;
                                }
                                    PUSE( tinP , pbCopy ) ;
                                    }
                                        //else if( bChatter ) { CONoUTrAW( "IGNORED sw\r\n" ) ; }
                                        }
                                            //if( bChatter ) { CONoUTrAW( "COPIED sw\r\n" ) ; }
            
                                            thirdC::c_memcpyIF( tinP , pbTo + sizeof( copyHeadS ) , (byteT*)pCopy , sizeof( tinS ) ) ;
            
                                                                                     entry.idStepLath = pCopy->monitor.idStep ;
                                            head.cStepsNew = pCopy->monitor.idStep - entry.idStepLath ;
            
                                            head.idAdam     = memorySpaceP.pczLeverAdam[ 1 ] ;
                                            head.idAdamRoot = memorySpaceP.pczLeverAdam[ 0 ] ;
            
                                            copyHeadS& head = *(copyHeadS*)pbTo ;
            
                                            byteT* pbTo = (byteT*)&(countT&)swTinCopy ;
                                            cLeverOsTid = entry.osTid ;
                                        {
                                        if( pCopy&& !bQuitMonitorP ) // pCopy IS EITHER 0 OR A VALID IMAGE OF A tinS
                                            
                                        }
                                            }
                                                }
                                                    //U::LOG postThreadName AND idThread

                                                    //LOGrAW9( "tmReportF/detected odor while sniffing tinS again to verify [bOk,fingerprint,entry.idSerial,idSerial]: " , bOk , "    " , pc2[ 0 ] , "    " , entry.idSerial , "    " , pc2[ 1 ] , "\r\n" ) ;
                                                    pCopy = 0 ;
                                                {
                                                if( !bOk || getNegAM( pc2[ 0 ] ) != FINGERnEG_TINs || entry.idSerial != pc2[ 1 ] )
                                                thirdC::dosReadProcessMemoryIF( tinP , (byteT*)pc2 , sizeof pc2 , bOk , (voidT*)( (byteT*)entry.ip ) , entry.osPid ) ;
                                                bOk = 0 ;
                                                countT pc2[ 2 ] ; //fingerprint idSerial MUST BE AT OFFSETS 0 4
                                            {
                                            else
                                            }
                                                //U::LOG postThreadName AND idThread

                                                //LOGrAW9( "tmReportF/detected odor while sniffing tinS full [bOk,fingerprint,entry.idSerial,idSerial]: " , bOk , "    " , pCopy->fingerprint , "    " , entry.idSerial , "    " , pCopy->idSerial , "\r\n" ) ;
                                                pCopy = 0 ;
                                            {
                                            if( !bOk || getNegAM( pCopy->fingerprint ) != FINGERnEG_TINs || entry.idSerial != pCopy->idSerial )
                                            thirdC::dosReadProcessMemoryIF( tinP , pbCopy , sizeof( tinS ) , bOk , (voidT*)entry.ip , entry.osPid ) ;
                                            ZE( boolT , bOk ) ;
                                        {
                                        if( !entry.bIda && !bQuitMonitorP )
                                        tinS* pCopy = (tinS*)pbCopy ;
                                    {
                                    if( pbCopy )
                                    PUSE.newF( tinP , LF , pbCopy , sizeof( tinS ) ) ; ___( pbCopy ) ;
                                    ZE( byteT* , pbCopy ) ;
                    
                                    //}
                                    //    CONoUTrAW( ostoSay ) ;
                                    //
                                    //    OStEXTAK( ostoSay , "\"\r\n" ) ;
                                    //    OStEXTA(  ostoSay , entry.postThreadName ) ;
                                    //    OStEXTAK( ostoSay , " , \"" ) ;
                                    //    OStEXTC(  ostoSay , entry.osTid , 0 ) ;
                                    //    OStEXTAK( ostoSay , " , " ) ;
                                    //    OStEXTC(  ostoSay , entry.idTin , 0 ) ;
                                    //    OStEXTAK( ostoSay , " , " ) ;
                                    //    OStEXTC(  ostoSay , entry.idThread , 0 ) ;
                                    //    OStEXTAK( ostoSay , "i [idThread,idTin,osTid,postThreadName]: " ) ;
                                    //    OStEXT(  ostoSay , TUCK ) ;
                                    //
                                    //    bChatter = 1 ;
                                    //{
                                    //if( !etThread.strCompareF( tinP , T(entry.postThreadName) , T("tm1F") ) )
                                    //ZE( boolT , bChatter ) ;

                                    tinEntryS& entry = *(tinEntryS*)&memorySpaceP.swsTin.downF( tinP , hWalk ) ;
                                {
                                do
                                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                        {
                        if( cPlates )
                        countT cPlates = memorySpaceP.swsTin ;
            
                        memorySpaceP.pczLeverAdam = (countT*)memorySpaceP.swsTin.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = memorySpaceP.swsTin.cFlavorsF( tinP ) ;
                {
                if( !bQuitMonitorP )
                CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  8\r\n" ) ;
                //etRock.traceF( tinP , T("tmReportF d/ ") ) ; //U:: TO FIND A BUG

                memorySpaceP.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
            
                CONoUTrAW7( "[cbGrainCode,cColsGrainCode,cRowsGrainCode]: " , cbGrainCode , " " , cColsGrainCode , " " , cRowsGrainCode , "\r\n" ) ;

                switchC sw_pbzGrainCode( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cLeverGrainCode , 0 , cbGrainCode ) ;
                ZE( countT , cLeverGrainCode ) ;

                while( cColsGrainCode * cRowsGrainCode < cbGrainCode ) cRowsGrainCode ++ ;
                while( cColsGrainCode * cRowsGrainCode > cbGrainCode ) cRowsGrainCode -- ;
                countT cRowsGrainCode = cColsGrainCode ;
                if( cColsGrainCode < TUCK ) cColsGrainCode = TUCK ;
                while( cColsGrainCode * cColsGrainCode < cbGrainCode ) cColsGrainCode ++ ;
                countT cColsGrainCode = thirdC::c_sqrtIF( cbGrainCode ) ;
                countT cbGrainCode = cbGrainSpace / cbGrain ;
                countT cbGrain = 1 << thirdC::os_expCbAllocationGrain_IF( tinP ) ;
                countT cbGrainSpace = BM_HIGH ; //ONLY LOWER HALF IS ACCESSIBLE TO APPLICATIONS IN WINDOWS (WIN32)

                soulC sRptLog(    tinP , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptLog    ) ; sRptLog    << (strokeS*)T("\r\nLog\r\n\r\n") ;
                soulC sRptEvent(  tinP , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptEvent  ) ; sRptEvent  << (strokeS*)T("\r\nEvent Tally\r\n\r\n") ;
                soulC sRptTin(    tinP , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptTin    ) ; sRptTin    << (strokeS*)T("\r\nThreads\r\n\r\n") ;
                soulC sRptSex(    tinP , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptSex    ) ; sRptSex    << (strokeS*)T("\r\n\r\nSex (Slot Extents) (Heap)\r\n") ;
                soulC sRptNapkin( tinP , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptNapkin ) ; sRptNapkin << (strokeS*)T("\r\n\r\nNapkin (Shared Memory)\r\n") ;
                soulC sRptAdd(    tinP , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptAdd    ) ; sRptAdd    << (strokeS*)T("\r\nAddress Space Usage\r\n") ;
                soulC sRptTitle(  tinP , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptTitle  ) ; sRptTitle  << (strokeS*)( T("Memory Space ")+TF2(idMemorySpaceP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" Glass: Minute Overview\r\nMinute by minute overview of the state of this home\r\nMinutes since gen: ")+TF2(idCycle,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\nMinute: ")+TF2(idMinute,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n\r\n") ) ;

                OStEXTC(  ostoFileRptLog    , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptLog    , "soul.rpt.log." ) ;
                OStEXT(   ostoFileRptLog    , TUCK >> 3 ) ;

                OStEXTC(  ostoFileRptEvent  , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptEvent  , "soul.rpt.event." ) ;
                OStEXT(   ostoFileRptEvent  , TUCK >> 3 ) ;

                OStEXTC(  ostoFileRptTin    , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptTin    , "soul.rpt.tin." ) ;
                OStEXT(   ostoFileRptTin    , TUCK >> 3 ) ;

                OStEXTC(  ostoFileRptSex    , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptSex    , "soul.rpt.sex." ) ;
                OStEXT(   ostoFileRptSex    , TUCK >> 3 ) ;

                OStEXTC(  ostoFileRptNapkin , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptNapkin , "soul.rpt.napkin." ) ;
                OStEXT(   ostoFileRptNapkin , TUCK >> 3 ) ;

                OStEXTC(  ostoFileRptAdd    , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptAdd    , "soul.rpt.add." ) ;
                OStEXT(   ostoFileRptAdd    , TUCK >> 3 ) ;

                OStEXTC(  ostoFileRptTitle  , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptTitle  , "soul.rpt.title." ) ;
                OStEXT(   ostoFileRptTitle  , TUCK >> 3 ) ;

                // bQuitMonitorP IS NOT TESTED HERE BECAUSE WE WANT WO LATH REPORT SO THAT WE CAN SEE THE FINAL EVENTS

                idCycle ++ ;

                //LOGrAW7( "tmReportF [fliPendingSnapShotRequestP,bSnapShot,idMemorySpaceP]: " , fliPendingSnapShotRequestP , " " , bSnapShot , " " , idMemorySpaceP , "\r\n" ) ;
                boolT bSnapShot = fliPendingSnapShotRequestP & fliMaskPending ;
                CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  9\r\n" ) ;
            {
            if( !bQuitMonitorP )

            bCompileReportP.grabF( tinP , TAG( TAGiDnULL ) ) ;  // AN OPTIMIZATION TO SERIALIZE USE OF CPU AND ADDRESS SPACE
        {
        if( !bQuitMonitorP )

//#if defined( NEVERdEFINED )
//20191006@1847: ENABLED FOR TESTING AND DEBUGGING
//U:: IT IS BEING UNCOMMENTED ONLY TO INVESTIGATE WHETHER THIS CODE IS THE CULPRIT FOR LONG QUIT TIMES
//U:: IN PRODUCTION, THE IFDEF SHOULD BE COMMENTED OUT SO THAT THE CODE IS TESTED BY PRODUCTION
//U:: 20190129: USING THE BATON MIGHT ALSO IMPACT QUIT QUALITY SO AT THIS TIME THE IFDEF IS BEING UNCOMMENTED
//U::WORKAROUND: THE USE OF THE BATON IN THE NEXT LINE REQUIRES REGRESSION DEBUGGING.  THE GOAL IS TO REDUCE ADDRESS SPACE FOOTPRINT TO HOPEVULLY ELIMMINATE THE ADDRESS SPACE EXHAUSTION BLAMMO ON FACTORY3

        }
            }
                else etThread.osSleepF( tinP , TUCK * 0x40 ) ;
                }
                    break ;
                    timeR2 = timeN2 ;
                    timeR1 = timeN1 ;
                    idMinute = idMinuteTry ;
                {
                if( bDo )

                if( !bDo && idMinute != idMinuteTry ) bDo = 1 ;

                else if( idFoTock ) idFoTock = 0 ;
                }
                    }
                        bDo = 1 ;
                        idFoTock = idFoTockTry ;
                    {
                    if( !idFoTock || idFoTock != idFoTockTry )
                {
                if( F(home.flagsUtility) & flHOMEsuTILITY_SNAPsHOT )
                ZE( boolT , bDo ) ;

                countT idFoTockTry = timeN1 >> 0x12 ;        
                countT idMinuteTry = timeN1 >> 0x16 ;    // 8:TUCK 01:TOCK 81:TICK 61:MINUTE(QUARTERTICK)
                // 8:TUCK 01:TOCK 81:TICK 61:MINUTE(QUARTERTICK)

                etThread.osTimeNowF( tinP ,  timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT  , timeN1 ) ;
            {
            while( !bQuitMonitorP && !etThread && !( fliPendingSnapShotRequestP & fliMaskPending ) ) // SNAPsHOT REQUEST IS OBEYED IMMEDIATELY
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        ZE( sCountT , timeR2 ) ;
        ZE( countT  , timeR1 ) ;

        //LOGrAW3( "tmReportF 1 [flHOMEsuTILITY_SNAPsHOT]: " , F(home.flagsUtility) & flHOMEsuTILITY_SNAPsHOT , "\r\n" ) ;
        CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  a\r\n" ) ;
        //etRock.traceF( tinP , T("tmReportF e/ ") ) ; //U:: TO FIND A BUG
    {
    while( !bQuitMonitorP )
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //bCompileReportP ADDED 20180108@1021
    //etRock.traceF( tinP , T("tmReportF f/ ") ) ; //U:: TO FIND A BUG
    ZE( countT , idFoTock ) ; // THIS IS USED ONLY IF flHOMEsuTILITY_SNAPsHOT
    countT idMinute = idMinuteZeP ;
    ZE( countT , idCycle ) ;
    TN( tcr , "\r\n" ) ;

    switchC swTinCopy( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cLeverOsTid , 0 , sizeof( copyHeadS ) + sizeof( tinS ) ) ;
    ZE( countT , cLeverOsTid ) ;

    booksC bkReport( tinP , TAG( TAGiDnULL ) , tBooks , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER , TICK ) ; //A SEPARATE BOOKS OBJECT IS USED FOR EACH MEMORY SPACE TO ELIMINATE SERIALIZATION COLLISIONS; WHICH ARE SUPPORTED BUT WHY TAKE A CHANCE WITH THE KERNEL!
    tBooks = T("kernel.minute.reports.memoryspace.")+TF3(idMemorySpaceP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,3) ;
    TN( tBooks , "" ) ;

    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIEST ) ; //CHANGE TO RUSH IF NEED TO ANALYZE BEHAVIOR INVOLVING CPU PEGGING

    tinP.c4Tell.c1 = idMemorySpaceP ;

    flagsT fliMaskPending = 1 << idMemorySpaceP - ifcIDmEMORYsPACE_min ;

    homeS& home = homeS::homeIF() ;
    CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  b\r\n" ) ;
    //etRock.traceF( tinP , T("tmReportF g/ ") ) ; //U:: TO FIND A BUG

    batonC&       bCompileReportP            =       *(batonC*)pTaskP->c8 ;
    osTextT*      postSnapShotRequestP       =       (osTextT*)pTaskP->c7 ;
    flagsT&       fliPendingSnapShotRequestP =       *(flagsT*)pTaskP->c6 ;
    countT        idMinuteZeP                =                 pTaskP->c5 ;
    memorySpaceS& memorySpaceP               = *(memorySpaceS*)pTaskP->c4 ;
    stackC&       stPeriodDataP              =       *(stackC*)pTaskP->c3 ;
    countT        idMemorySpaceP             =                 pTaskP->c2 ;
    boolT&        bQuitMonitorP              =        *(boolT*)pTaskP->c1 ;

    //etRock.traceF( tinP , T("tmReportF h/ ") ) ; //U:: TO FIND A BUG
    etherC& etRock = etherC::etRockIF( tinP ) ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c6 && pTaskP->c7 && pTaskP->c8 )

TASK( tmReportF )

    }
        thirdC::c_memcpyIF( tinP , pbc , (byteT*)pci , costai ) ; pbc += costai ;                           \
        costai = sizeof( countT ) * ( 1 + thirdC::c_strlenIF( tinP , pci ) ) ;                              \
        tinCopy.get_##arrayP##_F( tinP , pci , cci + 1 ) ;                                                  \
        countT pci[ cci + 1 ] ;                                                                             \
        const countT cci = sizeof tinP.monitor.##arrayP ;                                                   \
    {                                                                                                       \
                                                                                                            \
#define WRITEaRRAYmONITOR(arrayP)                                                                           \

    }
        thirdC::c_memcpyIF( tinP , pbc , (byteT*)pci , costai ) ; pbc += costai ;                           \
        costai = sizeof( countT ) * ( 1 + thirdC::c_strlenIF( tinP , pci ) ) ;                              \
        tinCopy.get_##arrayP##_F( tinP , pci , cci + 1 ) ;                                                  \
        countT pci[ cci + 1 ] ;                                                                             \
        const countT cci = sizeof tinP.##arrayP ;                                                           \
    {                                                                                                       \
                                                                                                            \
#define WRITEaRRAY(arrayP)                                                                                  \

    }
        costaVarying += sizeof( countT ) * ( 1 + thirdC::c_strlenIF( tinP , pci ) ) ;                        \
        tinCopy.get_##arrayP##_F( tinP , pci , cci + 1 ) ;                                                   \
        countT pci[ cci + 1 ] ;                                                                              \
        const countT cci = sizeof tinP.##arrayP ;                                                            \
    {                                                                                                        \
                                                                                                             \
#define ACCsIZE(arrayP)                                                                                      \

    }
        costaVarying += sizeof( countT ) * ( 1 + thirdC::c_strlenIF( tinP , pci ) ) ;                        \
        tinCopy.get_##arrayP##_F( tinP , pci , cci + 1 ) ;                                                   \
        countT pci[ cci + 1 ] ;                                                                              \
        const countT cci = sizeof tinP.monitor.##arrayP ;                                                    \
    {                                                                                                        \
                                                                                                             \
#define ACCsIZEmONITOR(arrayP)                                                                               \

;
}
    countT cStepsNew ;
    countT idAdam ;
    countT idAdamRoot ;
{
struct copyHeadS

DONE( tmcMonitorServerF )
}
    }
        DEL( psoP ) ;
        }
            }
                sOut.removeAllF( tinP ) ;
                psoP->writeF( tinP , sOut ) ;
                sIn.removeAllF( tinP ) ;
    
                }
                    #endif

                    }
                        break ;
    
                        etThread.delF( tinP , psttName ) ;
                        }
                            //etThread.strokeF( tinP , T("walked  ")+TF1(idMemorySpace)+T(" name \"")+T(psttName)+T("\"\r\n") ) ;
                            THREADmODE2rESTORE
                            poo.walkF( tinP , ifcIDtYPEpOOLoLDwALK_MONITORwALK1 , info ) ;
                            THREADmODE2oN( flTHREADmODE2_MARKnEWdROPSqUIETdURINGwALK )
                            //etThread.strokeF( tinP , T("walking ")+TF1(idMemorySpace)+T(" name \"")+T(psttName)+T("\"\r\n") ) ;
                            countT info = (countT)&c8i ;
                            count8S c8i( (countT)&sOut , 0/*idDrop*/ ) ;
                        {
                        if( !POOP )
                        //etThread.strokeF( tinP , T("this poolOld has ")+TF1(head.cdUsed)+T(" drops in memory [")+TF1(c_pbPool)+T(",")+TF1(c_pbPool+head.offHighWater)+T(",")+TF1(c_pbPool+head.cbPool-1)+T("]\r\n") ) ;
                        countT c_pbPool = (countT)poo.pbPool ;
                        //etThread.strokeF( tinP , T("received request to walk a poolOld in space ")+TF1(idMemorySpace)+T(" name \"")+T(psttName)+T("\"\r\n") ) ;
                        const poolOldHeaderS& head = poo ;
                        p oolC poo( tinP , TAG( TAGiDnULL ) , T(psttName) ) ;
    
                        sIn >> psttName ; ___( psttName ) ;
                        ZE( strokeS* , psttName ) ;
                        sIn >> idMemorySpace ;
                        ZE( countT , idMemorySpace ) ;
    
                        sOut << (countT)ifcIDrEPLYmONITOR_POOLoLDwALK1 ;
                    {
                    case ifcIDcMDmONITOR_POOLoLDwALK1 : //U::REPLACE THIS WITH ORTHOGONAL FUNCTIONALITY (REPLY WITH POOLoLD ADDRESS; FORCE CLIENT TO REQUEST IMAGES AND TO DO ITS OWN INSPECTION)
                    }
                        break ;
    
                        etThread.delF( tinP , psttName ) ;
                        //if( !POOP ) sOut.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_countTptr , (countT*)&(poolOldHeaderS&)poo , sizeof( poolOldHeaderS ) / sizeof( countT ) ) ;
                        p oolC poo( tinP , TAG( TAGiDnULL ) , T(psttName) ) ;
    
                        //etThread.strokeF( tinP , T("received request for the header of space ")+TF1(idMemorySpace)+T(" name \"")+T(psttName)+T("\"\r\n") ) ;
                        sIn >> psttName ; ___( psttName ) ;
                        ZE( strokeS* , psttName ) ;
                        sIn >> idMemorySpace ;
                        ZE( countT , idMemorySpace ) ;
    
                        sOut << (countT)ifcIDrEPLYmONITOR_POOLoLDhEADER ;
                    {
                    case ifcIDcMDmONITOR_POOLoLDhEADER : //U::REPLACE THIS WITH ORTHOGONAL FUNCTIONALITY (REPLY WITH POOLoLD ADDRESS; FORCE CLIENT TO REQUEST IMAGES AND TO DO ITS OWN INSPECTION)

                    #if defined( NEVERdEFINED )
                    //COMMENTED OUT WHEN poolC WAS REWRITTEN

                    }
                        break ;

                        swMemorySpaceP.ungrabF( tinP ) ;
                        }
                            }
                                while( !stName.third && ~hDown ) ;
                                }
                                    sOut << psttn ;
                                    strokeS* psttn = (strokeS*)stName.downF( tinP , hDown ) ;
                                {
                                do
                                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( stName )
                            sOut << (countT)stName ;
        
                            }
                                }
                                    while( !stTemp.third && ~hDown ) ;
                                    }
                                        if( !ids ) etThread.delF( tinP , psttn ) ;
                                        stName.sinkF( tinP , ids , psttn , flSTACKsINK_UNIQUE ) ;
                                        ZE( countT , ids ) ;
                                        strokeS*& psttn = *(strokeS**)&stTemp.downF( tinP , hDown ) ;
                                    {
                                    do
                                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( stTemp )
            
                                memorySpace.grab.ungrabF( tinP ) ;
                                }
                                    while( !memorySpace.stPool.third && ~hDown ) ;
                                    }
                                        stTemp << psttn ;
                                        //etThread.strokeF( tinP , T("entry.postName: \"")+T(entry.postName)+T("\"\r\n") ) ;
                                        etThread.strMakeF( tinP , psttn , T(entry.postName) ) ; ___( psttn ) ;
                                        ZE( strokeS* , psttn ) ;
                                        poolOldEntryS& entry = *(poolOldEntryS*)&memorySpace.stPool.downF( tinP , hDown ) ;
                                    {
                                    do
                                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( memorySpace.stPool )
                                memorySpace.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
            
                                stackC stTemp( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
                            {
                            stackC stName( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

                            memorySpaceS& memorySpace = *(memorySpaceS*)&(countT&)swMemorySpaceP ;
                            sOut << cLeverIdMemoryP ;
                            cLeverIdMemoryP = swMemorySpaceP.leverF( tinP , idfm ) ;
                        {
                        for( countT idfm = 1 ; idfm <= cFlavorsMemory ; idfm ++ )
                        sOut << cFlavorsMemory ;
                        countT cFlavorsMemory = swMemorySpaceP.cFlavorsF( tinP ) ;
                        swMemorySpaceP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                        sOut << (countT)ifcIDrEPLYmONITOR_POOLoLDnAMES ;
                    {
                    case ifcIDcMDmONITOR_POOLoLDnAMES : //U::REPLACE THIS WITH ORTHOGONAL FUNCTIONALITY (REPLY WITH POOLoLD ADDRESS; FORCE CLIENT TO REQUEST IMAGES AND TO DO ITS OWN INSPECTION)
                    }
                        break ;

                        swMemorySpaceP.ungrabF( tinP ) ;
                        }
                            memorySpace.grab.ungrabF( tinP ) ;
                            }
                                sOut << (countT)memorySpace.swTallySay ;
                                sOut << memorySpace.cLeverSay ;
                                memorySpace.cLeverSay = memorySpace.swTallySay.leverF( tinP , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            sOut << cFlavors ;
                            countT cFlavors = memorySpace.swTallySay.cFlavorsF( tinP ) ;
                            memorySpace.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;

                            memorySpaceS& memorySpace = *(memorySpaceS*)&(countT&)swMemorySpaceP ;
                            sOut << cLeverIdMemoryP ;
                            cLeverIdMemoryP = swMemorySpaceP.leverF( tinP , idfm ) ;
                        {
                        for( countT idfm = 1 ; idfm <= cFlavorsMemory ; idfm ++ )
                        sOut << cFlavorsMemory ;
                        countT cFlavorsMemory = swMemorySpaceP.cFlavorsF( tinP ) ;
                        swMemorySpaceP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        sOut << (countT)ifcIDrEPLYmONITOR_SAYtALLIES ;
                    {
                    case ifcIDcMDmONITOR_SAYtALLIES :
                    }
                        break ;

                        swMemorySpaceP.ungrabF( tinP ) ;
                        }
                            memorySpace.grab.ungrabF( tinP ) ;
                            }
                                }
                                    while( ~hWalk ) ;
                                    }
                                        sOut << (countT)entry.ip ;
                                        sOut << (countT)entry.bIda ;
                                        sOut << (countT)entry.osPid ;
                                        tinEntryS& entry = *(tinEntryS*)&memorySpace.swsTin.downF( tinP , hWalk ) ;
                                    {
                                    do
                                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( cPlates )
                                sOut << cPlates ;
                                countT cPlates = memorySpace.swsTin ;
                                memorySpace.pczLeverAdam = (countT*)memorySpace.swsTin.leverF( tinP , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            sOut << cFlavors ; //U::CLIENT CODE IS OBSOLETE BECAUSE IT DOESNT KNOW ABOUT cFlavors AND THAT MULTIPLE FLAVORS FOLLOW
                            countT cFlavors = memorySpace.swsTin.cFlavorsF( tinP ) ;
                            memorySpace.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;

                            memorySpaceS& memorySpace = *(memorySpaceS*)&(countT&)swMemorySpaceP ;
                            sOut << cLeverIdMemoryP ;
                            cLeverIdMemoryP = swMemorySpaceP.leverF( tinP , idfm ) ;
                        {
                        for( countT idfm = 1 ; idfm <= cFlavorsMemory ; idfm ++ )
                        sOut << cFlavorsMemory ;
                        countT cFlavorsMemory = swMemorySpaceP.cFlavorsF( tinP ) ;
                        swMemorySpaceP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        sOut << (countT)ifcIDrEPLYmONITOR_tinS ;
                    {
                    case ifcIDcMDmONITOR_tinS :
                    }
                        break ;

                        tinP.pEtScratch->delF( tinP , pbCopy ) ;
                        if( bOk ) sOut.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_byteTptr , pbCopy , cbAt ) ;
                        sOut << bOk ;
                        sOut << (countT)ifcIDrEPLYmONITOR_IMAGE ;

                        if( pbCopy ) thirdC::dosReadProcessMemoryIF( tinP , pbCopy , cbAt , bOk , pvAt , osPid ) ;
                        tinP.pEtScratch->newF( tinP , LF , pbCopy , cbAt ) ; ___( pbCopy ) ;
                        ZE( boolT , bOk ) ;
                        ZE( byteT* , pbCopy ) ;

                        sIn >> cbAt ;
                        ZE( countT , cbAt ) ;
                        sIn >> *(countT*)&pvAt ;
                        ZE( voidT* , pvAt ) ;
                        sIn >> osPid ;
                        ZE( countT , osPid ) ;
                    {
                    case ifcIDcMDmONITOR_IMAGE :
                {
                switch( idCmd )
                sIn >> idCmd ;
                ZE( countT , idCmd ) ;
            {
            else
            if( POOP ) { POOPR DEL( psoP ) ; }
    
            psoP->readF( tinP , sIn ) ;
        {
        while( !POOP && !etThread && !ether && psoP )
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
        soulC sIn(  tinP , TAG( TAGiDnULL ) ) ;
    
        psoP->etherF( tinP , *tinP.pEtScratch ) ;
        SCOOPS
    {
    IFsCRATCH

    tinP.c4Tell.c1 = cLeverIdMemoryP ;

    switchC& swMemorySpaceP  = *(switchC*)pTaskP->c3 ;
    countT&  cLeverIdMemoryP =  *(countT*)pTaskP->c2 ;
    socketC* psoP            =  (socketC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TELL( "setting up" )
TASK( tmcMonitorServerF ) //REN tmServerF

#include postHEADER

/*1*//*ifcIDaDAM_KERNEL2MONITOR 2*//*1*/

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

