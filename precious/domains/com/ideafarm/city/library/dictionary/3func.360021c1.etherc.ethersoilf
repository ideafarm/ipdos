
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#undef CSTTdOsHORT
#undef CfLAG23mAX
#undef CfLAG1mAX

}
    return rc ;

    //}
    //    default                                                  : { LOGrAW( "etherSoilF / ?               /-\r\n" ) ; strokeF( tinP , T("etherSoilF / ?               /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_DOdEBUG                          : { LOGrAW( "etherSoilF / DOdEBUG         /-\r\n" ) ; strokeF( tinP , T("etherSoilF / DOdEBUG         /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_DO                               : { LOGrAW( "etherSoilF / DO              /-\r\n" ) ; strokeF( tinP , T("etherSoilF / DO              /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_QUERYvALUES                      : { LOGrAW( "etherSoilF / QUERYvALUES     /-\r\n" ) ; strokeF( tinP , T("etherSoilF / QUERYvALUES     /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_REPORT                           : { LOGrAW( "etherSoilF / REPORT          /-\r\n" ) ; strokeF( tinP , T("etherSoilF / REPORT          /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_TRIM                             : { LOGrAW( "etherSoilF / TRIM            /-\r\n" ) ; strokeF( tinP , T("etherSoilF / TRIM            /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_LINT                             : { LOGrAW( "etherSoilF / LINT            /-\r\n" ) ; strokeF( tinP , T("etherSoilF / LINT            /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE                  : { LOGrAW( "etherSoilF / ASCIIfROMnATIVE /-\r\n" ) ; strokeF( tinP , T("etherSoilF / ASCIIfROMnATIVE /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_NATIVEfROMaSCII                  : { LOGrAW( "etherSoilF / NATIVEfROMaSCII /-\r\n" ) ; strokeF( tinP , T("etherSoilF / NATIVEfROMaSCII /-\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_PREPAREsOURCE                    : { LOGrAW( "etherSoilF / PREPAREsOURCE   /-\r\n" ) ; strokeF( tinP , T("etherSoilF / PREPAREsOURCE   /-\r\n") ) ; break ; }
    //{
    //switch( idModeP )

    ;
        : cFlag1
        ? bRepeat
    countT rc = idModeP == ifcIDmODEeTHERsOIL_REPORT

    }
        }
            }
                delF( tinP , psttAfter ) ;
                //strokeF( tinP , T("\"")+T(psttzLeverReplace)+T("\" -> \"")+T(psttAfter)+T("\"\r\n") ) ;
                strokeS*& psttAfter = *(strokeS**)&(countT&)swReplace ;
                psttzLeverReplace = (strokeS*)swReplace.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swReplace.cFlavorsF( tinP ) ;

            /**/if( bTrace ) traceF( tinP , T("etherSoilF / cleaning up") ) ;

            }
                }
                    soulOut.removeAllF( tinP ) ;
                    /**/if( bTrace ) traceF( tinP , T("etherSoilF / purging soulOut") ) ;
                    strPourF( tinP , soulOutP , soulOut , flSTRpOURf_CONSUMEiNPUT ) ;
                    /**/if( bTrace ) traceF( tinP , T("etherSoilF / fusing soulOut to soulOutP") ) ;

                    }
                        }
                            strReplaceF( tinP , soulOut , tm101 , tn , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ;
                            /**/if( bTrace ) traceF( tinP , T("etherSoilF / replacing tm101 with null") ) ;
                            strReplaceF( tinP , soulOut , tm001 , tn , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ;
                            /**/if( bTrace ) traceF( tinP , T("etherSoilF / replacing tm001 with null") ) ;
                            TN( tn , "" ) ;
                        {
                        else
                        }
                            strReplaceF( tinP , soulOut , tm101 , tFlag3 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ;
                            /**/if( bTrace ) traceF( tinP , T("etherSoilF / replacing tm101 with tFlag3") ) ;
                            strReplaceF( tinP , soulOut , tm001 , tFlag2 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ;
                            /**/if( bTrace ) traceF( tinP , T("etherSoilF / replacing tm001 with tFlag2") ) ;
                        {
                        if( cFlag1 )

                        }
                            strFuseF( tinP , soulOut , tAll ) ;

                            ;
                                : t1+tsp+t2+t3+t4
                                ? t1+tsp+t2
                            TN( tAll , "" ) ; tAll = cFlag1 <= CfLAG1mAX

                            TN( t4 , " were flagged]\r\n" ) ;
                            TN( t3 , "" ) ; t3 = TF2((countT)CfLAG1mAX,flFORMAT_NObIGITvALUES) ;
                            TN( t2 , cFlag1 <= CfLAG1mAX ? " detected]\r\n" : " detected (only the woth " ) ;
                            TN( tsp , cFlag1 == 1 ? " error was" : " errors were" ) ;
                            TN( t1  , "\r\n\r\n" ) ; t1 += tFlag1+T("[")+TF2(cFlag1,flFORMAT_NObIGITvALUES) ;
                        {
                        if( cFlag1 )
                    {
                    if( idModeP == ifcIDmODEeTHERsOIL_LINT )

                    }
                        }
                            }
                                break ;

                                soulOut.removeAllF( tinP ) ;
                            {
                            case ifcIDmODEeTHERsOIL_TRIM :
                            }
                                break ;

                                strFuseF( tinP , soulOut , tAll ) ;

                                TN( tAll , "" ) ; tAll = T("\r\n\r\n")+tFlag1+t1+t2 ;

                                TN( t2 , "" ) ; t2 = T(" unmatched ")+tco+tsp ;
                                TN( tsp , scNest == 1 ? " curly bracket]" : " curly brackets]" ) ;
                                TN( tco , bNeg ? "close" : "open" ) ;
                                TN( t1  , "" ) ; t1 = T(scNest==1?"[there is ":"[there are ")+TF2(scNest,flFORMAT_NObIGITvALUES) ;
                            {
                            case ifcIDmODEeTHERsOIL_LINT :
                        {
                        switch( idModeP )

                        }
                            scNest = - scNest ;
                            bNeg = 1 ;
                        {
                        if( scNest < 0 )
                        ZE( boolT , bNeg ) ;

                        cFlag1 ++ ;
                    {
                    if( scNest )
                {
                else
                }
                    traceF( tinP , T("etherSoilF / generating report / 0") ) ;
                    __NZ( soulOut ) ;

#endif
                    }
                        soulOutP << soulReport6 ;
                        soulOutP << (strokeS*)T("Journal") ;

                        strFuseF( tinP , soulReport6 , tTail ) ;
                         DEL( pStJournal ) ;
                        }
                            delF( tinP , psttJournal ) ;
                            strFuseF( tinP , soulReport6 , tSuffix ) ;
                            strFuseF( tinP , soulReport6 , psttJournal ) ;
                            strFuseF( tinP , soulReport6 , tPrefix ) ;
                            *pStJournal >> psttJournal ;
                            ZE( strokeS* , psttJournal ) ;
                        {
                        if( pStJournal ) while( *pStJournal )
                        strFuseF( tinP , soulReport6 , tHead ) ;
                        soulC soulReport6( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report6" ) ;

                        countT cJournal = pStJournal ? *pStJournal : 0 ;
                        TN( tSuffix , " }\r\n" ) ;
                        TN( tPrefix , "        {t: " ) ;
                        TN( tTail , "    }\r\n}\r\n" ) ;

                        }
                            ;

                                +TT4(grandMax1,grandMax2,4,8)+T("                                        }\r\n\r\n    {body:\r\n\r\n")
                                 TT4(timeN1,timeN2,4,8)  +T("                                        }\r\n    {lathtime: ")

                            tHead +=

                            osTimeNowF( tinP , timeN1 , timeN2 ) ;
                            ZE( sCountT , timeN2 ) ;
                            ZE( countT  , timeN1 ) ;
                        {

                        ) ;
                            "    {time:     "
                            "    {source:   ideafarm.com                                       }\r\n"
                            "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
                            "    {name:     Journal                                            }\r\n"
                            "\r\n"
                            "{report:\r\n"
                            "\r\n"

                        TN( tHead ,
                    {
                    traceF( tinP , T("etherSoilF / generating report / 1") ) ;

                    }
                        soulOutP << soulReport5 ;
                        soulOutP << (strokeS*)T("Log") ;

                        strFuseF( tinP , soulReport5 , tTail ) ;
                        DEL( pStLog ) ;
                        }
                            delF( tinP , psttLog ) ;
                            strFuseF( tinP , soulReport5 , tSuffix ) ;
                            strFuseF( tinP , soulReport5 , psttLog ) ;
                            strFuseF( tinP , soulReport5 , tPrefix ) ;
                            *pStLog >> psttLog ;
                            ZE( strokeS* , psttLog ) ;
                        {
                        if( pStLog ) while( *pStLog )
                        strFuseF( tinP , soulReport5 , tHead ) ;
                        soulC soulReport5( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report5" ) ;

                        countT cLog = pStLog ? *pStLog : 0 ;
                        TN( tSuffix , " }\r\n" ) ;
                        TN( tPrefix , "        {t: " ) ;
                        TN( tTail , "    }\r\n}\r\n" ) ;

                        }
                            ;

                                +TT4(grandMax1,grandMax2,4,8)+T("                                        }\r\n\r\n    {body:\r\n\r\n")
                                 TT4(timeN1,timeN2,4,8)  +T("                                        }\r\n    {lathtime: ")

                            tHead +=

                            osTimeNowF( tinP , timeN1 , timeN2 ) ;
                            ZE( sCountT , timeN2 ) ;
                            ZE( countT  , timeN1 ) ;
                        {

                        ) ;
                            "    {time:     "
                            "    {source:   ideafarm.com                                       }\r\n"
                            "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
                            "    {name:     Log                                                }\r\n"
                            "\r\n"
                            "{report:\r\n"
                            "\r\n"

                        TN( tHead ,
                    {
                    traceF( tinP , T("etherSoilF / generating report / 2") ) ;

                    }
                        soulOutP << soulReport4 ;
                        soulOutP << (strokeS*)T("Things.To.Do.Abridged") ;

                        soulOutP << soulReport3 ;
                        soulOutP << (strokeS*)T("Things.To.Do.Full") ;

                        strFuseF( tinP , soulReport4 , tTail ) ;
                        strFuseF( tinP , soulReport3 , tTail ) ;
                        DEL( pStDo ) ;
                        }
                            }
                                delF( tinP , psttDo ) ;

                                }
                                    delF( tinP , psttDoShort ) ;

                                    strFuseF( tinP , soulReport4 , tSuffix ) ;
                                    strFuseF( tinP , soulReport4 , TP( psttDoShort , CSTTdOsHORT ) ) ;
                                    strFuseF( tinP , soulReport4 , tPrefix ) ;

                                    strSubstringF( tinP , psttDoShort , idf , idl , psttDo ) ; ___( psttDoShort ) ;
                                    countT idl = psttDo->idAdam < CSTTdOsHORT ? psttDo->idAdam : CSTTdOsHORT ;
                                    countT idf = 1 ;

                                    ZE( strokeS* , psttDoShort ) ;
                                {
                                )
                                    1 != strIdF( tinP , tNix7 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix6 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix5 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix4 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix3 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix2 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix1 , psttDo ) //CS: 330021C0 330021C0: DUPLICATE CODE
                                (
                                if

                                strFuseF( tinP , soulReport3 , tSuffix ) ;
                                strFuseF( tinP , soulReport3 , psttDo ) ;
                                strFuseF( tinP , soulReport3 , tPrefix ) ;

                                *pStDo >> psttDo ;
                                ZE( strokeS* , psttDo ) ;
                            {
                            while( *pStDo )
                        {
                        if( pStDo )
                        strFuseF( tinP , soulReport4 , tHeadAbridged ) ;
                        strFuseF( tinP , soulReport3 , tHeadFull ) ;
                        soulC soulReport4( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report4" ) ;
                        soulC soulReport3( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report3" ) ;

                        }
                            while( ~hWalk ) ;
                            }
                                cDoAbridged ++ ;
                                )
                                    1 != strIdF( tinP , tNix7 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix6 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix5 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix4 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix3 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix2 , psttDo )
                                    &&
                                    1 != strIdF( tinP , tNix1 , psttDo ) //CS: 330021C0 330021C0: DUPLICATE CODE
                                (
                                if
                                strokeS* psttDo = (strokeS*)pStDo->downF( tinP , hWalk ) ;
                            {
                            do
                            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        {
                        if( pStDo && *pStDo )
                        ZE( countT , cDoAbridged ) ;
                        countT cDo = pStDo ? *pStDo : 0 ;
                        TN( tNix7 , "kt:" ) ;
                        TN( tNix6 , "sign idea:" ) ;
                        TN( tNix5 , "online:" ) ;
                        TN( tNix4 , "legal point:" ) ;
                        TN( tNix3 , "craftwork: text:" ) ;
                        TN( tNix2 , "craftwork: software:" ) ;
                        TN( tNix1 , "administrative: law:" ) ;

                        TN( tSuffix , " }\r\n" ) ;
                        TN( tPrefix , "        {a: " ) ;
                        TN( tTail , "    }\r\n}\r\n" ) ;

                        }
                            delF( tinP , psttc ) ;
                            ;

                                +TT4(grandMax1,grandMax2,4,8)+T("                         }\r\n\r\n    {body:\r\n\r\n")
                                +TT4(timeN1,timeN2,4,8)  +T("                         }\r\n    {lathtime: ")
                                +T("    {time:     ")
                                +T("\r\n")
                                +T("    }\r\n")
                                +T("\r\n")
                                +T(psttc)+T("\r\n")
                                T("\r\n")

                            tHeadAbridged +=

                            ;

                                +TT4(grandMax1,grandMax2,4,8)+T("                                        }\r\n\r\n    {body:\r\n\r\n")
                                 TT4(timeN1,timeN2,4,8)  +T("                                        }\r\n    {lathtime: ")

                            tHeadFull +=

                            strCalendarF( tinP , psttc , timeN2 ) ; ___( psttc ) ;
                            ZE( strokeS* , psttc ) ;

                            osTimeNowF( tinP , timeN1 , timeN2 ) ;
                            ZE( sCountT , timeN2 ) ;
                            ZE( countT  , timeN1 ) ;
                        {

                        ) ;
                            "\r\n"
                            "    {calendar: "
                            "\r\n"
                            "    {source:   ideafarm.com                                       }\r\n"
                            "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
                            "    {name:     Things To Do (Abridged)                            }\r\n"
                            "\r\n"
                            "{report:\r\n"
                            "\r\n"

                        TN( tHeadAbridged ,

                        ) ;
                            "    {time:     "
                            "    {source:   ideafarm.com                                       }\r\n"
                            "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
                            "    {name:     Things To Do                                       }\r\n"
                            "\r\n"
                            "{report:\r\n"
                            "\r\n"

                        TN( tHeadFull ,
                    {
                    traceF( tinP , T("etherSoilF / generating report / 3") ) ;

                    }
                        soulOutP << soulReport2 ;

                        soulOutP << (strokeS*)T("Spending.by.Category") ;

                        DEL( pSwSwBuy ) ;
                        }
                            }
                                DEL( pSwBuy ) ;
                                __Z( pSwBuy ) ;
                                switchC*& pSwBuy = *(switchC**)&(countT&)*pSwSwBuy ;
                                offStrong = pSwSwBuy->leverF( tinP , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            countT cFlavors = pSwSwBuy->cFlavorsF( tinP ) ;
                        {
                        if( pSwSwBuy )

                        strFuseF( tinP , soulReport2 , tTail ) ;
                        }
                            strFuseF( tinP , soulReport2 , tTotal ) ;
                            TN( tTotal , "\r\n            {total: " ) ; tTotal += TF3(total/100,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("}\r\n        }\r\n") ;
                        {
                        if( idsLath )

                        }
                            idsLath = pc3[ 0 ] ;

                            total += pc3[ 1 ] ;

                            strFuseF( tinP , soulReport2 , T(" }\r\n") ) ;
                            strFuseF( tinP , soulReport2 , T("            {c" ":    ")+TF3(pc3[1]/100,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TP(pstta,0x30) ) ;
                            strokeS* pstta = (strokeS*)pc3[ 2 ] ;

                            }
                                total = 0 ;

                                strFuseF( tinP , soulReport2 , tSubHead ) ;
                                TN( tSubHead , "\r\n        {strong: " ) ; tSubHead += TF2(pc3[0],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n\r\n") ; //CS:CODEsYNC 330021C0 330021C0 330021C0

                                idsLath = pc3[ 0 ] ;

                                }
                                    strFuseF( tinP , soulReport2 , tTotal ) ;
                                    TN( tTotal , "\r\n            {total: " ) ; tTotal += TF3(total/100,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("}\r\n        }\r\n") ; //CS:CODEsYNC 330021C0 330021C0 330021C0
                                {
                                if( idsLath )
                            {
                            if( idsLath != pc3[ 0 ] )

                            stSortedBuy >> pbi ;
                            byteT* pbi = (byteT*)pc3 ;
                            countT pc3[] = { 0 , 0 , 0 } ;
                        {
                        while( stSortedBuy )
                        ZE( countT  , total   ) ;
                        ZE( countT  , idsLath ) ;
                        strFuseF( tinP , soulReport2 , tHead ) ;
                        soulC soulReport2( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report2" ) ;

                        ) ;

                            "}\r\n"
                            "    }\r\n"
                            "        {n: Each value is the number of whole dollars spent on the category.  Cents are used in calculating totals but are truncated (not rounded) away when each value is reported. }\r\n"
                            "\r\n"
                            "    {notes:\r\n"
                            "\r\n"
                            "    }\r\n"

                        TN( tTail ,

                        }
                            ;

                                +TT4(grandMax1,grandMax2,4,8)+T("                                        }\r\n\r\n    {body:\r\n")
                                 TT4(timeN1,timeN2,4,8)  +T("                                        }\r\n    {lathtime: ")

                            tHead +=

                            osTimeNowF( tinP , timeN1 , timeN2 ) ;
                            ZE( sCountT , timeN2 ) ;
                            ZE( countT  , timeN1 ) ;
                        {

                        ) ;
                            "    {time:     "
                            "    {source:   ideafarm.com                                       }\r\n"
                            "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
                            "    {name:     Spending by Category                               }\r\n"
                            "\r\n"
                            "{report:\r\n"
                            "\r\n"

                        TN( tHead ,
                    {
                    traceF( tinP , T("etherSoilF / generating report / 4") ) ;
#if defined( NEVERdEFINED )

                    }
                        soulOutP << soulReport1 ;

                        soulOutP << (strokeS*)T("Time.by.Strong.by.Activity") ;

                        DEL( pSwTimeMax ) ;
                        DEL( pSwSwTimeCard ) ;
                        }
                            }
                                DEL( pSwTimeCard ) ;
                                __Z( pSwTimeCard ) ;
                                switchC*& pSwTimeCard = *(switchC**)&(countT&)*pSwSwTimeCard ;
                                offStrong = pSwSwTimeCard->leverF( tinP , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            countT cFlavors = pSwSwTimeCard->cFlavorsF( tinP ) ;
                        {
                        if( pSwSwTimeCard )

                        strFuseF( tinP , soulReport1 , T("    }\r\n}\r\n") ) ;
                        }
                            strFuseF( tinP , soulReport1 , tTotal ) ;
                            TN( tTotal , "\r\n            {total: " ) ; tTotal += TF3(t1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF2(t2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" }\r\n        }\r\n") ; //CS:CODEsYNC 330021C0 330021C0 330021C0
                            }
                                t2 ++ ;
                                t1 -= TUCK ;
                            {
                            if( t1 >= TUCK )
                            countT t2 = total2;
                            countT t1 = RC( total1 , 0x18 ) ;

                            }
                                strFuseF( tinP , soulReport1 , tSay2 ) ;
                                TN( tSay2 , "" ) ; tSay2 = T(idf==1?"\r\n":"")+T("            {c" ":    ")+TF3(t1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF3(t2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TP(psttzLeverAssign,0x30)+T(" }\r\n") ;

                                }
                                    t2 ++ ;
                                    t1 -= TUCK ;
                                {
                                if( t1 >= TUCK )
                                countT t2 = timeResult.time2 ;
                                countT t1 = RC( timeResult.time1 , 0x18 ) ;

                                }
                                    stForth >> pbd ;
                                    byteT* pbd = (byteT*)&timeResult ;
                                {
                                if( stForth )
                                timeS timeResult ;

                                }
                                    while( ~hWalk ) ;
                                    }
                                        }
                                            stForth << (byteT*)&timeTerm ;
                                            timeS& timeTerm = *(timeS*)&(countT&)swMathValues ;
                                            psttzLeverMath = psttTerm ;
                                        {
                                        else
                                        }
                                            stForth >> pbd ;
                                            byteT* pbd = (byteT*)&td ;
                                            timeS td ;

                                            osTimeAddF( tinP , t2.time1 , t2.time2 , t1.time1 , t1.time2 ) ;
                                            timeS& t2 = *(timeS*)&stForth[ 2 ] ;
                                            timeS& t1 = *(timeS*)&stForth[ 1 ] ;
                                        {
                                        else if( !strCompareF( tinP , psttTerm , tPlus ) )
                                        }
                                        {
                                        if( !strCompareF( tinP , psttTerm , tAssign ) )

                                        strokeS* psttTerm = (strokeS*)swsAssign.downF( tinP , hWalk ) ;
                                    {
                                    do
                                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( swsAssign )
                                stackC stForth( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , sizeof( timeS ) ) ;

                                psttzLeverAssign = (strokeS*)swsAssign.leverF( tinP , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavorsAssign ; idf ++ )
                            countT cFlavorsAssign = swsAssign.cFlavorsF( tinP ) ;
                        {
                        if( idsLath )

                        }
                            idsLath = pc4[ 0 ] ;

                            osTimeAddF( tinP , total1 , total2 , pc4[ 2 ] , pc4[ 1 ] ) ;

                            strFuseF( tinP , soulReport1 , T(" }\r\n") ) ;
                            strFuseF( tinP , soulReport1 , T("            {a:    ")+TF3(t1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF3(t2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TP(psttzLeverMath,0x30) ) ;

                            }
                                t2 ++ ;
                                t1 -= TUCK ;
                            {
                            if( t1 >= TUCK )
                            countT t2 = pc4[ 1 ] ;
                            countT t1 = RC( pc4[ 2 ] , 0x18 ) ;

                            timeValue.time2 = pc4[ 1 ] ;
                            timeValue.time1 = pc4[ 2 ] ;
                            timeS& timeValue = *(timeS*)&(countT&)swMathValues ;
                            psttzLeverMath = (strokeS*)pc4[ 3 ] ;

                            }
                                swMathValues.freeF( tinP ) ;
                                total2 = total1 = 0 ;
                                idsLath = pc4[ 0 ] ;

                                strFuseF( tinP , soulReport1 , tSubHead ) ;
                                TN( tSubHead , "\r\n        {strong: " ) ; tSubHead += TF2(pc4[0],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n\r\n") ; //CS:CODEsYNC 330021C0 330021C0 330021C0

                                }
                                    strFuseF( tinP , soulReport1 , tTotal ) ;
                                    TN( tTotal , "\r\n            {total: " ) ; tTotal += TF3(t1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF2(t2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" }\r\n        }\r\n") ; //CS:CODEsYNC 330021C0 330021C0 330021C0

                                    }
                                        t2 ++ ;
                                        t1 -= TUCK ;
                                    {
                                    if( t1 >= TUCK )
                                    countT t2 = total2;
                                    countT t1 = RC( total1 , 0x18 ) ;

                                    }

                                        strFuseF( tinP , soulReport1 , T(" }\r\n") ) ;

                                        }
                                            strFuseF( tinP , soulReport1 , T("    {variance: ")+TF3(v1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF2(v2,flFORMAT_NObIGITvALUES)+T(" }") ) ;

                                            }
                                                v2 ++ ;
                                                v1 -= TUCK ;
                                            {
                                            if( v1 >= TUCK )
                                            sCountT v2 = var2 ;
                                            countT v1 = RC( var1 , 0x18 ) ;

                                            osTimeSubtractF( tinP , var1 , var2 , timeBudget1 , timeBudget2 ) ;

                                            sCountT var2 = timeResult.time2 ;
                                            countT  var1 = timeResult.time1 ;

                                            strFuseF( tinP , soulReport1 , T("    {budget: ")+TF3(t1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF2(t2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" }") ) ;

                                            }
                                                t2 ++ ;
                                                t1 -= TUCK ;
                                            {
                                            if( t1 >= TUCK )
                                            countT t2 = timeBudget2 ;
                                            countT t1 = RC( timeBudget1 , 0x18 ) ;

                                            }
                                                while( ~hWalk ) ;
                                                }
                                                    osTimeAddF( tinP , timeBudget1 , timeBudget2 , add ) ;
                                                    countT add = mHours * ( TICK << 4 ) ;
                                                    measureT mHours = *(measureT*)&swsBudget.downF( tinP , hWalk ) ; // IN swsBudget, THE UNITS ARE IFC HOURS

                                                    if( !( cDo -- ) ) break ;
                                                {
                                                do
                                                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                countT cDo = 1 + offDay ;

                                                }
                                                    offDay = timeMax.time2 % 8 ;

                                                    if( !timeMax.time1 ) osTimeSubtractF( tinP , timeMax.time1 , timeMax.time2 , 1 ) ;

                                                    offStrong = save ;
                                                    timeS& timeMax = *(timeS*)&(countT&)*pSwTimeMax ;
                                                    offStrong = idsLath ;
                                                    countT save = offStrong ;
                                                {
                                                ZE( countT , offDay ) ;
                                            {
                                            if( swsBudget )
                                            ZE( sCountT , timeBudget2 ) ;
                                            ZE( countT , timeBudget1 ) ;

                                            psttzLeverBudget = psttzLeverAssign ;
                                        {
                                        if( swsBudget.idSlotOfLeverF( tinP , (countT)psttzLeverAssign ) )

                                        strFuseF( tinP , soulReport1 , tSay2 ) ;
                                        TN( tSay2 , "" ) ; tSay2 = T(idf==1?"\r\n":"")+T("            {c" ":    ")+TF3(t1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,2)+T(".")+TF3(t2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TP(psttzLeverAssign,0x30) ;

                                        }
                                            t2 ++ ;
                                            t1 -= TUCK ;
                                        {
                                        if( t1 >= TUCK )
                                        countT t2 = timeResult.time2 ;
                                        countT t1 = RC( timeResult.time1 , 0x18 ) ;

                                        }
                                            stForth >> pbd ;
                                            byteT* pbd = (byteT*)&timeResult ;
                                        {
                                        if( stForth )
                                        timeS timeResult ;

                                        }
                                            while( ~hWalk ) ;
                                            }
                                                }
                                                    stForth << (byteT*)&timeTerm ;
                                                    timeS& timeTerm = *(timeS*)&(countT&)swMathValues ;
                                                    psttzLeverMath = psttTerm ;
                                                {
                                                else
                                                }
                                                    stForth >> pbd ;
                                                    byteT* pbd = (byteT*)&td ;
                                                    timeS td ;

                                                    osTimeAddF( tinP , t2.time1 , t2.time2 , t1.time1 , t1.time2 ) ;
                                                    timeS& t2 = *(timeS*)&stForth[ 2 ] ;
                                                    timeS& t1 = *(timeS*)&stForth[ 1 ] ;
                                                {
                                                else if( !strCompareF( tinP , psttTerm , tPlus ) )
                                                }
                                                {
                                                if( !strCompareF( tinP , psttTerm , tAssign ) )

                                                strokeS* psttTerm = (strokeS*)swsAssign.downF( tinP , hWalk ) ;
                                            {
                                            do
                                            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        if( swsAssign )
                                        stackC stForth( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , sizeof( timeS ) ) ;

                                        psttzLeverAssign = (strokeS*)swsAssign.leverF( tinP , idf ) ;
                                    {
                                    for( countT idf = 1 ; idf <= cFlavorsAssign ; idf ++ )
                                    countT cFlavorsAssign = swsAssign.cFlavorsF( tinP ) ;
                                {
                                if( idsLath )
                            {
                            if( idsLath != pc4[ 0 ] )

                            stSortedCard >> pbi ;
                            byteT* pbi = (byteT*)pc4 ;
                            countT pc4[] = { 0 , 0 , 0 , 0 } ;
                        {
                        while( stSortedCard )
                        switchC swMathValues( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverMath , 0 , sizeof( timeS ) ) ;
                        ZE( strokeS* , psttzLeverMath ) ;
                        ZE( sCountT , total2  ) ;
                        ZE( countT  , total1  ) ;
                        ZE( countT  , idsLath ) ;
                        strFuseF( tinP , soulReport1 , tHead ) ;
                        soulC soulReport1( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report1" ) ;

                        }
                            ;

                                +TT4(grandMax1,grandMax2,4,8)+T("                                        }\r\n\r\n    {body:\r\n")
                                 TT4(timeN1,timeN2,4,8)  +T("                                        }\r\n    {lathtime: ")

                            tHead +=

                            osTimeNowF( tinP , timeN1 , timeN2 ) ;
                            ZE( sCountT , timeN2 ) ;
                            ZE( countT  , timeN1 ) ;
                        {

                        ) ;
                            "    {time:     "
                            "    {source:   ideafarm.com                                       }\r\n"
                            "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
                            "    {name:     Time by Strong by Activity                         }\r\n"
                            "\r\n"
                            "{report:\r\n"
                            "\r\n"

                        TN( tHead ,
                    {
                    traceF( tinP , T("etherSoilF / generating report / 5") ) ;

                    }
                        }
                            }
                                }
                                    }
                                        stSortedCard.sinkF( tinP , countTC() , (byteT*)pc4 , flSTACKsINK_null , subtractTimecard_330021c0_F ) ;
                                        countT pc4[] = { offStrong , accum.time2 , accum.time1 , (countT)psttLeverCard } ;

                                        csttActivity += psttLeverCard->idAdam ;

                                        //strokeF( tinP , TF3(accum.time1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,8)+T(".")+TF3(accum.time2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("    ")+T(psttLeverCard)+T("\r\n") ) ;
                                        timeS& accum = *(timeS*)&(countT&)*pSwTimeCard ;
                                        psttLeverCard = (strokeS*)pSwTimeCard->leverF( tinP , idf2 ) ;
                                    {
                                    for( countT idf2 = 1 ; idf2 <= cFlavors2 ; idf2 ++ )
                                {
                                if( !POOP )
                                countT cFlavors2 = pSwTimeCard->cFlavorsF( tinP ) ;
                            {
                            if( !POOP )
                            __Z( pSwTimeCard ) ;
                            switchC*& pSwTimeCard = *(switchC**)&(countT&)*pSwSwTimeCard ;
                            offStrong = pSwSwTimeCard->leverF( tinP , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cStrongCard ; idf ++ )
                        cStrongCard = pSwSwTimeCard->cFlavorsF( tinP ) ;
                    {
                    if( pSwSwTimeCard )
                    traceF( tinP , T("etherSoilF / generating report / 6") ) ;

                    }
                        }
                            }
                                }
                                    }
                                        stSortedBuy.sinkF( tinP , countTC() , (byteT*)pc3 , flSTACKsINK_null , subtractBuy_330021c0_F ) ;
                                        countT pc3[] = { offStrong , centsTotal , (countT)psttLeverBuy } ;

                                        csttCategory += psttLeverBuy->idAdam ;

                                        //strokeF( tinP , TF3(centsTotal,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FILLzE,8)+T("    ")+T(psttLeverBuy)+T("\r\n") ) ;
                                        countT centsTotal = *pSwBuy ;
                                        psttLeverBuy = (strokeS*)pSwBuy->leverF( tinP , idf2 ) ;
                                    {
                                    for( countT idf2 = 1 ; idf2 <= cFlavors2 ; idf2 ++ )
                                {
                                if( !POOP )
                                countT cFlavors2 = pSwBuy->cFlavorsF( tinP ) ;
                            {
                            if( !POOP )
                            __Z( pSwBuy ) ;
                            switchC*& pSwBuy = *(switchC**)&(countT&)*pSwSwBuy ;
                            offStrong = pSwSwBuy->leverF( tinP , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cStrongBuy ; idf ++ )
                        cStrongBuy = pSwSwBuy->cFlavorsF( tinP ) ;
                    {
                    if( pSwSwBuy )
                    traceF( tinP , T("etherSoilF / generating report / 7") ) ;

                    ZE( countT , cStrongCard ) ;
                    ZE( countT , cStrongBuy ) ;
                    ZE( countT , csttActivity ) ;
                    ZE( countT , csttCategory ) ;

                    stackC stSortedCard( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE|flSTACKc_BLOB , 4 * sizeof( countT ) ) ;
                    stackC stSortedBuy(  tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE|flSTACKc_BLOB , 3 * sizeof( countT ) ) ;

                    }
                        }
                            }
                                grandMax2 = timeMax.time2 ;
                                grandMax1 = timeMax.time1 ;
                            {
                            )
                                )
                                    grandMax1 < timeMax.time1
                                    &&
                                    grandMax2 == timeMax.time2
                                (
                                ||
                                grandMax2 < timeMax.time2
                            (
                            if
                            timeS& timeMax = *(timeS*)&(countT&)*pSwTimeMax ;
                            offStrong = pSwTimeMax->leverF( tinP , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        countT cFlavors = pSwTimeMax->cFlavorsF( tinP ) ;
                    {
                    if( pSwTimeMax )
                    ZE( sCountT , grandMax2 ) ;
                    ZE( countT  , grandMax1 ) ;
                    traceF( tinP , T("etherSoilF / generating report / 8") ) ;
                {
                if( !bQuitP && idModeP == ifcIDmODEeTHERsOIL_REPORT )

                /**/if( bTrace ) traceF( tinP , T("etherSoilF / generating reports") ) ;

                }
                    //LOGrAW3( "default soil processing [soulWords]: " , soulWords , " /-\r\n" ) ;

                    delF( tinP , psttWord ) ;
                    }
                        }
                            break ;

                            if( !bDone ) strFuseF( tinP , soulOut , psttWord ) ;
                        {
                        case ifcIDmODEeTHERsOIL_LINT :
                    {
                    switch( idModeP )

                    }
                        }
                            }
                                }
                                    }
                                        delF( tinP , psttKey ) ;
                                        delF( tinP , psttv ) ;
                                        }
                                            }
                                                break ;

                                                }
                                                    delF( tinP , psttvt ) ;
                                                    strFuseSeparateF( tinP , soulOut , psttvt ) ;
                                                    strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
                                                    ZE( strokeS* , psttvt ) ;

                                                    if( !psttKeyP ) strFuseSeparateF( tinP , soulOut , psttKey ) ;
                                                {
                                                if( !psttKeyP || !strCompareF( tinP , psttKey , psttKeyP ) )
                                            {
                                            case ifcIDmODEeTHERsOIL_QUERYvALUES :
                                            }
                                                break ;

                                                delF( tinP , psttvt ) ;
                                                strFuseF( tinP , soulOut , psttvt ) ;
                                                strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
                                                ZE( strokeS* , psttvt ) ;

                                                strFuseF( tinP , soulOut , tColon ) ;
                                                strFuseF( tinP , soulOut , psttKey ) ;
                                            {
                                            case ifcIDmODEeTHERsOIL_TRIM :
                                            }
                                                break ;

                                                }
                                                    }
/*N.U*/                                                 break ;
/*N.U*/                                                 }
/*N.U*/                                                     }
/*N.U*/                                                         }
/*N.U*/                                                             break ;
/*N.U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N.U*/                                                         {
/*N.U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N.U*/                                                     {
/*N.U*/                                                     switch( idModeP )
/*N.U*/
/*N.U*/                                                     //traceF( tinP , "COMMENT / * / * ...\r\n" ) ;
/*N.U*/                                                 {
/*N.U*/                                                 if( !strCompareF( tinP , tKeyLevel1 , tKeyComment ) )
                                                    {
                                                    default :
                                                    }
/*N3U*/                                                 break ;
/*N3U*/                                                 }
/*N3U*/                                                     }
/*N3U*/                                                         }
/*N3U*/                                                             }
/*N3U*/                                                                 break ;
/*N3U*/
/*N3U*/                                                                 //delF( tinP , psttvt ) ;
/*N3U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N3U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N3U*/                                                             {
/*N3U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N3U*/                                                             }
/*N3U*/                                                                 break ;
/*N3U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N3U*/                                                             {
/*N3U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N3U*/                                                         {
/*N3U*/                                                         switch( idModeP )
/*N3U*/
/*N3U*/                                                         }
/*N3U*/                                                             delF( tinP , psttvt ) ;
/*N3U*/                                                             }
/*N3U*/                                                                 delF( tinP , pstt1w ) ;
/*N3U*/                                                                 }
/*N3U*/                                                                     }
/*N3U*/                                                                         default : { break ; }
/*N3U*/                                                                         }
/*N3U*/                                                                             break ;
/*N3U*/
/*N3U*/                                                                             delF( tinP , postv ) ;
/*N3U*/                                                                             }
/*N3U*/                                                                                 strMakeFromOsTextF( tinP , psttValue , postv ) ; ___( psttValue ) ;
/*N3U*/                                                                                 delF( tinP , psttValue ) ;
/*N3U*/                                                                                 strokeS*& psttValue = *(strokeS**)&(countT&)swSettings ;
/*N3U*/                                                                                 psttzLeverSettings = tKey ;
/*N3U*/                                                                             {
/*N3U*/                                                                             else
/*N3U*/                                                                             if( POOP ) POOPR
/*N3U*/
/*N3U*/                                                                             tinP.pEtScratch->boxGetShadowF( tinP , postv , costv , psttc1 , 1 ) ; ___( postv ) ;
/*N3U*/                                                                             ZE( countT   , costv ) ;
/*N3U*/                                                                             ZE( osTextT* , postv ) ;
/*N3U*/
/*N3U*/                                                                             SCOOPS
/*N3U*/                                                                         {
/*N3U*/                                                                         case 2 :
/*N3U*/                                                                         case 1 : { tKey = tSettingsKeyPrefix+T(psttc1) ; break ; }
/*N3U*/                                                                     {
/*N3U*/                                                                     switch( ++ idIn )
/*N3U*/                                                                 {
/*N3U*/                                                                 FORsTRINGSiN1( pstt1w )
/*N3U*/                                                                 TN( tKey , "" ) ;
/*N3U*/                                                                 ZE( countT , idIn ) ;
/*N3U*/                                                                 traceF( tinP , T("called strWordsF a") ) ;
/*N3U*/                                                                 strWordsF( tinP , pstt1w , psttvt , sttq ) ; ___( pstt1w ) ;
/*N3U*/                                                                 traceF( tinP , T("calling strWordsF a") ) ;
/*N3U*/                                                                 strokeS sttq ;
/*N3U*/                                                                 ZE( strokeS* , pstt1w ) ;
/*N3U*/                                                             {
/*N3U*/                                                             if( psttvt && psttvt->idAdam )
/*N3U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N3U*/                                                             ZE( strokeS* , psttvt ) ;
/*N3U*/                                                         {
/*N3U*/                                                         IFsCRATCH
/*N3U*/
/*N3U*/                                                         //bAllowLevel3 = 1 ;
/*N3U*/                                                         //bAllowLevel2 = 0 ;
/*N3U*/                                                         //traceF( tinP , "SETTINGS / KVFPAIR\r\n" ) ;
/*N3U*/                                                     {
/*N3U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyKVF ) )
/*N3U*/                                                     }
/*N3U*/                                                         }
/*N3U*/                                                             }
/*N3U*/                                                                 break ;
/*N3U*/
/*N3U*/                                                                 //delF( tinP , psttvt ) ;
/*N3U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N3U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N3U*/                                                             {
/*N3U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N3U*/                                                             }
/*N3U*/                                                                 break ;
/*N3U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N3U*/                                                             {
/*N3U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N3U*/                                                         {
/*N3U*/                                                         switch( idModeP )
/*N3U*/
/*N3U*/                                                         }
/*N3U*/                                                             delF( tinP , psttvt ) ;
/*N3U*/                                                             }
/*N3U*/                                                                 delF( tinP , pstt1w ) ;
/*N3U*/                                                                 }
/*N3U*/                                                                     }
/*N3U*/                                                                         default : { break ; }
/*N3U*/                                                                         }
/*N3U*/                                                                             break ;
/*N3U*/
/*N3U*/                                                                             strMakeF( tinP , psttValue , psttc1 ) ; ___( psttValue ) ;
/*N3U*/                                                                             delF( tinP , psttValue ) ;
/*N3U*/                                                                             strokeS*& psttValue = *(strokeS**)&(countT&)swSettings ;
/*N3U*/                                                                             psttzLeverSettings = tKey ;
/*N3U*/                                                                         {
/*N3U*/                                                                         case 2 :
/*N3U*/                                                                         case 1 : { tKey = tSettingsKeyPrefix+T(psttc1) ; break ; }
/*N3U*/                                                                     {
/*N3U*/                                                                     switch( ++ idIn )
/*N3U*/                                                                 {
/*N3U*/                                                                 FORsTRINGSiN1( pstt1w )
/*N3U*/                                                                 TN( tKey , "" ) ;
/*N3U*/                                                                 ZE( countT , idIn ) ;
/*N3U*/                                                                 traceF( tinP , T("called strWordsF 9") ) ;
/*N3U*/                                                                 strWordsF( tinP , pstt1w , psttvt , sttq ) ; ___( pstt1w ) ;
/*N3U*/                                                                 traceF( tinP , T("calling strWordsF 9") ) ;
/*N3U*/                                                                 strokeS sttq ;
/*N3U*/                                                                 ZE( strokeS* , pstt1w ) ;
/*N3U*/                                                             {
/*N3U*/                                                             if( psttvt && psttvt->idAdam )
/*N3U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N3U*/                                                             ZE( strokeS* , psttvt ) ;
/*N3U*/                                                         {
/*N3U*/
/*N3U*/                                                         //bAllowLevel3 = 1 ;
/*N3U*/                                                         //bAllowLevel2 = 0 ;
/*N3U*/                                                         //traceF( tinP , "SETTINGS / KVPAIR\r\n" ) ;
/*N3U*/                                                     {
/*N3U*/                                                     if( !strCompareF( tinP , psttKey , tKeyKV ) )
/*N3U*/                                                 {
/*N3U*/                                                 )
/*N3U*/                                                     || !strCompareF( tinP , tKeyLevel2 , tKeyKtr       )
/*N3U*/                                                     || !strCompareF( tinP , tKeyLevel2 , tKeyIPDOS     )
/*N3U*/                                                     || !strCompareF( tinP , tKeyLevel2 , tKeyCloudView )
/*N3U*/                                                        !strCompareF( tinP , tKeyLevel2 , tKeyCloud     )
/*N3U*/                                                 (
/*N3U*/                                                 else if
/*N3U*/                                                 }
/*N3U*/                                                     }
/*N3U*/                                                         }
/*N3U*/                                                             break ;
/*N3U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N3U*/                                                         {
/*N3U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N3U*/                                                     {
/*N3U*/                                                     switch( idModeP )
/*N3U*/
/*N3U*/                                                     }
/*N3U*/                                                         delF( tinP , pstt1w ) ;
/*N3U*/
/*N3U*/                                                         }
/*N3U*/                                                             stTimeMinMax << (byteT*)ppstt2 ;
/*N3U*/
/*N3U*/                                                             //traceF( tinP , T("stTimeMinMax + [ppstt2[0],ppstt2[1]]:    \"")+T(ppstt2[0])+T("\"    \"")+T(ppstt2[1])+T("\"") ) ;
/*N3U*/
/*N3U*/                                                             strMakeF( tinP , ppstt2[ 1 ] , psttzMax ) ; ___( ppstt2[ 1 ] ) ;
/*N3U*/                                                             strMakeF( tinP , ppstt2[ 0 ] , psttzMin ) ; ___( ppstt2[ 0 ] ) ;
/*N3U*/                                                             strokeS* ppstt2[] = { 0 , 0 } ;
/*N3U*/                                                         {
/*N3U*/                                                         if( psttzMin && psttzMax )
/*N3U*/
/*N3U*/                                                         }
/*N3U*/                                                             }
/*N3U*/                                                                 }
/*N3U*/                                                                     break ;
/*N3U*/                                                                     psttzMax = psttc1 ;
/*N3U*/                                                                 {
/*N3U*/                                                                 else
/*N3U*/                                                                 }
/*N3U*/                                                                     psttzMin = psttc1 ;
/*N3U*/                                                                     bMin = 0 ;
/*N3U*/                                                                 {
/*N3U*/                                                                 if( bMin )
/*N3U*/                                                             {
/*N3U*/                                                             FORsTRINGSiN1( pstt1w )
/*N3U*/                                                             boolT bMin = 1 ;
/*N3U*/                                                         {
/*N3U*/                                                         ZE( strokeS* , psttzMax ) ;
/*N3U*/                                                         ZE( strokeS* , psttzMin ) ;
/*N3U*/
/*N3U*/                                                         delF( tinP , psttvt ) ;
/*N3U*/                                                         traceF( tinP , T("called strWordsF 8") ) ;
/*N3U*/                                                         strWordsF( tinP , pstt1w , psttvt , sttq  ) ; ___( pstt1w ) ;
/*N3U*/                                                         traceF( tinP , T("calling strWordsF 8") ) ;
/*N3U*/                                                         strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
/*N3U*/                                                         ZE( strokeS* , pstt1w ) ;
/*N3U*/
/*N3U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N3U*/                                                         ZE( strokeS* , psttvt ) ;
/*N3U*/                                                     {
/*N3U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyTimeRange ) )
/*N3U*/                                                     }
/*N3U*/                                                         }
/*N3U*/                                                             if( !ids ) delF( tinP , psttvt ) ;
/*N3U*/                                                             stFileType.sinkF( tinP , ids , psttvt , flSTACKsINK_UNIQUE ) ;
/*N3U*/                                                             ZE( countT , ids ) ;
/*N3U*/                                                         {
/*N3U*/                                                         if( psttvt && psttvt->idAdam )
/*N3U*/
/*N3U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N3U*/                                                         ZE( strokeS* , psttvt ) ;
/*N3U*/                                                     {
/*N3U*/                                                     if( !strCompareF( tinP , psttKey , tKeyFileType ) )
/*N3U*/                                                 {
/*N3U*/                                                 if( !strCompareF( tinP , tKeyLevel2 , tKeyFilter ) )
/*N3U*/                                                 tKeyLevel3 = T(psttKey) ;
                                                    {
                                                    case 3 :
                                                    }
/*N2U*/                                                 break ;
/*N2U*/                                                 }
/*N2U*/                                                     }
/*N2U*/                                                         if( idModeP == ifcIDmODEeTHERsOIL_LINT ) strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("set obeying tKeyNameSpace for KTR [tNameSpace]: ")+tNameSpace ) ; //U:: TO FIND A BUG
/*N2U*/                                                                 tNameSpace = T(psttvt) ;
/*N2U*/                                                                 //strokeF( tinP , T("[folder]: \"")+T(psttvt)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv , 0 , T(TbLACK "\"")  ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("trimming [psttv]: >>>>")+T(psttv)+T("<<<<") ) ; //U:: TO FIND A BUG
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "EDIT|REPORT|ZIP|INSPECT / NAMESPACE\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyNameSpace ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 }
/*N2U*/                                                                     delF( tinP , psttm ) ;
/*N2U*/                                                                     //traceF( tinP , T("set 9 [tArchive]: ")+tArchive ) ;
/*N2U*/                                                                     tArchive = T(psttm) ;
/*N2U*/                                                                     diskMapFileNameF( tinP , psttm , T("///ideafarm/IdeaFarm (tm)/")+( tUserOverride.csF( tinP ) ? tUserOverride : tUser )+T("/Drop Files Here To Archive/") ) ; ___( psttm ) ;
/*N2U*/                                                                     ZE( strokeS* , psttm ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 else
/*N2U*/                                                                 }
/*N2U*/                                                                     //traceF( tinP , T("set 8 [tArchive]: ")+tArchive ) ;
/*N2U*/                                                                     tArchive = tReportsSource ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( tReportsSource.csF( tinP ) )
/*N2U*/
/*N2U*/                                                                 traceF( tinP , T("EDIT|REPORT|ZIP|INSPECT / SOURCE set [tReportsSource]: ")+tReportsSource ) ;
/*N2U*/                                                                 tReportsSource = T(psttvt) ;
/*N2U*/                                                                 traceF( tinP , T("DOjOBS / JOBqUEUE [jobqueuefolder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 traceF( tinP , T("[reportssource]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "EDIT|REPORT|ZIP|INSPECT / SOURCE\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeySource ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 if( idModeP == ifcIDmODEeTHERsOIL_LINT ) strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 }
/*N2U*/                                                                     }
/*N2U*/                                                                         if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; }
/*N2U*/                                                                         cFlag1 ++ ;
/*N2U*/                                                                     {
/*N2U*/                                                                     if( !bFound )
/*N2U*/
/*N2U*/                                                                     }
/*N2U*/                                                                         }
/*N2U*/                                                                             bFound = 0 ;
/*N2U*/                                                                             POOPR
/*N2U*/                                                                         {
/*N2U*/                                                                         if( POOP )
/*N2U*/                                                                         bFound = tinP.pEtScratch->diskFileExistsF( tinP , tLike ) ;
/*N2U*/                                                                         TN( tLike , "" ) ; tLike = T("///ideafarm/IdeaFarm (tm)/")+T(psttvt)+T("/*") ;
/*N2U*/                                                                         SCOOPS
/*N2U*/                                                                     {
/*N2U*/                                                                     IFsCRATCH
/*N2U*/                                                                     ZE( boolT , bFound ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 else
/*N2U*/                                                                 }
/*N2U*/                                                                     }
/*N2U*/                                                                         delF( tinP , psttm ) ;
/*N2U*/                                                                         //traceF( tinP , T("set 2 [tArchive]: ")+tArchive ) ;
/*N2U*/                                                                         tArchive = T(psttm) ;
/*N2U*/                                                                         diskMapFileNameF( tinP , psttm , T("///ideafarm/IdeaFarm (tm)/")+( tUserOverride.csF( tinP ) ? tUserOverride : tUser )+T("/Drop Files Here To Archive/") ) ; ___( psttm ) ;
/*N2U*/                                                                         ZE( strokeS* , psttm ) ;
/*N2U*/                                                                     {
/*N2U*/                                                                     if( !tReportsSource.csF( tinP ) )
/*N2U*/                                                                     tUserOverride = T(psttvt) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( idModeP == ifcIDmODEeTHERsOIL_REPORT )
/*N2U*/
/*N2U*/                                                                 //strokeF( tinP , T("[file]: \"")+T(psttvt)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "EDIT|REPORT|ZIP|INSPECT / USER\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyUser ) )
/*N2U*/                                                     }
/*N2U*/                                                         if( idModeP == ifcIDmODEeTHERsOIL_LINT ) strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyFilter ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 tReportsFolder = T(psttvt) ;
/*N2U*/                                                                 traceF( tinP , T("[reportsfolder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "EDIT|REPORT|ZIP|INSPECT / FOLDER\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyFolder ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 tJobQueueFolder = T(psttvt) ;
/*N2U*/                                                                 traceF( tinP , T(" EDIT|REPORT|ZIP|INSPECT / JOBqUEUE [jobqueuefolder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "EDIT|REPORT|ZIP|INSPECT / JOBqUEUE\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyJobQueue ) )
/*N2U*/                                                 {
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyEdit ) || !strCompareF( tinP , tKeyLevel1 , tKeyReport ) || !strCompareF( tinP , tKeyLevel1 , tKeyZip ) || !strCompareF( tinP , tKeyLevel1 , tKeyInspectFileNames ) )
/*N2U*/                                                 }
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/                                                     {
/*N2U*/                                                     else
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("set obeying tKeyNameSpace for KTR [tNameSpace]: ")+tNameSpace ) ; //U:: TO FIND A BUG
/*N2U*/                                                                 tNameSpace = T(psttvt) ;
/*N2U*/                                                                 //strokeF( tinP , T("[folder]: \"")+T(psttvt)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv , 0 , T(TbLACK "\"")  ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("trimming [psttv]: >>>>")+T(psttv)+T("<<<<") ) ; //U:: TO FIND A BUG
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "KTR / NAMESPACE\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyNameSpace ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttv ) ; // CAN BE LARGE, AND DON'T NEED IT ANY MORE
/*N2U*/                                                                 soulValue << psttv ;
/*N2U*/                                                                 //traceF( tinP , T("pushing [psttv]: \"")+T(psttv)+T("\"\r\n") ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         bAllowLevel2 = 0 ;
/*N2U*/                                                         //traceF( tinP , "KTR / BODY\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyBody ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , pstt1w ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                     if( !strCompareF( tinP , psttc1 , tFlagFragNote ) ) flagsReport  |= flETHERsOILrEPORT_FRAGnOTE ;
/*N2U*/                                                                     if( !strCompareF( tinP , psttc1 , tFlagBeep     ) ) flagsPutFile |= flBRANCHspUTfILEf_BEEP  ;
/*N2U*/                                                                     if( !strCompareF( tinP , psttc1 , tFlagNoZip    ) ) flagsPutFile |= flBRANCHspUTfILEf_NOzIP ;
/*N2U*/                                                                     if( !strCompareF( tinP , psttc1 , tNoRef        ) ) flagsLoad    |= flBRANCHslOADf_NOrEFERENCES ;
/*N2U*/                                                                 {
/*N2U*/                                                                 FORsTRINGSiN1( pstt1w )
/*N2U*/                                                                 traceF( tinP , T("called strWordsF 7") ) ;
/*N2U*/                                                                 strWordsF( tinP , pstt1w , psttv , sttq ) ; ___( pstt1w ) ;
/*N2U*/                                                                 traceF( tinP , T("calling strWordsF 7") ) ;
/*N2U*/                                                                 strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
/*N2U*/                                                                 ZE( strokeS* , pstt1w ) ;
/*N2U*/
/*N2U*/                                                                 //strokeF( tinP , T("[flags]: \"")+T(psttv)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "KTR / FLAGS\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyFlags ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                     }
/*N2U*/                                                                         delF( tinP , postv ) ;
/*N2U*/                                                                         else       tHtmlHead = T(postv) ;
/*N2U*/                                                                         if( POOP ) POOPR
/*N2U*/
/*N2U*/                                                                         tinP.pEtScratch->boxGetShadowF( tinP , postv , costv , psttvt , 1 ) ; ___( postv ) ;
/*N2U*/                                                                         ZE( countT   , costv ) ;
/*N2U*/                                                                         ZE( osTextT* , postv ) ;
/*N2U*/
/*N2U*/                                                                         SCOOPS
/*N2U*/
/*N2U*/                                                                         traceF( tinP , T("ktr [htmlhead file name]: ")+T(psttvt) ) ;
/*N2U*/                                                                     {
/*N2U*/                                                                     IFsCRATCH
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "KTR / HTMLHEAD\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyHtmlHead ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                     }
/*N2U*/                                                                         delF( tinP , postv ) ;
/*N2U*/                                                                         else       tHtmlBodySuffix = T(postv) ;
/*N2U*/                                                                         if( POOP ) POOPR
/*N2U*/
/*N2U*/                                                                         tinP.pEtScratch->boxGetShadowF( tinP , postv , costv , psttvt , 1 ) ; ___( postv ) ;
/*N2U*/                                                                         ZE( countT   , costv ) ;
/*N2U*/                                                                         ZE( osTextT* , postv ) ;
/*N2U*/
/*N2U*/                                                                         SCOOPS
/*N2U*/
/*N2U*/                                                                         traceF( tinP , T("ktr [htmlbodysuffix file name]: ")+T(psttvt) ) ;
/*N2U*/                                                                     {
/*N2U*/                                                                     IFsCRATCH
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "KTR / HTMLBODYSUFFIX\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyHtmlBodySuffix ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                     }
/*N2U*/                                                                         delF( tinP , postv ) ;
/*N2U*/                                                                         else       tHtmlBodyPrefix = T(postv) ;
/*N2U*/                                                                         if( POOP ) POOPR
/*N2U*/
/*N2U*/                                                                         tinP.pEtScratch->boxGetShadowF( tinP , postv , costv , psttvt , 1 ) ; ___( postv ) ;
/*N2U*/                                                                         ZE( countT   , costv ) ;
/*N2U*/                                                                         ZE( osTextT* , postv ) ;
/*N2U*/
/*N2U*/                                                                         SCOOPS
/*N2U*/
/*N2U*/                                                                         traceF( tinP , T("ktr [htmlbodyprefix file name]: ")+T(psttvt) ) ;
/*N2U*/                                                                     {
/*N2U*/                                                                     IFsCRATCH
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "KTR / HTMLBODYPREFIX\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyHtmlBodyPrefix ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                     tHtmlFolder = T(psttvt) ;
/*N2U*/                                                                     traceF( tinP , T("ktr [htmlfolder name]: ")+T(psttvt) ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "KTR / HTMLFOLDER\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyHtmlFolder ) )
/*N2U*/                                                     }
/*N2U*/                                                         delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 //strokeF( tinP , T("[mode]: \"")+T(psttv)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N2U*/                                                             {
/*N2U*/                                                             switch( idModeP )
/*N2U*/                                                             cFlag1 ++ ;
/*N2U*/                                                         {
/*N2U*/                                                         if( !idKtrMode )
/*N2U*/
/*N2U*/                                                         ;
/*N2U*/                                                             : ifcIDmODEpUTfILE_OTHER //U:: SET AN ERROR AND REFUSE TO PROCESS THE INPUT
/*N2U*/                                                             ? ifcIDmODEpUTfILE_OTHER
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeOther )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_IPDOS
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeIpdos )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_PAY
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModePay )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_WO
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeWo )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_ARCHIVE
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeArchive )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_ESSAYS
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeEssays )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_NEWS
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeNews )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_BUNDLE
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeBundle )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_HOOKS
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeHooks )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_TUTORIALS
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModeTutorials )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_PAID
/*N2U*/                                                             : !strCompareF( tinP , psttvt , tValueKtrModePaid )
/*N2U*/                                                             ? ifcIDmODEpUTfILE_ROOT
/*N2U*/                                                         idKtrMode = !strCompareF( tinP , psttvt , tValueKtrModeRoot )
/*N2U*/
/*N2U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                         ZE( strokeS* , psttvt ) ;
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "KTR / MODE\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyMode ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("set obeying tKeyFolder for KTR [tFolder]: ")+tFolder ) ; //U:: TO FIND A BUG
/*N2U*/                                                                 tFolder = T(psttvt) ;
/*N2U*/                                                                 //strokeF( tinP , T("[folder]: \"")+T(psttvt)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv , 0 , T(TbLACK "\"")  ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                                 traceF( tinP , T("trimming [psttv]: >>>>")+T(psttv)+T("<<<<") ) ; //U:: TO FIND A BUG
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "KTR / FOLDER\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyFolder ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 tFile = T(psttvt) ;
/*N2U*/                                                                 //strokeF( tinP , T("[file]: \"")+T(psttvt)+T("\"\r\n") ) ; //U::REMOVE IN PRODUCTION
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "KTR / FILE\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyFile ) )
/*N2U*/                                                 {
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyKtr ) )
/*N2U*/                                                 }
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 }
/*N2U*/                                                                     delF( tinP , pstt1Terms ) ;
/*N2U*/                                                                     }
/*N2U*/                                                                         }
/*N2U*/                                                                             swsAssign << psttTerm ;
/*N2U*/                                                                             strMakeF( tinP , psttTerm , psttc1 ) ; ___( psttTerm ) ;
/*N2U*/                                                                             ZE( strokeS* , psttTerm ) ;
/*N2U*/                                                                         {
/*N2U*/                                                                         else
/*N2U*/                                                                         }
/*N2U*/                                                                             }
/*N2U*/                                                                                 swsAssign.purgeF( tinP ) ;
/*N2U*/                                                                                 bGotAssign = 1 ;
/*N2U*/                                                                             {
/*N2U*/                                                                             else
/*N2U*/                                                                             if( strCompareF( tinP , tAssign , psttc1 ) ) break ;
/*N2U*/                                                                         {
/*N2U*/                                                                         else if( !bGotAssign )
/*N2U*/                                                                         if( BwOTHsTRING1 ) psttzLeverAssign = psttc1 ;
/*N2U*/                                                                     {
/*N2U*/                                                                     FORsTRINGSiN1( pstt1Terms )
/*N2U*/                                                                     ZE( boolT , bGotAssign ) ;
/*N2U*/
/*N2U*/                                                                     traceF( tinP , T("called strWordsF 6") ) ;
/*N2U*/                                                                     strWordsF( tinP , pstt1Terms , psttvt , sttq ) ; ___( pstt1Terms ) ;
/*N2U*/                                                                     traceF( tinP , T("calling strWordsF 6") ) ;
/*N2U*/                                                                     strokeS sttq ;
/*N2U*/                                                                     ZE( strokeS* , pstt1Terms ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "MATH / CALCULATE\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyCalculate ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 }
/*N2U*/                                                                     delF( tinP , pstt1Terms ) ;
/*N2U*/                                                                     }
/*N2U*/                                                                         else swsBudget << (measureT)strDigitsToMeasureF( tinP , psttc1 ) ;
/*N2U*/                                                                         }
/*N2U*/                                                                             }
/*N2U*/                                                                                 swsBudget.purgeF( tinP ) ;
/*N2U*/                                                                                 bGotBudget = 1 ;
/*N2U*/                                                                             {
/*N2U*/                                                                             else
/*N2U*/                                                                             if( strCompareF( tinP , tAssign , psttc1 ) ) break ;
/*N2U*/                                                                         {
/*N2U*/                                                                         else if( !bGotBudget )
/*N2U*/                                                                         if( BwOTHsTRING1 ) psttzLeverBudget = psttc1 ;
/*N2U*/                                                                     {
/*N2U*/                                                                     FORsTRINGSiN1( pstt1Terms )
/*N2U*/                                                                     ZE( boolT , bGotBudget ) ;
/*N2U*/
/*N2U*/                                                                     traceF( tinP , T("called strWordsF 5") ) ;
/*N2U*/                                                                     strWordsF( tinP , pstt1Terms , psttvt , sttq ) ; ___( pstt1Terms ) ;
/*N2U*/                                                                     traceF( tinP , T("calling strWordsF 5") ) ;
/*N2U*/                                                                     strokeS sttq ;
/*N2U*/                                                                     ZE( strokeS* , pstt1Terms ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "MATH / BUDGET\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyBudget ) )
/*N2U*/                                                 {
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyMath ) )
/*N2U*/                                                 }
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                     traceF( tinP , T("[waitStepNapTocks]: ")+TF2(waitStepNapTocks,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N2U*/                                                                     waitStepNapTocks = strDigitsToSCountF( tinP , psttvt ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "WAITsTEP / NAPTOCKS\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyNapTocks ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                     traceF( tinP , T("[waitStepRemainder2]: ")+TF2(waitStepRemainder2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N2U*/                                                                     waitStepRemainder2 = strDigitsToSCountF( tinP , psttvt ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "WAITsTEP / REMAINDER2\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyRemainder2 ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                     traceF( tinP , T("[waitStepRemainder1]: ")+TF2(waitStepRemainder1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N2U*/                                                                     waitStepRemainder1 = strDigitsToSCountF( tinP , psttvt ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "WAITsTEP / REMAINDER1\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyRemainder1 ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                     traceF( tinP , T("[waitStepModulo2]: ")+TF2(waitStepModulo2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N2U*/                                                                     waitStepModulo2 = strDigitsToSCountF( tinP , psttvt ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "WAITsTEP / MODULO2\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyModulo2 ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                     traceF( tinP , T("[waitStepModulo1]: ")+TF2(waitStepModulo1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N2U*/                                                                     waitStepModulo1 = strDigitsToSCountF( tinP , psttvt ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "WAITsTEP / MODULO1\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyModulo1 ) )
/*N2U*/                                                 {
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyWaitStep ) )
/*N2U*/                                                 }
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 }
/*N2U*/                                                                     delF( tinP , pstt1Words ) ;
/*N2U*/                                                                     }
/*N2U*/                                                                         if( !ids ) delF( tinP , psttOk ) ;
/*N2U*/                                                                         stOkCard.sinkF( tinP , ids , psttOk , flSTACKsINK_UNIQUE ) ;
/*N2U*/                                                                         ZE( countT , ids ) ;
/*N2U*/                                                                         strMakeF( tinP , psttOk , psttc1 ) ; ___( psttOk ) ;
/*N2U*/                                                                         ZE( strokeS* , psttOk ) ;
/*N2U*/                                                                     {
/*N2U*/                                                                     FORsTRINGSiN1( pstt1Words )
/*N2U*/
/*N2U*/                                                                     traceF( tinP , T("called strWordsF 4") ) ;
/*N2U*/                                                                     strWordsF( tinP , pstt1Words , psttvt , sttq ) ; ___( pstt1Words ) ;
/*N2U*/                                                                     traceF( tinP , T("calling strWordsF 4") ) ;
/*N2U*/                                                                     strokeS sttq ;
/*N2U*/                                                                     ZE( strokeS* , pstt1Words ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "VALIDATE / TIMECARD\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyTimecard ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 }
/*N2U*/                                                                     delF( tinP , pstt1Words ) ;
/*N2U*/                                                                     }
/*N2U*/                                                                         if( !ids ) delF( tinP , psttOk ) ;
/*N2U*/                                                                         stOkBuy.sinkF( tinP , ids , psttOk , flSTACKsINK_UNIQUE ) ;
/*N2U*/                                                                         ZE( countT , ids ) ;
/*N2U*/                                                                         strMakeF( tinP , psttOk , psttc1 ) ; ___( psttOk ) ;
/*N2U*/                                                                         ZE( strokeS* , psttOk ) ;
/*N2U*/                                                                     {
/*N2U*/                                                                     FORsTRINGSiN1( pstt1Words )
/*N2U*/                                                                     ZE( boolT , bGotBudget ) ;
/*N2U*/
/*N2U*/                                                                     traceF( tinP , T("called strWordsF 3") ) ;
/*N2U*/                                                                     strWordsF( tinP , pstt1Words , psttvt , sttq ) ; ___( pstt1Words ) ;
/*N2U*/                                                                     traceF( tinP , T("calling strWordsF 3") ) ;
/*N2U*/                                                                     strokeS sttq ;
/*N2U*/                                                                     ZE( strokeS* , pstt1Words ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "VALIDATE / BUY\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyBuy ) )
/*N2U*/                                                 {
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyValidate ) )
/*N2U*/                                                 }
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 }
/*N2U*/                                                                     traceF( tinP , T("[sizebytes]: ")+TF2(sizeBytes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N2U*/                                                                     sizeBytes = strDigitsToSCountF( tinP , psttvt ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( psttvt && psttvt->idAdam )
/*N2U*/
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         traceF( tinP , T("SPLIT / SIZEBYTES\r\n") ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeySizeBytes ) && !strCompareF( tinP , tKeyLevel1 , tKeySplit ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 tFolderTo = T(psttvt) ;
/*N2U*/                                                                 traceF( tinP , T("[folder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         traceF( tinP , T("SPLIT JOIN / FOLDERTO\r\n") ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyFolderTo ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 tFolderFrom = T(psttvt) ;
/*N2U*/                                                                 traceF( tinP , T("[folder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         traceF( tinP , T("SPLIT JOIN / FOLDERFROM\r\n") ) ;
/*N2U*/                                                     {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyFolderFrom ) )
/*N2U*/                                                 {
/*N2U*/                                                 )
/*N2U*/                                                     || !strCompareF( tinP , tKeyLevel1 , tKeyJoin  )
/*N2U*/                                                        !strCompareF( tinP , tKeyLevel1 , tKeySplit )
/*N2U*/                                                 (
/*N2U*/                                                 else if
/*N2U*/                                                 }
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 tFolder = T(psttvt) ;
/*N2U*/                                                                 traceF( tinP , T("[folder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         traceF( tinP , T("RENAMEtOhASH / FOLDER\r\n") ) ;
/*N2U*/                                                     {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyFolder ) )
/*N2U*/                                                 {
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyRenameToHash ) )
/*N2U*/                                                 }
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 //delF( tinP , psttvt ) ;
/*N2U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         }
/*N2U*/                                                             delF( tinP , psttvt ) ;
/*N2U*/                                                             }
/*N2U*/                                                                 }
/*N2U*/                                                                     }
/*N2U*/                                                                         break ;
/*N2U*/                                                                         tSettingsKeyPrefix = T("!ktr.") ;
/*N2U*/                                                                         //tSettingsKeyPrefix = tn ;
/*N2U*/                                                                     {
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                                 {
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                             {
/*N2U*/                                                             else
/*N2U*/                                                             }
/*N2U*/                                                                 }
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N2U*/                                                                 {
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                                 cFlag1 ++ ;
/*N2U*/                                                             {
/*N2U*/                                                             if( psttvt && psttvt->idAdam )
/*N2U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                             ZE( strokeS* , psttvt ) ;
/*N2U*/                                                         {
/*N2U*/
/*N2U*/                                                         bAllowLevel3 = 1 ;
/*N2U*/                                                         bAllowLevel2 = 0 ;
/*N2U*/                                                         //traceF( tinP , "SETTINGS / KTR\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyKtr ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 //delF( tinP , psttvt ) ;
/*N2U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         }
/*N2U*/                                                             delF( tinP , psttvt ) ;
/*N2U*/                                                             }
/*N2U*/                                                                 }
/*N2U*/                                                                     }
/*N2U*/                                                                         break ;
/*N2U*/                                                                         tSettingsKeyPrefix = T("!ipdos.") ;
/*N2U*/                                                                     {
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                                 {
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                             {
/*N2U*/                                                             else
/*N2U*/                                                             }
/*N2U*/                                                                 }
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N2U*/                                                                 {
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                                 cFlag1 ++ ;
/*N2U*/                                                             {
/*N2U*/                                                             if( psttvt && psttvt->idAdam )
/*N2U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                             ZE( strokeS* , psttvt ) ;
/*N2U*/                                                         {
/*N2U*/
/*N2U*/                                                         bAllowLevel3 = 1 ;
/*N2U*/                                                         bAllowLevel2 = 0 ;
/*N2U*/                                                         //traceF( tinP , "SETTINGS / IPDOS\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyIPDOS ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 //delF( tinP , psttvt ) ;
/*N2U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         }
/*N2U*/                                                             delF( tinP , psttvt ) ;
/*N2U*/                                                             }
/*N2U*/                                                                 }
/*N2U*/                                                                     }
/*N2U*/                                                                         break ;
/*N2U*/                                                                         tSettingsKeyPrefix = T("!cloudview.")+T(psttvt)+strokeS('.') ;
/*N2U*/                                                                         //tSettingsKeyPrefix = tn ;
/*N2U*/                                                                     {
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                                 {
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                             {
/*N2U*/                                                             else
/*N2U*/                                                             }
/*N2U*/                                                                 }
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N2U*/                                                                 {
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                                 cFlag1 ++ ;
/*N2U*/                                                             {
/*N2U*/                                                             if( !psttvt || !psttvt->idAdam )
/*N2U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                             ZE( strokeS* , psttvt ) ;
/*N2U*/                                                         {
/*N2U*/
/*N2U*/                                                         bAllowLevel3 = 1 ;
/*N2U*/                                                         bAllowLevel2 = 0 ;
/*N2U*/                                                         //traceF( tinP , "SETTINGS / CLOUDVIEW\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyCloudView ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 //delF( tinP , psttvt ) ;
/*N2U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         }
/*N2U*/                                                             delF( tinP , psttvt ) ;
/*N2U*/                                                             }
/*N2U*/                                                                 }
/*N2U*/                                                                     }
/*N2U*/                                                                         break ;
/*N2U*/                                                                         tSettingsKeyPrefix = T("!cloud.")+T(psttvt)+strokeS('.') ;
/*N2U*/                                                                         //tSettingsKeyPrefix = tn ;
/*N2U*/                                                                     {
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                                 {
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                             {
/*N2U*/                                                             else
/*N2U*/                                                             }
/*N2U*/                                                                 }
/*N2U*/                                                                     case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N2U*/                                                                 {
/*N2U*/                                                                 switch( idModeP )
/*N2U*/                                                                 cFlag1 ++ ;
/*N2U*/                                                             {
/*N2U*/                                                             if( !psttvt || !psttvt->idAdam )
/*N2U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                             ZE( strokeS* , psttvt ) ;
/*N2U*/                                                         {
/*N2U*/
/*N2U*/                                                         bAllowLevel3 = 1 ;
/*N2U*/                                                         bAllowLevel2 = 0 ;
/*N2U*/                                                         //traceF( tinP , "SETTINGS / CLOUD\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyCloud ) )
/*N3U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 //delF( tinP , psttvt ) ;
/*N2U*/                                                                 //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 //ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         }
/*N2U*/                                                             delF( tinP , psttvt ) ;
/*N2U*/                                                             tMemory = T(psttvt) ;
/*N2U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                             ZE( strokeS* , psttvt ) ;
/*N2U*/                                                         {
/*N2U*/
/*N2U*/                                                         //bAllowLevel3 = 1 ;
/*N2U*/                                                         //bAllowLevel2 = 0 ;
/*N2U*/                                                         traceF( tinP , T("SETTINGS / MEMORY SPACE\r\n") ) ;
/*N2U*/                                                     {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyMemory ) )
/*N2U*/                                                 {
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeySettings ) )
/*N2U*/                                                 }
/*N2U*/                                                     }
/*N2U*/                                                         delF( tinP , psttvt ) ;
/*N2U*/                                                         }
/*N2U*/                                                             delF( tinP , pstt1Words ) ;
/*N2U*/                                                             delF( tinP , psttBefore ) ;
/*N2U*/                                                             }
/*N2U*/                                                                 }
/*N2U*/                                                                     break ;
/*N2U*/                                                                     strMakeF( tinP , psttAfter , psttc1 ) ; ___( psttAfter ) ;
/*N2U*/                                                                     if( psttAfter ) delF( tinP , psttAfter ) ;
/*N2U*/                                                                     strokeS*& psttAfter = *(strokeS**)&(countT&)swReplace ;
/*N2U*/                                                                 {
/*N2U*/                                                                 else
/*N2U*/                                                                 }
/*N2U*/                                                                     psttzLeverReplace = psttBefore ;
/*N2U*/                                                                     strMakeF( tinP , psttBefore , tm3+T(psttc1)+tm4 ) ; ___( psttBefore ) ;
/*N2U*/                                                                     delF( tinP , psttBefore ) ;
/*N2U*/                                                                 {
/*N2U*/                                                                 if( BwOTHsTRING1 )
/*N2U*/                                                             {
/*N2U*/                                                             FORsTRINGSiN1( pstt1Words )
/*N2U*/                                                             ZE( strokeS* , psttBefore ) ;
/*N2U*/
/*N2V*/                                                             traceF( tinP , T("called strWordsF 2") ) ;
/*N2U*/                                                             strWordsF( tinP , pstt1Words , psttvt , sttq ) ; ___( pstt1Words ) ;
/*N2V*/                                                             traceF( tinP , T("calling strWordsF 2") ) ;
/*N2U*/                                                             strokeS sttq ;
/*N2U*/                                                             ZE( strokeS* , pstt1Words ) ;
/*N2U*/                                                         {
/*N2U*/                                                         if( psttvt && psttvt->idAdam )
/*N2U*/
/*N2U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                         ZE( strokeS* , psttvt ) ;
/*N2U*/
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "REPLACEMENTS / REPLACE\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyReplace ) )
/*N2U*/                                                 {
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyReplacements ) )
/*N2U*/                                                 }
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 tJobQueueRepeat = T(psttvt) ;
/*N2U*/                                                                 traceF( tinP , T("[jobqueuerepeat]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "DOjOBS / REPEAT\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     else if( !strCompareF( tinP , psttKey , tKeyRepeat ) )
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/
/*N2U*/                                                                 delF( tinP , psttvt ) ;
/*N2U*/                                                                 tJobQueueFolder = T(psttvt) ;
/*N2U*/                                                                 traceF( tinP , T("DOjOBS / JOBqUEUE [jobqueuefolder]: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N2U*/                                                                 strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N2U*/                                                                 ZE( strokeS* , psttvt ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N2U*/                                                             }
/*N2U*/                                                                 break ;
/*N2U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                             {
/*N2U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                         {
/*N2U*/                                                         switch( idModeP )
/*N2U*/
/*N2U*/                                                         //traceF( tinP , "DOjOBS / JOBqUEUE\r\n" ) ;
/*N2U*/                                                     {
/*N2U*/                                                     if( !strCompareF( tinP , psttKey , tKeyJobQueue ) )
/*N2U*/                                                 {
/*N2U*/                                                 else if( !strCompareF( tinP , tKeyLevel1 , tKeyDoJobs ) )
/*N2U*/                                                 }
/*N2U*/                                                     }
/*N2U*/                                                         }
/*N2U*/                                                             break ;
/*N2U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N2U*/                                                         {
/*N2U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N2U*/                                                     {
/*N2U*/                                                     switch( idModeP )
/*N2U*/
/*N2U*/                                                     //traceF( tinP , "COMMENT / *\r\n" ) ;
/*N2U*/                                                 {
/*N2U*/                                                 if( !strCompareF( tinP , tKeyLevel1 , tKeyComment ) )
/*N2U*/                                                 tKeyLevel2 = T(psttKey) ;
                                                    {
                                                    case 2 :
                                                    }
/*N1U*/                                                 break ;
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/                                                 {
/*N1U*/                                                 else
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             {
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                         {
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     {
/*N1U*/
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "REPORT\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyEdit ) || !strCompareF( tinP , psttKey , tKeyReport ) || !strCompareF( tinP , psttKey , tKeyZip ) || !strCompareF( tinP , psttKey , tKeyInspectFileNames ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             {
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                         {
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     {
/*N1U*/
/*N1U*/                                                     if( !strCompareF( tinP , psttKey , tKeySplit ) ) sizeBytes = TICK ;
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "SPLIT JOIN\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 )
/*N1U*/                                                     || !strCompareF( tinP , psttKey , tKeyJoin  )
/*N1U*/                                                        !strCompareF( tinP , psttKey , tKeySplit )
/*N1U*/                                                 (
/*N1U*/                                                 else if
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             {
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                         {
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     {
/*N1U*/
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "RENAMEtOhASH\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyRenameToHash ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             {
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                         {
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     {
/*N1U*/
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "SETTINGS | WAITsTEP\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 )
/*N1U*/                                                     || !strCompareF( tinP , psttKey , tKeyWaitStep )
/*N1U*/                                                        !strCompareF( tinP , psttKey , tKeySettings )
/*N1U*/                                                 (
/*N1U*/                                                 else if
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             {
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                         {
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     {
/*N1U*/
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "KTR\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyKtr ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             {
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                         {
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     {
/*N1U*/
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "ARITHMETIC\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyMath ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             {
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                         {
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     {
/*N1U*/
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "VALIDATE\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyValidate ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/
/*N1U*/                                                             //delF( tinP , psttvt ) ;
/*N1U*/                                                             //strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             //ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
/*N1U*/                                                             {
/*N1U*/                                                             switch( idModeP )
/*N1U*/                                                             cFlag1 ++ ;
/*N1U*/                                                         {
/*N1U*/                                                         if( psttvt && psttvt->idAdam )
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     {
/*N1U*/
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "REPLACEMENTS\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyReplacements ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             bRepeat = 1 ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "REPEAT\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyRepeat ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/
/*N1U*/                                                             *pStJournal << pstte ; pstte = 0 ;
/*N1U*/                                                             if( csttMaxJournal < pstte->idAdam ) csttMaxJournal = pstte->idAdam ;
/*N1U*/
/*N1U*/                                                             delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                             }
/*N1U*/                                                                 emitTranscriptIfChangedF( tinP , *this , psttKey , psttvt , time1 , time2 , ++ idTranscriptLath , tArchive ) ;
/*N1U*/                                                                 }
/*N1U*/                                                                     idTranscriptLath = 0 ;
/*N1U*/                                                                     time2TranscriptLath = time2 ;
/*N1U*/                                                                     time1TranscriptLath = time1 ;
/*N1U*/                                                                 {
/*N1U*/                                                                 if( time1TranscriptLath != time1 || time2TranscriptLath != time2 )
/*N1U*/                                                             {
/*N1U*/                                                             if( time1 || time2 )
/*N1U*/
/*N1U*/                                                             strFuseF( tinP , pstte , psttvt ) ;
/*N1U*/                                                             strMakeF( tinP , pstte , TT4(time1,time2,4,6)+T(" } {j: ") , psttvt->idAdam ) ; ___( pstte ) ;
/*N1U*/                                                             ZE( strokeS* , pstte ) ;
/*N1U*/
/*N1U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             ZE( strokeS* , psttvt ) ;
/*N1U*/
/*N1U*/                                                             }
/*N1U*/                                                                 __Z( pStJournal ) ;
/*N1U*/                                                                 pStJournal = new( 0 , tinP , LF ) stackC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStJournal ) ;
/*N1U*/                                                             {
/*N1U*/                                                             if( !pStJournal )
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     //traceF( tinP , "JOURNAL\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyJournal ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/
/*N1U*/                                                             *pStLog << pstte ; pstte = 0 ;
/*N1U*/                                                             if( csttMaxLog < pstte->idAdam ) csttMaxLog = pstte->idAdam ;
/*N1U*/
/*N1U*/                                                             delF( tinP , psttvt ) ;
/*N1U*/
/*N1U*/                                                             }
/*N1U*/                                                                 emitTranscriptIfChangedF( tinP , *this , psttKey , psttvt , time1 , time2 , ++ idTranscriptLath , tArchive ) ;
/*N1U*/                                                                 }
/*N1U*/                                                                     idTranscriptLath = 0 ;
/*N1U*/                                                                     time2TranscriptLath = time2 ;
/*N1U*/                                                                     time1TranscriptLath = time1 ;
/*N1U*/                                                                 {
/*N1U*/                                                                 if( time1TranscriptLath != time1 || time2TranscriptLath != time2 )
/*N1U*/                                                             {
/*N1U*/                                                             if( time1 || time2 )
/*N1U*/
/*N1U*/                                                             strFuseF( tinP , pstte , psttvt ) ;
/*N1U*/                                                             strMakeF( tinP , pstte , TT4(time1,time2,4,6)+T(" } {l: ") , psttvt->idAdam ) ; ___( pstte ) ;
/*N1U*/                                                             ZE( strokeS* , pstte ) ;
/*N1U*/
/*N1U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             ZE( strokeS* , psttvt ) ;
/*N1U*/
/*N1U*/                                                             }
/*N1U*/                                                                 __Z( pStLog ) ;
/*N1U*/                                                                 pStLog = new( 0 , tinP , LF ) stackC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStLog ) ;
/*N1U*/                                                             {
/*N1U*/                                                             if( !pStLog )
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     //traceF( tinP , "LOG\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyLog ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/
/*N1U*/                                                             pStDo->sinkF( tinP , countTC() , psttvt ) ; psttvt = 0 ;
/*N1U*/                                                             if( csttMaxDo < psttvt->idAdam ) csttMaxDo = psttvt->idAdam ;
/*N1U*/
/*N1U*/                                                             }
/*N1U*/                                                                 emitTranscriptIfChangedF( tinP , *this , psttKey , psttvt , time1 , time2 , ++ idTranscriptLath , tArchive ) ;
/*N1U*/                                                                 }
/*N1U*/                                                                     idTranscriptLath = 0 ;
/*N1U*/                                                                     time2TranscriptLath = time2 ;
/*N1U*/                                                                     time1TranscriptLath = time1 ;
/*N1U*/                                                                 {
/*N1U*/                                                                 if( time1TranscriptLath != time1 || time2TranscriptLath != time2 )
/*N1U*/                                                             {
/*N1U*/                                                             if( time1 || time2 )
/*N1U*/
/*N1U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             ZE( strokeS* , psttvt ) ;
/*N1U*/
/*N1U*/                                                             }
/*N1U*/                                                                 __Z( pStDo ) ;
/*N1U*/                                                                 pStDo = new( 0 , tinP , LF ) stackC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStDo ) ;
/*N1U*/                                                             {
/*N1U*/                                                             if( !pStDo )
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     //traceF( tinP , "DO\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyDo ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         delF( tinP , psttvt ) ;
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 break ;
/*N1U*/
/*N1U*/                                                                 psttLeverCard = tLeverCard ; // SET THE NEW LEVER VALUE
/*N1U*/                                                                 tLeverCard = T(psttvt) ;
/*N1U*/
/*N1U*/                                                                 offStrongCard = timeCard2 & ~7 ;
/*N1U*/                                                                 timeCard2    = time2 ;
/*N1U*/                                                                 timeCard1    = time1 ; // STARTING TIME FOR THE NEW LEVER VALUE
/*N1U*/
/*N1U*/                                                                 }
/*N1U*/                                                                     }
/*N1U*/                                                                         }
/*N1U*/                                                                             osTimeAddF( tinP , accum.time1 , accum.time2 , timeE1 , timeE2 ) ;
/*N1U*/                                                                             timeS& accum = *(timeS*)&(countT&)*pSwTimeCard ;
/*N1U*/
/*N1U*/                                                                             }
/*N1U*/                                                                                 timeMax.time2 = time2 ;
/*N1U*/                                                                                 timeMax.time1 = time1 ;
/*N1U*/                                                                             {
/*N1U*/                                                                             )
/*N1U*/                                                                                 )
/*N1U*/                                                                                     timeMax.time1 < time1
/*N1U*/                                                                                     &&
/*N1U*/                                                                                     timeMax.time2 == time2
/*N1U*/                                                                                 (
/*N1U*/                                                                                 ||
/*N1U*/                                                                                 timeMax.time2 < time2
/*N1U*/                                                                             (
/*N1U*/                                                                             if
/*N1U*/                                                                             timeS& timeMax = *(timeS*)&(countT&)*pSwTimeMax ;
/*N1U*/                                                                         {
/*N1U*/                                                                         if( !POOP )
/*N1U*/
/*N1U*/                                                                         }
/*N1U*/                                                                             __Z( pSwTimeCard ) ;
/*N1U*/                                                                             pSwTimeCard = new( 0 , tinP , LF ) switchC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , psttLeverCard , 0 , sizeof( timeS ) ) ; ___( pSwTimeCard ) ;
/*N1U*/                                                                         {
/*N1U*/                                                                         if( !pSwTimeCard )
/*N1U*/                                                                         switchC*& pSwTimeCard = *(switchC**)&(countT&)*pSwSwTimeCard ;
/*N1U*/
/*N1U*/                                                                         osTimeSubtractF( tinP , timeE1 , timeE2 , timeCard1 , timeCard2 ) ;
/*N1U*/                                                                         sCountT timeE2 = time2 ;
/*N1U*/                                                                         countT  timeE1 = time1 ; //ELAPSED TIME TO ACCUMULATE FOR THE OLD LEVER VALUE
/*N1U*/
/*N1U*/                                                                         }
/*N1U*/                                                                             }
/*N1U*/                                                                                 offStrong = offStrongSaved ;
/*N1U*/
/*N1U*/                                                                                 offStrongCard = timeCard2 & ~7 ;
/*N1U*/                                                                                 timeCard2     = timeDivide2 ;
/*N1U*/                                                                                 timeCard1     = timeDivide1 ;
/*N1U*/
/*N1U*/                                                                                 osTimeAddF( tinP , accum.time1 , accum.time2 , timeE1 , timeE2 ) ;
/*N1U*/                                                                                 timeS& accum = *(timeS*)&(countT&)*pSwTimeCard ;
/*N1U*/                                                                                 osTimeSubtractF( tinP , timeE1 , timeE2 , timeCard1 , timeCard2 ) ;
/*N1U*/
/*N1U*/                                                                                 }
/*N1U*/                                                                                     timeMax.time2 = timeDivide2 ;
/*N1U*/                                                                                     timeMax.time1 = timeDivide1 ;
/*N1U*/                                                                                 {
/*N1U*/                                                                                 )
/*N1U*/                                                                                     )
/*N1U*/                                                                                         timeMax.time1 < timeDivide1
/*N1U*/                                                                                         &&
/*N1U*/                                                                                         timeMax.time2 == timeDivide2
/*N1U*/                                                                                     (
/*N1U*/                                                                                     ||
/*N1U*/                                                                                     timeMax.time2 < timeDivide2
/*N1U*/                                                                                 (
/*N1U*/                                                                                 if
/*N1U*/                                                                                 timeS& timeMax = *(timeS*)&(countT&)*pSwTimeMax ;
/*N1U*/
/*N1U*/                                                                                 const sCountT timeDivide2 = timeE2 ;
/*N1U*/                                                                                 const countT  timeDivide1 = timeE1 ;
/*N1U*/                                                                                 osTimeSubtractF( tinP , timeE1 , timeE2 , 1 ) ; //SO THAT THIS END TIME IS WITHIN (AT THE END OF) THE LATH STRONG
/*N1U*/                                                                                 sCountT timeE2 = time2 ;
/*N1U*/                                                                                 countT  timeE1 = 0 ;
/*N1U*/                                                                             {
/*N1U*/                                                                             if( !POOP )
/*N1U*/
/*N1U*/                                                                             }
/*N1U*/                                                                                 __Z( pSwTimeCard ) ;
/*N1U*/                                                                                 pSwTimeCard = new( 0 , tinP , LF ) switchC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , psttLeverCard , 0 , sizeof( timeS ) ) ; ___( pSwTimeCard ) ;
/*N1U*/                                                                             {
/*N1U*/                                                                             if( !pSwTimeCard )
/*N1U*/
/*N1U*/                                                                             switchC*& pSwTimeCard    = *(switchC**)&(countT&)*pSwSwTimeCard ;
/*N1U*/                                                                                       offStrong      = offStrongCard ;
/*N1U*/                                                                             countT    offStrongSaved = offStrong ;
/*N1U*/
/*N1U*/                                                                             if( offStrong - offStrongCard > 1 ) traceF( tinP , T("quantity ")+TF2(offStrong-offStrongCard-1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" consecutive strongs encountered for which there were no timecard entries.  reported timecard totals for the preceding strong will be incorrect") ) ;
/*N1U*/                                                                         {
/*N1U*/                                                                         if( offStrong - offStrongCard )
/*N1U*/                                                                     {
/*N1U*/                                                                     if( !POOP )
/*N1U*/
/*N1U*/                                                                     }
/*N1U*/                                                                         __Z( pSwTimeMax ) ;
/*N1U*/                                                                         pSwTimeMax = new( 0 , tinP , LF ) switchC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , offStrong , 0 , sizeof( timeS ) ) ; ___( pSwTimeMax ) ;
/*N1U*/
/*N1U*/                                                                         __Z( pSwSwTimeCard ) ;
/*N1U*/                                                                         pSwSwTimeCard = new( 0 , tinP , LF ) switchC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , offStrong ) ; ___( pSwSwTimeCard ) ;
/*N1U*/                                                                     {
/*N1U*/                                                                     if( !pSwSwTimeCard )
/*N1U*/                                                                 {
/*N1U*/                                                                 if( psttLeverCard && time2 && timeCard2 )
/*N1U*/                                                             {
/*N1U*/                                                             case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                             }
/*N1U*/                                                                 break ;
/*N1U*/                                                                 }
/*N1U*/                                                                     strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                                     if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; }
/*N1U*/                                                                     cFlag1 ++ ;
/*N1U*/                                                                 {
/*N1U*/                                                                 else
/*N1U*/                                                                 if( bOkCard ) { strFuseF( tinP , soulOut , psttv ) ; }
/*N1U*/                                                             {
/*N1U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                         switch( idModeP )
/*N1U*/
/*N1U*/                                                         boolT bOkCard = !!stOkCard( psttvt ) ;
/*N1U*/
/*N1U*/                                                         strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                         ZE( strokeS* , psttvt ) ;
/*N1U*/                                                     {
/*N1U*/                                                     else
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 break ;
/*N1U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                             {
/*N1U*/                                                             case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                         {
/*N1U*/                                                         switch( idModeP )
/*N1U*/                                                     {
/*N1U*/                                                     if( year < 2012 )
/*N1U*/
/*N1U*/                                                     //traceF( tinP , "TIMECARD\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyTimecard ) )
/*N1U*/                                                 }
/*N1U*/                                                     cents = 0 ;
/*N1U*/                                                     delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/
/*N1U*/                                                             }
/*N1U*/                                                                 }
/*N1U*/                                                                     }
/*N1U*/                                                                         psttLeverBuy = 0 ;
/*N1U*/                                                                         *pSwBuy += cents ;
/*N1U*/                                                                         psttLeverBuy = psttvt ;
/*N1U*/                                                                     {
/*N1U*/                                                                     if( !POOP )
/*N1U*/
/*N1U*/                                                                     }
/*N1U*/                                                                         __Z( pSwBuy ) ;
/*N1U*/                                                                         pSwBuy = new( 0 , tinP , LF ) switchC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , psttLeverBuy ) ; ___( pSwBuy ) ;
/*N1U*/                                                                     {
/*N1U*/                                                                     if( !pSwBuy )
/*N1U*/                                                                     switchC*& pSwBuy = *(switchC**)&(countT&)*pSwSwBuy ;
/*N1U*/                                                                 {
/*N1U*/                                                                 if( !POOP )
/*N1U*/
/*N1U*/                                                                 }
/*N1U*/                                                                     __Z( pSwSwBuy ) ;
/*N1U*/                                                                     pSwSwBuy = new( 0 , tinP , LF ) switchC( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , offStrong ) ; ___( pSwSwBuy ) ;
/*N1U*/                                                                 {
/*N1U*/                                                                 if( !pSwSwBuy )
/*N1U*/                                                             {
/*N1U*/                                                             if( cents )
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             }
/*N1U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                                 if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; }
/*N1U*/                                                                 cFlag1 ++ ;
/*N1U*/                                                             {
/*N1U*/                                                             else
/*N1U*/                                                             if( bOkBuy ) { strFuseF( tinP , soulOut , psttv ) ; }
/*N1U*/                                                             // WE DON'T VERIFY cents > 0 HERE BECAUSE THAT HAS ALREADY BEEN DONE (WHEN VALIDATING THE KEY)
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     boolT bOkBuy = !!stOkBuy( psttvt ) ;
/*N1U*/
/*N1U*/                                                     strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                     ZE( strokeS* , psttvt ) ;
/*N1U*/
/*N1U*/                                                     //traceF( tinP , "BUY\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyBuy ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             if( vBad ) cFlag1 ++ ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             }
/*N1U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                                 if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; }
/*N1U*/                                                                 cFlag1 ++ ;
/*N1U*/                                                             {
/*N1U*/                                                             else
/*N1U*/                                                             if( !vBad ) { strFuseF( tinP , soulOut , psttv ) ; }
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 offStrong = time2 & ~7 ;
/*N1U*/                                                                 time2 = time2New ;
/*N1U*/                                                                 time1 = time1New ;
/*N1U*/                                                             {
/*N1U*/                                                             else
/*N1U*/                                                             vBad = 1 ;
/*N1U*/                                                             )
/*N1U*/                                                                 )
/*N1U*/                                                                     )
/*N1U*/                                                                         time1New < time1
/*N1U*/                                                                         &&
/*N1U*/                                                                         time2New == time2
/*N1U*/                                                                     (
/*N1U*/                                                                     ||
/*N1U*/                                                                     time2New < time2
/*N1U*/                                                                 (
/*N1U*/                                                                 &&
/*N1U*/                                                                 year >= 2012                                    //DATES AND TIMES PRIOR TO 2012 ARE NOT VALIDATED
/*N1U*/                                                             (
/*N1U*/                                                             if
/*N1U*/
/*N1U*/                                                             }
/*N1U*/                                                                 countT foo = 2 ;
/*N1U*/                                                             {
/*N1U*/                                                             if( !time1New && !time2New )
/*N1U*/
/*N1U*/                                                             osTimeFromOldTimeF( tinP , time1New , time2New , year - 1 , month - 1 , date - 1 , hour , minute ) ;
/*N1U*/                                                             ZE( sCountT , time2New ) ;
/*N1U*/                                                             ZE( countT  , time1New ) ;
/*N1U*/                                                         {
/*N1U*/                                                         else
/*N1U*/                                                         vBad = 1 ;
/*N1U*/                                                         )
/*N1U*/                                                             minute > 59
/*N1U*/                                                             ||
/*N1U*/                                                             hour > 23
/*N1U*/                                                         (
/*N1U*/                                                         if
/*N1U*/
/*N1U*/                                                         delF( tinP , psttMinute ) ;
/*N1U*/                                                         delF( tinP , psttHour ) ;
/*N1U*/
/*N1U*/                                                         countT minute = strDigitsToSCountF( tinP , psttMinute , 0xa , 1 ) ;
/*N1U*/                                                         countT hour   = strDigitsToSCountF( tinP , psttHour   , 0xa , 1 ) ;
/*N1U*/
/*N1U*/                                                         //traceF( tinP , T("minute: \"")+T(psttMinute)+T("\"\r\n") ) ;
/*N1U*/                                                         //traceF( tinP , T("hour:   \"")+T(psttHour)+T("\"\r\n") ) ;
/*N1U*/                                                                idlc = 0 ; strSubstringF( tinP , psttMinute , idfc , idlc , psttvt ) ; ___( psttMinute ) ;
/*N1U*/                                                         countT idlc = 2 ; strSubstringF( tinP , psttHour   , idfc , idlc , psttvt ) ; ___( psttHour   ) ;
/*N1U*/                                                         countT idfc = 1 ;
/*N1U*/                                                         ZE( strokeS* , psttMinute ) ;
/*N1U*/                                                         ZE( strokeS* , psttHour ) ;
/*N1U*/
/*N1U*/                                                         //traceF( tinP , T("value passed test 1: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N1U*/                                                     {
/*N1U*/                                                     else
/*N1U*/                                                     if( psttvt->idAdam != 4 || !strIsDigitsF( tinP , psttvt , 0xa ) ) vBad = 1 ;
/*N1U*/                                                     ZE( boolT , vBad ) ;
/*N1U*/
/*N1U*/                                                     strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                     ZE( strokeS* , psttvt ) ;
/*N1U*/
/*N1U*/                                                     //traceF( tinP , "TIME\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyTime ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             delF( tinP , psttvt ) ;
/*N1U*/                                                             tTrace = T(psttvt) ;
/*N1U*/                                                             strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                             ZE( strokeS* , psttvt ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     //bAllowLevel2 = 1 ;
/*N1U*/                                                     //bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "TRACE\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyTrace ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "NULL\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyNull ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             if( vBad ) cFlag1 ++ ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             }
/*N1U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                                 if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; }
/*N1U*/                                                                 cFlag1 ++ ;
/*N1U*/                                                             {
/*N1U*/                                                             else
/*N1U*/                                                             if( !vBad ) { strFuseF( tinP , soulOut , psttv ) ; }
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/                                                         if( bNeg ) cents = - cents ;
/*N1U*/                                                         cents = strDigitsToSCountF( tinP , psttvt  , 0xa , 1 ) ;
/*N1U*/
/*N1U*/                                                         //traceF( tinP , T("value passed test 1: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N1U*/                                                     {
/*N1U*/                                                     else
/*N1U*/                                                     if( !strIsDigitsF( tinP , psttvt , 0xa ) ) vBad = 1 ;
/*N1U*/                                                     ZE( boolT , vBad ) ;
/*N1U*/
/*N1U*/                                                     }
/*N1U*/                                                         delF( tinP , psttd ) ;
/*N1U*/                                                         strSubstringF( tinP , psttvt , idf , idl , psttd ) ; ___( psttvt ) ;
/*N1U*/                                                         ZE( countT , idl ) ;
/*N1U*/                                                         countT idf = 2 ;
/*N1U*/                                                                          psttvt = 0 ;
/*N1U*/                                                         strokeS* psttd = psttvt ;
/*N1U*/                                                     {
/*N1U*/                                                     if( bNeg )
/*N1U*/
/*N1U*/                                                     boolT bNeg = psttvt[ CSpREFIX ].idAdam == '-' ;
/*N1U*/
/*N1U*/                                                     strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                     ZE( strokeS* , psttvt ) ;
/*N1U*/
/*N1U*/                                                     //traceF( tinP , "MONEY\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyMoney ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "DOjOBS\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyDoJobs ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     bAllowLevel2 = 1 ;
/*N1U*/                                                     bAllowLevel1 = 0 ;
/*N1U*/                                                     //traceF( tinP , "COMMENT\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 else if( !strCompareF( tinP , psttKey , tKeyComment ) )
/*N1U*/                                                 }
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             if( vBad ) cFlag1 ++ ;
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_REPORT :
/*N1U*/                                                         }
/*N1U*/                                                             break ;
/*N1U*/                                                             }
/*N1U*/                                                                 strFuseF( tinP , soulOut , psttv ) ;
/*N1U*/                                                                 if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; }
/*N1U*/                                                                 cFlag1 ++ ;
/*N1U*/                                                             {
/*N1U*/                                                             else
/*N1U*/                                                             if( !vBad ) { strFuseF( tinP , soulOut , psttv ) ; }
/*N1U*/                                                         {
/*N1U*/                                                         case ifcIDmODEeTHERsOIL_LINT :
/*N1U*/                                                     {
/*N1U*/                                                     switch( idModeP )
/*N1U*/
/*N1U*/                                                     delF( tinP , psttvt ) ;
/*N1U*/                                                     }
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 date  = dateNew ;
/*N1U*/                                                                 month = monthNew ;
/*N1U*/                                                                 year  = yearNew ;
/*N1U*/                                                                 date2 = date2New ;
/*N1U*/                                                                 date1 = date1New ;
/*N1U*/                                                             {
/*N1U*/                                                             else
/*N1U*/                                                             vBad = 1 ;
/*N1U*/                                                             )
/*N1U*/                                                                 )
/*N1U*/                                                                     )
/*N1U*/                                                                         )
/*N1U*/                                                                             )                                               //A:ASSUME:WORD IS 02 BITS
/*N1U*/                                                                                 date1New > date1 + 0x10000000               //ACROSS THE FALL BACK TIME CHANGE IN THE FALL, date1 WILL INCREASE BY 0x0aaaaaab ; WO IFC HOUR (90 CONVENTIONAL MINUTES) IS ALLOWED HERE JUST TO BE SURE
/*N1U*/                                                                                 &&
/*N1U*/                                                                                 date2New == date2 + 1
/*N1U*/                                                                             (
/*N1U*/                                                                             ||
/*N1U*/                                                                             date2New > date2 + 1                            //RULE: DATE MUST NOT ADVANCE BY MORE THAN 1 DAY
/*N1U*/                                                                         (
/*N1U*/                                                                         &&
/*N1U*/                                                                         date2
/*N1U*/                                                                     (
/*N1U*/                                                                     ||
/*N1U*/                                                                     )
/*N1U*/                                                                         date1New < date1
/*N1U*/                                                                         &&
/*N1U*/                                                                         date2New == date2
/*N1U*/                                                                     (
/*N1U*/                                                                     ||
/*N1U*/                                                                     date2New < date2                                //RULE: DATE MUST NOT BE EARLIER THAN PRECEEDING DATE
/*N1U*/                                                                 (
/*N1U*/                                                                 &&
/*N1U*/                                                                 year >= 2012                                    //DATES AND TIMES PRIOR TO 2012 ARE NOT VALIDATED
/*N1U*/                                                             (
/*N1U*/                                                             if
/*N1U*/
/*N1U*/                                                             }
/*N1U*/                                                                 countT foo = 2 ;
/*N1U*/                                                             {
/*N1U*/                                                             if( !date1New && !date2New )
/*N1U*/
/*N1U*/                                                             osTimeFromOldTimeF( tinP , date1New , date2New , yearNew - 1 , monthNew - 1 , dateNew - 1 ) ;
/*N1U*/                                                             ZE( sCountT , date2New ) ;
/*N1U*/                                                             ZE( countT  , date1New ) ;
/*N1U*/                                                         {
/*N1U*/                                                         else
/*N1U*/                                                         vBad = 1 ;
/*N1U*/                                                         )
/*N1U*/                                                             dateNew > dateMax
/*N1U*/                                                             ||
/*N1U*/                                                             !dateNew
/*N1U*/                                                             ||
/*N1U*/                                                             monthNew > 12
/*N1U*/                                                             ||
/*N1U*/                                                             !monthNew
/*N1U*/                                                             ||
/*N1U*/                                                             yearNew < 2011                                      //RULE: YEAR MUST BE 2011 OR LATER
/*N1U*/                                                         (
/*N1U*/                                                         if
/*N1U*/
/*N1U*/                                                         }
/*N1U*/                                                             }
/*N1U*/                                                                 }
/*N1U*/                                                                     break ;
/*N1U*/
/*N1U*/                                                                     //CONoUTrAW5( "[bLeap,dateMax]: " , bLeap , " " , dateMax , "\r\n" ) ;
/*N1U*/                                                                     ;
/*N1U*/                                                                         : 28
/*N1U*/                                                                         ? 29
/*N1U*/                                                                     dateMax = bLeap
/*N1U*/
/*N1U*/                                                                     ;
/*N1U*/                                                                                 : 1
/*N1U*/                                                                                 ? 0
/*N1U*/                                                                             : !( yearNew % 100 )
/*N1U*/                                                                             ? 1
/*N1U*/                                                                         : !( yearNew % 400 )
/*N1U*/                                                                         ? 0
/*N1U*/                                                                     boolT bLeap = yearNew % 4
/*N1U*/                                                                     // YEARS THAT ARE EVENLY DIVISIBLE BY 100 ARE NOT LEAP YEARS, UNLESS THEY ARE ALSO EVENLY DIVISIBLE BY 400
/*N1U*/                                                                 {
/*N1U*/                                                                 case  2 :
/*N1U*/                                                                 case 11 : { dateMax = 30 ; break ; }
/*N1U*/                                                                 case  9 :
/*N1U*/                                                                 case  6 :
/*N1U*/                                                                 case  4 :
/*N1U*/                                                             {
/*N1U*/                                                             switch( monthNew )
/*N1U*/                                                         {
/*N1U*/                                                         countT dateMax = 31 ;
/*N1U*/
/*N1U*/                                                         delF( tinP , psttDate ) ;
/*N1U*/                                                         delF( tinP , psttMonth ) ;
/*N1U*/                                                         delF( tinP , psttYear ) ;
/*N1U*/
/*N1U*/                                                         countT dateNew  = strDigitsToSCountF( tinP , psttDate  , 0xa , 1 ) ;
/*N1U*/                                                         countT monthNew = strDigitsToSCountF( tinP , psttMonth , 0xa , 1 ) ;
/*N1U*/                                                         countT yearNew  = strDigitsToSCountF( tinP , psttYear  , 0xa , 1 ) ;
/*N1U*/
/*N1U*/                                                         //traceF( tinP , T("date:  \"")+T(psttDate)+T("\"\r\n") ) ;
/*N1U*/                                                         //traceF( tinP , T("month: \"")+T(psttMonth)+T("\"\r\n") ) ;
/*N1U*/                                                         //traceF( tinP , T("year:  \"")+T(psttYear)+T("\"\r\n") ) ;
/*N1U*/                                                                idlc = 0 ; strSubstringF( tinP , psttDate  , idfc , idlc , psttvt ) ; ___( psttDate  ) ;
/*N1U*/                                                                idlc = 6 ; strSubstringF( tinP , psttMonth , idfc , idlc , psttvt ) ; ___( psttMonth ) ;
/*N1U*/                                                         countT idlc = 4 ; strSubstringF( tinP , psttYear  , idfc , idlc , psttvt ) ; ___( psttYear  ) ;
/*N1U*/                                                         countT idfc = 1 ;
/*N1U*/                                                         ZE( strokeS* , psttDate ) ;
/*N1U*/                                                         ZE( strokeS* , psttMonth ) ;
/*N1U*/                                                         ZE( strokeS* , psttYear ) ;
/*N1U*/
/*N1U*/                                                         //traceF( tinP , T("value passed test 1: \"")+T(psttvt)+T("\"\r\n") ) ;
/*N1U*/                                                     {
/*N1U*/                                                     else
/*N1U*/                                                     if( psttvt->idAdam != 8 || !strIsDigitsF( tinP , psttvt , 0xa ) ) vBad = 1 ;
/*N1U*/                                                     ZE( boolT , vBad ) ;
/*N1U*/
/*N1U*/                                                     strTrimF( tinP , psttvt , psttv ) ; ___( psttvt ) ;
/*N1U*/                                                     ZE( strokeS* , psttvt ) ;
/*N1U*/
/*N1U*/                                                     //traceF( tinP , "DATE\r\n" ) ;
/*N1U*/                                                 {
/*N1U*/                                                 if( !strCompareF( tinP , psttKey , tKeyDate ) )
/*N1U*/                                                 tKeyLevel1 = T(psttKey) ;
                                                    {
                                                    case 1 :
                                                {
                                                switch( scNest )
                                            {
                                            case ifcIDmODEeTHERsOIL_REPORT :
                                            }
                                                // INTENTIONAL FALLTHROUGH
                                                strFuseF( tinP , soulOut , tColon ) ;
                                                strFuseF( tinP , soulOut , psttKey ) ;
                                                bDone = 1 ;
                                            {
                                            case ifcIDmODEeTHERsOIL_LINT   :
                                        {
                                        switch( idModeP )

                                        obeyReplacementsF( tinP , *this , psttv , swReplace , psttzLeverReplace ) ;

                                        strSubstringF( tinP , psttv , idfv , idlv , psttWord ) ; ___( psttv ) ;
                                        ZE( countT , idlv ) ;
                                        countT idfv = idft ;
                                        ZE( strokeS* , psttv ) ;
                                    {
                                    else
                                    }
                                        }
                                            case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
                                        {
                                        switch( idModeP )

                                        delF( tinP , psttKey ) ;
                                        }
                                            }
                                                break ;
                                                strFuseF( tinP , soulOut , tColon ) ;
                                                strFuseF( tinP , soulOut , psttKey ) ;
                                            {
                                            default :
                                            }
                                                break ;
                                            {
                                            case ifcIDmODEeTHERsOIL_REPORT :
                                        {
                                        switch( idModeP )

                                        bDone = 1 ;
                                        cFlag1 ++ ;
                                    {
                                    else if( !idft )
                                    }
                                        delF( tinP , psttKey ) ;
                                        }
                                            }
                                                break ;
                                                }
                                                    delF( tinP , psttv ) ;
                                                    strFuseF( tinP , soulOut , psttv ) ;
                                                    strSubstringF( tinP , psttv , idfv , idlv , psttWord ) ; ___( psttv ) ;
                                                    ZE( countT , idlv ) ;
                                                    countT idfv = idft ;
                                                    ZE( strokeS* , psttv ) ;
                                                {
                                                if( idft )

                                                strFuseF( tinP , soulOut , tColon ) ;
                                                strFuseF( tinP , soulOut , psttKey ) ;
                                            {
                                            default :
                                            }
                                                break ;
                                            {
                                            case ifcIDmODEeTHERsOIL_REPORT :
                                        {
                                        switch( idModeP )

                                        }
                                            case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
                                        {
                                        switch( idModeP )

                                        bDone = 1 ;
                                        cFlag1 ++ ;
                                    {
                                    if( !bOkKey )

                                    }
                                        }
                                            break ;
                                            ;
                                                    : 1
                                                    ? 0
                                                : offk == offKeyOkBuy && !cents && scNest == 1
                                                ? 0
                                            bOkKey = offk == offKeyOkTime && ( !year || !month || !date )
                                        {
                                        if( !strCompareF( tinP , psttKey , ppsttOkKey[ offk ] ) )
                                    {
                                    else for( countT offk = 0 ; offk < sizeof ppsttOkKey / sizeof ppsttOkKey[ 0 ] ; offk ++ )
                                    if( scNest > 1 && !strCompareF( tinP , tKeyLevel1 , tKeyComment ) && !strCompareF( tinP , tKeyLevel1 , tKeyNull ) ) bOkKey = 1 ;
                                    ZE( boolT , bOkKey ) ;

                                    __( !strSubstringF( tinP , psttKey , idft , sttqt , tColon , psttWord ) ) ; ___( psttKey ) ;
                                    strokeS sttqt( 0 , sc_IGNOREqUOTES ) ;
                                    countT idft = 1 ;
                                    ZE( strokeS* , psttKey ) ;
                                {
                                else
                                }
                                    }
                                        case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
                                    {
                                    switch( idModeP )
                                    cFlag1 ++ ;
                                {
                                if( bBadPrefix )

                                bBadPrefix = 1 ;
                                )
                                    psttWord->idAdam < idfb                           // NO STROKES FOLLOW COLON
                                    ||
                                    psttWord[ CSpREFIX - 1 + idfb ].idAdam != ':'     // KEY NOT FOLLOWED BY COLON
                                    ||
                                    !idfb                                           // NOTHING FOLLOWS KEY
                                    ||
                                    idb != 1                                        // KEY DOES NOT BEGIN AT 1 OR IS NULL LENGTH
                                (
                                if
                            {
                            if( !bDown ) //THIS WILL PREVENT PARSING OF NONBLACK BETWEEN CONSECUTIVE CLOSE CURLY BRACKETS ; EDIT IF EVER NEED TO PARSE SUCH TEXT

                            }
                                bBadPrefix = 1 ;
                                }
                                    case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
                                {
                                switch( idModeP )
                                cFlag1 ++ ;
                            {
                            if( idb && !bAllowLevel1 && scNest == 1 )

                            // idfb: BEGINNING OF THE NONBLACK, IF ANY, THAT FOLLOWS THE BLACK
                            // idb : BEGINNING OF A BLACK, IF ANY

                            countT idb = strIdAnyF( tinP , 0 , flSTRmATCH_null , idfb , sttqb , tBlack , psttWord ) ;
                            strokeS sttqb( 0 , sc_IGNOREqUOTES ) ;
                            countT idfb = 1 ;

                            ZE( boolT , bBadPrefix ) ;
                        {
                        else
                        }
                            }
                                }
                                    case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
                                {
                                switch( idModeP )
                                cFlag1 ++ ;
                            {
                            if( idw != 1 || idfw )

                            // idfw: BEGINNING OF THE NONWHITE, IF ANY, THAT FOLLOWS THE WHITE
                            // idw : BEGINNING OF A WHITE, IF ANY

                            countT idw = strIdAnyF( tinP , 0 , flSTRmATCH_null , idfw , sttqw , tWhite , psttWord ) ;
                            strokeS sttqw( 0 , sc_IGNOREqUOTES ) ;
                            countT idfw = 1 ;
                        {
                        if( !scNest )
                    {
                    else
                    }
                        bDone = 1 ;

                        soulValue << psttWord ;
                        //traceF( tinP , T("pushing [psttv]: \"")+T(psttWord)+T("\"\r\n") ) ;

                        obeyReplacementsF( tinP , *this , psttWord , swReplace , psttzLeverReplace ) ;
                    {
                    else if( soulValue ) // HERE I ASSUME THAT THE "WORD" IS A PIECE, AFTER THE FIRST PIECE, OF A WHOLE VALUE, AND JUST QUEUE IT FOR LAZY PROCESSING
                    }
                        }
                            case ifcIDmODEeTHERsOIL_LINT : { if( cFlag1 <= CfLAG1mAX ) { strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tFlag1 ) ; } break ; }
                        {
                        switch( idModeP )
                        cFlag1 ++ ;
                    {
                    )
                        1 == strIdF( tinP , tm2 , psttWord )
                        ||
                        1 == strIdF( tinP , tm1 , psttWord )
                    (
                    else if
                    }
                        bDone = 1 ;

                        else            strFuseF( tinP , soulOut , psttWord ) ;
                        if( soulValue ) soulValue << psttWord ;
                    {
                    else if( !strCompareF( tinP , psttWord , tBreakMark ) )
                    }
                        }
                            }
                                break ;
                                }
                                    strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tm101 ) ;
                                    cFlag23 ++ ;
                                {
                                if( !bAllow && cFlag23 < CfLAG23mAX )

                                }
                                    default : {                     bAllow = 0 ; break ; }
                                    case 3  : { if( !bAllowLevel3 ) bAllow = 0 ; break ; }
                                    case 2  : { if( !bAllowLevel2 ) bAllow = 0 ; break ; }
                                    case 1  : { if( !bAllowLevel1 ) bAllow = 0 ; break ; }
                                {
                                switch( scNest )
                                boolT bAllow = 1 ;
                            {
                            case ifcIDmODEeTHERsOIL_LINT :
                            case ifcIDmODEeTHERsOIL_TRIM : { strFuseF( tinP , soulOut , psttWord ) ; break ; }
                        {
                        switch( idModeP )

                        bDown = 0 ;
                        scNest ++ ;
                    {
                    else if( !strCompareF( tinP , psttWord , tm1  ) )
                    }
                        }
                            case ifcIDmODEeTHERsOIL_TRIM : { strFuseF( tinP , soulOut , psttWord ) ; break ; }
                        {
                        switch( idModeP )

                        bDown = 0 ;
                    {
                    else if( !strCompareF( tinP , psttWord , tm21 ) )
                    }
                        }
                            }
                                break ;
                                }
                                    strFuseErrorFlag_330021c0_F( tinP , *this , soulOut , tm001 ) ;
                                    cFlag23 ++ ;
                                {
                                if( scNest < 0 && cFlag23 < CfLAG23mAX )
                            {
                            case ifcIDmODEeTHERsOIL_LINT :
                            case ifcIDmODEeTHERsOIL_TRIM : { strFuseF( tinP , soulOut , psttWord ) ; break ; }
                        {
                        switch( idModeP )

                        bDown = 1 ;

                        }
                            }
                                delF( tinP , psttv ) ;
                                //traceF( tinP , T("unprocessed value piece [psttv]: \"")+T(psttv)+T("\"\r\n") ) ;
                                soulValue >> psttv ; ___( psttv ) ;
                                ZE( strokeS* , psttv ) ;
                            {
                            while( soulValue )

                            }
                                }
/*N3D*/                             break ;
/*N3D*/
/*N3D*/                             tKeyLevel3 = tn ;
/*N3D*/                             bAllowLevel3 = 1 ;
                                {
                                case 3 :
                                }
/*N2D*/                             break ;
/*N2D*/
/*N2D*/                             tKeyLevel2 = tn ;
/*N2D*/                             bAllowLevel2 = 1 ;
/*N2D*/
/*N2D*/                             tSettingsKeyPrefix = tn ;
/*N2D*/                             )
/*N2D*/                                 )
/*N2D*/                                     || tKeyLevel2 == tKeyKtr
/*N2D*/                                     || tKeyLevel2 == tKeyIPDOS
/*N2D*/                                     || tKeyLevel2 == tKeyCloudView
/*N2D*/                                        tKeyLevel2 == tKeyCloud
/*N2D*/                                 (
/*N2D*/                                 &&
/*N2D*/                                 tKeyLevel1 == tKeySettings
/*N2D*/                             (
/*N2D*/                             else if
/*N2D*/                             }
/*N2D*/                                 }
/*N2D*/                                     }
/*N2D*/                                         break ;
/*N2D*/
/*N2D*/                                         }
/*N2D*/                                             }
/*N2D*/                                                 delF( tinP , psttlt ) ;
/*N2D*/                                                 soulBody << psttlt ;
/*N2D*/
/*N2D*/                                                 //traceF( tinP , T("[trimmed]: \"")+T(psttlt)+T("\"\r\n") ) ;
/*N2D*/                                                 delF( tinP , psttl ) ;
/*N2D*/                                                 strSubstringF( tinP , psttlt , countTC( idWothMin ) , countTC() , psttl ) ; ___( psttlt ) ;
/*N2D*/                                                 ZE( strokeS* , psttlt ) ;
/*N2D*/
/*N2D*/                                                 soulLinesLazy >> psttl ; ___( psttl ) ;
/*N2D*/                                                 ZE( strokeS* , psttl ) ;
/*N2D*/                                             {
/*N2D*/                                             while( soulLinesLazy )
/*N2D*/                                         {
/*N2D*/
/*N2D*/                                         }
/*N2D*/                                             }
/*N2D*/                                                 stq_psttlDelimiterOrBlankAfterLag.purgeF( tinP ) ;
/*N2D*/                                                 }
/*N2D*/                                                     delF( tinP , psttb ) ;
/*N2D*/                                                     if( idModeP != ifcIDmODEeTHERsOIL_REPORT ) soulOut << psttb ;
/*N2D*/                                                     __Z( psttb ) ;
/*N2D*/                                                     strokeS*& psttb = *(strokeS**)&stq_psttlDelimiterOrBlankAfterLag[ idb ] ;
/*N2D*/                                                 {
/*N2D*/                                                 for( countT idb = cBlank ; idb ; idb -- )
/*N2D*/                                                 countT cBlank = stq_psttlDelimiterOrBlankAfterLag ;
/*N2D*/                                                 //DUPLICATEcODE: 360021c1 360021c1
/*N2D*/
/*N2D*/                                                 delF( tinP , psttLag ) ;
/*N2D*/                                                 soulLinesLazy << psttLag ;
/*N2D*/                                                 if( idModeP != ifcIDmODEeTHERsOIL_REPORT ) soulOut << psttLag ;
/*N2D*/                                             {
/*N2D*/                                             if( psttLag )
/*N2D*/
/*N2D*/                                             }
/*N2D*/                                                 }
/*N2D*/                                                     }
/*N2D*/                                                         idWothLag = idWoth ;
/*N2D*/                                                                   psttl = 0 ;
/*N2D*/                                                         psttLag = psttl ;
/*N2D*/
/*N2D*/                                                         }
/*N2D*/                                                             stq_psttlDelimiterOrBlankAfterLag.purgeF( tinP ) ;
/*N2D*/                                                             }
/*N2D*/                                                                 delF( tinP , psttb ) ;
/*N2D*/                                                                 if( idModeP != ifcIDmODEeTHERsOIL_REPORT ) soulOut << psttb ;
/*N2D*/                                                                 __Z( psttb ) ;
/*N2D*/                                                                 strokeS*& psttb = *(strokeS**)&stq_psttlDelimiterOrBlankAfterLag[ idb ] ;
/*N2D*/                                                             {
/*N2D*/                                                             for( countT idb = cBlank ; idb ; idb -- )
/*N2D*/                                                             countT cBlank = stq_psttlDelimiterOrBlankAfterLag ;
/*N2D*/                                                             //DUPLICATEcODE: 360021c1 360021c1
/*N2D*/
/*N2D*/                                                             delF( tinP , psttLag ) ;
/*N2D*/                                                             soulLinesLazy << psttLag ;
/*N2D*/                                                             if( idModeP != ifcIDmODEeTHERsOIL_REPORT ) soulOut << psttLag ;
/*N2D*/                                                                    
/*N2D*/                                                             }
/*N2D*/                                                                 if( idModeP != ifcIDmODEeTHERsOIL_REPORT ) soulOut << (strokeS*)tFlag1 ;
/*N2D*/                                                                 //traceF( tinP , T("error [idWoth,idWothLag]")+TF2(idWoth,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" , ")+TF2(idWothLag,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
/*N2D*/                                                             {
/*N2D*/                                                             if( idModeP == ifcIDmODEeTHERsOIL_LINT && idWothLag - 1 > idWoth && ++ cFlag1 <= CfLAG1mAX ) //INDENTATION CANNOT INCREASE BY MORE THAN 1
/*N2D*/                                                         {
/*N2D*/                                                         else
/*N2D*/                                                         }
/*N2D*/                                                             stq_psttlDelimiterOrBlankAfterLag.purgeF( tinP ) ;
/*N2D*/                                                             }
/*N2D*/                                                                 delF( tinP , psttb ) ;
/*N2D*/                                                                 if( idModeP != ifcIDmODEeTHERsOIL_REPORT ) soulOut << psttb ;
/*N2D*/                                                                 __Z( psttb ) ;
/*N2D*/                                                                 strokeS*& psttb = *(strokeS**)&stq_psttlDelimiterOrBlankAfterLag[ idb ] ;
/*N2D*/                                                             {
/*N2D*/                                                             for( countT idb = cBlank ; idb ; idb -- )
/*N2D*/                                                             countT cBlank = stq_psttlDelimiterOrBlankAfterLag ;
/*N2D*/                                                             //DUPLICATEcODE: 360021c1 360021c1
/*N2D*/                                                         {
/*N2D*/                                                         if( !psttLag )
/*N2D*/
/*N2D*/                                                         if( !idWothMin || idWothMin > idWoth ) idWothMin = idWoth ;
/*N2D*/
/*N2D*/                                                         //traceF( tinP , T("[idWoth,psttl]: ")+TF2(idWoth,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    >")+T(psttl)+T("<") ) ;
/*N2D*/                                                     {
/*N2D*/                                                     else
/*N2D*/                                                     if( !idWoth ) { stq_psttlDelimiterOrBlankAfterLag << psttl ; psttl = 0 ; }
/*N2D*/
/*N2D*/                                                     countT idWoth = strIdAnyF( tinP , 0 , flSTRmATCH_null , countTC( 1 ) , sttq , tbcrb , psttl , 0 , 1 , flSTRiDaNY_NOT ) ;
/*N2D*/                                                     strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
/*N2D*/
/*N2D*/                                                     /**/if( bTrace && !( soulLines % TUCK ) ) traceF( tinP , T("processing body with ")+TF2((countT)soulLines,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" lines remaining") ) ;
/*N2D*/                                                 {
/*N2D*/                                                 if( !POOP )
/*N2D*/                                                 __Z( psttl ) ;
/*N2D*/                                                 soulLines >> psttl ; ___( psttl ) ;
/*N2D*/                                                 ZE( strokeS* , psttl ) ;
/*N2D*/                                             {
/*N2D*/                                             while( soulLines )
/*N2D*/                                             staqC stq_psttlDelimiterOrBlankAfterLag( tinP ) ;
/*N2D*/                                             ZE( countT   , idWothLag ) ;
/*N2D*/                                             ZE( strokeS* , psttLag ) ;
/*N2D*/                                         {
/*N2D*/                                         soulC soulLinesLazy( tinP , TAG( TAGiDnULL ) , flSOUL_LIFO , "soul.lines.lazy" ) ;
/*N2D*/                                         //U::20140127@1657: REPLACED WITH soulLinesLazy: staqC stq_psttl( tinP ) ;
/*N2D*/                                         ZE( countT , idWothMin ) ;
/*N2D*/
/*N2D*/                                         traceF( tinP , T("called strWordsF 1") ) ;
/*N2D*/                                         countT cWords = strWordsF( tinP , soulLines , soulValue , sttq , tcr , flSTRwORDS_DELIMITERS|flSTRwORDS_SPLITaTmARK|flSTRwORDS_CONSUMEiNPUT ) ;
/*N2D*/                                         traceF( tinP , T("calling strWordsF 1") ) ;
/*N2D*/                                         soulC soulLines( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.lines" ) ;  // THIS IS LIFO BECAUSE KTR ("KNOWLEDGE TREE REVERSED") INPUT IS IN REVERSE ORDER SO THAT IT FLOWS UPWARD WHEN THE SOIL FILE IS EDITED USING A CONVENTIONAL FOREIGN EDITOR
/*N2D*/
/*N2D*/                                         //strokeF( tinP , T("before strReverseF [psttv]]:\r\n\"")+T(psttv)+T("\"\r\n") ) ;
/*N2D*/                                     {
/*N2D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N2D*/                                     case ifcIDmODEeTHERsOIL_LINT :
/*N2D*/                                 {
/*N2D*/                                 switch( idModeP )
/*N2D*/                             {
/*N2D*/                             if( tKeyLevel2 == tKeyBody && tKeyLevel1 == tKeyKtr )
                                {
                                case 2 :
                                }
/*N1D*/                             break ;
/*N1D*/
/*N1D*/                             }
/*N1D*/                                 delF( tinP , psttm ) ;
/*N1D*/                                 //traceF( tinP , T("set 6 [tArchive]: ")+tArchive ) ;
/*N1D*/                                 tArchive = T(psttm) ;
/*N1D*/                                 diskMapFileNameF( tinP , psttm , T("///ideafarm/IdeaFarm (tm)/")+( tUserOverride.csF( tinP ) ? tUserOverride : tUser )+T("/Drop Files Here To Archive/") ) ; ___( psttm ) ;
/*N1D*/                                 ZE( strokeS* , psttm ) ;
/*N1D*/                             {
/*N1D*/                             if( !tReportsSource.csF( tinP ) )
/*N1D*/                             tUserOverride = tKeyLevel1 = tn ;
/*N1D*/                             bAllowLevel1 = 1 ; bAllowLevel3 = bAllowLevel2 = 0 ; //NONDEFAULT SETTINGS FOR LEVEL 1 AND 2 PERSIST UNTIL CLIMBING DOWN FROM 1
/*N1D*/
/*N1D*/                             }
/*N1D*/                                 }
/*N1D*/                                     }
/*N1D*/                                         }
/*N1D*/                                             delF( tinP , ppstt2[ 1 ] ) ;
/*N1D*/                                             delF( tinP , ppstt2[ 0 ] ) ;
/*N1D*/
/*N1D*/                                             //traceF( tinP , T("stTimeMinMax - [ppstt2[0],ppstt2[1]]:    \"")+T(ppstt2[0])+T("\"    \"")+T(ppstt2[1])+T("\"") ) ;
/*N1D*/
/*N1D*/                                             stTimeMinMax >> pbTo ;
/*N1D*/                                             byteT* pbTo = (byteT*)ppstt2 ;
/*N1D*/                                             strokeS* ppstt2[ 2 ] ;
/*N1D*/                                         {
/*N1D*/                                         while( stTimeMinMax )
/*N1D*/                                     {
/*N1D*/                                     default :
/*N1D*/                                     }
/*N1D*/                                         //INTENTIONAL FALLTHROUGH
/*N1D*/
/*N1D*/                                         }
/*N1D*/                                             default : { BLAMMO ; }
/*N1D*/                                             }
/*N1D*/                                                 break ;
/*N1D*/                                             {
/*N1D*/                                             case ifcIDmODEsOILwALK_INSPECTfILEnAMES :
/*N1D*/                                             }
/*N1D*/                                                 break ;
/*N1D*/
/*N1D*/                                                 delF( tinP , psttCurrentZipFile ) ;
/*N1D*/                                                 }
/*N1D*/                                                     delF( tinP , psttOsFileList ) ;
/*N1D*/                                                     osProcessF( tinP , countTC() , countTC() , value , idDeathType , tExeZip , tArg ) ;
/*N1D*/                                                     ZE( countT , idDeathType ) ;
/*N1D*/                                                     ZE( countT , value ) ;
/*N1D*/                                                     //traceF( tinP , tExeZip+T(" : ")+tArg ) ;
/*N1D*/
/*N1D*/                                                     TN( tArg , "" ) ; tArg = T("-9mj \"")+T(osfnZipFile)+tQuote+tBlank+T(psttOsFileList) ;
/*N1D*/
/*N1D*/                                                     osFileNameC osfnZipFile( tinP , third , T(psttCurrentZipFile) ) ;
/*N1D*/                                                     cListed = 0 ;
/*N1D*/                                                 {
/*N1D*/                                                 if( psttOsFileList && cListed )
/*N1D*/
/*N1D*/                                                 /**************************************************************************************************/
/*N1D*/                                                 /*****                                                                                        *****/
/*N1D*/                                                 /***** FLUSH ALL LISTED FILES TO THE CURRENT ZIP FILE                                         *****/
/*N1D*/                                                 /*****                                                                                        *****/
/*N1D*/                                                 /**************************************************************************************************/
/*N1D*/
/*N1D*/                                                 }
/*N1D*/                                                     delF( tinP , pstt1NameTriple ) ;
/*N1D*/                                                     }
/*N1D*/                                                         cbEstimateListed += cbEstimate ;
/*N1D*/                                                         cListed ++ ;
/*N1D*/                                                         strFuseF( tinP , psttOsFileList , tQuote+T(osfn)+tQuote ) ;
/*N1D*/                                                         if( psttOsFileList->idAdam ) strFuseF( tinP , psttOsFileList , tBlank ) ;
/*N1D*/
/*N1D*/                                                         delF( tinP , psttm ) ;
/*N1D*/                                                         osFileNameC osfn( tinP , third , T(psttm) ) ;
/*N1D*/
/*N1D*/                                                         diskMapFileNameF( tinP , psttm , tArchive+T(psttzFileName) ) ; ___( psttm ) ;
/*N1D*/                                                         ZE( strokeS* , psttm ) ;
/*N1D*/
/*N1D*/                                                         /**************************************************************************************************/
/*N1D*/                                                         /*****                                                                                        *****/
/*N1D*/                                                         /***** LIST THE CURRENT FILE                                                                  *****/
/*N1D*/                                                         /*****                                                                                        *****/
/*N1D*/                                                         /**************************************************************************************************/
/*N1D*/
/*N1D*/                                                         if( !psttCurrentZipFile ) { diskMapFileNameF( tinP , psttCurrentZipFile , tArchive+T("!ideafarm.9.2.00000000.00000001.")+tDateListed+tDayZipSuffix1+TF3(idZipNext++,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,3)+tDayZipSuffix2 ) ; ___( psttCurrentZipFile ) ; }
/*N1D*/                                                         //U:: 20200410@2018: THE NEXT LINE PROBABLY DOES NOT EMIT A VALID FORMAT 9 FILE NAME
/*N1D*/
/*N1D*/                                                         }
/*N1D*/                                                             cbCurrentZipFile = 0 ;
/*N1D*/                                                             delF( tinP , psttCurrentZipFile ) ;
/*N1D*/                                                             idZipNext   = 1     ;
/*N1D*/                                                             tDateListed = tDate ;
/*N1D*/                                                         {
/*N1D*/                                                         if( bNewDate )
/*N1D*/
/*N1D*/                                                         /**************************************************************************************************/
/*N1D*/                                                         /*****                                                                                        *****/
/*N1D*/                                                         /***** CALCULATE THE NAME OF THE NEW CURRENT ZIP FILE (IF IT HAS BEEN RESET)                  *****/
/*N1D*/                                                         /*****                                                                                        *****/
/*N1D*/                                                         /**************************************************************************************************/
/*N1D*/
/*N1D*/                                                         }
/*N1D*/                                                             }
/*N1D*/                                                                 cbCurrentZipFile = 0 ;
/*N1D*/                                                                 delF( tinP , psttCurrentZipFile ) ;
/*N1D*/                                                             {
/*N1D*/                                                             if( cbEnough <= cbCurrentZipFile + cbEstimate )
/*N1D*/
/*N1D*/                                                             }
/*N1D*/                                                                 }
/*N1D*/                                                                     DEL( pInfo ) ;
/*N1D*/                                                                     ;
/*N1D*/                                                                         : pInfo->cbUsed
/*N1D*/                                                                         ? - 1
/*N1D*/                                                                     cbCurrentZipFile = pInfo->cbUsedHigh
/*N1D*/                                                                     diskFileQueryF( tinP , pInfo , woZip ) ;
/*N1D*/                                                                     ZE( infoFileS* , pInfo ) ;
/*N1D*/                                                                     fileC woZip( tinP , psttCurrentZipFile ) ;
/*N1D*/                                                                 {
/*N1D*/
/*N1D*/                                                                 //__( idDeathType ) ;
/*N1D*/                                                                 //__( value ) ;             // NOT CHECKED, BECAUSE CAN BE CAUSED BY USER ERROR (TARGET ZIP FILE IS CORRUPT)
/*N1D*/                                                                 osProcessF( tinP , countTC() , countTC() , value , idDeathType , tExeZip , tArg ) ; //THIS CAN FAIL (E.G. IF TARGET ZIP FILE IS CORRUPT
/*N1D*/                                                                 ZE( countT , idDeathType ) ;
/*N1D*/                                                                 ZE( countT , value ) ;
/*N1D*/                                                                 //traceF( tinP , tArg ) ;
/*N1D*/                                                                 //traceF( tinP , tExeZip ) ;
/*N1D*/
/*N1D*/                                                                 strMakeF( tinP , psttOsFileList , 0 , ( 1 + cFilesPerZipLaunch ) * ( 1 + TUCK ) ) ; ___( psttOsFileList ) ; // WO EXTRA WO JUST TO MAKE SURE
/*N1D*/                                                                 cbEstimateListed = 0 ;
/*N1D*/                                                                 cListed = 0 ;
/*N1D*/                                                                 delF( tinP , psttOsFileList ) ;
/*N1D*/                                                                 TN( tArg , "" ) ; tArg = T("-9mj \"")+T(osfnZipFile)+tQuote+tBlank+T(psttOsFileList) ;
/*N1D*/
/*N1D*/                                                                 osFileNameC osfnZipFile( tinP , third , T(psttCurrentZipFile) ) ;
/*N1D*/                                                             {
/*N1D*/
/*N1D*/                                                             /**************************************************************************************************/
/*N1D*/                                                             /*****                                                                                        *****/
/*N1D*/                                                             /***** FLUSH THE LISTED FILES TO THE CURRENT ZIP FILE                                         *****/
/*N1D*/                                                             /*****                                                                                        *****/
/*N1D*/                                                             /**************************************************************************************************/
/*N1D*/                                                         {
/*N1D*/                                                         )
/*N1D*/                                                             )
/*N1D*/                                                                 )
/*N1D*/                                                                     cbEnough <= cbCurrentZipFile + cbEstimateListed + cbEstimate // THE FILE WOULD OVERFLOW
/*N1D*/                                                                     ||
/*N1D*/                                                                     bNewDate                                                     // THE DATE HAS CHANGED
/*N1D*/                                                                 (
/*N1D*/                                                                 ||
/*N1D*/                                                                 cListed == cFilesPerZipLaunch                                    // ENOUGH FILES ARE LISTED
/*N1D*/                                                             (
/*N1D*/                                                             &&
/*N1D*/                                                             cListed                                                              // AT LEAST 1 FILE IS LISTED
/*N1D*/                                                         (
/*N1D*/                                                         if
/*N1D*/
/*N1D*/                                                         boolT bNewDate = strCompareF( tinP , tDate , tDateListed ) ;
/*N1D*/                                                         }
/*N1D*/                                                             delF( tinP , psttDate ) ;
/*N1D*/                                                             tDate = T(psttDate) ;
/*N1D*/                                                             strSubstringF( tinP , psttDate , idf , idl , psttzFileName ) ; ___( psttDate ) ;
/*N1D*/                                                             countT idl = 0x14 ;
/*N1D*/                                                             countT idf = 0x0d ;
/*N1D*/                                                             ZE( strokeS* , psttDate ) ;
/*N1D*/                                                         {
/*N1D*/                                                         TN( tDate , "" ) ;
/*N1D*/                                                         //CS:CODEsYNC: PSEUDOdUPLICATE CODE: 360021c1 360021c1
/*N1D*/
/*N1D*/                                                         }
/*N1D*/                                                             cbEstimate += psttzFileName->idAdam >> 1 ; // ENSURES NONZE ; ADDS THE ESTIMATED BYTES NEEDED TO STORE THE FILE NAME
/*N1D*/                                                             ;
/*N1D*/                                                                 : cbInput << 1  // THIS RULE ARBITRARILY ASSUMES THAT ZIP COMPRESSION IS 1/2
/*N1D*/                                                                 ? cbInput
/*N1D*/                                                             cbEstimate = strIdF( tinP , tZipSuffix , psttzFileName ) == psttzFileName->idAdam + 1 - tZipSuffix.csF( tinP )
/*N1D*/
/*N1D*/                                                             }
/*N1D*/                                                                 DEL( pInfo ) ;
/*N1D*/                                                                 ;
/*N1D*/                                                                     : pInfo->cbUsed
/*N1D*/                                                                     ? - 1
/*N1D*/                                                                 cbInput = pInfo->cbUsedHigh
/*N1D*/                                                                 diskFileQueryF( tinP , pInfo , inFile ) ;
/*N1D*/                                                                 ZE( infoFileS* , pInfo ) ;
/*N1D*/                                                                 fileC inFile( tinP , (const strokeS*)( tArchive+T(psttzFileName) ) ) ;
/*N1D*/                                                             {
/*N1D*/                                                             ZE( countT , cbInput ) ;
/*N1D*/                                                         {
/*N1D*/                                                         ZE( countT , cbEstimate ) ;
/*N1D*/
/*N1D*/                                                         /**************************************************************************************************/
/*N1D*/                                                         /*****                                                                                        *****/
/*N1D*/                                                         /***** INSPECT THE FILE (GET ESTIMATED ZIPPED SIZE, DATE)                                     *****/
/*N1D*/                                                         /*****                                                                                        *****/
/*N1D*/                                                         /**************************************************************************************************/
/*N1D*/
/*N1D*/                                                         //traceF( tinP , psttzFileName ) ;
/*N1D*/                                                     {
/*N1D*/                                                     else
/*N1D*/                                                     }
/*N1D*/                                                         traceF( tinP , T("rejected: ")+T(psttzFileName) ) ;
/*N1D*/                                                     {
/*N1D*/                                                     )
/*N1D*/                                                         strIdF( tinP , tNix2 , psttzFileName )
/*N1D*/                                                         ||
/*N1D*/                                                         strIdF( tinP , tNix1 , psttzFileName )
/*N1D*/                                                         ||
/*N1D*/                                                         strIdF( tinP , tDayZipSuffix2 , psttzFileName )
/*N1D*/                                                         ||
/*N1D*/                                                         psttzFileName->idAdam <= 0x1e
/*N1D*/                                                     (
/*N1D*/                                                     if
/*N1D*/                                                     strConvertToLowerCaseF( tinP , psttzFileName ) ; ___( psttzFileName ) ;
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         else if( !psttzShortThumbnail ) psttzShortThumbnail = psttc1 ;
/*N1D*/                                                         else if( !psttzCurrentName    ) psttzCurrentName    = psttc1 ;
/*N1D*/                                                              if( !psttzFileName       ) psttzFileName       = psttc1 ;  // EXAMPLE: "!ideafarm.0.foo.600x400.jpg"
/*N1D*/                                                     {
/*N1D*/                                                     FORsTRINGSiN1( pstt1NameTriple )
/*N1D*/                                                     ZE( strokeS* , psttzShortThumbnail ) ;
/*N1D*/                                                     ZE( strokeS* , psttzCurrentName ) ;
/*N1D*/                                                     ZE( strokeS* , psttzFileName ) ;
/*N1D*/
/*N1D*/                                                     soulFileNames >> pstt1NameTriple ; ___( pstt1NameTriple ) ;         // EXAMPLE: "!ideafarm.0.foo.600x400.jpg"
/*N1D*/                                                     ZE( strokeS* , pstt1NameTriple ) ;                                //           |-----p1------||--sss--||2|
/*N1D*/                                                 {                                                                   // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
/*N1D*/                                                 while( soulFileNames )                                              // 0              1               2               3               4               5               6
/*N1D*/
/*N1D*/                                                 strMakeF( tinP , psttOsFileList , 0 , ( 1 + cFilesPerZipLaunch ) * ( 1 + TUCK ) ) ; ___( psttOsFileList ) ; // WO EXTRA WO JUST TO MAKE SURE
/*N1D*/                                                 const countT cbEnough = TICK << 4 ;
/*N1D*/                                                 const countT cFilesPerZipLaunch = TUCK >> 4 ;
/*N1D*/                                                 countT idZipNext = 1 ;
/*N1D*/                                                 ZE( countT , cbEstimateListed ) ;
/*N1D*/                                                 ZE( strokeS* , psttOsFileList ) ;
/*N1D*/                                                 ZE( countT , cListed ) ;
/*N1D*/                                                 ZE( countT   , cbCurrentZipFile ) ;
/*N1D*/                                                 ZE( strokeS* , psttCurrentZipFile ) ;
/*N1D*/                                                 TN( tDateListed , "" ) ;
/*N1D*/
/*N1D*/                                                 TN( tQuote , "\"" ) ;
/*N1D*/                                                 TN( tBlank , " " ) ;
/*N1D*/
/*N1D*/                                                 TN( tNix2 , ".!.locked.day.zip" ) ;
/*N1D*/                                                 TN( tNix1 , ".!.day.title.ttt" ) ;
/*N1D*/                                                 TN( tDayZipSuffix2 , ".!.day.zip" ) ;
/*N1D*/                                                 TN( tDayZipSuffix1 , "@0000.000." ) ;
/*N1D*/                                                 TN( tZipSuffix , ".zip" ) ;
/*N1D*/
/*N1D*/                                                 }
/*N1D*/                                                     delF( tinP , psttm ) ;
/*N1D*/                                                     tExeZip = T(psttm) ;
/*N1D*/                                                     diskMapFileNameF( tinP , psttm , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/infozip/zip.exe/zip.exe") ) ; ___( psttm ) ;
/*N1D*/                                                     ZE( strokeS* , psttm ) ;
/*N1D*/                                                 {
/*N1D*/                                                 TN( tExeZip , "" ) ;
/*N1D*/
/*N1D*/                                                 }
/*N1D*/                                                     }
/*N1D*/                                                         if( POOP ) POOPR ;
/*N1D*/                                                         tinP.pEtScratch->diskWalkF( tinP , cDirs , cFiles , tArchive , bQuit , flDISKwALK_null , etherSoilWalkCBF , pcArg ) ; // WILL FAIL IF tUserOverride CONTAINS DOUBLE QUOTE MARKS OR OTHER STROKES THAT MAKE THE PATH NAME INVALID
/*N1D*/                                                         SCOOPS
/*N1D*/                                                     {
/*N1D*/                                                     IFsCRATCH
/*N1D*/
/*N1D*/                                                     /**/if( bTrace ) traceF( tinP , T("etherSoilF / tKeyZip / reloading stale soulFileNames") ) ;
/*N1D*/                                                     cFiles = 0 ;
/*N1D*/                                                     cDirs  = 0 ;
/*N1D*/
/*N1D*/                                                     soulFileNames.removeAllF( tinP ) ;
/*N1D*/
/*N1D*/                                                     /**********************************************************************************************************/
/*N1D*/                                                     /*****                                                                                                *****/
/*N1D*/                                                     /***** RELOAD stFileName SINCE IT IS STALE                                                            *****/
/*N1D*/                                                     /*****                                                                                                *****/
/*N1D*/                                                     /**********************************************************************************************************/
/*N1D*/                                                 {
/*N1D*/                                                 if( cDaysUpdated )
/*N1D*/
/*N1D*/                                                 /**************************************************************************************************************/
/*N1D*/                                                 /*****                                                                                                    *****/
/*N1D*/                                                 /***** IT IS TIME TO ZIP THE ARCHIVE INTO DAY ZIP FILES                                                   *****/
/*N1D*/                                                 /***** THE FILES FOR EACH DAY ARE EITHER COMPLETELY ZIPPZED OR COMPLETELY UNZIPPED                        *****/
/*N1D*/                                                 /*****                                                                                                    *****/
/*N1D*/                                                 /**************************************************************************************************************/
/*N1D*/
/*N1D*/                                                 }
/*N1D*/                                                     if( diskFileExistsF( tinP , tDirTemporary ) ) diskFileOrDirDeleteF( tinP , tDirTemporary ) ;
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         pour360021c1F( tinP , *this , tArchive , tDirTemporary ) ;
/*N1D*/                                                         cDaysUpdated ++ ;
/*N1D*/                                                     {
/*N1D*/                                                     if( bMerge )
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         delF( tinP , pstt1NameTriple ) ;
/*N1D*/                                                         delF( tinP , psttFileName ) ;
/*N1D*/                                                         }
/*N1D*/                                                             }
/*N1D*/                                                                 diskMoveFileOrDirF(   tinP , tDirTemporary+tShort , tArchive+tShort ) ;
/*N1D*/                                                                 diskFileOrDirDeleteF( tinP , tDirTemporary+tShort ) ;
/*N1D*/                                                                 TN( tShort , psttzFileName ) ;
/*N1D*/                                                             {
/*N1D*/                                                             if( bMerge )
/*N1D*/
/*N1D*/                                                             }
/*N1D*/                                                                 while( !etherC::etPrimeIF( tinP ) && ~hFind ) ;
/*N1D*/                                                                 }
/*N1D*/                                                                     DEL( pInfo ) ;
/*N1D*/                                                                     }
/*N1D*/                                                                         }
/*N1D*/                                                                             if( !value && !idDeathType ) diskFileOrDirDeleteF( tinP , pInfo->psttIfoName ) ;
/*N1D*/
/*N1D*/                                                                             //__( idDeathType ) ;
/*N1D*/                                                                             //__( value ) ;             // NOT CHECKED, BECAUSE CAN BE CAUSED BY USER ERROR (TARGET ZIP FILE IS CORRUPT)
/*N1D*/                                                                             osProcessF( tinP , countTC() , countTC() , value , idDeathType , tExeUnzip , tArg ) ; //THIS CAN FAIL (E.G. IF TARGET ZIP FILE IS CORRUPT
/*N1D*/                                                                             ZE( countT , idDeathType ) ;
/*N1D*/                                                                             ZE( countT , value ) ;
/*N1D*/                                                                             //traceF( tinP , tArg ) ;
/*N1D*/                                                                             //traceF( tinP , tExeUnzip ) ;
/*N1D*/
/*N1D*/                                                                             hoverC hover( tinP , *this , tDirTemporary ) ; //U::NOT THREAD SAFE: ADD SERIALIZATION
/*N1D*/
/*N1D*/                                                                             TN( tArg , "" ) ; tArg = T(" \"")+T(osfnZipFile)+tQuote ;
/*N1D*/
/*N1D*/                                                                             osFileNameC osfnZipFile( tinP , third , T(pInfo->psttIfoName) ) ;
/*N1D*/                                                                         {
/*N1D*/                                                                         //traceF( tinP , T("unziping to temp: ")+T(pInfo->psttIfoName) ) ;
/*N1D*/                                                                     {
/*N1D*/                                                                     if( pInfo && pInfo->psttIfoName )
/*N1D*/                                                                     diskFindFileOrDirF( tinP , pInfo , hFind , fn.pathF() , &pat ) ;
/*N1D*/                                                                 {
/*N1D*/                                                                 do
/*N1D*/                                                                 handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
/*N1D*/                                                                 ZE( infoFileS* , pInfo ) ;
/*N1D*/                                                                 patternC pat( tinP , *this , fn , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                                 fileNameC fn( tinP , *this , tFileDayZipLike ) ;
/*N1D*/
/*N1D*/                                                                 }
/*N1D*/                                                                     delF( tinP , psttPrefix ) ;
/*N1D*/                                                                     tFileDayZipLike = tArchive+T(psttPrefix)+T("0000.000.???.!.day.zip") ;
/*N1D*/
/*N1D*/                                                                     strSubstringF( tinP , psttPrefix , idf , idl , psttzFileName ) ; ___( psttPrefix ) ;
/*N1D*/                                                                     countT idl = 0x15 ;
/*N1D*/                                                                     countT idf = 0x01 ;
/*N1D*/                                                                     ZE( strokeS* , psttPrefix ) ;
/*N1D*/
/*N1D*/                                                                     //   !ideafarm.9.2.00000000.00000001.20140703@0000.!.day.zip
/*N1D*/                                                                     //   !ideafarm.8.2.00000000.00000001.20140703@0000.000.001.!.day.zip
/*N1D*/                                                                     //   123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
/*N1D*/                                                                     //   0              1               2               3               4               5               6               7               8
/*N1D*/                                                                 {
/*N1D*/                                                                 TN( tFileDayZipLike , "" ) ;
/*N1D*/
/*N1D*/                                                                 /**********************************************************************************************************/
/*N1D*/                                                                 /*****                                                                                                *****/
/*N1D*/                                                                 /***** A TEMPORARY DIR                                                                                *****/
/*N1D*/                                                                 /***** AT LEAST WO UNZIPPED FILE IS PRESENT, SO UNZIP AND DELETE ALL DAY ZIPS FOR THIS DAY INTO       *****/
/*N1D*/                                                                 /*****                                                                                                *****/
/*N1D*/                                                                 /**********************************************************************************************************/
/*N1D*/
/*N1D*/                                                                 bWoth = 0 ;
/*N1D*/                                                             {
/*N1D*/                                                             if( bWoth )
/*N1D*/                                                         {
/*N1D*/                                                         else
/*N1D*/                                                         }
/*N1D*/                                                             bMerge = 1 ;
/*N1D*/                                                             st_psttFile << (countT)psttFileName ; psttFileName = 0 ;
/*N1D*/                                                         {
/*N1D*/                                                         if( strIdF( tinP , tDayZip , psttzFileName , 1 ) == psttzFileName->idAdam + 1 - tDayZip.csF( tinP ) )
/*N1D*/
/*N1D*/                                                         }
/*N1D*/                                                             if( diskFileExistsF( tinP , tDirTemporary ) ) diskFileOrDirDeleteF( tinP , tDirTemporary ) ;
/*N1D*/                                                             st_psttFile.purgeF( tinP ) ;
/*N1D*/                                                             bMerge = 0 ;
/*N1D*/                                                             bWoth = 1 ;
/*N1D*/
/*N1D*/                                                             tDateLath = tDate ;
/*N1D*/
/*N1D*/                                                             }
/*N1D*/                                                                 pour360021c1F( tinP , *this , tArchive , tDirTemporary ) ;
/*N1D*/                                                                 cDaysUpdated ++ ;
/*N1D*/                                                             {
/*N1D*/                                                             if( bMerge )
/*N1D*/                                                         {
/*N1D*/                                                         if( bNewDate )
/*N1D*/
/*N1D*/                                                         boolT bNewDate = strCompareF( tinP , tDate , tDateLath ) ;
/*N1D*/                                                         }
/*N1D*/                                                             delF( tinP , psttDate ) ;
/*N1D*/                                                             tDate = T(psttDate) ;
/*N1D*/                                                             strSubstringF( tinP , psttDate , idf , idl , psttzFileName ) ; ___( psttDate ) ;
/*N1D*/                                                             countT idl = 0x14 ;
/*N1D*/                                                             countT idf = 0x0d ;
/*N1D*/                                                             ZE( strokeS* , psttDate ) ;
/*N1D*/                                                         {
/*N1D*/                                                         TN( tDate , "" ) ;
/*N1D*/                                                         //CS:CODEsYNC: PSEUDOdUPLICATE CODE: 360021c1 360021c1
/*N1D*/
/*N1D*/                                                         //traceF( tinP , psttzFileName ) ;
/*N1D*/                                                         strMakeF( tinP , psttFileName , psttzFileName ) ; ___( psttFileName ) ;
/*N1D*/                                                         ZE( strokeS* , psttFileName ) ;
/*N1D*/
/*N1D*/                                                         }
/*N1D*/                                                             else if( !psttzShortThumbnail ) psttzShortThumbnail = psttc1 ;
/*N1D*/                                                             else if( !psttzCurrentName    ) psttzCurrentName    = psttc1 ;
/*N1D*/                                                                  if( !psttzFileName       ) psttzFileName       = psttc1 ;  // EXAMPLE: "!ideafarm.0.foo.600x400.jpg"
/*N1D*/                                                         {
/*N1D*/                                                         FORsTRINGSiN1( pstt1NameTriple )
/*N1D*/                                                         ZE( strokeS* , psttzShortThumbnail ) ;
/*N1D*/                                                         ZE( strokeS* , psttzCurrentName ) ;
/*N1D*/                                                         ZE( strokeS* , psttzFileName ) ;
/*N1D*/
/*N1D*/                                                         soulFileNamesCopy >> pstt1NameTriple ; ___( pstt1NameTriple ) ;
/*N1D*/                                                         ZE( strokeS* , pstt1NameTriple ) ;
/*N1D*/                                                     {
/*N1D*/                                                     while( soulFileNamesCopy )
/*N1D*/                                                     ZE( boolT , bMerge ) ;
/*N1D*/                                                     boolT bWoth = 1 ;
/*N1D*/                                                     TN( tQuote , "\"" ) ;
/*N1D*/                                                     TN( tDayZip , ".!.day.zip" ) ;
/*N1D*/                                                     TN( tDateLath , "" ) ;
/*N1D*/
/*N1D*/                                                     soulFileNamesCopy = soulFileNames ;
/*N1D*/                                                     soulC soulFileNamesCopy( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.file.names.copy" ) ;
/*N1D*/
/*N1D*/                                                     /**********************************************************************************************************/
/*N1D*/                                                     /*****                                                                                                *****/
/*N1D*/                                                     /***** FOR EACH ACCEPTED FILE (FILE OTHER THAN !confidential !phone ETC.)                             *****/
/*N1D*/                                                     /*****                                                                                                *****/
/*N1D*/                                                     /**********************************************************************************************************/
/*N1D*/
/*N1D*/                                                     stackC st_psttFile(  tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_countT ) ;
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         delF( tinP , psttu ) ;
/*N1D*/                                                         tDirTemporary = T("///ideafarm/ephemeral/tmp/")+T(psttu)+T("/") ;
/*N1D*/                                                         strUniqueF( tinP , psttu ) ; ___( psttu ) ;
/*N1D*/                                                         ZE( strokeS* , psttu ) ;
/*N1D*/                                                     {
/*N1D*/                                                     TN( tDirTemporary , "" ) ;
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         delF( tinP , psttm ) ;
/*N1D*/                                                         tExeUnzip = T(psttm) ;
/*N1D*/                                                         diskMapFileNameF( tinP , psttm , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/infozip/unzip.exe/unzip.exe") ) ; ___( psttm ) ;
/*N1D*/                                                         ZE( strokeS* , psttm ) ;
/*N1D*/                                                     {
/*N1D*/                                                     TN( tExeUnzip , "" ) ;
/*N1D*/                                                 {
/*N1D*/                                                 if( soulFileNames )
/*N1D*/                                                 ZE( countT , cDaysUpdated ) ;
/*N1D*/
/*N1D*/                                                 /**************************************************************************************************************/
/*N1D*/                                                 /*****                                                                                                    *****/
/*N1D*/                                                 /***** (SAFELY, BY USING A TEMPORARY DIRECTORY AND MERGING THE NEW FILES "OVER" THE OLD FILES)            *****/
/*N1D*/                                                 /***** IF AN UNZIPPED FILE EXISTS FOR A DAY, THEN UNZIP ALL FILES FOR THAT DAY                            *****/
/*N1D*/                                                 /***** INSPECT ALL ACCUMULATED FILE NAMES                                                                 *****/
/*N1D*/                                                 /*****                                                                                                    *****/
/*N1D*/                                                 /**************************************************************************************************************/
/*N1D*/                                             {
/*N1D*/                                             case ifcIDmODEsOILwALK_ZIP :
/*N1D*/                                             }
/*N1D*/                                                 break ;
/*N1D*/                                                 }
/*N1D*/                                                     delF( tinP , pstt1NameTriple ) ;
/*N1D*/                                                     }
/*N1D*/                                                         }
/*N1D*/                                                             osEditF( tinP , tNoteFileLong ) ;
/*N1D*/                                                             { fileC( tinP , (strokeS*)tNoteFileLong , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeF ) ; }
/*N1D*/
/*N1D*/                                                             third.dosExecPgmF( tinP , countTC() , countTC() , value , idDeathType , postExeMp3 , tq+T(osfn)+tq ) ;
/*N1D*/                                                             TN( tq , "\"" ) ;
/*N1D*/                                                             ZE( countT , idDeathType ) ;
/*N1D*/                                                             ZE( countT , value ) ;
/*N1D*/
/*N1D*/                                                             thirdC::exeFromFileExtensionIF( tinP , postExeMp3 , costaExeMp3 , ".mp3" ) ;
/*N1D*/                                                             countT  costaExeMp3 = sizeof postExeMp3 ;
/*N1D*/                                                             osTextT postExeMp3[ TUCK << 1 ] ;
/*N1D*/
/*N1D*/                                                             delF( tinP , psttm ) ;
/*N1D*/                                                             osFileNameC osfn( tinP , third , T(psttm) ) ;
/*N1D*/
/*N1D*/                                                             diskMapFileNameF( tinP , psttm , tArchive+T(psttzFileName) ) ; ___( psttm ) ;
/*N1D*/                                                             ZE( strokeS* , psttm ) ;
/*N1D*/
/*N1D*/                                                             traceF( tinP , T("note file does not exist for [file]: ")+T(psttzFileName) ) ;
/*N1D*/                                                         {
/*N1D*/                                                         if( !diskFileExistsF( tinP , tNoteFileLong ) )
/*N1D*/                                                         TN( tNoteFileLong , "" ) ; tNoteFileLong = tArchive+tNoteFile ;
/*N1D*/
/*N1D*/                                                         //traceF( tinP , tNoteFile ) ;
/*N1D*/
/*N1D*/                                                         delF( tinP , psttPrefix ) ;
/*N1D*/                                                         TN( tNoteFile , psttPrefix ) ; tNoteFile += T("!.note.ttt") ;
/*N1D*/
/*N1D*/                                                         strSubstringF( tinP , psttPrefix , idf , idl , psttzFileName ) ; ___( psttPrefix ) ;
/*N1D*/                                                         countT idl = 0x1e ;
/*N1D*/                                                         countT idf = 1 ;
/*N1D*/                                                         ZE( strokeS* , psttPrefix ) ;
/*N1D*/                                                     {
/*N1D*/                                                     if( psttzFileName->idAdam > 0x1e  )
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         else if( !psttzShortThumbnail ) psttzShortThumbnail = psttc1 ;
/*N1D*/                                                         else if( !psttzCurrentName    ) psttzCurrentName    = psttc1 ;
/*N1D*/                                                              if( !psttzFileName       ) psttzFileName       = psttc1 ;  // EXAMPLE: "!ideafarm.0.foo.600x400.jpg"
/*N1D*/                                                     {
/*N1D*/                                                     FORsTRINGSiN1( pstt1NameTriple )
/*N1D*/                                                     ZE( strokeS* , psttzShortThumbnail ) ;
/*N1D*/                                                     ZE( strokeS* , psttzCurrentName ) ;
/*N1D*/                                                     ZE( strokeS* , psttzFileName ) ;
/*N1D*/
/*N1D*/                                                                                                                         // !ideafarm.9.2.00000000.00000001.20140328@2129.000b3858.2feac2f0.fa5b8bcb.voice.pad.!.140328_034.mp3
/*N1D*/                                                     soulFileNames >> pstt1NameTriple ; ___( pstt1NameTriple ) ;         // !ideafarm.8.2.00000000.00000001.20140328@2129.001.000b3858.2feac2f0.fa5b8bcb.voice.pad.!.140328_034.mp3
/*N1D*/                                                     ZE( strokeS* , pstt1NameTriple ) ;                                // |----------------------------|                                //           |-----p1------||--sss--||2|
/*N1D*/                                                 {                                                                   // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
/*N1D*/                                                 while( soulFileNames )                                              // 0              1               2               3               4               5               6
/*N1D*/                                             {
/*N1D*/                                             case ifcIDmODEsOILwALK_EDIT :
/*N1D*/                                             }
/*N1D*/                                                 break ;
/*N1D*/
/*N1D*/                                                 delF( tinP , psttu ) ;
/*N1D*/                                                 boxPutF( tinP , tMouth+T("report.")+TF3(idBoxMe,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(".")+T(psttu)+T(".soil") , tSoil , tSoil.csF( tinP ) ) ;
/*N1D*/
/*N1D*/                                                 countT idBoxMe = 1 + incv02AM( idBox ) ;
/*N1D*/                                                 static countT idBox ;
/*N1D*/
/*N1D*/                                                 ;
/*N1D*/                                                     : T("///ideafarm/IdeaFarm (tm)/")+tUser+T("/Drop a Copy of SOIL (tm) Text Here/")
/*N1D*/                                                     ? tJobQueueFolder
/*N1D*/                                                 TN( tMouth , "" ) ; tMouth = tJobQueueFolder.csF( tinP )
/*N1D*/
/*N1D*/                                                 TN( tSoil , postSoilForReport1 ) ; tSoil += ( tReportsFolder.csF(tinP) ? tReportsFolder : T("///ideafarm/tmp/reports/") )+T(postSoilForReport2)+( tNameSpace.csF(tinP) ? tNameSpace : T("[missing.namespace]") )+T(postSoilForReport3)+tFileInclude+T(postSoilForReport4) ;
/*N1D*/
/*N1D*/                                                 //ENABLE IN PRODUCTION; COMMENT OUT JUST WHEN DEBUGGING WOTH STAGE OF ARCHIVE REPORTING
/*N1D*/                                                 //U::BUG: SHOULD tUserOverride BE USED IN THE NEXT LINE?
/*N1D*/
/*N1D*/                                                 }
/*N1D*/                                                     }
/*N1D*/                                                         delF( tinP , postp ) ;
/*N1D*/
/*N1D*/                                                         fileWriteF( tinP , hFile1 , postp , costp ) ;
/*N1D*/
/*N1D*/                                                         delF( tinP , psttp ) ;
/*N1D*/                                                         countT costp = strMakeF( tinP , postp , psttp ) ; ___( postp ) ;
/*N1D*/                                                         ZE( osTextT* , postp ) ;
/*N1D*/
/*N1D*/                                                         soulrFileSets >> psttp ; ___( psttp ) ;
/*N1D*/                                                         ZE( strokeS* , psttp ) ;
/*N1D*/                                                     {
/*N1D*/                                                     while( soulrFileSets )
/*N1D*/
/*N1D*/                                                     fileOpenF( tinP , hFile1 , countTC() , tFileInclude , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
/*N1D*/                                                     tFileInclude = T("///ideafarm/tmp/ktr/rpt.archive.")+T(psttu)+T(".soii") ;
/*N1D*/                                                     //fileOpenF( tinP , hFile1 , countTC() , tDisk+T("tmp/ktr/rpt.archive.soii") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
/*N1D*/                                                     //fileOpenF( tinP , hFile1 , countTC() , T("///ideafarm/IdeaFarm (tm)/")+tUser+T("/Drop a Copy of SOIL (tm) Text Here/")+TT(timeN1,timeN2)+T(".soil") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
/*N1D*/                                                     //U::BUG: SHOULD tUserOverride BE USED IN THE NEXT LINE?
/*N1D*/                                                     handleC hFile1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
/*N1D*/                                                     //A:ASSUME: tmp/ktr IS ON THE SAME DRIVE AS HOME FOLDER
/*N1D*/
/*N1D*/                                                     osTimeNowF( tinP , timeN1 , timeN2 ) ;
/*N1D*/                                                     ZE( sCountT , timeN2 ) ;
/*N1D*/                                                     ZE( countT , timeN1 ) ;
/*N1D*/                                                 {
/*N1D*/                                                 if( soulrFileSets )
/*N1D*/                                                 TN( tFileInclude , "" ) ;
/*N1D*/
/*N1D*/                                                 strUniqueF( tinP , psttu ) ; ___( psttu ) ;
/*N1D*/                                                 ZE( strokeS* , psttu ) ;
/*N1D*/
/*N1D*/                                                 }
/*N1D*/                                                     delF( tinP , psttm ) ;
/*N1D*/                                                     }
/*N1D*/                                                         tDisk = T(postd) ;
/*N1D*/                                                         osTextT postd[] = { '/' , '/' , '/' , (osTextT)psttm[ CSpREFIX + 3 ].idAdam , '/' , 0 } ;
/*N1D*/                                                     {
/*N1D*/                                                     if( psttm && psttm->idAdam > 3 )
/*N1D*/                                                     diskMapFileNameF( tinP , psttm , T("///ideafarm/") ) ; ___( psttm ) ;
/*N1D*/                                                     ZE( strokeS* , psttm ) ;
/*N1D*/                                                 {
/*N1D*/                                                 TN( tDisk , "" ) ;
/*N1D*/
/*N1D*/                                                 strFuseF( tinP , soulrFileSets , T(postReportEpilog) ) ;
/*N1D*/
/*N1D*/                                                 }
/*N1D*/                                                     ) ;
/*N1D*/
/*N1D*/                                                         +esp.tcr
/*N1D*/                                                         +esp.tcr
/*N1D*/                                                         +esp.tcr
/*N1D*/                                                         +esp.tTocAfter
/*N1D*/                                                         )
/*N1D*/                                                                 : T("</td></tr><tr><td>Signs:  ")+esp.tp4Scrubbed+esp.tDaySignsFileName+esp.tDaySignsSuffix
/*N1D*/                                                                 ? esp.tn
/*N1D*/                                                             !esp.tDaySignsFileName.csF(tinP)
/*N1D*/                                                         (
/*N1D*/                                                         +
/*N1D*/                                                         )
/*N1D*/                                                                 : T("</td></tr><tr><td>Keywords:  ")+esp.tp4Scrubbed+esp.tDayKeywordsFileName+esp.tDayKeywordsSuffix
/*N1D*/                                                                 ? esp.tn
/*N1D*/                                                             !esp.tDayKeywordsFileName.csF(tinP)
/*N1D*/                                                         (
/*N1D*/                                                         +
/*N1D*/                                                         )
/*N1D*/                                                                 : T("</td></tr><tr><td>Narrative:  ")+esp.tp4Scrubbed+esp.tDayNarrativeFileName+esp.tDayNarrativeSuffix
/*N1D*/                                                                 ? esp.tn
/*N1D*/                                                             !esp.tDayNarrativeFileName.csF(tinP)
/*N1D*/                                                         (
/*N1D*/                                                         +
/*N1D*/                                                         +T("\\m")
/*N1D*/                                                         )
/*N1D*/                                                                 : esp.tcs+esp.tp4NotScrubbed+esp.tDayTitleFileName+esp.tDayTitleSuffix
/*N1D*/                                                                 ? esp.tn
/*N1D*/                                                             !esp.tDayTitleFileName.csF(tinP)
/*N1D*/                                                         (
/*N1D*/                                                         +
/*N1D*/                                                         +esp.tTodayLath
/*N1D*/                                                         +esp.tDayPrefix            // THIS ENDS WITH "\\m\\r", WHICH ENDS THE PREFIX OF THE BRANCH (THE BRANCH WILL CONSIST OF tTodayLath CONCATENATED WITH ": " FOLLOWED BY THE TITLE)
/*N1D*/                                                         +esp.tc
/*N1D*/                                                         //+esp.tSequenceLath
/*N1D*/                                                         //+sttDot
/*N1D*/                                                         //20180421@1406: SUPPRESSED SEQUENCE NUMBER WITHOUT ANALYSIS SO THAT THE LABEL IS SIMPLY THE DAYTIME
/*N1D*/                                                         //+esp.tTimeLath
/*N1D*/                                                         //+sttDot
/*N1d*/                                                         //20180424@1606: SUPPRESSED TIME WITHOUT ANALYSIS SO THAT THE LABEL IS SIMPLY THE DAY
/*N1D*/                                                         +esp.tTodayLath
/*N1D*/                                                         esp.tc
/*N1D*/                                                         //CS:CODEsYNC: PSEUDODUPLICATE CODE: 360021c1 360021c1
/*N1D*/
/*N1D*/                                                     strFuseF( tinP , soulrFileSets ,
/*N1D*/                                                     strokeS sttDot( '.' ) ;
/*N1D*/                                                 {
/*N1D*/                                                 if( esp.tTodayLath.csF( tinP ) )
/*N1D*/
/*N1D*/                                                 }
/*N1D*/                                                     }
/*N1D*/                                                         fileWriteF( tinP , hFile , soulIdFragCloud ) ;
/*N1D*/                                                         fileOpenF( tinP , hFile , countTC() , T("///ideafarm/tmp/link.frag.note.soul.not.html") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
/*N1D*/                                                         //U::THIS IS NOT THREAD SAFE ; THE OUTPUT FILE IS INTENDED TO BE PROCESSED BY THE REPORT JOB THAT I WILL LAUNCH
/*N1D*/                                                         handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
/*N1D*/                                                         TN( tFolderFile , "" ) ; tFolderFile = tFolder+tFile ;
/*N1D*/
/*N1D*/                                                         traceF( tinP , T("writing tmp file for pickup by subsequent soil job.  *** NOT THREAD SAFE ***") ) ; //U:: UNIQUIFY TO MAKE THREAD SAFE
/*N1D*/
/*N1D*/                                                         }
/*N1D*/                                                             delF( tinP , pbNote ) ;
/*N1D*/                                                             }
/*N1D*/                                                                 //traceF( tinP , T(" [note]: ")+T(pbNote) ) ;
/*N1D*/                                                             {
/*N1D*/                                                             else
/*N1D*/                                                             }
/*N1D*/                                                                 traceF( tinP , T(" length of note is 0 [box]: ")+tBoxCloud ) ;
/*N1D*/                                                                 POOPR
/*N1D*/                                                             {
/*N1D*/                                                             else if( !*pbNote )
/*N1D*/                                                             }
/*N1D*/                                                                 traceF( tinP , T(" could not obtain note from cloud [box]: ")+tBoxCloud ) ;
/*N1D*/                                                                 POOPR
/*N1D*/                                                             {
/*N1D*/                                                             if( POOP || !pbNote )
/*N1D*/                                                             tinP.pEtScratch->boxGetShadowF( tinP , pbNote , cbNote , tBoxCloud ) ; ___( pbNote ) ;
/*N1D*/                                                             ZE( countT , cbNote ) ;
/*N1D*/                                                             ZE( byteT* , pbNote ) ;
/*N1D*/
/*N1D*/                                                             //traceF( tinP , T("[cloud]: ")+tBoxCloud ) ;
/*N1D*/                                                             //traceF( tinP , T(" [frag]: ")+tIdFrag ) ;
/*N1D*/                                                             soulIdFragCloud << (strokeS*)tBoxCloud ;
/*N1D*/                                                             soulIdFragCloud << (strokeS*)tIdFrag ;
/*N1D*/
/*N1D*/                                                             }
/*N1D*/                                                                 delF( tinP , psttp ) ;
/*N1D*/                                                                 tBoxCloud = T(psttzCloud)+T(psttp) ;
/*N1D*/                                                                 soulIdFragShort >> psttp ; ___( psttp ) ;
/*N1D*/
/*N1D*/                                                                 delF( tinP , psttp ) ;
/*N1D*/                                                                 tIdFrag = T(psttp) ;
/*N1D*/                                                                 soulIdFragShort >> psttp ; ___( psttp ) ;
/*N1D*/
/*N1D*/                                                                 ZE( strokeS* , psttp ) ;
/*N1D*/                                        
/*N1D*/                                                                 if( !psttzCloud ) psttzCloud = tCloudDefault ;
/*N1D*/                                                                 strokeS* psttzCloud = (strokeS*)(countT)swCloud ;
/*N1D*/                                                                 psttzLeverLocalFolder = tArchive ;
/*N1D*/                                                             {
/*N1D*/                                                             TN( tBoxCloud , "" ) ;
/*N1D*/                                                             TN( tIdFrag , "" ) ;
/*N1D*/                                                         {
/*N1D*/                                                         while( soulIdFragShort ) //U::EMIT [idFrag,boxCloud] PAIRS TO ROOT OF HTML OUTPUT
/*N1D*/                                                         TN( tCloudDefault , "[error: unknown location in cloud]/" ) ;
/*N1D*/                                                         soulC soulIdFragCloud( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/
/*N1D*/                                                         SCOOPS
/*N1D*/                                                     {
/*N1D*/                                                     IFsCRATCH
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         }
/*N1D*/                                                             traceF( tinP , T("cloudview [local,remote]:    \"")+T(psttzLeverLocalFolder)+T("\"    \"")+T(psttr)+T("\"") ) ;
/*N1D*/                                                             strokeS* psttr = (strokeS*)(countT)swCloud ;
/*N1D*/                                                             psttzLeverLocalFolder = (strokeS*)swCloud.leverF( tinP , idf ) ;
/*N1D*/                                                         {
/*N1D*/                                                         for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
/*N1D*/                                                         countT cFlavors = swCloud.cFlavorsF( tinP ) ;
/*N1D*/                                                     {
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         }
/*N1D*/                                                             delF( tinP , psttRemote      ) ;
/*N1D*/                                                             delF( tinP , psttLocal       ) ;
/*N1D*/                                                             delF( tinP , psttLocalMapped ) ;
/*N1D*/                                                             }
/*N1D*/                                                                                    psttRemote = 0 ;
/*N1D*/                                                                 psttRemoteFolder = psttRemote ;
/*N1D*/                                                                 delF( tinP , psttRemoteFolder ) ;
/*N1D*/                                                                 strokeS*& psttRemoteFolder = *(strokeS**)&(countT&)swCloud ;
/*N1D*/
/*N1D*/                                                                 psttzLeverLocalFolder = psttLocalMapped ;
/*N1D*/                                                             {
/*N1D*/                                                             if( psttLocalMapped && psttRemote )
/*N1D*/
/*N1D*/                                                             diskMapFileNameF( tinP , psttLocalMapped , psttLocal ) ; ___( psttLocalMapped ) ;
/*N1D*/                                                             ZE( strokeS* , psttLocalMapped ) ;
/*N1D*/
/*N1D*/                                                             GETsETTING( *this , psttRemote , T("!cloudview.")+T(psttzLeverCloud)+T(".remote") )
/*N1D*/                                                             GETsETTING( *this , psttLocal  , T("!cloudview.")+T(psttzLeverCloud)+T(".local" ) )
/*N1D*/
/*N1D*/                                                             psttzLeverCloud = (strokeS*)swsSettings.leverF( tinP , idf ) ;
/*N1D*/                                                         {
/*N1D*/                                                         for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
/*N1D*/                                                         countT cFlavors = swsSettings.cFlavorsF( tinP ) ;
/*N1D*/
/*N1D*/                                                         walkSettingsF( tinP , pbBuffer , sizeof pbBuffer , countTC() , walkCloudViewSettingsCBF , pcArg ) ;
/*N1D*/                                                         countT pcArg[] = { 0 , (countT)&psttzLeverCloud , (countT)&swsSettings } ;
/*N1D*/
/*N1D*/                                                         switchStackC swsSettings( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverCloud , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
/*N1D*/                                                         ZE( strokeS* , psttzLeverCloud ) ;
/*N1D*/                                                     {
/*N1D*/                                                     if( soulIdFragShort )
/*N1D*/                                                     switchC swCloud( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverLocalFolder ) ;
/*N1D*/                                                     ZE( strokeS* , psttzLeverLocalFolder ) ;
/*N1D*/                                                 {
/*N1D*/
/*N1D*/                                                 delF( tinP , psttCurrentNameLag ) ;
/*N1D*/                                                 if( tSet.csF( tinP ) ) emitSetF( tinP , *this , soulrFileSets , soulIdFragShort , tSet , stSet , esp , psttCurrentNameLag ) ;
/*N1D*/
/*N1D*/                                                 }
/*N1D*/                                                     delF( tinP , psttp1Lag ) ;
/*N1D*/                                                     }
/*N1D*/                                                         delF( tinP , pstt1NameTriple ) ;
/*N1D*/                                                         delF( tinP , psttShortThumbnail ) ;
/*N1D*/                                                         delF( tinP , psttFileName ) ;
/*N1D*/                                                         strMakeF( tinP , psttCurrentNameLag , psttzCurrentName ) ; ___( psttCurrentNameLag ) ;
/*N1D*/                                                         delF( tinP , psttCurrentNameLag ) ;
/*N1D*/                                                         }
/*N1D*/                                                             if( psttShortThumbnail ) { stSet << psttShortThumbnail ; psttShortThumbnail = 0 ; }
/*N1D*/                                                                                        stSet << psttFileName       ; psttFileName       = 0 ;
/*N1D*/
/*N1D*/                                                             ;
/*N1D*/                                                                 : T(psttzFileName)
/*N1D*/                                                                 ? T(psttzFileName)+T(",")+T(psttShortThumbnail)
/*N1D*/                                                             tSet = psttShortThumbnail
/*N1D*/
/*N1D*/                                                             /**/if( bTrace ) traceF( tinP , T("  stSet << [set     ]: ")+T(psttzFileName) ) ;
/*N1D*/
/*N1D*/                                                             delF( tinP , psttp1 ) ;
/*N1D*/
/*N1D*/                                                             }
/*N1D*/                                                                 emitSetF( tinP , *this , soulrFileSets , soulIdFragShort , tSet , stSet , esp , psttCurrentNameLag ) ;
/*N1D*/
/*N1D*/                                                                 }
/*N1D*/                                                                     delF( tinP , psttw ) ;
/*N1D*/
/*N1D*/                                                                     if( !strCompareF( tinP , psttw , esp.psttTestNote ) ) esp.tNoteFileName = T(psttzFileName) ;
/*N1D*/
/*N1D*/                                                                     strSubstringF( tinP , psttw , idf , idl , psttzFileName ) ; ___( psttw ) ;
/*N1D*/                                                                     countT idl = 0x25 ;
/*N1D*/                                                                     countT idf = 0x1e ;
/*N1D*/                                                                     ZE( strokeS* , psttw ) ;
/*N1D*/                                                                 {
/*N1D*/                                                                 if( psttzFileName->idAdam >= 0x28 && psttzFileName[ CSpREFIX - 1 + 0x1f ] == strokeS( '!' ) ) 
/*N1D*/                                                                 //CS:CODEsYNC: DUPLICATE CODE: 360021c1 360021c1
/*N1D*/
/*N1D*/                                                                 // !ideafarm.9.2.00000000.00000001.20140328@0556.!.note.optionalHtmlFragLabel.ttt
/*N1D*/                                                                 // !ideafarm.8.2.00000000.00000001.20140328@0556.001.!.note.optionalHtmlFragLabel.ttt
/*N1D*/                                                                 // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
/*N1D*/                                                                 // 0              1               2               3               4
/*N1D*/
/*N1D*/                                                                 strMakeF( tinP , psttp1Lag , psttp1 ) ; ___( psttp1Lag ) ;
/*N1D*/                                                                 delF( tinP , psttp1Lag ) ;
/*N1D*/                                                             {
/*N1D*/                                                             if( strCompareF( tinP , psttp1 , psttp1Lag ) || strIdF( tinP , T(".!.control.") , psttzFileName ) )
/*N1D*/
/*N1D*/                                                             if( !psttp1Lag ) { strMakeF( tinP , psttp1Lag , psttp1 ) ; ___( psttp1Lag ) ; }
/*N1D*/
/*N1D*/                                                             strSubstringF( tinP , psttp1 , idf , idl , psttzFileName ) ; ___( psttp1 ) ;
/*N1D*/                                                             countT idl = idBeforeLathDot ;
/*N1D*/                                                             countT idf = 1 ;
/*N1D*/                                                             ZE( strokeS* , psttp1 ) ;
/*N1D*/
/*N1D*/                                                             if( idBeforeLathDot ) idBeforeLathDot -- ;
/*N1D*/                                                             countT idBeforeLathDot = strIdF( tinP , sttDot , psttzFileName , - 1 ) ;
/*N1D*/                                                         {
/*N1D*/                                                         else
/*N1D*/                                                         }
/*N1D*/                                                             if( psttShortThumbnail ) { stSet << psttShortThumbnail ; psttShortThumbnail = 0 ; }
/*N1D*/                                                                                        stSet << psttFileName       ; psttFileName       = 0 ;
/*N1D*/
/*N1D*/                                                             ///**/if( bTrace ) traceF( tinP , T("stSet << [set,file]:    \"")+tSet+T("\"    \"")+T(psttzFileName)+T("\"") ) ;
/*N1D*/
/*N1D*/                                                             delF( tinP , psttp2 ) ;
/*N1D*/                                                             delF( tinP , psttp1 ) ;
/*N1D*/                                                             tSet = T(psttp1)+sttDot+T(psttp2) ;
/*N1D*/
/*N1D*/                                                             strSubstringF( tinP , psttp2 , idf , idl , psttzFileName ) ; ___( psttp2 ) ;
/*N1D*/                                                             idl = 0 ;
/*N1D*/                                                             idf = idAfter ;
/*N1D*/                                                             ZE( strokeS* , psttp2 ) ;
/*N1D*/
/*N1D*/                                                             }
/*N1D*/                                                                 emitSetF( tinP , *this , soulrFileSets , soulIdFragShort , tSet , stSet , esp , psttCurrentNameLag ) ;
/*N1D*/
/*N1D*/                                                                 }
/*N1D*/                                                                     delF( tinP , psttw ) ;
/*N1D*/
/*N1D*/                                                                     if( !strCompareF( tinP , psttw , esp.psttTestNote ) ) esp.tNoteFileName = T(psttzFileName) ;
/*N1D*/
/*N1D*/                                                                     strSubstringF( tinP , psttw , idf , idl , psttzFileName ) ; ___( psttw ) ;
/*N1D*/                                                                     countT idl = 0x25 ;
/*N1D*/                                                                     countT idf = 0x1e ;
/*N1D*/                                                                     ZE( strokeS* , psttw ) ;
/*N1D*/                                                                 {
/*N1D*/                                                                 if( psttzFileName->idAdam >= 0x28 && psttzFileName[ CSpREFIX - 1 + 0x1f ] == strokeS( '!' ) ) 
/*N1D*/                                                                 //CS:CODEsYNC: DUPLICATE CODE: 360021c1 360021c1
/*N1D*/
/*N1D*/                                                                 // !ideafarm.9.2.00000000.00000001.20140328@0556.!.note.optionalHtmlFragLabel.ttt
/*N1D*/                                                                 // !ideafarm.8.2.00000000.00000001.20140328@0556.001.!.note.optionalHtmlFragLabel.ttt
/*N1D*/                                                                 // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
/*N1D*/                                                                 // 0              1               2               3               4
/*N1D*/
/*N1D*/                                                                 strMakeF( tinP , psttp1Lag , psttp1 ) ; ___( psttp1Lag ) ;
/*N1D*/                                                                 delF( tinP , psttp1Lag ) ;
/*N1D*/                                                             {
/*N1D*/                                                             if( strCompareF( tinP , psttp1 , psttp1Lag ) || strIdF( tinP , T(".!.control.") , psttzFileName ) )
/*N1D*/
/*N1D*/                                                             if( !psttp1Lag ) { strMakeF( tinP , psttp1Lag , psttp1 ) ; ___( psttp1Lag ) ; }
/*N1D*/
/*N1D*/                                                             strSubstringF( tinP , psttp1 , idf , idl , psttzFileName ) ; ___( psttp1 ) ;
/*N1D*/                                                             ZE( strokeS* , psttp1 ) ;
/*N1D*/
/*N1D*/                                                             countT idl = idHit - 1 ;
/*N1D*/                                                             idf = 1 ;
/*N1D*/                                                             countT idAfter = idf ;
/*N1D*/                                                         {
/*N1D*/                                                         if( idHit > 1 && idf && idf == psttzFileName->idAdam - 2 )
/*N1D*/                                                         countT idHit = strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tSssDim , psttzFileName , 0 , -1 ) ;
/*N1D*/                                                         countT idf = 1 ;
/*N1D*/
/*N1D*/                                                         }
/*N1D*/                                                             if( bTrace && !( cRemain % ( TUCK << 0 ) ) ) traceF( tinP , T("etherSoilF / tKeyReport / loading swsFileNameSet and ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" files remain") ) ;
/*N1D*/                                                             countT cRemain = soulFileNames ;
/*N1D*/                                                         {
/*N1D*/
/*N1D*/                                                         if( (countT)psttzFileName < TUCK ) { BLAMMO ; } //U::TO FIND A BUG
/*N1D*/
/*N1D*/                                                         ///**/if( bTrace ) traceF( tinP , T("soulFileNames >> [file]: ")+T(psttzFileName) ) ;
/*N1D*/                                                                            traceF( tinP , T("soulFileNames >> [file]: ")+T(psttzFileName) ) ;
/*N1D*/
/*N1D*/                                                         if( psttzShortThumbnail ) { strMakeF( tinP , psttShortThumbnail , psttzShortThumbnail ) ; ___( psttShortThumbnail ) ; }
/*N1D*/                                                         ZE( strokeS* , psttShortThumbnail ) ;
/*N1D*/
/*N1D*/                                                         strMakeF( tinP , psttFileName , psttzFileName ) ; ___( psttFileName ) ;
/*N1D*/                                                         ZE( strokeS* , psttFileName ) ;
/*N1D*/
/*N1D*/                                                         }
/*N1D*/                                                             else if( !psttzShortThumbnail ) psttzShortThumbnail = psttc1 ;
/*N1D*/                                                             else if( !psttzCurrentName    ) psttzCurrentName    = psttc1 ;
/*N1D*/                                                                  if( !psttzFileName       ) psttzFileName       = psttc1 ;  // EXAMPLE: "!ideafarm.0.foo.600x400.jpg"
/*N1D*/                                                         {
/*N1D*/                                                         FORsTRINGSiN1( pstt1NameTriple )
/*N1D*/                                                         ZE( strokeS* , psttzShortThumbnail ) ;
/*N1D*/                                                         ZE( strokeS* , psttzCurrentName ) ;
/*N1D*/                                                         ZE( strokeS* , psttzFileName ) ;
/*N1D*/
/*N1D*/                                                         soulFileNames >> pstt1NameTriple ; ___( pstt1NameTriple ) ;         // EXAMPLE: "!ideafarm.0.foo.600x400.jpg"
/*N1D*/                                                         ZE( strokeS* , pstt1NameTriple ) ;                                //           |-----p1------||--sss--||2|
/*N1D*/                                                     {                                                                   // idf:                              ^
/*N1D*/                                                     while( soulFileNames )                                              // idHit:                   ^
/*N1D*/                                                     ///**/if( bTrace ) traceF( tinP , T("etherSoilF / tKeyReport / beginning to load swsFileNameSet and there are ")+TF2(soulFileNames,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" files") ) ;
/*N1D*/                                                     ZE( strokeS* , psttp1Lag ) ;
/*N1D*/                                                     strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
/*N1D*/                                                     strokeS sttDot( '.' ) ;
/*N1D*/                                                     //LOGrAW( T("\r\n**** PROCESSING FILE SETS ****\r\n") ) ;
/*N1D*/
/*N1D*/                                                     ;
/*N1D*/                                                                 
/*N1D*/                                                         +S2(sa_SSSaNDeND,sc_ccSSS)
/*N1D*/                                                             +T(".")
/*N1D*/
/*N1D*/                                                             //+S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
/*N1D*/                                                             //+S3(0,sc_ccSSSrEPEAT,7)
/*N1D*/                                                             //               NEW FORMAT: ".0600x."
/*N1D*/                                                             //20141017@2254: OLD FORMAT: ".0600x0400."  
/*N1D*/
/*N1D*/                                                             +T("x")
/*N1D*/                                                             +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)     // 20141017@2254: ALL DIMENSIONED FILES IN THE ARCHIVE USE EXACTLY 4 DIGITS, E.G. FILE NAME ENDS WITH ".0600x.jpg"
/*N1D*/                                                             +S3(0,sc_ccSSSrEPEAT,7)                 // DOES NOT ENFORCE MIN NUMBER OF DIGITS: 4 ; THE MINIMUM 4 CONVENTION IS "GOOD STYLE" TO PROMOTE READABILITY AND SORTABILITY
/*N1D*/                                                             +T(".")
/*N1D*/                                                         +S2(sa_SSSaND,sc_ccSSS)
/*N1D*/                                                         T("")
/*N1D*/
/*N1D*/                                                     TN( tSssDim , "" ) ; tSssDim =           // ".12345678x12345678."
/*N1D*/                                                 {
/*N1D*/                                                 soulC soulIdFragShort( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/                                                 ZE( strokeS* , psttCurrentNameLag ) ;
/*N1D*/
/*N1D*/                                                 strFuseF( tinP , soulrFileSets , T(postReportProlog) ) ;
/*N1D*/                                                 soulC        soulrFileSets( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.r.file.sets" ) ;
/*N1D*/                                                 emitSetParmS esp( tinP , *this , stFileType , bTrace , tArchive ) ;
/*N1D*/                                                 stackC       stSet( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
/*N1D*/                                                 TN( tSet , "" ) ;
/*N1D*/
/*N1D*/                                                 //|   
/*N1D*/                                                 //       [**__END__**]
/*N1D*/                                                 //        {preIncludeScrub1: \"///ideafarm/IdeaFarm (tm)/SYSTEM/Drop Files Here To"" Archive/<noteFile>\" }
/*N1D*/                                                 //       [**__P3__**]<time>: <title>
/*N1D*/                                                 //       [**__BEGIN__**]\a<file>\a[**__P1__**]
/*N1D*/                                                 //    
/*N1D*/                                                 //|   
/*N1D*/                                                 //       [**__END__**]
/*N1D*/                                                 //        {preIncludeScrub1: \"///ideafarm/IdeaFarm (tm)/SYSTEM/Drop Files Here To"" Archive/<noteFile>\" }
/*N1D*/                                                 //       [**__P3__**]<time>: <title>
/*N1D*/                                                 //       [**__BEGIN__**]\a<file>\a[**__P1__**]
/*N1D*/                                                 //    
/*N1D*/                                                 //      20131220
/*N1D*/                                                 //|   
/*N1D*/                                                 //       [**__END__**]
/*N1D*/                                                 //        {preIncludeScrub1: \"///ideafarm/IdeaFarm (tm)/SYSTEM/Drop Files Here To"" Archive/<noteFile>\" }
/*N1D*/                                                 //       [**__P3__**]<time>: <title>
/*N1D*/                                                 //       [**__BEGIN__**]\a<file>\a[**__P1__**]
/*N1D*/                                                 //    
/*N1D*/                                                 //|   
/*N1D*/                                                 //       [**__END__**]
/*N1D*/                                                 //        {preIncludeScrub1: \"///ideafarm/IdeaFarm (tm)/SYSTEM/Drop Files Here To"" Archive/<noteFile>\" }
/*N1D*/                                                 //       [**__P3__**]<time>: <title>
/*N1D*/                                                 //       [**__BEGIN__**]\a<file>\a[**__P1__**]
/*N1D*/                                                 //
/*N1D*/                                                 // FOR EACH FILE (AND ASSOCIATED NOTE FILE IF ANY), TEXT LIKE THIS IS EMITTED AFTER EMITTING A BLANK LEADING LINE:
/*N1D*/
/*N1D*/                                                 /**/if( bTrace ) traceF( tinP , T("etherSoilF / tKeyReport / setting up") ) ;
/*N1D*/                                             {
/*N1D*/                                             case ifcIDmODEsOILwALK_REPORT :
/*N1D*/                                         {
/*N1D*/                                         switch( idModeWalk )
/*N1D*/
/*N1D*/                                         }
/*N1D*/                                             if( POOP ) POOPR ;
/*N1D*/                                             tinP.pEtScratch->diskWalkF( tinP , cDirs , cFiles , tArchive , bQuit , flDISKwALK_null , etherSoilWalkCBF , pcArg ) ; // WILL FAIL IF tUserOverride CONTAINS DOUBLE QUOTE MARKS OR OTHER STROKES THAT MAKE THE PATH NAME INVALID
/*N1D*/                                             SCOOPS
/*N1D*/                                         {
/*N1D*/                                         IFsCRATCH
/*N1D*/
/*N1D*/                                         /**/if( bTrace ) traceF( tinP , T("etherSoilF / tKeyReport / loading soulFileNames from [tArchive]: ")+tArchive ) ;
/*N1D*/                                         ZE( boolT , bQuit ) ;
/*N1D*/                                         ZE( countT , cFiles ) ;
/*N1D*/                                         ZE( countT , cDirs ) ;
/*N1D*/
/*N1D*/                                         countT pcArg[] = { (countT)this , (countT)&stTimeMinMax , (countT)&soulFileNames , idModeWalk , (countT)(strokeS*)tPrefix , (countT)(strokeS*)tConfidential , (countT)(strokeS*)tPrivate , (countT)(strokeS*)tPhone , (countT)(strokeS*)tVideophone , (countT)(strokeS*)tExtMp3 } ;
/*N1D*/                                         soulC soulFileNames( tinP , TAG( TAGiDnULL )             , ( idModeWalk == ifcIDmODEsOILwALK_ZIP || idModeWalk ==  ifcIDmODEsOILwALK_INSPECTfILEnAMES ) ? flSOUL_null                                             : flSOUL_LIFO , "soul.file.names"         ) ;
/*N1D*/
/*N1D*/                                         TN( tExtMp3       , ".mp3"          ) ;
/*N1D*/                                         TN( tVideophone   , "!videophone"   ) ;
/*N1D*/                                         TN( tPhone        , "!phone"        ) ;
/*N1D*/                                         TN( tPrivate      , "!private"      ) ;
/*N1D*/                                         TN( tConfidential , "!confidential" ) ;
/*N1D*/                                         TN( tPrefix       , "!ideafarm.9.2.00000000.00000001."  ) ;
/*N1D*/                                     {
/*N1D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N1D*/                                 {
/*N1D*/                                 switch( idModeP )
/*N1D*/
/*N1D*/                                 ;
/*N1D*/                                                 : 0
/*N1D*/                                                 ? ifcIDmODEsOILwALK_INSPECTfILEnAMES
/*N1D*/                                             : tKeyLevel1 == tKeyInspectFileNames
/*N1D*/                                             ? ifcIDmODEsOILwALK_ZIP
/*N1D*/                                         : tKeyLevel1 == tKeyZip
/*N1D*/                                         ? ifcIDmODEsOILwALK_EDIT
/*N1D*/                                     : tKeyLevel1 == tKeyEdit
/*N1D*/                                     ? ifcIDmODEsOILwALK_REPORT
/*N1D*/                                 boolT idModeWalk = tKeyLevel1 == tKeyReport
/*N1D*/                             {
/*N1D*/                             else if( tKeyLevel1 == tKeyEdit || tKeyLevel1 == tKeyReport || tKeyLevel1 == tKeyZip || tKeyLevel1 == tKeyInspectFileNames )
/*N1D*/                             }
/*N1D*/                                 }
/*N1D*/                                     }
/*N1D*/                                         break ;
/*N1D*/
/*N1D*/                                         tFolderTo = tn ;
/*N1D*/                                         tFolderFrom = tn ;
/*N1D*/                                         }
/*N1D*/                                             }
/*N1D*/                                                 delF( tinP , pstt1f ) ;
/*N1D*/                                                 }
/*N1D*/                                                     }
/*N1D*/                                                         traceF( tinP , T("reassembled: ")+tLongData ) ;
/*N1D*/                                                         delF( tinP , pstt1fp ) ;
/*N1D*/                                                         }
/*N1D*/                                                             delF( tinP , posti ) ;
/*N1D*/                                                             fileWriteF( tinP , foData , posti , costi ) ;
/*N1D*/                                                             boxGetShadowF( tinP , posti , costi , psttc3 ) ; ___( posti ) ;
/*N1D*/                                                             ZE( countT , costi ) ;
/*N1D*/                                                             ZE( byteT* , posti ) ;
/*N1D*/
/*N1D*/                                                             traceF( tinP , T("reading part: ")+T(psttc3) ) ;
/*N1D*/                                                         {
/*N1D*/                                                         FORsTRINGSiN3( pstt1fp )
/*N1D*/                                                         diskFindFileOrDirF( tinP , pstt1fp , fnLike.pathF() , &pat ) ; ___( pstt1fp ) ;
/*N1D*/                                                         ZE( strokeS* , pstt1fp ) ;
/*N1D*/                                                                
/*N1D*/                                                         patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                         fileNameC fnLike( tinP , *this , tFolderFrom+tShortNoSuffix+T("meta.part.*") ) ;
/*N1D*/
/*N1D*/                                                         fileC foData( tinP , (strokeS*)tLongData , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
/*N1D*/                                                         traceF( tinP , T("i have all parts needed to reassemble ")+tLongData ) ;
/*N1D*/                                                         TN( tLongData , "" ) ; tLongData = tFolderTo+tShortNoSuffix+tData ;
/*N1D*/                                                     {
/*N1D*/                                                     if( bOk )
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         if( idPartLath != numParts ) bOk = 0 ;
/*N1D*/
/*N1D*/                                                         delF( tinP , pstt1fp ) ;
/*N1D*/                                                         }
/*N1D*/                                                             }
/*N1D*/                                                                 break ;
/*N1D*/                                                                 bOk = 0 ;
/*N1D*/                                                             {
/*N1D*/                                                             if( ++ idPartLath != idPart )
/*N1D*/
/*N1D*/                                                             }
/*N1D*/                                                                 delF( tinP , psttNU ) ;
/*N1D*/                                                                 delF( tinP , psttIdPart ) ;
/*N1D*/                                                                 idPart = strDigitsToSCountF( tinP , psttIdPart , 0 , 1 ) ;
/*N1D*/                                                                 ___( psttNU ) ;
/*N1D*/                                                                 ___( psttIdPart ) ;
/*N1D*/                                                                 strBisectF( tinP , psttNU , psttIdPart , psttc2 , T(".") , - 1 ) ;
/*N1D*/                                                                 ZE( strokeS* , psttIdPart ) ;
/*N1D*/                                                                 ZE( strokeS* , psttNU ) ;
/*N1D*/                                                             {
/*N1D*/                                                             ZE( countT , idPart ) ;
/*N1D*/                                                             traceF( tinP , T("part: ")+T(psttc2) ) ;
/*N1D*/                                                         {
/*N1D*/                                                         FORsTRINGSiN2( pstt1fp )
/*N1D*/                                                         diskFindFileOrDirF( tinP , pstt1fp , fnLike.pathF() , &pat ) ; ___( pstt1fp ) ;
/*N1D*/                                                         ZE( strokeS* , pstt1fp ) ;
/*N1D*/                                                                
/*N1D*/                                                         patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                         fileNameC fnLike( tinP , *this , tFolderFrom+tShortNoSuffix+T("meta.part.*") ) ;
/*N1D*/                                                     {
/*N1D*/                                                     ZE( countT , idPartLath ) ;
/*N1D*/                                                     boolT bOk = 1 ;
/*N1D*/
/*N1D*/                                                     traceF( tinP , T("numParts: ")+TF2(numParts,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N1D*/                                                     }
/*N1D*/                                                         delF( tinP , psttNU ) ;
/*N1D*/                                                         delF( tinP , psttNumParts ) ;
/*N1D*/                                                         numParts = strDigitsToSCountF( tinP , psttNumParts , 0 , 1 ) ;
/*N1D*/                                                         ___( psttNU ) ;
/*N1D*/                                                         ___( psttNumParts ) ;
/*N1D*/                                                         strBisectF( tinP , psttNU , psttNumParts , tSuffix , T(".") , - 1 ) ;
/*N1D*/                                                         ZE( strokeS* , psttNumParts ) ;
/*N1D*/                                                         ZE( strokeS* , psttNU ) ;
/*N1D*/                                                     {
/*N1D*/                                                     ZE( countT , numParts ) ;
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         delF( tinP , psttShortNoSuffix ) ;
/*N1D*/                                                         delF( tinP , psttSuffix ) ;
/*N1D*/                                                         tSuffix = T(psttSuffix) ;
/*N1D*/                                                         tShortNoSuffix = T(psttShortNoSuffix) ;
/*N1D*/                                                         ___( psttShortNoSuffix ) ;
/*N1D*/                                                         ___( psttSuffix ) ;
/*N1D*/                                                         strBisectF( tinP , psttShortNoSuffix , psttSuffix , tShort , T(".") , - 3 , flSTRbISECT_APPENDdELIMITER ) ;
/*N1D*/                                                         ZE( strokeS* , psttSuffix ) ;
/*N1D*/                                                         ZE( strokeS* , psttShortNoSuffix ) ;
/*N1D*/                                                     {
/*N1D*/                                                     TN( tSuffix , "" ) ;
/*N1D*/                                                     TN( tShortNoSuffix , "" ) ;
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         delF( tinP , psttShort ) ;
/*N1D*/                                                         delF( tinP , psttPath ) ;
/*N1D*/                                                         tShort = T(psttShort) ;
/*N1D*/                                                         __( strCompareF( tinP , psttPath ,tFolderFrom ) ) ;
/*N1D*/                                                         ___( psttShort ) ;
/*N1D*/                                                         ___( psttPath ) ;
/*N1D*/                                                         strBisectF( tinP , psttPath , psttShort , psttc1 , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
/*N1D*/                                                         ZE( strokeS* , psttShort ) ;
/*N1D*/                                                         ZE( strokeS* , psttPath ) ;
/*N1D*/                                                     {
/*N1D*/                                                     TN( tShort , "" ) ;
/*N1D*/
/*N1D*/                                                     traceF( tinP , T("join / *.meta.numparts.*: ")+T(psttc1) ) ;
/*N1D*/                                                 {
/*N1D*/                                                 FORsTRINGSiN1( pstt1f )
/*N1D*/                                                 diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat ) ; ___( pstt1f ) ;
/*N1D*/                                                 ZE( strokeS* , pstt1f ) ;
/*N1D*/                                                 TN( tData , "data" ) ;
/*N1D*/                                                        
/*N1D*/                                                 patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                 fileNameC fnLike( tinP , *this , tFolderFrom+T("*.meta.numparts.*") ) ;
/*N1D*/                                             {
/*N1D*/
/*N1D*/                                             diskMakeDirF( tinP , tFolderTo ) ;
/*N1D*/                                             diskMakeDirF( tinP , tFolderFrom ) ;
/*N1D*/
/*N1D*/                                             traceF( tinP , T("joining all *.meta.part.* files in ")+tFolderFrom+T(" into *.data files placed into ")+tFolderTo ) ;
/*N1D*/
/*N1D*/                                             if( !tFolderTo.csF( tinP) ) tFolderTo = tFolderFrom ;
/*N1D*/                                         {
/*N1D*/                                         if( tFolderFrom.csF( tinP ) )
/*N1D*/                                     {
/*N1D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N1D*/                                 {
/*N1D*/                                 switch( idModeP )
/*N1D*/                             {
/*N1D*/                             else if( tKeyLevel1 == tKeyJoin )
/*N1D*/                             }
/*N1D*/                                 }
/*N1D*/                                     }
/*N1D*/                                         break ;
/*N1D*/
/*N1D*/                                         sizeBytes = 0 ;
/*N1D*/                                         tFolderTo = tn ;
/*N1D*/                                         tFolderFrom = tn ;
/*N1D*/                                         }
/*N1D*/                                             }
/*N1D*/                                                 while( !etherC::etPrimeIF( tinP ) && ~hFind ) ;
/*N1D*/                                                 }
/*N1D*/                                                     DEL( pInfo ) ;
/*N1D*/                                                     }
/*N1D*/                                                         fileC foTally( tinP , (strokeS*)( tFolderTo+tShortNoSuffix+T("meta.numparts.")+TF3(idPartLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
/*N1D*/
/*N1D*/                                                         __NZ( pFo ) ;
/*N1D*/                                                         }
/*N1D*/                                                             if( !cbOutRemainPart ) DEL( pFo ) ;
/*N1D*/
/*N1D*/                                                             delF( tinP , pbChunk ) ;
/*N1D*/                                                             }
/*N1D*/                                                                 }
/*N1D*/                                                                     if( cbInRemain > save ) cbInRemainHigh -- ;
/*N1D*/
/*N1D*/                                                                                   cbInRemain -= cbChunk ;
/*N1D*/                                                                     countT save = cbInRemain ;
/*N1D*/                                                                 {
/*N1D*/                                                                 else
/*N1D*/                                                                 if( !cbInRemainHigh ) cbInRemain -= cbChunk ;
/*N1D*/
/*N1D*/                                                                 cbOutRemainPart -= cbChunk ;
/*N1D*/
/*N1D*/                                                                 fileWriteF( tinP , *pFo , pbChunk , cbChunk      ) ;
/*N1D*/                                                                 fileReadF(  tinP        , pbChunk , cbChunk , fi ) ;
/*N1D*/                                                             {
/*N1D*/                                                             if( !POOP )
/*N1D*/
/*N1D*/                                                             __Z( pbChunk ) ;
/*N1D*/                                                             newF( tinP , LF , pbChunk , cbChunk ) ; ___( pbChunk ) ;
/*N1D*/                                                             ZE( byteT*, pbChunk ) ;
/*N1D*/
/*N1D*/                                                             if(                    cbChunk > cbOutRemainPart ) cbChunk = cbOutRemainPart ;
/*N1D*/                                                             if( !cbInRemainHigh && cbChunk > cbInRemain      ) cbChunk = cbInRemain      ;
/*N1D*/                                                             countT cbChunk = TOCK ;
/*N1D*/                                                             
/*N1D*/                                                             }
/*N1D*/                                                                 ;
/*N1D*/                                                                     : sizeBytes
/*N1D*/                                                                     ? cbInRemain
/*N1D*/                                                                 cbOutRemainPart = !cbInRemainHigh && cbInRemain < sizeBytes
/*N1D*/           
/*N1D*/                                                                 __Z( pFo ) ;
/*N1D*/                                                                 pFo = new( 0 , tinP , LF ) fileC( tinP , (strokeS*)( tFolderTo+tShortNoSuffix+T("meta.part.")+TF3(++idPartLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ; ___( pFo ) ;
/*N1D*/                                                             {
/*N1D*/                                                             if( !pFo )
/*N1D*/                                                         {
/*N1D*/                                                         while( cbInRemain || cbInRemainHigh && !POOP )
/*N1D*/                                                         ZE( countT , idPartLath ) ;
/*N1D*/                                                         ZE( countT , cbOutRemainPart ) ;
/*N1D*/                                                         ZE( fileC* , pFo ) ;
/*N1D*/
/*N1D*/                                                         countT cbInRemainHigh = pInfo->cbUsedHigh ;
/*N1D*/                                                         countT cbInRemain     = pInfo->cbUsed     ;
/*N1D*/                                                         fileC fi( tinP , pInfo->psttIfoName ) ;
/*N1D*/
/*N1D*/                                                         }
/*N1D*/                                                             delF( tinP , psttShortNoSuffix ) ;
/*N1D*/                                                             delF( tinP , psttSuffix ) ;
/*N1D*/                                                             tShortNoSuffix = T(psttShortNoSuffix) ;
/*N1D*/                                                             ___( psttShortNoSuffix ) ;
/*N1D*/                                                             ___( psttSuffix ) ;
/*N1D*/                                                             strBisectF( tinP , psttShortNoSuffix , psttSuffix , tShort , T(".") , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
/*N1D*/                                                             ZE( strokeS* , psttSuffix ) ;
/*N1D*/                                                             ZE( strokeS* , psttShortNoSuffix ) ;
/*N1D*/                                                         {
/*N1D*/                                                         TN( tShortNoSuffix , "" ) ;
/*N1D*/
/*N1D*/                                                         }
/*N1D*/                                                             delF( tinP , psttShort ) ;
/*N1D*/                                                             delF( tinP , psttPath ) ;
/*N1D*/                                                             tShort = T(psttShort) ;
/*N1D*/                                                             __( strCompareF( tinP , psttPath ,tFolderFrom ) ) ;
/*N1D*/                                                             ___( psttShort ) ;
/*N1D*/                                                             ___( psttPath ) ;
/*N1D*/                                                             strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
/*N1D*/                                                             ZE( strokeS* , psttShort ) ;
/*N1D*/                                                             ZE( strokeS* , psttPath ) ;
/*N1D*/                                                         {
/*N1D*/                                                         TN( tShort , "" ) ;
/*N1D*/                                                     {
/*N1D*/                                                     if( pInfo && strIdF( tinP , sttSlash , pInfo->psttIfoName , - 1 ) != pInfo->psttIfoName->idAdam && ( pInfo->cbUsedHigh || sizeBytes < pInfo->cbUsed ) )
/*N1D*/                                                     diskFindFileOrDirF( tinP , pInfo , hFind , fnLike.pathF() , &pat ) ;
/*N1D*/                                                 {
/*N1D*/                                                 do
/*N1D*/                                                 handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
/*N1D*/                                                 ZE( infoFileS* , pInfo ) ;
/*N1D*/                                                 strokeS sttSlash( '/' ) ;
/*N1D*/                                                        
/*N1D*/                                                 patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                 fileNameC fnLike( tinP , *this , tLike ) ;
/*N1D*/                                             {
/*N1D*/                                             if( diskFileExistsF( tinP , tLike ) )
/*N1D*/                                             TN( tLike , "" ) ; tLike = tFolderFrom+tStarDotData ;
/*N1D*/
/*N1D*/                                             }
/*N1D*/                                                 }
/*N1D*/                                                     diskFileOrDirDeleteF( tinP , psttc1 ) ;
/*N1D*/                                                 {
/*N1D*/                                                 FORsTRINGSiN1( pstt1f )
/*N1D*/                                                 diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat ) ; ___( pstt1f ) ;
/*N1D*/                                                 ZE( strokeS* , pstt1f ) ;
/*N1D*/                                                        
/*N1D*/                                                 patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                 fileNameC fnLike( tinP , *this , tFolderTo+T("*.meta.numparts.*") ) ;
/*N1D*/                                             {
/*N1D*/
/*N1D*/                                             }
/*N1D*/                                                 }
/*N1D*/                                                     diskFileOrDirDeleteF( tinP , psttc1 ) ;
/*N1D*/                                                 {
/*N1D*/                                                 FORsTRINGSiN1( pstt1f )
/*N1D*/                                                 diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat ) ; ___( pstt1f ) ;
/*N1D*/                                                 ZE( strokeS* , pstt1f ) ;
/*N1D*/                                                        
/*N1D*/                                                 patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                 fileNameC fnLike( tinP , *this , tFolderFrom+T("*.meta.numparts.*") ) ;
/*N1D*/                                             {
/*N1D*/
/*N1D*/                                             }
/*N1D*/                                                 }
/*N1D*/                                                     diskFileOrDirDeleteF( tinP , psttc1 ) ;
/*N1D*/                                                 {
/*N1D*/                                                 FORsTRINGSiN1( pstt1f )
/*N1D*/                                                 diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat ) ; ___( pstt1f ) ;
/*N1D*/                                                 ZE( strokeS* , pstt1f ) ;
/*N1D*/                                                        
/*N1D*/                                                 patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                 fileNameC fnLike( tinP , *this , tFolderTo+T("*.meta.part.*") ) ;
/*N1D*/                                             {
/*N1D*/
/*N1D*/                                             }
/*N1D*/                                                 }
/*N1D*/                                                     diskFileOrDirDeleteF( tinP , psttc1 ) ;
/*N1D*/                                                 {
/*N1D*/                                                 FORsTRINGSiN1( pstt1f )
/*N1D*/                                                 diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat ) ; ___( pstt1f ) ;
/*N1D*/                                                 ZE( strokeS* , pstt1f ) ;
/*N1D*/                                                        
/*N1D*/                                                 patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                 fileNameC fnLike( tinP , *this , tFolderFrom+T("*.meta.part.*") ) ;
/*N1D*/                                             {
/*N1D*/
/*N1D*/                                             diskMakeDirF( tinP , tFolderTo ) ;
/*N1D*/                                             diskMakeDirF( tinP , tFolderFrom ) ;
/*N1D*/
/*N1D*/                                             traceF( tinP , T("splitting all data files larger than ")+TF2(sizeBytes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" in ")+tFolderFrom+T(" into parts placed into ")+tFolderTo ) ;
/*N1D*/
/*N1D*/                                             if( !tFolderTo.csF( tinP) ) tFolderTo = tFolderFrom ;
/*N1D*/                                         {
/*N1D*/                                         if( tFolderFrom.csF( tinP ) && sizeBytes )
/*N1D*/                                     {
/*N1D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N1D*/                                 {
/*N1D*/                                 switch( idModeP )
/*N1D*/                             {
/*N1D*/                             else if( tKeyLevel1 == tKeySplit )
/*N1D*/                             }
/*N1D*/                                 }
/*N1D*/                                     }
/*N1D*/                                         break ;
/*N1D*/
/*N1D*/                                         }
/*N1D*/                                             tFolder = tn ;
/*N1D*/                                             diskRenameToHashF( tinP , tFolder , flETHERrENAMEtOhASH_RECURSE ) ;
/*N1D*/                                             diskMakeDirF( tinP , tFolder ) ;
/*N1D*/                                         {
/*N1D*/                                         if( tFolder.csF( tinP ) )
/*N1D*/                                     {
/*N1D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N1D*/                                 {
/*N1D*/                                 switch( idModeP )
/*N1D*/                             {
/*N1D*/                             else if( tKeyLevel1 == tKeyRenameToHash )
/*N1D*/                             }
/*N1D*/                                 }
/*N1D*/                                     }
/*N1D*/                                         break ;
/*N1D*/
/*N1D*/                                         tMemory = tn ;
/*N1D*/
/*N1D*/                                         }
/*N1D*/                                             swSettings.freeAllF( tinP ) ;
/*N1D*/                                             }
/*N1D*/                                                 delF( tinP , psttv ) ;
/*N1D*/                                                 delF( tinP , postk ) ;
/*N1D*/
/*N1D*/                                                 kv.newF( tinP , LF , postk , 0 , costk * SB , postv , costv + 1 ) ;
/*N1D*/
/*N1D*/                                                 //kv.newF( tinP , LF , postk , 0 , 1 , postv , costv + 1 ) ;
/*N1D*/
/*N1D*/                                                 //kv.newF( tinP , LF , &bug , 0 , 1 , postv , costv + 1 ) ;
/*N1D*/                                                 //byteT bug = 0xff ;
/*N1D*/                                                 //TO FIND A BUG
/*N1D*/
/*N1D*/                                                 for( countT offr = 0 ; offr < costk ; offr ++ ) postk[ offr ] = reverseBitsF( postk[ offr ] ) ; // SO THAT WALKING kv WILL PRESENT THE KEYS IN THE NORMAL COLLATION ORDER
/*N1D*/                                                 countT costv = strMakeF( tinP , postv , psttv    ) ; ___( postv ) ;
/*N1D*/                                                 countT costk = strMakeF( tinP , postk , psttzLeverSettings ) ; ___( postk ) ;
/*N1D*/                                                 ZE( osTextT* , postv ) ;
/*N1D*/                                                 ZE( osTextT* , postk ) ;
/*N1D*/
/*N1D*/                                                 traceF( tinP , T("settings [key,value]:    \"")+T(psttzLeverSettings)+T("\"    \"")+T(psttv)+T("\"") ) ;
/*N1D*/                                                 strokeS*& psttv = *(strokeS**)&(countT&)swSettings ;
/*N1D*/
/*N1D*/                                                 psttzLeverSettings = (strokeS*)swSettings.leverF( tinP , idf ) ;
/*N1D*/                                             {
/*N1D*/                                             for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
/*N1D*/                                             countT cFlavors = swSettings.cFlavorsF( tinP ) ;
/*N1D*/
/*N1D*/                                             THREADmODE3rESTORE
/*N1D*/                                             keyValuePairsC kv( tinP , postTiny , flKEYvALUEpAIRSc_WRITE , ifcIDsTATEsPACE_MULTIPLEaDAMS , 0x15 , 0 , 0 , 0 , 0 , idMemorySpace ) ;
/*N1D*/                                             THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
/*N1D*/
/*N1D*/                                             }
/*N1D*/                                                 }
/*N1D*/                                                     delF( tinP , pstt1f ) ;
/*N1D*/                                                     }
/*N1D*/                                                         //traceF( tinP , T("deleted : ")+T(psttc1) ) ;
/*N1D*/                                                         diskFileOrDirDeleteF( tinP , psttc1 ) ;
/*N1D*/                                                         //traceF( tinP , T("deleting: ")+T(psttc1) ) ;
/*N1D*/                                                     {
/*N1D*/                                                     FORsTRINGSiN1( pstt1f )
/*N1D*/                                                     countT cFound = diskFindFileOrDirF( tinP , pstt1f , fnLike.pathF() , &pat , 0 , 0 , 0 , 8 ) ; ___( pstt1f ) ;
/*N1D*/                                                     ZE( strokeS* , pstt1f ) ;
/*N1D*/
/*N1D*/                                                     patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                                     fileNameC fnLike( tinP , *this , T(iffn)+T(postTiny)+T(".*") ) ;
/*N1D*/
/*N1D*/                                                     traceF( tinP , T("state space path: ")+T(iffn) ) ;
/*N1D*/
/*N1D*/                                                     ifFileNameC iffn( tinP , third , postPath ) ;
/*N1D*/                                                 {
/*N1D*/                                                 if( !POOP )
/*N1D*/
/*N1D*/                                                 __Z( *postPath ) ;
/*N1D*/                                                 THREADmODE3rESTORE
/*N1D*/                                                 thirdC::postPathStateSpaceIF( tinP , postPath , sizeof postPath , ifcIDsTATEsPACE_MULTIPLEaDAMS , idMemorySpace ) ;
/*N1D*/                                                 THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
/*N1D*/
/*N1D*/                                                 osTextT postPath[ TUCK << 1 ] ;
/*N1D*/                                             {
/*N1D*/                                             //DELETE ALL OF THE EXISTING FILES ASSOCIATED WITH kv HERE
/*N1D*/
/*N1D*/                                             osTextT postTiny[] = "kv.settings.ipdos" ;
/*N1D*/                                         {
/*N1D*/                                         else
/*N1D*/                                         }
/*N1D*/                                             traceF( tinP , T("error: unknown memory specification:    ")+tMemory ) ;
/*N1D*/                                         {
/*N1D*/                                         if( !idMemorySpace )
/*N1D*/
/*N1D*/                                         ;
/*N1D*/                                                                     : 0
/*N1D*/                                                                     ? ifcIDmEMORYsPACE_BANGrELAY
/*N1D*/                                                                 : !strCompareF( tinP , tMemory , T("relay") )
/*N1D*/                                                                 ? ifcIDmEMORYsPACE_WATCH
/*N1D*/                                                             : !strCompareF( tinP , tMemory , T("watch") )
/*N1D*/                                                             ? ifcIDmEMORYsPACE_MEMBRANE
/*N1D*/                                                         : !strCompareF( tinP , tMemory , T("membrane") )
/*N1D*/                                                         ? ifcIDmEMORYsPACE_KERNEL
/*N1D*/                                                     : !strCompareF( tinP , tMemory , T("kernel") )
/*N1D*/                                                     ? ifcIDmEMORYsPACE_CLOAK
/*N1D*/                                                 : !strCompareF( tinP , tMemory , T("cloak") )
/*N1D*/                                                 ? ifcIDmEMORYsPACE_APPLICATION
/*N1D*/                                             : !strCompareF( tinP , tMemory , T("application") )
/*N1D*/                                             ? ifcIDmEMORYsPACE_APPLICATION
/*N1D*/                                         const countT idMemorySpace = !strCompareF( tinP , tMemory , tn )
/*N1D*/                                     {
/*N1D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N1D*/                                 {
/*N1D*/                                 switch( idModeP )
/*N1D*/                             {
/*N1D*/                             else if( tKeyLevel1 == tKeySettings )
/*N1D*/                             }
/*N1D*/                                 }
/*N1D*/                                     }
/*N1D*/                                         break ;
/*N1D*/
/*N1D*/                                         }
/*N1D*/                                             flagsReport  = flETHERsOILrEPORT_null ;
/*N1D*/                                             flagsPutFile = flBRANCHspUTfILEf_null ;
/*N1D*/                                             flagsLoad    = flBRANCHslOADf_null    ;
/*N1D*/                                             soulBody.removeAllF( tinP ) ;
/*N1D*/
/*N1D*/                                             }
/*N1D*/                                                 delF( tinP , psttm ) ;
/*N1D*/                                                 //traceF( tinP , T("set 4 [tArchive]: ")+tArchive ) ;
/*N1D*/                                                 tArchive = T(psttm) ;
/*N1D*/                                                 diskMapFileNameF( tinP , psttm , T("///ideafarm/IdeaFarm (tm)/")+( tUserOverride.csF( tinP ) ? tUserOverride : tUser )+T("/Drop Files Here To Archive/") ) ; ___( psttm ) ;
/*N1D*/                                                 ZE( strokeS* , psttm ) ;
/*N1D*/                                             {
/*N1D*/
/*N1D*/                                             tJobQueueRepeat = tJobQueueFolder = tReportsSource = tReportsFolder = tHtmlHead = tHtmlBodySuffix = tHtmlBodyPrefix = tHtmlFolder = tn ;
/*N1D*/                                             traceF( tinP , T("reset to default [tFolder]: ")+tFolder ) ; //U:: TO FIND A BUG
/*N1D*/                                             tFolder = tFolderDefault ;
/*N1D*/
/*N1D*/                                             }
/*N1D*/                                                 traceF( tinP , T("elapsed time to load branches and put html files: ")+TT(timeB1,timeB2) ) ;
/*N1D*/                                                 osTimeSubtractF( tinP , timeB1 , timeB2 , timeA1 , timeA2 ) ;
/*N1D*/                                                 osTimeNowF( tinP , timeB1 , timeB2 ) ;
/*N1D*/                                                 ZE( sCountT , timeB2 ) ;
/*N1D*/                                                 ZE( countT , timeB1 ) ;
/*N1D*/
/*N1D*/                                                 }
/*N1D*/                                                     }
/*N1D*/                                                         traceF( tinP , T("ok") ) ;
/*N1D*/                                                 
/*N1D*/                                                         }
/*N1D*/                                                             traceF( tinP , T("etherSoilF swUrlReferenced [idf,cRef,lever]: ")+TF3(idf,flFORMAT_NObIGITvALUES,9)+T("    ")+TF3(cRef,flFORMAT_NObIGITvALUES,9)+T("\"")+T(psttLever)+T("\"") ) ;
/*N1D*/                                                             countT cRef = swUrlReferenced ;
/*N1D*/                                                             psttLever = (strokeS*)swUrlReferenced.leverF( tinP , idf ) ;
/*N1D*/                                                         {
/*N1D*/                                                         for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
/*N1D*/                                                         countT cFlavors = swUrlReferenced.cFlavorsF( tinP ) ;
/*N1D*/                                                     {
/*N1D*/                                                     else
/*N1D*/                                                     }
/*N1D*/                                                         traceF( tinP , T("error: could not create the html files, or an infinite loop was detected when doing so.") ) ;
/*N1D*/                                                         POOPR
/*N1D*/                                                     {
/*N1D*/                                                     if( POOP )
/*N1D*/                                                 
/*N1D*/                                                     }
/*N1D*/                                                         delF( tinP , psttBanner2 ) ;
/*N1D*/                                                         delF( tinP , psttBanner1 ) ;
/*N1D*/
/*N1D*/                                                         branchS::putFileIF( tinP , *tinP.pEtScratch , bQuitP , arg , jotBranches , 2 | jotBranches.tagHighNibbleF() , T(psttTimeN)+T(" : ")+T(psttTimeT) , psttBanner1 , psttBanner2 , tNameSpace , postSourceP , costSourceP ) ;
/*N1D*/                                                         putFileS arg( tinP , *this , psttLever , swUrlReferenced , TUCK << 1 , tFolderFile , idKtrMode , flagsPutFile ) ;
/*N1D*/
/*N1D*/                                                         traceF( tinP , T("etherSoilF [tHtmlFolder]: ")+tHtmlFolder ) ;
/*N1D*/
/*N1D*/                                                         // 20150202@1600: tHead tTail RENAMED AND REPURPOSED TO tHtmlBodyPrefix tHtmlBodySuffix tHtmlHead.  WILL BE USED TO ALLOW USER TO CONTROL THE HTML RATHER THAN HAVE IT HARDCODED JUST FOR MY USE
/*N1D*/
/*N1D*/                                                         // OOTH, putFileIF NEEDS TO CALCULATE HEAD SO THAT IT CAN EMIT BOTH A BLACK AND A WHITE FLAVOR OF EACH FILE
/*N1D*/                                                         // WOTH, THE CURRENT CODE DOES NOT SUPPORT CURLEY AND SQUARE BRACKETS IN THE HEAD VALUE, WHICH ARE REQUIRED IN ORDER TO SUPPORT THE USE OF GOOGLE AD WORDS TRACKING TAGS
/*N1D*/                                                         // THIS CHANGE WAS MADE FOR OO REASONS
/*N1D*/                                                         // WO POSSIBILITY IS TO ALLLOW THE SOIL FILE TO SPECIFY HEAD AND TAIL SUFFIXES THAT putFileIF WILL APPEND TO THE HEAD AND TAIL VALUES THAT IT CALCULATES AND USES
/*N1D*/                                                         // THE CODE REMAINS FOR USE AS A CODE MINE
/*N1D*/                                                         // 20150128@1620: IT IS NOW ILLEGAL TO SPECIFY THE head AND tail KEYS, BUT THIS IS NOT ENFORCED
/*N1D*/
/*N1D*/                                                         strFromTimeF( tinP , psttTimeT , timeN1 , timeN2 , 9 , 0xc , S1C('.') , 0 , ifcIDfORMATtIME_TEXT    , flFORMAT_null ) ; ___( psttTimeT ) ;
/*N1D*/                                                         ZE( strokeS* , psttTimeT ) ;
/*N1D*/
/*N1D*/                                                         strFromTimeF( tinP , psttTimeN , timeN1 , timeN2 , 4 , 7 , S1C('.') , 0 , ifcIDfORMATtIME_NUMERIC , flFORMAT_null ) ; ___( psttTimeN ) ;
/*N1D*/                                                         ZE( strokeS* , psttTimeN ) ;
/*N1D*/
/*N1D*/                                                         osTimeNowF( tinP , timeN1 , timeN2 ) ;
/*N1D*/                                                         ZE( sCountT , timeN2 ) ;
/*N1D*/                                                         ZE( countT , timeN1 ) ;
/*N1D*/
/*N1D*/                                                         }
/*N1D*/                                                             }
/*N1D*/                                                                 strMakeF( tinP , psttBanner2 , T("") ) ; ___( psttBanner2 ) ;
/*N1D*/                                                                 traceF( tinP , T("banner2 setting could not be retrieved ; using default banner2") ) ;
/*N1D*/                                                             {
/*N1D*/                                                             if( !psttBanner2 )
/*N1D*/
/*N1D*/                                                             }
/*N1D*/                                                                 strMakeF( tinP , psttBanner1 , T("") ) ; ___( psttBanner1 ) ;
/*N1D*/                                                                 traceF( tinP , T("banner1 setting could not be retrieved ; using default banner1") ) ;
/*N1D*/                                                             {
/*N1D*/                                                             if( !psttBanner1 )
/*N1D*/
/*N1D*/                                                             POOPR
/*N1D*/                                                         {
/*N1D*/                                                         if( POOP )
/*N1D*/
/*N1D*/                                                         __Z( psttBanner2 ) ;
/*N1D*/                                                         __Z( psttBanner1 ) ;
/*N1D*/
/*N1D*/                                                         }
/*N1D*/                                                             psttBanner2 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                             GETsETTING( *this , psttnu1 , T("!ktr.banner1") )
/*N1D*/                                                         {
/*N1D*/                                                         if( !psttBanner2 )
/*N1D*/                                                                 
/*N1D*/                                                         }
/*N1D*/                                                             psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                             GETsETTING( *this , psttnu1 , T("!ktr.banner1") )
/*N1D*/                                                         {
/*N1D*/                                                         if( !psttBanner1 )
/*N1D*/                                                                 
/*N1D*/                                                         }
/*N1D*/                                                             }
/*N1D*/                                                                 break ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.other") )
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.other") )
/*N1D*/                                                             {
/*N1D*/                                                             default                            :
/*N1D*/                                                             case ifcIDmODEpUTfILE_OTHER        :
/*N1D*/                                                             }
/*N1D*/                                                                 break ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.ipdos") )
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.ipdos") )
/*N1D*/                                                             {
/*N1D*/                                                             case ifcIDmODEpUTfILE_IPDOS        :
/*N1D*/                                                             }
/*N1D*/                                                                 break ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.pay") )
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.pay") )
/*N1D*/                                                             {
/*N1D*/                                                             case ifcIDmODEpUTfILE_PAY          :
/*N1D*/                                                             }
/*N1D*/                                                                 break ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.bio") )
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.bio") )
/*N1D*/                                                             {
/*N1D*/                                                             case ifcIDmODEpUTfILE_WO          :
/*N1D*/                                                             }
/*N1D*/                                                                 break ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.archive") )
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.archive") )
/*N1D*/                                                             {
/*N1D*/                                                             case ifcIDmODEpUTfILE_ARCHIVE      :
/*N1D*/                                                             }
/*N1D*/                                                                 break ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.essays") )
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.essays") )
/*N1D*/                                                             {
/*N1D*/                                                             case ifcIDmODEpUTfILE_ESSAYS       :
/*N1D*/                                                             }
/*N1D*/                                                                 break ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.news") )
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.news") )
/*N1D*/                                                             {
/*N1D*/                                                             case ifcIDmODEpUTfILE_NEWS    :
/*N1D*/                                                             }
/*N1D*/                                                                 break ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.bundle") )
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.bundle") )
/*N1D*/                                                             {
/*N1D*/                                                             case ifcIDmODEpUTfILE_BUNDLE       :
/*N1D*/                                                             }
/*N1D*/                                                                 break ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.tutorials") )
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.tutorials") )
/*N1D*/                                                             {
/*N1D*/                                                             case ifcIDmODEpUTfILE_TUTORIALS    :
/*N1D*/                                                             }
/*N1D*/                                                                 break ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.paid") )
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.paid") )
/*N1D*/                                                             {
/*N1D*/                                                             case ifcIDmODEpUTfILE_PAID  :
/*N1D*/                                                             }
/*N1D*/                                                                 break ;
/*N1D*/                                                                 psttBanner2 = psttnu2 ; psttnu2 = 0 ;
/*N1D*/                                                                 psttBanner1 = psttnu1 ; psttnu1 = 0 ;
/*N1D*/                                                                 GETsETTING( *this , psttnu2 , T("!ktr.banner2.root") )
/*N1D*/                                                                 GETsETTING( *this , psttnu1 , T("!ktr.banner1.root") )
/*N1D*/                                                             {
/*N1D*/                                                             case ifcIDmODEpUTfILE_ROOT  :
/*N1D*/                                                         {
/*N1D*/                                                         switch( idKtrMode )
/*N1D*/                                                         ZE( strokeS* , psttBanner2 ) ;
/*N1D*/                                                         ZE( strokeS* , psttBanner1 ) ;
/*N1D*/                                                     {
/*N1D*/                                                 
/*N1D*/                                                     switchC swUrlReferenced( tinP , third , TAG( TAGiDnULL) , flSTACKc_null , psttLever ) ;
/*N1D*/                                                     ZE( strokeS* , psttLever ) ;
/*N1D*/                                                 {
/*N1D*/                                                 else
/*N1D*/                                                 if( POOP ) POOPR
/*N1D*/                                                 /**/if( bTrace ) traceF( tinP , T("etherSoilF / loaded  knowledge tree branches") ) ;
/*N1D*/
/*N1D*/                                                 }
/*N1D*/                                                     }
/*N1D*/                                                         }
/*N1D*/                                                             fileWriteF( tinP , hFile2 , postp , costp ) ;
/*N1D*/    
/*N1D*/                                                             delF( tinP , psttp ) ;
/*N1D*/                                                             countT costp = strMakeF( tinP , postp , psttp ) ; ___( postp ) ;
/*N1D*/                                                             ZE( osTextT* , postp ) ;
/*N1D*/    
/*N1D*/                                                             soulReportLinkage >> psttp ; ___( psttp ) ;
/*N1D*/                                                             ZE( strokeS* , psttp ) ;
/*N1D*/                                                         {
/*N1D*/                                                         while( soulReportLinkage )
/*N1D*/                                                         fileOpenF( tinP , hFile2 , countTC() , tFolderFile+T(".link.pages.txt") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ; // READABLE LIST OF LINKAGE LABELS
/*N1D*/                                                         handleC hFile2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
/*N1D*/    
/*N1D*/                                                         //}
/*N1D*/                                                         //    LOGrAW( T(psttp) ) ;
/*N1D*/                                                         //    soulReportLinkage >> psttp ; ___( psttp ) ;
/*N1D*/                                                         //    ZE( strokeS* , psttp ) ;
/*N1D*/                                                         //{
/*N1D*/                                                         //while( soulReportLinkage )
/*N1D*/                                                         //TO FIND A BUG
/*N1D*/    
/*N1D*/                                                         }
/*N1D*/                                                             fileWriteF( tinP , hFile , soulLinkOuter ) ;
/*N1D*/                                                             fileOpenF( tinP , hFile , countTC() , tFolderFile+T(".link.pages.soul.not.html") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ; // ".not.html" IS USED TO DEFEAT THE BRAIN DEAD STUPID PRACTICE BY HTTP SERVERS OF REFUSING TO SERVE REQUESTS BASED ON FILE EXTENSION
/*N1D*/                                                             handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
/*N1D*/                                                         {
/*N1D*/                                                     {
/*N1D*/                                                     if( !POOP )
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         }
/*N1D*/                                                             strFuseF( tinP , soulReportLinkage , T("    }\r\n}\r\n") ) ;
/*N1D*/                                                             }
/*N1D*/                                                                 delF( tinP , psttText ) ;
/*N1D*/                                                                 strFuseF( tinP , soulReportLinkage , T(psttText)+T("\" }\r\n        }\r\n") ) ;
/*N1D*/    
/*N1D*/                                                                 }
/*N1D*/                                                                     //traceF( tinP , T("got trimmed [text]:   \"")+T(psttText)+T("\"") ) ;
/*N1D*/                                                                     }
/*N1D*/                                                                         delF( tinP , psttd ) ;
/*N1D*/                                                                         strSubstringF( tinP , psttText , idf , sttq , sttMark01 , psttd ) ; ___( psttText ) ;
/*N1D*/    
/*N1D*/                                                                                          psttText = 0 ;
/*N1D*/                                                                         strokeS* psttd = psttText ;
/*N1D*/                                                                     {
/*N1D*/                                                                     if( strIdF( tinP , idf , sttq , sttMark01 , psttText , idl , 1 ) )
/*N1D*/                                                                     strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
/*N1D*/                                                                     ZE( countT , idl ) ;
/*N1D*/                                                                     countT idf = 1 ;
/*N1D*/                                                                 {
/*N1D*/                                                                 // TRIM THE TEXT
/*N1D*/    
/*N1D*/                                                                 delF( tinP , psttLabel ) ;
/*N1D*/                                                                 }
/*N1D*/                                                                     strMakeF( tinP , psttText , T("[error: no text is associated with this label]") ) ; ___( psttText ) ;
/*N1D*/                                                                     traceF( tinP , T("error: no text is associated with this label [psttLabel]:    ")+T(psttLabel) ) ;
/*N1D*/                                                                 {
/*N1D*/                                                                 if( !psttText )
/*N1D*/    
/*N1D*/                                                                 soulLinkInner >> psttText ; ___( psttText ) ;
/*N1D*/                                                                 ZE( strokeS* , psttText ) ;
/*N1D*/    
/*N1D*/                                                                 soulLinkInner >> hashId ;
/*N1D*/                                                                 ZE( countT , hashId ) ;
/*N1D*/    
/*N1D*/                                                                 soulLinkInner >> hashv ;
/*N1D*/                                                                 ZE( countT , hashv ) ;
/*N1D*/    
/*N1D*/                                                                 strFuseF( tinP , soulReportLinkage , T("\r\n        {label:\r\n            {key: ")+T(psttLabel)+T(" }\r\n            {value: \"") ) ;
/*N1D*/                                                                 soulLinkInner >> psttLabel ; ___( psttLabel ) ;
/*N1D*/                                                                 ZE( strokeS* , psttLabel ) ;
/*N1D*/                                                             {
/*N1D*/                                                             while( soulLinkInner )
/*N1D*/                                                             strokeS sttMark01( 0x10 , sc_MARK ) ;
/*N1D*/    
/*N1D*/                                                             soulLinkInner >> cFlavors ;
/*N1D*/                                                             ZE( countT , cFlavors ) ;
/*N1D*/    
/*N1D*/                                                             soulLinkInner >> idFormat ;
/*N1D*/                                                             ZE( countT , idFormat ) ;
/*N1D*/    
/*N1D*/                                                             soulLinkInner >> fingerv ;
/*N1D*/                                                             ZE( countT , fingerv ) ;
/*N1D*/    
/*N1D*/                                                             delF( tinP , postTM ) ;
/*N1D*/                                                             soulLinkInner >> postTM ; ___( postTM ) ;
/*N1D*/                                                             ZE( osTextT* , postTM ) ;
/*N1D*/    
/*N1D*/                                                             soulLinkOuter << soulLinkInner ;
/*N1D*/                                                             soulLinkOuter << (strokeS*)tFolderFile ;
/*N1D*/    
/*N1D*/                                                             soulLinkOuter << (countT)1 ; // idFormat
/*N1D*/                                                             soulLinkOuter << finger ;
/*N1D*/                                                             putNegAM( *(countT*)&finger , FINGERnEG_KTlINKfILEoUTER ) ;
/*N1D*/                                                             ZE( countT , finger ) ;
/*N1D*/                                                             soulLinkOuter << (osTextT*)T(" >> IdeaFarm (tm) - (c) Wo'O Ideafarm - ideafarm.com << ") ;
/*N1D*/                                                         {
/*N1D*/                                                         if( !POOP )
/*N1D*/
/*N1D*/                                                         }
/*N1D*/ /*---------------- LOAD BRANCHES ----------------*/         branchS::loadIF( tinP , *this , etPrimeIF( tinP ) , jotBranches , csttTrimmed , soulBody , flagsLoad , &soulLinkInner ) ;
/*N1D*/                                                             _IO_
/*N1D*/                                                         {
/*N1D*/                                                         soulC soulLinkInner( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/                                                     {
/*N1D*/                                                     soulC soulLinkOuter( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         strFuseF( tinP , soulReportLinkage , tHead ) ;
/*N1D*/
/*N1D*/                                                         tHead += tFile+tFileNameSuffix+T(" }\r\n\r\n    {master:   \"")+tFolderFile+T("\" }\r\n\r\n    {labels:\r\n") ;
/*N1D*/
/*N1D*/                                                         ) ;
/*N1D*/
/*N1D*/                                                             "               contents of accompanying binary file\r\n               "
/*N1D*/                                                             "    {note:     This report is a nonauthoritative export of the\r\n"
/*N1D*/                                                             "    {source:   ideafarm.com                                       }\r\n\r\n"
/*N1D*/                                                             "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
/*N1D*/                                                             "    {name:     Knowledge Tree Linkage Report                      }\r\n"
/*N1D*/                                                             "\r\n"
/*N1D*/                                                             "{report:\r\n"
/*N1D*/                                                             "\r\n"
/*N1D*/
/*N1D*/                                                         TN( tHead ,
/*N1D*/                                                         TN( tFileNameSuffix , ".link.pages.soul.not.html" ) ;
/*N1D*/                                                     {
/*N1D*/                                                     soulC soulReportLinkage( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report.linkage" ) ;
/*N1D*/                                                 {
/*N1D*/
/*N1D*/                                                 }
/*N1D*/                                                     }
/*N1D*/                                                         fileWriteF( tinP , hFile2 , postp , costp ) ;
/*N1D*/
/*N1D*/                                                         delF( tinP , psttp ) ;
/*N1D*/                                                         countT costp = strMakeF( tinP , postp , psttp ) ; ___( postp ) ;
/*N1D*/                                                         ZE( osTextT* , postp ) ;
/*N1D*/
/*N1D*/                                                         soulReportFragments >> psttp ; ___( psttp ) ;
/*N1D*/                                                         ZE( strokeS* , psttp ) ;
/*N1D*/                                                     {
/*N1D*/                                                     while( soulReportFragments )
/*N1D*/                                                     fileOpenF( tinP , hFile2 , countTC() , tFolderFile+T(".link.frag.notes.txt") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ; // READABLE LIST OF LINKAGE LABELS
/*N1D*/                                                     handleC hFile2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
/*N1D*/
/*N1D*/
/*N1D*/
/*N1D*/                                                     //}
/*N1D*/                                                     //    THREADmODE1oN( flTHREADmODE1_ALLOWeMITwORD )
/*N1D*/                                                     //    traceF( tinP , T("setting flTHREADmODE1_ALLOWeMITwORD") ) ;
/*N1D*/                                                     //{
/*N1D*/                                                     //if( strIdF( tinP , T("2012") , tFolderFile , 1 ) )
/*N1D*/                                                     //TO FIND A BUG 20161130@1238
/*N1D*/
/*N1D*/
/*N1D*/                                                     }
/*N1D*/                                                         strFuseF( tinP , soulReportFragments , T("    }\r\n}\r\n") ) ;
/*N1D*/                                                         }
/*N1D*/                                                             delF( tinP , psttp ) ;
/*N1D*/                                                             strFuseF( tinP , soulReportFragments , tSay ) ;
/*N1D*/
/*N1D*/                                                             ;
/*N1D*/
/*N1D*/                                                                 : T(psttp)+T("\" }\r\n        }\r\n")
/*N1D*/                                                                 ? T("\r\n        {idfrag:\r\n            {key: ")+T(psttp)+T(" }\r\n            {value: \"")
/*N1D*/
/*N1D*/                                                             TN( tSay , "" ) ; tSay = bKey
/*N1D*/
/*N1D*/                                                             //traceF( tinP , T("sBinary [psttp]: ")+T(psttp) ) ;
/*N1D*/                                                             sBinary >> psttp ; ___( psttp ) ;
/*N1D*/                                                             ZE( strokeS* , psttp ) ;
/*N1D*/
/*N1D*/                                                             bKey = !bKey ;
/*N1D*/                                                         {
/*N1D*/                                                         while( sBinary )
/*N1D*/                                                         ZE( boolT , bKey ) ;
/*N1D*/
/*N1D*/                                                         strFuseF( tinP , soulReportFragments , tHead ) ;
/*N1D*/
/*N1D*/                                                         tHead += tFile+tFileNameSuffix+T(" }\r\n\r\n    {master:   \"")+tFolderFile+T("\" }\r\n\r\n    {idfrags:\r\n") ;
/*N1D*/
/*N1D*/                                                         ) ;
/*N1D*/
/*N1D*/                                                             "               contents of accompanying binary file\r\n               "
/*N1D*/                                                             "    {note:     This report is a nonauthoritative export of the\r\n"
/*N1D*/                                                             "    {source:   ideafarm.com                                       }\r\n\r\n"
/*N1D*/                                                             "    {tm:       IdeaFarm " "(tm) Personal Information Security System }\r\n"
/*N1D*/                                                             "    {name:     Knowledge Tree Linkage Fragment Report             }\r\n"
/*N1D*/                                                             "\r\n"
/*N1D*/                                                             "{report:\r\n"
/*N1D*/                                                             "\r\n"
/*N1D*/
/*N1D*/                                                         TN( tHead ,
/*N1D*/                                                     {
/*N1D*/                                                     soulC soulReportFragments( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report.fragments" ) ;
/*N1D*/
/*N1D*/                                                     boxGetShadowF( tinP , sBinary , tFileBinary ) ;
/*N1D*/                                                     soulC sBinary( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/
/*N1D*/                                                     diskWalkCopyFileF( tinP , tFileBinary , T("///ideafarm/tmp/link.frag.note.soul.not.html") ) ;
/*N1D*/                                                     TN( tFileBinary , "" ) ; tFileBinary = tFolderFile+tFileNameSuffix ;
/*N1D*/                                                     TN( tFileNameSuffix , ".link.frag.notes.soul.not.html" ) ;
/*N1D*/                                                 {
/*N1D*/                                                 if( F(flagsReport) & flETHERsOILrEPORT_FRAGnOTE )
/*N1D*/
/*N1D*/                                                 traceF( tinP , T("tKeyKtr close curly [tFolderFile]: ")+tFolderFile ) ; //U::TO FIND A BUG
/*N1D*/
/*N1D*/                                                 TN( tFolderFile , "" ) ; tFolderFile = tFolder+tFile ;
/*N1D*/
/*N1D*/                                                                        jotC jotBranches( tinP , "ethersoil.branches" , flJOTc_WRITE | flJOTc_DELETE | flJOTc_PRIVATE , TICK << 4 , TOCK << 6 , 8 ) ; //20180724@1648: CNR STOPPAGE FOR 2015
/*N1D*/                                                 //OLD: FAILS FOR 2015: jotC jotBranches( tinP , "ethersoil.branches" , flJOTc_WRITE | flJOTc_DELETE | flJOTc_PRIVATE , TICK << 2 , TOCK << 6 , 1 ) ; //PRODUCTION (20140521@0515: TICK<<1 IS CURRENTLY LARGE ENOUGH FOR THE PRODUCTION WEB SITE)
/*N1D*/                                                 //U:: USE AN INDEX THAT IS 8 TIMES THE DEFAULT SIZE, TO ELIMINATE THRASHING
/*N1D*/                                                 // 20140829@0750: 6 BOOKS ARE REQUIRED FOR THE INDEX
/*N1D*/                                                 // 20140829@0750: 4 BOOKS ARE REQUIRED IF EACH BOOK IS TICK << 2, SO IT WOULD BE NEAT IF TICK << 4 WOULD WORK (NOT TESTED YET)
/*N1D*/
/*N1D*/                                                 /**/if( bTrace ) traceF( tinP , T("etherSoilF / loading knowledge tree branches") ) ;
/*N1D*/
/*N1D*/                                                 osTimeNowF( tinP , timeA1 , timeA2 ) ;
/*N1D*/                                                 ZE( sCountT , timeA2 ) ;
/*N1D*/                                                 ZE( countT , timeA1 ) ;
/*N1D*/
/*N1D*/                                                 SCOOPS
/*N1D*/                                             {
/*N1D*/                                             IFsCRATCH
/*N1D*/                                             ZE( boolT , bFail ) ;
/*N1D*/                                             ZE( countT , csttTrimmed ) ;
/*N1D*/                                         {
/*N1D*/                                         //U::else
/*N1D*/                                         //U::traceF( tinP , T("PISS / KTR: doing nothing because this home does not have PAID privileges") ) ;
/*N1D*/                                         //U::)
/*N1D*/                                         //U::    !( F(home.flags) & flHOMEs_IDEAFARMcLOUDiSgONE )
/*N1D*/                                         //U::    &&
/*N1D*/                                         //U::    !( F(home.flags) & flHOMEs_PAIDpRIVILEGES )
/*N1D*/                                         //U::(
/*N1D*/                                         //U::if
/*N1D*/
/*N1D*/                                         homeS& home = homeS::homeIF() ;
/*N1D*/                                     {
/*N1D*/                                     case ifcIDmODEeTHERsOIL_REPORT :
/*N1D*/                                 {
/*N1D*/                                 switch( idModeP )
/*N1D*/                             {
/*N1D*/                             else if( tKeyLevel1 == tKeyKtr )
/*N1D*/                             }
/*N1D*/                                 }
/*N1D*/                                     traceF( tinP , T("dojobs: 0 file is in ")+tDone ) ;
/*N1D*/
/*N1D*/                                     while( !etPrime && !POOP && !etPrime.diskFileExistsF( tinP , tDone    ) ) { ++ s ; etPrime.osSleepF( tinP , TOCK ) ; }
/*N1D*/                                     traceF( tinP , T("dojobs: 1 waiting for file to appear in ")+tDone ) ;
/*N1D*/
/*N1D*/                                     while( !etPrime && !POOP &&  etPrime.diskFileExistsF( tinP , tPending ) ) { ++ s ; etPrime.osSleepF( tinP , TOCK ) ; }
/*N1D*/                                                                                                             ++ s ; etPrime.osSleepF( tinP , TOCK ) ;  // RACE: FOR A MOMENT, THE FILE EXISTS IN NEITHER DIRECTORY (BASE O.S. MOVE MIGHT NOT BE ATOMIC)
/*N1D*/                                     traceF( tinP , T("dojobs: 2 waiting for file to disappear from ")+tPending ) ;
/*N1D*/
/*N1D*/                                     while( !etPrime && !POOP &&  etPrime.diskFileExistsF( tinP , tDrop    ) ) { ++ s ; etPrime.osSleepF( tinP , TOCK ) ; }
/*N1D*/                                     traceF( tinP , T("dojobs: 3 waiting for file to disappear from ")+tDrop ) ;
/*N1D*/
/*N1D*/                                     etherC& etPrime = etPrimeIF( tinP ) ;
/*N1D*/
/*N1D*/                                     sleepC s( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/                                     //U::DO THIS ONLY IF A SYNC FLAG IS SET
/*N1D*/
/*N1D*/                                     delF( tinP , postAll ) ;
/*N1D*/                                     delF( tinP , psttu ) ;
/*N1D*/
/*N1D*/                                     boxPutF( tinP , tHomeUser+tDropHere+tShort , postAll , costAll ) ;
/*N1D*/
/*N1D*/                                     TN( tDone     , "" ) ; tDone    = tHomeUser+tDoneHere   +tShort ;
/*N1D*/                                     TN( tPending  , "" ) ; tPending = tHomeUser+tPendingHere+tShort ;
/*N1D*/                                     TN( tDrop     , "" ) ; tDrop    = tHomeUser+tDropHere   +tShort ;
/*N1D*/
/*N1D*/                                     TN( tDoneHere    , "/Pick Up SOIL (tm) Reply Text Here/"  ) ;
/*N1D*/                                     TN( tPendingHere , "/SOIL (tm) Text Being Eaten/"         ) ;
/*N1D*/                                     TN( tDropHere    , "/Drop a Copy of SOIL (tm) Text Here/" ) ;
/*N1D*/                                     TN( tShort       , ""                                     ) ; tShort    = T("jobs.")+T(psttu)+T(".soil") ;
/*N1D*/                                     TN( tHomeUser    , ""                                     ) ; tHomeUser = T("///ideafarm/IdeaFarm (tm)/")+tUser ;
/*N1D*/
/*N1D*/                                     //U:: SUPPRESS THE JOBS IF etherSoilWalkCBF DETECTED NAMES THAT ARE TOO LONG
/*N1D*/
/*N1D*/                                     strUniqueF( tinP , psttu ) ; ___( psttu ) ;
/*N1D*/                                     ZE( strokeS* , psttu ) ;
/*N1D*/
/*N1D*/                                     __( poste - postc ) ;
/*N1D*/                                     }
/*N1D*/                                         delF( tinP , pc2p ) ;
/*N1D*/                                         delF( tinP , *(osTextT**)&pc2p->c2 ) ;
/*N1D*/
/*N1D*/                                         }
/*N1D*/                                             postc += pc2p->c1 ;
/*N1D*/                                             thirdC::c_memcpyIF( tinP , postc , (osTextT*)pc2p->c2 , pc2p->c1 ) ;
/*N1D*/                                         {
/*N1D*/                                         if( pc2p->c2 && pc2p->c1 && costAvailable >= pc2p->c1 )
/*N1D*/                                         countT costAvailable = poste - postc ;
/*N1D*/
/*N1D*/                                         stImage >> pc2p ;
/*N1D*/                                         ZE( count2S* , pc2p ) ;
/*N1D*/                                     {
/*N1D*/                                     while( stImage )
/*N1D*/                                     osTextT* poste = postAll + costAll ;
/*N1D*/                                     osTextT* postc = postAll ;
/*N1D*/
/*N1D*/                                     newF( tinP , LF , postAll , costAll ) ; ___( postAll ) ;
/*N1D*/                                     ZE( osTextT* , postAll ) ;
/*N1D*/
/*N1D*/                                     }
/*N1D*/                                         while( !etherC::etPrimeIF( tinP ) && ~hFind ) ;
/*N1D*/                                         }
/*N1D*/                                             DEL( pInfo ) ;
/*N1D*/                                             }
/*N1D*/                                                 }
/*N1D*/                                                     }
/*N1D*/                                                         costAll += costWo ;
/*N1D*/                                                         stImage << pc2p ;
/*N1D*/                                                         pc2p->c2 = (countT)postWo ;
/*N1D*/                                                         pc2p->c1 = costWo ;
/*N1D*/                                                     {
/*N1D*/                                                     if( pc2p )
/*N1D*/                                                     newF( tinP , LF , pc2p ) ; ___( pc2p ) ;
/*N1D*/                                                     ZE( count2S* , pc2p ) ;
/*N1D*/                                                 {
/*N1D*/                                                 if( !POOP && postWo && costWo )
/*N1D*/
/*N1D*/                                                 boxGetF( tinP , postWo , costWo , pInfo->psttIfoName ) ; ___( postWo ) ;
/*N1D*/                                                 ZE( countT   , costWo ) ;
/*N1D*/                                                 ZE( osTextT* , postWo ) ;
/*N1D*/                                             {
/*N1D*/                                             if( pInfo && strIdF( tinP , sttSlash , pInfo->psttIfoName , - 1 ) != pInfo->psttIfoName->idAdam )
/*N1D*/                                             diskFindFileOrDirF( tinP , pInfo , hFind , fnLike.pathF() , &pat ) ;
/*N1D*/                                         {
/*N1D*/                                         do
/*N1D*/                                         handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
/*N1D*/                                         strokeS sttSlash( '/' ) ;
/*N1D*/                                         ZE( infoFileS* , pInfo ) ;
/*N1D*/                                                
/*N1D*/                                         patternC pat( tinP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
/*N1D*/                                         fileNameC fnLike( tinP , *this , tJobQueueFolder+T("*.soil") ) ;
/*N1D*/
/*N1D*/                                         }
/*N1D*/                                             }
/*N1D*/                                                 costAll += costr ;
/*N1D*/                                                 stImage << pc2p ;
/*N1D*/                                                 pc2p->c2 = (countT)postr ;
/*N1D*/                                                 pc2p->c1 = costr ;
/*N1D*/                                             {
/*N1D*/                                             if( pc2p )
/*N1D*/                                             newF( tinP , LF , pc2p ) ; ___( pc2p ) ;
/*N1D*/                                             ZE( count2S* , pc2p ) ;
/*N1D*/
/*N1D*/                                             countT costr = strMakeF( tinP , postr , tRepeatImage ) ; ___( postr ) ;
/*N1D*/                                             ZE( osTextT* , postr ) ;
/*N1D*/                                         {
/*N1D*/                                         if( tRepeatImage.csF( tinP ) )
/*N1D*/                                     {
/*N1D*/                                     stackC stImage( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_count2S ) ;
/*N1D*/                                     ZE( countT , costAll ) ;
/*N1D*/
/*N1D*/                                     if( tJobQueueRepeat.csF( tinP ) ) tRepeatImage = T("\r\n{repeat: ")+tJobQueueRepeat+T("}\r\n") ;
/*N1D*/                                     TN( tRepeatImage , "" ) ;
/*N1D*/                                 {
/*N1D*/                                 if( tJobQueueFolder.csF( tinP ) )
/*N1D*/                             {
/*N1D*/                             else if( tKeyLevel1 == tKeyDoJobs )
/*N1D*/                             }
/*N1D*/                                 }
/*N1D*/                                     tTrace = tn ;
/*N1D*/                                     traceF( tinP , T("trace: ")+tTrace ) ;
/*N1D*/                                 {
/*N1D*/                                 if( idModeP == ifcIDmODEeTHERsOIL_REPORT )
/*N1D*/                             {
/*N1D*/                             else if( tKeyLevel1 == tKeyTrace )
/*N1D*/                             }
/*N1D*/                                 }
/*N1D*/                                     traceF( tinP , T("step: [idStepSoil]:    ")+TF2(idStep,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N1D*/                                     countT idStep = 1 + incv02AM( home.idStepSoil ) ;
/*N1D*/                                     homeS& home = homeS::homeIF() ;
/*N1D*/                                 {
/*N1D*/                                 if( idModeP == ifcIDmODEeTHERsOIL_REPORT )
/*N1D*/                             {
/*N1D*/                             else if( tKeyLevel1 == tKeyStep )
/*N1D*/                             }
/*N1D*/                                 }
/*N1D*/                                     waitStepModulo1 = waitStepModulo2 = waitStepRemainder1 = waitStepRemainder2 = 0 ;
/*N1D*/
/*N1D*/                                     }
/*N1D*/                                         traceF( tinP , T(bNapped?"waitstep: waiting ended [idStepSoil,waitStepModulo1,waitStepRemainder1,waitStepModulo2,waitStepRemainder2]:    ":"waitstep: did not wait  [idStepSoil,waitStepModulo1,waitStepRemainder1]:    ")+TF2(home.idStepSoil,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepModulo1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepRemainder1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepModulo2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepRemainder2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N1D*/
/*N1D*/                                         }
/*N1D*/                                             ++ s ; etPrime.osSleepF( tinP , TOCK ) ;
/*N1D*/
/*N1D*/                                             }
/*N1D*/                                                 bNapped = 1 ;
/*N1D*/                                                 traceF( tinP , T("waitstep: waiting begun [idStepSoil,waitStepModulo1,waitStepRemainder1,waitStepModulo2,waitStepRemainder2]:    ")+TF2(home.idStepSoil,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepModulo1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepRemainder1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepModulo2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepRemainder2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N1D*/                                             {
/*N1D*/                                             if( !bNapped )
/*N1D*/                                         {
/*N1D*/                                         while( !etPrime && ( home.idStepSoil % waitStepModulo1 != waitStepRemainder1 || ( waitStepModulo2 > 1 && home.idStepSoil % waitStepModulo2 == waitStepRemainder2 ) ) )
/*N1D*/
/*N1D*/                                         // 01   4              B3
/*N1D*/                                         // 01   2              B2
/*N1D*/                                         // 01   0              B1
/*N1D*/                                         // 6    4    01   4    A3
/*N1D*/                                         // 6    2    01   2    A2
/*N1D*/                                         // 6    0    01   0    A1
/*N1D*/                                                                     // A1/A2/A3 CYCLE, EXCEPT THAT OCCASIONALLY B1/B2/B3 ARE DONE INSTEAD (A3 CAN BE A NULL ACTION)
/*N1D*/
/*N1D*/                                         // 01   4              B3
/*N1D*/                                         // 01   2              B2
/*N1D*/                                         // 01   0              B1
/*N1D*/                                         // 4    2    01   2    A2
/*N1D*/                                         // 4    0    01   0    A1
/*N1D*/                                                                     // A1/A2 ALTERNATE, EXCEPT THAT OCCASIONALLY B1/B2/B3 ARE DONE INSTEAD (WHENEVER B3 IS ACTIVE, A1 WILL ALSO BE ACTIVE)
/*N1D*/
/*N1D*/                                                // 01   2              B2
/*N1D*/                                         // 01   0              B1
/*N1D*/                                         // 4    2    01   2    A2
/*N1D*/                                         // 4    0    01   0    A1
/*N1D*/                                                                     // A1/A2 ALTERNATE, EXCEPT THAT OCCASIONALLY B1/B2 ARE DONE INSTEAD
/*N1D*/
/*N1D*/                                         // MOD1 REM1 MOD2 REM2 STEP
/*N1D*/                                         // EXAMPLES
/*N1D*/
/*N1D*/                                         // DISCUSSION:  INTENTION IS TO SUPPORT NORMAL CYCLING WITH OCCASIONAL EXTENDED STEPS
/*N1D*/
/*N1D*/                                         // MOD1:4 REM1:0 MOD2:01 REM2:0 - SLEEP IF REM1 NOT 0 OR IF REM2 IS 0 (PASSES EVERY 4TH EXCEPT EVERY 01TH)
/*N1D*/                                         // MOD1:4 REM1:0                - SLEEP IF REM1 NOT 0                 (PASSES EVERY 4TH)
/*N1D*/                                         // EXAMPLES:
/*N1D*/
/*N1D*/                                         // MODULO2: SLEEP IF     HIT  (MODULO2 IS OPTIONAL AND ACTS ONLY TO SUPPRESS THE "GO AHEAD" OF MODULO1)
/*N1D*/                                         // MODULO1: SLEEP IF NOT HIT
/*N1D*/
/*N1D*/                                         etherC& etPrime = etPrimeIF( tinP ) ;
/*N1D*/                                         ZE( boolT , bNapped ) ;
/*N1D*/                                         TN( tb4 , "    " ) ;
/*N1D*/
/*N1D*/                                         sleepC s( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/
/*N1D*/                                         homeS& home = homeS::homeIF() ;
/*N1D*/                                     {
/*N1D*/                                     else if( waitStepModulo1 > 1 && ( !waitStepModulo2 || waitStepModulo2 > 1 ) )
/*N1D*/                                     }
/*N1D*/                                         traceF( tinP , T("waitstep: napped  [idStepSoil,waitStepNapTocks]:    ")+TF2(home.idStepSoil,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepNapTocks,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N1D*/                                         ++ s ; etPrime.osSleepF( tinP , waitStepNapTocks * TOCK ) ;
/*N1D*/                                         etherC& etPrime = etPrimeIF( tinP ) ;
/*N1D*/                                         sleepC s( tinP , TAG( TAGiDnULL ) ) ;
/*N1D*/                                         traceF( tinP , T("waitstep: napping [idStepSoil,waitStepNapTocks]:    ")+TF2(home.idStepSoil,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepNapTocks,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
/*N1D*/                                         TN( tb4 , "    " ) ;
/*N1D*/                                         homeS& home = homeS::homeIF() ;
/*N1D*/                                     {
/*N1D*/                                     if( waitStepNapTocks )
/*N1D*/                                 {
/*N1D*/                                 if( idModeP == ifcIDmODEeTHERsOIL_REPORT )
/*N1D*/                             {
/*N1D*/                             if( tKeyLevel1 == tKeyWaitStep )
                                {
                                case 1 :
                            {
                            switch( scNest -- )
                        {
                        while( cDown -- )
                    {
                    if( cDown )
                    ZE( boolT , bDone ) ;

                    }
                        if( !strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , tm2 , psttWord , 0 , 1 , flSTRiDaNY_NOT ) ) cDown = psttWord->idAdam ; // IF psttWord ONLY CONTAINS '}'
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        countT idf = 1 ;
                    {
                    ZE( countT , cDown ) ; // THIS IS DONE TO SUPPORT OCCURRANCES LIKE "}}}}}" ; SUPPORT FOR "{{{{{{" IS NOT NEEDED BECAUSE SUCH IS ILLEGAL IN THE INPUT STREAM

                    }
                        countT foo = 2 ;
                    {
                    if( idString == 3 )

                    //traceF( tinP , T("\r\nword handler [idMode,idString,word]: ")+TF2(idModeP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(idString,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    >")+T(psttWord)+T("<") ) ;
                    //CONoUTrAW9( "[idString]: " , idString , "        [scNest]: " , scNest , "        [bAllowLevel1]: " , bAllowLevel1 , "        [bAllowLevel2]: " , bAllowLevel2 , "\r\n" ) ;
                    idString ++ ;

                    //}
                    //    }
                    //        strokeF( tinP , T("word:\r\n\"")+T(psttWord)+T("\"\r\n") ) ;
                    //        strokeF( tinP , T("\r\n\r\n[idWord]: ")+TF2(idWord,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
                    //    {
                    //    //if( idWord > 0x140 )
                    //    //if( strIdF( tinP , tBug , psttWord ) )
                    //
                    //    ++ idWord ;
                    //{
                    //if( idModeP == ifcIDmODEeTHERsOIL_LINT )

                    }
                        if( bTrace && !( cRemaining % TUCK ) ) traceF( tinP , T("etherSoilF / handling a word, with ")+TF2(cRemaining,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" words still awaiting") ) ;
                        countT cRemaining = soulWords ;
                    {

                    soulWords >> psttWord ; ___( psttWord ) ;
                    ZE( strokeS* , psttWord ) ;

                    //LOGrAW3( "default soil processing [soulWords]: " , soulWords , " /+\r\n" ) ;
                {
                while( !bQuitP && soulWords )

                }
                    delF( tinP , psttm ) ;
                    //traceF( tinP , T("set 2 [tArchive]: ")+tArchive ) ;
                    tArchive = T(psttm) ;
                    diskMapFileNameF( tinP , psttm , T("///ideafarm/IdeaFarm (tm)/")+( tUserOverride.csF( tinP ) ? tUserOverride : tUser )+T("/Drop Files Here To Archive/") ) ; ___( psttm ) ;
                    ZE( strokeS* , psttm ) ;
                {
                else
                }
                    //traceF( tinP , T("set 1 [tArchive]: ")+tArchive ) ;
                    tArchive = tReportsSource ;
                {
                if( tReportsSource.csF( tinP ) )
                TN( tArchive , "" ) ;

                TN( tBug , "and scatter it over the years" ) ;
                ZE( countT , idWord ) ;//U::

                ZE( countT , sizeBytes ) ;
                ZE( countT , waitStepNapTocks   ) ;
                ZE( countT , waitStepRemainder2 ) ;
                ZE( countT , waitStepRemainder1 ) ;
                ZE( countT , waitStepModulo2 ) ;
                ZE( countT , waitStepModulo1 ) ;

                TN( tValueKtrModeOther       , "other"          ) ;
                TN( tValueKtrModeIpdos       , "ipdos"          ) ;
                TN( tValueKtrModePay         , "pay"            ) ;
                TN( tValueKtrModeWo          , "wo"             ) ;
                TN( tValueKtrModeArchive     , "archive"        ) ;
                TN( tValueKtrModeEssays      , "essays"         ) ;
                TN( tValueKtrModeNews        , "news"           ) ;
                TN( tValueKtrModeBundle      , "bundle"         ) ;
                TN( tValueKtrModeHooks       , "hooks"          ) ;
                TN( tValueKtrModeTutorials   , "tutorials"      ) ;
                TN( tValueKtrModePaid        , "paid"           ) ;
                TN( tValueKtrModeRoot        , "root"           ) ;

                TN( tTrace , "" ) ;
                TN( tSettingsKeyPrefix , "" ) ;
                ZE( sCountT , time2TranscriptLath ) ;
                ZE( countT , time1TranscriptLath ) ;
                ZE( countT , idTranscriptLath ) ;
                flagsT flagsReport  = flETHERsOILrEPORT_null ;
                flagsT flagsPutFile = flBRANCHspUTfILEf_null ;
                flagsT flagsLoad    = flBRANCHslOADf_null ;
                soulC soulBody( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.body" ) ; // IF LINT THEN RETAINS WHITE SPACE AND MIGHT HAVE ERROR FLAG MARKS ; IF REPORT THEN OMITS WHITE SPACE OTHER THAN INDENT BLANKS
                soulC soulValue( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.value" ) ; // USED TO ELIMINATE 02 BIT ADDRESS SPACE CAPACITY CONSTRAINT FOR HUGE VALUE STRINGS
                stackC stFileType(   tinP , *this , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE  , ifcSTACKtYPE_PTR_strokeS ) ; // FORMAT EXAMPLE: mp3
                stackC stTimeMinMax( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY | flSTACKc_BLOB , 2 * sizeof( strokeS* ) ) ; // FORMAT EXAMPLE: 20130711@1401 20130711@1401
                countT idKtrMode = ifcIDmODEpUTfILE_OTHER ;
                TN( tMemory         , "" ) ;
                TN( tNameSpace      , "" ) ;
                TN( tHtmlHead       , "" ) ;
                TN( tHtmlBodySuffix , "" ) ;
                TN( tHtmlBodyPrefix , "" ) ;
                TN( tHtmlFolder , "" ) ;
                TN( tReportsSource , "" ) ;
                TN( tReportsFolder , "" ) ;
                TN( tRenameToHashFolder , "" ) ;
                TN( tJobQueueRepeat , "" ) ;
                TN( tJobQueueFolder , "" ) ;
                TN( tFolderTo , "" ) ;
                TN( tFolderFrom , "" ) ;
                TN( tFolder , (strokeS*)tFolderDefault ) ;
                TN( tFolderDefault , "///ideafarm/IdeaFarm " "(tm)/Pick Up SOIL (tm) Reply Text Here/" ) ;
                TN( tFlagFragNote , "fragnote" ) ;
                TN( tFlagBeep  , "beep" ) ;
                TN( tFlagNoZip , "noZip" ) ;
                TN( tNoRef , "noReferences" ) ;
                TN( tUserOverride , "" ) ;
                TN( tUser , thirdC::postUserNameIF() ) ;
                TN( tFile , "" ) ;
                TN( tbcrb , " \r\n" ) ; tbcrb += tBreakMark ;
                TN( tStarDotData , "*.data" ) ;
                TN( tStar , "*" ) ;
                TN( tcr , "\r\n" ) ;
                ZE( boolT    , bAllowLevel3   ) ;
                ZE( boolT    , bAllowLevel2   ) ;
                boolT bAllowLevel1 = 1 ;
                ZE( countT   , idString       ) ; //TO FIND A BUG
                ZE( countT   , cents          ) ;
                ZE( countT   , csttMaxJournal ) ;
                ZE( stackC*  , pStJournal     ) ;
                ZE( countT   , csttMaxLog     ) ;
                ZE( stackC*  , pStLog         ) ;
                ZE( countT   , csttMaxDo      ) ;
                ZE( stackC*  , pStDo          ) ;
                ZE( switchC* , pSwTimeMax     ) ;
                ZE( switchC* , pSwSwTimeCard  ) ;
                ZE( switchC* , pSwSwBuy       ) ;
                ZE( strokeS* , psttLeverCard      ) ; //MUST ALWAYS CONTAIN A POINTER RETURNED BY CASTING tLeverCard (TO ENSURE THAT IT DOES NOT CONTAIN A ZOMBIE)
                TN( tLeverCard , "" ) ;
                ZE( strokeS* , psttLeverBuy      ) ; //MUST ALWAYS CONTAIN A POINTER RETURNED BY CASTING tLeverBuy (TO ENSURE THAT IT DOES NOT CONTAIN A ZOMBIE)
                TN( tLeverBuy , "" ) ;
                ZE( countT  , offStrongCard ) ;
                ZE( sCountT , timeCard2  ) ; // TIME OF LATH CHANGE OF ACTIVITY
                ZE( countT  , timeCard1  ) ; // TIME OF LATH CHANGE OF ACTIVITY
                ZE( countT  , offStrong ) ;
                ZE( sCountT , time2      ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( countT  , time1      ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( sCountT , date2      ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( countT  , date1      ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( countT  , date       ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( countT  , month      ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( countT  , year       ) ; //USED BY LINT TO VALIDATE DATE AND TIME VALUES
                ZE( boolT   , bDown      ) ;
                ZE( sCountT , scNest     ) ; // 0: WHITE SPACE BETWEEN RECORDS ; 1: NORMAL VALUE WITHIN A RECOD ; 2: WITHIN A BRACKET PAIR THAT IS WITHIN A RECORD
            {
            if( !POOP )

            }
                }
                    break ;
                {
                case ifcIDmODEeTHERsOIL_QUERYvALUES :
                }
                    break ;
                {
                case ifcIDmODEeTHERsOIL_TRIM :
                }
                    break ;
                {
                case ifcIDmODEeTHERsOIL_LINT :
            {
            switch( idModeP )
            TN( tKeyLevel3  , "" ) ;
            TN( tKeyLevel2  , "" ) ;
            TN( tKeyLevel1  , "" ) ;
            TN( tColon      , ":" ) ;

            // THE REMAINING CHARACTERS CAN BE ANY ASCII VALUE INCLUDING NULL
            // WOTH CHARACTER MUST NOT BE WHITE SPACE
            //
            // VALUE SPECIFICATION
            //
            // ":"
            //
            // DELIMITER SPECIFICATION
            //
            // WO OR MORE OF [a-z,0-9,_]
            //
            // KEY SPECIFICATION
            //
            // VALUE
            // DELIMITER
            // KEY
            //
            // RECORD SPECIFICATION
            //
            // "\ " REPRESENTS HARD SPACE " " (A SPACE THAT IS NOT TO BE REMOVED BY TRIMMING OR COMPRESSING WHITE SPACE)
            // "\}" REPRESENTS "}"
            // "\{" REPRESENTS "{"
            // "\\" REPRESENTS "\"
            //
            // THE FOLLOWING ESCAPE SEQUENCES ARE USED TO REPRESENT CHARACTERS THAT WOULD OTHERWISE BE TREATED AS RECORD DELIMITERS
            // ANY ASCII CHARACTER, INCLUDING NULL, IS ALLOWED WITHIN A RECORD
            // RECORDS MAY BE NESTED, BUT NESTED RECORDS ARE NOT OBEYED; THEY ARE SIMPLY PASSED THROUGH AS LITERALS WITHIN THE VALUE
            // EACH RECORD BEGINS IMMEDIATELY AFTER A '{' AND ENDS IMMEDIATELY BEFORE A '}'
            // THIS STREAM CONSISTS OF RECORDS SEPARATED BY WHITE SPACE
            // THE FILE IS A STREAM OF ASCII CHARACTERS
            // INPUT FILE SPECIFICATION

            traceF( tinP , T("etherSoilF / setting up to handle ")+TF2(cWords,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" words") ) ;

            countT cWords = strWordsF( tinP , soulWords , soulInP , sttq , tMarks , F(flagsP) & flETHERsOILf_CONSUMEiNPUT ? flSTRwORDS_DELIMITERS|flSTRwORDS_SPLITaTmARK|flSTRwORDS_CONSUMEiNPUT : flSTRwORDS_DELIMITERS|flSTRwORDS_SPLITaTmARK ) ;
            soulC soulWords( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.words" ) ;

            traceF( tinP , T("etherSoilF / loading soulWords") ) ;

            switchC swSettings( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverSettings ) ;
            ZE( strokeS* , psttzLeverSettings ) ;

            switchC swReplace( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverReplace ) ;
            ZE( strokeS* , psttzLeverReplace ) ;

            switchStackC swsBudget( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverBudget , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO | flSTACKc_ALLOWzE , ifcSTACKtYPE_measureT ) ; // EACH PLATE IS INTERPRETED AS A NUMBER OF IFC HOURS (EACH IFC HOUR IS 90 CONVENTIONAL MINUTES)
            ZE( strokeS* , psttzLeverBudget ) ;

            switchStackC swsAssign( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverAssign , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
            ZE( strokeS* , psttzLeverAssign ) ;

            stackC stOkCard( tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
            stackC stOkBuy(  tinP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

            /*const*/ countT offKeyOkTime = 0x39 ;
            /*const*/ countT offKeyOkBuy  = 0x02 ;

            } ;
                tKeyZip                     ,           // 14
                tKeyWaitStep                ,           // 04
                tKeyVendor                  ,           // f3
                tKeyValidate                ,           // e3
                tKeyUser                    ,           // d3
                tKeyTimeRange               ,           // c3
                tKeyTrace                   ,           // b3
                tKeyTimecard                ,           // a3
                tKeyTime                    ,           // 93
                tKeyStep                    ,           // 83
                tKeySplit                   ,           // 73
                tKeySource                  ,           // 63
                tKeySizeBytes               ,           // 53
                tKeySettings                ,           // 43
                tKeySell                    ,           // 33
                tKeyReport                  ,           // 23
                tKeyReplacements            ,           // 13
                tKeyReplace                 ,           // 03
                tKeyRepeat                  ,           // f2
                tKeyRenameToHash            ,           // e2
                tKeyRemainder2              ,           // d2
                tKeyRemainder1              ,           // c2
                tKeyNull                    ,           // b2
                tKeyNapTocks                ,           // a2
                tKeyNameSpace               ,           // 92
                tKeyMoney                   ,           // 82
                tKeyModulo2                 ,           // 72
                tKeyModulo1                 ,           // 62
                tKeyMode                    ,           // 52
                tKeyMemory                  ,           // 42
                tKeyMath                    ,           // 32
                tKeyLog                     ,           // 22
                tKeyKVF                     ,           // 12
                tKeyKV                      ,           // 02
                tKeyKtr                     ,           // f1
                tKeyKt                      ,           // e1
                tKeyJournal                 ,           // d1
                tKeyJoin                    ,           // c1
                tKeyJobQueue                ,           // b1
                tKeyIPDOS                   ,           // a1
                tKeyInspectFileNames        ,           // 91
                tKeyInclude                 ,           // 81
                tKeyHtmlHead                ,           // 71
                tKeyHtmlBodySuffix          ,           // 61
                tKeyHtmlBodyPrefix          ,           // 51
                tKeyHtmlFolder              ,           // 41
                tKeyFolderTo                ,           // 31
                tKeyFolderFrom              ,           // 21
                tKeyFolder                  ,           // 11
                tKeyFlags                   ,           // 01
                tKeyFilter                  ,           // f0
                tKeyFileType                ,           // e0
                tKeyFile                    ,           // d0
                tKeyEdit                    ,           // c0
                tKeyDoJobs                  ,           // b0
                tKeyDo                      ,           // a0
                tKeyDate                    ,           // 90
                tKeyCustomer                ,           // 80
                tKeyComment                 ,           // 70
                tKeyCloudView               ,           // 60
                tKeyCloud                   ,           // 50
                tKeyClosed                  ,           // 40
                tKeyCalculate               ,           // 30
                tKeyBuy                     ,           // 20
                tKeyBudget                  ,           // 10
                tKeyBody                    ,           // 00
            {
            const strokeS* ppsttOkKey[] =

            TN( tKeyZip                     , "zip"                         ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyWaitStep                , "waitstep"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyVendor                  , "vendor"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyValidate                , "validate"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyUser                    , "user"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyTimeRange               , "timerange"                   ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyTrace                   , "trace"                       ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyTimecard                , "timecard"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyTime                    , "time"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyStep                    , "step"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeySplit                   , "split"                       ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeySource                  , "source"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeySizeBytes               , "sizebytes"                   ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeySettings                , "settings"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeySell                    , "sell"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyReport                  , "report"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyReplacements            , "replacements"                ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyReplace                 , "replace"                     ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyRepeat                  , "repeat"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyRenameToHash            , "renametohash"                ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyRemainder2              , "remainder2"                  ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyRemainder1              , "remainder1"                  ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyNull                    , "null"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyNapTocks                , "naptocks"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyNameSpace               , "namespace"                   ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyMoney                   , "money"                       ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyModulo2                 , "modulo2"                     ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyModulo1                 , "modulo1"                     ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyMode                    , "mode"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyMemory                  , "memory"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyMath                    , "math"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyLog                     , "log"                         ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyKVF                     , "kvf"                         ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyKV                      , "kv"                          ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyKtr                     , "ktr"                         ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyKt                      , "kt"                          ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyJournal                 , "journal"                     ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyJoin                    , "join"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyJobQueue                , "jobqueue"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyIPDOS                   , "ipdos"                       ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyInspectFileNames        , "inspectfilenames"            ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyInclude                 , "include"                     ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyHtmlHead                , "htmlhead"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyHtmlBodySuffix          , "htmlbodysuffix"              ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyHtmlBodyPrefix          , "htmlbodyprefix"              ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyHtmlFolder              , "htmlfolder"                  ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFolderTo                , "folderto"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFolderFrom              , "folderfrom"                  ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFolder                  , "folder"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFlags                   , "flags"                       ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFilter                  , "filter"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFileType                , "filetype"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyFile                    , "file"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyEdit                    , "edit"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyDoJobs                  , "dojobs"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyDo                      , "do"                          ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyDate                    , "date"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyCustomer                , "customer"                    ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyComment                 , "comment"                     ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyCloudView               , "cloudview"                   ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyCloud                   , "cloud"                       ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyClosed                  , "closed"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyCalculate               , "calculate"                   ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyBuy                     , "buy"                         ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyBudget                  , "budget"                      ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS
            TN( tKeyBody                    , "body"                        ) ; // CS:CODEsYNC: ELEMENTS OF ppsttOkKey IMMEDIATELY FOLLOWING THESE DECLARATIONS

            TN( tPlus   , "+" ) ;
            TN( tAssign , "=" ) ;
            __( tFlag3.csF( tinP ) > tFlag2.csF( tinP ) ) ;               // IF WANT TO BREAK THIS THEN EDIT THE cstte EXPRESSION TO USE tFlag3
            TN( tm101   , ""        ) ; tm101 = T("")+S2(0x101,sc_MARK) ; //USED TO MARK WHERE NESTING LEVEL BECOMES GREATER THAN 1
            TN( tm001   , ""        ) ; tm001 = T("")+S2(0x100,sc_MARK) ; //USED TO MARK WHERE NESTING LEVEL BECOMES NEGATIVE
            TN( tFlag3 , "(>)"     ) ;
            TN( tFlag2 , "(<)"     ) ;
            TN( tFlag1 , "(?)"     ) ;
            TN( tBlack , TwHITEanu ) ;
            TN( tWhite , TbLACK    ) ;
            TN( tBreakMark , ""    ) ; tBreakMark = tn+S2(sa_MARKsYSTEMbREAK,sc_MARKsYSTEM) ;
            TN( tMarks , ""        ) ; tMarks = tm1+tm2 ; // S2(sa_MARKsYSTEMbREAK,sc_MARKsYSTEM) WILL ALSO APPEAR AS A DELIMITER IF THE SOURCE INPUT CONTAINS '|'; THIS IS A CONSEQUENCE OF strWordsF OBEYING THE flSTRwORDS_SPLITaTmARK FLAG
            TN( tm21   , ""        ) ; tm21   = tm2+tm1 ;
            TN( tm4    , ""        ) ; tm4    = T("")+S2(4,sc_MARK) ;
            TN( tm3    , ""        ) ; tm3    = T("")+S2(3,sc_MARK) ;
            TN( tm2    , ""        ) ; tm2    = T("")+S2(2,sc_MARK) ;
            TN( tm1    , ""        ) ; tm1    = T("")+S2(1,sc_MARK) ;
            TN( tn     , ""        ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( countT , cFlag23 ) ;

            /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 2") ) ;
        {
        default :
        }
            break ;

            /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / -") ) ;
            }
                ///**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / loop / -") ) ;
                delF( tinP , psttp ) ;
                ///**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / loop / 1") ) ;

                if( !bQuitP ) soulOutP << psttp ;

                ///**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / loop / 2") ) ;
                }
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tmb   , tBar  , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // DECODE ALL |
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm4   , tcs   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // DECODE ALL ]
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm3   , tos   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // DECODE ALL [
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm2   , tc    , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // DECODE ALL }
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm1   , to    , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // DECODE ALL {
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tBar  , tbBar , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ESCAPE THE LITERAL |
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tcs   , tbcs  , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ESCAPE THE LITERAL ]
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tos   , tbos  , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ESCAPE THE LITERAL [
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tc    , tbc   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ESCAPE THE LITERAL }
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , to    , tbo   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ESCAPE THE LITERAL {
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tb    , tbb   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ESCAPE THE LITERAL BACKSLASH
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm5   , tbs   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // DECODE ALL LITERAL SPACE ' '
                {
                else
                }
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tmc   , tBar  , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // SHOW ALL LITERAL |
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tma   , tcs   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // SHOW ALL LITERAL ]
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm9   , tos   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // SHOW ALL LITERAL [
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm8   , tc    , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // SHOW ALL LITERAL }
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm7   , to    , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // SHOW ALL LITERAL {
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tm6   , tb    , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // SHOW ALL LITERAL BACKSLASH
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tBar  , tmb   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ENCODE ALL |
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tcs   , tm4   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ENCODE ALL ]
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tos   , tm3   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ENCODE ALL [
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tc    , tm2   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ENCODE ALL }
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , to    , tm1   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ENCODE ALL {
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbBar , tmc   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // HIDE ALL LITERAL |
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbcs  , tma   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // HIDE ALL LITERAL ]
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbos  , tm9   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // HIDE ALL LITERAL [
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbc   , tm8   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // HIDE ALL LITERAL }
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbo   , tm7   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // HIDE ALL LITERAL {
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbb   , tm6   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // HIDE ALL LITERAL BACKSLASH
                    if( !bQuitP ) { strReplaceF( tinP , psttp , 0 , tbs   , tm5   , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttp ) ; } // ENCODE ALL LITERAL SPACE ' '
                {
                if( bNative )
                ///**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / loop / 3") ) ;

                soult1 >> psttp ; ___( psttp ) ;

                ZE( strokeS* , psttp ) ;
                ///**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / loop / +") ) ;

                }
                    if( /*bTrace &&*/ !( cRemaining % TUCK ) ) traceF( tinP , T(bNative?"etherSoilF / native from ascii / handling a word, with ":"etherSoilF / ascii from native / handling a word, with ")+TF2(cRemaining,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" words still awaiting") ) ;
                    countT cRemaining = soult1 ;
                {
            {
            while( !bQuitP && soult1 )
            /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / 1") ) ;
            //LOGrAW( "ASCIIfROMnATIVE or NATIVEfROMaSCII\r\n" ) ;

            boolT bNative = idModeP == ifcIDmODEeTHERsOIL_NATIVEfROMaSCII ;

            strFuseF( tinP , soult1 , soulInP , 0 , S1C( '\\' ) , T("[]") ) ; //U::ADD THIS API TO etherC
            soulC soult1( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.t1" ) ;
            /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / 2") ) ;

            TN( tmc   , ""     ) ; tmc = T("")+S2(0x0c,sc_MARK) ; //LITERAL BAR: tbBar -> tmc
            TN( tmb   , ""     ) ; tmb = T("")+S2(sa_MARKsYSTEMbREAK,sc_MARKsYSTEM) ; //BREAK      : tBar  -> tmb
            TN( tma   , ""     ) ; tma = T("")+S2(0x0a,sc_MARK) ;
            TN( tm9   , ""     ) ; tm9 = T("")+S2(0x09,sc_MARK) ;
            TN( tm8   , ""     ) ; tm8 = T("")+S2(0x08,sc_MARK) ;
            TN( tm7   , ""     ) ; tm7 = T("")+S2(0x07,sc_MARK) ;
            TN( tm6   , ""     ) ; tm6 = T("")+S2(0x06,sc_MARK) ;
            TN( tm5   , ""     ) ; tm5 = T("")+S2(0x05,sc_MARK) ;
            TN( tm4   , ""     ) ; tm4 = T("")+S2(0x04,sc_MARK) ;
            TN( tm3   , ""     ) ; tm3 = T("")+S2(0x03,sc_MARK) ;
            TN( tm2   , ""     ) ; tm2 = T("")+S2(0x02,sc_MARK) ;
            TN( tm1   , ""     ) ; tm1 = T("")+S2(0x01,sc_MARK) ;
            TN( tbBar , "\\|"  ) ;
            TN( tbs   , "\\ "  ) ;
            TN( tbcs  , "\\]"  ) ;
            TN( tbos  , "\\["  ) ;
            TN( tbc   , "\\}"  ) ;
            TN( tbo   , "\\{"  ) ;
            TN( tbb   , "\\\\" ) ;
            
            // END OF RESERVED STROKES
            TN( tBar  , "|"    ) ;
            TN( tcs   , "]"    ) ;
            TN( tos   , "["    ) ;
            TN( tc    , "}"    ) ;
            TN( to    , "{"    ) ;
            TN( tb    , "\\"    ) ;
            // RESERVED STROKES (THESE STROKE VALUES CONTROL THE INTERPRETATION OF IdeaFarm (tm) SOIL INPUT
            //CS:CODEsYNC: 360021c1 360021c1

            //
            //      \}          }
            //      \{          {
            //      \\          \        x
            //
            //      \[space]    m3
            //      }           m2
            //      {           m1
            //
            //      BEFORE      AFTER
            //
            // ASCII TO NATIVE
            /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE ifcIDmODEeTHERsOIL_NATIVEfROMaSCII / +") ) ;
        {
        case ifcIDmODEeTHERsOIL_NATIVEfROMaSCII :
        case ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE :
        }
            break ;

            //LOGrAW( "etherSoilF / PREPAREsOURCE / 0\r\n" ) ;
            }
                //LOGrAW( "etherSoilF / PREPAREsOURCE / 1\r\n" ) ;
                }
                    //LOGrAW( "etherSoilF / PREPAREsOURCE / 2\r\n" ) ;
                    delF( tinP , psttElementLag ) ;
                    //NOT NEEDED SINCE I AM DONE: UPD8INDENT( csttIndent , psttElementLag )
                    //traceF( tinP , T("out07: >>>>")+T(psttElementLag)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                    soulOutP << psttElementLag ; //************************************************************************************************************
                    //LOGrAW( "etherSoilF / PREPAREsOURCE / 3\r\n" ) ;
                {
                if( psttElementLag )
                //LOGrAW( "etherSoilF / PREPAREsOURCE / 4\r\n" ) ;

                }
                    csttDone += csttNow ;
                    delF( tinP , psttp ) ;
                    //LOGrAW( "etherSoilF / PREPAREsOURCE / 5\r\n" ) ;

                    }
                        //LOGrAW( "etherSoilF / PREPAREsOURCE / 6\r\n" ) ;
                        delF( tinP , psttSnip ) ;
                        UPD8INDENT( csttIndent , psttSnip )
                        //traceF( tinP , T("out06: >>>>")+T(psttSnip)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                        soulOutP << psttSnip ; //************************************************************************************************************
                        strSubstringF( tinP , psttSnip , idf2 , idl2 , psttp ) ; ___( psttSnip ) ;
                        ZE( strokeS* , psttSnip ) ;
                        ZE( countT , idl2 ) ;
                        countT idf2 = idfNextOut ;
                        //LOGrAW( "etherSoilF / PREPAREsOURCE / 7\r\n" ) ;
                    {
                    if( idfNextOut )
                    //LOGrAW( "etherSoilF / PREPAREsOURCE / 8\r\n" ) ;

                    }
                        }
                            idlElement = idfElement = 0 ;

                            //LOGrAW( "etherSoilF / PREPAREsOURCE / 9\r\n" ) ;
                            }
                                }
                                    //LOGrAW( "etherSoilF / PREPAREsOURCE / a\r\n" ) ;
                                                     psttElement = 0 ;
                                    psttElementLag = psttElement ;
                                    delF( tinP , psttElementLag ) ;  // WILL SILENTLY DISCARD PART OF AN ELEMENT THAT SPANS THREE PIECES, WHICH SHOULD BE IMPOSSIBLE (MAKE THE PIECES LARGER THAN THE LARGEST POSSIBLE LEGAL ELEMENT)
                                    idfNextOut = 0 ;
                                    //LOGrAW( "etherSoilF / PREPAREsOURCE / b\r\n" ) ;
                                {
                                else
                                }
                                    //LOGrAW( "etherSoilF / PREPAREsOURCE / c\r\n" ) ;
                                    delF( tinP , psttElement ) ;
                                    delF( tinP , psttok ) ;
                                    }
                                        //LOGrAW( "etherSoilF / PREPAREsOURCE / d\r\n" ) ;
                                        }
                                            //LOGrAW( "etherSoilF / PREPAREsOURCE / e\r\n" ) ;
                                            delF( tinP , psttv ) ;
                                            }
                                                //LOGrAW( "etherSoilF / PREPAREsOURCE / f\r\n" ) ;
                                                }
                                                    idfNextOut = idlElement < psttp->idAdam ? idlElement + 1 : 0 ;

                                                    else                 csttIndent += csttLathText ;
                                                    if( bDelimiterSeen ) csttIndent  = csttLathText ;
                                                    //UPDATE csttIndent

                                                    delF( tinP , psttPad ) ;
                                                    }
                                                        bDelimiterLath = bDelimiter ;
                                                        cbBuffered -= offEnd ;

                                                        }
                                                            for( countT offo = 0 ; offo < cbDo ; offo ++ ) postBuffer[ offo ] = postBuffer[ offo + offEnd ] ;
                                                            countT cbDo = cbBuffered - offEnd ;
                                                        {
                                                        else
                                                        }
                                                            thirdC::c_memcpyIF( tinP , postBuffer , postBuffer + offEnd , cbBuffered - offEnd ) ; // CANNOT BE USED TO MOVE SMALL DISTANCES OR TO BE MOVED "UPWARD" WITHIN OVERLAPPING MEMORY BUFFERS
                                                        {
                                                        if( offEnd >= sizeof( countT ) )

                                                        // -----------------------------------------------
                                                        // SHIFT LEFT THE REMAINING CONTENTS OF THE BUFFER
                                                        // -----------------------------------------------

                                                        }
                                                            delF( tinP , psttLine ) ;

                                                            }
                                                                //traceF( tinP , T("out05: >>>>")+tb+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                                                                soulOutP << (strokeS*)tb ;                                  // ELSE EMIT BLANK INSTEAD OF CRLF
                                                            {
                                                            else
                                                            }
                                                                //traceF( tinP , T("out04: >>>>")+T(psttPad)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                                                                //traceF( tinP , T("out03: >>>>")+T(psttLine)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                                                                soulOutP << psttPad ;
                                                                soulOutP << psttLine ;
                                                            {
                                                            else if( !strCompareF( tinP , psttok , tKeyObeyPreInclude ) )    // ELSE IF NOT SCRUBBING
                                                            }
                                                                //traceF( tinP , T("out02: >>>>")+T(psttLine)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                                                                soulOutP << psttLine ;
                                                                csttLathText = psttLine->idAdam ;
                                                            {
                                                            if( !bDelimiter )                                                // IF NOT DELIMITER (CRLF)

                                                            postBuffer[ offEnd ] = ostSave ;
                                                            strMakeFromOsTextF( tinP , psttLine , postBuffer + costSkip ) ; ___( psttLine ) ;
                                                            ZE( strokeS* , psttLine ) ;

                                                            }
                                                                }
                                                                    }
                                                                        if( !bLeadingBlanks && !bColonDone && postBuffer[ offi ] != ':' ) bColonDone     = 1 ;
                                                                        if(  bLeadingBlanks &&                postBuffer[ offi ] != ' ' ) bLeadingBlanks = 0 ;

                                                                        }
                                                                            default   : {                                                                   break ; }

                                                                            case '|'  : {                     postBuffer[ offi ] = '$' ;                    break ; }
                                                                            case ']'  :
                                                                            case '['  :
                                                                            case '}'  :
                                                                            case '{'  :
                                                                            case '\\' :
                                                                            //CS:CODEsYNC: 360021c1 360021c1

                                                                            case ':'  : { if( !bColonDone ) { postBuffer[ offi ] = '$' ; bColonDone = 1 ; } break ; }

                                                                            case ' '  : { if( bLeadingBlanks ) costSkip ++ ; break ; }
                                                                        {
                                                                        switch( postBuffer[ offi ] )
                                                                    {
                                                                    for( ; postBuffer[ offi ] ; offi ++ )
                                                                    ZE( countT , offi ) ;
                                                                    ZE( boolT , bColonDone  ) ;
                                                                    boolT bLeadingBlanks = 1 ;
                                                                {
                                                                // SMUDGE LEADING COLON ':' AND SKIP LEADING BLANKS
                                                                // THIS IS DONE TO PREVENT VOICE TO TEXT TRANSCRIPTIONS FROM PRESENTING INVALID OR UNINTENDED CONTROL INPUT TO THE KT PARSER
                                                            {
                                                            if( !bDelimiter && !strCompareF( tinP , psttok , tKeyObeyPreIncludeScrub1 ) )
                                                            ZE( countT , costSkip ) ;

                                                                              postBuffer[ offEnd ] = 0 ;
                                                            osTextT ostSave = postBuffer[ offEnd ] ;

                                                            // --------------------------------------------
                                                            // EMIT THE SNIP AT THE BEGINNING OF THE BUFFER
                                                            // --------------------------------------------
                                                        {
                                                        if( !bDelimiter || offEnd < cbBuffered ) // IF NOT THE TRAILING DELIMITER (IF ANY)

                                                        { BLAMMO ; } //U::EDIT TO EXAPAND THE BUFFER AND ITERATE
                                                        )
                                                            ( cbDoHi || cbDoLo )                // THERE'S MORE INPUT
                                                            &&
                                                            offEnd == cbBuffered                // DIDN'T FIND AN EOL IN THE BUFFER
                                                        (
                                                        if

                                                        else             while( offEnd < cbBuffered &&   postBuffer[ offEnd ] != '\r' && postBuffer[ offEnd ] != '\n'   ) offEnd ++ ;
                                                        if( bDelimiter ) while( offEnd < cbBuffered && ( postBuffer[ offEnd ] == '\r' || postBuffer[ offEnd ] == '\n' ) ) offEnd ++ ;
                                                        countT offEnd = 1 ;

                                                        if( !bDelimiterSeen && bDelimiter ) bDelimiterSeen = 1 ;
                                                        boolT bDelimiter = postBuffer[ 0 ] == '\r' || postBuffer[ 0 ] == '\n' ;

                                                        // -------------------------------------------------------------------
                                                        // FIND THE END OF THE SNIP THAT BEGINS AT THE BEGINNING OF THE BUFFER
                                                        // -------------------------------------------------------------------

                                                        }
                                                            if( cbDoLo > cbDoLoWas ) cbDoHi -- ;
                                                            cbDoLo -= cbRead ;
                                                            countT cbDoLoWas = cbDoLo ;

                                                            cbBuffered += cbWant ;
                                                            __( cbWant - cbRead ) ;
                                                            fileReadF( tinP , postBuffer + cbBuffered , cbWant , inFile ) ;
                                                            countT cbWant = cbRead ;
                                                        {
                                                        if( cbRead )

                                                        if( !cbDoHi && cbRead > cbDoLo ) cbRead = cbDoLo ;
                                                        countT cbRead = cbaBuffer - 1 - cbBuffered ; // THE HIGH BYTE IS RESERVED FOR A PATCHED NULL
                                                        osTextT* postBuffer = (osTextT*)(const osTextT*)aBuffer ;

                                                        // ------------------------------------------------------
                                                        // FILL THE BUFFER TO THE TOP (IF IT IS NOT ALREADY FULL)
                                                        // ------------------------------------------------------

                                                        if( bQuitP ) break ;
                                                    {
                                                    while( cbDoLo || cbDoHi || cbBuffered )  // EACH ITERATION EMITS WO SNIP (EITHER TEXT OR NEWLINE+PAD) TO soulOutP
                                                    ZE( countT , csttLathText ) ;
                                                    ZE( boolT , bDelimiterLath ) ;
                                                    ZE( boolT , bDelimiterSeen ) ;
                                                    ZE( countT , cbBuffered ) ;
                                                    countT cbDoHi = cbFileHi ;
                                                    countT cbDoLo = cbFileLo ;
                                                    TN( tb , " " ) ;

                                                    }
                                                        while( cDo -- ) strFuseF( tinP , psttPad , psttzb ) ;
                                                        countT cDo = csttIndent ;
                                                        strMakeF( tinP , psttPad , 0 , csttIndent ) ; ___( psttPad ) ;
                                                        strokeS* psttzb = tb ;
                                                    {
                                                    ZE( strokeS* , psttPad ) ;

                                                    aBuffer[ cbaBuffer - 1 ] ; // TOUCH THE LATH BYTE TO STIMULATE REALLOCATION IF NEEDED
                                                    arrayC aBuffer( tinP , 1 , cbaBuffer ) ;

                                                    const countT cbaBuffer = ( cbFileHi || cbFileLo > TOCK ? TOCK : cbFileLo ) + 1 ; // ALLOCATE FOR A TRAILING NULL THAT IS PATCHED IN

                                                    }
                                                        DEL( pInfo ) ;
                                                        cbFileHi = pInfo->cbUsedHigh ;
                                                        cbFileLo = pInfo->cbUsed ;
                                                        diskFileQueryF( tinP , pInfo , inFile ) ;
                                                        ZE( infoFileS* , pInfo ) ;
                                                    {
                                                    ZE( countT , cbFileHi ) ;
                                                    ZE( countT , cbFileLo ) ;
                                                    fileC inFile( tinP , psttv ) ;

                                                    // 
                                                    //  THIS CAN BE DONE USING arrayC
                                                    // APPROACH: USE AN OO POWER EXPANDABLE BUFFER TO READ UNTIL RECEIVE AN END OF LINE
                                                    // 
                                                    //  NO LIMIT TO TOTAL SIZE OF INPUT
                                                    //  NO LIMIT TO NUMBER OF LINES
                                                    //  NO LIMIT TO LINE LENGTH
                                                    // GOALS
                                                    // PUSH INPUT LINES INTO soulOutP WITHOUT INPUT CAPACITY CONSTRAINT

                                                    SCOOPS
                                                    //LOGrAW( "etherSoilF / PREPAREsOURCE / m\r\n" ) ;

                                                    cFlag1 ++ ;
                                                {
                                                IFsCRATCH
    
                                                //traceF( tinP , T("include: ")+T(psttv) ) ;
                                                strTrimF( tinP , psttv , 0 , 0 , T(TbLACK "\"")  ) ; ___( psttv ) ;
                                                //LOGrAW( "etherSoilF / PREPAREsOURCE / n\r\n" ) ;
                                            {
                                            if( psttv && psttv->idAdam )
                                            strSubstringF( tinP , psttv , idfok , sttq , sttClose , psttElement ) ; ___( psttv ) ;
                                            ZE( strokeS* , psttv ) ;
                                            //LOGrAW( "etherSoilF / PREPAREsOURCE / o\r\n" ) ;
                                        {
                                        if( idfok )
                                        //LOGrAW( "etherSoilF / PREPAREsOURCE / p\r\n" ) ;
                                    {
                                    )
                                        !strCompareF( tinP , psttok , tKeyObeyPreIncludeScrub1 )
                                        ||
                                        !strCompareF( tinP , psttok , tKeyObeyPreInclude )
                                    (
                                    if
                                    //LOGrAW( "etherSoilF / PREPAREsOURCE / q\r\n" ) ;

                                    //strokeF( tinP , T("okelement: >>>>")+T(psttok)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
    
                                    strSubstringF( tinP , psttok , idfok , sttq , sttColon , psttElement ) ; ___( psttok ) ;
                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                    countT idfok = 1 ;
                                    ZE( strokeS* , psttok ) ;
                                    //LOGrAW( "etherSoilF / PREPAREsOURCE / r\r\n" ) ;
                                {
                                if( idlElement ) // IF I HAVE A COMPLETE ELEMENT OF THE FORM "{preInclude: [fileName] }"
                                //LOGrAW( "etherSoilF / PREPAREsOURCE / s\r\n" ) ;
                                //LOGrAW( "etherSoilF / PREPAREsOURCE / t\r\n" ) ;
                            {
                            if( psttElement )
                            //LOGrAW( "etherSoilF / PREPAREsOURCE / u\r\n" ) ;

                            }
                                //LOGrAW( "etherSoilF / PREPAREsOURCE / v\r\n" ) ;

                                //strokeF( tinP , T("element (full or part): >>>>")+T(psttElement)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG

                                strSubstringF( tinP , psttElement , idfe , idle , psttp ) ; ___( psttElement ) ;
                                countT idle = idlElement ;
                                countT idfe = idfElement ;
                                //LOGrAW( "etherSoilF / PREPAREsOURCE / w\r\n" ) ;
                            {
                            if( idfElement )
                            ZE( strokeS* , psttElement ) ;
                            //LOGrAW( "etherSoilF / PREPAREsOURCE / x\r\n" ) ;
    
                            }
                                //LOGrAW( "etherSoilF / PREPAREsOURCE / y\r\n" ) ;
                                }
                                    delF( tinP , psttSnip ) ;
                                    UPD8INDENT( csttIndent , psttSnip )
                                    soulOutP << psttSnip ; //************************************************************************************************************
                                    //traceF( tinP , T("out01: >>>>")+T(psttSnip)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG

                                    //strokeF( tinP , T("before: >>>>")+T(psttSnip)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG

                                    strSubstringF( tinP , psttSnip , idf2 , idl2 , psttp ) ; ___( psttSnip ) ;
                                    ZE( strokeS* , psttSnip ) ;
                                    idfNextOut  = psttp->idAdam > idlElement ? idlElement + 1 : 0 ;
                                {
                                if( idl2 )
                                countT idl2 = idfElement - 1 ;
                                countT idf2 = idfNextOut ;
                                //LOGrAW( "etherSoilF / PREPAREsOURCE / z\r\n" ) ;
                            {
                            if( idfNextOut < idfElement )
                            //LOGrAW( "etherSoilF / PREPAREsOURCE / A\r\n" ) ;

                            /**/if( /*bTrace &&*/ !( ++ idLoop % TUCK ) ) traceF( tinP , T("etherSoilF / preparing source / finding Elements [idLoop]: ")+TF2(idLoop,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" fields remain") ) ;
                        {
                        while( !bQuitP && idf && ( findElementF( tinP , *this , idfElement , idlElement , psttp , idf , pptFind , sizeof pptFind / sizeof pptFind[ 0 ] ) , idfElement ) )
                        ZE( countT , idLoop ) ;
    
                        countT idf = 1 ;
                        ZE( countT , idlElement ) ;
                        ZE( countT , idfElement ) ;
                        //LOGrAW( "etherSoilF / PREPAREsOURCE / B\r\n" ) ;
                    {
                    countT idfNextOut = 1 ;

                    }
                        //LOGrAW( "etherSoilF / PREPAREsOURCE / C\r\n" ) ;
                        delF( tinP , psttd ) ;
                        strFuseF( tinP , psttp , psttd ) ;
                        delF( tinP , psttElementLag ) ;
                        strMakeF( tinP , psttp , psttElementLag , psttd->idAdam ) ; ___( psttp ) ;
                                         psttp = 0 ;
                        strokeS* psttd = psttp ;
                        //LOGrAW( "etherSoilF / PREPAREsOURCE / D\r\n" ) ;
                    {
                    if( psttElementLag )

                    //LOGrAW( "etherSoilF / PREPAREsOURCE / E\r\n" ) ;
                    const countT csttNow = psttp->idAdam ;

                    //traceF( tinP , T("piece: >>>>")+T(psttp)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG

                    soulInP >> psttp ; ___( psttp ) ;
                    ZE( strokeS* , psttp ) ;
                    //LOGrAW3( "PREPAREsOURCE [soulInP]: " , soulInP , "\r\n" ) ;

                    }
                                                                                traceF( tinP , T("etherSoilF / preparing source [soulInP]: ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" fields remain") ) ;
                        ///**/ if( /*bTrace &&*/ !( cRemain % ( TUCK << 4 ) ) ) traceF( tinP , T("etherSoilF / preparing source [soulInP]: ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" fields remain") ) ;
                        countT cRemain = soulInP ;
                    {
                {
                while( soulInP && !bQuitP )
                ZE( countT , csttIndent ) ;              // csttIndent IS UPDATED WHENEVER STROKES ARE SHIFTED INTO soulOutP
                ZE( countT , csttDone ) ;
                ZE( strokeS* , psttElementLag ) ;
                /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_PREPAREsOURCE / flETHERsOILf_CONSUMEiNPUT / +") ) ;
            {
            if( F(flagsP) & flETHERsOILf_CONSUMEiNPUT )
            strokeS sttClose( '}' ) ;
            strokeS sttColon( ':' ) ;
            TN( tMaybeElement , "" ) ;
            TN( tKeyObeyPreIncludeScrub1 , "{preIncludeScrub1" ) ; // THIS VALUE IS NONCONFORMANT IN THAT IT INCLUDES THE '{' THAT BEGINS THE ELEMENT
            TN( tKeyObeyPreInclude       , "{preInclude"       ) ; // THIS VALUE IS NONCONFORMANT IN THAT IT INCLUDES THE '{' THAT BEGINS THE ELEMENT
            //LOGrAW( "etherSoilF / PREPAREsOURCE / F\r\n" ) ;

            } ;
                &tKeyPreIncludeScrub1
                &tKeyPreInclude       ,
            {
            textC* pptFind[] =
            TN( tKeyPreIncludeScrub1 , "preIncludeScrub1:" ) ; // THESE VALUES ARE NONCONFORMANT IN THAT THEY INCLUDE THE COLON THAT DELIMITS KEYS IN THE SOURCE
            TN( tKeyPreInclude       , "preInclude:"       ) ; // THESE VALUES ARE NONCONFORMANT IN THAT THEY INCLUDE THE COLON THAT DELIMITS KEYS IN THE SOURCE

            // THE CALLER SHOULD CALL ME REPEATEDLY UNTIL I RETURN 0
            // I WILL SET cFlag1 TO THE NUMBER OF REPLACEMENTS THAT I MAKE

            // 
            //  EMIT ANY REMAINING SNIP
            //   PROCESS IT
            //   EMIT THE SNIP THAT PRECEEDED IT
            //  WHILE FIND SYNTACTICALLY CORRECT PREPROCESSOR ELEMENT
            // FOR EACH PIECE IN soulInP
            // 
            // RECIPE

            // 
            //  EMIT THE FINAL SNIP THAT I SKIPPED OVER TO GET TO THE END OF THE PIECE
            //   ELSE STORE ITS PARTIAL SYNTAX FOR DEFERRED EMISSION
            //   IF IT IS COMPLETE THEN EMIT ITS VALUE WITH INDENTATION ADDED
            //   EMIT THE SNIP THAT I SKIPPED OVER TO GET TO IT
            //  WHILE FIND A SYNTACTICALLY CORRECT PREPROCESSOR ELEMENT OR A POSSIBLE PARTIAL WO AT THE END
            // FOR EACH PIECE IN soulInP
            // 
            // RECIPE


            //
            //   20140827@0931:  THIS WAS ADDED TO SUPPORT INCLUDED TEXT THAT IS OBTAINED PROGRAMMATICALLY FROM VOICE-TO-TEXT OUTPUT THAT MIGHT CONTAIN UTTERANCES THAT CONSTITUTE KT SYNTAX OR SEMANTICS ERRORS
            //  preIncludeScrub1:  IF THE FIRST NONBLANK CHARACTER IS ':' THEN LEADING ' ' AND ':' ARE ELIMINATED
            //
            // SCRUBBING
            //
            // "{preInclude:" AND "{preIncludeScrub1:" HAVE THE SAME EFFECT EXCEPT THAT THE LATTER KEY CAUSES THE INCLUDED CONTENT TO BE "SCRUBBED" I.E. EDITED AS FOLLOWS:
            // 
            //U:: Future: Replacement is recursive and will continue until there are no more occurances of {preInclude: [fileName] }
            // Multiple {preInclude: [fileName] } instances can occur on the same line either adjacently or separated by spaces or any other osTextT value.
            // If the file contains "\r\n" and "{preInclude:" occurs at column I of its line, then I-1 indentation spaces are appended to each occurance of "\r\n".
            // {preInclude: [fileName] } is replaced with the contents of the file, which is interpreted as a string of osTextT.
            // 
            //                                                                  {preInclude: "///c" "/tmp/fooey gooey" }
            //                                                                  {preInclude: ///c" "/tmp/fooey }
            // {preIncludeScrub1: [fileName] }
            // {preInclude: [fileName] }
            //
            // SPECIFICATION                                                    EXAMPLES
            //
            // SYNTAX (CONVENTION: ALL SOURCE PREPARATION KEYS BEGIN WITH "pre"
            //
            // PREPARE SOURCE
            /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1 / ifcIDmODEeTHERsOIL_PREPAREsOURCE / +") ) ;
        {
        case ifcIDmODEeTHERsOIL_PREPAREsOURCE :
    {
    switch( idModeP )
    ZE( boolT  , bRepeat ) ;
    ZE( countT , cFlag1 ) ;
    soulC soulOut( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.out" ) ;
    TN( tb , " " ) ;
    TN( tcr , "\r\n" ) ;

    /**/if( bTrace ) traceF( tinP , T("etherSoilF / setting up 1") ) ;

    //}
    //    default                                                  : { LOGrAW( "etherSoilF / ?               /+\r\n" ) ; strokeF( tinP , T("etherSoilF / ?               /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_DOdEBUG                          : { LOGrAW( "etherSoilF / DOdEBUG         /+\r\n" ) ; strokeF( tinP , T("etherSoilF / DOdEBUG         /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_DO                               : { LOGrAW( "etherSoilF / DO              /+\r\n" ) ; strokeF( tinP , T("etherSoilF / DO              /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_QUERYvALUES                      : { LOGrAW( "etherSoilF / QUERYvALUES     /+\r\n" ) ; strokeF( tinP , T("etherSoilF / QUERYvALUES     /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_REPORT                           : { LOGrAW( "etherSoilF / REPORT          /+\r\n" ) ; strokeF( tinP , T("etherSoilF / REPORT          /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_TRIM                             : { LOGrAW( "etherSoilF / TRIM            /+\r\n" ) ; strokeF( tinP , T("etherSoilF / TRIM            /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_LINT                             : { LOGrAW( "etherSoilF / LINT            /+\r\n" ) ; strokeF( tinP , T("etherSoilF / LINT            /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE                  : { LOGrAW( "etherSoilF / ASCIIfROMnATIVE /+\r\n" ) ; strokeF( tinP , T("etherSoilF / ASCIIfROMnATIVE /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_NATIVEfROMaSCII                  : { LOGrAW( "etherSoilF / NATIVEfROMaSCII /+\r\n" ) ; strokeF( tinP , T("etherSoilF / NATIVEfROMaSCII /+\r\n") ) ; break ; }
    //    case ifcIDmODEeTHERsOIL_PREPAREsOURCE                    : { LOGrAW( "etherSoilF / PREPAREsOURCE   /+\r\n" ) ; strokeF( tinP , T("etherSoilF / PREPAREsOURCE   /+\r\n") ) ; break ; }
    //{
    //switch( idModeP )

    _IO_

    }
        if( POOP ) return 0 ;
        }
            __( !cbIn ) ;
            __( flagsIn - flSOULiTEM_null ) ;
            __( idTypeIn - ifcIDtYPEsOULiTEM_strokeSptr ) ;
            byteT* pbzEncoded = soulInP.pbFieldF( tinP , idTypeIn , flagsIn , cbIn , idFieldIn ) ;
            ZE( countT , cbIn     ) ;
            ZE( flagsT , flagsIn  ) ;
            ZE( countT , idTypeIn ) ;

            }
                /**/if( /* bTrace && */ !( cRemain % ( TUCK << 4 ) ) ) traceF( tinP , T("etherSoilF / entering (validating each field of soulInP) ; ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" fields remain") ) ;
                countT cRemain = cFieldsIn - idFieldIn ;
            {
        {
        for( countT idFieldIn = 1 ; idFieldIn <= cFieldsIn ; idFieldIn ++ )
        countT cFieldsIn = soulInP ;
        if( POOP ) return 0 ;
        FV( flETHERsOILf , flagsP ) ;
        __Z( idModeP ) ;
        __Z( soulInP ) ;
        __NZ( soulOutP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL

    //bTrace = 1 ; //U:: TO FIND A BUG
    /**/if( bTrace ) traceF( tinP , T("etherSoilF / entering (validating each field of soulInP)") ) ;
    boolT bTrace = idModeP == ifcIDmODEeTHERsOIL_REPORT /*|| idModeP == ifcIDmODEeTHERsOIL_LINT*/ ;
{
/*1*/countT etherC::etherSoilF( tinS& tinP , const boolT& bQuitP , soulC& soulOutP , soulC& soulInP , const countT idModeP , const strokeS* const psttKeyP , const flagsT flagsP , const osTextT* const postSourceP , const countT costSourceP )/*1*/

}
    return 0 ;

    }
        __Z( ids ) ; // NONUNIQUENESS IS IMPOSSIBLE BECAUSE bitTreeC IS USED TO STORE THE SETTINGS KEYS AND VALUES
        swsSettingsP.sinkF( tinP , ids , psttKey , flSTACKsINK_UNIQUE ) ;
        ZE( countT , ids ) ;
        psttzLeverCloudP = tCloud ;
    
        tinP.pEther->strMakeFromOsTextF( tinP , psttKey , poste ) ; ___( psttKey ) ;
        ZE( strokeS* , psttKey ) ;
        TN( tCloud , postc ) ;
    
        *( poste ++ ) = 0 ;
        osTextT* poste = thirdC::c_strrchrIF( tinP , postc , '.' ) ;
        osTextT* postc = pbBufferCopy + sizeof postHey - 1 ;
    {
    if( thirdC::c_strstrIF( tinP , pbBufferCopy , postHey ) )
    osTextT postHey[] = "!cloudview." ;

    for( countT offr = 0 ; pbBuffer[ offr ] ; offr ++ ) pbBufferCopy[ offr ] = reverseBitsF( pbBuffer[ offr ] ) ;

    thirdC::c_memsetIF( tinP , pbBufferCopy , sizeof pbBufferCopy ) ;

    switchStackC& swsSettingsP     = *(switchStackC*)(&cArg2P)[ 2 ] ;
    strokeS*&     psttzLeverCloudP =     *(strokeS**)(&cArg2P)[ 1 ] ;
{
countT walkCloudViewSettingsCBF( tinS& tinP , countT& cArg1P , countT& cArg2P )
byteT pbBufferCopy[ TUCK ] ;
byteT pbBuffer[ TUCK ] ;

}
    }
        etherP.delF( tinP , psttFileName ) ;
        stSetP >> psttFileName ;
        ZE( strokeS* , psttFileName ) ;
    {
    while( stSetP )

    }
        //if( espP.bTrace ) etherP.traceF( tinP , T("------------------------------------------------------ emitSetF/- [psttSetP,tNoteFileName]: ")+T(psttSetP)+T("    \"")+espP.tNoteFileName+T("\"") ) ;

        }
            espP.tNoteFileName = espP.tMark = espP.tn ;
            }
                etherP.strFuseF( tinP , soulrFileSetsP , tEntry ) ;

                //LOGrAW( "\r\n--------------------------------------------- END 2 --------------------------------------------------------------------------\r\n" ) ;
                //LOGrAW( tEntry ) ;
                //LOGrAW( "\r\n--------------------------------------------- BEGIN 2 ------------------------------------------------------------------------\r\n" ) ;
                //U::TO FIND A BUG

                ;

                    +espP.tcr
                    +(!tIdFrag.csF(tinP)?espP.tn:espP.tb1+tIdFrag+espP.tcr)
                    +espP.tb1+espP.tBegin+espP.tMark/*+espP.tCloudPath*/+tFileNameSet+espP.tMark+espP.tp1+espP.tcr
                    +(bImage?espP.tb2+espP.tp2jpg+espP.tcr:espP.tn)
                    +espP.tb1+espP.tp3+(bDisplayTime?T("<span id=\"go.")+espP.tHtmlIdLath+T("\">")+tTime+T("</span>"):espP.tn)+(tTitle.csF(tinP)?espP.tcs:espP.tc)+espP.tcr
                    )
                                : espP.tn
                                ? espP.tb1+tTitle+espP.tcr
                            : tTitle.csF( tinP )
                            ? (bDisplayTime?espP.tb2:espP.tb1)+espP.tp4NotScrubbed+espP.tNoteFileName+espP.tp5+espP.tcr
                        espP.tNoteFileName.csF( tinP )
                    (
                    +
                    +espP.tb1+espP.tEnd+espP.tcr
                    espP.tBar+espP.tcr

                TN( tEntry , "" ) ; tEntry =
                strokeS sttDot( '.' ) ;

                }
                    }
                        etherP.delF( tinP , psttFileName ) ;

                        if( stSetP ) tFileNameSet += tComma ;
                                     tFileNameSet += tYear+espP.tSlash+T(psttFileName) ;

                        //if( espP.bTrace ) etherP.traceF( tinP , T("\r\n      emit [set,name]: ")+T(psttSetP)+T("    \"")+T(psttFileName)+T("\"") ) ;

                        }
                            etherP.delF( tinP , psttYear ) ;
                            ;
                                    : T(psttYear)
                                    ? T("2008")
                                : year <= 2008
                                ? T("1999")
                            tYear =  year <= 1999

                            countT year = etherP.strDigitsToSCountF( tinP , psttYear , 0xa , 1 ) ;

                                                                                                                            // FORMAT EXAMPLE: !ideafarm.9.2.00000000.00000001.19991231@1211.20170130@2228.afaa979fbcc5e521b59359026aaaf90a.001.data.pdf
                            etherP.strSubstringF( tinP , psttYear , idf , idl , psttFileName ) ; ___( psttYear ) ;          // FORMAT EXAMPLE: !ideafarm.8.2.00000000.00000001.19991231@1211.20170130@2228.001.afaa979fbcc5e521b59359026aaaf90a.00000001.data.pdf
                                                                                                                            //                                                 yyyy                                                                                                      NEW 8
                            countT idl = 0x24 ;                                                                             //                             yyyy                                                                                                      OLD 7
                            countT idf = 0x21 ;                                                                             //                 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
                            ZE( strokeS* , psttYear ) ;                                                                     //                                1               2               3               4               5               6               7
                        {
                        if( !tYear.csF( tinP ) )
        
                        stSetP >> psttFileName ;
                        ZE( strokeS* , psttFileName ) ;
                    {
                    while( stSetP )
                    TN( tComma , "," ) ;
                    TN( tYear , "" ) ;
                {
                TN( tFileNameSet , "" ) ;
            {
            else if( espP.tMark.csF( tinP ) )
            }
                etherP.strFuseF( tinP , soulrFileSetsP , tEntry ) ;

                //LOGrAW( "\r\n--------------------------------------------- END 1 --------------------------------------------------------------------------\r\n" ) ;
                //LOGrAW( tEntry ) ;
                //LOGrAW( "\r\n--------------------------------------------- BEGIN 1 ------------------------------------------------------------------------\r\n" ) ;
                //U::TO FIND A BUG

                ;

                    +espP.tcr
                    +(!tIdFrag.csF(tinP)?espP.tn:espP.tb1+tIdFrag+espP.tcr)
                    +espP.tb1+espP.tBegin+espP.tMark/*+espP.tCloudPath*/+espP.tIconTranscript+espP.tMark+espP.tp1+espP.tcr
                    +(bImage?espP.tb2+espP.tp2jpg+espP.tcr:espP.tn)
                    +espP.tb1+espP.tp3+(bDisplayTime?T("<span id=\"go.")+espP.tHtmlIdLath+T("\">")+tTime+T("</span>")+(tTitle.csF(tinP)||tNarrativePrefix.csF(tinP)?espP.tcs:espP.tc):espP.tn)+tNarrativePrefix+espP.tcr

                    )
                                : espP.tn
                                ? espP.tb1+tTitle+espP.tcr
                            : tTitle.csF( tinP )
                            ? (bDisplayTime?espP.tb2:espP.tb1)+(bNarrative?espP.tp4Scrubbed:espP.tp4NotScrubbed)+tFileNameSet+espP.tp5+espP.tcr
                        ( espP.tNoteFileName.csF( tinP ) || bNarrative )
                    (
                    +
                    +espP.tb1+espP.tEnd+espP.tcr
                    espP.tBar+espP.tcr

                TN( tEntry , "" ) ; tEntry =
                strokeS sttDot( '.' ) ;

                //if( espP.bTrace ) etherP.traceF( tinP , T("emitSetF [file,file,...]: ")+tFileNameSet ) ;
                }
                    }
                        etherP.delF( tinP , psttFileName ) ;

                        if( stSetP ) tFileNameSet += tComma ;
                                     tFileNameSet += T(psttFileName) ;

                        //etherP.traceF( tinP , T("\r\n      emit [set,name]: ")+T(psttSetP)+T("    \"")+T(psttFileName)+T("\"") ) ;
        
                        stSetP >> psttFileName ;
                        ZE( strokeS* , psttFileName ) ;
                    {
                    while( stSetP )
                    TN( tComma , "," ) ;
                {
                TN( tFileNameSet , "" ) ;
            {
            if( bNarrative ) //THIS CODE IS AN ADAPTATION OF THE CODE IN THE NEXT SNIPPET SO CONTAINS UNNECESSARY STUFF

            }
                }
                    
                    tIdFrag = T("\\h")+tIdFrag+T("\\h") ;
                    soulIdFragShortP << (strokeS*)espP.tNoteFileName ;
                    soulIdFragShortP << (strokeS*)tIdFrag ;
                    //if( espP.bTrace ) etherP.traceF( tinP , T("html frag: \"")+tIdFrag+T("\"") ) ;
                {
                if( tIdFrag.csF( tinP ) )

                }
                    }
                        etherP.delF( tinP , psttSuffix ) ;
                        tIdFrag += T(".")+T(psttSuffix) ;
                        etherP.strSubstringF( tinP , psttSuffix , idWothSuffix , idLathSuffix , espP.tNoteFileName ) ; ___( psttSuffix ) ;
                        ZE( strokeS* , psttSuffix ) ;
                        countT idLathSuffix = idHit2 - 1 ;
                    {
                    if( idHit2 && idf ) // idf IS CHECKED JUST BECAUSE A ZE VALUE SHOULD BE IMPOSSIBLE (SINCE FILE TYPE ".ttt" IS REQUIRED)
                    countT idHit2 = etherP.strIdF( tinP , idf , sttq , strokeS( '.' ) , espP.tNoteFileName ) ;

                    }
                        etherP.delF( tinP , psttTimeSeq ) ;
                        tIdFrag = T("i.")+T(psttTimeSeq) ; //"i." IS PREPENDED TO ENSURE HTML 4.01 COMPLIANCE (WOTH CHAR MUST NOT BE A DIGIT); WILL ALSO FACILITATE SEARCHING FOR TAGS
                        etherP.strReplaceF( tinP , psttTimeSeq , 0 , T("@") , T(".") ) ; ___( psttTimeSeq ) ;
                        etherP.strSubstringF( tinP , psttTimeSeq , idfp , idlp , espP.tNoteFileName ) ; ___( psttTimeSeq ) ;
                        ZE( strokeS* , psttTimeSeq ) ;
                        countT idlp = 0x31 ;
                        countT idfp = 0x21 ;

                        // !ideafarm.9.2.00000000.00000001.20100815@0903.002.!.note.ttt

                        // !ideafarm.8.2.00000000.00000001.20100815@0903.002.!.note.ttt
                        //                                                  |                                           NEW 8
                        //                              |                                           OLD 7
                        // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
                        // 0              1               2               3               4
                    {
                    if( espP.tNoteFileName.csF( tinP ) >= 0x32 ) // EVERY IdFrag BEGINS WITH "i." || TIME||SEQUENCE TO ENSURE THAT idFrag VALUES ARE UNIQUE ; IT IS ILLEGAL TO EXIST MULTIPLE .!.note.* FILES FOR THE SAME TIME||SEQUENCE

                    countT idWothSuffix = idf ;
                {
                if( idHit1 && idf )
                countT idHit1 = etherP.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , espP.psttTestNote , espP.tNoteFileName ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                countT idf = 1 ;
            {
            if( espP.tNoteFileName.csF( tinP ) )
            TN( tIdFrag , "" ) ;

            }
                etherP.delF( tinP , psttHtmlIdLath ) ;
                etherP.delF( tinP , psttSequence ) ;
                etherP.delF( tinP , psttTimeToday ) ;
                espP.tHtmlIdLath   = T(psttHtmlIdLath) ;
                espP.tSequenceLath = T(psttSequence) ;
                espP.tTimeLath     = T(psttTimeToday) ;
                espP.tTodayLath    = tToday ;

                }
                    if( espP.tDayTitleFileName.csF(     tinP ) ) espP.tDayTitleFileName     = espP.tn ;                                                                                                                        /*20151018@1623: NotScrubbed*/
                    if( espP.tDaySignsFileName.csF(     tinP ) ) espP.tDaySignsFileName     = espP.tn ;                                                                                                                        /*20180409@1513: NotScrubbed*/
                    if( espP.tDayNarrativeFileName.csF( tinP ) ) espP.tDayNarrativeFileName = espP.tn ;                                                                                                                        /*20151018@1623: NotScrubbed*/
                    if( espP.tDayKeywordsFileName.csF(  tinP ) ) espP.tDayKeywordsFileName  = espP.tn ;                                                                                                                        /*20180405@1630: NotScrubbed*/

                    ) ;

                        +espP.tcr
                        +espP.tcr
                        +espP.tcr
                        +espP.tTocAfter
                        )
                                : T("</td></tr><tr><td>Signs:  ")+espP.tp4Scrubbed+espP.tDaySignsFileName+espP.tDaySignsSuffix
                                ? espP.tn
                            !espP.tDaySignsFileName.csF(tinP)
                        (
                        +
                        )
                                : T("</td></tr><tr><td>Keywords:  ")+espP.tp4Scrubbed+espP.tDayKeywordsFileName+espP.tDayKeywordsSuffix
                                ? espP.tn
                            !espP.tDayKeywordsFileName.csF(tinP)
                        (
                        +
                        )
                                : T("</td></tr><tr><td>Narrative:  ")+espP.tp4Scrubbed+espP.tDayNarrativeFileName+espP.tDayNarrativeSuffix
                                ? espP.tn
                            !espP.tDayNarrativeFileName.csF(tinP)
                        (
                        +
                        +T("\\m")
                        )
                                : espP.tcs+espP.tp4NotScrubbed+espP.tDayTitleFileName+espP.tDayTitleSuffix
                                ? espP.tn
                            !espP.tDayTitleFileName.csF(tinP)
                        (
                        +
                        +espP.tTodayLath
                        +espP.tDayPrefix            // THIS ENDS WITH "\\m\\r", WHICH ENDS THE PREFIX OF THE BRANCH (THE BRANCH WILL CONSIST OF tTodayLath CONCATENATED WITH ": " FOLLOWED BY THE TITLE)
                        +espP.tc
                        //+espP.tSequenceLath
                        //+sttDot
                        //20180421@1406: SUPPRESSED SEQUENCE NUMBER WITHOUT ANALYSIS SO THAT THE LABEL IS SIMPLY THE DAYTIME
                        //+espP.tTimeLath
                        //+sttDot
                        //20180424@1606: SUPPRESSED TIME WITHOUT ANALYSIS SO THAT THE LABEL IS SIMPLY THE DAY
                        +espP.tTodayLath
                        espP.tc
                        //CS:CODEsYNC: PSEUDODUPLICATE CODE: 360021c1 360021c1

                    etherP.strFuseF( tinP , soulrFileSetsP , 

                    //EXAMPLE KT LINE: :20100113.0000.000:<p><table border=1 cellpadding=10><tr><td>\m\r20100113: {preInclude: "///d/archive/2010/!ideafarm.9.2.00000000.00000001.20100113@0000.!.control.page.title" }\m</td></tr><tr><td>Keywords:  {preInclude: "///d/archive/2010/!ideafarm.9.2.00000000.00000001.20100113@0000.!.control.page.keywords" }</td></tr><tr><td>Signs:  {preIncludeScrub1: "///d/archive/2010/!ideafarm.9.2.00000000.00000001.20100113@0000.!.control.page.signs" }</td></tr></table>

                    // :20100815.0648.001:\r<p>\m20100815: {preIncludeScrub1: "///ideafarm/IdeaFarm (tm)/SYSTEM/Drop Files Here To"" Archive/!ideafarm.9.2.00000000.00000001.20100815@0000.!.day.title.ttt" }

                    // :20100815.0648.001:\r<p>\m20100815: {preIncludeScrub1: "///ideafarm/IdeaFarm (tm)/SYSTEM/Drop Files Here To"" Archive/!ideafarm.8.2.00000000.00000001.20100815@0000.001.!.day.title.ttt" }
                    // ||       ||       ||      |       | |                                                                                 |                                            |
                    // ||       ||       ||      |       | |                                                                                 |                                            espP.tDayTitleSuffix
                    // ||       ||       ||      |       | |                                                                                 espP.tDayTitleFileName
                    // ||       ||       ||      |       | espP.tp4Scrubbed
                    // ||       ||       ||      |       espP.tcs
                    // ||       ||       ||      espP.tTodayLath
                    // ||       ||       |espP.tDayPrefix
                    // ||       ||       espP.tc
                    // ||       |psttTimeToday
                    // ||       sttDot 
                    // |espP.tTodayLath
                    // espP.tc
                    //20180417@1332: THIS COMMENT IS STALE
                {
                )
                    //espP.tDay TitleFileName.csF( tinP )      // 20140929@1804: THIS WAS ADDED SO THAT ADDITIONAL DAY TITLE FILES CAN BE USED TO SPLIT THE FILES FOR A DAY INTO MULTIPLE HTML PAGES
                    //||
                    //20180405@1622: NOTWITHSTANDING THE COMMENT CLAIMING 2014, I THINK THAT I ADDED THIS JUST A FEW DAYS AGO

                    ( espP.tTodayLath.csF( tinP ) && etherP.strCompareF( tinP , tToday , espP.tTodayLath ) )
                (
                if

                etherP.strConvertToLowerCaseF( tinP , psttHtmlIdLath ) ;
                etherP.strSubstringF( tinP , psttHtmlIdLath , idf , idl , psttSetP ) ; ___( psttHtmlIdLath ) ;
                ZE( strokeS* , psttHtmlIdLath ) ;
                idl = 0x3f ;
                idf = 0x21  ;

                etherP.strConvertToLowerCaseF( tinP , psttSequence ) ;
                etherP.strSubstringF( tinP , psttSequence , idf , idl , psttSetP ) ; ___( psttSequence ) ;
                ZE( strokeS* , psttSequence ) ;
                idl = 0x3f ;
                idf = 0x3d  ;

                etherP.strConvertToLowerCaseF( tinP , psttTimeToday ) ;
                etherP.strSubstringF( tinP , psttTimeToday , idf , idl , psttSetP ) ; ___( psttTimeToday ) ;
                ZE( strokeS* , psttTimeToday ) ;
                idl = 0x2d ;
                idf = 0x2a  ;

                etherP.delF( tinP , psttToday ) ;
                tToday = T(psttToday) ;
                etherP.strConvertToLowerCaseF( tinP , psttToday ) ;
                etherP.strSubstringF( tinP , psttToday , idf , idl , psttSetP ) ; ___( psttToday ) ;
                ZE( strokeS* , psttToday ) ;
                countT idl = 0x28 ;
                countT idf = 0x21  ;

                //
                // !ideafarm.9.2.00000000.00000001.20100115@1256.20170131@0039.0d6d4aac01544697a52d1cb3bcfca89c.001.data.jpg
                //
                // !ideafarm.8.2.00000000.00000001.20100115@1256.20170131@0039.888.0d6d4aac01544697a52d1cb3bcfca89c.00000001.data.jpg
                //                                 |------| |--|               |-|                                NEW 8
                //                                 |-----------------------------|
                // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
                // 0              1               2               3               4               5
            {
            if( bNarrative || espP.tMark.csF( tinP ) )
            TN( tToday , "" ) ;

            }
                }
                    //espP.tNote FileName = T(psttSetP) ;      20141008@1429: COMMENTED THIS OUT BECAUSE IT APPEARS TO BE A BUG (tNote FileName APPEARS TO ONLY BE USED TO HOLD THE MOST RECENTLY ENCOUNTERED *.!.note.ttt FILE)
                    bImage = bNarrative = 1 ;
                    espP.tMark = espP.tMarkJpg ;

                    if( etherP.strIdF( tinP , T(".!.narrative.ttt") , psttSetP ) ) bDisplayTime = 0 ;

                    ;
                                : espP.tn
                                ? T("(log)")
                            : etherP.strIdF( tinP , T(".!.transcript.log.ttt") , psttSetP )
                            ? T("(journal)")
                        : etherP.strIdF( tinP , T(".!.transcript.journal.ttt") , psttSetP )
                        ? T("(do)")
                    tNarrativePrefix = etherP.strIdF( tinP , T(".!.transcript.do.ttt") , psttSetP )
                {
                )
                    etherP.strIdF( tinP , T(".!.narrative.ttt")          , psttSetP )
                    ||
                    etherP.strIdF( tinP , T(".!.transcript.log.ttt")     , psttSetP )
                    ||
                    etherP.strIdF( tinP , T(".!.transcript.journal.ttt") , psttSetP )
                    ||
                    etherP.strIdF( tinP , T(".!.transcript.do.ttt")      , psttSetP )
                (
                if
            {
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtTtt  ) )
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtZip  ) )   espP.tMark = espP.tMarkZip ;
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtTxt  ) )   espP.tMark = espP.tMarkTxt ;
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtSoil ) )   espP.tMark = espP.tMarkSoil ;
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtPng  ) ) { espP.tMark = espP.tMarkPng ; bImage = 1 ; }
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtPdf  ) )   espP.tMark = espP.tMarkPdf ;
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtMp3  ) )   espP.tMark = espP.tMarkMp3 ;
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtJpg  ) ) { espP.tMark = espP.tMarkJpg ; bImage = 1 ; }
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtIco  ) ) { espP.tMark = espP.tMarkIco ; bImage = 1 ; }
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtEml  ) ) { espP.tMark = espP.tMarkEml ; bImage = 1 ; } //U:: 20180304@1402: SETTING bImage JUST TO SEE WHAT HAPPENS (CAN AN EMAIL BE DISPLAYED AS AN IMAGE?)
            else if( !etherP.strCompareF( tinP , tExt , espP.psttExtBmp  ) ) { espP.tMark = espP.tMarkBmp ; bImage = 1 ; }
                 if( !etherP.strCompareF( tinP , tExt , espP.psttExtAvi  ) )   espP.tMark = espP.tMarkAvi ;
            ZE( boolT , bImage ) ;
            ZE( boolT , bNarrative ) ;
            boolT bDisplayTime = 1 ;
        {
        if( tExt.csF( tinP ) )

        }
            }
                }
                    }
                        etherP.delF( tinP , psttTitle ) ;
                        }
                            tTitle = espP.tRaw+T(psttTitle) ;
                            etherP.strReplaceAnyF( tinP , psttTitle , 0 , T("_.") , T(" ") ) ; ___( psttTitle ) ;
                            etherP.delF( tinP , psttd ) ;
                            etherP.strSubstringF( tinP , psttTitle , idfUse , idl , psttd ) ; ___( psttTitle ) ;
                            idl = 0 ;
                            strokeS* psttd = psttTitle ; psttTitle = 0 ;
                        {
                        if( idfUse )
                        countT idfUse = etherP.strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , T("0123456789@_.") , psttTitle , 0 , 1 , flSTRiDaNY_NOT ) ;
                        idf = 1 ;

                        // GOAL: SUPPRESS PREDICTABLE PATTERNS ; MAP UNDERSCORES AND PERIODS TO BLANKS
                        //EXAMPLE OF RAW TITLE: 130709_008_02_01_20130709@1640_mv_bicycling_rebuking_bicyclist_on_wrong_side

                        etherP.strSubstringF( tinP , psttTitle , idf , idl , psttSetP ) ; ___( psttTitle ) ;
                        ZE( strokeS* , psttTitle ) ;
                        if( idl < idf ) idl = 0 ; // WILL OCCUR IF FILE NAME HAS NO EXTENSION, E.G. ".!.stamp"
                        idl = idfLathDot - 1 ;
                    {
                    else
                    if( psttCurrentNameP ) tTitle = T(psttCurrentNameP) ;

                    //U::20171002@1440:CRAFTWORK: if( !espP.tNoteFileName.csF( tinP ) && idf && etherP.strIdF( tinP , idf , sttq , espP.psttDotHeyDot , psttSetP ) && idf )
                    // IF I DON'T HAVE A NOTE FILE THEN CALCULATE A TITLE FROM THE FILE NAME
                    //THIS COMMENT IS OBSOLETED BY FORMAT 7 FILE NAMES

                    etherP.delF( tinP , psttTime ) ;
                    tTime = T(psttTime) ;
                    etherP.strSubstringF( tinP , psttTime , idf , idl , psttSetP ) ; ___( psttTime ) ;
                    idl = 0x2d ;
                    idf = 0x21 ;
                    ZE( strokeS* , psttTime ) ;
                {
                if( tExt.csF( tinP ) )

                }
                    if( !espP.stFileType( (strokeS*)tExt ) ) tExt = espP.tn ;

                    }
                        while( ~hWalk ) ;
                        }
                            //LOGrAW( T("    checking: \"")+T(psttExt)+T("\"\r\n") ) ;
                            strokeS* psttExt = (strokeS*)espP.stFileType.downF( tinP , hWalk ) ;
                        {
                        do
                        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    //LOGrAW3( T("looking up file type: \"")+tExt+T("\" among ") , espP.stFileType , " registered types\r\n" ) ;
                {
                if( espP.stFileType )

                //
                // !ideafarm.9.2.00000000.00000001.20130709@1913.000.*
                //
                // !ideafarm.8.2.00000000.00000001.20130709@1913.000.*
                //                                 |           |                                        NEW 8
                //             |           |                                        OLD 7
                // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
                //                1               2               3               4
                //

                etherP.delF( tinP , psttExt ) ;
                tExt = T(psttExt) ;
                etherP.strConvertToLowerCaseF( tinP , psttExt ) ;
                etherP.strSubstringF( tinP , psttExt , idf , countTC() , psttSetP ) ; ___( psttExt ) ;
                ZE( strokeS* , psttExt ) ;
                idf = idfLathDot + 1 ;
            {
            else
            if( !idfLathDot || !idf ) { LOGrAW( T("error: bad file name (no extension): ")+T(psttSetP)+espP.tcr ) ; }
            countT idfLathDot = etherP.strIdF( tinP , idf , sttq , sttDot , psttSetP , 0 , - 1 ) ;
            ZE( countT , idl ) ;
            countT idf = 1 ;
        {
        TN( tNarrativePrefix , "" ) ;
        TN( tTitle , "" ) ;
        TN( tTime , "" ) ;
        TN( tExt , "" ) ;

        }
            }
                etherP.delF( tinP , psttw ) ;
                else if( !etherP.strCompareF( tinP , psttw , espP.psttTestDayTitle     ) ) espP.tDayTitleFileName     = T(psttSetP) ;
                else if( !etherP.strCompareF( tinP , psttw , espP.psttTestDaySigns     ) ) espP.tDaySignsFileName     = T(psttSetP) ;
                     if( !etherP.strCompareF( tinP , psttw , espP.psttTestDayNarrative ) ) espP.tDayNarrativeFileName = T(psttSetP) ;

                etherP.strSubstringF( tinP , psttw , idf , idl , psttSetP ) ; ___( psttw ) ;
                countT idl = 0x42 ;
                countT idf = 0x2e ;
                ZE( strokeS* , psttw ) ;
            {
            else if( psttSetP->idAdam == 0x42 ) 
            // MAYBE SET espP.tDayTitleFileName
            // MAYBE SET espP.tDaySignsFileName

            // !ideafarm.9.2.00000000.00000001.20070516@1424.!.control.page.title
            // !ideafarm.8.2.00000000.00000001.20070516@1424.!.control.page.title
            // !ideafarm.8.2.00000000.00000001.20070516@1424.!.control.page.signs
            // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
            // 0              1               2               3               4               5
            //                                              |                   |
            //                                              0x2e                0x42

            }
                etherP.delF( tinP , psttw ) ;
                if( !etherP.strCompareF( tinP , psttw , espP.psttTestDayNarrative ) ) espP.tDayNarrativeFileName = T(psttSetP) ;

                etherP.strSubstringF( tinP , psttw , idf , idl , psttSetP ) ; ___( psttw ) ;
                countT idl = 0x46 ;
                countT idf = 0x2e ;
                ZE( strokeS* , psttw ) ;
            {
            else if( psttSetP->idAdam == 0x46 ) 
            // MAYBE SET espP.tDayNarrativeFileName

            // !ideafarm.9.2.00000000.00000001.20070516@1424.!.control.page.narrative
            // !ideafarm.8.2.00000000.00000001.20070516@1424.!.control.page.narrative
            // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
            // 0              1               2               3               4               5
            //                                              |                       |
            //                                              0x2e                    0x46
            }
                etherP.delF( tinP , psttw ) ;
                if( !etherP.strCompareF( tinP , psttw , espP.psttTestDayKeywords ) ) espP.tDayKeywordsFileName = T(psttSetP) ;

                etherP.strSubstringF( tinP , psttw , idf , idl , psttSetP ) ; ___( psttw ) ;
                countT idl = 0x45 ;
                countT idf = 0x2e ;
                ZE( strokeS* , psttw ) ;
            {
            if( psttSetP->idAdam == 0x45 ) 
            // MAYBE SET espP.tDayKeywordsFileName

            // !ideafarm.9.2.00000000.00000001.20070516@1424.!.control.page.keywords
            // !ideafarm.8.2.00000000.00000001.20070516@1424.!.control.page.keywords
            // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
            // 0              1               2               3               4               5
            //                                              |                      |
            //                                              0x2e                   0x45
        {
        if( psttSetP->idAdam > 0x2f && psttSetP[ CSpREFIX - 1 + 0x2f ] == strokeS( '!' ) ) 

        etherP.traceF( tinP , T("[psttSetP]: ")+T(psttSetP) ) ; //U:: TO FIND A BUG

        // WHEN MIGRATING THE ARCHIVE TO FORMAT 7, THE SPECIAL (FANCY) FILES WERE RETAINED AND SHOULD BE IN A ZIP FILE IN THE ARCHIVE SOMEWHERE
        // BY FANCY CODE I MEAN THE DAY TITLE FILES AND THE NOTE FILES.  ALL OF THAT FUNCTIONALITY WILL NEED TO BE REIMPLEMENTED
        //
        // THAT IS WHAT I DO NOW.  THE FANCY CODE REMAINS PRESENT BUT IS NEVER EXECUTED.
        // THE CONTENTS OF THAT FILE CAN BE USED BY ME TO DISPLAY THE "CURRENTNANE" TEXT RATHER THAN THE FORMAT 7 FILE NAME
        // THAT FILE NAME CAN BE PARSED TO OBTAIN THE NAME OF THE *.meta.currentname FILE
        // WITH THIS FILE NAME FORMAT, THE "FILE SET" WILL ALWAYS BE A SINGLE FILE NAME
        // 20200410@2011:  THE MIGRATION TO !ideafarm.9.2.00000000.00000001.* FILE NAMES PROBABLY BROKE IT AGAIN
        // 20171002@1500:  THE MIGRATION TO !ideafarm.8.2.00000000.00000001.* FILE NAMES DISABLED ALL OF THE FANCY CODE IN ME AND IN MY CALLER

        //
        // THIS IS A VARIATION OF THE FORMAT 4 FILE NAME; IT IS USED TO ANNOTATE THE ARCHIVE

        // FILES WHOSE SHORT NAME IS OF THE FORM !ideafarm.9.2.00000000.00000001.20140122@0000.!.day.title.ttt ARE EXCLUDED
        // FILES WHOSE SHORT NAME IS OF THE FORM !ideafarm.8.2.00000000.00000001.20140122@0000.000.!.day.title.ttt ARE EXCLUDED
        //                                                                                        |              |                                          NEW 8
        //                                                                    |              |                                          OLD 7
        //                                       123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd
        //                                                      1               2               3               4
        //
        // }
        //     }
        //         etherP.delF( tinP , psttw ) ;
        // 
        //         if( !etherP.strCompareF( tinP , psttw , espP.psttTestNote ) ) espP.tNote FileName = T(psttzLeverNoteMaybe) ;
        // 
        //         etherP.strSubstringF( tinP , psttw , idf , idl , psttzLeverNoteMaybe ) ; ___( psttw ) ;
        //         countT idl = 0x3c ;
        //         countT idf = 0x32 ;
        //         ZE( strokeS* , psttw ) ;
        //     {
        //     if( psttzLeverNoteMaybe->idAdam == 0x3b && psttzLeverNoteMaybe[ CSpREFIX - 1 + 0x32 ] == strokeS( '!' ) ) 
        // 
        //     strokeS* psttzLeverNoteMaybe = (strokeS*)stSetP.leverF( tinP , idFlavor - 1 ) ;
        // {
        // if( idFlavor > 1 ) // MAYBE SET espP.tNote FileName
        //U::CONJ: ALREADY DONE; THIS CODE CAN BE REMOVED
        //U:: MIGRATE THIS CODE.  IT IS FROM WHEN switchStackC WAS USED.  THIS MUST BE MIGRATED SO THAT NOTE FILES WILL BE OBEYED

        //
        // THIS IS A VARIATION OF THE FORMAT 5 FILE NAME; IT IS USED TO ANNOTATE THE ARCHIVE
        // FILES WHOSE SHORT NAME IS OF THE FORM !ideafarm.9.2.00000000.00000001.20130709@1913.001.!.note.ttt ARE EXCLUDED

        // FORMAT 9?
        //                                                                                        |         |                                   NEW 8  (+ 0x41)
        //                                                                    |         |                                                       OLD 7
        //                                       123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
        //                                                      1               2               3               4               5
        //

        //U::20200410@2006: EDIT THIS CODE TO USE FORMAT 9 ARCHIVE FILE NAMES

        // }
        //     continue ;
        //     etherP.delF( tinP , psttFile ) ;
        //     espP.tNote FileName = espP.tn ;
        // {
        // if( espP.tNote FileName.csF( tinP ) )
        //U:: MIGRATE THIS CODE.  IT IS FROM WHEN switchStackC WAS USED.  THIS MUST BE MIGRATED SO THAT NOTE FILES WILL BE OBEYED

        TN( tNoteFileName , "" ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        strokeS sttDot( '.' ) ;

        //if( espP.bTrace ) etherP.traceF( tinP , T("++++++++++++++++++++++++++++++++++++++++++++++++++++++ emitSetF/+ [psttSetP,tNoteFileName]: ")+T(psttSetP)+T("    \"")+espP.tNoteFileName+T("\"") ) ;
    {
    if( !POOP )

    __Z( psttSetP ) ;
{
voidT emitSetF( tinS& tinP , etherC& etherP , soulC& soulrFileSetsP , soulC& soulIdFragShortP , const strokeS* const psttSetP , stackC& stSetP , emitSetParmS& espP , const strokeS* const psttCurrentNameP )

}
    etherP.strMakeFromOsTextF( tinP , psttTestDayTitle        , ".!.control.page.title"       ) ; ___( psttTestDayTitle         ) ;
    etherP.strMakeFromOsTextF( tinP , psttTestDaySigns        , ".!.control.page.signs"       ) ; ___( psttTestDaySigns         ) ;
    etherP.strMakeFromOsTextF( tinP , psttTestDayNarrative    , ".!.control.page.narrative"   ) ; ___( psttTestDayNarrative     ) ;
    etherP.strMakeFromOsTextF( tinP , psttTestDayKeywords     , ".!.control.page.keywords"    ) ; ___( psttTestDayKeywords      ) ;
    etherP.strMakeFromOsTextF( tinP , psttTestNote            , ".!.note."                    ) ; ___( psttTestNote             ) ;
    etherP.strMakeFromOsTextF( tinP , psttDotHeyDot           , ".!."                         ) ; ___( psttDotHeyDot            ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtZip              , "zip"                         ) ; ___( psttExtZip               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtTxt              , "txt"                         ) ; ___( psttExtTxt               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtTtt              , "ttt"                         ) ; ___( psttExtTtt               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtSoil             , "soil"                        ) ; ___( psttExtSoil              ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtPng              , "png"                         ) ; ___( psttExtPng               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtPdf              , "pdf"                         ) ; ___( psttExtPdf               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtMp3              , "mp3"                         ) ; ___( psttExtMp3               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtJpg              , "jpg"                         ) ; ___( psttExtJpg               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtIco              , "ico"                         ) ; ___( psttExtIco               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtEml              , "eml"                         ) ; ___( psttExtEml               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtBmp              , "bmp"                         ) ; ___( psttExtBmp               ) ;
    etherP.strMakeFromOsTextF( tinP , psttExtAvi              , "avi"                         ) ; ___( psttExtAvi               ) ;
    etherP.strMakeFromOsTextF( tinP , psttb                   , " "                           ) ; ___( psttb                    ) ;

    tp4Scrubbed    = T("{preIncludeScrub1: \"")+tArchiveP ;
    tp4NotScrubbed = T(      "{preInclude: \"")+tArchiveP ;
{
psttTestDayTitle( 0 )
psttTestDaySigns( 0 ) ,
psttTestDayNarrative( 0 ) ,
psttTestDayKeywords( 0 ) ,
psttTestNote( 0 ) ,
psttDotHeyDot( 0 ) ,
psttExtZip( 0 ) ,
psttExtTxt( 0 ) ,
psttExtTtt( 0 ) ,
psttExtSoil( 0 ) ,
psttExtPng( 0 ) ,
psttExtPdf( 0 ) ,
psttExtMp3( 0 ) ,
psttExtJpg( 0 ) ,
psttExtIco( 0 ) ,
psttExtEml( 0 ) ,
psttExtBmp( 0 ) ,
psttExtAvi( 0 ) ,
psttb( 0 ) ,
tNoteFileName(         tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tp1(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "[**__P1__**]"                                                         ) ,
tIconTranscript(       tinP , TAG( TAGiDnULL ) , flTEXTc_null , /*"///ideafarm/IdeaFarm (tm)/Drop Files Here To"" Archive/"*/ "!ideafarm.9.2.00000000.00000001.20131214@1131.000b37ef.d03518a6.fa5b8bcb.scanner.!.wo.ideafarm.dictating.gold.tooth.0192x.jpg" ) ,
tMark(                 tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tMarkZip(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\z"                                                                  ) ,
tMarkTxt(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\c"                                                                  ) ,
tMarkSoil(             tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\w"                                                                  ) ,
tMarkPng(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\i"                                                                  ) ,
tMarkPdf(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\p"                                                                  ) ,
tMarkMp3(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\a"                                                                  ) ,
tMarkJpg(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\i"                                                                  ) ,
tMarkIco(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\i"                                                                  ) ,
tMarkEml(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\e"                                                                  ) , //U:: 20180304@1401 CONJ: DO NOT WANT OR NEED A MARK FOR EMAIL FILES
tMarkBmp(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\i"                                                                  ) ,
tMarkAvi(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\v"                                                                  ) ,
tCloudPath(            tinP , TAG( TAGiDnULL ) , flTEXTc_null , "http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/"                         ) ,
tBegin(                tinP , TAG( TAGiDnULL ) , flTEXTc_null , "[**__BEGINcHRONICLE__**]"                                             ) ,
tp3(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "[**__P3__**]"                                                         ) ,
tn(                    tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tp5(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\" }"                                                                 ) ,
tEnd(                  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "[**__ENDcHRONICLE__**]"                                               ) ,
tDayTitleSuffix(       tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\" }"                                                                 ) ,
tDaySignsSuffix(       tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\" }"                                                                 ) ,
tDayNarrativeSuffix(   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\" }"                                                                 ) ,
tDayKeywordsSuffix(    tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\" }"                                                                 ) ,
tp2jpg(                tinP , TAG( TAGiDnULL ) , flTEXTc_null , "[**__P2JPG__**]"                                                      ) ,
tc(                    tinP , TAG( TAGiDnULL ) , flTEXTc_null , ":"                                                                    ) ,
tb2(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "  "                                                                   ) ,
tb1(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , " "                                                                    ) ,
tTocAfter(             tinP , TAG( TAGiDnULL ) , flTEXTc_null , "</td></tr></table>"                                                   ) ,
tSlash(                tinP , TAG( TAGiDnULL ) , flTEXTc_null , "/"                                                                    ) ,
tBar(                  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "|"                                                                    ) ,
tp4Scrubbed(           tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tp4NotScrubbed(        tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tcs(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , ": "                                                                   ) ,
tDayTitleFileName(     tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tDaySignsFileName(     tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tDayNarrativeFileName( tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tDayKeywordsFileName(  tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tDayPrefix(            tinP , TAG( TAGiDnULL ) , flTEXTc_null , "<p><table border=1 cellpadding=10><tr><td>\\m\\r"                     ) ,
tHtmlIdLath(           tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tSequenceLath(         tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tTimeLath(             tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tTodayLath(            tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                     ) ,
tRaw(                  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\\r"                                                                  ) ,
tcr(                   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\r\n"                                                                 ) ,
bTrace( bTraceP ) ,
stFileType( stFileTypeP ) ,
ether( etherP ) ,
emitSetParmS::emitSetParmS( tinS& tinP , etherC& etherP , stackC& stFileTypeP , const boolT bTraceP , textC& tArchiveP ) :

}
    ether.delF( tinP , psttTestDayTitle         ) ;
    ether.delF( tinP , psttTestDaySigns         ) ;
    ether.delF( tinP , psttTestDayNarrative     ) ;
    ether.delF( tinP , psttTestDayKeywords      ) ;
    ether.delF( tinP , psttTestNote             ) ;
    ether.delF( tinP , psttDotHeyDot            ) ;
    ether.delF( tinP , psttExtZip               ) ;
    ether.delF( tinP , psttExtTxt               ) ;
    ether.delF( tinP , psttExtTtt               ) ;
    ether.delF( tinP , psttExtSoil              ) ;
    ether.delF( tinP , psttExtPdf               ) ;
    ether.delF( tinP , psttExtMp3               ) ;
    ether.delF( tinP , psttExtJpg               ) ;
    ether.delF( tinP , psttExtIco               ) ;
    ether.delF( tinP , psttExtEml               ) ;
    ether.delF( tinP , psttExtBmp               ) ;
    ether.delF( tinP , psttExtAvi               ) ;
    ether.delF( tinP , psttb                    ) ;
    TINSL
{
emitSetParmS::~emitSetParmS( voidT )

;
}
    emitSetParmS( tinS& tinP , etherC& etherP , stackC& stFileTypeP , const boolT bTraceP , textC& tArchiveP ) ;
    ~emitSetParmS( voidT ) ;

    strokeS* psttTestDayTitle       ;
    strokeS* psttTestDaySigns       ;
    strokeS* psttTestDayNarrative   ;
    strokeS* psttTestDayKeywords    ;
    strokeS* psttTestNote           ;
    strokeS* psttDotHeyDot          ;
    strokeS* psttExtZip             ;
    strokeS* psttExtTxt             ;
    strokeS* psttExtTtt             ;
    strokeS* psttExtSoil            ;
    strokeS* psttExtPng             ;
    strokeS* psttExtPdf             ;
    strokeS* psttExtMp3             ;
    strokeS* psttExtJpg             ;
    strokeS* psttExtIco             ;
    strokeS* psttExtEml             ;
    strokeS* psttExtBmp             ;
    strokeS* psttExtAvi             ;
    strokeS* psttb                  ;

    textC    tNoteFileName          ;
    textC    tp1                    ;
    textC    tIconTranscript        ;
    textC    tMark                  ;
    textC    tMarkZip               ;
    textC    tMarkTxt               ;
    textC    tMarkSoil              ;
    textC    tMarkPng               ;
    textC    tMarkPdf               ;
    textC    tMarkMp3               ;
    textC    tMarkJpg               ;
    textC    tMarkIco               ;
    textC    tMarkEml               ;
    textC    tMarkBmp               ;
    textC    tMarkAvi               ;
    textC    tCloudPath             ;
    textC    tBegin                 ;
    textC    tp3                    ;
    textC    tn                     ;
    textC    tp5                    ;
    textC    tEnd                   ;
    textC    tDayTitleSuffix        ;
    textC    tDaySignsSuffix        ;
    textC    tDayNarrativeSuffix    ;
    textC    tDayKeywordsSuffix     ;
    textC    tp2jpg                 ;
    textC    tc                     ;
    textC    tb2                    ;
    textC    tb1                    ;
    textC    tTocAfter              ;
    textC    tSlash                 ;
    textC    tBar                   ;
    textC    tp4Scrubbed            ;
    textC    tp4NotScrubbed         ;
    textC    tcs                    ;
    textC    tDayTitleFileName      ;
    textC    tDaySignsFileName      ;
    textC    tDayNarrativeFileName  ;
    textC    tDayKeywordsFileName   ;
    textC    tDayPrefix             ;
    textC    tHtmlIdLath            ;
    textC    tSequenceLath          ;
    textC    tTimeLath              ;
    textC    tTodayLath             ;
    textC    tRaw                   ;
    textC    tcr                    ;

    const boolT bTrace              ;
    stackC&     stFileType          ; 
    etherC&     ether               ;
{
struct emitSetParmS

    }
        else                (csttIndentP)  = _cstti          ;                      \
        if( _cstti == - 1 ) (csttIndentP) += (psttP)->idAdam ;                      \
        countT _cstti = csttIndentF( tinP , *this , (psttP) ) ;                     \
    {                                                                               \
                                                                                    \
#define UPD8INDENT(csttIndentP,psttP)                                               \

}
    return csttIndent ;

    }
        ;
            : 0
            ? psttP->idAdam - idf + 1
        csttIndent = idf
    {
    if( etherP.strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , T("\r\n") , psttP , 0 , - 1 ) )
    countT idf = 1 ;

    ;
        : sttqDefault
        ? *psttQuoteP
    strokeS& sttq = psttQuoteP
    strokeS sttqDefault( 0 , sc_IGNOREqUOTES ) ;

    }
        if( POOP ) return csttIndent ;
        __Z( psttP ) ;
        if( POOP ) return csttIndent ;
    {
    IFbEcAREFUL
    countT csttIndent = - 1 ;
{
countT csttIndentF( tinS& tinP , etherC& etherP , const strokeS* const psttP , strokeS* psttQuoteP = 0 )
// else i return -1, which means "eol not found"
// if psttP contains eol then i return the number of strokes in psttP after the lath eol
//U::MOVE THIS INTO etherC

}
    }
        }
            }
                if( offf < cFindP ) break ;

                }
                    }
                        break ;

                        }
                            idlElementP = etherP.strIdF( tinP , idFirstP , sttq , sttClose , psttP ) ;
                            idFirstP = idf + cDo ;
                            strokeS sttClose( '}' ) ;
                        {
                        if( cDo < cMaxSource )                                                      // "{[key]:" WAS VERIFIED AND THERE ARE MORE STROKES TO INSPECT
                        idfElementP = idOpen ;
                        //etherP.traceF( tinP , T("YES: >>>>")+T(psttFind)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                    {
                    if( offc == cDo )                                                               // NO MISMATCH WAS FOUND

                    }
                        }
                            break ;
                            //etherP.traceF( tinP , T("NOT: >>>>")+T(psttFind)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
                        {
                        if( psttP[ CSpREFIX - 1 + idf + offc ].idAdam != psttFind[ CSpREFIX + offc ].idAdam )
                    {
                    for( ; offc < cDo ; offc ++ )
                    ZE( countT , offc ) ;
            
                    if( cDo > cMaxSource ) cDo = cMaxSource ;
                    countT cDo = psttFind->idAdam ;
    
                    strokeS* psttFind = *pptFindP[ offf ] ;
                {
                for( ; offf < cFindP ; offf ++ )
                ZE( countT , offf ) ;
                const countT cMaxSource = psttP->idAdam - idf + 1 ;
            {
            else
            }
                break ;
                idfElementP = idOpen ;                                                       // PARTIAL ELEMENT (ONLY THE '{')
            {
            if( !idf )
            //etherP.traceF( tinP , T("[idOpen]: >>>>")+TF2(idOpen,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("<<<<\r\n") ) ; //U:: TO FIND A BUG
        {
        if( idOpen )

        }
            }
                idOpen = !idf ? 0 : etherP.strIdF( tinP , idf , sttq , sttOpen , psttP ) ;

                if( !( cEscapes % 2 ) ) break ; // IF THERE IS AN EVEN NUMBER OF ESCAPES THEN THE CURSORED OPEN CURLY IS NOT ESCAPED

                }
                    else                                                   cEscapes ++ ;
                    if( psttP[ CSpREFIX - 1 + idOpen - offNeg ] != sttbs ) break ;
                {
                for( countT offNeg = 1 ; idOpen - offNeg ; offNeg ++ )
                countT offNeg = 1 ;
                ZE( countT , cEscapes ) ;
            {
            while( idOpen )
            strokeS sttbs( '\\' ) ;
        {
        if( idOpen > 1 )
        // SKIP OPEN CURLIES THAT ARE ESCAPED

        countT idOpen = etherP.strIdF( tinP , idf , sttq , sttOpen , psttP ) ;
        strokeS sttOpen( '{' ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    {
    while( idf )

                 idFirstP = 0 ; // I AM NOT GOING TO DO ANYTHING ELSE TO PARAMETERS UNLESS I FIND A SYNTACTICALLY VALID FULL OR PARTIAL ELEMENT
    countT idf = idFirstP ;
{
voidT findElementF( tinS& tinP , etherC& etherP , countT& idfElementP , countT& idlElementP , const strokeS* const psttP , countT& idFirstP , textC** pptFindP , const countT cFindP )

// 
// idf       : IF FOUND AND THERE ARE MORE STROKES THEN WILL BE THE POSITION OF THE WOTH STROKE AFTER THE ELEMENT
// idlElement: IF NOT 0 THEN THE ELEMENT AT idfELEMENT IS COMPLETE
// idfElement: IF NOT 0 THEN IS THE POSITION OF AN ELEMENT OR A PARTIAL ELEMENT AT THE END
// 
// OUTPUT:
// 
// idf       : MUST NOT BE 0 ; I WILL LOOK FOR AN ELEMENT BEGINNING AT OR AFTER idf
// idlElement: MUST BE 0
// idfElement: MUST BE 0
// 
// INPUT:
// 
// SPECS


}
    return - scSgn ;

    else                           scSgn = ((etherC*)pEther)->strCompareF( tinP , (strokeS*)pc1[ 3 ] , (strokeS*)pc2[ 3 ] ) ;
    else if( pc1[ 2 ] < pc2[ 2 ] ) scSgn = - 1 ;
    else if( pc1[ 2 ] > pc2[ 2 ] ) scSgn =   1 ;
    else if( pc1[ 1 ] < pc2[ 1 ] ) scSgn = - 1 ;
    else if( pc1[ 1 ] > pc2[ 1 ] ) scSgn =   1 ;
    else if( pc1[ 0 ] < pc2[ 0 ] ) scSgn = - 1 ;
         if( pc1[ 0 ] > pc2[ 0 ] ) scSgn =   1 ;
    ZE( sCountT , scSgn ) ;

    countT* pc2 = (countT*)c2P ;
    countT* pc1 = (countT*)c1P ;

    }
    {
    IFbEcAREFUL
{
countT subtractTimecard_330021c0_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return - scSgn ;

    else                           scSgn = ((etherC*)pEther)->strCompareF( tinP , (strokeS*)pc1[ 2 ] , (strokeS*)pc2[ 2 ] ) ;
    else if( pc1[ 1 ] < pc2[ 1 ] ) scSgn = - 1 ;
    else if( pc1[ 1 ] > pc2[ 1 ] ) scSgn =   1 ;
    else if( pc1[ 0 ] < pc2[ 0 ] ) scSgn = - 1 ;
         if( pc1[ 0 ] > pc2[ 0 ] ) scSgn =   1 ;
    ZE( sCountT , scSgn ) ;

    countT* pc2 = (countT*)c2P ;
    countT* pc1 = (countT*)c1P ;

    }
    {
    IFbEcAREFUL
{
countT subtractBuy_330021c0_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

/**/
*/
/*

}
    etherP.strFuseF( tinP , soulOutP , psttFlagP ) ;
{
voidT strFuseErrorFlag_330021c0_F( tinS& tinP , etherC& etherP , soulC& soulOutP , const strokeS* const psttFlagP )
//THIS IS USED ONLY TO MAKE IT EASY TO PUT A BREAKPOINT IN WO PLACE TO FIND WHERE ERRONEOUS INPUT IS DETECTED

}
    return 1 ;

    }
        }
            etherP.delF( tinP , psttTime ) ;

            }
                etherP.delF( tinP , psttShortThumbnail ) ;
                etherP.delF( tinP , psttCurrentName ) ;
                etherP.delF( tinP , psttShort ) ;
                }
                    etherP.delF( tinP , pstt1NameTriple ) ;
                    soulFileNamesP << pstt1NameTriple ;

                    if( psttShortThumbnail ) etherP.strFuseSeparateF( tinP , pstt1NameTriple , psttShortThumbnail , 0 , 0 , 0 , 0 , 0                                                                                                                          ) ;
                    if( psttCurrentName    ) etherP.strFuseSeparateF( tinP , pstt1NameTriple , psttCurrentName    , 0 , 0 , 0 , 0 , 0                                                                                                                          ) ;
                                             etherP.strFuseSeparateF( tinP , pstt1NameTriple , psttShort          , 0 , 0 , 0 , 0 , ( bControl ? 0 : CSpREFIX + psttCurrentName->idAdam + ( psttShortThumbnail ? CSpREFIX + psttShortThumbnail->idAdam : 0 ) ) ) ; ___( pstt1NameTriple ) ;
                    ZE( strokeS* , pstt1NameTriple ) ;

                    if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / accepted ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;

                    _IO_
                {
                else
                }
                    if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / REJECTED ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
                {
                if( !bOk )

                etherP.delF( tinP , psttPath ) ;
                }
                    }
                        etherP.delF( tinP , psttShorter ) ;

                        bOk = 0 ;
                        )
                            )
                                etherP.strIdF( tinP , psttExtMp3P , psttCurrentName , 1 ) != psttCurrentName->idAdam - 3
                                &&
                                idModeWalkP == ifcIDmODEsOILwALK_EDIT
                            (
                            ||
                            etherP.strIdF( tinP , psttNix4P , psttCurrentName , 1 )
                            ||
                            etherP.strIdF( tinP , psttNix3P , psttCurrentName , 1 )
                            ||
                            etherP.strIdF( tinP , psttNix2P , psttCurrentName , 1 )
                            ||
                            etherP.strIdF( tinP , psttNix1P , psttCurrentName , 1 )
                        (
                        if

                        etherP.strConvertToLowerCaseF( tinP , psttCurrentName ) ;
                        etherP.delF( tinP , postCurrentName ) ;

                        else                  { etherP.strMakeF(           tinP , psttCurrentName , psttShort       ) ; ___( psttCurrentName ) ; }
                        if( postCurrentName ) { etherP.strMakeFromOsTextF( tinP , psttCurrentName , postCurrentName ) ; ___( psttCurrentName ) ; }

                        }
                            if( etherP.diskFileExistsF( tinP , tFileHashedName  ) ) { etherP.boxGetShadowF( tinP , postCurrentName , costCurrentName , tFileHashedName  ) ; ___( postCurrentName ) ; }
                            etherP.traceF( tinP , T("archive error: currentname file not found: ")+tFileCurrentName ) ;
                        {
                        else
                        if( etherP.diskFileExistsF( tinP , tFileCurrentName ) ) { etherP.boxGetShadowF( tinP , postCurrentName , costCurrentName , tFileCurrentName ) ; ___( postCurrentName ) ; }

                        }
                            else if( bTrace ) etherP.traceF( tinP , T("[tFileThumbnail600]: ")+tFileThumbnail600+T(" error: not found") ) ;
                            }
                                if( bTrace ) etherP.traceF( tinP , T("[psttShortThumbnail]: ")+T(psttShortThumbnail) ) ;
                                etherP.strMakeF( tinP , psttShortThumbnail , T(psttShorter)+tMetaSuffix ) ; ___( psttShortThumbnail ) ;
                            {
                            if( etherP.diskFileExistsF( tinP , tFileThumbnail600 ) )
                            if( bTrace ) etherP.traceF( tinP , T("[tFileThumbnail600]: ")+tFileThumbnail600 ) ;
                            TN( tFileThumbnail600 , "" ) ; tFileThumbnail600 = T(psttPath)+T(psttShorter)+tMetaSuffix ; //U::OPTIMIZE: PASS T(".meta.thumb.0600x.jpg") IN AS PARAM
                            TN( tMetaSuffix , ".meta.thumb.0600x.jpg" ) ;
                        {

                        TN( tFileHashedName   , "" ) ; tFileHashedName   = T(psttPath)+T(psttShorter)+T(".meta.hashedname" ) ;        //U::OPTIMIZE: PASS T(".meta.hashedname.") IN AS PARAM
                        TN( tFileCurrentName  , "" ) ; tFileCurrentName  = T(psttPath)+T(psttShorter)+T(".meta.currentname") ;        //U::OPTIMIZE: PASS T(".meta.currentname.") IN AS PARAM
                        ZE( countT   , costCurrentName ) ;
                        ZE( osTextT* , postCurrentName ) ;
                        _IO_
                    {
                    else
                    if( !psttShorter ) { bOk = 0 ; }

                    }
                        etherP.delF( tinP , psttShorterNU ) ;
                        ___( psttShorter ) ;
                        ___( psttShorterNU ) ;
                        etherP.strBisectF( tinP , psttShorter , psttShorterNU , psttShort , T(".data.") , -1 , flSTRbISECT_null ) ; //U::OPTIMIZE: PASS T(".data.") IN AS PARAM
                        ZE( strokeS* , psttShorterNU ) ;
                        _IO_
                    {
                    ZE( strokeS* , psttShorter ) ;
                    _IO_
                {
                if( !bControl )

                boolT bControl = !!etherP.strIdF( tinP , T(".!.control.") , psttShort ) ;
                ZE( strokeS* , psttShortThumbnail ) ;
                ZE( strokeS* , psttCurrentName ) ;
                boolT bOk = 1 ;

                }
                    ___( psttShort ) ;
                    ___( psttPath ) ;
                    etherP.strBisectF( tinP , psttPath , psttShort , tFile , T("/") , -1 , flSTRbISECT_APPENDdELIMITER ) ;
                    _IO_
                {
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttPath ) ;
                if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / including file: ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
                _IO_
            {
            else
            }
                if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / excluding file: ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
            {
            if( !bHit )

            }
                while( ~hWalk ) ;
                }
                    }
                        break ;
                        bHit = 1 ;
                        if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / setting bHit for file: ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
                    {
                    if( etherP.strCompareF( tinP , psttTime , ppsttMinMax[ 0 ] ) >= 0 && etherP.strCompareF( tinP , psttTime , ppsttMinMax[ 1 ] ) <= 0 )

                    strokeS** ppsttMinMax = (strokeS**)&stTimeMinMaxP.upF( tinP , hWalk ) ;
                {
                do
                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                bHit = 0 ;
                if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / rsetting bHit since have specs to inspect: ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
                _IO_
            {
            if( stTimeMinMaxP )
            boolT bHit = 1 ;

            etherP.strSubstringF( tinP , psttTime , idf , idl , tFile ) ; ___( psttTime ) ;
            ZE( strokeS* , psttTime ) ;

            countT idl = idf + 0xc ;
            if( bTrace ) etherP.traceF( tinP , T("etherSoilWalkCBF / perhaps setting bHit for file: ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
            _IO_
        {
        else if( etherP.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , psttPrefixP , tFile ) && idf )
        }
            etherP.traceF( tinP , T("etherSoilWalkCBF / file name is too long: ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;
            //LOGrAW( "\"\r\n" ) ;
            //LOGrAW( postNameP ) ;
            //LOGrAW( "\"    \"" ) ;
            //LOGrAW( postNameP ) ;
            //LOGrAW3( "\r\n\r\nrem TOO LONG (REMOVE " , tFile.csF( tinP ) - costFileNameMax , " CHARS):\r\nren \"" ) ;
            //U:: TRACE A MESSAGE (DO THIS AFTER HAVE CONVERTED ARCHIVE TO FORMAT 7; KEEP SILENT TILL THEN TO REDUCE DISK ACTIVITY TO AVOIDPISSING OFF GODADDY TECHNICIANS WHO KILL PROCESSES
            _IO_
        {
        if( tFile.csF( tinP ) > costFileNameMax )
        const countT costFileNameMax = COSToSfILEnAMEmAX + 1 - sizeof( countT ) * 2 ; // "+ 1 - sizeof( countT ) * 2": THIS IS TO ENSURE THAT CHANGING idHome WILL NOT CAUSE THE FILE NAMES TO BECOME TOO LONG

        }
            if( bTrace ) /*if( !( idIn % ( TUCK << 4 ) ) )*/ etherP.traceF( tinP , T("etherSoilWalkCBF / inspecting ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" file \"")+T(postNameP)+T("\"") ) ;

            idIn = 1 + incv02AM( idInLath ) ;
            static countT idInLath ;
            _IO_
        {
        ZE( countT , idIn ) ;
        //bTrace = 1 ;
        ZE( boolT , bTrace ) ;

        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;

        TN( tFile , ifFileName ) ;
        ifFileNameC ifFileName( tinP , etherP , postNameP ) ;

        const strokeS* psttExtMp3P      = (strokeS*)pcArgP[ 9 ] ;
        const strokeS* psttNix4P        = (strokeS*)pcArgP[ 8 ] ;
        const strokeS* psttNix3P        = (strokeS*)pcArgP[ 7 ] ;
        const strokeS* psttNix2P        = (strokeS*)pcArgP[ 6 ] ;
        const strokeS* psttNix1P        = (strokeS*)pcArgP[ 5 ] ;
        const strokeS* psttPrefixP      = (strokeS*)pcArgP[ 4 ] ;
        boolT          idModeWalkP      =           pcArgP[ 3 ] ;
        soulC&         soulFileNamesP   =  *(soulC*)pcArgP[ 2 ] ;
        stackC&        stTimeMinMaxP    = *(stackC*)pcArgP[ 1 ] ;
        etherC&        etherP           = *(etherC*)pcArgP[ 0 ] ;
    {
    if( postNameP )

    _IO_
{
boolT etherSoilWalkCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

#define ifcIDmODEsOILwALK_INSPECTfILEnAMES   0xdddd0004
#define ifcIDmODEsOILwALK_ZIP                0xdddd0003
#define ifcIDmODEsOILwALK_EDIT               0xdddd0002
#define ifcIDmODEsOILwALK_REPORT             0xdddd0001

}
    while( -- cMaxCycles && cFound ) ;
    }
        }
            cFound += etherP.strReplaceF( tinP , psttP , 0 , psttLeverReplaceP , psttAfter , 0 , flSTRrEPLACE_IGNOREqUOTES | flSTRrEPLACE_USEjOT ) ; ___( psttP ) ;
            strokeS*& psttAfter = *(strokeS**)&(countT&)swReplaceP ;
            psttLeverReplaceP = (strokeS*)swReplaceP.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swReplaceP.cFlavorsF( tinP ) ;

        cFound = 0 ;
    {
    do
    ZE( countT , cFound ) ;
    countT cMaxCycles = TUCK ; // GRACEFULLY FAIL IF CYCLING OCCURS
{
voidT obeyReplacementsF( tinS& tinP , etherC& etherP , strokeS*& psttP , switchC& swReplaceP , strokeS*& psttLeverReplaceP )

}
    etherP.delF( tinP , psttodt ) ;
    if( bEmit ) etherP.boxPutF( tinP , tFileTranscript , tTranscript , tTranscript.csF( tinP ) ) ;

    }
        while( !bFound && !etherC::etPrimeIF( tinP ) && ~hFind ) ;
        }
            DEL( pInfo ) ;
            }
                //etherP.traceF( tinP , T("[value,idDeathType]:    ")+TF2(value,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(idDeathType,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

                //__( idDeathType ) ;
                //__( value ) ;             // NOT CHECKED, BECAUSE CAN BE CAUSED BY USER ERROR (TARGET ZIP FILE IS CORRUPT)
                }
                    etherP.diskFileOrDirDeleteF( tinP , tPathHover ) ;

                    }
                        }
                            etherP.delF( tinP , posti ) ;
                            }
                                if( !((thirdC&)etherP).c_strcmpIF( tinP , posti , tTranscript ) ) bEmit = 0 ;
                                //etherP.traceF( tinP , T("[posti]: ")+T(posti) ) ;
                            {
                            if( posti && costi )
                            etherP.boxGetShadowF( tinP , posti , costi , tPathHover+tFileTranscriptShort ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;

                            bFound = 1 ;
                        {
                        if( !value && !idDeathType )

                        etherP.osProcessF( tinP , countTC() , countTC() , value , idDeathType , tExeUnzip , tArg ) ; //THIS CAN FAIL (E.G. IF ZIP FILE IS CORRUPT
                        //hoverC hover( tinP , etherP , tPathHover ) ; //U::NOT THREAD SAFE: ADD SERIALIZATION
                    {

                    etherP.delF( tinP , psttu ) ;
                    TN( tPathHover , "" ) ; tPathHover = T("///ideafarm/ephemeral/tmp/")+T(psttu)+T("/") ;
                    //etherP.traceF( tinP , psttu ) ;
                    etherP.strUniqueF( tinP , psttu ) ; ___( psttu ) ;
                    ZE( strokeS* , psttu ) ;

                {
                ZE( countT , idDeathType ) ;
                ZE( countT , value ) ;
                //etherP.traceF( tinP , tArg ) ;
                //etherP.traceF( tinP , tExeUnzip ) ;

                TN( tArg , "" ) ; tArg = T(" \"")+T(osfnZipFile)+T("\" ")+tFileTranscriptShort ;

                osFileNameC osfnZipFile( tinP , etherP , tFileZip ) ;

                //etherP.traceF( tinP , T("day zip: ")+tFileZip ) ;

                TN( tFileZip , pInfo->psttIfoName ) ;
            {
            if( pInfo )
            etherP.diskFindFileOrDirF( tinP , pInfo , hFind , fnLike.pathF() , &pat ) ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        ZE( infoFileS* , pInfo ) ;
        ZE( boolT , bFound ) ;
    
        patternC pat( tinP , etherP , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        fileNameC fnLike( tinP , etherP , tFileDayZipLike ) ;

        }
            etherP.delF( tinP , psttm ) ;
            tExeUnzip = T(psttm) ;
            etherP.diskMapFileNameF( tinP , psttm , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/infozip/unzip.exe/unzip.exe") ) ; ___( psttm ) ;
            ZE( strokeS* , psttm ) ;
        {
        TN( tExeUnzip , "" ) ;
    {
    if( bEmit )

    }
        etherP.delF( tinP , posti ) ;
        }
            if( !((thirdC&)etherP).c_strcmpIF( tinP , posti , tTranscript ) ) bEmit = 0 ;
            //etherP.traceF( tinP , T("[posti]: ")+T(posti) ) ;
        {
        if( posti && costi )
        etherP.boxGetShadowF( tinP , posti , costi , tFileTranscript ) ; ___( posti ) ;
        ZE( countT   , costi ) ;
        ZE( osTextT* , posti ) ;
    {
    if( etherP.diskFileExistsF( tinP , tFileTranscript ) ) 
    boolT bEmit = 1 ;

    TN( tFileDayZipLike      , "" ) ; tFileDayZipLike = tArchiveP+T("!ideafarm.9.2.00000000.00000001.")+T(psttod0)+T(".???.!.day.zip") ;
    TN( tFileTranscript      , "" ) ; tFileTranscript = tArchiveP+tFileTranscriptShort ;
    TN( tFileTranscriptShort , "" ) ; tFileTranscriptShort = T("!ideafarm.9.2.00000000.00000001.")+T(psttodt)+T(".!.transcript.")+T(psttKey)+T(".ttt") ; // EXTENSION "ttt" IS USED RATHER THAN "txt" BECAUSE Rimstar AND OTHER EDITORS INSIST ON APPLYING WORD WRAP ON "txt" FILES, WHICH IS INCONVENIENT FOR KT SOURCE FILES

    }
        etherP.strFuseF( tinP , psttodt , TF4(ss>30&&mm!=59?mm+1:mm,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ) ;
        etherP.strFuseF( tinP , psttodt , TF4(hh,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ) ;
        etherP.strFuseF( tinP , psttodt , tAmp ) ;

        etherP.strFuseF( tinP , psttod0 , T("@0000") ) ;

        etherP.strFuseF( tinP , psttod0 , TF4(d+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ) ;
        etherP.strFuseF( tinP , psttodt , TF4(d+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ) ;
        etherP.strFuseF( tinP , psttod0 , TF4(m+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ) ;
        etherP.strFuseF( tinP , psttodt , TF4(m+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ) ;
        etherP.strFuseF( tinP , psttod0 , TF4(y+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,4,0xa) ) ;
        etherP.strFuseF( tinP , psttodt , TF4(y+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,4,0xa) ) ;
        etherP.strFuseF( tinP , psttod0 , 0 , TUCK ) ; ___( psttod0 ) ;
        etherP.strFuseF( tinP , psttodt , 0 , TUCK ) ; ___( psttodt ) ;
        TN( tAmp  , "@" ) ;
    {
    ZE( strokeS* , psttod0 ) ;
    ZE( strokeS* , psttodt ) ;
    TN( tDot  , "." ) ;

    etherP.osTimeToOldTimeF( tinP , ms , ss , mm , hh , d , m , y , dow , time1P , time2P ) ;
    ZE( countT  , dow ) ;
    ZE( sCountT , y   ) ;
    ZE( countT  , m   ) ;
    ZE( countT  , d   ) ;
    ZE( countT  , hh  ) ;
    ZE( countT  , mm  ) ;
    ZE( countT  , ss  ) ;
    ZE( countT  , ms  ) ;

    TN( tTranscript , psttvtP ) ;
{
voidT emitTranscriptIfChangedF( tinS& tinP , etherC& etherP , const strokeS* psttKey , const strokeS* psttvtP , countT time1P , sCountT time2P , const countT idTranscriptP , textC& tArchiveP )

}
    while( !etherC::etPrimeIF( tinP ) && ~hFind ) ;
    }
        DEL( pInfo ) ;
        }
            etherP.diskMoveFileOrDirF(   tinP , tToLong , pInfo->psttIfoName ) ;
            etherP.diskFileOrDirDeleteF( tinP , tToLong ) ; //U:: BUG: RACE: DATA LOSS CAN OCCUR HERE IF SOMETHING IS DELETED.  ALT: MOVE IT OUT OF THE WAY RATHER THAN DELETE IT
            //etherP.traceF( tinP , T("deleting ")+tToLong ) ;
            TN( tToLong , "" ) ; tToLong = tTo+tShort ;

            }
                etherP.delF( tinP , psttShort ) ;
                etherP.delF( tinP , psttPathNU ) ;
                tShort = T(psttShort) ;
                ___( psttShort ) ;
                ___( psttPathNU ) ;
                etherP.strBisectF( tinP , psttPathNU , psttShort , pInfo->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttPathNU ) ;
            {
            TN( tShort , "" ) ;
        {
        if( pInfo && etherP.strIdF( tinP , sttSlash , pInfo->psttIfoName , - 1 ) != pInfo->psttIfoName->idAdam )
        etherP.diskFindFileOrDirF( tinP , pInfo , hFind , psttFromP ) ;
    {
    do
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    ZE( infoFileS* , pInfo ) ;
    TN( tTo , psttToP ) ;
    strokeS sttSlash( '/' ) ;
{
voidT pour360021c1F( tinS& tinP , etherC& etherP , const strokeS* const psttToP , const strokeS* const psttFromP )

;

    "}\r\n"
    "    }\r\n"
    "        root\r\n"
    "         :archive: \\x\\rThe IdeaFarm (tm) Operations Archive\r\n"
    "\" }\r\n"

osTextT* postSoilForReport4 =

;

    "          {preInclude: \""
    "    {body:\r\n"
    "\" }\r\n"

osTextT* postSoilForReport3 =

;

    "    {namespace: \""
    "\" }\r\n"

osTextT* postSoilForReport2 =

;

    "    {folder: \""
    "    {flags: noZip beep fragnote}\r\n"
    "    {mode: archive }\r\n"
    "    {file: index }\r\n"
    "{ktr:\r\n"
    "\r\n"
    "}\r\n"
    "    {replace: **__ENDcHRONICLE__**           \"\\\\m\\\\n\\\\m</td></tr></table></center>\"                                          }\r\n"
    "    {replace: **__P3__**            \"<td>\\\\m\"                                                              }\r\n"
    "    {replace: **__P2JPG__**         \"\\\\n\"                                                                  }\r\n"
    "    {replace: **__P1__**            \"\\\\m</td>\"                                                             }\r\n"
    "    {replace: **__BEGINcHRONICLE__**         \"<p><center><table><tr><td>\\\\m\"                                        }\r\n"
    "    {replace: **__AUDIOeARLY__** \"<tr style=\\\\\\\\\"background-color:#420\\\\\\\\\"><td style=\\\\\\\\\"width:608px; padding: 8px 8px 8px 8px\\\\\\\\\" align=center valign=center>\\\\rpictures before 2009-09-05 exist but have not yet been added[**__TIMEnOpIC__**]\" }\r\n"
    "    {replace: **__AUDIO__** \"<tr style=\\\\\\\\\"background-color:#420\\\\\\\\\"><td style=\\\\\\\\\"width:608px; padding: 8px 8px 8px 8px\\\\\\\\\" align=center valign=center>\\\\rU::put this recording next to the temporally closest picture[**__TIMEnOpIC__**]\" }\r\n"
    "    {replace: **__NEOL__** \"\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__ENDnEWlINE__**      \"</td></tr></table></td></tr>\\\\m\\\\n\\\\r\" }\r\n"
    "    {replace: **__NNeND__** \"[**__NULLnOTE__**][**__END__**]\" }\r\n"
    "    {replace: **__END__**      \"\\\\m</td></tr></table></td></tr>\" }\r\n"
    "    {replace: **__NOTEnEWlINE__**           \"</td></tr><tr><td><hr>\\\\m\\\\n\\\\r\" }\r\n"
    "    {replace: **__NULLnOTE__** \"[**__NOTE__**]\\\\r\\\\n\" }\r\n"
    "    {replace: **__NOTE__**           \"</td></tr><tr><td><hr>\\\\m\" }\r\n"
    "    {replace: **__TIME__**       \"\\\\i[**__TIMEnOpIC__**]\" }\r\n"
    "    {replace: **__TIMEnOpIC__**     \"</td><td><table><tr><td align=right valign=center>\" }\r\n"
    "    {replace: **__BEGINnOpIC__** \"<tr style=\\\\\\\\\"background-color:#420\\\\\\\\\"><td style=\\\\\\\\\"width:608px; padding: 8px 8px 8px 8px\\\\\\\\\" align=center valign=center>\" }\r\n"
    "    {replace: **__BEGINbROWN__** \"<tr style=\\\\\\\\\"background-color:#420\\\\\\\\\"><td style=\\\\\\\\\"width:608px; padding: 8px 8px 8px 8px\\\\\\\\\" align=left valign=center>\\\\i\" }\r\n"
    "    {replace: **__BEGIN__**                                            \"<tr><td style=\\\\\\\\\"width:608px; padding: 8px 8px 8px 8px\\\\\\\\\" align=left valign=center>\\\\i\" }\r\n"
    "    {replace: **__ENDtABLE__** \"</table></center>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__BEGINtABLE__** \"<center><table>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__ENDdOC__** \"</td></tr></table>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__BEGINdOC2__** \"</td></tr><tr><td>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__BEGINdOC1__** \"<table style=\\\\\\\\\"width:100%\\\\\\\\\"><tr><td>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__BEGINdOC__** \"<table style=\\\\\\\\\"width:100%\\\\\\\\\"><tr><td>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD77__** \"</td></tr></table>\" }\r\n"
    "    {replace: **__TOCaD76__** \"</td><td align=right valign=center style=\\\\\\\\\"\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD75__** \"</td><td align=left valign=center style=\\\\\\\\\"width:20px\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD74__** \"</td></tr></table><p><table style=\\\\\\\\\"width:100%\\\\\\\\\"><tr><td align=left valign=center style=\\\\\\\\\"width:300px\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD73__** \"</td><td align=right valign=center style=\\\\\\\\\"width:300px\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD72__** \"</td><td align=right valign=center style=\\\\\\\\\"width:20px\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD71__** \"<p><table style=\\\\\\\\\"width:100%\\\\\\\\\"><tr><td align=left valign=center style=\\\\\\\\\"\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD44__** \"</td></tr></table>\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD43__** \"</td><td align=right valign=center style=\\\\\\\\\"width:300px\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD42__** \"</td><td align=right valign=center style=\\\\\\\\\"width:20px\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "    {replace: **__TOCaD41__** \"<p><table style=\\\\\\\\\"width:100%\\\\\\\\\"><tr><td align=left valign=center style=\\\\\\\\\"\\\\\\\\\">\\\\m\\\\r\\\\n\" }\r\n"
    "\r\n{replacements:\r\n"

osTextT* postSoilForReport1 =

;

    "\r\n"

osTextT* postReportEpilog =

;

    "\r\n"

osTextT* postReportProlog =

#define flETHERsOILrEPORT_FRAGnOTE 0xe00001ff
#define flETHERsOILrEPORT_null     0xe00000ff

//#define CfLAG1mAX TUCK

#define CSTTdOsHORT 0x80
#define CfLAG23mAX 0x10
#define CfLAG1mAX ( TUCK << 2 )

//U:: 20160428@2015: SUPPORT NULL STEPS (LEVEL1 KEYS THAT RESULT IN NOTHING DONE)

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

