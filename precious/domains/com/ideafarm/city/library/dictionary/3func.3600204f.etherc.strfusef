
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        delF( tinP , psttOutP ) ;_WQ
        ___( psttOutP ) ;_WQ
        *pSoulP << psttOutP ;_WQ
    {
    if( pSoulP && *pSoulP ) // EVEN IF I AM NOT THE WO WHO PUSHED THE CONTENT

    while( psttic < psttie ) ;_WQ
    }
        if( !psttic ) break ;

        }
            }
                psttoe = psttoc   + cstta    ;_WQ
                psttoc = psttOutP + CSpREFIX ;_WQ
                SETpREFIX( psttOutP , 0 , cstta )
            {
            if( !POOP )
            __Z( psttOutP ) ;_WQ
            POSTPONEtEST( psttOutP ) ;_WQ
            third.newF( tinP , LF , psttOutP , CSpREFIX + cstta ) ; //CALLER MUST TAG ___( psttOutP ) ;_WQ

            ;_WQ
                    : CSTTsOULfUSEdEFAULT
                    ? csttExtraP
                : csttExtraP
                    : csttExtraP
                    ? psttie - psttic + csttExtraP
                ? psttic
            countT cstta = !pSoulP
        {
        if( !psttOutP )
        // ALLOCATE AN OUTPUT STRING (ALWAYS DONE, EVEN IF NO INPUT

        }
            }
                psttoe = psttoc = 0 ;_WQ
                delF( tinP , psttOutP ) ;_WQ
                ___( psttOutP ) ;_WQ
                if( pGrabP ) pGrabP->ungrabF( tinP ) ;_WQ
                *pSoulP << psttOutP ;_WQ
                if( pGrabP ) pGrabP->grabF( tinP , TAG( TAGiDnULL ) ) ;_WQ
            {
            else
            }
                break ;
                __1 ;_WQ
            {
            if( !pSoulP )
        {
        if( psttoc && psttic && psttic < psttie ) // IF HAVE OUTPUT AND STILL HAVE MORE INPUT TO PROCESS
        // MOVE OUTPUT TO FIFO SOUL

        }
            //}
            //    LOGrAW( "<<<<\r\n" ) ; 
            //    LOGrAW( postTock ) ;_WQ
            //    LOGrAW( "fusePiece: >>>>" ) ; 
            //    postTock[ offi ] = 0 ;_WQ
            //    for( offi = 0 ; offi < psttOutP->idAdam ; offi ++ ) postTock[ offi ] = (osTextT)psttOutP[ CSpREFIX + offi ].idAdam ;_WQ
            //    ZE( countT , offi ) ;_WQ
            //    static osTextT postTock[ TOCK ] ;_WQ
            //    //U::TO FIND A BUG.  CAN'T USE traceF CAUSE WOULD RECURSE INFINITELY
            //{
            //if( pSoulP && sttEscapeP.idAdam  )

            while( cDo -- ) *( psttoc ++ ) = *( psttic ++ ) ;_WQ

            psttOutP[ 0 ].idAdam += cDo ;_WQ
            psttOutP[ 2 ].idAdam -= cDo ;_WQ

            }
                }
                    if( psttFound ) cDo = psttFound - psttic ;_WQ
                    
                    }
                        }
                            psttLook -- ;_WQ
                    
                            }
                                break ;
                                psttFound = psttLook - 1 ;_WQ
                            {
                            )
                                )
                                    psttFound > psttLook - 1                                                // BELOW PREVIOUS FIND
                                    ||
                                    !psttFound                                                              // WOTH FOUND
                                (
                                &&
                                psttLook[ - 1 ] == sttEscapeP                                               // PRECEDED BY ESCAPE STROKE
                                &&
                                psttLook[ 0 ] == psttDelimiterPairsP[ CSpREFIX + offp ]                     // LOOKING AT OPENING DELIMITER
                            (
                            else if
                            if( psttLook[ 0 ] == psttDelimiterPairsP[ CSpREFIX + offp + 1 ] ) break ;       // CLOSING DELIMITER SO AM OK FOR THIS DELIMITER PAIR
                        {
                        while( cLook -- )
                        countT cLook = cMaxLook ;_WQ
                    
                        // BUT IF I FIND AN OPENING DELIMITER THEN I REDUCE THE LENGTH TO OMIT IT AND THEN QUIT INSPECTING
                        // IF I FIND A CLOSING DELIMITER THEN I AM OK SO I QUIT INSPECTING
                        // I INSPECT BACKWARDS FROM THE LATH STROKE
                        // ASSUME: DELIMITERS CANNOT BE NESTED
                        // THE GOAL IS TO AVOID HAVING AN UNTERMINATED DELIMITED STRING AT THE END
                        // 
                        // RECIPE
                    
                        const strokeS* psttLook = psttic + cDo - 1 ;_WQ
                    {
                    for( countT offp = 0 ; offp < csttdp ; offp += 2 )
                    ZE( const strokeS* , psttFound ) ;_WQ
                    if( cMaxLook > cDo - 2 ) cMaxLook = cDo - 2 ; // EXCLUDES WOTH STROKE AND THE ESCAPE CHAR, WHICH I DO NOT LOOK DIRECTLY AT
                    countT cMaxLook = csttMaxDelimiterP ? csttMaxDelimiterP + 2 : - 1 ;_WQ
                    countT csttdp = psttDelimiterPairsP->idAdam ;_WQ
                {
                if( psttDelimiterPairsP )

                }
                    cDo -- ;_WQ
                {
                while( cDo > 1 && psttic[ cDo - 1 ] == sttEscapeP )
            {
            if( co < ci && !!sttEscapeP )

            ;_WQ
                : co
                ? ci
            countT cDo = ci < co
            countT ci = psttie - psttic ;_WQ
            countT co = psttoe - psttoc ;_WQ
        {
        if( psttoc && psttic )
        // FILL UP THE OUTPUT STRING
    {
    do

    }
        countT foo = 2 ; //U;; TO FIND A BUG
    {
    if( !!sttEscapeP )

    strokeS*       psttoe = !psttoc   ? 0 : psttoc              + psttOutP[ 2 ].idAdam ;_WQ
    strokeS*       psttoc = !psttOutP ? 0 : psttOutP + CSpREFIX + psttOutP->idAdam ;_WQ
    const strokeS* psttie = !psttic   ? 0 : psttic              + psttInP->idAdam ;_WQ
    const strokeS* psttic = !psttInP  ? 0 : psttInP  + CSpREFIX ;_WQ

    _INoLD_

    }
        if( POOP ) return ;
        }
            __NZ( psttDelimiterPairsP->idAdam % 2 ) ;_WQ
            __Z( psttDelimiterPairsP->idAdam ) ;_WQ
        {
        if( psttDelimiterPairsP ) 
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::strFuseF( tinS& tinP , strokeS*& psttOutP , const strokeS* const psttInP , soulC* pSoulP , grabC* pGrabP , const strokeS sttEscapeP , const strokeS* psttDelimiterPairsP , const countT csttMaxDelimiterP , const countT csttExtraP )/*1*/

/**/
*/
 csttExtraP
  if not 0 then is the maximum length, excluding the delimiters, that a delimited string can be
  if 0 then delimited strings can be of any length and i will not split them
 csttMaxDelimiterP
  i will ensure that i do not split any occurance of sttEscapeP followed immediately by a delimited string
  each pair of strokes is interpreted as a delimiter pair
  if not 0 then must point to a string whose length is even
  if 0 then i will just ensure that sttEscapeP is not the lath stroke in any part
 psttDelimiterPairsP
  if not 0 then i will avoid splitting an assumed oo stroke escape sequence when pushing split output into *pSoulP
  can be 0
 sttEscapeP
  if not 0 then *pGrabP will be grabbed when *pSoulP is being accessed
  can be 0
 pGrabP
   the caller can force output to be in *pSoulP by preloading it with a null length string
  the result will either be in psttOutP xor in *pSoulP
  if not 0 then *pSoulP will be used as a fifo buffer to store the result
  if 0 then psttOutP must either be 0 or contain enough room for the result to be appended
  can be 0
 pSoulP
    using the default allocation size reduces memory paging and poolC administration overhead
   if pSoulP and !csttExtraP then the default allocation size CSTTsOULfUSEdEFAULT will be used
   else csttExtraP specifies the allocation size to use
   if pSoulP is 0 then csttExtraP specifies unused strokeS objects to will be included at the end of the allocated string, psttOutP
  meaning depends upon whether pSoulP is 0
 csttExtraP
  normally is not 0
  can be 0
 psttInP
  can either be 0 or point to a writeable string of strokeS objects
 psttOutP
arguments
  \<A HREF=\"5.3910104.1.1.0.html\"\>3910104:  WAKEsHOW( "example.simplest.func.1030059.etherC.strFuseF" )\</A\>
 simplest
examples
\<A HREF=\"5.1030059.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strFuseF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

