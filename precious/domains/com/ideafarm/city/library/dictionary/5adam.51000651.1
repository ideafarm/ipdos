
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.osThreadSwitchingDesireF( tinP , idDesireSave ) ;

}
    }
        }
            while( cFail ) ;
            }
                _OUT_
                if( cFail ) { ++ s ; ether.osSleepF( tinP , TOCK ) ; }
                _INoLD_

                FORsTRINGSiNsPANNEDcOMBINEDtAIL1
                }
                    }
                        }
                            etThread.osThreadF( TaRG1( tmObeySoilF ) , (countT)&cFail , (countT)(strokeS*)tPickSoil , (countT)(strokeS*)tBounce , (countT)psttFileName , (countT)posti , costi ) ; psttFileName = 0 ; posti = 0 ;
                            etThread.strMakeF( tinP , psttFileName , tFileBeingEaten ) ; ___( psttFileName ) ;
                            ZE( strokeS* , psttFileName ) ;
                        {
                        else
                        else if( !costi ) etThread.delF( tinP , posti ) ;
                        }
                            CONoUTrAW( T("could not input ")+tFileBeingEaten+T(" ; will nap, then retry\r\n") ) ;
                            cFail ++ ;                                                                                  // INCREMENT cFail
                            POOPR
                        {
                        if( POOP )                                                                                  // IF COULD NOT GET THE FILE

                        tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , tFileBeingEaten , 1 ) ; ___( posti ) ;        // GET THE FILE
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;
                        SCOOPS

                        }
                            if( POOP ) POOPR
                            tinP.pEtScratch->diskMoveFileOrDirF( tinP , tFileBeingEaten , psttc1 , 1 ) ;

                            etThread.delF( tinP , psttShort ) ;
                            etThread.delF( tinP , psttPath ) ;
                            tFileBeingEaten = tEatingSoil+T(psttShort) ;
                            ___( psttShort ) ;
                            ___( psttPath ) ;
                            countT ids = etThread.etherC::strBisectF( tinP , psttPath , psttShort , psttc1 , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttPath ) ;
                        {
                        TN( tFileBeingEaten , "" ) ;
                    {
                    if( psttc1[ CSpREFIX - 1 + psttc1->idAdam ].idAdam != '/' )                                 // IF NOT DIRECTORY

                    //CONoUTrAW( T("inspecting: ")+T(psttc1)+T("\r\n") ) ;
                {
                FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
                etThread.boxMenuF( tinP , soul1m , tDropSoil+T("*.soil") , 0 , TUCK ) ; // FOR ALL FILES OR DIRS "*.soil"
                soulC soul1m( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.eat.menu" ) ;

                cFail = 0 ;
            {
            do
            ZE( countT , cFail ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;

            if( bWoth ) bWoth = 0 ;
        {
        if( etThread.etherC::diskWaitDirF( tinP , hWait , ether , tDropSoil , flWAITdIR_FILEnAME ) || bWoth )
    {
    while( !ether && !POOP )
    handleC hWait( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    boolT bWoth = 1 ;
{
IFsCRATCH

const countT idDesireSave = etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIER ) ;

}
    //ether.osThread AdamF( tinP , ifcIDaDAM_ROOThTTPsERVER ) ;
    //THIS IS THE WO TO USE, BUT ONLY IF MASTER: ether.ifcHireF( tinP , T("U::TO FIND A WINDOWS RESOURCE LEAK") , ifcIDaDAM_ROOThTTPsERVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; //U:: TO FIND A WINDOWS RESOURCE LEAK
{
if( !etThread.strCompareF( tinP , tComputerName , T("ifo.master") ) )

ether.osThreadF( TaRG1( tmHireF ) ) ;

etThread.osThreadF( TaRG1( tmCleanF ) , (countT)(strokeS*)tBounce , (countT)(strokeS*)tDropSoil ) ;
//etThread.osThreadF( TaRG1( tmPingF ) ) ; //U::COMMENTED OUT BECAUSE SAW A FAILURE IN s_writeF 20121219@2102

//etThread.osThreadF( TaRG1( tmFixArcNamesF ) ) ; // REDUNDANT, JUST IN CASE A FILE WITH A BAD NAME HAS GOTTEN INTO THE ARCHIVE ; U::ADD bQuitP PARAMETER
//20161112@1559: DISABLED AS PART OF ENHANCING 6d9 TO OPTIONALLY RENAME ALL LOCAL MASTER FILES TO NUMERIC NAMES, PRESERVING THE ORIGINAL NAME IN A HASH LOOKUP FILE

}
    etThread.osThreadF( TaRG1( tmRenameF ) , (countT)psttDropIn , (countT)psttNeverDropHere ) ;

    etThread.strMakeF( tinP , psttNeverDropHere , tNeverDropHere ) ; ___( psttNeverDropHere ) ;
    etThread.strMakeF( tinP , psttDropIn , tDropIn ) ; ___( psttDropIn ) ;
    ZE( strokeS* , psttNeverDropHere ) ;
    ZE( strokeS* , psttDropIn ) ;
{

//) ;
//
//    "If you generate too much of data within a single quarter, divide the quarter into 2 or 4 or 8 reporting periods.\r\n"
//    "When each quarter ends, use a final version of the file for that quarter to obtain IdeaFarm " "(tm) Hoe reports for that quarter.\r\n"
//    "Workaround: Limit your input file to data for the current IdeaFarm " "(tm) City calendar quarter.\r\n"
//    "\r\n"
//    "IPDOS (tm) will not realize this architectural potential until it is ported to the 04 bit cpu architecture.\r\n"
//    "IPDOS (tm) is designed to run quickly and efficiently on 04 bit (64_9 bit) computers with lots of memory available.\r\n"
//    "The file that you have dropped is larger than ")+TF2(costiMax,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" bytes (")+TF4(costiMax,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,0,0xa)+T(" bytes).\r\n"
//    "\r\n"
//    "Error: The input file is too large.\r\n"
//
//TN( tErrorFileTooBig , "" ) ; tErrorFileTooBig = T(
//const countT costiMax = CSTTmAXsOIL ;

}
    }
        }
            etThread.diskMakeDirF( tinP , *pptDir[ offi ] ) ;
            cMade ++ ;
        {
        )
            )
                )
                    offi != 4
                    &&
                    offi != 3
                (
                ||
                !cMade
            (
            &&
            !etThread.diskFileExistsF( tinP , *pptDir[ offi ] )
        (
        if
    {
    for( countT offi = 0 ; offi < sizeof pptDir / sizeof pptDir[ 0 ] ; offi ++ )
    ZE( countT , cMade ) ;

    //20140415@1204: DISABLED THIS SO WILL CREATE ANY MISSING FOLDERS: if( !etThread.diskFileExistsF( tinP , tBounce ) )

    } ;
        &tPickSoil        // 9
        &tPickToProcess , // 8
        &tEatingSoil    , // 7
        &tDropSoil      , // 6
        &tDropIn2       , // 5
        &tDropIn1       , // 4 OPTIONAL: NOT CREATED UNLESS NONE EXIST
        &tDropIn        , // 3 OPTIONAL: NOT CREATED UNLESS NONE EXIST
        &tNeverDropHere , // 2
        &tDropArchive   , // 1
        &tBounce        , // 0
    {
    textC* pptDir[] =
{
TN( tPickSoil      , "///ideafarm/IdeaFarm " "(tm)/" ) ; tPickSoil      += tUser+T("/Pick Up SOIL (tm) Reply Text Here/"                                             ) ;
TN( tPickToProcess , "///ideafarm/IdeaFarm " "(tm)/" ) ; tPickToProcess += tUser+T("/Pick Up Files Ready for Processing Here/"                                       ) ;
TN( tEatingSoil    , "///ideafarm/IdeaFarm " "(tm)/" ) ; tEatingSoil    += tUser+T("/SOIL (tm) Text Being Eaten/"                                                    ) ;
TN( tDropSoil      , "///ideafarm/IdeaFarm " "(tm)/" ) ; tDropSoil      += tUser+T("/Drop a Copy of SOIL (tm) Text Here/"                                            ) ;
TN( tDropIn2       , "///ideafarm/IdeaFarm " "(tm)/" ) ; tDropIn2       += tUser+T("/Drop Files From Devices Here/voice.recorder/"                                   ) ;
TN( tDropIn1       , "///ideafarm/IdeaFarm " "(tm)/" ) ; tDropIn1       += tUser+T("/Drop Files From Devices Here/camera/"                                           ) ;
TN( tDropIn        , "///ideafarm/IdeaFarm " "(tm)/" ) ; tDropIn        += tUser+T("/Drop Files From Devices Here/"                                                  ) ;
TN( tNeverDropHere , "///ideafarm/IdeaFarm " "(tm)/" ) ; tNeverDropHere += tUser+T("/never.drop.here/"                                                               ) ;
TN( tDropArchive   , "///ideafarm/IdeaFarm " "(tm)/" ) ; tDropArchive   += tUser+T("/Drop Files Here To Archive/"                                                    ) ;
TN( tBounce        , "///ideafarm/IdeaFarm " "(tm)/" ) ; tBounce        += tUser+T("/Pick Up Rejected Files Here/"                                                   ) ;

TN( tDesk         , "///ideafarm/IdeaFarm " "(tm)/"  ) ;
TN( tUser         , thirdC::postUserNameIF() ) ;

}
    etThread.delF( tinP , psttName ) ;
    if( psttName && psttName->idAdam ) tComputerName = T(psttName) ;

    //U::CALL THIS ONLY IF SETTINGS FILES EXIST: etThread.querySettingF( tinP , psttName , T("computer.name") ) ;
    ZE( strokeS* , psttName ) ;

    TN( tHome , "" ) ; tHome = T("///d/ideafarm.home.")+TF2(etherC::ifc_idHomeIdisk_IF(),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
{
TN( tComputerName , "" ) ;

TODO

//DONE( tmFixArcNamesF )
//etThread.traceF( tinP , T("archive: fixed  bad file names, if any") ) ;
//etThread.disk FixBadFileNamesF( tinP , T("///ideafarm/IdeaFarm " "(tm)/")+T(thirdC::postUserNameIF())+T("/Drop Files Here To Archive/") ) ;
//etThread.traceF( tinP , T("archive: fixing bad file names, if any") ) ;
//TASK( tmFixArcNamesF )

DONE( tmHireF )

//U::ether.ifcHireF( tinP , T("PISS") , ifcIDaDAM_SNAPwORDS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; // flHIRE_DISPLAYaUTO CAN BE COMMENTED OUT TO AVOID WDW FOR ROOT CLOUD INSTANCE WHICH IS USUALLY NOT INTERESTING

}
    _OUT_
    ++ s ; ether.osSleepF( tinP , TOCK << 4 ) ;  // ENOUGH TIME SO THAT I WILL BE ABLE TO PROCESS A SETTINGS UPDATE
    _INoLD_
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{

TASK( tmHireF )

DONE( tmObeySoilF )
etThread.traceF( tinP , T("thread exit") ) ;
}
tinP.monitor.idWhat2 = 0 ;
etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;
etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_DISABLE ) ;

    etThread.delF( tinP , postiP ) ;
    etThread.delF( tinP , psttFileNameP ) ;
    etThread.delF( tinP , psttShort ) ;
    etThread.delF( tinP , psttPath ) ;
    }
        _OUT_
        }
            _OUT_
            }
                inc02AM( cFailP ) ;                                                                     // INCREMENT cFail
                POOPR
            {
            if( POOP )                                                                                  // IF COULD NOT MOVE UNIQUE
            etThread.delF( tinP , psttn ) ;
            tinP.pEtScratch->diskMoveFileOrDirUniqueF( tinP , psttn , psttFileNameP , 1 ) ;                    // MOVE UNIQUE TO ANUS
        
            etThread.strMakeF( tinP , psttn , tTo , TUCK+tShort.csF( tinP ) ) ; ___( psttn ) ;
            ZE( strokeS* , psttn ) ;
        
            POOPR
            _INoLD_
        {
        if( POOP )                                                                                  // IF COULD NOT MOVE TO ANUS
        tinP.pEtScratch->diskMoveFileOrDirF( tinP , tTo+tShort , psttFileNameP , 1 ) ;                     // MOVE TO ANUS
        etThread.traceF( tinP , T("cleaning up") ) ;

        }
            _OUT_
            }
                _OUT_
                }
                    _OUT_
                    }
                        _OUT_
                        }
                            _OUT_
                            etThread.delF( tinP , postr ) ;
                            etThread.fileWriteF( tinP , hFile1 , postr , costr ) ;
                        
                            etThread.delF( tinP , psttr ) ;
                            countT costr = etThread.strMakeF( tinP , postr , psttr ) ; ___( postr ) ;
                            ZE( osTextT* , postr ) ;
                    
                            soulAsciiOut >> psttr ; ___( psttr ) ;
                            ZE( strokeS* , psttr ) ;
                            _INoLD_
                        {
                        while( soulAsciiOut )
                        OPENfILEwRITE1( tTo+T("poop.")+tShort )
                        _INoLD_
                    {
                    tTo = tPickSoil ;                                                                              // POINT TO BLOOD
                    etThread.traceF( tinP , T("writing pseudoduplicate file of input file from soulAsciiOut") ) ;

                    etThread.etherSoilF( tinP , ether , soulAsciiOut , soulNativeLint , ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE , 0 , flETHERsOILf_CONSUMEiNPUT , postiP , costiP ) ;
                    soulC soulAsciiOut( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.ascii.out" ) ; //THIS IMAGE SHOULD BE IDENTICAL TO THE LINT IMAGE IF NO MARKS, SO THIS STEP COULD BE ELIMINATED; WE DO IT THIS WAY BECAUSE, OTHER THAN SOME MORE CODE, IT IS COSTLESS AND CONFIDENCE OF CORRECTNESS IS HIGHER (LINT MARKUP CODE IS COMPLEX SO MIGHT CONTAIN BUGS)
                    etThread.traceF( tinP , T("loading soulAsciiOut") ) ;
                    _INoLD_
                {
                if( soulNativeLint )
                // TAKES A LOT OF TIME AND I DO NOT NEED IT, EXCEPT WHEN DEBUGGING SOIL REPLACEMENTS

                }
                    _OUT_
                    }
                        _OUT_
                        etThread.delF( tinP , postr ) ;
                        etThread.fileWriteF( tinP , hFile1 , postr , costr ) ;
                    
                        etThread.delF( tinP , psttr ) ;
                        countT costr = etThread.strMakeF( tinP , postr , psttr ) ; ___( postr ) ;
                        ZE( osTextT* , postr ) ;
            
                        soulr >> psttr ; ___( psttr ) ;
                        ZE( strokeS* , psttr ) ;
                        _INoLD_
                    {
                    while( soulr )
                    OPENfILEwRITE1( tPickSoil+tPrefix+tFile+tSuffix )
            
                    etThread.traceF( tinP , T("loading soulReports / [cFields,tFile]: ")+TF2((countT)soulr,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    \"")+tFile+T("\"") ) ;
                    soulReports >> soulr ;
                    soulC soulr( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.report" ) ;
            
                    etThread.delF( tinP , psttf ) ;
                    tFile = T(psttf) ;
                    soulReports >> psttf ; ___( psttf ) ;
                    ZE( strokeS* , psttf ) ;
                    etThread.traceF( tinP , T("writing report file") ) ;
                    _INoLD_
                {
                while( soulReports )
                TN( tFile , "" ) ;
                TN( tSuffix , ".soil" ) ;
                TN( tPrefix , "report." ) ;
                TN( tn , "" ) ;
            
                DEL( tinP.pBarryUtility ) ;
                while( !ether && !POOP && etThread.etherSoilF( tinP , ether , soulReports , soulNativeLint , ifcIDmODEeTHERsOIL_REPORT , 0 , flETHERsOILf_null/*flETHERsOILf_CONSUMEiNPUT*/ , postiP , costiP ) ) ; // WHILE IS TO OBEY bRepeat ; WILL REPEAT FOREVER UNTIL I AM FIRED
                do     soulReports.removeAllF( tinP ) ;

                etThread.traceF( tinP , T("loading soulReports / calling etherSoilF") ) ;
                //TO GET REPORTS, COMMENT OUT THE CONSUMEiNPUT FLAG

                soulC soulReports( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.reports" , CBjOTbOOKwRAPPER( CBjOTbOOKdEFAULT , 1 ) ) ;
                etThread.traceF( tinP , T("loading soulReports") ) ;
                _INoLD_
            {
            else
            }
                _OUT_
                }
                    _OUT_
                    }
                        _OUT_
                        etThread.delF( tinP , postr ) ;
                        etThread.fileWriteF( tinP , hFile1 , postr , costr ) ;
                    
                        etThread.delF( tinP , psttr ) ;
                        countT costr = etThread.strMakeF( tinP , postr , psttr ) ; ___( postr ) ;
                        ZE( osTextT* , postr ) ;

                        soulAsciiLint >> psttr ; ___( psttr ) ;
                        ZE( strokeS* , psttr ) ;
                        _INoLD_
                    {
                    while( soulAsciiLint )
                    OPENfILEwRITE1( tTo+T("poop.")+tShort )
                    _INoLD_
                {
                tTo = T(psttzBounceP) ;                                                                               // POINT TO ANUS
                etThread.traceF( tinP , T("abort: writing poop file") ) ;

                //}
                //    etThread.delF( tinP , psttp ) ;
                //    etThread.strokeF( tinP , T("[part]: \"")+T(psttp)+T("\"\r\n") ) ;
                //    soulAsciiLint >> psttp ; ___( psttp ) ;
                //    ZE( strokeS* , psttp ) ;
                //{
                //while( soulAsciiLint )
                //U:: TO FIND A BUG

                etThread.etherSoilF( tinP , ether , soulAsciiLint , soulNativeLint , ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE , 0 , flETHERsOILf_CONSUMEiNPUT , postiP , costiP ) ;
                soulC soulAsciiLint( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.ascii.lint" ) ;
                etThread.traceF( tinP , T("abort: loading soulAsciiLint") ) ;
                DEL( tinP.pBarryUtility ) ;
                _INoLD_
            {
            if( bAbort )

            }
                _OUT_
                bAbort = !!etThread.etherSoilF( tinP , ether , soulNativeLint , soulNativeIn , ifcIDmODEeTHERsOIL_LINT , 0 , flETHERsOILf_CONSUMEiNPUT , postiP , costiP ) ;
                etThread.traceF( tinP , T("loading soulNativeLint and calculating bAbort") ) ;

                }
                    _OUT_
                    etThread.etherSoilF( tinP , ether , soulNativeIn , soulPrepared , ifcIDmODEeTHERsOIL_NATIVEfROMaSCII , 0 , flETHERsOILf_CONSUMEiNPUT , postiP , costiP ) ;
                    etThread.traceF( tinP , T("loading soulNativeIn") ) ;

                    //}
                    //    //LOGrAW( "\r\n---- PREPARED: (END) ----\r\n" ) ;
                    //    }
                    //        etThread.delF( tinP , psttp ) ;
                    //        LOGrAW( T(psttp) ) ;
                    //        soulPrepared << psttp ;
                    //        soulTmpDebug >> psttp ; ___( psttp ) ;
                    //        ZE( strokeS* , psttp ) ;
                    //    {
                    //    while( soulTmpDebug )
                    //    //LOGrAW( "\r\n---- PREPARED: (BEGIN) ----\r\n" ) ;
                    //
                    //    }
                    //        etThread.delF( tinP , psttp ) ;
                    //        soulTmpDebug << psttp ;
                    //        soulPrepared >> psttp ; ___( psttp ) ;
                    //        ZE( strokeS* , psttp ) ;
                    //    {
                    //    while( soulPrepared )
                    //    soulC soulTmpDebug( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.tmp.debug" ) ;
                    //{
                    //U::COMMENT OUT IN PRODUCTION

                    }
                        _OUT_
                        }
                            _OUT_
                            }
                                _OUT_
                                }
                                    _OUT_
                                    }
                                        _OUT_
                                        etThread.delF( tinP , psttp ) ;
                                        soulAsciiIn << psttp ;
                                        soulPrepared >> psttp ; ___( psttp ) ;
                                        ZE( strokeS* , psttp ) ;

                                        if( !( cRemain % ( TUCK << 4 ) ) ) etThread.traceF( tinP , T("[cRemain]: ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                        countT cRemain = soulPrepared ;
                                        _INoLD_
                                    {
                                    while( soulPrepared )
                                    etThread.traceF( tinP , T("pouring for another pass [idPass,soulPrepared]: ")+TF2(idPass,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2((countT)soulPrepared,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                    _INoLD_
                                {
                                else
                                }
                                    break ;
                                    _OUT_
                                    etThread.traceF( tinP , T("loaded soulPrepared for final pass [idPass]: ")+TF2(idPass,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                    _INoLD_
                                {
                                if( !etThread.etherSoilF( tinP , ether , soulPrepared , soulAsciiIn , ifcIDmODEeTHERsOIL_PREPAREsOURCE , 0 , flETHERsOILf_CONSUMEiNPUT , postiP , costiP ) )
                                etThread.traceF( tinP , T("loading soulPrepared [idPass]: ")+TF2(idPass,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                _INoLD_
                            {
                            for( countT idPass = 1 ; ; idPass ++ )
                            _INoLD_
                        {
                        etThread.traceF( tinP , T("loading soulPrepared") ) ;

                        }
                            _OUT_
                            }
                                _OUT_
                                etThread.delF( tinP , pstti ) ;
                                etThread.strFuseF( tinP , soulAsciiIn , pstti , 0 , S1C( '\\' ) , T("[]") ) ;

                                postzBite += costBite ;
                                etThread.strMakeFromOsTextF( tinP , pstti , postzBite , costBite ) ; ___( pstti ) ;
                                ZE( strokeS* , pstti ) ;                                                                  // INSPECT AND PERHAPS ANNOTATE

                                cDo -= costBite ;
                                while( postzBite[ costBite - 1 ] == '\\' ) costBite -- ; // LATH MUST NOT BE ESCAPE CHAR
                                countT costBite = cDo <= TOCK ? cDo : TOCK ;

                                etThread.traceF( tinP , T("loading soulAsciiIn [cDo]: ")+TF2(cDo,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                _INoLD_
                            {
                            while( cDo )
                            osTextT* postzBite = postiP ;
                            countT cDo = costiP ;
                            _INoLD_
                        {
                        else
                        }
                            _OUT_
                            etThread.delF( tinP , pstti ) ;
                            etThread.strFuseF( tinP , soulAsciiIn , pstti , 0 , S1C( '\\' ) , T("[]") ) ;

                            etThread.strMakeFromOsTextF( tinP , pstti , postiP , costiP ) ; ___( pstti ) ;
                            ZE( strokeS* , pstti ) ;                                                                  // INSPECT AND PERHAPS ANNOTATE
                            _INoLD_
                        {       
                        if( costiP <= TOCK )

                        soulC soulAsciiIn( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.ascii.in" ) ;
                        etThread.traceF( tinP , T("loading soulAsciiIn") ) ;
                        _INoLD_
                    {
                    soulC soulPrepared( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.prepared" ) ;
                    _INoLD_
                {
                soulC soulNativeIn( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.native.in" ) ;
                _INoLD_
            {
            soulC soulNativeLint( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.native.lint" ) ;
            ZE( boolT , bAbort ) ;
            _INoLD_
        {
        //else
        //}
        //    etThread.boxPutF( tinP , tTo+T("read.this.error.message.txt") , tErrorFileTooBig , tErrorFileTooBig.csF( tinP ) ) ;
        //    tTo = T(psttzBounceP) ;
        //{
        //if( costiP > costiMax ) // NOTE 1: AVOIDING POOL OVERFLOW
        TN( tTo , "" ) ;
        TN( tShort , psttShort ) ;
        TN( tPickSoil , psttzPickSoilP ) ;
        _INoLD_
    {
    if( ids )
    countT ids = etThread.etherC::strBisectF( tinP , psttPath , psttShort , psttFileNameP , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
    ZE( strokeS* , psttShort ) ;
    ZE( strokeS* , psttPath ) ;

    //etThread.traceF( tinP , T("setting up / ct'ed barryC") ) ;
    //tinP.pBarryUtility = new( 0 , tinP , LF ) barryC( tinP ) ; ___( tinP.pBarryUtility ) ;
    //etThread.traceF( tinP , T("setting up / ct'ing barryC") ) ;

    //20171229@1256: COMMENTED barryC PREALLOCATION OUT BECAUSE IT CONSUMES 1/4 OF THE ADDRESS SPACE
    //20171202@0909: PROVISIONALLY ENABLING THIS, SO IT IS PROVISIONALLY ILLEGAL TO RUN MORE THAN WO tmObeySoilF THREAD PER HOME

    //UNTIL THESE SCENAIOS ARE HANDLED SO THAT ONLY WO INSTANCE IS CT'D, THE FOLLOWING PREALLOCATING LINES MUST BE COMMENTED OUT
    //THIS NEEDS TO BE REDESIGNED SO WILL USE ONLY A SINGLE INSTANCE OF barryC EVEN IF QUEUEING JOBS AND EVEN IF USING REPEAT
    //THIS IS JUST A PREALLOCATOR SO WILL FIND OUT EARLIER IF CANNOT GET THIS MEMORY
    //CANNOT DO THIS WHEN QUEUEING WORK FOR A JOB, BECAUSE HAVE MULTIPLE tmObeySoilF THREADS AND THIS USES TOO MUCH MEMORY


etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_ENABLE ) ;
etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , 1 ) ;
tinP.monitor.idWhat2 = - 1 ;


    countT   costiP                     =           pTaskP->c6 ;
    osTextT* postiP                     = (osTextT*)pTaskP->c5 ;
    strokeS* psttFileNameP              = (strokeS*)pTaskP->c4 ;
    const strokeS* const psttzBounceP   = (strokeS*)pTaskP->c3 ;
    const strokeS* const psttzPickSoilP = (strokeS*)pTaskP->c2 ;
    countT&  cFailP                     = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmObeySoilF )

DONE( tmPingF )
}
    }
        _OUT_
        ++ s ; ether.osSleepF( tinP , TOCK ) ;
        _INoLD_
    
        sockPing.writeF( tinP , ifcIDpORT_DOOR , nnCast , sOut ) ;
    {
    while( !ether && !POOP )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    
    sOut << (countT)1 ; //PING
    soulC sOut( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.ping.out" ) ;
    
    countT idPortMe = sockPing.bindF( tinP ) ;
    socketC sockPing( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM , flSOCKETc_CANbROADCAST ) ;
    
    nicNameC nnCast = socketC::nicNameIF( tinP , etThread , T("!broadcast") ) ;
{
if( pTaskP )
TASK( tmPingF ) // MAKE MYSELF VISIBLE TO OTHER PISS CELLS ON THE LAN

DONE( tmCleanF )
}
    }
        }
            }
                while( cFail ) ;
                }
                    _OUT_
                    if( cFail ) { ++ s ; ether.osSleepF( tinP , TOCK ) ; }
                    _INoLD_

                    FORsTRINGSiNsPANNEDcOMBINEDtAIL1
                    }
                        }
                            etThread.delF( tinP , psttShort ) ;
                            etThread.delF( tinP , psttPath ) ;
                            }
                                }
                                    }
                                        cFail ++ ;                                                                                  // INCREMENT cFail
                                        POOPR
                                    {
                                    if( POOP )                                                                                  // IF COULD NOT MOVE UNIQUE
                                    etThread.delF( tinP , psttn ) ;
                                    tinP.pEtScratch->diskMoveFileOrDirUniqueF( tinP , psttn , psttc1 , 1 ) ;                    // MOVE UNIQUE TO ANUS
        
                                    etThread.strMakeF( tinP , psttn , tBounce , TUCK+tShort.csF( tinP ) ) ; ___( psttn ) ;
                                    ZE( strokeS* , psttn ) ;
        
                                    POOPR
                                {
                                if( POOP )                                                                                  // IF COULD NOT MOVE TO ANUS
                                tinP.pEtScratch->diskMoveFileOrDirF( tinP , tBounce+tShort , psttc1 , 1 ) ;                   // MOVE TO ANUS
                                SCOOPS

                                TN( tShort , psttShort ) ;
                            {
                            if( ids )                                                                                   // IF HAVE PATH (ALWAYS TRUE)
                            countT ids = etThread.etherC::strBisectF( tinP , psttPath , psttShort , psttc1 , tSlash , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttPath ) ;
                        {
                        if( psttc1[ CSpREFIX - 1 + psttc1->idAdam ].idAdam == '/' )                                 // IF DIRECTORY
                    {
                    FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
                    etThread.boxMenuF( tinP , soul1m , tDrop+T("*") , 0 , TUCK ) ;
                    soulC soul1m( tinP , TAG( TAGiDnULL ) , flSOUL_null , "soul.clean.menu" ) ;
                {
                do
                ZE( countT , cFail ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                if( bWoth ) bWoth = 0 ;
            {
            if( etThread.etherC::diskWaitDirF( tinP , hWait , ether , tDrop , flWAITdIR_DIRnAME ) || bWoth )
        {
        while( !ether && !POOP )
        handleC hWait( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
        boolT bWoth = 1 ;
    {
    IFsCRATCH

    TN( tSlash , "/" ) ;    
    TN( tDrop , psttDropSoilP ) ;
    TN( tBounce  , psttBounceP  ) ;

    const strokeS* const psttDropSoilP = (strokeS*)pTaskP->c2 ;
    const strokeS* const psttBounceP   = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmCleanF )

DONE( tmRenameF )
}
    etThread.delF( tinP , psttmDropIn ) ;
    }
        }
            CONoUTrAW5( "" , cDirs , " " , cFiles , "\r\n" ) ;
            etThread.diskWalkRenameForArchivalF( tinP , cDirs , cFiles , ether , psttzTo , psttmDropIn , myCBF ) ;
            ZE( countT , cFiles ) ;
            ZE( countT , cDirs ) ;
    
            strokeS* psttzTo = tTo ;
            TN( tTo , "///ideafarm/IdeaFarm " "(tm)/" ) ; tTo += tUser+T("/Pick Up Files Ready for Processing Here/") ;

            if( bWoth ) bWoth = 0 ;
        {
        if( etThread.etherC::diskWaitDirF( tinP , hWait , ether , psttmDropIn , flWAITdIR_RECURSE | flWAITdIR_FILEnAME | flWAITdIR_DIRnAME ) || bWoth )
    {
    while( !ether && !POOP )
    handleC hWait( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    boolT bWoth = 1 ;
    
    etThread.delF( tinP , psttDropInP ) ;
    etThread.diskMapFileNameF( tinP , psttmDropIn , psttDropInP ) ; ___( psttmDropIn ) ;
    ZE( strokeS* , psttmDropIn ) ;

    TN( tUser , thirdC::postUserNameIF() ) ;

    TN( tNeverDropHere , psttNeverDropHereP ) ;
    TN( tDropIn        , psttDropInP        ) ;

    strokeS* psttNeverDropHereP = (strokeS*)pTaskP->c2 ;
    strokeS* psttDropInP        = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmRenameF )

}
    return bDoIt ;
    boolT bDoIt = 1 ;
{
boolT myCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP )

// WHEN IPDOS (tm) IS PORTED TO 04 BIT HARDWARE, THE NEED FOR THIS LIMIT WILL VANISH
// THE HARDCODED LIMIT IS INTENDED TO SUFFICE FOR WO IFC QUARTER'S WORTH OF DATA
// THIS IS TO AVOID POOL OVERFLOW, WHICH OCCURS BECAUSE INPUT TEXT IS CONVERTED TO STRINGS OF strokeS
// IF AN EXCESSIVELY LARGE FILE IS DROPPED, IT WILL BOUNCE IMMEDIATELY TO THE ERROR FOLDER
//
// NOTE 1: AVOIDING POOL OVERFLOW

/*1*/WAKEhIDE( "ifcIDaDAM_PISS" )/*1*/

//WHEN DIFFERENT TYPES OF HARDWARE EXIST IN THE IPDOS CLOUD, THE FEATURE LIST WILL EXPAND TO INDICATE THE PRESENCE OR ABSENCE OF PARTICULAR CAPABILITIES SUCH AS TELEPHONY AND A FULL KEYBOARD AND LARGE DISPLAY
//IN THE FUTURE, THE TYPE OF THE HARDWARE WILL BE A FEATURE, TOO, DISTINGUISHING LAPTOP HARDWARE FROM SMARTPHONE HARDWARE
//ACCESS TO A HUMAN OPERATOR IS AN OPTIONAL "FEATURE", USING MICROSOFT'S TERMINOLOGY
//ALL LOGIN HOMES HAVE FULL ACCESS TO THE HARDWARE, BUT HARDWARE HOMES DO NOT HAVE ANY ACCESS TO A HUMAN OPERATOR
//BUT THE DISTINCTION IS TRANSPARENT TO ALL IPDOS FUNCTIONALITY INCLUDING INTERHOME COMMUNICATION
//HOMES IN THE IPDOS CLOUD ARE THUS OF OO TYPES
//EACH HARDWARE HOST HAS A HARDWARE HOME AND OPTIONALLY WO OR MORE LOGIN HOMES
//THIS IS SO THAT THE USER INTERFACE IS CLEAN
//U::WAKEhIDE FOR PRODUCTION

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

