
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("loafing") ) ;

}
    }
        while( ~hWalkStale && !ether ) ;
        }
            etThread.delF( tinP , psttfnStale ) ;
            }
                etThread.traceF( tinP , T("not found: ")+T(psttfnStale) ) ;
            {
            if( !bFound )

            }
                while( ~hWalkVerified && !ether && !bFound ) ;
                }
                    etThread.delF( tinP , pbBufferVerified ) ;
                    etThread.delF( tinP , pbBufferStale ) ;
                    etThread.delF( tinP , psttfnVerified ) ;

                    }
                        }
                            }
                                }
                                    break ;
                                    bFound = 0 ;
                                {
                                if( etThread.memCompareF( tinP , pbBufferStale , pbBufferVerified , cbBite ) )

                                __( cbActual != cbBite ) ;
                                etThread.fileReadF( tinP , pbBufferVerified , cbActual , hFileVerified ) ;
                                cbActual = cbBite ;

                                __( cbActual != cbBite ) ;
                                etThread.fileReadF( tinP , pbBufferStale  , cbActual , hFileStale ) ;
                                countT cbActual = cbBite ;

                                if( was < cbDo ) cbDoHigh -- ;
                                cbDo -= cbBite ;
                                countT was = cbDo ;

                                ;
                                        : cbBuffer
                                        ? cbDo
                                    : cbDo < cbBuffer
                                    ? cbBuffer
                                countT cbBite = cbDoHigh
                            {
                            while( cbDo || cbDoHigh )
                            countT cbDoHigh = pcLever[ 1 ] ;
                            countT cbDo     = pcLever[ 0 ] ;
                        {
                        bFound = 1 ;
                    {
                    if( pbBufferStale && pbBufferVerified )

                    etThread.newF( tinP , LF , pbBufferVerified , cbBuffer ) ; ___( pbBufferVerified ) ;
                    etThread.newF( tinP , LF , pbBufferStale , cbBuffer ) ; ___( pbBufferStale ) ;

                    ;
                            : CBmYbUFFER
                            ? pcLever[ 0 ]
                        : pcLever[ 0 ] < CBmYbUFFER
                        ? CBmYbUFFER
                    const countT cbBuffer = pcLever[ 1 ]
                    ZE( byteT* , pbBufferVerified ) ;
                    ZE( byteT* , pbBufferStale  ) ;

                    etThread.fileOpenF( tinP , hFileVerified , countTC() , tPathVerified+T(psttfnVerified) ) ;
                    etThread.fileOpenF( tinP , hFileStale    , countTC() , tPathStale   +T(psttfnStale   ) ) ;
                    handleC hFileVerified( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                    handleC hFileStale( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;

                    { byteT* pbzEncodedVerified = (byteT*)swsVerified.downF( tinP , hWalkVerified ) ; etThread.strDecodeF( tinP , psttfnVerified , pbzEncodedVerified ) ; } ___( psttfnVerified ) ;
                    ZE( strokeS* , psttfnVerified ) ;
                {
                do
                handleC hWalkVerified( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( !bFound && swsVerified )

            }
                while( ~hWalkFresh && !ether && !bFound ) ;
                }
                    etThread.delF( tinP , pbBufferFresh ) ;
                    etThread.delF( tinP , pbBufferStale ) ;
                    etThread.delF( tinP , psttfnFresh ) ;

                    }
                        }
                            }
                                }
                                    break ;
                                    bFound = 0 ;
                                {
                                if( etThread.memCompareF( tinP , pbBufferStale , pbBufferFresh , cbBite ) )

                                __( cbActual != cbBite ) ;
                                etThread.fileReadF( tinP , pbBufferFresh , cbActual , hFileFresh ) ;
                                cbActual = cbBite ;

                                __( cbActual != cbBite ) ;
                                etThread.fileReadF( tinP , pbBufferStale  , cbActual , hFileStale ) ;
                                countT cbActual = cbBite ;

                                if( was < cbDo ) cbDoHigh -- ;
                                cbDo -= cbBite ;
                                countT was = cbDo ;

                                ;
                                        : cbBuffer
                                        ? cbDo
                                    : cbDo < cbBuffer
                                    ? cbBuffer
                                countT cbBite = cbDoHigh
                            {
                            while( cbDo || cbDoHigh )
                            countT cbDoHigh = pcLever[ 1 ] ;
                            countT cbDo     = pcLever[ 0 ] ;
                        {
                        bFound = 1 ;
                    {
                    if( pbBufferStale && pbBufferFresh )

                    etThread.newF( tinP , LF , pbBufferFresh , cbBuffer ) ; ___( pbBufferFresh ) ;
                    etThread.newF( tinP , LF , pbBufferStale , cbBuffer ) ; ___( pbBufferStale ) ;

                    ;
                            : CBmYbUFFER
                            ? pcLever[ 0 ]
                        : pcLever[ 0 ] < CBmYbUFFER
                        ? CBmYbUFFER
                    const countT cbBuffer = pcLever[ 1 ]
                    ZE( byteT* , pbBufferFresh ) ;
                    ZE( byteT* , pbBufferStale  ) ;

                    etThread.fileOpenF( tinP , hFileFresh , countTC() , tPathFresh+T(psttfnFresh) ) ;
                    etThread.fileOpenF( tinP , hFileStale , countTC() , tPathStale+T(psttfnStale) ) ;
                    handleC hFileFresh( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                    handleC hFileStale( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;

                    { byteT* pbzEncodedFresh = (byteT*)swsFresh.downF( tinP , hWalkFresh ) ; etThread.strDecodeF( tinP , psttfnFresh , pbzEncodedFresh ) ; } ___( psttfnFresh ) ;
                    ZE( strokeS* , psttfnFresh ) ;
                {
                do
                handleC hWalkFresh( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( swsFresh )
            ZE( boolT , bFound ) ;

            { byteT* pbzEncodedStale = (byteT*)swsStale.downF( tinP , hWalkStale ) ; etThread.strDecodeF( tinP , psttfnStale , pbzEncodedStale ) ; } ___( psttfnStale ) ;
            ZE( strokeS* , psttfnStale ) ;
        {
        do
        handleC hWalkStale( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( swsStale )

    if( !pcLever[ 0 ] && !pcLever[ 1 ] ) continue ;

    etThread.memCopyF( tinP , (byteT*)pcLever , (byteT*)swsStale.leverF( tinP , idf ) , sizeof pcLever ) ;
{
for( countT idf = 1 ; !ether && idf <= cFlavors ; idf ++ )
countT cFlavors = swsStale.cFlavorsF( tinP ) ;

}
    etThread.traceF( tinP , T("verified [cFiles,cSizes,filesPerSize]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(swsVerified.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cFiles/swsVerified.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    while( ~hFind && !ether ) ;
    }
        DEL( pInfo ) ;
        }
            #endif

            }
                }
                {
                if( pInfoDad && pInfoDad->cbUsed == pInfo->cbUsed && pInfoDad->cbUsedHigh == pInfo->cbUsedHigh )
                etThread.diskFileQueryF( tinP , pInfoDad , hDad ) ;
                ZE( infoFileS* , pInfoDad ) ;

                etThread.traceF( tinP , tInspecting ) ;
            {
            else
            if( !etThread.diskFileExistsF( tinP , psttDadFile ) ) etThread.diskMoveFileOrDirF( tinP , psttDadFile , pInfo->psttIfoName ) ;

            #if defined( NEVERdEFINED )

            swsVerified << pbEncoded ; pbEncoded = 0 ;
            pcLever[ 1 ] = pInfo->cbUsedHigh ;
            pcLever[ 0 ] = pInfo->cbUsed     ;

            etThread.delF( tinP , psttShort ) ;
            etThread.strEncodeF( tinP , pbEncoded , psttShort ) ; ___( pbEncoded ) ;
            ZE( byteT* , pbEncoded ) ;

            if( !( ( ++ cFiles ) % TUCK ) ) etThread.traceF( tinP , psttShort ) ;

            }
                etThread.delF( tinP , psttPath ) ;
                ___( psttShort ) ;
                ___( psttPath  ) ;
                etThread.strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                ZE( strokeS* , psttPath ) ;
            {
            ZE( strokeS* , psttShort ) ;
        {
        )
            pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ] != '/'
            &&
            !etThread.strIdF( tinP , tSlashDotDotSlash , pInfo->psttIfoName )
            &&
            !etThread.strIdF( tinP , tSlashDotSlash , pInfo->psttIfoName )
            &&
            pInfo
        (
        if
        etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tLike ) ; ___( pInfo ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    ZE( countT , cFiles ) ;
    TN( tb4               , "    " ) ;
    TN( tDistinct         , "distinct" ) ;
    TN( tInspecting       , "inspecting " ) ;
    TN( tSlash            , "/" ) ;
    TN( tSlashDotSlash    , "/./" ) ;
    TN( tSlashDotDotSlash , "/../" ) ;
    TN( tLike , "" ) ; tLike = tPathVerified+T("*") ;
{
switchStackC swsVerified( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pbLever , sizeof pcLever , flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY , ifcSTACKtYPE_PTR_byteT ) ;
TN( tPathVerified , "///d/ideafarm.home.101/IdeaFarm (tm)/SYSTEM/Drop Files Here To Archive/verified.1/" ) ;
etThread.traceF( tinP , T("loading verified") ) ;

}
    etThread.traceF( tinP , T("fresh    [cFiles,cSizes,filesPerSize]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(swsFresh.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cFiles/swsFresh.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    while( ~hFind && !ether ) ;
    }
        DEL( pInfo ) ;
        }
            #endif

            }
                }
                {
                if( pInfoDad && pInfoDad->cbUsed == pInfo->cbUsed && pInfoDad->cbUsedHigh == pInfo->cbUsedHigh )
                etThread.diskFileQueryF( tinP , pInfoDad , hDad ) ;
                ZE( infoFileS* , pInfoDad ) ;

                etThread.traceF( tinP , tInspecting ) ;
            {
            else
            if( !etThread.diskFileExistsF( tinP , psttDadFile ) ) etThread.diskMoveFileOrDirF( tinP , psttDadFile , pInfo->psttIfoName ) ;

            #if defined( NEVERdEFINED )

            swsFresh << pbEncoded ; pbEncoded = 0 ;
            pcLever[ 1 ] = pInfo->cbUsedHigh ;
            pcLever[ 0 ] = pInfo->cbUsed     ;

            etThread.delF( tinP , psttShort ) ;
            etThread.strEncodeF( tinP , pbEncoded , psttShort ) ; ___( pbEncoded ) ;
            ZE( byteT* , pbEncoded ) ;

            if( !( ( ++ cFiles ) % TUCK ) ) etThread.traceF( tinP , psttShort ) ;

            }
                etThread.delF( tinP , psttPath ) ;
                ___( psttShort ) ;
                ___( psttPath  ) ;
                etThread.strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                ZE( strokeS* , psttPath ) ;
            {
            ZE( strokeS* , psttShort ) ;
        {
        )
            pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ] != '/'
            &&
            !etThread.strIdF( tinP , tSlashDotDotSlash , pInfo->psttIfoName )
            &&
            !etThread.strIdF( tinP , tSlashDotSlash , pInfo->psttIfoName )
            &&
            pInfo
        (
        if
        etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tLike ) ; ___( pInfo ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    ZE( countT , cFiles ) ;
    TN( tb4               , "    " ) ;
    TN( tDistinct         , "distinct" ) ;
    TN( tInspecting       , "inspecting " ) ;
    TN( tSlash            , "/" ) ;
    TN( tSlashDotSlash    , "/./" ) ;
    TN( tSlashDotDotSlash , "/../" ) ;
    TN( tLike , "" ) ; tLike = tPathFresh+T("*") ;
{
switchStackC swsFresh( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pbLever , sizeof pcLever , flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY , ifcSTACKtYPE_PTR_byteT ) ;
TN( tPathFresh , "///d/ideafarm.home.101/IdeaFarm (tm)/SYSTEM/Drop Files Here To Archive/" ) ;
etThread.traceF( tinP , T("loading fresh") ) ;

}
    etThread.traceF( tinP , T("stale    [cFiles,cSizes,filesPerSize]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(swsStale.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cFiles/swsStale.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    while( ~hFind && !ether ) ;
    }
        DEL( pInfo ) ;
        }
            #endif

            }
                }
                {
                if( pInfoDad && pInfoDad->cbUsed == pInfo->cbUsed && pInfoDad->cbUsedHigh == pInfo->cbUsedHigh )
                etThread.diskFileQueryF( tinP , pInfoDad , hDad ) ;
                ZE( infoFileS* , pInfoDad ) ;


                etThread.traceF( tinP , tInspecting ) ;
            {
            else
            if( !etThread.diskFileExistsF( tinP , psttDadFile ) ) etThread.diskMoveFileOrDirF( tinP , psttDadFile , pInfo->psttIfoName ) ;

            #if defined( NEVERdEFINED )

            swsStale << pbEncoded ; pbEncoded = 0 ;
            pcLever[ 1 ] = pInfo->cbUsedHigh ;
            pcLever[ 0 ] = pInfo->cbUsed     ;

            etThread.delF( tinP , psttShort ) ;
            etThread.strEncodeF( tinP , pbEncoded , psttShort ) ; ___( pbEncoded ) ;
            ZE( byteT* , pbEncoded ) ;

            if( !( ( ++ cFiles ) % TUCK ) ) etThread.traceF( tinP , psttShort ) ;

            }
                etThread.delF( tinP , psttPath ) ;
                ___( psttShort ) ;
                ___( psttPath  ) ;
                etThread.strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                ZE( strokeS* , psttPath ) ;
            {
            ZE( strokeS* , psttShort ) ;
        {
        )
            pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ] != '/'
            &&
            !etThread.strIdF( tinP , tSlashDotDotSlash , pInfo->psttIfoName )
            &&
            !etThread.strIdF( tinP , tSlashDotSlash , pInfo->psttIfoName )
            &&
            pInfo
        (
        if
        etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tLike ) ; ___( pInfo ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    ZE( countT , cFiles ) ;
    TN( tb4               , "    " ) ;
    TN( tDistinct         , "distinct" ) ;
    TN( tInspecting       , "inspecting " ) ;
    TN( tSlash            , "/" ) ;
    TN( tSlashDotSlash    , "/./" ) ;
    TN( tSlashDotDotSlash , "/../" ) ;
    TN( tLike , "" ) ; tLike = tPathStale+T("*") ;
{
switchStackC swsStale( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pbLever , sizeof pcLever , flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY , ifcSTACKtYPE_PTR_byteT ) ;
TN( tPathStale , "///a/ideafarm.home.101/IdeaFarm (tm)/SYSTEM/arc.b4.clean/" ) ;
etThread.traceF( tinP , T("loading stale") ) ;

const byteT* pbLever = (byteT*)pcLever ;
countT pcLever[] = { 0 , 0 } ;
TN( tc , ":" ) ;

TODO

#define CBmYbUFFER ( TICK << 0 )

/*1*/WAKEsHOWtEXT( "tool.detect.lost.archive.images" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

