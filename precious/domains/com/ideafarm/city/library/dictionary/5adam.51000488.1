
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::ifcSayIF( T("final aok\r\n")+tc , flSAY_APPEND | flSAY_LOG ) ;

}
    etUsesPoolPrime.delF( tinP , pbPackLag ) ;
    TELL( "cleaning up" ) ;
    }
        }
            etherC::ifcSayIF( TF1(DDNUMB)+T(" awakening")+tc , flSAY_APPEND | flSAY_LOG ) ;
            }
                while( !ether && !etThread.diskFileExistsF( tinP , tPackLoaded ) ) { ++ s ; ether.osSleepF( tinP , TOCK * 0x10 ) ; }
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            TN( tPackLoaded  , "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/pack.loaded."  ) ; tPackLoaded  += TF1(etThread.diskIdF(tinP,T("///c"))) ;
            etherC::ifcSayIF( TF1(DDNUMB)+T(" going to sleep until the pack that i just made has been loaded")+tc , flSAY_APPEND | flSAY_LOG ) ;
        {
        else
        if( bWoPass ) break ;

        etherC::ifcSayIF( TT(timeN1,timeN2)+T(" | ")+TF1(DDNUMB)+T(" cycle ")+tIdCycle+T(" this cycle has ended")+tc , flSAY_APPEND | flSAY_LOG ) ;
        etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
        timeN2 = timeN1 = 0 ;
        TELL( "ending a cycle" ) ;

        ether.beeClickF( tinP , 0x3800 , TUCK * 0x10 ) ;
        etherC::ifcSayIF( TF1(DDNUMB)+T(" cycle ")+tIdCycle+T(" a fresh pack file has been made")+tc , flSAY_APPEND | flSAY_LOG ) ;
        makePackF( tinP , ether , etThread , st1 , st2 , st3 , st4 , bTest , state ) ;
        etherC::ifcSayIF( TF1(DDNUMB)+T(" cycle ")+tIdCycle+T(" beginning to make a fresh pack file")+tc , flSAY_APPEND | flSAY_LOG ) ;
        //ether.beeClickF( tinP , 0x100 , TUCK * 0x20 ) ;
        TELL( "making a pack of fish" ) ;

        etherC::ifcSayIF( TT(timeN1,timeN2)+T(" | ")+TF1(DDNUMB)+T(" cycle ")+tIdCycle+T(" this cycle has begun")+tc , flSAY_APPEND | flSAY_LOG ) ;
        etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT , timeN1 ) ;
        TN( tIdCycle , "" ) ; tIdCycle = TF1(++idCycle) ;
        TELL( "beginning a cycle" ) ;
    {
    while( !ether && !etThread )
    ZE( countT , idCycle ) ;
    ZE( byteT* , pbPackLag ) ;
    etherC etUsesPoolPrime( tinP , TAG( TAGiDnULL ) ) ;
    stateS state( tinP , etThread ) ;
{

//U::{ countT idAdam = 0x40104b8 ; etThread.ifcHireF( tinP , T("g orilla http") , idAdam , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ; }//U::

setupF( tinP , etThread , st1 , st2 , st3 , st4 , bTest ) ;
stackC st4( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
stackC st3( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
stackC st2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
stackC st1( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;

//U:etThread.flagsMode |= flTHIRDmODE_CHECKpOOLoLD ;

etherC::ifcSayIF( T("IdeaFarm " "(tm) City Publisher\r\ni periodically write the city knowledge tree and associated html files\r\n")+tc , flSAY_APPEND | flSAY_LOG ) ;
TN( tLog , "///d/log.ifc.html" ) ;

const boolT bTest   = etThread.etherParameterF( tinP , T("!test")   ) ;
const boolT bWoPass = etThread.etherParameterF( tinP , T("!woPass") ) ; //U: THESE WILL BE OBSOLETE WHEN I CYCLE CONTINUOUSLY AS PART OF brain.bat

TN( tc , "\r\n" ) ;
etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIEST ) ; // I ALSO TAKE NAPS FREQUENTLY TO MAKE EXTRA SURE THAT I DO NOT INTERFERE WITH HTTP SERVICE
((thirdC&)etThread).third_bWatchful_F( tinP ) = 0 ;
TELL( "preparing for work" ) ;

TODO

}
    if( bTestP ) ;
    if( !ether && !etThread ) stateP.idStep = 0 ;
    etherC::ifcSayIF( T("pass ")+TF1(stateP.idPass)+T(" done")+tc , flSAY_APPEND | flSAY_LOG ) ;

    //etThread.beeSong1F( tinP ) ;

    etThread.delF( tinP , pstt1m ) ;
    FORsTRINGSiN1( pstt1m ) etThread.diskFileOrDirDeleteF( tinP , psttc1 ) ;
    etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/pack.loaded.*" ) ) ; ___( pstt1m ) ;
    etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/pack.noticed.*") ) ; ___( pstt1m ) ;
    ZE( strokeS* , pstt1m ) ;

    STEP( onePackF( tinP , etThread ) ) ;

    //}
    //    __( value ) ;
    //    etThread.diskMoveFileOrDirF( tinP , tZipOld , tZip ) ;
    //    if( etThread.diskFileExistsF( tinP , tZipOld ) ) etThread.diskFileOrDirDeleteF( tinP , tZipOld ) ;
    //    etThread.osProcessF( value , iddt , tinP , tZipper , T("-9j ")+tZipOs+T(" *") ) ;
    //    ZE( countT , iddt ) ;
    //    ZE( countT , value ) ;
    //    TN( tZipOs  , osFileNameC( tinP , etThread , tZip ) ) ;
    //    etThread.delF( tinP , psttZip ) ;
    //    tZip = T(psttZip) ;
    //    etThread.diskMapFileNameF( tinP , psttZip , tZip ) ; ___( psttZip ) ;
    //    ZE( strokeS* , psttZip ) ;
    //    TN( tZip , "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/readme.zip.new" ) ;
    //    TN( tZipOld , "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/readme.zip" ) ;
    //    TN( tZipper , "///d/ideafarm.work/backed.up.never/software/zip/zip.exe" ) ;
    //    etThread.diskHoverF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/files/") ) ;
    //{
    //etThread.diskMoveFileOrDirF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/files/readme.html") , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/files/1.1.0.html") ) ;

    tinP.flagsThreadMode1 = flagsThreadMode1Save ;

    }
        //tinP.zEtScratch->delF( tinP , psttf ) ;
        //STEP( tinP.zEtScratch->boxPutHtmlFromKnowledgeTreeBaseF( tinP , 0 , psttf , (strokeS*)st2P[ idt ] , (strokeS*)st3P[ idt ] , tCopy , (strokeS*)st4P[ idt ] , 0x100000 , 1 ) ) ;
        //etThread.strReplaceF( tinP , psttf , (strokeS*)st1P[ idt ] , T("/packs/") , T("/files/") ) ; ___( psttf ) ;
        //ZE( strokeS* , psttf ) ;
        //THIS IS NORMALLY COMMENTED _OUT_

        STEP( tinP.zEtScratch->boxPutHtmlFromKnowledgeTreeBaseF( tinP , 1 , (strokeS*)st1P[ idt ] , (strokeS*)st2P[ idt ] , (strokeS*)st3P[ idt ] , tCopy , (strokeS*)st4P[ idt ] , 0x100000 , 1 ) ) ;
        //THIS IS NORMALLY ENABLED
    {
    for( idt = 1 ; idt <= cTrees ; idt ++ )
    const countT cTrees = st2P ;
    TN( tCopy , "(c) IdeaFarm " "(tm) City" ) ;
    __( st2P - st4P ) ;
    __( st2P - st3P ) ;
    bLogKt = 1 ;
    bLogExp = 0 ;

    //COMMENTED OUT TO KEEP IT QUIET IN THE LOG: STEP( verifyExampleSimplestExistsF( tinP , *tinP.zEtScratch , bTestP                          ) ) ;
    //STEP( insertInstanceSectionF(       tinP , *tinP.zEtScratch , bTestP                          ) ) ;
    //STEP( findFunctionCallInstancesF(   tinP , *tinP.zEtScratch , bTestP , S1C('(') , T(TbLACK) ) ) ;
    //STEP( writeSymbolBaseF(             tinP , *tinP.zEtScratch , bTestP                          ) ) ;
    //STEP( writeVisiblesHtmlF(           tinP , *tinP.zEtScratch , bTestP                          ) ) ;
    //STEP( listVisibleDefinitionsF(      tinP , *tinP.zEtScratch , bTestP                          ) ) ;
    //U: //STEP( testAutoF(                    tinP , *tinP.zEtScratch , bTestP                     ) ) ;
    //U: STEP( tinP.zEtScratch->ifcHireF( tinP , T("city.publisher.make") , ifcIDaDAMoLD_MAKEaLLaDAMS , T(bTestP?"!test":"") , flHIRE_WAIT ) ) ;

    //}
    //    ether.delF( tinP , pbFile ) ;
    //    ether.boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/files/2.2.0") , pbFile , cbFile ) ;
    //    ether.boxGetShadowF( tinP , pbFile , cbFile , T("///d/ideafarm.work/backed.up.daily/images/jpeg/Dadflag.JPG") ) ; ___( pbFile ) ;
    //    ZE( countT , cbFile ) ;
    //    ZE( byteT* , pbFile ) ;
    //{
    //}
    //    while( cToDo ) ;
    //    }
    //        etThread.delF( tinP , pstt1m ) ;
    //        FORsTRINGSiN1( pstt1m ) etThread.diskFileOrDirDeleteF( tinP , psttc1 ) ;
    //        cToDo += etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/files/*") , 0 , 0x100 ) ; ___( pstt1m ) ;
    //        cToDo  = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/kt/*") , 0 , 0x100 ) ; ___( pstt1m ) ;
    //        ZE( strokeS* , pstt1m ) ;
    //    {
    //    do
    //    ZE( countT , cToDo ) ;
    //{
    //ENABLE THIS NORMALLY; DISABLE THIS IF AM EDITING SO AM DOING AN ABRIDGED BUILD

    ZE( countT , idt ) ;
    ZE( boolT , bLogKt ) ;
    boolT bLogExp = 1 ;

    tinP.flagsThreadMode1 |= flTHREADmODE1_WATCHfORaSYNCHiMPOTENCE ;
    flagsT flagsThreadMode1Save = tinP.flagsThreadMode1 ;

    ZE( countT , idStep ) ;
    etherC::ifcSayIF( T("pass ")+TF1(++stateP.idPass)+T(" begun")+tc , flSAY_APPEND | flSAY_LOG ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
    TN( tc , "\r\n" ) ;
{
voidT makePackF( tinS& tinP , etherC& ether , etherC& etThread , stackC& st1P , stackC& st2P , stackC& st3P , stackC& st4P , boolT bTestP , stateS& stateP )

    }
        }                                                                                                                       \
            /*(>>>>(p oolC&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<Thread).walkF( tinP , 0 , info , flPOOLoLDwALK_INCLUDEdROPSoTHERcLIENTS ) ;*/                             \
            etherC::ifcSayIF( TT(timeN1,timeN2)+T(" step ")+TF1(idStep)+T(" ended\r\n") , flSAY_APPEND | flSAY_LOG ) ;                              \
            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;                                                                     \
            timeN2 = timeN1 = 0 ;                                                                                               \
            if( bLogExp ) etherC::ifcSayIF( T(#expP)+tc , flSAY_APPEND | flSAY_LOG ) ;                                                              \
            TN( tLogPool , "///d/ideafarm.log.thirdC" ) ;                                                                       \
            ZE( countT , info ) ;                                                                                             \
            }                                                                                                                   \
                *tinP.zEtScratch = 0 ;                                                                                                 \
                etherC::ifcSayIF( T("FAILED\r\n") , flSAY_APPEND | flSAY_LOG ) ;                                                                    \
            {                                                                                                                   \
            if( *tinP.zEtScratch )                                                                                                     \
            expP ;                                                                                                              \
            if( bLogKt ) etherC::ifcSayIF( T((strokeS*)st3P[idt])+tc , flSAY_APPEND | flSAY_LOG ) ;                                                 \
            etherC::ifcSayIF( T("pass ")+TF1(stateP.idPass)+T(" step ")+TF1(stateP.idStep)+T(bLogExp?": "#expP:"") , flSAY_APPEND | flSAY_LOG ) ;   \
            stateP.idStep = idStep ;                                                                                            \
            if( bLogExp ) etherC::ifcSayIF( T(#expP)+tc , flSAY_APPEND | flSAY_LOG ) ;                                                              \
            TN( tLog , "///d/log.ifc.html" ) ;                                                                                  \
                                                                                                                                \
            etherC::ifcSayIF( TT(timeN1,timeN2)+T(" step ")+TF1(idStep)+T(" started\r\n") , flSAY_APPEND | flSAY_LOG ) ;                            \
            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;                                                                     \
            ZE( sCountT , timeN2 ) ;                                                                                          \
            ZE( countT , timeN1 ) ;                                                                                           \
        {                                                                                                                       \
        if( ++ idStep > stateP.idStep && !ether && !etThread && !*tinP.zEtScratch )                                                    \
    {                                                                                                                           \
                                                                                                                                \
#define STEP(expP)                                                                                                              \

}
    }
        ///* 44 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("e") , T("etherC") ) ;
        ///* 34 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("a2") , T("thirdC") ) ;
        ///* 54 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("2") , T("symbols") ) ;
        ///* 64 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("3") , T("dissertation") , T("Wo'O Ideafarm's Ph.D. Dissertation") ) ;
        ///* 74 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("f3") , T("templates") ) ;
        // THESE ARE DONE LAST BECAUSE THEY ARE LARGE

        // ALPHABETICAL END
        ///* 24 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("e2") , T("vectorOldC") ) ;
        ///* 14 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("d2") , T("tinS") ) ;
        ///* 04 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("c2") , T("timeS") ) ;
        ///* f3 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("b2") , T("thirdParties") ) ;
        ///* e3 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("92") , T("textIdFileC") ) ;
        ///* d3 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("82") , T("textC") ) ;
        ///* c3 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("72") , T("taskS") ) ;
        ///* b3 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("62") , T("tableC") ) ;
        ///* a3 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("52") , T("switchStackC") ) ;
        ///* 93 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("42") , T("switchC") ) ;
        ///* 83 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("32") , T("strokeS") ) ;
        ///* 73 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("22") , T("stackC") ) ;
        ///* 63 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("12") , T("sqMatrixOldC") ) ;
        ///* 53 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("02") , T("socketC") ) ;
        ///* 43 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("f1") , T("signC") ) ;
        ///* 23 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("d1") , T("sCountC") ) ;
        ///* 13 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("e3") , T("riverC") ) ;
        ///* 03 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("d3") , T("pricerC") ) ;
        ///* e2 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("c1") , T("poolC") ) ;
        ///* d2 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("b1") , T("plateS") ) ;
        ///* c2 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("a1") , T("peekS") ) ;
        ///* b2 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("91") , T("osFileNameC") ) ;
        ///* a2 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("81") , T("maxC") ) ;
        ///* 92 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("71") , T("mapC") ) ;
        ///* 82 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("61") , T("mainS") ) ;
        ///* 72 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("b3") , T("lakeC") ) ;
        ///* 62 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("51") , T("infoFileS") ) ;
        ///* 52 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("41") , T("infoDiskS") ) ;
        ///* 42 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("31") , T("infoDisk1S") ) ;
        ///* 32 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("21") , T("infoDisk1bS") ) ;
        ///* 22 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("11") , T("infoDisk1aS") ) ;
        ///* 12 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("01") , T("infoBoxGetPutS") ) ;
        ///* f1 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("f")  , T("ifFileNameC") ) ;
        ///* e1 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("93") , T("ap_artmentOldC") ) ;
        ///* d1 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("83") , T("dictionary1C") ) ;
        ///* c1 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("d")  , T("count8S") ) ;
        ///* b1 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("c")  , T("count7S") ) ;
        ///* a1 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("b")  , T("count6S") ) ;
        ///* 91 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("a")  , T("count5S") ) ;
        ///* 81 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("9")  , T("count4S") ) ;
        ///* 71 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("8")  , T("count3S") ) ;
        ///* 61 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("7")  , T("count2S") ) ;
        ///* 51 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("73") , T("countTC") ) ;
        ///* 41 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("63") , T("carC") ) ;
        ///* 31 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("53") , T("buoyFileC") ) ;
        ///* 21 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("43") , T("buoyDireC") ) ;
        ///* 11 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("33") , T("buoyDictionaryC") ) ;
        ///* 01 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("23") , T("buoyBookOfLifeC") ) ;
        ///* f0 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("13") , T("buoyC") ) ;
        ///* e0 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("6")  , T("boxC") ) ;
        ///* d0 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("5")  , T("batonC") ) ;
        ///* c0 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("4")  , T("batonBoxC") ) ;
        ///* b0 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("03") , T("anchorC") ) ;
        // ALPHABETICAL BEGIN
    {
    else
    if( bTestP ) /* 24 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("e2") , T("vectorOldC") ) ;

    ///* a0 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("f2") , T("busC") ) ;
    //* U:WHAT IS THIS NUMERIC COMMENT MEAN? */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("04") , T("test") ) ;
    
    ///* 00 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("102") , T("102") , T("resume: Wo'O Ideafarm") ) ;
    
    ///* 00 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("301") , T("301") , T("IdeaFarm " "(tm) City Market Plaza") ) ;
    ///* 00 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("201") , T("201") , T("IdeaFarm " "(tm) City Free Trade Zone") ) ;
    ///* 00 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("101") , T("101") , T("IdeaFarm " "(tm) ROC: pseudo perfect markets") ) ;
    
    /* 90 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("84") , T("commandments") , T("Ta Commandments") ) ;
    /* 90 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("74") , T("purchase") , T("Purchase Now!") ) ;
    /* 90 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("64") , T("song") , T("Community Song") ) ;
    /* 90 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("54") , T("work") , T("IdeaFarm " "(tm) City Affiliated Workplaces") ) ;
    /* 90 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("44") , T("community") , T("Evenings of Community in IdeaFarm " "(tm) City") ) ;
    ///* 90 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("34") , T("private2") , T("IdeaFarm " "(tm) City Private Disclosure for Executives") ) ;
    ///* 90 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("24") , T("private1") , T("IdeaFarm " "(tm) City New Resident Welcome") ) ;
    ///* 90 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("14") , T("fees")     , T("IdeaFarm " "(tm) City Fees") ) ;
    /* 90 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("1")  , T("ideafarm") , T("IdeaFarm " "(tm) City") ) ;
{
voidT setupF( tinS& tinP , etherC& etThread , stackC& st1P , stackC& st2P , stackC& st3P , stackC& st4P , boolT bTestP )

}
    etThread.strMakeF( tinP , psttw , T("///ideafarm/precious/domains/com/ideafarm/city/library/base/")+T(psttOldClassP)+T(".base")   ) ; st4P << psttw ; psttw = 0 ;
    etThread.strMakeF( tinP , psttw , psttTitle                                                                           ) ; st3P << psttw ; psttw = 0 ;
    etThread.strMakeF( tinP , psttw , T(WWWiDEAFARMcOM "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/1.")+T(psttIdP)         ) ; st2P << psttw ; psttw = 0 ;
    etThread.strMakeF( tinP , psttw , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/packs/1.")+T(psttIdP)                  ) ; st1P << psttw ; psttw = 0 ;

    ZE( strokeS* , psttw ) ;

    const strokeS* const psttTitle = psttTitleP ? psttTitleP : psttOldClassP ;
{
voidT htmlJobF( tinS& tinP , etherC& etThread , stackC& st1P , stackC& st2P , stackC& st3P , stackC& st4P , const strokeS* const psttIdP , const strokeS* const psttOldClassP , const strokeS* const psttTitleP = 0 )

}
    }
        etThread.delF( tinP , pba ) ;
        }
            etThread.boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/pack") , pba , cba ) ;
            etherC::ifcSayIF( T("writing combined pack")+tc , flSAY_APPEND | flSAY_LOG ) ;

            }
                etThread.delF( tinP , pc2p ) ;
                }
                    etThread.delF( tinP , pbPack ) ;
                    off += cbPack - sizeof( countT ) ;
                    etThread.memCopyF( tinP , pba + off , pbPack + sizeof( countT ) , cbPack - sizeof( countT ) ) ;
                    byteT* pbPack = (byteT*)pc2p->c2 ;
                    countT cbPack = pc2p->c1 ;
                {
                if( pc2p )
                stPacks >> pc2p ;
                ZE( count2S* , pc2p ) ;
                if( ++ idPack % 0x100 == 1 ) etherC::ifcSayIF( T("copying pack ")+TF1(idPack)+T(" of ")+TF1(cToDo)+T(" to combined image")+tc , flSAY_APPEND | flSAY_LOG ) ;
            {
            while( stPacks )
            countT off = sizeof( countT ) ;

            *(countT*)pba = ifcIDfILEtYPE_PACKED ;
        {
        if( pba )
        etThread.newF( tinP , LF , pba , cba ) ; ___( pba ) ;
        ZE( byteT* , pba ) ;
        idPack = 0 ;

        while( ~handle ) ;
        }
            if( pc2p ) cba += pc2p->c1 - sizeof( countT ) ;
            count2S* pc2p = (count2S*)stPacks.downF( tinP , handle ) ;
        {
        do
        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        countT cba = sizeof( countT ) ;
    {
    if( stPacks )

    }
        etThread.delF( tinP , pstt1m ) ;
        }
            }
                }
                    stPacks << pc2p ;
                    pc2p->c2 = (countT)pbPack ;
                    pc2p->c1 = cbPack ;
                {
                if( pc2p )
                etThread.newF( tinP , LF , pc2p ) ; ___( pc2p ) ;
                ZE( count2S* , pc2p ) ;
            {
            if( !etThread )

            if( !etThread ) { __( *(countT*)pbPack - ifcIDfILEtYPE_PACKED ) ; }
            if( !etThread ) { __( cbPack < sizeof( countT )               ) ; }
            etThread.boxGetShadowF( tinP , pbPack , cbPack , psttc1 ) ; ___( pbPack ) ;
            ZE( countT , cbPack ) ;
            ZE( byteT* , pbPack ) ;

            if( ++ idPack % 0x100 == 1 ) etherC::ifcSayIF( T("reading pack ")+TF1(idPack)+T(" of ")+TF1(cToDo)+T(" from disk")+tc , flSAY_APPEND | flSAY_LOG ) ;
        {
        FORsTRINGSiN1( pstt1m )

        cToDo = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/packs/" "*") ) ; ___( pstt1m ) ;
        ZE( strokeS* , pstt1m ) ;
    {
    stackC stPacks( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_count2S ) ;
    TN( tc , "\r\n" ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
    ZE( countT , cToDo ) ;
    ZE( countT , idPack ) ;
{
voidT onePackF( tinS& tinP , etherC& etThread )
// THIS CODE IS DUPLICATED IN 9e30104 AND IN dd30104

//U: USE A MACRO TO GEN THE CODE FOR THESE BOOLEAN FUNCTIONS

}
    etThread.delF( tinP , pstt1m ) ;
    }
        //etThread.boxPutHtmlFromKnowledgeTreeBaseF( tinP , 0 , tHtmlLocalf+tIdi , tHtml+tIdi , tIdi , tCopy , psttc1 , 0x100000 ) ;
        etThread.boxPutHtmlFromKnowledgeTreeBaseF( tinP , 1 , tHtmlLocalp+tIdi , tHtml+tIdi , tIdi , tCopy , psttc1 , 0x100000 ) ;
        if( !( cToDo % 0x1000 ) ) etherC::ifcSayIF( TF3(--cToDo,0,6)+tc , flSAY_APPEND | flSAY_LOG ) ;

        etThread.delF( tinP , psttIdi ) ;
        TN( tIdi , psttIdi ) ;
        etThread.delF( tinP , psttw ) ;
        etThread.strWordF( tinP , psttIdi , psttw , sttq , S1C('.') , 2 ) ; ___( psttIdi ) ;
        ZE( strokeS* , psttIdi ) ;
        etThread.strWordF( tinP , psttw , psttc1 , sttq , S1C('/') , - 1 ) ; ___( psttw ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , psttw ) ;
        etherC::ifcSayIF( T("writeVisiblesHtmlF/")+T(psttc1)+tc , flSAY_APPEND | flSAY_LOG ) ;

        //if( bSkip ) continue ;
        //if( bSkip && !etThread.strCompareF( tinP , psttc1 , tSkipTo ) ) bSkip = 0 ;
    {
    FORsTRINGSiN1( pstt1m )
    //TN( tSkipTo , "" ) ; tSkipTo = tKt+T("5100104.base") ;
    //boolT bSkip = 1 ;
    ZE( countT , idFile ) ;
    else { cToDo = etThread.boxMenuF( tinP , soul1m , tKt+T("*.base") ) ; ___( pstt1m ) ; }
    }
        cToDo  = etThread.boxMenuF( tinP , soul1m , tKt+T("2130104.base") ) ; ___( pstt1m ) ;
    {
    if( bTestP )
    ZE( countT , cToDo ) ;
    ZE( strokeS* , pstt1m ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
    TN( tCopy , "(c) IdeaFarm " "(tm) City" ) ;
    TN( tHtmlLocalf , "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/files/5." ) ;
    TN( tHtmlLocalp , "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/packs/5." ) ;
    TN( tHtml , WWWiDEAFARMcOM "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/5." ) ;
    TN( tKt2 , ".kt" ) ;
    }
        etThread.delF( tinP , psttm ) ;
        tKt = T(psttm) ;
        etThread.diskMapFileNameF( tinP , psttm , tKt ) ; // MAPPED WO TIME HERE, FOR SPEED
        ZE( strokeS* , psttm ) ;
    {
    TN( tKt  , "///ideafarm/ephemeral/domains/com/ideafarm/gen/kt/visible." ) ;
    TN( tc , "\r\n" ) ;
{
voidT writeVisiblesHtmlF( tinS& tinP , etherC& etThread , const boolT bTestP )

}
    baton.ungrabF( tinP ) ;

    __( idDeathType ) ;
    __( value ) ;
    else         etThread.osProcessF( value , idDeathType , tinP , T("///d/ideafarm.work/backed.up.never/gen/exe/released.i00005/01000030.ipdos-we") , T("de30104 !woPass") ) ;
    if( bTestP ) etThread.osProcessF( value , idDeathType , tinP , T("///d/ideafarm.work/backed.up.never/gen/exe/released.i00005/01000030.ipdos-we") , T("de30104 !woPass !test") ) ;
    ZE( countT , idDeathType ) ;
    ZE( countT , value ) ;

    baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
    batonC baton( tinP , TAG( TAGiDnULL ) , T("ifc.hog") ) ;
{
voidT testAutoF( tinS& tinP , etherC& etThread , const boolT bTestP )

}
    etThread.delF( tinP , pstt1mEx ) ;
    }
        etThread.delF( tinP , psttv ) ;
        }
            etThread.delF( tinP , pstts ) ;
            }
                }
                    etThread.delF( tinP , posts ) ;
                    etThread.boxPutF( tinP , tSubjectFile , posts , costs ) ;
                    countT costs = etThread.strMakeF( tinP , posts , pstts ) ; ___( posts ) ;
                    ZE( osTextT* , posts ) ;
                    etThread.strReverseF( tinP , pstts , 0 , T("\r\n") ) ; ___( pstts ) ;
                {
                if( bModified )

                }
                    }
                        bModified = 1 ;
                        etThread.strInsertF( tinP , pstts , idlList , tLink ) ; ___( pstts ) ;
                        idlList ++ ;
                    {
                    if( !bListed )

                    }
                        etThread.delF( tinP , psttwl ) ;

                        bListed = !!etThread.strIdF( tinP , idfListed , sttqListed , tLink , psttwl ) ;
                        strokeS sttqListed( (countT)0 , sc_IGNOREqUOTES ) ;
                        countT idfListed = 1 ;

                        etThread.strSubstringF( tinP , psttwl , idfwl , idlwl , pstts ) ; ___( psttwl ) ;
                        countT idlwl = idlList ;
                        countT idfwl = idfList ;
                        ZE( strokeS* , psttwl ) ;
                    {
                    if( idfList <= idlList )
                    ZE( boolT , bListed ) ;

                    etThread.delF( tinP , psttTitleOfSubject ) ;
                    textC tLink = t1+tIdi+t2+tIdi+T(":  ")+T(psttTitleOfSubject)+t3 ;
                    TN( t3 , "\\</A\\>\r\n" ) ;
                    TN( t2 , ".1.1" ".0.html\\\"\\>" ) ;
                    TN( t1 , "  \\<A HREF=\\\"5." ) ;
                    //OBSOLETE:TN( t1 , "  \\<A HREF=\\\"http://" WWWiDEAFARMcOM "/5." ) ;

                    }
                        if( !psttTitleOfSubject ) { etThread.strMakeF( tinP , psttTitleOfSubject , T("") ) ; ___( psttTitleOfSubject ) ; }
                        }
                            else if( psttTitleOfSubject )    etThread.delF( tinP , psttTitleOfSubject ) ;
                                 if( idClass == 1 ) break ;
                            etThread.strSubstringDelimitedF( tinP , psttTitleOfSubject , idClass , idf , sttq , psttv ) ; ___( psttTitleOfSubject ) ;
                            ZE( countT , idClass ) ;
                        {
                        while( !etThread && idf )
                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                        countT idf = 1 ;
                    {                        
                    ZE( strokeS* , psttTitleOfSubject ) ;

                    if( idlList ) idlList -- ;
                    countT idlList = idNextSectionF( tinP , etThread , pstts , idfList ) ;
                {
                if( !bSuppress )

                }
                    }
                        else idfList = idw + tSim.csF( tinP ) ;
                        }
                            bModified = 1 ;
                            idfList = idw ;
                            etThread.strInsertF( tinP , pstts , idw , T(" simplest\r\n") ) ;
                            idw = idws + tExa.csF( tinP ) ; // COULD NOT FIND THE "simplest" LINE, SO MAKE simplest LINE
                        {
                        if( !idw )
                        idw = etThread.strIdF( tinP , idf , sttq , tSim , pstts ) ;
                        const countT idws = idf = idw ; // FOUND examples LINE AT idws
                    {
                    else
                    }
                        }
                            bModified = 1 ;
                            idfList = idw ;
                            etThread.strInsertF( tinP , pstts , idw , T("examples\r\n simplest\r\n") ) ;
                        {
                        if( !bSuppress )

                        else idw += 6 ;
                        }
                            bSuppress = 1 ; //U: DO NOT SUPPRESS FOR ASSEMBLER FILES; INSTEAD, PREFIX THE INSERTED LINE WITH ";"
                            else idw += 7 ;
                            }
                                etherC::ifcSayIF( T("could not find the expected \"\\r\\n/" "*\\r\\n\" or \"\\r\\n;/" "*\\r\\n\" in file \"")+tSubjectFile+T("\"")+tc , flSAY_APPEND | flSAY_LOG ) ;
                            {
                            if( !idw )
                            idw = etThread.strIdF( tinP , idf , sttq , T("\r\n;/" "*\r\n") , pstts ) ;
                            idf = 1 ;
                        {
                        if( !idw )
                        idw = etThread.strIdF( tinP , idf , sttq , T("\r\n/" "*\r\n") , pstts ) ;
                        idf = 1 ; // COULD NOT FIND THE "examples" LINE, SO MAKE examples/simplest LINES
                    {
                    if( !idw )                                
                    countT idw = etThread.strIdF( tinP , idf , sttq , tExa , pstts ) ;
                    idf = 1 ;
                    TN( tSim , "\r\n simplest\r\n" ) ;
                    TN( tExa , "\r\nexamples\r\n" ) ;
                {
                ZE( countT , idfList ) ; // MAKE SURE THAT THE SUBJECT FILE CONTAINS THE "example/simplest" LINES, AND SET idfList
                ZE( boolT , bSuppress ) ;
                ZE( boolT , bModified ) ;
            {
            if( pstts )

            }
                etThread.delF( tinP , psttQuotedPart ) ;
                }
                    }
                        etThread.strReverseF( tinP , pstts , 0 , T("\r\n") ) ; ___( pstts ) ;
                        etThread.delF( tinP , posts ) ;
                        etThread.strMakeF( tinP , pstts , T(posts) ) ; ___( pstts ) ;

                        etThread.boxGetShadowF( tinP , posts , costs , tSubjectFile , 1 ) ; ___( posts ) ;
                        ZE( countT   , costs ) ;
                        ZE( osTextT* , posts ) ;
                    {
                    if( etThread.diskFileExistsF( tinP , tSubjectFile ) )

                    etThread.delF( tinP , psttw ) ;
                    tSubjectFile = tDic+T(psttw) ;
                    etThread.strSubstringF( tinP , psttw , idf , idl , psttQuotedPart ) ; ___( psttw ) ;
                    ZE( strokeS* , psttw ) ;
                    ZE( countT , idl ) ;
                {
                if( psttQuotedPart && 1 == etThread.strIdF( tinP , idf , sttq , T("example.simplest.") , psttQuotedPart ) && idf )
                countT idf = 1 ;

                etThread.strWordF( tinP , psttQuotedPart , tTitle , sttq , S1C(0x22) , 2 ) ; ___( psttQuotedPart ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttQuotedPart ) ;
            {
            if( !bBase )
            ZE( strokeS* , pstts ) ;
            TN( tSubjectFile , "" ) ;

            }
                }
                    etThread.delF( tinP , postv ) ;
                    etThread.boxPutF( tinP , psttc1 , postv , costv ) ;
                    etThread.delF( tinP , psttv2 ) ;
                    countT costv = etThread.strMakeF( tinP , postv , psttv2 ) ; ___( postv ) ;
                    ZE( osTextT* , postv ) ;
                    etThread.strReverseF( tinP , psttv2 , psttv , T("\r\n") ) ; ___( psttv2 ) ;
                    ZE( strokeS* , psttv2 ) ;

                    }
                        etThread.strInsertF( tinP , psttv , idlList , tLink ) ; ___( psttv ) ;
                        idlList ++ ;
                    {
                    if( !bListed )

                    }
                        etThread.delF( tinP , psttwl ) ;

                        bListed = !!etThread.strIdF( tinP , idfListed , sttqListed , tLink , psttwl ) ;
                        strokeS sttqListed( (countT)0 , sc_IGNOREqUOTES ) ;
                        countT idfListed = 1 ;

                        etThread.strSubstringF( tinP , psttwl , idfwl , idlwl , psttv ) ; ___( psttwl ) ;
                        countT idlwl = idlList ;
                        countT idfwl = idfList ;
                        ZE( strokeS* , psttwl ) ;
                    {
                    if( idfList <= idlList )
                    ZE( boolT , bListed ) ;

                    if( idlList ) idlList -- ;
                    countT idlList = idNextSectionF( tinP , etThread , psttv , idfList ) ;
                {
                if( !bSuppress )

                }
                    else idfList = idw + 6 ;
                    }
                        bSuppress = 1 ; //U: DO NOT SUPPRESS FOR ASSEMBLER FILES; INSTEAD, PREFIX THE INSERTED LINE WITH ";"
                        else idfList = idw + 7 ;
                        }
                            etherC::ifcSayIF( T("could not find the expected \"\\r\\n/" "*\\r\\n\" or \"\\r\\n;/" "*\\r\\n\" in file \"")+T(psttc1)+T("\"")+tc , flSAY_APPEND | flSAY_LOG ) ;
                        {
                        if( !idw )
                        idw = etThread.strIdF( tinP , idf , sttq , T("\r\n;/" "*\r\n") , psttv ) ;
                        idf = 1 ;
                    {
                    if( !idw )
                    idw = etThread.strIdF( tinP , idf , sttq , T("\r\n/" "*\r\n") , psttv ) ;
                    idf = 1 ;
                {
                else
                if( idw ) bSuppress = 1 ;
                countT idw = etThread.strIdF( tinP , idf , sttq , tLink , psttv ) ;
                idf = 1 ;
                textC tLink = T("\\<A HREF=\\\"5.")+tIdi+T(".1.0.html\\\"\\>definition\\</A\\>\r\n") ;
                //OBSOLETE: textC tLink = T("\\<A HREF=\\\"http://" WWWiDEAFARMcOM "/5.")+tIdi+T(".1.0\\\"\\>definition\\</A\\>\r\n") ;
                ZE( countT , idfList ) ;
                ZE( boolT , bSuppress ) ;
            {
            // INSERT A "DEFINITION" LINK LINE INTO FILE COMMENTS

            }
                etThread.delF( tinP , postx ) ;
                etThread.boxPutF( tinP , tKt+tIdi+tKt2 , postx , costx ) ;
                else        { costx = etThread.strMakeF( tinP , postx , T("/" "/" "|" "|" "!" "k" "t" "|"    )+T(psttc1)+T("!||\r\n")+tIdi+T(":  ")+tTitle+T("\r\n") ) ; ___( postx ) ; }
                if( bBase ) { costx = etThread.strMakeF( tinP , postx , T("/" "/" "|" "|" "!" "r" "a" "w" "|")+T(psttc1)+T("!||\r\n")+tIdi+T(":  ")+tTitle+T("\r\n") ) ; ___( postx ) ; }
                ZE( countT , costx ) ;
                ZE( osTextT* , postx ) ; // WRITE THE BASE FILE
            {

            }
                etThread.delF( tinP , psttTitle ) ;
                tTitle = T(psttTitle) ;
                if( !psttTitle ) { etThread.strMakeF( tinP , psttTitle , T("") ) ; ___( psttTitle ) ; }
                }
                    else if( psttTitle )    etThread.delF( tinP , psttTitle ) ;
                         if( idClass == 1 ) break ;
                    etThread.strSubstringDelimitedF( tinP , psttTitle , idClass , idf , sttq , psttv ) ; ___( psttTitle ) ;
                    ZE( countT , idClass ) ;
                {
                while( !etThread && idf )
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                countT idf = 1 ;
                ZE( strokeS* , psttTitle ) ;
            {
            TN( tTitle , "" ) ;

            }
                etThread.delF( tinP , psttIdi ) ;
                tIdi = T(psttIdi) ;
                etThread.delF( tinP , psttw ) ;
                etThread.strWordF( tinP , psttIdi , psttw , sttqId , S1C('.') , 2 ) ; ___( psttIdi ) ;
                ZE( strokeS* , psttIdi ) ;
                strokeS sttqId( (countT)0 , sc_IGNOREqUOTES ) ;

                __Z( psttw ) ;
                etThread.strWordF( tinP , psttw , psttc1 , sttqw , S1C('/') , - 1 ) ; ___( psttw ) ;
                strokeS sttqw( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttw ) ;
            {
            TN( tIdi , "" ) ;
        {
        if( bBase || etThread.strIdF( tinP , idf , sttq , T("\r\n//VISIBLE\r\n") , psttv ) )
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;

        }
            etThread.delF( tinP , postv ) ;
            etThread.strReverseF( tinP , psttv , 0 , T("\r\n") ) ; ___( psttv ) ;
            etThread.strMakeF( tinP , psttv , T(postv) ) ; ___( psttv ) ;
            etThread.boxGetShadowF( tinP , postv , costv , psttc1 , 1 ) ; ___( postv ) ;
            ZE( countT , costv ) ;
            ZE( osTextT* , postv ) ;
        {
        ZE( strokeS* , psttv ) ;

        //if( cToDo == cToDoSave && !etThread.strCompareF( tinP , psttc1 , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/5adam.0000104") ) ) continue ;

        }
            bBase = 1 != etThread.strIdF( tinP , idf , sttq , tDic+T("adam.") , psttc1 ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        ZE( boolT , bBase ) ;
        if( !( cToDo % 0x1000 ) ) etherC::ifcSayIF( TF3(cToDo,0,6)+tc , flSAY_APPEND | flSAY_LOG ) ;
    {
    FORsTRINGSiN1( pstt1mEx )
    const countT cToDoSave = cToDo ;
    else         { cToDo = etThread.boxMenuF( tinP , soul1mEx , tDic+T("*") ) ; ___( pstt1mEx ) ; }
    }
        cToDo += etThread.boxMenuF( tinP , soul1mEx , tDic+T("adam.2130104.*") ) ; ___( pstt1mEx ) ;
        cToDo  = etThread.boxMenuF( tinP , soul1mEx , tDic+T("func.1310003.*") ) ; ___( pstt1mEx ) ;
    {
    if( bTestP )

    ZE( countT , cToDo ) ;
    ZE( strokeS* , pstt1mEx ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
    TN( tKt2 , ".base" ) ;
    }
        etThread.delF( tinP , psttm ) ;
        tKt = T(psttm) ;
        etThread.diskMapFileNameF( tinP , psttm , tKt ) ; // MAPPING THIS WO TOO, FOR SPEED
        ZE( strokeS* , psttm ) ;
    {
    TN( tKt     , "///ideafarm/ephemeral/domains/com/ideafarm/gen/kt/visible." ) ;
    }
        etThread.delF( tinP , psttm ) ;
        tDic = T(psttm) ;
        etThread.diskMapFileNameF( tinP , psttm , tDic ) ; // NEED TO MAP tDic CAUSE WILL SEARCH FOR IT IN FILE NAMES IN MENU
        ZE( strokeS* , psttm ) ;
    {
    TN( tDic , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/" ) ;
    TN( tc , "\r\n" ) ;
{
voidT listVisibleDefinitionsF( tinS& tinP , etherC& etThread , const boolT bTestP )

}
    }
        etThread.delF( tinP , psttd ) ;
        stackDef >> psttd ;
        ZE( strokeS* , psttd ) ;        
    {
    while( stackDef )

    }
        etThread.delF( tinP , psttf ) ;

        //etThread.boxPutHtmlFromKnowledgeTreeBaseF( tinP , 0 , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/files/6.$")+T(psttf) , T(WWWiDEAFARMcOM "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/6.$")+T(psttf) , psttf , tCopy , tBase , 0x100000 ) ;
        etThread.boxPutHtmlFromKnowledgeTreeBaseF( tinP , 1 , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/packs/6.$")+T(psttf) , T(WWWiDEAFARMcOM "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/6.$")+T(psttf) , psttf , tCopy , tBase , 0x100000 ) ;
        TN( tCopy , "(c) IdeaFarm " "(tm) City" ) ;

        etThread.delF( tinP , posti ) ;
        etThread.boxPutF( tinP , tBase , posti , costi ) ;
        textC tBase = T("///ideafarm/ephemeral/domains/com/ideafarm/gen/kt/instances.")+T(psttf)+T(".base") ;
        etThread.delF( tinP , psttImage ) ;
        else costi = etThread.strMakeF( tinP , posti , T("none") ) ; ___( posti ) ;
        }
            costi = etThread.strMakeF( tinP , posti , psttImage ) ; ___( posti ) ;
            etThread.strReverseF( tinP , psttImage , 0 , T("\r\n") ) ; ___( psttImage ) ;
        {
        if( psttImage ? psttImage->idAdam : 0 )
        ZE( countT   , costi ) ;
        ZE( osTextT* , posti ) ;

        }
            etThread.delF( tinP , psttl ) ;
            etThread.strFuseF( tinP , psttImage , psttl , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ 0x10000 ) ; ___( psttImage ) ;
            else          { etThread.strFuseF( tinP , psttImage , T("\r\n") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ 0x10000 ) ; ___( psttImage ) ; }
            if( !bPrior ) bPrior = 1 ;
            stackLine >> psttl ;
            ZE( strokeS* , psttl ) ;        
        {
        while( stackLine )
        etThread.strMakeF( tinP , psttImage , T("") , 0x10000 ) ; ___( psttImage ) ;
        ZE( strokeS* , psttImage ) ;
        ZE( boolT , bPrior ) ;

        }
            while( ~hTour ) ;
            }
                }
                    if( psttExample ) stackLine.sinkF( tinP , idSlot , psttExample ) ;
                    ZE( countT , idSlot ) ;
                    etThread.strSubstringExampleF( tinP , psttExample , idfd , sttqd , psttd , psttf , sttOpenP , psttWhiteP ) ; ___( psttExample ) ;
                    ZE( strokeS* , psttExample ) ;
                {
                while( idfd )
                countT idfd = 1 ;
                strokeS sttqd( (countT)0 , sc_IGNOREqUOTES ) ;
                strokeS* psttd = (strokeS*)stackDef.upF( tinP , hTour ) ;
                if( !( ( ++ idTourStop ) % 0x100 ) ) etherC::ifcSayIF( T("3 functions not yet processed: ")+TF3(stackFun,0,6)+T(": tour stop ")+TF1(idTourStop)+tc , flSAY_APPEND | flSAY_LOG ) ;
            {
            do
            handleC hTour( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , idTourStop ) ;
        {
        stackC stackLine( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

        stackFun >> psttf ;
        ZE( strokeS* , psttf ) ;        
    {
    while( stackFun )

    }
        etThread.delF( tinP , pstt1mFun ) ;
        }
            if( psttf && S1C('F') != psttf[ CSpREFIX - 1 + psttf->idAdam ] || ( stackFun.sinkF( tinP , idSlot , psttf , flSTACKsINK_UNIQUE ) , !idSlot ) ) etThread.delF( tinP , psttf ) ;
            ZE( countT , idSlot ) ;
            etThread.strWordF( tinP , psttf , psttc1 , sttq , S1C('.') , - 1 , 1 ) ; ___( psttf ) ;
            ZE( strokeS* , psttf ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            etherC::ifcSayIF( T("2 building stack of function names")+TF3(--cToDo,0,6)+tc , flSAY_APPEND | flSAY_LOG ) ;
        {
        FORsTRINGSiN1( pstt1mFun )
        else         { cToDo = etThread.boxMenuF( tinP , soul1mFun , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.*"        ) ) ; ___( pstt1mFun ) ; }
        if( bTestP ) { cToDo = etThread.boxMenuF( tinP , soul1mFun , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.1330004.*") ) ; ___( pstt1mFun ) ; }
        ZE( countT , cToDo ) ;
        ZE( strokeS* , pstt1mFun ) ;
    {
    stackC stackFun( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

    }
        etThread.delF( tinP , pstt1mEx ) ;
        }
            stackDef << psttd ;
            etThread.strReverseF( tinP , psttd , 0 , T("\r\n") ) ; ___( psttd ) ;
            etThread.delF( tinP , postd ) ;
            etThread.strMakeF( tinP , psttd , T(postd) ) ; ___( psttd ) ;
            ZE( strokeS* , psttd ) ;
            etThread.boxGetShadowF( tinP , postd , costd , psttc1 , 1 ) ; ___( postd ) ;
            ZE( countT , costd ) ;
            ZE( osTextT* , postd ) ;
            etherC::ifcSayIF( T("1 building stack of reversed defs ")+TF3(--cToDo,0,6)+tc , flSAY_APPEND | flSAY_LOG ) ;
        {
        FORsTRINGSiN1( pstt1mEx )
        else         { cToDo = etThread.boxMenuF( tinP , soul1mEx , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.*"      ) ) ; ___( pstt1mEx ) ; }
        if( bTestP ) { cToDo = etThread.boxMenuF( tinP , soul1mEx , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/5adam.6230104") ) ; ___( pstt1mEx ) ; }
        ZE( countT , cToDo ) ;
        ZE( strokeS* , pstt1mEx ) ;
    {
    stackC stackDef( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    TN( tc , "\r\n" ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
{
voidT findFunctionCallInstancesF( tinS& tinP , etherC& etThread , const boolT bTestP , const strokeS sttOpenP , const strokeS* const psttWhiteP )

}
    etThread.delF( tinP , pstt1mEx ) ;
    }
        etThread.delF( tinP , pstti ) ;
        }
            etThread.delF( tinP , posti ) ;
            etThread.boxPutF( tinP , psttc1 , posti , costi ) ;
            if( !( cToDo % 0x1000 ) ) etherC::ifcSayIF( TF3(cToDo,0,6)+tc , flSAY_APPEND | flSAY_LOG ) ;
            costi = etThread.strMakeF( tinP , posti , pstti ) ; ___( posti ) ;
            etThread.strReverseF( tinP , pstti , 0 , T("\r\n") ) ; ___( pstti ) ;
        {
        if( bModified )

        if( !( cToDo % 0x1000 ) ) etherC::ifcSayIF( TF3(cToDo,0,6)+tc , flSAY_APPEND | flSAY_LOG ) ;
        }
            }
                }
                    bModified = 1 ;
                    etThread.strInsertF( tinP , pstti , idw , tLink ) ; ___( pstti ) ;
                    if( !( cToDo % 0x1000 ) ) etherC::ifcSayIF( TF3(cToDo,0,6)+tc , flSAY_APPEND | flSAY_LOG ) ;

                    textC tLink = t1+tName+t2 ;
                    TN( t2 , ".0.html\\\"\\>instances\\</A\\>\r\n" ) ;
                    TN( t1 , "\\<A HREF=\\\"6.$" ) ;
                    //OBSOLETE:TN( t1 , "\\<A HREF=\\\"http://" WWWiDEAFARMcOM "/6.$" ) ;

                    etThread.delF( tinP , psttName ) ;
                    TN( tName , psttName ) ;
                    etThread.strWordF( tinP , psttName , psttc1 , sttq , S1C('.') , - 1 ) ; ___( psttName ) ;
                    //sttq = ze ;
                    ZE( strokeS* , psttName ) ;

                    idw += 6 ;
                {
                else
                }
                    //U:: DO NOT SUPPRESS FOR ASSEMBLER FILES
                    if( !idw2 ) etherC::ifcSayIF( T("could not find the expected \"\\r\\n/" "*\\r\\n\" or \"\\r\\n;/" "*\\r\\n\" in file \"")+T(psttc1)+T("\"")+tc , flSAY_APPEND | flSAY_LOG ) ;
                    countT idw2 = etThread.strIdF( tinP , idf , sttq , T("\r\n;/" "*\r\n") , pstti ) ;
                    idf = 1 ;
                {
                if( !idw )
                countT idw = etThread.strIdF( tinP , idf , sttq , T("\r\n/" "*\r\n") , pstti ) ;
                //sttq = ze ;
                idf = 1 ;
            {
            if( !etThread.strIdF( tinP , idf , sttq , tIns , pstti ) )
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            TN( tIns , "\r\n\\<A HREF=\\\"6." ) ;
            //OBSOLETE:TN( tIns , "\r\n\\<A HREF=\\\"http://" WWWiDEAFARMcOM "/6." ) ;
        {
        ZE( boolT , bModified ) ;

        etThread.strReverseF( tinP , pstti , 0 , T("\r\n") ) ; ___( pstti ) ;
        etThread.delF( tinP , posti ) ;
        etThread.strMakeF( tinP , pstti , T(posti) ) ; ___( pstti ) ;
        ZE( strokeS* , pstti ) ;
        if( !( cToDo % 0x1000 ) ) etherC::ifcSayIF( TF3(cToDo,0,6)+tc , flSAY_APPEND | flSAY_LOG ) ;

        etThread.boxGetShadowF( tinP , posti , costi , psttc1 , 1 ) ; ___( posti ) ;
        ZE( countT   , costi ) ;
        ZE( osTextT* , posti ) ;

        { countT idf = 1 ; strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ; if( etThread.strIdF( tinP , idf , sttq , tOperator , psttc1 ) ) continue ; }

        if( !( cToDo % 0x1000 ) ) etherC::ifcSayIF( TF3(--cToDo,0,6)+tc , flSAY_APPEND | flSAY_LOG ) ;
    {
    FORsTRINGSiN1( pstt1mEx )
    TN( tc , "\r\n" ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
    TN( tOperator , ".operator" ) ;

    else         { cToDo = etThread.boxMenuF( tinP , soul1mEx , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.*F"        ) ) ; ___( pstt1mEx ) ; }
    if( bTestP ) { cToDo = etThread.boxMenuF( tinP , soul1mEx , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.1330004.*F") ) ; ___( pstt1mEx ) ; }
    ZE( countT , cToDo ) ;
    ZE( strokeS* , pstt1mEx ) ;
{
voidT insertInstanceSectionF( tinS& tinP , etherC& etThread , const boolT bTestP )

}
    etherC::ifcSayIF( TF1(cExists)+T(" simple examples found\r\n")+TF1(cNotExists)+T(" simple examples are missing\r\n") , flSAY_APPEND | flSAY_LOG ) ;

    etThread.delF( tinP , pstt1m ) ;
    }
        etThread.delF( tinP , psttd ) ;
        etThread.delF( tinP , psttw ) ;

        else cExists ++ ;
        etherC::ifcSayIF( TF1(++cNotExists)+T(": no example simplest exists for: ")+T(psttw)+tc , flSAY_APPEND | flSAY_LOG ) ;
        )
            ( idf = 1 , !etThread.strIdF( tinP , idf , sttq , T("example.simplest.")+T(psttw) , psttd ) ) // "example.simplest.func.1234001.fooC.barF"
            ( idf = 1 , !etThread.strIdF( tinP , idf , sttq , T("\r\nit is illegal to refer to this symbol in the definition of an adam\r\n") , psttd ) ) &&
        (
        if // FOR SPEED, sttq IS NOT REINITIALIZED FOR THE OO'TH strIdF CALL, SINCE IT SHOULD NOT HAVE CHANGED

        etThread.strWordF( tinP , psttw , psttc1 , sttq , S1C('/') , - 1 ) ; ___( psttw ) ; // "func.1234001.fooC.barF"
        ZE( strokeS* , psttw ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( countT , idf ) ;

        }
            etThread.delF( tinP , postd ) ;
            etThread.strMakeF( tinP , psttd , T(postd) ) ; ___( psttd ) ;
            etThread.boxGetShadowF( tinP , postd , costd , psttc1 , 1 ) ; ___( postd ) ;
            ZE( countT , costd ) ;
            ZE( osTextT* , postd ) ;
        {
        ZE( strokeS* , psttd ) ;

        if( !( cToDo % 0x1000 ) ) etherC::ifcSayIF( T("cToDo: ")+TF3(--cToDo,0,8)+tc , flSAY_APPEND | flSAY_LOG ) ;

        if( etThread ) break ;
    {
    FORsTRINGSiN1( pstt1m ) // FOR EACH SYMBOL DEFINITION
    TN( tc , "\r\n" ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
    ZE( countT , cNotExists ) ;
    ZE( countT , cExists ) ;

    }
        cToDo += etThread.boxMenuF( tinP , soul1m , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.*") ) ; ___( pstt1m ) ;
        cToDo  = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.*") ) ; ___( pstt1m ) ;
    {    
    else
    if( bTestP ) { cToDo = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.1330004.*") ) ; ___( pstt1m ) ; }
    ZE( countT , cToDo ) ;
    ZE( strokeS* , pstt1m ) ;
{
voidT verifyExampleSimplestExistsF( tinS& tinP , etherC& etThread , const boolT bTestP )

}
    return idNextSection ;

    }
        idNextSection = idcr + 2 ;

        if(    !idcr || idcr >  psttP->idAdam - 2 || psttP[ CSpREFIX + 1 + idcr ] == S1C(' ') ) idcr = 0 ;
        while(  idcr && idcr <= psttP->idAdam - 2 && psttP[ CSpREFIX + 1 + idcr ] == S1C(' ') ) idcr = etThread.strIdF( tinP , idf , sttq , tCr , psttP ) ;
        countT                                                                                idcr = etThread.strIdF( tinP , idf , sttq , tCr , psttP ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = idFirstP ;    
        TN( tCr , "\r\n" ) ;
    {
    else
    if( psttP && psttP[ CSpREFIX - 1 + idFirstP ] != S1C(' ') ) idNextSection = idFirstP ;

    ZE( countT , idNextSection ) ;
{
countT idNextSectionF( tinS& tinP , etherC& etThread , const strokeS* const psttP , const countT idFirstP )

}
    etThread.delF( tinP , postx ) ;
    etThread.boxPutF( tinP , T("///ideafarm/precious/domains/com/ideafarm/city/library/base/symbols.base") , postx , costx ) ;
    etThread.delF( tinP , pstto ) ;
    countT costx = etThread.strMakeF( tinP , postx , pstto ) ; ___( postx ) ;
    ZE( osTextT* , postx ) ;

    etThread.strReverseF( tinP , pstto , 0 , T("\r\n") ) ; ___( pstto ) ;

    etThread.delF( tinP , pstt1m ) ;
    }
        etThread.delF( tinP , psttw2 ) ;
        etThread.delF( tinP , psttw1 ) ;
        etThread.strFuseF( tinP , pstto , T(psttw2)+t1+T(psttw1)+t2 ) ; ___( pstto ) ;

        etThread.strWordF( tinP , psttw2 , psttc1 , sttq2 , sttd2 , - 1 ) ; ___( psttw2 ) ;
        strokeS sttq2( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , psttw2 ) ;

        etThread.strWordF( tinP , psttw1 , psttc1 , sttq1 , sttd1 , - 1 ) ; ___( psttw1 ) ;
        strokeS sttq1( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , psttw1 ) ;
    {
    FORsTRINGSiN1( pstt1m )
    TN( t2 , "!||\r\n" ) ;
    TN( t1 , "\r\n//||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/" ) ;
    strokeS sttd2( '.' ) ;
    strokeS sttd1( '/' ) ;
    etThread.strMakeF( tinP , pstto , T("") , cToDo * 0x400 ) ; ___( pstto ) ;
    ZE( strokeS* , pstto ) ;
    else         { cToDo = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010???.*") ) ; ___( pstt1m ) ; }
    if( bTestP ) { cToDo = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010001.*") ) ; ___( pstt1m ) ; }
    ZE( countT , cToDo ) ;
    ZE( strokeS* , pstt1m ) ;
    TN( tc , "\r\n" ) ;
{
voidT writeSymbolBaseF( tinS& tinP , etherC& etThread , const boolT bTestP )

}
{
stateC( tinP , etherP , sizeof *this , 0 , translateStateF )
stateS::stateS( tinS& tinP , etherC& etherP ) :

TRANSLATEsTATE_END
    state.idMe ++ ;
TRANSLATEsTATE_MIDDLE
    case 1 : { state.idMe = stateOther.idMe ; state.idPass = stateOther.idPass ; state.idStep = stateOther.idStep ; }
TRANSLATEsTATE_BEGIN( stateS , 1 )

;
}
    stateS( tinS& tinP , etherC& etherP ) ;

    countT idStep ;
    countT idPass ;
    countT idMe ;
    countT idVersion ;
{
struct stateS : public stateC

/*1*/WAKEhIDE( "city.publisher.make" )/*1*/
/**/
*/
  if specified, then a small lake pack is made that focuses on func.1330004.busC.cSubscribersF
 !test
command line parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

