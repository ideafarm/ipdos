
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

    
REST
//if( IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 == etThread.diskIdF( tinP , T("///c") ) ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;

etThread.delF( tinP , psttzOffUp   ) ;
etThread.delF( tinP , psttzOffDown ) ;
etThread.delF( tinP , psttzOnUp    ) ;
etThread.delF( tinP , psttzOnDown  ) ;
etThread.delF( tinP , psttzAbsent  ) ;
etThread.delF( tinP , psttzAbsent2 ) ;

etThread.strokeF( tinP , tPrefix+T("done 0")+tSuffix ) ;
THREADmODE2rESTORE
}
    etThread.strokeF( tinP , tPrefix+T("done 1")+tSuffix ) ;
    //}
    //    etThread.delF( tinP , psttfn ) ;
    //    QUITR
    //    etThread.boxPutGenerationF( tinP , psttfn , T("///ideafarm/ephemeral/domains/com/ideafarm/data/out") , 0x1000 , tNote , tNote.csF( tinP ) ) ; ___( psttfn ) ;
    //    QUITOZ
    //    ZE( strokeS* , psttfn ) ;
    //
    //    tNote += T(" [totalSessionDuration: ")+TT(timeSessionTotal1,timeSessionTotal2)+T("]") ;
    //
    //    tNote += T(" [cSessions: ")+TF1(idSession)+T("]") ;
    //
    //    tNote += T(" [duration: ")+TT(timeStop1,timeStop2)+T("]") ;
    //    etThread.osTimeSubtractF( tinP , timeStop1 , timeStop2 , timeStart1 , timeStart2 ) ;
    //
    //    ;
    //
    //        TT(timeStop1,timeStop2)
    //        T(": console stopped at ")+
    //        TF1(etThread.diskIdF(tinP))+
    //        T("Subject: ")+
    //
    //    TN( tNote , "" ) ; tNote =
    //{
    //etThread.osTimeNowF( tinP , timeStop1 , timeStop2 ) ;
    //ZE( sCountT , timeStop2 ) ;
    //ZE( countT  , timeStop1 ) ;
    //U::SPEED THIS UP BEFORE USING
    //U::MOVE THIS TO key_o so does not slow down quit
    etThread.strokeF( tinP , tPrefix+T("done 2")+tSuffix ) ;
    
    THREADmODE1rESTORE
    }
        DEL( ppBaton_psttvJoy[ 1 ] ) ;
        DEL( ppBaton_psttvJoy[ 0 ] ) ;
        DEL( pBaton_psttvWheel ) ;
        DEL( pBaton_ppsttvbToolState ) ;
        etThread( tinP , pStkClone        ) ;
        etThread( tinP , pStkActionMemory ) ;
        }
            pBatonTree->ungrabF( tinP ) ;
            }
                etThread.strokeF( tinP , tPrefix+T("done 3")+tSuffix ) ;
                writeStateF( tinP , etThread , tree ) ;
                etThread.strokeF( tinP , tPrefix+T("saving the state of your knowledge tree")+tSuffix ) ;
            {
            else
            if( !bStateHasChanged ) etThread.strokeF( tinP , tf ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    
            //}
            //    etThread.delF( tinP , psttfn ) ;
            //    QUITR
            //    etThread.boxPutGenerationF( tinP , psttfn , T("///ideafarm/ephemeral/domains/com/ideafarm/data/out") , 0x1000 , tNote , tNote.csF( tinP ) ) ; ___( psttfn ) ;
            //    QUITOZ
            //    ZE( strokeS* , psttfn ) ;
            //
            //    ;
            //
            //        TT(timeFlush1,timeFlush2)
            //        T(": console fired; flush beginning at ")+
            //        TF1(etThread.diskIdF(tinP))+
            //        T("Subject: ")+
            //
            //    TN( tNote , "" ) ; tNote =
            //    etThread.osTimeNowF( tinP , timeFlush1 , timeFlush2 ) ;
            //    ZE( sCountT , timeFlush2 ) ;
            //    ZE( countT  , timeFlush1 ) ;
            //{
            //U::SPEED THIS UP BEFORE USING
            //U::MOVE THIS TO key_o so does not slow down quit
    
            sgnDone_tmGiveSignF.waitF( tinP ) ;
            }
                etThread( tinP , psKE3Features ) ;
                etThread( tinP , psKE2Features ) ;
                etThread( tinP , psKEFeatures ) ;
        
                }
                    //key_oF( tinP , etThread , win , 1 ) ;
                    win.fireAnimatorIfF( tinP ) ;
                    sadam.flags |= flSADAM_SUPPRESSaNIMATION ;
                    THREADmODE2rESTORE
                    }
                        }
                            ++ s ; etThread.osSleepF( tinP , TUCK * 0x20 ) ;
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
    
                        }
                            sadam.flags &= ~( F(flSADAM_SUPPRESSaNIMATION) ) ;
                            }
                                etThread.winPostMessageAfterNapF( tinP , TOCK , win , idwm_BECOMEaCTIVE ) ;
                                ((thirdC&)etThread).winShowWindowF( tinP , win , idcWINsHOW_SHOW ) ;
                                bShowWhenFresh = 0 ;
                            {
                            if( bShowWhenFresh )
    
                            }
                                bToolTest = 1 ;
                                bToolTestHire = 0 ;
                            {
                            if( bToolTestHire )
                
                            etThread.delF( tinP , psttTalk ) ;
    
                            win.baton.ungrabF( tinP ) ;

                            //if( bFind ) tinP.pc Utility[ 0 ] -- ; //U::
                            etThread.strokeF( tinP , psttTalk ) ;
                            //if( bFind ) tinP.pc Utility[ 0 ] ++ ; //U::

                            }
                                bEntry = bFind = 0 ;
                                win.purgeCallBackScratchF( tinP ) ;
                                etThread.strokeF( tinP , T("\f") ) ;
                            {
                            if( bTestingTools && !bToolTest && !bToolTestHire )

                            tGuideMemory = T("") ;
                            win.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            //etThread.strokeF( tinP , tStutter ) ;
                            
                            //while( cTries -- ) tStutter += T(psttTalk) ;
                            //countT cTries = 8 ;
                            //TN( tStutter , "" ) ;

                            }
                                etThread.delF( tinP , psttr ) ;
                                etThread.strFuseF( tinP , psttTalk , psttr ) ;//U::ELIMINATE psttr
            
                                etThread.strFuseF( tinP , psttr , tn+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME) ) ;

                                }
                                    etThread.strFuseF( tinP , psttr , tn+S3((measure04T)(2+cColsBody),scOld_mmFRAMEcELLS,1.0)+sttw+tb+ta_v+S2(0,scOld_POPfRAME)+S2(3,scOld_cPUSHoFFfRAME)+T("\r\n")+S2(0,scOld_POPoFFfRAME) ) ;
                                    vTextC ta_v( tinP , ppsttvbToolState[ idTool - ifcIDtYPEtOOL_begin - 1 ] , cColsBody , pBaton_ppsttvbToolState ) ;
                                    countT cColsBody = 0x3e ; //SAME VALUE AS FOR JOYSTICK SO ICON IS SAME SIZE
                                    if( !sttw ) sttw = S1C(' ') ;
                                    strokeS sttw = strokeS::strokeIF( tinP , idTool ) ;
                                    countT idTool = ifcIDtYPEtOOL_MOUSEpOSITION ;
                                {
                                /*B2*/
            
                                }
                                    }
                                        etThread.strFuseF( tinP , psttr , tn+S3((measure04T)(2+cColsBody),scOld_mmFRAMEcELLS,1.0)+sttw+tb+ta_v+S2(0,scOld_POPfRAME)+S2(3,scOld_cPUSHoFFfRAME)+T("\r\n")+S2(0,scOld_POPoFFfRAME) ) ;
                                        vTextC ta_v( tinP , ppsttvbToolState[ idTool - ifcIDtYPEtOOL_begin - 1 ] , cColsBody , pBaton_ppsttvbToolState ) ;
                                        countT cColsBody = 0x3e ;
                                        if( !sttw ) sttw = S1C(' ') ;
                                        strokeS sttw = strokeS::strokeIF( tinP , idTool ) ;
                                    {
                                    for( countT idTool = ifcIDtYPEtOOL_JOY1pOSITION ; idTool <= ifcIDtYPEtOOL_JOY2pOSITION ; idTool ++ )
                                {
                                /*B1*/
            
                                etThread.strFuseF( tinP , psttr , tn+S2(1,scOld_cPUSHoFFfRAME)+S3(1.0,scOld_mmFRAMEtO,(measure04T)MAXmEASUREt)+S2(0,scOld_POPoFFfRAME) ) ;

                                if( cDone % cColsRpt ) etThread.strFuseF( tinP , psttr , tn+S2(2,scOld_cPUSHoFFfRAME)+T("\r\n")+S2(0,scOld_POPoFFfRAME) ) ;
                                //if( cDone % cColsRpt ) etThread.strFuseF( tinP , psttr , tn+S3(0.0,scOld_mmMOVEtO,1.0)+S3(0.0,scOld_mmMOVEpEL,1.0)+S2(0,scOld_MOVEpADuP)+S2(1,scOld_cPUSHoFFfRAME)+S3(0.0,scOld_mmMOVEtO,(measure04T)MAXmEASUREt)+S2(0,scOld_POPoFFfRAME) ) ;
                                }
                                    if( !( ( ++ cDone ) % cColsRpt ) ) etThread.strFuseF( tinP , psttr , tcrc ) ;
            
                                    etThread.strFuseF( tinP , psttr , tn+S3(9.0,scOld_mmFRAMEcELLS,1.0)+sttw+ta_v+S2(0,scOld_POPfRAME)+S3(1.0,scOld_mmMOVE,0.0)+S2(0,scOld_MOVEpADrIGHT) ) ;
                                    vTextC ta_v( tinP , ppsttvbToolState[ idTool - ifcIDtYPEtOOL_begin - 1 ] , 8 , pBaton_ppsttvbToolState ) ;
                                    if( !sttw ) sttw = S1C(' ') ;
                                    strokeS sttw = strokeS::strokeIF( tinP , idTool ) ;
            
                                    }
                                        case ifcIDtYPEtOOL_x2End        : { continue ; }
                                        case ifcIDtYPEtOOL_x7End        :
                                        case ifcIDtYPEtOOL_x7Begin      :
                                        case ifcIDtYPEtOOL_x2Begin      :
                                        case ifcIDtYPEtOOL_CONTROLeND   :
                                        case ifcIDtYPEtOOL_CONTROLbEGIN :
                                        case ifcIDtYPEtOOL_JOY2pOSITION :
                                        case ifcIDtYPEtOOL_JOY1pOSITION :
                                        case ifcIDtYPEtOOL_MOUSEpOSITION :
                                    {
                                    switch( idTool ) /*A*/
                                {
                                for( countT idTool = ifcIDtYPEtOOL_begin + 1 ; idTool < ifcIDtYPEtOOL_end ; idTool ++ )
                                ZE( countT , cDone ) ;
            
                                etThread.strFuseF( tinP , psttr , tn+S3((measure04T)cColsRpt,scOld_mmFRAMEcELLS,(measure04T)cRowsRpt) ) ; //FRAME: CELL
            
                                etThread.strFuseF( tinP , psttr , tn+S2(1,scOld_cPUSHoFFfRAME)+S3(1.0,scOld_mmFRAMEtO,1.0)+S2(0,scOld_POPoFFfRAME) ) ; // FRAME: BRANCH CLIENT AREA
            
                                etThread.strMakeF( tinP , psttr , 0 , 0x10 * ( ifcIDtYPEtOOL_end - ifcIDtYPEtOOL_begin - 1 ) ) ; ___( psttr ) ;
                                ZE( strokeS* , psttr ) ;
            
                                for( countT ii = 1 ; ii <= cColsRpt ; ii ++ ) tcrc += tn+S3(-1.0,scOld_mmMOVEpEL,0.0)+S2(0,scOld_MOVEpADlEFT) ;
                                TN( tcrc , "" ) ; tcrc = tn+S3(-(measure04T)cColsRpt,scOld_mmMOVEtO,1.0)+S3(0.0,scOld_mmMOVEpEL,1.0)+S2(0,scOld_MOVEpADuP) ;
                                TN( tn  , "" ) ;
            
                                countT cRowsRpt = 1 +/*B*/3 + ( ifcIDtYPEtOOL_end - ifcIDtYPEtOOL_begin - 1 - /*A*/9 - 1 ) / cColsRpt ;
                                countT cColsRpt = 8 ;
                            {
                            if( bToolTest || bToolTestHire )
    
                            }
                                case ifcIDtYPEdISPLAY_HOLLYWOOD : { tHollywoodF( tinP , etThread , psttTalk , tree , drawerHollywood ) ; break ; }
                                case ifcIDtYPEdISPLAY_HUGE      : { tHugeF(      tinP , etThread , psttTalk , tree , drawerHuge      ) ; break ; }
                            {
                            switch( idTypeDisplay )
                            etThread.strFuseF( tinP , psttTalk , t3 ) ;
                            }
                                }
                                    if( bOutOk     ) { etThread.strFuseF( tinP , psttTalk , taOutArrow   ) ; ___( psttTalk ) ; }
                                    if( bInOk      ) { etThread.strFuseF( tinP , psttTalk , taInArrow    ) ; ___( psttTalk ) ; }
                                    }
                                        etThread.strFuseF( tinP , psttTalk , taHome  ) ; ___( psttTalk ) ;
                                        etThread.strFuseF( tinP , psttTalk , taRightArrow  ) ; ___( psttTalk ) ;
                                    {
                                    if( bRightOk   )
                                    }
                                        etThread.strFuseF( tinP , psttTalk , taLeftArrow  ) ; ___( psttTalk ) ;
                                        etThread.strFuseF( tinP , psttTalk , taEnd  ) ; ___( psttTalk ) ;
                                    {
                                    if( bLeftOk    )
                                    if( bUpOk      ) { etThread.strFuseF( tinP , psttTalk , taUpArrow    ) ; ___( psttTalk ) ; }
                                    if( bDownOk    ) { etThread.strFuseF( tinP , psttTalk , taDownArrow  ) ; ___( psttTalk ) ; }
                                    if( *pStkClone ) { etThread.strFuseF( tinP , psttTalk , ta_g         ) ; ___( psttTalk ) ; }
                                    if( *pStkClone ) { etThread.strFuseF( tinP , psttTalk , ta_minus     ) ; ___( psttTalk ) ; }
                                    if( !bEmpty    ) { etThread.strFuseF( tinP , psttTalk , ta_plus      ) ; ___( psttTalk ) ; }
                                    if( !bEmpty    ) { etThread.strFuseF( tinP , psttTalk , ta_p         ) ; ___( psttTalk ) ; }
                                {
                                else
                                }
                                    }
                                        if( pStkFind->upF( tinP , 1 ) ) { etThread.strFuseF( tinP , psttTalk , taUpArrow ) ; ___( psttTalk ) ; }
                                        if( pStkFind->downF( tinP , 1 ) ) { etThread.strFuseF( tinP , psttTalk , taDownArrow  ) ; ___( psttTalk ) ; }
                                    {
                                    if( *pStkFind )
                                {
                                else if( bFind )
                                }
                                    }
                                        }
                                            etThread.strFuseF( tinP , psttTalk , taRightArrow ) ; ___( psttTalk ) ;
                                            etThread.strFuseF( tinP , psttTalk , taLeftArrow  ) ; ___( psttTalk ) ;
                                        {
                                        if( bDownOk )
                                        if( !bEmpty ) { etThread.strFuseF( tinP , psttTalk , taUpArrow    ) ; ___( psttTalk ) ; }
                                        if( bDownOk ) { etThread.strFuseF( tinP , psttTalk , taDownArrow  ) ; ___( psttTalk ) ; }
                                    {
                                    if( bHaveStrokes )
                                {
                                else if( bEntry )
                                }
                                    }
                                        etThread.strFuseF( tinP , psttTalk , taRightArrow ) ; ___( psttTalk ) ;
                                        etThread.strFuseF( tinP , psttTalk , taLeftArrow  ) ; ___( psttTalk ) ;
                                    {
                                    if( bDownOk )
                                    etThread.strFuseF( tinP , psttTalk , taUpArrow    ) ; ___( psttTalk ) ;
                                {
                                if( bGraft ) //U::BUG: IF bGraft THEN NO BACKTAB DEFAULT IS DISPLAYED
                                pBatonTree->ungrabF( tinP ) ;
                                if( bStateHasChanged ) etThread.strFuseF( tinP , psttTalk , ta_z ) ;
                                pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    
                                etThread.strFuseF( tinP , psttTalk , t2 ) ;
                                etThread.strFuseF( tinP , psttTalk , taKeyEater3 ) ;
                                etThread.strFuseF( tinP , psttTalk , taKeyEater2 ) ;
                                etThread.strFuseF( tinP , psttTalk , taKeyEater ) ;
                            {
                            else
                            if( bToolTest || bToolTestHire ) etThread.strFuseF( tinP , psttTalk , t2toolTest ) ;
    
                            etThread.strMakeF( tinP , psttTalk , t1 , 0x10000 ) ; ___( psttTalk ) ;
                            ZE( strokeS* , psttTalk ) ;

                            }
                                etThread.osTimeNowF( tinP , timeSessionStart1 , timeSessionStart2 ) ;
                                timeSessionStart2 = timeSessionStart1 = 0 ;
                                ++ idSession ;
                                bInSession = 1 ;
                            {
                            if( !bInSession )
                        
                            pBatonTree->ungrabF( tinP ) ;
                            tree.ungrabF( tinP ) ;
                            }
                                if( pData && pData->psttb && pData->psttb->idAdam ) bHaveStrokes = 1 ;
                                branchDataOldS* pData = *pTree ;
                            {
                            bHaveStrokes = 0 ;
                            boolT bEmpty = tree.bEmptyF( tinP ) ;
                            bOutOk   = tree.outF(   tinP , 1 ) ;
                            bInOk    = tree.inF(    tinP , 1 ) ;
                            bRightOk = tree.rightF( tinP , 1 ) ;
                            bLeftOk  = tree.leftF(  tinP , 1 ) ;
                            bUpOk    = tree.upF(    tinP , 1 ) ;
                            bDownOk  = tree.downF(  tinP , 1 ) ;
                            tree.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                
                            }
                                etThread.delF( tinP , psttKEB ) ;
            
                                taKeyEater3 = T(" ")+SADAM(psFeatures) ;
                                etThread( tinP , psFeature ) ;
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << psttKEB ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
                                {
                                etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
                                ZE( soulC* , psFeature ) ;
                            
                                psFeatures->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_byteT , *psKE3Features , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                                etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
                                ZE( soulC* , psFeatures ) ;
                    
                                etThread.strFuseF( tinP , psttKEB , S2(0,scOld_POPcOLOR) ) ;
                                etThread.strFuseF( tinP , psttKEB , tSay ) ;
                                etThread.strMakeF( tinP , psttKEB , S2(0x00ffff,scOld_cPUSHcOLOR) , 0x100 ) ; ___( psttKEB ) ;
                                ZE( strokeS* , psttKEB ) ;
    
                                if( pTxtFind->csF( tinP ) ) tSay += T(": \"")+*pTxtFind+T("\"") ;
                                TN( tSay , "find" ) ;
                            {
                            TN( taKeyEater3 , "" ) ;
                
                            }
                                etThread.delF( tinP , psttKEB ) ;
            
                                taKeyEater2 = T(" ")+SADAM(psFeatures) ;
                                etThread( tinP , psFeature ) ;
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << psttKEB ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
                                {
                                etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
                                ZE( soulC* , psFeature ) ;
                            
                                psFeatures->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_byteT , *psKE2Features , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                                etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
                                ZE( soulC* , psFeatures ) ;
                    
                                etThread.strFuseF( tinP , psttKEB , S2(0,scOld_POPcOLOR) ) ;
                                etThread.strFuseF( tinP , psttKEB , T("entry") ) ;
                                etThread.strMakeF( tinP , psttKEB , S2(0x00ffff,scOld_cPUSHcOLOR) , 0x100 ) ; ___( psttKEB ) ;
                                ZE( strokeS* , psttKEB ) ;
                            {
                            TN( taKeyEater2 , "" ) ;
                
                            }
                                etThread.delF( tinP , psttKEB ) ;
            
                                taKeyEater = T(" ")+SADAM(psFeatures) ;
                                etThread( tinP , psFeature ) ;
                                }
                                    psFeature->removeAllF( tinP ) ;
                                    *psFeatures << *psFeature ;
                                    *psFeature << psttKEB ;
                                    *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
                                {
                                etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
                                ZE( soulC* , psFeature ) ;
                                
                                psFeatures->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_byteT , *psKEFeatures , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                                etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
                                ZE( soulC* , psFeatures ) ;
                    
                                etThread.strFuseF( tinP , psttKEB , S2(0,scOld_POPcOLOR) ) ;
                                etThread.strFuseF( tinP , psttKEB , /*TF1(idCursor)*/T("climb") ) ;
                                etThread.strMakeF( tinP , psttKEB , S2(0x00ffff,scOld_cPUSHcOLOR) , 0x100 ) ; ___( psttKEB ) ;
                                ZE( strokeS* , psttKEB ) ;
                            {
                            TN( taKeyEater , "" ) ;

                            sadam.flags |= flSADAM_SUPPRESSaNIMATION ;
                            cDone ++ ;
                        {
                        if( cNew )
    
                        }
                            if( cNew == setIfEqualsAM( cRequestFresh , 0 , cNew ) ) break ;
                            cNew = cRequestFresh ;
                        {
                        for(;;)
                        ZE( countT , cNew ) ;
                    {
                    while( !ether )
                    sadamC sadam( tinP , ether ) ;
                    windowOldC& win = *thirdC::pWinRootIF() ;
                    incv02AM( cRequestFresh ) ;
                    ZE( countT , cDone ) ;
                    idThreadRefresh = tinP.monitor.idThread ;
                    THREADmODE2oN( flTHREADmODE2_MYoWNrECYCLER )
                {
                THREADmODE2oN( flTHREADmODE2_POOLoLDtURBO )
                //if( IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 == etThread.diskIdF( tinP , T("///c") ) ) etThread.osThreadF( tinP , countTC() , tmScriptF ) ;
                etThread.osThreadF( tinP , countTC() , tmWatchKtDepositoryF , 0 ) ;
                drawerHollywoodS drawerHollywood( tinP , etThread ) ;
                drawerHugeS      drawerHuge( tinP , etThread ) ;
        
                if( IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 != etThread.diskIdF( tinP , T("///c") ) ) ether.ifcHireF( tinP , T("ifcIDaDAM_NEWcONSOLE") , ifcIDaDAM_DATA , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                //U::THE IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 CONDITION IS SO I CAN DEBUG THE CONSOLE WITHOUT FORGETTING TO ENABLE HIRE FOR RELEASE
    
                }
                    etThread( tinP , psFeature ) ;
        
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKE3Features << *psFeature ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKE3Features << *psFeature ;
                        *psFeature << (countT)( flFEATUREsADAMkEYBOARD_ACTIONdOWN ) ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_KEYBOARD ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKE3Features << *psFeature ;
                        *psFeature << (strokeS*)T("saKeyEater3CBF") ;
                        *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_TAB ;
                        *psFeature << (strokeS*)T("saKeyEater3CBF") ;
                        *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                        *psFeature << (strokeS*)T("saKeyEater3CBF") ;
                        *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKE3Features << *psFeature ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_TABpARTICIPANT ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKE3Features << *psFeature ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_ADAM ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKE3Features << *psFeature ;
                        *psFeature << (countT)0x0000ff ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
                    {
        
                    etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
                    ZE( soulC* , psFeature ) ;
        
                    *psKE3Features << (countT)0 ;
                    *psKE3Features << (countT)sc_cADAM ;
                {
                etThread( tinP , psKE3Features , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psKE3Features ) ;
        
                }
                    etThread( tinP , psFeature ) ;
        
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKE2Features << *psFeature ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKE2Features << *psFeature ;
                        *psFeature << (countT)( flFEATUREsADAMkEYBOARD_ACTIONdOWN ) ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_KEYBOARD ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKE2Features << *psFeature ;
                        *psFeature << (strokeS*)T("saKeyEater2CBF") ;
                        *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_TAB ;
                        *psFeature << (strokeS*)T("saKeyEater2CBF") ;
                        *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                        *psFeature << (strokeS*)T("saKeyEater2CBF") ;
                        *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
                    {

                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKEFeatures << *psFeature ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_TABpARTICIPANT ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKE2Features << *psFeature ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_ADAM ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKE2Features << *psFeature ;
                        *psFeature << (countT)0x0000ff ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
                    {
        
                    etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
                    ZE( soulC* , psFeature ) ;
        
                    *psKE2Features << (countT)0 ;
                    *psKE2Features << (countT)sc_cADAM ;
                {
                etThread( tinP , psKE2Features , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psKE2Features ) ;
        
                }
                    etThread( tinP , psFeature ) ;
        
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKEFeatures << *psFeature ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKEFeatures << *psFeature ;
                        *psFeature << (countT)( flFEATUREsADAMkEYBOARD_ACTIONdOWN ) ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_KEYBOARD ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKEFeatures << *psFeature ;
                        *psFeature << (strokeS*)T("saKeyEaterCBF") ;
                        *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_ANIMATE ; //BECAUSE I WANT TO GET RENDERoFF RENDERoN CALLS
                        *psFeature << (strokeS*)T("saKeyEaterCBF") ;
                        *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                        *psFeature << (strokeS*)T("saKeyEaterCBF") ;
                        *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
                    {

                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKEFeatures << *psFeature ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_TABpARTICIPANT ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKEFeatures << *psFeature ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_ADAM ;
                    {
                
                    }
                        psFeature->removeAllF( tinP ) ;
                        *psKEFeatures << *psFeature ;
                        *psFeature << (countT)0x0000ff ;
                        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
                    {
        
                    etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
                    ZE( soulC* , psFeature ) ;
        
                    *psKEFeatures << (countT)0 ;
                    *psKEFeatures << (countT)sc_cADAM ;
                {
                etThread( tinP , psKEFeatures , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psKEFeatures ) ;
        
                ;
        
                        S2(0,scOld_POPfRAME)
                        //ta_guide+
                        S3(9.0,scOld_mmMOVEpEL,-9.0)+
                        S2(0,scOld_MOVEdOWNrIGHTfORaDAMfRAME)+
                        S3(0.0,scOld_mmFRAMEpELtO,0.0)+
                        S2(0,scOld_cOVERRIDEnEXTsTROKE)+
                        S2(0,scOld_POPfRAMEdETACH)+
                        S3(-1.0,scOld_mmMOVEpEL,1.0)+
                        S3(1.0/128.0,scOld_mmMOVEtO,23.0/24.0)+
                        S2(0,scOld_PUSHoVERRIDEcOLrOW)+
                        S3(1.0,scOld_mmMOVEpEL,-1.0)+
                        S3(0.0,scOld_mmMOVEtO,1.0)+
                        S2(0,scOld_FRAMEdETACH)+
        
                        S3(0.0,scOld_mmFRAMEpELtO,0.0)+
                        S2(0,scOld_cOVERRIDEnEXTsTROKE)+
                        S3(1.0,scOld_mmMOVEtO,1.0)+
                        S2(0,scOld_POPfRAME)+
                        S2(0,scOld_PUSHoVERRIDEcOLrOW)+
                        S3(0.0,scOld_mmMOVEpEL,6.0)+
                        S2(0,scOld_WRAPoFF)+
                        tcr+
        
                TN( t3 , "" ) ; t3 =
        
                ;
        
                        ta_o
                        ta_k+
                        ta_t+
        
                TN( t2toolTest , "" ) ; t2toolTest =
        
                ;
        
                        ta_m
                        ta_h+
                        ta_s+
                        ta_w+
                        ta_o+
                        ta_k+
                        ta_t+
        
                TN( t2 , "" ) ; t2 =
        
                ;
        
                        S2(0,scOld_POPcOLOR)
                        taLogo+
                        S2(0x00ffff,scOld_cPUSHcOLOR)+
                        ta_wheel+
                        tb+
                        ta_joy2+
                        tb+
                        ta_joy1+
                        S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)+
                        S2(0,scOld_WRAPoN)+
                        S3(1.0/256.0,scOld_mmFRAMEtO,1.0/32.0)+
                        S3(1.0,scOld_mmFRAMEtO,1.0)+ //SUPPORTS DISPLAY SHRINK (FOR DEBUGGING); IN PRODUCTION, MUST BE 1.0 1.0
                        //S3(0.8,scOld_mmFRAMEtO,0.8)+ //SUPPORTS DISPLAY SHRINK (FOR DEBUGGING); IN PRODUCTION, MUST BE 1.0 1.0
                        tf+
        
                TN( t1 , "" ) ; t1 =

                vTextC ta_joy2( tinP , psttzJoy2 , 4 , ppBaton_psttvJoy[ 1 ] ) ;
                strokeS* psttzJoy2 = ppsttvJoy[ 1 ] ;
        
                vTextC ta_joy1( tinP , psttzJoy1 , 4 , ppBaton_psttvJoy[ 0 ] ) ;
                strokeS* psttzJoy1 = ppsttvJoy[ 0 ] ;
        
                vTextC ta_wheel( tinP , psttzWheel , 1 , pBaton_psttvWheel ) ;
                strokeS* psttzWheel = psttvWheel ;
        
                TN( tcr , "\r\n" ) ;
                TN( tn , "" ) ;
                TN( tb , " " ) ;
            {
        
            etThread.osThreadF( tinP , countTC() , tmGiveSignF , &sgnDone_tmGiveSignF ) ;
            signC sgnDone_tmGiveSignF( tinP , TAG( TAGiDnULL ) ) ;
    
            readStateF( tinP , etThread , tree ) ;
            etThread.strokeF( tinP , tPrefix+T("reading the state of your knowledge tree")+tSuffix ) ;
    
            pBatonTree = &batonTree ;
            batonC batonTree( tinP , TAG( TAGiDnULL ) ) ;
            pTree = &tree ;
            treeOldC tree( tinP , TAG( TAGiDnULL ) , idCursor ) ;
    
            pStkFind = &stFind ;
            stackC stFind( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO |  flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY | flSTACKc_BLOB , sizeof( handleC ) ) ;
    
            pTxtToolsMemory = &tToolsMemory ;
            pTxtTools       = &tTools ;
            pTxtGuideMemory = &tGuideMemory ;
            pTxtGuide       = &tGuide ;
            TN( tToolsMemory , "" ) ; //MUST BE NULL LENGTH FOR CODE TO WORK
            TN( tTools       , "" ) ;
            TN( tGuideMemory , "" ) ; //MUST BE NULL LENGTH FOR CODE TO WORK
            TN( tGuide       , "explore with mouse and keys!" ) ;
        {
        if( pStkClone && pStkActionMemory )
        etThread( tinP , pStkActionMemory , TAG( TAGiDnULL ) , flSTACKc_XRAY , ifcSTACKtYPE_countT ) ;
        etThread( tinP , pStkClone        , TAG( TAGiDnULL ) , flSTACKc_XRAY , ifcSTACKtYPE_PTR_soulC ) ;

        ppBaton_psttvJoy[ 1 ]   = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) ) ;
        ppBaton_psttvJoy[ 0 ]   = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) ) ;
        pBaton_psttvWheel       = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) ) ;
        pBaton_ppsttvbToolState = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) ) ;
    
        //}
        //    ta_guide = T("")+SADAM(psFeatures) ;
        //    etThread( tinP , psFeature ) ;
        //
        //    }
        //        psFeature->removeAllF( tinP ) ;
        //        *psFeatures << *psFeature ;
        //        *psFeature << (countT)ifcIDiNTERCOM_GUIDE ;
        //        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
        //    {
        //
        //    }
        //        psFeature->removeAllF( tinP ) ;
        //        *psFeatures << *psFeature ;
        //        *psFeature << (strokeS*)T("saOLD_guideCBF") ;
        //        *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
        //        *psFeature << (strokeS*)T("saOLD_guideCBF") ;
        //        *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
        //        *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
        //    {
        //
        //    etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
        //    ZE( soulC* , psFeature ) ;
        //
        //    *psFeatures << (countT)0 ;
        //    *psFeatures << (countT)sc_cADAM ;
        //    etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
        //    ZE( soulC* , psFeatures ) ;
        //{
        //TN( ta_guide , "" ) ;
        
        }
            ta_s = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_KEY_s ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_sCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_sCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_sCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S2('s',sc_cALPHABET1)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_s , "" ) ;
        
        }
            ta_p = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_KEY_p ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_pCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_pCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_pCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S2('p',sc_cALPHABET1)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_p , "" ) ;
        
        }
            ta_h = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_KEY_h ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
    
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_hCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_hCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_hCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S2('h',sc_cALPHABET1)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_h , "" ) ;
        
        }
            ta_g = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_KEY_g ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
    
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_gCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_gCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_gCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S2('g',sc_cALPHABET1)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_g , "" ) ;
        
        }
            ta_minus = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_MINUS ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
    
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_minusCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_minusCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_minusCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S2('-',sc_cALPHABET1)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_minus , "" ) ;
        
        }
            ta_plus = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_PLUS ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
    
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_plusCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_plusCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_plusCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S2('+',sc_cALPHABET1)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_plus , "" ) ;
        
        }
            ta_w = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_KEY_w ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
    
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_wCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_wCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_wCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S2('w',sc_cALPHABET1)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_w , "" ) ;
        
        }
            taOutArrow = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_OUTaRROW ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOutArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOutArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOutArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S3(0.0,scOld_mmMOVEpELtO,0.0)+
                    S2(0,scOld_cOVERRIDEnEXTsTROKE)+
                    S2(0,scOld_POPfRAME)+
                    S2(0,scOld_PUSHoVERRIDEcOLrOW)+
                    T(" ")+
                    S2(0,scOld_POPfRAMEdETACH)+
                    S3(0.0,scOld_mmMOVEtO,0.0)+
                    S3(1.0,scOld_mmLINEeNDtO,0.5)+
                    S3(0.5,scOld_mmLINEtO,1.0)+
                    S3(0.0,scOld_mmMOVEtO,0.5)+
                    S3(0.5,scOld_mmLINEeNDtO,1.0)+
                    S3(0.5,scOld_mmMOVEtO,0.0)+
                    S2(0,scOld_FRAMEdETACH)+
                    S3(3.0,scOld_mmFRAMEtO,1.0)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( taOutArrow , "" ) ;
        
        }
            taInArrow = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_INaRROW ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saInArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saInArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saInArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S3(0.0,scOld_mmMOVEpELtO,0.0)+
                    S2(0,scOld_cOVERRIDEnEXTsTROKE)+
                    S2(0,scOld_POPfRAME)+
                    S2(0,scOld_PUSHoVERRIDEcOLrOW)+
                    T(" ")+
                    S2(0,scOld_POPfRAMEdETACH)+
                    S3(0.0,scOld_mmMOVEtO,0.0)+
                    S3(1.0,scOld_mmLINEeNDtO,0.5)+
                    S3(0.5,scOld_mmLINEtO,1.0)+
                    S3(0.0,scOld_mmMOVEtO,0.5)+
                    S3(0.5,scOld_mmLINEeNDtO,1.0)+
                    S3(0.5,scOld_mmMOVEtO,0.0)+
                    S2(0,scOld_FRAMEdETACH)+
                    S3(3.0,scOld_mmFRAMEtO,1.0)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( taInArrow , "" ) ;
        
        }
            taRightArrow = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_RIGHTaRROW ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saRightArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saRightArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saRightArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S3(0.0,scOld_mmMOVEpELtO,0.0)+
                    S2(0,scOld_cOVERRIDEnEXTsTROKE)+
                    S2(0,scOld_POPfRAME)+
                    S2(0,scOld_PUSHoVERRIDEcOLrOW)+
                    T(" ")+
                    S2(0,scOld_POPfRAMEdETACH)+
                    S3(0.0,scOld_mmMOVEtO,0.0)+
                    S3(0.5,scOld_mmLINEeNDtO,1.0)+
                    S3(1.0,scOld_mmLINEtO,0.5)+
                    S3(0.5,scOld_mmMOVEtO,0.0)+
                    S3(1.0,scOld_mmLINEeNDtO,0.5)+
                    S3(0.0,scOld_mmMOVEtO,0.5)+
                    S2(0,scOld_FRAMEdETACH)+
                    S3(3.0,scOld_mmFRAMEtO,1.0)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( taRightArrow , "" ) ;
        
        }
            taEnd = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_END ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saEndCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saEndCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saEndCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    T("end")+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( taEnd , "" ) ;
        
        }
            taHome = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_HOME ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saHomeCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saHomeCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saHomeCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    T("home")+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( taHome , "" ) ;
        
        }
            taLeftArrow = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_LEFTaRROW ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saLeftArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saLeftArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saLeftArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S3(0.0,scOld_mmMOVEpELtO,0.0)+
                    S2(0,scOld_cOVERRIDEnEXTsTROKE)+
                    S2(0,scOld_POPfRAME)+
                    S2(0,scOld_PUSHoVERRIDEcOLrOW)+
                    T(" ")+
                    S2(0,scOld_POPfRAMEdETACH)+
                    S3(0.0,scOld_mmMOVEtO,0.0)+
                    S3(0.5,scOld_mmLINEeNDtO,1.0)+
                    S3(0.0,scOld_mmLINEtO,0.5)+
                    S3(0.5,scOld_mmMOVEtO,0.0)+
                    S3(0.0,scOld_mmLINEeNDtO,0.5)+
                    S3(1.0,scOld_mmMOVEtO,0.5)+
                    S2(0,scOld_FRAMEdETACH)+
                    S3(3.0,scOld_mmFRAMEtO,1.0)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( taLeftArrow , "" ) ;
        
        }
            taUpArrow = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_UPaRROW ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saUpArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saUpArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saUpArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S3(0.0,scOld_mmMOVEpELtO,0.0)+
                    S2(0,scOld_cOVERRIDEnEXTsTROKE)+
                    S2(0,scOld_POPfRAME)+
                    S2(0,scOld_PUSHoVERRIDEcOLrOW)+
                    T(" ")+
                    S2(0,scOld_POPfRAMEdETACH)+
                    S3(0.0,scOld_mmMOVEtO,0.0)+
                    S3(1.0,scOld_mmLINEeNDtO,0.5)+
                    S3(0.5,scOld_mmLINEtO,1.0)+
                    S3(0.0,scOld_mmMOVEtO,0.5)+
                    S3(0.5,scOld_mmLINEeNDtO,1.0)+
                    S3(0.5,scOld_mmMOVEtO,0.0)+
                    S2(0,scOld_FRAMEdETACH)+
                    S3(3.0,scOld_mmFRAMEtO,1.0)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( taUpArrow , "" ) ;
        
        }
            taDownArrow = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_DOWNaRROW ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saDownArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saDownArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saDownArrowCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S3(0.0,scOld_mmMOVEpELtO,0.0)+
                    S2(0,scOld_cOVERRIDEnEXTsTROKE)+
                    S2(0,scOld_POPfRAME)+
                    S2(0,scOld_PUSHoVERRIDEcOLrOW)+
                    T(" ")+
                    S2(0,scOld_POPfRAMEdETACH)+
                    S3(0.0,scOld_mmMOVEtO,0.0)+
                    S3(1.0,scOld_mmLINEeNDtO,0.5)+
                    S3(0.5,scOld_mmLINEtO,0.0)+
                    S3(0.0,scOld_mmMOVEtO,0.5)+
                    S3(0.5,scOld_mmLINEeNDtO,0.0)+
                    S3(0.5,scOld_mmMOVEtO,1.0)+
                    S2(0,scOld_FRAMEdETACH)+
                    S3(3.0,scOld_mmFRAMEtO,1.0)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( taDownArrow , "" ) ;
    
        }
            ta_z = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_KEY_z ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_zCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_zCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_zCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S2('z',sc_cALPHABET1)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_z , "" ) ;
        
        }
            ta_t = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_KEY_t ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)flFEATUREsADAMjOYsTICK_null ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_JOYsTICK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_tCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_HOTkEY ;
                *psFeature << (strokeS*)T("saOLD_tCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_ANIMATE ;
                *psFeature << (strokeS*)T("saOLD_tCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_tCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_tCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_HOTkEY ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    T("utor")+
                    S2(0,scOld_POPsTYLE)+
                    S2('t',sc_cALPHABET1)+
                    S2(flRENDERsTYLE_SCOREuNDER,scOld_cPUSHsTYLE)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_t , "" ) ;
    
        }
            ta_o = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_KEY_o ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_oCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_oCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_oCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S2('o',sc_cALPHABET1)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_o , "" ) ;
    
        }
            ta_k = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_KEY_k ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_kCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_kCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_kCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S2('k',sc_cALPHABET1)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_k , "" ) ;
    
        }
            ta_m = T(" ")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_KEY_m ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_mCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_mCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_mCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)0x0000ff ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_FRAME ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tBody ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
    
                ;
    
                    S2(0,scOld_POPcOLOR)
                    S2('m',sc_cALPHABET1)+
                    S2(0x00ffff,scOld_cPUSHcOLOR)+
                    T("")+
    
                TN( tBody , "" ) ; tBody =
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( ta_m , "" ) ;
    
        }
            taLogo = T("")+SADAM(psFeatures) ;
            etThread( tinP , psFeature ) ;
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)ifcIDiNTERCOM_KEY_i ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_INTERCOM ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (countT)( flFEATUREsADAMmOUSE_ACTIONdOWN | flFEATUREsADAMmOUSE_TOOLbUTTONlEFT ) ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_MOUSE ;
            {
    
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)T("saOLD_iCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_INTERCOM ;
                *psFeature << (strokeS*)T("saOLD_iCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_IFhIT ;
                *psFeature << (strokeS*)T("saOLD_iCBF") ;
                *psFeature << (countT)ifcIDtYPEsADAMcALLbACK_FLYOVER ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_CALLbACK ;
            {
        
            }
                psFeature->removeAllF( tinP ) ;
                *psFeatures << *psFeature ;
                *psFeature << (strokeS*)tLogo ;
                *psFeature << (countT)ifcIDtYPEfEATUREsADAM_BODY ;
            {
        
            etThread( tinP , psFeature , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeature ) ;
        
            *psFeatures << (countT)0 ;
            *psFeatures << (countT)sc_cADAM ;
            etThread( tinP , psFeatures , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psFeatures ) ;
        {
        TN( taLogo , "" ) ;
    
        pTxtFind = &tFind ;
        TN( tFind , "" ) ;
    
        pTxtLogo = &tLogo ;
        ;
    
            S2(0,scOld_POPcOLOR)
            S3(0.0,scOld_mmMOVEpELtO,0.0)+
            S2(0,scOld_cOVERRIDEnEXTsTROKE)+
            S2(0,scOld_POPfRAME)+
            S2(0,scOld_PUSHoVERRIDEcOLrOW)+
            S2(saA1_TRADEmARK,sc_cALPHABET1)+
            S3(2.0,scOld_mmFRAMEtO,0.25)+
            T("IdeaFarm")+
            S2(0x00ffff,scOld_cPUSHcOLOR)+
            T("")+
    
        TN( tLogo , "" ) ; tLogo =
    {
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    
    }
        etThread.delF( tinP , psttfn ) ;
        etThread.boxPutGenerationF( tinP , psttfn , T("///ideafarm/ephemeral/domains/com/ideafarm/data/out") , 0x1000 , tNote , tNote.csF( tinP ) ) ; ___( psttfn ) ;
        ZE( strokeS* , psttfn ) ;
    
        ;
    
            TT(timeStart1,timeStart2)
            T(": console started at ")+
            TF1(etThread.diskIdF(tinP))+
            T("Subject: ")+
    
        TN( tNote , "" ) ; tNote =
    {
    etThread.osTimeNowF( tinP , timeStart1 , timeStart2 ) ;
    ZE( sCountT , timeStart2 ) ;
    ZE( countT  , timeStart1 ) ;
    
    pEtPrime = &etherC::etPrimeIF() ;
    { sadamCBFT f = saKeyEaterCBF ; }
    { sadamCBFT f = saKeyEater3CBF ; }
    { sadamCBFT f = saKeyEater2CBF ; }
    { sadamCBFT f = saOLD_oCBF ; }
    { sadamCBFT f = saOLD_mCBF ; }
    { sadamCBFT f = saOLD_tCBF ; }
    { sadamCBFT f = saDownArrowCBF ; }
    { sadamCBFT f = saUpArrowCBF ; }
    { sadamCBFT f = saEndCBF ; }
    { sadamCBFT f = saHomeCBF ; }
    { sadamCBFT f = saLeftArrowCBF ; }
    { sadamCBFT f = saRightArrowCBF ; }
    { sadamCBFT f = saInArrowCBF ; }
    { sadamCBFT f = saOutArrowCBF ; }
    { sadamCBFT f = saOLD_gCBF ; }
    { sadamCBFT f = saOLD_hCBF ; }
    { sadamCBFT f = saOLD_wCBF ; }
    { sadamCBFT f = saOLD_plusCBF ; }
    { sadamCBFT f = saOLD_minusCBF ; }
    { sadamCBFT f = saOLD_iCBF ; }
    { sadamCBFT f = saOLD_pCBF ; }
    { sadamCBFT f = saOLD_sCBF ; }
    { sadamCBFT f = saOLD_guideCBF ; }
{
THREADmODE2oN( flTHREADmODE2_MYoWNrECYCLER )

pTxtBlank = &tBlank ;
pTxtNull = &tNull ;
TN( tBlank , " " ) ;
TN( tNull , "" ) ;

etThread.strMakeF( tinP , psttzOffUp   , tn+S3(8.0,scOld_mmFRAMEcELLS,1.0)                          +T("        ")                          +S2(0,scOld_POPfRAME) ) ; ___( psttzOffUp   ) ;
etThread.strMakeF( tinP , psttzOffDown , tn+S3(8.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+T("    DOWN")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ; ___( psttzOffDown ) ;
etThread.strMakeF( tinP , psttzOnUp    , tn+S3(8.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+T(" ON"     )+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ; ___( psttzOnUp    ) ;
etThread.strMakeF( tinP , psttzOnDown  , tn+S3(8.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+T(" ON DOWN")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ; ___( psttzOnDown  ) ;
etThread.strMakeF( tinP , psttzAbsent  , tn+S3(8.0,scOld_mmFRAMEcELLS,1.0)+S2(0x0000ff,scOld_cPUSHcOLOR)+T(" ABSENT ")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ; ___( psttzAbsent  ) ;
etThread.strMakeF( tinP , psttzAbsent2 , tn+S3((measure04T)0x3e,scOld_mmFRAMEcELLS,1.0)+S2(0x0000ff,scOld_cPUSHcOLOR)+T("ABSENT")+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ; ___( psttzAbsent  ) ;
TN( tn , "" ) ;

}
    etThread.strFuseF( tinP , psttw , T("")+S2(0,scOld_FRAMEdETACH)+S2(0x0000ff,scOld_cPUSHcOLOR)+S3(1.0,scOld_mmLINEtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEeNDtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmMOVEtO,1.0)+S3(1.0,scOld_mmLINEtO,0.0)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAMEdETACH)/*+S3(16.0,scOld_mmFRAMEcELLS,16.0)+S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)+TF1(pmxP[1])+T(",")+TF1(pmxP[2])+S2(0,scOld_POPfRAME)*/ ) ;
    psttw = (strokeS*)ppsttvJoy[ 1 ] ;
    etThread.strFuseF( tinP , psttw , T("")+S2(0,scOld_FRAMEdETACH)+S2(0x0000ff,scOld_cPUSHcOLOR)+S3(1.0,scOld_mmLINEtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEeNDtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmMOVEtO,1.0)+S3(1.0,scOld_mmLINEtO,0.0)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAMEdETACH)/*+S3(16.0,scOld_mmFRAMEcELLS,16.0)+S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)+TF1(pmxP[1])+T(",")+TF1(pmxP[2])+S2(0,scOld_POPfRAME)*/ ) ;
    strokeS* psttw = (strokeS*)ppsttvJoy[ 0 ] ;
{
SETpREFIXA( ppsttvJoy[ 1 ] )
SETpREFIXA( ppsttvJoy[ 0 ] )
SETpREFIXA( psttvWheel )
SETpREFIXA( psttzMousePosition )
SETpREFIXA( psttzJoy2Position )
SETpREFIXA( psttzJoy1Position )

//if( IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 == etThread.diskIdF( tinP , T("///c") ) ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , 1 ) ;
etThread.strokeF( tinP , tPrefix+T("getting ready to go to work")+tSuffix ) ;
;
    
        S2(0,scOld_POPfRAME)
        T("")+
    
TN( tSuffix , "" ) ; tSuffix =
;
    
        S3(1.0/128.0,scOld_mmFRAMEtO,1.0/16.0)
        tf+
    
TN( tPrefix , "" ) ; tPrefix =
TN( tf , "\f" ) ;

TODO

DONE( tmScriptF )

incv02AM( cRequestFresh ) ;
etherC::etherFireImpersonateMonitorIF( tinP ) ;

}
    }
        ++ s ; etThread.osSleepF( tinP , TUCK * 0x80 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    incv02AM( cRequestFresh ) ;
{
while( cTries -- )
countT cTries = 0x3f ;
//countT cTries = 0x4 ;

}
    ++ s ; etThread.osSleepF( tinP , TOCK * 2 ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{

TASK( tmScriptF )

DONE( tmGiveSignF )
incv02AM( cRequestFresh ) ;
etThread.loafIF( tinP ) ;
TASK( tmGiveSignF )

DONE( tmWatchKtDepositoryF )
THREADmODE2rESTORE
}
    }
        etThread.diskWaitDirF( tinP , hDirChange , ether , tDepository , flWAITdIR_FILEnAME | flWAITdIR_DIRnAME ) ;
    
        etThread.delF( tinP , pstt1m ) ;
        }
            }
                etThread.delF( tinP , psttNameShort ) ;
                }
                    POPUP( tMsg ) ;
    
                    if( bLoaded ) tMsg += T("\r\n\r\nI was able to graft it onto your knowledge tree but was not able to delete it from the depository.") ;
                    TN( tMsg , "" ) ; tMsg = T("I have moved, to your desk, an object named \"")+tReject+T("\".") ;
    
                    }
                        }
                            idDup ++ ;
                            POOPR
                        {
                        else
                        if( !POOP ) break ;
                        tinP.pEtScratch->diskMoveFileOrDirF( tinP , tDesk+tReject , psttc1 ) ;
                        tReject = T("ideafarm.kt.reject.")+(idDup?TF1(idDup)+T("."):T(""))+T(psttNameShort) ;
                    {
                    while( !ether && idDup < 0x100 )
                    TN( tReject , "" ) ;
                    ZE( countT , idDup ) ;
    
                    }
                        pBatonTree->ungrabF( tinP ) ;
                        pTree->upF( tinP ) ;
                        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    if( bWentDown )
                    POOPR
                {
                else
                }
                    incv02AM( cRequestFresh ) ;
                    pBatonTree->ungrabF( tinP ) ;
                    bStateHasChanged = 1 ;
                    bShowWhenFresh = 1 ;
                    pTree->ungrabF( tinP ) ;
                    pTree->rightF( tinP ) ;
                    pTree->upF( tinP ) ;
                    pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( !POOP )
    
                }
                    cFilesIn ++ ;
                    tinP.pEtScratch->boxZapF( tinP , psttc1 , 1 ) ;
                {
                if( !POOP )
                boolT bLoaded = !POOP ;
    
                }
                    pBatonTree->ungrabF( tinP ) ;
                    pTree->ungrabF( tinP ) ;
                    THREADmODE1rESTORE
                    readF( tinP , *tinP.pEtScratch , *pTree , psttc1 , countTC() ) ;
                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                    bWentDown = pTree->downF( tinP ) ;
                    pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( !POOP )
                ZE( boolT , bWentDown ) ;
    
                __( 1 != tinP.pEtScratch->strIdF( tinP , T("ideafarm.kt.") , psttNameShort ) ) ;
                __( psttNameShort && !psttNameShort->idAdam ) ;
                __Z( psttNameShort ) ;
                __( bDir ) ;
        
                tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttNameShort ) ;
                }
                    }
                        etThread.strMakeF( tinP , psttNameShort , T("rejected") ) ; ___( psttNameShort ) ;
                        etThread.delF( tinP , psttNameShort ) ;
                    {
                    if( !psttNameShort || !psttNameShort->idAdam )
    
                    tinP.pEtScratch->strWordF( tinP , psttNameShort , psttc1 , sttq , S1C('/') , - 2 ) ; ___( psttNameShort ) ;
                    etThread.delF( tinP , psttNameShort ) ;
                {
                if( bDir )
                boolT bDir = psttNameShort && !psttNameShort->idAdam ;
                tinP.pEtScratch->strWordF( tinP , psttNameShort , psttc1 , sttq , S1C('/') , - 1 ) ; ___( psttNameShort ) ;
                strokeS sttq ;
                ZE( strokeS* , psttNameShort ) ;
        
                SCOOPS
            {
            IFsCRATCH
        {
        FORsTRINGSiN1( pstt1m )
        etThread.boxMenuF( tinP , soul , tDepository+T("*") , 0 , 1 ) ; ___( pstt1m ) ;
        ZE( strokeS* , pstt1m ) ;
    {
    while( !ether && !etThread )
    handleC hDirChange( tinP , TAG( TAGiDnULL ) ) ;
    
    etThread.diskMakeDirIfNeededF( tinP , tDepository ) ;
    }
        tDepository = tDesk+tDepositoryShort+T("/") ;
        etThread.delF( tinP , psttm ) ;
        tDesk = T(psttm) ;
        etThread.diskMapFileNameF( tinP , psttm , T("///desk/") ) ; ___( psttm ) ;
        ZE( strokeS* , psttm ) ;
    {
    TN( tDepository , "" ) ;
    TN( tDesk , "" ) ;
    TN( tDepositoryShort , "IdeaFarm " "(tm) KT Depository") ;
{
THREADmODE2oN( flTHREADmODE2_MYoWNrECYCLER ) //U:: TO CATCH A BUG
TASK( tmWatchKtDepositoryF )

}
    QUITR
    }
        }
            }
                break ;
                POOPR
            {
            if( POOP )

            tinP.pEtScratch->boxZapF( tinP , TsTATEfILE+T(".")+TF3(idMin++,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObIGITvALUES,8) ) ;
        {
        else while( idMin < idMinKeep )
        if( POOP ) POOPR

        countT idMinKeep = idMax > CgENSsTATE ? idMax - CgENSsTATE + 1 : 1 ;
        tinP.pEtScratch->boxMenuIdRangeF( tinP , idMin , idMax , TsTATEfILE+T(".*") , TUCK * CgENSsTATE ) ;
        ZE( countT , idMax ) ;
        ZE( countT , idMin ) ;
        SCOOPS
    {
    IFsCRATCH

    pBatonTree->ungrabF( tinP ) ;
    }
        bStateHasChanged = 0 ;
        writeF( tinP , etherP , TsTATEfILE , treeP , 1 ) ;
    {
    if( bStateHasChanged )
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    QUITOZ
{
voidT writeStateF( tinS& tinP , etherC& etherP , treeOldC& treeP )

}
    _OUT_
    pBatonTree->ungrabF( tinP ) ;
    if( bWholeP ) etherP( tinP , pStkDirections ) ;
    etherP( tinP , psFile ) ;
    }
        }
            _OUT_
            etherP.delF( tinP , psttf ) ;
            if( !bWholeP ) { POPUP( T("The current branch has been written to file\r\n\r\n    ")+T(psttf)+T("\r\n\r\n(KT file names must begin with \"ideafarm.kt.\".)") ) ; }
            tinP.pEtScratch->boxPutGenerationF( tinP , psttf , psttP , TUCK * 0x10 , *psFile , psFile->cbF( tinP ) ) ;
            ZE( strokeS* , psttf ) ;
            SCOOPS
            _INoLD_
        {
        IFsCRATCH
    
        }
            _OUT_
            treeP.writeF( tinP , *psFile ) ;//U::ENHANCE TO STORE ALL CURSORING INFORMATION SO CURSORS WILL PERSIST
            _INoLD_
        {

        }
            _OUT_
            }
                *psFile << idBro ;
                *pStkDirections >> idBro ;
                ZE( countT , idBro ) ;
            {
            if( bWholeP ) while( *pStkDirections )
            *psFile << ( bWholeP ? (countT)*pStkDirections : (countT)0 ) ;
            _INoLD_
        {

        }
            _OUT_
            }
                treeP.downF( tinP ) ;
                *pStkDirections << idBro ;
                while( treeP.leftF( tinP ) ) idBro ++ ;
                countT idBro = 1 ;
            {
            if( bWholeP ) while( treeP.downF( tinP , 1 ) )
            _INoLD_
        {

        *psFile << ( bWholeP ? idTypeDisplay : (countT)0 ) ;
        *psFile << ( bWholeP ? idCursor      : (countT)0 ) ;
    {
    if( psFile && ( !bWholeP || pStkDirections ) )
    if( bWholeP ) etherP( tinP , pStkDirections , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_countT ) ;
    etherP( tinP , psFile , TAG( TAGiDnULL ) ) ;
    ZE( stackC* , pStkDirections ) ;
    ZE( soulC* , psFile ) ;
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    _INoLD_
{
voidT writeF( tinS& tinP , etherC& etherP , const strokeS* const psttP , treeOldC& treeP , const boolT bWholeP )

}
    QUITR
    pBatonTree->ungrabF( tinP ) ;
    }
        }
            treeP.ungrabF( tinP ) ;
            treeP.rightF( tinP ) ;
            treeP.upF( tinP ) ;
            treeP.walkF( tinP , hWalk , etherP , countTC() , treeOldCBF , countTC() , flTREEwALK_REVERSE ) ; //CURSOR THE ELDEST KID OF EACH BRANCH
            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_TREEwALK ) ;
            while( treeP.downF( tinP ) ) ;
            
            etherP.delF( tinP , pstt1l ) ;
            }
                etherP.delF( tinP , psttb ) ;
                treeP.newKidF( tinP , psttb ) ;
                etherP.strTrimF( tinP , psttb , psttc1 , T(TbLACKnEWlINE) ) ; ___( psttb ) ;
                ZE( strokeS* , psttb ) ;
                    
                }
                    idLevel -- ;
                    treeP.downF( tinP ) ;
                {
                else while( idLevelRequested < idLevel )
                }
                    idLevel ++ ;
                    treeP.upF( tinP ) ;
                {
                if( idLevelRequested == idLevel + 1 )

                if( POOP ) break ;
                __( idLevel + 1 < idLevelRequested ) ; //INDENTATION IS NOT ALLLOWED TO INCREASE BY MORE THAN 1 OVER PRIOR INPUT LINE
                __Z( idLevelRequested ) ; //INPUT LINE DOES NOT CONTAIN NONBLANKS
                countT idLevelRequested = idBlanks != 1 ? 1 : idf ;
                    
                countT idBlanks = etherP.strIdAnyF( tinP , idf , sttq , sttb , psttc1 ) ;
                countT idf = 1 ;
            {
            FORsTRINGSiN1( pstt1l )
            treeP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            countT idLevel = 1 ;
            strokeS sttb( ' ' ) ;
            etherP.strWordsOldF( tinP , pstt1l , tGuide , sttq , T("\r\n") ) ; ___( pstt1l ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1l ) ;
            TN( tqq , "\"\"" ) ;
            TN( tq , "\"" ) ;
        {
        if( tGuide.csF( tinP ) )
        TN( tGuide , postGuide ) ;
    {
    if( !bLoaded )
    
    }
        else       bLoaded = 1 ;
        if( POOP ) POOPR
        readF( tinP , *tinP.pEtScratch , treeP , TsTATEfILE , idGeneration ) ; //U::EDIT TO USE PRIOR GENS UNTIL READ IS OK
        countT idGeneration = 1 ;
        SCOOPS
    {
    IFsCRATCH
    ZE( boolT , bLoaded ) ;
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    QUITOZ
{
voidT readStateF( tinS& tinP , etherC& etherP , treeOldC& treeP )

}
    if( bWhole ) etherP( tinP , pStkDirections ) ;
    etherP( tinP , psFile ) ;
    pBatonTree->ungrabF( tinP ) ;
    }
        }
            }
                while( -- idBro ) treeP.rightF( tinP ) ;
                *pStkDirections >> idBro ;
                ZE( countT , idBro ) ;
                treeP.upF( tinP ) ;
            {
            if( bWhole ) while( *pStkDirections )
                    
            treeP.walkF( tinP , hWalk , etherP , countTC() , treeOldCBF , countTC() , flTREEwALK_REVERSE ) ; //CURSOR THE ELDEST KID OF EACH BRANCH
            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_TREEwALK ) ;
            if( bWhole ) while( treeP.downF( tinP ) ) ;

            //LOGrAW3( "i read " , cBranches , " branches into the tree\r\n" ) ; //U::
            //}
            //    LOGrAWtID( "------------------- END -----------------------------" ) ;
            //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
            //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_DISABLE ) ;
            //{
            //if( idIn == 2 )
            countT cBranches = treeP.readF( tinP , *psFile , *pEtPrime ) ;
            //}
            //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_ENABLE ) ;
            //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
            //    LOGrAWtID( "------------------- BEGIN -----------------------------" ) ;
            //{
            //if( idIn == 2 )
            //countT idIn = 1 + incv02AM( idInLath ) ;
            //static countT idInLath ;
            //U::

            }
                *pStkDirections << idBro ;
                *psFile >> idBro ;
                ZE( countT , idBro ) ;
            {
            if( bWhole ) while( cDirections -- )

            *psFile >> cDirections ;
            ZE( countT , cDirections ) ;

            if( bWhole && idTypeDisplayNew ) idTypeDisplay = idTypeDisplayNew ;
            *psFile >> idTypeDisplayNew ;
            ZE( countT , idTypeDisplayNew ) ;

            if( bWhole && idCursorNew ) idCursor = idCursorNew ;
            *psFile >> idCursorNew ;
            ZE( countT , idCursorNew ) ;
        {
        if( !POOP )

        }
            etherP.delF( tinP , pbi ) ;
            if( pbi ) psFile->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbi , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
            etherP.delF( tinP , psttfn ) ;
            __Z( pbi ) ;
            etherP.boxGetShadowGenerationF( tinP , pbi , cbi , psttfn , psttP , TUCK * 0x10 , 0 , 1 ) ;
            ZE( strokeS* , psttfn ) ;
            ZE( countT , cbi ) ;
            ZE( byteT* , pbi ) ;
        {
        else
        if( !idGenerationP ) etherP.boxGetShadowF( tinP , *psFile , psttP , 1 ) ;
    {
    if( psFile && ( pStkDirections || !bWhole ) )
    if( bWhole ) etherP( tinP , pStkDirections , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_XRAY , ifcSTACKtYPE_countT ) ;
    ZE( stackC* , pStkDirections ) ;
    etherP( tinP , psFile , TAG( TAGiDnULL ) ) ;
    ZE( soulC* , psFile ) ;

    boolT bWhole = !treeP.downF( tinP , 1 ) ;
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT readF( tinS& tinP , etherC& etherP , treeOldC& treeP , const strokeS* const psttP , countT& idGenerationP )

}
    if( tinP.fingerprint && etherP && idTypeP && flagsP && pbP && cbP && cArgP && !handleP ) ;
    _OUT_
    }
        if( tCopy.csF( tinP ) && pData && pData->psttb && etherP.strIdF( tinP , tCopy , pData->psttb ) ) *pStkFind << (byteT*)&handleP ; //ASSUME: HANDLE IS CLONEABLE VIA MEMCOPY
        branchDataOldS* pData = (branchDataOldS*)pbP ;
    
        TN( tCopy , "" ) ; tCopy = *pTxtFind ; //U::O: ELIMINATE THE NEED FOR THIS BY SERIALIZING
    {
    if( idTypeP == ifcIDtYPEtREEwALKcb_BRANCHbEGIN )

    _INoLD_
{
voidT treeFindCBF( tinS& tinP , etherC& etherP , const countT idTypeP , const flagsT flagsP , const handleC& handleP , byteT* pbP , countT cbP , countT& cArgP )

}
    if( tinP.fingerprint && etherP && idTypeP && flagsP && pbP && cbP && cArgP && !handleP ) ;
    _OUT_
    _INoLD_
{
voidT treeOldCBF( tinS& tinP , etherC& etherP , const countT idTypeP , const flagsT flagsP , const handleC& handleP , byteT* pbP , countT cbP , countT& cArgP )

}
    return 0 ;
    _OUT_
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;

    }
        }
            break ;
            pBatonTree->ungrabF( tinP ) ;
            }
                sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
                key_zF( tinP , etherP ) ;
                sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
                const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
                const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
            {
            if( bStateHasChanged )
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("save my state and reload to verify saved ok") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_zCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_
    _INoLD_
{
boolT _export saOLD_guideCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            key_sF( tinP ) ;
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("\"squares\": display ni branches") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_sCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            key_pF( tinP ) ;
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("\"prune\": discards this branch") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_pCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            key_iF( tinP , etherP , wP ) ;
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        {
        default :
        }
            break ;

            ;
        
                T(" web site")
                *pTxtLogo+
                T("press the 'i' key to view the ")+
        
            *pTxtGuide = 
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_iCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            key_minusF( tinP , etherP ) ;
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("\"pop clone\": discards the top clone on the clone stack") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_minusCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            key_plusF( tinP , etherP ) ;
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("\"push clone\": pushes a clone to the clone stack") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_plusCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            key_wF( tinP , etherP , wP ) ;
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("\"write\": create an ideafarm.kt.anyname file") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_wCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            key_hF( tinP ) ;
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("\"huge\": display wo branch") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_hCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            key_gF( tinP , etherP ) ;
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("'g' then arrow to \"graft\"  a copy of the top branch of the clone stack") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_gCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            outArrowF( tinP ) ;
        
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("climb out to the next facet") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOutArrowCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            inArrowF( tinP ) ;
        
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("climb in to the preceding facet") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saInArrowCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            rightArrowF( tinP , etherP ) ;
        
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            ) ;

                        : "climb right to the next idea"
                        ? "jump to the next branch found"
                    : bFind
                    ? "graft a new, null younger brother branch"
                bEntry

            *pTxtGuide = T(
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saRightArrowCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            leftArrowF( tinP , etherP ) ;
        
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            ) ;

                        : "climb left to the preceding idea"
                        ? "jump to the previous branch found"
                    : bFind
                    ? "graft a new, null elder brother branch"
                bEntry

            *pTxtGuide = T(
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saLeftArrowCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            homeIF( tinP ) ;
        
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("climb right to youngest idea") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saHomeCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            endF( tinP ) ;
        
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("climb left to eldest idea") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saEndCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            else upArrowF( tinP , etherP ) ;
            }
                pTree->jumpF( tinP , *(handleC*)&(*pStkFind)[ 0 ] ) ;
                pStkFind->upF( tinP ) ;
            {
            if( bFind )
        
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;

            ) ;

                        : "climb up into detail"
                        ? "jump to the previous branch found"
                    : bFind
                    ? "graft a new, null kid branch"
                bEntry

            *pTxtGuide = T(
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saUpArrowCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            else downArrowF( tinP ) ;
            }
                pTree->jumpF( tinP , *(handleC*)&(*pStkFind)[ 0 ] ) ;
                pStkFind->downF( tinP ) ;
            {
            if( bFind )
        
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;

            ) ;

                        : "climb down out of detail"
                        ? "jump to the next branch found"
                    : bFind
                    ? "climb down out of detail"
                bEntry

            *pTxtGuide = T(
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saDownArrowCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;
    _OUT_

    }
        }
            break ;
            }
                key_tF( tinP ) ;

                if( !bEntry && !bFind ) sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;

                const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
                const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
            {
            if( !bToolTest || idTypeCallP != ifcIDtYPEsTROKEcALLbACK_KEYBOARD )
        {
        default :
        //case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        //case ifcIDtYPEsTROKEcALLbACK_KEYBOARD :
        }
            break ;
            }
                }
                    break ;
                    }
                        }
                            break ;
                            ppBaton_psttvJoy[ off ]->ungrabF( tinP ) ;
                            etherP.strFuseF( tinP , psttw , *pTxtNull+S2(0,scOld_FRAMEdETACH)+S2(0x00ff00,scOld_cPUSHcOLOR)+S3(1.0,scOld_mmLINEtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,0.0)+S3(0.5,scOld_mmMOVEtO,0.0)+S3(0.5,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmMOVEtO,0.5)+S3(1.0,scOld_mmLINEtO,0.5)+S2(0,scOld_POPcOLOR)+S3(pmxP[1],scOld_mmMOVEtO,pmxP[2])+S3(pmxP[1],scOld_mmLINEeNDtO,pmxP[2])+S2(0,scOld_POPfRAMEdETACH)/*+S3(16.0,scOld_mmFRAMEcELLS,16.0)+S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)+TF1(pmxP[1])+T(",")+TF1(pmxP[2])+S2(0,scOld_POPfRAME)*/ ) ;
                            strokeS* psttw = (strokeS*)ppsttvJoy[ off ] ;
                            SETpREFIXA( ppsttvJoy[ off ] )
                            ppBaton_psttvJoy[ off ]->grabF( tinP , TAG( TAGiDnULL ) ) ;
                            countT off = !( idTool == ifcIDtYPEtOOL_JOY1bUTTON1 ) ;
                        {
                        case ifcIDtYPEtOOL_JOY2bUTTON1 :
                        case ifcIDtYPEtOOL_JOY1bUTTON1 :
                    {
                    switch( idTool )
                {
                case ifcIDtYPEaCTION_DOWN :
                }
                    break ;
                    }
                        }
                            break ;
                            ppBaton_psttvJoy[ off ]->ungrabF( tinP ) ;
                            etherP.strFuseF( tinP , psttw , *pTxtNull+S2(0,scOld_FRAMEdETACH)+S2(0x0000ff,scOld_cPUSHcOLOR)+S3(1.0,scOld_mmLINEtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEeNDtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmMOVEtO,1.0)+S3(1.0,scOld_mmLINEtO,0.0)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAMEdETACH)/*+S3(16.0,scOld_mmFRAMEcELLS,16.0)+S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)+TF1(pmxP[1])+T(",")+TF1(pmxP[2])+S2(0,scOld_POPfRAME)*/ ) ;
                            strokeS* psttw = (strokeS*)ppsttvJoy[ off ] ;
                            SETpREFIXA( ppsttvJoy[ off ] )
                            ppBaton_psttvJoy[ off ]->grabF( tinP , TAG( TAGiDnULL ) ) ;
                            countT off = idTool - ifcIDtYPEtOOL_JOY1pOSITION ;
                        {
                        case ifcIDtYPEtOOL_JOY2pOSITION :
                        case ifcIDtYPEtOOL_JOY1pOSITION :
                    {
                    switch( idTool )
                {
                case ifcIDtYPEaCTION_DETACH :
                }
                    break ;
                    }
                        }
                            break ;
                            ppBaton_psttvJoy[ off ]->ungrabF( tinP ) ;
                            etherP.strFuseF( tinP , psttw , *pTxtNull+S2(0,scOld_FRAMEdETACH)+S2(bDown?0x00ff00:0x004400,scOld_cPUSHcOLOR)+S3(1.0,scOld_mmLINEtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,0.0)+S3(0.5,scOld_mmMOVEtO,0.0)+S3(0.5,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmMOVEtO,0.5)+S3(1.0,scOld_mmLINEtO,0.5)+S2(0,scOld_POPcOLOR)+S3(pmxP[1],scOld_mmMOVEtO,pmxP[2])+S3(pmxP[1],scOld_mmLINEeNDtO,pmxP[2])+S2(0,scOld_POPfRAMEdETACH)/*+S3(16.0,scOld_mmFRAMEcELLS,16.0)+S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)+TF1(pmxP[1])+T(",")+TF1(pmxP[2])+S2(0,scOld_POPfRAME)*/ ) ;
                            strokeS* psttw = (strokeS*)ppsttvJoy[ off ] ;
                            SETpREFIXA( ppsttvJoy[ off ] )
                            ppBaton_psttvJoy[ off ]->grabF( tinP , TAG( TAGiDnULL ) ) ;

                            boolT   bDown = F(*pFlags) & flTOOL_DOWN ;
                            flagsT* pFlags = (flagsT*)pcNotesP[ 5 ] ;
                            countT off = idTool - ifcIDtYPEtOOL_JOY1pOSITION ;
                        {
                        case ifcIDtYPEtOOL_JOY2pOSITION :
                        case ifcIDtYPEtOOL_JOY1pOSITION :
                    {
                    switch( idTool )
                {
                case ifcIDtYPEaCTION_MOVE :
            {
            switch( idAction )

            const measureT* pmxP   = pcNotesP ? (const measureT*)pcNotesP[ 4 ] : 0 ;
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_JOYsTICK :
        }
            break ;
            }
                }
                    }
                        pBaton_ppsttvbToolState->ungrabF( tinP ) ;
                        }
                            etherP.strFuseF( tinP , psttw , *pTxtNull+S3(62.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+TF3(pxNew[1],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxNew[2],flFORMAT_UNSIGNED,8)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
                            strokeS* psttw = psttzMousePosition ;
                            SETpREFIXA( psttzMousePosition )
                        {
                        if( !( F(pxNew[0]) & flTOOL_NOTpRESENT ) )
                        pBaton_ppsttvbToolState->grabF( tinP , TAG( TAGiDnULL ) ) ;
    
                        thirdC::c_memcpyIF( tinP , (byteT*)pxLag , (byteT*)pxNew , sizeof pxLag ) ;
                    {
                    if( thirdC::c_memcmpIF( tinP , (byteT*)pxLag , (byteT*)pxNew , sizeof pxLag ) )
                    static countT pxLag[ 3 ] ;
    
                    ;
                    }
                        wP.pcToolState_22[ ifcIDtYPEtOOL_MOUSEpOSITION - ifcIDtYPEtOOL_x2Begin - 1 ] ,
                        wP.pcToolState_12[ ifcIDtYPEtOOL_MOUSEpOSITION - ifcIDtYPEtOOL_x2Begin - 1 ] ,
                        wP.pfToolState_f[  ifcIDtYPEtOOL_MOUSEpOSITION - ifcIDtYPEtOOL_begin   - 1 ] ,
                    {
                    countT pxNew[ 3 ] =
                    //U::O: THIS WOULD BE FASTER IF TOOL STATE INFO WAS CONTIGUOUS

                    }
                        }
                            pBaton_ppsttvbToolState->ungrabF( tinP ) ;
                            }
                                etherP.strFuseF( tinP , psttw , *pTxtNull+S3(62.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+TF3(pxRpt[1],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[2],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[3],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[4],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[5],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[6],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[7],flFORMAT_UNSIGNED,8)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
                                strokeS* psttw = psttzJoy2Position ;
                                SETpREFIXA( psttzJoy2Position )
                            {
                            else if( !( F(pxNew[0]) & flTOOL_NOTpRESENT ) )
                            }
                                etherP.strFuseF( tinP , psttw , *pTxtNull+S3(62.0,scOld_mmFRAMEcELLS,1.0)+S2(0x00ff00,scOld_cPUSHcOLOR)+TF3(pxRpt[1],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[2],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[3],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[4],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[5],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[6],flFORMAT_UNSIGNED,8)+*pTxtBlank+TF3(pxRpt[7],flFORMAT_UNSIGNED,8)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
                                strokeS* psttw = psttzJoy1Position ;
                                SETpREFIXA( psttzJoy1Position )
                            {
                            if( !( F(pxNew[0]) & flTOOL_NOTpRESENT ) && idTool == ifcIDtYPEtOOL_JOY1pOSITION )
                            pBaton_ppsttvbToolState->grabF( tinP , TAG( TAGiDnULL ) ) ;

                            }
                                ;
                                    : ( pxNew[ off ] - pxMin[ off ] ) * 0x100 / range
                                    ? 0
                                pxRpt[ off ] = !range
                                countT range = pxMax[ off ] - pxMin[ off ] ;
                            {
                            for( countT off = 1 ; off <= 7 ; off ++ )
                            countT pxRpt[ 8 ] ;

                            ;
                            }
                                wP.pcToolState_77MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ]
                                wP.pcToolState_67MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                                wP.pcToolState_57MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                                wP.pcToolState_47MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                                wP.pcToolState_37MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                                wP.pcToolState_27MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                                wP.pcToolState_17MaxI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                                0 ,
                            {
                            countT pxMax[ 8 ] =
                            //U::O: THIS WOULD BE FASTER IF TOOL STATE INFO WAS CONTIGUOUS

                            ;
                            }
                                wP.pcToolState_77MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ]
                                wP.pcToolState_67MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                                wP.pcToolState_57MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                                wP.pcToolState_47MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                                wP.pcToolState_37MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                                wP.pcToolState_27MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                                wP.pcToolState_17MinI[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                                0 ,
                            {
                            countT pxMin[ 8 ] =
                            //U::O: THIS WOULD BE FASTER IF TOOL STATE INFO WAS CONTIGUOUS

                            thirdC::c_memcpyIF( tinP , (byteT*)pxLag , (byteT*)pxNew , sizeof pxLag ) ;
                        {
                        if( thirdC::c_memcmpIF( tinP , (byteT*)pxLag , (byteT*)pxNew , sizeof pxLag ) )
                        static countT pxLag[ 8 ] ;

                        ;
                        }
                            wP.pcToolState_77I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ]
                            wP.pcToolState_67I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                            wP.pcToolState_57I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                            wP.pcToolState_47I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                            wP.pcToolState_37I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                            wP.pcToolState_27I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                            wP.pcToolState_17I[ idTool - ifcIDtYPEtOOL_x7Begin - 1 ] ,
                            wP.pfToolState_fI[  idTool - ifcIDtYPEtOOL_begin   - 1 ] ,
                        {
                        countT pxNew[ 8 ] =
                        //U::O: THIS WOULD BE FASTER IF TOOL STATE INFO WAS CONTIGUOUS
                    {
                    for( countT idTool = ifcIDtYPEtOOL_JOY1pOSITION ; idTool <= ifcIDtYPEtOOL_JOY2pOSITION ; idTool ++ )
                    //A:ASSUME: JOYSTICK POSITION TOOLS ARE CONTIGUOUS

                    }
                        pBaton_ppsttvbToolState->ungrabF( tinP ) ;
                        }
                            }
                                }
                                    continue ;
                                    else                    ppsttvbToolState[ idTool - ifcIDtYPEtOOL_begin - 1 ] = psttzOffUp ;
                                    else if( bDown        ) ppsttvbToolState[ idTool - ifcIDtYPEtOOL_begin - 1 ] = psttzOffDown ;
                                    else if( bOn          ) ppsttvbToolState[ idTool - ifcIDtYPEtOOL_begin - 1 ] = psttzOnUp ;
                                    else if( bOn && bDown ) ppsttvbToolState[ idTool - ifcIDtYPEtOOL_begin - 1 ] = psttzOnDown ;
                                         if( bAbsent      ) ppsttvbToolState[ idTool - ifcIDtYPEtOOL_begin - 1 ] = psttzAbsent ;
        
                                    boolT bOn     = F(wP.pfToolState_f[idTool-ifcIDtYPEtOOL_begin-1]) & flTOOL_ON ;
                                    boolT bDown   = F(wP.pfToolState_f[idTool-ifcIDtYPEtOOL_begin-1]) & flTOOL_DOWN ;
                                    boolT bAbsent = F(wP.pfToolState_f[idTool-ifcIDtYPEtOOL_begin-1]) & flTOOL_NOTpRESENT ;
                                {
                                default :
                                }
                                    continue ;
                                    }
                                        case ifcIDtYPEtOOL_MOUSEpOSITION : { ppsttvbToolState[ ifcIDtYPEtOOL_MOUSEpOSITION - ifcIDtYPEtOOL_begin - 1 ] = psttzMousePosition ; break ; }
                                        case ifcIDtYPEtOOL_JOY2pOSITION  : { ppsttvbToolState[ ifcIDtYPEtOOL_JOY2pOSITION  - ifcIDtYPEtOOL_begin - 1 ] = psttzJoy2Position  ; break ; }
                                        case ifcIDtYPEtOOL_JOY1pOSITION  : { ppsttvbToolState[ ifcIDtYPEtOOL_JOY1pOSITION  - ifcIDtYPEtOOL_begin - 1 ] = psttzJoy1Position  ; break ; }
                                    {
                                    else switch( idTool )
                                    if( bAbsent ) ppsttvbToolState[ idTool - ifcIDtYPEtOOL_begin - 1 ] = psttzAbsent2 ;
        
                                    boolT bAbsent = F(wP.pfToolState_f[idTool-ifcIDtYPEtOOL_begin-1]) & flTOOL_NOTpRESENT ;
                                {
                                case ifcIDtYPEtOOL_JOY2pOSITION :
                                case ifcIDtYPEtOOL_JOY1pOSITION :
                                case ifcIDtYPEtOOL_MOUSEpOSITION :
                                case ifcIDtYPEtOOL_x2End        : { continue ; }
                                case ifcIDtYPEtOOL_x7End        :
                                case ifcIDtYPEtOOL_x7Begin      :
                                case ifcIDtYPEtOOL_x2Begin      :
                                case ifcIDtYPEtOOL_CONTROLeND   :
                                case ifcIDtYPEtOOL_CONTROLbEGIN :
                            {
                            switch( idTool ) /*A*/
                        {
                        for( countT idTool = ifcIDtYPEtOOL_begin + 1 ; idTool < ifcIDtYPEtOOL_end ; idTool ++ )
                        ZE( countT , cDone ) ;
                        pBaton_ppsttvbToolState->grabF( tinP , TAG( TAGiDnULL ) ) ;

                        thirdC::c_memcpyIF( tinP , pbSave_f , (byteT*)wP.pfToolState_f , sizeof pbSave_f ) ;
                    {
                    if( thirdC::c_memcmpIF( tinP , pbSave_f , (byteT*)wP.pfToolState_f , sizeof pbSave_f ) )

                    static byteT pbSave_f[ sizeof wP.pfToolState_f ] ;
                {
                if( bToolTest )

                if( timeN1 > TOCK * 8 ) *pTxtGuide = T("") ;
                etherP.osTimeSubtractF( tinP , timeN1 , timeN2 , timeGuideAge1 , timeGuideAge2 ) ;
                etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT , timeN1 ) ;

                }
                    etherP.osTimeNowF( tinP , timeGuideAge1 , timeGuideAge2 ) ;
                    timeGuideAge2 = timeGuideAge1 = 0 ;

                    thirdC::winBitBltIF( tinP , wP , mIdColMinGuide , mIdRowMinGuide , mColsGuideBitBlt , mRowsGuide ) ;
                    *pTxtGuideMemory = *pTxtGuide ;
                    }
                        etherP.delF( tinP , psttSay ) ;
                        wP.wrapRenderF( tinP , psttSay ) ;

                        etherP.strFuseF( tinP , psttSay , S2(0,scOld_POPfRAME) ) ;
                        etherP.strFuseF( tinP , psttSay , S2(0,scOld_POPfRAME) ) ;
                        etherP.strFuseF( tinP , psttSay , tSay ) ;
                        etherP.strFuseF( tinP , psttSay , S3(mIdColMinGuide-1.0+mColsGuide,scOld_mmFRAMEpELtO,mIdRowMinGuide-1.0+mRowsGuide) ) ;
                        etherP.strFuseF( tinP , psttSay , S3(mIdColMinGuide,scOld_mmMOVEpELtO,mIdRowMinGuide) ) ;
                        etherP.strFuseF( tinP , psttSay , S3(1.0,scOld_mmFRAMEtO,1.0) ) ;
                        etherP.strFuseF( tinP , psttSay , S3(0.0,scOld_mmMOVEtO,0.0) ) ; //TO PREVENT AFFECTING HIGH WATER

                        etherP.strMakeF( tinP , psttSay , 0 , 0x10 + tSay.csF( tinP ) ) ;
                        ZE( strokeS* , psttSay ) ;

                        textC& tSay = idPass == 1 ? *pTxtGuideMemory : *pTxtGuide ;
                    {
                    for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
                {
                if( *pTxtGuideMemory != *pTxtGuide )
            {

            }
                pBaton_psttvWheel->ungrabF( tinP ) ;
                etherP.strFuseF( tinP , psttw , *pTxtNull+S3(1.0,scOld_mmFRAMEcELLS,1.0)+S2(0,scOld_FRAMEdETACH)+S3(0.0,scOld_mmMOVEtO,mRowWhere)+S3(1.0,scOld_mmLINEtO,mRowWhere)+S2(0,scOld_POPfRAMEdETACH)+S2(0,scOld_POPfRAME) ) ;
                strokeS* psttw = (strokeS*)psttvWheel ;
                SETpREFIXA( psttvWheel )
                pBaton_psttvWheel->grabF( tinP , TAG( TAGiDnULL ) ) ;

                }
                    if( !( idv % TUCK ) ) bLeft = !bLeft ;
                    else         mRowWhere = (measure04T)( ( TUCK - idv % TUCK ) % TUCK ) / (measure04T)( TUCK - 1 ) ;
                    if( !bLeft ) mRowWhere = (measure04T)( ( - 1  + idv                 ) % TUCK ) / (measure04T)( TUCK - 1 ) ;
                    static boolT bLeft ;
                    countT idv = idInAnimateLath ;
                {
                ZE( measure04T , mRowWhere ) ;
                //MOVE A VERTICAL LINE BACK AND FORTH HORIZONTALLY 1 PEL PER ANIMATION CYCLE
            {

            }
                mIdRowMinTools = ( sf.mIdRow - 1.0 ) + (measureT)0x10 ;
                mRowsTools = sf.mRows / (measureT)0x20 ;
                mColsToolsBitBlt += 0x10 ; //TO TAKE CARE OF STROKING BEYOND RIGHT BOUNDARY (SINCE AM NOT CLIPPING)
                mIdColMinTools = sf.mIdCol + 0x10 ;
                mColsTools = mColsToolsBitBlt / (measureT)0xc0 ;
                mColsToolsBitBlt = sf.mCols - 0x20 ;

                mIdRowMinGuide = ( sf.mIdRow - 1.0 + sf.mRows ) - (measureT)0x10 - mRowsGuide ;
                mRowsGuide = sf.mRows / (measureT)0x20 ;
                mColsGuideBitBlt += 0x10 ; //TO TAKE CARE OF STROKING BEYOND RIGHT BOUNDARY (SINCE AM NOT CLIPPING)
                mIdColMinGuide = sf.mIdCol + 0x10 ;
                mColsGuide = mColsGuideBitBlt / (measureT)0xc0 ;
                mColsGuideBitBlt = sf.mCols - 0x20 ;

                strokingFrameS& sf = *(strokingFrameS*)&wP.stqr_strokingFrame[ wP.stqr_strokingFrame - 3 ] ;
            {
            if( 1 == ++ idInAnimateLath )
        {
        case ifcIDtYPEsTROKEcALLbACK_ANIMATE :
        }
            break ;
            *pTxtToolsMemory = T("") ;
            *pTxtGuideMemory = T("") ;
            idInAnimateLath = 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_DESTROY :
        }
            break ;
            *pTxtGuide = T("click me or key 't' for a suggestion") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
        case ifcIDtYPEsTROKEcALLbACK_RENDERoFF : { break ; }
        case ifcIDtYPEsTROKEcALLbACK_RENDERoN :
    {
    switch( idTypeCallP )
    static countT   idInAnimateLath ;

    static measureT mColsToolsBitBlt ;
    static measureT mRowsTools ;
    static measureT mColsTools ;
    static measureT mIdRowMinTools ;
    static measureT mIdColMinTools ;

    static measureT mColsGuideBitBlt ;
    static measureT mRowsGuide ;
    static measureT mColsGuide ;
    static measureT mIdRowMinGuide ;
    static measureT mIdColMinGuide ;

    _INoLD_
{
boolT _export saOLD_tCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    _OUT_
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;

    }
        }
            break ;
            key_oF( tinP , etherP , wP ) ;
        
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("display the base operating system") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_oCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    _OUT_
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;

    }
        }
            break ;
            key_mF( tinP ) ;
        
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("toggle between stroke entry modes: alpha bigit") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_mCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    _OUT_
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;

    }
        }
            break ;
            key_kF( tinP , wP ) ;
        
            sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
        
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            *pTxtGuide = T("toggle between normal display and tool test (keyboard mouse joystick)") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saOLD_kCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    _OUT_
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;

    }
        }
            break ;
            }
                }
                    }
                        break ;

                        }
                            }
                                incv02AM( cRequestFresh ) ;
                                *pTxtFind += T(psttn) ;
                            {
                            if( psttn[ CSpREFIX ].idAdam )
    
                            else           psttn[ CSpREFIX ] = S2( vv | sscDIGIT | SDBITS( 4 ) , sc_cALPHABET1 ) ;
                            if( !bUse_vv ) psttn[ CSpREFIX ] = strokeS::strokeIF( tinP , idTool ) ;
    
                            }
                                }
                                    break ;
                                    bUse_vv = 1 ;
                                    vv = 0xa + idTool - ifcIDtYPEtOOL_a ;
                                {
                                case ifcIDtYPEtOOL_f :
                                case ifcIDtYPEtOOL_e :
                                case ifcIDtYPEtOOL_d :
                                case ifcIDtYPEtOOL_c :
                                case ifcIDtYPEtOOL_b :
                                case ifcIDtYPEtOOL_a :
                                }
                                    break ;
                                    bUse_vv = 1 ;
                                    vv = idTool - ifcIDtYPEtOOL_PAD0 ;
                                {
                                case ifcIDtYPEtOOL_PAD9 :
                                case ifcIDtYPEtOOL_PAD8 :
                                case ifcIDtYPEtOOL_PAD7 :
                                case ifcIDtYPEtOOL_PAD6 :
                                case ifcIDtYPEtOOL_PAD5 :
                                case ifcIDtYPEtOOL_PAD4 :
                                case ifcIDtYPEtOOL_PAD3 :
                                case ifcIDtYPEtOOL_PAD2 :
                                case ifcIDtYPEtOOL_PAD1 :
                                }
                                    break ;
                                    bUse_vv = 1 ;
                                    vv = idTool - ifcIDtYPEtOOL_0 ;
                                {
                                case ifcIDtYPEtOOL_9 :
                                case ifcIDtYPEtOOL_8 :
                                case ifcIDtYPEtOOL_7 :
                                case ifcIDtYPEtOOL_6 :
                                case ifcIDtYPEtOOL_5 :
                                case ifcIDtYPEtOOL_4 :
                                case ifcIDtYPEtOOL_3 :
                                case ifcIDtYPEtOOL_2 :
                                case ifcIDtYPEtOOL_1 :
                            {
                            if( bNumericEntry ) switch( idTool )
                            ZE( boolT , bUse_vv ) ;
                            ZE( countT , vv ) ;
                            SETpREFIX( psttn , 1 , 0 ) ;
                            strokeS psttn[ CSpREFIX + 1 ] ;
                        {
                        if( idTool < ifcIDtYPEtOOL_CONTROLbEGIN || idTool > ifcIDtYPEtOOL_CONTROLeND )
                    {
                    default :
                    }
                        break ;

                        }
                            incv02AM( cRequestFresh ) ;

                            }
                                pTree->jumpF( tinP , *(handleC*)&(*pStkFind)[ 1 ] ) ;
                            {
                            if( *pStkFind )
                            //U::ORTHOGONALIZE: PROVIDE A SEPARATE BUTTON(S) TO WALK THE STACK OF FOUND BRANCHES

                            etherP.beeClickF( tinP ) ;
                            pTree->walkF( tinP , hWalk , etherP , countTC() , treeFindCBF , countTC() , flTREEwALK_null ) ;
                            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_TREEwALK ) ;
                            etherP.beeClickF( tinP ) ;
                            pStkFind->purgeF( tinP ) ; //U::ORTHOGONALIZE THIS BY PROVIDING A SEPARATE BUTTON TO CLEAR THE FIND LIST
                        {
                        if( pTxtFind->csF( tinP ) )
                    {
                    case ifcIDtYPEtOOL_ENTERnUM :
                    case ifcIDtYPEtOOL_ENTER :
                    }
                        break ;

                        incv02AM( cRequestFresh ) ;
                        etherP.delF( tinP , psttw ) ;
                        *pTxtFind = T(psttw) ;

                        }
                            etherP.strTrimF( tinP , psttw , 0 , T(TbLACKnEWlINE) ) ; ___( psttw ) ;
                            etherP.strSubstringF( tinP , psttw , idf , idl , *pTxtFind ) ; ___( psttw ) ;
                            countT idl = csOld - 1 ;
                            countT idf = 1 ;
                        {
                        else
                        if( csOld == 1 ) { etherP.strMakeF( tinP , psttw , T("") ) ; ___( psttw ) ; }
                        countT csOld = pTxtFind->csF( tinP ) ;
                        ZE( strokeS* , psttw ) ;
                    {
                    case ifcIDtYPEtOOL_BACKSPACE :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_UPaRROW ) ) ;
                    {
                    case ifcIDtYPEtOOL_UP :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_DOWNaRROW ) ) ;
                    {
                    case ifcIDtYPEtOOL_DOWN :
                {
                switch( idTool )
            {
            if( idAction == ifcIDtYPEaCTION_DOWN )
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            incv02AM( cRequestFresh ) ;
            bFind = 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_TABlEAVING :
        }
            break ;
            incv02AM( cRequestFresh ) ;
            bFind = 1 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_TABaRRIVING :
        }
            break ;
            *pTxtGuide = T("to find text, tab to me, key text, then key Enter") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saKeyEater3CBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

voidT treeFindCBF( tinS& tinP , etherC& etherP , const countT idTypeP , const flagsT flagsP , const handleC& handleP , byteT* pbP , countT cbP , countT& cArgP ) ;

}
    return 0 ;
    _OUT_
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;

    }
        }
            break ;
            }
                }
                    }
                        break ;
                        }
                            }
                                pBatonTree->ungrabF( tinP ) ;
                                pTree->ungrabF( tinP ) ;
                                }
                                    incv02AM( cRequestFresh ) ;
                                    bStateHasChanged = 1 ;
                                    pData->psttb = psttw ; psttw = 0 ;
                                    etherP.delF( tinP , pData->psttb ) ;
                                    etherP.strFuseF( tinP , psttw , psttn[ CSpREFIX ] ) ;
                                    etherP.strMakeF( tinP , psttw , pData->psttb , 1 ) ; ___( psttw ) ;
                                    ZE( strokeS* , psttw ) ;
                                {
                                if( pData )
                                
                                }
                                    etherP( tinP , psClone ) ;
                                    }
                                        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
                                        *pStkActionMemory << (countT)ifcIDiNTERCOM_STROKEeNTRY ;
                                        incv02AM( cRequestFresh ) ;
                                        bStateHasChanged = 1 ;
                                        pTree->rightF( tinP ) ;
                                        pTree->upF( tinP ) ;
                                        pTree->readF( tinP , *psClone , *pEtPrime ) ;
                                        pTree->downF( tinP ) ;
                                        
                                        pTree->writeF( tinP , *psClone , psttn ) ;
                                    {
                                    if( psClone )
                                    etherP( tinP , psClone , TAG( TAGiDnULL ) ) ;
                                    ZE( soulC* , psClone ) ;
                                {
                                if( !pData )
                                branchDataOldS* pData = *pTree ;
                                pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                                pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                            {
                            if( psttn[ CSpREFIX ].idAdam )
    
                            else           psttn[ CSpREFIX ] = S2( vv | sscDIGIT | SDBITS( 4 ) , sc_cALPHABET1 ) ;
                            if( !bUse_vv ) psttn[ CSpREFIX ] = strokeS::strokeIF( tinP , idTool ) ;
    
                            }
                                }
                                    break ;
                                    bUse_vv = 1 ;
                                    vv = 0xa + idTool - ifcIDtYPEtOOL_a ;
                                {
                                case ifcIDtYPEtOOL_f :
                                case ifcIDtYPEtOOL_e :
                                case ifcIDtYPEtOOL_d :
                                case ifcIDtYPEtOOL_c :
                                case ifcIDtYPEtOOL_b :
                                case ifcIDtYPEtOOL_a :
                                }
                                    break ;
                                    bUse_vv = 1 ;
                                    vv = idTool - ifcIDtYPEtOOL_PAD0 ;
                                {
                                case ifcIDtYPEtOOL_PAD9 :
                                case ifcIDtYPEtOOL_PAD8 :
                                case ifcIDtYPEtOOL_PAD7 :
                                case ifcIDtYPEtOOL_PAD6 :
                                case ifcIDtYPEtOOL_PAD5 :
                                case ifcIDtYPEtOOL_PAD4 :
                                case ifcIDtYPEtOOL_PAD3 :
                                case ifcIDtYPEtOOL_PAD2 :
                                case ifcIDtYPEtOOL_PAD1 :
                                }
                                    break ;
                                    bUse_vv = 1 ;
                                    vv = idTool - ifcIDtYPEtOOL_0 ;
                                {
                                case ifcIDtYPEtOOL_9 :
                                case ifcIDtYPEtOOL_8 :
                                case ifcIDtYPEtOOL_7 :
                                case ifcIDtYPEtOOL_6 :
                                case ifcIDtYPEtOOL_5 :
                                case ifcIDtYPEtOOL_4 :
                                case ifcIDtYPEtOOL_3 :
                                case ifcIDtYPEtOOL_2 :
                                case ifcIDtYPEtOOL_1 :
                            {
                            if( bNumericEntry ) switch( idTool )
                            ZE( boolT , bUse_vv ) ;
                            ZE( countT , vv ) ;
                            SETpREFIX( psttn , 1 , 0 ) ;
                            strokeS psttn[ CSpREFIX + 1 ] ;
                        {
                        if( idTool < ifcIDtYPEtOOL_CONTROLbEGIN || idTool > ifcIDtYPEtOOL_CONTROLeND )
                    {
                    default :
                    }
                        break ;
                        pBatonTree->ungrabF( tinP ) ;
                        pTree->ungrabF( tinP ) ;
                        }
                            incv02AM( cRequestFresh ) ;
                            bStateHasChanged = 1 ;
                            pData->psttb = psttw ; psttw = 0 ;
                            etherP.delF( tinP , pData->psttb ) ;
                            }
                                etherP.strSubstringF( tinP , psttw , idf , idl , pData->psttb ) ; ___( psttw ) ;
                                countT idl = pData->psttb->idAdam - 1 ;
                                countT idf = 1 ;
                            {
                            else
                            if( pData->psttb->idAdam == 1 ) etherP.strMakeF( tinP , psttw , T("") ) ;
                            ZE( strokeS* , psttw ) ;
                        {
                        if( pData && pData->psttb && pData->psttb->idAdam )
                        branchDataOldS* pData = *pTree ;
                        pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    case ifcIDtYPEtOOL_BACKSPACE :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_RIGHTaRROW ) ) ;
                    {
                    case ifcIDtYPEtOOL_RIGHT :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_LEFTaRROW ) ) ;
                    {
                    case ifcIDtYPEtOOL_LEFT :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_UPaRROW ) ) ;
                    {
                    case ifcIDtYPEtOOL_UP :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_DOWNaRROW ) ) ;
                    {
                    case ifcIDtYPEtOOL_DOWN :
                {
                switch( idTool )
            {
            if( idAction == ifcIDtYPEaCTION_DOWN )
            const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
            const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
        {
        default :
        }
            break ;
            incv02AM( cRequestFresh ) ;
            bEntry = 0 ;
            pBatonTree->ungrabF( tinP ) ;
            pTree->ungrabF( tinP ) ;
            }
                bStateHasChanged = 1 ;
                pTree->delF( tinP ) ;
            {
            if( pData && pData->psttb && !pData->psttb->idAdam )
            branchDataOldS* pData = *pTree ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_TABlEAVING :
        }
            break ;
            }
                incv02AM( cEntryArrivals ) ;
                incv02AM( cRequestFresh ) ;
                bEntry = 1 ;
            {
            if( tinP.monitor.idThread != idThreadRefresh ) //I WANT TO DO THIS ONLY IN RESPONSE TO A KEYSTROKE
        {
        case ifcIDtYPEsTROKEcALLbACK_TABaRRIVING :
        }
            break ;
            *pTxtGuide = T("to enter text, tab to me, key text, and press Enter") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saKeyEater2CBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    return 0 ;
    _OUT_
    if( tinP.fingerprint && etherP && wP.bDoomed && idSnipP && psttSnipP && idsP && idAdamP && flagsP && bNoDrawP && idTypeCallP && pcNotesP && scratchEventP.c8scratch.c1 && scratchAdamP.c8scratch.c1 && scratchSnipP.c8scratch.c1 && scratchSnipAdamP.c8scratch.c1 && scratchStrokeP.c8scratch.c1 ) ;

    }
        }
            }
                break ;
                }
                    //#endif
                    }
                        break ;
                        //incv02AM( cRequestFresh ) ;
                        //idCursor = 0xa + idTool - ifcIDtYPEtOOL_a ;
                        //sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
                    {
                    case ifcIDtYPEtOOL_f :
                    case ifcIDtYPEtOOL_e :
                    case ifcIDtYPEtOOL_d :
                    case ifcIDtYPEtOOL_c :
                    case ifcIDtYPEtOOL_b :
                    case ifcIDtYPEtOOL_a :
                    }
                        break ;
                        //incv02AM( cRequestFresh ) ;
                        //idCursor = idTool - ifcIDtYPEtOOL_PAD0 ;
                        //sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
                    {
                    case ifcIDtYPEtOOL_PAD9 :
                    case ifcIDtYPEtOOL_PAD8 :
                    case ifcIDtYPEtOOL_PAD7 :
                    case ifcIDtYPEtOOL_PAD6 :
                    case ifcIDtYPEtOOL_PAD5 :
                    case ifcIDtYPEtOOL_PAD4 :
                    case ifcIDtYPEtOOL_PAD3 :
                    case ifcIDtYPEtOOL_PAD2 :
                    case ifcIDtYPEtOOL_PAD1 :
                    }
                        break ;
                        //incv02AM( cRequestFresh ) ;
                        //idCursor = idTool - ifcIDtYPEtOOL_0 ;
                        //sadamHighlightF( tinP , etherP , wP , scratchStrokeP , 1 ) ;
                        //DO NOT ENABLE THIS UNTIL THIS MODULE IS REWRITTEN
                        //U::ENABLE AFTER THOROUGH TESTING INCL SAVE AND RESTORE TO/FROM STATE FILE
                    {
                    case ifcIDtYPEtOOL_9 :
                    case ifcIDtYPEtOOL_8 :
                    case ifcIDtYPEtOOL_7 :
                    case ifcIDtYPEtOOL_6 :
                    case ifcIDtYPEtOOL_5 :
                    case ifcIDtYPEtOOL_4 :
                    case ifcIDtYPEtOOL_3 :
                    case ifcIDtYPEtOOL_2 :
                    case ifcIDtYPEtOOL_1 :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_OUTaRROW ) ) ;
                    {
                    case ifcIDtYPEtOOL_PAGEuP :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_INaRROW ) ) ;
                    {
                    case ifcIDtYPEtOOL_PAGEdOWN :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_RIGHTaRROW ) ) ;
                    {
                    case ifcIDtYPEtOOL_RIGHT :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_LEFTaRROW ) ) ;
                    {
                    case ifcIDtYPEtOOL_LEFT :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_UPaRROW ) ) ;
                    {
                    case ifcIDtYPEtOOL_UP :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1  , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_DOWNaRROW ) ) ;
                    {
                    case ifcIDtYPEtOOL_DOWN :
                    //}
                    //    break ;
                    //    wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_KEY_t ) ) ;
                    //{
                    //case ifcIDtYPEtOOL_t :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_KEY_s ) ) ;
                    {
                    case ifcIDtYPEtOOL_s :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_KEY_p ) ) ;
                    {
                    case ifcIDtYPEtOOL_p :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_KEY_i ) ) ;
                    {
                    case ifcIDtYPEtOOL_i :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_MINUS ) ) ;
                    {
                    case ifcIDtYPEtOOL_MINUS :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_PLUS ) ) ;
                    {
                    case ifcIDtYPEtOOL_PLUS :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_KEY_z ) ) ;
                    {
                    case ifcIDtYPEtOOL_z :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_KEY_w ) ) ;
                    {
                    case ifcIDtYPEtOOL_w :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_KEY_h ) ) ;
                    {
                    case ifcIDtYPEtOOL_h :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_KEY_g ) ) ;
                    {
                    case ifcIDtYPEtOOL_g :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_KEY_m ) ) ;
                    {
                    case ifcIDtYPEtOOL_m :
                    //#if defined( NEVERDEFINED )
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_KEY_k ) ) ;
                    {
                    case ifcIDtYPEtOOL_k :
                    }
                        break ;
                        wP.callSadamsF( tinP , 0 , countTC() , ifcIDtYPEsTROKEcALLbACK_FORaDAMtOUSE1 , 0 , 0 , 0 , count2S( ifcIDiNTERCOM_KEY_o ) ) ;
                    {
                    case ifcIDtYPEtOOL_o :
                    }
                        break ;
                        }
                            incv02AM( cRequestFresh ) ;
                            etherC::etherFireImpersonateMonitorIF( tinP ) ;
                        {
                        if( IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 == etherP.diskIdF( tinP , T("///c") ) )
                    {
                    case ifcIDtYPEtOOL_q :
                {
                switch( idTool )
    
                //etherP.beeClickF( tinP ) ;
                //LOGrAW( *pTxtGuide+T("\r\n") ) ;
                //*pTxtGuide = T("state if key VK_NUMLOCK is: ")+TF1(state) ;
                //*pTxtGuide = T("state of key 'A' is: ")+TF1(state) ;
                //countT state = tinP.brcRaw ;
                //BOSdOnOTtEST( WHATgbo , GetKeyState( VK_NUMLOCK ) )
                //countT state = tinP.brcRaw ;
                //BOSdOnOTtEST( WHATgbo , GetKeyState( 'A' ) )
                //U::
    
                }
                    //LOGrAW( T("\r\n") ) ;
                    //if( !( state & 0x80000000 ) ) { LOGrAW( T(" (no vk value matches)") ) ; }
    
                    }
                        }
                            break ;
                            //LOGrAW( T(" (found correct state by trying vk value ")+TF1(vki)+T(")") ) ;
                        {
                        if( state & 0x80000000 )
                        state = tinP.brcRaw ;
                        BOSdOnOTtEST( WHATgbo , GetKeyState( vki ) )
    
                        if( vki == 0x10 || vki == 0xa0 ) continue ;
                    {
                    if( !( state & 0x80000000 ) ) for( countT vki = 0 ; vki <= 0xff ; vki ++ )
    
                    }
                        }
                            break ;
                            }
                                //if( state & 0x80000000 ) { LOGrAW( T(" (found correct state using table)") ) }
                                state = tinP.brcRaw ;
                                BOSdOnOTtEST( WHATgbo , GetKeyState( vk ) )
                                //LOGrAW( T(" (in table)") )
                            {
                            if( vk )
                            vk = pVkTool[ off ].vk ;
                        {
                        if( pVkTool[ off ].id == idTool )
                    {
                    for( countT off = 0 ; off < sizeof pVkTool / sizeof pVkTool[ 0 ] ; off ++ )
                    ZE( countT , state ) ;
                    ZE( countT , vk ) ;
    
                    //LOGrAW( T(" \"")+T(processGlobal3I.mapTool(idTool))+T("\": ") )
                {
                if( idAction == ifcIDtYPEaCTION_DOWN && !bToolTest && !bToolTestHire )
            
                const countT& idAction = pcNotesP ? pcNotesP[ 3 ] : 0 ;
                const countT& idTool   = pcNotesP ? pcNotesP[ 2 ] : 0 ;
            {
            if( !bToolTest && !bToolTestHire && pcNotesP )
        {
        default :
        }
            break ;
            *pTxtGuide = T("press bigit key to select climber: numeric key or 'a'-'f'") ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
        }
            break ;
            if( bToolTestHire ) bTestingTools = 1 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_RENDERoFF :
        }
            break ;
            if( bTestingTools ) bTestingTools = 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_RENDERoN :
    {
    switch( idTypeCallP )

    _INoLD_
{
boolT _export saKeyEaterCBF( tinS& tinP , etherC& etherP , windowOldC& wP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const countT idAdamP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , scbScratchEventS& scratchEventP , scbScratchAdamS& scratchAdamP , scbScratchSnipS& scratchSnipP , scbScratchSnipAdamS& scratchSnipAdamP , scbScratchStrokeS& scratchStrokeP )/*1*/

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_KEY_s ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        idTypeDisplay = ifcIDtYPEdISPLAY_HOLLYWOOD ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT key_sF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_KEY_p ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->delF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT key_pF( tinS& tinP )

}
    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
    *pStkActionMemory << (countT)ifcIDiNTERCOM_KEY_i ;
    etherP.osHttpViewF( tinP , T("www.ideafarm.com//http/id15.html") , 1 ) ;
    ((thirdC&)etherP).winShowWindowF( tinP , wP , idcWINsHOW_HIDE ) ;
{
voidT key_iF( tinS& tinP , etherC& etherP , windowOldC& wP )

}
    }
        pStkClone->ungrabF( tinP ) ;
        }
            pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
            *pStkActionMemory << (countT)ifcIDiNTERCOM_MINUS ;
            incv02AM( cRequestFresh ) ;
            etherP( tinP , psClone ) ;
            *pStkClone >> psClone ;
            ZE( soulC* , psClone ) ;
        {
        if( *pStkClone )
        pStkClone->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT key_minusF( tinS& tinP , etherC& etherP )

}
    }
        }
            pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
            *pStkActionMemory << (countT)ifcIDiNTERCOM_PLUS ;
            incv02AM( cRequestFresh ) ;
            *pStkClone << psClone ;
            pBatonTree->ungrabF( tinP ) ;
            pTree->writeF( tinP , *psClone ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( psClone )
        etherP( tinP , psClone , TAG( TAGiDnULL ) ) ;
        ZE( soulC* , psClone ) ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT key_plusF( tinS& tinP , etherC& etherP )

}
    }
        pBatonTree->ungrabF( tinP ) ;
        }
            pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
            *pStkActionMemory << (countT)ifcIDiNTERCOM_KEY_z ;
        
            incv02AM( cRequestFresh ) ;
            readStateF( tinP , etherP , *pTree ) ;
            pTree->delF( tinP ) ;
            while( pTree->downF( tinP ) ) ;
            //U::ELIMINATE THE READ, AND INSTEAD JUST RESTORE MY DIRECTIONS
            //THIS BLOCK TAKES TIME AND CAN BE ELIMINATED WHEN HAVE CONFIDENCE IN writeStateF
        
            writeStateF( tinP , etherP , *pTree ) ;
        {
        if( bStateHasChanged )
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT key_zF( tinS& tinP , etherC& etherP )

voidT readStateF( tinS& tinP , etherC& etherP , treeOldC& treeP ) ;

}
    }
        _OUT_
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_KEY_w ;
        writeF( tinP , etherP , T("///desk/")+tShort , *pTree ) ;
    
        //}
        //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
        //
        //    //LOGrAW( "------------------------- END ------------------------\r\n" ) ;
        //    etherP.beeClickF( tinP , TOCK * 0x20 ) ;
        //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_DISABLE ) ;
        //
        //    while( cToDo -- ) writeF( tinP , etherP , T("///desk/")+tShort , *pTree ) ;
        //    countT cToDo = 0x1 ;
        //    
        //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_ENABLE ) ;
        //    etherP.beeClickF( tinP , TOCK * 0x20 ) ;
        //    //LOGrAW( "------------------------- BEGIN ------------------------\r\n" ) ;
        //    etherP.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
        //{
        //USE TO STUDY WHERE WHILE WRITING FILE
    
        TN( tShort , "ideafarm.kt.append.any.name.here" ) ;
        key_oF( tinP , etherP , wP , 1 ) ;
        _INoLD_
    {
    if( !bToolTest && !bToolTestHire )
{
voidT key_wF( tinS& tinP , etherC& etherP , windowOldC& wP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_KEY_t ;
    
        pBatonTree->ungrabF( tinP ) ;
        }
            else                                                                         *pTxtGuide = T("you have completed the tutorial!") ;
            else if(    !cFilesIn                                                      ) { *pTxtGuide = T("key 'o' and drop the file into the KT depository") ; bSuppressSessionEnd = 1 ; }
            else if(    !cFoundF( tinP , *pStkActionMemory , ifcIDiNTERCOM_KEY_p     ) ) *pTxtGuide = T("key 'p' to prune (discard) the current branch") ;
            else if(    !cFoundF( tinP , *pStkActionMemory , ifcIDiNTERCOM_KEY_w     ) ) *pTxtGuide = T("key 'w' to write a knowledge tree file") ;
            else if( 2 > cFoundF( tinP , *pStkActionMemory , ifcIDiNTERCOM_DOWNaRROW ) ) *pTxtGuide = T("key DOWN ARROW to climb down") ;
                 if(    !cFoundF( tinP , *pStkActionMemory , ifcIDiNTERCOM_PLUS      ) ) *pTxtGuide = T("key '+' to copy this branch to the clone stack") ;
        {
        else if( !pTree->bEmptyF( tinP ) )
        }
            }
                default                  : { *pTxtGuide = T("key 'g' to graft the top item (of ")+TF1(*pStkClone)+T(") on the clone stack") ; break ; }
                case ifcIDiNTERCOM_KEY_g : { *pTxtGuide = T("key '-' to discard the top item on the clone stack") ; break ; }
            {
            switch( (*pStkActionMemory)[ 1 ] )
        {
        else if( *pStkClone )
        else if( bEntry ) *pTxtGuide = T("tab to \"climb\"") ;
        else if( !cEntryArrivals ) *pTxtGuide = T("tab to \"entry\" and stroke the tree (enter some text)") ;
        else if( !cFoundF( tinP , *pStkActionMemory , ifcIDiNTERCOM_KEY_p     ) ) *pTxtGuide = T("key 'p' to prune (discard) the current branch") ;
        else if( !cFoundF( tinP , *pStkActionMemory , ifcIDiNTERCOM_DOWNaRROW ) ) *pTxtGuide = T("key DOWN ARROW to climb down") ;
        else if( !cFoundF( tinP , *pStkActionMemory , ifcIDiNTERCOM_KEY_s     ) ) *pTxtGuide = T("key 's' to view nearby branches") ;
        else if( !cFoundF( tinP , *pStkActionMemory , ifcIDiNTERCOM_KEY_h     ) ) *pTxtGuide = T("key 'h' to view only the current branch") ;
             if( !cFoundF( tinP , *pStkActionMemory , ifcIDiNTERCOM_KEY_o     ) ) { *pTxtGuide = T("key 'o' to display the base operating system console") ; bSuppressSessionEnd = 1 ; }
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else
    if( bToolTest || bToolTestHire ) *pTxtGuide = T("mouse click 'k' to return to the normal display (pressing 'k' key won't work!)") ;
{
voidT key_tF( tinS& tinP )

}
    return cFound ;
    }
        while( ~hWalk ) ;
        }
            if( vv == cP ) cFound ++ ;
            countT vv = stP.downF( tinP , hWalk ) ;
        {
        do
        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stP )
    ZE( boolT , cFound ) ;
{
boolT cFoundF( tinS& tinP , stackC& stP , const countT cP )

}
    key_zF( tinP , etherP ) ;
    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
    *pStkActionMemory << (countT)ifcIDiNTERCOM_KEY_o ;

    }
        }
            }
                etherP.boxPutF( tinP , TmESSAGEtIMElATHfILE , (byteT*)&timeLath , sizeof timeLath ) ;
                timeLath.time2 = timeN2 ;
                timeLath.time1 = timeN1 ;
                    
                etherP.osHttpViewF( tinP , T("www.ideafarm.com//http/id15.html") , 1 ) ;
            {
            if( timeD2 >= 8 )
                    
            etherP.osTimeSubtractF( tinP , timeD1 , timeD2 , timeLath.time1 , timeLath.time2 ) ;
            sCountT timeD2 = timeN2 ;
            countT  timeD1 = timeN1 ;
                    
            etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
                    
            }
                etherP.delF( tinP , pbTimeLath ) ;
                else if( cbTimeLath == sizeof timeLath ) etherP.memCopyF( tinP , (byteT*)&timeLath , pbTimeLath , sizeof timeLath ) ;
                if( POOP ) POOPR
                tinP.pEtScratch->boxGetShadowF( tinP , pbTimeLath , cbTimeLath , TmESSAGEtIMElATHfILE , 1 ) ; ___( pbTimeLath ) ; //U::A soulC SHOULD BE USED TO STORE THIS TIME ON DISK, SO WILL WORK ON EITHER ENDIAN BASE O.S.'S
                ZE( countT , cbTimeLath ) ;
                ZE( byteT* , pbTimeLath ) ;
                    
                SCOOPS
            {
            timeS timeLath ;
        {
        IFsCRATCH
            
        etherP.osTimeAddF( tinP , timeSessionTotal1 , timeSessionTotal2 , timeSessionEnd1 , timeSessionEnd2 ) ;
        etherP.osTimeSubtractF( tinP , timeSessionEnd1 , timeSessionEnd2 , timeSessionStart1 , timeSessionStart2 ) ;
        etherP.osTimeNowF( tinP , timeSessionEnd1 , timeSessionEnd2 ) ;
        ZE( sCountT , timeSessionEnd2 ) ;
        ZE( countT  , timeSessionEnd1 ) ;
    
        bInSession = 0 ;
    {
    else if( !bContinueSessionP )
    if( bSuppressSessionEnd ) bSuppressSessionEnd = 0 ;

    ((thirdC&)etherP).winShowWindowF( tinP , wP , idcWINsHOW_HIDE ) ;
{
voidT key_oF( tinS& tinP , etherC& etherP , windowOldC& wP , const boolT bContinueSessionP = 0 )

voidT key_zF( tinS& tinP , etherC& etherP ) ;

voidT writeStateF( tinS& tinP , etherC& etherP , treeOldC& treeP ) ;

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_KEY_m ;
        *pTxtGuide = T(bNumericEntry?"numeric":"alphabetic")+T(" interpretation of digit keys and keys 'a'-'f'") ;
        bNumericEntry = !bNumericEntry ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT key_mF( tinS& tinP )

}
    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
    *pStkActionMemory << (countT)ifcIDiNTERCOM_KEY_k ;

    wP.baton.ungrabF( tinP ) ;

    }
        *pTxtGuide = T("tool test display") ;
        key_hF( tinP ) ;
        idTypeDisplaySave = idTypeDisplay ;
        bToolTestHire = 1 ;
    {
    else
    }
        *pTxtTools = *pTxtToolsMemory = T("") ;
        *pTxtGuide = T("normal display") ;
        }
            case ifcIDtYPEdISPLAY_HOLLYWOOD : { key_sF( tinP ) ; break ; }
            case ifcIDtYPEdISPLAY_HUGE      : { key_hF( tinP ) ; break ; }
        {
        switch( idTypeDisplaySave )
        bToolTest = 0 ;
    {
    if( bToolTest )

    wP.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;

    static countT idTypeDisplaySave ;
{
voidT key_kF( tinS& tinP , windowOldC& wP )

voidT key_sF( tinS& tinP ) ;

}
    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
    *pStkActionMemory << (countT)ifcIDiNTERCOM_KEY_h ;
    incv02AM( cRequestFresh ) ;
    pBatonTree->ungrabF( tinP ) ;
    bStateHasChanged = 1 ;
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    idTypeDisplay = ifcIDtYPEdISPLAY_HUGE ;
{
voidT key_hF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_KEY_g ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        if( !bDownOk ) upArrowF( tinP , etherP ) ;
        bGraft = 1 ;
    {
    if( !bToolTest && !bToolTestHire )
{
voidT key_gF( tinS& tinP , etherC& etherP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_OUTaRROW ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->outF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bOutOk )
    if( bToolTest || bToolTestHire ) ;
{
voidT outArrowF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_INaRROW ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->inF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bInOk )
    if( bToolTest || bToolTestHire ) ;
{
voidT inArrowF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_RIGHTaRROW ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->rightF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bRightOk )
    }
        }
            pBatonTree->ungrabF( tinP ) ;
            pTree->ungrabF( tinP ) ;
            }
                etherP( tinP , psClone ) ;
                }
                    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
                    *pStkActionMemory << (countT)ifcIDiNTERCOM_RIGHTaRROW ;
                    incv02AM( cRequestFresh ) ;
                    bStateHasChanged = 1 ;
                    pTree->upF( tinP ) ;
                    pTree->readF( tinP , *psClone , *pEtPrime ) ;
                    pTree->downF( tinP ) ;
                                
                    pTree->writeF( tinP , *psClone , T("") ) ;
                {
                if( psClone )
                etherP( tinP , psClone , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psClone ) ;
            {
            if( pData )
            branchDataOldS* pData = *pTree ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( bHaveStrokes )
    {
    else if( bEntry )
    }
        pStkClone->ungrabF( tinP ) ;
        }
            incv02AM( cRequestFresh ) ;
            pBatonTree->ungrabF( tinP ) ;
            bStateHasChanged = 1 ;
            pTree->ungrabF( tinP ) ;
            pTree->upF( tinP ) ;
            pTree->readF( tinP , sClone , *pEtPrime ) ;
            pTree->downF( tinP ) ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            soulC& sClone = *(soulC*)(*pStkClone)[ 1 ] ;
        {
        if( *pStkClone )
        pStkClone->grabF( tinP , TAG( TAGiDnULL ) ) ;
        bGraft = 0 ;
    {
    else if( bGraft )
    if( bToolTest || bToolTestHire ) ;
{
voidT rightArrowF( tinS& tinP , etherC& etherP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_END ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        while( pTree->leftF( tinP ) ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bLeftOk )
    if( bToolTest || bToolTestHire ) ;
{
voidT endF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_HOME ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        while( pTree->rightF( tinP ) ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bRightOk )
    if( bToolTest || bToolTestHire ) ;
{
voidT homeIF( tinS& tinP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_LEFTaRROW ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->leftF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bLeftOk )
    }
        }
            pBatonTree->ungrabF( tinP ) ;
            pTree->ungrabF( tinP ) ;
            }
                etherP( tinP , psClone ) ;
                }
                    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
                    *pStkActionMemory << (countT)ifcIDiNTERCOM_RIGHTaRROW ;
                    incv02AM( cRequestFresh ) ;
                    bStateHasChanged = 1 ;
                    pTree->upF( tinP ) ;
                    pTree->readF( tinP , *psClone , *pEtPrime , 0 , 1 ) ;
                    pTree->downF( tinP ) ;
                                
                    pTree->writeF( tinP , *psClone , T("") ) ;
                {
                if( psClone )
                etherP( tinP , psClone , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psClone ) ;
            {
            if( pData )
            branchDataOldS* pData = *pTree ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( bHaveStrokes )
    {
    else if( bEntry )
    }
        pStkClone->ungrabF( tinP ) ;
        }
            incv02AM( cRequestFresh ) ;
            pBatonTree->ungrabF( tinP ) ;
            bStateHasChanged = 1 ;
            pTree->ungrabF( tinP ) ;
            pTree->upF( tinP ) ;
            pTree->readF( tinP , sClone , *pEtPrime , 0 , 1 ) ;
            pTree->downF( tinP ) ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            soulC& sClone = *(soulC*)(*pStkClone)[ 1 ] ;
        {
        if( *pStkClone )
        pStkClone->grabF( tinP , TAG( TAGiDnULL ) ) ;
        bGraft = 0 ;
    {
    else if( bGraft )
    if( bToolTest || bToolTestHire ) ;
{
voidT leftArrowF( tinS& tinP , etherC& etherP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_UPaRROW ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->upF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bUpOk )
    }
        }
            pBatonTree->ungrabF( tinP ) ;
            pTree->ungrabF( tinP ) ;
            }
                etherP( tinP , psClone ) ;
                }
                    pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
                    *pStkActionMemory << (countT)ifcIDiNTERCOM_UPaRROW ;
                    incv02AM( cRequestFresh ) ;
                    bStateHasChanged = 1 ;
                    pTree->rightF( tinP ) ;
                    pTree->upF( tinP ) ;
                    pTree->readF( tinP , *psClone , *pEtPrime ) ;
                                
                    pTree->writeF( tinP , *psClone , T("") ) ;
                {
                if( psClone )
                etherP( tinP , psClone , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psClone ) ;
            {
            if( pData )
            branchDataOldS* pData = *pTree ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( bHaveStrokes )
    {
    else if( bEntry )
    }
        pStkClone->ungrabF( tinP ) ;
        }
            incv02AM( cRequestFresh ) ;
            pBatonTree->ungrabF( tinP ) ;
            bStateHasChanged = 1 ;
            pTree->ungrabF( tinP ) ;
            pTree->upF( tinP ) ;
            pTree->readF( tinP , sClone , *pEtPrime ) ;
            pTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
            soulC& sClone = *(soulC*)(*pStkClone)[ 1 ] ;
        {
        if( *pStkClone )
        pStkClone->grabF( tinP , TAG( TAGiDnULL ) ) ;
        bGraft = 0 ;
    {
    else if( bGraft )
    if( bToolTest || bToolTestHire ) ;
{
voidT upArrowF( tinS& tinP , etherC& etherP )

}
    }
        pStkActionMemory->purgeF( tinP , CaCTIONmEMORY ) ;
        *pStkActionMemory << (countT)ifcIDiNTERCOM_DOWNaRROW ;
        incv02AM( cRequestFresh ) ;
        pBatonTree->ungrabF( tinP ) ;
        bStateHasChanged = 1 ;
        pTree->downF( tinP ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    else if( bDownOk )
    if( bToolTest || bToolTestHire ) ;
{
voidT downArrowF( tinS& tinP )

}
    etherP.strFuseF( tinP , psttP , drawerP.pstt3 ) ; ___( psttP ) ;

    }
        etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW7 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW6 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        //BRO2 (MUST BE LATH RENDERED SO STROKE ENTRY CAN STROKE IMMEDIATE INTO MY AREA
    {
    else
    }
        //etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
        etherP.strFuseF( tinP , psttP , bs.ppsttzDnBros[ 0 ] ) ;
        etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW7 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW6 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        //BRO2 (MUST BE LATH RENDERED SO STROKE ENTRY CAN STROKE IMMEDIATE INTO MY AREA

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzUpBros[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW7 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW6 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;
            //BRO3
        {
        if( bs.cUpBros   )
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnBros[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW7 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW6 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
            //BRO1
        {
        if( bs.cDnBros   )
    {
    if( bs.ppsttzDnBros  )
    
    }
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzUpMoms[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW6 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW5 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;
        {
        if( bs.cUpMoms && bs.ppsttzUpMoms[ 1 ] )
        //MOM3

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnMoms[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW6 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW5 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
        {
        if( bs.cDnMoms && bs.ppsttzDnMoms[ 1 ] )
        //MOM1

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnMoms[ 0 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW6 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW5 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        {
        if( bs.ppsttzDnMoms[ 0 ] )
        //MOM2
    {
    if( bs.ppsttzDnMoms )
    
    }
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzUpDads[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW5 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW4 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;
            //DAD3
        {
        if( bs.cUpDads   )
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnDads[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW5 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW4 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
            //DAD1
        {
        if( bs.cDnDads   )

        etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
        etherP.strFuseF( tinP , psttP , bs.ppsttzDnDads[ 0 ] ) ;
        etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW5 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW4 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        //DAD2
    {
    if( bs.ppsttzDnDads  )
    
    }
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzUpGMoms[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW4 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW3 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;
        {
        if( bs.cUpGMoms  && bs.ppsttzUpGMoms[ 1 ] )
        //GmOM3

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnGMoms[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW4 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW3 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
        {
        if( bs.cDnGMoms  && bs.ppsttzDnGMoms[ 1 ] )
        //GmOM1

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnGMoms[ 0 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW4 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW3 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        {
        if( bs.ppsttzDnGMoms[ 0 ] )
        //GmOM2
    {
    if( bs.ppsttzDnGMoms )
    
    }
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzUpGDads[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW3 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW2 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;
            //GdAD3
        {
        if( bs.cUpGDads  )
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnGDads[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW3 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW2 ;
            *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
            //GdAD1
        {
        if( bs.cDnGDads  )

        etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
        etherP.strFuseF( tinP , psttP , bs.ppsttzDnGDads[ 0 ] ) ;
        etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologMale ) ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].cNote  = ROW3 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].cNote  = ROW2 ;
        *(measureT*)&drawerP.psttBranchPrologMale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        //GdAD2
    {
    if( bs.ppsttzDnGDads )
    
    }
        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzUpGGMoms[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW2 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL4 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW1 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL3 ;
        {
        if( bs.cUpGGMoms && bs.ppsttzUpGGMoms[ 1 ] )
        //GGmOM3

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnGGMoms[ 1 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW2 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL2 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW1 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL1 ;
        {
        if( bs.cDnGGMoms && bs.ppsttzDnGGMoms[ 1 ] )
        //GGmOM1

        }
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchEpilog ) ;
            etherP.strFuseF( tinP , psttP , bs.ppsttzDnGGMoms[ 0 ] ) ;
            etherP.strFuseF( tinP , psttP , drawerP.psttBranchPrologFemale ) ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].cNote  = ROW2 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 5 ].idAdam = COL3 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].cNote  = ROW1 ;
            *(measureT*)&drawerP.psttBranchPrologFemale[ CSpREFIX - 1 + 2 ].idAdam = COL2 ;
        {
        if( bs.ppsttzDnGGMoms[ 0 ] )
        //GGmOM2
    {
    if( bs.ppsttzDnGGMoms )
    //FEMALE VALUES CAN BE 0; MALE VALUES CANNOT; THAT IS WHY THE CHECK IS MADE FOR FEMALES ONLY

    etherP.strFuseF( tinP , psttP , drawerP.pstt2 ) ;

    if( bUpOk ) etherP.strFuseF( tinP , psttP , drawerP.psttUpHint ) ;

    etherP.strFuseF( tinP , psttP , drawerP.psttHighBorder ) ; //GIVES TOP CENTER A YELLOW BORDER
    etherP.strFuseF( tinP , psttP , drawerP.pstt1 ) ;

    pBatonTree->ungrabF( tinP ) ;
    treeP.nearbyF( tinP , bs ) ;
    pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
    bs.cUpGKids = 1 ;
    bs.cDnGKids =
    bs.cUpKids =
    bs.cDnKids =
    bs.cUpWives =
    bs.cDnWives =
    bs.cUpBros =
    bs.cDnBros =
    bs.cUpMoms =
    bs.cDnMoms =
    bs.cUpDads =
    bs.cDnDads =
    bs.cUpGMoms =
    bs.cDnGMoms =
    bs.cUpGDads =
    bs.cDnGDads =
    bs.cUpGGMoms =
    bs.cDnGGMoms =
    branchesOldS bs ;
{
voidT tHollywoodF( tinS& tinP , etherC& etherP , strokeS*& psttP , treeOldC& treeP , drawerHollywoodS& drawerP )

}
    ) ; ___( pstt3 ) ;
    
        S2(0,scOld_WRAPoFF)
        T("")+
    
    etherP.strMakeF( tinP , pstt3 , 

    ) ; ___( psttHighBorder ) ;

        S2(0,scOld_POPfRAMEdETACH)
        S2(0,scOld_POPcOLOR)+
        S3(COL2,scOld_mmLINEtO,ROW6)+
        S3(COL2,scOld_mmLINEtO,ROW7)+
        S3(COL3,scOld_mmLINEtO,ROW7)+
        S3(COL3,scOld_mmLINEtO,ROW6)+
        S3(COL2,scOld_mmMOVEtO,ROW6)+
        S2(0x00ffff,scOld_cPUSHcOLOR)+
        S2(0,scOld_POPcOLOR)+
        S3(COL2,scOld_mmLINEtO,ROW6)+
        S3(COL2,scOld_mmLINEtO,ROW7)+
        S3(COL3,scOld_mmLINEtO,ROW7)+
        S3(COL3,scOld_mmLINEtO,ROW6)+
        S3(COL2,scOld_mmMOVEtO,ROW6)+
        S2(0x0000ff,scOld_cPUSHcOLOR)+
        S2(0,scOld_FRAMEdETACH)+
        T("")+

    etherP.strMakeF( tinP , psttHighBorder , 

    ) ; ___( psttBranchEpilog ) ;

        S2(0,scOld_POPfRAME)
        S2(0,scOld_POPfRAME)+
        S2(0,scOld_WRAPoFF)+
        T("")+

    etherP.strMakeF( tinP , psttBranchEpilog , 

    ) ; ___( psttBranchPrologMale ) ;

        S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)
        S2(0,scOld_WRAPoN)+
        S3(MSC,scOld_mmFRAMEtO,MSR)+
        //CONTENT
        S3(0.0,scOld_mmFRAMEpELtO,0.0)+
        S2(0,scOld_cOVERRIDEnEXTsTROKE)+
        S2(0,scOld_POPfRAMEdETACH)+
        S3(-9.0,scOld_mmMOVEpEL,-9.0)+
        S3(COL2,scOld_mmMOVEtO,ROW3)+                                //5: PATCH idAdam,cNote
        S2(0,scOld_PUSHoVERRIDEcOLrOW)+   //4
        S3(9.0,scOld_mmMOVEpEL,9.0)+                                 //3
        S3(COL1,scOld_mmMOVEtO,ROW2)+                                //2: PATCH idAdam,cNote
        S2(0,scOld_FRAMEdETACH)+                       //1
        T("")+

    etherP.strMakeF( tinP , psttBranchPrologMale , 

    ) ; ___( psttBranchPrologFemale ) ;

        S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)
        S2(0,scOld_WRAPoN)+
        S3(FSC,scOld_mmFRAMEtO,FSR)+
        //CONTENT
        S3(0.0,scOld_mmFRAMEpELtO,0.0)+
        S2(0,scOld_cOVERRIDEnEXTsTROKE)+
        S2(0,scOld_POPfRAMEdETACH)+
        S3(-9.0,scOld_mmMOVEpEL,-3.0)+
        S3(COL2,scOld_mmMOVEtO,ROW2)+                                //5: PATCH idAdam,cNote
        S2(0,scOld_PUSHoVERRIDEcOLrOW)+   //4
        S3(9.0,scOld_mmMOVEpEL,3.0)+                                 //3
        S3(COL1,scOld_mmMOVEtO,ROW1)+                                //2: PATCH idAdam,cNote
        S2(0,scOld_FRAMEdETACH)+                       //1
        T("")+

    etherP.strMakeF( tinP , psttBranchPrologFemale , 

    ) ; ___( pstt2 ) ;

        S2(0,scOld_POPfRAME)
        S2(0,scOld_POPfRAMEdETACH)+
        S2(0,scOld_POPcOLOR)+
        T("")+
        //CLEANUP FOR HINTS

    etherP.strMakeF( tinP , pstt2 , 

    ) ; ___( psttUpHint ) ;

        S3(16.0,scOld_mmLINEeNDpEL,-16.0)
        S3(16.0,scOld_mmLINEpEL,16.0)+
        S3(-16.0,scOld_mmMOVEpEL,-16.0)+
        S3(0.0,scOld_mmLINEpEL,32.0)+
        S3(-32.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL3,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttUpHint , 

    ) ; ___( pstt1 ) ;

        S2(0x00ffff,scOld_cPUSHcOLOR)
        S2(0,scOld_FRAMEdETACH)+
        S3(1.0,scOld_mmFRAMEtO,1.0)+
        S3(0.0,scOld_mmMOVEtO,0.0)+
        //SET UP FOR HINTS

        S2(0,scOld_POPfRAMEdETACH)+
        S2(0,scOld_POPcOLOR)+

        S3(1.0,scOld_mmLINEtO,2.0/3.0+1.0/32.0)+
        S3(0.0,scOld_mmMOVEtO,2.0/3.0+1.0/32.0)+

        S3(1.0,scOld_mmLINEtO,2.0/3.0)+
        S3(0.0,scOld_mmMOVEtO,2.0/3.0)+

        S3(1.0,scOld_mmLINEtO,1.0/3.0+1.0/32.0)+
        S3(0.0,scOld_mmMOVEtO,1.0/3.0+1.0/32.0)+

        S3(1.0,scOld_mmLINEtO,1.0/3.0)+
        S3(0.0,scOld_mmMOVEtO,1.0/3.0)+

        S3(1.0,scOld_mmLINEtO,1.0/32.0)+
        S3(0.0,scOld_mmMOVEtO,1.0/32.0)+

        S3(2.0/3.0,scOld_mmLINEtO,1.0)+
        S3(2.0/3.0,scOld_mmMOVEtO,0.0)+
        S3(1.0/3.0,scOld_mmLINEtO,1.0)+
        S3(1.0/3.0,scOld_mmMOVEtO,0.0)+

        S3(0.0,scOld_mmLINEtO,0.0)+
        S3(0.0,scOld_mmLINEtO,1.0)+
        S3(1.0,scOld_mmLINEtO,1.0)+
        S3(1.0,scOld_mmLINEtO,0.0)+

        S2(0x0000ff,scOld_cPUSHcOLOR)+
        S2(0,scOld_FRAMEdETACH)+

        //RED GRID

        T("")+

    etherP.strMakeF( tinP , pstt1 , 
{
pstt3( 0 )
psttHighBorder( 0 ) ,
psttBranchPrologMale( 0 ) ,
psttBranchPrologFemale( 0 ) ,
psttBranchEpilog( 0 ) ,
pstt2( 0 ) ,
psttUpHint( 0 ) ,
pstt1( 0 ) ,
drawerHollywoodS::drawerHollywoodS( tinS& tinP , etherC& etherP ) :

}
    PUSE( tinP , *(voidT**)&pstt3 ) ;
    PUSE( tinP , *(voidT**)&psttHighBorder ) ;
    PUSE( tinP , *(voidT**)&psttBranchEpilog ) ;
    PUSE( tinP , *(voidT**)&psttBranchPrologMale ) ;
    PUSE( tinP , *(voidT**)&psttBranchPrologFemale ) ;
    PUSE( tinP , *(voidT**)&pstt2 ) ;
    PUSE( tinP , *(voidT**)&psttUpHint ) ;
    PUSE( tinP , *(voidT**)&pstt1 ) ;
    TINSL
{
drawerHollywoodS::~drawerHollywoodS( voidT )

;
}
    drawerHollywoodS( tinS& tinP , etherC& etherP ) ;
    ~drawerHollywoodS( voidT ) ;

    strokeS* pstt3 ;
    strokeS* psttHighBorder ;
    strokeS* psttBranchEpilog ;
    strokeS* psttBranchPrologMale ;
    strokeS* psttBranchPrologFemale ;
    strokeS* pstt2 ;
    strokeS* psttUpHint ;
    strokeS* pstt1 ;
{
struct drawerHollywoodS

}
    etherP.strFuseF( tinP , psttP , drawerP.pstt3 ) ; ___( psttP ) ;

    }
        if( bs.ppsttzDnBros ) { etherP.strFuseF( tinP , psttP , *bs.ppsttzDnBros ) ; ___( psttP ) ; }
        pBatonTree->ungrabF( tinP ) ;
        treeP.nearbyF( tinP , bs ) ;
        pBatonTree->grabF( tinP , TAG( TAGiDnULL ) ) ;
        branchesOldS bs ;
    {
    if( !bToolTest && !bToolTestHire )

    etherP.strFuseF( tinP , psttP , drawerP.pstt2 ) ; ___( psttP ) ;

    }
        if( bOutOk   ) { etherP.strFuseF( tinP , psttP , drawerP.psttOutHint   ) ; ___( psttP ) ; }
        if( bInOk    ) { etherP.strFuseF( tinP , psttP , drawerP.psttInHint    ) ; ___( psttP ) ; }
        if( bRightOk ) { etherP.strFuseF( tinP , psttP , drawerP.psttRightHint ) ; ___( psttP ) ; }
        if( bLeftOk  ) { etherP.strFuseF( tinP , psttP , drawerP.psttLeftHint  ) ; ___( psttP ) ; }
        if( bUpOk    ) { etherP.strFuseF( tinP , psttP , drawerP.psttUpHint    ) ; ___( psttP ) ; }
        if( bDownOk  ) { etherP.strFuseF( tinP , psttP , drawerP.psttDownHint  ) ; ___( psttP ) ; }
    {
    if( !bToolTest && !bToolTestHire )

    etherP.strFuseF( tinP , psttP , drawerP.pstt1 ) ; ___( psttP ) ;
{
voidT tHugeF( tinS& tinP , etherC& etherP , strokeS*& psttP , treeOldC& treeP , drawerHugeS& drawerP )

}
    //) ; ___( pstt2 ) ;
    //
    //    S2(0,scOld_POPfRAME)
    //    S2(0,scOld_WRAPoFF)+
    //    T("")+
    //
    //etherP.strMakeF( tinP , pstt2 , 
    //THIS IS THE OLD EPILOG; NOW I DON'T DO THIS TO ALLOW STROKE ENTRY TO APPEND STROKES TO MY IMAGE

    ) ; ___( pstt3 ) ;
    
        S2(0,scOld_WRAPoFF)
        T("")+
    
    etherP.strMakeF( tinP , pstt3 , 

    ) ; ___( pstt2 ) ;

        S2(0,scOld_MOVEuPrIGHTfORaDAMfRAME)
        S2(0,scOld_WRAPoN)+
        S3(1.0/220.0,scOld_mmFRAMEtO,1.0/24.0)+
        //STROKING FRAME SETUP
        
        S3(0.0,scOld_mmFRAMEpELtO,0.0)+
        S2(0,scOld_cOVERRIDEnEXTsTROKE)+
        S2(0,scOld_POPfRAMEdETACH)+
        S3(-9.0,scOld_mmMOVEpEL,-9.0)+
        S3(1.0,scOld_mmMOVEtO,1.0)+
        S2(0,scOld_PUSHoVERRIDEcOLrOW)+
        S3(9.0,scOld_mmMOVEpEL,9.0)+
        S2(0,scOld_FRAMEdETACH)+
        //CONTENT FRAME

        S2(0,scOld_POPfRAME)+
        S2(0,scOld_POPfRAMEdETACH)+
        S2(0,scOld_POPcOLOR)+
        T("")+
        //CLEANUP FOR HINTS

    etherP.strMakeF( tinP , pstt2 , 

    ) ; ___( psttOutHint ) ;

        S3(16.0,scOld_mmLINEpEL,16.0)
        S3(-48.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL4,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttOutHint , 

    ) ; ___( psttInHint ) ;

        S3(-16.0,scOld_mmLINEpEL,-16.0)
        S3(-48.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL4,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttInHint , 

    ) ; ___( psttRightHint ) ;

        S3(-12.0,scOld_mmLINEeNDpEL,12.0)
        S3(12.0,scOld_mmLINEpEL,12.0)+
        S3(-12.0,scOld_mmMOVEpEL,-12.0)+
        S3(32.0,scOld_mmLINEpEL,0.0)+
        S3(-48.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL4,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttRightHint , 

    ) ; ___( psttLeftHint ) ;

        S3(12.0,scOld_mmLINEeNDpEL,12.0)
        S3(-12.0,scOld_mmLINEpEL,12.0)+
        S3(12.0,scOld_mmMOVEpEL,-12.0)+
        S3(-32.0,scOld_mmLINEpEL,0.0)+
        S3(-48.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL4,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttLeftHint , 

    ) ; ___( psttUpHint ) ;

        S3(12.0,scOld_mmLINEeNDpEL,-12.0)
        S3(12.0,scOld_mmLINEpEL,12.0)+
        S3(-12.0,scOld_mmMOVEpEL,-12.0)+
        S3(0.0,scOld_mmLINEpEL,32.0)+
        S3(-48.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL4,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttUpHint , 

    ) ; ___( psttDownHint ) ;

        S3(12.0,scOld_mmLINEeNDpEL,12.0)
        S3(12.0,scOld_mmLINEpEL,-12.0)+
        S3(-12.0,scOld_mmMOVEpEL,12.0)+
        S3(0.0,scOld_mmLINEpEL,-32.0)+
        S3(-48.0,scOld_mmMOVEpEL,-48.0)+
        S3(COL4,scOld_mmMOVEtO,ROW7)+
        T("")+

    etherP.strMakeF( tinP , psttDownHint , 

    ) ; ___( pstt1 ) ;

        S2(0x00ffff,scOld_cPUSHcOLOR)
        S2(0,scOld_FRAMEdETACH)+
        S3(1.0,scOld_mmFRAMEtO,1.0)+
        //SET UP FOR HINTS

        S2(0,scOld_POPfRAMEdETACH)+
        S2(0,scOld_POPcOLOR)+
        S3(0.0,scOld_mmLINEtO,0.0)+
        S3(0.0,scOld_mmLINEtO,1.0)+
        S3(1.0,scOld_mmLINEtO,1.0)+
        S3(1.0,scOld_mmLINEtO,0.0)+
        S2(0x0000ff,scOld_cPUSHcOLOR)+
        S2(0,scOld_FRAMEdETACH)+
        //RED BORDER

        T("")+

    etherP.strMakeF( tinP , pstt1 , 
{
pstt3( 0 )
pstt2( 0 ) ,
pstt1( 0 ) ,
psttOutHint( 0 ) ,
psttInHint( 0 ) ,
psttRightHint( 0 ) ,
psttLeftHint( 0 ) ,
psttUpHint( 0 ) ,
psttDownHint( 0 ) ,
drawerHugeS::drawerHugeS( tinS& tinP , etherC& etherP ) :

voidT writeF( tinS& tinP , etherC& etherP , const strokeS* const psttP , treeOldC& treeP , const boolT bWholeP = 0 ) ;

}
    PUSE( tinP , *(voidT**)&pstt3 ) ;
    PUSE( tinP , *(voidT**)&pstt2 ) ;
    PUSE( tinP , *(voidT**)&pstt1 ) ;
    PUSE( tinP , *(voidT**)&psttOutHint ) ;
    PUSE( tinP , *(voidT**)&psttInHint ) ;
    PUSE( tinP , *(voidT**)&psttRightHint ) ;
    PUSE( tinP , *(voidT**)&psttLeftHint ) ;
    PUSE( tinP , *(voidT**)&psttUpHint ) ;
    PUSE( tinP , *(voidT**)&psttDownHint ) ;
    TINSL
{
drawerHugeS::~drawerHugeS( voidT )

;
}
    drawerHugeS( tinS& tinP , etherC& etherP ) ;
    ~drawerHugeS( voidT ) ;

    strokeS* pstt3 ;
    strokeS* pstt2 ;
    strokeS* pstt1 ;
    strokeS* psttOutHint ;
    strokeS* psttInHint ;
    strokeS* psttRightHint ;
    strokeS* psttLeftHint ;
    strokeS* psttUpHint ;
    strokeS* psttDownHint ;
{
struct drawerHugeS

//;
//
//    " ac\r\n"
//    "  abc\r\n"
//    "  abb\r\n"
//    "  aba\r\n"
//    " ab\r\n"
//    " aa\r\n"
//    "a\r\n"
//
//osTextT postGuide[] =

//;
//
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "                aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "               aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "              aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "             aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "            aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "           aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "          aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "         aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "        aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "       aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "      aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "     aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "    aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "   aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "  aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    " aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa\r\n"
//    "this is a very large kt\r\n"
//
//osTextT postGuide[] =

;

    " cap lock must be off!\r\n"
    " use the mouse when entering text\r\n"
    " mouse click \"tutor\" or key 't'\r\n"
    "\"tutor\" will guide you\r\n"

osTextT postGuide[] =

boolT  bSuppressSessionEnd ;
textC* pTxtBlank ;
textC* pTxtNull ;
strokeS  psttzMousePosition[ CSpREFIX + 0x80 ] ;
strokeS  psttzJoy2Position[ CSpREFIX + 0x80 ] ;
strokeS  psttzJoy1Position[ CSpREFIX + 0x80 ] ;
strokeS* psttzOffUp ;
strokeS* psttzOffDown ;
strokeS* psttzOnUp ;
strokeS* psttzOnDown ;
strokeS* psttzAbsent2 ;
strokeS* psttzAbsent ;
strokeS  ppsttvJoy[ 2 ][ 0x80 ] ;
batonC*  ppBaton_psttvJoy[ 2 ] ;
strokeS  psttvWheel[ 0x80 ] ;
batonC*  pBaton_psttvWheel ;
strokeS* ppsttvbToolState[ ifcIDtYPEtOOL_end - ifcIDtYPEtOOL_begin - 1 ] ;
batonC*  pBaton_ppsttvbToolState ;
sCountT timeSessionTotal2 ;
countT  timeSessionTotal1 ;
sCountT timeSessionStart2 ;
countT  timeSessionStart1 ;
boolT   bInSession ;
countT  idSession ;
etherC* pEtPrime ;
boolT   bStateHasChanged ;
stackC* pStkFind ;
textC*  pTxtFind ;
boolT   bTestingTools ;
boolT   bToolTestHire ;
boolT   bToolTest ;
boolT   bNumericEntry ;
textC* pTxtLogo ;
sCountT timeGuideAge2 ;
countT  timeGuideAge1 ;
textC* pTxtToolsMemory ;
textC* pTxtTools ;
textC* pTxtGuideMemory ;
textC* pTxtGuide ;
countT cEntryArrivals ;//JUST USED BY TUTORIAL
boolT  bHaveStrokes ;
boolT  bFind ;
boolT  bEntry ;
boolT  bGraft ;
countT idThreadRefresh ;
countT cFilesIn ;
stackC* pStkActionMemory ;
stackC* pStkClone ;
countT idCursor = 1 ; //ALLOWABLE RANGE: [1,f]
countT idTypeDisplay = ifcIDtYPEdISPLAY_HOLLYWOOD ;
countT cRequestFresh ;
boolT bShowWhenFresh ;
boolT bOutOk ;
boolT bInOk ;
boolT bRightOk ;
boolT bLeftOk ;
boolT bUpOk ;
boolT bDownOk ;
batonC* pBatonTree ;
treeOldC* pTree ;

#define CaCTIONmEMORY 0x40

#define ifcIDiNTERCOM_HOME                          0x18
#define ifcIDiNTERCOM_END                           0x17
#define ifcIDiNTERCOM_KEY_m                         0x16
#define ifcIDiNTERCOM_STROKEeNTRY                   0x15
#define ifcIDiNTERCOM_MINUS                         0x14
#define ifcIDiNTERCOM_PLUS                          0x13
#define ifcIDiNTERCOM_GUIDE                         0x12
#define ifcIDiNTERCOM_KEY_z                         0x11
#define ifcIDiNTERCOM_KEY_w                         0x10
#define ifcIDiNTERCOM_KEY_t                         0xf
#define ifcIDiNTERCOM_KEY_s                         0xe
#define ifcIDiNTERCOM_KEY_p                         0xd
#define ifcIDiNTERCOM_KEY_i                         0xc
#define ifcIDiNTERCOM_KEY_k                         0xb
#define ifcIDiNTERCOM_KEY_h                         0xa
#define ifcIDiNTERCOM_KEY_g                         0x8
#define ifcIDiNTERCOM_KEY_o                         0x7
#define ifcIDiNTERCOM_OUTaRROW                      0x6
#define ifcIDiNTERCOM_INaRROW                       0x5
#define ifcIDiNTERCOM_RIGHTaRROW                    0x4
#define ifcIDiNTERCOM_LEFTaRROW                     0x3
#define ifcIDiNTERCOM_UPaRROW                       0x2
#define ifcIDiNTERCOM_DOWNaRROW                     0x1

#define MSR (1.0/16.0)
#define MSC (1.0/64.0)
#define FSR (1.0)
#define FSC (1.0/64.0)
//'C''R':COL/ROW
//'S': SCALE
//'F''M': FEMALE/MALE

#define ROW7 (1.0)
#define ROW6 (ROW5+SHIFT)
#define ROW5 (2.0/3.0)
#define ROW4 (ROW3+SHIFT)
#define ROW3 (1.0/3.0)
#define ROW2 (ROW1+SHIFT)
#define ROW1 (0.0)

#define COL4 (1.0)
#define COL3 (2.0/3.0)
#define COL2 (1.0/3.0)
#define COL1 (0.0)

#define SHIFT (1.0/32.0)

#define CgENSsTATE 0x10

#define TmESSAGEtIMElATHfILE T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF2(DDNUMB,flFORMAT_NObIGITvALUES)+T("/time.message.lath")
#define TsTATEfILE           T("///ideafarm/ephemeral/domains/com/ideafarm/")+TF2(DDNUMB,flFORMAT_NObIGITvALUES)+T("/ideafarm.kt.console.state")

;
}
    VK_CONTROL          , ifcIDtYPEtOOL_CONTROL
    VK_LWIN             , ifcIDtYPEtOOL_BASEoSlEFT ,
    VK_MENU             , ifcIDtYPEtOOL_ALT ,
    VK_SHIFT            , ifcIDtYPEtOOL_SHIFT ,
    VK_CAPITAL          , ifcIDtYPEtOOL_LOCKcAPS ,
    VK_TAB              , ifcIDtYPEtOOL_TAB ,
    VK_ESCAPE           , ifcIDtYPEtOOL_ESCAPE ,
    VK_F1               , ifcIDtYPEtOOL_F1 ,
    VK_F2               , ifcIDtYPEtOOL_F2 ,
    VK_F3               , ifcIDtYPEtOOL_F3 ,
    VK_F4               , ifcIDtYPEtOOL_F4 ,
    VK_F5               , ifcIDtYPEtOOL_F5 ,
    VK_F6               , ifcIDtYPEtOOL_F6 ,
    VK_F7               , ifcIDtYPEtOOL_F7 ,
    VK_F8               , ifcIDtYPEtOOL_F8 ,
    VK_F9               , ifcIDtYPEtOOL_F9 ,
    VK_F10              , ifcIDtYPEtOOL_F10 ,
    VK_F11              , ifcIDtYPEtOOL_F11 ,
    VK_F12              , ifcIDtYPEtOOL_F12 ,
    VK_SCROLL           , ifcIDtYPEtOOL_LOCKsCROLL ,
    VK_PAUSE            , ifcIDtYPEtOOL_PAUSE ,
    VK_CANCEL           , ifcIDtYPEtOOL_BREAK ,
    VK_INSERT           , ifcIDtYPEtOOL_INSERT ,
    VK_HOME             , ifcIDtYPEtOOL_HOME ,
    VK_PRIOR            , ifcIDtYPEtOOL_PAGEuP ,
    VK_DELETE           , ifcIDtYPEtOOL_DELETE ,
    VK_END              , ifcIDtYPEtOOL_END ,
    VK_NEXT             , ifcIDtYPEtOOL_PAGEdOWN ,
    VK_LEFT             , ifcIDtYPEtOOL_LEFT ,
    VK_DOWN             , ifcIDtYPEtOOL_DOWN ,
    VK_RIGHT            , ifcIDtYPEtOOL_RIGHT ,
    VK_UP               , ifcIDtYPEtOOL_UP ,
    VK_MENU             , ifcIDtYPEtOOL_ALTrIGHT ,
    VK_RWIN             , ifcIDtYPEtOOL_BASEoSrIGHT ,
    VK_APPS             , ifcIDtYPEtOOL_BASEoScELLlIST ,
    VK_CONTROL          , ifcIDtYPEtOOL_CONTROLrIGHT ,
    VK_SHIFT            , ifcIDtYPEtOOL_SHIFTrIGHT ,
    VK_RETURN           , ifcIDtYPEtOOL_ENTER ,
    VK_BACK             , ifcIDtYPEtOOL_BACKSPACE ,
    VK_SCROLL           , ifcIDtYPEtOOL_LOCKsCROLL ,
    VK_CAPITAL          , ifcIDtYPEtOOL_LOCKcAPS ,
    VK_INSERT           , ifcIDtYPEtOOL_INSERTnUM ,
    VK_DELETE           , ifcIDtYPEtOOL_DELETEnUM ,
    VK_RETURN           , ifcIDtYPEtOOL_ENTERnUM ,
    VK_NEXT             , ifcIDtYPEtOOL_PAGEdOWNnUM ,
    VK_DOWN             , ifcIDtYPEtOOL_DOWNnUM ,
    VK_END              , ifcIDtYPEtOOL_ENDnUM ,
    VK_LEFT             , ifcIDtYPEtOOL_LEFTnUM ,
    VK_CLEAR            , ifcIDtYPEtOOL_NULLnUM ,
    VK_RIGHT            , ifcIDtYPEtOOL_RIGHTnUM ,
    VK_PRIOR            , ifcIDtYPEtOOL_PAGEuPnUM ,
    VK_UP               , ifcIDtYPEtOOL_UPnUM ,
    VK_HOME             , ifcIDtYPEtOOL_HOMEnUM ,
    VK_EXECUTE          , ifcIDtYPEtOOL_PLUSnUM ,
    VK_INSERT           , ifcIDtYPEtOOL_MINUSnUM ,
    VK_PRINT            , ifcIDtYPEtOOL_MULTIPLYnUM ,
    VK_HELP             , ifcIDtYPEtOOL_DIVIDEnUM ,
    VK_NUMLOCK          , ifcIDtYPEtOOL_LOCKnUM ,
    VK_DELETE           , ifcIDtYPEtOOL_PERIODnUM ,
    VK_RETURN           , ifcIDtYPEtOOL_ENTERnUM ,
    VK_HELP             , ifcIDtYPEtOOL_DIVIDEnUM ,
    VK_PRINT            , ifcIDtYPEtOOL_MULTIPLYnUM ,
    VK_INSERT           , ifcIDtYPEtOOL_MINUSnUM ,
    VK_NUMLOCK          , ifcIDtYPEtOOL_LOCKnUM ,
    VK_ESCAPE           , ifcIDtYPEtOOL_ESCAPE ,
    VK_SPACE            , ifcIDtYPEtOOL_SPACE ,
    'Z'                 , ifcIDtYPEtOOL_z ,
    'Y'                 , ifcIDtYPEtOOL_y ,
    'X'                 , ifcIDtYPEtOOL_x ,
    'W'                 , ifcIDtYPEtOOL_w ,
    'V'                 , ifcIDtYPEtOOL_v ,
    'U'                 , ifcIDtYPEtOOL_u ,
    'T'                 , ifcIDtYPEtOOL_t ,
    'S'                 , ifcIDtYPEtOOL_s ,
    'R'                 , ifcIDtYPEtOOL_r ,
    'Q'                 , ifcIDtYPEtOOL_q ,
    'P'                 , ifcIDtYPEtOOL_p ,
    'O'                 , ifcIDtYPEtOOL_o ,
    'N'                 , ifcIDtYPEtOOL_n ,
    'M'                 , ifcIDtYPEtOOL_m ,
    'L'                 , ifcIDtYPEtOOL_l ,
    'K'                 , ifcIDtYPEtOOL_k ,
    'J'                 , ifcIDtYPEtOOL_j ,
    'I'                 , ifcIDtYPEtOOL_i ,
    'H'                 , ifcIDtYPEtOOL_h ,
    'G'                 , ifcIDtYPEtOOL_g ,
    'F'                 , ifcIDtYPEtOOL_f ,
    'E'                 , ifcIDtYPEtOOL_e ,
    'D'                 , ifcIDtYPEtOOL_d ,
    'C'                 , ifcIDtYPEtOOL_c ,
    'B'                 , ifcIDtYPEtOOL_b ,
    'A'                 , ifcIDtYPEtOOL_a ,
    'Z'                 , ifcIDtYPEtOOL_Z ,
    'Y'                 , ifcIDtYPEtOOL_Y ,
    'X'                 , ifcIDtYPEtOOL_X ,
    'W'                 , ifcIDtYPEtOOL_W ,
    'V'                 , ifcIDtYPEtOOL_V ,
    'U'                 , ifcIDtYPEtOOL_U ,
    'T'                 , ifcIDtYPEtOOL_T ,
    'S'                 , ifcIDtYPEtOOL_S ,
    'R'                 , ifcIDtYPEtOOL_R ,
    'Q'                 , ifcIDtYPEtOOL_Q ,
    'P'                 , ifcIDtYPEtOOL_P ,
    'O'                 , ifcIDtYPEtOOL_O ,
    'N'                 , ifcIDtYPEtOOL_N ,
    'M'                 , ifcIDtYPEtOOL_M ,
    'L'                 , ifcIDtYPEtOOL_L ,
    'K'                 , ifcIDtYPEtOOL_K ,
    'J'                 , ifcIDtYPEtOOL_J ,
    'I'                 , ifcIDtYPEtOOL_I ,
    'H'                 , ifcIDtYPEtOOL_H ,
    'G'                 , ifcIDtYPEtOOL_G ,
    'F'                 , ifcIDtYPEtOOL_F ,
    'E'                 , ifcIDtYPEtOOL_E ,
    'D'                 , ifcIDtYPEtOOL_D ,
    'C'                 , ifcIDtYPEtOOL_C ,
    'B'                 , ifcIDtYPEtOOL_B ,
    'A'                 , ifcIDtYPEtOOL_A ,
    0xdb                , ifcIDtYPEtOOL_SQUAREoPEN ,
    0xdd                , ifcIDtYPEtOOL_SQUAREcLOSE ,
    0xbc                , ifcIDtYPEtOOL_COMMA ,
    0xbe                , ifcIDtYPEtOOL_PERIOD ,
    0xbf                , ifcIDtYPEtOOL_DIVIDE ,
    0xde                , ifcIDtYPEtOOL_QUOTEsINGLE ,
    0xba                , ifcIDtYPEtOOL_SEMICOLON ,
    0xdc                , ifcIDtYPEtOOL_BACKsLASH ,
    0xbb                , ifcIDtYPEtOOL_EQUALS ,
    0xbd                , ifcIDtYPEtOOL_MINUS ,
    0xc0                , ifcIDtYPEtOOL_ACCENT ,
    0x30                , ifcIDtYPEtOOL_PARENcLOSE ,
    0x39                , ifcIDtYPEtOOL_PARENoPEN ,
    0x38                , ifcIDtYPEtOOL_MULTIPLY ,
    0x37                , ifcIDtYPEtOOL_AND ,
    0x36                , ifcIDtYPEtOOL_CARET ,
    0x35                , ifcIDtYPEtOOL_PERCENT ,
    0x34                , ifcIDtYPEtOOL_DOLLAR ,
    0x33                , ifcIDtYPEtOOL_POUND ,
    0x32                , ifcIDtYPEtOOL_AT ,
    0x31                , ifcIDtYPEtOOL_EXCLAIM ,
    0xbf                , ifcIDtYPEtOOL_QUESTION ,
    0xbe                , ifcIDtYPEtOOL_GREATERtHAN ,
    0xbc                , ifcIDtYPEtOOL_LESStHAN ,
    0xde                , ifcIDtYPEtOOL_QUOTEdOUBLE ,
    0xba                , ifcIDtYPEtOOL_COLON ,
    0xdc                , ifcIDtYPEtOOL_OR ,
    0xdd                , ifcIDtYPEtOOL_CURLEYcLOSE ,
    0xdb                , ifcIDtYPEtOOL_CURLEYoPEN ,
    0xbb                , ifcIDtYPEtOOL_PLUS ,
    0xbd                , ifcIDtYPEtOOL_UNDERSCORE ,
    0xc0                , ifcIDtYPEtOOL_TILDE ,
    0x6a                , ifcIDtYPEtOOL_MULTIPLYnUM ,
    0x6b                , ifcIDtYPEtOOL_PLUSnUM ,
    0x6d                , ifcIDtYPEtOOL_MINUSnUM ,
    0x6e                , ifcIDtYPEtOOL_PERIODnUM ,
    0x6f                , ifcIDtYPEtOOL_DIVIDEnUM ,
    0x69                , ifcIDtYPEtOOL_PAD9 ,
    0x68                , ifcIDtYPEtOOL_PAD8 ,
    0x67                , ifcIDtYPEtOOL_PAD7 ,
    0x66                , ifcIDtYPEtOOL_PAD6 ,
    0x65                , ifcIDtYPEtOOL_PAD5 ,
    0x64                , ifcIDtYPEtOOL_PAD4 ,
    0x63                , ifcIDtYPEtOOL_PAD3 ,
    0x62                , ifcIDtYPEtOOL_PAD2 ,
    0x61                , ifcIDtYPEtOOL_PAD1 ,
    0x60                , ifcIDtYPEtOOL_PAD0 ,
{
vkToolS pVkTool[] =
//U::MOVE THIS TO A BASE API (0b5)

;
}
    countT id ;
    countT vk ;
{
struct vkToolS

/*1*/WAKEsHOW( "2do.copy.of.a450104.for.rewrite.pull.from.here" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

