
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / \r\n" ) ;
        _OUT_

        handleP.osh = handleP.oshInvalid ;

        }
            default : { BLAMMO ; break ; }
            
            }
                break ;
                DEL( *(bookC**)&handleP.osh ) ;
            {
            case ifcIDtYPEhANDLE_BOOKSrEADcURSOR :
            }
                break ;
                DEL( *(cloudInfoS**)&handleP.osh ) ;
            {
            case ifcIDtYPEhANDLE_CLOUD :
            }
                break ;
                BOSnOvALUE( WHATgbo , (*processGlobal1I.openSsl_pContextFreeF)( (SSL_CTX*)handleP.osh ) )
            {
            case ifcIDtYPEhANDLE_openSslContext :
            }
                break ;

                #endif
    
                    }
                        PUSE( tinP , *(byteT**)&handleP.osh ) ;
                        if( !POOP ) { BOSnOvALUE( WHATgbo , DeleteCriticalSection( (CRITICAL_SECTION*)handleP.osh ) ) }
                        __( !handleP.osh ) ;
                        TINSL
                    {
    
                #if defined( __NT__ )
            {
            case ifcIDtYPEhANDLE_CRITICALsECTION :
            }
                break ;
            {
            case ifcIDtYPEhANDLE_FORaDAMtOuSEf :
            case ifcIDtYPEhANDLE_FORaDAMtOuSEe :
            case ifcIDtYPEhANDLE_FORaDAMtOuSEd :
            case ifcIDtYPEhANDLE_FORaDAMtOuSEc :
            case ifcIDtYPEhANDLE_FORaDAMtOuSEb :
            case ifcIDtYPEhANDLE_FORaDAMtOuSEa :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE9 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE8 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE7 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE6 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE5 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE4 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE3 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE2 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE1 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE0 :
            case ifcIDtYPEhANDLE_TREEwALK :
            case ifcIDtYPEhANDLE_STACKwALK :
            case ifcIDtYPEhANDLE_FISH :
            }
                break ;

                if( handleP.cNoteF() ) { BOSnOvALUE( WHATgbo , (*processGlobal1I.openSsl_pWrapperFreeF)( (SSL*)handleP.cNoteF() ) ) }
    
                #endif
                    
                    if( tinP.bosFail && handleP.osh != handleP.oshInvalid && tinP.brcLath != WSAENOTCONN && tinP.brcLath != WSAENOTSOCK ) { BLAMMO ; }

                    BOSS( WHATgbo , BOSfAIL , closesocket( handleP.osh ) )
                    //LOGrAW5( "" , handleP.osh , "    " , tinP.pAdamGlobal1->idAdam , " ----\r\n" ) ;
                    
                #elif defined( __NT__ )
                    if( 0 > (sCountT)tinP.brcLath ) { BLAMMO ; }
                    BOSdOnOTtEST( WHATgbo , soclose( handleP.osh ) )
                #ifdef __OS2__
                    
                #endif
                    BOSS( WHATgbo , BOSfAIL , shutdown( handleP.osh , 2 ) )
                #elif defined( __NT__ )
                    BOSdOnOTtEST( WHATgbo , so_cancel( handleP.osh ) )
                #ifdef __OS2__
                
                //}
                //    thp = 0 ;
                //    thp.s_optionLingerF( tinP , handleP , 60 ) ; //20150322@1105: 0->60 TO FIND A BUG
                //    thirdC thp( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ;
                //    //U::O: ELIMINATE CONSTRUCTION OF THIS thp
                //    TINSL
                //{
                //U:: 20200524@2335: WHY NEEDED?  CAN'T DO THIS EARLY OR LATE.  COMMENTED OUT BECAUSE CAUSES PROCESS C++ INIT TO FAIL WHEN HOME IS CLOAKED

                if( handleP.cNoteF() ) { BOSnOvALUE( WHATgbo , (*processGlobal1I.openSsl_pShutdownF)(    (SSL*)handleP.cNoteF() ) ) }
            {
            case ifcIDtYPEhANDLE_SOCKET :
            }
                break ;
            {
            case ifcIDtYPEhANDLE_PROCESStOKEN :
            }
                break ;
            {
            case ifcIDtYPEhANDLE_PIPE :
            }
                break ;
                #endif

                    BOSpOOP
                    BOS( WHATgbo , BOSoK , SetConsoleCtrlHandler( (PHANDLER_ROUTINE)handleP.osh , 0 ) )

                #elif defined( __NT__ )
                #if defined( __OS2__ )
            {
            case ifcIDtYPEhANDLE_CONSOLEhANDLER :
            }
                break ;
                BOSdOnOTtEST( WHATgbo , SetUnhandledExceptionFilter( (LPTOP_LEVEL_EXCEPTION_FILTER)handleP.osF( ifcIDtYPEhANDLE_EXCEPTIONhANDLER ) ) )
            {
            case ifcIDtYPEhANDLE_EXCEPTIONhANDLER :
            }
                break ;
                BOSpOOP
                BOS( WHATgbo , BOSoK , DeleteObject( (HGDIOBJ)handleP.osh ) )
                TINSL
            {
            case ifcIDtYPEhANDLE_DRAWINGtOOL :
            }
                break ;
    
                    #endif
                
                    if( tinP.bosFail ) { BLAMMO ; }
                    BOS( WHATgbd , BOSoK , DeleteDC( (HDC)handleP.osh ) )
        
                    //U::hDrawP = 0 ;

                    //U::}
                    //U::    BOSpOOP
                    //U::    BOS( WHATgbd , BOSoK , DeleteDC( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) ) )
                    //U::{
                    //U::if( !hWindow ) //ASSUME: IF hWindow THEN IS A PRIVATE DC; ELSE IS A MEMORY (BITMAP) DC
                    //U::
                    //U::pswWinFromDraw->freeF( tinP ) ;
                    //U::countT hWindow = *pswWinFromDraw ;
                    //U::thirdC::lever_swWinFromDraw = handleP.osh ;
                
                #elif defined( __NT__ )
                
                    //U:
                
                #if defined( __OS2__ )
            {
            case ifcIDtYPEhANDLE_DRAWpRIVATE :
            }
                break ;
            {
            case ifcIDtYPEhANDLE_DRAWsHARED :
            }
                break ;
    
                }
                    #endif

                        BOSpOOP
                        BOS( WHATgbd , BOSoK , DestroyWindow( (HWND)handleP.osh ) )

                    #elif defined( __NT__ )
                        //U:
                    #if defined( __OS2__ )
                {
                if( !handleP.cNote )
            {
            case ifcIDtYPEhANDLE_WINDOW :
            }
                break ;
            {
            case ifcIDtYPEhANDLE_WINDOWINGcLIENT :
            }
                break ;
    
                #endif
                    
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , FindCloseChangeNotification( (HANDLE)handleP.osh ) )
                    
                #elif defined( __NT__ )
                    
                    //U:
                    
                #ifdef __OS2__
            {
            case ifcIDtYPEhANDLE_FILEwAIT :
            }
                break ;
    
                #endif

                    }
                        processGlobal3I.heap.delF( tinP , *(byteT**)&pOsh ) ;
                        DELzOMBIE( pOsh ) ;
                    {
                    if( pOsh )

                    diskFindHandleS* pOsh = (diskFindHandleS*)handleP.osh ;
                    
                #elif defined( __NT__ )
                    
                    //U:
                    
                #ifdef __OS2__
            {
            case ifcIDtYPEhANDLE_FILEfIND :
            }
                break ;
    
                #endif
                    
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , FindClose( (HANDLE)handleP.osh ) )
                    
                #elif defined( __NT__ )
                    
                    //U:
                    
                #ifdef __OS2__
            {
            case ifcIDtYPEhANDLE_FILEfINDbASE :
            }
                break ;
    
                }
                    #endif

                        BOSpOOP
                        BOSS( WHATgbo , BOSoK , CloseHandle( (HANDLE)handleP.osh ) )

                    #elif defined( __NT__ )
                        BOSpOOP
                        BOS( WHATgbo , BOSfAIL , DosClose( (HFILE)handleP.osh ) )
                    #ifdef __OS2__
                {
                if( handleP.idType != ifcIDtYPEhANDLE_PROCESS || !handleP.cNote )
            {
            case ifcIDtYPEhANDLE_THREAD         :
            case ifcIDtYPEhANDLE_PROCESS        :
            case ifcIDtYPEhANDLE_MUTEXsEMAPHORE :
            case ifcIDtYPEhANDLE_EVENTsEMAPHORE :
            }
                // INTENTIONAL FALLTHROUGH

                BOSpOOP
                BOS( WHATgbo , BOSoK , UnmapViewOfFile( (voidT*)handleP.cNote ) )
            {
            case ifcIDtYPEhANDLE_FILEmAPPING    :
            }
                break ;
                handleP.cNote = 0 ;
                #endif

                    BOSpOOP
                    BOS( WHATgbo , BOSoK , CloseHandle( (HANDLE)handleP.osh ) )
                    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 0\r\n" ) ;
    
                    thirdC::dosPriorityIF( tinP , idDesireSave ) ;
                    }
                        }
                            //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 1\r\n" ) ;
                            BOSpOOP
                            BOS( WHATgbo , BOSoK , UnmapViewOfFile( (voidT*)handleP.cNote ) )
                            //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 2\r\n" ) ;
                        {
                        if( !bFoundAlias )
                        //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 3\r\n" ) ;

                        }
                            //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 4\r\n" ) ;
                            _OUT_

                            }
                                _OUT_

                                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 5\r\n" ) ;
                                }
                                    _OUT_
                                    linkedC::nextIF( tinP , hx ) ;
                                    _INoLD_
                                {
    
                                }
                                    break ;
                                    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 6\r\n" ) ;
                                    ++ bFoundAlias ;
                                {
                                )
                                    &he       != &handleP
                                    he.cNote  ==  handleP.cNote               &&
                                    he.idType ==  handleP.idType              &&
                                (
                                if
    
                                handleC& he = *(handleC*)( (byteT*)&linked - SIZEOF_baseSoilXxxxC ) ;
                                linkedC& linked = linkedC::getLinkIF( tinP , hx ) ;

#endif

                                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 7\r\n" ) ;

                                }
                                    }
                                        }
                                            //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 8\r\n" ) ;
                                            thirdC::dosSleepIF( tinP , TICK , TOCK ) ;
                                            //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 9\r\n" ) ;
                                        {
                                        while( !etPrime )
                                        etherC& etPrime = etherC::etPrimeIF() ;
                                        LOGrAW( "calling dosSleepIF because hopefully i've logged enough loop handle values" ) ; // THIS RATHER THAN BLAMMO SO MINUTE REPORTS CAN REVEAL WHO CALLED ME
                                        //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / a\r\n" ) ;

                                        }
                                            _OUT_

                                            linkedC::nextIF( tinP , hx2 ) ;
                                            LOGrAWd( "[idThread,INtALLY,hx2,idLineCt,idiFileCt]:    " , tinP.monitor.idThread , "    " , INtALLY , "    " , hx2.osF( ifcIDtYPEhANDLE_LINKED ) , "    " , linked.idLineCtF() , "    " , linked.idiFileCtF() , "    " , linked.idThreadCtF() , "\r\n" ) ;
                                            linkedC& linked = linkedC::getLinkIF( tinP , hx2 ) ;

                                            _INoLD_
                                        {
                                        while( cDo -- && ~hx2 )
                                        countT cDo = TUCK ;
                                        //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / b\r\n" ) ;
                                    
                                        root.openKidF( tinP , hx2 ) ;
                                        linkedC& root = processGlobal3I._handleC_linked_sm ;
                                        handleC hx2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LINKED ) ;

                                        LOGrAW( "walking from the root to document the state of the list (hopefully i've logged enough loop handle values)" ) ;
                                        //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / c\r\n" ) ;
                                    {
                                    if( ++ cLogged > TOCK )

                                    LOGrAW7( "[idThread,INtALLY,hx]:    " , tinP.monitor.idThread , "    " , INtALLY , "    " , hx.osF( ifcIDtYPEhANDLE_LINKED ) , "\r\n" ) ;

                                    static countT cLogged ;
                                {
                                if( INtALLY > TUCK ) //20161219@0929: LIST REPEATS WITH GROUPS OF 8
                                //U:: TO FIND A BUG
                                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / d\r\n" ) ;

#if defined( NEVERdEFINED )

                                _INoLD_
                            {
                            while( ~hx )
                        
                            //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / e\r\n" ) ;
                            root.openKidF( tinP , hx ) ;
                            linkedC& root = processGlobal3I._handleC_linked_sm ;
                            handleC hx( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LINKED ) ;
                            //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / f\r\n" ) ;

                            _INoLD_
                        {
                        ZE( boolT , bFoundAlias ) ;

                        TINSL
                    {
                    if( handleP.cNote ) //WILL BE 0 IF WAS NOT ABLE TO MAP A VIEW
                    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / g\r\n" ) ;

                    linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
                    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / h\r\n" ) ;
    
                    }
                        if( F(processGlobal1I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal1I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal3I.grabUniverse.ungrabF( tinP ) ;
                        }
                            }
                                break ;
                                processGlobal1I._thirdC_pSharedMemInfo[ offr ].pv = 0 ;
                                processGlobal1I._thirdC_pSharedMemInfo[ offr ].osh = 0 ;
                                *processGlobal1I._thirdC_pSharedMemInfo[ offr ].postName = 0 ;
                            {
                            if( processGlobal1I._thirdC_pSharedMemInfo[ offr ].osh == handleP.osh )
                        {
                        for( countT offr = 0 ; offr < CsHAREDmEMiNFO ; offr ++ )
                        if( F(processGlobal1I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal1I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal3I.grabUniverse.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
                    const countT idDesireSave = thirdC::dosPriorityIF( tinP ) ;
                    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / i\r\n" ) ;
    
                #elif defined( __NT__ )

                    BOSdOnOTtEST( WHATgbo , DosFreeMem( (voidT*)handleP.cNote ) )

                #ifdef __OS2__
            {
            case ifcIDtYPEhANDLE_SHAREDmEMORY :
            }
                break ;

                }
                    DEL( pInfo ) ;

                    }
                        if( pInfo->postNameTag ) { BOS( WHATgbo , BOSoK , DeleteFile( pInfo->postNameTag ) ) }
                        if( ~pInfo->hTag       ) pInfo->hTag.closeIfF() ; //IT WOULD BE NICE TO DO THIS AFTER DELETING THE FILE, BUT NO CAN DO FOR NT FLAVOR OF win32
                        }
                            }
                                countT foo = 2 ;
                            {
                            if( c_strstrIF( pInfo->postName , ".!.transcript." ) )
                            //U:: TO FIND A BUG

                            BOS( WHATgbo , BOSoK , DeleteFile( pInfo->postName ) )
                        {
                        if( F(pInfo->flagsAtClose) & flFILEaTcLOSE_DELETE )
                    {
                    if( pInfo )

                    handleP.osh = 0 ;
                    #endif

                        BOSpOOP
                        BOS( WHATgbo , BOSoK , CloseHandle( (HANDLE)handleP.osh ) )

                    #elif defined( __NT__ )
                        //U::
                    #ifdef __OS2__

                    }
                        }
                            tinP.pAdamGlobal1->_thirdC_.pSwFileOpen->ungrabF( tinP ) ;
                            tinP.pAdamGlobal1->_thirdC_.pSwFileOpen->freeF( tinP ) ;
                            pInfo = (fileOpenS*)(countT)*tinP.pAdamGlobal1->_thirdC_.pSwFileOpen ;
                            tinP.pAdamGlobal1->_thirdC_.cLever_pSwFileOpen = handleP.osh ;
                            tinP.pAdamGlobal1->_thirdC_.pSwFileOpen->grabF( tinP , TAG( TAGiDnULL ) ) ;
                            puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                        {
                        if( tinP.pAdamGlobal1->_thirdC_.pSwFileOpen ) //DEREGISTRATION MUST OCCUR BEFORE HANDLE CLOSURE BECAUSE THE OS MIGHT IMMEDIATELY REUSE THAT HANDLE, RESULTING IN AN ATTEMPT TO REGISTER IT (WHICH WOULD FAIL IF IT WINS THE RACE)
                    {
                    if( F(handleP.cNote) & flFILEhANDLEnOTE_OPENrEGISTERED )
                    ZE( fileOpenS* , pInfo ) ;

                    TINSL
                {
                if( handleP.osh > 2 ) //DO NOT CLOSE THE STANDARD FILE HANDLES 0 , 1 , 2 (STDIN STDOUT STDERR)
            {
            case ifcIDtYPEhANDLE_FILE :
            }
                break ;
                #endif
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , FreeLibrary( (HMODULE)handleP.osh ) )
                    dec02AM( processGlobal1I.cDllLoaded ) ; //COUNT WILL BE WRONG IF THE NEXT LINE FAILS
                #elif defined( __NT__ )
                    //U::
                #ifdef __OS2__
            {
            case ifcIDtYPEhANDLE_DLL :
            }
                break ;

                //}
                //    tinP.pEther->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
                //
                //    OStEXTC(  ostoSay , idNameDebug , 0 ) ;
                //    OStEXTAK( ostoSay , "openF / COULD NOT UNGRAB (NOT REGISTERED) [idName]: " ) ;
                //    OStEXT(   ostoSay , TUCK << 2 ) ;
                //{
                //else if( tinP.pc Utility[ 0 ] && tinP.pAdamGlobal1->idAdam == ifcIDaDAM_KERNEL2MONITOR )
                }
                    //}
                    //    CONoUTrAW( ostoSay ) ;
                    //    //PUSE( tinP , postName ) ;
                    //    //OStEXTA(  ostoSay , postName ) ;
                    //    OStEXTC(  ostoSay , pListing->nameF() , 0 ) ;
                    //    OStEXTAK( ostoSay , " | ----- " ) ;
                    //    OStEXTC(  ostoSay , tinP.monitor.idThread , 0 ) ;
                    //    OStEXTAK( ostoSay , "\r\n" ) ;
                    //    OStEXT(   ostoSay , TUCK << 1 ) ;
                    //
                    //    //getListNameGF( tinP , postName , pListing->nameF() ) ; ___( postName ) ;
                    //    //ZE( osTextT* , postName ) ;
                    //{
                    //if( pListing->flagsF() & fliLISTINGc_MIXINlIST )

                    //}
                    //    tinP.pEther->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
                    //
                    //    OStEXTC(  ostoSay , idNameDebug , 0 ) ;
                    //    OStEXTAK( ostoSay , "openF / ungrabbed  [idName]: " ) ;
                    //    OStEXT(   ostoSay , TUCK << 2 ) ;
                    //{
                    //if( tinP.pc Utility[ 0 ] && tinP.pAdamGlobal1->idAdam == ifcIDaDAM_KERNEL2MONITOR )

                    _OUT_


                    //tinP.pEther->traceF( tinP , (const strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
                    OStEXTAK( ostoSay , " --   ungrabbed" ) ;
                    //U:: TO FIND A BUG

                    grabitx.ungrabF( tinP ) ; //FOR APPLICATION CODING CONVENIENCE; AS OF THIS WRITING THERE IS NO WAY TO EXPLICITLY UNGRAB A LIST THAT HAS BEEN OPENED AND KEPT OPEN EXCEPT TO MAKE SURE THAT THE LATH LIST WALK DOES NOT SPECIFY THE "DO NOT UNGRAB LIST" FLAG


                    //tinP.pEther->traceF( tinP , (const strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
                    //THESE HAVE TRIGGERED DEADLOCK WHEN CAUSES A NEW bookC INSTANCE TO BE CT'D; ENABLE WHEN traceF IS ENHANCED TO AVOID CREATING bookC INSTANCES
                    OStEXTAK( ostoSay , " : --   ungrabbing" ) ;
                    OStEXTCF( ostoSay , (countT)&pListing->flagsRefF() , '0' ) ;
                    OStEXT(   ostoSay , TUCK << 2 ) ;
                    //U:: TO FIND A BUG


                    _INoLD_
                {
                if( grabitx.isRegisteredF( tinP ) )

                //}
                //    tinP.pEther->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
                //
                //    OStEXTC(  ostoSay , idNameDebug , 0 ) ;
                //    OStEXTAK( ostoSay , "openF / ungrabbing [idName]: " ) ;
                //    OStEXT(   ostoSay , TUCK << 2 ) ;
                //{
                //if( tinP.pc Utility[ 0 ] && tinP.pAdamGlobal1->idAdam == ifcIDaDAM_KERNEL2MONITOR )

                grabitC grabitx( tinP , TAG( TAGiDnULL ) , pListing->flagsRefF() , ifcIDgRABITbIT_00 + offLISTINGgRABBEDbIT , *(grabitC*)0 , 0 , 0 , 0 , flagsx ) ;

                }
                    flagsx |= flGRABITc_RECURSEuSINGtINs ;
                    )
                        )
                            idName <= LISTnAME_ROOTsYSTEM8              //CS:CODEsYNC: 330e5007 33001126 3300039b
                            &&
                            idName >= LISTnAME_ROOTsYSTEM1
                        (
                        ||
                        idName == LISTnAME_ROOTaPPLICATION
                        ||
                        idName == LISTnAME_ROOT
                    (
                    if
                    //idNameDebug = idName ;
                    countT idName = ((listC*)pListing)->nameF() ;
                {
                if( pListing->flagsF() & fliLISTINGc_MIXINlIST )
                //ZE( countT , idNameDebug ) ;
                flagsT flagsx = flGRABITc_SUPPRESScTdT | flGRABITc_UNKEYED ; //CS:CODEsYNC 360e5007 35001126 "flGRABITc_UNKEYED" IS SPECIFIED TO AVOID NEEDING TO DOUBLE THE SIZE OF THE sexC ALLOCATION DROP FOR listingC INSTANCES.  sizeof( listingC ) IS CURRENTLY OPTIMAL.  ADDING A countT MEMBER TO HOLD A KEY WOULD CHANGE THE ALLOCATION DROP SIZE.

                listingC* pListing = (listingC*)handleP.osh ;

                //__( thirdC::dosPriorityIF( tinP ) - ifcTHREADpRIORITY_SPINLOCK ) ;
            {
            case ifcIDtYPEhANDLE_LISTING :
            }
                break ;
                ((linkedC*)handleP.osh)->ungrabF( tinP ) ;
            {
            case ifcIDtYPEhANDLE_LINKED :
            }
                break ;
            {
            case ifcIDtYPEhANDLE_BOOKS :
            }
                break ;
                sadamsC::pSadamsIF( tinP )->unlockF( tinP , handleP ) ;
            {
            case ifcIDtYPEhANDLE_sadamsC :
        {
        switch( handleP.idType )

        _INoLD_

        //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / j\r\n" ) ;

        TINSL //U::CONJ: THIS WILL FAIL VERY EARLY; IF NOT THEN LET'S JUST ADD tinP TO THE PARAMETERS
    {
    if( ~handleP.osh != handleP.oshInvalid )
{
/*1*/voidT thirdC::handleCloseIF( handleC& handleP )/*1*/

/**/
*/
\<A HREF=\"5.1020161.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$handleCloseIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

