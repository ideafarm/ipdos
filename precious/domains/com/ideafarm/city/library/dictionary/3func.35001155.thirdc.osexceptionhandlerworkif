
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bFixed ;
    }
        _OUT_
        THREADmODE3rESTORE
        TINSL
    {

    }
        //TELL( "osExceptionHandlerWorkIF/-" ) ;/*_M*/
        /*_M*/
        //TINSL
        }
            //TINSL
            }
                //TINSL
                }
                    }
                        //dosExitProcessIF( ifcEXITcODEpROCESSiMPOTENT ) ; //TO PREVENT AN AV ON tmWindowsF FROM LEAVING DESKTOP COVERED UP WITH AN UNRESPONSIVE WINDOW
                        //flagsResultP |= flEXCEPTIONrESULT_EXITpROCESScALLED ;
                        //OBSOLETE: NOW THIS IS DONE BY rootExceptionFilterF, WHO CALLED MY CALLER

                        }
                            }
                                }
                                    BLAMMO ;
                                    homeS::homeIF().flags |= flHOMEs_KILLsELFiMMEDIATELY ; //20191014@1759: ADDED WITHOUT ANALYSIS TO MAKE REBOOT MORE RELIABLE AND QUICKER

                                    thirdC::osFireIF( tinP ) ;
                                    if( tinP.pEtText ) tinP.pEtText->emailFactoryReportF( tinP , T("an exception occured.  rebooting") ) ;
                                    LOGrAW3( "on unhandled exception, firing the os at age (ms) since boot: " , msSinceBoot , "\r\n" ) ;
                                {
                                else
                                if( msSinceBoot < msMinimum ) { LOGrAW3( "on unhandled exception, did not fire the os because ms since boot is only " , msSinceBoot , "\r\n" ) ; }
                                countT msSinceBoot = thirdC::osTimeTicksSinceBootIF() >= home.osTicksAtCt ? thirdC::osTimeTicksSinceBootIF() - home.osTicksAtCt : 0 ;
                                countT msMinimum = 10 * 60 * 1000 ; //20190819@1106: CHANGED TO 10 FROM 5 MINUTES
                            {
                            else
                            else if( etherC::ifc_idHomeIdisk_IF() < TUCK ) { LOGrAW3( "on unhandled exception, ignored flHOMEs_FIREoSoNuNHANDLEDeXCEPTION because idHome < TUCK for home " , etherC::ifc_idHomeIdisk_IF() , "\r\n" ) ; } //A:ASSUME: PRODUCTION HOME DISK VALUES ARE 001 OR HIGHER
                            if( !( F(home.flags) & flHOMEs_FIREoSoNuNHANDLEDeXCEPTION ) ) { LOGrAW3( "on unhandled exception, did not fire the os because flHOMEs_FIREoSoNuNHANDLEDeXCEPTION is not set for home " , etherC::ifc_idHomeIdisk_IF() , "\r\n" ) ; }
                            //20191204@1440: ENABLED THE NEXT 3 LINES
                            //U::BUG: 20191015@2147: FLAG IS NOT SET WHEN I NEED IT TO BE SET DURING PRODUCTION FAILURE FACTORY6 HOME 102

                            homeS& home = homeS::homeIF() ;
                        {
                        //ALWAYS ENABLE REBOOT ON EXCEPTION BEFORE UPLOADING (THIS COMMENT IS OBSOLETE, ASSUMING THAT THE SYSTEM IS RUNNING A SERVER)
                        //20190812@1944: ENABLED THIS CODE

                        }
                            }
                                else { POOPR /*_M*/ }
                                }
                                    //THE REPORT FILE IS WRITTEN BEFORE ME BECAUSE SOMETIMES MY TELLc3EBP CALL AV'S
                                    //I CAN DELETE THE REPORT FILE THAT I JUST WROTE TO DISK BECAUSE I WAS ABLE TO TELL THE MONITOR
                                    bTold = 1 ;/*_M*/
                                {/*_M*/
                                if( !POOP )
                                THREADmODE1rESTORE
                                TELLc3( ifcIDtYPEtELL_ERROReXCEPTION , (byteT*)&tellInfo , sizeof tellInfo ) /*_M*/
                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                            {
                        {/*_M*/
                        if( !bDriver && !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & ( flMODEpROCESS2_SUPPRESStELLS | flMODEpROCESS2_FAILtELLS ) ) )
                        ZE( boolT , bTold ) ;/*_M*/

                        }
                            //TELL( "osExceptionHandlerWorkIF/reported the exception to disk" )

                            THREADmODE1rESTORE
                            }
                                ++ s ; dosSleepIF( tinP , TOCK ) ;
                                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                            {
                            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                            //U:: JUST TO MAKE SURE THAT IT HAS TIME TO CLOSE AND FLUSH (SHOULD NOT BE NECESSARY)

                            }
                                }
                                    //CONoUTrAW( "appending memory readability bit dump to exception report: done\r\n" ) ;
                                    fileWriteGF( ostoFileName , postr , sizeof postr - 1 , 1 ) ;
                                    etherC::ifcBitDumpIF( tinP , postr , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;
    
                                    static byteT postr[ CBrEADABILITYmAPdUMP ] ;
                                    //CONoUTrAW( "appending memory readability bit dump to exception report\r\n" ) ;
                                {
                                if( cbaNeeded == CBrEADABILITYmAPdUMP )
                                
                                //CONoUTrAW3( "memory readability map [cbaNeeded]: " , cbaNeeded , "\r\n" ) ;
                                LOGrAW3( "memory readability map [cbaNeeded]: " , cbaNeeded , "\r\n" ) ;
                                countT cbaNeeded = etherC::ifcBitDumpIF( tinP , 0 , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;
                                //[cbaNeeded]: 1858
                                //[cbaNeeded]: 10858
                                //[cbaNeeded]: 958
                                countT cbGrain = thirdC::osMemoryReadabilityMapIF( tinP , pbBits , sizeof pbBits ) ;
                                
                                //static byteT pbBits[ TOCK ] ;   //THERE ARE A TUCK OF CHAR PER LINE ; EACH LINE REPRESENTS 01 TOCK ; EACH CHAR REPRESENTS 01 TUCK (1 PAGE) ;
                                static byteT pbBits[ TUCK << 4 ] ; //EACH LINE OF REPORT WILL REPRESENT 1 TICK OF MEMORY
                            {
                            #endif
                                if( tinSnap.brcLath == ERROR_NOT_ENOUGH_MEMORY )
                            #elif defined( __NT__ )
                                if( tinSnap.brcLath == U: )
                            #if defined( __OS2__ )

                            }
                                fileWriteGF( ostoFileName , postRpt , costRpt , 1 ) ;
                                OStEXTAK( ostoFileName , "\\log.exception.txt" ) ;
                                OStEXTA(  ostoFileName , processGlobal1I.postPathHomeTmp ) ;
                            {
                            OStEXT( ostoFileName , TUCK << 1 ) ;

                            countT         costRpt = thirdC::c_strlenIF( tinP , postRpt ) ;
                            const osTextT* postRpt = ostoRpt ;

                            OStEXTAK( ostoRpt , "Please always report to www.ideafarm.com that this information appeared,\r\nso that the quality of this software can be improved for you and also for others.\r\n" ) ;/*_M*/
                            }
                                OStEXTAK( ostoRpt , "\r\n \r\n" ) ;/*_M*/
                                OStEXTA( ostoRpt , tellInfo.postFix2 ) ;/*_M*/
                                OStEXTAK( ostoRpt , " \r\nIf that does not work, try this:\r\n" ) ;/*_M*/
                            {/*_M*/
                            if( tellInfo.postFix2[ 0 ] )
                            OStEXTAK( ostoRpt , "\r\n \r\n" ) ;/*_M*/
                            OStEXTA( ostoRpt , tellInfo.postFix1 ) ;/*_M*/
                            OStEXTAK( ostoRpt , ".\r\n \r\nTry this woth:\r\n" ) ;/*_M*/
                            OStEXTA( ostoRpt , tellInfo.postSuspect ) ;/*_M*/
                            OStEXTAK( ostoRpt , "Probable defect location: " ) ;/*_M*/
                            
                            OStEXTAK( ostoRpt , "\r\n \r\n" ) ;/*_M*/
                            }
                                }
                                    break ;
                                    OStEXTC( ostoRpt , tellInfo.pcInfo[ 0 ] , 0 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "\r\nraw exception code (tellInfo.pcInfo[0]): " ) ;/*_M*/
                                    OStEXTC( ostoRpt , tellInfo.idException , 0 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "tellInfo.idException: " ) ;/*_M*/
                                {/*_M*/
                                default :
                                }
                                    break ;
                                    OStEXTC(    ostoRpt , tellInfo.pcInfo[ 2 ] , 0 ) ;/*_M*/
                                    OStEXTAK(   ostoRpt , "\r\nidiFileCt: " ) ;/*_M*/
                                    OStEXTCmIN( ostoRpt , tellInfo.pcInfo[ 2 ] , 4 ) ;/*_M*/
                                    OStEXTAK(   ostoRpt , "\r\nidLineCt: " ) ;/*_M*/
                                    OStEXTC(    ostoRpt , tellInfo.pcInfo[ 1 ] , 0 ) ;/*_M*/
                                    OStEXTAK(   ostoRpt , "\r\nidiFile: " ) ;/*_M*/
                                    OStEXTCmIN( ostoRpt , tellInfo.pcInfo[ 0 ] , 4 ) ;/*_M*/
                                    OStEXTAK(   ostoRpt , "idLine: " ) ;/*_M*/
                                {/*_M*/
                                case ifcIDeVENTeXCEPTIONmONITORED_BLAMMO :
                                }
                                    break ;
                                    OStEXTCmIN( ostoRpt , tellInfo.pcInfo[ 5 ] , 7 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "\r\nidiFileNote: " ) ;/*_M*/
                                    OStEXTCmIN( ostoRpt , tellInfo.pcInfo[ 4 ] , 4 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "\r\nidLineNote: " ) ;/*_M*/
                                    OStEXTC( ostoRpt , tellInfo.pcInfo[ 3 ] , 0 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "\r\nidType: " ) ;/*_M*/
                                    OStEXTC( ostoRpt , tellInfo.pcInfo[ 2 ] , 0 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "\r\nidSubType: " ) ;/*_M*/
                                    OStEXTC( ostoRpt , tellInfo.pcInfo[ 1 ] , 0 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "\r\nidiFile: " ) ;/*_M*/
                                    OStEXTCmIN( ostoRpt , tellInfo.pcInfo[ 0 ] , 4 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "idLine: " ) ;/*_M*/
                                {/*_M*/
                                case ifcIDeVENTeXCEPTIONmONITORED_GRUNT :
                                }
                                    break ;
                                    OStEXTC( ostoRpt , tellInfo.pcInfo[ 1 ] , 0 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "\r\npvTarget: " ) ;/*_M*/
                                    OStEXTC( ostoRpt , tellInfo.pcInfo[ 0 ] , 0 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "bWrite: " ) ;/*_M*/
                                {/*_M*/
                                case ifcIDeVENTeXCEPTIONmONITORED_ACCESSvIOLATION :
                            {
                            switch( tellInfo.idException )
                            
                            OStEXTAK( ostoRpt , " \r\n" ) ;/*_M*/
                            }
                                }
                                    OStEXTAK( ostoRpt , "\r\n" ) ;/*_M*/
                                    }
                                        OStEXTA( ostoRpt , postTitle ) ;/*_M*/
                                    {/*_M*/
                                    if( postTitle )
                                    const osTextT* postTitle = processGlobal7I.source.postFileTitleF( tinP , processGlobal7I.source.idFileRankF( tinP , idiFile ) ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "    " ) ;/*_M*/
                                    OStEXTCmIN( ostoRpt , idiFile , 7 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "." ) ;/*_M*/
                                    OStEXTCmIN( ostoRpt , idLine , 4 ) ;/*_M*/
                                    OStEXTA( ostoRpt , ( bOut ? "\\ " : ( bIn ? "/ " : "| " ) ) ) ;/*_M*/
                            
                                    }
                                        ++ cIndent ;/*_M*/
                                    {/*_M*/
                                    if( bOut )

                                    }
                                        }
                                            OStEXTAK( ostoRpt , " " ) ;/*_M*/
                                        {/*_M*/
                                        while( cToDo -- )
                                        countT cToDo = cIndent ;/*_M*/
                                    {/*_M*/
                                    else
                                    }
                                        OStEXTC( ostoRpt , cIndent , ' ' ) ;/*_M*/
                                    {/*_M*/
                                    if( cIndent > TUCK >> 2 )

                                    if( bIn && cIndent ) { -- cIndent ;/*_M*/ }
                            
                                    idLine &= ~fliSTEP_FLAGmASK ;/*_M*/
                                    }
                                        bIn  = !bOut ;/*_M*/
                                        bOut = idLine & fliSTEP_NESToUT ;/*_M*/
                                    {
                                    else
                                    }
                                        bIn = bOut = 0 ;/*_M*/
                                    {/*_M*/
                                    if( !( idLine & fliSTEP_NESTcHANGE ) )
                                    boolT bIn ;
                                    boolT bOut ;
                            
                                    countT idiFile = tinSnap.pLFstep[ offe + 1 ] ;/*_M*/
                                    countT idLine  = tinSnap.pLFstep[ offe     ] ;/*_M*/
                                    countT offe = ( ids & OFFsLOTtINsTEPmAX ) << 1 ;/*_M*/
                                {/*_M*/
                                for( countT ids = tinSnap.monitor.idStep ; cDo -- ; ids -- )
                                countT cDo = OFFsLOTtINsTEPmAX + 1 ;/*_M*/                          // IF idStep IS SMALL AND NOT BECAUSE OF WRAP THEN SOME REPORT LINES WILL BE FROM [0,0] PAIRS ; TO KISS, I DO NOT TEST FOR THIS SO I WILL REPORT EVEN IF pLFstep HAS BEEN TRASHED
                                countT cIndent = tinSnap.monitor.cInNest ;/*_M*/
                            
                                OStEXTAK( ostoRpt , "\r\n \r\nExecution Steps:\r\n \r\n" ) ;/*_M*/
                            {/*_M*/

                            //A:ASSUME: idStep IS VALID
                            //THIS CODE ALWAYS GIVES THE FULL STEP ARRAY AS A CIRCULAR BUFFER STARTING WITH THE MOST RECENT ELEMENT
                            //20191104@2007: REWRITE TO UNCONDITIONALLY GIVE THE FULL STEP ARRAY

                            //else
                            //else if( (sCountT)tinSnap.monitor.idStep < 0 ) { OStEXTAK( ostoRpt , "\r\n \r\nExecution Steps:  error: idStep is negative\r\n" ) ;/*_M*/ }
                            //U::WE CAN GET FANCY HERE; I HAVE NOT DONE SO TO KISS SO THAT THIS CODE IS RELIABLE.  THE CHANCE OF AN EXCEPTION HAPPENING IMMEDIATELY AFTER WRAP IS EXTREMELY LOW
                            //20160603@1931: THE NEXT LINE COMMENTED OUT WITHOUT ANALYSIS ;  SHOULD NOW GET A STEP LISTING EXCEPT WHEN, UNLUCKILY, idStep IS 0 OR VERY SMALL
                            //if( !tinSnap.monitor.idStep ) { OStEXTAK( ostoRpt , "\r\n \r\nExecution Steps:  no step information exists\r\n" ) ;/*_M*/ }
                            //20160604@1657: MADE THIS UNCONDITIONAL WITHOUT ANALYSIS, RELYING ON 2'S COMPLEMENT PROPERTIES TO CORRECTLY DISPLAY STEPS EVEN IF idStep IS NEAR ZE
                            //20191104@2007: REWRITE THIS OLD COMMENTED OUT CODE SO THAT GET CORRECT STEP REPORT EVEN IF idStep HAS WRAPPED


                            }
                                }
                                    OStEXTAK( ostoRpt , "\r\n" ) ;/*_M*/
                                    }
                                        OStEXTA( ostoRpt , postTitle ) ;/*_M*/
                                    {/*_M*/
                                    if( postTitle )
                                    const osTextT* postTitle = processGlobal7I.source.postFileTitleF( tinP , processGlobal7I.source.idFileRankF( tinP , idiFile ) ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "    " ) ;/*_M*/
                                    OStEXTCmIN( ostoRpt , idiFile , 7 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "." ) ;/*_M*/
                                    OStEXTCmIN( ostoRpt , idLine , 4 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , "'th: " ) ;/*_M*/
                                    OStEXTC( ostoRpt , tinSnap.pIdInNest[ offez ] , 0 ) ;/*_M*/
                                    OStEXTAK( ostoRpt , " | " ) ;/*_M*/
                                    OStEXTC( ostoRpt , tinSnap.pEIPInNest[ offez ] , ' ' ) ;/*_M*/
                            
                                    countT idiFile = tinSnap.monitor.pLFnest[ offe + 1 ] ;/*_M*/
                                    countT idLine  = tinSnap.monitor.pLFnest[ offe     ] ;/*_M*/
                                    countT offe = ( idn & OFFsLOTtINnESTmAX ) << 1 ;
                                    countT offez = idn & OFFsLOTtINnESTmAX ;
                                {/*_M*/
                                for( countT idn = tinSnap.monitor.cInNest ; idn >= idnf ; idn -- )
                                /*PSEUDODUPLICATE CODE: 2e40104 0010266*/
                            
                                }
                                    idnf = 1 ;/*_M*/
                                {/*_M*/
                                if( (sCountT)idnf < 1 )
                                countT idnf = tinSnap.monitor.cInNest - OFFsLOTtINnESTmAX ;/*_M*/
                                OStEXTAK( ostoRpt , "\r\n \r\nCall Nest:\r\n \r\n" ) ;/*_M*/
                            {/*_M*/
                            else
                            else if( (sCountT)tinSnap.monitor.cInNest < 0 ) { OStEXTAK( ostoRpt , "\r\n \r\nCall Nest:  error: cNest is negative\r\n" ) ;/*_M*/ }
                            if( !tinSnap.monitor.cInNest ) { OStEXTAK( ostoRpt , "\r\n \r\nCall Nest:  no nest information exists\r\n" ) ;/*_M*/ }
                            OStEXTC( ostoRpt , tinSnap.monitor.cInNest , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ncNest: " ) ;/*_M*/
                            OStEXTC( ostoRpt , tellInfo.cFixed , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ncFixed: " ) ;/*_M*/
                            OStEXTC( ostoRpt , tellInfo.bFixed , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nbFixed: " ) ;/*_M*/
                            //OStEXTC( ostoRpt , tinSnap.idiFileMileDad , 0 ) ;/*_M*/
                            //OStEXTAK( ostoRpt , "\r\nidiFileMileDad: " ) ;/*_M*/
                            //OStEXTCmIN( ostoRpt , tinSnap.idLineMileDad , 4 ) ;/*_M*/
                            //OStEXTAK( ostoRpt , "\r\nidLineMileDad: " ) ;/*_M*/
                            OStEXTC( ostoRpt , tinSnap.idiFileMile , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nidiFileMile: " ) ;/*_M*/
                            OStEXTCmIN( ostoRpt , tinSnap.idLineMile , 4 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nidLineMile: " ) ;/*_M*/
                            OStEXTC( ostoRpt , tinSnap.idPhase3 , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nidPhase3: " ) ;/*_M*/
                            OStEXTC( ostoRpt , tinSnap.idPhase2 , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nidPhase2: " ) ;/*_M*/
                            }
                                OStEXTC( ostoRpt , tinSnap.idPhase1 , 0 ) ;/*_M*/
                            {/*_M*/
                            else
                            }
                                OStEXTA( ostoRpt , postIdPhase1 ) ;/*_M*/
                            {/*_M*/
                            if( postIdPhase1 )
                            const osTextT* postIdPhase1 = processGlobal3I.mapThreadPhase( tinSnap.idPhase1 ) ;
                            OStEXTAK( ostoRpt , "\r\nidPhase1: " ) ;/*_M*/
                            }
                                OStEXTC( ostoRpt , tinP.pAdamGlobal1->idPhaseAdam , 0 ) ;/*_M*/
                            {/*_M*/
                            else
                            }
                                OStEXTA( ostoRpt , postIdPhaseAdam ) ;/*_M*/
                            {/*_M*/
                            if( postIdPhaseAdam )
                            const osTextT* postIdPhaseAdam = processGlobal3I.mapProcessPhase( tinP.pAdamGlobal1->idPhaseAdam ) ;
                            OStEXTAK( ostoRpt , "\r\nidPhaseAdamI: " ) ;/*_M*/
                            }
                                OStEXTC( ostoRpt , processGlobal1I.idPhaseProcess , 0 ) ;/*_M*/
                            {/*_M*/
                            else
                            }
                                OStEXTA( ostoRpt , postIdPhaseProcess ) ;/*_M*/
                            {/*_M*/
                            if( postIdPhaseProcess )
                            const osTextT* postIdPhaseProcess = processGlobal3I.mapIdPhaseProcess( processGlobal1I.idPhaseProcess ) ;
                            OStEXTAK( ostoRpt , "\r\nidPhaseProcess: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.pAdamGlobal1->idAdam , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\npAdamGlobal1->idAdam: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      processGlobal1I.idAdamRoot , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nprocessGlobal1I.idAdamRoot: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      processGlobal1I.idHome , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\"\r\nprocessGlobal1I.idHome: " ) ;/*_M*/
                            OStEXTA(  ostoRpt , thirdC::postUserNameIF() ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nbase os user name: \"" ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.monitor.idThread , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nidThread: " ) ;/*_M*/
                            OStEXTA(  ostoRpt ,      processGlobal1I.postDllsLoaded ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ndll load history: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      processGlobal1I.cDllLoaded , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ncDllLoaded: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      thirdC::os_cAllOrphanThreadsI_IF( tinP ) , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ncAllOrphanThreadsI: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.cKidThreads , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ntinP.cKidThreads: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      thirdC::os_cAllKidThreadsI_IF( tinP ) , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ntinP.pAdamGlobal1->_thirdC_.cAllKidThreads: " ) ;/*_M*/
                            }}
                                OStEXTC( ostoRpt , tinSnap.pPanLifiRecurseGrabbedLevel[ off + 3 ] , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , " " ) ;/*_M*/
                                OStEXTC( ostoRpt , tinSnap.pPanLifiRecurseGrabbedLevel[ off + 2 ] , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , " " ) ;/*_M*/
                                OStEXTC( ostoRpt , tinSnap.pPanLifiRecurseGrabbedLevel[ off + 1 ] , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , " " ) ;/*_M*/
                                OStEXTC( ostoRpt , tinSnap.pPanLifiRecurseGrabbedLevel[ off + 0 ] , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , "](pandle,idLineGrab,idiFileGrab,cRecurse): " ) ;/*_M*/
                                OStEXTC( ostoRpt , off , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , "\r\ntinP.pPanLifiRecurseGrabbedLevel[" ) ;/*_M*/
                            {
                            {for( countT off = 0 ; off < sizeof tinSnap.pPanLifiRecurseGrabbedLevel / sizeof tinSnap.pPanLifiRecurseGrabbedLevel[ 0 ] ; off += 5 )
                            }}
                                OStEXTC( ostoRpt , tinSnap.pcUtility[ off ] , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , "]: " ) ;/*_M*/
                                OStEXTC( ostoRpt , off , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , "\r\ntinP.pc" "Utility[" ) ;/*_M*/
                            {
                            {for( countT off = 0 ; off < sizeof tinSnap.pcUtility / sizeof tinSnap.pcUtility[ 0 ] ; off ++ )
                            }}
                                OStEXTC( ostoRpt , rootAdamGlobal1I._etherC_.pcUtility[ off ] , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , "]: " ) ;/*_M*/
                                OStEXTC( ostoRpt , off , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , "\r\netherC::pcUtilityI[" ) ;/*_M*/
                            {
                            {for( countT off = 0 ; off < CCuTILITY ; off ++ )
                            }}
                                OStEXTC( ostoRpt , processGlobal1I.pcUtility[ off ] , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , "]: " ) ;/*_M*/
                                OStEXTC( ostoRpt , off , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , "\r\nprocessGlobal1I.pcUtility[" ) ;/*_M*/
                            {
                            {for( countT off = 0 ; off < sizeof processGlobal1I.pcUtility / sizeof processGlobal1I.pcUtility[ 0 ] ; off ++ )
                            }}
                                OStEXTC( ostoRpt , processGlobal1I.pcPhaseLow[ off ] , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , "]: " ) ;/*_M*/
                                OStEXTC( ostoRpt , off , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , "\r\netherC::pcPhaseLowI[" ) ;/*_M*/
                            {
                            {for( countT off = 1 ; off <= ClOWtHREADS ; off ++ )
                            OStEXTAK( ostoRpt , "\"" ) ;/*_M*/
                            OStEXTA(  ostoRpt , tinSnap.postTellIf ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\"\r\npostTellIf: \"" ) ;/*_M*/
                            OStEXTA(  ostoRpt , tinSnap.postTellWait ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\"\r\npostTellWait: \"" ) ;/*_M*/
                            OStEXTA(  ostoRpt , tinSnap.postTell ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\npostTell: \"" ) ;/*_M*/
                            OStEXTC(  ostoRpt , tinSnap.monitor.idWhat2 , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nidWhat2: " ) ;/*_M*/
                            OStEXTA(  ostoRpt , processGlobal3I.mapWhat( tinSnap.monitor.idWhat1 ) ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nidWhat1: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.monitor.idWhat1 , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nU::debug [tinSnap.monitor.idWhat1]: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.idiFile_brcLath , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nidiFile_brcLath: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.idLine_brcLath , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nidLine_brcLath: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.brcLath , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nbrcLath: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.cGrabitC_unregistered , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ntinP.cGrabitC_unregistered: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.cGrabitC_registered , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ntinP.cGrabitC_registered: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.cGrabitC_reset , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ntinP.cGrabitC_reset: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.cGrabitC_set , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ntinP.cGrabitC_set: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.monitor.cGrabbed , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ncGrabbed: " ) ;/*_M*/

                            OStEXTC(  ostoRpt ,      processGlobal1I.idiFileBlammoCt , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nprocessGlobal1I.idiFileBlammoCt: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      processGlobal1I.idLineBlammoCt , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nprocessGlobal1I.idLineBlammoCt: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      processGlobal1I.idiFileBlammo , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nprocessGlobal1I.idiFileBlammo: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      processGlobal1I.idLineBlammo , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nprocessGlobal1I.idLineBlammo: " ) ;/*_M*/

                            OStEXTC(  ostoRpt ,      tinSnap.pAdamGlobal1->idiFileBlammoCt , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ntinP.pAdamGlobal1->idiFileBlammoCt: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.pAdamGlobal1->idLineBlammoCt , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ntinP.pAdamGlobal1->idLineBlammoCt: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.pAdamGlobal1->idiFileBlammo , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ntinP.pAdamGlobal1->idiFileBlammo: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.pAdamGlobal1->idLineBlammo , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ntinP.pAdamGlobal1->idLineBlammo: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      tinSnap.pAdamGlobal1->flagsAdamState , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\ntinP.pAdamGlobal1->flagsAdamState: " ) ;/*_M*/
                            OStEXTC(  ostoRpt , bCleanFailed , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nbCleanFailed: " ) ;/*_M*/
                            OStEXTC(  ostoRpt ,      (const countT)*tinSnap.pPoop , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\nPOOP: " ) ;/*_M*/
                            }
                                }
                                    }
                                        BLOBpOP( prFloatP )
                                        }
                                            }
                                                OStEXTAK( ostoRpt , " " ) ;/*_M*/
                                            {/*_M*/
                                            if( off == - 1 )
                                    
                                            }
                                                OStEXTAK( ostoRpt , ".." ) ;/*_M*/
                                            {/*_M*/
                                            else
                                            }
                                                if( pbCode[ off ] < 0x10 ) OStEXTAS( ostoRpt , '0' ) ;/*_M*/
                                                OStEXTC( ostoRpt , pbCode[ off ] , 0 ) ;/*_M*/ //WILL GP IF CODE IS NO LONGER PRESENT IN MEMORY (E.G. DURING SHUTDOWN) OR IF THE OFFENDING EIP IS VERY CLOSE TO A MEMORY BOUNDARY SO THAT THE RANGE OF THIS LOOP CROSSES THAT BOUNDARY
                                                prFloatP->flags |= flRESTARTc_QUIET ;/*_M*/
                                            {/*_M*/
                                            if( !*prFloatP )

                                            RESTARTrEF( *prFloatP )
                                        {
                                        BLOBpUSH( prFloatP , sizeof *prFloatP )
                                    {/*_M*/
                                    for( sCountT off = - 8 ; off <= 7 ; off ++ )
                                    byteT* pbCode = (byteT*)tellInfo.pvOffendingCode ;/*_M*/
                                    OStEXTAK( ostoRpt , "\r\ncodes [-8,7]: " ) ;/*_M*/
                                {/*_M*/
                            
                                OStEXTAK( ostoRpt , ")" ) ;/*_M*/
                                OStEXTC(  ostoRpt , (countT)tellInfo.pvOffendingCode - tinSnap.pEIPInNest[ tinSnap.monitor.cInNest & OFFsLOTtINnESTmAX ] , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , " (offset from in: " ) ;/*_M*/
                                OStEXTC(  ostoRpt , tellInfo.pvOffendingCode , 0 ) ;/*_M*/
                                OStEXTAK( ostoRpt , " at " ) ;/*_M*/
                            {/*_M*/
                            if( tellInfo.idException != ifcIDeVENTeXCEPTIONmONITORED_GRUNT )
                            OStEXTA(  ostoRpt , tinSnap.postThreadName ) ;/*_M*/
                            OStEXTAK( ostoRpt , ") exception occured while executing thread\r\n" ) ;/*_M*/
                            OStEXTC(  ostoRpt , tellInfo.idException , 0 ) ;/*_M*/
                            OStEXTAK( ostoRpt , " (" ) ;/*_M*/
                            OStEXTA(  ostoRpt , processGlobal3I.mapExceptionType( tellInfo.idException ) ) ;/*_M*/
                            OStEXTAK( ostoRpt , "Subject: IPDOS (tm) Exception Event\r\n\r\nIdeaFarm " "(tm) Piggyback Distributed Operating System\r\nhttp://ideafarm.com\r\nWo'O Ideafarm\r\n \r\nAn " ) ;/*_M*/
                            OStEXTAK( ostoRpt , "\r\n//\r\n// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.\r\n//\r\n// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.\r\n// Respecting the rights of other people is an important part of empowering one another.\r\n//\r\n\r\n" ) ;/*_M*/

                            osTextC   ostoRpt( COSTArPTeXCEPTION - 2 * sizeof( countT ) , 0 , tinP.postRptExceptionLath - sizeof( countT ) , COSTArPTeXCEPTION ) ;/*_M*/
                        {/*_M*/
                        if( *processGlobal1I.postPathHomeTmp )

                        //CONoUTrAW( "osExceptionHandlerWorkIF/5\r\n" ) ;
                        //CONoUTrAW9( " [bosTicks,idHome,idAdamRoot,idAdam]: " , thirdC::osTimeTicksSinceBootIF() , "/" , processGlobal1I.idHome , "/" , processGlobal1I.idAdamRoot , "/" , tinSnap.pAdamGlobal1->idAdam , ": UNHANDLED EXCEPTION\r\n" ) ;
                        //CONoUTrAW( "osExceptionHandlerWorkIF/4\r\n" ) ;
                        LOGrAW9( " [bosTicks,idHome,idAdamRoot,idAdam]: " , thirdC::osTimeTicksSinceBootIF() , "/" , processGlobal1I.idHome , "/" , processGlobal1I.idAdamRoot , "/" , tinSnap.pAdamGlobal1->idAdam , ": UNHANDLED EXCEPTION (NO RESTART HANDLER FOUND)\r\n" ) ;
                        LOGrAW( thirdC::postUserNameIF() ) ;
                        //CONoUTrAW( "osExceptionHandlerWorkIF/3\r\n" ) ;

                        homeS::homeIF().flags |= flHOMEs_EXCEPTIONhASoCCURRED ;
                    {/*_M*/
                    if( idMe <= 1 ) //CAN BE CHANGED; "1" LIMITS EACH PROCESS TO 1 REPORT; FOR PRODUCTION, PERHAPS IT WOULD BE BEST TO SET THIS TO 1 (SO THAT I KNOW WHICH EXCEPTION HAPPENED WOTH)
                    //20160610@0912: "2" -> "1" IN THE NEXT LINE
                    countT idMe = 1 + incv02AM( cRpts ) ;/*_M*/
                    static countT cRpts ;/*_M*/
                    //CONoUTrAW( "osExceptionHandlerWorkIF/2\r\n" ) ;
                {/*_M*/
                if( !bFixed || !bQuiet )
                //CONoUTrAW( "osExceptionHandlerWorkIF/1\r\n" ) ;
                TINSL

                }
                    BLOBpOP( prFloatP )

                    }
                        // }
                        //     //if( pTinSave ) pTinF() = pTinSave ;
                        // 
                        //     //CONoUTrAW3( "osExceptionHandlerWorkIF: cleanup done [cDeleted]: " , cDeleted , "\r\n" ) ;
                        //     }
                        //         }
                        //             if( pTin->pClean == pTin ) pTin = pTinF() ;
                        // 
                        //             cDeleted ++ ;
                        //             { TINSL THREADmODE3rESTORE THREADmODE2rESTORE }
                        //             delete pTin->pClean ;
                        //             THREADmODE3oN( flTHREADmODE3_EXCEPTIONcLEANUPdELETIONiNpROGRESS )
                        //             THREADmODE2oN( flTHREADmODE2_DOnOTcaLLdELif )
                        //             //CONoUTrAW3( "osExceptionHandlerWorkIF:   deleting [pClean]: " , pTin->pClean , "\r\n" ) ;
                        // 
                        //             break ;
                        //             )
                        //                 pTin->pClean == (cleanC*)&processGlobal5I.tinBreak // ExitProcess WILL CALL THE DLL TERMINATION ROUTINE, WHICH WILL DELETE tinBreak ; THIS LINE MUST TEST FOR THE LATH cleanC DERIVED INSTANCE CONSTRUCTED DURING DLL INITIALIZATION
                        //                 ||
                        //                 ( bFixed && ebpAtRestart && ebpAtRestart < (countT)pTin->pClean )
                        //             (
                        //             if
                        //             tinS& tinP = *pTin ; //THIS IS JUST FOR THE CONoUTrAW CALLS
                        //         {
                        //         while( pTin->pClean )
                        // 
                        //         //U:: THE FOLLOWING CODE WILL NOT DESTROY THE INTENDED INSTANCES IF THE WOTH cleanC INSTANCE IS IN poolC AND HAPPENS TO HAVE A HIGHER ADDRESS THAN THE ADDRESSES ON THE STACK FOR THE INSTANT THREAD
                        //         //U:: 20140404@2006: BUG: SOME cleanC INSTANCES ARE NOT ON A THREAD STACK.  (tinS INSTANCES CAN BE IN THE poolC.)  CONJ: ORIGINALLY, cleanC WAS ENVISIONED AS ASSUMING THAT ALL INSTANCES ARE ON A THREAD STACK.  CONJ: EXCEPTION HANDLER CODE ASSUMES THIS AND WILL BREAK IF A cleanC INSTANCE IS NOT ON A THREAD STACK
                        // 
                        //         // WILL ALWAYS DESTROY cleanC INSTANCES IN THE STACK FRAMES OF AND WITHIN THE RESTART POINT ; IF !bFixed OR NOT EXIST RESTART POINT THEN WILL DESTROY ALL cleanC INSTANCES
                        // 
                        //         //
                        //         //  * SIMPLE RECIPE:  AT THE BEGINNING OF THE RESTART BLOCK, TALLY THE NUMBER OF cleanC INSTANCES REGISTERED.  ON RESTART, IF bFixed, DELETE ALL NEW INSTANCES.  IF !bFixed, DO NOTHING
                        //         //
                        //         //  * FORGET ABOUT STACK FRAMES
                        //         //
                        //         //  * RESTART BLOCKS CAN BE NESTED (NOT SURE WHETHER CURRENT CODE SUPPORTS THIS)
                        //         //
                        //         //  * ANY CLASS CAN BE DERIVED FROM cleanC SUCH THAT EACH INSTANCE REGISTERS ITSELF FOR CLEANUP (CURRENT CODE SUPPORTS THIS; NO NEW CRAFTWORK NEEDED)
                        //         //
                        //         // WISH LIST FOR cleanC SUPPORT
                        //         //
                        //         //FUTURE CRAFTWORK:  REWRITE THIS LOOP ACCORDING TO THE FOLLOWING WISH LIST
                        // 
                        //         //20171003@1354: DECISION: JUST COMMENT THIS OUT.  DO NOT DESTROY tinS INSTANCES CT WITHIN A RESTART BLOCK
                        //         //THE FOLLOWING CODE DOES NOT WORK CORRECTLY SO ISN'T A GOOD EXAMPLE
                        //         //THERE ISN'T REALLY ANY NEED TO CLEAN UP tinS INSTANCES BECAUSE tinS INSTANCES WILL NEVER BE CT ON THE STACK BY APPLICATION CODE
                        //         //THINK: THIS CODE WAS WRITTEN MAINLY TO SERVE AS AN EXAMPLE OF HOW TO USE cleanC TO PERFORM CLEANUP DURING RESTART
                        //         //20171003@1354:  CONJECTURE: THE INTENT HERE IS TO DESTROY tinS INSTANCES CONSTRUCTED ON THE STACK WITHIN THE RESTART BLOCK
                        // 
                        //         tinS* pTin = &tinP ;
                        //         //CONoUTrAW( "osExceptionHandlerWorkIF: clean +\r\n" ) ;
                        // 
                        //         if( !bFixed ) tinP.cKidThreads = 0 ;
                        //         if( &tinP != pTinMainI ) { BLAMMO ; }
                        //         TINSL
                        //     {
                        //     ZE( countT , cDeleted ) ;
                        // 
                        //     ;
                        //         : ( pTinF() = pTinMainI , &tinP )
                        //         ? 0
                        //     tinS* pTinSave = &tinP == pTinMainI
                        // {/*_M*/
                        // else
                        // 20171003@1405:  COMMENTED THIS OUT TO WORK AROUND INSTABILITY DURING EXCEPTION HANDLING.  REWRITE IF cleanC SUPPORT IS EVER NEEDED.  THIS cleanC FUNCTIONALITY IS REALLY A DOODLE THAT ISN'T NEEDED FOR IPDOS (tm) TO WORK

                        }
                            bCleanFailed = 1 ; //U::REPORT THIS
                            //CONoUTrAW( "osExceptionHandlerWorkIF: skipping clean\r\n" ) ;
                        {/*_M*/
                        if( *prFloatP )

                        RESTARTrEF( *prFloatP )
                    {

                    BLOBpUSH( prFloatP , sizeof *prFloatP )
                {/*_M*/
                if( bFixed ) //U::ADDED THIS TEST AS WORKAROUND TO MAKE EXCEPTION REPORTING RELIABLE RATHER THAN ALLOWING BLOCKAGE TO OCCUR IN DT'OR FOR tinS
                ZE( boolT , bCleanFailed ) ;
                //U::ISSUE: IF THE EXCEPTION IS NOT ON MAIN THREAD THEN THIS WILL NOT CLEAN UP THE INTENDED ITEMS FOR DLL TERMINATION

                }
                    processGlobal1I.osTidTerminator = tinP.brcRaw ;
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , GetCurrentThreadId() )
                    processGlobal1I._thirdC_flagsProcessState |= flPROCESSsTATE_EXCEPTIONnOThANDLED ;
                {
                if( !bFixed )

                }
                    }
                        //TELL( "osExceptionHandlerWorkIF/rolled back registers" )
                        #endif

                            osInfoP.ContextRecord->SegCs                 = pr->pcRegisters[ 0xf ] ;/*_M*/
                            osInfoP.ContextRecord->SegSs                 = pr->pcRegisters[ 0xe ] ;/*_M*/
                            osInfoP.ContextRecord->SegGs                 = pr->pcRegisters[ 0xd ] ;/*_M*/
                            osInfoP.ContextRecord->SegFs                 = pr->pcRegisters[ 0xc ] ;/*_M*/
                            osInfoP.ContextRecord->SegEs                 = pr->pcRegisters[ 0xb ] ;/*_M*/
                            osInfoP.ContextRecord->SegDs                 = pr->pcRegisters[ 0xa ] ;/*_M*/
                            osInfoP.ContextRecord->EFlags                = pr->pcRegisters[ 0x9 ] ;/*_M*/
                            osInfoP.ContextRecord->Eip                   = pr->pcRegisters[ 0x8 ] ;/*_M*/
                            osInfoP.ContextRecord->Esp                   = pr->pcRegisters[ 0x7 ] ;/*_M*/
                            osInfoP.ContextRecord->Ebp    = ebpAtRestart = pr->pcRegisters[ 0x6 ] ;/*_M*/
                            osInfoP.ContextRecord->Edi                   = pr->pcRegisters[ 0x5 ] ;/*_M*/
                            osInfoP.ContextRecord->Esi                   = pr->pcRegisters[ 0x4 ] ;/*_M*/
                            osInfoP.ContextRecord->Edx                   = pr->pcRegisters[ 0x3 ] ;/*_M*/
                            osInfoP.ContextRecord->Ecx                   = pr->pcRegisters[ 0x2 ] ;/*_M*/
                            osInfoP.ContextRecord->Ebx                   = pr->pcRegisters[ 0x1 ] ;/*_M*/
                            osInfoP.ContextRecord->Eax                   = pr->pcRegisters[ 0x0 ] ;/*_M*/

                            ebpAtException = osInfoP.ContextRecord->Ebp ;/*_M*/

                        #if defined( __NT__ )

                        if( F(pr->flags) & flRESTARTc_QUIET ) bQuiet = 1 ;/*_M*/
                        bFixed = 1 ;/*_M*/
                        if( !( F(pr->flags) & flRESTARTc_DOnOTtALLY ) ) pr->cRestarted ++ ;/*_M*/
                        //TELL( "osExceptionHandlerWorkIF/rolling back registers" )
                    {/*_M*/
                    if( pr )

                    //TELL( "osExceptionHandlerWorkIF/looked for a restartC" )
                    }
                        pr = pr->prD ;/*_M*/

                        else if( pr->bAcceptF( &tinP , tellInfo ) ) break ;
                             if( F(pr->flags) & flRESTARTc_SKIP    ) ;
                    {/*_M*/
                    while( pr )
                    pr = tinP.pRestart ;/*_M*/
                    restartC* pr ;/*_M*/
                    //TELL( "osExceptionHandlerWorkIF/looking for a restartC" )
                {/*_M*/
                if( !bFixed )
                ZE( countT , ebpAtException ) ;
                ZE( countT , ebpAtRestart ) ;

                tellInfo.cFixed = cFixed ;/*_M*/
                tellInfo.bFixed = bFixed ;/*_M*/
                }
                    inc02AM( cFixed ) ;/*_M*/
                {/*_M*/
                if( bFixed )

                }
                    }
                        break ;
                        ADVICE( "COMPUTER CIRCUITRY" , "Use the Services icon to stop the IdeaFarm driver.  Reboot if necessary.  Start the driver." , "" ) ;/*_M*/
                        tellInfo.pcInfo[ 0 ] = osInfoP.ExceptionRecord->ExceptionCode ;/*_M*/
                        tellInfo.ccInfo = 1 ;/*_M*/
                        tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_NOTlISTED ;/*_M*/
                    {/*_M*/
                    default :
                    }
                        break ;
                        ADVICEdFLT ;/*_M*/
                        for( countT off = 0 ; off < tellInfo.ccInfo ; off ++ ) tellInfo.pcInfo[ off ] = osInfoP.ExceptionRecord->ExceptionInformation[ off ] ;/*_M*/
                        if( tellInfo.ccInfo > sizeof tellInfo.pcInfo / sizeof tellInfo.pcInfo[ 0 ] ) tellInfo.ccInfo = sizeof tellInfo.pcInfo / sizeof tellInfo.pcInfo[ 0 ] ;/*_M*/
                        tellInfo.ccInfo = osInfoP.ExceptionRecord->NumberParameters ;/*_M*/
                        tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_BLAMMO ;/*_M*/
                        //bFixed = 1 ;/*_M*/
                        //2011.04.10: COMMENTED OUT NEXT LINE SO THAT EXCEPTION HANDLER WOULD NOT BLOCK CLEANING UP BY DELETING tinS FOR A THREAD THAT HAS KIDS
                    {/*_M*/
                    case ifcIDeVENTeXCEPTIONmONITORED_BLAMMO              : //SEEN IT NOT BE CLEARED_
                    case ifcIDeVENTeXCEPTIONmONITORED_BLAMMO & 0xefffffff : //WINDOWS CLEARS BIT 28 IN RaiseException(...)
                    }
                        break ;
                        ADVICEdFLT ;/*_M*/
                        for( countT off = 0 ; off < tellInfo.ccInfo ; off ++ ) tellInfo.pcInfo[ off ] = osInfoP.ExceptionRecord->ExceptionInformation[ off ] ;/*_M*/
                        if( tellInfo.ccInfo > sizeof tellInfo.pcInfo / sizeof tellInfo.pcInfo[ 0 ] ) tellInfo.ccInfo = sizeof tellInfo.pcInfo / sizeof tellInfo.pcInfo[ 0 ] ;/*_M*/
                        tellInfo.ccInfo = osInfoP.ExceptionRecord->NumberParameters ;/*_M*/
                        tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_GRUNT ;/*_M*/
                        //bFixed = 1 ;/*_M*/
                        //2011.04.10: COMMENTED OUT NEXT LINE SO THAT EXCEPTION HANDLER WOULD NOT BLOCK CLEANING UP BY DELETING tinS FOR A THREAD THAT HAS KIDS
                    {/*_M*/
                    case ifcIDeVENTeXCEPTIONmONITORED_GRUNT              : //SEEN IT NOT BE CLEARED_
                    case ifcIDeVENTeXCEPTIONmONITORED_GRUNT & 0xefffffff : //WINDOWS CLEARS BIT 28 IN RaiseException(...)
                    }
                        break ;

                        }
                            ADVICEdFLT ;/*_M*/
                        {/*_M*/

                        if( cCodeReadRetries ) ;
                        //else
                        //}
                        //    THREADmODE1rESTORE
                        //    }
                        //        ++ s ; dosSleepIF( tinP , cCodeReadRetries == 1 ? TUCK * 0x40 : TOCK ) ;
                        //        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        //    {
                        //    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                        //    LOGrAW5( "i will nap and then retry " , cCodeReadRetries , " to read code at " , tellInfo.pcInfo[ 1 ] , "\r\n" ) ;
                        //    bQuiet = bFixed = 1 ;/*_M*/
                        //{/*_M*/
                        //if( !tellInfo.pcInfo[ 0 ] && tellInfo.pcInfo[ 1 ] == (countT)tellInfo.pvOffendingCode && incv02AM( cCodeReadRetries ) < 0x4 )

                        tellInfo.pcInfo[ 1 ] =   osInfoP.ExceptionRecord->ExceptionInformation[ 1 ] ;/*_M*/ // pvTarget
                        tellInfo.pcInfo[ 0 ] = !!osInfoP.ExceptionRecord->ExceptionInformation[ 0 ] ;/*_M*/ // bWrite
                        tellInfo.ccInfo = 2 ;/*_M*/
                        tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_ACCESSvIOLATION ;/*_M*/
                    {/*_M*/
                    case EXCEPTION_ACCESS_VIOLATION                          :
                    case DBG_CONTINUE                                        : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_DBGcONTINUE             ; ADVICEdFLT ; break ; }
                    case DBG_TERMINATE_THREAD                                : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_DBGtERMINATEtHREAD      ; ADVICEdFLT ; break ; }
                    case DBG_TERMINATE_PROCESS                               : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_DBGtERMINATEpROCESS     ; ADVICEdFLT ; break ; }
                    case DBG_CONTROL_C                                       : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_DBGcONTROLc             ; ADVICEdFLT ; break ; }
                    case DBG_CONTROL_BREAK                                   : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_DBGcONTROLbREAK         ; ADVICEdFLT ; break ; }
                    case DBG_EXCEPTION_NOT_HANDLED                           : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_DBGnOThANDLED           ; ADVICEdFLT ; break ; }
                    case CONTROL_C_EXIT                                      : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_CONTROLcnOTIFICATION    ; ADVICEdFLT ; break ; } //U: NOT TESTED.  THE OS CONSTANT LISTED IN WIN32 DOC IS "DBG_CONTROL_C"; CONJ: THIS IS A DOC ERROR; DBG_CONTROL_C IS MEANT TO BE A CODE THAT A DEBUGGER CAN RETURN IN ORDER TO RAISE A CONTROL_C EXCEPTION
                    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED                     : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_ARRAYbOUNDSeXCEEDED     ; ADVICEdFLT ; break ; }
                    case EXCEPTION_DATATYPE_MISALIGNMENT                     : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_DATATYPEmISALIGNMENT    ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_DENORMAL_OPERAND                      : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOATdENORMALoPERAND    ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_DIVIDE_BY_ZERO                        : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOATdIVIDEbYzE       ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_INEXACT_RESULT                        : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOATiNEXACTrESULT      ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_INVALID_OPERATION                     : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOATiNVALIDoPERATION   ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_OVERFLOW                              : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOAToVERFLOW           ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_STACK_CHECK                           : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOATsTACKcHECK         ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_UNDERFLOW                             : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOATuNDERFLOW          ; ADVICEdFLT ; break ; }
                    case EXCEPTION_ILLEGAL_INSTRUCTION                       : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_ILLEGALiNSTRUCTION      ; ADVICEdFLT ; break ; }
                    case EXCEPTION_IN_PAGE_ERROR                             : {/*_M*/ bFixed = 1 ; tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_INpAGEeRROR             ; ADVICE( "HARD DRIVE" , "Use the Services icon to stop the IdeaFarm driver.  Reboot if necessary.\r\nClose all Windows and stop all unnecessary services, to unload the computer.\r\nStart the driver." , "Look for other evidence that the hard drive might be starting to fail." ) ; break ; }
                    case EXCEPTION_INT_DIVIDE_BY_ZERO                        : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_INTEGERdIVIDEbYzE     ; ADVICEdFLT ; break ; }
                    case EXCEPTION_INT_OVERFLOW                              : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_INTEGERoVERFLOW         ; ADVICEdFLT ; break ; }
                    case EXCEPTION_INVALID_DISPOSITION                       : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_INVALIDdISPOSITION      ; ADVICEdFLT ; break ; }
                    case EXCEPTION_NONCONTINUABLE_EXCEPTION                  : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_NONCONTINUABLEeXCEPTION ; ADVICEdFLT ; break ; }
                    case EXCEPTION_PRIV_INSTRUCTION                          : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_PRIVILEGEDiNSTRUCTION   ; ADVICEdFLT ; break ; }
                    case EXCEPTION_STACK_OVERFLOW                            : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_STACKoVERFLOW           ; ADVICEdFLT ; break ; }
                    case EXCEPTION_SINGLE_STEP                               : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_SINGLEsTEP              ; ADVICEdFLT ; break ; }
                    case EXCEPTION_BREAKPOINT                                : {/*_M*/              tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_BREAKPOINT              ; ADVICEdFLT ; break ; }
                {
                else switch( osInfoP.ExceptionRecord->ExceptionCode )
                }
                    tellInfo.idException = ifcIDeVENTeXCEPTIONmONITORED_CODEnOTaVAILABLE ; ADVICEdFLT ;/*_M*/
                {/*_M*/
                if( !osInfoP.ExceptionRecord )
                static boolT cFixed ;/*_M*/
                ZE( boolT , bQuiet ) ;/*_M*/

                tellInfo.postSuspect[ 0 ] = 0 ;/*_M*/
                tellInfo.pcInfo[ 4 ] = tellInfo.pcInfo[ 3 ] = tellInfo.pcInfo[ 2 ] = tellInfo.pcInfo[ 1 ] = tellInfo.pcInfo[ 0 ] = tellInfo.ccInfo = 0 ;/*_M*/
                tellInfo.pvOffendingCode = !osInfoP.ExceptionRecord ? 0 : osInfoP.ExceptionRecord->ExceptionAddress ;/*_M*/
                //TELL( "osExceptionHandlerWorkIF/filling tellInfo" )

                }
                    OStEXTCmIN( ostoSuspectDflt , tinSnap.pAdamGlobal1->idAdam , 7 ) ;/*_M*/
                    OStEXTAK( ostoSuspectDflt , "/" ) ;/*_M*/
                    OStEXTCmIN( ostoSuspectDflt , processGlobal1I.idAdamRoot , 7 ) ;/*_M*/
                    OStEXTAK( ostoSuspectDflt , "IdeaFarm " "(tm) Cell " ) ;/*_M*/
                {/*_M*/
                else
                }
                    OStEXTAK( ostoSuspectDflt , "IdeaFarm " "(tm) Operating System Driver" ) ;/*_M*/
                {/*_M*/
                if( bDriver )
                OStEXT( ostoSuspectDflt , TUCK ) /*_M*/
                const boolT bDriver = !!( F(thirdC::third_flagsModeProcess1I_IF(tinP)) & flMODEpROCESS1_DRIVER ) ;/*_M*/
            {/*_M*/
        {/*_M*/
        scoopC _scoop( tinP , _poop , flSCOOPc_DOnOTcHECKtINiD ) ;/*_M*/
        poopC _poop( flPOOP_null ) ;/*_M*/
        static countT cCodeReadRetries ;

        const tinS&          tinSnap  = *(tinS*)tellInfo.pbTin ;
        tellInfoExceptionS&  tellInfo = *tinP.pTieLath ;/*_M*/

        //TELL( "osExceptionHandlerWorkIF/+" )
        //A: ASSUME: tinP.pTieLath POINTS TO A STRUCTURE THAT CONTAINS AN IMAGE OF tinP AT EXCEPTION EVENT TIME
    {
    ZE( boolT , bFixed ) ;
    _INoLD_

    THREADmODE3oN( flTHREADmODE3_EXCEPTIONrEPORTINGiNpROGRESS )

    TINSL
    ebpTlsAM() = ebpOffenderP ; //THIS IS NEEDED BECAUSE SOMETIMES THE TLS IS NOT IN THE STACK CHAIN (E.G. WHEN TINSL WOULD FAIL AT BEGINNING OF winMessageHandlerWorkF)

    restartC*&           prFloatP     =           *(restartC**)c8p.c4 ;
    countT               ebpOffenderP =                        c8p.c3 ;
    countT&              idMile       =              *(countT*)c8p.c2 ;
    _EXCEPTION_POINTERS& osInfoP      = *(_EXCEPTION_POINTERS*)c8p.c1 ;
    count8S& c8p = *(count8S*)cArgP ;
{
/*1*/boolT thirdC::osExceptionHandlerWorkIF( const countT cArgP )/*1*/

#define ADVICEdFLT ADVICE( ostoSuspectDflt , "Use the Services icon to stop the IdeaFarm driver.\r\nReboot if necessary.  Start the driver." , "" )

 thirdC::c_strncpyIF( tinP , tellInfo.postFix2    , postFix2P    , sizeof tellInfo.postFix2    ) ;
 thirdC::c_strncpyIF( tinP , tellInfo.postFix1    , postFix1P    , sizeof tellInfo.postFix1    ) ;  \
 thirdC::c_strncpyIF( tinP , tellInfo.postSuspect , postSuspectP , sizeof tellInfo.postSuspect ) ;  \
                                                                                                    \
#define ADVICE(postSuspectP,postFix1P,postFix2P)                                                    \

//  b. USING BLAMMO IN ~tinS SEEMS TO CAUSE EXECUTION TO HALT (EDITED TO CALL ExitProcess NOT BLAMMO IN ~tinS)
//  a. ~tinS CAN SLEEP FOREVER WAITING FOR KID THREADS
// THESE WORKAROUNDS AVOID 2 SEPARATE PROBLEMS OCCURING DURING ~tinS
// 3. EDITED ~tinS TO NOT WAIT FOR KIDS IF I AM ACTIVE, BUT TO INSTEAD CALL ExitProcess
// 2. CLEAN ONLY IF bFixed
// 1. MADE GRUNT !bFixed
// WORKAROUNDS TO MAKE EXCEPTION REPORTING RELIABLE

/**/
*/
it is illegal to refer to this symbol in the definition of an adam
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

