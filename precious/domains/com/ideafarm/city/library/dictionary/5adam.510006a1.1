
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        ++ s ; etThread.osSleepF( tinP ) ;
    {
    while( cReaders )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    etherC::loafIF( tinP ) ;

    }
        etThread.osThreadF( TaRG1( tmReadF ) , (countT)&bksFoo , (countT)&cReaders ) ;
        inc02AM( cReaders ) ;
    {
    while( cDo -- )
    countT cDo = 2 ;
    ZE( countT , cReaders ) ;

    booksC bksFoo( tinP , TAG( TAGiDnULL ) , "foo" , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKSc_null , 0 , 0 , 0 , 0 , 0 , 0 ) ;
{

}
    }
        bOut ++ ;
        bksFoo.writeF( tinP , &bOut , 1 , 0 , 0 , flBOOKScwRITE_ALLOWoDDlENGTH , 0 , 0 ) ;
        if( ido == cbCapacity + 1 ) bOut = 'A' ;        
    {
    for( countT ido = 1 ; ido <= cDo ; ido ++ )
    byteT bOut = 'a' ;

    countT cDo = cbCapacity << 1 ;

    booksC bksFoo( tinP , TAG( TAGiDnULL ) , "foo" , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKSc_WRITER | flBOOKSc_PURGEoNcT , cbCapacity , 0 , 0 , 0 , 0 , 0 ) ;
{

countT cbCapacity = TUCK >> 4 ;

TODO

DONE( tmReadF )
}
    dec02AM( cReadersP ) ;

    }
        }
            }
                //++ s ; etThread.osSleepF( tinP ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( !( cCyclesDone % 0x10 ) )

            c2AppNote.c2 = idMe ;

            cCyclesDone ++ ;
        {
        if( !c2AppNote.c1 )

        }
            }
                }
                    }
                        CONoUTrAW( pb4 ) ;

                        byteT pb4[] = { '>' , *(const byteT*)pageFoo , '<' , 0 } ;

                        //++ s ; etThread.osSleepF( tinP ) ;
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    while( cDo -- )
                    countT cDo = 2 ;
                {
                //if( !( cCyclesDone % pModulo[ idMe ] ) )

                CONoUTrAW( pb2 ) ;

                byteT pb2[] = { *(const byteT*)pageFoo , 0 } ;
            {
            if( (const byteT*)pageFoo && pageFoo )

            pageC page2 = pageFoo ;

            //pageC page( tinP , bksFooP , pbi , cbi , bDelete ? flPAGEc_DELETE : flPAGEc_null ) ;
        {

        if( *pbzBlammo ) ;
        const byteT* pbzBlammo = pageFoo ;

        bksFooP.readF( tinP , pageFoo , hBks , flBOOKScrEAD_null ) ;
        pageC pageFoo( tinP , bksFooP , 1 ) ;

        //boolT bDelete = bksFooP.readF( tinP , pbi , cbi , hBks , flBOOKScrEAD_INCREMENTrEFERENCEcOUNTiF ) ;
        //countT cbi = 1 ;
        //ZE( const byteT* , pbi ) ;
    {
    while( !ether )
    ZE( countT , cCyclesDone ) ;

    c2AppNote.c2 = idMe ;
    c2AppNote.c1 = 0 ;

    HANDLEaPPnOTEScOUNTcLASS& c2AppNote = hBks ;
    handleC hBks( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;

    //if( idMe == 1 ) etherC::loafIF( tinP ) ;

    countT pModulo[] = { 0 , 13 , 17 } ;

    countT idMe = 1 + incv02AM( idMeLath ) ;
    static countT idMeLath ;

    countT& cReadersP = *(countT*)pTaskP->c2 ;
    booksC& bksFooP   = *(booksC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmReadF )

/*1*/WAKEsHOWtEXT( "example.other.1snip.15000112.booksC.multithreaded.reading.using.pageC.smartpointer.functionality" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

