
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    delF( tinP , psttBlankList ) ;
    delF( tinP , psttEnd ) ;
    delF( tinP , psttOld ) ;

    }
        }
            delF( tinP , psttl ) ;

            }
                if( ide && idf ) strFuseF( tinP , psttP , psttEnd ) ;
                strFuseF( tinP , psttP , psttl ) ;
            {
            if( !idb || idb > 1 || idfb ) // IF THERE ARE EITHER LEADING OR TRAILING NONBLANKS

            countT idb = strIdAnyF( tinP , 0 , flSTRmATCH_null , idfb , sttqb , psttBlankList , psttl ) ; // FIND FIRST STRING OF BLANKS IN THIS LINE
            ZE( strokeS* , psttw ) ;
            strokeS sttqb( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idfb = 1 ;

            strSubstringF( tinP , psttl , idfSave , idl , psttOld ) ; ___( psttl ) ; // GET THIS LINE
            ZE( strokeS* , psttl ) ;
            countT idl = ide ? ide - 1 : 0 ;
        {
        if( !ide || ide > idfSave ) // IF THIS LINE IS NOT NULL

        countT ide = strIdAnyF( tinP , 0 , flSTRmATCH_null , idf , sttq , psttEnd , psttOld ) ; // FIND EOL.  NOW idf IS AT BEGINNING OF NEXT LINE
        strokeS sttqSave = sttq ;
        countT idfSave = idf ;
    {
    while( !POOP && idf ) 
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    countT idf = 1 ;
    strMakeF( tinP , LF , psttP , T("") , ( psttOld ? psttOld->idAdam : 0 ) + cEOL * ( psttEnd->idAdam - 1 ) ) ; // CALLER MUST TAG ___( psttP ) ;

    countT cEOL = strCLinesF( tinP , psttOld , psttEnd , 1 ) ;

    __NZ( psttP ) ;
    }
        psttP = 0 ;
        psttOld = psttP ;
    {
    else
    if( psttOldP ) { strMakeF( tinP , LF , psttOld , psttOldP ) ; ___( psttOld ) ; }
    ZE( strokeS* , psttOld ) ;

    else           { strMakeF( tinP , LF , psttEnd , T("\r\n") ) ; ___( psttEnd ) ; }
    if( psttEndP ) { strFuseF( tinP , psttEnd , psttEndP  ) ; ___( psttEnd ) ; }
    ZE( strokeS* , psttEnd ) ;

    else                 { strMakeF( tinP , LF , psttBlankList , T(" \t\x1a")   ) ; ___( psttBlankList ) ; }
    if( psttBlankListP ) { strFuseF( tinP , psttBlankList , psttBlankListP ) ; ___( psttBlankList ) ; }
    ZE( strokeS* , psttBlankList ) ;

    _IO_

    }
        if( POOP ) return ;
        __( psttEndP && !psttEndP->idAdam ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/**//*1*/voidT etherC::strRemoveBlankLinesF( tinS& tinP , strokeS*& psttP , const strokeS* const psttOldP , const strokeS* const psttEndP , const strokeS* const psttBlankListP )/*1*/
*/
    spaces (' '), tabs ('\t'), and end of file marks ('\x1a') are removed
   if 0 then T(" \t\x1a") is used
  lines containing only these strokes will be eliminated
 psttBlankListP
  T("\r\n\n\r\n\n\n\n\r\n")
  T("\n\r")
  T("\n")
  T("\r")
  T("\r\n")
  for example, T("\r\n") causes all of the substrings listed in this branch to delimit lines
  if 0 then T("\r\n") is used
  substrings consisting only of these strokes delimit each line
  cannot be of ze length
 psttEndP
  can be 0
 psttOldP
 psttP
arguments
 for example, "\n" is replaced with "\r\n"
replaces nonstandard line terminators with standard line terminators
removes null lines and blank lines
  \<A HREF=\"5.4b10104.1.1.0.html\"\>4b10104:  WAKEsHOW( "example.simplest.func.10300cd.etherc.strRemoveBlankLinesF" )\</A\>
 simplest
examples
\<A HREF=\"5.10300cd.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strRemoveBlankLinesF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

