
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //TELLsYSc1( ifcIDtYPEtELLsYS_AOKfYIeXCEPTIONhANDLERpUSH )

    handleP.osF( ifcIDtYPEhANDLE_CONSOLEhANDLER , (countT)pConsoleHandlerF ) ;
    #endif

        BOSpOOP
        BOS( WHATgbo , BOSoK , SetConsoleCtrlHandler( pConsoleHandlerF , 1 ) )

    #elif defined( __NT__ )

        }
            handleP.cNoteF( ifcIDtYPEhANDLE_CONSOLEhANDLER , (countT)pInfo ) ;
            }
                BOSpOOP
                BOS( WHATgbo , BOSfAIL , DosSetSignalExceptionFocus( SIG_SETFOCUS , &info ) )
                ZE( ULONG , info ) ;
            {
            BOSpOOP
            BOS( WHATgbo , BOSfAIL , DosSetExceptionHandler( pInfo ) )
            pInfo->ExceptionHandler = pConsoleHandlerF ;
            pInfo->prev_structure = 0 ;
        {
        if( pInfo )
        EXCEPTIONREGISTRATIONRECORD* pInfo = (EXCEPTIONREGISTRATIONRECORD*)pbInfo ;
        newF( tinP , LF , pbInfo , sizeof( EXCEPTIONREGISTRATIONRECORD ) ) ; ___( pbInfo ) ;
        ZE( byteT* , pbInfo ) ;

    #ifdef __OS2__

    consoleHandlerFT pConsoleHandlerF = pConsoleHandlerFP ? (consoleHandlerFT)pConsoleHandlerFP : consoleHandlerDfltF ;

    _IO_

    }
        if( POOP ) return ;
        __( ~handleP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
{
/*1*/voidT thirdC::dosPushConsoleHandlerIF( tinS& tinP , handleC& handleP , voidT* pConsoleHandlerFP )/*1*/

#endif

    }
        return 1 ;
        }
            //while( !( F(processGlobal1I._thirdC_flagsProcessState) & flPROCESSsTATE_GLOBALdESTRUCTIONiScOMPLETE ) ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
            //sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            etherC::etPrimeIF( tinP ).etherFireImpersonateMonitorIF( tinP ) ;
        {
        else if( bQuit )
        }
            //while( !( F(processGlobal1I._thirdC_flagsProcessState) & flPROCESSsTATE_GLOBALdESTRUCTIONiScOMPLETE ) ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
            //sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //TELLsYSc1( ifcIDtYPEtELLsYS_READYtOdIE ) ; // IFF I AM MONITORED, I WILL NEVER RETURN FROM THIS
            //CANNOT USE tellC HERE BECAUSE pTinF WILL NOT FIND THE TLS FRAME
            //state C::writeToDiskIfIF( tinP ) ;
        {
        if( bDie ) // FOR THE DRIVER f040104, I WILL DO bDie == 1, WHICH HAS NO EFFECT SINCE IT IS NOT MONITORED

        }
            thirdC::c_strncpyIF( tinP , tinP.postTell , ostoBuf , sizeof tinP.postTell ) ;
            OStEXTC( ostoBuf , cCloseIgnored , 0 ) ;
            OStEXTAK( ostoBuf , "refusalsToClose:" ) ;
            OStEXT( ostoBuf , sizeof tinP.postTell ) //CODEsYNC: 12f0006 10200cc
        {

        }
            }
                break ;
                TELL( "consoleHandlerDfltF/default-" )
                TELL( "consoleHandlerDfltF/default+" )
            {
            default:
            }
                break ;
                TELL( "consoleHandlerDfltF/CTRL_C_EVENT CTRL_CLOSE_EVENT-" )
                else bQuit = 1 ;
                }
                    //AV'S (AT LEAST IN WDW), AS IF pTinAM DOES NOT WORK ON Ctrl-c thread: thirdC::dosBeepIF( tinP , 0x100 , TUCK * 0x40 ) ;
                    inc02AM( cCloseIgnored ) ;
                {
                if( F(thirdC::third_flagsModeProcess1I_IF(tinP)) & flMODEpROCESS1_IGNOREfIREbYoPERATOR )
                TELL( "consoleHandlerDfltF/CTRL_C_EVENT CTRL_CLOSE_EVENT+" )
            {
            case CTRL_CLOSE_EVENT    :
            case CTRL_C_EVENT        :
            }
                break ;
                TELL( "consoleHandlerDfltF/CTRL_BREAK_EVENT CTRL_SHUTDOWN_EVENT-" )
                else                                                                                   bDie  = 1 ;
                if( F( thirdC::third_flagsModeProcess1I_IF( tinP ) ) & flMODEpROCESS1_QUITaTsHUTDOWN ) bQuit = 1 ;
                //THIS WOULD LOAD THE CPU WITH CLEANUP ACTIVITY: ((poolOld SideS&)*tinP.pAdamGlobal1->pPoolHomeTemp).flags ForestFire |= flFORESTfIRE_SHUTDOWN ;
                TELL( "consoleHandlerDfltF/CTRL_BREAK_EVENT CTRL_SHUTDOWN_EVENT+" )

                logGF( "CTRL_BREAK_EVENT or CTRL_SHUTDOWN_EVENT\r\n" ) ;
            {
            case CTRL_SHUTDOWN_EVENT :
            case CTRL_BREAK_EVENT    : // OPERATOR CAN SIMULATE SHUTDOWN BY KEYING Ctrl-Break IN ANY IFC CONSOLE
            }
                break ;
                TELL( "consoleHandlerDfltF/CTRL_LOGOFF_EVENT-" )
                if( F(thirdC::third_flagsModeProcess1I_IF(tinP)) & flMODEpROCESS1_QUITaTlOGOFF ) bQuit = 1 ;
                TELL( "consoleHandlerDfltF/CTRL_LOGOFF_EVENT+" )
            {
            case CTRL_LOGOFF_EVENT   :
        {
        switch( idType )
        ZE( boolT , bDie ) ;
        ZE( boolT , bQuit ) ;
        static countT cCloseIgnored ;

        _IO_
        TELL( "consoleHandlerDfltF/+" )
        tinP.osTid = tinP.brcRaw ;
        BOSpOOP
        BOS( WHATgbo , BOSoK , GetCurrentThreadId() )
        if( tinP.monitor.idThread - ifcIDtHREADlOW_break ) { BLAMMO ; }
        if( !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
        tinS& tinP = processGlobal5I.tinBreak ; //ASSUME: I AM CALLED SERIALLY (NEVER BY MULTIPLE THREADS SIMULTANEOUSLY) U:: ADD CODE TO SERIALIZE, JUST TO MAKE SURE
    {
    BOOL OSF consoleHandlerDfltF( DWORD idType ) // thirdC::thPrimeIF( tinP ) IS NOT STORED, BECAUSE THIS FUNCTION COULD EXECUTE LATE

//CONJ: THE STACK FOR THE O.S. THREAD THAT WILL CALL ME IS SMALL.  I CANNOT USE FUNCTIONS SUCH AS boxC::boxC
//THIS MUST RETURN QUICKLY (E.G. NOT SLEEP) BECAUSE THE O.S. BROADCASTS SHUTDOWN AND LOGOFF NOTICES SERIALLY

#elif defined( __NT__ )

    }
        else                                                                                                            return XCPT_CONTINUE_SEARCH ;
        if( pReportP && pReportP->ExceptionNum == XCPT_SIGNAL && pReportP->ExceptionInfo[ 0 ] != XCPT_SIGNAL_KILLPROC ) return XCPT_CONTINUE_EXECUTION ;
        pRegistrationP = pRegistrationP ; pContextP = pContextP ; pvP = pvP ;
    {
    ULONG _export OSF consoleHandlerDfltF( EXCEPTIONREPORTRECORD* pReportP , EXCEPTIONREGISTRATIONRECORD* pRegistrationP , CONTEXTRECORD* pContextP , voidT* pvP )

    //U: UPDATE THIS TO HAVE THE SAME FUNCTIONALITY AS THE NT FLAVOR

#if defined( __OS2__ )

/**/    
*/
  it is illegal to specify a value other than 0 in the definition of an adam
 pConsoleHandlerFP
  must be 0
 handleP
 tinP
arguments
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.10200cc.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$DosPushConsoleHandlerF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

