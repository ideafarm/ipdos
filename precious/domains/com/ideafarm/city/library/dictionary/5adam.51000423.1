
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        etThread = 0 ;

        }
            }
                }
                    etThread.delF( tinP , psttLog ) ;
                    //etThread.ifcSayF( tinP , psttLog , flSAY_APPEND | flSAY_LOG ) ;
                    etThread.strConcatenateF( tinP , psttLog , stPhrases ) ; ___( psttLog ) ;
                    ZE( strokeS* , psttLog ) ;

                    }
                        stPhrases << postOldC( tinP , etThread , T(" ")+TF1(idMetric)+T("/")+TF1(swTotal1)+(swTotal2?T("/")+TF1(swTotal2):T("")) ) ;
                        idMetric = swTotal1.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = swTotal1.cFlavorsF( tinP ) ;
                    stackC stPhrases( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_byteT ) ;

                    }
                        etThread.osTimeNowF( tinP , timeL1 , timeL2 ) ;
                        timeL1 = timeL2 = 0 ;
                    {
                    if( ether )
                {
                if( ether || etThread.osTimeTestF( tinP , timeL1 , timeL2 , TICK ) )

                }
                    writeFishF( tinP , etThread , lake , idMetric , swTotal1 , swTotal2 ) ;
                    if( total1 < total1Lag ) total2 ++ ;
                    total1 += value ;
                    countT total1Lag = total1 ;
                    countT& total2 = swTotal2 ;
                    countT& total1 = swTotal1 ;
                {
                if( idMetric )

                souli >> value ;
                souli >> idMetric ;
                ZE( countT , value ) ;
                idMetric = 0 ;

                soc.readF( tinP , souli , idPort , nicName ) ;
                soulC souli( tinP , TAG( TAGiDnULL ) ) ;
                nicNameC nicName ;
                ZE( countT , idPort ) ;
            {
            while( !ether && !etThread )
            ZE( sCountT , timeL2 ) ;
            ZE( countT , timeL1 ) ;

            soc.bindF( tinP , ifcPORToLD2_IFC11CATCHmETRICS ) ;
            socketC soc( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
        {

        lakeC lake( tinP , etThread ) ;
    {
    while( !ether )

    loadDataF( tinP , etThread , idMetric , swTotal1 , swTotal2 , tJournal ) ;
    TN( tJournal , "///d/ideafarm." ) ; tJournal += TF1(etherC::ifc_idHomeI_IF())+T(".log.journal.5240104") ;

    switchC swTotal2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idMetric ) ;
    switchC swTotal1( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idMetric ) ;
    ZE( countT , idMetric ) ;

    stateS state( tinP , etThread ) ;
{

TODO

}
    etThread.delF( tinP , postr ) ;
    lakeP.writeF( tinP , count3S( DDNUMB , 1 ) , postr , costr , 1 , 1 ) ; //U:OPTIMIZE: ELIMINATE THE COPYING
    etThread.delF( tinP , psttr ) ;
    countT costr = etThread.strMakeF( tinP , LF , postr , psttr ) ; ___( postr ) ;
    ZE( osTextT* , postr ) ;

    }
        etThread.strFuseF( tinP , psttr , t9           ) ; ___( psttr ) ;
        etThread.strFuseF( tinP , psttr , tBody ) ; ___( psttr ) ;
        etThread.strFuseF( tinP , psttr , t0+t1+ta+t2  ) ; ___( psttr ) ;

        etThread.strMakeF( tinP , LF , psttr , T("") , t0.csF( tinP ) + t1.csF( tinP ) + ta.csF( tinP ) + t2.csF( tinP ) + tBody.csF( tinP ) + 1 + t9.csF( tinP ) ) ;

        //U: REMOVE UNUSED TN ITEMS IN THIS BLOCK
        textC t0 = T("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\nContent-Length: ")+TF4(t1.csF(tinP)+ta.csF(tinP)+t2.csF(tinP)+tBody.csF(tinP)+t9.csF(tinP),flFORMAT_FILLzE|flFORMAT_NObASE|flFORMAT_FOREIGN,8,0xa)+T("\r\n\r\n") ;
        TN( t9 , "</PRE></BODY>" ) ;
        TN( t7 , /*".html"*/ "\">down to the root</A>\r\n" ) ;
        TN( t2 , "</TITLE>\r\n</HEAD>" postHTMLbODYpART1 "\r\n" ) ;
        textC t1 = T("<!-- ")+TF3(ta.csF(tinP),flFORMAT_FILLzE,8)+T(" --><!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\r\n<HEAD><TITLE>") ; //THE LEADING 4 STROKES CAUSE 4 BYTES TO BE RESERVED IN THE HTML FILE FOR A countT VALUE
        TN( ta , "report by 5240104 on ifc11" ) ;
    {
    ZE( strokeS* , psttr ) ;

    }
        tBody += (idf==1?T(""):T("\r\n"))+T("idMetric ")+TF3(idMetricP&0xfffffff,flFORMAT_null,8)+T(" = ")+(swTotal2P?TF3(swTotal1P,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+TF1(swTotal2P):TF1(swTotal1P)) ; //ASSUME: countT IS 4 BYTES
        idMetricP = swTotal1P.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swTotal1P.cFlavorsF( tinP ) ;
    TN( tBody , "report by 5240104 on ifc11 of metrics caught\r\n\r\n" ) ;
{
voidT writeFishF( tinS& tinP , etherC& etThread , lakeC& lakeP , countT& idMetricP , switchC& swTotal1P , switchC& swTotal2P )

}
    etThread.delF( tinP , posti ) ;
    }
        etThread.delF( tinP , psttl ) ;
        }
            }
                etThread.delF( tinP , psttw ) ;
                }
                    etThread.delF( tinP , psttw2 ) ;
                    }
                        }
                            }
                                swTotal2P = etThread.strDigitsToSCountF( tinP , psttw2 ) ;
                                etThread.strSubstringF( tinP , psttw2 , idf2 , sttq2 , sttSlash , psttw ) ; ___( psttw2 ) ;
                                etThread.delF( tinP , psttw2 ) ;
                            {
                            if( idf2 )
                            swTotal1P = etThread.strDigitsToSCountF( tinP , psttw2 ) ;
                            etThread.strSubstringF( tinP , psttw2 , idf2 , sttq2 , sttSlash , psttw ) ; ___( psttw2 ) ;
                            etThread.delF( tinP , psttw2 ) ;
                        {
                        if( idMetricP && idf2 )
                        idMetricP = etThread.strDigitsToSCountF( tinP , psttw2 ) ;
                    {
                    if( psttw2 && psttw2->idAdam )
                    etThread.strSubstringF( tinP , psttw2 , idf2 , sttq2 , sttSlash , psttw ) ; ___( psttw2 ) ;
                    ZE( strokeS* , psttw2 ) ;
                    countT idf2 = 1 ;
                    strokeS sttq2( (countT)0 , sc_IGNOREqUOTES ) ; //PARSE THE LINE AND FILL THE SWITCHES
                {
                if( etThread.strIdF( tinP , sttSlash , psttw ) )

                etThread.strSubstringF( tinP , psttw , idf , sttq , tDelim , psttl , 1 ) ; ___( psttw ) ;
            {
            while( !etThread && idf )
            ZE( strokeS* , psttw ) ;
            strokeS sttSlash( '/' ) ;
            //sttq = ze ;
            idf = 1 ;
            TN( tDelim , " " ) ;
        {
        if( psttl )

        if( !psttl ) { etThread.strSubstringLineF( tinP , psttl , idf , sttq , T(posti) , - 1 ) ; ___( psttl ) ; } //JUST IN CASE THE FILE IS NOT TERMINATED BY A CRLF
                       etThread.strSubstringLineF( tinP , psttl , idf , sttq , T(posti) , - 2 ) ; ___( psttl ) ;   //THE FILE SHOULD BE TERMINATED BY A CRLF
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;
        ZE( strokeS* , psttl ) ;
    {
    else
    if( etThread ) etThread = 0 ;
    etThread.boxGetShadowF( tinP , posti , costi , psttFileP , 1 ) ; ___( posti ) ;
    ZE( countT , costi ) ;
    ZE( byteT* , posti ) ;
{
voidT loadDataF( tinS& tinP , etherC& etThread , countT& idMetricP , switchC& swTotal1P , switchC& swTotal2P , const strokeS* const psttFileP )

STATE0

/*1*/WAKEhIDE( "city.catch.measurements" )/*1*/
/**/
*/
i use the measurements to update files
i live on ifc11 and am thrown measurements from all over the Internet
i catch measurements thrown at me
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

