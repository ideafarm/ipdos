
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return offo ;
    if( time1P || time2P ) { __( s_unregisterTimeoutF( tinP , handleP ) ) ; }

    }
            c_zReverseByteOrderF( tinP , pbP , offo ) ;
        if( !POOP && offo && F(flagsP) & flSOCKETcrEAD_CONVERTbYTEoRDER )
    
        if( !fhok && !fTinyNibbles && cbToDo ) __( cbToDo ) ;
    {

    PRO = cbToDo ; PROSHO ;
    }
        }
            if( !cbNew || fJustOne ) break ;

            cbToDo             -= cbNew ;
            offo               += cbNew ;
            tinP.odoSockCbRead += cbNew ;

            //}
            //    else                   tinP.pEther->traceF( tinP , T("s_readOrPeekPrivateF [time in recv]:    fast") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ; //U:: TO FIND A BUG
            //    if( timeE1 || timeE2 ) tinP.pEther->traceF( tinP , T("s_readOrPeekPrivateF [time in recv]:    slow    ")+TTF(timeE1,timeE2) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ; //U:: TO FIND A BUG
            //    tinP.pEther->osTimeSubtractF( tinP , timeE1 , timeE2 , timeB1 , timeB2 ) ;
            //    tinP.pEther->osTimeNowF(      tinP , timeE1 , timeE2 ) ;
            //    ZE( sCountT , timeE2 ) ;
            //    ZE( countT  , timeE1 ) ;
            //{
            //if( tinP.pc Utility[ 1 ] && tinP.pEther )

            }
                }
                    break ;
                    }
                        __1 ;
                        cbNew = 0 ;
                    {
                    if( cbNew == SOCKET_ERROR )
                    ;
                        : thirdC::openSsl_readIF( tinP , pbP + offo , cbBite , handleP )
                        ? thirdC::openSsl_peekIF( tinP , pbP + offo , cbBite , handleP )
                    cbNew = flagsTcpP & MSG_PEEK
                    _IO_
                {
                case ifcIDmODEsOCKETS_ENCRYPTED :
                }
                    break ;
                    }
                        __1 ;
                        cbNew = 0 ;
                    {
                    if( cbNew == SOCKET_ERROR )
                    if( !POOP ) cbNew = tinP.brcRaw ;
                    BOSpOOP
                    BOSS( WHATsir , BOSsOCKETcODE2 , recv( handleP.osF( ifcIDtYPEhANDLE_SOCKET ) , pbP + offo , cbBite , flagsTcpP ) )
                    _IO_
                {
                case ifcIDmODEsOCKETS_NOTeNCRYPTED :
            {
            switch( idModeP )
            ZE( sCountT , cbNew ) ;

            //if( tinP.pc Utility[ 1 ] && tinP.pEther ) tinP.pEther->osTimeNowF( tinP , timeB1 , timeB2 ) ;
            //ZE( sCountT , timeB2 ) ;
            //ZE( countT  , timeB1 ) ;

            #endif

                BOSnOvALUE( WHATgbo , WSASetLastError( 0 ) )

            #if defined( __NT__ )

            ;
                    : cbToDo
                    ? 8192
                : cbToDo > 8192
                ? 1
            countT cbBite = fTinyNibbles
            PRO = cbToDo ; PROSHO ;
            ++ s ;
        {
        while( !*this && cbToDo )
        sleepC s( tinP , TAG( TAGiDnULL ) , 1 ) ;
    {
    ZE( countT , offo ) ;

    if( tinP.pcUtility[ 0 ] )tinP.pEther->traceF( tinP , T("s_readOrPeekPrivateF [cbP]:    ")+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG

    boolT fTinyNibbles = !!( F(flagsP) & flSOCKETcrEAD_WObYTEpERbITE   ) ;
    boolT fJustOne     = !!( F(flagsP) & flSOCKETcrEAD_JUSToNEmOUTHFUL ) ;
    boolT fhok         = !!( F(flagsP) & flSOCKETcrEAD_STILLhUNGRYiSoK ) ;
    PRO = cbToDo ; PROSHO ;
    countT cbToDo = cbP ;
    if( pEtherContainsMe ) pEtherContainsMe->chokeAttackerF( tinP , handleP , cbP ) ;

    if( time1P || time2P ) s_registerTimeoutF( tinP , handleP , time1P , time2P ) ;

    _IO_
    
    }
        if( POOP ) return 0 ;
        IFsIMULATEoFFLINEpOOP
        FV( flSOCKETcrEAD , flagsP ) ;
        __Z( cbP ) ;
        __Z( pbP ) ;
        __Z( handleP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL    
    SCOOP
{
/*1*/countT thirdC::s_readOrPeekPrivateF( tinS& tinP , byteT* const pbP , const countT cbP , handleC& handleP , const flagsT flagsTcpP , const flagsT flagsP , const countT time1P , const sCountT time2P , const countT idModeP )/*1*/

/**/
*/
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001000f.flSOCKETc!||
 flagsP
  see documentation for the flags argument of the recv function
 flagsTcpP
  must not be 0
 cbP
  must not be 0
 pbP
  must not be 0
 handleP
arguments
flagsTcpP is passed unmodified to the tcpip recv call
see the flSOCKETc symbolic constants before specifying flagsP
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.1020041.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$s_readOrPeekPrivateF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

