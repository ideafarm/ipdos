
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return *this ;

    }
        }
            if( !cFields && pJot ) { DEL( pJot ) ; }

            ed.freePrefixF( cbFree ) ;

            ;
                : sizeof( countT )                            // IF pJot THEN THE idJot IN ed IS FREED BUT NEIGHER THE INDEX ENTRY (A handle0111C) NOR THE DATA ARE FREED ; BOTH WILL CONTINUE TO OCCUPY MEMORY AND BACKING DISK SPACE UNTIL *this IS DESTROYED
                ? sizeof( countT ) + *(countT*)(byteT*)ed
            countT cbFree = !pJot

            }
                }
                    }
                        else if( cCourtesyBytes == 1                )            pbP[ cbP ] = 0 ;
                             if( cCourtesyBytes == sizeof( countT ) ) *(countT*)&pbP[ cbP ] = 0 ;
                    {
                    if( pbP )
        
                    }
                        #endif
                            //U: OTHERWISE, REARRANGE THE BYTES SO THAT THEY ARE IN ORDER OF INCREASING NUMERICAL SIGNIFICANCE
                            //U: FOR NON 386 HARDWARE (CAN DO MEMCOPY IFF LEAST SIGNIF NUMERIC BYTE IS AT LOWEST ADDRESS, AS ON INTEL HARDWARE
                        #else
                            thirdC::c_memcpyIF( tinP , pbP , pbi2 , cbP - cbaExtra ) ;
                        #if defined( __386__ )
                    {
                    else
                    if( !( F(flagsItem) & flSOULiTEM_MADEoFcOUNToBJECTS ) ) thirdC::c_memcpyIF( tinP , pbP , pbi2 , cbP - cbaExtra ) ;
        
                    if( !pbP ) { ((thirdC&)ether).newF( tinP , LF , pbP , cbP + cCourtesyBytes ) ; ___BITScT( pbP , 0x1160 ) ; }
        
                    if( !pbP && !( F(flagsItem) & flSOULiTEM_TERMINATEDbYnULL ) ) cCourtesyBytes = F(flagsItem) & flSOULiTEM_MADEoFcOUNToBJECTS ? sizeof( countT ) : 1 ;
                    ZE( countT , cCourtesyBytes ) ;
                {
                if( !POOP )
        
                }
                    //}
                    //    }
                    //        cbP += cbaExtra ;
                    //        cbaExtra = sizeof( strokeS ) * pstts[ 2 ].idAdam ;
                    //    {
                    //    if( cbP >= CSpREFIX * sizeof( strokeS ) && pstts[ 0 ].idCaste == sc_PREFIXlENGTH && pstts[ 1 ].idCaste == sc_PREFIXuTILITY && pstts[ 2 ].idCaste == sc_PREFIXeXTRA )
                    //    strokeS* pstts = (strokeS*)pbi2 ;
                    //{
                    //if( idType == ifcIDtYPEsOULiTEM_strokeSptr ) //I MUST DO THIS BECAUSE THE EXTRA STROKES, IF ANY, CLAIMED IN THE PREFIX WERE NOT ACTUALLY STORED IN ME
                    //THIS OBSOLETE CODE IS LEFT OVER FROM BEFORE strokeS STRINGS BECAME ENCODED ; NOW THAT THEY ARE ENCODED, MY JOB IS JUST TO RETURN THE ENCODING
        
                    cbP = length - 2 * sizeof( countT ) ;
                {
                else
                }
                    __( idType == ifcIDtYPEsOULiTEM_strokeSptr ) ;
                    __( cbP - length + 2 * sizeof( countT ) ) ;
                {
                if( cbP )
                ZE( countT , cbaExtra ) ;
            {
            if( !POOP && !( F(flagsItem) & flSOULiTEM_NULLpTR ) )
            __( F(flagsItem) & flSOULiTEM_NULLpTR && length != 2 * sizeof( countT ) ) ;
            FV( flSOULiTEM , flagsItem ) ;
            POOPIE

            cFields -- ;
        {
        if( length && idTypeVerifyP == idType )

        }
            if( !( F(flagsItem) & flSOULiTEM_NULLpTR ) ) pbi2 = pbi + 3 * sizeof( countT ) ;

            flagsItem = ((flagsT*)pbi)[ 2 ] ;
            idType    = ((countT*)pbi)[ 1 ] ;
            length    = ((countT*)pbi)[ 0 ] ;

            }
                }
                    pbi = (*pJot)[ idJot ] ;
                    countT idJot = ((countT*)(byteT*)ed)[ 0 ] ;
                {
                if( !POOP )
            {
            else
            if( !pJot ) pbi = ed ;
            ZE( const byteT* , pbi ) ;
        {
        ZE( const byteT* , pbi2 ) ;
        ZE( flagsT , flagsItem ) ;
        ZE( countT , idType    ) ;
        ZE( countT , length    ) ;
    {

    _IO_

    }
        if( ( !!pbP - !!cbP ) || !(byteT*)ed ) return *this ;
    {
    IFbEcAREFUL    
    SCOOP
{
/*1*/soulC& soulC::shiftRightF( tinS& tinP , byteT*& pbP , countT& cbP , const countT idTypeVerifyP )/*1*/

/**/
*/
   the courtesy allocation is -not- made if the caller provides memory (by setting pbP)
   this courtesy allocation does not affect cbP; cbP will not include it
  if !pbP and no terminating null was stored, i will allocate and set a terminator at the end of the cbP byteT's
   whether this includes a terminating null depends upon how the item was stored
  will be set to the number of byteT objects retrieved
   i do not bother to support preallocation for strokeS strings because the caller would have to know the length of the string, including claimed extra strokes
   this restriction exists because strokeS strings can claim to have (unstored) extra bytes at the end
  must be 0 for strokeS string
  if  pbP then must not be 0
  if !pbP then must be 0
 cbP
  guaranteed to be null terminated, even if a null terminator was not stored in the item
   else must point to cbP bytes
   if 0 then will be allocated
  can be 0
 pbP
 tinP
arguments
\<A HREF=\"5.14e000d.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$shiftRightF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

