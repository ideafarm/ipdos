
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            else if( !( -- cTries ) ) break ;
            }
                break ;
                replyP.idSnipHttpLocation = idSnipLocation ;
            {
            if( idSnipLocation )

            }
                }
                    etThread.delF( tinP , pbi ) ;
                    }
                        //etThread.traceF( tinP , T("deadman received [pbi]: ")+T(pbi) ) ;
                    {
                    else
                    }
                        idSnipLocation = 0 ;
                        etThread.traceF( tinP , T("unresponsive http server (unexpected text) [tNameDNS]: ")+tNameDNS ) ;
                    {
                    else if( !pbi || !cbi || etThread.strCompareF( tinP , T(pbi) , T("IdeaFarm (tm)") ) )
                    }
                        idSnipLocation = 0 ;
                        etThread.traceF( tinP , T("unresponsive http server (impotence) [tNameDNS]: ")+tNameDNS ) ;
                        POOPR ;
                    {
                    if( POOP )

                    tinP.pEtScratch->boxGetShadowF( tinP , pbi , cbi , tNameDNS+T("//http/deadman") , 1 , TUCK >> 2 ) ; ___( pbi ) ; //U:: 20190903@2233: BLAMMO IN HERE
                    ZE( countT   , cbi ) ;
                    ZE( osTextT* , pbi ) ;

                    SCOOPS
                {
                IFsCRATCH

                //etThread.traceF( tinP , T("[tNameNetBIOS]: ")+tNameNetBIOS ) ;
                etThread.traceF( tinP , T("[tNameDNS]:     ")+tNameDNS ) ;

                }
                    etThread.delF( tinP , pstt1w ) ;
                    }
                        break ;
                        tNameNetBIOS = T(psttc1) ;

                        //etThread.traceF( tinP , T("word [psttc1]: ")+T(psttc1) ) ;
                    {
                    FORsTRINGSiN1( pstt1w )
                    etThread.strWordsF( tinP , pstt1w , tNameDNS , sttq , T(".") ) ; ___( pstt1w ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , pstt1w ) ;
                {
                TN( tNameNetBIOS , "" ) ;

                DEL( prPostsHttpLocation ) ;
                }
                    etThread.delF( tinP , pstt1w ) ;
                    }
                        }
                            break ;
                            tNameDNS = T(psttc1) ;
                        {
                        else
                        if( cSkip -- ) ;

                        //etThread.traceF( tinP , T("word [psttc1]: ")+T(psttc1) ) ;
                    {
                    FORsTRINGSiN1( pstt1w )
                    countT cSkip = 1 ;
                    etThread.delF( tinP , psttLocation ) ;
                    etThread.strWordsF( tinP , pstt1w , psttLocation , sttq , T("/") ) ; ___( pstt1w ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , pstt1w ) ;

                    etThread.traceF( tinP , T("location [psttLocation]: ")+T(psttLocation) ) ;
                    etThread.strMakeFromOsTextF( tinP , psttLocation , POSTS( *prPostsHttpLocation ) ) ; ___( psttLocation ) ;
                    ZE( strokeS* , psttLocation ) ;

                    // "http://factory3.ideafarm.com/home.3.html"
                {
                TN( tNameDNS , "" ) ;

                countT costLocation = COSTS( *prPostsHttpLocation ) ;

                }
                    meP.getSnipF( tinP , prPostsHttpLocation , idSnipLocation ) ; ___( prPostsHttpLocation ) ;
                    idSnipLocation = pIdSnip[ ( offi ++ ) % cIdSnip ] ;
                {
                ZE( pbRefC* , prPostsHttpLocation ) ;
            {
            ZE( countT , idSnipLocation ) ;
        {
        for(;;)
        countT cTries = cIdSnip ; // I WILL TRY EVERY SERVER AND THEN GIVE UP

        }
            cIdSnip = sizeof pIdSnipBalance / sizeof pIdSnipBalance[ 0 ] ;
            pIdSnip = pIdSnipBalance ;
        {
        else
        }
            cIdSnip = sizeof pIdSnipNoBalance / sizeof pIdSnipNoBalance[ 0 ] ;
            pIdSnip = pIdSnipNoBalance ;
        {
        if( idLoadMode == ifcIDhTTPlOADmODE_NObALANCE )
        ZE( countT  , cIdSnip ) ;
        ZE( countT* , pIdSnip ) ;

        //idLoadMode = ifcIDhTTPlOADmODE_NObALANCE ; //REMOVE IN PRODUCTION

        } ;
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY16 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY15 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY14 ,        //U:: ENABLE WO OR MORE OF THESE TO CRAFT AND TEST CODE THAT DETECTS AND SKIPS OFFLINE SERVER
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY13 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY12 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY11 ,  //11-16 SERVERS DON'T EXIST, BUT I DISCOVER THEIR NONRESPONSIVENESS JUST AS I WOULD DISCOVER AN EXISTING SERVER THAT BECOMES UNRESPONSIVE.  I DO THIS TO TEST MY ABILITY TO HANDLE A SERVER THAT GOES DOWN
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY10 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY9 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY8 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY7 ,
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY6 ,
            ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY5 ,
            ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY4 ,
            ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY3 ,

            // 4: GORILLA
            // 3: STANDALONE TEST (SERVES HTTP WITHOUT HELP FROM OTHER SERVERS)
            // 2: WINDOWS SERVER 2016 SERVES MULTIMEDIA FROM ARCHIVE
            // 1: CRAFTWORK
            // 20200312@1643: THESE COMMENTS ARE OBSOLETE
        {
        static countT pIdSnipBalance[] =

        } ;
            ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY3        // ALL EXTERNAL VISITORS ARE HANDLED BY factory3 DURING DEVELOPMENT OF THE LOAD BALANCING CODE
            //ifcIDsNIPpREDEFINED_REDIRECTlOCATIONfACTORY1        // U::FOR CRAFTWORK ONLY
        {
        static countT pIdSnipNoBalance[] =

        static countT offi ;

        }
            etThread.delF( tinP , psttHttpLoadMode ) ;
            ;
                : ifcIDhTTPlOADmODE_bALANCE
                ? ifcIDhTTPlOADmODE_NObALANCE
            idLoadMode = psttHttpLoadMode && !etThread.strCompareF( tinP , psttHttpLoadMode , T("nobalance") )
            ZE( strokeS* , psttHttpLoadMode ) ; etThread.querySettingF( tinP , psttHttpLoadMode , T("!ipdos.serve.http.load.mode")  ) ; ___( psttHttpLoadMode ) ;
        {
        if( !idLoadMode )
        static boolT idLoadMode ;
    {
    if( replyP.idSnipHttpPrefix == ifcIDsNIPpREDEFINED_HTTPfAILmOVEDtEMP )
{
/*1*/voidT homeCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttUrlP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/


#define ifcIDhTTPlOADmODE_bALANCE           2
#define ifcIDhTTPlOADmODE_NObALANCE         1


/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

