
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    //}
    //    if( pEtherContainsMe ) pEtherContainsMe->ifcSayIF( tNNP+T(" NOT connected") , flSAY_APPEND | flSAY_LOG ) ;
    //{
    //else
    //}
    //    if( pEtherContainsMe ) pEtherContainsMe->ifcSayIF( tNNP+T(" connected") , flSAY_APPEND | flSAY_LOG ) ;
    //{
    //if( !POOP )

    }
        __1
        #endif

            __( tinP.brcRaw - WSABASEERR ) ;
            BOSdOnOTtEST( WHATgbo , WSAGetLastError() )

        #elif defined( __NT__ )

            __( tinP.brcRaw - SOCBASEERR ) ;
            BOSdOnOTtEST( WHATgbo , sock_errno() )

        #if defined( __OS2__ )
    {
    if( bFail )

    if( pks ) { __( s_unregisterTimeoutF( tinP , handleP ) ) ; }
    }
        while( !*this && ( !pks || !pks->bKilled ) && ( bNoQuit || ( bNoQuitEarly && !thPrimeIF( tinP ) ) || ( cTriesP && -- cTriesP ) ) ) ;
        }
            }
                break ;
                bFail = 0 ;
            {
            else
            }
                dosSleepIF( tinP , TUCK * 0x40 ) ;
                ++ s ;

                #endif
                    if( tinP.brcLath == WSAENOTSOCK ) break ; //THIS WILL HAPPEN IF thirdC::s_cancelF IS CALLED ON handleP
                #elif defined( __NT__ )
                    //U:
                #if defined( __OS2__ )
            {
            if( tinP.bosFail )







            //}
            //    tinP.brcRaw = _brcRawExp ;
            //    tinP.monitor.idWhat1 = _idWhatSaveBos ;
            //    }
            //        }
            //            /*if( F(POOP.flagsF()) & flPOOP_SMELLY ) { LOGrAW7( "BOS0   [brcLath,idLine,idiFile]: " , tinP.brcLath , " " , tinP.idLine_brcLath , " " , tinP.idiFile_brcLath , "\r\n" ) ; }*/
            //            tinP.idiFile_brcLath = DDNUMB ;
            //            tinP.idLine_brcLath = ifcLINE ;
            //            tinP.brcLath = tinP.brcQuery ;
            //        {
            //        if( tinP.brcQuery )
            //        tinP.brcQuery = _brcRaw ;
            //        _brcRaw -= WSABASEERR ;
            //        }
            //            }
            //                if( !( tally % CbOStALLYpERlOG ) ) logTallyIF( tally , LF , 0 , idMe , "WSAGetLastError()" ) ;
            //                countT tally = homeS::homeIF().tallyHo.tallyF( idMe ) ;
            //                static countT idMe ;
            //            {
            //            if( F(pg1.flCt) & flCTdTg_napHomeI && !( F(pg1.flDt) & flCTdTg_napHomeI ) )
            //            processGlobal1S& pg1 = processGlobal1S::_processGlobal1I_IF() ;
            //            _brcRaw = (countT)(WSAGetLastError()) ;
            //        {
            //        ZE( countT , _brcRaw ) ;
            //    {
            //    if( tinP.bosFail )
            //    }
            //        if( !( tally % CbOStALLYpERlOG ) ) logTallyIF( tally , LF , tinP.bosFail , tinP.bosFail ? idMeFail : idMeOk , "connect( handleP.osF( ifcIDtYPEhANDLE_SOCKET ) , (sockaddr*)&info , sizeof info )" ) ;
            //        countT tally = homeS::homeIF().tallyHo.tallyF( tinP.bosFail ? idMeFail : idMeOk ) ;
            //        static countT idMeFail ;
            //        static countT idMeOk ;
            //    {
            //    if( F(pg1.flCt) & flCTdTg_napHomeI && !( F(pg1.flDt) & flCTdTg_napHomeI ) )
            //    processGlobal1S& pg1 = processGlobal1S::_processGlobal1I_IF() ;
            //
            //
            //
            //
            //    }
            //        }
            //            s_setupF( tinP ) ;
            //            s_shutdownIF( tinP ) ;
            //        {
            //        if( rc == WSAECONNREFUSED )
            //        tinP.bosFail = 1 ;
            //        countT rc = WSAGetLastError() ;
            //    {
            //    if( _brcRawExp )
            //
            //    //tinP.bosFail = !!_brcRawExp ;
            //
            //
            //
            //
            //    countT _brcRawExp = (countT)( connect( handleP.osF( ifcIDtYPEhANDLE_SOCKET ) , (sockaddr*)&info , sizeof info ) ) ;
            //    WHATsir
            //    countT _idWhatSaveBos = tinP.monitor.idWhat1 ;
            //{
            //20141124@1644: WEIRD BEHAVIOR: THE tinP.bosFail = !!_brcRawExp ; LINE WAS OBSERVED IN WDW TO SET handleP.osh TO -1 (THE VALUE OF _brcRawExp)

            BOSS( WHATsir , BOSfAIL , connect( handleP.osF( ifcIDtYPEhANDLE_SOCKET ) , (sockaddr*)&info , sizeof info ) )








            //CONoUTrAW5( "" , tinP.pAdamGlobal1->idAdam , ": connecting to port " , idPortP , "\r\n" ) ;
    
            if( !handleP ) break ;
        {
        do
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    boolT bFail = 1 ;
    boolT bNoQuitEarly = !cTriesP ;
    boolT bNoQuit = cTriesP == - 1 ;

    killSocketS* pks = time1P || time2P ? s_registerTimeoutF( tinP , handleP , time1P , time2P ) : 0 ;

    //tinP.pEther->traceF( tinP , T("s_connect [sin_addr.s_addr,sin_port]: ")+TF3((countT)info.sin_addr.s_addr,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,3)+T("    ")+TF2((countT)info.sin_port,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    info.sin_addr.s_addr = tinP.brcRaw ; //U: SUPPORTS ONLY IPV4 (NOT IPV6)
    BOSdOnOTtEST( WHATgbo , htonl( *(const countT*)nicName ) )
    info.sin_port = (count01T)tinP.brcRaw ;
    BOSdOnOTtEST( WHATgbo , htons( (count01T)idPortP ) )
    info.sin_family = AF_INET ;
    c_memsetIF( tinP , (byteT* const)&info , sizeof info ) ;
    sockaddr_in info ;
    if( !time1P && !time2P ) time1P = nicNameP ? TOCK * 2 : TUCK * 0x80 ;
    const nicNameC nicName = nicNameP ? nicNameP : nicNameC( NICnAMElOCAL ) ;
    //if( pEtherContainsMe ) pEtherContainsMe->ifcSayIF( tNNP+T(" connecting") , flSAY_APPEND | flSAY_LOG ) ;
    //TN( tNNP , "" ) ; tNNP = TF1(nicNameP)+T("(")+TF1(idPortP)+T(")") ;
    _INoLD_

    }
        if( POOP ) return ;
        IFsIMULATEoFFLINEpOOP
        __Z( idPortP ) ;
        __Z( handleP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT thirdC::s_connectF( tinS& tinP , handleC& handleP , const countT idPortP , const nicNameC nicNameP , countT cTriesP , countT time1P , const sCountT time2P )/*1*/

/**/
*/
  can be 0
 time2P
  if 0 then will default to a value that depends upon whether nicNameP is null
  can be 0
 time1P
  regardless of cTriesP, i will discontinue retrying if [time1P,time2P] elapses or if s_cancelF is called (by another thread) for handleP
  if - 1 then will retry forever even if thPrimeIF( tinP ) is impotent
  if not 0 then will try cTriesP times (even if thPrimeIF( tinP ) is impotent)
  if 0 then will retry forever unless thPrimeIF( tinP ) is impotent
  can be 0
 cTriesP
  if 0 then the local host is implied
  can be 0
 nicNameP
  must not be 0
 idPortP
  must not be 0
 handleP
 tinP
arguments
  \<A HREF=\"5.f840104.1.1.0.html\"\>f840104:  WAKEsHOW( "example.simplest.func.102003b.thirdC.s_connectF" )\</A\>
  \<A HREF=\"5.8e00104.1.1.0.html\"\>8e00104:  WAKEsHOW( "example.simplest.func.102003b.thirdC.s_connectF" )\</A\>
 simplest
examples
\<A HREF=\"5.102003b.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$s_connectF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

