
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tinP , T("ok") ) ;

}
    ether.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS7rEPORTbYcONTAINERuRI napped") ) ;
    ++ s ; ether.osSleepF( tinP , TICK << 4 ) ;
    etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS7rEPORTbYcONTAINERuRI napping [cIn,cOut]:    ")+TF2(cIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    }
        //etThread.traceF( tinP , T("waited  for workers") ) ;
        }
            ++ s ; etThread.osSleepF( tinP , TOCK ) ;
        {
        while( ws.cWorkers )
        //etThread.traceF( tinP , T("waiting for workers") ) ;
        ws.bNoMoreToPush = 1 ;

        }
            etThread.fileWriteF( tinP , fileReportAll , tSay , tSay.csF( tinP ) ) ;
            tSay = TF3(tally,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,0xc)+T(psttBrowser)+ws.tcr ;

            }
                if( pbEncodedHe && cbEncodedHe ) { etThread.strDecodeF( tinP , psttBrowser , pbEncodedHe + sizeof( countT ) ) ; ___( psttBrowser ) ; }

                countT       cbEncodedHe = pageHe ;
                const byteT* pbEncodedHe = pageHe ;

                pageC pageHe = ws.jhsBrowser[ lever_idjBrowser ] ;
            {
            ZE( strokeS* , psttBrowser ) ;

            countT tally = swTallyAllByBrowser ;
            lever_idjBrowser = swTallyAllByBrowser.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swTallyAllByBrowser.cFlavorsF( tinP ) ;

        etThread.fileWriteF( tinP , fileReportAll , tSay , tSay.csF( tinP ) ) ;

        ) ;

            "\r\n"
            "\r\n"
            "access tally (all pages) by browser\r\n"
            "\r\n"
            "\r\n"
            "\r\n"
            "\r\n"

        tSay = T(

        while( !ether && ~hFind && !POOP ) ;
        }
            }
                }
                    ++ s ; etThread.osSleepF( tinP , TOCK >> 3 ) ;
                    //etThread.traceF( tinP , T("waiting for queue to shrink [cPending]:    ")+TF2(ws.st_psttContainerUriBooksName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                while( ws.st_psttContainerUriBooksName > TUCK )
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( ws.st_psttContainerUriBooksName > ( TUCK << 1 ) )

            DEL( pInfo ) ;
            }
                }
                    ws.st_psttContainerUriBooksName << psttShorter ;

                    //switchC swTallyPageByBrowser( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , lever_idjBrowser , 0 , 0 , ifcIDgRABlAYER_7BASEmISC1 ) ;

                    etThread.traceF( tinP , T("pushing [tShorter]:    ")+tShorter ) ;

                    }
                        tShorter = T(psttShorter) ;
                        etThread.delF( tinP , psttnu ) ;
                        etThread.strBisectF( tinP , psttShorter , psttnu , tShort , ws.tDot , 5 , flSTRbISECT_null ) ; ___( psttShorter ) ; ___( psttnu ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    ZE( strokeS* , psttShorter ) ;
                    TN( tShorter , "" ) ;

                    //etThread.traceF( tinP , tShort ) ;
                {
                if( !bDir )
        
                }
                    etThread.delF( tinP , psttShort ) ;
                    tShort = T(psttShort) ;
                    etThread.delF( tinP , psttnu ) ;
                    etThread.strBisectF( tinP , psttnu , psttShort , pInfo->psttIfoName , ws.tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                    ZE( strokeS* , psttShort ) ;
                    ZE( strokeS* , psttnu ) ;
                {
                TN( tShort , "" ) ;
        
                const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
        
                TN( tIfoName , pInfo->psttIfoName ) ;
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )
        
            etThread.diskFindFileOrDirF( tinP , pInfo , hFind , ws.tLike ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

        switchC swTallyAllByBrowser( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , lever_idjBrowser , 0 , 0 , ifcIDgRABlAYER_7BASEmISC1 ) ;
        ZE( countT , lever_idjBrowser ) ;

        etThread.fileWriteF( tinP , fileReportAll , tSay , tSay.csF( tinP ) ) ;

        fileC fileReportAll( tinP , (strokeS*)( ws.tPathReport+ws.tAll+ws.tDotTxt ) , ifcOPENaCCESS_W , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

        ) ;

            "\r\n"
            "\r\n"
            "\r\n"
            "\r\n"
            //"report time:  ")+TT(timeN1,timeN2)+T("\r\n"
            //"\r\n"
            "all objects\r\n"
            "\r\n"
            "Object Access Report\r\n"
            "\r\n"
            "IDEAFARM.COM\r\n"
            "\r\n"

        TN( tSay , "" ) ; tSay = T(

        //etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
        //ZE( sCountT , timeN2 ) ;
        //ZE( countT , timeN1 ) ;
        //TIME IS NOT PUT INTO THE REPORT IN ORDER TO AVOID CLOUD REFRESHES FOR REPORTS THAT HAVE NOT CHANGED
        //U:: GENERATE A SPECIAL REPORT THAT PRESENTS THE TIME THAT RECENT CYCLES (SINCE I WAS HIRED) BEGAN AND ENDED

        }
            etThread.osThreadF( tinP , countTC() , tmWorkerF , 0 , flTHREADlAUNCH_INHERITjOTrEGISTRATIONS , TOCK , (countT)&ws ) ;
            inc02AM( ws.cWorkers ) ;
        {
        while( cDo -- )
        countT cDo = 0x10 ;
        //etThread.traceF( tinP , T("launching workers") ) ;
        
        workS ws( tinP , etThread ) ;
    {
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{
while( !ether && !POOP )

//U::ether.ifcHireF( tinP , T("ifcIDaDAM_ACCESSeVENTS7rEPORTbYcONTAINERuRI") , ifcIDaDAM_ACCESSeVENTS8aUDITbOOKS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; // flHIRE_DISPLAYaUTO CAN BE COMMENTED OUT TO AVOID WDW FOR ROOT CLOUD INSTANCE WHICH IS USUALLY NOT INTERESTING

TODO

DONE( tmWorkerF )
}
    dec02AM( wsP.cWorkers ) ;
    _OUT_

    }
        _OUT_
        }
            _OUT_

            wsP.st_psttContainerUriBooksName.ungrabF( tinP ) ;

            }
                wsP.st_psttContainerUriBooksName.grabF( tinP , TAG( TAGiDnULL ) ) ;

                etThread.delF( tinP , psttContainerUriBooksName ) ;
                }
                    }
                        }
                            //*******************************************************************************************************************************************************************************************************
                            //*******************************************************************************************************************************************************************************************************
                            //****                                          *********************************************************************************************************************************************************
                            //****  THIS IS WHERE THE WORK GETS DONE (END)  *********************************************************************************************************************************************************
                            //****                                          *********************************************************************************************************************************************************
                            //*******************************************************************************************************************************************************************************************************
                            //*******************************************************************************************************************************************************************************************************

                            etThread.fileWriteF( tinP , fileReport , tSay , tSay.csF( tinP ) ) ;

                            ) ;

                                "\r\n"
                                "\r\n"
                                "access tally (this page) by browser\r\n"
                                "\r\n"
                                "\r\n"
                                "\r\n"
                                "\r\n"

                            tSay = T(

                            THREADmODE1rESTORE
                            }
                                }
                                    bPrefix = !bPrefix ;

                                    else          pbi = 0 ;
                                    if( bDelete ) PUSE( tinP , *(byteT**)&pbi ) ;

                                    ;
                                        : sizeof( countT )
                                        ? *(countT*)pbi
                                    cbi = bPrefix

                                    }
                                        }
                                            }
                                                inc02AM( cOut ) ;

                                                etThread.fileWriteF( tinP , fileReport , tSay , tSay.csF( tinP ) ) ;

                                                etThread.delF( tinP , psttBrowser ) ;
                                                etThread.delF( tinP , psttProtocol ) ;
                                                etThread.delF( tinP , psttQuery ) ;
                                                etThread.delF( tinP , psttBucket ) ;
                                                etThread.delF( tinP , psttMethod ) ;
                                                etThread.delF( tinP , psttSay ) ;

                                                tSay = T(psttSay) ;

                                                etThread.strFuseF( tinP , psttSay , T("browser:   ") ) ; etThread.strFuseF( tinP , psttSay , psttBrowser                                           ) ; etThread.strFuseF( tinP , psttSay , wsP.tcr ) ;
                                                etThread.strFuseF( tinP , psttSay , T("protocol:  ") ) ; etThread.strFuseF( tinP , psttSay , psttProtocol                                          ) ; etThread.strFuseF( tinP , psttSay , wsP.tcr ) ;
                                                etThread.strFuseF( tinP , psttSay , T("bucket:    ") ) ; etThread.strFuseF( tinP , psttSay , psttBucket                                            ) ; etThread.strFuseF( tinP , psttSay , wsP.tcr ) ;
                                                etThread.strFuseF( tinP , psttSay , T("method:    ") ) ; etThread.strFuseF( tinP , psttSay , psttMethod                                            ) ; etThread.strFuseF( tinP , psttSay , wsP.tcr ) ;
                                                etThread.strFuseF( tinP , psttSay , T("length:    ") ) ; etThread.strFuseF( tinP , psttSay , TF2(cbReply,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; etThread.strFuseF( tinP , psttSay , wsP.tcr ) ;
                                                etThread.strFuseF( tinP , psttSay , T("code:      ") ) ; etThread.strFuseF( tinP , psttSay , TF2(code,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)    ) ; etThread.strFuseF( tinP , psttSay , wsP.tcr ) ;
                                                etThread.strFuseF( tinP , psttSay , T("nicName:   ") ) ; etThread.strFuseF( tinP , psttSay , TF2(nnHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)    ) ; etThread.strFuseF( tinP , psttSay , wsP.tcr ) ;
                                                etThread.strFuseF( tinP , psttSay , T("time:      ") ) ; etThread.strFuseF( tinP , psttSay , TT(timeW1,timeW2)                                     ) ; etThread.strFuseF( tinP , psttSay , wsP.tcr ) ;

                                                etThread.strMakeF( tinP , psttSay , wsP.tcrcr , TUCK + csNeeded ) ; ___( psttSay ) ;
                                                ZE( strokeS* , psttSay ) ;

                                                }
                                                    }
                                                        csNeeded += ( *pppsttX[ offs ] )->idAdam ;

                                                        }
                                                                               psttTruncated = 0 ;
                                                            *pppsttX[ offs ] = psttTruncated ;
                                                            etThread.delF( tinP , *pppsttX[ offs ] ) ;
                                                            etThread.strSubstringF( tinP , psttTruncated , idf , idl , *pppsttX[ offs ] ) ; ___( *pppsttX[ offs ] ) ;
                                                            ZE( strokeS* , psttTruncated ) ;
                                                            countT idl = TUCK ;
                                                            countT idf = 1 ;
                                                        {
                                                        else if( ( *pppsttX[ offs ] )->idAdam > TUCK )
                                                        if( !*pppsttX[ offs ] ) { etThread.strMakeF( tinP , *pppsttX[ offs ] , wsP.tn ) ; ___( *pppsttX[ offs ] ) ; }
                                                    {
                                                    for( countT offs = 0 ; offs < sizeof pppsttX / sizeof pppsttX[ 0 ] ; offs ++ )
                                                    strokeS** pppsttX[] = { &psttMethod , &psttBucket , &psttQuery , &psttProtocol , &psttBrowser } ;                   // TRUNCATE ALL STRINGS TO LENGTH TUCK (TO PROTECT AGAINST ATTACK)
                                                {
                                                ZE( countT , csNeeded ) ;
                                            {
                                            if( !ether )

                                            //etThread.traceF( tinP , T("    [idjBrowser] :    ")+TF2(idjBrowser,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //etThread.traceF( tinP , T("    [cbReply]    :    ")+TF2(cbReply,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //etThread.traceF( tinP , T("    [code]       :    ")+TF2(code,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //etThread.traceF( tinP , T("    [idjProtocol]:    ")+TF2(idjProtocol,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //etThread.traceF( tinP , T("    [idjQuery]   :    ")+TF2(idjQuery,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //etThread.traceF( tinP , T("    [idjBucket]  :    ")+TF2(idjBucket,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //etThread.traceF( tinP , T("    [idjMethod]  :    ")+TF2(idjMethod,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //etThread.traceF( tinP , T("    [nnHe]       :    ")+TF2(nnHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                              etThread.traceF( tinP , T("    [timeW2]     :    ")+TF2(timeW2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //etThread.traceF( tinP , T("    [timeW1]     :    ")+TF2(timeW1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //etThread.traceF( tinP , T("    [idFormat]   :    ")+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //etThread.traceF( tinP , T("    [finger]     :    ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                            }
                                                }
                                                    //etThread.traceF( tinP , T("event [psttBrowser]:    ")+T(psttBrowser) ) ;
                                                    etThread.strDecodeF( tinP , psttBrowser , pbEncodedHe + sizeof( countT ) ) ; ___( psttBrowser ) ;
                                                {
                                                if( pbEncodedHe && cbEncodedHe )

                                                countT       cbEncodedHe = pageHe ;
                                                const byteT* pbEncodedHe = pageHe ;

                                                pageC pageHe = wsP.jhsBrowser[  idjBrowser ] ;
                                            {
                                            ZE( strokeS* , psttBrowser ) ;

                                            }
                                                }
                                                    //etThread.traceF( tinP , T("event [psttProtocol]:    ")+T(psttProtocol) ) ;
                                                    etThread.strDecodeF( tinP , psttProtocol , pbEncodedHe + sizeof( countT ) ) ; ___( psttProtocol ) ;
                                                {
                                                if( pbEncodedHe && cbEncodedHe )

                                                countT       cbEncodedHe = pageHe ;
                                                const byteT* pbEncodedHe = pageHe ;

                                                pageC pageHe = wsP.jhsOther[  idjProtocol ] ;
                                            {
                                            ZE( strokeS* , psttProtocol ) ;

                                            }
                                                }
                                                    //etThread.traceF( tinP , T("event [psttQuery]:    ")+T(psttQuery) ) ;
                                                    etThread.strDecodeF( tinP , psttQuery , pbEncodedHe + sizeof( countT ) ) ; ___( psttQuery ) ;
                                                {
                                                if( pbEncodedHe && cbEncodedHe )

                                                countT       cbEncodedHe = pageHe ;
                                                const byteT* pbEncodedHe = pageHe ;

                                                pageC pageHe = wsP.jhsQuery[  idjQuery ] ;
                                            {
                                            ZE( strokeS* , psttQuery ) ;

                                            }
                                                }
                                                    //etThread.traceF( tinP , T("event [psttBucket]:    ")+T(psttBucket) ) ;
                                                    etThread.strDecodeF( tinP , psttBucket , pbEncodedHe + sizeof( countT ) ) ; ___( psttBucket ) ;
                                                {
                                                if( pbEncodedHe && cbEncodedHe )

                                                countT       cbEncodedHe = pageHe ;
                                                const byteT* pbEncodedHe = pageHe ;

                                                pageC pageHe = wsP.jhsOther[  idjBucket ] ;
                                            {
                                            ZE( strokeS* , psttBucket ) ;

                                            }
                                                }
                                                    //etThread.traceF( tinP , T("event [psttMethod]:    ")+T(psttMethod) ) ;
                                                    etThread.strDecodeF( tinP , psttMethod , pbEncodedHe + sizeof( countT ) ) ; ___( psttMethod ) ;
                                                {
                                                if( pbEncodedHe && cbEncodedHe )

                                                countT       cbEncodedHe = pageHe ;
                                                const byteT* pbEncodedHe = pageHe ;

                                                pageC pageHe = wsP.jhsOther[ idjMethod ] ;
                                            {
                                            ZE( strokeS* , psttMethod ) ;

                                            sBookEntry >> cbReply ;
                                            sBookEntry >> code ;
                                            sBookEntry >> idjQuery ;
                                            sBookEntry >> idjBucket ;
                                            sBookEntry >> idjMethod ;
                                            sBookEntry >> idjProtocol ;
                                            sBookEntry >> idjBrowser ;
                                            sBookEntry >> nnHe ;
                                            sBookEntry >> *(countT*)&timeW2 ;
                                            sBookEntry >> timeW1 ;
                                            sBookEntry >> idFormat ;
                                            sBookEntry >> finger ;
                                            ZE( countT  , idjBrowser ) ;
                                            ZE( countT  , cbReply ) ;
                                            ZE( countT  , code ) ;
                                            ZE( countT  , idjProtocol ) ;
                                            ZE( countT  , idjQuery ) ;
                                            ZE( countT  , idjBucket ) ;
                                            ZE( countT  , idjMethod ) ;
                                            nicNameC nnHe ;
                                            ZE( sCountT , timeW2 ) ;
                                            ZE( countT  , timeW1 ) ;
                                            ZE( countT  , idFormat ) ;
                                            ZE( countT  , finger ) ;

                                            inc02AM( cIn ) ;

                                            THREADmODE3rESTORE
                                            DEL( pPageEvent ) ;
                                            THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                                            }
                                                etThread.delF( tinP , pbPageCopy ) ;
                                                }
                                                    sBookEntry.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbPageCopy , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;

                                                    bksAccessEvents.unlockF( tinP ) ;
                                                    etThread.memCopyF( tinP , pbPageCopy , pbzPage , cbzPage ) ;
                                                    const byteT* pbzPage = *pPageEvent ;
                                                    bksAccessEvents.lockF( tinP , TAG( TAGiDnULL ) ) ;
                                                {
                                                if( !POOP )

                                                __Z( pbPageCopy ) ;
                                                etThread.newF( tinP , LF , pbPageCopy , cbzPage ) ; ___( pbPageCopy ) ;
                                                ZE( byteT* , pbPageCopy ) ;

                                                countT cbzPage = *pPageEvent ;
                                            {
                                            soulC sBookEntry( tinP , TAG( TAGiDnULL ) ) ;
                                        {
                                        else
                                        }
                                            THREADmODE3rESTORE
                                            DEL( pPageEvent ) ;
                                            THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                                        {
                                        if( ether )

                                        __( (countT)*pPageEvent - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                                        }
                                            break ;
                                            hRead = hReadSave ;
                                            cbi = cbiSave ;

                                            THREADmODE3rESTORE
                                            DEL( pPageEvent ) ;
                                            THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                                            BLAMMO ;                                                //SHOULD BE IMPOSSIBLE SINCE "ALL OR NONE" USED FOR WRITING BOOKTOGETHER AND I'VE ALREADY READ THE PREFIX
                                        {
                                        if( !(const byteT*)*pPageEvent )

                                        THREADmODE3rESTORE
                                        bksAccessEvents.readF( tinP , *pPageEvent , hRead , flBOOKScrEAD_null , &bQuit ) ;
                                        pPageEvent = new( 0 , tinP , LF ) pageC( tinP , bksAccessEvents , cbi ) ; ___( pPageEvent ) ;
                                        THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                                        ZE( pageC* , pPageEvent ) ;
                                    {
                                    else
                                    }
                                        __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                                        }
                                            break ;
                                            hRead = hReadSave ;
                                            cbi = cbiSave ;
                                        {
                                        if( !pbi )
                                        bDelete = bksAccessEvents.readF( tinP , pbi , cbi , hRead , flBOOKScrEAD_STILLhUNGRYiSoK , &bQuit ) ;
                                    {
                                    if( bPrefix )
                                    ZE( boolT , bDelete ) ;

                                    HANDLEaPPnOTEScOUNTcLASS ch = hRead ;

                                    handleC hReadSave = hRead ;
                                    countT cbiSave = cbi ;
                                {
                                while( !etThread && !POOP && !ether )
                                const boolT& bQuit = *(const boolT*)&(const countT&)ether ;
                                boolT bPrefix = 1 ;
                                countT cbi = sizeof( countT ) ;
                                ZE( const byteT* , pbi ) ;
                                handleC hRead( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
                            {
                            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                            etThread.fileWriteF( tinP , fileReport , tSay , tSay.csF( tinP ) ) ;

                            fileC fileReport( tinP , (strokeS*)( wsP.tPathReport+tContainerUri+wsP.tDotTxt ) , ifcOPENaCCESS_W , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

                            ) ;

                                "\r\n"
                                "\r\n"
                                "\r\n"
                                "\r\n"
                                "report time:  ")+TT(timeN1,timeN2)+T("\r\n"
                                "\r\n"
                                "object:  ")+tContainerUri+T("\r\n"
                                "\r\n"
                                "Object Access Report\r\n"
                                "\r\n"
                                "IDEAFARM.COM\r\n"
                                "\r\n"

                            tSay = T(

                            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                            ZE( sCountT , timeN2 ) ;
                            ZE( countT , timeN1 ) ;

                            etThread.traceF( tinP , T("[tContainerUri]:    ")+tContainerUri ) ;

                            }
                                ;
                                    : tContainer+wsP.tSlash+tUriUse
                                    ? wsP.tUnknownContainer+wsP.tDot+TF2(idjContainer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+wsP.tDot+TF2(idjUri,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                tContainerUri = !tContainer.csF( tinP )

                                etThread.traceF( tinP , T("[tUriUse]:    ")+tUriUse ) ;
                                }
                                    etThread.delF( tinP , pstt1w ) ;
                                    }
                                        }
                                            default : {                                                               tUriUse += T(tUriUse.csF(tinP)?"/":"")+T(psttc1) ; break ; }
                                            case 3  : { if( etThread.strCompareF( tinP , tContainer      , psttc1 ) ) tUriUse += T(tUriUse.csF(tinP)?"/":"")+T(psttc1) ; break ; }
                                            case 2  : { if( !etThread.strIdF(     tinP , wsP.tMossoCloud , psttc1 ) ) tUriUse += T(tUriUse.csF(tinP)?"/":"")+T(psttc1) ; break ; }
                                            case 1  : { if( etThread.strCompareF( tinP , wsP.tV1         , psttc1 ) ) tUriUse +=                             T(psttc1) ; break ; }
                                        {
                                        switch( ++ idw )

                                        //etThread.traceF( tinP , T("uri word: ")+T(psttc1) ) ;
                                    {
                                    FORsTRINGSiN1( pstt1w )
                                    ZE( countT , idw ) ;
                                    etThread.strWordsF( tinP , pstt1w , tUri , sttq , wsP.tSlash ) ; ___( pstt1w ) ;
                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                    ZE( strokeS* , pstt1w ) ;
                                {
                                if( tUri.csF( tinP ) )
                                TN( tUriUse , "" ) ;

                                etThread.traceF( tinP , T("[tUri]:    ")+tUri ) ;
                                }
                                    else etThread.traceF( tinP , T("error: could not get tUri [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    }
                                        etThread.delF( tinP , psttUri ) ;
                                        tUri = T(psttUri) ;
                                        etThread.strDecodeF( tinP , psttUri , pbEncodedHe + sizeof( countT ) ) ; ___( psttUri ) ;
                                        ZE( strokeS* , psttUri ) ;
                                    {
                                    if( pbEncodedHe && cbEncodedHe )

                                    countT       cbEncodedHe = pageHe ;
                                    const byteT* pbEncodedHe = pageHe ;

                                    pageC pageHe = wsP.jhsUri[ idjUri ] ;
                                {
                                TN( tUri , "" ) ;

                                etThread.traceF( tinP , T("[tContainer]:    ")+tContainer ) ;
                                }
                                    else etThread.traceF( tinP , T("error: could not get tContainer [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    }
                                        etThread.delF( tinP , psttContainer ) ;
                                        tContainer = T(psttContainer) ;
                                        etThread.strDecodeF( tinP , psttContainer , pbEncodedHe + sizeof( countT ) ) ; ___( psttContainer ) ;
                                        ZE( strokeS* , psttContainer ) ;
                                    {
                                    if( pbEncodedHe && cbEncodedHe )

                                    countT       cbEncodedHe = pageHe ;
                                    const byteT* pbEncodedHe = pageHe ;

                                    pageC pageHe = wsP.jhsOther[ idjContainer ] ;
                                {
                                TN( tContainer , "" ) ;
                            {
                            TN( tContainerUri , "" ) ;
                        {
                        if( !ether )

                        booksC bksAccessEvents( tinP , TAG( TAGiDnULL ) , tContainerUriBooksName , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
                    {
                    if( !ether )

                    //}
                    //    booksC bksAccessEvents( tinP , TAG( TAGiDnULL ) , tContainerUriBooksName , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_RESETcREFoNcT ) ; //NULL FLAG IN PRODUCTION
                    //{
                    //DISABLE IN PRODUCTION

                    etThread.traceF( tinP , T("[idjContainer,idjUri,tContainerUriBooksName]:    ")+TF2(idjContainer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idjUri,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tContainerUriBooksName ) ;

                    TN( tContainerUriBooksName , psttContainerUriBooksName ) ;

                    }
                        etThread.delF( tinP , pstt1w ) ;
                        }
                            }
                                }
                                    break ;

                                    = etThread.strDigitsToSCountF( tinP , psttc1 , 0 , 1 ) ;
                                    )
                                            : idjUri
                                            ? idjContainer
                                        idw == 4
                                    (
                                {
                                case 5 :
                                case 4 :
                            {
                            switch( ++ idw )

                            //etThread.traceF( tinP , psttc1 ) ;
                        {
                        FORsTRINGSiN1( pstt1w )
                        ZE( countT , idw ) ;
                        etThread.strWordsF( tinP , pstt1w , psttContainerUriBooksName , sttq , wsP.tDot ) ; ___( pstt1w ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        ZE( strokeS* , pstt1w ) ;
                    {
                    ZE( countT , idjUri ) ;
                    ZE( countT , idjContainer ) ;

                    //*******************************************************************************************************************************************************************************************************
                    //*******************************************************************************************************************************************************************************************************
                    //****                                            *******************************************************************************************************************************************************
                    //****  THIS IS WHERE THE WORK GETS DONE (BEGIN)  *******************************************************************************************************************************************************
                    //****                                            *******************************************************************************************************************************************************
                    //*******************************************************************************************************************************************************************************************************
                    //*******************************************************************************************************************************************************************************************************
                {
                if( !ether )

                etThread.traceF( tinP , T("pulled [cRemain,psttContainerUriBooksName]:    ")+TF2(wsP.st_psttContainerUriBooksName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttContainerUriBooksName) ) ;
                wsP.st_psttContainerUriBooksName.ungrabF( tinP ) ;
                wsP.st_psttContainerUriBooksName >> psttContainerUriBooksName ;
                ZE( strokeS* , psttContainerUriBooksName ) ;
                _INoLD_
            {
            while( !ether && wsP.st_psttContainerUriBooksName )

            wsP.st_psttContainerUriBooksName.grabF( tinP , TAG( TAGiDnULL ) ) ;

            _INoLD_
        {
        else
        }
            etThread.traceF( tinP , T("napped (waited  to pull)") ) ;
            ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            etThread.traceF( tinP , T("napping (waiting to pull)") ) ;

            if( wsP.bNoMoreToPush ) break ;
        {
        if( !wsP.st_psttContainerUriBooksName )
        _INoLD_
    {
    while( !ether && !etThread && !POOP )

    TN( tSay , "" ) ;

    workS& wsP =  *(workS*)pTaskP->c1 ;
    _INoLD_
{
if( pTaskP && pTaskP->c1 )
TASK( tmWorkerF )

}
    tLike = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/")+tUser+T("/4/stateSpaces/ffffefff/bksAccessEvents.5.containerUri.????????.????????.booksC.1.book.00000001.00000001.bookC") ;
{
tMossoCloud(       tinP , TAG( TAGiDnULL ) , flTEXTc_null , "MossoCloud"               )
tV1(               tinP , TAG( TAGiDnULL ) , flTEXTc_null , "v1"                       ) ,
tAll(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "all"                      ) ,
tUnknownContainer( tinP , TAG( TAGiDnULL ) , flTEXTc_null , "unknownContainer"         ) ,
tn(                tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                         ) ,
tcrcr(             tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\r\n\r\n"                 ) ,
tcr(               tinP , TAG( TAGiDnULL ) , flTEXTc_null , "\r\n"                     ) ,
tPathReport(       tinP , TAG( TAGiDnULL ) , flTEXTc_null , "///d/web.reports/access/" ) ,
tDotTxt(           tinP , TAG( TAGiDnULL ) , flTEXTc_null , ".txt"                     ) ,
tDot(              tinP , TAG( TAGiDnULL ) , flTEXTc_null , "."                        ) ,
tSlash(            tinP , TAG( TAGiDnULL ) , flTEXTc_null , "/"                        ) ,
tLike(             tinP , TAG( TAGiDnULL ) , flTEXTc_null , ""                         ) ,
tUser(             tinP , TAG( TAGiDnULL ) , flTEXTc_null , thirdC::postUserNameIF()   ) ,
tb4(               tinP , TAG( TAGiDnULL ) , flTEXTc_null , "    "                     ) ,
idAccess( 0 ) ,
st_psttContainerUriBooksName( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ,
jhsOther(      tinP , "jotAccessEvents.hash.string.other"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [STRING]; WO JOT PER UNIQUE STRING
jhsBrowser(    tinP , "jotAccessEvents.hash.string.browser" , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsQuery(      tinP , "jotAccessEvents.hash.string.query"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsUri(        tinP , "jotAccessEvents.hash.string.uri"     , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
cWorkers( 0 ) ,
bNoMoreToPush( 0 ) ,
workS::workS( tinS& tinP , etherC& etherP ) :

}
    TINSL
{
workS::~workS( voidT )

countT cOut ;
countT cIn ;

;
}
    workS( tinS& tinP , etherC& etherP ) ;
    ~workS( voidT ) ;

    textC         tMossoCloud ;
    textC         tV1 ;
    textC         tAll ;
    textC         tUnknownContainer ;
    textC         tn ;
    textC         tcrcr ;
    textC         tcr ;
    textC         tPathReport ;
    textC         tDotTxt ;
    textC         tDot ;
    textC         tSlash ;
    textC         tLike ;
    textC         tUser ;
    textC         tb4 ;

    countT        idAccess ;
    stackC        st_psttContainerUriBooksName ;
    jotC          jhsOther         ;
    jotC          jhsBrowser       ;
    jotC          jhsQuery         ;          //CS:CODEsYNC: 73a 740 (THESE MUST BE CT IN THE SAME ORDER SO THAT THE SAME TAG VALES ARE ASSIGNED
    jotC          jhsUri           ;          // EVERY JOT INSTANCE CONTAINS HASH PREFIXED STRINGS TO KEEP CODE SIMPLE EVEN THOUGH THE HASH IS NOT USEFUL FOR THE STRINGS IN jhsOther
    countT        cWorkers         ;
    boolT         bNoMoreToPush    ;
{
struct workS



/*1*/WAKEhIDE( "ifcIDaDAM_ACCESSeVENTS7rEPORTbYcONTAINERuRI" )/*1*/
/**/
*/
 on output, each access event is written to a book dedicated to the corresponding idJot pair that identifies [container] [uri]
 the idJot values identify strings that i place into jotC instances
 on output, each access event soulC contains idJot values rather than string values
 on input, each access event soulC is self sufficient in that it contains string values
i "divide and conquer" by distributing access events to a dedicated booksC instantShort ) ;ce for each hash of [container] || [uri]
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
