
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

bOk = tinP.brcRaw ;
BOSpOOP
BOS( WHATgbo , BOSoK , UnregisterClass( postClass , oshInstance ) )

BOSpOOP
BOS( WHATgbo , BOSoK , DestroyWindow( oshw ) )

}
    BOSdOnOTtEST( WHATgbo , DispatchMessage( &info ) )

    if( POOP || !tinP.brcRaw ) break ;
    BOSpOOP
    BOS( WHATgbo , BOSfAILiFmINUS1 , GetMessage( &info , oshw , 0 , 0 ) )
    MSG info ;
{
for(;;)

etThread.osThreadF( TaRG1( tmDrawF ) ) ;

boolT bOk = tinP.brcRaw ;
BOSdOnOTtEST( WHATgbo , ShowWindow( oshw , SW_SHOW ) )

oshw = (HWND)tinP.brcRaw ;
BOSpOOP
BOS( WHATgbo , BOSoK , CreateWindowEx( 0 , postClass , "ifcDoodle" , 0x06cf0000 , 0x0 , 0x20 , 0x400 , 0x200 , 0 , 0 , oshInstance , 0 ) )

}
    if( atomClass ) ;
    ATOM atomClass = (ATOM)tinP.brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , RegisterClass( &info ) )

    info.lpszClassName = postClass ;
    info.lpszMenuName  = 0 ;
    info.hbrBackground = 0 ;
    info.hCursor       = (HCURSOR)tinP.brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , LoadCursor( 0 , IDC_CROSS ) )
    info.hIcon         = 0 ;
    info.hInstance     = oshInstance ;
    info.cbWndExtra    = 0 ;
    info.cbClsExtra    = 0 ;
    info.lpfnWndProc   = winMessageHandlerFooF ;
    info.style         = CS_HREDRAW | CS_VREDRAW | CS_OWNDC | CS_BYTEALIGNCLIENT ;
    WNDCLASS info;
{
osTextT* postClass = "doodleClass" ;
HINSTANCE oshInstance = (HINSTANCE)processGlobal4S::_processGlobal4I_IF()._thirdC_hWindowingClient.osF( ifcIDtYPEhANDLE_WINDOWINGcLIENT ) ;

pTin = &tinP ;

TODO

DONE( tmDrawF )
}
    BOSpOOP
    BOS( WHATgbo , BOSoK , TextOut( oshdc , 0x100 , 0x100 , bOk ? "done" : "fail" , 4 ) )

    #endif

        LOGrAW9( "         [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;

    #else

        LOGrAW9( "POLY     [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;

    #elif defined( POLY )

        LOGrAW9( "POLYPOLY [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;

    #if defined( POLYPOLY )

    const countT cLines = ( cSize - 1 ) * cGlyph ;
    
    //Beep( TUCK << 2 , TUCK ) ;
    
    tinP.pEther->osTimeSubtractF( tinP , timeE1 , timeE2 , timeS1 , timeS2 ) ;
    tinP.pEther->osTimeNowF( tinP , timeE1 , timeE2 ) ;
    ZE( sCountT , timeE2 ) ;
    ZE( countT , timeE1 ) ;

    #endif

        }
            }
                BOSpOOP
                BOS( WHATgbo , BOSoK , MoveToEx( oshdc , ppt[ offp ].x , ppt[ offp ].y , 0 ) )
            {
            else
            }
                BOSpOOP
                BOS( WHATgbo , BOSoK , LineTo(   oshdc , ppt[ offp ].x , ppt[ offp ].y ) )
            {
            if( offp % cSize )
        {
        for( countT offp = 0 ; offp < cpt ; offp ++ )

    #else

        }
            BOSpOOP
            BOS( WHATgbo , BOSoK , Polyline( oshdc , ppt + offg * cSize , cSize ) )
        {
        for( countT offg = 0 ; offg < cGlyph ; offg ++ )

    #elif defined( POLY )

        boolT bOk = tinP.brcRaw ;
        BOSpOOP
        BOS( WHATgbo , BOSoK , PolyPolyline( oshdc , ppt , (DWORD*)pcSize , cGlyph ) )

    #if defined( POLYPOLY )
    
    tinP.pEther->osTimeNowF( tinP , timeS1 , timeS2 ) ;
    ZE( sCountT , timeS2 ) ;
    ZE( countT , timeS1 ) ;

    //Beep( TUCK << 1 , TUCK ) ;

    BOSpOOP
    BOS( WHATgbo , BOSoK , SetROP2( oshdc , R2_XORPEN ) )

    BOSpOOP
    BOS( WHATgbo , BOSoK , Rectangle( oshdc , info.left , info.top , info.right , info.bottom ) )

    BOSdOnOTtEST( WHATgbo , SelectObject( oshdc , oshp ) )
    BOSdOnOTtEST( WHATgbo , SelectObject( oshdc , oshb ) )

    oshp = (HPEN)tinP.brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , CreatePen( PS_SOLID , 1 , 0xffffff ) )
    oshb = (HBRUSH)tinP.brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , CreateSolidBrush( 0 ) )

    }
        }

            #endif

                case 0 : { ppt[ offp ].x = ppt[ offp - 1 ].x ; ppt[ offp ].y = ppt[ offp - 1 ].y + 1 ; break ; }
                case 3 : { ppt[ offp ].x = 0x10              ; ppt[ offp ].y = ppt[ offp - 1 ].y     ; break ; }
                case 2 : { ppt[ offp ].x = ppt[ offp - 1 ].x ; ppt[ offp ].y = ppt[ offp - 1 ].y + 1 ; break ; }
                case 1 : { ppt[ offp ].x = 0x20              ; ppt[ offp ].y = ppt[ offp - 1 ].y     ; break ; }

            #else

                case 0 : { ppt[ offp ].x = ppt[ offp - 1 ].x ; ppt[ offp ].y = ppt[ offp - 1 ].y + 1 ; break ; }
                case 3 : { ppt[ offp ].x = 0x10              ; ppt[ offp ].y = ppt[ offp - 1 ].y     ; break ; }
                case 2 : { ppt[ offp ].x = ppt[ offp - 1 ].x ; ppt[ offp ].y = ppt[ offp - 1 ].y + 1 ; break ; }
                case 1 : { ppt[ offp ].x = info.right - 0x10 ; ppt[ offp ].y = ppt[ offp - 1 ].y     ; break ; }

            #if defined( LONGlINES )
        {
        else switch( offp % 4 )
        }
            ppt[ offp ].y = 0x10 ;
            ppt[ offp ].x = 0x10 ;
        {
        if( !( offp % cSize ) )
    {
    for( countT offp = 0 ; offp < sizeof ppt / sizeof ppt[ 0 ] ; offp ++ )

    for( countT offs = 0 ; offs < cGlyph ; offs ++ ) pcSize[ offs ] = cSize ;

    BOSpOOP
    BOS( WHATgbo , BOSoK , GetClientRect( oshw , &info ) )

    while( !oshdc ) OSsLEEPf( 50 ) ;
{
if( pTaskP )
TASK( tmDrawF )

#define LONGlINES
//#define POLY
#define POLYPOLY

const countT cSize = cpt / cGlyph ;
const countT cpt = sizeof ppt / sizeof ppt[ 0 ] ;
POINT        ppt[ cGlyph << 4 ] ;

      countT pcSize[ cGlyph ] ;
const countT cGlyph = 0x4e200 ;
//const countT cGlyph = TOCK ;

//
//  LIMIT: 2,560,000_9 points
//
//  001         02e4        00088310
//  01          002e4       00088310  01388000_  20480000_9
//
// cSize        cGlyphs     cbData
//LIMITS

HPEN   oshp ;
HBRUSH oshb ;

}
    return rc ;

    }
        }
            break ;
            rc = tinP.brcRaw ;
            BOSdOnOTtEST( WHATgbo , DefWindowProc( oshWindowP , idCmdP , p1P , p2P ) )
        {
        default :
        }
            break ;
            BOSpOOP
            BOS( WHATgbo , BOSoK , PostMessage( oshWindowP , WM_QUIT , 0 , 0 ) )
        {
        case WM_CLOSE :
        }
            break ;
            oshdc = oshdcTmp ;
            BOSdOnOTtEST( WHATgbo , EndPaint( oshWindowP , &info ) )
            HDC oshdcTmp = (HDC)tinP.brcRaw ;
            BOSpOOP
            BOS( WHATgbo , BOSoK , BeginPaint( oshWindowP , &info ) )
            PAINTSTRUCT info ;
        {
        case WM_PAINT :
    {
    switch( idCmdP )
    ZE( LRESULT , rc ) ;

    tinS& tinP = *pTin ;
{
extern "C" LRESULT OSF winMessageHandlerFooF( HWND oshWindowP , UINT idCmdP , WPARAM p1P , LPARAM p2P )

RECT  info ;
HDC   oshdc ;
HWND  oshw ;
tinS* pTin ;

/*1*/WAKEsHOW( "doodle.raw.graphics.calls.benchmark.Line.v.polyline" )/*1*/
/**/
*/
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

