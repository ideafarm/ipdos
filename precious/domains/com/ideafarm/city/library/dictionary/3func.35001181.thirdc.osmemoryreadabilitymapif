
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cbGrain ;

    }
        if( offi >= MAXcOUNTT >> 1 ) break ;
        offi += cbGrain ;
    
        }
            offo ++ ;
            mask = 1 ;
        {
        if( !mask )
        mask <<= 1 ;

        else      pbBitsP[ offo ] &= ~ mask ;
        if( bOk ) pbBitsP[ offo ] |=   mask ;
    
        thirdC::dosReadProcessMemoryIF( tinP , &bIn , 1 , bOk , (voidT*)offi , tinP.osPid ) ;
        byteT bIn ;
        ZE( boolT , bOk ) ;
    {
    for(;;)
    byteT mask = 1 ;
    ZE( countT , offo ) ;
    ZE( countT , offi ) ;

    CONoUTrAW5( "[cBits,cbGrain]: " , cBits , " " , cbGrain , "" ) ;
    countT cbGrain = ( ( MAXcOUNTT >> 1 ) + 1 ) / cBits ; // ">> 1" IS BECAUSE UPPER HALF OF ADDRESS SPACE IS NOT AVAILABLE ON WINDOWS
    countT cBits = cbBitsP * SB ;
{
/*1*/countT thirdC::osMemoryReadabilityMapIF( tinS& tinP , byteT* const pbBitsP , const countT cbBitsP )/*1*/

/**/
*/
  if TOCK then grainsize will be what the size of a page is as of this writing for Windows
  must be nonze
 cbBitsP
  must point to cbBitsP bytes of readable memory
  must be nonze
 pbBitsP
 tinP
parameters
i evaluate to the "grainsize", the number of bytes represented by each bit of the bitstring that i set
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

