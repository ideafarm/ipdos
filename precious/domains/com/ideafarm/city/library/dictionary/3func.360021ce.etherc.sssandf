
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bMatch ;

    }
        }
            *pstMatchP << psttm ; psttm = 0 ;
            strSubstringF( tinP , psttm , idf , idl , psttBigP ) ; ___( psttm ) ;
            countT idl = idbDoP ;
            countT idf = idbDoSave ;
            ZE( strokeS* , psttm ) ;
        {
        if( pstMatchP && F(flagsMatchP) & flSTRmATCH_AND )

        if( bLastActWasToIgnore ) idbDoP -- ;
    {
    else
    }
        if( pstMatchP ) pstMatchP->purgeF( tinP , cPlatesWas ) ;

        idbDoP = idbDoSave ;
        //idsDoP = idsDoSave ;
    {
    if( !bMatch )

    }
        idsDoP = ++ idsMax ; // ')'

        }
            }
                }
                    if( !bDoNotAdvanceBig ) idbDoP ++ ;
                    idsDoP ++ ;
                {
                else
                }
                    }
                        bUndoIfNotMatch = 1 ;
                        if( !( -- cRepeatIf ) ) bDisarmUndoIf = 1 ;
                    {
                    else
                    if( cRepeat ) cRepeat -- ;

                    if( !bDoNotAdvanceBig ) idbDoP ++ ;
                    idsDoP = idsDoSaveInLoop ;
                {
                if( cRepeat || cRepeatIf )
            {
            else
            //U:: THIS CODE WRONGLY ASSUMES THAT REMAINDER OF SMALL IS NOT TO BE IGNORED: else if( idbDoP == psttBigP->idAdam && !bDoNotAdvanceBig ) { bMatch = 0 ; break ; } // WE ARE DONE
            }
                }
                    }
                        }
                            bUndoIfNotMatch = 1 ;
                            if( !( -- cRepeatIf ) ) bDisarmUndoIf = 1 ;
                        {
                        else if( cRepeatIf )
                        if( cRepeat ) cRepeat -- ;

                        if( !bDoNotAdvanceBig ) idbDoP ++ ;
                        idsDoP = idsDoSaveInLoop ;
                    {
                    else
                    if( idbDoP == psttBigP->idAdam && cRepeat ) { bMatch = 0 ; break ; } // WE ARE DONE
                {
                else
                if( !cRepeat && ( !cRepeatIf || idbDoP == psttBigP->idAdam ) ) break ;      // WE ARE DONE
            {
            if( idsDoP == idsMax )

            if( bDisarmUndoIf ) bDisarmUndoIf = bUndoIfNotMatch = 0 ;
            if( cArmLiterals  ) cArmLiterals -- ;

            idbDoLathMatch = idbDoP ;
            idsDoLathMatch = idsDoP ;

            }
                }
                    break ;
                    bMatch = 0 ;
                {
                else
                }
                    while( idbDoP < psttBigP->idAdam && ( psttBigP[ CSpREFIX + idbDoP ] == S1C( '\r' ) || psttBigP[ CSpREFIX + idbDoP ] == S1C( '\n' ) ) ) idbDoP ++ ;
                    idsDoP ++ ;
                {
                )
                    psttBigP[ CSpREFIX + idbDoP ] == S1C( '\n' )
                    ||
                    psttBigP[ CSpREFIX + idbDoP ] == S1C( '\r' )
                    ||
                    idbDoP == psttBigP->idAdam
                (
                if
            {
            )
                psttSmallP[ CSpREFIX + idsDoP ].idAdam == sa_SSSmARKlINEeND
                &&
                psttSmallP[ CSpREFIX + idsDoP ].idCaste == sc_cSSSmARK
                &&
                idsDoP < idsMax
            (
            if
            // AS OF THIS WRITING, THE ONLY SPECIFICATION THAT MUST BE OBEYED USING LOOK AHEAD IS: sa_SSSmARKlINEeND
            // THIS IS THE TIME TO TEST ANY LOOK AHEAD SPECIFICATIONS
            // IF WE GET HERE THEN THE CURRENT CURSORED STROKES MATCH
            // LOOK AHEAD RECIPES

            }
                }
                    }
                        }
                            continue ;
                            cRepeatIf = 0 ;
                            idbDoP = idbDoSaveInLoop ;
                            idsDoP ++ ;
                        {
                        else
                        }
                            break ;
                            idbDoP = idbDoLathMatch ;
                            idsDoP = idsDoLathMatch ;
                        {
                        if( idsDoP == idsMax )

                        bUndoIfNotMatch = 0 ;
                    {
                    else
                    }
                        break ;
                        bMatch = 0 ;
                    {
                    if( !bUndoIfNotMatch )
                {
                if( !bOk )

                ;
                    : sssTestF( tinP , bDoNotAdvanceBig , psttSmallP , psttBigP , idsDoP , idbDoP , tBlack , tPunctuation )
                    ? psttSmallP[ CSpREFIX - 1 + idsDoP ] == psttBigP[ CSpREFIX - 1 + idbDoP ]
                boolT bOk = cArmLiterals
            {
            else
            }
                }
                    }
                        }
                            continue ;
                            cRepeatIf = 0 ;
                            idbDoP = idbDoSaveInLoop ;
                            idsDoP ++ ;
                        {
                        else
                        }
                            break ;
                            idbDoP = idbDoLathMatch ;
                            idsDoP = idsDoLathMatch ;
                        {
                        if( idsDoP == idsMax )

                        bUndoIfNotMatch = 0 ;
                    {
                    else
                    }
                        break ;
                        bMatch = 0 ;
                    {
                    if( !bUndoIfNotMatch )
                {
                if( !sssOrF( tinP , pstMatchP , flagsMatchP , psttSmallP , psttBigP ,  idsDoP ,  idbDoP ) )
            {
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam  == sa_SSSoR )
            }
                }
                    }
                        }
                            continue ;
                            cRepeatIf = 0 ;
                            idbDoP = idbDoSaveInLoop ;
                            idsDoP ++ ;
                        {
                        else
                        }
                            break ;
                            idbDoP = idbDoLathMatch ;
                            idsDoP = idsDoLathMatch ;
                        {
                        if( idsDoP == idsMax )

                        bUndoIfNotMatch = 0 ;
                    {
                    else
                    }
                        break ;
                        bMatch = 0 ;
                    {
                    if( !bUndoIfNotMatch )
                {
                if( !sssAndF( tinP , pstMatchP , flagsMatchP , psttSmallP , psttBigP ,  idsDoP ,  idbDoP ) )
            {
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSaND )
            }
                }
                    continue ;
                    idsDoP ++ ;
                {
                else
                if( idsDoP == idsMax ) break ;

                }
                    }
                        }
                            break ;
                            bMatch = 0 ;
                        {
                        else
                        }
                            }
                                break ;
                                bMatch = 0 ;
                                idsDoP = 0 ;
                            {
                            if( idsDoP > psttSmallP->idAdam )
                            idsDoP = idsLathMe ;
                        {
                        if( !POOP )

                        __Z( idsLathMe ) ;
                        countT idsLathMe = idsLathF( psttSmallP , idsDoP ) ;
                    {
                    while( cIgnore -- && idsDoP <= psttSmallP->idAdam )
                    idsDoP ++ ;
                    countT cIgnore = psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote ;

                    bLastActWasToIgnore = 1 ;
                {
                else if( psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == -1 && psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote )            // SPECIAL VALUES THAT MEAN: "IGNORE THE NEXT cNote SUBEXPRESSIONS"
                }
                    cRepeatIf = psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote  - cRepeat ;
                    cRepeat   = psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam           ;
                {
                if( psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam <= psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote )
            {
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSSrEPEAT )
            }
                }
                    continue ;
                    idsDoP ++ ;
                {
                else
                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL

                idbReportWoth = 0 ;
                }
                    }
                        *pstMatchP << psttm ; psttm = 0 ;
                        strSubstringF( tinP , psttm , idf , idl , psttBigP ) ; ___( psttm ) ;
                        countT idl = idbDoP - 1 ;
                        countT idf = idbReportWoth ;
                        ZE( strokeS* , psttm ) ;
                    {
                    if( pstMatchP && F(flagsMatchP) & flSTRmATCH_REPORTmATCH )
                {
                if( idbReportWoth && idbReportWoth < idbDoP )
            {
            else if( psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSrEPORTmATCHeND )
            }
                }
                    continue ;
                    if( !idbReportWoth ) idbReportWoth = idbDoP ;

                    idsDoP ++ ;
                {
                else
                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL
            {
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSrEPORTmATCH )
            }
                }
                    continue ;
                    idsDoP ++ ;
                    cArmLiterals = 0 ;
                {
                else
                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL
            {
            else if( psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERALeND )
            }
                }
                    continue ;
                    idsDoP ++ ;
                    cArmLiterals = - 1 ;
                {
                else
                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL
            {
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERALbEGIN )
            }
                }
                    continue ;
                    idsDoP ++ ;
                    cArmLiterals = 1 ;
                {
                else
                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL
            {
            if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERAL )

            ZE( boolT , bDoNotAdvanceBig ) ;
            const countT idbDoSaveInLoop = idbDoP ;
            const countT idsDoSaveInLoop = idsDoP ;

            bLastActWasToIgnore = 0 ;
        {
        if( idsDoP <= idsMax && idbDoP <= psttBigP->idAdam ) for(;;)
        ZE( countT , idbDoLathMatch ) ;
        ZE( countT , idsDoLathMatch ) ;

        TN( tPunctuation , TpUNCTUATION ) ;
        TN( tBlack , TbLACKeXCLUDINGnEWlINE ) ;

        ZE( countT , idbReportWoth ) ;
        ZE( countT , cArmLiterals ) ;
        ZE( boolT  , bDisarmUndoIf ) ;
        ZE( boolT  , bUndoIfNotMatch ) ;
        ZE( countT , cRepeatIf ) ;
        ZE( countT , cRepeat ) ;

        bMatch = 1 ; // A NULL LENGTH PATTERN WILL ALWAYS MATCH

        idsMax -- ; // LATH BEFORE ')'
        idsDoP ++ ;                           // WOTH AFTER '('
    {
    if( !POOP )
    ZE( boolT  , bLastActWasToIgnore ) ;

    __Z( idsMax ) ;
    countT idsMax = idsLathF( psttSmallP , idsDoP ) ;              // SINCE idsDoP MUST POINT TO AN [sc_ccSSS,sa_SSSaND], idsMax IS HERE SET TO THE CORRESPONDING [sc_ccSSS,sa_SSSaNDeND]

    const countT cPlatesWas = pstMatchP ? *pstMatchP : 0 ;
    const countT idbDoSave  = idbDoP ;

    }
        if( POOP ) return bMatch ;
        //FV(flSTRmATCH,flagsMatchP) ;
        }
            __( F( pstMatchP->flagsF( tinP ) ) & flSTACKc_FIFO ) ; // IF FIFO THEN WILL CONTAIN INCORRECT CONTENTS
        {
        if( pstMatchP )
        __NZ( psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam  - sa_SSSaND ) ;
        __NZ( psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste - sc_ccSSS  ) ;
        if( POOP ) return bMatch ;
        __Z( psttBigP->idAdam ) ;
        __( psttSmallP->idAdam < idsDoP + 1 ) ; // NULL LENGTH SPECS ARE ALLOWED
        if( POOP ) return bMatch ;
        __Z( idbDoP ) ;
        __Z( idsDoP ) ;
        __Z( psttBigP ) ;
        __Z( psttSmallP ) ;
        if( POOP ) return bMatch ;
    {
    IFbEcAREFUL

    ZE( boolT , bMatch ) ;
{
/*1*/boolT etherC::sssAndF( tinS& tinP , stackC* const pstMatchP , const flagsT flagsMatchP , const strokeS* const psttSmallP , const strokeS* const psttBigP ,  countT& idsDoP ,  countT& idbDoP )/*1*/

}
    return idsLath ;

    if( idsLath > psttSmallP->idAdam ) idsLath = 0 ;

    }
        else if( !cNest ) break ;
        }
            if( bFound ) break ;

            }
                }
                    break ;
                    if( !( -- cNest ) ) bFound = 1 ;
                {
                case sa_SSSoReND :
                case sa_SSSaNDeND :
                }
                    break ;
                    ++ cNest ;
                {
                case sa_SSSoR :
                case sa_SSSaND :
                }
                    break ;
                    cArmLiterals = 0 ;
                {
                case sa_SSSlITERALeND :
                }
                    break ;
                    cArmLiterals = - 1 ; //A:ASSUME: STRING LENGTH CANNOT EXCEED maxCountTT
                {
                case sa_SSSlITERALbEGIN :
                }
                    break ;
                    cArmLiterals = 1 ;
                {
                case sa_SSSlITERAL :
            {
            switch( psttSmallP[ CSpREFIX - 1 + idsLath ].idAdam )
            ZE( boolT , bFound ) ;
        {
        else if( psttSmallP[ CSpREFIX - 1 + idsLath ].idCaste == sc_ccSSS )
        else if( cArmLiterals                                            ) cArmLiterals -- ;
             if( psttSmallP[ CSpREFIX - 1 + idsLath ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsLath ].idAdam == sa_SSSlITERALeND ) cArmLiterals = 0 ;
    {
    for( ; idsLath <= psttSmallP->idAdam ; idsLath ++ )
    countT idsLath = idsWothP ;
    ZE( boolT , cArmLiterals ) ;
    ZE( countT , cNest ) ;
{
countT idsLathF( const strokeS* const psttSmallP , countT idsWothP )          // WILL RETURN idsWothP EXCEPT WHEN idsWoth POINTS TO THE BEGINNING OF AN AND OR OR OR LITERAL SUBEXPRESSION

/**/

*/
  when i return, will point to the lath position done
  the position in psttBigP at which to look for the specified AND pattern
  must be nonze
 idbDoP
  when i return, will point to the lath position done
  position idsDoP in psttSmallP must be sc_ccSSS(sa_SSSaND,?)
  must be nonze
 idsDoP
 psttBigP
  must have sc_ccSSS(sa_SSSaND) at position idsDoP
 psttSmallP
 tinP
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

