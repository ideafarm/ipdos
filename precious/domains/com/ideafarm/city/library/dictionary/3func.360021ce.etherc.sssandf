
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bMatch ;

    }
        idbDoP = idbDoSave ;
        //idsDoP = idsDoSave ;
    {
    if( !bMatch )

    }
        idsDoP = ++ idsMax ; // ')'

        }
            }
                }
                    if( !bDoNotAdvanceBig ) idbDoP ++ ;
                    idsDoP ++ ;
                {
                else
                }
                    }
                        bUndoIfNotMatch = 1 ;
                        if( !( -- cRepeatIf ) ) bDisarmUndoIf = 1 ;
                    {
                    else
                    if( cRepeat ) cRepeat -- ;

                    if( !bDoNotAdvanceBig ) idbDoP ++ ;
                    idsDoP = idsDoSaveInLoop ;
                {
                if( cRepeat || cRepeatIf )
            {
            else
            else if( idbDoP == psttBigP->idAdam && !bDoNotAdvanceBig ) { bMatch = 0 ; break ; } // WE ARE DONE
            }
                }
                    }
                        }
                            bUndoIfNotMatch = 1 ;
                            if( !( -- cRepeatIf ) ) bDisarmUndoIf = 1 ;
                        {
                        else if( cRepeatIf )
                        if( cRepeat ) cRepeat -- ;

                        if( !bDoNotAdvanceBig ) idbDoP ++ ;
                        idsDoP = idsDoSaveInLoop ;
                    {
                    else
                    if( idbDoP == psttBigP->idAdam && cRepeat ) { bMatch = 0 ; break ; } // WE ARE DONE
                {
                else
                if( !cRepeat && ( !cRepeatIf || idbDoP == psttBigP->idAdam ) ) break ;      // WE ARE DONE
            {
            if( idsDoP == idsMax )

            if( bDisarmUndoIf ) bDisarmUndoIf = bUndoIfNotMatch = 0 ;
            if( cArmLiterals  ) cArmLiterals -- ;

            idbDoLathMatch = idbDoP ;
            idsDoLathMatch = idsDoP ;

            }
                }
                    break ;
                    bMatch = 0 ;
                {
                else
                }
                    while( idbDoP < psttBigP->idAdam && ( psttBigP[ CSpREFIX + idbDoP ] == S1C( '\r' ) || psttBigP[ CSpREFIX + idbDoP ] == S1C( '\n' ) ) ) idbDoP ++ ;
                    idsDoP ++ ;
                {
                )
                    psttBigP[ CSpREFIX + idbDoP ] == S1C( '\n' )
                    ||
                    psttBigP[ CSpREFIX + idbDoP ] == S1C( '\r' )
                    ||
                    idbDoP == psttBigP->idAdam
                (
                if
            {
            )
                psttSmallP[ CSpREFIX + idsDoP ].idAdam == sa_SSSmARKlINEeND
                &&
                psttSmallP[ CSpREFIX + idsDoP ].idCaste == sc_cSSSmARK
                &&
                idsDoP < idsMax
            (
            if
            // AS OF THIS WRITING, THE ONLY SPECIFICATION THAT MUST BE OBEYED USING LOOK AHEAD IS: sa_SSSmARKlINEeND
            // THIS IS THE TIME TO TEST ANY LOOK AHEAD SPECIFICATIONS
            // IF WE GET HERE THEN THE CURRENT CURSORED STROKES MATCH
            // LOOK AHEAD RECIPES

            }
                }
                    }
                        }
                            continue ;
                            cRepeatIf = 0 ;
                            idbDoP = idbDoSaveInLoop ;
                            idsDoP ++ ;
                        {
                        else
                        }
                            break ;
                            idbDoP = idbDoLathMatch ;
                            idsDoP = idsDoLathMatch ;
                        {
                        if( idsDoP == idsMax )

                        bUndoIfNotMatch = 0 ;
                    {
                    else
                    }
                        break ;
                        bMatch = 0 ;
                    {
                    if( !bUndoIfNotMatch )
                {
                if( !bOk )

                ;
                    : sssTestF( tinP , bDoNotAdvanceBig , psttSmallP , psttBigP , idsDoP , idbDoP , tBlack , tPunctuation )
                    ? psttSmallP[ CSpREFIX - 1 + idsDoP ] == psttBigP[ CSpREFIX - 1 + idbDoP ]
                boolT bOk = cArmLiterals
            {
            else
            }
                }
                    }
                        }
                            continue ;
                            cRepeatIf = 0 ;
                            idbDoP = idbDoSaveInLoop ;
                            idsDoP ++ ;
                        {
                        else
                        }
                            break ;
                            idbDoP = idbDoLathMatch ;
                            idsDoP = idsDoLathMatch ;
                        {
                        if( idsDoP == idsMax )

                        bUndoIfNotMatch = 0 ;
                    {
                    else
                    }
                        break ;
                        bMatch = 0 ;
                    {
                    if( !bUndoIfNotMatch )
                {
                if( !sssOrF( tinP , psttSmallP , psttBigP ,  idsDoP ,  idbDoP ) )
            {
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam  == sa_SSSoR )
            }
                }
                    }
                        }
                            continue ;
                            cRepeatIf = 0 ;
                            idbDoP = idbDoSaveInLoop ;
                            idsDoP ++ ;
                        {
                        else
                        }
                            break ;
                            idbDoP = idbDoLathMatch ;
                            idsDoP = idsDoLathMatch ;
                        {
                        if( idsDoP == idsMax )

                        bUndoIfNotMatch = 0 ;
                    {
                    else
                    }
                        break ;
                        bMatch = 0 ;
                    {
                    if( !bUndoIfNotMatch )
                {
                if( !sssAndF( tinP , psttSmallP , psttBigP ,  idsDoP ,  idbDoP ) )
            {
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSaND )
            }
                }
                    continue ;
                    idsDoP ++ ;
                {
                else
                if( idsDoP == idsMax ) break ;

                }
                    cRepeatIf = psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote  - cRepeat ;
                    cRepeat   = psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam           ;
                {
                if( psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam <= psttSmallP[ CSpREFIX - 1 + idsDoP ].cNote )
            {
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSSrEPEAT )
            }
                }
                    continue ;
                    idsDoP ++ ;
                    cArmLiterals = 0 ;
                {
                else
                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL
            {
            else if( psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERALeND )
            }
                }
                    continue ;
                    idsDoP ++ ;
                    cArmLiterals = - 1 ;
                {
                else
                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL
            {
            else if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERALbEGIN )
            }
                }
                    continue ;
                    idsDoP ++ ;
                    cArmLiterals = 1 ;
                {
                else
                if( idsDoP == idsMax ) break ; // SHOULD BE IMPOSSIBLE SINCE THE CODE THAT SETS idsMax OBEYS sa_SSSlITERAL
            {
            if( !cArmLiterals && psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam == sa_SSSlITERAL )

            ZE( boolT , bDoNotAdvanceBig ) ;
            const countT idbDoSaveInLoop = idbDoP ;
            const countT idsDoSaveInLoop = idsDoP ;
        {
        if( idsDoP <= idsMax && idbDoP <= psttBigP->idAdam ) for(;;)
        ZE( countT , idbDoLathMatch ) ;
        ZE( countT , idsDoLathMatch ) ;

        TN( tPunctuation , TpUNCTUATION ) ;
        TN( tBlack , TbLACKeXCLUDINGnEWlINE ) ;

        ZE( boolT , cArmLiterals ) ;
        ZE( boolT , bDisarmUndoIf ) ;
        ZE( boolT , bUndoIfNotMatch ) ;
        ZE( countT , cRepeatIf ) ;
        ZE( countT , cRepeat ) ;

        idsMax -- ; // LATH BEFORE ')'
        bMatch = 1 ; // A NULL LENGTH PATTERN WILL ALWAYS MATCH
    {
    if( !POOP )

    // --------------------------------------------------------------------------------------------------------------------------------------------------
    // SET bMatch
    // --------------------------------------------------------------------------------------------------------------------------------------------------

    __Z( idsMax ) ;
    }
        if( idsMax > psttSmallP->idAdam ) idsMax = 0 ;

        }
            }
                if( bFound ) break ;

                }
                    }
                        break ;
                        if( !( -- cLevels ) ) bFound = 1 ;
                    {
                    case sa_SSSaNDeND :
                    }
                        break ;
                        ++ cLevels ;
                    {
                    case sa_SSSaND :
                    }
                        break ;
                        cArmLiterals = - 1 ; //A:ASSUME: STRING LENGTH CANNOT EXCEED maxCountTT
                    {
                    case sa_SSSlITERALbEGIN :
                    }
                        break ;
                        cArmLiterals = 1 ;
                    {
                    case sa_SSSlITERAL :
                {
                switch( psttSmallP[ CSpREFIX - 1 + idsMax ].idAdam )
                ZE( boolT , bFound ) ;
            {
            else if( psttSmallP[ CSpREFIX - 1 + idsMax ].idCaste == sc_ccSSS )
            else if( cArmLiterals                                            ) cArmLiterals -- ;
                 if( psttSmallP[ CSpREFIX - 1 + idsMax ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX - 1 + idsMax ].idAdam == sa_SSSlITERALeND ) cArmLiterals = 0 ;
        {
        for( ; idsMax <= psttSmallP->idAdam ; idsMax ++ )
        ZE( boolT , cArmLiterals ) ;
        countT cLevels = 1 ;
    {
    countT idsMax = idsDoP ;
    idsDoP ++ ;                           // WOTH AFTER '('

    // --------------------------------------------------------------------------------------------------------------------------------------------------
    // FIND THE MATCHING END
    // --------------------------------------------------------------------------------------------------------------------------------------------------

    const countT idbDoSave = idbDoP ;

    }
        if( POOP ) return bMatch ;
        __NZ( psttSmallP[ CSpREFIX - 1 + idsDoP ].idAdam  - sa_SSSaND ) ;
        __NZ( psttSmallP[ CSpREFIX - 1 + idsDoP ].idCaste - sc_ccSSS  ) ;
        if( POOP ) return bMatch ;
        __Z( psttBigP->idAdam ) ;
        __( psttSmallP->idAdam < idsDoP + 1 ) ; // NULL LENGTH SPECS ARE ALLOWED
        if( POOP ) return bMatch ;
        __Z( idbDoP ) ;
        __Z( idsDoP ) ;
        __Z( psttBigP ) ;
        __Z( psttSmallP ) ;
        if( POOP ) return bMatch ;
    {
    IFbEcAREFUL

    ZE( boolT , bMatch ) ;
{
/*1*/boolT etherC::sssAndF( tinS& tinP , const strokeS* const psttSmallP , const strokeS* const psttBigP ,  countT& idsDoP ,  countT& idbDoP )/*1*/

/**/

*/
  when i return, will point to the lath position done
  the position in psttBigP at which to look for the specified AND pattern
  must be nonze
 idbDoP
  when i return, will point to the lath position done
  position idsDoP in psttSmallP must be sc_ccSSS(sa_SSSaND,?)
  must be nonze
 idsDoP
 psttBigP
  must have sc_ccSSS(sa_SSSaND) at position idsDoP
 psttSmallP
 tinP
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

