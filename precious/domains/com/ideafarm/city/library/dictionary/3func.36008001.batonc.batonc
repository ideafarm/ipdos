
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
        _OUT_
        if( POOP ) BLAMMO ;

        }
            }
                pGrabA->grabNotes.cDetach = 0 ;
                pGrabA->grabNotes.cAttach = 0 ;
                pGrabA->grabNotes.flags   = bIsSign ? flGRABnOTES_CTaSsIGNc : flGRABnOTES_CTaSbATONc ;
                pGrabA->grabNotes.idCt    = grabNotesS::idNextF( tinP ) ;
                pGrabA->grabNotes.osPidCt = dosGetInfoBlocksIdProcessIF( tinP ) ;
                pGrabA->grabNotes.osTidCt = dosGetInfoBlocksIdThreadIF() ;
    
                pGrabA->formatF( tinP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , flagsGrab , idGrabLayerP ) ;
            {
            if( F(pGrabA->flagsF()) & flGRABc_DISABLED )
            pGrabA = &grabA ;
        {
        if( F(pGrabA->flagsF()) & flGRABc_DISABLED )

        }
            countT foo = 2 ;
            BLAMMO ;
        {
        if( F(pGrabA->flagsF()) & flGRABc_DISABLED && pGrabA != &grabA )
        //U::REWRITE THIS UGLYASS DEFINITION!
    
        }
            pGrabA->grabNotes.cDetach = 0 ;
            pGrabA->grabNotes.cAttach = 0 ;
            pGrabA->grabNotes.flags   = bIsSign ? flGRABnOTES_CTaSsIGNc : flGRABnOTES_CTaSbATONc ;
            pGrabA->grabNotes.idCt    = grabNotesS::idNextF( tinP ) ;
            pGrabA->grabNotes.osPidCt = dosGetInfoBlocksIdProcessIF( tinP ) ;
            pGrabA->grabNotes.osTidCt = dosGetInfoBlocksIdThreadIF() ;
    
            else               grabA.formatF( tinP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , flagsGrab , idGrabLayerP ) ;
            if( pGrabInPool ) pGrabA = pGrabInPool ;
    
            if( tinP.pAdamGlobal1->pPoolAdamTemp ) { pGrabInPool = new( 0 , tinP , LF ) grabAnnotatedS( tinP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , flagsGrab , idGrabLayerP ) ; ___BITScT( pGrabInPool , 0xdd8 ) ; } //U::LEAKS
            ZE( grabAnnotatedS* , pGrabInPool ) ;
        {
        else
        }
            if( F(flagsGrab) & flGRABc_GRABBED && !bIsSign ) pGrabA->grabF( tinP , idLineCtP , idiFileCtP , pbBitsCtP ) ; // ASSUME: THE CALLING CODE WILL UNGRAB ME

            }
                pGrabA->grabNotes.flags   |= bIsSign ? flGRABnOTES_ATTACHEDaSsIGNc : flGRABnOTES_ATTACHEDaSbATONc ;
            {
            else
            }
                pGrabA->grabNotes.flags   |= bIsSign ? flGRABnOTES_ATTACHEDaSsIGNc : flGRABnOTES_ATTACHEDaSbATONc ;
                pGrabA->grabNotes.cAttach ++ ;
            {
            else if( !( F(pNapkin->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYoPEN ) )
            }
                pNapkin->formattingIsDoneF( tinP ) ;
                pGrabA->grabNotes.cDetach = 0 ;
                pGrabA->grabNotes.cAttach = 0 ;
                pGrabA->grabNotes.flags   = bIsSign ? flGRABnOTES_CTaSsIGNc : flGRABnOTES_CTaSbATONc ;
                pGrabA->grabNotes.idCt    = grabNotesS::idNextF( tinP ) ;
                pGrabA->grabNotes.osPidCt = dosGetInfoBlocksIdProcessIF( tinP ) ;
                pGrabA->grabNotes.osTidCt = dosGetInfoBlocksIdThreadIF() ;
    
                pGrabA->formatF( tinP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , flagsGrab & ~( F(flGRABc_GRABBED) ) , idGrabLayerP ) ;
            {
            if( !( F(pNapkin->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
            pGrabA = pGrabInNapkin ;

            if( POOP ) BLAMMO
            __Z( pGrabInNapkin ) ;
            grabAnnotatedS* pGrabInNapkin = (grabAnnotatedS*)(byteT*)*pNapkin ;
            __( *pNapkin < sizeof( grabAnnotatedS ) ) ;
            __( !(byteT*)*pNapkin ) ; // THIS IS REDUNDANT; THE napkinC CONSTRUCTOR WILL HAVE BLAMMO'D
            __Z( pNapkin ) ;

            }
                THREADmODE1rESTORE

                else                                      { pNapkin = new( 0 , tinP , LF                            ) napkinC( tinP , idLineCtP , idiFileCtP , bits , ostoNapkinName , 0 , sizeof( grabAnnotatedS ) , ifcOPENsHAREDmEMORYhOW_nCeO , flagsNapkin ) ; ___( pNapkin ) ; }
                if( F(flagsCt) & flBATONcT_NAPKINiSzOMBIE ) pNapkin = new( 0 , tinP , pbZombieP , sizeof( napkinC ) ) napkinC( tinP , idLineCtP , idiFileCtP , bits , ostoNapkinName , 0 , sizeof( grabAnnotatedS ) , ifcOPENsHAREDmEMORYhOW_nCeO , flagsNapkin ) ;
                bitsC bits( tinP , CbITSlIFI , pbBitsCtP , 1 ) ;

                flagsT flagsNapkin = F(flagsP) & flBATONc_DOnOTsERIALIZEnAPKIN ? flNAPKINc_DOnOTsERIALIZEcT : flNAPKINc_null ;

                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            {

            if( POOP ) BLAMMO ;
            OStEXTA(  ostoNapkinName , postP ) ;
            OStEXTA(  ostoNapkinName , ostoPrefix ) ;
            OStEXT(   ostoNapkinName , COSTnAPKINnAMEmAX + 1      )

            //U::__(  pbZombieP && cbZombieP < sizeof( napkinC ) ) ;

            }
                LOGrAW5( "napkinC [cbZombie,sizeofNapkinC]: " , cbZombieP , " " , sizeof( napkinC ) , "\r\n" ) ;
            {
            if( pbZombieP && cbZombieP < sizeof( napkinC ) )
        {
        if( postP )

        ;    

            (             F(flagsP) & flBATONc_SHARElAYER             ? flGRABc_SHARElAYER                                                     : flGRABc_null                 )
            (             F(flagsP) & flBATONc_SNEAKYlOVER            ? flGRABc_SNEAKYlOVER                                                    : flGRABc_null                 ) |
            (             F(flagsP) & flBATONc_NOTjEALOUS             ? flGRABc_NOTjEALOUS                                                     : flGRABc_null                 ) |
            (             F(flagsP) & flBATONc_GRABBEDnEVERtID        ? flGRABc_GRABBEDnEVERtID                                                : flGRABc_null                 ) |
            (             F(flagsP) & flBATONc_GRABBED                ? flGRABc_GRABBED                                                        : flGRABc_null                 ) |
            (             F(flagsP) & flBATONc_DOnOTrEGISTERiNtIN     ? flGRABc_DOnOTrEGISTERiNtIN                                             : flGRABc_null                 ) |
            ( postP                                                   ? flGRABc_INTERpROCESS                                                   : flGRABc_null                 ) |
            ( bIsSign                                                 ? flGRABc_ISsIGN | flGRABc_DOnOTrEGISTERiNtIN | flGRABc_DISABLErECURSION : flGRABc_null                 ) |
        flagsT flagsGrab =

        const boolT bIsSign = !!( F(flags) & flBATONc_ISsIGN ) ;

        else            thirdC::c_memsetIF( tinP , (byteT*)pbBitsCt , sizeof pbBitsCt ) ;
        if( pbBitsCtP ) thirdC::c_memcpyIF( tinP , (byteT*)pbBitsCt , (byteT*)pbBitsCtP , sizeof pbBitsCt ) ;
    
        }
            if( POOP ) BLAMMO ;
            }
                __( !!pbZombieP && !cbZombieP ) ;
                FV( flBATONc , flagsP ) ;
                __( thirdC::c_strlenIF( tinP , postP ) > COSTnAPKINnAMEmAX - ostoPrefix.costF() ) ;
                __( !postP[ 0 ] ) ;
                __( !pbZombieP && !tinP.pAdamGlobal1->pPoolAdamTemp ) ;
            {
            if( postP )
            if( POOP ) BLAMMO ;
        {
        IFbEcAREFUL

        OStEXTV( ostoPrefix , "batonC/" )

        _INoLD_
    {
    SCOOP
{
flagsCt( pbZombieP ? flBATONcT_NAPKINiSzOMBIE : flBATONcT_null )
flags( flagsP ) ,
pNapkin( 0 ) ,
pGrabA( &grabA ) ,
grabA( tinP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , flGRABc_DISABLED , idGrabLayerP ) ,
cFunctionsPending( 1 ) ,
poop( flPOOP_SMELLY ) ,
idiFileCt( idiFileCtP ) ,
idLineCt( idLineCtP ) ,
/*1*/batonC::batonC( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postP , const countT idGrabLayerP , const flagsT flagsP , byteT* const pbZombieP , const countT cbZombieP , const countT idMemorySpaceP )/*1*/ :

/**/
*/
  i am intended for use only by system code that needs to construct a napkinC when no poolC object exists
   i will layout pbZombieP as: PAD napkinC
  if not 0 then must be the address of CBzOMBIEbATONc bytes that i can use to construct a napkin in
  it is illegal to specify a nonze value in the definition of an adam
  can be 0
 pbZombieP
 postP
arguments
 this can be used to prevent multiple citizens of a class from being hired on the same computer
fFailIfExistsP: if set, then POOP will become impotent if a baton with the same name already exists
  replace "com/domain" with your domain name (e.g. "com/chevrolet" or "edu/uchicago")
  U::conj; this comment is incorrect; the name must be a napkinC name
 if not 0, must be of the form T("any.name/with.slashes.and.dots")
 can be 0
postP: a name for this batonC object
works even if impotent
 it should work for application code, but it is illegal for application code to construct static global objects
 this usage is reserved for system code
it is illegal to construct me as a static global
  \<A HREF=\"5.3a00104.1.1.0.html\"\>3a00104:  WAKEsHOW( "example.simplest.func.10a0001.batonC.batonC" )\</A\>
 simplest
examples
\<A HREF=\"5.10a0001.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

