
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbData ;

    tlsCheckF() ;

    //}
    //    LOGrAWtID2( "tinS::newF [pb]: " , pbData ) //U:: TO FIND A BUG: REMOVE IN PRODUCTION FOR SPEED
    //    tinS& tinP = *this ;
    //{

    }
        }
            th.pcStepLFAt[ offElt + 2 ] = (countT)pbData      ;
            th.pcStepLFAt[ offElt + 1 ] = idiFileP            ;
            th.pcStepLFAt[ offElt     ] = idLineP   | BM_HIGH ;     // BM_HIGH INDICATES "NEW"
            offElt = offStep * 3 ;
            countT offStep = ( th.cSteps ++ ) % CmAXsTEPtLS ;
        {
        ZE( countT , offElt ) ;

        }
            cTls ++ ;
            if( postNameP ) thirdC::c_memsetIF( tinP , pbData , cbP ) ; //tlsBlobC RELIES ON THIS LINE TO SMUDGE ITS FOOT FINGERPRINTS
            pbData = pbc ;
            if( pbe < pbc + cbP ) { BLAMMO ; } //IF BLOW HERE THEN NEED TO MAKE TLS LARGER FOR THIS THREAD

            }
                thirdC::c_memcpyIF( tinP , pbc , postInGroupP , costaInGroupP )  ; pbc += costaInGroupP    ; // postInGroup
                if( pbe < pbc + costaInGroupP ) { BLAMMO ; } //IF BLOW HERE THEN NEED TO MAKE TLS LARGER FOR THIS THREAD
            {
            if( costaInGroupP )
            }
                thirdC::c_memcpyIF( tinP , pbc , postNameP , costaNameP )           ; pbc += costaNameP       ; // postName
                if( pbe < pbc + costaNameP ) { BLAMMO ; } //IF BLOW HERE THEN NEED TO MAKE TLS LARGER FOR THIS THREAD
            {
            if( costaNameP )
            *(countT*)pbc = costaInGroupP                                                        ; pbc += sizeof( countT ) ; // costaInGroup
            *(countT*)pbc = costaNameP                                                           ; pbc += sizeof( countT ) ; // costaName
            *(countT*)pbc = 0                                                                    ; pbc += sizeof( countT ) ; // offNextInGroup
            *(countT*)pbc = 0                                                                    ; pbc += sizeof( countT ) ; // offNextObject
            *(countT*)pbc = offElder                                                             ; pbc += sizeof( countT ) ; // offElder
            *(countT*)pbc = 1                                                                    ; pbc += sizeof( countT ) ; // cRef
            *(countT*)pbc = sizeof( countT ) * 6 + costaNameP + costaInGroupP + cbP              ; pbc += sizeof( countT ) ; // cbEntry
            //if( tinP.pc Utility[ 0 ] && costaInGroupP ) { CONoUTrAW( postInGroupP ) ; CONoUTrAW( "\r\n" ) ; }
            //if( tinP.pc Utility[ 0 ] && costaNameP    ) { CONoUTrAW( postNameP    ) ; CONoUTrAW( "\r\n" ) ; }
            //if( tinP.pc Utility[ 0 ]                  ) { CONoUTrAW3( "tinS::newF/entry formatted at " , (countT)pbc , "\r\n" ) ; }
            //if( tinP.pc Utility[ 0 ] ) tinP.pc Utility[ 1 ] ++ ;
            const byteT* const pbe = pbTls + cbTls ;
            byteT*             pbc = pbTls + th.offTopEntry ;
        
            }
                }
                    offCursor = ( (countT*)( pbTls + offCursor ) )[ TLSeNTRYoFF_offElder ] ;
        
                    }
                        break ;
                        offNextInGroup = th.offTopEntry ;
                        if( offNextInGroup ) { BLAMMO ; }
                        countT& offNextInGroup = ( (countT*)( pbTls + offCursor ) )[ TLSeNTRYoFF_offNextInGroup ] ;
                    {
                    )
                        ( costaInGroupP && postInGroup && !thirdC::c_strcmpIF( tinP , postInGroup , postInGroupP ) )
                        ||
                        ( !costaInGroup && !costaInGroupP )
                    (
                    if
        
                    const osTextT* const postInGroup  = !costaInGroup ? 0 : (byteT*)&costaInGroup + sizeof( countT ) + costaName ;
                    countT&              costaInGroup = ( (countT*)( pbTls + offCursor ) )[ TLSeNTRYoFF_costaInGroup ] ;
                    countT&              costaName    = ( (countT*)( pbTls + offCursor ) )[ TLSeNTRYoFF_costaName    ] ;
                {
                while( offCursor )
                countT offCursor = offElder ;
        
                offNextObject = th.offTopEntry ;                                               // elder.offNextObject
                if( offNextObject ) { BLAMMO ; }
                countT& offNextObject = ( (countT*)( pbTls + offElder ) )[ TLSeNTRYoFF_offNextObject ] ;
            {
            if( offElder )

            if( cbTls <= th.offTopEntry + 7 * sizeof( countT ) ) { BLAMMO ; } //IF BLOW HERE THEN NEED TO MAKE TLS LARGER FOR THIS THREAD
            if( cbTls <= th.offTopEntry                        ) { BLAMMO ; } //IF BLOW HERE THEN THE FOLLOWING CODE HAS A BUG

            //if( !thirdC::c_strcmpIF( *this , postThreadName , "tmWorkerF" ) ) { CONoUTrAW5( "" , (countT)&th.offTopEntry , "    tlsNewF / !pbData so just set [offTopEntry]:    " , th.offTopEntry , "\r\n" ) ; }

            th.cNew ++ ;
        
            ;
                : offElder + sizeof( countT ) + ( (countT*)( pbTls + offElder ) )[ TLSeNTRYoFF_cbEntry ]
                ? sizeof( tlsHeaderS )
            th.offTopEntry = !offElder
            const countT offElder = th.offTopEntry ;

            pcUtility[ 2 ] = TLSeNTRYoFF_cbEntry    ; //U:: TO FIND A BUG
            pcUtility[ 1 ] = (countT)pbTls          ; //U:: TO FIND A BUG
            pcUtility[ 0 ] = th.offTopEntry            ; //U:: TO FIND A BUG
        {
        if( !pbData )
    
        }
            }
                offMe = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_offElder ] ;
        
                }
                    }
                        break ;
                        pbData = (byteT*)&costaInGroup + sizeof( countT ) + costaName + costaInGroup ;
                        __( !( cRef ++ ) ) ;
                        countT& cRef = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_cRef ] ;
                    {
                    if( postName && !thirdC::c_strcmpIF( tinP , postName , postNameP ) )
                {
                if( !postInGroupP || ( postInGroup && !thirdC::c_strcmpIF( tinP , postInGroup , postInGroupP ) ) )
        
                const osTextT* const postInGroup  = !costaInGroup ? 0 : (byteT*)&costaInGroup + sizeof( countT ) + costaName ;
                const osTextT* const postName     = !costaName    ? 0 : (byteT*)&costaInGroup + sizeof( countT ) ;
                countT&              costaInGroup = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_costaInGroup ] ;
                countT&              costaName    = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_costaName    ] ;
            {
            while( offMe )
            countT offMe = costaNameP ? th.offTopEntry : 0 ;
        {
        //if( !thirdC::c_strcmpIF( *this , postThreadName , "tmWorkerF" ) ) { CONoUTrAW5( "" , (countT)&th.offTopEntry , "    tlsNewF / on entry [offTopEntry]:    " , th.offTopEntry , "\r\n" ) ; }

        tlsHeaderS& th = *(tlsHeaderS*)pbTls ;

        }
            countT foo = 2 ;
        {
        if( costaNameP )
    
        const countT costaInGroupP = !postInGroupP ? 0 : 1 + thirdC::c_strlenIF( tinP , postInGroupP ) ;
        const countT costaNameP    = !postNameP    ? 0 : 1 + thirdC::c_strlenIF( tinP , postNameP    ) ;
    {
    ZE( byteT* , pbData ) ;

    }
        scoopC _scoop( tinP , LF , _poop ) ;
        poopC _poop( flPOOP_SMELLY ) ;
    {
    //THIS BUG WAS FOUND; IT WAS A ZOMBIE tinP REFERENCE; THE TEST IS RETAINED TO DETECT NEW INTRODUCTIONS OF THAT BUG

    }
        *pcBlammo = -1 ;
        ZE( countT* , pcBlammo ) ;

        LOGrAW(    postSay ) ;
        CONoUTrAW( postSay ) ;

        ;
            : "\r\nerror:  tlsNewF called on raw thread (tmBreakF)\r\n"
            ? "\r\nerror:  tlsNewF called on raw thread (tmHeartF)\r\n"
        osTextT* postSay = tinP.idTinNamed == ifcIDtINnAMED_tinHeartI
    {
    if( tinP.idTinNamed == ifcIDtINnAMED_tinHeartI || tinP.idTinNamed == ifcIDtINnAMED_tinBreakI  ) // RAW THREAD, SO CANNOT CALL TINSL

    //_IO_
    //SPEED OPTIMIZATION: THIS _IO_ WOULD HAVE THE #1 HIGHEST FREQUENCY OF CALLS

    if( !pbTls ) { BLAMMO ; }

    }
        countT foo = 2 ;
    {
    if( !thirdC::c_strcmpIF( *this , postThreadName , "tmWorkerF" ) )

    tlsCheckF() ;

    }
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    POOPIES

    tinS& tinP = *this ;
{
/*1*/byteT* tinS::tlsNewF( const countT idLineP , const countT idiFileP , const countT cbP , const osTextT* const postNameP , const osTextT* const postInGroupP )/*1*/

//
//    postInGroup
//    postName
//    costaInGroup (includes null terminator; if 0 then class is unnamed)
//    costaName (includes null terminator; if 0 then object is unnamed)
//    offNextInGroup (set to 0 by constructing entry)
//    offNextObject (set to 0 by constructing entry; if null then terminates the tls stack
//    offElder (address of entry immediately below me) (0 indicates that i am the bottommost entry)
//    cRef (number of instances including the constructing instance; is never 0)
//    cbEntry (exclusive prefix)
//   tls entry
//    th.offTopEntry (address of lath entry constructed); this is redundant; it is for speed and to detect corruption
//   tls header
//
// TLS LAYOUT

/**/
*/
caller must d elete tls pointers lifo
if i allocate unnamed bytes then i do not initialize them
if i allocate named bytes then i initialize those bytes to 0
if there was no bytes associated with this name and group, i allocate those bytes
i evaluate to the address of cbP bytes associated with the specified name and group
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

