
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            }
                }
                    BLAMMO ;

                    LOGcALLnEST( "nonmonotonic grab call nest:" ) ;

                    LOGrAWf(    "! error: nonmonotonic grabbing (grab layer decrease attempted [bOnlyWo,lifi,idGrabLayer,lifiHe,idGrabLayerHe]: " , bOnlyWo , "\r\n ME: " , idiFileCt , "(" , idLineCt , ") " , idGrabLayer , " ;\r\n HE: " , tinP.pPanLifiRecurseGrabbedLevel[ offi + 2 ] , "(" , tinP.pPanLifiRecurseGrabbedLevel[ offi + 1 ] , ") " , idGrabLayerHe , "\r\n" ) ;
                    CONoUTrAWf( "! error: nonmonotonic grabbing (grab layer decrease attempted [bOnlyWo,lifi,idGrabLayer,lifiHe,idGrabLayerHe]: " , bOnlyWo , "\r\n ME: " , idiFileCt , "(" , idLineCt , ") " , idGrabLayer , " ;\r\n HE: " , tinP.pPanLifiRecurseGrabbedLevel[ offi + 2 ] , "(" , tinP.pPanLifiRecurseGrabbedLevel[ offi + 1 ] , ") " , idGrabLayerHe , "\r\n" ) ;

                    LOGrAW3( "\r\n[idAdam]: " , tinP.pAdamGlobal1->idAdam , "\r\n" ) ;
                    CONoUTrAW3( "\r\n[idAdam]: " , tinP.pAdamGlobal1->idAdam , "\r\n" ) ;
                {
                if( bComplainIf && !( F(flagsP) & flBASEgRABcrEGISTERbEGUN_RECURSING ) )
    
                ;
                        : idGrabLayer <= idGrabLayerHe
                        ? idGrabLayer <  idGrabLayerHe
                    : F(flagsCt) & flBASEgRABc_SHARElAYER
                    ? 1
                boolT bComplainIf = bOnlyWo
                countT idGrabLayerHe = tinP.pPanLifiRecurseGrabbedLevel[ offi + 4 ] ;

                }
                    }
                        BLAMMO ; //20151117@1854: THIS WAS ADDED WITHOUT ANALYSIS AFTER VERIFYING THAT PRODUCTION CONFIGURATION CAN BE BUILT AND RUN
                        LOGrAW(   ostoJealous ) ;

                        OStEXTAK( ostoJealous , "_9)\r\n\r\n" ) ;
                        OStEXTC9( ostoJealous , idLineP ) ;
                        OStEXTAK( ostoJealous , "(" ) ;
                        OStEXTC(  ostoJealous , idiFileP , 0 ) ;
                        OStEXTAK( ostoJealous , "_9) and being grabbed at " ) ;
                        OStEXTC9( ostoJealous , idLineCt ) ;
                        OStEXTAK( ostoJealous , "(" ) ;
                        OStEXTC(  ostoJealous , idiFileCt , 0 ) ;
                        OStEXTAK( ostoJealous , "_9).  ME: ct at " ) ;
                        OStEXTC9( ostoJealous , pbgHe->idLineGrabberNote ) ;
                        OStEXTAK( ostoJealous , "(" ) ;
                        OStEXTC(  ostoJealous , pbgHe->idiFileGrabberNote , 0 ) ;
                        OStEXTAK( ostoJealous , "_9) in " ) ;
                        OStEXTC9( ostoJealous , pbgHe->idLineGrabber ) ;
                        OStEXTAK( ostoJealous , "(" ) ;
                        OStEXTC(  ostoJealous , pbgHe->idiFileGrabber , 0 ) ;
                        OStEXTAK( ostoJealous , "_9) and grabbed at " ) ;
                        OStEXTC9( ostoJealous , pbgHe->idLineCt ) ;
                        OStEXTAK( ostoJealous , "(" ) ;
                        OStEXTC(  ostoJealous , pbgHe->idiFileCt , 0 ) ;
                        OStEXTAK( ostoJealous , "_9) ct at " ) ;
                        OStEXTC9( ostoJealous , tinP.pPanLifiRecurseGrabbedLevel[offi+1] ) ;
                        OStEXTAK( ostoJealous , "(" ) ;
                        OStEXTC(  ostoJealous , tinP.pPanLifiRecurseGrabbedLevel[offi+2] , 0 ) ;
                        OStEXTAK( ostoJealous , "\r\nHE is jealous of ME because this thread, while holding HIM, is now trying to grab ME.  HE: " ) ;
                        OStEXT(   ostoJealous , TUCK << 2 ) ;
                    {
                    if( !( F(pbgHe->flagsCt) & flBASEgRABc_NOTjEALOUS ) /*&& tinP.p Ether*/ )        //20200822@2016: COMMENTED OUT tinP.p Ether WITHOUT ANALYSIS
                    baseGrabC* pbgHe = (baseGrabC*)tinP.pPanLifiRecurseGrabbedLevel[ offi ] ;        //U:: THIS IS A BUG: pandle WILL NOT POINT TO A baseGrabC INSTANCE FOR TYPES (grabitC grabotC) OTHER THAN grabC
                {
                )
                    && !( tinP.pPanLifiRecurseGrabbedLevel[ offi ] & BM_HIGH )
                    !( F(flagsCt) & flBASEgRABc_SNEAKYlOVER )
                (
                if

                // "SNEAKY LOVERS" CAN GRAB WITHOUT TRIGGERING JEALOUSY
                // grabC INSTANCES ARE JEALOUS BY DEFAULT, WHICH MEANS THAT THEY, WHILE GRABBED, WILL NOT ALLOW THE THREAD TO GRAB ANOTHER WO
                // THE CONCEPT OF JEALOUSY ALLOWS APPLICATION CODE TO AVOID DEADLOCKS BY FORCING APP CODE TO EXPLICITLY CONSTRUCT grabC INSTANCES AS NONjEALOUS
                //20151117@1242: ADDED TO BLAMMO IF I AM BEGIN GRABBED BY A THREAD THAT ALREADY HOLDS A JEALOUS OTHER
            {
            if( tinP.pPanLifiRecurseGrabbedLevel[ offi ] && tinP.pPanLifiRecurseGrabbedLevel[ offi ] != pandle )
        {
        for( countT offi = 0 ; offi < sizeof tinP.pPanLifiRecurseGrabbedLevel / sizeof tinP.pPanLifiRecurseGrabbedLevel[ 0 ] ; offi += 5 )
        boolT bOnlyWo = F(processGlobal1I._thirdC_flagsModeProcess2) & flMODEpROCESS2_GRABoNLYwO || F(tinP.flagsThreadMode3) & flTHREADmODE3_GRABoNLYwO ;
        //BLAMMO IF CALLING THREAD IS GRABBING BACKWARDS IN THE GRAB OBJECT SEQUENCE ; THE SET OF ALL GRAB OBJECTS IS WEAKLY ORDERED, AS CAN BE SEEN BY INSPECTING THIS CODE
    {
    if( !( F(flagsP) & flBASEgRABcrEGISTERbEGUN_RECURSING ) )

    }
        tinP.monitor.pPanLifiGrabbing[ 0 ] = pandle ;
        tinP.monitor.pPanLifiGrabbing[ 1 ] = idLineP  ;
        tinP.monitor.pPanLifiGrabbing[ 2 ] = idiFileP ;
    {
    if( !( F(flagsCt) & flBASEgRABc_DOnOTrEGISTER ) )

    //}
    //    countT foo = 2 ;
    //{
    //if( !( pandle & BM_HIGH ) && !( F(this->flagsCt) & flBASEgRABc_NOTjEALOUS ) && idLineP == 9162 && idiFileP == 0x33000065 )
    //TO FIND A BUG

    ;
        : ( (countT)&(byteT&)*(grabitC*)this ) | BM_HIGH
        ? (countT)this
    const countT pandle = idTypeCt == ifcIDtYPEdERIVEDbASEgRABc_grabC

    _IO_

    SCOOP
{
/*1*/voidT baseGrabC::registerBegunF( tinS& tinP , const countT idLineP , const countT idiFileP , const flagsT flagsP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

