
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.strokeF( tinP , T("final aok\r\n") ) ;
}
    else           for( countT idAdam = idMin ; !ether && idAdam <= idMax && !etThread ; idAdam ++ ) workF( tinP , etThread , idAdam ) ;
    if( bReverse ) for( countT idAdam = idMax ; !ether && idAdam >= idMin && !etThread ; idAdam -- ) workF( tinP , etThread , idAdam ) ;

    const boolT bReverse = bReverseF( tinP , etThread ) ;

    if( idMin == 0x51000000 ) idMin ++ ;

    else etThread.boxMenuIdRangeF( tinP , idMin , idMax , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/5adam.51000???") , 0x100000 , S1C('/') ) ;
    }
        idMax = 0x5100061f ;
        idMin = 0x5100061f ;
    {
    if( bTest )
    ZE( countT , idMax ) ;
    ZE( countT , idMin ) ;

    const boolT bTest = bTestF( tinP , etThread ) ;

    stateS state( tinP , etThread ) ;
{

TODO

}
    etThread.delF( tinP , psttLog ) ;
    //etThread.ifcSayF( tinP , psttLog , flSAY_APPEND | flSAY_LOG ) ;
    etThread.strConcatenateF( tinP , psttLog , stPhrases ) ; ___( psttLog ) ;
    ZE( strokeS* , psttLog ) ;

    }
        DEL( ps ) ;
        }
            etThread.delF( tinP , psttNote ) ;
            etThread.delF( tinP , psttLine ) ;
            stPhrases << postOldC( tinP , etThread , T("note: ")+T(psttNote)+T("\r\nbad line: \"")+T(psttLine)+T("\"\r\nidLine: ")+TF4(idLine,flFORMAT_FOREIGN,0,0xa)+T("\r\nidColumn: ")+TF4(idColumn,flFORMAT_FOREIGN,0,0xa)+T("\r\n") ) ;

            soul >> psttNote ; ___( psttNote ) ;
            soul >> psttLine ; ___( psttLine ) ;
            soul >> idColumn ;
            soul >> idLine ;

            ZE( strokeS* , psttNote ) ;
            ZE( strokeS* , psttLine ) ;
            ZE( countT , idColumn ) ;
            ZE( countT , idLine ) ;

            soulC& soul = *ps ;
        {
        stErrors >> ps ;
        ZE( soulC* , ps ) ;
    {
    while( stErrors )
    stPhrases << postOldC( tinP , etThread , T("make ")+TF1(idAdamP)+T("\r\n") ) ;
    stackC stPhrases( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_byteT ) ;

    etThread.osMakeF( tinP , stErrors , idAdamP /*U: , flMAKE_MINIMALtIME | flMAKE_MINIMALtIMErISKY*/ ) ;
    stackC stErrors( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_soulC ) ;
{
voidT workF( tinS& tinP , etherC& etThread , const countT idAdamP )

}
    return bTest ;

    }
        }
            if( bOk ) etThread.strokeF( tinP , T("\"")+T(psttc1)+T("\" ok\r\n") ) ;
            else if( !etThread.strCompareF( tinP , psttc1 , T("!test") ) ) { bTest = bOk = 1 ; }
            }
                //}
                //    default : { idArg = 0 ; break ; }
                //{
                //switch( idArg )
                idArg = 0 ;
            {
            if( idArg )

            ZE( boolT , bOk ) ;
        {
        FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )
        ZE( countT , idArg ) ;
    {
    ZE( boolT , bTest ) ;
{
boolT bTestF( tinS& tinP , etherC& etThread )

}
    return bReverse ;

    }
        }
            if( bOk ) etThread.strokeF( tinP , T("\"")+T(psttc1)+T("\" ok\r\n") ) ;
            else if( !etThread.strCompareF( tinP , psttc1 , T("!reverse") ) ) { bReverse = bOk = 1 ; }
            }
                //}
                //    default : { idArg = 0 ; break ; }
                //{
                //switch( idArg )
                idArg = 0 ;
            {
            if( idArg )

            ZE( boolT , bOk ) ;
        {
        FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )
        ZE( countT , idArg ) ;
    {
    ZE( boolT , bReverse ) ;
{
boolT bReverseF( tinS& tinP , etherC& etThread )

}
{
stateC( tinP , etherP , sizeof *this , 0 , translateStateF )
stateS::stateS( tinS& tinP , etherC& etherP ) :

TRANSLATEsTATE_END
    state.idMe ++ ;
TRANSLATEsTATE_MIDDLE
    case 1 : { state.idMe        = stateOther.idMe        ; }
TRANSLATEsTATE_BEGIN( stateS , 1 )

;
}
    stateS( tinS& tinP , etherC& etherP ) ;

    countT idMe ;
    countT idVersion ;
{
struct stateS : public stateC

/*1*/WAKEhIDE( "ifcIDaDAMoLD_MAKEaLLaDAMS.make.all.adam.test.images" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

