
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_
    delF( tinP , postKey ) ;

    #endif

        #endif

            }
                delF( tinP , postv ) ;
                if( postValueP ) postValueP[ costv ] = 0 ;
                c_memcpyIF( tinP , postValueP , postv , costv ) ; // THIS COSTS CPU CYCLES BUT AVOIDS WASTING POOLoLD BYTES
                newF( tinP , LF , postValueP , costv + 1 ) ; ___( postValueP ) ;
                countT costv = tinP.brcRaw ;
                BOSdOnOTtEST( WHATgbo , strlen( postv ) )
            {
            if( postv )

            }
                cbTry *= 2 ;
                delF( tinP , postv ) ;

                if( *postv ) break ;

                }
                    break ;
                    delF( tinP , postv ) ;
                {
                if( tinP.brcRaw <= cbTry || *postv != '%' )

                BOSpOOP
                BOS( WHATgbo , BOSoK , ExpandEnvironmentStrings( postKey , postv , cbTry ) )
                *postv = 0 ;

                }
                    break ;
                    __1
                {
                else
                }
                    #endif
                        }
                            pNote->cbRequested  = pNote->cbUsedReally = cbTry ;
                            pNote->idType       = ifciDtYPEdROPnOTE_thirdCdosScanEnvFpostv ;
                        {
                        if( pNote )
                        dropNoteS* pNote = PUSE.pDropNoteF( tinP , (byteT*)postv ) ;
                    #if defined( ENABLEdROPnOTES )
                {
                if( postv )
                PUSE.newF( tinP , LF , postv , cbTry ) ; ___( postv ) ; // DONE THIS WAY SO IMPOTENCE DOES NOT OCCUR IF CANNOT ALLOC
            {
            while( !*this )
            ZE( osTextT* , postv ) ;
            countT cbTry = 0x10 ;
            //c_struprIF( tinP , postKey ) ; (NOT REQUIRED BY NT; NT IGNORES CASE)
            }
                c_strncpyIF( tinP , postKey , ostot , costaKey ) ;
                OStEXTAK( ostot  , "%" ) ;
                OStEXTA(  ostot  , postKeyP ) ;
                OStEXTAK( ostot  , "%" ) ;
                OStEXT(   ostot , 0x100 )
            {

        #else

            delF( tinP , postValue ) ;
            }
                OStEXTA( postValueP  , postValue ) ;
                newF( tinP , LF , postValueP , tinP.brcRaw + 1 ) ; ___( postValueP ) ;
                BOSdOnOTtEST( WHATgbo , strlen( postValue ) )
            {
            if( !*this && postValue )
            }
                if( POOP || *postValue == '%' ) delF( tinP , postValue ) ; //U::THIS CHECK TO SEE WHETHER THE BUFFER IS MODIFIED MIGHT NOT BE NEEDED NOW THAT THE CODE HAS BEEN CORRECTED TO COMPARE THE RETURN VALUE WITH THE BUFFER SIZE

                __( tinP.brcRaw > CBbATCH ) ;
                BOSpOOP
                BOS( WHATgbo , BOSoK , ExpandEnvironmentStrings( postKey , postValue , CBcATCH ) )

                //c_struprIF( tinP , postKey ) ; (NOT REQUIRED BY NT; NT IGNORES CASE)
                OStEXTAK( postKey  , "%" ) ;
                OStEXTA( postKey  , postKeyP ) ;
                OStEXTAK( postKey  , "%" ) ;
            {
            if( !*this && postValue )
            newF( tinP , LF , postValue , CBcATCH ) ; ___( postValue ) ;
            ZE( osTextT* , postValue ) ;

        #if defined( NEVERdEFINED )
        //U: DELETE THIS OLD CODE ONCE AM CONFIDENT THAT THE NEW CODE WORKS 000205

    #elif defined( __NT__ )

        }
            OStEXTA( postValueP  , postValue ) ;
            newF( tinP , LF , postValueP , tinP.brcRaw + 1 ) ; ___( postValueP ) ;
            BOSdOnOTtEST( WHATgbo , strlen( postValue ) )
        {
        if( !*this && postValue )
        }
            if( tinP.brcRaw ) __NZ( postValue ) ;
            __( tinP.brcRaw && tinP.brcRaw != ERROR_ENVVAR_NOT_FOUND ) ; 
            BOSdOnOTtEST( WHATgbo , DosScanEnv( postKey , (const osTextT**)&postValue ) ) //U: VERIFY THAT THIS SETS postValue TO A VALUE THAT WE SHOULD -NOT- DELETE                
        {
        if( !POOP )
        c_struprIF( tinP , postKey ) ;
        OStEXTA( postKey  , postKeyP ) ;
        ZE( osTextT* , postValue ) ;

    #ifdef __OS2__

    newF( tinP , LF , postKey , costaKey ) ; ___( postKey ) ; // +1 NEEDED FOR OS/2; +3 NEEDED FOR NT
    const countT costaKey = tinP.brcRaw + 3 ;
    BOSdOnOTtEST( WHATgbo , strlen( postKeyP ) )
    ZE( osTextT* , postKey ) ;
    _INoLD_

    }
        if( POOP ) return ;
        __Z( postKeyP ) ;
        __NZ( postValueP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
    SCOOP
{
/*1*/voidT thirdC::dosScanEnvF( tinS& tinP , osTextT*& postValueP , const osTextT* const postKeyP )/*1*/

//U: REWRITE THE NT CODE TO USE GetEnvironmentVariable (SEE THE 102* CODE THAT CALLS GetCurrentDirectory WHICH IS VERY SIMILAR)

/**/
*/
  must not be 0
 postKeyP
  must be 0
 postValueP
arguments
 for windows, successively large buffer sizes are attempted until the attempt succeeds or a limit is reached
for windows, there is no way to distinguish reasons for failure, which can include an insufficiently large receiving buffer
for os/2, the value can be any length
impotence will occur, however, if the key exists but a buffer to hold the value cannot be allocated
if the key does not exist, postValueP remains 0 and impotence does not occur
  \<A HREF=\"5.3e00104.1.1.0.html\"\>3e00104:  WAKEsHOW( "example.simplest.func.1020031.thirdC.dosScanEnvF" )\</A\>
 simplest
examples
\<A HREF=\"5.1020031.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosScanEnvF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

