
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

//==============================================================================================================================================================
//==== BELOW THIS LINE: DAYTIME WORK ===========================================================================================================================
//==============================================================================================================================================================

REST

}
    }
        }
            etThread.delF( tinP , pbs ) ;
            if( pbs ) del_sessionS_ptrs_F( tinP , (sessionS*)pbs ) ;
            sws_session >> pbs ;
            ZE( byteT* , pbs ) ;
        {
        while( sws_session )
        idhLever = *(nicNameC*)sws_session.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = sws_session.cFlavorsF( tinP ) ;
{
TELL( "cleaning up" ) ;

etThread.delF( tinP , postxHelpExe   ) ;
etThread.delF( tinP , postxLoggedOut ) ;
etThread.delF( tinP , postxLoggedIn  ) ;
etThread.delF( tinP , postxNotFound  ) ;

etThread.ifcDrivenServerF( tinP , i1 , i2 ) ;
serverInfo2S i2( ifcPORToLD2_HTTP , TF2(thirdC::third_idAdamRootI_IF( tinP ),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , 0 , (countT)&c2p , 0 , 1 , sizeof( stateS ) , translateStateF ) ;
serverInfo1S i1( &pbdVarying , b_pbdVarying , bHandedOff , sgnIdPortReplaced , tmcF , countTC() , ether ) ;
TELL( "serving the HTTP port" ) ;
etThread.ifcChatF( tinP , (countT)&c2p , DDNUMB , jobFillCourseF ) ;
TELL( "preparing to accept chat clients" ) ;

count2S c2p( (countT)&c8p1 , (countT)&c8p2 ) ;
c8p2.c7 = (countT)&costxHelpExe ;
c8p2.c6 = (countT)&postxHelpExe ;
c8p2.c5 = (countT)&costxLoggedOut ;
c8p2.c4 = (countT)&postxLoggedOut ;
c8p2.c3 = (countT)&costxLoggedIn ;
c8p2.c2 = (countT)&postxLoggedIn ;
c8p2.c1 = (countT)&sws_session ;
c8p1.c8 = (countT)&b_idhLever ;
c8p1.c7 = (countT)&idhLever ;
c8p1.c5 = (countT)&costxNotFound ;
c8p1.c4 = (countT)&postxNotFound ;
c8p1.c2 = (countT)&b_pbdVarying ;
c8p1.c1 = (countT)&pbdVarying ;
count8S c8p2 ;
count8S c8p1 ;

switchStackC sws_session( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idhLever , flSTACKc_null , ifcSTACKtYPE_PTR_byteT ) ;
batonC b_idhLever( tinP , TAG( TAGiDnULL ) ) ;
nicNameC idhLever ;

}
    etThread.delF( tinP , pbExe ) ;
    etThread.memCopyF( tinP , postxHelpExe + cb0 , pbExe , cbExe ) ;
    etThread.memCopyF( tinP , postxHelpExe       , pb0   , cb0   ) ;
    etThread.newF( tinP , LF , postxHelpExe , cb0 + cbExe ) ; ___( postxHelpExe ) ;

    countT cb0 = t0.csF( tinP ) ;
    byteT* pb0 = t0 ;
    textC t0 = T("HTTP/1.1 200 OK\r\nCache-Control: no-cache\r\nPragma: no-cache\r\nContent-Type: application/octet-stream\r\nContent-Length: ")+TF4(cbExe,flFORMAT_FILLzE|flFORMAT_NObASE|flFORMAT_FOREIGN,8,0xa)+T("\r\n\r\n") ;

    etThread.boxGetShadowF( tinP , pbExe , cbExe , T("///d/ifcwhelp.exe") ) ; ___( pbExe ) ;
    ZE( countT , cbExe ) ;
    ZE( byteT* , pbExe ) ;
{
ZE( countT   , costxHelpExe ) ;
ZE( osTextT* , postxHelpExe ) ;

}
    costxLoggedOut = etThread.strMakeF( tinP , postxLoggedOut , t0+tnf ) ; ___( postxLoggedOut ) ;
    textC t0 = T("HTTP/1.1 200 OK\r\nCache-Control: no-cache\r\nPragma: no-cache\r\nContent-Type: text/html\r\nContent-Length: ")+TF4(tnf.csF(tinP),flFORMAT_FILLzE|flFORMAT_NObASE|flFORMAT_FOREIGN,8,0xa)+T("\r\n\r\n") ;
    TN( tnf , "You have been logged out.  If you are a visitor, thank you for visiting us in IdeaFarm " "(tm) City.  While we value the opportunity to exchange goods, services, and money with you, that is not why we want you to visit us.  You are welcome because you are an important part of God's creation, and we want you to enjoy true community when with us.   If you are a resident, please act immediately and decisively if you ever find that any aspect of the operation of the city does not proclaim Jesus's rule for our lives: \"Love God.  Love Neighbor.\"" ) ;
{
ZE( countT   , costxLoggedOut ) ;
ZE( osTextT* , postxLoggedOut ) ;

}
    costxLoggedIn = etThread.strMakeF( tinP , postxLoggedIn , t0+tnf ) ; ___( postxLoggedIn ) ;
    textC t0 = T("HTTP/1.1 200 OK\r\nCache-Control: no-cache\r\nPragma: no-cache\r\nContent-Type: text/html\r\nContent-Length: ")+TF4(tnf.csF(tinP),flFORMAT_FILLzE|flFORMAT_NObASE|flFORMAT_FOREIGN,8,0xa)+T("\r\n\r\n") ;
    TN( tnf , "You have been logged in.  Please be sure to log out when you are no longer using, or supervising the use of, this computer.  If you have an account with the IdeaFarm " "(tm) City central bank, logging out is important to prevent someone else from spending your money." ) ;
{
ZE( countT   , costxLoggedIn ) ;
ZE( osTextT* , postxLoggedIn ) ;

}
    costxNotFound = etThread.strMakeF( tinP , postxNotFound , t0+tnf ) ; ___( postxNotFound ) ;
    textC t0 = T("HTTP/1.1 200 OK\r\nCache-Control: no-cache\r\nPragma: no-cache\r\nContent-Type: text/html\r\nContent-Length: ")+TF4(tnf.csF(tinP),flFORMAT_FILLzE|flFORMAT_NObASE|flFORMAT_FOREIGN,8,0xa)+T("\r\n\r\n") ;
    TN( tnf , "The requested page is not currently available, probably because the preceding page that you were viewing just became obsolete.  Please reload the preceding page and then try again." ) ;
{
ZE( countT   , costxNotFound ) ;
ZE( osTextT* , postxNotFound ) ;

ZE( boolT , bHandedOff ) ;
batonC b_pbdVarying( tinP , TAG( TAGiDnULL ) ) ;
ZE( byteT* , pbdVarying ) ;
signC sgnIdPortReplaced( tinP , TAG( TAGiDnULL ) ) ;

//etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;

TELL( "preparing for work" ) ;
TODO

DONEdRIVENsERVER( tmcF )
}
    TELL( "cleaning up" ) ;
    etThread.osSleepF( tinP , TOCK * 8 ) ; // THIS IS USED INSTEAD OF shutdown TO GIVE PACKETS TIME TO REACH THE PEER; IT IS DONE THIS WAY TO AVOID HAVING THE "SHUTDOWN" CONCEPT IN THE IFC API
    TELL( "sleeping so client can close connection wo'th" ) ;

    }
        etThread.delF( tinP , psttPeer ) ;
        etThread.delF( tinP , pcIdName ) ;
        }
            stPhrases << postOldC( tinP , etThread , T(" notFound") ) ;
            if( bHttpWoZe ) postxNotFound[ 7 ] = '1' ;
            pso->writeF( tinP , postxNotFound , costxNotFound ) ;
            if( bHttpWoZe ) postxNotFound[ 7 ] = '0' ;
            *tinP.zEtScratch = 0 ;
        {
        else
        }
            thirdC::logIF( tinP , ostoFile , nicNamePeer , 4 , count5S( 1 , 2 , 3 , 4 ) , (countT)&stPhrases , 1 ) ;
            OStEXTAK( ostoFile , ".log.port.05" ) ;
            OStEXTC( ostoFile , etherC::ifc_idHomeI_IF() , 0 ) ;
            OStEXTAK( ostoFile , "\\ideafarm." ) ;
            OStEXT( ostoFile , 0x100 )
            }
                }
                    lake.readCloseF( tinP , handle ) ;
                    if( bHttpWoZe ) postx[ 7 ] = '1' ;
                    pso->writeF( tinP , postx , costx ) ;
                    if( bHttpWoZe ) postx[ 7 ] = '0' ;
                {
                else
                }
                    stPhrases << postOldC( tinP , etThread , T(" notFound") ) ;
                    if( bHttpWoZe ) postxNotFound[ 7 ] = '1' ;
                    pso->writeF( tinP , postxNotFound , costxNotFound ) ;
                    if( bHttpWoZe ) postxNotFound[ 7 ] = '0' ;
                {
                if( !postx )
                TELL( "writing the requested fish image" ) ;
        
                //}
                //    lake.readF( tinP , postx , costx , handle , count3S( 1 , 1 ) , cSkip ) ; //SERVE HOME PAGE IF THE SPECIFIED PAGE IS NOT FOUND
                //    cSkip = 0 ;
                //{
                //if( !postx )
        
                if( *pcIdName ) lake.readF( tinP , postx , costx , handle , pcIdName , cSkip ) ;
                ZE( countT , cSkip ) ;
                handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FISH ) ;
                ZE( countT , costx ) ;
                ZE( osTextT* , postx ) ;
                TELL( "retrieving the requested fish from the lake" ) ;
            {
            else
            }
                stPhrases << postOldC( tinP , etThread , T(" logOutNotification") ) ;
                if( bHttpWoZe ) postxLoggedOut[ 7 ] = '1' ;
                pso->writeF( tinP , postxLoggedOut , costxLoggedOut ) ;
                if( bHttpWoZe ) postxLoggedOut[ 7 ] = '0' ;
        
                b_idhLever.ungrabF( tinP ) ;
                }
                    etThread.osTimeNowF( tinP , ps->timeLogout1 , ps->timeLogout2 ) ;
                    ps->flags |= fliSESSION_ENDED ;
                {
                if( ps )
                sessionS* ps = sws_session ? (sessionS*)sws_session[ 1 ] : 0 ;
                idhLever = nicNamePeer ;
                b_idhLever.grabF( tinP , TAG( TAGiDnULL ) ) ;
                TELL( "writing logout confirmation reply" ) ;
            {
            else if( idRequestType == ifcIDrEQtYPE_LOGOUT )
            }
                stPhrases << postOldC( tinP , etThread , T(" logInNotification") ) ;
                if( bHttpWoZe ) postxLoggedIn[ 7 ] = '1' ;
                pso->writeF( tinP , postxLoggedIn , costxLoggedIn ) ;
                if( bHttpWoZe ) postxLoggedIn[ 7 ] = '0' ;
                TELL( "writing login confirmation reply" ) ;
            {
            if( bLogin )

            }
                }
                    }
                        }
                            }
                                //U:etThread.boxPutF( tinP , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+T(psttv)+T("//" ifcEMAIL_OLDfROM "") , tNote ) ;
                                //TELL( "sending login confirmation email" ) ;
                                ;
        
                                    postEMAILsECTIONhEAD_c_END)
                                    postEMAILsECTIONbODY_b_MAILcLIENTsETTINGS
                                    postEMAILsECTIONhEAD_b_MAILcLIENTsETTINGS
                                    postEMAILsECTIONhEAD_a_CONSTANTrEFERENCE
                                    postEMAILsECTIONhEAD_9_VARIABLErEFERENCE
                                    postEMAILsECTIONbODY_8_CONSTANTcONTACTS
                                    postEMAILsECTIONhEAD_8_CONSTANTcONTACTS
                                    postEMAILsECTIONhEAD_7_VARIABLEcONTACTS
                                    "!nicNameC:")+T(idhLever)+T("\r\n"
                                    "!passCode:")+T(cPassCode)+T("\r\n"
                                    postEMAILsECTIONhEAD_6_DATAdOnOTmODIFY)+T(
                                    postEMAILsECTIONhEAD_5_DATApLEASEeDIT
                                    postEMAILsECTIONbODY_4_EXPLANATION
                                    postEMAILsECTIONhEAD_4_EXPLANATION
                                    postEMAILsECTIONbODY_3_INSTRUCTIONS
                                    postEMAILsECTIONhEAD_3_INSTRUCTIONS
                                    postEMAILsECTIONhEAD_2_MESSAGE
                                    "or submit forms at http://www.ideafarm.com, you are communicating with me.  You can send email to me at mailto:")+tMyEmail+T(".\r\n"
                                    "I am ")+TF2(DDNUMB,flFORMAT_CITIZENnAME)+T(", a sentient robot and full citizen of IdeaFarm " "(tm) City.  When you request web pages\r\n"
                                    postEMAILsECTIONhEAD_1_INTRODUCTION
        
                                    T("Subject: !IFC login confirmation"
        
                                TN( tNote , "" ) ; tNote =
                                TN( tMyEmail , "" ) ; tMyEmail = TF2(DDNUMB,flFORMAT_CITIZENeMAIL) ;
        
                                countT cPassCode = ru ;
                                ranUniC ru( 0xffffffff ) ;
        
                                bLogin = 1 ;
                                stPhrases << postOldC( tinP , etThread , T(" login:\"")+T(psttv)+T("\"") ) ;
                                b_idhLever.ungrabF( tinP ) ;
                                }
                                    sws_session << (byteT*)ps ;
                                    etThread.osTimeNowF( tinP , ps->timeLogin1 , ps->timeLogin2 ) ;
                                    etThread.strMakeF( tinP , ps->psttEmail , psttv ) ; ___( ps->psttEmail ) ;
                                {
                                if( ps )
                                sessionS* ps = new_sessionS_F( tinP ) ;
                                idhLever = nicNamePeer ;
                                b_idhLever.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                TELL( "composing a login confirmation email" ) ;
                            {
                            if( psttv && psttv->idAdam )
                            etThread.strTrimF( tinP , psttv , 0 , T(TbLACKnEWlINE) ) ;
                        {
                        if( psttv && psttv->idAdam )
                        strokeS*& psttv = tblKeyValue._CT1_07F( idr , 2 ) ;
                    {
                    if( !etThread.strCompareF( tinP , tEmail , tblKeyValue._CT1_07F( idr , 1 ) ) )
                {
                for( countT idr = 1 ; idr <= cRows ; idr ++ )
                countT cRows = tblKeyValue.cRowsF( tinP ) ;
                TN( tEmail , "email" ) ;
        
                !tblKeyValue ;
            {
            if( !*tinP.zEtScratch && tblKeyValue.cRowsF( tinP ) )
            ZE( boolT , bLogin ) ;
            stPhrases << postOldC( tinP , etThread , T("name: ")+T(pcIdName)+T("\r\n") ) ;
            stPhrases << postOldC( tinP , etThread , T("peer: ")+T(nicNamePeer)+T("\r\n") ) ;
            stPhrases << postOldC( tinP , etThread , T("peer: \"")+T(psttPeer)+T("\"\r\n") ) ;
        {
        else if( !*tinP.zEtScratch )
        if( etThread ) ;
        TELL( "preparing to compose a reply" ) ;
        countT idRequestType = readRequestF( tinP , etThread , *tinP.zEtScratch , *pso , bMore , bHttpWoZe , pcIdName , tblKeyValue , std_pstt , psttPeer , nicNamePeer , dict ) ;
        TELL( "reading a request" ) ;
        ZE( boolT , bHttpWoZe ) ;
        stackC std_pstt( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
        ZE( strokeS* , psttPeer ) ;
    
        tblKeyValue.newColF( tinP , T("value") ) ;
        tblKeyValue.newColF( tinP , T("key") ) ;
        tableC tblKeyValue( tinP , etThread , T("keyValue") ) ;
    
        b_pbdVarying.ungrabF( tinP ) ;
        }
            TN( t_cHamburgers , "" ) ; t_cHamburgers = TF3(++state.cHamburgers,0,8) ;
            TN( t_idMe        , "" ) ; t_idMe        = TF3(state.idMe,0,8) ;
            stateS& state = *(stateS*)pbdVarying ;
        {
        if( pbdVarying )
        b_pbdVarying.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        etThread.newF( tinP , LF , pcIdName , CCiDnAMEmAX + 1 ) ; ___( pcIdName ) ;
        ZE( countT* , pcIdName ) ;
    
        nicNameC nicNamePeer ;
        stackC stPhrases( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_byteT ) ;
        TELL( "preparing to read a request" ) ;
    {
    while( !etThread && !*tinP.zEtScratch && bMore )
    boolT bMore = 1 ;

    PARAMS( cArg )
{
if( cArg )
TELL( "preparing for work" ) ;
TASKdRIVENsERVER( tmcF )

}
    return idRequestType ;

    etThread.delF( tinP , psttName ) ;
    etThread.delF( tinP , psttAction ) ;
    }
        }
            tinP.zEtScratch->delF( tinP , psttNameTrimmed ) ;

            if( offi < CCiDnAMEmAX ) pcIdNameP[ offi ++ ] = 0 ;
            }
                tinP.zEtScratch->delF( tinP , psttw ) ;
                else __1
                }
                    }
                        __( !pcIdNameP[ offi ++ ] ) ;
                        tinP.zEtScratch->delF( tinP , psttw2 ) ;
                        pcIdNameP[ offi ] = dictP( psttw2 ) ;
                        tinP.zEtScratch->strSubstringF( tinP , psttw2 , idf2 , idl2 , psttw ) ; ___( psttw2 ) ;
                        ZE( strokeS* , psttw2 ) ;
                        ZE( countT , idl2 ) ;
                        countT idf2 = 2 ;
                    {
                    else
                    if( 1 != tinP.zEtScratch->strIdF( tinP , sttDollar , psttw ) ) pcIdNameP[ offi ++ ] = tinP.zEtScratch->strDigitsToSCountF( tinP , psttw ) ;
                {
                if( offi < CCiDnAMEmAX - 1 )
                tinP.zEtScratch->strSubstringF( tinP , psttw , idf , sttq , sttDot , psttNameTrimmed ) ; ___( psttw ) ;            // "$foo"
                ZE( strokeS* , psttw ) ;
            {
            while( !*tinP.zEtScratch && idf )
            strokeS sttDollar( '$' ) ;
            strokeS sttDot( '.' ) ;
            idf = 1 ;
            ZE( countT , offi ) ;

            tinP.zEtScratch->strSubstringF( tinP , psttNameTrimmed , idf , idl , psttName ) ; ___( psttNameTrimmed ) ;      // "1.2.$foo.4"
            ZE( strokeS* , psttNameTrimmed ) ;
            countT idl = idDot0 ? idDot0 - 1 : 0 ;
            idf = 2 ;

            __( psttName->idAdam - 1 - idDot0 ) ;
            countT idDot0 = tinP.zEtScratch->strIdF( tinP , countTC( 1 ) , sttq , tDot0 , psttName , 0 , - 1 ) ;
            TN( tDot0 , ".0" ) ;
            idf = 1 ;
        {
        else
        }
            pcIdNameP[ 2 ] = 0 ;
            pcIdNameP[ 1 ] = 1 ;
            pcIdNameP[ 0 ] = 1 ;
        {
        else if( psttName->idAdam == 1 )
        if( idRequestType != ifcIDrEQtYPE_FISH ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;
        __( tinP.zEtScratch->strIdF( tinP , sttSlash , psttName ) - 1 ) ;                                                  // "/1.2.$foo.4.0"
        __( !psttName->idAdam ) ;
    {
    if( !*tinP.zEtScratch && !etThread )
    __Z( psttName ) ; // WILL BE NULL IF CLIENT CLOSES WITHOUT TELLING ME TO CLOSE

    etThread.delF( tinP , psttKV ) ;
    }
        tinP.zEtScratch->delF( tinP , pstt1e ) ;
        }
            }
                tblKeyValueP.newObjectF( tinP , psttv ) ;
                tblKeyValueP.newObjectF( tinP , psttk ) ;
                tblKeyValueP.newEventF( tinP ) ;

                std_psttP << psttv ;
                std_psttP << psttk ;
            {
            else
            if( *tinP.zEtScratch ) *tinP.zEtScratch = 0 ;

            tinP.zEtScratch->strFromUrlF( tinP , psttv ) ; ___( psttv ) ;
            tinP.zEtScratch->strFromUrlF( tinP , psttk ) ; ___( psttk ) ;

            tinP.zEtScratch->strSubstringF( tinP , psttv , idf , sttq , sttEq , psttc1 ) ; ___( psttv ) ;
            tinP.zEtScratch->strSubstringF( tinP , psttk , idf , sttq , sttEq , psttc1 ) ; ___( psttk ) ;
            ZE( strokeS* , psttv ) ;
            ZE( strokeS* , psttk ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        FORsTRINGSiN1( pstt1e )
        strokeS sttEq( '=' ) ;
        tinP.zEtScratch->strWordsOldF( tinP , pstt1e , psttKV , sttq , T("&") ) ; ___( pstt1e ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , pstt1e ) ;
    {
    if( !*tinP.zEtScratch && psttKV ) // STORE THE KEY/VALUE PAIRS

    }
        etThread.strMakeF( tinP , psttKV , ( psttw ? T(psttw)+T("&") : T("") )+tBody ) ; ___( psttKV ) ; //ASSUME: psttKV IS OF FORM T("aaaa=1111&bbbb=2222&cccc=3333&dddd=4444")
        psttKV = 0 ;
        strokeS* psttw = psttKV ;
        TN( tBody , "" ) ; tBody = T(postBody) ;

        if( postBody ) postBody[ costBody ] = 0 ;
        sInP.readF( tinP , postBody , costBody ) ;
        etThread.newF( tinP , LF , postBody , costBody + 1 ) ;
        ZE( osTextT* , postBody ) ;
    {
    if( !*tinP.zEtScratch && costBody ) // HTTP/1.1 KEYvALUE PAIRS

    }
        tinP.zEtScratch->delF( tinP , psttw ) ;
        tinP.zEtScratch->strWordF( tinP , psttKV   , psttw , sttq , sttQuest , 2 ) ; ___( psttKV   ) ;
        tinP.zEtScratch->strWordF( tinP , psttName , psttw , sttq , sttQuest , 1 ) ; ___( psttName ) ;
        psttName = 0 ;
        strokeS* psttw = psttName ;
    {
    if( tinP.zEtScratch->strIdF( tinP , T("?") , psttName ) ) // HTTP/1.0 KEYvALUE PAIRS
    ZE( strokeS* , psttKV ) ;

    }
        tinP.zEtScratch->delF( tinP , psttl ) ;
        }
            break ;
            tinP.zEtScratch->delF( tinP , psttl ) ;
        {
        else
        }
            tinP.zEtScratch->delF( tinP , psttValue ) ;
            tinP.zEtScratch->delF( tinP , psttKey ) ;
            }
                if( tinP.zEtScratch->strIdF( tinP , tClose , psttValue ) ) bMoreP = 0 ;
            {
            else if( !tinP.zEtScratch->strCompareF( tinP , tConnection    , psttKey ) )
                 if( !tinP.zEtScratch->strCompareF( tinP , tContentLength , psttKey ) ) costBody = tinP.zEtScratch->strDigitsToSCountF( tinP , psttValue , 0xa , 1 ) ;
            tinP.zEtScratch->strSubstringF( tinP , psttValue , idf , idl , psttl ) ; ___( psttValue ) ;
            ZE( countT , idl ) ;
            tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttKey ) ; ___( psttKey ) ;
            tinP.zEtScratch->strSubstringF( tinP , psttKey , idf , sttq , tColonWhite , psttl , 1 ) ; ___( psttKey ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttValue ) ;
            ZE( strokeS* , psttKey ) ;
        {
        else if( psttl && psttl->idAdam ) // HEADER LINE ASSUMED TO BE OF THE FORM, FOR EXAMPLE,  "Content-Length:1234"
        }
            if( tinP.zEtScratch->strIdF( tinP , idf , sttq , T("logout") , psttName ) ) idRequestType = ifcIDrEQtYPE_LOGOUT ;
            countT idf = 1 ;
            tinP.zEtScratch->delF( tinP , psttw ) ;
            bHttpWoZeP = !tinP.zEtScratch->strIdF( tinP , tHttp11 , psttw ) ;
            bMoreP = !!tinP.zEtScratch->strIdF( tinP , tHttp11 , psttw ) ;
            tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttw ) ; ___( psttw ) ;
            tinP.zEtScratch->strWordF( tinP , psttw , psttl , sttq , sttb , 3 ) ; ___( psttw ) ;
            ZE( strokeS* , psttw ) ;
            tinP.zEtScratch->strWordF( tinP , psttName , psttl , sttq , sttb , 2 ) ; ___( psttName ) ;
            tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttAction ) ; ___( psttAction ) ;
            tinP.zEtScratch->strWordF( tinP , psttAction , psttl , sttq , sttb , 1 ) ; ___( psttAction ) ;
        {
        if( !psttAction ) // IF WO'TH LINE

        if( *tinP.zEtScratch ) break ;
        sInP.readWoLineF( tinP , psttl , 0x200 ) ; ___( psttl ) ;
        ZE( strokeS* , psttl ) ;
    {
    while( !*tinP.zEtScratch && !etThread )
    ZE( countT , costBody ) ;
    ZE( strokeS* , psttName ) ;
    ZE( strokeS* , psttAction ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    strokeS sttSlash( '/' ) ;
    strokeS sttQuest( '?' ) ;
    strokeS sttb( ' ' ) ;
    TN( tHttp11 , "http/1.1" ) ;
    TN( tLog   , "///d/log." ) ; tLog += T(DDNUMB) ;
    TN( tClose , "close" ) ;
    TN( tConnection , "connection" ) ;
    TN( tContentLength , "content-length" ) ;
    TN( tColonWhite , ": " ) ;

    etThread.sockPsttHostF( tinP , psttPeerP , nicNamePeerP ) ; ___( psttPeerP ) ;
    { ZE( countT , idp ) ; sInP.peerNameF( tinP , idp , nicNamePeerP ) ; }

    countT idRequestType = ifcIDrEQtYPE_FISH ;
    __( bHttpWoZeP ) ;
    __( bMoreP - 1 ) ;
{
countT readRequestF( tinS& tinP , etherC& etThread , socketC& sInP , boolT& bMoreP , boolT& bHttpWoZeP , countT* pcIdNameP , tableC& tblKeyValueP , stackC& std_psttP , strokeS*& psttPeerP , nicNameC& nicNamePeerP , dictionary1C& dictP )
*/
 terminate pcIdNameP with a 0
  if     begin with '$': look up the word in the dictionary; if not found, use -1
  if not begin with '$': else        : - 1
  if not begin with '$': if <= 8 char: convert the word to a countT 
 convert each '.' delimited word to a countT value and place that value in pcIdNameP[]
 obtain the request that is either "/ " or "/aaaaaaaa.bbbbbbbb.cccccccc.<...>.zzzzzzzz.0 "
 read at least the wo'th line of the request
 captures domain name of peer
pseudocode
i evaluate to idRequestType
/*

#define ifcIDrEQtYPE_LOGOUT                   2
#define ifcIDrEQtYPE_FISH                     1

//==============================================================================================================================================================
//==== ABOVE THIS LINE: DAYTIME WORK ===========================================================================================================================
//==============================================================================================================================================================


//==============================================================================================================================================================
//==== BELOW THIS LINE: MOONLIGHT WORK =========================================================================================================================
//==============================================================================================================================================================

}
    if( ether && *tinP.zEtScratch && cArgP && c8argP.c1 && sNotesTextP && sNotesDataP && idChatSessionP ) ;

    }
        }
            break ;
            else __1
            }
                b_idhLever.ungrabF( tinP ) ;
                }
                    }
                        else                                                                        sDataP << ps->psttEmail ;
                        if( ps->flags & fliSESSION_ENDED || !( ps->flags & fliSESSION_CONFIRMED ) ) sDataP << (strokeS*)0 ;
                    {
                    if( ps )
                    sessionS* ps = (sessionS*)sws_session[ 1 ] ;
                {
                else
                if( !sws_session ) sDataP << (strokeS*)0 ;
                idhLever = nicNameAt ;
                b_idhLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

                sOrderP >> nicNameAt ;
                nicNameC nicNameAt ;
            {
            if( !etThread.strCompareF( tinP , psttOldCmd , T("!emailFromNicName") ) )
        {
        case 1 :
    {
    switch( idCourseP )

    sOrderP >> psttOldCmd ; ___( psttOldCmd ) ;
    ZE( strokeS* , psttOldCmd ) ;

    __( idAdamP - DDNUMB ) ;
    PARAMS( cArgP )
{
voidT jobFillCourseF( tinS& tinP , etherC& ether , etherC& etThread , soulC& sDataP , soulC& sNotesTextP , soulC& sNotesDataP , const countT idCourseP , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

//==============================================================================================================================================================
//==== ABOVE THIS LINE: MOONLIGHT WORK =========================================================================================================================
//==============================================================================================================================================================


//==============================================================================================================================================================
//==== BELOW THIS LINE: PROCESS STATE CODE =====================================================================================================================
//==============================================================================================================================================================

TRANSLATEsTATEdRIVENsERVER_END
    state.idMe ++ ;
TRANSLATEsTATEdRIVENsERVER_MIDDLE
    case 1 : { state.idMe        = stateOther.idMe        ; }
    case 2 : { state.cHamburgers = stateOther.cHamburgers ; }
TRANSLATEsTATEdRIVENsERVER_BEGIN( stateS , 2 )

;
}
    countT cHamburgers ;
    countT idMe ;
    countT idVersion ;
{
struct stateS

//==============================================================================================================================================================
//==== ABOVE THIS LINE: PROCESS STATE CODE =====================================================================================================================
//==============================================================================================================================================================

}
    }
        if( POOP ) POOPR
        if( psP ) tinP.pEtScratch->delF( tinP , psP->psttEmail ) ;
        SCOOPS
    {
    IFsCRATCH
{
voidT del_sessionS_ptrs_F( tinS& tinP , sessionS* psP )

}
    return (sessionS*)pbs ;
    }
        if( POOP ) POOPR
        tinP.pEtScratch->memSetF( tinP , pbs , sizeof( sessionS ) ) ;
        tinP.pEtScratch->newF(    tinP , pbs , sizeof( sessionS ) ) ; ___( pbs ) ;
        SCOOPS
    {
    IFsCRATCH
    ZE( byteT* , pbs ) ;
{
sessionS* new_sessionS_F( tinS& tinP )

;
}
    sCountT  timeLogout2 ;
    countT   timeLogout1 ;      // TIME EXPLICIT LOGOUT, IF ANY, OCCURS
    sCountT  timeConfirmed2 ;
    countT   timeConfirmed1 ;   // TIME PASSCODE IS RECEIVED VIA EMAIL
    sCountT  timeLogin2 ;
    countT   timeLogin1 ;            // TIME OF LOGIN (AND TIME WHEN PASSCODE IS EMAILED TO THE EMAIL ADDRESS GIVEN IN THE LOGIN FORM
    countT   passcode ;              // CAN BE USED ONLY WO TIME.  SET UPON LOGIN.  RESET UPON CONFIRMATION
    strokeS* psttEmail ;
    flagsT   flags ;
{
struct sessionS
*/
session management is integrated with the port.05 server because sessions are begun and ended using a port.05 client
all state information for each host session is kept in wo sessionS object
each logged in interval is called a host session
each host is either logged in or logged out
/*

    countT&       costxHelpExe   =       *(countT*)c8p2.c7 ;
    osTextT*&     postxHelpExe   =     *(osTextT**)c8p2.c6 ;                                                                \
    countT&       costxLoggedOut =       *(countT*)c8p2.c5 ;                                                                \
    osTextT*&     postxLoggedOut =     *(osTextT**)c8p2.c4 ;                                                                \
    countT&       costxLoggedIn  =       *(countT*)c8p2.c3 ;                                                                \
    osTextT*&     postxLoggedIn  =     *(osTextT**)c8p2.c2 ;                                                                \
    switchStackC& sws_session    = *(switchStackC*)c8p2.c1 ;                                                                \
    batonC&       b_idhLever     =       *(batonC*)c8p1.c8 ;                                                                \
    nicNameC&     idhLever       =     *(nicNameC*)c8p1.c7 ;                                                                \
    lakeC&        lake           =        *(lakeC*)c8p1.c6 ;                                                                \
    countT&       costxNotFound  =       *(countT*)c8p1.c5 ;                                                                \
    osTextT*&     postxNotFound  =     *(osTextT**)c8p1.c4 ;                                                                \
    dictionary1C&  dict           =  *(dictionary1C*)c8p1.c3 ;                                                                \
    batonC&       b_pbdVarying   =       *(batonC*)c8p1.c2 ;                                                                \
    byteT*&       pbdVarying     =       *(byteT**)c8p1.c1 ;                                                                \
                                                                                                                            \
    count8S&      c8p2           =      *(count8S*)c2p.c2 ;                                                                 \
    count8S&      c8p1           =      *(count8S*)c2p.c1 ;                                                                 \
    count2S&      c2p            =      *(count2S*)cArgP ;                                                                  \
                                                                                                                            \
#define PARAMS(cArgP)                                                                                                       \

#define fliSESSION_ENDED      0x00000002
#define fliSESSION_CONFIRMED  0x00000001

#define CCiDnAMEmAX 0x10
#define COSTiN 0x1000
#define CsLOTpSO 0x4

    "note immediately to the \"abuse\" or \"fraud\" address listed below.\r\n"
    "If you suspect that someone else is entering your email address in order to harass you or to defraud you, please forward this\r\n"      \
    "\r\n"                                                                                                                                   \
    "web page.  If you did not do this, or if you would like to cancel your login, do -not- reply to this note.\r\n"                         \
    "You received this note because your email address was entered, presumably by you, at the top of the http://www.ideafarm.com\r\n"        \
    "\r\n"                                                                                                                                   \
    "you will be allowed to pass through the gate, into the city.\r\n"                                                                       \
    "Please click the \"Reply\" button to complete your login at the gate of IdeaFarm " "(tm) City.  As soon as your reply is received,\r\n"    \
                                                                                                                                             \
#define postEMAILsECTIONbODY_4_EXPLANATION                                                                                                   \

    "(b) To complete your log in, click \"Reply\".\r\n"
    "\r\n"                                                                                                                                   \
    "(a) If you did not expect to receive this, DO NOT REPLY.\r\n"                                                                           \
    "\r\n"                                                                                                                                   \
    "Do either (a) -or- (b): \r\n"                                                                                                           \
                                                                                                                                             \
#define postEMAILsECTIONbODY_3_INSTRUCTIONS                                                                                                  \

/*1*/WAKEhIDE( "doodle.port.05" )/*1*/
/**/
*/
\<A HREF=\"5.a840104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

