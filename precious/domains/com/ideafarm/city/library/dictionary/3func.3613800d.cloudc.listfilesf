
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cGot ;

    }
        }
            break ;
            etRock.traceF( tinP , T("marker: \"")+tMarkerP+T("\"") ) ;
            tMarkerP = T(postShort) ;

            ether.delF( tinP , postBody ) ;
            }
                }
                    }
                        }
                            }
                                }
                                    }
                                        }
                                            }
                                                ((keyValuePairsC*)pb_kvFileMetaByNameRemote)->newF( tinP , LF , postReversedBits , 0 , costo * SB , (byteT*)&meta , sizeof meta ) ;
                                                cGot ++ ;

                                                countT costo = posto - postReversedBits ;
                                                *posto = 0 ;
                                                while( *posti ) *( posto ++ ) = reverseBitsF( *( posti ++ ) ) ; // SO TREE WILL SORT EACH BYTE BY MSB (BIG-ENDIAN), PRODUCING THE NORMAL COLLATING SEQUENCE
                                                byteT* posto = postReversedBits ;
                                                byteT* posti = postShort ;
                                                osTextT postReversedBits[ sizeof postShort ] ; // TOCK TO AVOID LIMITING FILE NAME LENGTH ; THIS COULD BE ALLOCATED FROM THE POOL TO LENGTH OF postHead STRING

                                                etRock.traceF( tinP , T("remoteFile: ")+T(postShort) , flTRACE_null , ifcIDtRACEdIVERT_8 ) ; //U:: SUPPRESS THIS UNLESS FLAG IS SET BY THE CONSTRUCTOR CALLER
                                            {
                                            else
                                            if( POOP ) etRock.traceF( tinP , T("listFilesF / impotent, so not adding to kvFileMetaByNameRemote") ) ;
                                            //THIS IS THE POINT OF NO RETURN SINCE I AM ABOUT TO MODIFY btP ; IF POOP OCCURS, THERE'S NO WAY FOR ME TO CLEAN UP

                                            }
                                                }
                                                    }
                                                        }
                                                            }
                                                                }
                                                                    postc += 8 ;
                                                                    meta.pcHashMd5[ offo ] = thirdC::c_atoiForeignIF( postr , 0 ) ;
                                                                    osTextT postr[] = { postc[ 6 ] , postc[ 7 ] , postc[ 4 ] , postc[ 5 ] , postc[ 2 ] , postc[ 3 ] , postc[ 0 ] , postc[ 1 ] , 0 } ;
                                                                {
                                                                for( countT offo = 0 ; offo < 4 ; offo ++ )

                                                                // b780cb58f1e55912cac006cb7594edac
                                                            {
                                                            else
                                                            if( POOP ) etRock.traceF( tinP , T("listFilesF / length of hash is not 02") ) ;

                                                            __( thirdC::c_strlenIF( tinP , postc ) - 0x20 ) ;
                                                            *poste = 0 ;
                                                        {
                                                        else
                                                        if( POOP ) etRock.traceF( tinP , T("listFilesF / could not find trailing double quote for hash") ) ;

                                                        __Z( poste ) ;
                                                        osTextT* poste = thirdC::c_strstrIF( tinP , postc , "\"" ) ;
                                                        postc ++ ;
                                                    {
                                                    else
                                                    if( POOP ) etRock.traceF( tinP , T("listFilesF / woth nonblank in hash is not double quote") ) ;

                                                    __NZ( *postc != '"' ) ;
                                                    while( *postc == ' ' ) postc ++ ;
                                                    postc += sizeof postKey - 1 ;
                                                {
                                                else
                                                if( POOP ) etRock.traceF( tinP , T("listFilesF / could not find \"hash\" key") ) ;

                                                __Z( postc ) ;
                                                osTextT* postc = thirdC::c_strstrIF( tinP , postSet , postKey ) ;
                                                osTextT postKey[] = "\"hash\":" ;
                                            {
                                        {
                                        if( !bIgnoreSize )

                                        }
                                            bIgnoreSize = 1 ;
                                            )
                                                ( cbMaxP && meta.cbUsed > cbMaxP )
                                                ||
                                                ( cbMinP && meta.cbUsed < cbMinP )
                                            (
                                            if
                                        {
                                        ZE( boolT , bIgnoreSize ) ;

                                        }
                                            }
                                                meta.cbUsed = thirdC::c_atoiForeignDecimalIF( postc , 0 ) ;

                                                *poste = 0 ;
                                                while( *poste >= '0' && *poste <= '9' ) poste ++ ;
                                                osTextT* poste = postc ;

                                                while( *postc == ' ' ) postc ++ ;
                                                postc += sizeof postKey - 1 ;
                                            {
                                            else
                                            if( POOP ) etRock.traceF( tinP , T("listFilesF / could not find \"bytes\" key") ) ;

                                            __Z( postc ) ;
                                            osTextT* postc = thirdC::c_strstrIF( tinP , postSet , postKey ) ;
                                            osTextT postKey[] = "\"bytes\":" ;
                                        {
                                        metaS meta( tinP ) ;
                                    {
                                    if( !bIgnoreName )

                                    }
                                        if( bIgnoreName ) cGot ++ ;
                                        bIgnoreName = !ether.strFileMatchF( tinP , psttLikeP , T(postShort) ) ;
                                    {
                                    if( !bIgnoreName && psttLikeP && psttLikeP->idAdam )

                                    }
                                        }
                                            }
                                                }
                                                    thirdC::c_strncpyIF( tinP , postShort , postc , sizeof postShort ) ;
                                                    *poste = 0 ;
                                                {
                                                else if( !bIgnoreName )
                                                if( POOP ) etRock.traceF( tinP , T("listFilesF / could not find trailing double quote for name") ) ;

                                                __Z( poste ) ;
                                                osTextT* poste = thirdC::c_strstrIF( tinP , postc , "\"" ) ;
                                                postc ++ ;
                                            {
                                            else
                                            if( POOP ) etRock.traceF( tinP , T("listFilesF / woth nonblank in name is not double quote") ) ;

                                            __NZ( *postc != '"' ) ;
                                            while( *postc == ' ' ) postc ++ ;
                                            postc += sizeof postKey - 1 ;
                                        {
                                        else
                                        if( POOP ) etRock.traceF( tinP , T("listFilesF / could not find \"name\" key") ) ;

                                        bIgnoreName = !!thirdC::c_strstrIF( tinP , postSet , postKeyIgnore ) ;

                                        __Z( postc ) ;
                                        osTextT* postc = thirdC::c_strstrIF( tinP , postSet , postKey ) ;
                                    {
                                    ZE( boolT , bIgnoreName ) ;

                                    //    ---------- SET END ----------------
                                    //    "hash": "b780cb58f1e55912cac006cb7594edac", "last_modified": "2014-12-10T05:54:07.596160", "bytes": 6, "name": "1", "content_type": "application/octet-stream"
                                    //    ---------- SET BEGIN ----------------

                                    //LOGrAW( "\r\n---------- SET END ----------------\r\n" ) ;
                                    //LOGrAW( postSet ) ;
                                    //LOGrAW( "\r\n---------- SET BEGIN ----------------\r\n" ) ;

                                    postc = poste + 1 ;
                                    *poste = 0 ;
                                {
                                else
                                if( POOP ) etRock.traceF( tinP , T("listFilesF / could not find close curly bracket") ) ;

                                __Z( poste ) ;
                                osTextT* poste = thirdC::c_strstrIF( tinP , postSet , "}" ) ;

                                postSet ++ ;

                                if( !postSet ) break ;
                                osTextT* postSet = thirdC::c_strstrIF( tinP , postc , "{" ) ;
                            {
                            while( !POOP && postc && *postc )
                            osTextT postKeyIgnore[] = "\"content_type\": \"application/directory\"" ;
                            osTextT postKey[] = "\"name\":" ;

                            osTextT* postc = postSets ;

                            *poste = 0 ;

                            }
                                }
                                    etRock.traceF( tinP , T("listFilesF / if this is in a file name, please rename the file to eliminate square (and curly) brackets") ) ;
                                    etRock.traceF( tinP , T("dump: ")+T(postDump) ) ;
                                    if( postDump < postSets ) postDump = postSets ;
                                    osTextT* postDump = postv - 0x20 ;
                                    etRock.traceF( tinP , T("listFilesF / unexpected close square bracket encountered in:") ) ;
                                {
                                if( poste - postv )
                                osTextT* postv = thirdC::c_strstrIF( tinP , postSets , "]" ) ;
                            {
                        {
                        else
                        if( POOP ) etRock.traceF( tinP , T("listFilesF / lath character in body is not close square bracket") ) ;

                        __( *poste - ']' ) ;

                        osTextT* poste = postBody + costBody - 1 ;
                        postSets ++ ;
                    {
                    else
                    if( POOP ) etRock.traceF( tinP , T("listFilesF / the woth open square bracket is not exactly at the beginning of the body as expected") ) ;

                    __( postSets - postBody ) ;
                {
                else
                if( POOP ) etRock.traceF( tinP , T("listFilesF / could not find open square bracket") ) ;

                __Z( postSets ) ;
                osTextT* postSets = thirdC::c_strstrIF( tinP , postBody , "[" ) ;

                //    ]
                //        }
                //            "content_type": "application/octet-stream"
                //            ,
                //            "name": "2"
                //            ,
                //            "bytes": 14
                //            ,
                //            "last_modified": "2014-12-10T05:54:08.325520"
                //            ,
                //            "hash": "3918695a4255570e86d32b315f1cef37"
                //        {
                //        ,
                //        }
                //            "content_type": "application/octet-stream"
                //            ,
                //            "name": "1"
                //            ,
                //            "bytes": 6
                //            ,
                //            "last_modified": "2014-12-10T05:54:07.596160"
                //            ,
                //            "hash": "b780cb58f1e55912cac006cb7594edac"
                //        {
                //    [
                //
                // THIS IS WHAT THE RESPONSE LOOKS LIKE (WITH BLACKSPACE ADDED FOR READABILITY)

                //LOGrAW( "\r\n---------------------------------------------------------------------------------------------\r\n" ) ;
                //LOGrAW( postBody ) ; //U:: TO FIND A BUG
                //LOGrAW( "\r\n-------- REPLY HEADER: ----------------------------------------------------------------------\r\n" ) ;

                }
                    continue ;

                    etPrime.osSleepF( tinP , TOCK << 4 ) ;
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                    etRock.traceF( tinP , T("listFilesF 2 / connect, write, or read failed / will retry after napping for 01 tock") ) ;

                    POOPR
                {
                if( POOP )

                }
                    }
                        cDo   -= costBite ;
                        posti += costBite ;
                        __Z( costBite ) ;
                        countT costBite = ss.readF( tinP , posti , cDo ) ;
                    {
                    while( !POOP && cDo )
                    countT cDo = costBody ;
                    osTextT* posti = postBody ;
                {

                postBody[ costBody ] = 0 ;
            {
            else
            if( POOP ) etRock.traceF( tinP , T("listFilesF / could not get pool drop") ) ;
            osTextT postShort[ TUCK ] = "" ;

            __Z( postBody ) ;
            ether.newF( tinP , LF , postBody , costBody + 1 ) ; ___( postBody ) ;
            ZE( osTextT* , postBody ) ;

            }
                }
                    costBody = thirdC::c_atoiForeignDecimalIF( postc , 0 ) ;

                    *poste = 0 ;
                    while( *poste >= '0' && *poste <= '9' ) poste ++ ;
                    poste = postc ;
                    while( *postc == ' ' ) postc ++ ;
                    postc += sizeof postTag - 1 ;
                {
                if( postc )
                postc = thirdC::c_strstrIF( tinP , postHead , postTag ) ;

                osTextT postTag[] = "\r\nContent-Length:" ;

                }
                    continue ;

                    etPrime.osSleepF( tinP , TOCK << 4 ) ;
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                    etRock.traceF( tinP , T("listFilesF 1 / suggestion: verify that this container exists:    ")+T(psttCloudContainerP) ) ;
                    etRock.traceF( tinP , T("listFilesF 1 / unexpected reply code / will retry after napping for 01 tock") ) ;
                    etRock.traceF( tinP , T(postHead) ) ;

                    POOPR
                {
                if( POOP )
                __NZ( thirdC::c_memcmpIF( tinP , postHead , tReplyCode200_OK , tReplyCode200_OK.csF( tinP ) ) ) ;

                if( !thirdC::c_memcmpIF( tinP , postHead , tReplyCode204_NoContent , tReplyCode204_NoContent.csF( tinP ) ) ) break ;

                }
                    break ;
                    etRock.traceF( tinP , T("authorization refused") ) ;
                {
                if( POOP )
                __Z( thirdC::c_memcmpIF( tinP , tReplyCode401_Unauthorized , postHead , tReplyCode401_Unauthorized.csF( tinP ) ) ) ;

                //LOGrAW( "\r\n---------------------------------------------------------------------------------------------\r\n" ) ;
                //LOGrAW( postHead ) ; //U:: TO FIND A BUG
                //LOGrAW( "\r\n-------- REPLY HEADER: ----------------------------------------------------------------------\r\n" ) ;

                }
                    continue ;

                    etPrime.osSleepF( tinP , TOCK << 4 ) ;
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                    etRock.traceF( tinP , T("listFilesF 1 / connect, write, or read failed / will retry after napping for 01 tock") ) ;

                    POOPR
                {
                if( POOP )

                __Z( bGotHead ) ;
                }
                    postc ++ ;

                    }
                        break ;
                        bGotHead = 1 ;
                        postc[ -3 ] = 0 ;
                    {
                    if( postc - postHead >= 3 && postc[ 0 ] == '\n' && postc[ - 1 ] == '\r' && postc[ - 2 ] == '\n' && postc[ - 3 ] == '\r' )
                {
                while( postc < poste && ss.readF( tinP , postc , 1 ) )
                ZE( boolT , bGotHead ) ;

                osTextT* poste = postHead + sizeof postHead - 1 ;
                osTextT* postc = postHead ;

                thirdC::c_memsetIF( tinP , postHead , sizeof postHead ) ;
                osTextT postHead[ TOCK ] ; 
            {
            ZE( countT , costBody ) ;
            //LOAD THE REPLY HEADER

            ss.writeF( tinP , (osTextT*)tSay , (countT)tSay.csF( tinP ) ) ;

            //LOGrAW( "\r\n---------------------------------------------------------------------------------------------\r\n" ) ;
            //LOGrAW( tSay ) ; //U:: TO FIND A BUG
            //LOGrAW( "\r\n---------------------------------------------------------------------------------------------\r\n" ) ;

            etRock.traceF( tinP , T(POOP?"listFilesF / could not connect to \"":"listFilesF / connected to \"")+tHost+T("\"") ) ;
            ss.connectF( tinP , 443 , socketC::nicNameIF( tinP , etScratch , tHost ) ) ;
            etRock.traceF( tinP , T("listFilesF / connecting to \"")+tHost+T("\"") ) ;
            socketC ss( tinP , etScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL ) ;
        {
        while( !etPrime && !ether && !POOP )
        const countT idIn = ++ idInLath ;
        static countT idInLath ;

        etherC& etPrime   = etherC::etPrimeIF( tinP ) ;
        etherC& etScratch = *tinP.pEtScratch ;
        SCOOPS
    {
    IFsCRATCH
    ZE( countT , cGot ) ; // INCLUDES ITEMS FILTERED OUT BY FAILING TO MATCH psttLikeP

    //etRock.traceF( tinP , tSay ) ;
    etherC& etRock = etherC::etRockIF( tinP ) ;

    }
        bHandle.ungrabF( tinP ) ;
        tSay += T(" HTTP/1.1\r\nHost: ")+tHost+T("\r\nX-Auth-Token: ")+cloudInfo.tRackspaceAccessToken+T("\r\n\r\n") ;
        cloudInfoS& cloudInfo = *(cloudInfoS*)hCloud.osF( ifcIDtYPEhANDLE_CLOUD ) ;
        bHandle.grabF( tinP , TAG( TAGiDnULL ) ) ;

        ether.delF( tinP , psttMarkerEncoded ) ;
        if( psttMarkerEncoded ) tSay += T("&marker=")+T(psttMarkerEncoded) ;
        tSay = T("GET ")+tUrlCloudAgent+T("/")+T(psttCloudContainerP)+T("?format=json") ;

        // X-Auth-Token: f064c46a782c444cb4ba4b6434288f7c
        // Host: storage.clouddrive.com
        // GET /v1/MossoCloudFS_0672d7fa-9f85-4a81-a3ab-adb66a880123/test HTTP/1.1
        // EXAMPLE OF QUERY (NO BODY IS SENT)

        if( tMarkerP.csF( tinP ) ) { ether.strToUrlF( tinP , psttMarkerEncoded , tMarkerP ) ; ___( psttMarkerEncoded ) ; }
        ZE( strokeS* , psttMarkerEncoded ) ;
    {
    TN( tSay , "" ) ;

    _IO_

    }
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL

    SCOOP
{
/*1*/countT cloudC::listFilesF( tinS& tinP , const strokeS* const psttCloudContainerP , textC& tMarkerP , const strokeS* const psttLikeP , const countT cbMinP , const countT cbMaxP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

