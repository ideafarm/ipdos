
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmWindowsF )

//CONJ: THIS COMMENT IS WRONG BECAUSE tinP IS NOW tinEarlyLate
//DONE WILL NOT DO THIS BECAUSE tinP AND etThread ARE ALREADY GONE
//WARNING: IF I AM EDITED TO LAUNCH KID THREADS, I MUST EXPLICITLY WAIT HERE FOR THEM ALL TO END

processGlobal1I._thirdC_flagsProcessState |= flPROCESSsTATE_tmWindowsF_HASeNDED | flPROCESSsTATE_MAINtHREADiSaLONE ;

THREADmODE1rESTORE
}
    THREADmODE2rESTORE
    }
    
#endif

        etherC::loafIF( tinP ) ; //U::DOODLING
        sgnReady.giveF( tinP ) ;
        etThread.delF( tinP , psttTitle ) ;

#else

        }
            thirdC::winDestroyWindowClassIF( tinP , MAINwINDOWcLASSnAME ) ;
            tinP.idPhase2 = 3 ;
            //LOGrAW( "tmWindowsF/dispatchola/-\r\n" ) ;
            TINSL
        {
        //TELL( "cleaning up" )

        }
            ether.etherFireImpersonateMonitorIF( tinP ) ;
            thirdC::third_flagsModeAdam1I_IF( tinP ) &= ~( F(flADAMmODE1_tmWindows) ) ;
            }
                thirdC::third_flagsProcessStateI_IF( tinP , flPROCESSsTATE_WM_CLOSE_RECEIVED , 1 ) ; // main WILL PROCEED TO CLEANUP WHEN IT SEES THIS
                POOPIES
            {
        {
        else
        }
            thirdC::winDispatchMessagesIF( tinP ) ; // WM_CLOSE WILL DELETE pEtThread (WHICH DELETES tinP) BEFORE THIS RETURNS
            //LOGrAW( "tmWindowsF/dispatchola/+\r\n" ) ;
            //FROM HERE ON DO NOT REFER TO ANY IFC OBJECTS (EG etThread)
            tinP.idPhase2 = 2 ;
            DEL( pTaskP ) ;
            TELL( "pumping window messages" )
        {
        if( !etThread )
        sgnReady.giveF( tinP ) ;

        else __1 ;        
        }
            pRootI->letRefF() ;
        
            etThread.delF( tinP , psttTitle ) ;
            if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_HIDEwITHiCON ) ) thThread.winShowWindowF( tinP , *pRootI , F(thirdC::third_flagsModeProcess1I_IF(tinP)) & flMODEpROCESS1_LAUNCHmINIMIZED ? idcWINsHOW_MINIMIZE : /*idcWINsHOW_MAXIMIZE*/idcWINsHOW_SHOW ) ;
    
            }
                }
                    ((paperOldC&)paper).purgeF( tinP ) ;
                    const paperOldC& paper = pRootI->selectPaperF( tinP , ifcIDcMDpAPERsELECT_SETrENDER , idPaper ) ;
                {
                for( countT idPaper = cPapersRoot ; idPaper >= 1 ; idPaper -- )
            {

            thThread.winSetTitleF( tinP , T(psttTitle) , *pRootI ) ;
        {
        if( pRootI )
        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;

        }
            { windowOldC* pwq = new( 0 , tinP , LF ) windowOldC( tinP , etThread , cPapersRoot , 0 , 1 , ifCol , ifRow , cCol , cRow , cColClient , cRowClient , 1 ) ; ___( pwq ) ; } // winRoot MUST BE THE WO'TH WINDOW CONSTRUCTED
            thThread.winAdjustWindowPositionF( tinP , ifCol , ifRow , cCol , cRow ) ;

            }
                cRow = cRowClient ;
                cCol = cColClient ;

                //}
                //    ifRow = 1 ;
                //    ifCol = 1 ;
                //    cRowClient = TUCK >> 1 ;
                //    cColClient = TUCK >> 1 ;
                //{

                //}
                //    ifRow = 0x30 ;
                //    ifCol = 0x8 ;
                //    cRowClient = cRowDisplay >> 3 ;
                //    //cColClient = cColDisplay - 0x80 ;
                //    //LOGrAW3( "[cColClient]: " , cColClient , "\r\n" ) ;
                //    cColClient = cColDisplay >> 3 ;
                //{
//#endif
                //else
                }
                    cRowClient = cRowDisplay ;
                    cColClient = cColDisplay ;
                    ifRow = 1 ;
                    ifCol = 1 ;
                {
                //if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_DEBUG ) )
//#if defined( NEVERdEFINED )
    
                thThread.osDisplaySizeF( tinP , cColDisplay , cRowDisplay ) ;
                ZE( countT , cRowDisplay ) ;
                ZE( countT , cColDisplay ) ;
            {
            ZE( countT , cRowClient ) ;
            ZE( countT , cColClient ) ;
            ZE( countT , cRow ) ;
            ZE( countT , cCol ) ;
            ZE( sCountT , ifRow ) ;
            ZE( sCountT , ifCol ) ;

            //PSEUDODUPLICATED CODE: 1020171 0b0001b (APPARENTLY OBSOLETE COMMENT)
        {
        const countT cPapersRoot = 3 ; //MUST BE 3 OR GREATER BECAUSE EXIST 3 IS GUARANTEED (3 CAN BE USED AS SCRATCH)
    
        thThread.winCreateWindowClassF( tinP , MAINwINDOWcLASSnAME , winMessageHandlerF ) ;
        //thThread.winCreateWindowClassF( tinP , MAINwINDOWcLASSnAME , winMessageHandlerDebugF ) ;
        etherC::ether_pMainRefsIF( tinP ) = new( 0 , tinP , LF ) mainRefsS( tinP , ether , pEtThread ) ; ___( etherC::ether_pMainRefsIF( tinP ) ) ;
#if defined( NEVERdEFINED )
        thirdC& thThread = etThread ;
        thirdC::third_idThreadWindowsIF( tinP ) = tinP.monitor.idThread ;
        strokeS*& psttTitle = *(strokeS**)pTaskP->c2 ;
        signC&    sgnReady  =    *(signC*)pTaskP->c1 ;
        //THIS IS A NO NO.  A FAILURE ON THIS THREAD CAN CAUSE RUSH SPIN OF THE CPU: etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;
        }
            __( ifMin < osMin ) ;
            countT ifMin = idwm_USER ;
            countT osMin = thirdC::winIdMsgUserIF( tinP ) ;
        {
    
        tinP.idPhase2 = 1 ;
        processGlobal1I.ebp_tmWindowsF_ = ebpAM() ; //winMessageHandlerWorkF WILL USE THIS VALUE TO FIND tinP
        if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS ) ) { __( tinP.monitor.idThread - ifcIDtHREADlOW_tmWindowsOrServiceMainF ) ; }
        TELL( "setting up" )
    {
    if( pTaskP && pTaskP->c1 && pTaskP->c2 )
    THREADmODE2oN( flTHREADmODE2_MYoWNrECYCLER )
{
THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //OBSERVED SLEEP BLAMMO FOR CONSOLE a45 OCCASIONALLY July 31,2005 DURING INSTALL; DID NOT ANALYZE

/*1*/TASK( tmWindowsF )/*1*/

/**/
*/
/*

// tmWindowsF IS TO BE UNAFFECTED BY ether I.E. WHETHER THE CELL HAS BEEN FIRED

/**/
*/
 in particular, i must hang around and not return from WM_CLOSE until my whole process cleanup is complete
 i must do this because MS Windows is such a piece of shit
 i am essentially an orphan thread, hanging around while main d eletes all of this processes ifc objects
  for example, i must not use the T macro
 after that time, i must avoid referring to etThread or tinP and i must also avoid referring to other ifc objects
wo tricky aspect of this thread is that it blocks in the WM_CLOSE handler, which destroys its etThread and its tinP objects
 psttTitle
 sgnReady
arguments
 i wake up, create my root window, and wait patiently until i can maximize it
 i reset sgnReady and sleep for 01 tock
 the WM_QUIT causes the message pump to return
 my windows are all gone
 my root window handles the WM_DESTROY by destroying its object and posting WM_QUIT
 my root window handles the WM_CLOSE by destroying itself, which also destroys the input window, its child
 my root window receives a WM_CLOSE message
 the operator logs off
 since i can now maximize my root window, i do so, create my input window, and begin pumping window messages
 an operator logs on
 i detect that i cannot maximize my root window, so i patiently wait indefinitely (hours, days,...) for an operator to log on
 at boot, i am launched
example scenario: gui process that is launched automatically at boot
i create windows, handle their messages, and destroy them
\<A HREF=\"5.0b00012.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$tmWindowsF.0.html\"\>instances\</A\>
/*

#endif
}
    return rc ;

    }
        }
            break ;
            rc = tinP.brcRaw ;
            BOSdOnOTtEST( WHATgbo , DefWindowProc( (HWND)hWindowP , idCmdP , p1P , p2P ) )
        {
        default:
        }
            break ;
            BOSdOnOTtEST( WHATgbo , EndPaint(   (HWND)hWindowP , &info ) )
            BOSpOOP
            BOS( WHATgbo , BOSoK , BeginPaint( (HWND)hWindowP , &info ) )
        {
        case WM_PAINT :
        }
            break ;
            BOSpOOP
            BOS( WHATgbo , BOSoK , PostMessage( (HANDLE)hWindowP , WM_QUIT , 0 , 0 ) )
            rc = tinP.brcRaw ;
            BOSdOnOTtEST( WHATgbo , DefWindowProc( (HWND)hWindowP , idCmdP , p1P , p2P ) )
            }
                while( !( F(thirdC::third_flagsProcessStateI_IF(tinP)) & flPROCESSsTATE_MAINtHREADcLEANUPiScOMPLETE ) ) { ++ s ; thirdC::dosSleepRawIF( tinP , 250 ) ; }
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            thirdC::third_flagsProcessStateI_IF( tinP , flPROCESSsTATE_WM_CLOSE_RECEIVED , 1 ) ; // main WILL PROCEED TO CLEANUP WHEN IT SEES THIS

            DEL( etherC::ether_pMainRefsIF( tinP ) ) ; // NO FURTHER USE FOR THIS
            TINSL
            DEL( pEtThread ) ; //THIS ALSO CAUSES tinP TO BE DESTROYED
            DEL( tinP.pEtScratch ) ;
            etherC*& pEtThread  = etherC::ether_pMainRefsIF( tinP )->pEtThread ;
        {
        case idwm_CLOSE :
        case WM_CLOSE :
    {
    switch( idCmdP )
    ZE( countT , rc ) ;
    TINSL
{
extern "C" countT __export OSF winMessageHandlerDebugF( const handleC& hWindowP , const countT idCmdP , const countT p1P , const countT p2P )
PAINTSTRUCT info ;
//DEBUG

#if defined( NEVERdEFINED )

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

