
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    #endif

        }
            }
                }
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( zlib_hModule , "inflateEnd"   ) ) ; if( !_brcRaw ) { BLAMMO ; } ; zlib_pInflateEndF   =   (zlib_inflateEndFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( zlib_hModule , "inflate"      ) ) ; if( !_brcRaw ) { BLAMMO ; } ; zlib_pInflateF      =      (zlib_inflateFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( zlib_hModule , "inflateInit2_") ) ; if( !_brcRaw ) { BLAMMO ; } ; zlib_pInflateInit2F = (zlib_inflateInit2FT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( zlib_hModule , "inflateInit_" ) ) ; if( !_brcRaw ) { BLAMMO ; } ; zlib_pInflateInitF  =  (zlib_inflateInitFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( zlib_hModule , "deflateEnd"   ) ) ; if( !_brcRaw ) { BLAMMO ; } ; zlib_pDeflateEndF   =   (zlib_deflateEndFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( zlib_hModule , "deflate"      ) ) ; if( !_brcRaw ) { BLAMMO ; } ; zlib_pDeflateF      =      (zlib_deflateFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( zlib_hModule , "deflateInit_" ) ) ; if( !_brcRaw ) { BLAMMO ; } ; zlib_pDeflateInitF  =  (zlib_deflateInitFT)_brcRaw ; 
                {                                                                
                else
                if( !zlib_hModule ) { BLAMMO ; }

                zlib_hModule = (HMODULE)_brcRaw ;
                BOSnOtIN( LoadLibraryEx( postDllZlib , 0 , 0 ) ) ;
                _brcRaw = 0 ;

                thirdC::c_strcatIF( postDllZlib , "precious\\domains\\com\\ideafarm\\city\\workshop\\zlib\\unzipped.zlib123dll\\dll32\\zlibwapi.dll" ) ;

            {                     // A POLICY OF NEVER LOADING THIRD PARTY LIBRARIES STATICALLY MIGHT BE A GOOD IDEA TO CONSERVE MEMORY AND SPEED UP PROCESS INITIALIZATION ; IF HUNDREDS OR THOUSANDS OF 3RD PARTY MODULES ARE SUPPORTED THEN DYNAMIC, ON DEMAND LOADING BECOMES NECESSARY, SO MIGHT AS WELL DO THEM ALL THAT WAY, JUST IN CASE SUCH A SCENARIO MATERIALIZES
            if( *postDllZlib ) // ZLIB IS LOADED VERY EARLY SO THAT IT CAN BE USED VERY EARLY ; IT IS LOADED DYNAMICALLY MAINLY BECAUSE ZLIB HEADERS ARE NOT COMPATIBLE WITH WATCOM COMPILER

            }
                }
                    else *( ++ postBS ) = 0 ;
                    if( !postBS ) *postDllZlib = 0 ;
                    osTextT* postBS = thirdC::c_strstrIF( postA + sizeof postTestA - 1  , "\\" ) ;
                {
                else
                if( !postA || postA - postDllZlib != 1 ) *postDllZlib = 0 ;

                osTextT* postA = thirdC::c_strstrIF( postDllZlib , postTestA ) ;

                osTextT postTestA[] = ":\\ideafarm.home." ;

                thirdC::c_strcpyIF( postDllZlib , (osTextT*)thirdC::postExeFileNameIF() ) ;
            {
            osTextT postDllZlib[ TUCK << 1 ] ;  // EXAMPLE:  POSThHOMEdRIVE ":\\ideafarm.home.12345678\\"
        {

        }
            }
                //thirdC::openSsl_setupIF() ;

                }
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "SSL_shutdown"     ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pShutdownF    =        (openSsl_pShutdownFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "SSL_read"         ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pReadF        =            (openSsl_pReadFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "SSL_write"        ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pWriteF       =           (openSsl_pWriteFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "SSL_connect"      ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pShakeF       =           (openSsl_pShakeFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "SSL_set_fd"       ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pWrapF        =            (openSsl_pWrapFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "SSL_free"         ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pWrapperFreeF =     (openSsl_pWrapperFreeFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "SSL_new"          ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pWrapperF     =         (openSsl_pWrapperFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "SSL_CTX_free"     ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pContextFreeF =     (openSsl_pContextFreeFT)_brcRaw ; 
                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "SSL_CTX_new"      ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pContextF     =         (openSsl_pContextFT)_brcRaw ; 

                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "OPENSSL_init_ssl" ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pInitF        =            (openSsl_pInitFT)_brcRaw ; 
                    //20200613@2004: DEPRECATED AND NOT FOUND:  _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "SSL_library_init" ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pInitF        =            (openSsl_pInitFT)_brcRaw ; 

                    _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "TLS_method"       ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pMethodF      =          (openSsl_pMethodFT)_brcRaw ; 
                    //20200613@2004: DEPRECATED AND NOT FOUND:  _brcRaw = 0 ; BOSnOtIN( GetProcAddress( openSsl_hModule , "SSLv23_method"    ) ) ; if( !_brcRaw ) { BLAMMO ; } ; openSsl_pMethodF      =          (openSsl_pMethodFT)_brcRaw ; 
                {                                                                
                else
                }
                    BLAMMO ;

                    LOGrAW3( "\r\nLoadLibraryEx [rc]:    " , rc , "\r\n" ) ;
                    LOGrAW( postDllOpenSsl ) ;
                    LOGrAW( "\r\n [postDllOpenSsl]:    " ) ;
                    countT rc = GetLastError() ;
                {
                if( !openSsl_hModule )

                openSsl_hModule = (HMODULE)_brcRaw ;
                BOSnOtIN( LoadLibraryEx( postDllOpenSsl , 0 , /*LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR*/0x100 | /*LOAD_LIBRARY_SEARCH_DEFAULT_DIRS*/0x1000 ) ) ;
                _brcRaw = 0 ;

                //LOGrAW( "\r\n\r\n" ) ;
                //LOGrAW( postDllOpenSsl ) ;
                //LOGrAW( "U::TO FIND A BUG, OPENSSL DLL IS NOT LOADED DURING CT OF processGlobal1I:\r\n" ) ;
                //CONoUTrAW( "\r\n" ) ;
                //CONoUTrAW( postDllOpenSsl ) ;

                thirdC::c_strcatIF( postDllOpenSsl , "precious\\domains\\com\\ideafarm\\city\\workshop\\openssl\\bin\\libssl-3.dll" ) ; // 20200613@1930
                //20200613@1930: RETIRED WHEN MIGRATED workshop/openssl TO CONTAIN RELEASE OF OPENSSL BUILT USING CURRENT SOURCE:  thirdC::c_strcatIF( postDllOpenSsl , "precious\\domains\\com\\ideafarm\\city\\workshop\\openssl\\dll\\ssleay32.dll" ) ;

            {                     // A POLICY OF NEVER LOADING THIRD PARTY LIBRARIES STATICALLY MIGHT BE A GOOD IDEA TO CONSERVE MEMORY AND SPEED UP PROCESS INITIALIZATION ; IF HUNDREDS OR THOUSANDS OF 3RD PARTY MODULES ARE SUPPORTED THEN DYNAMIC, ON DEMAND LOADING BECOMES NECESSARY, SO MIGHT AS WELL DO THEM ALL THAT WAY, JUST IN CASE SUCH A SCENARIO MATERIALIZES
            if( *postDllOpenSsl ) // OPENSSL IS LOADED VERY EARLY SO THAT IT CAN BE USED VERY EARLY ; IT IS LOADED DYNAMICALLY MAINLY BECAUSE OPENSSL HEADERS ARE NOT COMPATIBLE WITH WATCOM COMPILER

            }
                }
                    else *( ++ postBS ) = 0 ;
                    if( !postBS ) *postDllOpenSsl = 0 ;
                    osTextT* postBS = thirdC::c_strstrIF( postA + sizeof postTestA - 1  , "\\" ) ;
                {
                else
                if( !postA || postA - postDllOpenSsl != 1 ) *postDllOpenSsl = 0 ;

                osTextT* postA = thirdC::c_strstrIF( postDllOpenSsl , postTestA ) ;

                osTextT postTestA[] = ":\\ideafarm.home." ;

                thirdC::c_strcpyIF( postDllOpenSsl , (osTextT*)thirdC::postExeFileNameIF() ) ;
            {
            osTextT postDllOpenSsl[ TUCK << 1 ] ;  // EXAMPLE:  POSThHOMEdRIVE ":\\ideafarm.home.12345678\\"
        {

        ecInfo.ContextRecord   = &cInfo ;
        ecInfo.ExceptionRecord = &eInfo ;

    #if defined( __NT__ )

    if( this != &processGlobal1I ) { BLAMMO ; }
    if( !osTidMain ) { BLAMMO ; }

    osTidMain = _brcRaw ;
    BOSnOtIN( GetCurrentThreadId() )
    ZE( countT , _brcRaw ) ;

    }
        //}
        //    TELLc3( ifcIDtYPEtELL_PROCESSgLOBAL1scT , (byteT*)&ti , sizeof ti )
        //    ti.cGrains      = TOCK >> 1 ;
        //    ti.pbEarlyGrain = pbEarlyGrain ;
        //    ti.osPid        = tinP.osPid ;
        //    tellInfoProcessGlobal1S ti ;
        //{
        //U::CAN'T DO THIS EARLY.  DO IT IN processGlobal3S, WHERE THIS CODE WAS BEFORE BEING MOVED HERE

        //#endif
        //
        //    CONoUTrAW5( "processGlobal1I / QueryWorkingSetEx [bOk,rc]:    " , bOk , "    " , rc , "\r\n" ) ;
        //    countT rc = bOk ? 0 : GetLastError() ;
        //
        //    //B:static BOOL bOk = QueryWorkingSetEx( GetCurrentProcess() , pInfoGrain , sizeof pInfoGrain ) ;
        //
        //    static BOOL bOk = QueryWorkingSetEx( GetCurrentProcess() , pInfoGrain , sizeof( PSAPI_WORKING_SET_EX_INFORMATION ) * TOCK / 2 ) ;
        //
        //    }
        //        pInfoGrain[ ++ offg ].VirtualAddress = (voidT*)pbTry ;
        //
        //        //}
        //        //    CONoUTrAW( "\r\n" ) ;
        //        //    idColLath = 0 ;
        //        //{
        //        //if( ++ idColLath == TUCK )
        //        //CONoUTrAW( bOk ? "0" : "." ) ;
        //
        //        //if( bOk ) pbEarlyGrain[ offg / SB ] |= mask ;
        //        //byteT mask = (byteT)( 1 << ( ++ offg ) % SB ) ;
        //        //
        //        //thirdC::dosReadProcessMemoryIF( tinP , &bIn , 1 , bOk , (voidT*)pbTry , tinP.osPid ) ;
        //        //ZE( byteT , bIn ) ;
        //        //ZE( boolT , bOk ) ;
        //    {
        //    for( byteT* pbTry = 0 ; pbTry < (byteT*)BM_HIGH ; pbTry += cbGrain )
        //    countT offg = -1 ;
        //    ZE( countT , idColLath ) ;
        //    CONoUTrAW3( "[cbGrain]: " , cbGrain , "\r\n" ) ;
        //    if( cbAllocationGrain != cbGrain ) { BLAMMO ; }
        //
        //    }
        //        cbGrain = info.dwAllocationGranularity ;
        //        GetSystemInfo( &info ) ;
        //        SYSTEM_INFO info ;
        //    {
        //    ZE( countT , cbGrain ) ;
        //
        //    CONoUTrAW( "\r\n\r\nAddress Space Usage (ct processGlobal1I):\r\n\r\n" ) ;
        //
        //    PSAPI_WORKING_SET_EX_INFORMATION* pInfoGrain = (PSAPI_WORKING_SET_EX_INFORMATION*)pcInfoGrain ;
        //
        //    }
        //        }
        //            BLAMMO ;
        //            LOGrAW3( "error: unexpected size [sizeof(PSAPI_WORKING_SET_EX_INFORMATION)]: ]: " , sizeof( PSAPI_WORKING_SET_EX_INFORMATION ) , "\r\n" ) ;
        //        {
        //        if( ci != sizeof( count04T ) )
        //        countT ci = sizeof( PSAPI_WORKING_SET_EX_INFORMATION ) ;
        //    {
        //
        //#if defined( __NT__ )
        //
        //TINSL
    {

    if( this != &processGlobal1I ) { BLAMMO ; }
{
idiFileBlammoCt( 0 )
idLineBlammoCt( 0 ) ,
idiFileBlammo( 0 ) ,
idLineBlammo( 0 ) ,
cbAllocationGrain( TOCK ) ,
flagsCpuFeatures( queryCpuFeaturesAM() ) ,
ostLathLog( 0 ) ,
osTidTerminator( 0 ) ,
osTidMain( 0 ) ,
idTrial( 0 ) ,
idPhaseProcess( ifcIDpHASEpROCESS_PROLOGcONSTRUCTINGgLOBALS ) ,
idProcessOld( 0 ) ,
idNumaNode( 0 ) ,
idHome( 1 ) ,
idAdamRoot( 0 ) ,
flDt( flCTdTg_null ) ,
flCt( flCTdTg_null ) ,
cDebug( 0 ) ,
ccValidFlags( sizeof pcValidFlags / sizeof pcValidFlags[ 0 ] ) ,
ccPrime( sizeof pcPrime / sizeof pcPrime[ 0 ] ) ,
cb_nicNameC_( sizeof( nicNameC ) ) ,
cb_idPortTimeC_( sizeof( idPortTimeC ) ) ,
//bGo( 0 ) ,
_tinS_idTinLath( 0 ) ,
_thirdC_flagsProcessState( flPROCESSsTATE_MAINtHREADiSaLONE ) ,
_thirdC_flagsModeProcess2( flMODEpROCESS2_null ) ,
_thirdC_flagsModeProcess1( flMODEpROCESS1_JOT ) ,
_taskS_idThreadLath( 3 ) , //1:main 2:heart 3:break
_handleC_cInstances( 0 ) ,
_poolC_bQuitFlushing( 0 ) ,
_poolC_idFlushLath( 0 ) ,
_poolC_cBacked( 0 ) ,
_poolC_pPool( 0 ) ,
_grabC_pgw( 0 ) ,
_grabC_cgw( TOCK ) , //GLOBALS WON'T CT WITH LESS THAN TOCK
_displayC_pDisplay( 0 ) ,
/*1*/processGlobal1S::processGlobal1S( voidT ) :/*1*/

byteT processGlobal1S::pbnuTuck[ TUCK ] ;

countT processGlobal1S::pcPrime[] = { 0x11 , 0x13 , 0x17 , 0x1d , 0x1f , 0x25 , 0x29 , 0x2b , 0x2f , 0x35 , 0x3b , 0x3d , 0x43 , 0x47 , 0x49 , 0x4f } ;

osTextT processGlobal1S::postIdHome[ 0x9 ] = { 0 , 'b' , 'b' , 'b' , 'b' , 'b' , 'b' , 'b' , 'b' } ;

osTextT processGlobal1S::postIdAdamRoot[ 0x9 ] = { 0 , 'b' , 'b' , 'b' , 'b' , 'b' , 'b' , 'b' , 'b' } ;

osTextT processGlobal1S::postIdNumaNode[ 0x9 ] = { 0 , 'b' , 'b' , 'b' , 'b' , 'b' , 'b' , 'b' , 'b' } ;

;
}
    #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.1900000b.genValidFlags.h"
{
flagsT processGlobal1S::pcValidFlags[] =

const osTextT* const processGlobal1S::_handleC_postOldClassName = "handleC" ;

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

