
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//



#undef OFFbOOKsLOTnOW

#undef NEWbOOK2sETfLAG

#undef BOOKnOWrESETfLAG

#undef NEWbOOK1bLAMMOiFcT                                                                 

#undef BOOKnOWeXISTS

#undef BOOKnOWmASK

#undef DELzOMBIEbOOKbACKnOWiF

}
    THREADmODE3rESTORE

    }
        }
            }
                }
                    ++ s ; tinP.pEther->osSleepF( tinP , TOCK ) ;
            
                    }
                        break ;
                        __1
                    {
                    if( pbQuitP && *pbQuitP )
            
                    if( pcpIdBookMinP || F(flagsCt) & flBOOKSc_WRITER ) break ;
            
                    while( ~hFind ) ;
                    }
                        DEL( pInfo ) ;
                        //if( tinP.pEther && pInfo ) tinP.pEther->trace F( tinP , T("idBookMinMaxF inspected  [psttIfoName]:    ")+T(pInfo->psttIfoName) ) ;
                        }
                            }
                                }
                                    PUSE( tinP , *(byteT**)&pcpIdBookThis ) ;
                
                                    }
                                        if( pcpIdBookMaxP ) thirdC::c_memcpyIF( tinP , (byteT*)pcpIdBookMaxP , (byteT*)pcpIdBookThis , cba ) ;
                                        PUSE.newF( tinP , LF , *(byteT**)&pcpIdBookMaxP , cba ) ; ___( pcpIdBookMaxP ) ;
                                        countT cba = sizeof( countT ) * ( 1 + *pcpIdBookThis ) ;
                                        PUSE( tinP , *(byteT**)&pcpIdBookMaxP ) ;
                                    {
                                    if( sgn < 0 )
                                    PUSE( tinP , *(byteT**)&pcpnu ) ;
                                    sgn = subtractF( tinP , pcpnu , pcpIdBookMaxP , pcpIdBookThis ) ; ___( pcpnu ) ;
                
                                    }
                                        if( pcpIdBookMinP ) thirdC::c_memcpyIF( tinP , (byteT*)pcpIdBookMinP , (byteT*)pcpIdBookThis , cba ) ;
                                        PUSE.newF( tinP , LF , *(byteT**)&pcpIdBookMinP , cba ) ; ___( pcpIdBookMinP ) ;
                                        countT cba = sizeof( countT ) * ( 1 + *pcpIdBookThis ) ;
                                        PUSE( tinP , *(byteT**)&pcpIdBookMinP ) ;
                                    {
                                    if( sgn > 0 )
                                    PUSE( tinP , *(byteT**)&pcpnu ) ;
                                    sCountT sgn = subtractF( tinP , pcpnu , pcpIdBookMinP , pcpIdBookThis ) ; ___( pcpnu ) ;
                
                                    ZE( countT* , pcpnu ) ;
                                {
                                else
                                }
                                    if( !POOP ) thirdC::c_memcpyIF( tinP , (byteT*)pcpIdBookMaxP , (byteT*)pcpIdBookMinP , sizeof( countT ) * ( 1 + *pcpIdBookMinP ) ) ;
                                    __Z( pcpIdBookMaxP ) ;
                                    PUSE.newF( tinP , LF , *(byteT**)&pcpIdBookMaxP , sizeof( countT ) * ( 1 + *pcpIdBookMinP ) ) ; ___( pcpIdBookMaxP ) ;
                                    pcpIdBookMinP = pcpIdBookThis ; pcpIdBookThis = 0 ;
                                {
                                if( !pcpIdBookMinP )
                
                                tinP.pEther->delF( tinP , pstt1w ) ;
                                }
                                    }
                                        else                       pco -- ;
                                        if( pco == pcpIdBookThis ) pco = pcpIdBookThis + cWords - 1 ;
                                        *pco = tinP.pEther->strDigitsToSCountF( tinP , psttc1 , 0 , 1 ) ;
                                    {
                                    FORsTRINGSiN1( pstt1w )
                
                                    countT* pco = pcpIdBookThis ;
                                {
                                if( pcpIdBookThis )
                                PUSE.newF( tinP , LF , *(byteT**)&pcpIdBookThis , sizeof( countT ) * cWords ) ; ___( pcpIdBookThis ) ;
                                ZE( countT* , pcpIdBookThis ) ;
                                tinP.pEther->delF( tinP , psttw ) ;
                                countT cWords = tinP.pEther->strWordsOldF( tinP , pstt1w , psttw , sttq , tDot ) ; ___( pstt1w ) ;
                                ZE( strokeS* , pstt1w ) ;
                
                                tinP.pEther->strSubstringF( tinP , psttw , idf , sttq , tAfter , pInfo->psttIfoName ) ; ___( psttw ) ;
                                tinP.pEther->delF( tinP , psttw ) ;
                                tinP.pEther->strSubstringF( tinP , psttw , idf , sttq , tBefore , pInfo->psttIfoName ) ; ___( psttw ) ;
                                countT idf = 1 ;
                                ZE( strokeS* , psttw ) ;
                            {
                            else
                            }
                                if( POOP ) { POOPR ; }
                                tinP.pEtScratch->diskFileOrDirDeleteF( tinP , pInfo->psttIfoName , flFILEoRdIRdELETE_null , 1 ) ;
                                SCOOPS
                            {
                            if( F(flagsP) & flBOOKScsELECT_PURGE )
                        {
                        if( pInfo && !( F(pInfo->flags) & flFILEaTTR_DIRECTORY ) )

                        //if( tinP.pEther && pInfo ) tinP.pEther->trace F( tinP , T("idBookMinMaxF inspecting [psttIfoName]:    ")+T(pInfo->psttIfoName) ) ;
                        }
                            }
                                break ;
                                POOPR
                            {
                            if( POOP )
                            tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , fnLike.pathF() , &pat ) ; ___( pInfo ) ;
                            SCOOPS
                        {
                        ZE( infoFileS* , pInfo ) ;
                    {
                    do
                    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                    patternC pat( tinP , *tinP.pEther , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; //U:: O:  TO SPEED THIS (BY ELIMINATING RECURSION), USE STRICT INTERPRETATION OF WILDCARDS
                    fileNameC fnLike( tinP , *tinP.pEther , psttFindLike ) ;
                    TN( tDot , "." ) ;
                    strokeS sttDot( '.' ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                
                    TN( tAfter  , ".bookC" ) ;
                    TN( tBefore , ".booksC.1.book." ) ;
                {
                for(;;)
            {
            IFsCRATCH
        {
        else
        }
            }
                ++ s ; tinP.pEther->osSleepF( tinP , TOCK ) ;

                }
                    break ;
                    __1
                {
                if( pbQuitP && *pbQuitP )
        
                if( pcpIdBookMinP || F(flagsCt) & flBOOKSc_WRITER ) break ;
        
                while( ~hFind ) ;
                }
                    //if( tinP.pEther ) tinP.pEther->trace F( tinP , T("idBookMinMazF inspected  [postName]:    ")+T(postName) ) ;
                    }
                        }
                            if( sgn < 0 ) thirdC::c_memcpyIF( tinP , (byteT*)pcpIdBookScratchMax , (byteT*)pcpIdBookScratch1 , cbToCopy ) ;

                            __NZ( pcpnu ) ;
                            sgn = subtractF( tinP , pcpnu , pcpIdBookScratchMax , pcpIdBookScratch1 ) ;
        
                            if( sgn > 0 ) thirdC::c_memcpyIF( tinP , (byteT*)pcpIdBookScratchMin , (byteT*)pcpIdBookScratch1 , cbToCopy ) ;

                            __NZ( pcpnu ) ;
                            sCountT sgn = subtractF( tinP , pcpnu , pcpIdBookScratchMin , pcpIdBookScratch1 ) ;
                            ZE( countT* , pcpnu ) ;
                            //CONoUTrAW7( "comparing " , pcpIdBookScratch1[ 1 ] , " to [min,max]: [" , pcpIdBookScratchMin[ 1 ] , "," , pcpIdBookScratchMax[ 1 ] , "]\r\n" ) ;
                        {
                        else
                        }
                            pcpIdBookMaxP = pcpIdBookScratchMax ;
                            pcpIdBookMinP = pcpIdBookScratchMin ;

                            thirdC::c_memcpyIF( tinP , (byteT*)pcpIdBookScratchMax , (byteT*)pcpIdBookScratch1 , cbToCopy ) ;
                            thirdC::c_memcpyIF( tinP , (byteT*)pcpIdBookScratchMin , (byteT*)pcpIdBookScratch1 , cbToCopy ) ;
                        {
                        if( !pcpIdBookMinP )

                        }
                            }
                                else        offo -- ;
                                if( !offo ) offo = cWords - 1 ;

                                posti = poste + 1 ;
                                pcpIdBookScratch1[ offo ] = thirdC::c_atoiForeignIF( posti ) ;
                                *poste = 0 ;                                // EXAMPLE: "00000001"

                                if( !poste ) break ; //SHOULD NEVER OCCUR
                                poste = thirdC::c_strstrIF( tinP , posti , "." ) ;
                            {
                            while( cToDo -- )
                            countT cToDo = cWords ;
                            ZE( osTextT* , poste ) ;
                            ZE( countT , offo ) ;
                            const osTextT* posti = postv ;
                        {                                       // SET pcpIdBookScratch1 FROM THE FILE NAME

                        }
                            while( posti ) ;
                            }
                                }
                                    cWords ++ ;
                                    posti ++ ;
                                {
                                if( posti )
                                posti = thirdC::c_strstrIF( tinP , posti , "." ) ;
                            {
                            do
                            const osTextT* posti = postv ;
                        {
                        if( *postv )
                        ZE( countT , cWords ) ;

                        //CONoUTrAW( "\"\r\n" ) ;
                        //CONoUTrAW( postv ) ;
                        //CONoUTrAW( "found pcp value \"" ) ;
                        osTextT* postv = postName + costPrefix ; // EXAMPLE: "00000001.0000001c.bookC"
                    {
                    else
                    }
                        if( POOP ) { POOPR ; }
                        thirdC::dosDeleteIF( tinP , postName ) ;
                    {
                    if( F(flagsP) & flBOOKScsELECT_PURGE )

                    }
                        break ;
                        __( ~hFind ) ;
                    {
                    if( !postName[ 0 ] )
                    //if( tinP.pEther ) tinP.pEther->trace F( tinP , T("idBookMinMazF inspecting [postName]:    ")+T(postName) ) ;
                    thirdC::dosFindFileOrDirSimpleIF( tinP , postName , sizeof postName , hFind , postFindLike ) ;
                    postName[ 0 ] = 0 ;
                    osTextT postName[ TUCK << 1 ] ;
                {
                do
                handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {
            for(;;)
            if( cbToCopy > ccMaxIdBook * sizeof( countT ) ) *(countT*)&cbToCopy = ccMaxIdBook * sizeof( countT ) ;
            const countT cbToCopy = ccMaxIdBook * sizeof( countT ) ;

            __( !!tinP.pPoolUse ) ; //subtractF TESTS THIS AND WILL RETURN A POINTER THAT I DO NOT EXPECT IF IT IS TRUE

            }
                thirdC::c_strcpyIF( tinP , postFindLike , ostoLike ) ;

                OStEXTAK( ostoLike , "*" ) ;
                OStEXTA(  ostoLike , ostoPrefix ) ;
                OStEXT(   ostoLike , TUCK << 2 ) ;

                costPrefix = ostoPrefix.costF() ;
                }
                    OStEXTAK( ostoPrefix , ".booksC.1.book." ) ;
                    OStEXTA(  ostoPrefix , postNameShort ) ;
                    OStEXTAK( ostoPrefix , "\\" ) ;

                    POOPR
                    OStEXTC(  ostoPrefix , idStateSpace , 0 ) ;                                                                 thirdC::dosCreateDirIF( tinP , ostoPrefix ) ;
                    OStEXTAK( ostoPrefix , "\\" ) ;
                    OStEXTAK( ostoPrefix , "\\stateSpaces" ) ;                                                                  thirdC::dosCreateDirIF( tinP , ostoPrefix ) ;
                    OStEXTCF( ostoPrefix , idMemorySpace ? idMemorySpace : tinP.pAdamGlobal1->idMemorySpace , '0' ) ;           thirdC::dosCreateDirIF( tinP , ostoPrefix ) ;
                    OStEXTAK( ostoPrefix , "\\" ) ;
                    OStEXTA(  ostoPrefix , thirdC::postUserNameIF() ) ;                                                         thirdC::dosCreateDirIF( tinP , ostoPrefix ) ;
                    OStEXTAK( ostoPrefix , "\\" ) ;
                    OStEXTAK( ostoPrefix , "\\memorySpaces" ) ;                                                                 thirdC::dosCreateDirIF( tinP , ostoPrefix ) ;
                    OStEXTAK( ostoPrefix , "\\ipdos" ) ;                                                                        thirdC::dosCreateDirIF( tinP , ostoPrefix ) ;
                    OStEXTAK( ostoPrefix , "\\ideafarm" ) ;                                                                     thirdC::dosCreateDirIF( tinP , ostoPrefix ) ;
                    OStEXTAK( ostoPrefix , "\\com" ) ;                                                                          thirdC::dosCreateDirIF( tinP , ostoPrefix ) ;
                    OStEXTAK( ostoPrefix , "\\domains" ) ;                                                                      thirdC::dosCreateDirIF( tinP , ostoPrefix ) ;
                    OStEXTAK( ostoPrefix , "\\backed.up.daily" ) ;                                                              thirdC::dosCreateDirIF( tinP , ostoPrefix ) ;
                    OStEXTAK( ostoPrefix , "\\ephemeral" ) ;                                                                    thirdC::dosCreateDirIF( tinP , ostoPrefix ) ;
                    OStEXTA(  ostoPrefix , postHome ) ;                                                                         thirdC::dosCreateDirIF( tinP , ostoPrefix ) ;

                    if( POOP ) { BLAMMO ; }
                    thirdC::diskFindHomeIF( tinP , postHome , sizeof postHome , "ideafarm" ) ;
                    osTextT postHome[ TUCK << 1 ] ;

                    SCOOP
                    poopC poop ;
                {
                OStEXT( ostoPrefix , TUCK << 1 ) ;
            {
            ZE( countT , costPrefix ) ;
        {
        if( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE ) //BOTH FLAVORS ARE RETAINED IN ORDER TO HAVE TRUE UNLIMITED CAPACITY WHEN PUSE EXISTS
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {                                                               //U:: ENUMERATE SHARED MEMORY RATHER THAN BACKING FILES
    if( idStateSpace )

    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )

    _IO_

    }
        if( POOP ) return ;
        }
            FV( flBOOKScsELECT , flagsP ) ;
            __( tinP.monitor.idThread != 1 ) ; //I WILL USE STATIC STORAGE SO WILL NOT BE THREAD SAFE; INTENDED ONLY FOR CT/DT OF INSTANCES IN STATIC STORAGE
        {
        if( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE )
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT booksC::idBookMinMaxF( tinS& tinP , countT*& pcpIdBookMinP , countT*& pcpIdBookMaxP , const flagsT flagsP , const boolT* pbQuitP )/*1*/

/**/
*/
 tinP
arguments
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

