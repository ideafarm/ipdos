
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etherC::loafIF( tinP ) ;

}
    }
        //etThread.traceF( tinP , T("napped") ) ;
        ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        //etThread.traceF( tinP , T("napping") ) ;

        if( bQuit ) break ;
        if( !bQuit ) break ; //U::LATER: CYCLE THIS ONCE PER MONTH.  NOW: RUN MANUALLY FOR A SINGLE PASS

        }
            etThread.boxPutF( tinP , T("smtp.mailgun.org[admin]/b42/smtp/")+tHost+T("@ideafarm.com/")+tTo+T("//wo@ideafarm.com") , tBody ) ;

            etThread.traceF( tinP , T("[tTo]:    ")+tTo ) ;

            }
                etThread.delF( tinP , pstte ) ;

                }
                    tTo += T(pstte) ;                
                    if( tTo.csF( tinP ) ) tTo += tSlash ;
                    etThread.traceF( tinP , tb4+T(pstte) ) ;
                {
                if( !swDelete )
                psttzEmail = pstte ;

                swsEmail >> pstte ;
                ZE( strokeS* , pstte ) ;
            {
            while( swsEmail )
            TN( tTo , "" ) ;

            }
                ;

                    )
                        "for using good judgment to ensure his or her own safety.  Have fun but be careful!\r\n"
                        "No background checks or safety monitoring is done.  Each participant is responsible\r\n"
                        "All should remember that IDEAFARM.COM only puts you into contact with each other.\r\n"
                        "\r\n"
                        "group in future monthly notices for your location.\r\n"
                        "When these decisions have been made, let me know and I will include the details for your\r\n"
                        "\r\n"
                        "in order to ensure that the group is safe, legal, and equally welcoming to all.\r\n"
                        "Each moderator then decides where and when his/her group will meet and what rules, if any, to set\r\n"
                        "The next step is for one or more of you to decide to \"moderate\" an \"eat together\" group.\r\n"
                        "\r\n"
                        "how to start eating together weekly.\r\n"
                        "Feel free to contact me, Wo'O' Ideafarm, to ask questions or get ideas about\r\n"
                        "\r\n"
                        "These notices are sent monthly.  You now have enough people to bring Wo'O's Table to your postal code,\r\n"
                        "\r\n"
                        "\r\n"
                    +T(
                    +T(psttzCountryZip)
                    +T(" people are registered for ")
                    +TF4(cFriends,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FOREIGN,0,0xa)
                    T("Subject: Wo'O's Table:  ")

                tBody =
            {
            else
            }
                ;

                    )
                        "how to get a group started.\r\n"
                        "Feel free to contact me, Wo'O' Ideafarm, to ask questions or get ideas about\r\n"
                        "\r\n"
                        "Or, you can just wait for us to find one for you.\r\n"
                        "you just need to find one additional person to help you form an \"eat together\" group!\r\n"
                        "These notices are sent monthly.  To bring Wo'O's Table to your postal code,\r\n"
                        "\r\n"
                        "\r\n"
                    +T(
                    +T(psttzCountryZip)
                    T("Subject: Wo'O's Table:  Only you are registered for ")

                tBody =
            {
            if( bLonely )
            TN( tBody , "" ) ;

            boolT bLonely = cFriends == 1 ;
            countT cFriends = swsEmail ;
            etThread.traceF( tinP , psttzCountryZip ) ;
            psttzCountryZip = (strokeS*)swsEmail.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swsEmail.cFlavorsF( tinP ) ;

        }
            if( !tHost.csF( tinP ) ) tHost = T("factories") ;
            etThread.delF( tinP , psttHost ) ;
            else       tHost = T(psttHost) ;
            if( POOP ) { POOPR ; }
            tinP.pEtScratch->sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
            ZE( strokeS* , psttHost ) ;

            SCOOPS
        {
        IFsCRATCH
        TN( tHost , "" ) ;

        while( !ether && ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                }
                    etThread.delF( tinP , psttCountry ) ;
                    etThread.delF( tinP , psttZip     ) ;
                    etThread.delF( tinP , psttDelete  ) ;
                    etThread.delF( tinP , psttPeer    ) ;


                    }
                        etThread.delF( tinP , psttEmail ) ;
                    {
                    else
                    }
                        else      etThread.delF( tinP , psttEmail ) ;
                        if( ids ) psttEmail = 0 ;
                        swsEmail.sinkF( tinP , ids , psttEmail , flSTACKsINK_UNIQUE ) ;
                        ZE( countT , ids ) ;

                        psttzCountryZip = tFlavor ;

                        TN( tFlavor , "" ) ; tFlavor = T(psttCountry)+tBlankDashBlank+T(psttZip) ;

                        swDelete = (boolT)!etThread.strCompareF( tinP , psttDelete , tYes ) ; //ONLY THE LATH IS EFFECTIVE
                        psttzEmail = psttEmail ;

                        etThread.traceF( tinP , T("rec:")+tb4+T(psttPeer)+tb4+T(psttDelete)+tb4+T(psttEmail)+tb4+T(psttZip)+tb4+T(psttCountry) ) ;
                        //etThread.traceF( tinP , T(USCORE79) ) ;
                        //etThread.traceF( tinP , T("country:    \"")+T(psttCountry)+T("\"") ) ;
                        //etThread.traceF( tinP , T("zip:        \"")+T(psttZip)+T("\"") ) ;
                        //etThread.traceF( tinP , T("email:      \"")+T(psttEmail)+T("\"") ) ;
                        //etThread.traceF( tinP , T("delete:     \"")+T(psttDelete)+T("\"") ) ;
                        //etThread.traceF( tinP , T("peer:       \"")+T(psttPeer)+T("\"") ) ;
                        //etThread.traceF( tinP , T("cFields:    ")+TF2(cFields,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //etThread.traceF( tinP , T("idFormat:   ")+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //etThread.traceF( tinP , T(USCORE79) ) ;
                    {
                    if( ( idFormat > 1 || cFields == 7 ) && etThread.strCompareF( tinP , psttEmail , tEmailIgnore1 ) && etThread.strCompareF( tinP , psttEmail , tEmailIgnore2 ) )

                    //etThread.strConvertToLowerCaseF( tinP , psttCountry ) ;
                    etThread.strTrimF( tinP , psttCountry ) ; ___( psttCountry ) ;
                    souli >> psttCountry ; ___( psttCountry ) ;
                    ZE( strokeS* , psttCountry ) ;

                    etThread.strConvertToLowerCaseF( tinP , psttZip ) ;
                    etThread.strTrimF( tinP , psttZip ) ; ___( psttZip ) ;
                    souli >> psttZip ; ___( psttZip ) ;
                    ZE( strokeS* , psttZip ) ;

                    etThread.strConvertToLowerCaseF( tinP , psttEmail ) ;
                    etThread.strTrimF( tinP , psttEmail ) ; ___( psttEmail ) ;
                    souli >> psttEmail ; ___( psttEmail ) ;
                    ZE( strokeS* , psttEmail ) ;

                    souli >> psttDelete ; ___( psttDelete ) ;
                    ZE( strokeS* , psttDelete ) ;

                    souli >> psttPeer ; ___( psttPeer ) ;
                    ZE( strokeS* , psttPeer ) ;

                    souli >> idFormat ;
                    ZE( countT , idFormat ) ;

                    souli >> finger ;
                    ZE( countT , finger ) ;

                    countT cFields = souli.cFieldsF() ;

                    //etThread.traceF( tinP , T("got soul") ) ;
                    etThread.boxGetShadowF( tinP , souli , tIfoName ) ;
                    soulC souli( tinP , TAG( TAGiDnULL ) ) ;

                    //etThread.traceF( tinP , tShort ) ;

                    }
                        etThread.delF( tinP , psttShort ) ;
                        tShort = T(psttShort) ;
                        etThread.delF( tinP , psttnu ) ;
                        etThread.strBisectF( tinP , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShort , "" ) ;
                {
                if( !bDir )

                const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;

                TN( tIfoName , pInfo->psttIfoName ) ;

            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirOldF( tinP , pInfo , hFind , tLike ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        etThread.traceF( tinP , T(USCORE79) ) ;

        switchC swDelete( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzEmail ) ;
        ZE( strokeS* , psttzEmail ) ;

        switchStackC swsEmail( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzCountryZip , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
        ZE( strokeS* , psttzCountryZip ) ;
    {
    while( !bQuit && !POOP )
    const boolT& bQuit = *(const boolT*)&(const countT&)ether ;

    putNegAM( *(countT*)&fingerTest , FINGERnEG_WOtABLEcONFIRMEDeMAIL ) ;
    ZE( countT , fingerTest ) ;

    TN( tBlankDashBlank , " - " ) ;
    TN( tYes , "yes" ) ;
    TN( tEmailIgnore2 , "ideafarmcity@gmail.com" ) ;
    TN( tEmailIgnore1 , "ideafarm.published.after.4.yrs@gmail.com" ) ;
    TN( tb4 , "    " ) ;
    TN( tDotJotDot , ".jotC." ) ;
    TN( tDot , "." ) ;
    TN( tSlash , "/" ) ;
    TN( tLike , "////factory5/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/confirmed.email/*" ) ;
{

//etThread.traceF( tinP , T(folder) ) ;
osFileNameC folder( tinP , etThread , "////factory5/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/confirmed.email/" ) ;

//RUN MONTHLY AFTER MANUALLY POURING ALL CONFIRMED EMAIL SOUL FILES TO FACTORY5

TODO



/*1*/WAKEsHOWtEXT( "tool.send.monthly.status.emails.to.wo.o.s.table.participnts" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
