
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    etThread.delF( tinP , pcAll ) ;
    }
        }
            ++ s ; ether.osSleepF( tinP , TUCK * 0x40 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        
            etThread.strokeF( tinP , tSay ) ;
    
            }
                else       off -- ;
                if( !off ) off = pcAll[ 3 ] - 1 ;
    
                if( !( ++ cDone % 8 ) ) tSay += tcr ;
    
                tSay += TF3(pcBuf[off],flFORMAT_NObIGITvALUES,9) ;
                //tSay += TF3(off,flFORMAT_NObIGITvALUES,9) ;
            {
            while( cToDo -- )
            ZE( countT , cDone ) ;
            countT off = ( pcAll[ 2 ] - 1 ) % pcAll[ 3 ] ;
        
            if( cToDo > pcAll[ 2 ] ) cToDo = pcAll[ 2 ] ;
            countT cToDo = pcAll[ 3 ] ;
        
            TN( tSay , "\f" ) ; tSay += TF2(++idCycle,flFORMAT_NObIGITvALUES)+tb+TF2(pcAll[2],flFORMAT_NObIGITvALUES)+tcrcr ;
            etThread.memCopyF( tinP , (byteT*)pcAll , (byteT*)pch , cbAll ) ;
        {
        while( !ether )
        ZE( countT , idCycle ) ;
        TN( tcrcr , "\r\n\r\n" ) ;
        TN( tcr   , "\r\n" ) ;
        TN( tb   , " " ) ;
    
        countT* pcBuf = pcAll + 4 ;
    {
    if( pcAll )
    etThread.newF( tinP , LF , *(byteT**)&pcAll , cbAll ) ; ___( pcAll ) ;
    ZE( countT* , pcAll ) ;
    
    //etThread.loafIF( tinP ) ;
    //etThread.strokeF( tinP , tName+T("    ")+TF2(cbAll,flFORMAT_NObIGITvALUES) ) ;
    
    countT* pcb = pch + 4 ;
{
if( pch )
countT* pch = (countT*)(byteT*)napWord ;
const countT cbAll = napWord ;

thirdC::ifc_idHomeOverrideI_IF( tinP ) = 0 ;
napkinC napWord( tinP , LF , (byteT*)bits , tName , 0 , 0 , ifcOPENsHAREDmEMORYhOW_nFeO , flNAPKINc_null , 1 , idMemorySpaceP ) ;
bitsC bits( tinP , CbITSlIFI , 0 , 1 ) ;
thirdC::ifc_idHomeOverrideI_IF( tinP ) = idHomeP ;
//U::ERROR_ACCESS_DENIED: WIN32 IS NOT LETTING ME DO THIS; PERHAPS THAT IS AS I WANT IT

etThread.strokeF( tinP , tName ) ;

LOGrAW( T("ww monitor attempting to open \"")+tName+T("\"\r\n") )
TN( tName , "napWord." ) ; tName += TF2(idAdamP,flFORMAT_NObIGITvALUES)+T(".")+TF2(osPidP,flFORMAT_NObIGITvALUES)+T(".")+TF2(idListP,flFORMAT_NObIGITvALUES) ;

}
    }
        }
            }
                break ;
                etThread.strokeF( tinP , T("idListP: \"")+T(psttc1)+T("\" ")+TF2(idListP,flFORMAT_NObIGITvALUES)+T("\r\n") ) ; //U::
                idListP = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
            {
            case 7 :
            }
                break ;
                etThread.strokeF( tinP , T("osPidP: \"")+T(psttc1)+T("\" ")+TF2(osPidP,flFORMAT_NObIGITvALUES)+T("\r\n") ) ; //U::
                LOGrAW3( "osPidP: " , osPidP , "\r\n" ) ; //U::
                osPidP = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
            {
            case 6 :
            }
                break ;
                etThread.strokeF( tinP , T("idAdamP: \"")+T(psttc1)+T("\" ")+TF2(idAdamP,flFORMAT_NObIGITvALUES)+T("\r\n") ) ; //U::
                LOGrAW3( "idAdamP: " , idAdamP , "\r\n" ) ; //U::
                if( idAdamP < 0x1000 ) idAdamP |= 0x4010000 ;
                idAdamP = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
            {
            case 5 :
            }
                break ;
                etThread.strokeF( tinP , T("idMemorySpaceP: \"")+T(psttc1)+T("\" ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES)+T("\r\n") ) ; //U::
                LOGrAW3( "idMemorySpaceP: " , idMemorySpaceP , "\r\n" ) ; //U::
                idMemorySpaceP = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
            {
            case 4 :
            }
                break ;
                etThread.strokeF( tinP , T("idHomeP: \"")+T(psttc1)+T("\" ")+TF2(idHomeP,flFORMAT_NObIGITvALUES)+T("\r\n") ) ; //U::
                LOGrAW3( "idHomeP: " , idHomeP , "\r\n" ) ; //U::
                idHomeP = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
            {
            case 3 :
        {
        switch( ++ idp )
    {
    FORsTRINGSiN1( pstt1p )
    ZE( countT , idp )
    strokeS*& pstt1p = etThread.ether_pstt1_processParametersI_F( tinP ) ;
{
countT idListP = 1 ;
ZE( countT , osPidP ) ;
ZE( countT , idAdamP ) ;
ZE( countT , idMemorySpaceP ) ;
ZE( countT , idHomeP ) ;

TODO

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_TOOLnAPwORDvIEWER.tool.ww" )/*1*/
/**/
*/
i must be opened on the same login account as the process that is to be inspected
   if omitted, defaults to 1
  can be omitted
  as of this writing, there are 2 lists
  the woth thread to claim a list, by using WW, gets list 1
 idListP
  must be specified
  the osPid value of the process to be inspected
 osPidP
   105 implies 1050104
  you can specify only the short value
  must be specified
 idAdamP
 idMemorySpaceP
 idHomeP
command line parameters
typical use: see where a thread is blocked
this content is a list of countT values, in reverse chronological order, written using the WW macro
i report the current contents of a wo word napkin
"ww": "wo word"
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

