
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.strokeF( tinP , T("\r\nok\r\n") ) ;

etThread.delF( tinP , psttOk2 ) ;
etThread.delF( tinP , psttOk1 ) ;
}
    cDo = cDoSave ;
    }
        }
            break ;

            }
                while( ~hFind && !ether ) ;
                }
                    DEL( pInfo ) ;
                    }
                        }
                            etThread.delF( tinP , pstta ) ;
                            }
                                bInspect1 = !bInspect1 ;
                                etThread.delF( tinP , psttp1 ) ;
            
                                }
                                    }
                                        }
                                            bInspect2 = !bInspect2 ;
                        
                                            }
                                                else etThread.delF( tinP , psttp2 ) ;
                                                }
                                                    etThread.delF( tinP , psttf ) ;
                                                    }
                                                        }
                                                            etThread.delF( tinP , psttn ) ;
                                                            }
                                                                bDefineLag = bDefine ;
                                                                }
                                                                    bClassLag = bClass ;
                                                                    }
                                                                        }
                                                                            }
                                                                                etThread.delF( tinP , psttShort ) ;
                                                                                etThread.strokeF( tinP , T("nonconformer: \"")+T(psttn)+T("\"\r\n") ) ;
                                                                                LOGrAW( tnc+T(psttn)+tb8+T(psttShort)+tcr ) ;
                                                                                etThread.delF( tinP , psttPath ) ;
                                                                                etThread.strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , 0 , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                                                                                ZE( strokeS* , psttShort ) ;
                                                                                ZE( strokeS* , psttPath ) ;
                                                                            {
                                                                            if( !bOk )

                                                                            ;

                                                                                ( woth < 'A' || woth > 'Z' )
                                                                                &&
                                                                                )
                                                                                    || lath == 'U'  // 'U': "union"                 "fooU::fooU( ..."
                                                                                    || lath == 'T'  // 'T': "type"                  "operator countT( ..."
                                                                                    || lath == 'S'  // 'S': "struct"                "fooS::fooS( ..."
                                                                                    || lath == 'C'  // 'C': "class"                 "fooC::fooC( ..."
                                                                                    || lath == 'M'  // 'M': "assembler macro"       "fooAM( ..."
                                                                                       lath == 'F'  // 'F': "function"              "fooF( ..."
                                                                                (

                                                                            boolT bOk =                                             // EXAMPLE CODE THAT IS CONFORMANT
                                    
                                                                            // 
                                                                            //  WOTH STROKE IS CAPITALIZED
                                                                            //  LATH STROKE IS NOT 'F' OR 'M'
                                                                            // NONCONFORMANT IFF ANY OF THESE ARE TRUE:
                                                                            // 
                                                                            // DEFINITIONS
                                                                        {
                                                                        if( bFun )
                        
                                                                        if( bFun && swIgnore.idSlotOfLeverF( tinP , (countT)psttn ) ) bFun = 0 ; // RESET IF NAME IS A MACRO NAME
                    
                                                                        if( bFun and bClassLag ) bFun = 0 ;
                                
                                                                        }
                                                                            }
                                                                                }
                                                                                    }
                                                                                        break ;
                                                                                        bFun = 1 ;          // WILL BE SET FOR fooF( *pGoo ) BUT NOT FOR voidT (*fooFT)( voidT ) ; THE LATTER IS SUPPRESSED BECAUSE THERE IS NO BLANK BETWEEN THE '(' AND THE "*"
                                                                                    {                       // A:ASSUME: "(*" NEVER OCCURS AT THE BEGINNING OF A FUNCTION CALL
                                                                                    else
                                                                                    if( xx == '*' ) break ;
                                                                                {
                                                                                else
                                                                                }
                                                                                    else                 break ;
                                                                                    else if( xx == '(' ) bParen = 1 ;
                                                                                         if( xx == ' ' ) continue ;
                                                                                {
                                                                                if( !bParen )
                                    
                                                                                countT xx = psttf[ CSpREFIX - 1 + idc ].idAdam ;
                                                                            {
                                                                            for( countT idc = idf2 ; idc <= psttf->idAdam ; idc ++ )
                                                                            ZE( boolT , bParen ) ;
                                                                        {
                                                                        ZE( boolT , bFun ) ;
                                                                    {
                                                                    if( !bClass )
                    
                                                                    boolT bClass = ( lath == 'C' || lath == 'S' || lath == 'U' || lath == 'P' ) && ( woth < 'A' || woth > 'Z' ) ;
                                                                    countT lath = psttn[ CSpREFIX - 1 + psttn->idAdam ].idAdam ;
                                                                    countT woth = psttn[ CSpREFIX                     ].idAdam ;
                                                                {
                                                                if( !bDefine && !bDefineLag )
                
                                                                idf2 = save ;
                
                                                                countT bDefine = !etThread.strCompareF( tinP , tDefine , psttn ) ;
                
                                                                //etThread.strokeF( tinP , T("validating: \"")+T(psttn)+T("\"\r\n") ) ;
                                                            {
                                                            else
                                                            if( !idf2 ) idf2 = save ; // psttn CANNOT BE A FUNCTION CALL IF THERE AREN'T ANY STROKES AFTER IT
            
                                                            etThread.strSubstringF( tinP , psttn , idf2 , idl , psttf ) ; ___( psttn ) ;
                                                            ZE( strokeS* , psttn ) ;
                                                            idf2 = idHit ;
                                                            countT idl = idf2 ? idf2 - 1 : 0 ;
                                                            countT save = idf2 ;
                                                        {
                                                        if( idHit )
                                                        countT idHit = etThread.strIdAnyF( tinP , idf2 , sttq2 , psttOk2 , psttf ) ;
                                                    {
                                                    while( idf2 )
                                                    ZE( boolT , bDefineLag ) ;
                                                    ZE( boolT , bClassLag ) ;
                                                    strokeS sttq2( 0 , sc_IGNOREqUOTES ) ;
                                                    countT idf2 = 1 ;
                        
                                                    //
                                                    // IF IT IS '(' AND THE NEXT NONBLANK IS NOT '*' THEN TEST THE IDENTIFIER
                                                    // FIND THE WOTH NONBLANK AFTER THE IDENTIFIER
                                                    // FIND AN IDENTIFIER
                                                    //
                                                    // RECIPE
                        
                                                    // IDENTIFIER: [a-z,A-Z,0-9,_,#]+
                                                    // IGNORE < 02 OR > f7 (THIS IS DONE BY FILTERING THEM OUT OF psttp2)
                                                    // 
                                                    // DEFININTIONS
                        
                                                    etThread.delF( tinP , psttp2 ) ;
                                                    filterF( tinP , etThread , psttf , psttp2 , psttOk1 ) ; ___( psttf ) ;
                                                    ZE( strokeS* , psttf ) ;

                                                    }
                                                        etThread.delF( tinP , pstt1Lines ) ;
                                                        }
                                                            }
                                                                }
                                                                    bEscapeLag = bEscape ;
                                                                    }
                                                                        }
                                                                            break ;
                                                                            if( bKeep ) etThread.strFuseF( tinP , psttp2 , psttc1[ CSpREFIX - 1 + ids ] ) ;
                                                                        {
                                                                        default :
                                                                        }
                                                                            break ;
                                                                            if( ids == 1 || !bEscapeLag ) bKeep = !bKeep ;
                                                                        {
                                                                        case '\"' :
                                                                        }
                                                                            break ;
                                                                            if( !bEscapeLag ) bEscape = 1 ;
                                                                        {
                                                                        case '\\' :
                                                                    {
                                                                    switch( psttc1[ CSpREFIX - 1 + ids ].idAdam )
                                                                    ZE( boolT , bEscape ) ;
                                                                {
                                                                for( countT ids = 1 ; ids <= psttc1->idAdam ; ids ++ )
                                                                ZE( boolT , bEscapeLag ) ;
                                                                boolT bKeep = 1 ;
                                                            {
                                                            else
                                                            if( !etThread.strCompareF( tinP , psttc1 , tcr ) ) etThread.strFuseF( tinP , psttp2 , tb ) ;
                                                        {
                                                        FORsTRINGSiN1( pstt1Lines )

                                                        etThread.delF( tinP , psttDoomed ) ;
                                                        etThread.strWordsF( tinP , pstt1Lines , psttDoomed , sttq3 , tcr , flSTRwORDS_DELIMITERS  ) ; ___( pstt1Lines ) ;
                                                        strokeS sttq3( 0 , sc_IGNOREqUOTES ) ;
                                                        ZE( strokeS* , pstt1Lines ) ;

                                                        etThread.strMakeF( tinP , psttp2 , 0 , psttDoomed->idAdam ) ; ___( psttp2 ) ;

                                                                              psttp2 = 0 ;
                                                        strokeS* psttDoomed = psttp2 ;
                                                    {
                                                    //ELIMINATE STRING LITERALS

                                                    }
                                                        etThread.delF( tinP , pstt1Lines ) ;
                                                        }
                                                            }
                                                                etThread.delF( tinP , psttw ) ;
                                                                etThread.strFuseF( tinP , psttp2 , psttw ) ;
                                                                etThread.strSubstringF( tinP , psttw , idf3 , idl3 , psttc1 ) ; ___( psttw ) ;
                                                                countT idl3 = idHit - 1 ;
                                                                countT idf3 = 1 ;
                                                                ZE( strokeS* , psttw ) ;
                                                            {
                                                            else if( idHit > 1 )
                                                            if( !idHit ) etThread.strFuseF( tinP , psttp2 , psttc1 ) ;

                                                            countT idHit = etThread.strIdF( tinP , idfss , sttqss , tSlashSlash , psttc1 ) ;
                                                            strokeS sttqss ;
                                                            countT idfss = 1 ;
                                                        {
                                                        FORsTRINGSiN1( pstt1Lines )

                                                        etThread.delF( tinP , psttDoomed ) ;
                                                        etThread.strWordsF( tinP , pstt1Lines , psttDoomed , sttq3 , tcr , flSTRwORDS_DELIMITERS  ) ; ___( pstt1Lines ) ;
                                                        strokeS sttq3( 0 , sc_IGNOREqUOTES ) ;
                                                        ZE( strokeS* , pstt1Lines ) ;

                                                        etThread.strMakeF( tinP , psttp2 , 0 , psttDoomed->idAdam ) ; ___( psttp2 ) ;

                                                                              psttp2 = 0 ;
                                                        strokeS* psttDoomed = psttp2 ;
                                                    {
                                                    //ELIMINATE TEXT TO THE RIGHT OF "//" (NOT WITHIN A CHARACTER STRING) ON EACH LINE
                                                {
                                                if( bInspect2 )
                                            {
                                            if( psttp2 )
                        
                                            }
                                                }
                                                    if( idf22 <= idl2 ) { etThread.strSubstringF( tinP , psttp2 , idf22 , idl2 , psttp1 ) ; ___( psttp2 ) ; } // WILL BE FALSE IF "BOS()"
                                                    countT idf22 = save ;
                                                    countT idl2 = idHit - 1 ;
                                                {
                                                if( idHit )
                        
                                                }
                                                    if( !bFound ) idHit = 0 ;
                                                    }
                                                        }
                                                            }
                                                                if( !( -- offNest ) ) bFound = 1 ;
                                                            {
                                                            else if( psttp1[ CSpREFIX - 1 + idHit ].idAdam == ')' )
                                                                 if( psttp1[ CSpREFIX - 1 + idHit ].idAdam == '(' ) ++ offNest ;
                                                        {
                                                        if( idHit )
                                                        idHit = etThread.strIdAnyF( tinP , idf2 , sttq2 , tParens , psttp1 ) ;
                                                    {
                                                    while( idf2 && offNest )
                                                    ZE( boolT , bFound ) ;
                                                {
                                                ZE( countT , idHit ) ;
                                                countT save = idf2 ;
                                                countT offNest = 1 ; // st_psttBos VALUES END WITH '('.  I AM LOOKING FOR THE MATCHING ')'
                                            {
                                            else
                                            if( bInspect2 ) { etThread.strSubstringF( tinP , psttp2 , idf2 , sttq2 , st_psttBos , countTC() , psttp1 ) ; ___( psttp2 ) ; }
                                        {
                                        while( idf2 )
                                        boolT  bInspect2 = 1 ;
                                        countT idf2 = 1 ;
                                        strokeS sttq2( 0 , sc_IGNOREqUOTES ) ;
                                        ZE( strokeS* , psttp2 ) ; // "p":"PIECE"

                                        //
                                        // SET CURSOR TO NEXT STROKE
                                        // (LATER: REPORT)
                                        // SNIP TO MATCHING ")"
                                        // INSPECT
                                        // SNIP TO "BOS("
                                        //
                                    {
                                    if( bInspect1 )
                                {
                                if( psttp1 )

                                else            { etThread.strSubstringF( tinP , psttp1 , idf1 , sttq1 , tStarSlash , pstta ) ; ___( psttp1 ) ; }
                                if( bInspect1 ) { etThread.strSubstringF( tinP , psttp1 , idf1 , sttq1 , tSlashStar , pstta ) ; ___( psttp1 ) ; }
                                //A:ASSUME: DELIMITED COMMENTS ("/*...*/") ARE NOT NESTED (BUT THEY MAY CONTAIN // COMMENTS)

                                //
                                // SET CURSOR TO NEXT STROKE
                                // SNIP TO "*/"
                                // INSPECT (LEVEL 1)
                                // SNIP TO "/*"
                                //
                                // RECIPE
                            {
                            while( idf1 )
                            boolT  bInspect1 = 1 ;
                            countT idf1 = 1 ;
                            strokeS sttq1( 0 , sc_IGNOREqUOTES ) ;
                            ZE( strokeS* , psttp1 ) ; // "p":"PIECE"
            
                            etThread.strReverseF( tinP , pstta , 0 , T("\r\n") ) ; ___( pstta ) ;
                            etThread.delF( tinP , posta ) ;
                            etThread.strMakeF( tinP , pstta , T(posta) ) ; ___( pstta ) ;
                            ZE( strokeS* , pstta ) ;
                        
                            etThread.boxGetShadowF( tinP , posta , costa , pInfo->psttIfoName ) ; ___( posta ) ;
                        
                            ZE( countT , costa ) ;
                            ZE( osTextT* , posta ) ;
                        {
                        
                        if( !( cDo % 0x10 ) ) { CONoUTrAW3( "\r               \rcDo: " , cDo , "\r" ) ; }
                    {
                    if( pInfo && !( F(pInfo->flags) & flFILEaTTR_DIRECTORY ) && !etThread.strIdF( tinP , tAsm , pInfo->psttIfoName ) )
                    tinP.pEtScratch->diskFindFileOrDirOldF( tinP , pInfo , hFind , *pptLike[ offl ] ) ; ___( pInfo ) ;
                    ZE( infoFileS* , pInfo ) ;
                    cDo -- ;
                {
                do
                handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {
            for( countT offl = 0 ; !ether && offl < sizeof pptLike / sizeof pptLike[ 0 ] ; offl ++ )
            CONoUTrAW3( "\rcDo: " , cDo , "\r\n" ) ;
            
            TN( tnc     , "nonconformant:    " ) ;
            TN( tb8     , "        " ) ;
            TN( tcr     , "\r\n" ) ;
            TN( tb      , " " ) ;
            TN( tParens , "()" ) ;

            }
                }
                    st_psttBos << pstts ;
                    etThread.strMakeFromOsTextF( tinP , pstts , ppostSmall[ offi ] ) ; ___( pstts ) ;
                    ZE( strokeS* , pstts ) ;
                {
                for( countT offi = 0 ; offi < sizeof ppostSmall / sizeof ppostSmall[ 0 ] ; offi ++ )
            
                } ;
                    "BOSmEASURE04nOtIN(" ,
                    "BOSnOtIN("          ,
                    "BOSmEASURE04("      ,
                    "BOSnOvALUEnOtIN("   ,
                    "BOSnOvALUE("        ,
                    "BOSdOnOTtEST("      ,
                    "BOSrAW("            ,
                    "BOSfICKLE("         ,
                    "BOSSO("             ,
                    "BOSI("              ,
                    "BOSS("              ,
                    "BOS("               ,
                {
                osTextT* ppostSmall[] =         // THE MOST COMMON VALUES SHOULD BE EARLIEST IN THIS ARRAY
            {
            stackC st_psttBos( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

            TN( tDoubleQuote , "\"" ) ;
            TN( tSlashSlash , "//" ) ;
            TN( tStarSlash  , "*/" ) ;
            TN( tSlashStar  , "/*" ) ;
        {
        case 3 : // VALIDATE ALL FUNCTION IDENTIFIERS IN FUNCTION CALLS
        }
            break ;

            }
                while( ~hFind && !ether ) ;
                }
                    DEL( pInfo ) ;
                    }
                        }
                            etThread.delF( tinP , pstta ) ;
                            }
                                bInspect = !bInspect ;
            
                                etThread.delF( tinP , psttp ) ;
                                }
                                    }
                                        etThread.delF( tinP , pstt1Lines ) ;
                                        }
                                            etThread.delF( tinP , psttf ) ;
                                            }
                                                }
                                                    etThread.delF( tinP , psttn ) ;
                                                    ++ swIgnore ;
                                                    psttLever = psttn ;
                                                    //etThread.strokeF( tinP , T("member: \"")+T(psttn)+T("\"\r\n") ) ;
                                                    etThread.strSubstringF( tinP , psttn , idIdentifier , idIdentifierLath , psttf ) ; ___( psttn ) ;
                                                    ZE( strokeS* , psttn ) ;
                                                {
                                                if( bParen )

                                                }
                                                    bParen = idn && psttn[ CSpREFIX - 1 + idn ].idAdam == '(' ;
                                                    if( idn > psttn->idAdam ) idn = 0 ;
                                                    while( idn && psttn[ CSpREFIX - 1 + idn ].idAdam == ' ' && idn <= psttn->idAdam ) idn ++ ;
                                                    countT idn = 1 ;
                                                    NEXTsTRING( psttn ) ;
                                                    strokeS* psttn = psttc1 ;
                                                {
                                                if( !bParen && !idf && !BlATHsTRING( 1 ) )
                                                boolT bParen = idf && psttf[ CSpREFIX - 1 + idf ].idAdam == '(' ;

                                                if( idf > psttf->idAdam ) idf = 0 ;
                                                while( idf && psttf[ CSpREFIX - 1 + idf ].idAdam == ' ' && idf <= psttf->idAdam ) idf ++ ;

                                                countT idIdentifierLath = idf ? idf - 1 : 0 ;
                                            {
                                            if( idIdentifier && idIdentifier == idNonblank ) // IF THE WOTH NONBLANK IS THE BEGINNING OF AN IDENTIFIER

                                            countT idIdentifier = etThread.strIdAnyF( tinP , idf , sttq , psttOk2 , psttf ) ;
                                            idf = 1 ;
                                            countT idNonblank = etThread.strIdAnyF( tinP , idf , sttq , tb , psttf , 0 , 1 , flSTRiDaNY_NOT ) ;
                                            countT idf = 1 ;
    
                                            filterF( tinP , etThread , psttf , psttc1 , psttOk1 ) ; ___( psttf ) ;
                                            ZE( strokeS* , psttf ) ;
                                        {
                                        FORsTRINGSiN1( pstt1Lines )

                                        etThread.strWordsF( tinP , pstt1Lines , psttp , sttq , tcr ) ; ___( pstt1Lines ) ;
                                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                        ZE( strokeS* , pstt1Lines ) ;

                                        // 
                                        //    REGISTER THE IDENTIFIER INTO swIgnore
                                        //   IF THE WOTH NONBLANK AFTER THE IDENTIFIER IS '('
                                        //  IF THE IDENTIFIER BEGINS AT THE WOTH NONBLANK
                                        //  FIND THE WOTH IDENTIFIER
                                        //  FIND THE WOTH NONBLANK
                                        //  FILTER
                                        // FOR EACH LINE
                                        // 
                                        // RECIPE
            
                                        // IDENTIFIER: [a-z,A-Z,0-9,_,#]+
                                        // IGNORE < 02 OR > f7 (THIS IS DONE BY FILTERING THEM OUT OF psttc1)
                                        // 
                                        // DEFININTIONS
                                    {
                                    if( bInspect )
                                {
                                if( psttp )
            
                                }
                                    }
                                        if( idf2 <= idl2 ) { etThread.strSubstringF( tinP , psttp , idf2 , idl2 , pstta ) ; ___( psttp ) ; } // WILL BE FALSE IF "BOS()"
                                        countT idf2 = save ;
                                        countT idl2 = idHit - 1 ;
                                    {
                                    if( idHit )
            
                                    }
                                        }
                                            }
                                                }
                                                    break ;
                                                    idHit = idClose ;
                                                    bFound = 1 ;
                                                {
                                                else if( !( -- offNest ) ) //A:ASSUME: NO VALUE IN st_psttCurlyClose EXISTS IN st_psttCurlyOpen AND VICE VERSA
                                                }
                                                    idf = save3 ;
                                                    ++ offNest ;
                                                {
                                                if( idOpen < idClose )
                                            {
                                            if( idOpen || idClose )

                                            countT idClose = etThread.strIdF( tinP , idf , sttq , st_psttCurlyClose , countTC() , pstta ) ;
                                            idf = save2 ;
                                            countT save3 = idf ;
                                            countT idOpen = etThread.strIdF( tinP , idf , sttq , st_psttCurlyOpen , countTC() , pstta ) ;
                                            countT save2 = idf ;
                                        {
                                        while( idf )
                                        ZE( boolT , bFound ) ;
                                    {
                                    ZE( countT , idHit ) ;
                                    countT save = idf ;
                                    countT offNest = 1 ; // st_psttCurlyOpen ENDS WITH '{'.  I AM LOOKING FOR THE MATCHING '}'
                                {
                                else
                                if( bInspect ) { etThread.strSubstringF( tinP , psttp , idf , sttq , st_psttCurlyOpen , countTC() , pstta ) ; ___( psttp ) ; }
                            {
                            while( idf )
                            boolT  bInspect = 1 ;
                            countT idf = 1 ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                            ZE( strokeS* , psttp ) ; // "p":"PIECE"
            
                            //
                            // SET CURSOR TO NEXT STROKE
                            // SNIP TO MATCHING "}"
                            // INSPECT
                            // SNIP TO "{"
                            //
                            // RECIPE
            
                            etThread.strReverseF( tinP , pstta , 0 , T("\r\n") ) ; ___( pstta ) ;
                            etThread.delF( tinP , posta ) ;
                            etThread.strMakeF( tinP , pstta , T(posta) ) ; ___( pstta ) ;
                            ZE( strokeS* , pstta ) ;
                        
                            etThread.boxGetShadowF( tinP , posta , costa , pInfo->psttIfoName ) ; ___( posta ) ;
                        
                            ZE( countT , costa ) ;
                            ZE( osTextT* , posta ) ;
                        {
                        
                        if( !( cDo % 0x10 ) ) { CONoUTrAW3( "\r               \rcDo: " , cDo , "\r" ) ; }
                    {
                    if( pInfo && !( F(pInfo->flags) & flFILEaTTR_DIRECTORY ) && !etThread.strIdF( tinP , tAsm , pInfo->psttIfoName ) )
                    tinP.pEtScratch->diskFindFileOrDirOldF( tinP , pInfo , hFind , *pptLike[ offl ] ) ; ___( pInfo ) ;
                    ZE( infoFileS* , pInfo ) ;
                    cDo -- ;
                {
                do
                handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {
            for( countT offl = 0 ; !ether && offl < sizeof pptLike / sizeof pptLike[ 0 ] ; offl ++ )
            CONoUTrAW3( "\rcDo: " , cDo , "\r\n" ) ;

            }
                }
                    st_psttCurlyClose << pstts1 ;
                    etThread.strMakeFromOsTextF( tinP , pstts1 , ppostSmall[ offi ] ) ; ___( pstts1 ) ;
                    ZE( strokeS* , pstts1 ) ;
                {
                for( countT offi = 0 ; offi < sizeof ppostSmall / sizeof ppostSmall[ 0 ] ; offi ++ )
            
                } ;
                    "STATEpART3"        ,
                    "}"                 ,
                {
                osTextT* ppostSmall[] =         // THE MOST COMMON VALUES SHOULD BE EARLIEST IN THIS ARRAY
            {
            }
                }
                    st_psttCurlyOpen << pstts1 ;
                    etThread.strMakeFromOsTextF( tinP , pstts1 , ppostSmall[ offi ] ) ; ___( pstts1 ) ;
                    ZE( strokeS* , pstts1 ) ;
                {
                for( countT offi = 0 ; offi < sizeof ppostSmall / sizeof ppostSmall[ 0 ] ; offi ++ )
            
                } ;
                    "STATEpART1"        ,
                    "{"                 ,
                {
                osTextT* ppostSmall[] =         // THE MOST COMMON VALUES SHOULD BE EARLIEST IN THIS ARRAY
            {
            stackC st_psttCurlyClose( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
            stackC st_psttCurlyOpen(  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
            
            TN( tb8     , "        " ) ;
            TN( tb      , " " ) ;
            TN( tcr     , "\r\n" ) ;
        {
        case 2 : // LIST ALL DATA MEMBERS THAT HAVE CONSTRUCTORS
        }
            break ;

            }
                while( ~hFind && !ether ) ;
                }
                    DEL( pInfo ) ;
                    }
                        }
                            etThread.delF( tinP , pstta ) ;
                            }
                                }
                                    }
                                        }
                                            etThread.delF( tinP , psttm ) ;
                                            ++ swIgnore ;
                                            psttLever = psttm ;
                                            //etThread.strokeF( tinP , T("macro: \"")+T(psttm)+T("\"\r\n") ) ;

                                            etThread.strSubstringF( tinP , psttm , idfName , idlName , pstta ) ; ___( psttm ) ;
                                            ZE( strokeS* , psttm ) ;
                                            countT idfName = idHit ;
                                        {
                                        //if( idf && pstta[ CSpREFIX - 1 + idf ].idAdam == '(' )

                                        //if( idf > pstta->idAdam ) idf = 0 ;
                                        //while( idf && pstta[ CSpREFIX - 1 + idf ].idAdam == ' ' && idf <= pstta->idAdam ) idf ++ ;
                                        countT idlName = idf - 1 ;
                                    {
                                    if( idHit && idf )

                                    countT idHit = etThread.strIdAnyF( tinP , idf , sttq , psttOk2 , pstta ) ;
                                {
                                if( idf )

                                }
                                    else if( idf2 ) idf = idf2 ;
                                    else if( idf1 ) idf = idf1 ;
                                    }
                                        ;
                                            : idf2
                                            ? idf1
                                        idf = idf1 <= idf2
                                    {
                                    if( idf1 && idf2 )

                                    countT idf2   = idf ;
                                    countT idHit2 = etThread.strIdF( tinP , idf , sttqde2 , tTypedef , pstta ) ;
                                    strokeS sttqde2 ;
                                    idf = save ;

                                    countT idf1   = idf ;
                                    countT idHit1 = etThread.strIdF( tinP , idf , sttqde1 , tDefine , pstta ) ;
                                    strokeS sttqde1 ;
                                    countT save = idf ;
                                {
                                ZE( boolT , bArm )
                            {
                            while( idf )
                            countT idf = 1 ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

                            // THIS CODE HAS BEEN EDITED TO REGISTER ALL SYMBOLIC CONSTANTS, NOT JUST MACROS; THIS IS BECAUSE A SYMBOLIC CONSTANT MIGHT BE FOLLOWED BY AN OPEN PAREN.  IT IS SAFE TO IGNORE SYMBOLIC CONSTANTS BECAUSE THEY WON'T BE THIRD PARTY IDENTIFIERS            
                            //
                            // IF THE WOTH NONBLANK STROKE AFTER THE SYMBOL IS '(' THEN REMEMBER THE SYMBOL (BLANKS ARE IGNORED BECAUSE I SEE "#define FOO ( 2 + 3 ) AS A POSSIBLE FUNCTION CALL SO WILL COMPLAIN IF FOO IS NOT LISTED IN swIgnore)
                            // FIND THE NEXT SYMBOL
                            // FIND THE NEXT "#define" OR "typedef"
                            //
                            // RECIPE
            
                            etThread.strReverseF( tinP , pstta , 0 , T("\r\n") ) ; ___( pstta ) ;
                            etThread.delF( tinP , posta ) ;
                            etThread.strMakeF( tinP , pstta , T(posta) ) ; ___( pstta ) ;
                            ZE( strokeS* , pstta ) ;
                        
                            etThread.boxGetShadowF( tinP , posta , costa , pInfo->psttIfoName ) ; ___( posta ) ;
                        
                            ZE( countT , costa ) ;
                            ZE( osTextT* , posta ) ;
                        {
                        
                        if( !( cDo % 0x10 ) ) { CONoUTrAW3( "\r               \rcDo: " , cDo , "\r" ) ; }
                    {
                    if( pInfo && !( F(pInfo->flags) & flFILEaTTR_DIRECTORY ) && !etThread.strIdF( tinP , tAsm , pInfo->psttIfoName ) )
                    tinP.pEtScratch->diskFindFileOrDirOldF( tinP , pInfo , hFind , *pptLike[ offl ] ) ; ___( pInfo ) ;
                    ZE( infoFileS* , pInfo ) ;
                    cDo -- ;
                {
                do
                handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {
            for( countT offl = 0 ; !ether && offl < sizeof pptLike / sizeof pptLike[ 0 ] ; offl ++ )
            CONoUTrAW3( "\rcDo: " , cDo , "\r\n" ) ;
            
            TN( tcr     , "\r\n" ) ;
        {
        case 1 : // LIST ALL PRECOMPILATION MACROS
    {
    switch( idPass )
    countT cDoSave = cDo ;
{
while( ++ idPass <= 3 )
TN( tAsm              , "3func.31000" ) ;
TN( tDefine           , "#define" ) ;
TN( tTypedef          , "typedef" ) ; // EXAMPLE OF CODE THAT MUST PASS: extern "C" typedef LRESULT (OSF */*ff*/osWindowMessageHandlerFT/*ff*/)( HWND hWindowP , UINT idCmdP , WPARAM p1P , LPARAM p2P ) ; /*ff*//**//*ff*/

}
    }
        ++ swIgnore ;
        psttLever = ti ;
        TN( ti , ppostIgnore[ offi ] ) ;
    {
    for( countT offi = 0 ; offi < sizeof ppostIgnore / sizeof ppostIgnore[ 0 ] ; offi ++ )

    ;
    }
        "WINDOWrEFERENCEeND"    ,
        "WINDOWrEFERENCEbEGIN"  ,
        "Wo"                    ,
        // MACROS THAT ARE NO LONGER DEFINED

        "rod"                   ,
        "f2"                    ,
        "ab"                    ,
        "ae"                    ,
        "ah"                    ,
        "sz"                    ,
        "sy"                    ,
        "sx"                    ,
        "oz"                    ,
        "oy"                    ,
        "ox"                    ,
        "cy"                    ,
        "cx"                    ,
        "viewee"                ,
        "ro"                    ,
        "rgb"                   ,
        "pswUrlReferenced"      ,
        "psttTail"              ,
        "psttHead"              ,
        "psttFile"              ,
        "pSpacec"               ,
        "pSpace"                ,
        "pSgnAllDone"           ,
        "pPulp"                 ,
        "ppsttLever"            ,
        "pPel"                  ,
        "postzIdSerialSpace"    ,
        "pNext"                 ,
        "pmmResult"             ,
        "pmm"                   ,
        "pListingValue"         ,
        "period"                ,
        "pczValue"              ,
        "pcPending"             ,
        "pbzValue"              ,
        "pBool_listingC_ptr_ok" ,
        "pBool_listingC_ptr_no" ,
        "pBool_countTstrz_ok"   ,
        "pBool_countTstrz_no"   ,
        "pBool_countT_ok"       ,
        "pBool_countT_no"       ,
        "pBool_blob_ok"         ,
        "pBool_blob_no"         ,
        "instance"              ,
        "idPlate"               ,
        "idGroup"               ,
        "footFinger2"           ,
        "footFinger1"           ,
        "flagsTypeMask"         ,
        "flags"                 ,
        "finger"                ,
        "cValue"                ,
        "cRows"                 ,
        "cRef"                  ,
        "countdown"             ,
        "cNestMax"              ,
        "cKeep"                 ,
        "cbzValue"              ,
        "cba"                   ,
        // OBJECTS THAT ARE CONSTRUCTED BY INLINE CONSTRUCTORS (SO ARE WITHIN CURLY BRACKETS) ; U:: DEVELOP MY PARSING SO THAT I SEE THE "struct" "class" "union" KEYWORDS SO RECOGNIZE THE CONTAINING CURLY BRACKET BLOCK AS A CLASS DEFINITION RATHER THAN AS A FUNCTION DEFINITION

        "stx"               ,
        "sws"               ,
        "swsg"              ,
        "swv"               ,
        "v14"               ,
        "stIdPort"              ,
        "stn"               ,
        "stNnPrivate1A"             ,
        "stNnPrivate1B"             ,
        "stNnPrivate2A"             ,
        "stNnPrivate2B"             ,
        "stNodeHisList"             ,
        "stNodeSlander"             ,
        "stOsTidLooped"             ,
        "stIdMe" ,
        "stFoo"                 ,
        "stack"                 ,
        "st2"                   ,
        "st_ST_osTidMessiah"    ,
        "st_ST_osTidPseudoBelieving"                ,
        "st_ST_osTidPseudoSleeping"             ,
        "st_ST_osTidSleeping"               ,
        "map"                   ,
        "hetero"                ,
        "dict"                  ,
        "coder"                 ,
        "maybe"                 ,
        "found"                 ,
        "stzListed"             ,
        "stWanted"              ,
        "inv"                   ,
        "raw"                   ,
        "tra"                   ,
        "rslt"                  ,
        "mm"                    ,
        "stOkCard"              ,
        "stOkBuy"               ,
        "stRelayAbsent5"        ,
        "stRelayAbsent4"        ,
        "stRelayAbsent3"        ,
        "stRelayAbsent2"        ,
        "stRelayAbsent1"        ,
        "sqmrt"                 ,
        "sqmrv"                 ,
        "sqmrh"                 ,
        "sqmr2"                 ,
        "sqmr"                  ,
        "vStep"                 ,
        "vSpecPod"              ,
        "vSpecAbs"              ,
        "vSpecPodAft"           ,
        "vSpecPodHorProj"       ,
        "vNow"                  ,
        "vEye"                  ,
        "vTmp"                  ,
        "vLag"                  ,
        "vNext"                 ,
        "PUSE"                  ,
        "mapSoulItem"           ,
        "aabbccdd"              ,
        "aa"                    ,
        // OBJECTS THAT SUPPORT OPERATOR CALL

        "foo"                   ,
        // INSTANCES OF UNNAMED CLASSES

        ""                      ,
        "THREADmODE2rESTORE"                      ,
        "SCOOPS"                      ,
        "SCOOPS"                      ,
        "TINSL"                 ,
        "STRiDf_OR_sTRiDaNYf"   ,
        "_IO_"                  ,   // CAN BE FOLLOWED BY '(' AT THE BEGINNING OF THE NEXT STATEMENT.  SEE 3func.35002100.etherC.loafIF
        // IPDOS SYMBOLS THAT ARE FOLLOWED BY SPACES AND THEN AN OPEN PARENTHESIS
        //U::EDIT ME TO ELIMINATE THE NEED TO LIST HERE WHEN THE OPEN PAREN IS ON ANOTHER LINE

        "FileTimeToSystemTime"  ,
        "setTimeout"            ,
        "clearTimeout"          ,
        // JAVASCRIPT FUNCTIONS

        "else"                  ,
        "case"                  ,
        "delete"                ,
        "operator"              ,
        "switch"                ,
        "sizeof"                ,
        "for"                   ,
        "while"                 ,
        "return"                ,
        "new"                   ,
        "if"                    ,
        "defined"               ,
        // C++ KEYWORDS

        "matherr"               ,
        "WinMain"               ,
        "main"                  ,
        // TRUE NONCONFORMANT IPDOS (tm) FUNCTION IDENTIFIERS

        // FOR DEBUGGING (IN PRODUCTION, NOTHING SHOULD APPEAR IMMEDIATELY AFTER THIS LINE)
    {
    osTextT* ppostIgnore[] =
{

switchC swIgnore( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttLever ) ;
ZE( strokeS* , psttLever ) ;
ZE( countT , idPass ) ;
            
}
    for( countT vv = min5 ; vv <= max5 ; vv ++ ) etThread.strFuseF( tinP , psttOk2 , strokeS( vv ) ) ;
    for( countT vv = min4 ; vv <= max4 ; vv ++ ) etThread.strFuseF( tinP , psttOk2 , strokeS( vv ) ) ;
    for( countT vv = min3 ; vv <= max3 ; vv ++ ) etThread.strFuseF( tinP , psttOk2 , strokeS( vv ) ) ;
    for( countT vv = min2 ; vv <= max2 ; vv ++ ) etThread.strFuseF( tinP , psttOk2 , strokeS( vv ) ) ;
    for( countT vv = min1 ; vv <= max1 ; vv ++ ) etThread.strFuseF( tinP , psttOk2 , strokeS( vv ) ) ;
    etThread.strMakeF( tinP , psttOk2 , 0 , max1 - min1 + max2 - min2 + max3 - min3 + max4 - min4 + max5 - min5 + 5 ) ; ___( psttOk2 ) ;
    countT max5 = '#' ;
    countT min5 = '#' ; // TO TREAT "postNameP##_footFinger1" AS AN IDENTIFIER FOR VALIDATION PURPOSES ; SEE 1snip.1120024e.FOOTMiNIT
    countT max4 = '_' ;
    countT min4 = '_' ;
    countT max3 = '9' ;
    countT min3 = '0' ;
    countT max2 = 'Z' ;
    countT min2 = 'A' ;
    countT max1 = 'z' ;
    countT min1 = 'a' ;
{
ZE( strokeS* , psttOk2 ) ;
            
}
    for( countT vv = min ; vv <= max ; vv ++ ) etThread.strFuseF( tinP , psttOk1 , strokeS( vv ) ) ;
    etThread.strMakeF( tinP , psttOk1 , 0 , max - min + 1 ) ; ___( psttOk1 ) ;
    countT max = 0x7f ;
    countT min = 0x20 ;
{
ZE( strokeS* , psttOk1 ) ;

}
    while( ~hFind && !ether ) ; //U:: BUG: NEED TO CALL WITHIN LOOP: diskFindFileOrDirOldF
    }
        DEL( pInfo ) ;
        }
            if( !( cDo % 0x10 ) ) { CONoUTrAW3( "\r               \rcDo: " , cDo , "\r" ) ; }
            cDo ++ ;
        {
        if( pInfo && !( F(pInfo->flags) & flFILEaTTR_DIRECTORY ) )
        tinP.pEtScratch->diskFindFileOrDirOldF( tinP , pInfo , hFind , *pptLike[ offl ] ) ; ___( pInfo ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
{
for( countT offl = 0 ; !ether && offl < sizeof pptLike / sizeof pptLike[ 0 ] ; offl ++ )
CONoUTrAW3( "\r\n               \rcDo: " , cDo , "\r" ) ;
ZE( countT , cDo ) ;

#endif

    textC* pptLike[] = { &tLike1 , &tLike2 , &tLike3 , &tLike4 , &tLike5 , &tLike6 /*, &tLikeT*/ } ;
    //TN( tLikeT , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/9test.foo" ) ;
    TN( tLike6 , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/5adam.*" ) ;
    TN( tLike5 , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/4boot.*" ) ;
    TN( tLike4 , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.*" ) ;
    TN( tLike3 , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/2glob.*" ) ;
    TN( tLike2 , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.*" ) ;
    TN( tLike1 , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/0*" ) ;

#else

    textC* pptLike[] = { &tLikeT } ;
    TN( tLikeT , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/9test.foo" ) ;
    //TN( tLikeT , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/*.NEWdELtYPEtHIRD" ) ;
    //TN( tLikeT , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.11200321.POSThTMLhEAD" ) ;
    //TN( tLikeT , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.11200029.__1" ) ;
    //TN( tLikeT , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.19000008.idcWINcASES" ) ;
    //TN( tLikeT , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.1120024e.FOOTMiNIT" ) ;
    //TN( tLikeT , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.32000001.debugF" ) ;

#if defined( NEVERdEFINED )

CONoUTrAW( "LINT\r\n" ) ;

TODO

}
    }
        }
            if( idf ) etherP.strFuseF( tinP , psttP , tb ) ;

            idf = save ;
            etherP.delF( tinP , psttp ) ;
            etherP.strFuseF( tinP , psttP , psttp ) ;
            etherP.strSubstringF( tinP , psttp , idf , idl , psttRawP ) ; ___( psttp ) ;
            ZE( strokeS* , psttp ) ;
            idf = idHit ;
            countT idl = idf ? idf - 1 : 0 ;
            countT save = idf ;
        {
        if( idHit )
        countT idHit = etherP.strIdAnyF( tinP , idf , sttq , psttOkP , psttRawP , 0 , 1 , bNotP ? flSTRiDaNY_NOT : flSTRiDaNY_null ) ;
    {
    while( idf )
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    countT idf = 1 ;
    TN( tb , " " ) ;

    etherP.strMakeF( tinP , psttP , 0 , psttRawP->idAdam ) ; ___( psttP ) ; //U::O: IF psttRawP IS LONG, MAKE OO PASSES TO AVOID ALLOCATING MORE THAN I NEED
{
voidT filterF( tinS& tinP , etherC& etherP , strokeS*& psttP , const strokeS* psttRawP , const strokeS* psttOkP , const boolT bNotP = 0 )

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_LINT" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

