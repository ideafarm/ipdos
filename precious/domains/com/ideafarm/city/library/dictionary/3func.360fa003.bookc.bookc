
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //}
    //    LOGrAW(   ostoSay ) ;
    //    OStEXTAK( ostoSay , "\r\n" ) ;
    //    OStEXTA(  ostoSay , postP ) ;
    //    OStEXTAK( ostoSay ,"    " ) ;
    //    OStEXTC(  ostoSay , this , '0' ) ;
    //    OStEXTAK( ostoSay , "bookC: ++ " ) ;
    //    OStEXT(   ostoSay , TUCK << 2 ) ;
    //{

    // if( tinP.pEther ) tinP.pEther->trace F( tinP , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": bookC constructed") ) ; //U:: TO FIND A BUG

    // }
    //     tinP.pEther->trace F( tinP , (const strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
    //     //OStEXTAK( ostoSay , "\"" ) ;
    //     OStEXTA(  ostoSay , postFileName + offset ) ;
    //     //OStEXTAK( ostoSay , "    \"" ) ;
    //     //OStEXTCF( ostoSay , pHead->cbBody , '0' ) ;
    //     //OStEXTAK( ostoSay , "    " ) ;
    //     //OStEXTCF( ostoSay , pbBody , '0' ) ;
    //     //OStEXTAK( ostoSay , "    " ) ;
    //     //OStEXTCF( ostoSay , this , '0' ) ;
    //     OStEXTAK( ostoSay , " bookC CT"/*" [this,pbBody,cbBody,postFile]"*/": " ) ;
    //     OStEXT(   ostoSay , TUCK << 3 ) ;
    // 
    //     ;
    //         : 0
    //         ? sizeof postPrefix - 1
    //     countT offset = postFileName == thirdC::c_strstrIF( tinP , postFileName , postPrefix )
    // 
    //     #endif
    //         static osTextT postPrefix[] = "d:\\ideafarm.home.1\\ephemeral\\backed.up.daily\\domains\\com\\ideafarm\\ipdos\\memorySpaces\\Wo'O Ideafarm\\4\\stateSpaces\\0000ffff\\" ;
    //     #else
    //         static osTextT postPrefix[] = "d:\\ideafarm.home.1\\ephemeral\\backed.up.daily\\domains\\com\\ideafarm\\ipdos\\memorySpaces\\Wo'O Ideafarm\\4\\stateSpaces\\0000ffff\\" ;
    //     #if defined( HOMEdRIVEiS_i )
    // {
    // //if( tinP.pEther )
    // if( postFileName && thirdC::c_strstrIF( tinP , postFileName , ".putfileif.s.out." ) )
    // const osTextT* postFileName = *(fileC*)pbFile ;
    //TO FIND A BUG

    if( !bMemoryExisted ) napkin.formattingIsDoneF( tinP ) ;

    provisionF( tinP , napkin , napkin , flagsProvision , bFillP ) ;

    if( F(flagsCt) & flBOOKc_PRIORbOOKnOTcONTINUEDhERE ) flagsProvision |= flBOOK0pROVISION_PRIORbOOKnOTcONTINUEDhERE ;
    if( F(flagsCt) & flBOOKc_RESETcREFoNcT             ) flagsProvision |= flBOOK0pROVISION_RESETcREFoNcT             ;      //20180816@1339: ADDED WITHOUT ANALYSIS OTHER THAN TO NOTICE THAT flBOOKc_RESETcREFoNcT IS NOWHERE ELSE INSPECTED
    if( F(flagsCt) & flBOOKc_DOnOTiNITIALIZEdATA       ) flagsProvision |= flBOOK0pROVISION_DOnOTiNITIALIZE           ;
    flagsT flagsProvision = !bMemoryExisted && !bFileExisted ? flBOOK0pROVISION_FORMAT : flBOOK0pROVISION_null ;

    boolT bMemoryExisted = F(napkin.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ;

    napkinC& napkin = *(napkinC*)pbNapkin ;
    }
        ) ;
            idMemorySpaceP
            - 1 ,
            ) ,
                | ( F(flagsP) & flBOOKc_DOnOTsERIALIZEnAPKIN    ? flNAPKINc_DOnOTsERIALIZEcT        : flNAPKINc_null )
                | ( F(flagsP) & flBOOKc_LOCK                    ? flNAPKINc_LOCK                    : flNAPKINc_null )
                  ( F(flagsP) & flBOOKc_USEgRABuNIVERSEoVERRIDE ? flNAPKINc_USEgRABuNIVERSEoVERRIDE : flNAPKINc_null )
            (
            ifcOPENsHAREDmEMORYhOW_nCeO ,
            sizeof( bookHeadS ) + cbP ,
            ) ,
                    : (const handleC*)*(fileC*)pbFile
                    ? 0
                !idStateSpaceP
            (
            ostoBuf ,
            pbBitsCtP ,
            idiFileCtP ,
            idLineCtP ,
            tinP ,
        (
        new( 0 , tinP , pbNapkin , sizeof pbNapkin ) napkinC

        }
            OStEXTC(  ostoBuf , idStateSpaceP , '0' ) ;
            OStEXTAK( ostoBuf , "." ) ;
        {
        if( idStateSpaceP )                                 // APPENDING idStateSpaceP ENSURES THAT SHARED MEMORY NAME IS DISTINCT FOR EACH BACKING FILE; ADDED 20190104@1712 WITHOUT ANALYSIS
        OStEXTA(  ostoBuf , postP ) ;
        OStEXTAK( ostoBuf , "book0C/" ) ;
        OStEXT(   ostoBuf , TUCK << 2 ) ;
    {

    }
        }
            }
                }
                    if( !cbP ) cbP = info.cbUsed - sizeof( napkinHeaderS ) - sizeof( bookHeadS ) ;

                    if( cbP && cbP != info.cbUsed - sizeof( napkinHeaderS ) - sizeof( bookHeadS ) ) { BLAMMO ; }
                {
                //if( cbHead == sizeof head && info.cbUsed == sizeof head + head.cbBody )
            
                //thirdC::dosReadIF( tinP , (byteT*)&head , cbHead , (const handleC&)file ) ;
                //countT cbHead = sizeof head ;
                //bookHeadS head ;
            {
            if( info.cbUsed >= sizeof( napkinHeaderS ) + sizeof( bookHeadS ) )

            thirdC::dosQueryFileInfoIF( tinP , pInfo , file ) ;
            infoFileS* pInfo = &info ;
            infoFileS info( tinP ) ;
        {
        //if( bFileExisted )

        bFileExisted = file.idOpenResultF( tinP  ) == ifcOPENrESULT_EXISTED ;

        fileC& file = *(fileC*)pbFile ;
        ctFileF( tinP , postP , idStateSpaceP , idMemorySpaceP ) ;
    {
    if( idStateSpaceP )
    ZE( boolT  , bFileExisted ) ;
    
    }
        }
            countT foo = 2 ;
        {
        if( idIn > 0x1000 )
        countT idIn = 1 + incv02AM( idInLath ) ;
        static countT idInLath ;
    {
    if( postP && thirdC::c_strstrIF( tinP , postP , ".soul.reports." ) ) //U::20141002@0549: TO FIND A BUG

    // if( tinP.pEther ) tinP.pEther->trace F( tinP , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": bookC constructing") ) ; //U:: TO FIND A BUG

    //}
    //    CONoUTrAW(   ostoSay ) ;
    //    OStEXTAK( ostoSay , "\r\n" ) ;
    //    OStEXTA(  ostoSay , postP ) ;
    //    OStEXTAK( ostoSay ,"    " ) ;
    //    OStEXTC(  ostoSay , this , '0' ) ;
    //    OStEXTAK( ostoSay , "bookC: +  " ) ;
    //    OStEXT(   ostoSay , TUCK << 2 ) ;
    //{

    _IO_

}
    }
        if( POOP ) return ;
        __( idMemorySpaceP && !( F(tinP.flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tinP ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tinP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        __( !*postP ) ;
        if( POOP ) return ;
        __( cbP && !( F(flagsCt) & flBOOKc_WRITER ) ) ;
        __( F(flagsP) & flBOOKc_FILEiScONSTRUCTED ) ; //THIS FLAG IS FOR INTERNAL USE ONLY; CALLER MAY NOT SPECIFY IT
        __( F(flagsP) & flBOOKc_NOsTATEsPACE      ) ; //THIS FLAG IS FOR INTERNAL USE ONLY; CALLER MAY NOT SPECIFY IT (IT IS IMPLIED BY !idStateSpaceP)
        FV( flBOOKc , flagsP ) ;
        __Z( postP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    

    _IO_        //U::TO FIND A BUG
{
{
)
        : flagsP | flBOOKc_NOsTATEsPACE
        ? flagsP
    idStateSpaceP
(
flagsCt
book0C( tinP , 0 , 0 ) ,
/*1*/bookC::bookC( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postP , const countT idStateSpaceP , const flagsT flagsP , countT cbP , const byteT bFillP , const countT idMemorySpaceP ) :/*1*/

/**/
*/
 idMemorySpaceP
 bFillP
 cbP
 flagsP
 idStateSpaceP
 postP
 pbBitsCtP
 idiFileCtP
 idLineCtP
 tinP
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

