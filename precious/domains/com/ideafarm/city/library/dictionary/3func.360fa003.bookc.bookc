
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //}
    //    LOGrAW(   ostoSay ) ;
    //    OStEXTAK( ostoSay , "\r\n" ) ;
    //    OStEXTA(  ostoSay , postP ) ;
    //    OStEXTAK( ostoSay ,"    " ) ;
    //    OStEXTC(  ostoSay , this , '0' ) ;
    //    OStEXTAK( ostoSay , "bookC: ++ " ) ;
    //    OStEXT(   ostoSay , TUCK << 2 ) ;
    //{

    // if( tinP.pEther ) tinP.pEther->trace F( tinP , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": bookC constructed") ) ; //U:: TO FIND A BUG

    // }
    //     tinP.pEther->trace F( tinP , (const strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
    //     //OStEXTAK( ostoSay , "\"" ) ;
    //     OStEXTA(  ostoSay , postFileName + offset ) ;
    //     //OStEXTAK( ostoSay , "    \"" ) ;
    //     //OStEXTCF( ostoSay , pHead->cbBody , '0' ) ;
    //     //OStEXTAK( ostoSay , "    " ) ;
    //     //OStEXTCF( ostoSay , pbBody , '0' ) ;
    //     //OStEXTAK( ostoSay , "    " ) ;
    //     //OStEXTCF( ostoSay , this , '0' ) ;
    //     OStEXTAK( ostoSay , " bookC CT"/*" [this,pbBody,cbBody,postFile]"*/": " ) ;
    //     OStEXT(   ostoSay , TUCK << 3 ) ;
    // 
    //     ;
    //         : 0
    //         ? sizeof postPrefix - 1
    //     countT offset = postFileName == thirdC::c_strstrIF( tinP , postFileName , postPrefix )
    // 
    //     #endif
    //         static osTextT postPrefix[] = "d:\\ideafarm.home.1\\ephemeral\\backed.up.daily\\domains\\com\\ideafarm\\ipdos\\memorySpaces\\Wo'O Ideafarm\\4\\stateSpaces\\0000ffff\\" ;
    //     #else
    //         static osTextT postPrefix[] = "d:\\ideafarm.home.1\\ephemeral\\backed.up.daily\\domains\\com\\ideafarm\\ipdos\\memorySpaces\\Wo'O Ideafarm\\4\\stateSpaces\\0000ffff\\" ;
    //     #if defined( HOMEdRIVEiS_i )
    // {
    // //if( tinP.pEther )
    // if( postFileName && thirdC::c_strstrIF( tinP , postFileName , ".putfileif.s.out." ) )
    // const osTextT* postFileName = *(fileC*)pbFile ;
    //TO FIND A BUG

    }
        if( !bMemoryExisted ) napkin.formattingIsDoneF( tinP ) ;

        provisionF( tinP , napkin , napkin , flagsProvision , bFillP ) ;

        if( bMemoryExisted || bFileExisted ) flagsProvision &= ~( F(flBOOK0pROVISION_FORMAT) ) ; //U::20201124@1544: POSSIBLE BUG: HOW CAN FILE PREEXIST WITHOUT MEMORY ALSO PREEXISTING?

        boolT bMemoryExisted = F(napkin.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ;

        napkinC& napkin = *(napkinC*)pbNapkin ;
        }
            ) ;
                idMemorySpaceP
                - 1 ,
                ) ,
                    | ( F(flagsP) & flBOOKc_DOnOTsERIALIZEnAPKIN       ? flNAPKINc_DOnOTsERIALIZEcT           : flNAPKINc_null )
                    | ( F(flagsP) & flBOOKc_LOCK                       ? flNAPKINc_LOCK                       : flNAPKINc_null )
                      ( F(flagsP) & flBOOKc_USEgRABmEMORYsPACEoVERRIDE ? flNAPKINc_USEgRABmEMORYsPACEoVERRIDE : flNAPKINc_null )
                (
                ifcOPENsHAREDmEMORYhOW_nCeO ,
                sizeof( bookHeadS ) + cbP ,
                ) ,
                        : (const handleC*)*(fileC*)pbFile
                        ? 0
                    !idStateSpaceP
                (
                ostoBuf ,
                pbBitsCtP ,
                idiFileCtP ,
                idLineCtP ,
                tinP ,
            (
            new( 0 , tinP , pbNapkin , sizeof pbNapkin ) napkinC

            }
                OStEXTC(  ostoBuf , idStateSpaceP , '0' ) ;
                OStEXTAK( ostoBuf , "." ) ;
            {
            if( idStateSpaceP )                                 // APPENDING idStateSpaceP ENSURES THAT SHARED MEMORY NAME IS DISTINCT FOR EACH BACKING FILE; ADDED 20190104@1712 WITHOUT ANALYSIS
            OStEXTA(  ostoBuf , postP ) ;
            OStEXTAK( ostoBuf , "book0C/" ) ;
            OStEXT(   ostoBuf , TUCK << 2 ) ;
        {

        }
            }
                }
                    }
                        if( !cbP ) cbP = info.cbUsed - sizeof( napkinHeaderS ) - sizeof( bookHeadS ) ;

                        if( cbP && cbP != info.cbUsed - sizeof( napkinHeaderS ) - sizeof( bookHeadS ) ) { BLAMMO ; }
                    {
                    //if( cbHead == sizeof head && info.cbUsed == sizeof head + head.cbBody )
                
                    //thirdC::dosReadIF( tinP , (byteT*)&head , cbHead , (const handleC&)file ) ;
                    //countT cbHead = sizeof head ;
                    //bookHeadS head ;
                {
                if( info.cbUsed >= sizeof( napkinHeaderS ) + sizeof( bookHeadS ) )

                thirdC::dosQueryFileInfoIF( tinP , pInfo , file ) ;
                infoFileS* pInfo = &info ;
                infoFileS info( tinP ) ;
            {
            //if( bFileExisted )

            bFileExisted = file.idOpenResultF( tinP  ) == ifcOPENrESULT_EXISTED ;

            fileC& file = *(fileC*)pbFile ;
            ctFileF( tinP , postP , idStateSpaceP , idMemorySpaceP ) ;
        {
        if( idStateSpaceP )
        ZE( boolT  , bFileExisted ) ;
    {
    else
    }
        provisionF( tinP , pbFromHeap , cba , flagsProvision , bFillP ) ;
        pbFromHeap = processGlobal4I.heap.newF( tinP , idLineCtP , idiFileCtP , cba ) ;
        countT cba = sizeof( bookHeadS ) + cbP ;
    {
    if( F(flagsCt) & flBOOKc_USEhEAPnOTnAPKIN )

    if( F(flagsCt) & flBOOKc_PRIORbOOKnOTcONTINUEDhERE ) flagsProvision |= flBOOK0pROVISION_PRIORbOOKnOTcONTINUEDhERE ;
    if( F(flagsCt) & flBOOKc_RESETcREFoNcT             ) flagsProvision |= flBOOK0pROVISION_RESETcREFoNcT             ;      //20180816@1339: ADDED WITHOUT ANALYSIS OTHER THAN TO NOTICE THAT flBOOKc_RESETcREFoNcT IS NOWHERE ELSE INSPECTED
    if( F(flagsCt) & flBOOKc_DOnOTiNITIALIZEdATA       ) flagsProvision |= flBOOK0pROVISION_DOnOTiNITIALIZE           ;
    flagsT flagsProvision = flBOOK0pROVISION_FORMAT ;

    if( F(flagsCt) & flBOOKc_USEhEAPnOTnAPKIN ) flagsCt |= flBOOKc_RESETcREFoNcT | flBOOKc_PRIORbOOKnOTcONTINUEDhERE ;

    }
        }
            countT foo = 2 ;
        {
        if( idIn > 0x1000 )
        countT idIn = 1 + incv02AM( idInLath ) ;
        static countT idInLath ;
    {
    if( postP && thirdC::c_strstrIF( tinP , postP , ".soul.reports." ) ) //U::20141002@0549: TO FIND A BUG

    // if( tinP.pEther ) tinP.pEther->trace F( tinP , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": bookC constructing") ) ; //U:: TO FIND A BUG

    //}
    //    CONoUTrAW(   ostoSay ) ;
    //    OStEXTAK( ostoSay , "\r\n" ) ;
    //    OStEXTA(  ostoSay , postP ) ;
    //    OStEXTAK( ostoSay ,"    " ) ;
    //    OStEXTC(  ostoSay , this , '0' ) ;
    //    OStEXTAK( ostoSay , "bookC: +  " ) ;
    //    OStEXT(   ostoSay , TUCK << 2 ) ;
    //{

    _IO_

    }
        if( POOP ) return ;
        __( idMemorySpaceP && !( F(tinP.flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tinP ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tinP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        }
            __( !*postP ) ;
            if( POOP ) return ;
            __Z( postP ) ;
        {
        else
        }
            __( idMemorySpaceP ) ;
            __( idStateSpaceP  ) ;
            __( postP          ) ;
        {
        if( F(flagsCt) & flBOOKc_USEhEAPnOTnAPKIN )
        __( cbP && !( F(flagsCt) & flBOOKc_WRITER ) ) ;
        __( F(flagsP) & flBOOKc_FILEiScONSTRUCTED ) ; //THIS FLAG IS FOR INTERNAL USE ONLY; CALLER MAY NOT SPECIFY IT
        __( F(flagsP) & flBOOKc_NOsTATEsPACE      ) ; //THIS FLAG IS FOR INTERNAL USE ONLY; CALLER MAY NOT SPECIFY IT (IT IS IMPLIED BY !idStateSpaceP)
        FV( flBOOKc , flagsP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
{
pbFromHeap( 0 )
) ,
        : flagsP | flBOOKc_NOsTATEsPACE
        ? flagsP
    idStateSpaceP
(
flagsCt
book0C( tinP , 0 , 0 ) ,
/*1*/bookC::bookC( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postP , const countT idStateSpaceP , const flagsT flagsP , countT cbP , const byteT bFillP , const countT idMemorySpaceP ) :/*1*/

/**/
*/
 idMemorySpaceP
 bFillP
 cbP
 flagsP
 idStateSpaceP
 postP
 pbBitsCtP
 idiFileCtP
 idLineCtP
 tinP
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

