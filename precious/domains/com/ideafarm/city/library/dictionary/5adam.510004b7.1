
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    while( cGorillas ) { ++ s ; etThread.osSleepF( tinP , TUCK * 0x40 ) ; }
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{

}
    etThread.osThreadF( tinP , countTC() , tmGorillaF , 0 , flTHREADlAUNCH_null , 0 , (countT)&cGorillas , (countT)&cLever , (countT)&b_cLever , (countT)&swsg ) ;
    cGorillas ++ ;
{
while( cTries -- )
countT cTries = 0x10 ;

switchStackC swsg( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , cLever ) ;
batonC b_cLever( tinP , TAG( TAGiDnULL ) ) ;
ZE( countT , cLever ) ;
ZE( countT , cGorillas ) ;

TODO

DONE( tmGorillaF )
}                           
    cGorillas -- ;
    }
        }
            b_cLever.ungrabF( tinP ) ;
            }
                serial ++ ;
                }
                    if( !swsg ) swsg.freeF( tinP ) ;
                    }
                        swsg.extractF( 0 , tinP ) ;
                        CONoUT( postPull )
                    {
                    if( swsg( jj ) )
                {
                for( countT jj = 0x10000 ; jj <= 0x40000 ; jj += 0x10000 )
            {
            else
            }
                }
                    __Z( ids ) ;
                    swsg.sinkF( tinP , ids , jj , flSTACKsINK_UNIQUE ) ;
                    ZE( countT , ids ) ;
                    CONoUT( postPush )
                {
                for( countT jj = 0x10000 ; jj <= 0x40000 ; jj += 0x10000 )
            {
            if( !swsg )
            cLever = serial ;
            b_cLever.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        for( countT ii = 1 ; ii <= 0x1 ; ii ++ )

        //}
        //    ++ s ; etThread.osSleepF( tinP ) ;
        //    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        //{
        //U::WITHOUT THIS SLEEP, ONLY WO GORILLA EVER TRACES TO CONSOLE
    {
    while( !etThread && !ether && !swsg.third )
    const osTextT postPull[] = { 'a' + tinP.monitor.idThread % 26 , 0 } ;
    const osTextT postPush[] = { 'A' + tinP.monitor.idThread % 26 , 0 } ;
    countT serial = tinP.monitor.idThread * TICK ;

    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {

    switchStackC& swsg      = *(switchStackC*)pTaskP->c4 ;
    batonC&       b_cLever  =       *(batonC*)pTaskP->c3 ;
    countT&       cLever    =       *(countT*)pTaskP->c2 ;
    countT&       cGorillas =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmGorillaF )

/*1*/WAKEhIDE( "gorilla.switchStackC" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

