
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        delF( tinP , pcRemoteFileTimes ) ;
        delF( tinP , pfWanted ) ;
        delF( tinP , psttRemoteWanted ) ;
        if( !pstt1NotRefreshedP ) { strFuseF( tinP , pstt1NotRefreshedP , T("") ) ; ___( pstt1NotRefreshedP ) ; }
    
        }
            delF( tinP , pba ) ;
    
            }
                off ++ ;
    
                }
                    pbac += sizeof( countT ) + ( pbac ? *(countT*)pbac : 0 ) ;
                    if( !fAggregate ) break ;
                    }
                        strFuseSeparateF( tinP , pstt1NotRefreshedP , psttc1 , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 0x100000 ) ;
                        SCOOPSdEL
                        POOPR
                    {
                    else
                    if( !POOP ) SCOOPSdEL
                    tinP.pEtScratch->boxPutF( tinP , T(psttc1)+T(".time") , (byteT*)&pcRemoteFileTimes[ 2 * off ] , 2 * sizeof( countT ) ) ;
                    else             tinP.pEtScratch->boxPutF( tinP , psttc1 , pbac                    , cba            ) ;
                    if( fAggregate ) tinP.pEtScratch->boxPutF( tinP , psttc1 , pbac + sizeof( countT ) , pbac ? *(countT*)pbac : 0 ) ;
                    SCOOPSnEW
                {
                if( pfWanted[ off ] )
                if( POOP ) break ;
            {
            FORsTRINGSiN1( (strokeS*)pstt1LocalP )
            pbac = pba ;
            ZE( byteT* , pbac ) ;
            ZE( countT , off ) ;
            // WRITE THE IMAGES TO THE LOCAL DISK
    
            __Z( cba ) ;
            __Z( pba ) ;
            boxGetShadowF( tinP , pba , cba , psttRemoteWanted ) ; ___( pba ) ;
            ZE( countT , cba ) ;
            ZE( byteT* , pba ) ;
            // GET THE AGGREGATE IMAGE FOR THE REMOTE FILES
        {
        if( pcRemoteFileTimes && strCompareF( tinP , psttRemoteWanted , psttRemotePrefixP ) )
    
        delF( tinP , pcLocalFileTimes ) ;
    
        }
            }
                off ++ ;
    
                }
                    fPrior = 1 ;
                    strFuseF( tinP , psttRemoteWanted , psttc1 ) ; ___( psttRemoteWanted ) ;
                    if( fPrior ) { fAggregate = 1 ; strFuseF( tinP , psttRemoteWanted , T(" ") ) ; ___( psttRemoteWanted ) ; }
                    pfWanted[ off ] = 1 ;
                {
                if( memCompareF( tinP , (byteT*)&pcRemoteFileTimes[ 2 * off ] , (byteT*)&pcLocalFileTimes[ 2 * off ] , 2 * sizeof( countT ) ) )
                if( POOP ) break ;
            {
            FORsTRINGSiN1( (strokeS*)pstt1RemoteP )
            ZE( boolT , fPrior ) ;
            strFuseF( tinP , psttRemoteWanted , psttRemotePrefixP , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ 2 * ( pstt1RemoteP ? pstt1RemoteP->idAdam : 0 ) ) ; ___( psttRemoteWanted ) ;
            ZE( countT , off ) ;
        {
        if( pcRemoteFileTimes )
        ZE( boolT , fAggregate ) ;
        ZE( strokeS* , psttRemoteWanted ) ;
        // SELECT THE REMOTE FILES WANTED
    
        }
            }
                off ++ ;
    
                delF( tinP , pblt ) ;
                }
                    pcLocalFileTimes[ 2 * off + 1 ] = ((countT*)pblt)[ 1 ] ;
                    pcLocalFileTimes[ 2 * off     ] = ((countT*)pblt)[ 0 ] ;
    
                    __( cblt - 2 * sizeof( countT ) ) ;
                    __Z( pblt ) ;
                    SCOOPSdEL
                {
                else
                }
                    pcLocalFileTimes[ 2 * off + 1 ] = 0 ;
                    pcLocalFileTimes[ 2 * off     ] = 0 ;
                    __NZ( pblt ) ;
                    SCOOPSdEL
                    POOPR
                {
                if( POOP )
                delF( tinP , psttl ) ;
                tinP.pEtScratch->boxGetShadowF( tinP , pblt , cblt , psttl , 1 ) ; ___( pblt ) ;
                SCOOPSnEW
                ZE( countT , cblt ) ;
                ZE( byteT* , pblt ) ;
    
                strFuseF( tinP , psttl , T(psttc1)+T(".time") ) ; ___( psttl ) ;
                ZE( strokeS* , psttl ) ;
                if( POOP ) break ;
            {
            FORsTRINGSiN1( (strokeS*)pstt1LocalP )
            ZE( countT , off ) ;
        {
        if( pcLocalFileTimes )
        // GET THE LOCAL FILE TIMES
    
        }
            delF( tinP , pba ) ;
            }
                }
                    }
                        pcRemoteFileTimes[ 2 * off + 1 ] = ((countT*)pba)[ 3 * off + 2 ] ;
                        pcRemoteFileTimes[ 2 * off     ] = ((countT*)pba)[ 3 * off + 1 ] ;
                        __( ((countT*)pba)[ 3 * off ] - 2 * sizeof( countT ) ) ;
                    {
                    else
                    }
                        pcRemoteFileTimes[ 2 * off + 1 ] = ((countT*)pba)[ 2 * off + 1 ] ;
                        pcRemoteFileTimes[ 2 * off     ] = ((countT*)pba)[ 2 * off     ] ;
                    {
                    if( cFiles == 1 )
                {
                for( countT off = 0 ; !POOP && off < cFiles ; off ++ )
            {
            if( !POOP && pba )
    
            delF( tinP , pstta ) ;
            else              { __( cba != cFiles * 3 * sizeof( countT ) ) ; }
            if( cFiles == 1 ) { __( cba != cFiles * 2 * sizeof( countT ) ) ; }
            __Z( pba ) ;
            boxGetShadowF( tinP , pba , cba , pstta ) ; ___( pba ) ;
            ZE( countT , cba ) ;
            ZE( byteT* , pba ) ;
    
            }
                if( psttc1 + CSpREFIX + psttc1->idAdam < pstte1 ) { strFuseF( tinP , pstta , T(" ") ) ; ___( pstta ) ; }
                strFuseF( tinP , pstta , T(psttc1)+tTime ) ; ___( pstta ) ;
                if( POOP ) break ;
            {
            FORsTRINGSiN1( (strokeS*)pstt1RemoteP )
            strMakeF( tinP , LF , pstta , psttRemotePrefixP , ( pstt1RemoteP ? pstt1RemoteP->idAdam : 0 ) + cFiles * ( 1 + tTime.csF( tinP ) ) ) ; ___( pstta ) ;
            ZE( strokeS* , pstta ) ;
            TN( tTime , ".time" ) ;
        {
        if( !POOP )
        // GET THE REMOTE FILE TIMES
    
        memSetF( tinP , (byteT*)pfWanted , cFiles * sizeof( boolT ) ) ;
        newF( tinP , LF , pfWanted  , cFiles ) ; ___( pfWanted ) ;
        newF( tinP , LF , pcLocalFileTimes  , cFiles * 2 ) ; ___( pcLocalFileTimes ) ;
        newF( tinP , LF , pcRemoteFileTimes , cFiles * 2 ) ; ___( pcRemoteFileTimes ) ;
        ZE( boolT* , pfWanted ) ;
        ZE( countT* , pcLocalFileTimes ) ;
        ZE( countT* , pcRemoteFileTimes ) ;
    
        }
            if( !POOP ) cFiles = cLocal ;
            __( cLocal - cRemote ) ;
            { FORsTRINGSiN1( (strokeS*)pstt1RemoteP ) cRemote ++ ; }
            { FORsTRINGSiN1( (strokeS*)pstt1LocalP  ) cLocal ++ ;  }
            ZE( countT , cRemote ) ;
            ZE( countT , cLocal ) ;
        {
        ZE( countT , cFiles ) ;
        // COUNT THE FILES
    {
    IFsCRATCH
    _IO_

    }
        if( POOP ) return ;
        __Z( psttRemotePrefixP ) ;
        __Z( pstt1RemoteP ) ;
        __Z( pstt1LocalP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/**//*1*/voidT etherC::diskFileRefreshF( tinS& tinP , strokeS*& pstt1NotRefreshedP , const strokeS* const pstt1LocalP , const strokeS* const pstt1RemoteP , const strokeS* const psttRemotePrefixP )/*1*/
*/
 psttRemotePrefixP
 pstt1RemoteP
 pstt1LocalP
  will contain a string of strings; use FORsTRINGSiN1 to access them
 pstt1NotRefreshedP
arguments
 strFuseSeparateF
this function can fail due to hardcoded capacity limits
it is illegal to refer to this symbol in the definition of an adam
  \<A HREF=\"5.7210104.1.1.0.html\"\>7210104:  WAKEsHOW( "example.simplest.func.1030017.etherC.diskFileRefreshF" )\</A\>
 simplest
examples
\<A HREF=\"5.1030017.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$diskFileRefreshF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

