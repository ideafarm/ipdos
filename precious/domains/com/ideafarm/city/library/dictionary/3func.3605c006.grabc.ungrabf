
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cUngrabsDone ;
    //if( (countT)this == etherC::ether_cUtility_IF( tinP , 0 ) ) { LOGrAWtID( "U-" ) ; }

    //}
    //    CONoUTrAW( os ) ;
    //
    //    OStEXTAK(  os , "\r\n" ) ;
    //    }
    //        if( offi % 5 == 3 ) { OStEXTAK(  os , "]" ) ; }
    //        OStEXTC(   os , tinP.pPanLifiRecurseGrabbedLevel[ offi ] , 0 ) ;
    //        else { OStEXTAK(  os , "," ) ; }
    //        }
    //            else { OStEXTAK(  os , " [" ) ; }
    //            }
    //                continue ;
    //                offi += 4 ;
    //            {
    //            if( !tinP.pPanLifiRecurseGrabbedLevel[ offi ] )
    //        {
    //        if( !( offi % 5 ) )
    //    {
    //    for( countT offi = 0 ; offi < sizeof tinP.pPanLifiRecurseGrabbedLevel / sizeof tinP.pPanLifiRecurseGrabbedLevel[ 0 ] ; offi ++ )
    //
    //    OStEXTAK( os , "} ----" ) ;
    //    OStEXTC(  os , idiFileCt , 0 ) ;
    //    OStEXTAK( os , "," ) ;
    //    OStEXTC(  os , idLineCt , 0 ) ;
    //    OStEXTAK( os , "," ) ;
    //    OStEXTC(  os , this , 0 ) ;
    //    OStEXTAK( os , " | {" ) ;
    //    OStEXTA(  os , tinP.postThreadName ) ;
    //    OStEXTAK( os , " " ) ;
    //    OStEXTC(  os , tinP.monitor.idThread , 0 ) ;
    //    OStEXTAK( os , " | " ) ;
    //    OStEXTC9( os , tinP.osTid ) ;
    //    OStEXTAK( os , "         | " ) ;
    //    OStEXT(   os , TUCK << 2 ) ;
    //{
    //if( tinP.pAdamGlobal1->idAdam == 0x4010501 )

    }
        THREADmODE1rESTORE
    
        }
            }
                if( !bFound && F(flagsP) & flGRABcUNGRABf_DEPOSITkISSiF ) inc02AM( stat.cKissBank ) ;

                thirdC::dosPriorityIF( tinP , idDesireSave ) ;

                tinP.cYield = 0 ;
                }
                    if( !bWoth && ogw < processGlobal2I._grabC_cgw ) break ;
        
                    }
                        }
                            break ;

                            bFound = 1 ;
                            thirdC::dosResumeThreadIF( tinP , hThreadWant , 1 ) ;
        
                            }
                                thirdC::dosWriteStdOutIF( ostoBuf ) ;
                                OStEXTA( ostoBuf , ")\r\n" ) ;
                                OStEXTA( ostoBuf , tinP.postThreadName ) ;
                                OStEXTA( ostoBuf , " " ) ;
                                OStEXTC( ostoBuf , tinP.monitor.idThread , 0 ) ;
                                OStEXTA( ostoBuf , " (heater: " ) ;
                                OStEXTC( ostoBuf , processGlobal2I._grabC_pgw[ ogw ].idThread , 0 ) ;
                                OStEXTA( ostoBuf , "heatin " ) ;
                                OStEXT( ostoBuf , 0x140 )
                            {
                            if( F(processGlobal2I._grabC_pgw[ogw].flags) & flGRABwANT_CHATTERrESUME )
        
                            thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) ) ; //THIS WILL GIVE THE WANTER TIME TO GET TO SLEEP
                        
                            if( !hThreadWant ) { BLAMMO ; }
                            hThreadWant.cloneF( processGlobal2I._grabC_pgw[ ogw ].hThread , dosGetInfoBlocksIdProcessIF( tinP ) , hProcessMe , hProcessWant ) ;
                            handleC hThreadWant( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_THREAD ) ;
        
                            if( !hProcessWant ) { BLAMMO ; }
                            handleC hProcessWant = hProcessF( tinP , processGlobal2I._grabC_pgw[ ogw ].osPid , dosGetInfoBlocksIdProcessIF( tinP ) ) ;
        
                            hProcessMe.osF( ifcIDtYPEhANDLE_PROCESS , (countT)thirdC::osOpenProcessIF() ) ;
                            handleC hProcessMe( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_PROCESS ) ;
                            //U:O: if processGlobal2I._grabC_pgw[ ogw ].osPid == tinP.osPid THEN JUST USE PSEUDOHANDLE FOR hProcessWant
                            //U:O: USE tinP.osPid
        
                            if( !processGlobal2I._grabC_pgw[ ogw ].hThread ) { BLAMMO ; }

                            }
                                if( processGlobal2I._grabC_pgw[ ogw ].idGrab != idMe || processGlobal2I._grabC_pgw[ ogw ].idGrabber != idGrabberKiss ) continue ;

                                tinP.cYield = save ;
                                while( processGlobal2I._grabC_pgw[ ogw ].bDirty ) thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) ) ;
                                              tinP.cYield = 0 ;
                                countT save = tinP.cYield ;
                                ZE( countT , idCycle2 ) ;
                            {
                            if( processGlobal2I._grabC_pgw[ ogw ].bDirty ) //SOME DIRTY ENTRIES ARE TENTATIVE AND WILL DISAPPEAR (E.G. IF WANTER IS WILLING TO WITHDRAW FROM KISS BANK)
                        {
                        if( processGlobal2I._grabC_pgw[ ogw ].idGrab == idMe && processGlobal2I._grabC_pgw[ ogw ].idGrabber == idGrabberKiss )
                    {
                    for( ; ogw < processGlobal2I._grabC_cgw ; ogw ++ )
                    ZE( countT , ogw ) ;

                    else        thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) ) ;
                    if( bWoth ) bWoth = 0 ;
                {
                while( !cGrabbed && idGrabberOk == idGrabberKiss && (sCountT)( idGrabberHigh - idGrabberKiss ) >= 0 )
                //while( !cGrabbed && idGrabberOk == idGrabberKiss && idGrabberKiss <= idGrabberHigh )
                ZE( countT , idCycle ) ;
                ZE( boolT  , bFound ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                boolT bWoth = 1 ; //ALSO USED TO INDICATE "bKissChanged"

                countT idGrabberKiss = 1 + incv02AM( idGrabberOk ) ;

                thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
                const countT idDesireSave = thirdC::dosPriorityIF( tinP ) ;
        
                osTid = idDesireGrabber = 0 ;
                tinP.cYield = 0 ;
            {
            if( bKiss )
    
            }
                cUngrabsDone = cDone ;
                
                }
                    if( (sCountT)prior <= 1 ) break ;
    
                    if( prior == 1 ) bKiss = 1 ;
                    countT prior = decv02AM( cGrabbed ) ;
                    cDone ++ ;
                    unregisterF( tinP ) ;
                {
                for(;;)
                ZE( countT , cDone ) ;
    
                if( osTid != tinP.osTid ) { BLAMMO ; } //CATCH PROBABLE APPLICATION CODE ERROR
            {
            else
            }
                if( 1 == decv02AM( cGrabbed ) ) bKiss = 1 ;
                unregisterF( tinP ) ;
            {
            if( !( F(flagsP) & flGRABcUNGRABf_ALLrECURSIONS ) )
            ZE( boolT , bKiss ) ;
        {
        if( cUngrabsDone )
        //CODE SYNCH: 1700002 17f0006
    
        }
            }
                ++ s ; thirdC::dosSleepRawIF( tinP , 0x20 ) ;
    
                if( !cIgnore || !( -- cIgnore ) ) { BLAMMO ; } ;
            {
            while( !cGrabbed )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            countT cIgnore = 0x80 ;
        {
        else //U::EDIT TO NOT BLOCK IF flGRABcUNGRABf_ALLrECURSIONS IS SPECIFIED
        }
            if( !cGrabbed ) cUngrabsDone = 0 ;
        {
        if( F(flagsP) & flGRABcUNGRABf_IF )
        _IO_
    
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    
        }
            if( POOP ) { BLAMMO ; }
            FV(flGRABcUNGRABf,flagsP)
            POOPIE
        {
        if( F(tinP.pAdamGlobal1->_thirdC_.flagsModeAdam1) & flADAMmODE1_DISALLOWgRABoFiNTERPROCESSgRABs && F(flags) & flGRABc_INTERpROCESS ) { BLAMMO ; }
        if( F(tinP.flagsThreadMode1     ) &   flTHREADmODE1_DISALLOWgRABoFiNTERPROCESSgRABs && F(flags) & flGRABc_INTERpROCESS ) { BLAMMO ; }
        if( F(flags) & flGRABc_DISABLED ) { BLAMMO ; }
    {
    else
    if( this == &tinP.grabPseudo ) cGrabbed -- ;
    countT cUngrabsDone = 1 ;

    SCOOP
{
/*1*/countT grabC::ungrabF( tinS& tinP , const flagsT flagsP )/*1*/

/**/
*/
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010393.flUNGRAB!||
 flagsP
 tinP
arguments
i evaluate to the number of ungrabs i did, which will always be 1 if flagsP is flGRABcUNGRABf_null
excess calls to me will block
 U::conj: this is no longer true; the current code is rock solid w.r.t. racing ungrabbers
 it is illegal to rely upon this code, which will fail if the asynchronous excess call occurs at a particular time
 i contain code that will USUALLY detect excess ungrabs and block
the caller must ensure that i am not called too many times
multiple threads can call me
any thread may call me
\<A HREF=\"5.17f0006.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$ungrabF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

