
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return flagsRC ;

    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    listC::deleteIF( tinP , hRecordP , pczFieldP , flLISTdELETE_IFeMPTY , idGrabLayerP ) ;

    }
        }
            tinP.ta.retained.u.listWalk.walk.flagsWalkP = saveRetained  ;

            POPtINaRGS
    
            flagsRC |= field.walkF( tinP , idGrabLayerP ) ;


                                                          tinP.ta.pushed.u.listWalk.util.pcP[ 7 ]      = idiFileNewP ;
                                                          tinP.ta.pushed.u.listWalk.util.pcP[ 6 ]      = idLineNewP ;
          //                                              tinP.ta.pushed.u.listWalk.util.pcP[ 5 ]                                          WILL CONTAIN THE NUMBER OF LISTINGS DELETED
          //                                              tinP.ta.pushed.u.listWalk.util.pcP[ 4 ]                                          WILL CONTAIN THE NUMBER OF LISTINGS NOT DELETED
                                                          tinP.ta.pushed.u.listWalk.util.pcP[ 3 ]      = inP.cKeep ;
          //                                              tinP.ta.pushed.u.listWalk.util.pcP[ 2 ]                                          IS USED AS A CURSOR
                                                          tinP.ta.pushed.u.listWalk.util.pcP[ 1 ]      = (countT)&inP ;
                                                          tinP.ta.pushed.u.listWalk.util.pcP[ 0 ]      = (countT)&pOutP ;
                                                          tinP.ta.pushed.u.listWalk.walk.flagsWalkP    = flLISTwALK_CALLERgRABBEDrOOT ;
                                                          tinP.ta.pushed.u.listWalk.walk.pListWalkCBFP = listWalkFieldEditCBF ;

            //}
            //    __Z( aptTest ) ;
            //    aptTest = pbTest ;
            //    aptC aptTest ;
            //    //CONoUTrAW( "\r\n" ) ;
            //    //CONoUTrAW( tinP.pPoolUse->postNameF( tinP ) ) ;
            //    //CONoUTrAW5( "testing list [pPoolUse,pTest]: " , tinP.pPoolUse , " " , pbTest , " " ) ; //U::
            //    byteT* pbTest = (byteT*)hRecordP.osF( ifcIDtYPEhANDLE_LISTING ) ;
            //{
            //U::
        
            PUSHtINaRGS

                                  tinP.ta.retained.u.listWalk.walk.flagsWalkP  = F(inP.flags) & flFIELDeDIT_DOnOTiNDEXdATA ? flLISTwALK_DOnOTiNDEXdATA : flLISTwALK_null ;
            flagsT saveRetained = tinP.ta.retained.u.listWalk.walk.flagsWalkP ;

            if( !( field.flagsi & fliLISTINGc_FIELD ) ) field.flagsi |= fliLISTINGc_FIELD ; 

            listC& field = *(listC*)hField.osF( ifcIDtYPEhANDLE_LISTING ) ;
    
            const handleC& hField = ~hKid ? hKid : hRecordP ;
        {
        if( !POOP )
    
        }
            if( !hKid ) { __( !( F(flagsP) & flLISToPEN_IFeXISTS ) ) ; }
    
            if( F( openIF( tinP , hKid , hRecordP , pczFieldP , flagsP | flLISToPEN_RETAINrOOT , idGrabLayerP ) ) & flLISToPENrETURNcODE_LISTeXISTED ) flagsRC |= flLISTwALKrETURNcODE_LISTeXISTED ;
        {
        if( pczFieldP )
        handleC hKid( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
    {

    }
        countT foo = 2 ;
    {
    if( idIn == 0x4139 )
    countT idIn = 1 + incv02AM( idInLath ) ;
    static countT idInLath ;
    //U::TO FIND A BUG


    }
        if( !( record.flagsi & fliLISTINGc_RECORD ) ) record.flagsi |= fliLISTINGc_RECORD ; 
        listC& record = *(listC*)hRecordP.osF( ifcIDtYPEhANDLE_LISTING ) ;
    {
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    _IO_

    }
        if( POOP ) return flagsRC ;
        __( F(inP.flags) & flFIELDeDIT_MODEpUSHsINK && inP.postzIdSerialSpace ) ; // I WILL DISPENSE AN idSerial VALUE ONLY IF I DECIDE TO PUSH, AND JUST IN TIME; SO I CANNOT SUPPORT SINK, SINCE THAT WOULD REQUIRE EARLY DISPENSING 
        FV( flLISToPEN , flagsP ) ;
        }
            __( cValues > 1 ) ;
            countT cValues = !!inP.cValue + ( !!inP.pbzValue || !!inP.cbzValue ) + !!inP.pczValue + !!inP.pListingValue ;
        {
        FV(flFIELDeDIT,inP.flags)
        __NZ( pOutP ) ;
        __Z( hRecordP ) ;
        if( POOP ) return flagsRC ;
    {
    IFbEcAREFUL

    flagsT flagsRC = flLISTwALKrETURNcODE_null ;
{
/*1*/flagsT listC::fieldIF( tinS& tinP , fieldEditParamOutC*& pOutP , handleC& hRecordP , const countT* pczFieldP , const fieldEditParamInC& inP , const countT idLineNewP , const countT idiFileNewP , const flagsT flagsP , const countT idGrabLayerP )/*1*/

/**/
*/
  flagsP
    queries all values of the specified field that are either numeric and between 4 and 6, or text strings that are between "cc" and "ee"
   _1_queryC() + _1_modeAllC() + _1_no_below_C( 4 ) + _1_no_above_C( 6 ) + _1_no_below_C( "cc" ) + _1_no_above_C( "ee" )
    queries all values of the specified field
   _1_queryC() + _1_modeAllC()
    creates a new listing with an attached byteT string (null terminated blob) value
   _1_pushC( "brown cow" )
    creates a new listing with an attached countT datum
   _1_pushC( 0x1234 )
  examples
  this is where the caller tells me what to do
  this is an expression that evaluates to a temporary fieldEditParamInC instance
 inP
   such a record will contain no field names, but the type of each value is, as always, stored
  if pczFieldP is null or of null length, the "record" will be a simple list of (possibly heterogeneous typed) values
  by using calls to me for a given record that use pczFieldP of varying positive lengths, fields that are subfields of other fields can be created and queried
   the record will be a list of field names, and each field name will be a list of (possibly heterogeneous typed) values
  if all calls to me for a given record use a pczFieldP of length 1 then the record will have a conventional structure
  is the name of the "field" that i am to operate on
  normally is not ze and is of length 1
  can be 0
 pczFieldP
  this listC instance corresponds to a "record" in the conventional model
  must be a handle to an open listC instance
  must not be 0
 hRecordP
  caller can display *pOut by invoking "SAYfIELDoUT( "[put comment text here]" ) ;"
  caller must delete by invoking "DELlIST( fieldEditParamOutC , pOut ) ;"
  must be 0
 pOutP
 tinP
parameters
   for example, within a record, the "name" field can have several text string values intermixed with several countT values
  these values can be of heterogeneous type
  within a record, a given field can have multiple values
 i am still more general than the conventional database model
 applications can use me to manifest conventional database functionality
 i impose additional structure
   any node can be a list, and any node can have an attached datum
  in this "list of lists" topology each node is undifferentiated from the others
   since a soulC image can be stored, a datum can store a (compressed) strokeS string
   since blobs are supported, a datum can store a soulC image
  each datum can be a countT , a countT string, or a blob (including an osTextT string)
   typically, a listing serves either as a sublist or as a leaf that contains a datum
  although a listing can simultaneously have a datum attached to it and also be a list, but this is not normally done
  a listing can also be a list
  a listing can have a datum attached to it
  each list is a sequence of "listings"
 the list subsystem manifests named data stores, each of which is a list of lists
i manifest a "records database" model that imposes conventional "fields in records" structure onto the ipdos list subsystem
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

