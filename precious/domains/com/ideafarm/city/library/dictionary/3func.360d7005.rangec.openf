
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return offBegin ;

    //CHATTERiF { CONoUTrAW( "]" ) ; }

    }
        //CHATTERiF { CONoUTrAW( "0" ) ; }
        else if( offBegin == setIfEqualsAM( offFree , offEnd , offBegin ) ) break ;
        }
            }
                break ;

                dec02AM( cOpen ) ;
                }
                    }
                        break ;
                        if( news >= olds ) inc02AM( cSlotsOpenHigh ) ;
                    {
                    if( olds == setIfEqualsAM( cSlotsOpenLow , news , olds ) )
                    const countT news = olds - cSlots ;
                    const countT olds = cSlotsOpenLow ;
                {
                for(;;)

                bAbortedP = 1 ;
                offBegin = 0 ;
            {
            else
            }
                thirdC::dosSleepWinkIF( tinP ) ;
                //if( !( F(flags) & flRANGEc_CONSUMER ) ) { CONoUTrAW( "+" ) ; }

                //}
                //    //}
                //    //
                //    //    //CONoUTrAW9( " cSlots:" , cSlotsMinusWoP + 1 , " begin:" , offBegin , " open:" , offOpen , " end:" , offEnd , "\r\n" ) ;
                //    //{
                //    //if( bContainsOpen )
                //
                //    }
                //        CONoUTrAW5( "[idThread,cOpen]: " , tinP.monitor.idThread , " " , cOpen , "\r\n" ) ;
                //    {
                //    if( bContainsOpen )
                //
                //    ) ;
                //                : "o"
                //                ? "i"
                //            : bContainsOpen
                //            ? "&"
                //        bContainsOpen && bContainsOpenPeer
                //    (
                //    CONoUTrAW
                //{
                //CHATTERiF

                //)
                //    )
                //        )
                //            idThreadChatter == tinP.monitor.idThread
                //            !setIfZeAM( idThreadChatter , tinP.monitor.idThread ) ||
                //        (
                //        etherC::ether_cUtility_IF( tinP ) &&
                //    (
                //    tinP.pc Utility[ 0 ] ||
                //(
                //if
                //static countT idThreadChatter ;
            {
            if( !bQuitP )
        {
        if( bContainsOpen || bContainsOpenPeer )

        }
            }
                if( !pcQueuedUse || !*pcQueuedUse ) bContainsOpenPeer = 0 ; //PRODUCER WILL PROCEED IF ALL THAT IT HAS WRITTEN HAS BEEN CONSUMED
            {
            else
            }
                if(  pcQueuedUse &&  *pcQueuedUse ) bContainsOpenPeer = 0 ; //CONSUMER WILL SLEEP UNTIL PRODUCER CLOSES
            {
            if( ( F(flags) & flRANGEc_CONSUMER ) )

            countT* pcQueuedUse = F(flags) & flRANGEc_POINTERSaREoFFSETS ? (countT*)( (byteT*)this + (countT)pcQueued ) : pcQueued ;
        {
        if( bContainsOpenPeer )

        if( bContainsOpen && offBegin == offOpen ) bContainsOpen = 0 ;

        ;
            )
                *pOffOpenPeerUse <  offEnd
                ||
                offBegin         <= *pOffOpenPeerUse
            (
            :
            )
                *pOffOpenPeerUse <  offEnd
                &&
                offBegin         <= *pOffOpenPeerUse
            (
            ?
        boolT bContainsOpenPeer = !bWrap

        const countT* pOffOpenPeerUse = F(flags) & flRANGEc_POINTERSaREoFFSETS ? (const countT*)( (byteT*)this + (countT)pOffOpenPeer ) : pOffOpenPeer ;

        ;
            )
                offOpen          <  offEnd
                ||
                offBegin         <= offOpen
            (
            :
            )
                offOpen          <  offEnd
                &&
                offBegin         <= offOpen
            (
            ?
        boolT bContainsOpen = !bWrap

        const boolT bWrap = offEnd <= offBegin ;
        const countT offEnd = offBegin + cSlotsMinusWoP + 1 ; //CANNOT WRAP TO A VALUE GREATER THAN offBegin BECAUSE cSlotsMinusWoPis <= ffffffff
        offBegin = offFree ;
        //CHATTERiF { CONoUTrAW( "1" ) ; }
    {
    for(;;)
    ZE( countT , offBegin ) ;

    }
        //CHATTERiF { CONoUTrAW( "2" ) ; }
        }
            break ;
            if( news <= olds ) inc02AM( cSlotsOpenHigh ) ;
        {
        if( olds == setIfEqualsAM( cSlotsOpenLow , news , olds ) )
        const countT news = olds + cSlots ;
        const countT olds = cSlotsOpenLow ;
    {
    for(;;)
    inc02AM( cOpen ) ;
    const countT cSlots = cSlotsMinusWoP + 1 ;

    //CHATTERiF { CONoUTrAW( "[" ) ; }
{
/*1*/countT rangeC::openF( tinS& tinP , boolT& bAbortedP , const boolT& bQuitP , const countT cSlotsMinusWoP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

