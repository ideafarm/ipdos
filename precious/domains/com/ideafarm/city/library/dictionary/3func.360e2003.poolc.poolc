
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //CONoUTrAW( " *********************************************************************************************************\r\n" ) ;
    //CONoUTrAW( guts.postName ) ;
    //CONoUTrAW( " poolC/-:  " ) ;

    }
        THREADmODE2rESTORE
        }
            }
                listC::indexIF( tinP , hList ) ;

                //CONoUTrAW( "\"\r\n" ) ;
                //CONoUTrAW( postNameP ) ;
                //CONoUTrAW( "poolC / indexing list root/application of \"" ) ;
            {
            if( ~hList )

            listC::openIF( tinP , hList , pczName , flLISToPEN_IFeXISTS ) ;
            countT pczName[] = { LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION , 0 } ;
            handleC hList( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

            puseC puseMe( tinP , *this ) ;
        {
        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
    {                                                                                                                   // INDEX ALL OF MY DATUM VALUES
    )
        && !( F(flagsP) & flPOOLc_DOnOTiNDEXdURINGcT                                 )                                  // MY CALLER DIDN'T FORBID ME TO INDEX MYSELF               (DO NOTHING IF I AM TOLD TO DO NOTHING)
        && !( F(napFace.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED )                                  // MY BACKING IMAGE DIDN'T ALREADY EXIST                    (DO NOTHING IF BACKING DATA ALREADY EXISTED BECAUSE ITS CREATOR PRESUMABLY INDEXED IT ALL)
           !( F(flagsInstance) & flPOOLiNSTANCE_NAPfACEfORMATTEDbYmE                 )                                  // I DIDN'T FORMAT MY BACKING IMAGE                         (DO NOTHING IF I FORMATTED MY BACKING IMAGE BECAUSE THERE IS NO DATA TO INDEX)
    (
    if

    // INDEX IFF NEW INTO MEMORY... (OPTIMIZATION:)... UNLESS I FORMATTED, WHICH IMPLIES THAT THERE IS NO CONTENT YET

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // MAYBE INDEX ALL OF MY DATUM VALUES
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        if( ~hList ) listC::resetIndexBitsIF( tinP , hList ) ;

        listC::openIF( tinP , hList , pczName , flLISToPEN_IFeXISTS ) ;
        countT pczName[] = { LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION , 0 } ;
        handleC hList( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

        puseC puseMe( tinP , *this ) ;
    {
    if( F(flagsP) & flPOOLc_RESETiNDEXbITS )

    tinP.flagsThreadMode1 = saveThreadMode1 ;

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // MAYBE RESET ALL INDEX BITS
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    batPoolCt.ungrabF( tinP ) ;

    else if( this == (poolC*)tinP.pAdamGlobal1->pbzphp )                 tinP.pAdamGlobal1->pPoolHomePerm = this ;
    else if( this == (poolC*)tinP.pAdamGlobal1->pbzpap )                 tinP.pAdamGlobal1->pPoolAdamPerm = this ;
    else if( this == (poolC*)tinP.pAdamGlobal1->pbzpsc )                 tinP.pAdamGlobal1->pPoolScratch  = this ;
    else if( this == (poolC*)tinP.pAdamGlobal1->pbzpht )                 tinP.pAdamGlobal1->pPoolHomeTemp = this ;
         if( !tinP.pAdamGlobal1->pPoolAdamTemp         ) tinP.pPoolUse = tinP.pAdamGlobal1->pPoolAdamTemp = this ; //A:ASSUME: THE ADAM TEMP POOL IS CT WOTH

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // REGISTER MYSELF AS AN ADAM/HOME TEMP/PERM (OR SCRATCH) INSTANCE
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    processGlobal4I._poolC_grab_pPool.ungrabF( tinP ) ;

    }
        tinP.pEther->osThreadF( TaRG1( tmPoolFlushF ) ) ;
        puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
    {
    if( idStateSpaceP && ! processGlobal1I._poolC_cBacked ++ )

            processGlobal1I._poolC_pPool = this ;
    pNext = processGlobal1I._poolC_pPool ;

    processGlobal4I._poolC_grab_pPool.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // LAUNCH tmPoolFlushF IF NOT YET LAUNCHED
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        }
            }
                }
                    guts.pGrabNewElt[ offs ].ungrabF( tinP ) ;

                    guts.ppSlots[ offs ]->makeSexF( tinP , expSlotsWanted ) ;

                    }
                        guts.ppSlots[ offs ] = new( 0 , tinP , guts.pbza + offs * sizeof( slotsC ) , sizeof( slotsC ) ) slotsC( tinP , TAG( TAGiDnULL ) , LF , ostoName , guts.cBitsExpCbDrop , offs , flagsc , guts.idStateSpace , guts.idMemorySpace , this ) ;
        
                        if( F(guts.flagsCt) & flPOOLc_NOTES    ) flagsc |= flSLOTSc_NOTES    ;
                        if( F(guts.flagsCt) & flPOOLc_READoNLY ) flagsc |= flSLOTSc_READoNLY ;
                        flagsT flagsc = flSLOTSc_null ;
                    {
                    if( !guts.ppSlots[ offs ] )

                    guts.pGrabNewElt[ offs ].grabF( tinP , TAG( TAGiDnULL ) ) ;
    
                    //CONoUTrAW( "\r\n" ) ;
                    //CONoUTrAW( ostoName ) ;
    
                    OStEXTCF( ostoName , offs , '0' ) ;
                    OStEXTAK( ostoName , ".slots." ) ;
                    OStEXTA(  ostoName , ostoNameGroup ) ;
                    OStEXT(   ostoName , TUCK << 2 )

                    countT offs = expCbDropWanted ;
                {
                if( guts.expCbDropMin <= expCbDropWanted && expCbDropWanted <= guts.expCbDropMax )

                countT expSlotsWanted  = *pczHintPreallocationP >> SB & ( 1 << SB ) - 1 ;
                countT expCbDropWanted = *pczHintPreallocationP       & ( 1 << SB ) - 1 ;
                boolT  bAll            = *pczHintPreallocationP       & BM_HIGH2        ;           //U:: OBEY THIS
            {
            for( ; *pczHintPreallocationP ; pczHintPreallocationP ++ )
        {
        if( pczHintPreallocationP )
    
        // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
        // EARLY CONSTRUCT THE slotsC INSTANCE FOR EACH HINT expCbDrop
        // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

        }
            }
                }
                    guts.pGrabNewElt[ offs ].ungrabF( tinP ) ;
                    }
                        if( !( F(guts.flagsCt) & ( flPOOLc_MAKEaLL | flPOOLc_KEEPeMPTIES ) ) && !*guts.ppSlots[ offs ] ) { DELzOMBIE( guts.ppSlots[ offs ] ) ; }
        
                        guts.ppSlots[ offs ] = new( 0 , tinP , guts.pbza + offs * sizeof( slotsC ) , sizeof( slotsC ) ) slotsC( tinP , TAG( TAGiDnULL ) , LF , ostoName , guts.cBitsExpCbDrop , expCbDrop , flagsc , guts.idStateSpace , guts.idMemorySpace , this ) ;
        
                        if( F(guts.flagsCt) & flPOOLc_NOTES    ) flagsc |= flSLOTSc_NOTES    ;
                        if( F(guts.flagsCt) & flPOOLc_READoNLY ) flagsc |= flSLOTSc_READoNLY ;
                        flagsT flagsc = bBrowse ? flSLOTSc_BROWSE : flSLOTSc_null ;
                    {
                    else
                    if( guts.ppSlots[ offs ] ) { BLAMMO ; }
                    guts.pGrabNewElt[ offs ].grabF( tinP , TAG( TAGiDnULL ) ) ;
    
                    const countT expCbDrop   = offs ;
    
                    //CONoUTrAW( "\r\n" ) ;
                    //CONoUTrAW( ostoName ) ;
    
                    OStEXTCF( ostoName , offs , '0' ) ;
                    OStEXTAK( ostoName , ".slots." ) ;
                    OStEXTA(  ostoName , ostoNameGroup ) ;
                    OStEXT(   ostoName , TUCK << 2 )
                {
                if( bBrowse || bitsStateExists >> offs & 1 )
            {
            for( countT offs = guts.expCbDropMin ; offs <= guts.expCbDropMax ; offs ++ )
        {
        if( bBrowse || bitsStateExists )
    
        // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
        // EARLY CONSTRUCT THE slotsC INSTANCE FOR EACH expCbDrop THAT I WANT
        // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

        }
            }
                while( ~hFind ) ;
                }
                    }
                        }
                            bitsStateExists |= 1 << offNeed ;
                            countT offNeed = thirdC::c_atoiIF( postAt ) ; ;
                            *postEnd = 0 ;
                        {
                        if( postEnd )
                        osTextT* postEnd = thirdC::c_strstrIF( tinP , postAt , "." ) ;
                        postAt += sizeof postBefore - 1 ;
                    {
                    if( postAt )
                    osTextT* postAt = thirdC::c_strstrIF( tinP , postName , postBefore ) ;
                    osTextT postBefore[] = ".poolC.slots." ;

                    }
                        continue ;
                        thirdC::dosDeleteIF( tinP , postName , 1 ) ;
                        POOPIE ;
                    {
                    if( !bOk )

                    }
                        }
                            else { CONoUTrAW3( "thread " , tinP.monitor.idThread , " uh ohh!\r\n" ) ; } //U::

                            if( info.cbUsed || info.cbUsedHigh ) bOk = 1 ;

                            if( POOP ) break ;
                            thirdC::dosQueryFileInfoIF( tinP , pInfo , hFile ) ;
                            infoFileS* pInfo = &info ;
                            infoFileS info( tinP ) ;

                            if( !hFile ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE

                            if( POOP ) break ;
                            thirdC::dosOpenIF( tinP , tinP.pEther , hFile , countTC() , postName , ifcOPENaCCESS_R , ifcOPENsHARE_WR , flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO , flFILEaTTR_null , 0 , 1 ) ;
                            handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                        {
                        while( !bOk )

                        POOPIE ;
                    {
                    ZE( boolT , bOk ) ;

                    }
                        break ;
                        __( ~hFind ) ;
                    {
                    if( !postName[ 0 ] )
                    thirdC::dosFindFileOrDirSimpleIF( tinP , postName , sizeof postName , hFind , ostoLike ) ;
                    postName[ 0 ] = 0 ;
                    osTextT postName[ TUCK << 1 ] ;
                {
                do
                handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {

            }
                OStEXTAK( ostoLike , ".poolC.slots.*.data.*" ) ;
                OStEXTA(  ostoLike , postNameP ) ;
                OStEXTAK( ostoLike , "\\" ) ;

                POOPR
                OStEXTC(  ostoLike , idStateSpaceP , 0 ) ;                                                                thirdC::dosCreateDirIF( tinP , ostoLike ) ;
                OStEXTAK( ostoLike , "\\" ) ;
                OStEXTAK( ostoLike , "\\stateSpaces" ) ;                                                                  thirdC::dosCreateDirIF( tinP , ostoLike ) ;
                OStEXTCF( ostoLike , tinP.pAdamGlobal1->idMemorySpace , '0' ) ;                                           thirdC::dosCreateDirIF( tinP , ostoLike ) ;
                OStEXTAK( ostoLike , "\\" ) ;
                OStEXTA(  ostoLike , thirdC::postUserNameIF() ) ;                                                         thirdC::dosCreateDirIF( tinP , ostoLike ) ;
                OStEXTAK( ostoLike , "\\" ) ;
                OStEXTAK( ostoLike , "\\memorySpaces" ) ;                                                                 thirdC::dosCreateDirIF( tinP , ostoLike ) ;
                OStEXTAK( ostoLike , "\\ipdos" ) ;                                                                        thirdC::dosCreateDirIF( tinP , ostoLike ) ;
                OStEXTAK( ostoLike , "\\ideafarm" ) ;                                                                     thirdC::dosCreateDirIF( tinP , ostoLike ) ;
                OStEXTAK( ostoLike , "\\com" ) ;                                                                          thirdC::dosCreateDirIF( tinP , ostoLike ) ;
                OStEXTAK( ostoLike , "\\domains" ) ;                                                                      thirdC::dosCreateDirIF( tinP , ostoLike ) ;
                OStEXTAK( ostoLike , "\\backed.up.daily" ) ;                                                              thirdC::dosCreateDirIF( tinP , ostoLike ) ;
                OStEXTAK( ostoLike , "\\ephemeral" ) ;                                                                    thirdC::dosCreateDirIF( tinP , ostoLike ) ;
                OStEXTA(  ostoLike , postHome ) ;                                                                         thirdC::dosCreateDirIF( tinP , ostoLike ) ;

                if( POOP ) { BLAMMO ; }
                thirdC::diskFindHomeIF( tinP , postHome , sizeof postHome , "ideafarm" ) ;
                osTextT postHome[ TUCK << 1 ] ;

                SCOOP
                poopC poop ;
            {
            OStEXT( ostoLike , TUCK * 2 ) ;
        {
        if( idStateSpaceP )
        ZE( countT , bitsStateExists ) ;
    
        // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
        // FOR PERSISTENT INSTANCES, FOR EACH expCbDrop, SET A BIT IF A BACKING FILE EXISTS
        // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

        boolT bBrowse =  F(guts.flagsCt) & flPOOLc_BROWSE ;
                
        OStEXTAK( ostoNameGroup , ".poolC" ) ;
        OStEXTA(  ostoNameGroup , guts.postName ) ;
        OStEXT(   ostoNameGroup , TUCK << 2 )
    
        //CONoUTrAW( " *********************************************************************************************************\r\n" ) ;
        //CONoUTrAW( guts.postName ) ;
        //CONoUTrAW( " poolC/+:  " ) ;
    
        puseC puse( tinP , ifcIDpOOL_NONE ) ;
    {

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // EARLY CONSTRUCT ALL slotsC INSTANCES THAT I WANT
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        }
            }
                ++ s ; thirdC::dosSleepWinkIF( tinP ) ;
                etherC::etRockIF( tinP ).traceF( tinP , (strokeS*)"poolC / registration / waiting for a free slot" , flTRACE_PARAMETERiSoStEXT ) ;

                if( bDone ) break ;
                }
                    }
                        }
                            break ;
                            bDone = 1 ;        
                            pRegs[ offr ].flagsi |= fliPOOLrEGISTRATIONs_FORMATTED ;
                            thirdC::c_strcpyIF( tinP , pRegs[ offr ].postPoolName , postNameP ) ;
                            pRegs[ offr ].resetF( tinP ) ;
                        {
                        if( !setIfZeAM( pRegs[ offr ].cRefPool , 1 ) )
                        grabitC grabx( tinP , TAG( TAGiDnULL ) , (byteT*)&pRegs[ offr ].flagsi , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_null , 0 , ifcIDgRABlAYER_9POOLlAYER3 ) ;
                    {
                    if( !bDone ) for( countT offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )

                    }
                        }
                            break ;
                            bDone = 1 ;        
                            inc02AM( pRegs[ offr ].cRefPool ) ;
                        {
                        if( pRegs[ offr ].flagsi & fliPOOLrEGISTRATIONs_FORMATTED && !thirdC::c_strcmpIF( tinP , pRegs[ offr ].postPoolName , postNameP ) )
                        grabitC grabx( tinP , TAG( TAGiDnULL ) , (byteT*)&pRegs[ offr ].flagsi , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_null , 0 , ifcIDgRABlAYER_9POOLlAYER2) ;
                    {
                    for( countT offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )

                    grabitC grabx( tinP , TAG( TAGiDnULL ) , (byteT*)&home.fliGrab , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_null , 0 , ifcIDgRABlAYER_9POOLlAYER1 ) ;
                {
                ZE( boolT , bDone ) ;
            {
            for(;;)
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {

        //   nap
        //  if !done
        //  ungrab array
        // 
        //     break
        //     set done
        //     format
        //    if set cRef from 0 to 1
        //   for each array element
        //  if !done
        //    break
        //    set done
        //    update
        //   if formatted and name matches
        //  for each array element
        //  grab array
        // while( !done )
        // 
        // RECIPE

        ZE( countT , offr ) ;
        poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;
        homeS& home = homeS::homeIF() ;
        // THIS MEANS THAT poolC INSTANCES THAT ARE REGISTERED ARE NOT NECESSARILY FULLY CONSTRUCTED AND USEABLE
    {   // *this IS REGISTERED EARLY AND DEREGISTERED LATE BECAUSE sexC CONSTRUCTORS AND DESTRUCTORS MUST REFER TO IT

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // CREATE AND FORMAT REGISTRATION RECORD OR WAIT UNTIL ANOTHER poolC INSTANCE HAS DONE SO
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    napGuts.formattingIsDoneF( tinP ) ; //MUST BE DONE AFTER napFace IS FULLY CT SO THAT tinP.idDesire IS UNWOUND CORRECTLY
    new( 0 , tinP , &napGuts ) guts_poolC_S( tinP , idLineCtP , idiFileCtP , pbBitsCtP , postNameP , flagsP , idStateSpaceP , expCbDropMinP , expCbDropMaxP , idMemorySpaceP ) ;
    
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // FORMAT napGuts
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        ((face_poolC_S*)(byteT*)napFace)->cRef = 1 ;
        CONoUTrAW3( " resetting poolC cRef to 1 from " , ((face_poolC_S*)(byteT*)napFace)->cRef , "\r\n" ) ;
    {
    if( F(flagsP) & flPOOLc_RESETcrEF && ((face_poolC_S*)(byteT*)napFace)->cRef != 1 ) //A:ASSUME: I AM NOT RACING WITH ANOTHER PROCESS TO ctFaceF()

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // MAYBE RESET cRef
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    //20170830@2027: ctFaceF WAS CALLED HERE.  MOVED TO EARLIER TO AVOID RECURSIVELY GRABBING GRABmEMORYsPACE

    if( F(tinP.flagsThreadMode2) & flTHREADmODE2_DISALLOWpUSE ) { BLAMMO ; }

    }
        if( aptnu ) ;
        aptC& aptnu = aptListRootF() ;
    {
    //U:: TO FIND A BUG

    }
        __( idMemorySpaceP && ( idMemorySpaceP < ifcIDmEMORYsPACE_min || idMemorySpaceP > ifcIDmEMORYsPACE_max ) ) ;
        FV( flPOOLc , flagsP ) ;
        FV( flTHREADmODE1 , tinP.flagsThreadMode1 ) ;
        FV( flTHREADmODE1 , saveThreadMode1 ) ;
    {
    IFbEcAREFUL

                                                    tinP.tlsDelF( LF , countTC() ) ; //TLS:1
                                                    tinP.tlsDelF( LF , countTC() ) ; //TLS:2
                                                    tinP.tlsDelF( LF , countTC() ) ; //TLS:3
    flagsT saveThreadMode1 = *(flagsT*)tinP.pbF() ; tinP.tlsDelF( LF , countTC() ) ; //TLS:4
                                                    tinP.tlsDelF( LF , countTC() ) ; //TLS:5
                                                    tinP.tlsDelF( LF , countTC() ) ; //TLS:6
                                                    tinP.tlsDelF( LF , countTC() ) ; //TLS:7
    _IO_
{
pSexLifoConstructed( 0 )
guts( *(guts_poolC_S*)(byteT*)napGuts ) ,
) ,
    0 , sizeof( guts_poolC_S ) , ifcOPENsHAREDmEMORYhOW_nCeF //ALWAYS USES MEMORY SPACE OF THE CONSTRUCTING PROCESS
    ) ,
        )
            tinP.pbF( 3 )                                                                                   /*TLS:5*/
            ) ,
                "."
                ) ,
                    tinP.pbF( 2 )                                                                           /*TLS:6*/
                    ) ,
                        "."
                        ) ,
                            postNameP
                            ) ,
                                tinP , tinP.pbF() , "poolC/guts/"                                           /*TLS:7*/
                            (
                            thirdC::c_strcpyIF
                            tinP ,
                        (
                        thirdC::c_strcatIF
                        tinP ,
                    (
                    thirdC::c_strcatIF
                    tinP ,
                (
                thirdC::c_strcatIF
                tinP ,
            (
            thirdC::c_strcatIF
            tinP ,
        (
        thirdC::c_strcatIF
        tinP.tlsNewF( LF , TUCK ) ,                                                                              //TLS:7     "poolC/guts/[postNameP].[this].[osTid]
        thirdC::c_itoaIF( tinP , tinP.pbF() , 0x10 , (countT)this ) ,                                       /*TLS:6*/
        tinP.tlsNewF( LF , 0x10 ) ,                                                                              //TLS:6     [this]
        thirdC::c_itoaIF( tinP , tinP.pbF() , 0x10 , tinP.osTid ) ,                                         /*TLS:5*/
        tinP.tlsNewF( LF , 0x10 ) ,                                                                              //TLS:5     "[osTid]"
    (
    tinP , idLineCtP , idiFileCtP , pbBitsCtP ,
(
napGuts
flagsInstance( flPOOLiNSTANCE_null ) ,
) ,
    )
        (poolC*)0
        tinP.flagsThreadMode1 |= flTHREADmODE1_ALLOWsTOPwHILEgRABBING ,
        *(flagsT*)tinP.pbF() = tinP.flagsThreadMode1 ,                                                      /*TLS:4*/
        tinP.tlsNewF( LF , sizeof( flagsT ) ) ,                                                                  //TLS:4     [flagsThreadMode1]
        ctFaceF( tinP , idLineCtP , idiFileCtP , pbBitsCtP , idStateSpaceP ) ,
    (
(
pNext
) ,
    sizeof( face_poolC_S ) , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_null , - 1 , idMemorySpaceP
    ) ,
                )
                    (const handleC*)*(fileC*)pbFileFace
                    ctFilesF( tinP , postNameP , idStateSpaceP ) ,
                (
            :
            ? 0
        !idStateSpaceP
    (
    ) ,
        )
            tinP.pbF( 2 )                                                                                   /*TLS:2*/
            ) ,
                "."
                ) ,
                    postNameP
                    ) ,
                        tinP , tinP.pbF() , "poolC/face/"                                                   /*TLS:3*/
                    (
                    thirdC::c_strcpyIF
                    tinP ,
                (
                thirdC::c_strcatIF
                tinP ,
            (
            thirdC::c_strcatIF
            tinP ,
        (
        thirdC::c_strcatIF
        tinP.tlsNewF( LF , TUCK ) ,                                                                              //TLS:3     "poolC/face/[postNameP].[idStateSpaceP]"
        thirdC::c_itoaIF( tinP , tinP.pbF() , 0x10 , idStateSpaceP ) ,                                      /*TLS:2*/
        tinP.tlsNewF( LF , 0x10 ) ,                                                                              //TLS:2     [idStateSpaceP]
    (
    tinP ,idLineCtP , idiFileCtP , pbBitsCtP ,
(
napFace
) ,
    ifcIDgRABlAYER_8POOL1cT , flBATONc_GRABBED | flBATONc_NOTjEALOUS , pb_batPoolCt , sizeof pb_batPoolCt
    ) ,
        )
            postNameP
            ) ,
                tinP , tinP.pbF() , "poolC/batonCt/"                                                        /*TLS:1*/
            (
            thirdC::c_strcpyIF
            tinP ,
        (
        thirdC::c_strcatIF
        tinP.tlsNewF( LF , TUCK ) ,                                                                              //TLS:1     "poolC/batonCt/[postNameP]"
    (
    tinP , idLineCtP , idiFileCtP , pbBitsCtP ,
(
batPoolCt
/*1*/poolC::poolC( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postNameP , const flagsT flagsP , const countT idStateSpaceP , const countT expCbDropMinP , const countT expCbDropMaxP , const countT* pczHintPreallocationP , countT idMemorySpaceP ) :/*1*/

}
    putNegAM( *(countT*)&finger , FINGERnEG_POOLcfACE ) ;
    _IO_
{
idListNameLath( 0 )
cRef( 1 ) ,
flFormat( flPOOLfORMAT_NOTES ) ,
idFormat( 1 ) ,
finger( 0 ) ,
poolC::face_poolC_S::face_poolC_S( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP ) :

}
    for( countT offg = 0 ; offg < CsLOTsIZESmAX ; offg ++ ) new( 0 , tinP , pbzaGrab + offg * sizeof( grabC ) , sizeof( grabC ) ) grabC( tinP , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS | flGRABc_SHARElAYER , ifcIDgRABlAYER_8POOL5nEW ) ;

    thirdC::c_memsetIF( tinP , (byteT*)ppSlots , sizeof ppSlots ) ;
    thirdC::c_strcpyIF( tinP , postName , postNameP ) ;
    _IO_
{
)
                    : 5
                    ? 4
                : expCbDropMax - expCbDropMin <= 0xf
                ? 3
            : expCbDropMax - expCbDropMin <= 7
            ? 2
        : expCbDropMax - expCbDropMin == 3
        ? expCbDropMax - expCbDropMin
    expCbDropMax - expCbDropMin <= 2
(
cBitsExpCbDrop
expCbDropMax( expCbDropMaxP != - 1 ? expCbDropMaxP : sizeof ppSlots / sizeof ppSlots[ 0 ] - 1 ) ,
expCbDropMin( expCbDropMinP != - 1 ? expCbDropMinP : 0                                        ) ,
pGrabNewElt( (grabC*)pbzaGrab ) ,
idMemorySpace( idMemorySpaceP ) ,
idStateSpace( idStateSpaceP ) ,
flagsCt( flagsP ) ,
poolC::guts_poolC_S::guts_poolC_S( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postNameP , const flagsT flagsP , const countT idStateSpaceP , const countT expCbDropMinP , const countT expCbDropMaxP , countT idMemorySpaceP ) :

//     | 
//     | f1 (impossible) f1                  5              (expCbDrop f1 IS IMPOSSIBLE BECAUSE THE LOWEST ALLOCATION GRAIN IS NOT AVAILABLE AND THE RUNNING PROGRAM'S FOOTPRINT OCCUPIES PART OF THE REMAINDER OF THE LOWER HALF OF THE FULL ADDRESS SPACE (THE UPPER HALF IS NOT ACCESSIBLE TO APPLICATION CODE)
//     | e1              e1                  5
//     | d1              d1                  5
//     | c1              c1                  5
//     | b1              b1                  5
//     | a1              a1                  5
//     | 91              91                  5
//     | 81              81                  5
//     | 71              71                  5
//     | 61              61                  5
//     | 51              51                  5
//     | 41              41                  5
//     | 31              31                  5
//     | 21              21                  5
//     | 11              11                  5
//     | 01              01 ---------------- 5
//     | f               f                   4
//     | e               e                   4
//     | d               d                   4
//     | c               c                   4
//     | b               b                   4
//     | a               a                   4
//     | 9               9                   4
//     | 8               8  ---------------- 4
//     | 7               7                   3
//     | 6               6                   3
//     | 5               5                   3
//     | 4               4  ---------------- 3
//     | 3               3                   2
//     | 2               2  ---------------- 2
//     | 1               1  ---------------- 1
//     | 0               0  ---------------- 0
//     | 
//     | EXPmAX-EXPmIN   HIGHESToFFSET       BITSnEEDED
//     | 
//  cBitsExpCbDrop IS SET ACCORDING TO THIS TABLE


/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

