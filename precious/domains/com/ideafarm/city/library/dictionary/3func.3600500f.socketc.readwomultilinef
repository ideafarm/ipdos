
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
        _OUT_
    
        tinP.pAdamGlobal3->_socketC_.grab.ungrabF( tinP ) ;
        pOdometer->cbWrite += tinP.odoSockCbWrite - _odoSockCbWriteOpen ;
        pOdometer->cbRead  += tinP.odoSockCbRead  - _odoSockCbReadOpen  ;
        pOdometer = (sockOdometerS*)&(countT&)*tinP.pAdamGlobal3->_socketC_.pSwOdometer ;
        tinP.pAdamGlobal3->_socketC_.nnLever = nnPeer ;
        tinP.pAdamGlobal3->_socketC_.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        bRead.ungrabF( tinP ) ;
    
        if( idleTimeAllowedRead ) FRESHtIMEaTOMIC( *pEther , timeLathRead.time1 , timeLathRead.time2 )
    
        if( !psttP ) { pEther->strMakeF( tinP , psttP , T("") ) ; ___( psttP ) ; }
    
        pEther->delF( tinP , psttDelimiter ) ;    
        }
            }
                pEther->delF( tinP , psttl ) ;
                pEther->strFuseF( tinP , psttP , tCRLF ) ; ___( psttP ) ;
                pEther->strFuseF( tinP , psttP , psttl , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ csttEstimateP ) ; ___( psttP ) ;
            {
            else
            }
                break ;
                pEther->delF( tinP , psttl ) ;
            {
            if( !pEther->strCompareF( tinP , psttl , psttDelimiter ) )
            readWoLineF( tinP , psttl , csttEstimateP ) ; ___( psttl ) ;
            ZE( strokeS* , psttl ) ;
        {
        while( !*pEther )
        TN( tCRLF , "\r\n" ) ;
    
        if( !csttEstimateP ) csttEstimateP = 0x100 ;
        else                 { pEther->strMakeF( tinP , psttDelimiter , T("")          ) ; ___( psttDelimiter ) ; }
        if( psttDelimiterP ) { pEther->strMakeF( tinP , psttDelimiter , psttDelimiterP ) ; ___( psttDelimiter ) ; }
        ZE( strokeS* , psttDelimiter ) ;
        _INoLD_
        bRead.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        const countT _odoSockCbWriteOpen = tinP.odoSockCbWrite ;
        const countT _odoSockCbReadOpen  = tinP.odoSockCbRead  ;
    
        }
            }
                return ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL
        SCOOPP
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/voidT socketC::readWoMultilineF( tinS& tinP , strokeS*& psttP , const strokeS* const psttDelimiterP , countT csttEstimateP )/*1*/

/**/
*/
  if 0 then 100 is implied
  can be 0
 csttEstimateP
   reading will stop when a null length line is encountered
  if 0 then T("") is used
  can be 0
  the delimiting line is excluded from the value returned in psttP
   in this example, reading will stop when a line consisting exactly of "stop here" is encountered
  example: T("stop here")
  value of the line to be used as the delimiting line
 psttDelimiterP
  after evaluation, will contain the lines read
 psttP
arguments
else psttP will contain a line, followed by "\r\n", for each line read, excluding the terminating line
if only the terminating line is read, psttP will be a null length string
the terminating line that equals the delimiter string is excluded from the returned string
the end of the message is marked by a line that is equal to psttDelimiterP
gets one multiline message from the peer
  \<A HREF=\"5.8430104.1.1.0.html\"\>8430104:  WAKEsHOW( "example.simplest.func.1070010.socketC.readWoMultilineF" )\</A\>
 simplest
examples
\<A HREF=\"5.1070010.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$readWoMultilineF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

