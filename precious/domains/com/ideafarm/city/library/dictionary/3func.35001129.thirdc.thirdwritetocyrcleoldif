
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        *pFlags2 = *pFlags1 = flCYRCLEoLDwRITE_CLEAN ; //THIS VALUE MUST NEVER GET ONTO A THREAD STACK OR INTO A POOLoLD, SUCH THAT IT MIGHT END UP IN AN UNINITIALIZED PORTION OF A TELL MESSAGE
        }
            }
                }
                    else if( pbc == (byteT*)&finger2 + sizeof finger2 ) { pbc = (byteT*)&finger1 ; bSuffix = 0 ; }
                    else if( pbc == (byteT*)&flags   + sizeof flags   )   pbc = (byteT*)&finger2 ;
                         if( pbc == (byteT*)&cbP     + sizeof cbP     ) { pbc = (byteT*)&flags   ; pFlags2 = (flagsT*)pbWrite ; }
                {
                else
                }
                    else if( pbc ==          pbP     +        cbP     ) { pbc = (byteT*)&cbP     ; bSuffix = 1 ; }
                    else if( pbc == (byteT*)&cbP     + sizeof cbP     )   pbc =          pbP     ;
                    else if( pbc == (byteT*)&flags   + sizeof flags   )   pbc = (byteT*)&cbP     ;
                         if( pbc == (byteT*)&finger1 + sizeof finger1 ) { pbc = (byteT*)&flags   ; pFlags1 = (flagsT*)pbWrite ; }
                {
                if( !bSuffix )

                cbc -= cbThis ;
                pbc += cbThis ;
    
                if( pbWrite == pbEnd ) pbWrite = pbCircle ;
                pbWrite += cbThis ;
                c_memcpyIF( tinP , pbWrite , pbc , cbThis ) ;
            {
            if( !POOP )
    
            }
                }
                    ++ s ; thirdC::dosSleepRawIF( tinP , 50 ) ;

                    }
                        break ;
                        __1
                    {
                    if( F(ph->flags) & flCYRCLEoLD_CLOSING )

                {
                while( cbwNew - ph->cbRead > cbCircle )
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
    
            countT cbwNew = cbWrittenPrior + cbThis ; //U::2008.07.05: CONJ: CNR NOW: 
            //countT cbwNew = ph->cbWritten + cbThis ; //U::BUG? CONJ: SHOULD BE CBwRITTENpRIOR
    
            cbThis = pbP + cbP - pbc ;
            )
                cbThis >  pbP + cbP - pbc
                pbc    <  pbP + cbP                               &&
                pbc    >= pbP                                     &&
            (
            else if
            cbThis = (byteT*)&cbP + sizeof cbP - pbc ;
            )
                cbThis >  (byteT*)&cbP + sizeof cbP - pbc
                pbc    <  (byteT*)&cbP + sizeof cbP               &&
                pbc    >= (byteT*)&cbP                            &&
            (
            else if
            cbThis = (byteT*)&flags + sizeof flags - pbc ;
            )
                cbThis >  (byteT*)&flags + sizeof flags - pbc
                pbc    <  (byteT*)&flags + sizeof flags           &&
                pbc    >= (byteT*)&flags                          &&
            (
            else if
            cbThis = (byteT*)&finger1 + sizeof finger1 - pbc ;
            )
                cbThis >  (byteT*)&finger1 + sizeof finger1 - pbc
                pbc    <  (byteT*)&finger1 + sizeof finger1       &&
                pbc    >= (byteT*)&finger1                        &&
            (
            if
            countT cbThis = cbc - cbOver ;

            countT cbOver = bSplit ? pbWrite + cbc - pbEnd : 0 ;
            boolT bSplit  =          pbWrite + cbc > pbEnd ;
        {
        while( cbc )
        ZE( boolT , bSuffix ) ;
        const byteT* pbc = (byteT*)&finger1 ;
        ZE( flagsT* , pFlags2 ) ;
        ZE( flagsT* , pFlags1 ) ;
        const static flagsT flags = flCYRCLEoLDwRITE_null ; //THIS VALUE SHOULD (FOR EXTRA SAFETY) NEVER GET ONTO A THREAD STACK OR INTO A POOLoLD, SUCH THAT IT MIGHT END UP IN AN UNINITIALIZED PORTION OF A TELL MESSAGE

        byteT* pbWrite = pbCircle + cbWrittenPrior % cbCircle ;

        }
            if( cbWrittenPrior == setIfEqualsAM( ph->cbWritten , cbWrittenPrior + cbc , cbWrittenPrior ) ) break ;
            cbWrittenPrior = ph->cbWritten ;
        {
        for(;;)
        ZE( countT , cbWrittenPrior ) ; //ATOMICALLY RESERVE AN ARC ON THE CIRCLE

        countT cbc = 6 * sizeof cbP + cbP ; // FINGERPRINT ; FLAGS; LENGTH PREFIX ; DATA ; LENGTH SUFFIX ; FLAGS ; FINGERPRINT

        byteT* pbEnd    = pbCircle + cbCircle ;
        byteT* pbCircle = (byteT*)ph + sizeof( cyrcleOldHeaderS ) ;
        const countT cbCircle = (countT)napkinP - sizeof( cyrcleOldHeaderS ) ;
        //PSEUDODUPLICATED CODE: 1020166 1020197
    {
    if( !POOP )

    { __( F(ph->flags) & flCYRCLEoLD_CLOSING ) ; }
    //AN EXCEPTION HERE WOULD CAUSE A RECURSIVE GRAB OF ph->bGrab

    cyrcleOldHeaderS* ph = (cyrcleOldHeaderS*)(byteT*)napkinP ;
    _IO_

    }
        if( POOP ) return ;
        __( cbP >= TOCK ) ; //U::TO CATCH A BUG
        __(  pbP + cbP - pbBad2 ) ;
        __(  pbP + cbP - pbBad1 ) ;
        byteT* pbBad2 = c_memmemIF( tinP , pbP , cbP , (byteT*)&finger2 , sizeof finger2 ) ;
        byteT* pbBad1 = c_memmemIF( tinP , pbP , cbP , (byteT*)&finger1 , sizeof finger1 ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    }
        putNegAM( *(countT*)&finger2 , FINGERnEG_CYRCLEoLDwRITEeND ) ; //THIS VALUE MUST NEVER GET ONTO A THREAD STACK OR INTO A POOLoLD, SUCH THAT IT MIGHT END UP IN AN UNINITIALIZED PORTION OF A TELL MESSAGE
        putNegAM( *(countT*)&finger1 , FINGERnEG_CYRCLEoLDwRITE    ) ; //THIS VALUE MUST NEVER GET ONTO A THREAD STACK OR INTO A POOLoLD, SUCH THAT IT MIGHT END UP IN AN UNINITIALIZED PORTION OF A TELL MESSAGE
        bWoth = 0 ;
    {
    if( bWoth )
{
/*1*/voidT thirdC::thirdWriteToCyrcleOldIF( tinS& tinP , napkinC& napkinP , const byteT* const pbP , countT cbP )/*1*/

boolT bWoth = 1 ;
const countT finger2 = 0 ;
const countT finger1 = 0 ;

/**/
*/
 cbP
  this blob must not contain the value FINGERnEG_CYRCLEoLDwRITE
 pbP
 napkinP
 tinP
arguments
\<A HREF=\"5.1020166.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$thirdWriteToCyrcleOldIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

