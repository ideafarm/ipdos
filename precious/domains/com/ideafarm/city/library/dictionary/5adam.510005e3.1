
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

CONoUTrAW( "ok\r\n" ) ;

THREADmODE2rESTORE
}
    }
        }
            }
                else       etThread.osThreadF( TaRG1( tmListServeF ) , (countT)pso , (countT)&puseMaster ) ;
                if( POOP ) { DEL( pso ) ; }
                __( bRefuse ) ;
                socket.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ; ___( pso ) ;
                ZE( boolT , bRefuse ) ;
                ZE( countT , idPortPeer ) ;
                nicNameC nnPeer ;
                ZE( socketC* , pso ) ;
            {
            while( !ether && !POOP )
    
            }
                }
                    /*PROD*/ ether.osThreadAdamF( tinP , idAdamRoot ) ;
                    
                    else                                          { LOGrAW( "root adam is soixlOld interpreter, so will not fire os on exception\r\n" ) ; } //TO FIND A BUG; REMOVE THIS LINE (ELSE CLAUSE ONLY) IN PRODUCTION
                    if( idAdamRoot != ifcIDaDAM_SOIXLoLDiNTERPRETER ) homeS::homeIF().flags |= flHOMEs_FIREoSoNuNHANDLEDeXCEPTION ;
                    
                    }
                        ether.delF( tinP , psttSetting ) ;
                        }
                            if( idAdamSetting ) idAdamRoot = idAdamSetting ;
                            countT idAdamSetting = etThread.strDigitsToSCountF( tinP , psttSetting ) ;
                        {
                        if( psttSetting )
                        etThread.boxGetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF( tinP , psttSetting , T("///d/ideafarm.home.")+TF1(etherC::ifc_idHomeIdisk_IF())+T(".setting.keyValue.idAdamRoot") ) ; ___( psttSetting ) ;
                        ZE( strokeS* , psttSetting ) ;
                    {
                    countT idAdamRoot = ifcIDaDAM_SOIXLoLDiNTERPRETER ;
                {

                //if( idCycle == 1 ) etThread.osThreadF( TaRG1( tmTestF ) ) ;
            {
            if( idCycle == 1 )
    
            socket.listenF( tinP ) ;
            homeS::homeIF().idPortListMoneyBuckets = socket.bindF( tinP ) ;
            socketC socket( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    
            ++ idCycle ;
        {
        while( !ether )
        ZE( countT , idCycle ) ;
    {
    IFsCRATCH
    
    puseC puseWork1( tinP , ifcIDpOOL_ADAMtEMP ) ; //--------------------------------------------------------------------------------------
    puseC puseMaster( tinP , "list.moneyBuckets" , flPOOLc_null , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
{
THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

TODO

DONE( tmTestF )
}
    bucketDetailC info2( tinP ) ;

    CONoUTrAW( T("total: ")+TF2(info.moneyT1,flFORMAT_NObIGITvALUES)+T(",")+TF2((sCountT)info.moneyT2,flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
    bucketTotalC info( tinP ) ;

    }
        depositS info( tinP , ifcIDaCCbUCKEToWNER_IFO  , ifcIDbUCKET_CENTRALbANK , ifcIDpRODUCTcENTRALbANK_EXCHANGEmEDIA , 3/*idAccDepositor*/ , c8n/*pczNote*/ , timeN1 , timeN2 , 0x22222222/*idDeposit*/ , 0x11111111/*idAccCommission*/ , moneyT1 , moneyT2 ) ;

        etThread.osTimeSubtractF( tinP , moneyT1 , moneyT2 , 8 * TICK , 0 ) ;
        ZE( sCountT , moneyT2 ) ;
        ZE( countT  , moneyT1 ) ;

        count8S c8n( 6 , 7 , 8 , 9 ) ;

        }
            CONoUTrAW( T("time: ")+T(pczTime)+T("\r\n") ) ;
            countT pczTime[] = { timeN1 , timeN2 , 0 } ;
        {
        etThread.osTimeNowUniqueF( tinP , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;
    {
    while( cToDo -- )
    countT cToDo = 0 ;
{
if( pTaskP )
TASK( tmTestF )






        }
            return threadLocalStorageF( ifcIDtYPEtLS_KID , tmListServeF_workF , (countT)argP , 0 , 0 , 0 , 0 , "tmListServeF" ) ;
        {
        TASK0PROTO( tmListServeF )


        DONE1
        }
            }
                dec02AM( cAllThreads ) ; /* MUST BE THE VERY LAST THING THAT THIS THREAD DOES */
                if( !bFake ) { DEL( pTaskP ) ; } /* MUST BE AS LATE AS POSSIBLE BECAUSE IT GIVES THE SIGN THAT THE THREAD IS DONE.  THE PROCESS MUST SLEEP AFTER RECEIVING THIS SIGN BEFORE ENDING, SO THAT THIS THREAD CAN COMPLETE */
                if( tinP.monitor.idThread <= ClOWtHREADS ) processGlobal1S::_processGlobal1I_IF().pcPhaseLow[ tinP.monitor.idThread ] = - 1 ;
                TELL( "DONE0: i am outa here" )
                ;
                    : thirdC::os_cAllKidThreadsI_IF( tinP )
                    ? thirdC::os_cAllOrphanThreadsI_IF( tinP )
                countT& cAllThreads = bOrphan
                boolT bFake   = pTaskP ? !!( F(pTaskP->flags) & flTHREADlAUNCH_FAKE   ) : 0 ;
                boolT bOrphan = pTaskP ? !!( F(pTaskP->flags) & flTHREADlAUNCH_ORPHAN ) : 0 ;
                TELL( "DONE0: deregistering myself from either cAllOrphanThreadsI or cAllKidThreadsI (my final act)" )
                TINSL /*THIS IS NEEDED BECAUSE tinP WAS DELETED IF I AM tmWindowsF */
            {
            if( pEtThread ) *pEtThread = 0 ;

            }
                }
                    }
                        }
                            TELL( "DONE0: after deleting pEtThread, which destroys tinP in poolOld" )
                            if( pEtThread ) { BLAMMO ; }
                            PUSE( tinP , *(byteT**)&pEtThread ) ;
                            TINSL
                        {
                        }
                            DELzOMBIE( pDoomed ) ; /* tinP IS DESTROYED HERE */
                            etherC* pDoomed = pEtThread ;
                        {
                        DEL( tinP.pEtScratch ) ;
                        DEL( tinP.pScoopEtThread ) ; /*CODEsYNC: 0010056 1020171 */
                        TELL( "DONE0: deleting etThread (and tinP)" ) ;
                        tinP.pEther = 0 ;
                        TELL( "DONE0: testing poolOld" ) ;

                        }
                            tinP.pEtScratch->delF( tinP , psttThreadFile ) ;
                            tinP.pEtScratch->boxZapF( tinP , psttThreadFile ) ;
                            TELL( "DONE0: deleting thread file" ) ;
                        {
                        if( psttThreadFile )
                    {
                    if( pEtThread ) /*THREADS THAT DELETE etThread EARLY: tmWindowsF*/
                    TINSL /*THIS IS NEEDED BECAUSE tinP WAS DELETED IF I AM tmWindowsF */
                {

                }
                    }
                        if( tinP.monitor.idThread <= ClOWtHREADS && !( ++ processGlobal1S::_processGlobal1I_IF().pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                        if( tinP.idPhase1 < ifcIDpHASEtHREAD_EPILOGnOkIDS ) tinP.idPhase1 = ifcIDpHASEtHREAD_EPILOGnOkIDS ;
                        }
                            TELL( "DONE0: destroying all adam objects that remain on the thread stack" ) ;
                            }
                                while( tinP.cKidThreads ) { ++ s ; thirdC::dosSleepRawIF( tinP , 250 ) ; }
                                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                            {
                            TELL( "DONE0: waiting for my kid threads to end" ) ;

                            if( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_WHEREaLL && !( F(tinP.flagsThreadMode1) & flTHREADmODE1_NOwHERE ) ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_DISABLE ) ;
                            TELL( "DONE0: conditionally calling etherWhereF" ) ;
                        {
                        else
                        if( !pEtThread ) ; /*THIS IS NEEDED BECAUSE tinP WAS DELETED IF I AM tmWindowsF */

                        TELL( "DONE0: after returning from application code" ) ;
                        _OUT_
                        tinP.idPhase2 = 0 ;
                        if( tinP.idPhase1 < ifcIDpHASEtHREAD_EPILOGkIDS ) tinP.idPhase1 = ifcIDpHASEtHREAD_EPILOGkIDS ;
                        if( tinP.monitor.idThread <= ClOWtHREADS && !( ++ processGlobal1S::_processGlobal1I_IF().pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                        TINSL /*THIS IS NEEDED BECAUSE tinP WAS DELETED IF I AM tmWindowsF */
                    {
                    /*DO NOT CLOSE THE CODE BLOCK HERE BECAUSE KID THREADS MIGHT BE USING OBJECTS THAT WOULD DT HERE*/
                                                                                                                                                                    \






//U::DONE( tmListServeF )





}
    }
        DEL( psoP ) ;
        if( POOP ) POOPR

        }
            psoP->writeF( tinP , sOut ) ;
            sOut << bDone ;

            THREADmODE2rESTORE
            }
                DEL( pGrabit ) ;
                }
                    PUSE.ungrabListOld2012F( tinP , hListMain ) ;
                    puseC puseMaster( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                {
                if( ~hListMain )
            {
            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

            }
                }
                    break ;
                    __1 ;
                    __( idCmd ) ;
                {
                default :
                }
                    break ;

                    bDone = !POOP ;

                    }
                        }
                            PUSE( tinP , *(byteT**)&pczSquished ) ;

                            sOut << *( pcc ++ ) ; // idAccBucketOwner
                            sOut << *( pcc ++ ) ; // idBucket
                            sOut << *( pcc ++ ) ; // idProduct
                            sOut << *( pcc ++ ) ; // idAccDepositor

                            __( *( pcc ++ ) - LISTnAMEnOTEbEGIN ) ;
                            }
                                pcc += ccNote1 ;
                                PUSE( tinP , *(byteT**)&pczNote ) ;
                                //CONoUTrAW( T("GETdETAIL sent: [pczNote]: ")+T(pczNote)+T("\r\n") ) ;
                                sOut << pczNote ;
                                }
                                    pczNote[ ccNote1 ] = 0 ;
                                    thirdC::c_memcpyIF( tinP , (byteT*)pczNote , (byteT*)pcc , cban - sizeof( countT ) ) ;
                                {
                                if( pczNote )
                                countT* pczNote = (countT*)PUSE.newF( tinP , LF , cban ) ; ___( pczNote ) ;
                                countT cban = sizeof( countT ) * ( ccNote1 + 1 ) ;

                                }
                                    while( *( pcc2 ++ ) != LISTnAMEnOTEbEGIN ) ccNote1 ++ ;
                                    countT* pcc2 = pcc ;
                                {
                                ZE( countT , ccNote1 ) ;
                            {
                            __( *( pcc ++ ) - LISTnAMEnOTEeND ) ;

                            sOut << *(countT*)&timeT2 ;
                            sOut << timeT1 ;
                            etThread.osTimeSubtractF( tinP , timeT1 , timeT2 , pcc[ 0 ] , pcc[ 1 ] ) ; pcc += 2 ;
                            ZE( sCountT , timeT2 ) ;
                            ZE( countT  , timeT1 ) ;

                            sOut << *( pcc ++ ) ; // idDeposit
                            sOut << ( *( pcc ++ ) & ~BM_HIGH ) ; // idAccCommission

                            countT* pcc = pczSquished ;

                            sOut << *(countT*)&moneyT2 ;
                            sOut << moneyT1 ;

                            //0000008f,1- at 11111111/22222222/7a46d4df/6aec4ff7/3005dddd/6/7/8/9/2005dddd/3/1/1/1

                            //CONoUTrAW( TF2(moneyT1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(",")+TF2(moneyT2,flFORMAT_NObIGITvALUES)+T(" at ")+T(pczSquished)+T("\r\n") ) ;
        
                            PUSE( tinP , *(byteT**)&pczListName ) ;
                            etherC::strSquishOldIF( tinP , pczSquished , pczListName + 2 ) ; ___( pczSquished ) ;
                            ZE( countT* , pczSquished ) ;
                        {
                        if( ccListName > 2 )
                        
                        pczListName[ ccListName - 1 ] = 0 ;
                        countT ccListName = thirdC::c_strlenIF( tinP , pczListName ) ;

                        //CONoUTrAW( TF2(moneyT1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(",")+TF2(moneyT2,flFORMAT_NObIGITvALUES)+T(" at ")+T(pczListName)+T("\r\n") ) ;

                        countT*& pczListName = *(countT**)&c3d.c3 ;
                        sCountT& moneyT2     = *(sCountT*)&c3d.c2 ;
                        countT&  moneyT1     =             c3d.c1 ;
                        
                        count3S& c3d = *(count3S*)&(countT&)swDeposit ;
                        pczTime2Time2IdDeposit = (countT*)swDeposit.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    sOut << cFlavors ;
                    countT cFlavors = swDeposit.cFlavorsF( tinP ) ;

                    THREADmODE2rESTORE
                    }
                        PUSE.listOld2012F( tinP , hListMain , ifcIDhOWlIST_FIFO , &arg , 0 , listingInspectMoneyBucketsCBF ) ;
                        puseC puseMaster( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                    {
                    if( ~hListMain )
                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                    arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;
                    arg.pc Utility[ 1 ] = (countT)&swDeposit ;
                    arg.pc Utility[ 0 ] = (countT)&pczTime2Time2IdDeposit ;
                    arg.flagsInspect = /*flAPTiNSPECT_CHATTERtOcONSOLE |*/ flAPTiNSPECT_RECURSE ;
                    listWalkArgOldS arg( tinP ) ;

                    switchC swDeposit( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , pczTime2Time2IdDeposit , 0 , sizeof( count3S ) ) ;
                    ZE( const countT* , pczTime2Time2IdDeposit ) ;
                {
                case ifcIDcMDlISTsERVERmONEYbUCKETS_GETdETAIL :
                }
                    break ;

                    bDone = !POOP ;
                    sOut << arg.pc Utility[ 4 ] ; // moneyTotal2
                    sOut << arg.pc Utility[ 1 ] ; // moneyTotal1

                    arg.pc U tility[ 4 ] += arg.pc Utility[ 2 ] ;

                    if( arg.pcUtility[ 5 ] ) { LOGrAW5( "" , DDNUMB , ": exception: accumulator overflow 2: " , arg.pcUtility[ 5 ] , "\r\n" ) ; } //U::THIS SHOULD BE PRACTICALLY IMPOSSIBLE
                    // arg.pc Utility[ 5 ] moneyTotal2 overflow
                    // arg.pc Utility[ 4 ] moneyTotal2
                    // arg.pc Utility[ 2 ] moneyTotal1 overflow
                    // arg.pc Utility[ 1 ] moneyTotal1

                    THREADmODE2rESTORE
                    }
                        PUSE.listOld2012F( tinP , hListMain , ifcIDhOWlIST_FIFO , &arg , 0 ) ;
                        puseC puseMaster( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                    {
                    if( ~hListMain )
                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                    arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;
                    arg.pc Utility[ 3 ] = TfIELD_MONEYhIGH ; // moneyTotal2
                    arg.pc Utility[ 0 ] = TfIELD_MONEYlOW  ; // moneyTotal1
                    arg.flagsInspect = /*flAPTiNSPECT_CHATTERtOcONSOLE |*/ flAPTiNSPECT_RECURSE | flAPTiNSPECT_ACCUMULATE ;
                    listWalkArgOldS arg( tinP ) ;                    
                {
                case ifcIDcMDlISTsERVERmONEYbUCKETS_GETtOTAL :
                }
                    break ;

                    THREADmODE2rESTORE
                    }
                        bDone = !POOP ;
                        if( moneyT2 ) TpUSHfIFOcOUNT( TfIELD_MONEYhIGH , moneyT2 ) ;
                        if( moneyT1 ) TpUSHfIFOcOUNT( TfIELD_MONEYlOW  , moneyT1 ) ;
                        }
                            PUSE.unlistOld2012F( tinP , hListMain , &arg ) ; //DUPLICATE PUT WILL RESULT IN REPLACEMENT
                            arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;
                            listWalkArgOldS arg( tinP ) ;
                        {
                        if( bListExisted )
                        puseC puseMaster( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                    {
                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                    sIn >> *(countT*)&moneyT2 ;
                    ZE( sCountT , moneyT2 ) ;

                    sIn >> moneyT1 ;
                    ZE( countT , moneyT1 ) ; //MONEY IS STORED THE SAME WAY THAT TIME IS STORED; THE TIME FUNCTIONS ARE USED TO PERFORM ARITHMETIC ON MONEY VALUES
                    __Z( hListMain ) ;
                {
                case ifcIDcMDlISTsERVERmONEYbUCKETS_PUT :
            {
            switch( idCmd )
            ZE( boolT , bDone ) ;

            }
                PUSE( tinP , *(byteT**)&pczSquished ) ;
                }
                    PUSE( tinP , *(byteT**)&pczListMain ) ;
                    //CONoUTrAW( T(DASH127 "\r\n")+TF2(idCmd,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" <")+T(pczListMain)+T(">\r\n") ) ;
                    THREADmODE2rESTORE
                    }
                        bListExisted = PUSE.openListOld2012F( tinP , hListMain , pczListMain , idCmd == ifcIDcMDlISTsERVERmONEYbUCKETS_PUT ? flLISTwALKoLD_null : flLISTwALKoLD_DOnOTcREATElIST ) ;
                        puseC puseMaster( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                    {
                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                    pGrabit = new( 0 , tinP , LF ) grabitC( tinP , TAG( TAGiDnULL ) ) ; ___( pGrabit ) ;
    
                    etherC::strStretchIF( tinP , pczListMain , count8S( LISTnAME_ROOTaPPLICATION , LISTnAMEiDfORMAT ) , pczSquished ) ; ___( pczListMain ) ;
                    ZE( countT* , pczListMain ) ;
                {
                if( pczSquished )
                //CONoUTrAW( T(DASH127 "\r\n")+TF2(idCmd,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" {")+T(pczSquished)+T("}\r\n") ) ;

                //
                // [LISTnAME_ROOTaPPLICATION][LISTnAMEiDfORMAT]<idAccBucketOwner><idBucket><idProduct><idAccDepositor><pczNote><-timeN2><-timeN1><idDeposit><idAccCommission>
                //
                // APPLICATION           IDfORMAT        IDaCCbUCKEToWNER  IDbUCKET  IDpRODUCT  IDaCCdEPOSITOR  NOTE     TIME              IDdEPOSIT  IDaCCcOMMISION
                //
                // LIST NAME AFTER EXPANSION WILL BE:
                //
                //
                //
                //
                // IDaCCcOMMISSION:     IDENTIFIES SOMEONE WHO CLAIMS A COMMISSION ON THIS DEPOSIT; (WHEN COMMISSIONS ARE TO BE PAID TO MULTIPLE PARTIES, MAKE SEPARATE DEPOSITS ALL BEARING THE SAME TIMESTAMP)
                //
                // IDdEPOSIT:           UNIQUELY IDENTIFIES THIS DEPOSIT WITHIN THE DEPOSIT SET THAT CONTAINS IT
                //
                // TIME:                IDENTIFIES THE DEPOSIT SET (EXCHANGE SET) TO WHICH THIS DEPOSIT BELONGS; MUST BE OBTAINED FROM osTimeNowUniqueF
                //
                // NOTE:                NULL TERMINATED LIST OF COUNT VALUES PERMANENTLY ASSOCIATED WITH THIS DEPOSIT (USER WILL BE ABLE TO EDIT THIS, WHICH USE LIST RENAMING)
                //
                // IDaCCdEPOSITOR:      WHOEVER IS LOGGED IN OR MAKES A PAYPAL PAYMENT
                //
                // IDpRODUCT:           ifcIDpRODUCTcENTRALbANK_EXCHANGEmEDIA
                //
                // IDbUCKET:            ifcIDbUCKET_CENTRALbANK
                //
                // IDaCCbUCKEToWNER:    ifcIDaCCbUCKEToWNER_IFO
                //
                // IDfORMAT:            ALWAYS THE SAME VALUE; IF THE CURRENT DESIGN WILL NOT SUPPORT A DESIRED ENHANCEMENT, A NEW LIST CAN BE USED WITHIN THE SAME BACKING FILES
                //
                // APPLICATION:         REQUIRED BY LIST SYSTEM
                //
                // LIST NAME SEMANTICS
                //
                //
                //
                // THIS LIST STORES THE AMOUNT OF THE DEPOSIT AND MERELY DOCUMENTS THE IDENTITY OF THE COMMISSIONER WHO HAS A CLAIM BASED UPON THIS DEPOSIT
                // WHEN A COMMISSION IS INVOLVED, THE MONETARY AMOUNT OF THE COMMISSION IS NOT STORED IN THIS LIST
                // ALL SUCH DEPOSITS MUST HAVE THE SAME TIMESTAMP TO INDICATE THE IDENTITY OF THE EXCHANGE SET OF WHICH THEY ARE A PART
                // WHEN MULTIPLE COMMISSIONS ARE ASSOCIATED WITH A DEPOSIT, A SEPARATE DEPOSIT IS MADE FOR EACH idAccComission VALUE
                // EACH KID LIST CONTAINS A SINGLE LISTING, WHICH IS A countT VALUE
                // EACH LIST NAME IS ASSOCIATED WITH A PAIR OF KID LISTNAMES: TfIELD_MONEYlOW TfIELD_MONEYhIGH
                //
    
                PUSE( tinP , *(byteT**)&pczNote ) ;
                }
                    }
                                                          pczSquished[ offs ++ ] = 0 ;                                    //CS:A  b
                        if( bAll || idAccBucketOwner    ) pczSquished[ offs ++ ] = idAccBucketOwner ;                     //CS:A  a
                        if( bAll || idBucket            ) pczSquished[ offs ++ ] = idBucket ;                             //CS:A  9
                        if( bAll || idProduct           ) pczSquished[ offs ++ ] = idProduct ;                            //CS:A  8
                        if( bAll || idAccDepositor      ) pczSquished[ offs ++ ] = idAccDepositor ;                       //CS:A  7
                        }
                                                          pczSquished[ offs ++ ] = LISTnAMEnOTEbEGIN ; /*DELIMITER*/         //CS:A  6
                                                          }
                                                              while( cToDo -- ) pczSquished[ offs ++ ] = pczNote[ offn ++ ] ;
                                                              countT cToDo = cczNote ;
                                                              ZE( countT , offn ) ;
                                                          {
                            if( bAll || timeT2          ) pczSquished[ offs ++ ] = LISTnAMEnOTEeND ; /*DELIMITER*/         //CS:A  5
                            // IF !timeT2 THEN DON'T NEED DELIMITER SO OMIT IT; THIS WILL ALLOW CLIENT TO SPECIFY PARTIAL NOTES TO GET AGGREGATED TOTALS
                        {
                        if( bAll || pczNote             )
                        if( bAll || timeT2              ) pczSquished[ offs ++ ] = timeT2 ;                               //CS:A  4
                        if( bAll || timeT1              ) pczSquished[ offs ++ ] = timeT1 ;                               //CS:A  3
                        if( bAll || idDeposit           ) pczSquished[ offs ++ ] = idDeposit ;                            //CS:A  2
                        if( bAll || idAccCommission     ) pczSquished[ offs ++ ] = idAccCommission | BM_HIGH ;            //CS:A  1
                        ZE( countT , offs ) ;
                    {
                    if( pczSquished )
                    etThread.newF( tinP , LF , pczSquished , ccaSquished ) ; ___( pczSquished ) ;
                    const countT ccaSquished = cczNote + 0xb ;                                                            //CS:A
                {
                ZE( countT* , pczSquished ) ;
    
                sIn >> idAccCommission ;
                ZE( countT , idAccCommission ) ;
    
                __( bAll && !idDeposit ) ;    
                sIn >> idDeposit ;
                ZE( countT , idDeposit ) ;
    
                }
                    etThread.osTimeSubtractF( tinP , timeT1 , timeT2 , timeP1 , timeP2 ) ; //SIGN IS REVERSED ON TIME VALUES SO THAT LATEST TRANS WILL BE LIGHTEST SO WILL NOT SINK
    
                    __( bAll && !timeP2 ) ;    
                    sIn >> *(countT*)&timeP2 ;
                    ZE( sCountT , timeP2 ) ;
        
                    sIn >> timeP1 ;
                    ZE( countT , timeP1 ) ;
                {
                ZE( sCountT , timeT2 ) ;
                ZE( countT , timeT1 ) ;
    
                const countT cczNote = !pczNote ? 0 : thirdC::c_strlenIF( tinP , pczNote ) ;
                sIn >> pczNote ; ___( pczNote ) ; // LEAST SIGNIFICANT -> MOST SIGNIFICANT
                ZE( countT* , pczNote ) ;
    
                __( bAll && !idAccDepositor ) ;    
                sIn >> idAccDepositor ;
                ZE( countT , idAccDepositor ) ;
    
                __( bAll && !idProduct ) ;    
                sIn >> idProduct ;
                ZE( countT , idProduct ) ;
    
                __( bAll && !idBucket ) ;    
                sIn >> idBucket ;
                ZE( countT , idBucket ) ;

                __( bAll && !idAccBucketOwner ) ;    
                sIn >> idAccBucketOwner ;
                ZE( countT , idAccBucketOwner ) ;
                        
                sOut << (countT)1 ; //idFormat
                sOut << (countT)FINGERnEG_LISTsERVERrEPLY ;
    
                boolT bAll = idCmd == ifcIDcMDlISTsERVERmONEYbUCKETS_PUT ;
                sIn >> idCmd ;
    
                __( idFormat - 1 ) ;
                sIn >> idFormat ;
                ZE( countT , idFormat ) ;
    
                __( finger - FINGERnEG_LISTsERVERcMD ) ;
                sIn >> finger ;
                ZE( countT , finger ) ;

                }
                    break ;
                    POOPR
                {
                if( POOP )
    
                psoP->readF( tinP , sIn ) ;
            {
            ZE( countT , idCmd ) ;
            ZE( boolT , bListExisted ) ;
            handleC hListMain( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LIST oLD ) ;
            ZE( grabitC* , pGrabit ) ;

            soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
            soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
        {
        while( !ether && !POOP )

        psoP->etherF( tinP , *tinP.pEtScratch ) ;
        SCOOPS
    {
    IFsCRATCH

    puseC&    puseMasterP =  *(puseC*)pTaskP->c2 ;
    socketC*  psoP      = (socketC*)pTaskP->c1 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmListServeF )

}
    return heavy ;

    _OUT_

    }
        }
            }
                }
                    break ;
                    __1 ;
                    __( pdListing->flagsF() & fliLISTINGc_maskTypeBits ) ;
                {
                default :
                }
                    break ;

                    }
                        }
                            }
                                PUSE( tinP , *(byteT**)&pczListNameKid ) ;
                                puseC puse( tinP , ifcIDpOOL_ADAMtEMP ) ;
                            {
    
                            }
                                argP.flagsWalk = flagsSave ;

                                -- argP.offNestLevel ;
                                paList->walkOldF( tinP , ifcIDmODEaPTsINK_LEADsHOES , &argP , 0 , listingInspectMoneyBucketsCBF , pczListNameKid ) ;
                                ++ argP.offNestLevel ;
    
                                argP.flagsWalk |= flLISTwALKoLD_DOnOTuNGRABlIST ;
                                flagsT flagsSave = argP.flagsWalk ;
    
                                pczListNameKid[ ccDad    ] = 0 ;
                                pczListNameKid[ ccDad ++ ] = A lIST.idNameF() ;
                                thirdC::c_memcpyIF( tinP , (byteT*)pczListNameKid , (byteT*)pczListNameP , sizeof( countT ) * ccDad ) ;
                            {
                            if( pczListNameKid )
    
                            }
                                pczListNameKid = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccDad + 2 ) ) ; ___( pczListNameKid ) ;
                                puseC puse( tinP , ifcIDpOOL_ADAMtEMP ) ;
                            {
                            ZE( countT* , pczListNameKid ) ;
                            countT ccDad = thirdC::c_strlenIF( tinP , pczListNameP ) ;
                        {
                        if( paList )

                        }
                            }
                                break ;
                                __1 ;
                                __( pdListing->idTypeDatumF() ) ;
                            {
                            default :
                            }
                                break ;
                                paList = &A lISToStEXT ;
                            {
                            case ifcIDtYPEmIXINdATUM_blob :
                            }
                                break ;
                                paList = &A lISTcOUNT ;
                            {
                            case ifcIDtYPEmIXINdATUM_countT :
                        {
                        switch( pdListing->idTypeDatumF() )
                        ZE( listC* , paList ) ;
                    {
                    if( F(argP.flagsInspect) & flAPTiNSPECT_RECURSE )

                    }
                        }
                            break ;
                            __1 ;
                            __( pdListing->idTypeDatumF() ) ;
                        {
                        default :
                        }
                            break ;
                            }
                                argP.flagsInspect |= flAPTiNSPECT_ABORT ;
                                )
                                    ( F(argP.flagsInspect) & flAPTiNSPECT_SETaBORTfLAGiFmATCH && bMatch )
                                    F(argP.flagsInspect) & flAPTiNSPECT_SETaBORTfLAGiFeXISTS               ||
                                (
                                if
    
                                }
                                    else argP.idNameFound = A lISToStEXT.idNameF() ;
                                    }
                                        *argP.pStk_idNameFound << (byteT*)pc2 ;
                                        //CONoUTrAW5( "**************** 3 **************** [offNestLevel,idNameFound]: " , argP.offNestLevel , " " , argP.idNameFound , "\r\n" ) ; //U::
                                        puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                                        countT pc2[] = { argP.offNestLevel , A lISToStEXT.idNameF() } ;
                                    {
                                    if( argP.pStk_idNameFound )
                                    argP.offNestLevelIdNameFound = argP.offNestLevel ;
                                {
                                if( bMatch )

                                if( argP.idNameSpec ) //SETmATCHnAME( heavy )
                                boolT bMatch = 1 ;

                                ;
                                        : 0
                                        ? argP.idNameSpec - A lISToStEXT.idNameF()
                                    : argP.idNameSpec
                                    ? pGraft->idNameF() - A lISToStEXT.idNameF()
                                heavy = pGraft
    
                                }
                                    pGraft = &A lISToStEXT ;
                                    aptC aptP = argP.aptGraft ;
                                {
                                if( argP.aptGraft ) //GRAFTING CAN ONLY BE DONE TO HOMOGENEOUS LISTS OF CORRECT TYPE; THIS IS ENFORCED TO ENSURE THAT GRAFTING NEVER DESTROYS SORTABILITY OR COMPARABILITY
                                ZE( list_blob_C* , pGraft ) ;
    
                                }
                                    CONoUTrAW( "\"\r\n" ) ;
                                    CONoUTrAW( (osTextT*)A lISToStEXT ) ;
                                    CONoUTrAW3( "A lISToStEXT [cName,postValue]: " , A lISToStEXT.idNameF() , " \"" ) ;
                                {
                                if( F(argP.flagsInspect) & flAPTiNSPECT_CHATTERtOcONSOLE  )
    
                                }
                                    LOGrAW( "\"\r\n" ) ;
                                    LOGrAW( (osTextT*)A lISToStEXT ) ;
                                    LOGrAW3( "A lISToStEXT [cName,postValue]: " , A lISToStEXT.idNameF() , " \"" ) ;
                                {
                                if( F(argP.flagsInspect) & flAPTiNSPECT_CHATTERtOlOG )
                            {
                            if( !argP.idTypeInspect || argP.idTypeInspect == ifcIDtYPElISTING_LISToStEXTsTRz )
                        {
                        case ifcIDtYPEmIXINdATUM_blob : // list_blob_C
                        }
                            break ;
                            }
                                argP.flagsInspect |= flAPTiNSPECT_ABORT ;
                                )
                                    ( F(argP.flagsInspect) & flAPTiNSPECT_SETaBORTfLAGiFmATCH && bMatch )
                                    F(argP.flagsInspect) & flAPTiNSPECT_SETaBORTfLAGiFeXISTS               ||
                                (
                                if
                        
                                }
                                    else argP.idNameFound = A lISTcOUNT.idNameF() ;
                                    }
                                        *argP.pStk_idNameFound << (byteT*)pc2 ;
                                        //CONoUTrAW5( "**************** 2 **************** [offNestLevel,idNameFound]: " , argP.offNestLevel , " " , argP.idNameFound , "\r\n" ) ; //U::
                                        puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                                        countT pc2[] = { argP.offNestLevel , A lISTcOUNT.idNameF() } ;
                                    {
                                    if( argP.pStk_idNameFound )
                                    argP.offNestLevelIdNameFound = argP.offNestLevel ;
                                {
                                if( bMatch )

                                if( argP.idNameSpec ) //SETmATCHnAME( heavy )
                                boolT bMatch = 1 ;

                                ;
                                        : 0
                                        ? argP.idNameSpec - A lISTcOUNT.idNameF()
                                    : argP.idNameSpec
                                    ? pGraft->idNameF() - A lISTcOUNT.idNameF()
                                heavy = pGraft
    
                                }
                                    pGraft = &A lISTcOUNT ;
                                    aptC aptP = argP.aptGraft ;
                                {
                                if( argP.aptGraft ) //GRAFTING CAN ONLY BE DONE TO HOMOGENEOUS LISTS OF CORRECT TYPE; THIS IS ENFORCED TO ENSURE THAT GRAFTING NEVER DESTROYS SORTABILITY OR COMPARABILITY
                                ZE( list_countT_C* , pGraft ) ;
    
                                if( F(argP.flagsInspect) & flAPTiNSPECT_DECREMENTiFeXISTS  ) -- *(countT*)A lISTcOUNT ;
                                if( F(argP.flagsInspect) & flAPTiNSPECT_INCREMENTiFeXISTS  ) ++ *(countT*)A lISTcOUNT ;
    
                                if( F(argP.flagsInspect) & flAPTiNSPECT_CHATTERtOcONSOLE ) { CONoUTrAW5( "A lISTcOUNT [idName,cValue]: " , A lISTcOUNT.idNameF() , " " , *(countT*)A lISTcOUNT , "\r\n" ) ; }
                                if( F(argP.flagsInspect) & flAPTiNSPECT_CHATTERtOlOG     ) {    LOGrAW5( "A lISTcOUNT [idName,cValue]: " , A lISTcOUNT.idNameF() , " " , *(countT*)A lISTcOUNT , "\r\n" ) ; }
                            {
                            if( !argP.idTypeInspect || argP.idTypeInspect == ifcIDtYPElISTING_LISTcOUNTt )
                        {
                        case ifcIDtYPEmIXINdATUM_countT : // list_countT_C
                    {
                    switch( pdListing->idTypeDatumF() )
                {
                case fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM :
                }
                    break ;
                    }
                        }
                            break ;
                            __1 ;
                            __( pdListing->idTypeDatumF() ) ;
                        {
                        default :
                        }
                            break ;
                            }
                                argP.flagsInspect |= flAPTiNSPECT_ABORT ;
                                )
                                    ( F(argP.flagsInspect) & flAPTiNSPECT_SETaBORTfLAGiFmATCH && bMatch )
                                    F(argP.flagsInspect) & flAPTiNSPECT_SETaBORTfLAGiFeXISTS               ||
                                (
                                if
                            
                                }
                                    }
                                        THREADmODE2rESTORE
                                        }
                                            argP.cValueAttached = (countT)(osTextT*)Ao StEXT ;
                                        {
                                        else if( F(argP.flagsInspect) & flAPTiNSPECT_RETURNoRIGINAL )
                                        }
                                            }
                                                argP.cValueAttached = (countT)postOldCopy ;
                                                thirdC::c_memcpyIF( tinP , postOldCopy , postOriginal , costa ) ;
                                            {
                                            if( postOldCopy )
                                            osTextT* postOldCopy = PUSE.newF( tinP , LF , costa ) ; ___( postOldCopy ) ;
                                            countT costa = 1 + thirdC::c_strlenIF( tinP , postOriginal ) ;
                                            puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                                        {
                                        if( F(argP.flagsInspect) & flAPTiNSPECT_RETURNcOPY && !argP.cValueAttached )
    
                                        osTextT* postOriginal = Ao StEXT = (osTextT*)argP.cValueAttachSpec ;
                                        THREADmODE2oN( flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP | flTHREADmODE2_UNLOCKpOOLiDENTITY )
                                    {
                                    if( argP.cValueAttachSpec && F(argP.flagsInspect) & flAPTiNSPECT_REPLACEvALUE )
        
                                    }
                                        else argP.cValueFound = (countT)(osTextT*)Ao StEXT ;
                                        }
                                            *argP.pStk_cValueFound << cvf ;
                                            puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                                            countT cvf = (countT)(osTextT*)Ao StEXT ;
                                        {
                                        if( argP.pStk_cValueFound )
                                    {
                                    else if( F(argP.flagsInspect) & flAPTiNSPECT_RETURNoRIGINAL )
                                    }
                                        }
                                            }
                                                argP.cValueFound = (countT)postOldCopy ;
                                                thirdC::c_memcpyIF( tinP , postOldCopy , postOriginal , costa ) ;
                                            {
                                            if( postOldCopy )
                                            osTextT* postOldCopy = PUSE.newF( tinP , LF , costa ) ; ___( postOldCopy ) ;
                                        {
                                        else if( !argP.cValueFound )
                                        }
                                            }
                                                *argP.pStk_cValueFound << (countT)postOldCopy ;
                                                thirdC::c_memcpyIF( tinP , postOldCopy , postOriginal , costa ) ;
                                            {
                                            if( postOldCopy )
                                            osTextT* postOldCopy = PUSE.newF( tinP , LF , costa ) ; ___( postOldCopy ) ;
                                        {
                                        if( argP.pStk_cValueFound )
    
                                        countT costa = 1 + thirdC::c_strlenIF( tinP , postOriginal ) ;
                                        puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                                        const osTextT* const postOriginal = (osTextT*)Ao StEXT ;
                                    {
                                    if( F(argP.flagsInspect) & flAPTiNSPECT_RETURNcOPY )
                                {
                                if( bMatch )

                                if( argP.cValueTestSpec ) //SETmATCHvALUE( heavy )
                                boolT bMatch = 1 ;

                                ;
                                        : 0
                                        ? thirdC::c_strcmpIF( tinP , (osTextT*)argP.cValueTestSpec , (osTextT*)Ao StEXT )
                                    : argP.cValueTestSpec
                                    ? thirdC::c_strcmpIF( tinP , (osTextT*)*pGraft , (osTextT*)Ao StEXT )
                                heavy = pGraft
                        
                                }
                                    pGraft = &Ao StEXT ;
                                    aptC aptP = argP.aptGraft ;
                                {
                                if( argP.aptGraft ) //GRAFTING CAN ONLY BE DONE TO HOMOGENEOUS LISTS OF CORRECT TYPE; THIS IS ENFORCED TO ENSURE THAT GRAFTING NEVER DESTROYS SORTABILITY OR COMPARABILITY
                                ZE( listing_blob_C* , pGraft ) ;
    
                                }
                                    CONoUTrAW( "\"\r\n" ) ;
                                    CONoUTrAW( (osTextT*)Ao StEXT ) ;
                                    CONoUTrAW( "Ao StEXT [postValue]: \"" ) ;
                                {
                                if( F(argP.flagsInspect) & flAPTiNSPECT_CHATTERtOcONSOLE  )
                        
                                }
                                    LOGrAW( "\"\r\n" ) ;
                                    LOGrAW( (osTextT*)Ao StEXT ) ;
                                    LOGrAW( "Ao StEXT [postValue]: \"" ) ;
                                {
                                if( F(argP.flagsInspect) & flAPTiNSPECT_CHATTERtOlOG  )
                            {
                            if( !argP.idTypeInspect || argP.idTypeInspect == ifcIDtYPElISTING_OStEXTsTRz )
                        {
                        case ifcIDtYPEmIXINdATUM_blob : //listing_blob_C
                        }
                            break ;
                            }
                                argP.flagsInspect |= flAPTiNSPECT_ABORT ;
                                )
                                    ( F(argP.flagsInspect) & flAPTiNSPECT_SETaBORTfLAGiFmATCH && bMatch )
                                    F(argP.flagsInspect) & flAPTiNSPECT_SETaBORTfLAGiFeXISTS               ||
                                (
                                if
    
                                }
                                    }
                                        }
                                            //      strSquishF( pczList + N-d )
                                            //      pczList[ N-1 ] = 0 ;
                                            //      idField = pczList[ N-1 ]
                                            //     recipe     
                                            //      N-11
                                            //      N-01
                                            //      N-f
                                            //      N-e            timeU2
                                            //      --------------------------
                                            //      N-d
                                            //      N-c
                                            //      N-b
                                            //      N-a            timeU1
                                            //      --------------------------
                                            //      N-9
                                            //      N-8
                                            //      N-7
                                            //      N-6            idDeposit
                                            //      --------------------------
                                            //      N-5
                                            //      N-4
                                            //      N-3
                                            //      N-2            idCommission
                                            //      --------------------------
                                            //      N-1            cNameField
                                            //      off            what

                                            }
                                                }
                                                    if( pbCopy ) thirdC::c_memcpyIF( tinP , pbCopy , (byteT*)pczListNameP , cbaCopy ) ;
                                                    pbCopy = PUSE.newF( tinP , LF , cbaCopy ) ; ___( pbCopy ) ;
                                                    countT  cbaCopy = sizeof( countT ) * ( ccName + 1 ) ;
                                                {
                                                if( !pbCopy )
                                                byteT*& pbCopy = *(byteT**)&c3money.c3 ;

                                                PUSE( tinP , *(byteT**)&pczSquished ) ;
                                                }
                                                    }
                                                        break ;
                                                        __1 ;
                                                        __( cNameField ) ;
                                                    {
                                                    default :
                                                    case TfIELD_MONEYhIGH : { c3money.c2 = vv ; break ; }
                                                    case TfIELD_MONEYlOW  : { c3money.c1 = vv ; break ; }
                                                {
                                                switch( cNameField )

                                                count3S& c3money = *(count3S*)&(countT&)swDepositP ;
                                                pczTime2Time2IdDepositP = pczSquished ;

                                                switchC& swDepositP              = *(switchC*)argP.pc Utility[ 1 ] ;         
                                                countT*& pczTime2Time2IdDepositP = *(countT**)argP.pc Utility[ 0 ] ;

                                                //CONoUTrAW( T(">>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<: ")+T(pczSquished)+T("\r\n") ) ;
                                                etherC::strSquishOldIF( tinP , pczSquished , pczListNameP + ccName - ccIn - 1 , ccIn ) ; ___( pczSquished ) ;
                                                ZE( countT* , pczSquished ) ;
                                            {
                                            if( ccIn < ccName - 1 )
                                            countT ccIn = 4 * sizeof( countT ) ;

                                            //CONoUTrAW3( "cNameField: " , cNameField , "\r\n" ) ;
                                            countT cNameField = pczListNameP[ ccName - 1 ] ;
                                            const countT ccName = thirdC::c_strlenIF( tinP , pczListNameP ) ;
                                            //CONoUTrAW( T("<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>: ")+T(pczListNameP)+T("\r\n") ) ;

                                            puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                                            countT vv = *(countT*)Ac OUNT ;
                                        {

                                        countT cName = *( -- pcc ) ;
                                        while( *pcc ) pcc ++ ;
                                        const countT* pcc = pczListNameP ;
                                    {
                                    if( *pczListNameP )
                                {
                                if( bMatch )

                                if( argP.cValueTestSpec ) //SETmATCHvALUE( heavy )
                                boolT bMatch = 1 ;

                                ;
                                        : 0
                                        ? argP.cValueTestSpec - *(countT*)Ac OUNT
                                    : argP.cValueTestSpec
                                    ? *(countT*)*pGraft - *(countT*)Ac OUNT
                                heavy = pGraft
                        
                                }
                                    pGraft = &Ac OUNT ;
                                    aptC aptP = argP.aptGraft ;
                                {
                                if( argP.aptGraft ) //GRAFTING CAN ONLY BE DONE TO HOMOGENEOUS LISTS OF CORRECT TYPE; THIS IS ENFORCED TO ENSURE THAT GRAFTING NEVER DESTROYS SORTABILITY OR COMPARABILITY
                                ZE( listing_countT_C* , pGraft ) ;
    
                                if( F(argP.flagsInspect) & flAPTiNSPECT_DECREMENTiFeXISTS  ) -- *(countT*)Ac OUNT ;
                                if( F(argP.flagsInspect) & flAPTiNSPECT_INCREMENTiFeXISTS  ) ++ *(countT*)Ac OUNT ;
    
                                if( F(argP.flagsInspect) & flAPTiNSPECT_CHATTERtOcONSOLE  ) { CONoUTrAW3( "Ac OUNT [cValue]: " , *(countT*)Ac OUNT , "\r\n" ) ; }
                                if( F(argP.flagsInspect) & flAPTiNSPECT_CHATTERtOlOG      ) {    LOGrAW3( "Ac OUNT [cValue]: " , *(countT*)Ac OUNT , "\r\n" ) ; }
                            {
                            if( !argP.idTypeInspect || argP.idTypeInspect == ifcIDtYPElISTING_COUNTt )
                        {
                        case ifcIDtYPEmIXINdATUM_countT : //listing_countT_C
                    {
                    switch( pdListing->idTypeDatumF() )
                {
                case fliLISTINGc_MIXINdATUM :
                }
                    break ;
                    }
                        argP.flagsInspect |= flAPTiNSPECT_ABORT ;
                        )
                            ( F(argP.flagsInspect) & flAPTiNSPECT_SETaBORTfLAGiFmATCH && bMatch )
                            F(argP.flagsInspect) & flAPTiNSPECT_SETaBORTfLAGiFeXISTS               ||
                        (
                        if
    
                        }
                            }
                                PUSE( tinP , *(byteT**)&pczListNameKid ) ;
                                puseC puse( tinP , ifcIDpOOL_ADAMtEMP ) ;
                            {
    
                            }
                                argP.flagsWalk = flagsSave ;

                                -- argP.offNestLevel ;
                                aList.walkOldF( tinP , ifcIDmODEaPTsINK_LEADsHOES , &argP , 0 , listingInspectMoneyBucketsCBF , pczListNameKid ) ;
                                ++ argP.offNestLevel ;

                                argP.flagsWalk |= flLISTwALKoLD_DOnOTuNGRABlIST ;
                                flagsT flagsSave = argP.flagsWalk ;
    
                                pczListNameKid[ ccDad    ] = 0 ;
                                pczListNameKid[ ccDad ++ ] = A lIST.idNameF() ;
                                thirdC::c_memcpyIF( tinP , (byteT*)pczListNameKid , (byteT*)pczListNameP , sizeof( countT ) * ccDad ) ;
                            {
                            if( pczListNameKid )
    
                            }
                                pczListNameKid = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccDad + 2 ) ) ; ___( pczListNameKid ) ;
                                puseC puse( tinP , ifcIDpOOL_ADAMtEMP ) ;
                            {
                            ZE( countT* , pczListNameKid ) ;
                            countT ccDad = thirdC::c_strlenIF( tinP , pczListNameP ) ;
    
                            listC& aList = A lIST ;
                        {
                        if( F(argP.flagsInspect) & flAPTiNSPECT_RECURSE )
    
                        }
                            else argP.idNameFound = A lIST.idNameF() ;
                            }
                                *argP.pStk_idNameFound << (byteT*)pc2 ;
                                //CONoUTrAW5( "**************** 1 **************** [offNestLevel,idNameFound]: " , argP.offNestLevel , " " , argP.idNameFound , "\r\n" ) ; //U::
                                puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                                countT pc2[] = { argP.offNestLevel , A lIST.idNameF() } ;
                            {
                            if( argP.pStk_idNameFound )
                            argP.offNestLevelIdNameFound = argP.offNestLevel ;
                        {
                        if( bMatch )

                        if( argP.idNameSpec ) //SETmATCHnAME( heavy )
                        boolT bMatch = 1 ;

                        ;
                                : 0
                                ? argP.idNameSpec - A lIST.idNameF()
                            : argP.idNameSpec
                            ? pGraft->idNameF() - A lIST.idNameF()
                        heavy = pGraft

                        }
                            pGraft = &A lIST ;
                            aptC aptP = argP.aptGraft ;
                        {
                        if( argP.aptGraft ) //GRAFTING CAN ONLY BE DONE TO HOMOGENEOUS LISTS OF CORRECT TYPE; THIS IS ENFORCED TO ENSURE THAT GRAFTING NEVER DESTROYS SORTABILITY OR COMPARABILITY
                        ZE( listC* , pGraft ) ;
    
                        if( F(argP.flagsInspect) & flAPTiNSPECT_CHATTERtOcONSOLE ) { CONoUTrAW3( "A lIST [idName]: " , A lIST.idNameF() , "\r\n" ) ; }
                        if( F(argP.flagsInspect) & flAPTiNSPECT_CHATTERtOlOG     ) {    LOGrAW3( "A lIST [idName]: " , A lIST.idNameF() , "\r\n" ) ; }
                    {
                    if( !argP.idTypeInspect || argP.idTypeInspect == ifcIDtYPElISTING_LIST )
                {
                case fliLISTINGc_MIXINlIST : // listC
                }
                    break ;
                {
                case 0 : // listingC
            {
            switch( pdListing->flagsF() & fliLISTINGc_maskTypeBits )

            }
                CONoUTrAW( T("---- ")+T(pczListNameP)+T("\r\n") ) ;
                puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
            {
            if( F(argP.flagsInspect) & flAPTiNSPECT_CHATTERtOcONSOLE  )

            }
                LOGrAW( T("---- ")+T(pczListNameP)+T("\r\n") ) ;
                puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
            {
            if( F(argP.flagsInspect) & flAPTiNSPECT_CHATTERtOlOG  )
        {
        if( !POOP )

        __( !listingC::bIsListingIF( tinP , aptP ) ) ;
        listingC* pdListing = &APT( listingC , aptP ) ;
    {
    if( aptP )
    ZE( sCountT , heavy ) ;

    _INoLD_

    if( POOP ) return 0 ;
{
/*1*/sCountT listingInspectMoneyBucketsCBF( tinS& tinP , aptC& aptP , listWalkArgOldS& argP , const countT* pczListNameP )/*1*/

/**/
*/
/*


    }
        PUSE.listOld2012F( tinP , hListMain , pc2 , ifcIDhOWlIST_LIFO , &arg ) ;                                                                                   \
        countT pc2[] = { (cNameP) , 0 } ;                                                                                                                   \
        arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;                                                                                                        \
        arg.cValueAttachSpec = (countT)cValueP ;                                                                                                            \
        arg.idTypeAttach = ifcIDtYPElISTING_COUNTt ;                                                                                                        \
        listWalkArgOldS arg( tinP ) ;                                                                                                                          \
    {                                                                                                                                                       \
                                                                                                                                                            \
#define TpUSHfIFOcOUNT(cNameP,cValueP)                                                                                                                      \

#define LISTnAMEnOTEeND                  LISTnAMEaDAMoLD_3
#define LISTnAMEnOTEbEGIN                LISTnAMEaDAMoLD_2
#define LISTnAMEiDfORMAT                 LISTnAMEaDAMoLD_1

#define TfIELD_MONEYhIGH                 LISTnAMEaDAMoLD_2
#define TfIELD_MONEYlOW                  LISTnAMEaDAMoLD_1
//"T": "TRANSACTION"
//IT IS ILLEGAL TO CHANGE THIS LIST EXCEPT BY ADDING NEW DEFS TO THE TOP (SfIELD_*) CONSTANTS CAN BE RENAMED BUT CANNOT BE CHANGED SEMANTICALLY

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_LISTsERVERmONEYbUCKETS" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

