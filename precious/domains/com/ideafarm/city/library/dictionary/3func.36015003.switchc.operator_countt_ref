
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cRef ;
    _OUT_
    if( pBaton ) pBaton->ungrabF( tinP ) ;

    countT& cRef = stackk ? ( &stackk[ 0 ] )[ 1 ] : *(countT*)pbnu ;

    }
        third.delF( tinP , pbLB ) ;
        }
            //if( !( stackk % TUCK ) ) { LOGrAW7( "switchC: another flavor added [cFlavors,idLineCt,idiFileCt]: " , stackk , "   " , idiFileCt , "(" , idLineCt , ")\r\n" ) ; }

            __Z( idSlot ) ;
            //if( !idSlot ) { CONoUTrAW( "\r\n**** idSlot IS NULL ****\r\n" ) ; } //U::
            stackk.sinkF( tinP , idSlot , pbLB , flSTACKsINK_UNIQUE , pSubtractF , cbLever ) ;
            ZE( countT , idSlot ) ;
            }
                }
                    __1
                    __( idLeverType ) ;
                {
                default :
                }
                    break ;
                    else __1
                    }
                        *(countT*)pbLB = (countT)pSoul ;
                        else        __1
                        if( pSoul ) *pSoul = *(soulC*)query ;
                        soulC* pSoul = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    if( query )
                {
                case ifcIDtYPElEVER_PTR_soulC :
                }
                    break ;
                    else __1
                    }
                        *(countT*)pbLB = (countT)pbl ;
                        third.c_memcpyIF( tinP , pbl , (byteT*)query , cba ) ;
                        third.newF( tinP , LF , pbl , cba ) ; ___BITScT( pbl , 0xe44 ) ;
                        countT cba = cbLever ;
                        ZE( byteT* , pbl ) ;
                    {
                    if( query )
                {
                case ifcIDtYPElEVER_BLOBdOOMED :
                }
                    break ;
                    else __1
                    }
                        *(countT*)pbLB = (countT)pcl ;
                        third.c_memcpyIF( tinP , (byteT*)pcl , (byteT*)query , processGlobal1I.cb_nicNameC_ ) ;
                        third.newF( tinP , LF , pcl ) ; ___BITScT( pcl , 0xe45 ) ;
                        ZE( nicNameC* , pcl ) ;
                    {
                    if( query )
                {
                case ifcIDtYPElEVER_PTR_nicNameC :
                }
                    break ;
                    else __1
                    }
                        *(countT*)pbLB = (countT)postl ;
                        thirdC::c_memcpyIF( tinP , postl , (osTextT*)query , costa ) ;
                        third.newF( tinP , LF , postl , costa ) ; ___BITScT( postl , 0xe46 ) ;
                        countT costa = 1 + thirdC::c_strlenIF( tinP , (osTextT*)query ) ;
                        ZE( osTextT* , postl ) ;
                    {
                    if( query )
                {
                case ifcIDtYPElEVER_PTR_osTextT :
                }
                    break ;
                    }
                        }
                            *(countT*)pbLB = (countT)pPlateLever ;
                            *pPlateLever = plateQuery ;
                            plateC* pPlateLever = plateQuery.newPlateF( tinP ) ; ___BITScT( pPlateLever , 0xe47 ) ;
                            plateC& plateQuery = *(plateC*)query ;
                        {
                        if( pEther )
                        etherC* pEther = third.third_pEtherContainsMe_F() ;
                    {
                    else
                    if( !query ) *(countT*)pbLB = 0 ;
                {
                case ifcIDtYPElEVER_PTR_plateC :
                }
                    break ;
                    }
                        }
                            *(countT*)pbLB = (countT)psttl ;
                            pEther->strMakeF( tinP , psttl , (strokeS*)query ) ; ___BITScT( psttl , 0xe47 ) ;
                            ZE( strokeS* , psttl ) ;
                        {
                        if( pEther )
                        etherC* pEther = third.third_pEtherContainsMe_F() ;
                    {
                    else
                    if( !query ) *(countT*)pbLB = 0 ;
                {
                case ifcIDtYPElEVER_PTR_strokeS :
                }
                    break ;
                    else __1
                    }
                        *(countT*)pbLB = (countT)pcl ;
                        third.c_memcpyIF( tinP , (byteT*)pcl , (byteT*)query , sizeof( countT ) * cc ) ;
                        third.newF( tinP , LF , pcl , cc ) ; ___BITScT( pcl , 0xe48 ) ;
                        ZE( countT* , pcl ) ;
                        countT cc = 1 + third.strBodyLengthF( tinP , (countT*)query ) ;
                    {
                    if( query ) //U::CONJ: BUG: THIS CODE ASSUMES ERRONEOUSLY THAT LENGTH PREFIXED LEVER VALUES WILL ALSO BE NULL TERMINATED
                {
                case ifcIDtYPElEVER_PTR_countT :
                case ifcIDtYPElEVER_PTR_lenPrefixedCountT :
                }
                    break ;
                    else __1
                    }
                        *(countT*)pbLB = (countT)pbl ;
                        third.c_memcpyIF( tinP , pbl , (byteT*)query , cba ) ;
                        third.newF( tinP , LF , pbl , cba ) ; ___BITScT( pbl , 0xe44 ) ;
                        countT cba = cbLever ;
                        ZE( byteT* , pbl ) ;
                    {
                    if( query )
                {
                case ifcIDtYPElEVER_PTR_BLOB :
                }
                    break ;
                    else __1
                    }
                        *(countT*)pbLB = (countT)ppsttl ;
                        for( countT off = 0 ; off < cc ; off ++ ) { pEther->strMakeF( tinP , ppsttl[ off ] , ((const strokeS**)query)[ off ] ) ; ___CT( ppsttl[ off ] ) ; }
                        third.c_memsetIF( tinP , *(byteT**)&ppsttl , ( cc + 1 ) * sizeof( countT ) ) ;
                        third.newF( tinP , LF , *(countT**)&ppsttl , cc + 1 ) ; ___BITScT( ppsttl , 0xe48 ) ;
                        ZE( strokeS** , ppsttl ) ;
                        countT cc = third.strBodyLengthF( tinP , (countT*)query ) ;
                        etherC* pEther = third.third_pEtherContainsMe_F() ;
                    {
                    if( query )
                {
                case ifcIDtYPElEVER_PTR_ptrStrokeS :
                case ifcIDtYPElEVER_countT : { *(countT*)pbLB = query ; break ; }
                case ifcIDtYPElEVER_tid :
            {
            switch( idLeverType )

            if( F(flags) & flSTACKc_PATCHnEWfLAVOR ) ((countT*)pbLB)[ 1 ] = SWITCHfLAVORpATCH ; //APPLICATIONS USE THIS TO AVOID FREEING UNINTENDED FLAVORS WHEN CALLING freeNullsF
            third.c_memsetIF( tinP , pbLB + sizeof( countT ) , cbData ) ;
        {
        if( !third && pbLB )
        third.newF( tinP , LF , pbLB , sizeof( countT ) + cbData ) ; ___BITScT( pbLB , 0xe49 ) ;
        ZE( byteT* , pbLB ) ;
    {
    if( !idSlot )

    stackk.sinkF( tinP , idSlot , (byteT*)&query , flSTACKsINK_QUERY , pSubtractF , cbLever ) ;
    ZE( countT , idSlot ) ;
    }
        default                                   : { __( idLeverType ) ; __1                                           ; break ; }
        case ifcIDtYPElEVER_PTR_soulC             : { query = (countT)pbLever                                           ; break ; }
        case ifcIDtYPElEVER_BLOBdOOMED                  :
        case ifcIDtYPElEVER_PTR_nicNameC          :
        case ifcIDtYPElEVER_PTR_osTextT           : { query = (countT)*(osTextT**)pbLever                               ; break ; }
        case ifcIDtYPElEVER_PTR_plateC            : { query = (countT)*(plateC**)pbLever                                ; break ; }
        case ifcIDtYPElEVER_PTR_strokeS           : { query = (countT)*(strokeS**)pbLever                               ; break ; }
        case ifcIDtYPElEVER_PTR_countT            : { query = (countT)*(countT**)pbLever                                ; break ; }
        case ifcIDtYPElEVER_PTR_lenPrefixedCountT :
        case ifcIDtYPElEVER_PTR_ptrStrokeS        :
        case ifcIDtYPElEVER_PTR_BLOB              :
        case ifcIDtYPElEVER_countT                : { query = *(countT*)pbLever                                         ; break ; }
        case ifcIDtYPElEVER_tid                   : { query = dosGetInfoBlocksIdThreadIF()                  ; break ; }
    {
    switch( idLeverType )
    ZE( countT , query ) ;

    _INoLD_
    else if( osTidOwner != tinP.osTid && !bDying && !( F(stackk.flagsF(tinP)) & flSTACKc_ALLOWmULTIPLEuNSERIALIZED ) ) BLAMMO ;
    else if( !osTidOwner ) osTidOwner = tinP.osTid ;
    if( pBaton ) pBaton->grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        if( third ) return *(countT*)pbnu ;

        }
            POPUP("ERROR: c_pThird is 0 in switchC::operator countT&( voidT )") ;
        {
        if( !c_pThird )
        countT c_pThird = (countT)&third ;
        //U::

    {
    IFbEcAREFUL

    }
        countT foo = 2 ;
    {
    if( tinP.monitor.idThread == 1 ) //U::TO FIND A BUG: 20141109@2241

    SCOOP
    TINSL
{
/*1*/switchC::operator countT&( voidT )/*1*/

/**/
*/
for locked switchC objects, i will fail if a countT value for the current lever does not already exist
  this would impose the cost of a function call, so is not done
  support for casts to references of other types would call this function indirectly
 casts to references of other types is intentionally not supported
you must cast to countT& and then recast to the desired reference type
it is deallocated when the switchC object is destroyed
 it is initialized to 0
this allocation is made the first time that it is needed
this cast returns a reference to that allocation
each switchC object maintains a single storage allocation of sizeof( countT ) bytes for each thread
if we are switching on an explicit lever, this evaluates to a countT& value that is distinct for each distinct value of the lever
 this slight extra coding effort also gives you more speed, since an operating system call is avoided
 an alternative to implicit thread switching is to use an explicit lever, and set the lever value using tinP.monitor.idThread
 failure to do this is not an error, but results in the same countT object being reused, and hence not initialized to ze for the reusing thread
 if this switchC object is implicitly thread switched, you -must- clear the switch for a thread before each thread that refers to this object ends
 on some operating systems, the thread id values are reused
if we are switching on the os thread id (tid), this evaluates to a countT& that is distinct for each -active- thread
  \<A HREF=\"5.7e10104.1.1.0.html\"\>7e10104:  WAKEsHOW( "example.simplest.func.1200004.switchC.operator_countT_ref" )\</A\>
 simplest
examples
\<A HREF=\"5.1200004.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

