
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    }
        etThread.delF( tinP , pbd ) ;
        byteT* pbd = (byteT*)cpbd ;
        stStringsOfBytesToDelete >> cpbd ;
        ZE( countT , cpbd ) ;
    {
    while( stStringsOfBytesToDelete )

    }
        DEL( ptbld ) ;
        tableC* ptbld = (tableC*)cptbld ;
        stTablesToDelete >> cptbld ;
        ZE( countT , cptbld ) ;
    {
    while( stTablesToDelete )

    }
        DEL( pstd ) ;
        stackC* pstd = (stackC*)cpstd ;
        stStacksToDelete >> cpstd ;
        ZE( countT , cpstd ) ;
    {
    while( stStacksToDelete )

    snapshotF( tinP , etThread , tNickname , tExtEmail , bLever , lever , swNickname , swExtEmail ) ;

    while( !etThread && etThread.os_cAllKidThreadsI_IF( tinP ) > cctAtBegin ) etThread.osSleepF( tinP , TUCK * 0x40 ) ;

    }
        else                    { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmServeF , 0 , flTHREADlAUNCH_null , 0 , (countT)pso , (countT)&lever , (countT)&bLever , (countT)&swNickname , (countT)&swExtEmail ) ; }
        if( ether || etThread ) { DEL( pso ) ; }
        socket.acceptF( tinP , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        ZE( socketC* , pso ) ;
    {
    while( !ether && !etThread )
    ZE( countT , cIn ) ;
    etThread.etherCryF( tinP ) ;

    { ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmSnapshotF , 0 , flTHREADlAUNCH_null , 0 , (countT)&tNickname , (countT)&tExtEmail , (countT)&lever , (countT)&bLever , (countT)&swNickname , (countT)&swExtEmail ) ; }

    }
        bLever.ungrabF( tinP ) ;
        swExtEmail = (countT)(strokeS*)tExtEmail2 ;
        lever = 2 ;
        swExtEmail = (countT)(strokeS*)tExtEmail1 ;
        lever = 1 ;
        bLever.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !swExtEmail )
    TN( tExtEmail2 , ifcEMAIL_OLDfROM ) ;
    TN( tExtEmail1 , ifcEMAIL_OLDfROM ) ;

    }
        bLever.ungrabF( tinP ) ;
        swNickname = (countT)(strokeS*)tNick2 ;
        lever = 2 ;
        swNickname = (countT)(strokeS*)tNick1 ;
        lever = 1 ;
        bLever.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !swNickname )
    TN( tNick2 , "anonymous" ) ;
    TN( tNick1 , "christian the proprietor" ) ;

    loadDataF( tinP , etThread , stStringsOfBytesToDelete , stTablesToDelete , stStacksToDelete , tNickname , tExtEmail , bLever , lever , swNickname , swExtEmail ) ;
    TN( tExtEmail   , "///ideafarm/ephemeral/domains/com/ideafarm/city/data/base/be30104.extEmail"   ) ;
    TN( tNickname   , "///ideafarm/ephemeral/domains/com/ideafarm/city/data/base/be30104.nickname"   ) ;

    stackC stStacksToDelete( tinP , etThread , TAG( TAGiDnULL ) ) ;
    stackC stTablesToDelete( tinP , etThread , TAG( TAGiDnULL ) ) ;
    stackC stStringsOfBytesToDelete( tinP , etThread , TAG( TAGiDnULL ) ) ;

    switchC      swExtEmail( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever ) ;
    switchC      swNickname( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever ) ;
    batonC       bLever( tinP , TAG( TAGiDnULL ) ) ;
    ZE( countT , lever ) ;

    socket.listenF( tinP ) ;    
    countT idPort = socket.bindF( tinP , ifcPORToLD1nICKNAME ) ;
    socketC socket( tinP , etThread , TAG( TAGiDnULL ) ) ;

    etThread.strokeF( tinP , T("IdeaFarm " "(tm) City Nickname Authority\r\ni map between idCitizen and nickname\r\n\r\n") ) ;

    { ZE( boolT , bnu ) ; __( !bnu && sizeof( measureT ) != sizeof( countT ) ) ; }

    //U: ENHANCE THIS TO ACCEPT THE CLASS OF THE CITIZEN ID (IMPLICITLY ASSUMES CLASS 1 (HUMANS))

    const countT cctAtBegin = etThread.os_cAllKidThreadsI_IF( tinP ) ;
{
else
}
    etThread.strokeF( tinP , T("Another be30104 appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tinP , TAG( TAGiDnULL ) , T("be30104") ) ;

TODO

}
    bLeverP.ungrabF( tinP ) ;

    }
        }
            swExtEmailP = (countT)tbl._CT1_07F( idr , 2 ) ;
            leverP   =            tbl._CT1_04F( idr , 1 ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tinP ) ;

        tbl.readF( tinP , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttExtEmailP ) ;
        tableC tbl( tinP , etThread ) ;
    {
    if( etThread.diskFileExistsF( tinP , psttExtEmailP ) )

    }
        }
            swNicknameP = (countT)tbl._CT1_07F( idr , 2 ) ;
            leverP   =            tbl._CT1_04F( idr , 1 ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tinP ) ;

        tbl.readF( tinP , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttNicknameP ) ;
        tableC tbl( tinP , etThread ) ;
    {
    if( etThread.diskFileExistsF( tinP , psttNicknameP ) )

    bLeverP.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT loadDataF( tinS& tinP , etherC& etThread , stackC& stStringsOfBytesToDeleteP , stackC& stTablesToDeleteP , stackC& stStacksToDeleteP , const strokeS* const psttNicknameP , const strokeS* const psttExtEmailP , batonC& bLeverP , countT& leverP , switchC& swNicknameP  , switchC& swExtEmailP )

DONE( tmSnapshotF )
}
    }
        etThread.osSleepF( tinP , TOCK ) ;
        if( !( idTry % 0x40 ) ) snapshotF( tinP , etThread , tNickname , tExtEmail , bLever , lever , swNickname , swExtEmail ) ;

        idTry ++ ;
    {
    while( !ether && !etThread )
    ZE( countT , idTry ) ;

    switchC&      swExtEmail  = *(switchC*)pTaskP->c6 ;
    switchC&      swNickname  = *(switchC*)pTaskP->c5 ;
    batonC&       bLever      = *(batonC*) pTaskP->c4 ;
    countT&       lever       = *(countT*) pTaskP->c3 ;
    textC&        tExtEmail   = *(textC*)  pTaskP->c2 ;
    textC&        tNickname   = *(textC*)  pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmSnapshotF )

}
    bLeverP.ungrabF( tinP ) ;

    }
        tbl.writeF( tinP , psttExtEmailP ) ;

        }
            }
                tbl.newObjectF( tinP , psttn ) ;
                tbl.newObjectF( tinP , leverP ) ;
                tbl.newEventF( tinP ) ;
            {
            if( psttn )
            strokeS* psttn = (strokeS*)(countT)swExtEmailP ;
            leverP = swExtEmailP.leverF( tinP , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )

        tbl.newColF( tinP ) ;
        tbl.newColF( tinP ) ;
        tableC tbl( tinP , etThread ) ;

        const countT cLevers = swExtEmailP.cFlavorsF( tinP ) ;
    {

    }
        tbl.writeF( tinP , psttNicknameP ) ;

        }
            }
                tbl.newObjectF( tinP , psttn ) ;
                tbl.newObjectF( tinP , leverP ) ;
                tbl.newEventF( tinP ) ;
            {
            if( psttn )
            strokeS* psttn = (strokeS*)(countT)swNicknameP ;
            leverP = swNicknameP.leverF( tinP , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )

        tbl.newColF( tinP ) ;
        tbl.newColF( tinP ) ;
        tableC tbl( tinP , etThread ) ;

        const countT cLevers = swNicknameP.cFlavorsF( tinP ) ;
    {

    bLeverP.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT snapshotF( tinS& tinP , etherC& etThread , const strokeS* const psttNicknameP , const strokeS* const psttExtEmailP , batonC& bLeverP , countT& leverP , switchC& swNicknameP , switchC& swExtEmailP )

DONE( tmServeF )

}
    }
        DEL( pso ) ;
        }
            default : { __( idCmd ) ; __1 break ; }
            }
                break ;

                pso->writeF( tinP , (byteT*)&idCitizenNew , sizeof idCitizenNew ) ;

                }
                    bLever.ungrabF( tinP ) ;

                    idCitizenNew = lever ;
                    swNickname = (countT)psttNickname ;
                    swExtEmail = (countT)psttExtEmail ;

                    }
                        lever ++ ;
                        }
                            if( lever < idCitizen ) lever = idCitizen ;
                            countT idCitizen = swNickname.leverF( tinP , idl ) ;
                        {
                        for( countT idl = 1 ; idl <= cLevers ; idl ++ )
                        const countT cLevers = swNickname.cFlavorsF( tinP ) ;
                        lever = 0 ;
                    {

                    bLever.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( !etThread && psttNickname && psttExtEmail && psttNickname->idAdam && psttExtEmail->idAdam )
                ZE( countT , idCitizenNew ) ;

                etThread.delF( tinP , pbi ) ;
                }
                    }
                        }
                            default : __1
                            case 2 : { etThread.strMakeF( tinP , LF , psttNickname , psttc1 ) ; ___( psttNickname ) ; break ; }
                            case 1 : { etThread.strMakeF( tinP , LF , psttExtEmail , psttc1 ) ; ___( psttExtEmail ) ; break ; }
                        {
                        switch( ++ idString )
                    {
                    FORsTRINGSiN1( pstt1i )
                    ZE( countT , idString ) ;
                {
                ZE( strokeS* , psttNickname ) ;
                ZE( strokeS* , psttExtEmail ) ;

                }
                    __( ( CSpREFIX + pstt1i->idAdam ) * sizeof( strokeS ) - cbi ) ;
                    pstt1i = (strokeS*)pbi ;
                    pso->readF( tinP , pbi , cbi ) ;
                    etThread.newF( tinP , LF , pbi , cbi ) ; ___( pbi ) ;
                    __Z( cbi ) ;
                    pso->readF( tinP , (byteT*)&cbi , sizeof cbi ) ;
                    ZE( countT , cbi ) ;
                {
                ZE( strokeS* , pstt1i ) ;
                ZE( byteT* , pbi ) ;
            {
            case idcNICKNAMEcMD_NEWiD :
            }
                break ;

                etThread.delF( tinP , pbi ) ;

                pso->writeF( tinP , (byteT*)&idCitizen , sizeof idCitizen ) ;

                bLever.ungrabF( tinP ) ;
                }
                    }
                        break ;
                        idCitizen = swExtEmail.leverF( tinP , idl ) ;
                    {
                    if( !etThread.strCompareF( tinP , psttn , psttnq ) )
                    strokeS* psttn = (strokeS*)swExtEmail[ idl ] ;
                {
                for( countT idl = 1 ; idl <= cLevers ; idl ++ )
                const countT cLevers = swExtEmail.cFlavorsF( tinP ) ;
                ZE( countT , idCitizen ) ;
                bLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

                __( ( CSpREFIX + psttnq->idAdam ) * sizeof( strokeS ) - cbi ) ;
                strokeS* psttnq = (strokeS*)pbi ;
                pso->readF( tinP , pbi , cbi ) ;
                etThread.newF( tinP , LF , pbi , cbi ) ; ___( pbi ) ;
                ZE( byteT* , pbi ) ;
                __Z( cbi ) ;
                pso->readF( tinP , (byteT*)&cbi , sizeof cbi ) ;
                ZE( countT , cbi ) ;
            {
            case idcNICKNAMEcMD_QUERYiDfROMeXTERNALeMAIL :
            }
                break ;

                etThread.delF( tinP , pbi ) ;

                pso->writeF( tinP , (byteT*)&idCitizen , sizeof idCitizen ) ;

                bLever.ungrabF( tinP ) ;
                }
                    }
                        break ;
                        idCitizen = swNickname.leverF( tinP , idl ) ;
                    {
                    if( !etThread.strCompareF( tinP , psttn , psttnq ) )
                    strokeS* psttn = (strokeS*)swNickname[ idl ] ;
                {
                for( countT idl = 1 ; idl <= cLevers ; idl ++ )
                const countT cLevers = swNickname.cFlavorsF( tinP ) ;
                ZE( countT , idCitizen ) ;
                bLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

                __( ( CSpREFIX + psttnq->idAdam ) * sizeof( strokeS ) - cbi ) ;
                strokeS* psttnq = (strokeS*)pbi ;
                pso->readF( tinP , pbi , cbi ) ;
                etThread.newF( tinP , LF , pbi , cbi ) ; ___( pbi ) ;
                ZE( byteT* , pbi ) ;
                __Z( cbi ) ;
                pso->readF( tinP , (byteT*)&cbi , sizeof cbi ) ;
                ZE( countT , cbi ) ;
            {
            case idcNICKNAMEcMD_QUERYiDfROMnICK :
            }
                break ;

                if( psttn ) pso->writeF( tinP , (byteT*)psttn , cbo ) ;
                pso->writeF( tinP , (byteT*)&cbo , sizeof cbo ) ;

                bLever.ungrabF( tinP ) ;
                }
                    if( psttn ) cbo = ( CSpREFIX + psttn->idAdam ) * sizeof( strokeS ) ;
                    psttn = (strokeS*)(countT)swExtEmail ;
                    lever = idCitizen ;
                {
                if( swExtEmail.idSlotOfLeverF( tinP , idCitizen ) )
                ZE( countT , cbo ) ;
                ZE( strokeS* , psttn ) ;
                bLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

                pso->readF( tinP , (byteT*)&idCitizen , sizeof idCitizen ) ;
                ZE( countT , idCitizen ) ;
            {
            case idcNICKNAMEcMD_QUERYeXTERNALeMAILfROMiD :
            }
                break ;

                if( psttn ) pso->writeF( tinP , (byteT*)psttn , cbo ) ;
                pso->writeF( tinP , (byteT*)&cbo , sizeof cbo ) ;

                bLever.ungrabF( tinP ) ;
                }
                    if( psttn ) cbo = ( CSpREFIX + psttn->idAdam ) * sizeof( strokeS ) ;
                    psttn = (strokeS*)(countT)swNickname ;
                    lever = idCitizen ;
                {
                if( swNickname.idSlotOfLeverF( tinP , idCitizen ) )
                ZE( countT , cbo ) ;
                ZE( strokeS* , psttn ) ;
                bLever.grabF( tinP , TAG( TAGiDnULL ) ) ;

                pso->readF( tinP , (byteT*)&idCitizen , sizeof idCitizen ) ;
                ZE( countT , idCitizen ) ;
            {
            case idcNICKNAMEcMD_QUERYnICKfROMiD :
        {
        switch( idCmd )
        pso->readF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;
        ZE( countT , idCmd ) ;

        pso->etherF( tinP , etThread ) ;
        switchC& swExtEmail  = *(switchC*)pTaskP->c5 ;
        switchC& swNickname  = *(switchC*)pTaskP->c4 ;
        batonC&  bLever      = *(batonC*) pTaskP->c3 ;
        countT&  lever       = *(countT*) pTaskP->c2 ;
        socketC* pso         = (socketC*) pTaskP->c1 ;
    {
    if( !etThread )

    __( !pTaskP->c5 ) ;
    __( !pTaskP->c4 ) ;
    __( !pTaskP->c3 ) ;
    __( !pTaskP->c2 ) ;
    __( !pTaskP->c1 ) ;
{
if( !etThread )
__Z( pTaskP ) ;
TASK( tmServeF )

/*1*/WAKEhIDE( "city.nickname.authority" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

