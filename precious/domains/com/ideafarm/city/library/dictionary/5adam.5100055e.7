
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            etherP.osThreadF( TaRG1( tmRestoreTabbingF ) , (countT)&paramP ) ;
            paramP.vtHoverPad.setF( tinP , T("")+S2(idIn,sc_NULL)+paramP.tHoverPad ) ;
            countT idIn = 1 + incv02AM( idInLath ) ;
            static countT idInLath ;
        {
        case ifcIDtYPEsTROKEcALLbACK_DRAGeND :
        }
            break ;
            paramP.vtHoverPad.setF( tinP , paramP.tHoverPadDrag ) ;
            etherP.strokeF( tinP , T("")+S2(0,scOld_PUSHtABfRESHoFF) ) ;
            paramP.bHoverPadDrag.grabF( tinP , TAG( TAGiDnULL ) ) ; //UNGRABBED BY tmRestoreTabbingF
        {
        case ifcIDtYPEsTROKEcALLbACK_DRAGbEGIN :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("drag me with the right mouse button") , TOCK * 1 , flHINT_EVENiFfULLsCREEN ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buHoverPadCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP ) ;

    }
        //paramP.vtTest.setF( tinP , T("")+S2(2,scOld_cPUSHiDoBJECT)+T(post2)+S2(0,scOld_POPiDoBJECT) ) ;

        if( ++ post2[ 0 ] > 'z' ) post2[ 0 ] = 'a' ;
        static osTextT post2[] = { 'a' - 1 , 0 } ;
    {
    else
    }
    {
    if( !idCycleP )

    ARGgET( cArgP )
{
voidT animateTestCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    paramP.eye >> paramP.vtEye ;

    }
        }
            paramP.eye.setModeFlagsF( tinP , flPAPERbACKmODE_null , flPAPERbACKmODE_ABSENT ) ;

            replaceButtonsF( tinP , etherP , cArgP , tButtons , CSTTmINbUTTONS , T("IPDOS (tm)  buttons") ) ;
            if(      paramP.treeKt.rightF( 1 , 1 ) ) tButtons += T(" ")+paramP.buClimbRight ;
            if(      paramP.treeKt.leftF(  1 , 1 ) ) tButtons += T(" ")+paramP.buClimbLeft  ;
            if( 2 == paramP.treeKt.upF(    2 , 1 ) ) tButtons += T(" ")+paramP.buClimbUp    ;
            if( 2 == paramP.treeKt.downF(  2 , 1 ) ) tButtons += T(" ")+paramP.buClimbDown  ;
            TN( tButtons , "" ) ; tButtons = paramP.buEyeEnter+T(" ")+paramP.buEscape+T(" ")+paramP.buF1/*+T(" ")+paramP.buF2*/+T(" ")+paramP.buSubscribe ;

            paramP.bEyeStarted = 1 ;
        {
        if( !paramP.bEyeStarted )
    {
    else
    }
        paramP.bEyeStarted = 0 ;

        replaceButtonsF( tinP , etherP , cArgP , tButtons , CSTTmINbUTTONS , T("IPDOS (tm)  buttons") ) ;
        if(      paramP.treeKt.rightF( 1 , 1 ) ) tButtons += T(" ")+paramP.buClimbRight ;
        if(      paramP.treeKt.leftF(  1 , 1 ) ) tButtons += T(" ")+paramP.buClimbLeft  ;
        if( 2 == paramP.treeKt.upF(    2 , 1 ) ) tButtons += T(" ")+paramP.buClimbUp    ;
        if( 2 == paramP.treeKt.downF(  2 , 1 ) ) tButtons += T(" ")+paramP.buClimbDown  ;
        TN( tButtons , "" ) ; tButtons = paramP.buEscape+T(" ")+paramP.buF1/*+T(" ")+paramP.buF2*/+T(" ")+paramP.buSubscribe ;

        paramP.eye.setModeFlagsF( tinP , flPAPERbACKmODE_ABSENT , flPAPERbACKmODE_null ) ;
    {
    if( !idCycleP )

    ARGgET( cArgP )
{
voidT animateEyeCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    if( etherP ) ;

    }
        paramP.vtEyeNote5.setF( tinP , T("")+S3(28.0,scOld_mmFRAMEcELLS,11.0)+tSay+S2(0,scOld_POPfRAME) ) ;

        ;

            +T("state.vaPod_z(3): ")+TF1(state.vaPod_z(3))+T("\r\n")
            +T("state.vaPod_z(2): ")+TF1(state.vaPod_z(2))+T("\r\n")
            +T("state.vaPod_z(1): ")+TF1(state.vaPod_z(1))+T("\r\n")
            +S2(saA1_HARDbLANKfILLEDwITHpEE,sc_cALPHABET1)+T("\r\n")
            +T("state.vaPod_y(3): ")+TF1(state.vaPod_y(3))+T("\r\n")
            +T("state.vaPod_y(2): ")+TF1(state.vaPod_y(2))+T("\r\n")
            +T("state.vaPod_y(1): ")+TF1(state.vaPod_y(1))+T("\r\n")
            +S2(saA1_HARDbLANKfILLEDwITHpEE,sc_cALPHABET1)+T("\r\n")
            +T("state.vaPod_x(3): ")+TF1(state.vaPod_x(3))+T("\r\n")
            +T("state.vaPod_x(2): ")+TF1(state.vaPod_x(2))+T("\r\n")
             T("state.vaPod_x(1): ")+TF1(state.vaPod_x(1))+T("\r\n")

        TN( tSay , "" ) ; tSay =

        const eyeStateOldS& state = paramP.eye ;
    {
    if( idCycleP )

    ARGgET( cArgP )
{
voidT animateEyeNote5CBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    if( etherP ) ;

    }
        paramP.vtEyeNote4.setF( tinP , T("")+S3(28.0,scOld_mmFRAMEcELLS,13.0)+tSay+S2(0,scOld_POPfRAME) ) ;

        ;

            +T("state.vhPod_z(3): ")+TF1(state.vhPod_z(3))+T("\r\n")
            +T("state.vhPod_z(2): ")+TF1(state.vhPod_z(2))+T("\r\n")
            +T("state.vhPod_z(1): ")+TF1(state.vhPod_z(1))+T("\r\n")
            +S2(saA1_HARDbLANKfILLEDwITHpEE,sc_cALPHABET1)+T("\r\n")
            +T("state.vhPod_y(3): ")+TF1(state.vhPod_y(3))+T("\r\n")
            +T("state.vhPod_y(2): ")+TF1(state.vhPod_y(2))+T("\r\n")
            +T("state.vhPod_y(1): ")+TF1(state.vhPod_y(1))+T("\r\n")
            +S2(saA1_HARDbLANKfILLEDwITHpEE,sc_cALPHABET1)+T("\r\n")
            +T("state.vhPod_x(3): ")+TF1(state.vhPod_x(3))+T("\r\n")
            +T("state.vhPod_x(2): ")+TF1(state.vhPod_x(2))+T("\r\n")
            +T("state.vhPod_x(1): ")+TF1(state.vhPod_x(1))+T("\r\n")
            +S2(saA1_HARDbLANKfILLEDwITHpEE,sc_cALPHABET1)+T("\r\n")
            T("angPodRotate: ")+TF1(paramP.eye.rowEye.ro.angPodRotate)+T("\r\n")

        TN( tSay , "" ) ; tSay =

        const eyeStateOldS& state = paramP.eye ;
    {
    if( idCycleP )

    ARGgET( cArgP )
{
voidT animateEyeNote4CBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    if( etherP ) ;

    }
        paramP.vtEyeNote3.setF( tinP , T("")+S3(28.0,scOld_mmFRAMEcELLS,13.0)+tSay+S2(0,scOld_POPfRAME) ) ;

        ;

            +T("state.vaHull_z(3): ")+TF1(state.vaHull_z(3))+T("\r\n")
            +T("state.vaHull_z(2): ")+TF1(state.vaHull_z(2))+T("\r\n")
            +T("state.vaHull_z(1): ")+TF1(state.vaHull_z(1))+T("\r\n")
            +S2(saA1_HARDbLANKfILLEDwITHpEE,sc_cALPHABET1)+T("\r\n")
            +T("state.vaHull_y(3): ")+TF1(state.vaHull_y(3))+T("\r\n")
            +T("state.vaHull_y(2): ")+TF1(state.vaHull_y(2))+T("\r\n")
            +T("state.vaHull_y(1): ")+TF1(state.vaHull_y(1))+T("\r\n")
            +S2(saA1_HARDbLANKfILLEDwITHpEE,sc_cALPHABET1)+T("\r\n")
            +T("state.vaHull_x(3): ")+TF1(state.vaHull_x(3))+T("\r\n")
            +T("state.vaHull_x(2): ")+TF1(state.vaHull_x(2))+T("\r\n")
             T("state.vaHull_x(1): ")+TF1(state.vaHull_x(1))+T("\r\n")

        TN( tSay , "" ) ; tSay =

        const eyeStateOldS& state = paramP.eye ;
    {
    if( idCycleP )

    ARGgET( cArgP )
{
voidT animateEyeNote3CBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    if( etherP ) ;

    }
        paramP.vtEyeNote1.setF( tinP , T("")+S3(28.0,scOld_mmFRAMEcELLS,3.0)+tSay+S2(0,scOld_POPfRAME) ) ;

        ;

            +T("vao(3) : ")+TF1(state.vao(3))+T("\r\n")
            +T("vao(2) : ")+TF1(state.vao(2))+T("\r\n")
             T("vao(1) : ")+TF1(state.vao(1))+T("\r\n")

        TN( tSay , "" ) ; tSay =

        const eyeStateOldS& state = paramP.eye ;
    {
    if( idCycleP )

    ARGgET( cArgP )
{
voidT animateEyeNote1CBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    if( idCycleP ) ;

    timeL2 = timeN2 ;
    timeL1 = timeN1 ;

    }
        }
            etherP.delF( tinP , psttw ) ;
    
            paramP.vtGraphSpeedMinMax.setF( tinP , T("")+S3(8.0,scOld_mmFRAMEcELLS,2.0)+S2(ifcRGB_G4,scOld_cPUSHcOLOR)+TF1(mMin)+S2(0,scOld_POPcOLOR)+T("\r\n")+S2(ifcRGB_R4,scOld_cPUSHcOLOR)+TF1(mMax)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
            paramP.vtGraphSpeed.setF( tinP , psttw ) ;
    
            }
                etherP.strFuseF( tinP , psttw , tn+S2(0,scOld_POPfRAME) ) ;
                etherP.strFuseF( tinP , psttw , tn    +S2(0,scOld_POPfRAME) ) ;
                etherP.strFuseF( tinP , psttw , tn        +S2(0,scOld_POPfRAMEdETACH) ) ;

                etherP.strFuseF( tinP , psttw , tn        +S2(0,scOld_POPcOLOR) ) ;
                }
                    mx += mxd ;
                    etherP.strFuseF( tinP , psttw , T("")+S3(mx,(cLines?scOld_mmLINEtO:scOld_mmLINEeNDtO),mRel) ) ; ___( psttw ) ;
                    if( offc == CsAMPLE ) offc = 0 ;
                    measureT mRel = ( pmElapsed[offc++] - mMin ) / ( mMax - mMin ) ;
                {
                while( cLines -- )
                measureT mx = mxd ;
                etherP.strFuseF( tinP , psttw , tn        +S3((measureT)0.0,scOld_mmMOVEtO,mRel0) ) ;
                etherP.strFuseF( tinP , psttw , tn        +S2(ifcRGB_DARKcYAN,scOld_cPUSHcOLOR) ) ;

                etherP.strFuseF( tinP , psttw , tn        +S2(0,scOld_FRAMEdETACH) ) ;
                etherP.strFuseF( tinP , psttw , tn    +S3(1.0,scOld_mmFRAMEtO,1.0) ) ;
                etherP.strMakeF( tinP , psttw , tn+S3(1.0,scOld_mmFRAMEtO,1.0) , CsAMPLE * 0x10 ) ; ___( psttw ) ; //U::O: EXACT ALLOCATION
                TN( tn , "" ) ;

                if( offc == CsAMPLE ) offc = 0 ;
                measureT mRel0 = ( pmElapsed[offc++] - mMin ) / ( mMax - mMin ) ;
                const measureT mxd = 1.0 / (measureT)cLines ;
            {
            ZE( strokeS* , psttw ) ;
        {
        if( cLines && mMax > mMin )

        countT offc   = bFull ? offEnd : 0 ;
        countT cLines = ( bFull ? CsAMPLE : offEnd ) - 1 ;

        }
            bNew = 1 ;
            }
                if( mMin > mNew ) mMin = mNew ;
                if( mMax < mNew ) mMax = mNew ;
                measureT mNew = pmElapsed[ off ] ;
            {
            for( countT off = 0 ; off < offe ; off ++ )
            const countT offe = bFull ? CsAMPLE : offEnd ;
            mMax = 0.0 ;
            mMin = 1e10 ;
        {
        if( !offEnd && !( cFrames % 0x2 ) )

        }
            cFrames ++ ;
            if( !bFull ) bFull = 1 ;
            offEnd = 0 ;
        {
        if( offEnd >= CsAMPLE )
        static countT cFrames ;

        }
            if( mMin > mNew ) { mMin = mNew ; bNew = 1 ; }
            if( mMax < mNew ) { mMax = mNew ; bNew = 1 ; }
            pmElapsed[ offEnd ++ ] = mNew ;
            measureT mNew = timeE1 ;
        {

        static measureT pmElapsed[ CsAMPLE ] ;
        static countT offEnd ;
        static flagsT bFull ;

        etherP.osTimeSubtractF( tinP , timeE1 , timeE2 , timeL1 , timeL2 ) ;
        sCountT timeE2 = timeN2 ;
        countT  timeE1 = timeN1 ;
    {
    if( timeL2 == timeN2 )

    etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT  , timeN1 ) ;

    static sCountT timeL2 ;
    static countT  timeL1 ;

    ARGgET( cArgP )
{
voidT animateGraphSpeedCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    if( etherP && idCycleP ) ;

    }
        paramP.vtGraphSpeedMinMax.setF( tinP , T("")+S3(8.0,scOld_mmFRAMEcELLS,2.0)+S2(ifcRGB_G4,scOld_cPUSHcOLOR)+TF1(mMin)+S2(0,scOld_POPcOLOR)+T("\r\n")+S2(ifcRGB_R4,scOld_cPUSHcOLOR)+TF1(mMax)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
        bNew = 0 ;
    {
    if( bNew )
    ARGgET( cArgP )
{
voidT animateGraphSpeedMinMaxCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

boolT    bNew ;
measureT mMin = 1e10 ;
measureT mMax ;

#define CsAMPLE ( TUCK / 2 )
}
    }
        paramP.stSpeech.ungrabF( tinP ) ;
        }
            if( !cRemaining ) speechEpilogF( tinP , etherP , cArgP ) ;
        
            paramP.vtSlidesRemaining.setF( tinP , T("")+S3((measureT)tRemPlain.csF(tinP),scOld_mmFRAMEcELLS,(measureT)1.0)+tRem+S2(0,scOld_POPfRAME) ) ;
            TN( tRem , "" ) ; tRem = T("")+S2(ifcRGB_BROWN,scOld_cPUSHcOLOR)+tRemPlain+S2(0,scOld_POPcOLOR) ;
            TN( tRemPlain , "" ) ; tRemPlain = TF1(cRemaining) ;
            countT cRemaining = paramP.stSpeech - idSpeak ;
        
            paramP.vtSpeech.setF( tinP , T("")+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1)+S3(mFrames,scOld_mmFRAMEcELLS,(measureT)1.0)+T(psttzSpeak)+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME) ) ;
            strokeS::renderSizeIF( tinP , etherP , psttzSpeak , mCols , mPads , mFrames ) ;
            ZE( measureT , mFrames ) ;
            ZE( measureT , mPads ) ;
            ZE( measureT , mCols ) ;
    
            }
                paramP.timeHintExpires1 = c3p.c3 ;
                hintF( tinP , etherP , cArgP , psttzHint ) ;
            {
            if( psttzHint )
    
            strokeS* psttzHint  = (strokeS*)c3p.c2 ;
            strokeS* psttzSpeak = (strokeS*)c3p.c1 ;
            count3S& c3p = *(count3S*)&paramP.stSpeech[ idSpeak ] ;
            countT   idSpeak    = 1 + ( ( ++ paramP.idSpeak ) - 1 ) % paramP.stSpeech ;
        {
        if( paramP.stSpeech )
        paramP.stSpeech.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( paramP.bBegin && !( idCycleP % PERIOD ) )
    ARGgET( cArgP )
{
voidT animateSpeechCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    THREADmODE1rESTORE
    #endif
    }
        }
            }
                etherP( tinP , psIn ) ;
                etherP( tinP , psOut ) ;
                }
                    }
                        paramP.vtMonitorPoolNames.setF( tinP , T("")+S3((measureT)csttMax,scOld_mmFRAMEcELLS,(measureT)cLines)+tRpt+S2(0,scOld_POPfRAME) ) ;

                        }
                            }
                                etherP.delF( tinP , psttName ) ;

                                tRpt += tEntry+T("\r\n") ;
                                if( csttMax < tEntry.csF( tinP ) ) csttMax = tEntry.csF( tinP ) ;

                                TN( tEntry , " " ) ; tEntry += T(psttName) ;

                                }
                                    psttName = psttw ; psttw = 0 ;
                                    etherP.delF( tinP , psttName ) ;
                                    etherP.strSubstringF( tinP , psttw , idf , countTC() , psttName ) ; ___( psttw ) ;
                                    countT idf = 1 + tPrefix.csF( tinP ) ;
                                    ZE( strokeS* , psttw ) ;
                                {
                                if( 1 == etherP.strIdF( tinP , tPrefix , psttName ) )

                                *psIn >> psttName ;
                                ZE( strokeS* , psttName ) ;
                            {
                            while( cNames -- )

                            cLines += cNames ;
                            *psIn >> cNames ;
                            ZE( countT , cNames ) ;

                            cLines ++ ;
                            tRpt += tEntry+T("\r\n") ;

                            if( csttMax < tEntry.csF( tinP ) ) csttMax = tEntry.csF( tinP ) ;
                            }
                                default                            : { tEntry += T(" (special)"     ) ; break ; }
                                case ifcIDmEMORYsPACE_APPLICATIONS : { tEntry += T(" (applications)") ; break ; }
                                case ifcIDmEMORYsPACE_KERNEL       : { tEntry += T(" (kernel)"      ) ; break ; }
                            {
                            switch( idMemorySpace )
                            TN( tEntry , "memory space " ) ; tEntry += TF1(idMemorySpace) ;

                            *psIn >> idMemorySpace ;
                            ZE( countT , idMemorySpace ) ;
                        {
                        while( cSpaces -- )
                        ZE( countT , csttMax ) ;
                        ZE( countT , cLines ) ;

                        *psIn >> cSpaces ;
                        ZE( countT , cSpaces ) ;

                        __( idReply - ifcIDrEPLYmONITOR_POOLoLDnAMES ) ;
                        *psIn >> idReply ;
                        ZE( countT , idReply ) ;

                        TN( tRpt , "" ) ;
                        TN( tPrefix , postIFCpOOLoLDpREFIX ) ;
                    {
                    else
                    if( POOP ) POOPR

                    pso->readF( tinP , *psIn ) ;
                    pso->writeF( tinP , *psOut ) ;
                    *psOut << (countT)ifcIDcMDmONITOR_POOLoLDnAMES ;
                {
                if( psOut && psIn )
                etherP( tinP , psIn , TAG( TAGiDnULL ) ) ;
                etherP( tinP , psOut , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psIn ) ;
                ZE( soulC* , psOut ) ;
            {
            if( pso )

            }
                else paramP.vtMonitorPoolNames.setF( tinP , T("")+S3(32.0,scOld_mmFRAMEcELLS,8.0)+T("connected")+S2(0,scOld_POPfRAME) ) ;
                }
                    POOPR
                    DEL( pso ) ;
                    paramP.vtMonitorPoolNames.setF( tinP , T("")+S3(32.0,scOld_mmFRAMEcELLS,8.0)+T("could not connect")+S2(0,scOld_POPfRAME) ) ;
                {
                if( POOP )
                pso->connectF( tinP , U::(SEE f750104 0850104) ifcIDpORT_DOOR , nicNameC() , 1 ) ;
                pso = new( 0 , tinP , LF ) socketC( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ; ___( pso ) ;
                paramP.vtMonitorPoolNames.setF( tinP , T("")+S3(32.0,scOld_mmFRAMEcELLS,8.0)+T("connecting")+S2(0,scOld_POPfRAME) ) ;
            {
            if( !pso )
            SCOOPS
        {
        IFsCRATCH
    {
    else
    #if defined( NEVERdEFINED )
    //DISABLE FOR DEVELOPMENT; ENABLE FOR RELEASE (DISABLED CAUSE NEED TO USE A DIFF PORT)

    }
        paramP.vtMonitorPoolNames.setF( tinP , T("")+S3(32.0,scOld_mmFRAMEcELLS,8.0)+T("disconnected")+S2(0,scOld_POPfRAME) ) ;
        DEL( pso ) ;
        paramP.vtMonitorPoolNames.setF( tinP , T("")+S3(32.0,scOld_mmFRAMEcELLS,8.0)+T("disconnecting")+S2(0,scOld_POPfRAME) ) ;
    {
    if( !idCycleP )
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    static socketC* pso ;
    ARGgET( cArgP )
{
voidT animateMonitorPoolNamesCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    if( idCycleP ) ;

    setClockHandsF( tinP , etherP , paramP.ppvtClockBanner , paramP.cpvtClockBanner , &paramP.vtHintClockBanner , timeLeft1 , timeLeft2 , paramP.rReachRemaining , T("")+S3(1.0,scOld_mmFRAMEtO,1.0)+(paramP.psttLabelRemaining?T(""):paramP.buClockBannerLabel)+S2(0,scOld_POPfRAME)+T(paramP.psttLabelRemaining) , 5 ) ;
    etherP.osTimeSubtractF( tinP , timeLeft1 , timeLeft2 , timeN1 , timeN2 ) ;
    sCountT timeLeft2 = timeRetire2 ;
    countT timeLeft1 = timeRetire1 ;
                
    etherP.osTimeFromOldTimeF( tinP , timeRetire1 , timeRetire2 , 2013 , 9 , 7 ) ;
    ZE( sCountT , timeRetire2 ) ;
    ZE( countT , timeRetire1 ) ;
                
    etherP.osTimeSubtractF( tinP , timeAge1 , timeAge2 , timeBorn1 , timeBorn2 ) ;
    sCountT timeAge2 = timeN2 ;
    countT timeAge1 = timeN1 ;
                
    etherP.osTimeFromOldTimeF( tinP , timeBorn1 , timeBorn2 , 1953 , 9 , 7 ) ;
    ZE( sCountT , timeBorn2 ) ;
    ZE( countT , timeBorn1 ) ;
                
    etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT , timeN1 ) ;
    ARGgET( cArgP )
{
voidT animateClockBannerCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    if( idCycleP ) ;

    setClockHandsF( tinP , etherP , paramP.ppvtClock , paramP.cpvtClock , &paramP.vtHintClock , timeN1 , timeN2 , 1.0 / 16.0 , T("NOW") , 5 ) ;
    etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT , timeN1 ) ;
    ARGgET( cArgP )
{
voidT animateClockCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    if( etherP && idCycleP ) ;

    paramP.vtHoverPadAnimation.setF( tinP , T("")+S3(1.0,scOld_mmFRAMEtO,1.0)+S2(0,scOld_cPUSHrIPPLES)+S2(0,scOld_FRAMEdETACH)+S2(color*intensity,scOld_cPUSHcOLOR)+S3(1.0,scOld_mmLINEtO,0.0)+S3(1.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,1.0)+S3(0.0,scOld_mmLINEtO,0.0)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAMEdETACH)+S2(0,scOld_POPrIPPLES)+S2(0,scOld_POPfRAME) ) ;

    }
        if( !( color & 0xffffff ) ) color = 1 ;
        color <<= 8 ;

        intensity = INTENSITYmIN ;
        delta = - delta ;
    {
    else if( intensity < INTENSITYmIN )
    }
        intensity = 0xff ;
        delta = - delta ;
    {
    if( intensity > 0xff )

    intensity += delta ;
    static countT color = 1 ;
    static sCountT intensity = INTENSITYmIN ;
    static countT delta = 8 ;

    ARGgET( cArgP )
{
voidT animateHoverPadCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

#define INTENSITYmIN 0x60

}
    if( tinP.fingerprint && etherP && idCycleP ) ;

    ARGgET( cArgP )
{
voidT animateViewsCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    }
        paramP.buTest.setF( tinP , T("O") ) ;

        pRoot->letRefF() ;

        }
            }
                //Beep( TUCK , TUCK ) ; //U::
                thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_ENABLEsECURITYsHUTDOWN ;
            {
            if( !( F(thirdC::third_flagsModeProcess2I_IF( tinP )) & flMODEpROCESS2_ENABLEsECURITYsHUTDOWN ) )

            }
                }
                    if( paramP.timeHintExpires2 < timeN2 || ( paramP.timeHintExpires2 == timeN2 && paramP.timeHintExpires1 < timeN1 ) ) hintF( tinP , etherP , cArgP , paramP.tHintDefault , 0 , flHINT_EVENiFfULLsCREEN ) ;
                    etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                if( paramP.timeHintExpires1 || paramP.timeHintExpires2 )
    
                if( !paramP.bAnimating ) paramP.bAnimating = 1 ;
            {
            if( paramP.bBegin && !( idCycleP % PERIOD ) )
        {
        else
        }
            }
                }
                    default : { paramP.idSpeak -= 2 ; break ; }
                    case 1  : { paramP.idSpeak --   ; break ; }
                    case 0  : {                       break ; }
                {
                switch( paramP.idSpeak )
                paramP.bAnimating = 0 ;
            {
            if( paramP.bAnimating )
        {
        if( !pRoot || F(pRoot->rowBack.ro.flagsPaperBackMode) & flPAPERbACKmODE_ABSENT )
        ARGgET( cArgP )
    {
    if( pRoot )
    windowOldC* pRoot = windowOldC::getRefIF( tinP ) ;
{
voidT animateCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    if( etherP && idCycleP ) ;

    }
        paramP.vt1tutorial.setF( tinP , T("")+S3((measureT)1.0,scOld_mmFRAMEtO,height)+S2(rgb,scOld_cPUSHcOLOR)+S2(saA1_TOOLUP,sc_cALPHABET1)+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;
        ARGgET( cArgP )
    
        }
            height = MIN2 + hDelta ;
            hDelta = DELTA2 ;
        {
        else if( height < MIN2 )
        }
            height = MAX2 + hDelta ;
            hDelta = - DELTA2 ;
        {
        if( height >= MAX2 )
        height += hDelta ;
        static measureT hDelta = DELTA2 ;
        static measureT height = MIN2 ;
    
        countT rgb = 0x000100 * intensity ;
        }
            intensity = MIN1 + iDelta ;
            iDelta = DELTA1 ;
        {
        else if( intensity < MIN1 )
        }
            intensity = MAX1 + iDelta ;
            iDelta = - DELTA1 ;
        {
        if( intensity >= MAX1 )
        intensity += iDelta ;
        static sCountT iDelta = DELTA1 ;
        static sCountT intensity = MIN1 ;
    {
    if( paramP.b1tutorial )
    ARGgET( cArgP )
{
voidT vt1tutorialCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    }
        }
            }
                }
                    }
                        }
                            break ;
                            idPhase = 0 ;
                            paramP.vt2bigitName.setF( tinP , T("")+S3(1.0,scOld_mmFRAMEtO,1.0)+S3(4.0,scOld_mmPADfORsADAMfRAMES,4.0)+S3(2.0,scOld_mmFRAMEcELLS,1.0)+S2(ifcRGB_G4,scOld_cPUSHcOLOR)+T(ppostName[bigit])+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME) ) ;
            
                            } ;
                                "fU" ,
                                "Ee" ,
                                "De" ,
                                "Ce" ,
                                "Be" ,
                                "Ay" ,
                                "Ni" ,
                                "Ta" ,
                                "Ve" ,
                                "Se" ,
                                "fI" ,
                                "Fo" ,
                                "Re" ,
                                "Oo" ,
                                "Wo" ,
                                "Ze" ,
                            {
                            static osTextT* ppostName[] =
                        {
                        case 2 :
                        }
                            break ;
                            idPhase = 2 ;
                            paramP.vt2bigit.setF( tinP , T("")+S2(ifcRGB_G4,scOld_cPUSHcOLOR)+TF1(bigit)+S2(0,scOld_POPcOLOR) ) ;
    
                            (*pStkBigitsToDo) >> bigit ;
                            bigit = 0 ;
                        {
                        case 1 :
                        }
                            break ;
                            idPhase = 1 ;
                            paramP.vt2bigitName.setF( tinP , T("") ) ;
                            paramP.vt2bigit.setF( tinP , T("") ) ;
                        {
                        case 0 :
                    {
                    switch( idPhase )
                    ARGgET( cArgP )
                {
                if( !( idCycleP % 0x20 ) )

                }
                    }
                        }
                            }
                                (*pStkBigitsToDo) << bigit ;
                                pTally[ bigit ] ++ ;
                            {
                            if( !pTally[ bigit ] )
                            countT bigit = tinP.ranUni % 0x10 ;
                        {
                        while( 0x10 > *pStkBigitsToDo )
        
                        } ;
                            0 , 0 , 0 , 0
                            0 , 0 , 0 , 0 ,
                            0 , 0 , 0 , 0 ,
                            0 , 0 , 0 , 0 ,
                        {
                        countT pTally[] =
                    {
                    else
                    }
                        for( countT bigit = 0 ; bigit <= 0xf ; bigit ++ ) (*pStkBigitsToDo) << bigit ;
                    {
                    if( idIn < 4 )

                    countT idIn = ++ idInLath ;
                    static countT idInLath ;
                {
                if( !*pStkBigitsToDo )
            {
            else
            }
                }
                    paramP.vt2bigitHelp.setF( tinP , tDo ) ;
                    }
                        ;
                        
                            S2(0,scOld_POPfRAME)
                                S2(0,scOld_POPfRAME)+
                                    tDoWoth+
                                S3(7.0,scOld_mmFRAMEcELLS,1.0)+
                                S3(1.0,scOld_mmPADfORsADAMfRAMES,1.0)+
                            S3(1.0,scOld_mmFRAMEtO,1.0)+
                            T("")+
                        
                        tDo =
                        TN( tDoWoth , "" ) ; tDoWoth += T("climb ")+S2(saA1_TOOLUP,sc_cALPHABET1) ;
                    {
                    if( !paramP.bReadingInstructions && idIn ++ % 2 )
                    TN( tDo , "" ) ;
                    static countT idIn ;
                    ARGgET( cArgP )
                {
                if( !( idCycleP % 0x10 ) )
            {
            if( !paramP.bGameStarted )

            }
                }
                    paramP.bReadingInstructions = paramP.bGameStarted = 0 ;
                    paramP.vt2bigitHelp.setF( tinP ) ;
                    paramP.vt2bigitName.setF( tinP ) ;
                    paramP.vt2bigit.setF( tinP ) ;
                    ARGgET( cArgP )
                {
                if( timeN2 || timeN1 > TOCK * 0x40 ) //ENOUGH TIME FOR USER TO PLAY WITH VIEW BUTTON WHILE READING INSTRUCTIONS FOR BIGIT GAME

                paramP.timeGameErased2 = paramP.timeGameErased1 = 0 ;
                etherP.osTimeSubtractF( tinP , timeN1 , timeN2 , paramP.timeGameErased1 , paramP.timeGameErased2 ) ;
                etherP.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT  , timeN1 ) ;
            {
            if( paramP.timeGameErased2 || paramP.timeGameErased1 )
            ARGgET( cArgP )
        {
        if( pStkBigitsToDo )
        if( !pStkBigitsToDo ) etherP( tinP , pStkBigitsToDo , TAG( TAGiDnULL ) , flSTACKc_FIFO|flSTACKc_ALLOWzE ) ;
    {
    else
    }
        etherP( tinP , pStkBigitsToDo ) ;
        ARGgET( cArgP )
    {
    if( !idCycleP )

    static stackC* pStkBigitsToDo ;
    static countT bigit ;
    static countT idPhase ;
{
voidT vt2bigitCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    if( etherP && tinP.fingerprint && idCycleP ) ;

    if( !paramP.bReadingInstructions ) paramP.bReadingInstructions = 1 ;
    ARGgET( cArgP )
{
voidT readTheseInstructionsCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

}
    }
        etherP.osTimeNowF( tinP , paramP.timeGameErased1 , paramP.timeGameErased2 ) ;
        paramP.timeGameErased2 = paramP.timeGameErased1 = 0 ;
    {
    if( !idCycleP )
    ARGgET( cArgP )
{
voidT gameShownCBF( tinS& tinP , etherC& etherP , const countT idCycleP , const countT cArgP )

#define MAX2 1.0
#define MIN2 0.5
#define DELTA2 1e-1

#define MAX1 0x100
#define MIN1 0x00
#define DELTA1 0x10

#include postHEADER

/*1*//*callbacks (cont'd)*//*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

