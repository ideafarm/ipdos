
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_
    }
        }
            }
                pInfoFileP->flags |= flFILEaTTR_DOTdIRECTORY ;
                )
                    )
                        )
                            pInfoFileP->postOsName[ costn - 4 ] == '\\'
                            pInfoFileP->postOsName[ costn - 3 ] == '.' &&
                        (
                        pInfoFileP->postOsName[ costn - 3 ] == '\\' ||
                    (
                    pInfoFileP->postOsName[ costn - 2 ] == '.' &&
                    pInfoFileP->postOsName[ costn - 1 ] == '\\' &&
                (
                if                                                                                 // ENDS WITH EITHER "/./" OR "/../"
                countT costn = c_strlenIF( tinP , pInfoFileP->postOsName ) ;

                thirdC::c_strncpyIF( tinP , pInfoFileP->postOsName , ostot , pInfoFileP->costaOsName ) ;
                OStEXTAK( ostot , "\\" )
                OStEXTA( ostot , pInfoFileP->postOsName )
                OStEXT( ostot , 0x200 )
            {
            if( F(pInfoFileP->flags) & flFILEaTTR_DIRECTORY )
            #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000001.getFileInfo.h"
        {
        if( !*this && fFound )

        delF( tinP , postLike ) ;
        }
            }
                }
                    c_strncpyIF( tinP , pInfoFileP->postOsNameAlt , ostota , pInfoFileP->costaOsNameAlt ) ;
                    newF( tinP , LF , pInfoFileP->postOsNameAlt , pInfoFileP->costaOsNameAlt ) ; ___( pInfoFileP->postOsNameAlt ) ; // 1 osTextT IS ALLOCATED FOR THE '\\' THAT WILL BE APPENDED IF THE OBJECT IS A DIRECTORY
                    pInfoFileP->costaOsNameAlt = ostota.costF() + 2 ;
                {
                if( *info.symACHnAMEaLT )

                c_strncpyIF( tinP , pInfoFileP->postOsName , ostot , pInfoFileP->costaOsName ) ;
                newF( tinP , LF , pInfoFileP->postOsName , pInfoFileP->costaOsName ) ; ___( pInfoFileP->postOsName ) ; // 1 osTextT IS ALLOCATED FOR THE '\\' THAT WILL BE APPENDED IF THE OBJECT IS A DIRECTORY
                pInfoFileP->costaOsName = ostot.costF() + 2 ;

                if( info.symACHnAMEaLT ) OStEXTA( ostota , info.symACHnAMEaLT )
                OStEXTAL( ostota , postLike , costPrefix )
                OStEXT( ostota , TUCK << 1 )

                if( info.symACHnAME ) OStEXTA( ostot , info.symACHnAME )
                OStEXTAL( ostot , postLike , costPrefix )
                OStEXT( ostot , TUCK << 1 )

                countT costPrefix = postEnd - postLike + 1 ;
                postEnd = c_strrchrIF( tinP , postLike , '\\' ) ;
                ZE( osTextT* , postEnd ) ;
            {
            if( pInfoFileP )
            __Z( pInfoFileP ) ;
            pInfoFileP = new( 0 , tinP , LF ) infoFileS( tinP ) ; ___( pInfoFileP ) ;
        {
        if( !*this && fFound )

        }
            #endif

                }
                    }
                        }
                            break ;
                            handleP.closeIfF() ;
                            fFound = 0 ;
                            tinP.bosFail = 0 ;
                            BOSpOOP
                        {
                        default :
                        }
                            break ;
                            handleP.closeIfF() ;
                            fFound = 0 ;
                            tinP.bosFail = 0 ;
                        {
                        case ERROR_NO_MORE_FILES  :
                        case ERROR_PATH_NOT_FOUND :
                        case ERROR_FILE_NOT_FOUND :
                        }
                            //INTENTIONAL FALLTHROUGH
                            etherC::etTextIF( tinP ).traceF( tinP , T("thirdC::dosFindFileOrDirPrivateF / ERROR_SHARING_VIOLATION [postLike]: ")+T(postLike) ) ;
                            BOSpOOP
                        {
                        case ERROR_SHARING_VIOLATION :
                    {
                    switch( tinP.brcLath )
                {
                if( tinP.bosFail )

                }
                    fFound = !tinP.bosFail ;
                    BOS( WHATsfr , BOSoK , FindNextFile( (HANDLE)handleP.osF( ifcIDtYPEhANDLE_FILEfIND ) , &info ) )
                {
                else
                }
                    fFound = !!handleP ;
                    handleP.osF( ifcIDtYPEhANDLE_FILEfIND , tinP.brcRaw ) ;
                    BOS( WHATsfr , BOShANDLE , FindFirstFile( postLike , &info ) )
                {
                if( !handleP )
                BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                ULONG cc = 1 ;

            #elif defined( __NT__ )

                //U: CONJ: NEED TO CLOSE THE HANDLE IF ANOTHER FILE WAS NOT FOUND

                fFound = cc == 1 && !tinP.brcLath ;
                }
                    BOSpOOP
                {
                )
                    tinP.brcLath != ERROR_NOT_READY
                    tinP.brcLath != ERROR_PATH_NOT_FOUND          && /*CONJECTURE: THIS WILL NEVER OCCUR*/
                    tinP.brcLath != ERROR_FILE_NOT_FOUND          && /*CONJECTURE: THIS WILL NEVER OCCUR*/
                    tinP.brcLath != ERROR_NOT_DOS_DISK            && /*DON''T KNOW IF THIS OCCURS*/
                    tinP.brcLath != ERROR_FILENAME_EXCED_RANGE    && /*LONG NAME THAT IS NOT SUPPORTED ON THIS DISK*/
                    tinP.brcLath != ERROR_NO_MORE_FILES           && /*NO MORE MATCHES*/
                    tinP.bosFail                                 && /*CAUSE:*/
                if( 

                }
                    BOSI( WHATsfr , BOSfAIL , DosFindNext( handleP.osF( ifcIDtYPEhANDLE_FILEfIND ) , &info , sizeof info , &cc ) )
                {
                else
                }
                    handleP.osF( ifcIDtYPEhANDLE_FILEfIND , (countT)osh ) ;
                    BOSI( WHATsfr , BOSfAIL , DosFindFirst( postLike , &osh , FILE_ARCHIVED | FILE_DIRECTORY | FILE_SYSTEM | FILE_HIDDEN | FILE_READONLY , &info , sizeof info , &cc, FIL_STANDARD ) )
                    ZE( HDIR , osh ) ;

                    else                                                                               handleP.osF( ifcIDtYPEhANDLE_fileFind , (countT)HDIR_CREATE ;
                    if( !c_sttinP.brcRawhrIF( tinP , postLike , '?' ) && !c_sttinP.brcRawhrIF( tinP , postLike , '*' ) ) handleP.osF( ifcIDtYPEhANDLE_FILEfIND , (countT)HDIR_SYSTEM ) ;
                {
                if( !handleP )
                ULONG cc = 1 ;

            #ifdef __OS2__
        {
        if( !POOP )

        c_memsetIF( tinP , (byteT*)&info , sizeof info ) ;
        #endif
            WIN32_FIND_DATA info ;
        #elif defined( __NT__ )
            FILEFINDBUF3 info ;
        #ifdef __OS2__
        ZE( boolT , fFound ) ;

        __Z( cMax ) ;
        countT cMax = dosQuerySysInfoMaxPathLengthIF( tinP ) ;
        }
            __( !(( ostDisk >= 'a' && ostDisk <= 'z' )||( ostDisk >= 'A' && ostDisk <= 'Z' )) ) ;
            if( !POOP ) ostDisk = *postLike ;
            ZE( osTextT , ostDisk ) ;
        {
        if( !bNetBios )

        const boolT bNetBios = postLike[ 0 ] == '\\' && postLike[ 1 ] == '\\' ;

        if( postLike ) postLike[ costCopy ] = 0 ;
        c_memcpyIF( tinP , postLike , postLikeP , costCopy ) ;
        newF( tinP , LF , postLike , costCopy + 1 ) ; ___( postLike ) ;
        countT costCopy = costLikeP - ( postLikeP[ costLikeP - 1 ] == '\\' ) ;
        const countT costLikeP = postLikeP ? c_strlenIF( tinP , postLikeP ) : 0 ;
        ZE( osTextT* , postLike ) ;                                                 // REMOVED TRAILING '\\' FOR DIRECTORY NAME
    {
    _INoLD_

    }
        if( POOP ) return ;
        #endif
            __( sizeof( countT ) != sizeof( HANDLE ) || fnu ) ;
        #elif defined( __NT__ )
        __( sizeof( countT ) != sizeof( HDIR ) || fnu ) ;
        #ifdef __OS2__
        ZE( boolT , fnu ) ;
        __NZ( pInfoFileP ) ;
        __( !postLikeP[ 3 ] ) ;
        if( POOP ) return ;
        __( !postLikeP[ 2 ] ) ;
        if( POOP ) return ;
        }
            __( postLikeP[ 1 ] - ':' ) ;
        {
        if( postLikeP[ 1 ] != '\\' )            //20190826@0902: ACCOMMODATE NETBIOS FILE NAMES OF THE FORM "\\netbiosname\disk\path\short"
        if( POOP ) return ;
        __( !postLikeP[ 0 ] ) ;
        if( POOP ) return ;
        __Z( postLikeP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
    SCOOP
{
/*1*/voidT thirdC::dosFindFileOrDirPrivateF( tinS& tinP , infoFileS*& pInfoFileP , handleC& handleP , const osTextT* const postLikeP )/*1*/

#endif
    #define symACHnAMEaLT      cAlternateFileName
    #define symACHnAME         cFileName
#elif defined( __NT__ )
    #define symACHnAMEaLT      replaceThisWithName
    #define symACHnAME         achName
#ifdef __OS2__

// CONJ: O.S. WILL SUPPORT SEARCHES FOR ROOT DIRECTORIES
//U: ENHANCE TO ALLOW "?:\\" TO RESULT IN FINDING A ROOT DIRECTORY

/**/

*/
    for Windows: "\\myDir\\myFile.foo*"
   examples
  can contain wildcard strokes ('*' and '?')
   the result is a dir iff F(pInfoFileP->flags) & flFILEaTTR_DIRECTORY
   i cannot be told to just find files, or to just find directories
   my search will find both files and directories
  a terminating '\' character is ignored if present
  must point to a fully qualified file name, in native operating system form
  can contain the wildcard strokes '*' and '?'
  exception: cannot be a root directory, e.g. "?:\"
  can be a directory name (terminating '\' stroke is present)
  can be a file name (no terminating '\' stroke)
  must not be 0
 postLikeP
  call this function repeatedly until handleP is set, by it, to 0
  must be 0 on first call
 handleP
 pInfoFileP
arguments
 failure to do this causes a resource leak
 applications -must- call this function repeatedly until handleP is ze
 as long as handleP is nonze, more matching files exist
this function -must- be called repeatedly until handleP is ze
this function finds a single file whose name matches postLikeP
\<A HREF=\"5.102001e.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosFindFileOrDirPrivateF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

