
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bCloaked ;

    }
        }
            }
                pInfoFileP->flags |= flFILEaTTR_DOTdIRECTORY ;
                )
                    )
                        )
                            pInfoFileP->postOsName[ costn - 4 ] == '\\'
                            pInfoFileP->postOsName[ costn - 3 ] == '.' &&
                        (
                        pInfoFileP->postOsName[ costn - 3 ] == '\\' ||
                    (
                    pInfoFileP->postOsName[ costn - 2 ] == '.' &&
                    pInfoFileP->postOsName[ costn - 1 ] == '\\' &&
                (
                if                                                                                 // ENDS WITH EITHER "/./" OR "/../"
                countT costn = c_strlenIF( tinP , pInfoFileP->postOsName ) ;

                thirdC::c_strncpyIF( tinP , pInfoFileP->postOsName , ostot , pInfoFileP->costaOsName ) ;
                OStEXTAK( ostot , "\\" )
                OStEXTA( ostot , pInfoFileP->postOsName )
                OStEXT( ostot , 0x200 )
            {
            if( F(pInfoFileP->flags) & flFILEaTTR_DIRECTORY )
            #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000001.getFileInfo.h"
        {
        if( !*this && fFound )

        delF( tinP , postLike ) ;
        }
            }
                }
                    c_strncpyIF( tinP , pInfoFileP->postOsNameAlt , ostota , pInfoFileP->costaOsNameAlt ) ;
                    newF( tinP , LF , pInfoFileP->postOsNameAlt , pInfoFileP->costaOsNameAlt ) ; ___( pInfoFileP->postOsNameAlt ) ; // 1 osTextT IS ALLOCATED FOR THE '\\' THAT WILL BE APPENDED IF THE OBJECT IS A DIRECTORY
                    pInfoFileP->costaOsNameAlt = ostota.costF() + 2 ;
                {
                if( *info.symACHnAMEaLT )

                c_strncpyIF( tinP , pInfoFileP->postOsName , ostot , pInfoFileP->costaOsName ) ;
                newF( tinP , LF , pInfoFileP->postOsName , pInfoFileP->costaOsName ) ; ___( pInfoFileP->postOsName ) ; // 1 osTextT IS ALLOCATED FOR THE '\\' THAT WILL BE APPENDED IF THE OBJECT IS A DIRECTORY
                pInfoFileP->costaOsName = ostot.costF() + 2 ;

                if( info.symACHnAMEaLT ) OStEXTA( ostota , info.symACHnAMEaLT )
                OStEXTAL( ostota , postLike , costPrefix )
                OStEXT( ostota , TUCK << 1 )

                if( info.symACHnAME ) OStEXTA( ostot , info.symACHnAME )
                OStEXTAL( ostot , postLike , costPrefix )
                OStEXT( ostot , TUCK << 1 )

                countT costPrefix = postEnd - postLike + 1 ;
                postEnd = c_strrchrIF( tinP , postLike , '\\' ) ;
                ZE( osTextT* , postEnd ) ;
            {
            if( pInfoFileP )
            __Z( pInfoFileP ) ;
            pInfoFileP = new( 0 , tinP , LF ) infoFileS( tinP ) ; ___( pInfoFileP ) ;
        {
        if( !POOP && fFound )

        }
            }
                #endif

                    }
                        }
                            }
                                break ;
                                handleP.closeIfF() ;
                                fFound = 0 ;
                                tinP.bosFail = 0 ;
                                BOSpOOP
                            {
                            default :
                            }
                                break ;
                                handleP.closeIfF() ;
                                fFound = 0 ;
                                tinP.bosFail = 0 ;
                            {
                            case ERROR_NO_MORE_FILES  :
                            case ERROR_PATH_NOT_FOUND :
                            case ERROR_FILE_NOT_FOUND :
                            }
                                //INTENTIONAL FALLTHROUGH
                                etherC::etTextIF( tinP ).traceF( tinP , T("thirdC::dosFindFileOrDirPrivateF / ERROR_SHARING_VIOLATION [postLike]: ")+T(postLike) ) ;
                                BOSpOOP
                            {
                            case ERROR_SHARING_VIOLATION :
                        {
                        switch( tinP.brcLath )
                    {
                    if( tinP.bosFail )

                    }
                        fFound = !tinP.bosFail ;
                        BOS( WHATsfr , BOSoK , FindNextFile( (HANDLE)pOsh->hFind.osF( ifcIDtYPEhANDLE_FILEfINDbASE ) , &info ) )
                    {
                    else
                    }
                        if( ~pOsh->hFind ) fFound = 1 ;
                        pOsh->hFind.osF( ifcIDtYPEhANDLE_FILEfINDbASE , (countT)tinP.brcRaw ) ;
                        BOS( WHATsfr , BOShANDLE , FindFirstFile( postLikeP , &info ) )
                    {
                    if( bWoth )
                    //CS:CODEsYNCH: DUPLICATE CODE 3600101d 35001186

                    BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                    ULONG cc = 1 ;

                #elif defined( __NT__ )

                    //U: CONJ: NEED TO CLOSE THE HANDLE IF ANOTHER FILE WAS NOT FOUND

                    fFound = cc == 1 && !tinP.brcLath ;
                    }
                        BOSpOOP
                    {
                    )
                        tinP.brcLath != ERROR_NOT_READY
                        tinP.brcLath != ERROR_PATH_NOT_FOUND          && /*CONJECTURE: THIS WILL NEVER OCCUR*/
                        tinP.brcLath != ERROR_FILE_NOT_FOUND          && /*CONJECTURE: THIS WILL NEVER OCCUR*/
                        tinP.brcLath != ERROR_NOT_DOS_DISK            && /*DON''T KNOW IF THIS OCCURS*/
                        tinP.brcLath != ERROR_FILENAME_E~CED_RANGE    && /*LONG NAME THAT IS NOT SUPPORTED ON THIS DISK*/
                        tinP.brcLath != ERROR_NO_MORE_FILES           && /*NO MORE MATCHES*/
                        tinP.bosFail                                 && /*CAUSE:*/
                    if( 

                    }
                        BOSI( WHATsfr , BOSfAIL , DosFindNext( handleP.osF( ifcIDtYPEhANDLE_FILEfIND ) , &info , sizeof info , &cc ) )
                    {
                    else
                    }
                        handleP.osF( ifcIDtYPEhANDLE_FILEfIND , (countT)osh ) ;
                        BOSI( WHATsfr , BOSfAIL , DosFindFirst( postLike , &osh , FILE_ARCHIVED | FILE_DIRECTORY | FILE_SYSTEM | FILE_HIDDEN | FILE_READONLY , &info , sizeof info , &cc, FIL_STANDARD ) )
                        ZE( HDIR , osh ) ;

                        else                                                                               handleP.osF( ifcIDtYPEhANDLE_fileFind , (countT)HDIR_CREATE ;
                        if( !c_sttinP.brcRawhrIF( tinP , postLike , '?' ) && !c_sttinP.brcRawhrIF( tinP , postLike , '*' ) ) handleP.osF( ifcIDtYPEhANDLE_FILEfIND , (countT)HDIR_SYSTEM ) ;
                    {
                    if( bWoth )
                    ULONG cc = 1 ;
                                                                                                         =
                #ifdef __OS2__
            {
            if( !POOP )
        {
        else
        }
            }
                }
                    c_strcpyIF( tinP , info.symACHnAME , ostoCloaked ) ;
                    OStEXTA( ostoCloaked , posti ) ;
                    fFound = 1 ;
                {
                if( posti )                                                                         //U:: IF THIS IS TRUE THEN REMOVE THE CODE USED HERE TO CONCATENATE
                //OStEXTAL( ostoCloaked , postLikeP , costPrefix ) ;                                //20200602@1150: COMMENTED OUT BECAUSE CONJ: info.symACHnAME SHOULD CONTAIN ONLY THE SHORT NAME
                OStEXT( ostoCloaked , 0x200 )

                countT costPrefix = postEnd - postLikeP + 1 ;
                postEnd = c_strrchrIF( tinP , postLikeP , '\\' ) ;
                ZE( osTextT* , postEnd ) ;

                posti[ costi ] = 0 ;
                countT rc = thirdC::s_readIF( tinP , posti , costi , pOsh->hSockCloak ) ;
                osTextT* posti = processGlobal3I.heap.newF( tinP , LF , costi + 1 ) ;
            {
            else
            if( !costi || costi > TUCK << 2 ) handleP.closeIfF() ;

            countT rc = thirdC::s_readIF( tinP , (byteT*)&costi , sizeof costi , pOsh->hSockCloak ) ;
            ZE( countT , costi ) ;
        {
        if( bCloaked )

        c_memsetIF( tinP , (byteT*)&info , sizeof info ) ;
        #endif
            WIN32_FIND_DATA info ;
        #elif defined( __NT__ )
            FILEFINDBUF3 info ;
        #ifdef __OS2__
        ZE( boolT , fFound ) ;

        }
            }
                thirdC::s_writeIF( tinP , pOsh->hSockCloak , postLikeP , costLike ) ;
                thirdC::s_writeIF( tinP , pOsh->hSockCloak , (byteT*)&costLike , sizeof costLike ) ;
                countT costLike = thirdC::c_strlenIF( tinP , postLikeP ) ;

                thirdC::s_writeIF( tinP , pOsh->hSockCloak , (byteT*)&idFormat , sizeof idFormat ) ;
                countT idFormat = 1 ;

                thirdC::s_writeIF( tinP , pOsh->hSockCloak , (byteT*)&finger , sizeof finger ) ;
                countT finger = FINGERnEG_CLOAKsIMPLEcONNECTION ;

                thirdC::s_writeIF( tinP , pOsh->hSockCloak , (byteT*)&idTypeConnection , sizeof idTypeConnection ) ;
                countT idTypeConnection = ifcIDtYPEcLOAKcONNECTION_SIMPLE ;

                thirdC::s_connectIF( tinP , countTC() , pOsh->hSockCloak , homeS::homeIF().idPortCloak ) ;

                thirdC::s_socketIF( tinP , pOsh->hSockCloak , ifcSOCKETtYPE_STREAM ) ;
            {
            if( bCloaked )

            }
                handleP.osF( ifcIDtYPEhANDLE_FILEfIND , (countT)pOsh ) ;
                pOsh = new( 0 , tinP , pba , cba ) diskFindHandleS( tinP ) ;
            {
            if( pba )
            byteT* pba = processGlobal3I.heap.newF( tinP , LF , cba ) ;
            countT cba = sizeof( diskFindHandleS ) ;
        {
        else
        if( ~handleP ) pOsh = (diskFindHandleS*)handleP.osF( ifcIDtYPEhANDLE_FILEfIND ) ;
        boolT bWoth = !handleP ;
        ZE( diskFindHandleS* , pOsh ) ;
        //CS:CODEsYNC: DUPLICATE CODE 3600101d 35001186

        }
            else bDebug = 1 ;
            }
                }
                    pEtherContainsMe->traceF( tinP , T(postLikeP) ) ;
                    pEtherContainsMe->traceF( tinP , T("dosFindFileOrDirPrivateF / setting bCloaked [postLikeP] (next line):") ) ;
                {
                if( pEtherContainsMe )
                bCloaked = 1 ;
                POOPRqUIET
            {
            if( POOP )

            THREADmODE1rESTORE
            thirdC::dosFindFileOrDirSimpleIF( tinP , postf , sizeof postf , hFind , postLikeP , flDOSfINDfILEoRdIR_DOnOTtESTwATER ) ;
            THREADmODE1oN( flTHREADmODE1_QUIETiMPOTENCE ) ;

            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            postf[ 0 ] = 0 ;
            osTextT postf[ TUCK << 1 ] ;

            SCOOP
            poopC poop ;
        {
        //CS:CODEsYNC: PSEUDODUPLICATE CODE 3600101d 35001186

        __Z( cMax ) ;
        countT cMax = dosQuerySysInfoMaxPathLengthIF( tinP ) ;
        }
            __( !(( ostDisk >= 'a' && ostDisk <= 'z' )||( ostDisk >= 'A' && ostDisk <= 'Z' )) ) ;
            if( !POOP ) ostDisk = *postLike ;
            ZE( osTextT , ostDisk ) ;
        {
        if( !bNetBios )

        const boolT bNetBios = postLike[ 0 ] == '\\' && postLike[ 1 ] == '\\' ;

        if( postLike ) postLike[ costCopy ] = 0 ;
        c_memcpyIF( tinP , postLike , postLikeP , costCopy ) ;
        newF( tinP , LF , postLike , costCopy + 1 ) ; ___( postLike ) ;
        countT costCopy = costLikeP - ( postLikeP[ costLikeP - 1 ] == '\\' ) ;
        const countT costLikeP = postLikeP ? c_strlenIF( tinP , postLikeP ) : 0 ;
        ZE( osTextT* , postLike ) ;                                                 // REMOVED TRAILING '\\' FOR DIRECTORY NAME
    {
    ZE( boolT , bDebug ) ;
    ZE( boolT , bCloaked ) ;

    _IO_

    }
        if( POOP ) return 0 ;
        #endif
            __( sizeof( countT ) != sizeof( HANDLE ) || fnu ) ;
        #elif defined( __NT__ )
        __( sizeof( countT ) != sizeof( HDIR ) || fnu ) ;
        #ifdef __OS2__
        ZE( boolT , fnu ) ;
        __NZ( pInfoFileP ) ;
        __( !postLikeP[ 3 ] ) ;
        if( POOP ) return 0 ;
        __( !postLikeP[ 2 ] ) ;
        if( POOP ) return 0 ;
        }
            __( postLikeP[ 1 ] - ':' ) ;
        {
        if( postLikeP[ 1 ] != '\\' )            //20190826@0902: ACCOMMODATE NETBIOS FILE NAMES OF THE FORM "\\netbiosname\disk\path\short"
        if( POOP ) return 0 ;
        __( !postLikeP[ 0 ] ) ;
        if( POOP ) return 0 ;
        __Z( postLikeP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL    
    SCOOP


    }
        countT foo = 2 ;
    {
    if( postLikeP[ 0 ] == '\\' && postLikeP[ 1 ] == '\\' )



//}
//    countT foo = 2 ;
//{
//if( tinP.pc Utility[ 0 ] && c_strstrIF( tinP , postLikeP , "\\exedll\\1" ) )
//U:: TO FIND A BUG



{
/*1*/boolT thirdC::dosFindFileOrDirPrivateF( tinS& tinP , infoFileS*& pInfoFileP , handleC& handleP , const osTextT* const postLikeP )/*1*/

#endif
    #define symACHnAMEaLT      cAlternateFileName
    #define symACHnAME         cFileName
#elif defined( __NT__ )
    #define symACHnAMEaLT      replaceThisWithName
    #define symACHnAME         achName
#ifdef __OS2__

// CONJ: O.S. WILL SUPPORT SEARCHES FOR ROOT DIRECTORIES
//U: ENHANCE TO ALLOW "?:\\" TO RESULT IN FINDING A ROOT DIRECTORY

/**/

*/
    for Windows: "\\myDir\\myFile.foo*"
   examples
  can contain wildcard strokes ('*' and '?')
   the result is a dir iff F(pInfoFileP->flags) & flFILEaTTR_DIRECTORY
   i cannot be told to just find files, or to just find directories
   my search will find both files and directories
  a terminating '\' character is ignored if present
  must point to a fully qualified file name, in native operating system form
  can contain the wildcard strokes '*' and '?'
  exception: cannot be a root directory, e.g. "?:\"
  can be a directory name (terminating '\' stroke is present)
  can be a file name (no terminating '\' stroke)
  must not be 0
 postLikeP
  call this function repeatedly until handleP is set, by it, to 0
  must be 0 on first call
 handleP
 pInfoFileP
arguments
 failure to do this causes a resource leak
 applications -must- call this function repeatedly until handleP is ze
 as long as handleP is nonze, more matching files exist
this function -must- be called repeatedly until handleP is ze
this function finds a single file whose name matches postLikeP
\<A HREF=\"5.102001e.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosFindFileOrDirPrivateF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

