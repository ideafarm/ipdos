
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.delF( tinP , postTagPoolWork ) ;
etThread.delF( tinP , postTagPoolRoot ) ;
etThread.delF( tinP , postTagSearchFor2 ) ;
etThread.delF( tinP , postTagSearchFor1 ) ;
*postTagSearchFor2 = *postTagSearchFor1 = *postTagPoolRoot = *postTagPoolWork = '.' ;
}
    while( !stRange.third && ~hDown ) ;
    }
        }
            //}
            //    etThread.delF( tinP , postd ) ;
            //    etThread.boxPutF( tinP , T("///" ifcSCRATCH "/tmp.dump.form.")+TF1(idRange) , postd , costd ) ;
            //    etThread.delF( tinP , psttd ) ;
            //    countT costd = etThread.strMakeF( tinP , LF , postd , psttd ) ; ___( postd ) ;
            //    ZE( osTextT* , postd ) ;
            //    etThread.strDumpIF( tinP , psttd , postc , poste - postc , 0x40 , 4 , ' ' , 0 ) ; ___( psttd ) ;
            //    ZE( strokeS* , psttd ) ;
            //
            //    etThread.boxPutF( tinP , T("///" ifcSCRATCH "/tmp.dump.unfo.")+TF1(idRange) , postc , poste - postc ) ;
            //
            //    if( poste - postc > TOCK * 0x10 ) poste = postc + TOCK * 0x10 ;
            //    osTextT* poste = (osTextT*)minMax.c2 + 1 ;
            //    osTextT* postc = (osTextT*)minMax.c1 ;
            //{
            //if( !postc )
    
            etThread.strokeF( tinP , T(postc ? postc : "no tag" )+T("\r\n") ) ;
    
            if( postc == poste ) postc = 0 ;
            while( postc < poste ) ;
            }
                }
                    }
                        break ;
                        etThread.strokeF( tinP , T("tag found at offset ")+TF1((countT)postc-minMax.c1)+T("  ") ) ;
                        postc += costTagSearchFor2 ;
                    {
                    if( !thThread.c_memcmpIF( tinP , postc , postTagSearchFor2  , costTagSearchFor2 ) )
                    postc += costTagSearchFor1 ;
                {
                if( postc < poste )
                postc = thThread.c_memmemIF( tinP , postc , poste - postc , postTagSearchFor1  , costTagSearchFor1 ) ;
            {
            do
        {
        else
        if( postc[ 0 ] == 'M' && postc[ 1 ] == 'Z' ) etThread.strokeF( tinP , T("dll or exe image\r\n") ) ;

        if( poste - postc > TOCK * 0x10 ) poste = postc + TOCK * 0x10 ;
        osTextT* poste = (osTextT*)minMax.c2 + 1 ;
        osTextT* postc = (osTextT*)minMax.c1 ;

        etThread.strokeF( tinP , TF3(idRange,flFORMAT_UNSIGNED,3)+T("[")+TF3(minMax.c1,flFORMAT_FILLzE,8)+T(",")+TF3(minMax.c2,flFORMAT_FILLzE,8)+T("] ") ) ;

        //if( idRange != 2 && idRange != 0x1c ) continue ;
        count2S& minMax = *(count2S*)&stRange.downF( tinP , hDown ) ;
        ++ idRange ;
    {
    do
    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
{
if( stRange )
ZE( countT , idRange ) ;
etherC::rangerF( tinP , stRange , ether ) ;
stackC stRange( tinP , etThread , TAG( 0 ) , flSTACKc_FIFO|flSTACKc_BLOB , sizeof( count2S ) ) ;

thirdC& thThread = etThread ;

etThread.strMakeF( tinP , LF , postTagPoolWork , tTag1+tTag2+T("poolC.")+T(poolOld.postName) ) ; ___( postTagPoolWork ) ;
ZE( osTextT* , postTagPoolWork ) ;

etThread.strMakeF( tinP , LF , postTagPoolRoot , tTag1+tTag2+T("poolC.")+T(poolOldRoot.postName) ) ; ___( postTagPoolRoot ) ;
ZE( osTextT* , postTagPoolRoot ) ;

countT costTagSearchFor2 = etThread.strMakeF( tinP , LF , postTagSearchFor2 , tTag2 ) ; ___( postTagSearchFor2 ) ;
ZE( osTextT* , postTagSearchFor2 ) ;

countT costTagSearchFor1 = etThread.strMakeF( tinP , LF , postTagSearchFor1 , tTag1 ) ; ___( postTagSearchFor1 ) ;
ZE( osTextT* , postTagSearchFor1 ) ;

TN( tTag2 , "RangerTag:") ;
TN( tTag1 , "!ifc" ) ;

rTagF() ;
//byteT* pbFoo = pbPoolPrimeGF_() ;

CONoUTrAW3( "after TODO, eip is " , eip , "\r\n" ) ;
eipF( &eip ) ;
ZE( countT , eip ) ;

TODO

/*1*/WAKEhIDE( "tool.mapper" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

