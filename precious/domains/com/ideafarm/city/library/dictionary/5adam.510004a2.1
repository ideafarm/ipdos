
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
}
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ; //U::
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_DISABLE ) ; //U::
    }
        OStEXTAK( napHomeJot  , "cell monitor: bequesting state" ) ;
        cellC::classShutdown2F( tinP ) ;
        sgnDone_tmInspect.waitF( tinP ) ;
        cellC::classShutdown1F( tinP , state.idCellLath , state.serialLath ) ;
        cellC::classFireAllF( tinP ) ;
        OStEXTAK( napHomeJot  , "cell monitor: cleaning up" ) ;
        etThread.loafIF( tinP ) ;
        OStEXTAK( napHomeJot  , "cell monitor: watching" ) ;

        if( !ether ) NEWcELL( etThread , ifcIDaDAMoLD_VIEWjOT , 0 )
        ether.osSleepF( tinP , TOCK * 0x8 ) ; //U::
        if( !ether ) NEWcELL( etThread , ifcIDaDAMoLD_LOGIN , 0 )
        ether.osSleepF( tinP , TOCK * 0x8 ) ; //U::
        if( !ether ) etThread.ifcChatF( tinP , 0 , DDNUMB , jobFillCourseF , jobHearOrderF ) ;
        if( !ether ) NEWcELL( etThread , ifcIDaDAMoLD_CHATsERVER , T("") )
        //etThread.osThreadF( tinP , countTC() , tmInspectPoolsF ) ;
        //etThread.osThreadF( tinP , countTC() , tmInspectF , &sgnDone_tmInspect ) ;
        //etThread.osThreadF( tinP , countTC() , tmFireMyselfF ) ;
        cellC::classSetupF( tinP , state.idCellLath , state.serialLath , 1 , windowTitle ) ;
        signC sgnDone_tmInspect( tinP , TAG( TAGiDnULL ) ) ;
        OStEXTAK( napHomeJot  , "cell monitor: setting up" ) ;
    
        stateS state( tinP , etThread , T("monitored") ) ;
        OStEXTAK( napHomeJot  , "cell monitor: inheriting state" ) ;
    {
    else
    }
        OStEXTAK( napHomeJot  , "base cell monitor: state has been bequested" ) ;
        }
            OStEXTAK( napHomeJot  , "base cell monitor: bequesting state" ) ;
            cellC::classShutdown2F( tinP ) ;
            sgnDone_tmInspect.waitF( tinP ) ;
            cellC::classShutdown1F( tinP , state.idCellLath , state.serialLath ) ;
            cellC::classFireAllF( tinP ) ;
            OStEXTAK( napHomeJot  , "base cell monitor: cleaning up" ) ;
            etThread.loafIF( tinP ) ;

            OStEXTAK( napHomeJot  , "base cell monitor: watching" ) ;
            NEWcELL( etThread , DDNUMB , TaRG1_OSmONITOR+T(".monitored !postHandoffOld monitored") )
            __( DDNUMB - countTC( ifcIDaDAM_KERNEL2MONITOR ) ) ;
            //etThread.osThreadF( tinP , countTC() , tmInspectF , &sgnDone_tmInspect ) ;
            //etThread.osThreadF( tinP , countTC() , tmFireMyselfF ) ;
            cellC::classSetupF( tinP , state.idCellLath , state.serialLath , 1 , windowTitle ) ;
            signC sgnDone_tmInspect( tinP , TAG( TAGiDnULL ) ) ;
            OStEXTAK( napHomeJot  , "base cell monitor: setting up" ) ;
        {
        stateS state( tinP , etThread ) ;
        OStEXTAK( napHomeJot  , "base cell monitor: inheriting state" ) ;
    {
    else if( thirdC::ifcCellIsWorkingIF( tinP , DDNUMB ) )
    if( etThread ) ;

    //ether.osThreadF( tinP , countTC() , tmDeadLockF , 0 , flTHREADlAUNCH_null , 0 , (countT)&grab1 , (countT)&grab2 , 2 ) ;
    //ether.osThreadF( tinP , countTC() , tmDeadLockF , 0 , flTHREADlAUNCH_null , 0 , (countT)&grab1 , (countT)&grab2 , 1 ) ;
    //grabOldS grab2( tinP , TAG( TAGiDnULL ) ) ;
    //grabOldS grab1( tinP , TAG( TAGiDnULL ) ) ;

    windowTitleS windowTitle( tinP , etThread ) ;
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_ENABLE ) ; //U::
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , 8 ) ; //U::
    
    }
        napHomeJot.formattingIsDoneF( tinP ) ;
        if( !etThread ) *napHomeJot = 0 ;
    {
    if( !( F(napHomeJot.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
    __( !(byteT*)napHomeJot ) ;
    __( (countT)napHomeJot - CBnAPjOT ) ;
    napkinC napHomeJot( tinP , LF , (byteT*)bits , "napHomeJot" , 0 , CBnAPjOT ) ;
    bitsC bits( tinP , CbITSlIFI , 0 , 1 ) ;

    __( !etThread.strIdF( tinP , TF1(DDNUMB) , T(poolC::poolOldWorkIF(tinP).postName) ) ) ;
    __( !( F(poolC::poolOldRootIF(tinP).flags) & flPOOLoLDc_NOcLIENTrIGHTS ) ) ;
{
TODO

//---- a: MAIN THREAD --------------------------------------------------------------------------------------------------------------

}
    return sgn ;
    if( tinP.fingerprint && c3P ) ;

    }
        else if( pc4v1->c1 < pc4v2->c1 ) sgn = - 1 ;
             if( pc4v1->c1 > pc4v2->c1 ) sgn =   1 ;
    {
    if( pc4v1 && pc4v2 )
    ZE( sCountT , sgn ) ;

    count4S* pc4v2 = (count4S*)c2P ;
    count4S* pc4v1 = (count4S*)c1P ;

    }
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )

    }
    {
    IFbEcAREFUL
{
countT subtract_count4S_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return sgn ;
    if( tinP.fingerprint && c3P ) ;

    }
        else if( pTinc1->osTid < pTinc2->osTid ) sgn = - 1 ;
             if( pTinc1->osTid > pTinc2->osTid ) sgn =   1 ;
    {
    if( pTinc1 && pTinc2 )
    ZE( sCountT , sgn ) ;

    tinC* pTinc2 = (tinC*)c2P ;
    tinC* pTinc1 = (tinC*)c1P ;

    }
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )

    }
    {
    IFbEcAREFUL
{
countT subtract_tinC_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return sgn ;
    if( tinP.fingerprint && c3P ) ;

    }
        else if( pProcess1->osPid < pProcess2->osPid ) sgn = - 1 ;
             if( pProcess1->osPid > pProcess2->osPid ) sgn =   1 ;
    {
    if( pProcess1 && pProcess2 )
    ZE( sCountT , sgn ) ;

    processC* pProcess2 = (processC*)c2P ;
    processC* pProcess1 = (processC*)c1P ;

    }
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )

    }
    {
    IFbEcAREFUL
{
countT subtract_processC_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return sgn ;
    if( tinP.fingerprint && c3P ) ;

    }
        else if( pCell1->idCell < pCell2->idCell ) sgn = - 1 ;
             if( pCell1->idCell > pCell2->idCell ) sgn =   1 ;
    {
    if( pCell1 && pCell2 )
    ZE( sCountT , sgn ) ;

    cellC* pCell2 = (cellC*)c2P ;
    cellC* pCell1 = (cellC*)c1P ;

    }
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )

    }
    {
    IFbEcAREFUL
{
countT subtract_cellC_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return 0 ;
    THREADmODE1rESTORE
    }
        else                                       cell.fifoEvent << (countT)pEvent ;
        else if( cell.fifoEvent.bLockedF( tinP ) ) { DEL( pEvent ) ; }
        if( !pEvent ) ;
    
        __Z( pEvent ) ;
        eventC* pEvent = new( 0 , tinP , LF ) eventC( tinP , cell , pbP , cbP ) ; ___( pEvent ) ;
    
        //cellC::pWindowTitle->writeF( tinP ) ; //INFO MIGHT BE INCONSISTENT; NO SERIALIZATION IS DONE BECAUSE WE DON'T WANT DEADLOCKING POTENTIAL
        inc02AM( cellC::pWindowTitle->cEvents ) ;
        inc02AM( cellC::pWindowTitle->cEventsPending ) ;
        cellC& cell = *cellC::pCellSelf ;
    
        if( cP ) ;
    {
    THREADmODE1oN( flTHREADmODE1_DISALLOWtELLmONITOR )
{
boolT monitoredEventHandlerF( tinS& tinP , const byteT* const pbP , const countT cbP , countT cP )

//---- 9: GLOBAL FUNCTION DEFINITIONS : OTHER --------------------------------------------------------------------------------------------------


}
    if( cArgP && c8argP.c1 && sOrderP && ether && idChatSessionP ) ;

    __( idAdamP - DDNUMB ) ;
{
voidT jobHearOrderF( tinS& tinP , etherC& ether , etherC& etThread , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

}
    if( ether && cArgP && c8argP.c1 && sDataP && sNotesTextP && sNotesDataP && idChatSessionP ) ;

    }
        }
            __1
            __( idCmd ) ;
        {
        default :
        }
            break ;

            }
                }
                    break ;
                    sDataP << cellC::classQuery_cHandle_F( tinP ) ;
                {
                case 1 :
            {
            switch( idCourseP )
        {
        case ifcIDcMDjOBoRDER_QUERYchANDLES :
        }
            break ;

            }
                }
                    break ;

                    tinP.zEtScratch->delF( tinP , psttArgs ) ;
                    tinP.zEtScratch->osThreadF( tinP , countTC() , tmNewCellF , 0 , flTHREADlAUNCH_null , 0 , idAdam , (countT)pstta ) ;
                    strokeS* pstta = (strokeS*)psttOldC( tinP , *tinP.zEtScratch , (psttArgs?T(psttArgs):T("")) ) ; ___( pstta ) ;
        
                    sOrderP >> (countT&)time2Limit ;
                    ZE( sCountT , time2Limit ) ;
        
                    sOrderP >> time1Limit ;
                    ZE( countT , time1Limit ) ; //U: CONJ: THESE ARE NOT USED AND SHOULD BE ELIMINATED OR FULLY SUPPORTED (SEE EVENT LOOP SUPPORT FOR TIMEOUTS)
        
                    sOrderP >> flags ;
                    ZE( countT , flags ) ;
        
                    sOrderP >> psttArgs ; ___( psttArgs ) ;
                    ZE( strokeS* , psttArgs ) ;
        
                    __Z( idAdam ) ;
                    sOrderP >> idAdam ;
                    ZE( countT , idAdam ) ;
        
                    __( idCmd2 - idCmd ) ;
                    sOrderP >> idCmd2 ;
                    ZE( countT , idCmd2 ) ;
                {
                case 1 :
            {
            switch( idCourseP )
        {
        case ifcIDcMDjOBoRDER_CONSTRUCTlOCALcELL :
    {
    switch( idCmd )

    countT idCmd = sOrderP.cFieldF( tinP ) ;

    __( idAdamP - DDNUMB ) ;
{
voidT jobFillCourseF( tinS& tinP , etherC& ether , etherC& etThread , soulC& sDataP , soulC& sNotesTextP , soulC& sNotesDataP , const countT idCourseP , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

//---- 8: GLOBAL FUNCTION DEFINITIONS : CHAT --------------------------------------------------------------------------------------------------

DONE( tmNewCellF )
}
    etThread.delF( tinP , psttArgs ) ;
    NEWcELL( etThread , pTaskP->c1 , psttArgs )
    strokeS* psttArgs = (strokeS*)pTaskP->c2 ;
    countT   idAdam   =           pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmNewCellF ) //U::THIS THREAD WILL NOT END UNTIL THE CELL'S THREADS HAVE ENDED; FIND A WAY TO ELIMINATE THIS OVERHEAD

DONE( tmInspectF )
THREADmODE1rESTORE
}
    OSsLEEPf( 0x400 * 0x40 ) ;

    //U::}
    //U::    ++ s ; ether.osSleepF( tinP , TOCK * 0x10 ) ;
    //U::    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    //U::{
    cellC::classInspectF( tinP , stCellCopy , ether , st_pGrabP , stOsTidAllWanterP , stOsTidWanterP , stOsTidWanterInLoop , stOsTidWanterInLoopUnique , stThreads , c3lifi , swGrabTally ) ;
{
while( !etThread && cellC::classIdPhaseF( tinP ) < 3 )
THREADmODE1oN( flTHREADmODE1_DISALLOWtELLmONITOR )
switchC swGrabTally(              tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , pczLever ) ;
countT* pczLever = c3lifi ;
count3S c3lifi ;
stackC stThreads(                 tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( count4S ) ) ;
stackC stOsTidWanterInLoopUnique( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( count5S ) ) ;
stackC stOsTidWanterInLoop(       tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( count5S ) ) ;
stackC stOsTidWanterP(            tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( count5S ) ) ;
stackC stOsTidAllWanterP(         tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( count5S ) ) ;
stackC st_pGrabP(                 tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;
stackC stCellCopy(                tinP , etThread , TAG( TAGiDnULL ) ) ;
//etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIEST ) ;
TASK( tmInspectF )

DONE( tmInspectPoolsF )
}
    }
        ++ s ; ether.osSleepF( tinP , TICK * 0x1 ) ; // HOURLY
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {

    }
        LEAKiNSPECTOR( etThread )
        inc02AM( bInspector ) ;

        }
            ++ s ; ether.osSleepF( tinP , TOCK * 0x10 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
    {
    if( !bInspector )
{
while( !ether && !etThread && cellC::classIdPhaseF( tinP ) < 3 ) 
}
    ++ s ; ether.osSleepF( tinP , TOCK * 8 ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{
TASK( tmInspectPoolsF )

DONE( tmFireMyselfF )
CONoUT( "\r\ntmFireMyself: fired myself\r\n" )
etThread.etherFireImpersonateMonitorIF( tinP ) ;
CONoUT( "\r\ntmFireMyself: firing myself\r\n" )
cellC::classLogF( tinP , T("firing myself!") ) ;
}
    ++ s ; ether.osSleepF( tinP , time1fire ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{
CONoUT( "\r\ntmFireMyself: going to seleep\r\n" )
cellC::classLogF( tinP , T("time1fire: ")+TF1(time1fire) ) ;
countT time1fire = bias + ru ;
ranUniC ru( TOCK * 0x20 , 0 ) ; countT bias = TOCK * 0x0 ;
TASK( tmFireMyselfF )

DONE( tmFireCellF )
}
    cFirePending -- ;
    }
        cell.unrefF() ;
        cell.fireF( tinP ) ;
    {
    cellC&  cell         =  *(cellC*)pTaskP->c2 ;
    countT& cFirePending = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmFireCellF )

DONE( tmDeadLockF )
}
    }
        ungrabF( tinP , grab2 ) ;
        ungrabF( tinP , grab1 ) ;

        }
            ++ s ; ether.osSleepF( tinP , TOCK ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {

        }
            grabF( tinP , grab1 ) ;
            }
                ++ s ; ether.osSleepF( tinP , TOCK ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            grabF( tinP , grab2 ) ;
        {
        else
        }
            grabF( tinP , grab2 ) ;
            }
                ++ s ; ether.osSleepF( tinP , TOCK ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            grabF( tinP , grab1 ) ;
        {
        if( idDead == 1 )
    {
    while( !ether && !etThread )

    countT idDead = pTaskP->c3 ;
    grabOldS& grab2 = *(grabOldS*)pTaskP->c2 ;
    grabOldS& grab1 = *(grabOldS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmDeadLockF )

//---- 7: GLOBAL FUNCTION DEFINITIONS : THREAD MAIN --------------------------------------------------------------------------------------------------

}
    ether.winSetTitleF( tinP , TF1(cEvents)+T(" ")+TF1(cEventsPending) ) ;
{
voidT windowTitleS::writeF( tinS& tinP )

}
    if( tinP.fingerprint ) ;
{
cEvents( 0 )
cEventsPending( 0 ) ,
ether( etherP ) ,
windowTitleS::windowTitleS( tinS& tinP , etherC& etherP ) :

}
    }
        if( !bOk ) ether.delF( tinP , pbTin ) ;

        else if( getNegAM( tin.fingerprint ) != FINGERnEG_TINs || tin.idTin != idTin ) bOk = 0 ;
        if( !bOk ) ;
        tinS& tin = *(tinS*)pbTin ;

        else        thirdC::dosReadProcessMemoryIF( tinP , pbTin , sizeof( tinS ) , bOk , pvOrIda , osPid ) ;
        if( bSelf ) ether.memCopyF( tinP , pbTin , (const byteT*)pvOrIda , sizeof( tinS ) ) , bOk = 1 ;
        ZE( boolT , bOk ) ;
        if( !pbTin ) { ether.newF( tinP , LF , pbTin , sizeof( tinS ) ) ; ___( pbTin ) ; }
        SLEEPwHILE( cRef_pbTin )
    {
    if( bCopy_pbTin )
    _IO_
{
voidT tinC::freshIfF( tinS& tinP )

}
    return bIs ;
    boolT bIs = !thirdC::c_strcmpIF( tinP , postThreadNameP , postThreadName ) ;
    _IO_
{
boolT tinC::bIsF( tinS& tinP , const osTextT* const postThreadNameP )

}
    }
        if( info.ip ) ;
        thirdC::c_strncpyIF( tinP , postThreadName , info.postThreadName , sizeof postThreadName ) ;
        idThread = info.idThread ;
        idTin = info.idTin ;    
        tellInfoTinS& info = *(tellInfoTinS*)saidP.pbData ;
    {
    if( !ether )

    }
        __( pInfoP->osPid - osPid ) ;
        __( pInfoP->osTid - osTid ) ;
    {
    if( pInfoP )
    __( saidP.cbData - sizeof( tellInfoTinS ) ) ;
    __( !pbTin && saidP.idType - ifcIDtYPEtELL_TINcTP ) ;

    _IO_
{
idThread( 0 )
idTin( 0 ) ,
osPid( saidP.osPid ) ,
osTid( saidP.osTid ) ,
cRef_pbTin( 0 ) ,
bCopy_pbTin( !pbTin ) ,
pbTin( pvOrIda && saidP.idType == ifcIDtYPEtELL_TINcTI ? (byteT*)ap_artmentOldC( tinP , (countT)pvOrIda ) : 0 ) ,
pvOrIda( saidP.pbData && saidP.cbData == sizeof( tellInfoTinS ) ? ((tellInfoTinS*)saidP.pbData)->ip : 0 ) ,
ether( tinP , TAG( TAGiDnULL ) , *tinP.pAdamGlobal1->pPoolAdamTemp ) ,
bSelf( !pInfoP ) ,
tinC::tinC( tinS& tinP , saidS& saidP , const ifcMonitorEventS* pInfoP ) :

}
    if( bCopy_pbTin ) ether.delF( tinP , pbTin ) ;
    SLEEPwHILE( cRef_pbTin )
    _IO_
    TINSL
{
tinC::~tinC( voidT )

NEWdELcLASSb( tinC )

}
    }
        __( !bText == !idType ) ;
        }
            }
                __Z( bOk ) ;
                Wo third.dosReadProcessMemoryIF( tinP , (byteT*&)pbData , cbData , bOk , infoP.osSay_post + ( bText ? 0 : sizeof( tellS ) ) , infoP.osPid ) ; Wi
                ZE( boolT , bOk ) ;
            {
            if( pbData )
            etherP.newF( tinP , LF , (byteT*&)pbData , cbData ) ; ___( (byteT*&)pbData ) ;
        {
        if( cbData )
    
        }
            }
                (countT&)cbData = head.cbData ;
                (countT&)idType = head.idType ;
                (countT&)osPid  = head.osPid ;
                (countT&)osTid  = head.osTid ;
            {
            if( !etherP )
    
            __( getNegAM( head.finger1 ) - ( FINGERnEG_TELEMETRY1 & 0xffffff00 ) ) ; //ASSUME HARDWARE: countT IS 4 BYTES
            __Z( bOk ) ;
            Wo third.dosReadProcessMemoryIF( tinP , (byteT*)&head , sizeof head , bOk , infoP.osSay_post , infoP.osPid ) ; Wi
            ZE( boolT , bOk ) ;
    
            struct tellS head ;
        {
        else
        }
            (countT&)cbData = infoP.osSay_cost ;
            bText = 1 ;
        {
        if( infoP.osSay_cost > 1 ) //ASSUME: OS WILL NEVER EMIT A NULL LENGTH STRING; NOTE: osSay_cost INCLUDES NULL TERMINATOR
        ZE( boolT  , bText  ) ;
        thirdC& third = etherP ;
    {
    if( infoP.idEvent == ifcIDeVENTmONITORED_SAY )
{
pbData( 0 )
cbData( 0 ) ,
idType( 0 ) ,
flags( 0 ) ,
osPid( 0 ) ,
osTid( 0 ) ,
saidS::saidS( tinS& tinP , etherC& etherP , const ifcMonitorEventS& infoP ) :

}
    }
        etherP.memCopyF( tinP , (byteT*&)pbData , pbP + sizeof( tellS ) , cbData ) ;
        etherP.newF( tinP , LF , (byteT*&)pbData , cbData ) ; ___( (byteT*&)pbData ) ;
    {
    if( cbData )

    __( cbP - sizeof head - cbData ) ;
    }
        (countT&)cbData = head.cbData ;
        (countT&)idType = head.idType ;
        (countT&)osPid  = head.osPid ;
        (countT&)osTid  = head.osTid ;
    {
    if( !etherP )

    __( getNegAM( head.finger1 ) - ( FINGERnEG_TELEMETRY1 & 0xffffff00 ) ) ; //ASSUME HARDWARE: countT IS 4 BYTES
    tellS& head = *(tellS*)pbP ;
{
pbData( 0 )
cbData( 0 ) ,
idType( 0 ) ,
flags( 0 ) ,
osPid( 0 ) ,
osTid( 0 ) ,
saidS::saidS( tinS& tinP , etherC& etherP , const byteT* const pbP , const countT cbP ) :

}
    PUSE( tinP , pbData ) ;
    TINSL
{
saidS::~saidS( voidT )

}
    return cP == osPid ;
{
boolT processC::operator ==( const cP ) const

}
    if( tinP.fingerprint ) ;
{
osPid( infoP.osPid )
osTid( infoP.osTid ) ,
ether( tinP , TAG( TAGiDnULL ) , *tinP.pAdamGlobal1->pPoolAdamTemp ) ,
processC::processC( tinS& tinP , const ifcMonitorEventS& infoP ) :

NEWdELcLASSb( processC )

}
    return *this ;
    if( offGetNext == FIFOcAPACITY ) offGetNext = 0 ;
    cP = pcStore[ offGetNext ++ ] ;
    dec02AM( cHave ) ;

    }
        while( !cHave ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        TINSL
    {
{
fifoC& fifoC::operator >>( countT& cP )

}
    return *this ;
    if( offPutNext == FIFOcAPACITY ) offPutNext = 0 ;
    inc02AM( cHave ) ;
    pcStore[ offPutNext ++ ] = cP ;

    }
        while( cHave == FIFOcAPACITY ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        TINSL
    {

    else if( !cP ) bLocked = 1 ;
    if( bLocked ) { BLAMMO ; }
{
fifoC& fifoC::operator <<( countT cP )

}
    return bLocked ;
    if( tinP.fingerprint ) ;
{
boolT fifoC::bLockedF( tinS& tinP ) const

}
    return cHave ;
{
fifoC::operator countT( voidT )

}
    if( tinP.fingerprint ) ;
{
bLocked( 0 )
cHave( 0 ) ,
offGetNext( 0 ) ,
offPutNext( 0 ) ,
fifoC::fifoC( tinS& tinP ) :

}
    }
        }
            break ;

            cellC::pBaton_lSerial->ungrabF( tinP ) ;
            }
                if( !*cellC::pSwsGrabInfo ) cellC::pSwsGrabInfo->freeF( tinP ) ;
                else                                                                      __1
                if( (*cellC::pSwsGrabInfo)( (byteT*)&info2 , 0 , subtract_grabInfoS_F ) ) cellC::pSwsGrabInfo->extractF( 0 , tinP ) ;
            {
            else
            }
                THREADmODE1rESTORE
                cellC::pSwsGrabInfo->sinkF( tinP , ids , (byteT*)&info2 , flSTACKsINK_UNIQUE , 0 , subtract_grabInfoS_F ) ;
                THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
                ZE( countT , ids ) ;
            {
            if( bCA )
            cellC::lSerial = info.serial ;
            cellC::pBaton_lSerial->grabF( tinP , TAG( TAGiDnULL ) ) ;
            cellC::cAboutToGrab_lSerial ++ ;

            }
                case ifcIDtYPEtELL_GRABdEP : { info2.flags = flGRABiNFOs_null                   ;           break ; }
                case ifcIDtYPEtELL_GRABdEI : { info2.flags =                    flGRABiNFOs_IDA ;           break ; }
                case ifcIDtYPEtELL_GRABdTP : { info2.flags = flGRABiNFOs_CT                     ;           break ; }
                case ifcIDtYPEtELL_GRABdTI : { info2.flags = flGRABiNFOs_CT   | flGRABiNFOs_IDA ;           break ; }
                case ifcIDtYPEtELL_GRABaTP : { info2.flags = flGRABiNFOs_null                   ; bCA = 1 ; break ; }
                case ifcIDtYPEtELL_GRABaTI : { info2.flags =                    flGRABiNFOs_IDA ; bCA = 1 ; break ; }
                case ifcIDtYPEtELL_GRABcTP : { info2.flags = flGRABiNFOs_CT                     ; bCA = 1 ; break ; }
                case ifcIDtYPEtELL_GRABcTI : { info2.flags = flGRABiNFOs_CT   | flGRABiNFOs_IDA ; bCA = 1 ; break ; }
            {
            switch( said.idType )
            ZE( boolT , bCA ) ;

            info2.idiFileCt = info.idiFileCt ;
            info2.idLineCt  = info.idLineCt ;
            info2.ip        = info.ip ;
            info2.osPid     = said.osPid ;
            grabInfoS info2 ;

            __( !info.idiFileCt ) ;
            __( !info.idLineCt ) ;
            __( !info.ip ) ;
            __( !info.serial ) ;
            tellInfoGrabS& info = *(tellInfoGrabS*)said.pbData ;
            __( said.cbData - sizeof( tellInfoGrabS ) ) ;
            TELL( "hearF: GRABcTI" )
        {
        case ifcIDtYPEtELL_GRABdEP :
        case ifcIDtYPEtELL_GRABdEI :
        case ifcIDtYPEtELL_GRABdTP :
        case ifcIDtYPEtELL_GRABdTI :
        case ifcIDtYPEtELL_GRABaTP :
        case ifcIDtYPEtELL_GRABaTI :
        case ifcIDtYPEtELL_GRABcTP :
        case ifcIDtYPEtELL_GRABcTI :
        }
            break ;

            }
                __Z( bOk ) ;
                thirdC::dosWriteProcessMemoryIF( tinP , bOk , (voidT*)ip , said.osPid , (byteT*)pReply , sizeof( monQueryReplyS ) ) ;
                ZE( boolT , bOk ) ;
            {
            if( said.idType == ifcIDtYPEtELL_QUERYP )

            pReply->flags |= flMONqUERYrEPLY_READY ;
            }
                }
                    __1
                    __( pReply->idTypeQuery ) ;
                {
                default :
                }
                    break ;
                    }
                        THREADmODE1rESTORE
                        cellC::classSerialNumberF( tinP , snWoth , snLath , *(countT*)pReply->pbReply ) ;
                        THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
                        countT& snLath = ((countT*)pReply->pbReply)[ 1 ] ;
                        countT& snWoth = ((countT*)pReply->pbReply)[ 0 ] ;
                        pReply->cbReply = 2 * sizeof( countT ) ;
                    {
                    if( pReply->cbReply >= 2 * sizeof( countT ) && pReply->cbParam == sizeof( countT ) )
                {
                case ifcIDtYPEqUERY_SNuNIQUEaLLcELLStHISmONITORmULTIPLE :
                }
                    break ;
                    }
                        THREADmODE1rESTORE
                        *(countT*)pReply->pbReply = cellC::classSerialNumberF( tinP ) ;
                        THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
                        pReply->cbReply = sizeof( countT ) ;
                    {
                    if( pReply->cbReply >= sizeof( countT ) )
                {
                case ifcIDtYPEqUERY_SNuNIQUEaLLcELLStHISmONITOR :
            {
            switch( pReply->idTypeQuery )
            pReply->flags &= ~( F(flMONqUERYrEPLY_VIRGIN) ) ;
            __( !!( F(pReply->flags) & flMONqUERYrEPLY_READY ) ) ;
            __( !( F(pReply->flags) & flMONqUERYrEPLY_VIRGIN ) ) ;

            }
                __Z( bOk ) ;
                thirdC::dosReadProcessMemoryIF( tinP , (byteT*)pReply , sizeof( monQueryReplyS )  , bOk , (voidT*)ip , said.osPid ) ;
                ZE( boolT , bOk ) ;
                pReply = (monQueryReplyS*)pbInvisible ;
            {
            else
            if( said.idType == ifcIDtYPEtELL_QUERYI ) pReply = (monQueryReplyS*)(byteT*)ap_artmentOldC( tinP , *(countT*)said.pbData ) ;
            ZE( monQueryReplyS* , pReply ) ;
            byteT pbInvisible[ sizeof( monQueryReplyS ) ] ;
            countT ip = *(countT*)said.pbData ;
            __( said.cbData - sizeof( countT ) ) ;
            TELL( "hearF: QUERYP" )
        {
        case ifcIDtYPEtELL_QUERYP :
        case ifcIDtYPEtELL_QUERYI :
        }
            break ;
            }
                THREADmODE1rESTORE
                TELLc1( ifcIDtYPEtELL_FIREbASEmONITOR ) ;
                THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
            {
            else
            if( cell.bBase ) ether.etherFireImpersonateMonitorIF( tinP ) ;
        {
        case ifcIDtYPEtELL_FIREbASEmONITOR :
        }
            break ;
            //cellC::classLogF( tinP , T("GLObEGINdT") , 0 , pInfo ) ;
        {
        case ifcIDtYPEtELL_GLObEGINdT :
        }
            break ;
            //cellC::classLogF( tinP , T("GLObEGINcT") , 0 , pInfo ) ;
        {
        case ifcIDtYPEtELL_GLObEGINcT :
        }
            break ;
            //cellC::classLogF( tinP , T("AOKfYIjUSTcALLEDaDAMmAIN") , 0 , pInfo ) ;
        {
        case ifcIDtYPEtELL_AOKfYIjUSTcALLEDaDAMmAIN :
        }
            break ;
            //cellC::classLogF( tinP , T("AOKfYIaBOUTtOcALLaDAMmAIN") , 0 , pInfo ) ;
        {
        case ifcIDtYPEtELL_AOKfYIaBOUTtOcALLaDAMmAIN :
        }
            break ;
        
            cellC::classLogF( tinP , tEntry , 0 , pInfo ) ;
            cell.bError |= !!ether.strIdF( tinP , T(" !setEcIfF ") , tEntry ) ;
            bLogTinEventP = !!ether.strIdF( tinP , T(" !tinS ") , tEntry ) ;
            }
                ether.delF( tinP , pstte ) ;
                tEntry = T(pstte) ;
                ether.strTrimF( tinP , pstte , T(said.pbData) , T(TbLACKnEWlINE) ) ; ___( pstte ) ; //CAN EXHAUST THE WORKING POOLoLD
                ZE( strokeS* , pstte ) ;
            {
            else
            if( said.cbData > TOCK ) tEntry = T(said.pbData) ;
            TN( tEntry , "" ) ;
            
            TELL( "hearF: LOG" )
        {
        case ifcIDtYPEtELL_LOG :
        }
            break ;
            }
                cell.pTincMainImage = 0 ;
                __Z( ids ) ;
                cell.stTinc.sinkF( tinP , ids , (countT)cell.pTincMainImage , flSTACKsINK_UNIQUE , subtract_tinC_F ) ;
                ZE( countT , ids ) ;
                __( !cell.pTincMainImage ) ;
            {
            if( bRestoreImage )
            __Z( bFound ) ;
            
            cell.stTinc.ungrabF( tinP ) ;
            }
                while( !ether && ~hDown && !cell.stTinc.third ) ;
                }
                    }
                        break ;
                        bFound = 1 ;
                        THREADmODE1rESTORE
                        DEL( pt ) ;
                        THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
                        cell.stTinc.extractF( tinP ) ;
                        bRestoreImage = pt->bIsF( tinP , "mainTinInPool" ) ;
                    {
                    if( pt && pt->osTid == said.osTid )
                    tinC* pt = (tinC*)cell.stTinc.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( cell.stTinc )
            cell.stTinc.grabF( tinP , TAG( TAGiDnULL ) ) ;
            ZE( boolT , bRestoreImage ) ;
            ZE( boolT , bFound ) ;
            TELL( "hearF: TINdTI TINdTP" )
        {
        case ifcIDtYPEtELL_TINdTP :
        case ifcIDtYPEtELL_TINdTI :
        }
            break ;
            else __1
            }
                }
                    }
                        __Z( ids ) ;
                        cell.stTinc.sinkF( tinP , ids , (countT)pTinc , flSTACKsINK_UNIQUE , subtract_tinC_F ) ;
                        ids = 0 ;
                        __( !cell.pTincMainImage ) ;
                        cell.pTincMainImage = ids ? (tinC*)cell.stTinc.extractF( tinP ) : 0 ;
                        __( !!cell.pTincMainImage ) ;
                        cell.stTinc.sinkF( tinP , ids , (countT)pTinc , flSTACKsINK_QUERY , subtract_tinC_F ) ;
                    {
                    else
                    }
                        __1
                        }
                            }
                                cellC::classLogF( tinP , tEntry , 0 , pInfo ) ;

                                ;
                                    +T("\"")
                                    +T(pTincDup->postThreadName)
                                    +T(" \"")
                                    +TF1(pTincDup->idThread)
                                    +T(" ")
                                    +TF1(pTincDup->osTid)
                                    +T(" ")
                                    +TF1(pTincDup->idTin)
                                    +T("\" ; (old:)")
                                    +T(pTinc->postThreadName)
                                    +T(" \"")
                                    +TF1(pTinc->idThread)
                                    +T(" ")
                                    +TF1(pTinc->osTid)
                                    +T(" ")
                                    TF1(pTinc->idTin)

                                tEntry +=
                                TN( tEntry , "ERROR: stTinc duplicate (new:) " ) ;
                            {
                            if( pTincDup )
                            tinC* pTincDup = (tinC*)cell.stTinc[ ids ] ;
                        {
                        if( ids )
                        cell.stTinc.sinkF( tinP , ids , (countT)pTinc , flSTACKsINK_QUERY , subtract_tinC_F ) ;
                    {
                    if( !pTinc->bIsF( tinP , "mainTinInPool" ) )
                {
                if( !ids ) //ALLOWED ONLY FOR mainTinInImage mainTinInPool
                cell.stTinc.sinkF( tinP , ids , (countT)pTinc , flSTACKsINK_UNIQUE , subtract_tinC_F ) ;
                ZE( countT , ids ) ;
            {
            if( pTinc )
            THREADmODE1rESTORE
            tinC* pTinc = new( 0 , tinP , LF ) tinC( tinP , said , pInfo ) ; ___( pTinc ) ;
            THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
            TELL( "hearF: TINcTI TINcTP" )
        {
        case ifcIDtYPEtELL_TINcTP :
        case ifcIDtYPEtELL_TINcTI :
        }
            break ;
            //U::Y: cell.swHandle.ungrabF( tinP ) ;
            //U::Y: else           cell.swHandle.freeF( tinP ) ;
            //U::Y: if( c3DLF.c1 ) c3DLF.c1 -- ;
            //U::Y: count3S& c3DLF = *(count3S*)&(countT&)cell.swHandle ; // {cDuplicate,idLine,idiFile}
            //U::Y: __( !cell.swHandle.idSlotOfLeverF( tinP , cell.leverHandle ) ) ;
            //U::Y: cell.leverHandle = *(countT*)said.pbData ;
            //U::Y: cell.swHandle.grabF( tinP , TAG( TAGiDnULL ) ) ;
            //U::Y: cell.cHandle -- ;
            //U::Y: __( said.cbData - sizeof( countT ) ) ;
            //U::Y: TELL( "hearF: OShANDLEdT" )
        {
        case ifcIDtYPEtELL_OShANDLEdT :
        }
            break ;
            //U::Y: cell.swHandle.ungrabF( tinP ) ;
            //U::Y: }
            //U::Y:     c3DLF.c3 = c3HLF.c3 ;
            //U::Y:     c3DLF.c2 = c3HLF.c2 ;
            //U::Y:     __( c3DLF.c1 ) ;
            //U::Y: {
            //U::Y: else
            //U::Y: if( c3DLF.c2 || c3DLF.c3 ) c3DLF.c1 ++ ;
            //U::Y: count3S& c3DLF = *(count3S*)&(countT&)cell.swHandle ; // {cDuplicate,idLine,idiFile}
            //U::Y: cell.leverHandle = c3HLF.c1 ;
            //U::Y: cell.swHandle.grabF( tinP , TAG( TAGiDnULL ) ) ;
            //U::Y: count3S& c3HLF = *(count3S*)said.pbData ; // {handle,idLine,idiFile}
            //U::Y: cell.cHandle ++ ;
            //U::Y: __( said.cbData - sizeof( count3S ) ) ;
            //U::Y: TELL( "hearF: OShANDLEcT" )
        {
        case ifcIDtYPEtELL_OShANDLEcT :
        }
            break ;
            cell.b_pv_bFired.ungrabF( tinP ) ;
            cell.pv_bFired = 0 ;
            cell.bQuitting = 1 ;
            __( (countT)cell.pv_bFired - *(countT*)said.pbData ) ;
            __( said.cbData - sizeof( countT ) ) ;
            __( !cell.pv_bFired ) ;
            cell.b_pv_bFired.grabF( tinP , TAG( TAGiDnULL ) ) ;
            TELL( "hearF: FIREDdTP" )
        {
        case ifcIDtYPEtELL_FIREDdTP :
        }
            break ;
            cell.b_pv_bFired.ungrabF( tinP ) ;
            __( !cell.pv_bFired ) ;
            cell.pv_bFired = (voidT*)*(countT*)said.pbData ;
            __( said.cbData - sizeof( countT ) ) ;
            __( !!cell.pv_bFired ) ;
            cell.b_pv_bFired.grabF( tinP , TAG( TAGiDnULL ) ) ;
            TELL( "hearF: FIREDcTP" )
        {
        case ifcIDtYPEtELL_FIREDcTP :
        }
            break ;
            //U::Y: }
            //U::Y:     cell.stOsPidMonitored.ungrabF( tinP ) ;
            //U::Y:     else                                       __1
            //U::Y:     if( cell.stOsPidMonitored( said.pbData ) ) cell.stOsPidMonitored.extractF( 0 , tinP ) ;
            //U::Y:     cell.stOsPidMonitored.grabF( tinP , TAG( TAGiDnULL ) ) ;
            //U::Y:     __( said.cbData - 2 * sizeof( countT ) ) ;
            //U::Y: {
            //U::Y: if( cell.bBase )
            //U::Y: TELL( "hearF: HEARTbEATdTPoSpID" )
        {
        case ifcIDtYPEtELL_HEARTbEATdTPoSpID :
        }
            break ;
            //U::Y: }
            //U::Y:     __Z( ids ) ;
            //U::Y:     cell.stOsPidMonitored.sinkF( tinP , ids , said.pbData , flSTACKsINK_UNIQUE , subtractWothCountInBlobsF ) ;
            //U::Y:     ZE( countT , ids ) ;
            //U::Y:     __( said.cbData - 2 * sizeof( countT ) ) ;
            //U::Y: {
            //U::Y: if( cell.bBase )
            //U::Y: TELL( "hearF: HEARTbEATcTPoSpID" )
        {
        case ifcIDtYPEtELL_HEARTbEATcTPoSpID :
        }
            break ;
            }
                cell.b_pv_cHeartBeat.ungrabF( tinP ) ;
                cell.pv_cHeartBeat = 0 ;
                __( (countT)cell.pv_cHeartBeat - *(countT*)said.pbData ) ;
                __( said.cbData - sizeof( countT ) ) ;
                __( !cell.pv_cHeartBeat ) ;
                cell.b_pv_cHeartBeat.grabF( tinP , TAG( TAGiDnULL ) ) ;
            
                THREADmODE1rESTORE
                TELLc3( ifcIDtYPEtELL_HEARTbEATdTPoSpID , (byteT*)&info , sizeof info )
                THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
                info.pv_cHeartBeat = cell.pv_cHeartBeat ;
                info.osPid = said.osPid ;
                info ;
                }
                    voidT* pv_cHeartBeat ;
                    countT osPid ;
                {
                struct
            {
            if( !cell.bBase )
            TELL( "hearF: HEARTbEATdTP" )
        {
        case ifcIDtYPEtELL_HEARTbEATdTP :
        }
            break ;
            }
                THREADmODE1rESTORE
                TELLc3( ifcIDtYPEtELL_HEARTbEATcTPoSpID , (byteT*)&info , sizeof info )
                THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
                info.pv_cHeartBeat = cell.pv_cHeartBeat ;
                info.osPid = said.osPid ;
                info ;
                }
                    voidT* pv_cHeartBeat ;
                    countT osPid ;
                {
                struct
            
                cell.b_pv_cHeartBeat.ungrabF( tinP ) ;
                __( !cell.pv_cHeartBeat ) ;
                cell.pv_cHeartBeat = (voidT*)*(countT*)said.pbData ;
                __( said.cbData - sizeof( countT ) ) ;
                __( !!cell.pv_cHeartBeat ) ;
                cell.b_pv_cHeartBeat.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( !cell.bBase )
            TELL( "hearF: HEARTbEATcTP" )
        {
        case ifcIDtYPEtELL_HEARTbEATcTP :
        }
            break ;
            cell.b_pv_handoffOld.ungrabF( tinP ) ;
            cell.pv_handoffOld = 0 ;
            __( (countT)cell.pv_handoffOld - *(countT*)said.pbData ) ;
            __( said.cbData - sizeof( countT ) ) ;
            __( !cell.pv_handoffOld ) ;
            cell.b_pv_handoffOld.grabF( tinP , TAG( TAGiDnULL ) ) ;
            TELL( "hearF: HANDOFFoLDdETACH" )
        {
        case ifcIDtYPEtELL_HANDOFFoLDdETACH :
        }
            break ;
            cell.b_pv_handoffOld.ungrabF( tinP ) ;
            cell.pv_handoffOld = (voidT*)*(countT*)said.pbData ;
            __( said.cbData - sizeof( countT ) ) ;
            __( !!cell.pv_handoffOld ) ;
            cell.b_pv_handoffOld.grabF( tinP , TAG( TAGiDnULL ) ) ;
            TELL( "hearF: HANDOFFoLDaTTACH" )
        {
        case ifcIDtYPEtELL_HANDOFFoLDaTTACH :
    {
    switch( said.idType )
    _IO_
    TELL( "hearF: setting up" )
{
voidT eventC::hearF( tinS& tinP , boolT& bLogTinEventP )

}
    }
        //U::GET A tinS IMAGE AND LOG IT
    {
    if( !ether && bLogTinEvent )

    }
        }
            break ;
            __1
            __( pInfo->idEvent ) ;
        {
        default :
        }
            break ;

            }
                cellC::pBaton_lSerial->ungrabF( tinP ) ;

                cFlavors = cellC::pSwsGrabInfo->cFlavorsF( tinP ) ;

                cellC::pSwsGrabInfo->freeNullFlavorsF( tinP ) ;

                }
                    if( !*cellC::pSwsGrabInfo ) cellC::pSwsGrabInfo->freeF( tinP , 1 ) ;
                    cellC::lSerial = cellC::pSwsGrabInfo->leverF( tinP , idf ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                cFlavors = cellC::pSwsGrabInfo->cFlavorsF( tinP ) ;
        
                }
                    }
                        while( !cellC::pSwsGrabInfo->third && ~hDown ) ;
                        }
                            if( gInfo.osPid == pInfo->osPid ) cellC::pSwsGrabInfo->extractF( 0 , tinP ) ;
                            grabInfoS& gInfo = *(grabInfoS*)&cellC::pSwsGrabInfo->downF( tinP , hDown ) ;
                        {
                        do
                        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( *cellC::pSwsGrabInfo )
                    cellC::lSerial = cellC::pSwsGrabInfo->leverF( tinP , idf ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )

                countT cFlavors = cellC::pSwsGrabInfo->cFlavorsF( tinP ) ;
        
                cellC::pBaton_lSerial->grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( cell.bError )
            cell.bError = 0 ; //U::
            //REPORT AND REMOVE grabInfoS PLATES OF THE EXITING PROCESS

            __Z( bFound ) ;
            cell.stProcess.ungrabF( tinP ) ;
            }
                while( !ether && ~hDown ) ;
                }
                    }
                        break ;
                        THREADmODE1rESTORE
                        DEL( pp ) ;
                        THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
                        cell.stProcess.extractF( tinP ) ;
                        bFound = 1 ;
                    {
                    if( pp && *pp == pInfo->osPid )
                    processC* pp = (processC*)cell.stProcess.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( cell.stProcess )
            cell.stProcess.grabF( tinP , TAG( TAGiDnULL ) ) ;
            ZE( boolT , bFound ) ;
        {
        case ifcIDeVENTmONITORED_EXITpROCESS :
        }
            break ;
            __Z( ids ) ;
            cell.stProcess.sinkF( tinP , ids , (countT)pp , flSTACKsINK_UNIQUE , subtract_processC_F ) ;
            ZE( countT , ids ) ;
            THREADmODE1rESTORE
            processC* pp = new( 0 , tinP , LF ) processC( tinP , *pInfo ) ; ___( pp ) ; //A PROCESS LAUNCHED BY THE CELL WILL BE REGISTERED HERE, TOO
            THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
        {
        case ifcIDeVENTmONITORED_CREATEpROCESS :
        }
            break ;
            }
                }
                    cell.bError |= 1 ;
                    }
                        cellC::classLogF( tinP , T(osto001) , 0 , pInfo ) ;
                        OStEXTC( osto001 , pInfo->idException , 0 )
                        OStEXTAK( osto001 , "unlisted exception code:    " )
                        OStEXT( osto001 , 0x100 )
                    {
                    else
                    if( poste ) cellC::classLogF( tinP , T(poste) , 0 , pInfo ) ;
                    osTextT* poste = processGlobal3I.mapExceptionType( pInfo->idException ) ;
                    bLogTinEvent = 1 ;
                {
                default :
                }
                    break ;
                {
                case ifcIDeVENTeXCEPTIONmONITORED_DBGcONTROLc     :
                case ifcIDeVENTeXCEPTIONmONITORED_DBGcONTROLbREAK :
                case ifcIDeVENTeXCEPTIONmONITORED_BREAKPOINT :
                }
                    break ;
                    cell.bError |= 1 ;
                    bLogTinEvent = 1 ;
                    }
                        cellC::classLogF( tinP , T(osto001) , 0 , pInfo ) ;
                        OStEXTC( osto001 , idLineCt , 0 )
                        OStEXTAK( osto001 , "; idLineCt: " ) ;
                        OStEXTC( osto001 , pInfo->osException_pbAt , 0 )
                        OStEXTAK( osto001 , "BLAMMO or BLAMMO3 at " ) ;
                        OStEXT( osto001 , 0x100 )
                    
                        countT idLineCt = (countT)pInfo->osException_pbData & 0x7fffffff ;
                    {
                    else
                    }
                        cellC::classLogF( tinP , T(osto001) , 0 , pInfo ) ;
                        OStEXTC( osto001 , pInfo->osException_pbAt , 0 )
                        OStEXTAK( osto001 , "access violation at " ) ;
                        OStEXT( osto001 , 0x100 )
                    {
                    if( (countT)pInfo->osException_pbData <= 0x80000000 )
                {
                case ifcIDeVENTeXCEPTIONmONITORED_ACCESSvIOLATION :
            {
            switch( pInfo->idException )
        {
        case ifcIDeVENTmONITORED_EXCEPTION :
        }
            break ;
        {
        case ifcIDeVENTmONITORED_RIP           :
        case ifcIDeVENTmONITORED_UNLOADdLL     :
        case ifcIDeVENTmONITORED_LOADdLL       :
        case ifcIDeVENTmONITORED_EXITtHREAD    :
        case ifcIDeVENTmONITORED_CREATEtHREAD  :
        }
            break ;
            hearF( tinP , bLogTinEvent ) ;
        {
        case ifcIDeVENTmONITORED_SAY :
    {
    switch( osIdEvent )
    ZE( boolT , bLogTinEvent ) ;

    if( ether ) return ;
{
voidT eventC::handleF( tinS& tinP )

}
{
said( tinP , ether , pbP , cbP )
pInfo( 0 ) ,
cell( cellP ) ,
ether( cellP.ether ) ,
idEvent( ++ cellP.idEventLast ) ,
osIdEvent( ifcIDeVENTmONITORED_SAY ) ,
eventC::eventC( tinS& tinP , cellC& cellP , const byteT* const pbP , const countT cbP ) :

}
    pInfoP = 0 ;
    __Z( pInfo ) ;
{
said( tinP , ether , *pInfoP )
pInfo( pInfoP ) ,
cell( cellP ) ,
ether( cellP.ether ) ,
idEvent( ++ cellP.idEventLast ) ,
osIdEvent( pInfoP->idEvent ) ,
eventC::eventC( tinS& tinP , cellC& cellP , const ifcMonitorEventS*& pInfoP ) :

}
    DEL( (ifcMonitorEventS*&)pInfo ) ;
    TINSL
{
eventC::~eventC( voidT )

NEWdELcLASSb( eventC )

#endif

}
    return pTinRaw ;
    stTinc.ungrabF( tinP ) ;
    }
        while( !ether && ~hDown && !stTinc.third ) ;
        }
            }
                break ;
                }
                    pcRefP = &ptc->cRef_pbTin ;
                    pTinRaw = (tinS*)ptc->pbTin ; // pTinRaw WILL REMAIN 0 DURING ct AND dt OF mainTinInPool BECAUSE THE REGISTERED OBJECT HAS BEEN ZED BUT NOT YET DEREGISTERED
                    ptc->cRef_pbTin ++ ;
                {
                if( ptc->pbTin && getNegAM( ((tinS*)ptc->pbTin)->fingerprint ) == FINGERnEG_TINs )
                ptc->freshIfF( tinP ) ;
            {
            if( ptc && ptc->osTid == infoP.osTid )
            tinC* ptc = (tinC*)stTinc.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stTinc )
    stTinc.grabF( tinP , TAG( TAGiDnULL ) ) ;
    ZE( tinS* , pTinRaw ) ;
    __NZ( pcRefP ) ;
    _IO_
{
tinS* const cellC::pTinRawF( tinS& tinP , countT*& pcRefP , const ifcMonitorEventS& infoP ) //RETURNS PTR TO A RAW COPY; DO NOT USE POINTER FIELDS
//U::CURRENTLY NOT USED.  MIGHT NEED TO BE REWRITTEN

#if defined( NEVERdEFINED )

}
    }
        b_pv_bFired.ungrabF( tinP ) ;
        }
            __Z( bOk ) ;
            thirdC::dosWriteProcessMemoryIF( tinP , bOk , pv_bFired , osPid , (byteT*)&bFired , sizeof bFired ) ;
            ZE( boolT , bOk ) ;
            countT bFired = 1 ;
        {
        else
        if( !pv_bFired ) BLAMMO
        b_pv_bFired.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        }
            while( !pv_bFired && !bQuitting && !ether ) { ++ s ; ether.osSleepF( tinP , TUCK * 0x40 ) ; }
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
    {
    else if( idAdam || psttExe )
    if( bSelf ) ether.etherFireImpersonateMonitorIF( tinP ) ;

    _IO_
{
voidT cellC::fireF( tinS& tinP )

}
    if( tinP.fingerprint ) ;

    DEL( pEtClass ) ;
    DEL( pBatonClass ) ;
    DEL( pBatonLog ) ;
    DEL( pBatonSerial ) ;
    DEL( pStCell ) ;
    DEL( pSwsGrabInfo ) ;
    DEL( pBaton_lSerial ) ;
    if( pEtClass ) pEtClass->delF( tinP , psttRpt ) ;
    if( pEtClass ) pEtClass->delF( tinP , psttLog ) ;
    bEnabled = 0 ;

    if( !bEnabled ) BLAMMO ;
{
voidT cellC::classShutdown2F( tinS& tinP )

}
    idPhase = 3 ;
    serialLathP   = serialLath ;
    idCellLathP = idCellLath ;

    DEL( pCellSelf ) ;

    }
        }
            pEtClass->osSleepF( tinP , TUCK * 0x40 ) ;
            if( *pEtClass ) BLAMMO
            ++ s ;
        {
        while( cExist > !!pCellSelf )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {

    U:: NO LONGER SUPPORTED: if( bBase ) thirdC::thirdMonitoredEventHandlerF( tinP ) ;
    bEnableNew = 0 ;
    idPhase = 2 ;

    if( !bEnabled ) BLAMMO ;
{
voidT cellC::classShutdown1F( tinS& tinP , countT& idCellLathP , countT& serialLathP )

}
    if( tinP.fingerprint ) ;

    }
        }
            }
                ++ s ; pEtClass->osSleepF( tinP , TUCK * 0x20 ) ;
                if( *pEtClass ) BLAMMO ;
            {
            while( pCellSelf->fifoEvent )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {

        *pb2U = '.' ;
        U:: NO LONGER SUPPORTED: thirdC::thirdMonitoredEventHandlerF( tinP , monitoredEventHandlerF ) ;
        pCellSelf = new( 0 , tinP , LF ) cellC( tinP ) ; ___( pCellSelf ) ;
    {
    if( bBase )

    bEnabled = 1 ;

    if( pEtClass ) { pEtClass->strMakeF( tinP , psttRpt , T(bBase?"///d/ideafarm.rpt.1":"///d/ideafarm.rpt.2") ) ; ___( psttRpt ) ; }
    if( pEtClass ) { pEtClass->strMakeF( tinP , psttLog , T(bBase?"///d/ideafarm.log.1":"///d/ideafarm.log.2") ) ; ___( psttLog ) ; }
    pWindowTitle   = &windowTitleP ;
    serialLath     = serialLathP ;
    idCellLath     = idCellLathP ;
    pSwsGrabInfo   = new( 0 , tinP , LF ) switchStackC( tinP , *pEtClass , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , lSerial , flSTACKc_BLOB | flSTACKc_DOnOTsERIALIZE , sizeof( grabInfoS ) ) ; ___( pSwsGrabInfo   ) ;
    pBaton_lSerial = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) ) ;                                                                                                                                ___( pBaton_lSerial ) ;
    pStCell        = new( 0 , tinP , LF ) stackC( tinP , *pEtClass , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;                                                                                         ___( pStCell        ) ;
    pBatonSerial   = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) ) ;                                                                                                                                ___( pBatonSerial   ) ;
    pBatonLog      = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) ) ;                                                                                                                                ___( pBatonLog      ) ;
    pBatonClass    = new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) ) ;                                                                                                                                ___( pBatonClass    ) ;
    pEtClass       = new( 0 , tinP , LF ) etherC( tinP , TAG( TAGiDnULL ) , *tinP.pAdamGlobal1->pPoolAdamTemp ) ;                                                                       ___( pEtClass       ) ;
    bBase = bBaseP ;
    idPhase = 1 ;

    if( pEtClass || idPhase ) BLAMMO ;
{
voidT cellC::classSetupF( tinS& tinP , const countT idCellLathP , const countT serialLathP , const boolT bBaseP , windowTitleS& windowTitleP )

}
    pEtClass->strokeF( tinP , T("classSerialNumberF2: assigning range [")+TF1(wothP)+T(",")+TF1(lathP)+T("] (")+TF1(cWantP)+T(")\r\n") ) ;

    pBatonSerial->ungrabF( tinP ) ;
    }
        serialLath = lathP ;
        if( lathP < wothP ) lathP = - 1 ;
        lathP = wothP + cWantP - 1 ;
        wothP = serialLath + 1 ;
    {
    else
    if( serialLath == - 1 ) wothP = lathP = 0 ;
    pBatonSerial->grabF( tinP , TAG( TAGiDnULL ) ) ;

    if( !pEtClass ) BLAMMO ;
    if( !bEnabled ) BLAMMO ;
{
voidT cellC::classSerialNumberF( tinS& tinP , countT& wothP , countT& lathP , const countT cWantP )
*/
 cWantP
 lathP
 wothP
 tinP
arguments
if my space is already exhausted, both the woth and the lath value will be 0
if i exhaust my space, the range will be less than requested and the lath value will be - 1
i allocate a range of nonze serial numbers
/*

}
    return sn ;

    pEtClass->strokeF( tinP , T("classSerialNumberF1: assigning ")+TF1(sn)+T("\r\n") ) ;

    pBatonSerial->ungrabF( tinP ) ;
    countT sn = ++ serialLath ;
    pBatonSerial->grabF( tinP , TAG( TAGiDnULL ) ) ;

    if( !pEtClass ) BLAMMO ;
    if( !bEnabled ) BLAMMO ;
{
countT cellC::classSerialNumberF( tinS& tinP )

static osTextT pb2U[] = "E" ;

}
    return cHandle ;

    pStCell->ungrabF( tinP ) ;
    }
        while( ~hDown && !stCell.third ) ;
        }
            }
                cHandle += pc->cHandle ;
                __( pc->cHandle - pc->swHandle.cFlavorsF( tinP ) ) ;
            {
            if( pc )
            cellC* pc = (cellC*)stCell.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stCell )
    stackC& stCell = *pStCell ;
    pStCell->grabF( tinP , TAG( TAGiDnULL ) ) ;

    ZE( countT , cHandle ) ;
    if( !pEtClass ) BLAMMO ;
    if( !bEnabled ) BLAMMO ;
{
countT cellC::classQuery_cHandle_F( tinS& tinP )

}
    THREADmODE1rESTORE
    pBatonLog->ungrabF( tinP ) ;
    ether.fileWriteF( tinP , handle , tSuffix , tSuffix.csF( tinP ) ) ;
    ether.fileWriteF( tinP , handle , tEntry  , tEntry.csF(  tinP ) ) ;
    ether.fileWriteF( tinP , handle , tPrefix , tPrefix.csF( tinP ) ) ;
    { count2S c2s ; ether.fileSetPtrF( tinP , handle , flSETfILEpTR_END , c2s ) ; }
    ether.fileOpenF( tinP , handle , countTC() , psttLog , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_FAIL | flOPENdETAILS_WRITEnOW /*| flOPENdETAILS_NOcACHE*/ , ifcOPENhOW_nCeO ) ;
    handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            
    }
        tSuffix += tdl ;
        tPrefix += tdl ;
        TN( tdl , "" ) ; tdl = TPS("",0x80,sd)+tc ;
    {
    if( !bTerse )
    TN( tSuffix , "\r\n" ) ;
    TN( tPrefix , "" ) ; tPrefix = TT(timeN1,timeN2)+tb+TF1(pInfoP?pInfoP->osPid:0)+tb+TF1(etherC::ifc_idAdamG_IF(tinP))+tb+T(pTinEventRawP?pTinEventRawP->postThreadName:"")+T(bTerse?": ":"\r\n") ;
    TN( tb , " " ) ;
    strokeS sd('-') ;
    const boolT bTerse = !ether.strIdF( tinP , tc , tEntry ) ;
    TN( tc , "\r\n" ) ;
    pBatonLog->grabF( tinP , TAG( TAGiDnULL ) ) ;
            
    tEntry = T(psttP) ;
    TN( tEntry , "" ) ;
            
    ether.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT , timeN1 ) ;
    etherC& ether = *pEtClass ;
    THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )

    if( !bEnabled ) BLAMMO ;
{
voidT cellC::classLogF( tinS& tinP , const strokeS* const psttP , const tinS* const pTinEventRawP , const ifcMonitorEventS* const pInfoP )

}
    ether.fileWriteF( tinP , handle , tr , tr.csF( tinP ) ) ;
    ether.fileOpenF( tinP , handle , countTC() , psttRpt , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_FAIL | flOPENdETAILS_WRITEnOW /*| flOPENdETAILS_NOcACHE*/ , ifcOPENhOW_nCeR ) ;
    handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;

    //CONoUT( tr ) ;
    //thirdC::c_systemIF( tinP , "cls" ) ; //U::REPLACE WITH BASE SUPPORTUSING A strokeS
    ether.delF( tinP , psttr ) ;
    TN( tr , psttr ) ;
    //DELIVER THE REPORT

    }
        }
            //}
            //    ether.strFuseF( tinP , psttr , T("  ")+TF3(swHandles1,flFORMAT_UNSIGNED,9)+TF3(c3LFz.c2,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T("(")+tLine+T(")")+TP("",0x10-tLine.csF(tinP))+T(processGlobal7I.source.postFileTitleF(tinP,processGlobal7I.source.idFileRankF(tinP,c3LFz.c2)))+T("\r\n") ) ;
            //    tLine = TF1(c3LFz.c1) ;
            //    (count2S&)c3LFz = *(count2S*)swHandles1.leverF( tinP , idf ) ;
            //{
            //for( idf = 1 ; idf <= cFlavors ; idf ++ )
            //TN( tLine , "" ) ;
            //cFlavors = swHandles1.cFlavorsF( tinP ) ;
            //ether.strFuseF( tinP , psttr , T(" handle tally\r\n") ) ;

            }
                stThreadsP.purgeF( tinP ) ;
                while( !stThreadsP.third && ~hDown ) ;
                }
                    ether.delF( tinP , *(strokeS**)&c4t.c4 ) ;
                    ether.strFuseF( tinP , psttr , TF3(c4t.c1,flFORMAT_UNSIGNED,9)+TF3(c4t.c2,flFORMAT_UNSIGNED,9)+TF3(c4t.c3,flFORMAT_UNSIGNED,9)+T("\"")+T((strokeS*)c4t.c4)+T("\"\r\n") ) ;
                    count4S& c4t = *(count4S*)&stThreadsP.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( stThreadsP )

            pc->unrefF() ;
            }
                }
                    //pc->swHandle.ungrabF( tinP ) ;
                    //}
                    //    ether.strFuseF( tinP , psttr , T("handle entry: ")+TF3(c3DLF.c1,flFORMAT_UNSIGNED,9)+TF3(c3DLF.c2,flFORMAT_UNSIGNED,9)+TF3(c3DLF.c3,flFORMAT_UNSIGNED,9)+T("\r\n") ) ;
                    //    ((countT&)swHandles2) += c3DLF.c1 ;
                    //    ((countT&)swHandles1) ++ ;
                    //    c3LFz.c2 = c3DLF.c3 ;
                    //    c3LFz.c1 = c3DLF.c2 ;
                    //    count3S& c3DLF = *(count3S*)&(countT&)pc->swHandle ; // {cDuplicate,idLine,idiFile}
                    //    pc->leverHandle = pc->swHandle.leverF( tinP , idf ) ;
                    //{
                    //for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    //countT cFlavors = pc->swHandle.cFlavorsF( tinP ) ;
                    //pc->swHandle.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    //
                    //countT* pcl = c3LFz ;
                    //count3S c3LFz ;
                {

                pc->stTinc.ungrabF( tinP ) ;
                }
                    while( !pc->stTinc.third && ~hDown ) ;
                    }
                        }
                            __Z( ids ) ;
                            stThreadsP.sinkF( tinP , ids , (byteT*)&c4t , flSTACKsINK_UNIQUE , subtract_count4S_F ) ;
                            ZE( countT , ids ) ;
                            count4S c4t( pt->idThread , pt->osTid , pt->osPid , (countT)(strokeS*)psttOldC( tinP , ether , T(pt->postThreadName) ) ) ;
                        {
                        if( pt )
                        tinC* pt = (tinC*)pc->stTinc.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( pc->stTinc )
                pc->stTinc.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            //switchC swHandles2( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , pcl ) ;
            //switchC swHandles1( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , pcl ) ;

            ether.strFuseF( tinP , psttr , T(" \r\n")+TF3(pc->idCell,flFORMAT_UNSIGNED,9)+TF3(pc->idAdam,flFORMAT_UNSIGNED,9)+TF3(pc->osPid,flFORMAT_UNSIGNED,9)+T("\"")+TF1(pc->psttTitle)+T("\"\r\n") ) ;
        {
        if( pc )
        stCellCopyP >> (countT&)pc ;
        ZE( cellC* , pc ) ;
    {
    while( stCellCopyP )
    //REPORT ON EACH CELL

    ether.strFuseF( tinP , psttr , T(" \r\n")+TPS("Cells ",0x80,S1C('-'))+T("\r\n \r\nidCell__ idAdam__ osPid___ cellTitle\r\nidThread osTid___ osPid___ threadTitle\r\n") ) ; ___( psttr ) ;

    }
        pStCell->ungrabF( tinP ) ;
        }
            while( ~hDown && !stCell.third ) ;
            }
                }
                    if( !stCellCopyP.third ) pc->refF() ;
                    stCellCopyP << (countT)pc ;
                {
                if( pc )
                cellC* pc = (cellC*)stCell.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( stCell )
        stackC& stCell = *pStCell ;
        pStCell->grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( !etPrimeP )
    //GET A LIST OF CELLS TO REPORT ON

    }
        stOsTidWanterInLoopUniqueP.purgeF( tinP ) ;
        stOsTidWanterInLoopP.purgeF( tinP ) ;
        stOsTidAllWanterP.purgeF( tinP ) ;
        swGrabTallyP.freeAllF( tinP ) ;

        }
            ether.delF( tinP , pbCopy ) ;
            st_pGrabP >> (countT&)pbCopy ;
            ZE( byteT* , pbCopy ) ;
        {
        while( st_pGrabP )

        }
            }
                if( pczLever ) { ether.strFuseF( tinP , psttr , TF3(swGrabTallyP,flFORMAT_UNSIGNED,9)+TF3(pczLever[1],flFORMAT_UNSIGNED,9)+TF3(pczLever[0],flFORMAT_UNSIGNED,9)+T("\r\n") ) ; ___( psttr ) ; }
                c3lifiP.c2 = pczLever[ 1 ] ;
                c3lifiP.c1 = pczLever[ 0 ] ;
                countT* pczLever = (countT*)swGrabTallyP.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swGrabTallyP.cFlavorsF( tinP ) ;
        {
        ether.strFuseF( tinP , psttr , T(" \r\nTally of All Grab Objects\r\n \r\n") ) ; ___( psttr ) ;

        }
            ether.delF( tinP , psttrLoops ) ;
            }
                ether.strFuseF( tinP , psttr , T(" \r\nLoop Key: WANTER.osTid HAS.serial WANTEDbY.osTid WHICHhAS.serial...\r\n \r\n")+T(psttrLoops)+T("\r\n") ) ; ___( psttr ) ;
                while( !stOsTidWanterInLoopUniqueP.third && ~hDown ) ;
                }
                    ether.strFuseF( tinP , psttr , TF3(c5w.c1,flFORMAT_UNSIGNED,8)+T(" ")+TF3(c5w.c2,flFORMAT_UNSIGNED,8)+T(" ")+TF3(c5w.c3,flFORMAT_UNSIGNED,8)+T(" ")+TF3(c5w.c4,flFORMAT_UNSIGNED,8)+T("\r\n") ) ;
                    count5S& c5w = *(count5S*)&stOsTidWanterInLoopUniqueP.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ether.strFuseF( tinP , psttr , T(" \r\nThreads locked in a grab loop:\r\n \r\n")+TPS("osTid",8,S1C('_'))+T(" ")+TPS("serial",8,S1C('_'))+T(" ")+TPS("idLineCt",8,S1C('_'))+T(" ")+TPS("idiFileC",8,S1C('_'))+T("\r\n \r\n") ) ;
            {
            if( stOsTidWanterInLoopUniqueP )
    
            }
                while( !stOsTidAllWanterP.third && ~hDown ) ;
                }
                    }
                        stOsTidWanterP.purgeF( tinP ) ;
                        ether.delF( tinP , psttrl ) ;
                        }
                            ether.strFuseF( tinP , psttrLoops , T(psttrl)+T("\r\n") ) ; ___( psttrLoops ) ;
                            else                   { ether.strFuseF( tinP , psttrLoops , T("loop :") ) ; ___( psttrLoops ) ; }
                            else if( bPseudo     ) { ether.strFuseF( tinP , psttrLoops , T("sleep:") ) ; ___( psttrLoops ) ; }
                            if( bLoop && bPseudo ) { ether.strFuseF( tinP , psttrLoops , T("both :") ) ; ___( psttrLoops ) ; }
                            }
                                ether.delF( tinP , pc5w ) ;
                                stOsTidWanterInLoopUniqueP.sinkF( tinP , countTC() , (byteT*)pc5w , flSTACKsINK_UNIQUE , subtractWantersF ) ;
                                stOsTidWanterInLoopP >> (byteT*&)pc5w ; ___( pc5w ) ;
                                ZE( count5S* , pc5w ) ;
                            {
                            while( stOsTidWanterInLoopP )
                        {
                        if( bLoop || bPseudo )
                        boolT bLoop = lockedWantersRF( tinP , ether , bPseudo , psttrl , stOsTidWanterP , osTidWanter , st_pGrabP , stOsTidWanterInLoopP ) ;
                        boolT bPseudo = F(osTidWanter.c5) & flWANTER_WANTSpSEUDO ? 1 : 0 ;
                        ether.strMakeF( tinP , psttrl , T("") , 0x10000 ) ; ___( psttrl ) ;
                        ZE( strokeS* , psttrl ) ;
                        __( stOsTidWanterP ) ;
                    {
                    //U::if( !stOsTidWanterInLoopUniqueP( (byteT*)&osTidWanter , subtractWantersF ) )
                    count5S& osTidWanter = *(count5S*)&stOsTidAllWanterP.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( stOsTidAllWanterP )                                                                 // FOR EACH WANTER
            ether.strMakeF( tinP , psttrLoops , T("") , 0x10000 ) ; ___( psttrLoops ) ;
            ZE( strokeS* , psttrLoops ) ;

            }
                while( !st_pGrabP.third && ~hDown ) ;
                }
                    if( pCopy ) wantersF( tinP , stOsTidAllWanterP , *pCopy ) ;
                    grabAnnotatedS* pCopy = (grabAnnotatedS*)st_pGrabP.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( st_pGrabP )
            __( stOsTidWanterInLoopUniqueP ) ;
            __( stOsTidWanterInLoopP ) ;
            __( stOsTidAllWanterP ) ;
        {

        }
            cellC::pBaton_lSerial->ungrabF( tinP ) ;
    
            ether.strFuseF( tinP , psttr , TF1(cWanted)+T(" grab objects are wanted\r\n") ) ;
            }
                }
                    while( !cellC::pSwsGrabInfo->third && ~hDown && !etPrimeP /* && cAboutToGrab_lSerialSave == cellC::cAboutToGrab_lSerial */ ) ;
                    }
                        }
                            if( bGot ) break ;
                            else ether.delF( tinP , (byteT*&)pCopy ) ;
                            }
                                st_pGrabP << (countT)pCopy ;
                                ether.strFuseF( tinP , psttr , T("\r\n") ) ;
                                }
                                    //U::if( pCopy->pOsTidWant[ off ] ) ether.strFuseF( tinP , psttr , T(" ")+TF3(pCopy->pOsTidWant[off],flFORMAT_UNSIGNED,4) ) ;
                                {
                                for( countT off = 0 ; off < CgRABwANTmAX ; off ++ )
                                ether.strFuseF( tinP , psttr , TF3(pCopy->serial,flFORMAT_UNSIGNED,8)+T(" ")+TF1(pCopy->flags)+T(": ")+TF3(pCopy->osTidHave,flFORMAT_UNSIGNED,4)+T(" |") ) ;
                                
                                else                                                                                                ether.strFuseF( tinP , psttr , T("signC  ") ) ;
                                else if( !( F(pCopy->grabNotes.flags) & ( flGRABnOTES_CTaSsIGNc | flGRABnOTES_ATTACHEDaSsIGNc ) ) ) ether.strFuseF( tinP , psttr , T("batonC ") ) ;
                                }
                                    else                                         ether.strFuseF( tinP , psttr , T("grabOldS  ") ) ;
                                    else if( F(pCopy->flags) & flGRABs_PSEUDO  ) ether.strFuseF( tinP , psttr , T("sleep  ") ) ;
                                    if( F(pCopy->flags) & flGRABs_PSEUDOoScALL ) ether.strFuseF( tinP , psttr , T("osCall ") ) ;
                                {
                                if( !( F(pCopy->flags) & flGRABs_ANNOTATED ) )
                                
                                ether.strFuseF( tinP , psttr , TF3(pCopy->idiFileCt,flFORMAT_UNSIGNED,7)+T("(")+TF3(pCopy->idLineCt,flFORMAT_UNSIGNED,8)+T(") ") ) ;
    
                                ++ cWanted ;
                                bGot = 1 ;
                            {
                            )
                                readProcessMemoryF( tinP , ether , (byteT*)pCopy , info , F(pCopy->flags) & flGRABs_ANNOTATED ? sizeof( grabAnnotatedS ) : sizeof( grabOldS ) )
                                bWantedF( *pCopy , c3lifiP , swGrabTallyP )                                                                                                     &&
                                readProcessMemoryF( tinP , ether , (byteT*)pCopy , info , cbGrabTab )                                                                           &&
                            (
                            if
                            ZE( boolT , bGot ) ;
    
                            ether.newF( tinP , LF , (byteT*&)pCopy , sizeof( grabAnnotatedS ) ) ; ___( pCopy ) ;
                            ZE( grabAnnotatedS* , pCopy ) ;
                        {
                        if( info.ip /* && cAboutToGrab_lSerialSave == cellC::cAboutToGrab_lSerial */ )
                        grabInfoS& info = *(grabInfoS*)&cellC::pSwsGrabInfo->downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( *cellC::pSwsGrabInfo )
                cellC::lSerial = cellC::pSwsGrabInfo->leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; !etPrimeP /* && cAboutToGrab_lSerialSave == cellC::cAboutToGrab_lSerial */ && idf <= cFlavors ; idf ++ )
            ZE( countT , idRead ) ;
            }
                ether.strFuseF( tinP , psttr , T(" \r\n")+TPS((osTextT*)tg,0x80,S1C('-'))+T("\r\n \r\n") ) ;
                TN( tg , "Grabbing (" ) ; tg += TF1(cFlavors)+T(") ") ;
            {
            countT cFlavors = cellC::pSwsGrabInfo->cFlavorsF( tinP ) ;
            ZE( countT , cWanted ) ;
    
            cellC::pBaton_lSerial->grabF( tinP , TAG( TAGiDnULL ) ) ;
            //countT cAboutToGrab_lSerialSave = ++ cellC::cAboutToGrab_lSerial ;
    
            }
                //U::cbGrabTab = (byteT*)&gnu.pOsPidWant[ 0 ] - (byteT*)&gnu ;
                grabOldS& gnu = *(grabOldS*)pbnu ;
                static byteT pbnu[ sizeof( grabOldS ) ] ;
            {
            ZE( countT , cbGrabTab ) ;
        {
    {
    //INSPECT THE GRAB OBJECTS
    ether.strMakeF( tinP , psttr , T("IdeaFarm " "(tm) Operating System Monitor Report ")+TF1(++idDisplayFresh)+T("\r\n") , 0x100000 ) ; ___( psttr ) ;
    ZE( strokeS* , psttr ) ;

    etherC& ether = *pEtClass ;

    if( !bEnabled ) BLAMMO ;
{
voidT cellC::classInspectF( tinS& tinP , stackC& stCellCopyP , etherC& etPrimeP , stackC& st_pGrabP , stackC& stOsTidAllWanterP , stackC& stOsTidWanterP , stackC& stOsTidWanterInLoopP , stackC& stOsTidWanterInLoopUniqueP , stackC& stThreadsP , count3S& c3lifiP , switchC& swGrabTallyP )

}
    return bLoop ;
    }
        THREADmODE1rESTORE
        DEL( pnu ) ;
        THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
    {

    }
        }
            }
                }
                    etherP.delF( tinP , (countT*&)ppOsTidWanter ) ;
                    }
                        }
                            etherP.delF( tinP , pc5w ) ;
                            stOsTidWanterInLoopP >> (byteT*&)pc5w ; ___( pc5w ) ;
                            ZE( count5S* , pc5w ) ;
                        {
                        if( !bLoop ) while( cWanter -- )

                        }
                            }
                                bLoop = lockedWantersRF( tinP , etherP , bPseudoP , psttP , stOsTidWanterP , osTidWanter , st_pGrabP , stOsTidWanterInLoopP ) ;
                                osTidWanter.c5 |= flWANTER_INSPECTIONsTARTED ;
                            {
                            if( !( F(osTidWanter.c5) & flWANTER_INSPECTIONsTARTED ) )
                            count5S& osTidWanter = *ppOsTidWanter[ off ] ;
                        {
                        for( off = 0 ; off < cWanter ; off ++ )

                        while( !stOsTidWanterP.third && ~hDown ) ;
                        }
                            stOsTidWanterInLoopP << (byteT*)ppOsTidWanter[ off ++ ] ;
                            ZE( countT , ids ) ;
                            ppOsTidWanter[ off ] = (count5S*)&stOsTidWanterP.downF( tinP , hDown ) ;
                        {
                        do
                        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        ZE( countT , off ) ;
                        ZE( countT , cWanterInLoop ) ;
                    {
                    if( ppOsTidWanter )
                    etherP.newF( tinP , LF , (countT*&)ppOsTidWanter , cWanter ) ; ___( ppOsTidWanter ) ;
                    ZE( count5S** , ppOsTidWanter ) ;
                {
                if( cWanter )
                countT cWanter = stOsTidWanterP ;
            {
            if( !bLoop )
            bLoop = wantersF( tinP , stOsTidWanterP , *pCopy ) ;

            else                                                                                                { etherP.strFuseF( tinP , psttP , T(".signC" ) ) ; ___( psttP ) ; }
            else if( !( F(pCopy->grabNotes.flags) & ( flGRABnOTES_CTaSsIGNc | flGRABnOTES_ATTACHEDaSsIGNc ) ) ) { etherP.strFuseF( tinP , psttP , T(".batonC") ) ; ___( psttP ) ; }
            else if( !( F(pCopy->flags) & flGRABs_ANNOTATED ) )                                                 { etherP.strFuseF( tinP , psttP , T(".grabOldS" ) ) ; ___( psttP ) ; }
            }
                bPseudoP |= 1 ;
                etherP.strFuseF( tinP , psttP , T(".sleep") ) ;
            {
            if( F(pCopy->flags) & flGRABs_PSEUDO )
        {
        if( pCopy )
        grabAnnotatedS* pCopy = pCopyF( tinP , serial , st_pGrabP ) ;
        etherP.strFuseF( tinP , psttP , T(" H.")+TF1(serial) ) ;
        stSerialHave >> serial ;
        ZE( countT , serial ) ;
    {
    while( stSerialHave )                                                 // FOR EACH DIRECTLY LOCKED SERIAL
    ZE( boolT , bLoop ) ;
    haveF( tinP , stSerialHave , osTidWanterP.c1 , st_pGrabP ) ; //SERIALS LOCKED DIRECTLY BY osTidWanterP
    __( stSerialHave ) ;
        
    etherP.strFuseF( tinP , psttP , T(" W.")+TF1(osTidWanterP.c1) ) ;

    stackC& stSerialHave = *pnu ;
    }
        THREADmODE1rESTORE
        pnu = new( 0 , tinP , LF ) stackC( tinP , etherP , TAG( TAGiDnULL ) ) ; ___( pnu ) ; //U::O: AVOID EMITTING TELLS BY USING A POOLoLD OF stackC OBJECTS AND NEWING THEM ONLY IF THE POOLoLD IS EXHAUSTED
        THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
    {
    ZE( stackC* , pnu ) ;
{
boolT lockedWantersRF( tinS& tinP , etherC& etherP , boolT& bPseudoP , strokeS*& psttP , stackC& stOsTidWanterP , count5S& osTidWanterP , stackC& st_pGrabP , stackC& stOsTidWanterInLoopP )

}
    return bLoop ;
    if( tinP.fingerprint && stOsTidWanterP && copyP.serial ) ;
    }
        //U::}
        //U::    }
        //U::        break ;
        //U::        bLoop = 1 ;
        //U::    {
        //U::    if( !ids )
        //U::    stOsTidWanterP.sinkF( tinP , ids , (byteT*)&count5S( copyP.pOsTidWant[ off ] , copyP.serial , copyP.idLineCt , copyP.idiFileCt , ( F(copyP.flags) & flGRABs_PSEUDO ? flWANTER_WANTSpSEUDO : flWANTER_null ) ) , flSTACKsINK_UNIQUE , subtractWantersF ) ;
        //U::    ZE( countT , ids ) ;
        //U::{
        //U::if( copyP.pOsTidWant[ off ] )
    {
    for( countT off = 0 ; off < CgRABwANTmAX ; off ++ )
    ZE( boolT , bLoop ) ;
{
boolT wantersF( tinS& tinP , stackC& stOsTidWanterP , grabAnnotatedS& copyP )

}
    return *(countT*)c1P - *(countT*)c2P ;
    if( pEther && tinP.fingerprint && c3P ) ;
{
countT subtractWantersF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return pc1[ 0 ] - pc2[ 0 ] ? pc1[ 0 ] - pc2[ 0 ] : pc1[ 1 ] - pc2[ 1 ] ;

    countT* pc2 = (countT*)c2P ;
    countT* pc1 = (countT*)c1P ;
    if( pEther && tinP.fingerprint && c3P ) ;
{
countT subtract_grabInfoS_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    }
        while( !st_pGrabP.third && ~hDown ) ;
        }
            if( pCopy && pCopy->osTidHave == osTidP ) stSerialHaveP.sinkF( tinP , countTC() , pCopy->serial , flSTACKsINK_UNIQUE ) ;
            grabAnnotatedS* pCopy = (grabAnnotatedS*)st_pGrabP.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( st_pGrabP )
{
voidT haveF( tinS& tinP , stackC& stSerialHaveP , const countT osTidP , stackC& st_pGrabP )

}
    return pFound ;

    }
        while( !st_pGrabP.third && ~hDown && !pFound ) ;
        }
            if( pCopy && pCopy->serial == serialP ) pFound = pCopy ;
            grabAnnotatedS* pCopy = (grabAnnotatedS*)st_pGrabP.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( st_pGrabP )
    ZE( grabAnnotatedS* , pFound ) ;
{
grabAnnotatedS* pCopyF( tinS& tinP , const countT serialP , stackC& st_pGrabP )

}
    return bOk ;

    }
        }
            if( bOk ) bOk = pTo->fingerprint == FINGERnEG_grabOldS && c2fs.c1 == FINGERnEG_grabOldS && pTo->serial == c2fs.c2 ;
            thirdC::dosReadProcessMemoryIF( tinP , (byteT*)&c2fs , sizeof c2fs , bOk , (voidT*)infoP.ip , infoP.osPid ) ;
            bOk = 0 ;
        {
        if( bOk )
        thirdC::dosReadProcessMemoryIF(     tinP , pbToP         , cbP         , bOk , (voidT*)infoP.ip , infoP.osPid ) ;
        count2S c2fs ;
        //CODE SYNC: 0030050 6a40104: serial      MUST BE AT OFFSET sizeof( countT )
        //CODE SYNC: 0030050 6a40104: fingerprint MUST BE AT OFFSET 0
    {
    else
    }
        if( pTo->fingerprint == FINGERnEG_grabOldS && pFrom->fingerprint == FINGERnEG_grabOldS && pTo->serial == pFrom->serial ) bOk = 1 ;
        etherP.memCopyF( tinP , pbToP , (byteT*)pFrom , cbP ) ;
        grabOldS* pFrom = (grabOldS*)(byteT*)ap_artmentOldC( tinP , infoP.ip ) ;
    {
    if( F(infoP.flags) & flGRABiNFOs_IDA )
    grabOldS* const pTo = (grabOldS*)pbToP ;
    ZE( boolT , bOk ) ;
{
boolT readProcessMemoryF( tinS& tinP , etherC& etherP , byteT* const pbToP , grabInfoS& infoP , const countT cbP )

}
    return 0 ;
    //U::for( countT off = 0 ; off < CgRABwANTmAX ; off ++ ) if( grabP.pOsTidWant[ off ] ) return 1 ;

    ( (countT&)swGrabTallyP ) ++ ;
    c3lifiP.c2 = grabP.idiFileCt ;
    c3lifiP.c1 = grabP.idLineCt ;
{
inline boolT bWantedF( grabOldS& grabP , count3S& c3lifiP , switchC& swGrabTallyP )

}
    return idPhase ;
    if( tinP.fingerprint ) ;
{
countT cellC::classIdPhaseF( tinS& tinP )

}
    SLEEPwHILE( cFirePending ) ;
    }
        }
            ether.osThreadF( tinP , countTC() , tmFireCellF , 0 , flTHREADlAUNCH_null , 0 , (countT)&cFirePending , (countT)pc ) ;
            cFirePending ++ ;
        {
        if( pc )
        stCellCopy >> (countT&)pc ;
        ZE( cellC* , pc ) ;
    {
    while( stCellCopy )
    ZE( countT , cFirePending ) ;

    pStCell->ungrabF( tinP ) ;
    }
        while( ~hDown && !stCell.third ) ;
        }
            }
                if( !stCellCopy.third ) pc->refF() ;
                stCellCopy << (countT)pc ;
            {
            if( pc )
            cellC* pc = (cellC*)stCell.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stCell )
    stackC& stCell = *pStCell ;
    pStCell->grabF( tinP , TAG( TAGiDnULL ) ) ;
    stackC stCellCopy( tinP , ether , TAG( TAGiDnULL ) ) ;
    etherC& ether = *pEtClass ;

    if( !bEnabled ) BLAMMO ;
{
voidT cellC::classFireAllF( tinS& tinP )

}
    _deleteMyselfF( tinP ) ;

    sgnDone_tmHandleEvents.waitF( tinP ) ; //CANNOT DELETE THE THREAD POOLoLD UNTIL ALL EVENTS ARE HANDLED

    countT idc = idCell ;
    }
        fifoEvent << (countT)0 ;
        //THREADmODE1rESTORE
        }
            if( bEnded ) break ;
CONoUTrAW( "0" ) ; //U::
            ((thirdC&)ether).dosContinueMonitoringF( tinP , osTidEvent , osPidEvent , idCmd ) ;
CONoUTrAW( "1" ) ; //U::

            }
                fifoEvent << (countT)pEvent ;
                __Z( pEvent ) ;
                eventC* pEvent = new( 0 , tinP , LF ) eventC( tinP , *this , pInfo ) ; ___( pEvent ) ;

                //cellC::pWindowTitle->writeF( tinP ) ; //INFO MIGHT BE INCONSISTENT; NO SERIALIZATION IS DONE BECAUSE WE DON'T WANT DEADLOCKING POTENTIAL
                inc02AM( cellC::pWindowTitle->cEvents ) ;
                inc02AM( cellC::pWindowTitle->cEventsPending ) ;
            {
            else
            }
                DEL( (ifcMonitorEventS*&)pInfo ) ;
            {
            if( !bWant )

            boolT bEnded = osPid == pInfo->osPid && idEvent == ifcIDeVENTmONITORED_EXITpROCESS ;

            ;
                : ifcIDcMDmoNITOR_DOhANDLERS
                ? ifcIDcMDmoNITOR_SKIPhANDLERS
                idEvent == ifcIDeVENTmONITORED_SAY
                ( idEvent == ifcIDeVENTmONITORED_EXCEPTION && idException == ifcIDeVENTeXCEPTIONmONITORED_BREAKPOINT ) ||
            countT idCmd =
            countT osPidEvent = pInfo->osPid ;
            countT osTidEvent = pInfo->osTid ;
            countT idException = pInfo->idException ;
            countT idEvent = pInfo->idEvent ;

            }
                }
                    }
                        break ;
                        __1
                        __( pInfo->idEvent ) ;
                    {
                    default :
                    }
                        break ;
    
                        }
                            b_pv_handoffOld.ungrabF( tinP ) ;
                            }
                                THREADmODE1rESTORE
                                }
                                    THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
                                    }
                                        }
                                            __Z( bOk ) ;
                                            thirdC::dosWriteProcessMemoryIF( tinP , bOk , (voidT*)( (byteT*)pv_handoffOld + ( (byteT*)&copy.osPid[ off01 ]    - (byteT*)&copy ) ) , osPid , (byteT*)&vv , sizeof vv ) ;
                                            vv = 0 ;
                                            bOk = 0 ;
                                
                                            __Z( bOk ) ;
                                            thirdC::dosWriteProcessMemoryIF( tinP , bOk , (voidT*)( (byteT*)pv_handoffOld + ( (byteT*)&copy.idPhase[ off01 ]  - (byteT*)&copy ) ) , osPid , (byteT*)&vv , sizeof vv ) ;
                                            vv = ifcIDpHASEhANDOFFoLD_GONE ;
                                            bOk = 0 ;
                                
                                            __Z( bOk ) ;
                                            thirdC::dosWriteProcessMemoryIF( tinP , bOk , (voidT*)( (byteT*)pv_handoffOld + ( (byteT*)copy.postState[ off01 ] - (byteT*)&copy ) ) , osPid , (byteT*)&vv , 1 ) ;
                                
                                            ZE( countT , vv ) ;
                                            ZE( boolT , bOk ) ;
                                        {
                                        if( bValid )
                                        //U::else
                                        //U::if( !bValid ) __1
                                
                                        }
                                            }
                                                off01 = copy.osPid[ 1 ] == osPid ;
                                                bValid = 1 ;
                                            {
                                            if( bOk && ( copy.osPid[ 0 ] == osPid || copy.osPid[ 1 ] == osPid ) )
                                            //U::THIS SOMETIMES FAILS: __Z( bOk ) ;
                                            thirdC::dosReadProcessMemoryIF( tinP , (byteT*)&copy , sizeof copy , bOk , pv_handoffOld , osPid ) ;
                                            ZE( boolT , bOk ) ;
                                        {
                                        ZE( boolT , bValid ) ;
                                    {
                                    THREADmODE1rESTORE
                                    handoffOldS& copy = *(handoffOldS*)pbCopy ;
                                    byteT pbCopy[ sizeof( handoffOldS ) ] ;
                                {
                                THREADmODE1oFF( flTHREADmODE1_DISALLOWtELLmONITOR )
                                ZE( countT , off01 ) ;
                            {
                            if( pv_handoffOld )
                            b_pv_handoffOld.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( osPid == pInfo->osPid ) //WILL BE FALSE IF THE ENDING PROCESS WAS LAUNCHED BY THE CELL
                        //THIS CANNOT WAIT CAUSE PROCESS IS ABOUT TO GO AWAY
                    {
                    case ifcIDeVENTmONITORED_EXITpROCESS :
                    }
                        break ;
                        bWant = 0 ;
                    {
                    case ifcIDeVENTmONITORED_RIP           :
                    case ifcIDeVENTmONITORED_UNLOADdLL     :
                    case ifcIDeVENTmONITORED_LOADdLL       :
                    }
                        break ;
                        }
                            countT foo = 2 ;
                        {
                        if( pInfo->idException != ifcIDeVENTeXCEPTIONmONITORED_BREAKPOINT )
                    {
                    case ifcIDeVENTmONITORED_EXCEPTION :
                    }
                        break ;
                    {
                    case ifcIDeVENTmONITORED_CREATEpROCESS :
                    case ifcIDeVENTmONITORED_EXITtHREAD    :
                    case ifcIDeVENTmONITORED_CREATEtHREAD  :
                    case ifcIDeVENTmONITORED_SAY           : //PUT THE MOST COMMON idEvent VALUES WO'TH, FOR SPEED
                {
                switch( pInfo->idEvent )
                bWant = 1 ;
            {
            if( osPid == pInfo->osPid )
            ZE( boolT , bWant ) ;

            if( !pInfo ) break ;
            __Z( pInfo ) ;
CONoUTrAW( "2" ) ; //U::
            ((thirdC&)ether).dosWaitForMonitorEventF( tinP , (ifcMonitorEventS*&)pInfo , - 1 ) ; ___( pInfo ) ;
            ZE( const ifcMonitorEventS* , pInfo ) ;
        {
        while( !ether ) //IF ether THEN MY THREAD WILL END, WHICH WILL CAUSE THE PROCESS TO BE TERMINATED (POSSIBLY DIRTILY)
        //THREADmODE1oN( flTHREADmODE1_DISALLOWtELLmONITOR | flTHREADmODE1_DISALLOWgRABoFiNTERPROCESSgRABs )

        }
            else __1        
            else if( psttExe ) ether.osProcessF( tinP , osTidMain , osPid , psttExe , psttArgs , flPROCESShIRE_MONITORED ) ;
            }
                else                                                                __1        
                else if( !ether.strCompareF( tinP , T("graphics") , psttDisplay ) ) ether.osSessionF( tinP , osTidMain , osPid , idAdam  , psttArgs , 0 , 0 , 0 , 0 , flSESSION_MONITORED                             ) ;
                else if( !ether.strCompareF( tinP , T("text"    ) , psttDisplay ) ) ether.osProcessF( tinP , osTidMain , osPid , idAdam  , psttArgs                 , flPROCESShIRE_MONITORED | flPROCESShIRE_VISIBLE ) ;
                     if( !ether.strCompareF( tinP , T("none"    ) , psttDisplay ) ) ether.osProcessF( tinP , osTidMain , osPid , idAdam  , psttArgs                 , flPROCESShIRE_MONITORED                         ) ;
                ether.strokeF( tinP , T("cell: ")+TF1(idAdam)+T(" \"")+T(psttArgs)+T("\"\r\n") ) ; //U::
            {
            if( idAdam )
        {
        ZE( countT , osTidMain ) ;
        _IO_
    {
    if( !pEtClass ) BLAMMO ;
    //ether.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;
    etherC& ether = etThreadP ; //THIS HIDES this->ether SO THAT I USE THE THREAD'S UNSERIALIZED POOLoLD
{
cellC::_liveF( tinS& tinP , etherC& etThreadP )

*/
  base monitor wants to grab X in order to handle event M
  cell monitor has an event M while handling event E
  cell grabs X and has an event E
 scenario
synchronous event handling creates a deadlock possibility
with wo exception, i do not do any synchronous event handling
i capture event info and place it onto a stack
/*

}
    }
        }
            _deleteMyselfF( tinP ) ;
            fifoEvent << (countT)0 ;
            countT idc = idCell ;
        {
        else
        if( bEnableNew && !ether ) LIFEdEFcT( cellC )
    {
    if( !bSelf )

    }
        if( !ids ) BLAMMO ;
        pStCell->sinkF( tinP , ids , (countT)this , flSTACKsINK_UNIQUE , subtract_cellC_F ) ;
        ZE( countT , ids ) ;
    {
    cExist ++ ;

    pBatonClass->ungrabF( tinP ) ;
    (countT&)idCell = bBase ? -- idCellLath : ++ idCellLath ;
    pBatonClass->grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        }
            ether.osSleepF( tinP , TUCK * 0x40 ) ;
            ++ s ;
        {
        while( !ether && !bEnabled )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {

    }
        if( psttArgsP ) { psttArgs = psttOldC( tinP , ether , psttArgsP ) ; ___( psttArgs ) ; }
    {
    else if( psttExe )
    }
        }
            }
                ether.strMakeF( tinP , psttDisplay , T(info.psttDirectivesReplied) ) ; ___( psttDisplay ) ;
                if( pPeekF ) (*pPeekF)( &info ) ;
                peekS info( tinP , ether , T("!display") ) ;
            {
            }
                ether.strMakeF( tinP , psttTitle , T(info.psttDirectivesReplied) ) ; ___( psttTitle ) ;
                if( pPeekF ) (*pPeekF)( &info ) ;
                peekS info( tinP , ether , T("!title") ) ;
            {
            __Z( pPeekF ) ;
            ether.dllEntryF( tinP , pPeekF , hDllAdam , T("peekF") ) ;
            ZE( peekFT , pPeekF ) ;
        {
        ether.dllOpenF( tinP , hDllAdam , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/")+TF1(idAdam)+T(".ipdos-wd") ) ;
        ether.strMakeF( tinP , psttArgs , T(psttArgsP?"!monitored ":"!monitored")+T(psttArgsP) ) ; ___( psttArgs ) ;
    {
    else if( idAdam )
    if( bSelf ) ; //I AM DOING SELF MONITORING (MONITORING EVENTS ORIGINATING FROM CALLS TO thirdC::DosTellMonitorF BY THE PROCESS THAT CONTAINS ME

    ether.osThreadF( tinP , countTC() , tmHandleEventsF , &sgnDone_tmHandleEvents , flTHREADlAUNCH_null , 0 , (countT)this ) ;

    _IO_
{
voidT cellC::ctF( tinS& tinP , const strokeS* const psttArgsP )

DONE( tmHandleEventsF )
//etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_DISABLE ) ; //U::
}
    }
        THREADmODE1rESTORE
        }
            //cellC::pWindowTitle->writeF( tinP ) ; //INFO MIGHT BE INCONSISTENT; NO SERIALIZATION IS DONE BECAUSE WE DON'T WANT DEADLOCKING POTENTIAL
            dec02AM( cellC::pWindowTitle->cEventsPending ) ;
            DEL( pe ) ;
            pe->handleF( tinP ) ;

            }
                break ;
                __( cell.fifoEvent ) ;
            {
            if( !pe )
            cell.fifoEvent >> (countT&)pe ;
        {
        for(;;)
        ZE( eventC* , pe ) ;
        THREADmODE1oN( flTHREADmODE1_DISALLOWtELLmONITOR )  //REASON 1: SELF MONITORING; REASON 2: SPEED OF BASE MONITOR
    {
    ZE( boolT , bQuit ) ;
    cellC& cell = *(cellC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
//etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;
//etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_ENABLE ) ; //U::
TASK( tmHandleEventsF )

}
    ctF( tinP , psttArgsP ) ; //CAN DELETE *this
    _IO_
{
cDebug2( 0 )
cDebug1( 0 ) ,
bError( 0 ) ,
idEventLast( 0 ) ,
cRef( 0 ) ,
bQuitting( 0 ) ,
pTincMainImage( 0 ) ,
sgnDone_tmHandleEvents( tinP , TAG( TAGiDnULL ) ) ,
fifoEvent( tinP ) ,
stOsPidInEvent(   tinP , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE ) , //NOT SERIALIZED CAUSE OTHERWISE GET INFINITE RECURSION IN grabF
stOsPidMonitored( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , 2 * sizeof( countT ) ) , //NOT SERIALIZED CAUSE OTHERWISE GET INFINITE RECURSION IN grabF
stTinc( tinP , ether , TAG( TAGiDnULL ) ) ,
cHandle( 0 ) ,
swHandle( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , leverHandle , 3 * sizeof( countT ) ) ,
leverHandle( 0 ) ,
b_pv_handoffOld( tinP , TAG( TAGiDnULL ) ) ,
pv_handoffOld( 0 ) ,
b_pv_bFired( tinP , TAG( TAGiDnULL ) ) ,
pv_bFired( 0 ) ,
b_pv_cHeartBeat( tinP , TAG( TAGiDnULL ) ) ,
pv_cHeartBeat( 0 ) ,
stProcess( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ,
psttDisplay( 0 ) ,
psttTitle( idAdamP ? (strokeS*)0 : (strokeS*)psttOldC( tinP , ether , T("IdeaFarm " "(tm) Operating System Base Monitor") ) ) ,
hDllAdam( TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DLL ) ,
psttArgs( 0 ) ,
osPid( idAdamP ? 0 : dosGetInfoBlocksIdProcessIF( tinP ) ) ,
psttExe( 0 ) ,
bSelf( !idAdamP ) ,
idAdam( idAdamP ? idAdamP : DDNUMB ) ,
idCell( 0 ) ,
ether( tinP , TAG( TAGiDnULL ) , poolOld ) ,
poolOld( tinP , TAG( TAGiDnULL ) , TF1(DDNUMB)+T(".cellC.")+TF1(idAdamP)+T(".")+TF1((countT)this) , CBpOOLoLDcELL ) ,
cellC::cellC( tinS& tinP , const countT idAdamP , const strokeS* const psttArgsP ) :
//IF !idAdamP THEN THE OBJECT WILL MONITOR THE PROCESS THAT CONTAINS IT

}
    ctF( tinP , psttArgsP ) ; //CAN DELETE *this
    ___( psttExe ) ;
    _IO_
{
cDebug2( 0 )
cDebug1( 0 ) ,
bError( 0 ) ,
idEventLast( 0 ) ,
cRef( 0 ) ,
bQuitting( 0 ) ,
pTincMainImage( 0 ) ,
sgnDone_tmHandleEvents( tinP , TAG( TAGiDnULL ) ) ,
fifoEvent( tinP ) ,
stOsPidInEvent(   tinP , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE ) , //NOT SERIALIZED CAUSE OTHERWISE GET INFINITE RECURSION IN grabF
stOsPidMonitored( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , 2 * sizeof( countT ) ) , //NOT SERIALIZED CAUSE OTHERWISE GET INFINITE RECURSION IN grabF
stTinc( tinP , ether , TAG( TAGiDnULL ) ) ,
cHandle( 0 ) ,
swHandle( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , leverHandle , 3 * sizeof( countT ) ) ,
leverHandle( 0 ) ,
b_pv_handoffOld( tinP , TAG( TAGiDnULL ) ) ,
pv_handoffOld( 0 ) ,
b_pv_bFired( tinP , TAG( TAGiDnULL ) ) ,
pv_bFired( 0 ) ,
b_pv_cHeartBeat( tinP , TAG( TAGiDnULL ) ) ,
pv_cHeartBeat( 0 ) ,
stProcess( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ,
psttDisplay( 0 ) ,
psttTitle( 0 ) ,
hDllAdam( TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DLL ) ,
psttArgs( 0 ) ,
osPid( 0 ) ,
psttExe( psttOldC( tinP , ether , psttExeP ) ) ,
bSelf( 0 ) ,
idAdam( 0 ) ,
idCell( 0 ) ,
ether( tinP , TAG( TAGiDnULL ) ) ,
poolOld( tinP , TAG( TAGiDnULL ) , TF1(DDNUMB)+T(".cellC.")+T(psttExeP)+T(".")+TF1((countT)this) , CBpOOLoLDcELL ) ,
cellC::cellC( tinS& tinP , const strokeS* const psttExeP , const strokeS* const psttArgsP ) :

}
if( idAdam == 0x401044d ) dec02AM( bInspector ) ; //U::
    cExist -- ;

    stTinc.ungrabF( tinP ) ;
    DEL( pTincMainImage ) ; // MIGHT BE NONZE IF IMPOTENCE OCCURS THAT CAUSES _liveF LOOP TO EXIT
    }
        DEL( pt ) ;
        stTinc >> (countT&)pt ;
        ZE( tinC* , pt ) ;
    {
    while( stTinc )
    stTinc.grabF( tinP , TAG( TAGiDnULL ) ) ;
    ether = 0 ; //TO PREVENT: ether -> stTinc PLATES NOT DELETED -> 6a4 WON'T QUIT BECAUSE thirdC OBJECTS EXIST

    stProcess.ungrabF( tinP ) ;
    }
        DEL( pp ) ;
        stProcess >> (countT&)pp ;
        ZE( processC* , pp ) ;
    {
    while( stProcess )
    stProcess.grabF( tinP , TAG( TAGiDnULL ) ) ; // EXAMPLE: THE processC OBJECT FOR THE deadman PROCESS LAUNCHED BY 2540104
    ether = 0 ; //TO PREVENT: ether -> stProcess PLATES NOT DELETED -> 6a4 WON'T QUIT BECAUSE thirdC OBJECTS EXIST

    ether.delF( tinP , psttExe ) ;
    ether.delF( tinP , psttArgs ) ;
    ether.delF( tinP , psttTitle ) ;
    ether.delF( tinP , psttDisplay ) ;

    SLEEPwHILErEF

    pStCell->ungrabF( tinP ) ;
    else                                                BLAMMO ;
    if( (*pStCell)( (countT)this , subtract_cellC_F ) ) pStCell->extractF( tinP ) ;
    pStCell->grabF( tinP , TAG( TAGiDnULL ) ) ;
    ether = 0 ; //TO PREVENT: ether -> stProcess PLATES NOT DELETED -> 6a4 WON'T QUIT BECAUSE thirdC OBJECTS EXIST

    sgnDone_tmHandleEvents.waitF( tinP ) ;
    if( bSelf ) fifoEvent << (countT)0 ;

    _IO_

    if( !pEtClass ) BLAMMO ;
    TINSL
{
cellC::~cellC( voidT )

NEWdELcLASSb( cellC )

LIFEdEFoUT( cellC )

//---- 6: CLASS MEMBER DEFINITIONS ----------------------------------------------------------------------------------------------------------

boolT    cellC::bBase ;
strokeS* cellC::psttRpt ;
strokeS* cellC::psttLog ;
countT   cellC::serialLath ;
countT   cellC::idCellLath ;
countT   cellC::idDisplayFresh ;
countT   cellC::idPhase ;
countT   cellC::cExist ;
boolT    cellC::bEnableNew = 1 ;
boolT    cellC::bEnabled ;
windowTitleS* cellC::pWindowTitle ;
cellC*   cellC::pCellSelf ;
switchStackC* cellC::pSwsGrabInfo ;
countT   cellC::lSerial ;
countT   cellC::cAboutToGrab_lSerial ;
batonC*  cellC::pBaton_lSerial ;
stackC*  cellC::pStCell ;
batonC*  cellC::pBatonSerial ;
batonC*  cellC::pBatonLog ;
batonC*  cellC::pBatonClass ;
etherC*  cellC::pEtClass ;

boolT bInspector ; //U::


//---- 5: CLASS STATIC ALLOCATIONS -------------------------------------------------------------------------------------------------

;
}
    voidT writeF( tinS& tinP ) ;
    windowTitleS( tinS& tinP , etherC& etherP ) ;

    countT          cEvents ;
    countT          cEventsPending ;
    etherC&         ether ;
{
struct windowTitleS

;
}
    friend tinS* const cellC::pTinRawF( tinS& tinP , countT*& pcRefP , const ifcMonitorEventS& infoP ) ;
    friend countT  subtract_tinC_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P ) ;

    boolT           bIsF( tinS& tinP , const osTextT* const postThreadNameP ) ;
    voidT           freshIfF( tinS& tinP ) ;
                    tinC( tinS& tinP , saidS& saidP , const ifcMonitorEventS* pInfoP = 0 ) ;
                    ~tinC( voidT ) ;
                    NEWdELcLASSpROTOS( tinC , etherC , thirdC )

    osTextT         postThreadName[ COSTmAXtHREADnAME + 1 ] ; //STROKES NOT USED FOR SEED AND DEBUGGING EASE
    countT          idThread ;
    countT          idTin ;
    const countT    osPid ;
    const countT    osTid ;

    public :

    countT          cRef_pbTin ;
    const boolT     bCopy_pbTin ;
    byteT*          pbTin ; //RAW COPY; DO NOT USE POINTER FIELDS
    voidT* const    pvOrIda ;
    const boolT     bSelf ;
    etherC          ether ;
{
class tinC

;
}
    friend countT   subtract_processC_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P ) ;

    boolT           operator ==( const cP ) const ;
                    processC( tinS& tinP , const ifcMonitorEventS& infoP ) ;
                    NEWdELcLASSpROTOS( processC , etherC , thirdC )

    public :

    countT          osPid ;
    countT          osTid ;
    etherC          ether ;
{
class processC

;
}
    timeS           time ; //U::WHEN THIS IS SET, IT WILL NEED TO BE EXCLUDED FROM SINK AND FIND
    flagsT          flags ;
    countT          idiFileCt ;
    countT          idLineCt ;
    countT          ip ;
    countT          osPid ;
{
struct grabInfoS

;
}
    voidT                   handleF( tinS& tinP ) ;
                            eventC( tinS& tinP , cellC& cellP , const byteT* const pbP , const countT cbP ) ;
                            eventC( tinS& tinP , cellC& cellP , const ifcMonitorEventS*& pInfoP ) ;
                            ~eventC( voidT ) ;
                            NEWdELcLASSpROTOS( eventC , etherC , thirdC )

                            public :

    voidT                   hearF( tinS& tinP , boolT& bLogTinEventP ) ;

    saidS                   said ;
    const ifcMonitorEventS* pInfo ;
    cellC&                  cell ;
    etherC&                 ether ;
    countT                  idEvent ;
    countT                  osIdEvent ;
{
class eventC

;
}
            saidS( tinS& tinP , etherC& etherP , const byteT* const pbP , const countT cbP ) ;
            saidS( tinS& tinP , etherC& etherP , const ifcMonitorEventS& infoP ) ;
            ~saidS( voidT ) ;

            const byteT* const  pbData ;
            const countT        cbData ;
            const countT        idType ;
            const flagsT        flags ;
            const countT        osPid ;
            const countT        osTid ;
{
struct saidS

;
}
    friend boolT    monitoredEventHandlerF( tinS& tinP , const byteT* const pbP , const countT cbP , countT cP ) ;
    friend class    eventC ;
    friend TASKpROTO( tmHandleEventsF ) ;
    friend TASKpROTO( tmFireCellF ) ;
    friend countT   subtract_cellC_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P ) ;

    static voidT    classSerialNumberF( tinS& tinP , countT& wothP , countT& lathP , const countT cWantP ) ;
    static countT   classSerialNumberF( tinS& tinP ) ;
    static voidT    classLogF( tinS& tinP , const strokeS* const psttP , const tinS* const pTinEventRawP = 0 , const ifcMonitorEventS* const pInfoP = 0 ) ;
    static countT   classIdPhaseF( tinS& tinP ) ;
    static voidT    classInspectF( tinS& tinP , stackC& stCellCopyP , etherC& etPrimeP , stackC& st_pGrabP , stackC& stOsTidAllWanterP , stackC& stOsTidWanterP , stackC& stOsTidWanterInLoopP , stackC& stOsTidWanterInLoopUniqueP , stackC& stThreadsP , count3S& c3lifiP , switchC& swGrabTallyP ) ;
    static countT   classQuery_cHandle_F( tinS& tinP ) ;
    static voidT    classFireAllF( tinS& tinP ) ;
    static voidT    classShutdown2F( tinS& tinP ) ;
    static voidT    classShutdown1F( tinS& tinP , countT& idCellLathP , countT& serialLathP ) ;
    static voidT    classSetupF( tinS& tinP , const countT idCellLathP , const countT serialLathP , const boolT bBaseP , windowTitleS& windowTitleP ) ;
                    cellC( tinS& tinP , const strokeS* const psttExeP , const strokeS* const psttArgsP = 0 ) ;
                    cellC( tinS& tinP , const countT idAdamP = 0 , const strokeS* const psttArgsP = 0 ) ;
                    NEWdELcLASSpROTOS( cellC , etherC , thirdC ) //NEVER STORE A POINTER TO A cellC OBJECT; THE cellC OBJECT DESTROYS ITSELF VOLATILELY
                    LIFEpROTO
                    //WHEN INSERTING FUNCTION PROTOTYPES, PUT THEM BELOW, IN THE PRIVATE SECTION
                    //EXTERNAL CODE IS ONLY ALLOWED TO CALL new OPERATOR AND THE class STATIC MEMBERS

    static windowTitleS* pWindowTitle ;

    public :

    inline voidT    unrefF( voidT ) { dec02AM( cRef ) ; }
    inline voidT    refF(   voidT ) { inc02AM( cRef ) ; }
    tinS* const     pTinRawF( tinS& tinP , countT*& pcRefP , const ifcMonitorEventS& infoP ) ; //RETURNS PTR TO RAW COPY; DO NOT USE PTR FIELDS
    voidT           fireF( tinS& tinP ) ;
    voidT           ctF( tinS& tinP , const strokeS* const psttArgsP ) ;
                    ~cellC( voidT ) ;

    countT          cDebug2 ;
    countT          cDebug1 ;
    boolT           bError ;
    countT          idEventLast ;
    signC           sgnDone_tmHandleEvents ;
    fifoC           fifoEvent ;
    stackC          stOsPidInEvent ;
    stackC          stOsPidMonitored ; //REDUNDANT; THIS INFO IS IN *pStCell; I EXIST FOR THE CONVENIENCE OF ::grabF
    countT          cRef ;
    boolT           bQuitting ;
    tinC*           pTincMainImage ;
    stackC          stTinc ;
    countT          cHandle ;
    switchC         swHandle ;
    countT          leverHandle ;
    batonC          b_pv_handoffOld ;
    voidT*          pv_handoffOld ;
    batonC          b_pv_bFired ;
    voidT*          pv_bFired ;
    batonC          b_pv_cHeartBeat ;
    voidT*          pv_cHeartBeat ;
    stackC          stProcess ;
    strokeS*        psttDisplay ;
    strokeS*        psttTitle ;
    handleC         hDllAdam ;
    strokeS*        psttArgs ;
    countT          osPid ;
    strokeS*        psttExe ;
    const boolT     bSelf ;
    const countT    idAdam ;
    const countT    idCell ;
    etherC          ether ;
    p oolC           poolOld ;

    static cellC*   pCellSelf ;
    static switchStackC* pSwsGrabInfo ;
    static countT   lSerial ;
    static countT   cAboutToGrab_lSerial ;
    static batonC*  pBaton_lSerial ;
    static boolT    bBase ;
    static strokeS* psttRpt ;
    static strokeS* psttLog ;
    static countT   serialLath ;
    static countT   idCellLath ;
    static countT   idDisplayFresh ;
    static countT   idPhase ;
    static countT   cExist ;
    static boolT    bEnableNew ;
    static boolT    bEnabled ; // IF TRUE THEN THE CLASS IS COMPLETELY SET UP SO CAN BE USED
    static stackC*  pStCell ;
    static batonC*  pBatonSerial ;
    static batonC*  pBatonLog ;
    static batonC*  pBatonClass ;
    static etherC*  pEtClass ; // USED BY STATIC MEMBER FUNCTIONS
{
class cellC

;
}
    boolT bLockedF( tinS& tinP ) const ;
    operator countT( voidT ) ;
    fifoC& operator >>( countT& cP ) ;//ASSUME: CALLED ONLY BY A SINGLE THREAD B (B AND A CAN BE THE SAME THREAD)
    fifoC& operator <<( countT cP ) ; //ASSUME: CALLED ONLY BY A SINGLE THREAD A
    fifoC( tinS& tinP ) ;

    public :

    boolT  bLocked ;
    countT cHave ;
    countT offGetNext ;
    countT offPutNext ;
    countT pcStore[ FIFOcAPACITY ] ;
{
class fifoC
//U::PARAMETERIZE THIS CLASS AND THEN MOVE IT INTO BASE

class windowTitleS ;

//---- 4: CLASS DEFINITIONS ---------------------------------------------------------------------------------------------------------


class tinC ;
struct saidS ;
TASKpROTO( tmFireCellF ) ;
TASK0PROTO( tmFireCellF ) ;
TASK0PROTO( tmFireMyselfF ) ;
countT subtract_tinC_F(     tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P ) ;
countT subtract_processC_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P ) ;
countT subtract_count4S_F(  tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P ) ;
countT subtract_cellC_F(    tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P ) ;
boolT monitoredEventHandlerF( tinS& tinP , const byteT* const pbP , const countT cbP , countT cP ) ;

//---- 3: PROTOTYPES ------------------------------------------------------------------------------------------------------------------

#define NEWcELL(etherP,idAdamP,psttArgsP) { cellC* pCell = new( 0 , tinP , LF ) cellC( tinP , idAdamP , psttArgsP ) ; ___( pCell ) ; }
#define LEAKiNSPECTOR(etherP) NEWcELL( etherP , ifcIDaDAMoLD_POOLoLDlEAKiNSPECTOR , T(" !inspect a340104") ) ;
//#define LEAKiNSPECTOR(etherP) NEWcELL( etherP , ifcIDaDAMoLD_POOLoLDlEAKiNSPECTOR , T("!inspect 6a40104.monitored") )
#define FIFOcAPACITY 0x10000

#define flWANTER_WANTSpSEUDO                0xe00002fe
#define flWANTER_INSPECTIONsTARTED          0xe00001fe
#define flWANTER_null                       0xe00000fe

#define flGRABiNFOs_TIMEsTAMPED             0xe00004ff
#define flGRABiNFOs_IDA                     0xe00002ff
#define flGRABiNFOs_CT                      0xe00001ff
#define flGRABiNFOs_null                    0xe00000ff

}
    CONoUT2( postP , info ) ;                                                                           \
    ((p oolC&)cell.ether).walkF( tinP , ifcIDtYPEpOOLoLDwALK_COUNTwOtYPE , info ) ;                         \
    countT info = ifciDtYPEdROPnOTE_tinS ;                                                              \
{                                                                                                       \
if( cell.idAdam == 0x4010418 )                                                                          \
                                                                                                        \
#define COUNTtIN2(postP)                                                                                \

}
    CONoUT2( postP , info ) ;                                                                           \
    (>>>>(p oolC&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<her).walkF( tinP , ifcIDtYPEpOOLoLDwALK_COUNTwOtYPE , info ) ;                              \
    countT info = ifciDtYPEdROPnOTE_tinS ;                                                              \
{                                                                                                       \
if( idAdam == 0x4010418 )                                                                               \
                                                                                                        \
#define COUNTtIN(postP)                                                                                 \

#define CBpOOLoLDcELL 0x1000004

//---- 2: MACROS AND SYMBOLS -------------------------------------------------------------------------------------------------------


}
{
stateC( tinP , etherP , sizeof *this , 0 , translateStateF , 0 , psttSuffixP )
stateS::stateS( tinS& tinP , etherC& etherP , const strokeS* const psttSuffixP ) :
TRANSLATEsTATE_END
( state.idChatLath = state.idChatLath ) ;
( state.serialLath   = state.serialLath   ) ;
( state.idCellLath = state.idCellLath ) ;
STATEpART3
state.idChatLath = stateOther.idChatLath ;
state.serialLath   = stateOther.serialLath   ;
state.idCellLath = stateOther.idCellLath ;
state.idMe = stateOther.idMe ;
{
case 1 :
TRANSLATEsTATE_BEGIN( stateS , 1 )
;
}
stateS( tinS& tinP , etherC& etherP , const strokeS* const psttSuffixP = 0 ) ;
countT idChatLath ;
countT serialLath ;
countT idCellLath ;
STATEpART1
//STATE2 COULD BE USED IF I DIDN'T NEED TO SPECIFY psttSuffix IN ORDER TO HAVE 2 CELLS ON THE SAME HOST)

//---- 1: STATE --------------------------------------------------------------------------------------------------------------------------------------------------

#define TaRG1_OSmONITOR T("!quitAtShutdown !ignoreFireByOperator !poolOldRootNoClientRights")
#undef  TaRG1_OSmONITOR
//---- 0: WORKBENCH --------------------------------------------------------------------------------------------------------------------------------------------------


*/

    when traversing, either do all work, or call pCell->refF(), while *pStCell is grabbed
    the only legal way to obtain a cellC pointer is to traverse *pStCell
    it is illegal to store a cellC pointer returned by the new operator
    it is illegal for code other than within cellC definitions to store a cellC pointer
    cellC: this is a self destructing class; each object is responsible for destructing itself

    Code notes:

/*

// OBSOLETES 3140104

/*1*/WAKEhIDE( "os.monitor" )/*1*/
/**/
*/
 for example, it is not notified that it raised an access violation exception
base monitor self monitoring is abridged in that it does not receive notification of some events
the "base monitor" instance also monitors itself
the "cell monitor" instance of me creates and monitors all other cells (wo for each idAdam value present on the local host)
the "base monitor" instance of me creates and monitors the "cell monitor" instance of me
unlike most adams (idAdam values), oo instances of me exist on each host
it is my job to create all other IdeaFarm " "(tm) processes on the local host and to monitor those processes
i am the "kernel" of the IdeaFarm " "(tm) Operating System
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

