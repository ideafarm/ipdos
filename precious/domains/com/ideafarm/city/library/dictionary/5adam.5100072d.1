
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

//etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

#endif

THREADmODE1rESTORE
THREADmODE2rESTORE
}

    listC::deleteIF( tinP , pczName ) ;
    listC::chatterIF( tinP , pczName ) ;
    countT pczName[] = { LISTnAME_ROOT , 0 } ;
    //puseC puseUse( puseMaster ) ;

//#endif
    }
        break ; //U:: TO FIND A BUG

        PUSE( tinP , *(byteT**)&pczHash ) ;
        }
            }
                }
                    DELlIST( fieldEditParamOutC , pOut ) ;

                    SAYfIELDoUT( "\r\nyabba dabba doo!    " )

                    //puseC puseAT( tinP , ifcIDpOOL_ADAMtEMP ) ;

                    //{ puseC puseAT( tinP , ifcIDpOOL_ADAMtEMP ) ; etThread.traceF( tinP , T("queried  idJot") ) ; }
                    listC::fieldIF( tinP , pOut , hList , pczfIdJot , _1_queryC() , LF ) ; ___( pOut ) ;
                    //{ puseC puseAT( tinP , ifcIDpOOL_ADAMtEMP ) ; etThread.traceF( tinP , T("querying idJot") ) ; }
                    ZE( fieldEditParamOutC* , pOut ) ;

                    listC::openIF( tinP , hList , pczHash ) ;
                    handleC hList( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

                    grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
                {

                //puseC puseUse( puseMaster ) ;
            {

            etThread.traceF( tinP , T("[pczHash]:    ")+TF2(pczHash,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            etherC::strStretchIF( tinP , pczHash , count3S( LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION ) , pcHash[ offi ] ) ;
            pczHash[ offo ] = 0 ;
            for( offo = 0 ; offo < cczHash ; offo ++ ) pczHash[ offo ] = LISTnAME_PLACEhOLDER ;
            ZE( countT , offo ) ;
        {
        if( pczHash )
        PUSE.newF( tinP , LF , *(byteT**)&pczHash , sizeof( countT ) * ( cczHash + 1 ) ) ; ___( pczHash ) ;
        ZE( countT* , pczHash ) ;
        const countT cczHash = 4 + sizeof pcHash[ offi ] ;
    {
    for( countT offi = 0 ; offi < sizeof pcHash / sizeof pcHash[ 0 ] ; offi ++ )
//#if defined( NEVERdEFINED )

    }
        break ; //U:: TO FIND A BUG

        PUSE( tinP , *(byteT**)&pczHash ) ;
        }
            }
                }
                    }
                        break ; //U:: TO FIND A BUG

//#endif
                        DELlIST( fieldEditParamOutC , pOut ) ;
                        //puseC puseAT( tinP , ifcIDpOOL_ADAMtEMP ) ;
                        //{ puseC puseAT( tinP , ifcIDpOOL_ADAMtEMP ) ; etThread.traceF( tinP , T("registered  idJot") ) ; }
//#if defined( NEVERdEFINED )
                        listC::fieldIF( tinP , pOut , hList , pczfIdJot , _1_pushC( pcHash[ offi ] | ( jj << 0x10 ) ) + _1_modePushSinkC() , LF ) ; ___( pOut ) ;
                        //{ puseC puseAT( tinP , ifcIDpOOL_ADAMtEMP ) ; etThread.traceF( tinP , T("registering idJot") ) ; }

                        ZE( fieldEditParamOutC* , pOut ) ;
                    {
                    for( countT jj = 1 ; jj <= 4 ; jj ++ )

                    listC::openIF( tinP , hList , pczHash ) ;
                    handleC hList( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

                    grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
                {

                //puseC puseUse( puseMaster ) ;
            {

            etThread.traceF( tinP , T("[pczHash]:    ")+TF2(pczHash,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            etherC::strStretchIF( tinP , pczHash , count3S( LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION ) , pcHash[ offi ] ) ;
            pczHash[ offo ] = 0 ;
            for( offo = 0 ; offo < cczHash ; offo ++ ) pczHash[ offo ] = LISTnAME_PLACEhOLDER ;
            ZE( countT , offo ) ;
        {
        if( pczHash )
        PUSE.newF( tinP , LF , *(byteT**)&pczHash , sizeof( countT ) * ( cczHash + 1 ) ) ; ___( pczHash ) ;
        ZE( countT* , pczHash ) ;
        const countT cczHash = 4 + sizeof pcHash[ offi ] ;
    {
    for( countT offi = 0 ; offi < sizeof pcHash / sizeof pcHash[ 0 ] ; offi ++ )

    countT pcHash[] = { 0x10 , 0xf , 0xe , 0xd , 0xc , 0xb , 0xa , 0x9 , 0x8 , 0x7 , 0x6 , 0x5 , 0x4 , 0x3 , 0x2 , 0x1 } ;

    //puseC puseAT( tinP , ifcIDpOOL_ADAMtEMP ) ;

    listC::dictionaryReplaceOsTextIF( tinP , pczfIdJot ) ;
    countT pczfIdJot[] = { (countT)"idJot" , 0 } ;

    //puseC puseMaster( tinP , "list.rax.traffic.hash.to.idjot" , flPOOLc_DOnOTiNDEXdURINGcT , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) ) ;
{
THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

#if defined( NEVERdEFINED )

TODO



/*1*/WAKEsHOWtEXT( "was.scratch.8.archived.20180508@1202.scr" )/*1*/
/**/
*/
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

