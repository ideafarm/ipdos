
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            off -- ;
            else                      break ;
            if( postP[ off ] == '0' ) postP[ off ] = ostPadP ;
        {
        while( off > 0 )
        off = 2 * sizeof( countT ) - 1 ;
    {
    if( ostPadP != '0' )

    }
        postP[ off ++ ] = (osTextT)( digit < 0xa ? '0' + digit : 'a' + digit - 0xa ) ;
        valueP >>= 4 ;
        digit = valueP & 0xf ;
    {
    while( cToDo -- )
    ZE( countT , digit ) ;
    countT cToDo = 2 * sizeof( countT ) ;
    ZE( countT , off ) ;
{
/*1*/voidT thirdC::c_itoaIF( osTextT* const postP , countT valueP , const osTextT ostPadP )/*1*/

/**/
*/
 U:: it looks like this does unsigned representation
  high order '0' digits, excluding the units digit, will be replaced with this value
  can be 0
 ostPadP
 valueP
   the number will be in ifc format with high ze's
  will be set to base 16_ digits representing the unsigned value valueP
  caller should normally allocate 9 bytes, and initialize the 9th byte to 0
  must point to at least 8 bytes of storage
 postP
arguments
 it contains no overhead code
this function is optimized for speed
\<A HREF=\"5.10200a4.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$c_itoaIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

