
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    THREADmODE3rESTORE

    }
        }
            }
                while( stqIdBookCb ) { stqIdBookCb >> (byteT*)pcc ; pcc -= 2 ; }

                pcc += cBooks - 1 << 1 ;
                countT* pcc = pcpIdBookSizePairsP + 1 ;

                *pcpIdBookSizePairsP = cBooks ;
            {
            if( pcpIdBookSizePairsP )
            tinP.pEther->newF( tinP , LF , pcpIdBookSizePairsP , 1 + ( cBooks << 1 ) ) ; ___( pcpIdBookSizePairsP ) ;
        {
        if( cBooks )
        countT cBooks = stqIdBookCb ;

        while( ~hFind ) ;
        }
            DEL( pInfo ) ;
            }
                DEL( pLook ) ;
                tinP.pEther->delF( tinP , pcpIdLook ) ;
                }
                    //CONoUTrAW3( T("book: \"")+tName+T("\" [cbUsed]: ") , head.cbUsed , "\r\n" ) ;

                    stqIdBookCb << (byteT*)pc2 ;
                    countT pc2[] = { pcpIdLook[ 1 ] , head.cbUsed } ;

                    const bookHeadS& head = *pLook ;
                {
                if( pLook && pcpIdLook )

                THREADmODE3rESTORE
                THREADmODE1rESTORE ;
                bookC* pLook = new( 0 , tinP , LF ) bookC( tinP , TAG( TAGiDnULL ) , tName , idStateSpace , flBOOKc_null , 0 , bFill , idMemorySpace ) ; ___( pLook ) ;
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;
                THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )

                TN( tName , "" ) ; tName = T(postNameShort)+T(".booksC.1.book.")+tIdLook ;
        
                }
                    for( countT offi = *pcpIdLook ; offi ; offi -- ) tIdLook += tDot+TF3(pcpIdLook[offi],flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ;
                    TN( tDot , "." ) ;
                    tIdLook = TF3(*pcpIdLook,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ;
                {
                TN( tIdLook , "" ) ;

                tinP.pEther->delF( tinP , pstt1w ) ;
                }
                    }
                        else                       pco -- ;
                        if( pco == pcpIdLook ) pco = pcpIdLook + cWords - 1 ;
                        *pco = tinP.pEther->strDigitsToSCountF( tinP , psttc1 , 0 , 1 ) ;
                    {
                    FORsTRINGSiN1( pstt1w )

                    countT* pco = pcpIdLook ;
                {
                if( pcpIdLook )
                PUSE.newF( tinP , LF , *(byteT**)&pcpIdLook , sizeof( countT ) * cWords ) ; ___( pcpIdLook ) ;
                ZE( countT* , pcpIdLook ) ;

                tinP.pEther->delF( tinP , psttw ) ;
                countT cWords = tinP.pEther->strWordsOldF( tinP , pstt1w , psttw , sttq , tDot ) ; ___( pstt1w ) ;
                ZE( strokeS* , pstt1w ) ;

                tinP.pEther->strSubstringF( tinP , psttw , idf , sttq , tAfter , pInfo->psttIfoName ) ; ___( psttw ) ;
                tinP.pEther->delF( tinP , psttw ) ;
                tinP.pEther->strSubstringF( tinP , psttw , idf , sttq , tBefore , pInfo->psttIfoName ) ; ___( psttw ) ;
                countT idf = 1 ;
                ZE( strokeS* , psttw ) ;
            {
            if( pInfo && !( F(pInfo->flags) & flFILEaTTR_DIRECTORY ) )
            tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , fnLike.pathF() , &pat ) ; ___( pInfo ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

        patternC pat( tinP , *tinP.pEther , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        fileNameC fnLike( tinP , *tinP.pEther , psttFindLike ) ;
        TN( tDot , "." ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        TN( tAfter  , ".bookC" ) ;
        TN( tBefore , ".booksC.1.book." ) ;
        staqC stqIdBookCb( tinP , 2 * sizeof( countT ) , 0x20 ) ;
    {
    if( idStateSpace )

    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )

    _IO_

    }
        if( POOP ) return ;
        __NZ( pcpIdBookSizePairsP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT booksC::cbEachBookF( tinS& tinP , countT*& pcpIdBookSizePairsP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

