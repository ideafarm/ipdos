
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return *this ;

    _OUTbATONsTACKc_
    if( cPlates < *p_idCursor || ( *p_idCursor && !*p_ppCursor ) ) { BLAMMO ; } //U::

    }
        }
            if( pSgnEvent && F(flags) & flSTACKc_GIVEsIGNdELpLATE ) pSgnEvent->giveF( tinP ) ;
    
            else                           third.delF( tinP , (byteT*&)ppd ) ;
            if( F(flags) & flSTACKc_XRAY ) pXray->freeF( tinP ) ;

            }
                default : { valueP = PLATE_countT_REF( ppd ) ; break ; }
                }
                    break ;
    
                    third.c_memcpyIF( tinP , pbv , (byteT*)&cd , cbData ? cbData : sizeof( countT ) + cd ) ;
                    if( !pbv ) { third.newF( tinP , LF , pbv , cbData ? cbData : sizeof( countT ) + cd ) ; ___BITScT( pbv , 0xdf4 ) ; }
                    countT& cd = PLATE_countT_REF( ppd ) ;
                    byteT*& pbv = *(byteT**)&valueP ;
                {
                case ifcSTACKtYPE_BLOB             :    
                case ifcSTACKtYPE_timeS            : {            *(timeS*)valueP =            *(timeS*)PLATE_byteT_PTR(  ppd ) ; break ; }
                case ifcSTACKtYPE_nicNameC         : {         *(nicNameC*)valueP =         *(nicNameC*)PLATE_byteT_PTR(  ppd ) ; break ; }
            {
            switch( idType )
    
            newTabsIfF( tinP , ppd , 1 ) ;
    
            }
                ppBottom = 0 ;
                __( ppBottom != ppd ) ;
                __NZ( ppTop ) ;
            {
            if( !( -- cPlates ) )
    
            }
                ppTop->ppU = 0 ;
                //U::__( ppTop->ppU != ppd ) ;
                __( (plateS*)ppTop->ppU != ppd ) ;
            {
            if( ppTop )
            ppTop = ppTop->ppD ;
            plateS* ppd = ppTop ;

            adjustRefsF( tinP , 1 , ifcIDaCTIONsTACKaDJUSTrEFS_DELETED ) ;
        {
        else
        }
            }
                default                            : { valueP = randomF( tinP )                     ;         __( extractF( tinP , 0  ) - valueP )    ; break ; }
                case ifcSTACKtYPE_BLOB             : { randomF( tinP ,            (byteT*&)valueP ) ;             extractF( 0 , tinP , 0 )            ; break ; }
                case ifcSTACKtYPE_timeS            : { randomF( tinP ,            *(timeS*)valueP ) ;             extractF( 0 , tinP , 0 )            ; break ; }
                case ifcSTACKtYPE_nicNameC         : { randomF( tinP ,         *(nicNameC*)valueP ) ;             extractF( 0 , tinP , 0 )            ; break ; }
            {
            switch( idType )
        {
        if( F(flags) & flSTACKc_PULLrANDOMLY )
    {
    if( !POOP )
    __( ppTop->ppD && ppTop != ppTop->ppD->ppU ) ;
    __( !!ppTop->ppU ) ;
    __Z( ppTop ) ;

    LATHrEF

    }
        countT foo = 2 ;
    {
    if( idIn == 0xb )

    countT idIn = 1 + incv02AM( idInLath ) ;
    static countT idInLath ;

    if( cPlates < *p_idCursor || ( *p_idCursor && !*p_ppCursor ) ) { BLAMMO ; } //U::

    CURSOR
    _INbATONsTACKc_

    }
        if( third ) return *this ;
        }
            default                            : { __NZ( valueP ) ; break ; }
            case ifcSTACKtYPE_BLOB             : {                  break ; }
            case ifcSTACKtYPE_timeS            : { __Z(  valueP ) ; break ; }
            case ifcSTACKtYPE_nicNameC         :
        {
        switch( idType )
        if( third ) return *this ;
    {
    IFbEcAREFUL    

    SCOOP
    TINSL
{
/*1*/stackC& stackC::operator >> ( countT& valueP )/*1*/

/**/
*/
 this is not enforced
it is illegal for code other than stackC code to call me for idType ifcSTACKtYPE_nicNameC
   exception: if ifcSTACKtYPE_nicNameC then must contain the address of the nicNameC object that the value is to be assigned into
  must be 0
 valueP
arguments
if the item that this function removes was the most recently referenced item, it zees the "last reference cursor"
this function zees the internal cursor that is used to make operator [] speedy
evaluates to a reference to this stack object
removes the item that was most recently put onto the stack
  \<A HREF=\"5.0c10104.1.1.0.html\"\>0c10104:  WAKEsHOW( "example.simplest.func.1150008.stackC.operator_shiftRight" )\</A\>
 simplest
examples
\<A HREF=\"5.1150008.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

