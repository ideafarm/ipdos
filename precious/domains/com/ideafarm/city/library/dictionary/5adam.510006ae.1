
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    display.set_pDeviceCBF_F( tinP , pDeviceNewCBF , cArgNew , pDeviceOldCBF , cArgOld ) ;
    ZE( countT     , cArgNew       ) ;
    ZE( deviceCBFT , pDeviceNewCBF ) ;

    etherC::loafIF( tinP ) ;

    display.ungrabF( tinP ) ;

    display.set_pDeviceCBF_F( tinP , pDeviceOldCBF , cArgOld , deviceCBF , (countT)pcArg ) ;
    ZE( countT     , cArgOld       ) ;
    ZE( deviceCBFT , pDeviceOldCBF ) ;

    countT pcArg[] = { (countT)&paper , (countT)&paper , (countT)&paperBW , (countT)&surf , (countT)&eye } ;

    display += eye ;

    eye += surf ;

    }
        eye.moveF( tinP , vDeltaAt , aBad ) ;
        vectorOldC vDeltaAt( tinP , etThread ) ;
        }
            aBad = 0 ;
            //aBad = PI / 2.0 ;
            //aBad = etThread.strDigitsToMeasureF( tinP , tStr , 0 , 0 ) ;
            //TN( tStr , "100+^bf1291." ) ;
        {
        ZE( measureT , aBad ) ;
    {
    eyeC eye( tinP , etThread ) ;

    surf += paper ;
    surfC surf( tinP , etThread , 0 , surfaceCBF , (countT)&sin , 0 , 0 , flSURFc_NOsMOOTHIES ) ;
    surfS sin ;

    display.grabF( tinP , TAG( TAGiDnULL ) ) ;

    displayC& display = *pDisplay ;
{
if( pDisplay )
displayC* pDisplay = displayC::pDisplayIF() ;

}
    etThread.delF( tinP , psttSay ) ;
    paperBW.strokeF( tinP , psttSay ) ;

        }
            scSize += DELTA ;

            //APPENDcc( psttSay , sc_ccLINEpEL ,   scSize , - scSize ) ;
            //APPENDcc( psttSay , sc_ccLINEpEL ,   0      , - scSize ) ;
            //APPENDcc( psttSay , sc_ccLINEpEL , - scSize , - scSize ) ;
            //APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ;
            //APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   scSize ) ;
            //APPENDcc( psttSay , sc_ccLINEpEL ,   0      ,   scSize ) ;
            //APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   scSize ) ;
            APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;

            APPENDcc( psttSay , sc_ccMOVEpEL , - (sCountT)( DELTA >> 1 ) , - (sCountT)( DELTA >> 1 ) ) ;
        {
        while( cDo -- )
        sCountT scSize = SIZE ;
        APPENDmm( psttSay , sc_mmMOVEtO  , 0.5 , 0.5 ) ;
        countT cDo = 1 ;

    APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;
    APPENDcc( psttSay , sc_cPUSHiDgRID , 3 , 0 ) ;

    etThread.strMakeF( tinP , psttSay , 0 , TOCK ) ; ___( psttSay ) ;
    ZE( strokeS* , psttSay ) ;
{
paperC paperBW( tinP , etThread , TUCK , TUCK ) ;

}
    etThread.delF( tinP , psttSay ) ;
    paper.strokeF( tinP , psttSay ) ;

    #endif

        }
            scSize += DELTA ;

            #endif

                #endif

                    APPENDcc( psttSay , sc_ccLINEpEL ,   scSize , - scSize ) ;
                    APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_ORANGE , 0 ) ;
                    APPENDcc( psttSay , sc_ccLINEpEL ,   0      , - scSize ) ;
                    APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_BROWN , 0 ) ;

                #if !defined( CHEAT )

                APPENDcc( psttSay , sc_ccLINEpEL , - scSize , - scSize ) ;
                APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_C4 , 0 ) ;
                APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ;
                APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_P4 , 0 ) ;
                APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   scSize ) ;     //CAN DO 1 GLYPH OF 4 LINES
                APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_Y4 , 0 ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   0      ,   scSize ) ;
                APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_B4 , 0 ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   scSize ) ;
                APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_G4 , 0 ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;
                APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_R4 , 0 ) ;

            #else

                #endif

                    APPENDcc( psttSay , sc_ccLINEpEL ,   scSize , - scSize ) ;
                    APPENDcc( psttSay , sc_ccLINEpEL ,   0      , - scSize ) ;
                    APPENDcc( psttSay , sc_ccLINEpEL , - scSize , - scSize ) ;

                #if !defined( CHEAT )

                APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ;
                APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   scSize ) ;     //CAN DO 1 GLYPH OF 4 LINES
                APPENDcc( psttSay , sc_ccLINEpEL ,   0      ,   scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;

            #elif defined( MONOCHROME )

                APPENDcc( psttSay , sc_ccLINEpEL ,   0      , - scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   0      ,   scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;

            #elif defined( BOX )

                APPENDcc( psttSay , sc_ccLINEpEL , - scSize / 2 , - scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL , - scSize / 2 ,   scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;

            #elif defined( TRIANGLE )

                APPENDcc( psttSay , sc_ccLINEpEL , - scSize , - scSize ) ;

            #elif defined( SLASH )

                APPENDcc( psttSay , sc_ccLINEpEL , 0 ,scSize ) ;

            #elif defined( LINE )

                APPENDcc( psttSay , sc_ccLINEpEL , 0 , 1 ) ; // WILL GET WO PEL AT THE STARTING POSITION

            #elif defined( POINT )

                APPENDcc( psttSay , sc_ccLINEpEL , 0 , 0 ) ;

            #elif defined( NONDISTINCT )

                APPENDcc( psttSay , sc_ccLINEpEL , - scSize , - scSize ) ;

                APPENDcc( psttSay , sc_ccMOVEpEL ,   0      ,   3 * scSize ) ;

            #if defined( SAMEOsAMEO )

            APPENDcc( psttSay , sc_ccMOVEpEL , - (sCountT)( DELTA >> 1 ) , - (sCountT)( DELTA >> 1 ) ) ;
        {
        while( cDo -- )
        countT cDo = GLYPHS ;
        sCountT scSize = SIZE ;

        APPENDmm( psttSay , sc_mmMOVEtO  , 0.5 , 0.5 ) ;

    #else

        APPENDmm( psttSay , sc_mmLINEtO  , 0.0 , 1.0 ) ;
        APPENDmm( psttSay , sc_mmMOVEtO  , 0.0 , 0.0 ) ;

    #if defined( PAPERDIAGONAL )

    APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;
    APPENDcc( psttSay , sc_cPUSHiDgRID , 3 , 0 ) ;

    etThread.strMakeF( tinP , psttSay , 0 , TOCK ) ; ___( psttSay ) ;
    ZE( strokeS* , psttSay ) ;
{
paperC paper( tinP , etThread , TUCK , TUCK ) ;

TODO

}
    return 0 ;

    }
        }
            break ;

            }
                tinP.pEther->etherWhereF( tinP , ifcIDaCTIONwHERE_DISABLE ) ;
                //eyeP.moveF( tinP , vDeltaAt , - PI / ( TUCK << 2 ) , - PI / ( TUCK << 2 ) , - PI / ( TUCK << 2 ) ) ;
                //eyeP.moveF( tinP , vDeltaAt , - PI / ( TUCK >> 2 ) , - PI / ( TUCK >> 2 ) , - PI / ( TUCK >> 2 ) ) ;

                #endif
                    eyeP.moveF( tinP , vDeltaAt /*, 0.0 , 0.0*/ , + PI / ( TUCK >> 0 ) ) ;
                #elif defined( MOVE )
                    eyeP.moveF( tinP , vDeltaAt /*, 0.0 , 0.0*/ , + PI / ( TUCK >> 2 ) ) ;
                #if defined( JERK )

                //AOK: eyeP.moveF( tinP , vDeltaAt , 0 , 0 , - PI / ( TUCK >> 0 ) ) ;
                //AOK: eyeP.moveF( tinP , vDeltaAt , 0 , - PI / ( TUCK >> 0 ) , 0 ) ;
                //AOK: eyeP.moveF( tinP , vDeltaAt , - PI / ( TUCK >> 0 ) , 0 , 0 ) ;

                tinP.pEther->etherWhereF( tinP , ifcIDaCTIONwHERE_ENABLE ) ;
                vectorOldC vDeltaAt( tinP , *tinP.pEther ) ;
            {
            #endif
                if( !( idIn % ( TUCK << 3 ) ) )
                countT idIn = 1 + incv02AM( idInLath ) ;
                static countT idInLath ;
            #if defined( JERK )

            #endif

                }
                    pPaperNowP = &paperP ;
                    surfP += paperP ;
                    surfP -= paperBWP ;
                {
                else if( !( F(flagsP) & flDEVICEcbf_TOOsLOW ) && pPaperNowP != &paperP )
                }
                    pPaperNowP = &paperBWP ;
                    surfP += paperBWP ;
                    surfP -= paperP ;
                {
                if( F(flagsP) & flDEVICEcbf_TOOsLOW && pPaperNowP != &paperBWP )

            #if defined( CHEAT )

        {
        case ifcIDeVENTdEVICEc_TICK :
    {
    switch( idEventP )

    eyeC&    eyeP       =     *(eyeC*)pcDeviceArgP[ 4 ] ;
    surfC&   surfP      =    *(surfC*)pcDeviceArgP[ 3 ] ;
    paperC&  paperBWP   =   *(paperC*)pcDeviceArgP[ 2 ] ;
    paperC&  paperP     =   *(paperC*)pcDeviceArgP[ 1 ] ;
    paperC*& pPaperNowP = *(paperC**)&pcDeviceArgP[ 0 ] ;
    countT*  pcDeviceArgP =  (countT*)cDeviceArgP ;
{
countT deviceCBF( tinS& tinP , const flagsT flagsP , deviceC& deviceP , const countT cDeviceArgP , const countT idEventP , const countT cEventArgP )

}
    if( toP.z ) ;

    toP.z += sinP.oz ;
    toP.y += sinP.oy ;
    toP.x += sinP.ox ;
    // SHIFTING

    toP.z *= sinP.sz ;
    toP.y *= sinP.sy ;
    toP.x *= sinP.sx ;
    // SCALING

    }
        toP.z = - mx * tinP.brcm04Raw + mz * m1 ;
        toP.x =   mx * m1 + mz * tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , sin( sinP.ah ) )
        measure04T m1 = tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , cos( sinP.ah ) )

        measureT mz = toP.z ;
        measureT mx = toP.x ;
    {
    // HEADING

    }
        toP.z =   my * tinP.brcm04Raw + mz * m1 ;
        toP.y =   my * m1 - mz * tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , sin( - sinP.ae ) )
        measure04T m1 = tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , cos( - sinP.ae ) )

        measureT mz = toP.z ;
        measureT my = toP.y ;
    {
    // ELEVATION

    }
        toP.z = 0.0 ;
        toP.y = - rx * tinP.brcm04Raw + ry * m1 ;
        toP.x =   rx * m1 + ry * tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , sin( sinP.ab ) )
        measure04T m1 = tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , cos( sinP.ab ) )
    {
    // BANK

    measureT ry = (sCountT)( fromP.y - sinP.cy ) ;
    measureT rx = (sCountT)( fromP.x - sinP.cx ) ;

    surfS& sinP = *(surfS*)cArgP ;

    TINSL
{
voidT surfaceCBF( mPoint3S& toP , const cPoint2S& fromP , const countT cArgP )

;
}
    }
    {
    ab( 0.0 )
    ae( 0.0 ) ,
    ah( 0.0 ) ,
    sz( 1.0 ) ,
    sy( 1.0 ) ,
    sx( 1.0 ) ,
    oz( (sCountT)TUCK ) ,
    oy( 0 ) ,
    ox( 0 ) ,
    cy( TUCK / 2 ) ,
    cx( TUCK / 2 ) ,
    inline surfS( voidT ) :

    measureT ab ; //"a":"angle" ; "b":"bank"
    measureT ae ; //"a":"angle" ; "e":"elevation"
    measureT ah ; //"a":"angle" ; "h":"heading"

    measureT sz ;
    measureT sy ;
    measureT sx ; //"s":"scale"

    sCountT oz ;
    sCountT oy ;
    sCountT ox ; //"o":"origin"

    countT cy ;
    countT cx ; //"c":"center" 
{
struct surfS

//#define CHEAT

//#define BOX
//#define TRIANGLE
//#define NONDISTINCT
//#define PAPERDIAGONAL
//#define SLASH
//#define LINE
//#define POINT
//#define MONOCHROME
//#define SAMEOsAMEO

//#define JERK
#define MOVE

#define GLYPHS TUCK
#define SIZE ( TUCK >> 1 )
#define DELTA TUCK

/*1*/WAKEsHOW( "tool.benchmark.drawing.speed" )/*1*/

//20140915@1840: MOVED FROM SCRATCH 4 TO PERMANENT ADAM ID

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

