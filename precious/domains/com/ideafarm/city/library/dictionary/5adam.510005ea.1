
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.loafIF( tinP ) ;

if( POOP ) { CONoUTrAW( "loafing with POOP in my pants\r\n" ) ; }

etThread.osThreadF( TaRG1( tmReportLocalNodesF      ) , (countT)&napNodeList ) ;
etThread.osThreadF( TaRG1( tmSayNodeAdvertisementF  )                        ) ;
etThread.osThreadF( TaRG1( tmHearNodeAdvertisementF ) , (countT)&napNodeList ) ;

THREADmODE3rESTORE
}
    napNodeList.formattingIsDoneF( tinP ) ;

    nl.cEltsMax = ( cbData - sizeof( nodeListS ) + sizeof( nodeEntryS ) ) / sizeof( nodeEntryS ) ;
    nodeListS& nl = *(nodeListS*)pbData ;

    etThread.memSetF( tinP , pbData , cbData ) ;
    countT cbData = napNodeList ;
    byteT* pbData = napNodeList ;
{
if( !napNodeList.bFormattedF() )
napkinC napNodeList( tinP , TAG( TAGiDnULL ) , "ipdos.node.list.link.local.recent.advertisers" , 0 , TOCK , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_null , - 1 , ifcIDmEMORYsPACE_UNIVERSE ) ;
THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )

}
    #endif

        }
            etThread.osThreadF( TaRG1( tmWatch05TallyF       ) ) ;
            etThread.osThreadF( TaRG1( tmWatch05Deadman2F    ) ) ;
            etThread.osThreadF( TaRG1( tmWatch05Deadman1F    ) ) ;
        {
        if( !bSandbox )

        //while( cDo -- ) etThread.osThreadF( TaRG1( tmWatch05GorillaHomeF ) , (countT)&sgnGo ) ;
        //countT cDo = 0x10 ;

        //etThread.osThreadF( TaRG1( tmWatch05GorillaHomeMasterF ) , (countT)&sgnGo ) ;

    #else

        while( cDo -- ) etThread.osThreadF( tinP , countTC() , tmWatch05Deadman1F , 0 , flTHREADlAUNCH_null , TOCK >> 3 ) ;

        if( cDo ) etThread.osThreadF( TaRG1( tmWatch05TallyF ) ) ;

        countT cDo = CgORILLAS2 ;

    #elif defined( CgORILLAS2 )

        while( cDo -- ) etThread.osThreadF( tinP , countTC() , tmWatch05Deadman1F , 0 , flTHREADlAUNCH_null , TOCK >> 3 ) ;

        if( cDo ) etThread.osThreadF( TaRG1( tmWatch05TallyF ) ) ;

        countT cDo = CgORILLAS1 ;

    #if defined( CgORILLAS1 )

    if( !bSandbox ) etThread.osThreadF( TaRG1( tmWatchFileF ) ) ;

    ether.traceF( tinP , T("WATCH: launching watch threads") ) ;
{
else
}
    ether.traceF( tinP , T("WATCH: doing nothing since i am global impotent") ) ;
{
if( ether )

signC sgnGo( tinP , TAG( TAGiDnULL ) ) ;

//etThread.loafIF( tinP ) ; //TO FIND A BUG

/*PROD*/ if( !bSandbox ) ether.ifcHireF( tinP , T("ifcIDaDAM_WATCH") , bSandbox ? ifcIDaDAM_ROOThTTPsERVER : ifcIDaDAM_WATCHiDLEcPU , T("!ignoreFireByOperator") , bSandbox ? flHIRE_DISPLAYtEXT : flHIRE_DISPLAYaUTO , nicNameC() ) ;

//TEST PASSED 4 DAYS 20130915: ether.ifcHireF( tinP , T("ifcIDaDAM_WATCH") , ifcIDaDAM_ROOThTTPsERVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

//OLD PRODUCTION RETIRED 2011.01.09: /*PROD*/ ether.ifcHireF( tinP , T("ifcIDaDAM_WATCH") , ifcIDaDAM_KERNELwATCHdATABASE , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

}
    sgnDone.waitF( tinP ) ;
    ether.osThreadAdamF( tinP , ifcIDaDAM_PREPARElISTS , 0 , flOStHREADaDAMf_null , &sgnDone ) ;
    signC sgnDone( tinP , TAG( TAGiDnULL ) ) ;
{
if( !bSandbox )

boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

__( tinP.pAdamGlobal1->idMemorySpace - ifcIDmEMORYsPACE_WATCH ) ;

}
    etThread.delF( tinP , psttName ) ;
    if( psttName && psttName->idAdam ) tComputerName = T(psttName) ;
    GETsETTING( etThread , psttName , T("computer.name") )

    TN( tHome , "" ) ; tHome = T("///d/ideafarm.home.")+TF2(etherC::ifc_idHomeIdisk_IF(),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
{
TN( tComputerName , "" ) ;

//home.flagsAdams |= flHOMEsaDAMS_ROOThTTPsERVER ;
//homeS& home = homeS::homeIF() ;
//REMOVE IN PRODUCTION

TODO


DONE( tmReportLocalNodesF )
}
    }
        }
            ++ s ; ether.osSleepF( tinP , TOCK << 4 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {

        etThread.traceF( tinP , T("local nodes (end)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
        }
            }
                etThread.traceF( tinP , T("local node [off,nn,nnv4]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nn)+T("    ")+T(nnv4) , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
                nicNameC nnv4 = nl.pEntry[ offi ].port.nnv4F() ;
                nicNameC nn   = nl.pEntry[ offi ].port ;
            {
            if( nl.pEntry[ offi ].ttl )
        {
        for( countT offi = 0 ; offi < nl.cEltsMax ; offi ++ )
        etThread.traceF( tinP , T("local nodes (begin)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
    {
    while( !POOP && !ether )
    nodeListS& nl = *(nodeListS*)(byteT*)napNodeListP ;
    TN( tb4 , "    " ) ;

    napkinC& napNodeListP = *(napkinC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmReportLocalNodesF )

DONE( tmHearNodeAdvertisementF )
}
    }
        }
            nl.idRevisionFinished ++ ;  //THESE CAN BE USED BY APP CODE TO VERIFY THAT THEY HAVE SEEN A CLEAN LIST (NOT BEING REVISED)

            }
                etThread.traceF( tinP , T("error: could not add [nn,nnv4]:    ")+T(nn)+T("    ")+T(nnv4) ) ;
                nicNameC nnv4 = neTest.port.nnv4F() ;
                nicNameC nn   = neTest.port ;
            {
            if( !bFound )

            }
                }
                    break ;
                    bFound = 1 ;
                    nl.cElts ++ ;
                    etThread.traceF( tinP , T("adding [nn,nnv4]:    ")+T(nn)+T("    ")+T(nnv4) ) ;
                    nicNameC nnv4 = nl.pEntry[ offi ].port.nnv4F() ;
                    nicNameC nn   = nl.pEntry[ offi ].port ;

                    nl.pEntry[ offi ].ttl = 0x8 * ( nl.cElts + 1 ) ;        // TO REMAIN LISTED, A NODE MUST MUST RESPOND WITHIN 8 RESPONSE WAVES
                    nl.pEntry[ offi ]     = neTest ;
                {
                if( !nl.pEntry[ offi ].ttl )
            {
            if( !bFound ) for( countT offi = 0 ; offi < nl.cEltsMax ; offi ++ )

            }
                }
                    etThread.traceF( tinP , T("refreshing [nn,nnv4]:    ")+T(nn)+T("    ")+T(nnv4) ) ;
                    nicNameC nnv4 = nl.pEntry[ offi ].port.nnv4F() ;
                    nicNameC nn   = nl.pEntry[ offi ].port ;

                    nl.pEntry[ offi ].ttl = 0x8 * ( nl.cElts + 1 ) ;       // ENTRY WILL DISAPPEAR IF NOT REFRESHED ; THIS LINE REFRESHES
                    bFound = 1 ;
                {
                if( nl.pEntry[ offi ].ttl && nl.pEntry[ offi ] == neTest )
            {
            for( countT offi = 0 ; offi < nl.cEltsMax ; offi ++ )
            ZE( boolT , bFound ) ;

            }
                neTest.port = nnWo ;

                if( bIgnore ) continue ;

                boolT bIgnore = bv4 ? ~nnv4 : ~nn ;
                nicNameC nnv4 = neTest.port.nnv4F() ;
                nicNameC nn   = neTest.port ;

                boolT bv4     = nnWo.isIPv4F() ;

                etThread.traceF( tinP , T("yippee! [nnWo]:    ")+T(nnWo)+T(nnWo.isIPv4F()?"    IPv4":"    IPv6") ) ;
                soulNicNameIn >> nnWo ;
                nicNameC nnWo ;

                }
                    if( ~nn && ~nnv4 ) break ;
                    nicNameC nnv4 = neTest.port.nnv4F() ;
                    nicNameC nn   = neTest.port ;
                {
            {
            while( soulNicNameIn )

            nodeEntryS neTest ;

            }
                }
                    etThread.traceF( tinP , T("removing [nn,nnv4]:    ")+T(nn)+T("    ")+T(nnv4) ) ;
                    nicNameC nnv4 = nl.pEntry[ offi ].port.nnv4F() ;
                    nicNameC nn   = nl.pEntry[ offi ].port ;

                    nl.cElts -- ;
                    nl.pEntry[ offi ] = nodeEntryS() ;
                {
                if( nl.pEntry[ offi ].ttl && !( -- nl.pEntry[ offi ].ttl ) )
            {
            for( countT offi = 0 ; offi < nl.cEltsMax ; offi ++ )

            nl.idRevisionBegun ++ ;     //THESE CAN BE USED BY APP CODE TO VERIFY THAT THEY HAVE SEEN A CLEAN LIST (NOT BEING REVISED)

            etThread.traceF( tinP , T("called readF [nnHe,idpHe]:    ")+T(nnHe)+T("    ")+TF2(idpHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                continue ;
                etThread.traceF( tinP , T("error: could not read soul nicNameIn") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
                POOPRqUIET
            {
            if( POOP )

            socki.readF( tinP , soulNicNameIn , idpHe , nnHe , 0 , 0 ) ;
            soulC soulNicNameIn( tinP , TAG( TAGiDnULL ) ) ;
            etThread.traceF( tinP , T("calling readF") ) ;
            ZE( countT , idpHe ) ;
            nicNameC nnHe ;
        {
        while( !POOP && !ether )

        nodeListS& nl = *(nodeListS*)(byteT*)napNodeListP ;

        countT idpMe = socki.bindF( tinP , ifcIDpORT_MULTICASTaDVERTISElANnODES , nnAny , 1 , 0 ) ;
        socketC socki( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM , flSOCKETc_null , T(postIPaDDRgROUP_ADVERTISElANnODE) , 0 , 0 , 0 , 0 , 0 ) ;

        SCOOPS
    {
    IFsCRATCH

    nicNameC nnAny = socketC::nicNameIF( tinP , etThread , T("::") ) ;

    napkinC& napNodeListP = *(napkinC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmHearNodeAdvertisementF )

DONE( tmSayNodeAdvertisementF )

}
    }
        ++ s ; ether.osSleepF( tinP , TOCK << 2 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {

    socko.writeF( tinP , ifcIDpORT_MULTICASTaDVERTISElANnODES , nicNameC() , soulNicName ) ;

    }
        etThread.delF( tinP , pnnMe ) ;
        }
            else etThread.traceF( tinP , T("NON-routable    :    ")+T(pnnMe[offi]) ) ;
            }
                soulNicName << pnnMe[ offi ] ;
                etThread.traceF( tinP ,  T("routable unicast:    ")+T(pnnMe[offi]) ) ;
            {
            if( pnnMe[ offi ].isRoutableUnicastF() )
        {
        for( countT offi = 0 ; offi < cnnMe ; offi ++ )
        socketC::nicNameIF( tinP , etThread , pnnMe , cnnMe , 0 ) ; ___( pnnMe ) ;
        ZE( countT    , cnnMe ) ;
        ZE( nicNameC* , pnnMe ) ;
    {
    soulC soulNicName( tinP , TAG( TAGiDnULL ) ) ;
{
while( !ether && !POOP )

socketC socko( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM , flSOCKETc_null , T(postIPaDDRgROUP_ADVERTISElANnODE) , 0 , 0 , 0 , 0 , 0 ) ;

TASK( tmSayNodeAdvertisementF )

DONE( tmWatch05GorillaHomeF )
}
    TELL( "terminating" ) ;
    }
        etThread.traceF( tinP , T("gorillaHome:  received [timeE1|timeE2]:    ")+TT(timeE1,timeE2) , flTRACE_HOMEeCHOgORILLAhOME | flTRACE_ECHOoNLY | flTRACE_FORCEnOsILENCE ) ;
        etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1 , timeA2 ) ;
        etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
        ZE( sCountT , timeE2 ) ;
        ZE( countT , timeE1 ) ;

        #endif

            }
                etThread.delF( tinP , pNicName ) ;
                }
                    }
                        }
                            }
                                }
                                    etThread.traceF( tinP , T("gorillaHome:  error: unexpected reply") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                    POOPRqUIET
                                {
                                if( POOP )

                                __NZ( tinP.pEtScratch->strCompareF( tinP , T(postEX) , tEX ) ) ;

                                //etThread.traceF( tinP , T("gorillaHome:  received [timeE1|timeE2,postEX]:    ")+TT(timeE1,timeE2)+T("    \"")+T(postEX)+T("\"") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1 , timeA2 ) ;
                                etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                                ZE( sCountT , timeE2 ) ;
                                ZE( countT  , timeE1 ) ;
                            {
                            else
                            }
                                etThread.traceF( tinP , T("gorillaHome:  error: could not read reply") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                POOPRqUIET
                            {
                            if( POOP )

                            }
                                lag1 = post2[ 0 ] ;
                                lag2 = lag1 ;

                                else if( post2[ 0 ] == '\n' && lag1 == '\r' && lag2 == '\n' ) bArmed = 1 ; //ARM WHEN HAVE READ "\n\r\n"
                                }
                                    postEX[ sizeof postEX - 1 - cDo -- ] = post2[ 0 ] ;                            
                                {
                                if( bArmed )

                                sGet.readF( tinP , post2 , 1 ) ;
                                osTextT post2[] = { 0 , 0 } ;
                            {
                            while( !POOP && cDo )
                            //etThread.traceF( tinP , T("gorillaHome:  reading reply") , flTRACE_null , ifcIDtRACEdIVERT_1 ) ;
                            ZE( countT , lag2 ) ;
                            ZE( countT , lag1 ) ;
                            ZE( boolT , bArmed ) ;
                            countT cDo = sizeof postEX - 1 ;
                            osTextT postEX[ 0x10 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ;
                            //                         <   !   d   o   c   t   y   p   e       h   t   m   l   >     
                        {
                        else
                        }
                            etThread.traceF( tinP , T("gorillaHome:  error: could not write request") , flTRACE_HOMEeCHOgORILLAhOME | flTRACE_ECHOoNLY | flTRACE_FORCEnOsILENCE ) ;
                            POOPRqUIET
                        {
                        if( POOP )

                        //etThread.traceF( tinP , T("gorillaHome:  wrote   request ") , flTRACE_HOMEeCHOgORILLAhOME | flTRACE_ECHOoNLY | flTRACE_FORCEnOsILENCE ) ;
                        sGet.writeF( tinP , (osTextT*)tRequest ) ;
                        //etThread.traceF( tinP , T("gorillaHome:  writing request ") , flTRACE_HOMEeCHOgORILLAhOME | flTRACE_ECHOoNLY | flTRACE_FORCEnOsILENCE ) ;

                        etThread.osTimeNowF( tinP , timeA1 , timeA2 ) ;
                        ZE( sCountT , timeA2 ) ;
                        ZE( countT  , timeA1 ) ;

                        TN( tRequest , "" ) ; tRequest = T("GET /home.1.html HTTP/1.1\r\nHost: ideafarm.com\r\n\r\n") ;

                        //etThread.traceF( tinP , T("gorillaHome:  [idpMeBound,idpMe,nnMe]:    ")+TF2(idpMeBound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idpMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(nnMe) ) ;
                    {
                    else
                    }
                        etThread.traceF( tinP , T("gorillaHome:  error: could not get my connection endpoint name") , flTRACE_HOMEeCHOgORILLAhOME | flTRACE_ECHOoNLY | flTRACE_FORCEnOsILENCE ) ;
                        POOPRqUIET
                    {
                    if( POOP )

                    sGet.myNameF( tinP , idpMe , nnMe ) ;
                    nicNameC nnMe ;
                    ZE( countT , idpMe ) ;
                {
                else
                }
                    etThread.traceF( tinP , T("gorillaHome:  error: could not connect") , flTRACE_HOMEeCHOgORILLAhOME | flTRACE_ECHOoNLY | flTRACE_FORCEnOsILENCE ) ;
                    POOPRqUIET
                {
                if( POOP )

                sGet.connectF( tinP , 0x50 , pNicName[ 0 ] , 1 ) ;

                sgnGo.waitF( tinP ) ;

                //etThread.traceF( tinP , T("gorillaHome:  connecting:    ") , flTRACE_HOMEeCHOgORILLAhOME | flTRACE_ECHOoNLY | flTRACE_FORCEnOsILENCE ) ;
                home.idPortWatchHttpDeadman1 = sGet.bindF( tinP ) ;
                socketC sGet( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;

                __Z( cNicName ) ;
                __Z( pNicName ) ;
                socketC::nicNameIF( tinP , *tinP.pEtScratch , pNicName , cNicName , 0/*T("factory3.ideafarm.com")*/ ) ; ___( pNicName ) ;
                ZE( nicNameC* , pNicName ) ;
                ZE( countT , cNicName ) ;

                SCOOPS
            {
            IFsCRATCH

        #else

            }
                }
                    etThread.traceF( tinP , T("gorillaHome:  not received") , flTRACE_HOMEeCHOgORILLAhOME | flTRACE_ECHOoNLY | flTRACE_FORCEnOsILENCE ) ;
                    POOPRqUIET
                {
                if( POOP )

                etThread.delF( tinP , pbAll ) ;
                __Z( pbAll ) ;
                tinP.pEtScratch->boxGetShadowF( tinP , pbAll , cbAll , tNameHome ) ; ___( pbAll  ) ;
                ZE( countT , cbAll ) ;
                ZE( byteT* , pbAll  ) ;

                SCOOPS
            {
            IFsCRATCH

        #if defined( NEVERdEFINED )

        etThread.osTimeNowF( tinP , timeA1 , timeA2 ) ;
        ZE( sCountT , timeA2 ) ;
        ZE( countT , timeA1 ) ;
    {
    while( !etThread && !ether )
    TN( tEX , "<!doctype html>" ) ;
    //TN( tNameHome , "factory6.ideafarm.com//http//home.6.html" ) ;
    TN( tNameHome , "38.111.147.101//http//home.1.html" ) ;
    TN( tb4 , "    " ) ;
    homeS& home = homeS::homeIF() ;

    signC& sgnGo = *(signC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmWatch05GorillaHomeF )

DONE( tmWatch05GorillaHomeMasterF )
}
    }
        }
            ++ s ; ether.osSleepF( tinP , TOCK << 4 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {

        sgnGo.giveF( tinP ) ;
        etThread.traceF( tinP , T("gorillaHome:  go!") , flTRACE_HOMEeCHOgORILLAhOME | flTRACE_ECHOoNLY | flTRACE_FORCEnOsILENCE ) ;
    {
    while( !ether )

    signC& sgnGo = *(signC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmWatch05GorillaHomeMasterF )

DONE( tmWatch05Deadman2F )
}
    TELL( "terminating" ) ;
    }
        #endif
    
            }
                ++ s ; ether.osSleepF( tinP , INSPECTIONpERIOD >> 6 ) ; //MUST BE LESS THAN INSPECTIONpERIOD.  >> 4 GIVES ABOUT 01 PULLS PER INSPECTION PERIOD
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
    
        #if !defined( CgORILLAS2 )

        }
            }
                inc02AM( cDone2 ) ;
                countT idGotMe = 1 + incv02AM( idGotAok2 ) ;
            {
            else
            }
                //etThread.traceF( tinP , T("deadman2:  NOT received") , flTRACE_HOMEeCHOdEADMAN2 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
            {
            if( bFail )

            }
                etThread.delF( tinP , pNicName ) ;
                }
                    home.idPortWatchHttpDeadman2 = 0 ;
                    //etThread.traceF( tinP , T("deadman2:  socket destroyed ; resetting [home.idPortWatchHttpDeadman2]:    ")+TF2(home.idPortWatchHttpDeadman2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN2 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    }
                        }
                            }
                                }
                                    }
                                        else bFail = 0 ;
                                        }
                                            etThread.traceF( tinP , T("deadman2:  error: unexpected trademark") , flTRACE_HOMEeCHOdEADMAN2 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                            POOPR
                                        {
                                        if( POOP )

                                        __NZ( etThread.strCompareF( tinP , T(postTM) , tTM ) ) ;

                                        //etThread.traceF( tinP , T("deadman2:  received [timeE1|timeE2,postTM]:    ")+TT(timeE1,timeE2)+T("    \"")+T(postTM)+T("\"") , flTRACE_HOMEeCHOdEADMAN2 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                        etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1 , timeA2 ) ;
                                        etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                                        ZE( sCountT , timeE2 ) ;
                                        ZE( countT  , timeE1 ) ;
                                    {
                                    else
                                    }
                                        etThread.traceF( tinP , T("deadman2:  error: could not read reply") , flTRACE_HOMEeCHOdEADMAN2 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                        POOPR
                                    {
                                    if( POOP )

                                    }
                                        lag1 = post2[ 0 ] ;
                                        lag2 = lag1 ;

                                        else if( post2[ 0 ] == '\n' && lag1 == '\r' && lag2 == '\n' ) bArmed = 1 ; //ARM WHEN HAVE READ "\n\r\n"
                                        }
                                            postTM[ sizeof postTM - 1 - cDo -- ] = post2[ 0 ] ;                            
                                        {
                                        if( bArmed )

                                        sGet.readF( tinP , post2 , 1 ) ;
                                        osTextT post2[] = { 0 , 0 } ;
                                    {
                                    while( !POOP && cDo )
                                    //etThread.traceF( tinP , T("deadman2:  reading reply") , flTRACE_null , ifcIDtRACEdIVERT_1 ) ;
                                    ZE( countT , lag2 ) ;
                                    ZE( countT , lag1 ) ;
                                    ZE( boolT , bArmed ) ;
                                    countT cDo = sizeof postTM - 1 ;
                                    osTextT postTM[ 0xe ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ;
                                    //                        I   d   e   a   f   a   r   m       (   t   m   )
                                {
                                else
                                }
                                    etThread.traceF( tinP , T("deadman2:  error: could not write request") , flTRACE_HOMEeCHOdEADMAN2 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                    POOPR
                                {
                                if( POOP )

                                sGet.writeF( tinP , (osTextT*)tRequest ) ;
                                //etThread.traceF( tinP , T("deadman2:  writing request") , flTRACE_HOMEeCHOdEADMAN2 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                etThread.osTimeNowF( tinP , timeA1 , timeA2 ) ;
                                ZE( sCountT , timeA2 ) ;
                                ZE( countT  , timeA1 ) ;

                                TN( tRequest , "" ) ; tRequest = T("GET /deadman2?idCycle=")+TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" HTTP/1.1\r\nHost: ideafarm.com\r\n\r\n") ;

                                //etThread.traceF( tinP , T("deadman2:  [idpMeBound,idpMe,nnMe]:    ")+TF2(idpMeBound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idpMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(nnMe) ) ;
                            {
                            else
                            }
                                etThread.traceF( tinP , T("deadman2:  error: could not get my connection endpoint name") , flTRACE_HOMEeCHOdEADMAN2 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                POOPR
                            {
                            if( POOP )

                            sGet.myNameF( tinP , idpMe , nnMe ) ;
                            nicNameC nnMe ;
                            ZE( countT , idpMe ) ;
                        {
                        else
                        }
                            etThread.traceF( tinP , T("deadman2:  error: could not connect") , flTRACE_HOMEeCHOdEADMAN2 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                            POOPR
                        {
                        if( POOP )

                        sGet.connectF( tinP , 0x50 , pNicName[ 0 ] , 1 ) ;
                        //etThread.traceF( tinP , T("deadman2:  connecting [home.idPortWatchHttpDeadman2]:    ")+TF2(home.idPortWatchHttpDeadman2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN2 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        home.idPortWatchHttpDeadman2 = sGet.bindF( tinP ) ;
                        socketC sGet( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                    {
                {
                else
                }
                    etThread.traceF( tinP , T("deadman2:  error: could not obtain nicName array") , flTRACE_HOMEeCHOdEADMAN2 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    POOPR ;
                {
                if( POOP )

                __Z( cNicName ) ;
                __Z( pNicName ) ;
                socketC::nicNameIF( tinP , *tinP.pEtScratch , pNicName , cNicName , 0/*T("factory3.ideafarm.com")*/ ) ; ___( pNicName ) ;
                ZE( nicNameC* , pNicName ) ;
                ZE( countT , cNicName ) ;

                //etThread.traceF( tinP , T("deadman2:  requesting") ) ;
                SCOOPS
            {
            IFsCRATCH
            boolT bFail = 1 ;

            //etThread.traceF( tinP , T("deadman2:  http watch cycle begun [idCycle]:    ")+TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN2 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
        {
        if( bSandbox || F(home.flagsAdams) & flHOMEsaDAMS_ROOThTTPsERVER )
    
        //CONoUTrAW5( "cycle " , idCycle , " on thread " , tinP.monitor.idThread , ": querying...\r\n") ;
    
        idCycle ++ ;
    {
    while( !etThread && !ether )
    TN( tTM , "IdeaFarm (tm)" ) ;
    homeS& home = homeS::homeIF() ;
    ZE( countT , idCycle ) ;
    countT idGorilla = 1 + incv02AM( idGorillaLath2 ) ;

    #endif
        etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;
    #if !defined( CgORILLAS2 )

    bSandbox = 0 ;
    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

    //etThread.traceF( tinP , T("deadman2:  WATCH: about to enter watch loop") ) ;
{
if( pTaskP )
TASK( tmWatch05Deadman2F )
countT idGorillaLath2 ;
countT idGotAok2 ;

DONE( tmWatch05Deadman1F )
}
    TELL( "terminating" ) ;
    }
        #endif
    
            }
                //PROD:  ++ s ; ether.osSleepF( tinP , INSPECTIONpERIOD >> 6 ) ; //MUST BE LESS THAN INSPECTIONpERIOD.  >> 4 GIVES ABOUT 01 PULLS PER INSPECTION PERIOD
                ++ s ; ether.osSleepF( tinP , INSPECTIONpERIOD >> 0xa ) ; //U:: TO FIND A BUG
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
    
        #if !defined( CgORILLAS1 )

        if( bSandbox ) break ; //U::TO FIND A BUG

        }
            }
                inc02AM( cDone1 ) ;
                countT idGotMe = 1 + incv02AM( idGotAok1 ) ;
            {
            else
            }
                etThread.traceF( tinP , T("deadman1:  NOT received") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
            {
            if( bFail )

            }
                etThread.delF( tinP , pNicName ) ;
                }
                    home.idPortWatchHttpDeadman1 = 0 ;
                    //etThread.traceF( tinP , T("deadman1:  my socket is dt'd ; resetting from [home.idPortWatchHttpDeadman1]:    ")+TF2(home.idPortWatchHttpDeadman1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    }
                        }
                            }
                                }
                                    }
                                        else bFail = 0 ;
                                        }
                                            etThread.traceF( tinP , T("deadman1:  error: unexpected trademark") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                            POOPR
                                        {
                                        if( POOP )

                                        __NZ( etThread.strCompareF( tinP , T(postTM) , tTM ) ) ;

                                        etThread.traceF( tinP , T("deadman1:  received [idCycle,timeE1|timeE2,postTM]:    ")+tIdCycle+tb4+TT(timeE1,timeE2)+T("    \"")+T(postTM)+T("\"") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                        etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1 , timeA2 ) ;
                                        etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                                        ZE( sCountT , timeE2 ) ;
                                        ZE( countT  , timeE1 ) ;
                                    {
                                    else
                                    }
                                        etThread.traceF( tinP , T("deadman1:  error: could not read reply") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                        POOPR
                                    {
                                    if( POOP )

                                    }
                                        lag1 = post2[ 0 ] ;
                                        lag2 = lag1 ;

                                        else if( post2[ 0 ] == '\n' && lag1 == '\r' && lag2 == '\n' ) bArmed = 1 ; //ARM WHEN HAVE READ "\n\r\n"
                                        }
                                            postTM[ sizeof postTM - 1 - cDo -- ] = post2[ 0 ] ;                            
                                        {
                                        if( bArmed )

                                        sGet.readF( tinP , post2 , 1 ) ;
                                        osTextT post2[] = { 0 , 0 } ;
                                    {
                                    while( !POOP && cDo )
                                    etThread.traceF( tinP , T("deadman1:  reading reply") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                    ZE( countT , lag2 ) ;
                                    ZE( countT , lag1 ) ;
                                    ZE( boolT , bArmed ) ;
                                    countT cDo = sizeof postTM - 1 ;
                                    osTextT postTM[ 0xe ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ;
                                    //                        I   d   e   a   f   a   r   m       (   t   m   )
                                {
                                else
                                }
                                    etThread.traceF( tinP , T("deadman1:  error: could not write request") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                    POOPR
                                {
                                if( POOP )

                                etThread.traceF( tinP , T("deadman1:  wrote   request ")+tIdCycle , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                sGet.writeF( tinP , (osTextT*)tRequest ) ;
                                etThread.traceF( tinP , T("deadman1:  writing request ")+tIdCycle , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                etThread.osTimeNowF( tinP , timeA1 , timeA2 ) ;
                                ZE( sCountT , timeA2 ) ;
                                ZE( countT  , timeA1 ) ;

                                TN( tRequest , "" ) ; tRequest = T("GET /deadman1?idCycle=")+tIdCycle+T(" HTTP/1.1\r\nHost: ideafarm.com\r\n\r\n") ;

                                //etThread.traceF( tinP , T("deadman1:  [idpMeBound,idpMe,nnMe]:    ")+TF2(idpMeBound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idpMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(nnMe) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                            {
                            else
                            }
                                etThread.traceF( tinP , T("deadman1:  error: could not get my connection endpoint name") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                POOPR
                            {
                            if( POOP )

                            sGet.myNameF( tinP , idpMe , nnMe ) ;
                            nicNameC nnMe ;
                            ZE( countT , idpMe ) ;
                        {
                        else
                        }
                            etThread.traceF( tinP , T("deadman1:  error: could not connect") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                            POOPR
                        {
                        if( POOP )

                        sGet.connectF( tinP , 0x50 , pNicName[ 0 ] , 1 ) ;
                        etThread.traceF( tinP , T("deadman1:  connecting [home.idPortWatchHttpDeadman1]:    ")+TF2(home.idPortWatchHttpDeadman1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        home.idPortWatchHttpDeadman1 = sGet.bindF( tinP ) ;
                        socketC sGet( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , countTC( SOCKETtIMEOUTdEFAULTlAN ) , countTC( SOCKETtIMEOUTdEFAULTlAN ) , countTC( SOCKETtIMEOUTdEFAULTlAN ) ) ;
                    {
                {
                else
                }
                    etThread.traceF( tinP , T("deadman1:  error: could not obtain nicName array") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    POOPR ;
                {
                if( POOP )

                __Z( cNicName ) ;
                __Z( pNicName ) ;
                socketC::nicNameIF( tinP , *tinP.pEtScratch , pNicName , cNicName , 0/*T("factory3.ideafarm.com")*/ ) ; ___( pNicName ) ;
                ZE( nicNameC* , pNicName ) ;
                ZE( countT , cNicName ) ;

                etThread.traceF( tinP , T("deadman1:  requesting") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                SCOOPS
            {
            IFsCRATCH
            boolT bFail = 1 ;

            etThread.traceF( tinP , T("deadman1:  http watch cycle begun [idCycle]:    ")+TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
        {
        if( bSandbox || F(home.flagsAdams) & flHOMEsaDAMS_ROOThTTPsERVER )
    
        //CONoUTrAW5( "cycle " , idCycle , " on thread " , tinP.monitor.idThread , ": querying...\r\n") ;
    
        TN( tIdCycle , "" ) ; tIdCycle = TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
        idCycle ++ ;
    {
    while( !etThread && !ether )
    TN( tb4 , "    " ) ;
    TN( tTM , "IdeaFarm (tm)" ) ;
    homeS& home = homeS::homeIF() ;
    ZE( countT , idCycle ) ;
    countT idGorilla = 1 + incv02AM( idGorillaLath1 ) ;

    #endif
        etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;
    #if !defined( CgORILLAS1 )

    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

    etThread.traceF( tinP , T("deadman1:  WATCH: about to enter watch loop") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
{
if( pTaskP )
TASK( tmWatch05Deadman1F )
countT idGorillaLath1 ;
countT idGotAok1 ;

DONE( tmWatchFileF )
}
    TELL( "terminating" ) ;
    }
        }
            ++ s ; ether.osSleepF( tinP , INSPECTIONpERIODfILE ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {

        }
            etThread.delF( tinP , posti ) ;

            }
                thirdC::osFireIF( tinP ) ;
                etThread.traceF( tinP , T("firing os because a trigger file exists [posti]: ")+T(posti) ) ;
            {
            else
            if( POOP ) { POOPR ; }
            tinP.pEtScratch->boxGetF( tinP , posti , costi , tTriggerFile , 1 ) ; ___( posti ) ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;

            SCOOPS
        {
        IFsCRATCH
    
        ether.traceF( tinP , T("watchfile (triggerfile) cycle begun [idCycle]:    ")+TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        idCycle ++ ;
    {
    while( !etThread && !ether )
    TN( tTriggerFile , "///ideafarm/controls/osfire.txt" ) ;
    ZE( countT , idCycle ) ;

    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;
{
if( pTaskP )
TASK( tmWatchFileF )

DONE( tmWatch05TallyF )
}
    }
        }
            ++ s ; ether.osSleepF( tinP , INSPECTIONpERIOD ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {

        }
            //CONoUTrAW3( "tmWatch05TallyF [flHOMEsuTILITY_SNAPsHOT]: " , F(home.flagsUtility) & flHOMEsuTILITY_SNAPsHOT , "\r\n" ) ;

            }
                }
                    }
                        thirdC::osFireIF( tinP ) ;
                        //CRAFTWORK NOT FINISHED: SNAPsHOT( "watchport05" ) ;
                        etThread.traceF( tinP , tSay , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        tSay = T("\r\n")+TT(timeN1,timeN2)+T(" | WATCH: calling osFireIF now") ;
                    
                        ++ s ; ether.osSleepF( tinP , TOCK << 5 ) ; //GIVE MAILoUT TIME TO SEND THIS
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        
                        etThread.emailFactoryReportF( tinP , tSay ) ;
                        etThread.traceF( tinP , tSay , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                        TELL( tSay ) ;
                        TN( tSay , "sending suicide note: nothing new done and no more forgiving, so will reboot after short nap" ) ;
                    {
                    if( !( cFire ++ ) )

                    etThread.traceF( tinP , tSay , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                    ;

                        + T(" | calling osFireIF if i have not already done so")
                        TT(timeN1,timeN2)

                    TN( tSay , "\r\n" ) ; tSay +=

                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                else                                                                                                // ------------ NOTHING NEW HAS BEEN DONE: TIME TO REBOOT
                }
                    home.flagsUtility |= flHOMEsuTILITY_SNAPsHOT ;

                    if( !( cForgive % 4 ) ) etThread.emailFactoryReportF( tinP , tSay ) ;
                    etThread.traceF( tinP , tSay , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                    ;

                        + T(" (http service failure detected)")
                        + TF2(cForgive,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                        + T(" | nothing new has been done.  forgiven.  cForgive is now ")
                        TT(timeN1,timeN2)

                    TN( tSay , "\r\n" ) ; tSay +=

                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                if( cForgive && cForgive -- )                                                                  // ------------ NOTHING NEW HAS BEEN DONE: FORGIVE
            {
            else
            }
                home.flagsUtility &= ~( F(flHOMEsuTILITY_SNAPsHOT) ) ;
                cDone1Lag = cDone1 ;

                }
                    cForgive = CfORGIVE ;

                    etThread.emailFactoryReportF( tinP , tSay ) ;
                    etThread.traceF( tinP , tSay , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
        
                    ;
        
                        + T(" (http service restoration detected)")
                        + T(" to ")                            +TF2(CfORGIVE,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                        + T(" | cForgive is being reset from ")+TF2(cForgive,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                        TT(timeN1,timeN2)
        
                    TN( tSay , "" ) ; tSay =
        
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                if( cForgive < CfORGIVE )

                }
                    etThread.emailFactoryReportF( tinP , tSay ) ;
                    etThread.traceF( tinP , tSay , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    TN( tSay , "http service detected" ) ;
                {
                if( !cDone1Lag )
            {
            else if( cDone1Lag < cDone1 )                                                                         // ------------ MORE HAS BEEN DONE
            }
                etThread.traceF( tinP , tSay , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                ;

                    + T(" | cDone1Lag is near its capacity so has been reset to 0")
                    TT(timeN1,timeN2)

                TN( tSay , "" ) ; tSay =

                etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT , timeN1 ) ;

                //home.flagsUtility &= ~( F(flHOMEsuTILITY_SNAPsHOT) ) ;
                cDone1Lag = cDone1 = 0 ;
                cForgive = CfORGIVE ;
            {
            if( cDone1Lag > MAXcOUNTT - TOCK )                                                                   // ------------ WRAP

            if( cForgive != CfORGIVE && cForgive ) etThread.traceF( tinP , TT(timeN1,timeN2)+T(" | ")+tNote+TF2(cDone1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb+TF2(cDone1Lag,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb+TF2(cForgive,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
            ether.traceF( tinP , T("tally cycle begun [cForgive,cDone1]:    ")+TF2(cForgive,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb+TF2(cDone1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
        {
        if( ( bSandbox || F(home.flagsAdams) & flHOMEsaDAMS_ROOThTTPsERVER ) && ( !cSkip || !( cSkip -- ) ) )
    {
    while( !ether && !etThread )
    countT cSkip = 0 ;
    ZE( countT , cFire ) ; //U:; TO FIND A BUG
    TN( tNote , " tmWatch05TallyF / inspecting [cDone1,cDone1Lag,cForgive]: " ) ;
    TN( tcr , "\r\n" ) ;
    TN( tb  , " " ) ;
    ZE( countT , cDone1Lag ) ;
    countT cForgive = CfORGIVE ;

    bSandbox = 0 ;
    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

    etThread.traceF( tinP , TT(timeB1,timeB2)+T(": tmWatch05TallyF awoke") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
    etThread.osTimeNowF( tinP , timeB1 , timeB2 ) ;
    ZE( sCountT , timeB2 ) ;
    ZE( countT , timeB1 ) ;

    homeS& home = homeS::homeIF() ;

    }
        ++ s ; ether.osSleepF( tinP , TOCK << 5 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {

    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;
{
if( pTaskP )
TASK( tmWatch05TallyF )

countT cDone2 ;
countT cDone1 ;

// 352_9 THREADS OBSERVED AS A MAXIMUM
//#define CgORILLAS1              ( CsESSIONmAXdFLTiFCdRIVENsERVER >> 4 )
//AOK BUT SLOW: #define CgORILLAS1              CsESSIONmAXdFLTiFCdRIVENsERVER
//#define CgORILLAS1              ( TUCK >> 1 )
//AOK: #define CgORILLAS1              0x10
//#define CgORILLAS1              0x10
//#define CgORILLAS1              0x4
//#define CgORILLAS1              0x3
// NORMALLY CgORILLAS1 IS NOT DEFINED; DEFINE IT TO DO GORILLA TESTING

// NOTE: TO USE GORILLA, THE SPOOFING DETECTION CODE IN etherDoHttpServerF MUST BE DISABLED

#define INSPECTIONpERIODfILE ( TICK >> 2 )

#define INSPECTIONpERIOD ( TICK )
// TICK >> 2 --> TICK    (TO REDUCE EMAIL FROM factory4)
// TOCK << 3: TOO MANY FAILURES
// TOCK << 1: TOO MANY FAILURES ON factory5  20190825@1218

#define CfORGIVE 0x10

//#define CfORGIVE 0x40
//#define CfORGIVE 0x2
//U::SHOULD BE 01

// OBSOLETES: 510005ea

/*1*/WAKEhIDE( "ifcIDaDAM_WATCH" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

