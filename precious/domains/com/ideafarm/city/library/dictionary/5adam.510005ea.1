
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.loafIF( tinP ) ;

if( POOP ) { CONoUTrAW( "loafing with POOP in my pants\r\n" ) ; }

}
    #endif

        }
            if( POOP ) { CONoUTrAW3( "" , cDo , " [cDo after]: called osThreadF and it POOPED\r\n" ) ; }
            etThread.osThreadF( tinP , countTC() , tmWatch05F , 0 , flTHREADlAUNCH_null , TOCK >> 3 ) ;
            CONoUTrAW3( "" , cDo , " [cDo after]: calling osThreadF\r\n" ) ;
        {
        while( cDo -- )

        if( cDo ) etThread.osThreadF( TaRG1( tmWatch05TallyF ) ) ;

        countT cDo = CgORILLAS ;

    #else

        etThread.osThreadF( TaRG1( tmWatch05TallyF ) ) ;
        etThread.osThreadF( TaRG1( tmWatch05F ) ) ;

    #if !defined( CgORILLAS )

    etThread.osThreadF( TaRG1( tmWatchFileF    ) ) ;

    ether.traceF( tinP , T("WATCH: launching watch threads") ) ;
{
else
}
    ether.traceF( tinP , T("WATCH: doing nothing since i am global impotent") ) ;
{
if( ether )

/*PROD*/ ether.ifcHireF( tinP , T("ifcIDaDAM_WATCH") , ifcIDaDAM_WATCHiDLEcPU , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

//TEST PASSED 4 DAYS 20130915: ether.ifcHireF( tinP , T("ifcIDaDAM_WATCH") , ifcIDaDAM_ROOThTTPsERVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

//OLD PRODUCTION RETIRED 2011.01.09: /*PROD*/ ether.ifcHireF( tinP , T("ifcIDaDAM_WATCH") , ifcIDaDAM_KERNELwATCHdATABASE , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

}
    sgnDone.waitF( tinP ) ;
    ether.osThreadAdamF( tinP , ifcIDaDAM_PREPARElISTS , 0 , flOStHREADaDAMf_null , &sgnDone ) ;
    signC sgnDone( tinP , TAG( TAGiDnULL ) ) ;
{

__( tinP.pAdamGlobal1->idMemorySpace - ifcIDmEMORYsPACE_WATCH ) ;

}
    etThread.delF( tinP , psttName ) ;
    if( psttName && psttName->idAdam ) tComputerName = T(psttName) ;
    GETsETTING( etThread , psttName , T("computer.name") )

    TN( tHome , "" ) ; tHome = T("///d/ideafarm.home.")+TF2(etherC::ifc_idHomeIdisk_IF(),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
{
TN( tComputerName , "" ) ;

//home.flagsAdams |= flHOMEsaDAMS_ROOThTTPsERVER ;
//homeS& home = homeS::homeIF() ;
//REMOVE IN PRODUCTION

TODO

DONE( tmWatch05F )
}
    TELL( "terminating" ) ;
    }
        #endif
    
            }
                ++ s ; ether.osSleepF( tinP , INSPECTIONpERIOD >> 4 ) ; //MUST BE LESS THAN INSPECTIONpERIOD.  >> 4 GIVES ABOUT 01 PULLS PER INSPECTION PERIOD
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
    
        #if !defined( CgORILLAS )

        etThread.delF( tinP , posti ) ;
    
        //CONoUTrAW( "\"\r\n ") ;
        //CONoUTrAW( posti ) ;
        //CONoUTrAW( DASH127  "\r\nreceived:\r\n\"") ;
    
        }
            }
                }
                    inc02AM( cDone ) ;
                    etThread.traceF( tinP , T("deadman was received aok") ) ;
                    countT idGotMe = 1 + incv02AM( idGotAok ) ;
                {
                else
                }
                    etThread.traceF( tinP , T("deadman was NOT received") ) ;
                    POOPR ;
                {
                if( POOP )
                tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , T("//http/deadman") , 1 , TOCK >> 0 ) ; ___( posti ) ;
                SCOOPS
            {
            IFsCRATCH
        {
        if( F(home.flagsAdams) & flHOMEsaDAMS_ROOThTTPsERVER )
    
        //CONoUTrAW5( "cycle " , idCycle , " on thread " , tinP.monitor.idThread , ": querying...\r\n") ;
    
        ZE( countT , costi ) ;
        ZE( byteT* , posti ) ;

        etThread.traceF( tinP , T("http watch cycle begun [idCycle]:    ")+TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        idCycle ++ ;
    {
    while( !etThread && !ether )
    homeS& home = homeS::homeIF() ;
    ZE( countT , idCycle ) ;
    countT idGorilla = 1 + incv02AM( idGorillaLath ) ;

    #endif
        etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;
    #if !defined( CgORILLAS )

    etThread.traceF( tinP , T("WATCH: about to enter watch loop") ) ;
{
if( pTaskP )
TASK( tmWatch05F )
countT idGorillaLath ;
countT idGotAok ;

DONE( tmWatchFileF )
}
    TELL( "terminating" ) ;
    }
        }
            ++ s ; ether.osSleepF( tinP , INSPECTIONpERIODfILE ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {

        }
            etThread.delF( tinP , posti ) ;

            }
                thirdC::osFireIF( tinP ) ;
                etThread.traceF( tinP , T("firing os because a trigger file exists [posti]: ")+T(posti) ) ;
            {
            else
            if( POOP ) { POOPR ; }
            tinP.pEtScratch->boxGetF( tinP , posti , costi , tTriggerFile , 1 ) ; ___( posti ) ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;

            SCOOPS
        {
        IFsCRATCH
    
        ether.traceF( tinP , T("watchfile (triggerfile) cycle begun [idCycle]:    ")+TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        idCycle ++ ;
    {
    while( !etThread && !ether )
    TN( tTriggerFile , "///ideafarm/controls/osfire.txt" ) ;
    ZE( countT , idCycle ) ;

    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;
{
if( pTaskP )
TASK( tmWatchFileF )

DONE( tmWatch05TallyF )
}
    }
        }
            ++ s ; ether.osSleepF( tinP , INSPECTIONpERIOD ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {

        }
            //CONoUTrAW3( "tmWatch05TallyF [flHOMEsuTILITY_SNAPsHOT]: " , F(home.flagsUtility) & flHOMEsuTILITY_SNAPsHOT , "\r\n" ) ;

            }
                }
                    }
                        thirdC::osFireIF( tinP ) ;
                        //CRAFTWORK NOT FINISHED: SNAPsHOT( "watchport05" ) ;
                        TRACE( T("\r\n")+TT(timeN1,timeN2)+T(" | WATCH: calling osFireIF cause nothing new done") ) ;
                    
                        ++ s ; ether.osSleepF( tinP , TOCK << 4 ) ; //GIVE MAILoUT TIME TO SEND THIS
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        
                        etThread.emailFactoryReportF( tinP , T("rebooting") ) ;
                        TELL( "requesting reboot: nothing new done and no more forgiving" ) ;
                    {
                    if( !( cFire ++ ) )

                    TRACE( tSay )

                    ;

                        + T(" | calling osFireIF if i have not already done so")
                        TT(timeN1,timeN2)

                    TN( tSay , "\r\n" ) ; tSay +=

                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                else                                                                                                // ------------ NOTHING NEW HAS BEEN DONE: TIME TO REBOOT
                }
                    home.flagsUtility |= flHOMEsuTILITY_SNAPsHOT ;

                    TRACE( tSay )

                    ;

                        + TF2(cForgive,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                        + T(" | nothing new has been done.  forgiven.  cForgive is now ")
                        TT(timeN1,timeN2)

                    TN( tSay , "\r\n" ) ; tSay +=

                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;

                    if( cForgive == CfORGIVE - 1 ) etThread.emailFactoryReportF( tinP , T("http service failure detected") ) ;
                {
                if( cForgive && cForgive -- )                                                                  // ------------ NOTHING NEW HAS BEEN DONE: FORGIVE
            {
            else
            }
                home.flagsUtility &= ~( F(flHOMEsuTILITY_SNAPsHOT) ) ;
                cDoneLag = cDone ;

                }
                    cForgive = CfORGIVE ;

                    etThread.emailFactoryReportF( tinP , T("http service restoration detected") ) ;
                    TRACE( tSay )
        
                    ;
        
                        + T(" to ")                            +TF2(CfORGIVE,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                        + T(" | cForgive is being reset from ")+TF2(cForgive,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                        TT(timeN1,timeN2)
        
                    TN( tSay , "\r\n" ) ; tSay +=
        
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                if( cForgive < CfORGIVE )

                }
                    etThread.emailFactoryReportF( tinP , T("http service detected") ) ;
                {
                if( !cDoneLag )
            {
            else if( cDoneLag < cDone )                                                                         // ------------ MORE HAS BEEN DONE
            }
                TRACE( tSay )

                ;

                    + T(" | cDoneLag is near its capacity so has been reset to 0")
                    TT(timeN1,timeN2)

                TN( tSay , "\r\n" ) ; tSay +=

                etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT , timeN1 ) ;

                //home.flagsUtility &= ~( F(flHOMEsuTILITY_SNAPsHOT) ) ;
                cDoneLag = cDone = 0 ;
                cForgive = CfORGIVE ;
            {
            if( cDoneLag > MAXcOUNTT - TOCK )                                                                   // ------------ WRAP

            if( cForgive != CfORGIVE && cForgive ) { TRACE( T("\r\n")+TT(timeN1,timeN2)+T(" | ")+tNote+TF2(cDone,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb+TF2(cDoneLag,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb+TF2(cForgive,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ; }
            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
            ether.traceF( tinP , T("tally cycle begun [cForgive,cDone]:    ")+TF2(cForgive,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb+TF2(cDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        if( F(home.flagsAdams) & flHOMEsaDAMS_ROOThTTPsERVER && ( !cSkip || !( cSkip -- ) ) )
    {
    while( !ether && !etThread )
    countT cSkip = 8 ;
    ZE( countT , cFire ) ; //U:; TO FIND A BUG
    TN( tNote , " tmWatch05TallyF / inspecting [cDone,cDoneLag,cForgive]: " ) ;
    TN( tcr , "\r\n" ) ;
    TN( tb  , " " ) ;
    ZE( countT , cDoneLag ) ;
    countT cForgive = CfORGIVE ;

    TRACE( T("\r\n")+TT(timeB1,timeB2)+T(": tmWatch05TallyF awoke") ) ;
    etThread.osTimeNowF( tinP , timeB1 , timeB2 ) ;
    ZE( sCountT , timeB2 ) ;
    ZE( countT , timeB1 ) ;

    homeS& home = homeS::homeIF() ;

    //}
    //    ++ s ; ether.osSleepF( tinP , TOCK << 5 ) ;
    //    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    //{

    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;
{
if( pTaskP )
TASK( tmWatch05TallyF )

countT cDone ;

// 352_9 THREADS OBSERVED AS A MAXIMUM
//#define CgORILLAS              ( CsESSIONmAXdFLTiFCdRIVENsERVER >> 4 )
//AOK BUT SLOW: #define CgORILLAS              CsESSIONmAXdFLTiFCdRIVENsERVER
//#define CgORILLAS              ( TUCK >> 1 )
//AOK: #define CgORILLAS              0x10
//#define CgORILLAS              0x4
//#define CgORILLAS              0x3
// NORMALLY CgORILLAS IS NOT DEFINED; DEFINE IT TO DO GORILLA TESTING

#define INSPECTIONpERIODfILE ( TICK >> 2 )

#define INSPECTIONpERIOD ( TICK >> 2 )
// TOCK << 3: TOO MANY FAILURES
// TOCK << 1: TOO MANY FAILURES ON factory5  20190825@1218

#define CfORGIVE 0x10

//#define CfORGIVE 0x40
//#define CfORGIVE 0x2
//U::SHOULD BE 01

// OBSOLETES: 510005ea

/*1*/WAKEhIDE( "ifcIDaDAM_WATCH" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

