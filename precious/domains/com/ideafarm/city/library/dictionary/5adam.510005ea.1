
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.loafIF( tinP ) ;

if( POOP ) { CONoUTrAW( "loafing with POOP in my pants\r\n" ) ; }

}
    #endif

        }
            if( POOP ) { CONoUTrAW3( "" , cDo , " [cDo after]: called osThreadF and it POOPED\r\n" ) ; }
            etThread.osThreadF( tinP , countTC() , tmWatch05F , 0 , flTHREADlAUNCH_null , TOCK >> 3 ) ;
            CONoUTrAW3( "" , cDo , " [cDo after]: calling osThreadF\r\n" ) ;
        {
        while( cDo -- )

        if( cDo ) etThread.osThreadF( TaRG1( tmWatch05TallyF ) ) ;

        countT cDo = CgORILLAS ;

    #else

        etThread.osThreadF( TaRG1( tmWatch05TallyF ) ) ;
        etThread.osThreadF( TaRG1( tmWatch05F ) ) ;

    #if !defined( CgORILLAS )

    etThread.osThreadF( TaRG1( tmWatchFileF    ) ) ;

    ether.traceF( tinP , T("WATCH: launching watch threads") ) ;
{
else
}
    ether.traceF( tinP , T("WATCH: doing nothing since i am global impotent") ) ;
{
if( ether )

/*PROD*/ ether.ifcHireF( tinP , T("ifcIDaDAM_WATCH") , ifcIDaDAM_WATCHiDLEcPU , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

//TEST PASSED 4 DAYS 20130915: ether.ifcHireF( tinP , T("ifcIDaDAM_WATCH") , ifcIDaDAM_ROOThTTPsERVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

//OLD PRODUCTION RETIRED 2011.01.09: /*PROD*/ ether.ifcHireF( tinP , T("ifcIDaDAM_WATCH") , ifcIDaDAM_KERNELwATCHdATABASE , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

}
    sgnDone.waitF( tinP ) ;
    ether.osThreadAdamF( tinP , ifcIDaDAM_PREPARElISTS , 0 , flOStHREADaDAMf_null , &sgnDone ) ;
    signC sgnDone( tinP , TAG( TAGiDnULL ) ) ;
{

__( tinP.pAdamGlobal1->idMemorySpace - ifcIDmEMORYsPACE_WATCH ) ;

}
    etThread.delF( tinP , psttName ) ;
    if( psttName && psttName->idAdam ) tComputerName = T(psttName) ;
    GETsETTING( etThread , psttName , T("computer.name") )

    TN( tHome , "" ) ; tHome = T("///d/ideafarm.home.")+TF2(etherC::ifc_idHomeIdisk_IF(),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
{
TN( tComputerName , "" ) ;

//home.flagsAdams |= flHOMEsaDAMS_ROOThTTPsERVER ;
//homeS& home = homeS::homeIF() ;
//REMOVE IN PRODUCTION

TODO

DONE( tmWatch05F )
}
    TELL( "terminating" ) ;
    }
        #endif
    
            }
                ++ s ; ether.osSleepF( tinP , INSPECTIONpERIOD >> 6 ) ; //MUST BE LESS THAN INSPECTIONpERIOD.  >> 4 GIVES ABOUT 01 PULLS PER INSPECTION PERIOD
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
    
        #if !defined( CgORILLAS )

        }
            }
                inc02AM( cDone ) ;
                countT idGotMe = 1 + incv02AM( idGotAok ) ;
            {
            else
            }
                etThread.traceF( tinP , T("deadman was NOT received") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
            {
            if( bFail )

            }
                etThread.delF( tinP , pNicName ) ;
                }
                    home.idPortWatchHttp = 0 ;
                    }
                        }
                            }
                                }
                                    }
                                        else bFail = 0 ;
                                        }
                                            etThread.traceF( tinP , T("error: unexpected trademark") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
                                            POOPR
                                        {
                                        if( POOP )

                                        __NZ( etThread.strCompareF( tinP , T(postTM) , tTM ) ) ;

                                        etThread.traceF( tinP , T("received [timeE1|timeE2,postTM]:    ")+TT(timeE1,timeE2)+T("    \"")+T(postTM)+T("\"") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;

                                        etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1 , timeA2 ) ;
                                        etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                                        ZE( sCountT , timeE2 ) ;
                                        ZE( countT  , timeE1 ) ;
                                    {
                                    else
                                    }
                                        etThread.traceF( tinP , T("error: could not read reply") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
                                        POOPR
                                    {
                                    if( POOP )

                                    }
                                        lag1 = post2[ 0 ] ;
                                        lag2 = lag1 ;

                                        else if( post2[ 0 ] == '\n' && lag1 == '\r' && lag2 == '\n' ) bArmed = 1 ; //ARM WHEN HAVE READ "\n\r\n"
                                        }
                                            postTM[ sizeof postTM - 1 - cDo -- ] = post2[ 0 ] ;                            
                                        {
                                        if( bArmed )

                                        sGet.readF( tinP , post2 , 1 ) ;
                                        osTextT post2[] = { 0 , 0 } ;
                                    {
                                    while( !POOP && cDo )
                                    etThread.traceF( tinP , T("reading reply") , flTRACE_null , ifcIDtRACEdIVERT_1 ) ;
                                    ZE( countT , lag2 ) ;
                                    ZE( countT , lag1 ) ;
                                    ZE( boolT , bArmed ) ;
                                    countT cDo = sizeof postTM - 1 ;
                                    osTextT postTM[ 0xe ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ;
                                    //                        I   d   e   a   f   a   r   m       (   t   m   )
                                {
                                else
                                }
                                    etThread.traceF( tinP , T("error: could not write request") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
                                    POOPR
                                {
                                if( POOP )

                                sGet.writeF( tinP , (osTextT*)tRequest ) ;
                                etThread.traceF( tinP , T("writing request") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;

                                etThread.osTimeNowF( tinP , timeA1 , timeA2 ) ;
                                ZE( sCountT , timeA2 ) ;
                                ZE( countT  , timeA1 ) ;

                                TN( tRequest , "" ) ; tRequest = T("GET /deadman?idCycle=")+TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" HTTP/1.1\r\nHost: ideafarm.com\r\n\r\n") ;

                                //etThread.traceF( tinP , T("[idpMeBound,idpMe,nnMe]:    ")+TF2(idpMeBound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idpMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(nnMe) ) ;
                            {
                            else
                            }
                                etThread.traceF( tinP , T("error: could not get my connection endpoint name") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
                                POOPR
                            {
                            if( POOP )

                            sGet.myNameF( tinP , idpMe , nnMe ) ;
                            nicNameC nnMe ;
                            ZE( countT , idpMe ) ;
                        {
                        else
                        }
                            etThread.traceF( tinP , T("error: could not connect") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
                            POOPR
                        {
                        if( POOP )

                        sGet.connectF( tinP , 0x50 , pNicName[ 0 ] , 1 ) ;
                        etThread.traceF( tinP , T("connecting") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
                        home.idPortWatchHttp = sGet.bindF( tinP ) ;
                        socketC sGet( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                    {
                {
                else
                }
                    etThread.traceF( tinP , T("error: could not obtain nicName array") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
                    POOPR ;
                {
                if( POOP )

                __Z( cNicName ) ;
                __Z( pNicName ) ;
                socketC::nicNameIF( tinP , *tinP.pEtScratch , pNicName , cNicName , 0/*T("factory3.ideafarm.com")*/ ) ; ___( pNicName ) ;
                ZE( nicNameC* , pNicName ) ;
                ZE( countT , cNicName ) ;

                //etThread.traceF( tinP , T("requesting deadman") ) ;
                SCOOPS
            {
            IFsCRATCH
            boolT bFail = 1 ;

            etThread.traceF( tinP , T("http watch cycle begun [idCycle]:    ")+TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
        {
        if( F(home.flagsAdams) & flHOMEsaDAMS_ROOThTTPsERVER )
    
        //CONoUTrAW5( "cycle " , idCycle , " on thread " , tinP.monitor.idThread , ": querying...\r\n") ;
    
        idCycle ++ ;
    {
    while( !etThread && !ether )
    TN( tTM , "IdeaFarm (tm)" ) ;
    homeS& home = homeS::homeIF() ;
    ZE( countT , idCycle ) ;
    countT idGorilla = 1 + incv02AM( idGorillaLath ) ;

    #endif
        etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;
    #if !defined( CgORILLAS )

    etThread.traceF( tinP , T("WATCH: about to enter watch loop") ) ;
{
if( pTaskP )
TASK( tmWatch05F )
countT idGorillaLath ;
countT idGotAok ;

DONE( tmWatchFileF )
}
    TELL( "terminating" ) ;
    }
        }
            ++ s ; ether.osSleepF( tinP , INSPECTIONpERIODfILE ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {

        }
            etThread.delF( tinP , posti ) ;

            }
                thirdC::osFireIF( tinP ) ;
                etThread.traceF( tinP , T("firing os because a trigger file exists [posti]: ")+T(posti) ) ;
            {
            else
            if( POOP ) { POOPR ; }
            tinP.pEtScratch->boxGetF( tinP , posti , costi , tTriggerFile , 1 ) ; ___( posti ) ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;

            SCOOPS
        {
        IFsCRATCH
    
        ether.traceF( tinP , T("watchfile (triggerfile) cycle begun [idCycle]:    ")+TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        idCycle ++ ;
    {
    while( !etThread && !ether )
    TN( tTriggerFile , "///ideafarm/controls/osfire.txt" ) ;
    ZE( countT , idCycle ) ;

    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;
{
if( pTaskP )
TASK( tmWatchFileF )

DONE( tmWatch05TallyF )
}
    }
        }
            ++ s ; ether.osSleepF( tinP , INSPECTIONpERIOD ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {

        }
            //CONoUTrAW3( "tmWatch05TallyF [flHOMEsuTILITY_SNAPsHOT]: " , F(home.flagsUtility) & flHOMEsuTILITY_SNAPsHOT , "\r\n" ) ;

            }
                }
                    }
                        thirdC::osFireIF( tinP ) ;
                        //CRAFTWORK NOT FINISHED: SNAPsHOT( "watchport05" ) ;
                        etThread.traceF( tinP , tSay , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
                        tSay = T("\r\n")+TT(timeN1,timeN2)+T(" | WATCH: calling osFireIF now") ;
                    
                        ++ s ; ether.osSleepF( tinP , TOCK << 5 ) ; //GIVE MAILoUT TIME TO SEND THIS
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        
                        etThread.emailFactoryReportF( tinP , tSay ) ;
                        etThread.traceF( tinP , tSay , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
                        TELL( tSay ) ;
                        TN( tSay , "sending suicide note: nothing new done and no more forgiving, so will reboot after short nap" ) ;
                    {
                    if( !( cFire ++ ) )

                    etThread.traceF( tinP , tSay , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;

                    ;

                        + T(" | calling osFireIF if i have not already done so")
                        TT(timeN1,timeN2)

                    TN( tSay , "\r\n" ) ; tSay +=

                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                else                                                                                                // ------------ NOTHING NEW HAS BEEN DONE: TIME TO REBOOT
                }
                    home.flagsUtility |= flHOMEsuTILITY_SNAPsHOT ;

                    if( cForgive == CfORGIVE - 1 ) etThread.emailFactoryReportF( tinP , tSay ) ;
                    etThread.traceF( tinP , tSay , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;

                    ;

                        + T(" (http service failure detected)")
                        + TF2(cForgive,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                        + T(" | nothing new has been done.  forgiven.  cForgive is now ")
                        TT(timeN1,timeN2)

                    TN( tSay , "\r\n" ) ; tSay +=

                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                if( cForgive && cForgive -- )                                                                  // ------------ NOTHING NEW HAS BEEN DONE: FORGIVE
            {
            else
            }
                home.flagsUtility &= ~( F(flHOMEsuTILITY_SNAPsHOT) ) ;
                cDoneLag = cDone ;

                }
                    cForgive = CfORGIVE ;

                    etThread.emailFactoryReportF( tinP , tSay ) ;
                    etThread.traceF( tinP , tSay , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
        
                    ;
        
                        + T(" (http service restoration detected)")
                        + T(" to ")                            +TF2(CfORGIVE,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                        + T(" | cForgive is being reset from ")+TF2(cForgive,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                        TT(timeN1,timeN2)
        
                    TN( tSay , "" ) ; tSay =
        
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {
                if( cForgive < CfORGIVE )

                }
                    etThread.emailFactoryReportF( tinP , tSay ) ;
                    etThread.traceF( tinP , tSay , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
                    TN( tSay , "http service detected" ) ;
                {
                if( !cDoneLag )
            {
            else if( cDoneLag < cDone )                                                                         // ------------ MORE HAS BEEN DONE
            }
                etThread.traceF( tinP , tSay , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;

                ;

                    + T(" | cDoneLag is near its capacity so has been reset to 0")
                    TT(timeN1,timeN2)

                TN( tSay , "" ) ; tSay =

                etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT , timeN1 ) ;

                //home.flagsUtility &= ~( F(flHOMEsuTILITY_SNAPsHOT) ) ;
                cDoneLag = cDone = 0 ;
                cForgive = CfORGIVE ;
            {
            if( cDoneLag > MAXcOUNTT - TOCK )                                                                   // ------------ WRAP

            if( cForgive != CfORGIVE && cForgive ) etThread.traceF( tinP , TT(timeN1,timeN2)+T(" | ")+tNote+TF2(cDone,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb+TF2(cDoneLag,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb+TF2(cForgive,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
            ether.traceF( tinP , T("tally cycle begun [cForgive,cDone]:    ")+TF2(cForgive,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb+TF2(cDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
        {
        if( F(home.flagsAdams) & flHOMEsaDAMS_ROOThTTPsERVER && ( !cSkip || !( cSkip -- ) ) )
    {
    while( !ether && !etThread )
    countT cSkip = 8 ;
    ZE( countT , cFire ) ; //U:; TO FIND A BUG
    TN( tNote , " tmWatch05TallyF / inspecting [cDone,cDoneLag,cForgive]: " ) ;
    TN( tcr , "\r\n" ) ;
    TN( tb  , " " ) ;
    ZE( countT , cDoneLag ) ;
    countT cForgive = CfORGIVE ;

    etThread.traceF( tinP , TT(timeB1,timeB2)+T(": tmWatch05TallyF awoke") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_1 ) ;
    etThread.osTimeNowF( tinP , timeB1 , timeB2 ) ;
    ZE( sCountT , timeB2 ) ;
    ZE( countT , timeB1 ) ;

    homeS& home = homeS::homeIF() ;

    }
        ++ s ; ether.osSleepF( tinP , TOCK << 5 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {

    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUDE ) ;
{
if( pTaskP )
TASK( tmWatch05TallyF )

countT cDone ;

// 352_9 THREADS OBSERVED AS A MAXIMUM
//#define CgORILLAS              ( CsESSIONmAXdFLTiFCdRIVENsERVER >> 4 )
//AOK BUT SLOW: #define CgORILLAS              CsESSIONmAXdFLTiFCdRIVENsERVER
//#define CgORILLAS              ( TUCK >> 1 )
//AOK: #define CgORILLAS              0x10
//#define CgORILLAS              0x4
//#define CgORILLAS              0x3
// NORMALLY CgORILLAS IS NOT DEFINED; DEFINE IT TO DO GORILLA TESTING

#define INSPECTIONpERIODfILE ( TICK >> 2 )

#define INSPECTIONpERIOD ( TICK )
// TICK >> 2 --> TICK    (TO REDUCE EMAIL FROM factory4)
// TOCK << 3: TOO MANY FAILURES
// TOCK << 1: TOO MANY FAILURES ON factory5  20190825@1218

#define CfORGIVE 0x10

//#define CfORGIVE 0x40
//#define CfORGIVE 0x2
//U::SHOULD BE 01

// OBSOLETES: 510005ea

/*1*/WAKEhIDE( "ifcIDaDAM_WATCH" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

