
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

#endif

etThread.osEditF( tinP , tLogFile ) ;

}
    trialF( tinP , etThread , ether , 0x40 , 2 , idaDead ) ;
    //etThread.ifcSayF( tinP , T("idaDead:")+TF1(idaDead)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
    etThread.strokeF( tinP , T("idaDead:")+TF1(idaDead)+T("\r\n") ) ;
{
//for( countT idaDead = 0 ; idaDead <= 0 ; idaDead ++ )
for( countT idaDead = 0x17 ; idaDead <= 0x17 ; idaDead ++ )
TN( tLogFile , "///d/ideafarm.log." ) ; tLogFile += TF1(DDNUMB) ;

#else

    }
        }
                trialF( tinP , etThread , ether , cn , cg , idad ) ;
            for( countT cg = cgMin ; cg <= cgMax ; cg ++ )
            //etThread.ifcSayF( tinP , T("idaDead:")+TF1(idad)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
        {
        countT idad = idaDead ;
        //for( countT idad = 1 ; idad <= cn ; idad ++ )
    {
    for( countT cn = cnMin ; cn <= cnMax ; cn ++ )
    
    //etThread.ifcSayF( tinP , TPS("cGossip",8,sttDash)+tb+TPS("cSaw",8,sttDash)+tb+TPS("by_cNics",8,sttDash)+tb+TPS("of_cNics",8,sttDash) , flSAY_APPEND | flSAY_LOG ) ;
    TN( tb , " " ) ;
    strokeS sttDash('-') ;
    TN( tLogFile , "///d/ideafarm.log." ) ; tLogFile += TF1(DDNUMB) ;
    
    idaDead = 2 ;
    cgMin = cgMax = 0 ;
    cnMin = cnMax = 0x10 ;
    
    }
        cgMin = cgMax ;
        cnMin = cnMax ;
    {
    if( bExact )
    ZE( countT , cgMin ) ;
    countT cnMin = 1 ;
    
    }
        }
            else if(    idp == 6 ) idaDead = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
            else if(    idp == 5 ) bExact  = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
            else if(    idp == 4 ) cgMax   = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
                 if( ++ idp == 3 ) cnMax   = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
        {
        FORsTRINGSiN1( pstt1p )
        ZE( countT , idp ) ;
        strokeS* pstt1p = etThread.ether_pstt1_processParametersI_F( tinP ) ;
    {
    ZE( countT , idaDead ) ;
    ZE( boolT  , bExact ) ;
    ZE( countT , cgMax ) ;
    ZE( countT , cnMax ) ;

#if defined( NEVERdEFINED )

TODO

}
    lnicC::armageddonF( tinP , etThread , tLogFile ) ;
    //etThread.strokeF( tinP , T("armageddonF\r\n") ) ;
    //etThread.ifcSayF( tinP , T("cExplosions: ")+TF1(lnicC::cExplosions)+T("\r\nmExplosionsPerTock: ")+TF1((measureT)lnicC::cExplosions/(idTickTock-1)) , flSAY_APPEND | flSAY_LOG ) ;
    
    }
            if( lnicC::ppln[ uida ] ) lnicC::ppln[ uida ]->tockF( tinP ) ;
        for( countT uida = 1 ; uida <= lnicC::cpln ; uida ++ )
            if( lnicC::ppln[ uida ] ) lnicC::ppln[ uida ]->tickF( tinP , idTickTock , uida ) ;
        for( countT uida = 1 ; uida <= lnicC::cpln ; uida ++ )
        //etThread.ifcSayF( tinP , T("******************************** tock ")+TF1(idTickTock)+T(" ********************************") , flSAY_APPEND | flSAY_LOG ) ;
        etThread.strokeF( tinP , T("tock ")+TF1(idTickTock)+T("\r\n") ) ;
    {
    while( !ether && ++ idTickTock <= 0x40 )
    //while( !ether && !lnicC::bFlashSeenByAllF( tinP , etThread ) )
    ZE( countT , idTickTock ) ;
    
    }
        //etThread.strokeF( tinP , T("\r\n") ) ;
        }
            }
                lnicC::ppln[ ida1 ]->logF( tinP , tInitialized2 ) ;
                lnicC::ppln[ ida1 ]->freshKnownF( tinP , 1 ) ;
                lnicC::ppln[ ida1 ]->readNewsF( tinP ) ;
    
                }
                    if( lnicC::ppln[ ida2 ] ) lnicC::ppln[ ida1 ]->newsNewF( tinP , lnicC::ppln[ ida2 ]->nicNameMe ) ;
                {
                for( countT ida2 = 1 ; ida2 <= lnicC::cpln ; ida2 ++ )
            {
            if( lnicC::ppln[ ida1 ] )
            //etThread.strokeF( tinP , T(".") ) ;
        {
        for( countT ida1 = 1 ; !ether && ida1 <= lnicC::cpln ; ida1 ++ )
        TN( tInitialized2 , "init" ) ;
    {
    if( lnicC::ppln )
    //etThread.strokeF( tinP , T("using newsNewF to tell each (even the dead wo) about all\r\n") ) ;
    
    lnicC::genesisF( tinP , etThread , cNicP , cGossipP , idaDeadP ) ;
    //etThread.strokeF( tinP , T("genesisF\r\n") ) ;
    lnicC::setupF( tinP ) ;

    //etThread.ifcSayF( tinP , T("******************************** T R I A L ********************************") , flSAY_APPEND | flSAY_LOG ) ;
    TN( tLogFile , "///d/ideafarm.log." ) ; tLogFile += TF1(DDNUMB) ;
{
voidT trialF( tinS& tinP , etherC& etThread , etherC& ether , const countT cNicP , const countT cGossipP , const countT idaDeadP )

}
    swDeclareNextTock.freeAllF( tinP ) ;

    }
        }
            if( swDeclare < swDeclareNextTock ) swDeclare = swDeclareNextTock ;
            souDeclare = *pSouLever ;
        {
        if( pSouLever )
        soulC* pSouLever = (soulC*)swDeclareNextTock.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swDeclareNextTock.cFlavorsF( tinP ) ;
{
voidT lnicC::tockF( tinS& tinP )

}
    swDeclare.freeAllF( tinP ) ;

    while( stDead ) ;
    }
        }
            }
                }
                    }
                        }
                            }
                                }
                                    }
                                        if( stDead ) idHitDead = 4 ;
                                        if( /*idHitDeadLag <= 4 &&*/ know.pLnicExHit2 && know.pLnicExHit2->shockF( tinP , souShock4 ) ) stDead << know.pLnicExHit2->nicNameMe ;
                                    {
                                    else
                                    if( stDead ) idHitDead = 3 ;
                                    if( idHitDeadLag <= 3 && know.pLnicExHit1 && know.pLnicExHit1->shockF( tinP , souShock3 ) ) stDead << know.pLnicExHit1->nicNameMe ;
                                    freshKnownF( tinP ) ;
                                    souShock4 = souShock3 ;
                                    souShock3 << souDebugNotes ;
                                    souShock3 << souHandlers ;
                                    souShock3 << souNewsOrReplies ;
                                    souShock3 << cGossip ;
                                    souShock3 << nicNameMe ;
                                    souShock3 << ( nicNameAckTo ? nicNameAckTo : nicNameSingularity ) ;
                                    souShock3 << nicNameMe ; // nicNameSingularity
                                    souShock3 << idNewsRef ;
                                    souShock3 << idNewsMe ;
                                    souShock3 << flNews ;
                                    souShock3 << (countT)ifcIDcMDsESSION_NEWS ;
                                    soulC souShock4( tinP , TAG( TAGiDnULL ) ) ;
                                    soulC souShock3( tinP , TAG( TAGiDnULL ) ) ;
                                    cSawFlash ++ ;
                                {
                                if( bGossip )
            
                                if( cGossip ) cGossip = 0 ; // PREVENTS GOSSIP FROM BEING GOSSIPPED
                            {
                            else
                            if( stDead ) idHitDead = 2 ;
                            if( idHitDeadLag <= 2 && know.pLnicExHit2 && know.pLnicExHit2->shockF( tinP , souShock2 ) ) stDead << know.pLnicExHit2->nicNameMe ;
                            if( cGossip ) souShock2.cFieldF( tinP , 8 ) = 0 ; // SINCE HIT1 WILL GOSSIP, DO NOT TELL HIT2 TO GOSSIP (WANT GOSSIP TO BE LINEAR, NOT EXPLOSIVE, IN cGossip)
                        {
                        else
                        if( stDead ) idHitDead = 1 ;
                        if( idHitDeadLag <= 1 && know.pLnicExHit1 && know.pLnicExHit1->shockF( tinP , souShock1 ) ) stDead << know.pLnicExHit1->nicNameMe ;
                    {
                    else
                    }
                        }
                            ( (countT&)swDeclare_cImDead ) ++ ; // FOR IMPLOSIONS, WE DO NOT GOSSIP; INSTEAD, WE RETRY, APPLYING A LARGER BIAS EACH TRY
                            idHitDead = 1 ;
                            stDead << know.pLnicImHit->nicNameMe ;
                        {
                        if( idHitDeadLag <= 1 && know.pLnicImHit && know.pLnicImHit->shockF( tinP , souShock1 ) )
                    {
                    if( bImplode || bDirect )

                    idHitDead = 0 ;
                    countT idHitDeadLag = idHitDead ;

                    freshKnownF( tinP , stKnow( nicNameSingularity ) , bImplode ? swDeclare_cImDead : 0 , bDirect ) ;
                    if( !bImplode && !bDirect ) souShock2 = souShock1 ;
                    souShock1 << souDebugNotes ;
                    souShock1 << souHandlers ;
                    souShock1 << souNewsOrReplies ;
                    souShock1 << cGossip ;
                    souShock1 << nicNameMe ;
                    souShock1 << nicNameAckTo ;
                    souShock1 << nicNameSingularity ;
                    souShock1 << idNewsRef ;
                    souShock1 << idNewsMe ;
                    souShock1 << flNews ;
                    souShock1 << (countT)ifcIDcMDsESSION_NEWS ;
                    soulC souShock2( tinP , TAG( TAGiDnULL ) ) ;
                    soulC souShock1( tinP , TAG( TAGiDnULL ) ) ;
    
                    else if( bGossip ) cGossip -- ;
                    if( bImplode ) cGossip = 0 ;
                    boolT bGossip = !bImplode && !!cGossip && nicNameSingularity != nicNameMe ;
    
                    souDeclare >> souDebugNotes ;
                    soulC souDebugNotes( tinP , TAG( TAGiDnULL ) ) ;

                    souDeclare >> souHandlers ;
                    soulC souHandlers( tinP , TAG( TAGiDnULL ) ) ;

                    souDeclare >> souNewsOrReplies ;
                    soulC souNewsOrReplies( tinP , TAG( TAGiDnULL ) ) ;

                    souDeclare >> nicNameAckTo ;
                    nicNameC nicNameAckTo ;

                    souDeclare >> nicNameSingularity ;
                    nicNameC nicNameSingularity ;

                    souDeclare >> idNewsRef ;
                    ZE( countT , idNewsRef ) ;
    
                    souDeclare >> idNewsMe ;
                    ZE( countT , idNewsMe ) ;

                    __( bDirect && bImplode ) ;
                    boolT bDirect  = !!( F(flNews) & flNEWS_DIRECT  ) ;
                    boolT bImplode = !!( F(flNews) & flNEWS_IMPLODE ) ;
                    souDeclare >> flNews ;
                    ZE( flagsT , flNews ) ;

                    countT cGossip = swDeclare ;

                    }
                        }
                            __( *psd != souDeclare ) ;
                           soulC* psd = (soulC*)(countT)swDeclareSent ;
                        {
                        else // I AM RESENDING
                        }
                            }
                                swDeclareSent = (countT)psd ;
                                *psd = souDeclare ;
                            {
                            if( psd )
                            soulC* psd = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( !swDeclareSent )
                        idNewsAck = souDeclare.cFieldF( tinP , 2 ) ;
                    {

                    souDeclare = *pSouLever ;
                {
                if( pSouLever )
                soulC* pSouLever = (soulC*)swDeclare.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swDeclare.cFlavorsF( tinP ) ;
    
            freshKnownF( tinP ) ;
            readNewsF( tinP ) ;
    
            cExplosions ++ ;
        {
        if( swDeclare.cFlavorsF( tinP ) )

        }
            }
                swDeclare = cGossipOrdered ;
                souDeclare << souDebugNotes ;
                souDeclare << souHandlers ;
                souDeclare << souNews ;
                souDeclare << nicNameC() ; // nicNameAckTo
                souDeclare << nicNameMe ;
                souDeclare << (countT)0 ; // idNewsRef
                souDeclare << ++ idNewsDeclareLast ;
                souDeclare << (countT)flNEWS_DOnOTaCK ;
                souDeclare.removeAllF( tinP ) ;

                soulC souDebugNotes( tinP , TAG( TAGiDnULL ) ) ;

                souHandlers << nicNameMe ;
                soulC souHandlers( tinP , TAG( TAGiDnULL ) ) ;

                souNews << nicNameDead ;
                soulC souNews( tinP , TAG( TAGiDnULL ) , flSOUL_null , (countT)ifcIDnEWSeX_DEL ) ;
        
                newsDelF( tinP , nicNameDead ) ;

                //ether.ifcSayF( tinP , TF1(uidaF(nicNameMe))+T(" is reporting that ")+TF1(uidaDead)+T(" is dead") , flSAY_APPEND | flSAY_LOG ) ;
                //countT uidaDead = uidaF( nicNameDead ) ;
            {
            if( nicNameDead )
            stDead >> nicNameDead ;
            nicNameC nicNameDead ;
        {
        while( stDead )
    {
    do
    ZE( countT , idHitDead ) ;
    ZE( countT , cImDead ) ;
    stackC stDead( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_nicNameC ) ;

    }
        }
            }
                }
                    ether.ifcSayF( tinP , tEntry , flSAY_APPEND | flSAY_LOG ) ;
    
                    }
                        //KEEP THIS soulC AROUND SO CAN REPORT TIMED OUT NEWS: DEL( (soulC*&)(countT&)swDeclareSent ) ;
                        tEntry += T("**** TIMEOUT ****") ;
                    {
                    else if( !tr )
                    }
                        }
                            tEntry += T("**** 1/2 TIMEOUT: ")+TF1((countT)swsNack)+T(" RIFLE SHOTS DECLARED ****") ;
                            while( !ether && ~hDown ) ;
                            }
                                swDeclare = 0 ;
                                souDeclare.nicNameFieldF( tinP , 4 ) = *(nicNameC*)&swsNack.downF( tinP , hDown ) ;

                                //}
                                //    nn = 
                                //    nicNameC& nn = *(nicNameC*)pbnn ;
                                //{
                                //if( pbnn )
                                //__( cbd - 1 - sizeof( nicNameC ) ) ;
                                //__( flags - ( flSOULiTEM_MADEoFcOUNToBJECTS | flSOULiTEM_INCREASINGiNsIGNIFICANCE ) ) ;
                                //__( idType - ifcIDtYPEsOULiTEM_nicNameC ) ;
                                //if( pbnn ) pbnn ++ ;
                                //__Z( pbnn ) ;
                                //const byteT* pbnn = souDeclare.pbFieldF( tinP , idType , flags , cbd , 4 ) ;
                                //ZE( countT , cbd ) ;
                                //ZE( countT , flags ) ;
                                //ZE( countT , idType ) ;
                                //U:
                            {
                            do
                            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                            flNews |= (countT)( flNEWS_DIRECT | flNEWS_DOnOThOLD ) ;
                            flNews &= ~(countT)( F(flNEWS_IMPLODE) ) ;

                            __( idNewsMe - idNewsAck ) ;


                            souDeclare.nicNameFieldF( tinP , 5 ) = nicNameMe ;

                            //}
                            //    nn = nicNameMe ;
                            //    nicNameC& nn = *(nicNameC*)pbnn ;
                            //{
                            //if( pbnn )
                            //__( cbd - 1 - sizeof( nicNameC ) ) ;
                            //__( flags - ( flSOULiTEM_MADEoFcOUNToBJECTS | flSOULiTEM_INCREASINGiNsIGNIFICANCE ) ) ;
                            //__( idType - ifcIDtYPEsOULiTEM_nicNameC ) ;
                            //if( pbnn ) pbnn ++ ;
                            //__Z( pbnn ) ;
                            //const byteT* pbnn = souDeclare.pbFieldF( tinP , idType , flags , cbd , 5 ) ;
                            //ZE( countT , cbd ) ;
                            //ZE( countT , flags ) ;
                            //ZE( countT , idType ) ;

                            countT& idNewsMe = souDeclare.cFieldF( tinP , 2 ) ;
                            flagsT& flNews = souDeclare.cFieldF( tinP , 1 ) ;
                            souDeclare = *psd ;
                        {
                        if( psd )
                        soulC* psd = (soulC*)(countT)swDeclareSent ;
                    {
                    if( tr == TIMEoUT / 2 )
                    tr -- ;
    
                    }
                        while( !ether && ~hDown ) ;
                        }
                            tEntry += TF1(uidaF(*(nicNameC*)&swsNack.downF(tinP,hDown))) ;
                            if( hDown ) tEntry += T(",") ;
                        {
                        do
                        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        tEntry += T("*") ;
                    {
                    if( swsNack )
        
                    }
                        while( !ether && ~hDown ) ;
                        }
                            tEntry += TF1(uidaF(*(nicNameC*)&swsAck.downF(tinP,hDown))) ;
                            if( hDown ) tEntry += T(",") ;
                        {
                        do
                        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( swsAck )
    
                    }
                        swAckAok = 1 ;
                        tEntry += T(" aok: ") ;
                    {
                    if( swsAck && !swsNack && !swAckAok )
                    TN( tEntry , "" ) ; tEntry = TF1(uidaF(nicNameMe))+T(" swsAck<")+TF1(idNewsAck)+T(">:") ;
                {
                if( !swAckAok && tr )
        
                countT& tr = swNackTimeRemaining ;
                __( idNewsAck - swsNack.leverF( tinP , idf ) ) ;
                idNewsAck = swsAck.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavorsAck ; idf ++ )
        {
        if( !ether )
        __( cFlavorsAck - cFlavorsNack ) ;
        countT cFlavorsNack = swsNack.cFlavorsF( tinP ) ;
        countT cFlavorsAck = swsAck.cFlavorsF( tinP ) ;
    
        //if( know.uidaMe == 1 ) logKnowF( tinP ) ;

        }
            }
                swsDebugNotesPending.freeF( tinP ) ;
                swsRepliesPending.freeF( tinP ) ;

                swDeclare = 0 ;
                souDeclare << souDebugNotes ;
                souDeclare << souHandlers ;
                souDeclare << souReplies ;
                souDeclare << nicNameC() ; // nicNameAckTo
                souDeclare << nicNameImPending ;
                souDeclare << (countT)0 ; // idNewsRef
                souDeclare << ++ idNewsDeclareLast ;
                souDeclare << flNews ;
                souDeclare.removeAllF( tinP ) ;

                flNews |= stKnow( nicNameImPending ) ? flNEWS_IMPLODE : flNEWS_DIRECT ;
                flagsT flNews = flNEWS_REPLIES ;
        
                }
                    souDebugNotes << psttn ;
                    swsDebugNotesPending >> psttn ;
                    ZE( strokeS* , psttn ) ;
                {
                while( swsDebugNotesPending )
                soulC souDebugNotes( tinP , TAG( TAGiDnULL ) ) ;

                souHandlers << nicNameMe ;
                soulC souHandlers( tinP , TAG( TAGiDnULL ) ) ;
        
                souReplies << souReply ;
                souReply << nicNameMe ;
                soulC souReply( tinP , TAG( TAGiDnULL ) , flSOUL_null , (countT)ifcIDnEWSiM_TIMEOUT ) ;
        
                }
                    if( psour ) souReplies << *psour ;
                    swsRepliesPending >> psour ;
                    ZE( soulC* , psour ) ;
                {
                while( swsRepliesPending )
                soulC souReplies( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( idTick - swIdTickPending > 8 )
            nicNameImPending = *(nicNameC*)swsRepliesPending.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swsRepliesPending.cFlavorsF( tinP ) ;
    {
    else
    }
        swDeclare = 0 ;
        souDeclare << souDebugNotes ;
        souDeclare << souHandlers ;
        souDeclare << souReplies ;
        souDeclare << nicNameC() ; // nicNameAckTo
        souDeclare << ppln[ 1 ]->nicNameMe ;
        souDeclare << (countT)0 ; // idNewsRef
        souDeclare << ++ idNewsDeclareLast ; // idNewsMe
        souDeclare << (countT)( flNEWS_IMPLODE | flNEWS_REPLIES ) ;
        souDeclare.removeAllF( tinP ) ;

        soulC souDebugNotes( tinP , TAG( TAGiDnULL ) ) ;

        souHandlers << nicNameMe ;
        soulC souHandlers( tinP , TAG( TAGiDnULL ) ) ;

        souReplies << souReply ;
        soulC souReplies( tinP , TAG( TAGiDnULL ) ) ;

        souReply << nicNameMe ;
        soulC souReply( tinP , TAG( TAGiDnULL ) , flSOUL_null , (countT)ifcIDnEWSiM_FLASH ) ;

        bIgniter = 1 ;
        ether.strokeF( tinP , T("ignition ")+TF1(nicNameMe)+T("\r\n") ) ;
    {
    else if( idTickP == 1 && uidaP >= 1 && idFlashMode == ifcIDfLASHmODE_IMPLODE && ppln && ppln[ 1 ] && ppln[ 1 ]->nicNameMe )
    }
        loadNackF( tinP , idNewsDeclareLast ) ;
        swDeclare = cGossipOrdered ;

        souDeclare << souDebugNotes ;
        souDeclare << souHandlers ;
        souDeclare << souNews ;
        souDeclare << nicNameC() ; // nicNameAckTo
        souDeclare << nicNameMe ;
        souDeclare << (countT)0 ; // idNewsRef
        souDeclare << ++ idNewsDeclareLast ; // idNewsMe
        souDeclare << (countT)flNEWS_null ;
        souDeclare.removeAllF( tinP ) ;

        soulC souDebugNotes( tinP , TAG( TAGiDnULL ) ) ;

        souHandlers << nicNameMe ;
        soulC souHandlers( tinP , TAG( TAGiDnULL ) ) ;

        souNews << nicNameMe ;
        soulC souNews( tinP , TAG( TAGiDnULL ) , flSOUL_null , (countT)ifcIDnEWSeX_FLASH ) ;

        cSawFlash ++ ;
        bIgniter = 1 ;
        ether.strokeF( tinP , T("ignition\r\n") ) ;
    {
    if( idTickP == 1 && uidaP == 1 && idFlashMode == ifcIDfLASHmODE_EXPLODE )
    ZE( boolT , bIgniter ) ;

    idTick = idTickP ;
{
voidT lnicC::tickF( tinS& tinP , const countT idTickP , const countT uidaP )

}
    stNew.sinkF( tinP , countTC() , nicNameP , flSTACKsINK_UNIQUE ) ;
{
voidT lnicC::newsNewF( tinS& tinP , const nicNameC& nicNameP )

}
    stHello.sinkF( tinP , countTC() , nicNameP , flSTACKsINK_UNIQUE ) ;
{
voidT lnicC::newsHelloF( tinS& tinP , const nicNameC& nicNameP )

}
    stFlash.sinkF( tinP , countTC() , nicNameP , flSTACKsINK_UNIQUE ) ;
    cSawFlash ++ ;
{
voidT lnicC::newsFlashF( tinS& tinP , const nicNameC& nicNameP )

}
    }
        stFlash >> nicName ;
        nicNameC nicName ;
    {
    while( stFlash )

    }
        stKnow.sinkF( tinP , countTC() , nicName , flSTACKsINK_UNIQUE ) ;
        stHello >> nicName ;
        nicNameC nicName ;
    {
    while( stHello )

    }
        stKnow.sinkF( tinP , countTC() , nicName , flSTACKsINK_UNIQUE ) ;
        stNew >> nicName ;
        nicNameC nicName ;
    {
    while( stNew )

    }
        }
            }
                __( nnd - nicName ) ;
                swsNack.extractF( tinP , nnd ) ;
                nicNameC nnd ;
            {
            if( swsNack( nicName ) )
            idNewsAck = swsNack.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swsNack.cFlavorsF( tinP ) ;

        }
            __( nnd - nicName ) ;
            stKnow.extractF( tinP , nnd ) ;
            nicNameC nnd ;
        {
        if( stKnow( nicName ) )
        stDel >> nicName ;
        nicNameC nicName ;
    {
    while( stDel )
{
voidT lnicC::readNewsF( tinS& tinP )

}
    stDel.sinkF( tinP , countTC() , nicNameP , flSTACKsINK_UNIQUE ) ;
{
voidT lnicC::newsDelF( tinS& tinP , const nicNameC& nicNameP )

}
    if( tinP.fingerprint ) ;

    }
        }
            }
                }
                    else if( ppln[ idn ]->nicNameMe == know.nicNameExHit2 ) know.pLnicExHit2 = ppln[ idn ] ;
                         if( ppln[ idn ]->nicNameMe == know.nicNameExHit1 ) know.pLnicExHit1 = ppln[ idn ] ;
                {
                if( ppln[ idn ] )
            {
            for( countT idn = 1 ; idn <= cpln ; idn ++ )
            know.pLnicExHit2 = know.pLnicExHit1 = 0 ;
            know.nicNameExHit2 = know.idaExHit2 ? *(nicNameC*)&stKnow[ know.idaExHit2 ] : nicNameC() ;
            know.nicNameExHit1 = know.idaExHit1 ? *(nicNameC*)&stKnow[ know.idaExHit1 ] : nicNameC() ;
            know.idaExHit2 = idaF( know.idrExHit2 , know.idaSingularity , know.cKnown ) ;
            know.idaExHit1 = idaF( know.idrExHit1 , know.idaSingularity , know.cKnown ) ;
            if( know.cKnown < know.idrExHit2 ) know.idrExHit2 = 0 ;
            if( know.cKnown < know.idrExHit1 ) know.idrExHit1 = 0 ;
            know.idrExHit2 = know.idrExHit1 + 1 ;
            know.idrExHit1 = cc + 2 * oMe ;
    
            }
                 if( ppln[ idn ] && ppln[ idn ]->nicNameMe == know.nicNameImHit ) know.pLnicImHit = ppln[ idn ] ;
            {
            for( countT idn = 1 ; idn <= cpln ; idn ++ )
            know.pLnicImHit = 0 ;
            know.nicNameImHit = know.idaImHit ? *(nicNameC*)&stKnow[ know.idaImHit ] : nicNameC() ;
            know.idaImHit = idaF( know.idrImHit , know.idaSingularity , know.cKnown ) ;
            if( (sCountT)know.idrImHit < 0 ) know.idrImHit = 0 ;
            know.idrImHit = aa + oMe / 2 - cImDeadP ;
    
            countT oMe = know.idrMe - bb ;  //MY OFFSET AMONG MY PEERS IN RELAYING THIS EXPLOSION
            const countT cc  = bb << 1 ;                //2**(t+1)
            const countT bb  = aa << 1 ;                //2**t
            const countT aa  =  1 << know.exTime - 1 ;  //2**(t-1)
        {
        else
        }
            }
                 if( ppln[ idn ] && ppln[ idn ]->nicNameMe == know.nicNameImHit ) know.pLnicImHit = ppln[ idn ] ;
            {
            for( countT idn = 1 ; idn <= cpln ; idn ++ )
            know.pLnicImHit = 0 ;
            know.nicNameImHit = *(nicNameC*)&stKnow[ idaSingularityP ] ;
        {
        if( bDirectP )
    {
    if( !ether )
    __( know.exTime > 0x1e ) ;
    know.exTime         = know.idrMe ? (countT)tinP.brcm04Raw : 0 ;
    BOSmEASURE04( WHATgbo , log2( know.idrMe ) )
    know.idrMe          = idrF( know.idaMe , know.idaSingularity , know.cKnown ) ;
    know.idaSingularity = idaSingularityP ? idaSingularityP : know.idaMe ;

    know.uidaMe         = uidaF( nicNameMe ) ;
    know.idaMe          = stKnow( nicNameMe ) ;
    know.exTimeMax      = know.cKnown ? (countT)tinP.brcm04Raw : 0 ;
    BOSmEASURE04( WHATgbo , log2( know.cKnown ) )
    know.cKnown         = stKnow ;

    ether.memSetF( tinP , (byteT*)&know , sizeof know ) ;

    __( bDirectP && !idaSingularityP ) ;
    __( bDirectP && cImDeadP ) ;

{
voidT lnicC::freshKnownF( tinS& tinP , const countT idaSingularityP , const countT cImDeadP , const boolT bDirectP )

}
    __Z( idp ) ;
    stKnow.sinkF( tinP , idp , nicNameMe , flSTACKsINK_UNIQUE ) ;
    ZE( countT , idp ) ;

    ether.memSetF( tinP , (byteT*)&know , sizeof know ) ;
    ether.strMakeF( tinP , LF , psttLogFile , T("///d/ideafarm.log.")+TF1(DDNUMB) ) ; ___( psttLogFile ) ;

    }
        if( ether ) return ;
        __Z( nicNameMe ) ;
        if( ether ) return ;
    {
    IFbEcAREFUL
{
swNackTimeRemaining( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , idNewsAck )
swAckAok( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , idNewsAck ) ,
swsNack( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , idNewsAck , flSTACKc_FIFO , ifcSTACKtYPE_nicNameC ) ,
swsAck( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , idNewsAck , flSTACKc_FIFO , ifcSTACKtYPE_nicNameC ) ,
idNewsAck( 0 ) ,
idNewsDeclareLast( 0 ) ,
idTick( 0 ) ,
swIdTickPending( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , nicNameImPending ) ,
swsDebugNotesPending( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , nicNameImPending , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ,
swsRepliesPending( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , nicNameImPending , flSTACKc_FIFO , ifcSTACKtYPE_PTR_soulC ) ,
cSawFlash( 0 ) ,
psttLogFile( 0 ) ,
bOnline( 1 ) ,
swDeclareSent( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , idNewsAck ) ,
swDeclare_cImDead( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , souDeclare ) ,
swDeclareNextTock( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , souDeclare ) ,
swDeclare( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , souDeclare ) ,
souDeclare( tinP , ether ) ,
stDel(          tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ,
stNew(          tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ,
stFlash(        tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ,
stHello(        tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ,
stKnow(         tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ,
nicNameMe( nicNameMeP ) ,
ether( etherP ) ,
lnicC::lnicC( tinS& tinP , etherC& etherP , const nicNameC& nicNameMeP ) :

}
    if( tinP.fingerprint ) ;

    cExplosions = 0 ;
    ppln = 0 ;
    cpln = 0 ;
    cGossipOrdered = 0 ;
{
voidT lnicC::setupF( tinS& tinP )

const countT    lnicC::idFlashMode = ifcIDfLASHmODE_EXPLODE ;
countT          lnicC::cExplosions ;
lnicC**         lnicC::ppln ;
countT          lnicC::cpln ;
countT          lnicC::cGossipOrdered ;

}
    ether.delF( tinP , psttLogFile ) ;

    }
        }
            DEL( (soulC*&)(countT&)swDeclareSent ) ;
            idNewsAck = swDeclareSent.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swDeclareSent.cFlavorsF( tinP ) ;
    {

    TINSL
{
lnicC::~lnicC( voidT )

NEWdELcLASSb( lnicC )

}
    return bSeen ;

    }
        }
            break ;
            bSeen = 0 ;
        {
        if( ppln[ idn ] && !ppln[ idn ]->cSawFlash )
    {
    for( countT idn = 1 ; idn <= cpln ; idn ++ )
    boolT bSeen = 1 ;

    }
        if( etThreadP ) return 0 ;
        __Z( ppln ) ;
        if( etThreadP ) return 0 ;
    {
    IFbEcAREFUL
{
boolT lnicC::bFlashSeenByAllF( tinS& tinP , etherC& etThreadP )

}
    }
        //etThreadP.ifcSayF( tinP , TF3(cGossipOrdered,flFORMAT_null,8)+tb+TF3(cLever,flFORMAT_null,8)+tb+TF3(swSawFlash,flFORMAT_null,8)+tb+TF3(cpln,flFORMAT_null,8) , flSAY_APPEND | flSAY_LOG ) ;
        etThreadP.ifcSayF( tinP , T("**** the flash was seen ")+TF1(cLever)+T(" times by ")+TF1(swSawFlash)+T(" nics") , flSAY_APPEND | flSAY_LOG ) ;
        cLever = swSawFlash.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swSawFlash.cFlavorsF( tinP ) ;
    TN( tb , " " ) ;

    for( countT idn = 1 ; idn <= cpln ; idn ++ ) { DEL( ppln[ idn ] ) ; }

    }
        }
            ++ ( (countT&)swSawFlash ) ;
            cLever = ppln[ idn ]->cSawFlash ;
            etThreadP.ifcSayF( tinP , T("[")+TF1(idn)+T("] saw the flash ")+TF1(ppln[idn]->cSawFlash)+T(" times")+(ppln[idn]->bOnlineF(tinP)?T(""):T(" OFFLINE"))+(ppln[idn]->cSawFlash?T(""):T(" BLIND")) , flSAY_APPEND | flSAY_LOG ) ;
        {
        if( ppln[ idn ] )
    {
    for( countT idn = 1 ; idn <= cpln ; idn ++ )
    switchC swSawFlash( tinP , etThreadP , TAG( TAGiDnULL ) , flSTACKc_null , cLever ) ;
    ZE( countT , cLever ) ;

    }
        if( etThreadP ) return ;
        __Z( ppln ) ;
        if( etThreadP ) return ;
    {
    IFbEcAREFUL
{
voidT lnicC::armageddonF( tinS& tinP , etherC& etThreadP , const strokeS* const psttLogFileP )

}
    return !bOnline ;

    }
        }
            }
                else ether.ifcSayF( tinP , T("[")+TF1(idNewsMe)+tc+TF1(idNewsRef)+T("] i")+TF1(uidaF(nicNameSingularity))+TPS(".",1+know.exTime,S1C('.'))+T("|")+TF1(uidaF(nicNameMe))+T("<")+TF1(uidaF(nicNameFrom))+tb81+tNewsOrReplies+tb81+tHandlers+tb81+tDebugNotes , flSAY_APPEND | flSAY_LOG ) ;
                }
                    if( swDeclareNextTock < cGossip ) swDeclareNextTock = cGossip ;
                    souDeclare << souDebugNotes ;
                    souDeclare << souHandlers ;
                    souDeclare << souReplies ;
                    souDeclare << nicNameC() ; // nicNameAckTo
                    souDeclare << nicNameSingularity ;
                    souDeclare << idNewsRef ;
                    souDeclare << idNewsMe ;
                    souDeclare << flNews ;
                    souDeclare.removeAllF( tinP ) ;
                    ether.ifcSayF( tinP , T("[")+TF1(idNewsMe)+tc+TF1(idNewsRef)+T("] i")+TF1(uidaF(nicNameSingularity))+TPS(".",1+know.exTime,S1C('.'))+T("<")+TF1(uidaF(nicNameMe))+T("<")+TF1(uidaF(nicNameFrom))+tb81+tNewsOrReplies+tb81+tHandlers+tb81+tDebugNotes , flSAY_APPEND | flSAY_LOG ) ;
                {
                if( bFlush )
    
                freshKnownF( tinP , stKnow( nicNameSingularity ) ) ;
        
                }                   // ALL REPLIES THAT I HAVE ARE NOW EITHER IN souReplies OR IN swsRepliesPending (DITTO FOR NOTES)
                    swsDebugNotesPending.freeF( tinP ) ;
                    }
                        souDebugNotes << psttn ;
                        swsDebugNotesPending >> psttn ;
                        ZE( strokeS* , psttn ) ;
                    {
                    while( swsDebugNotesPending )
    
                    swsRepliesPending.freeF( tinP ) ;
                    }
                        if( psour ) souReplies << *psour ;
                        swsRepliesPending >> psour ;
                        ZE( soulC* , psour ) ;
                    {
                    while( swsRepliesPending )
                {
                if( bFlush )
    
                swIdTickPending = !bFlush && swsRepliesPending ? idTick : 0 ;
    
                }
                    swsDebugNotesPending << psttn ;
                    souDebugNotes >> psttn ; ___( psttn ) ;
                    ZE( strokeS* , psttn ) ;
                {
                while( souDebugNotes )
    
                }
                    }
                        swsRepliesPending << psour ;
                        souReplies >> *psour ;
                    {
                    if( psour )
                    soulC* psour = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                {
                while( souReplies )
    
                boolT bFlush = F(flNews) & flNEWS_DOnOThOLD || !!swsRepliesPending ;

                __( bDirect ) ;
            {
            else
            }
                }
                    }
                        }
                            __1
                            __( idType ) ;
                        {
                        default :
                        }
                            break ;

                            swsAck.sinkF( tinP , countTC() , nicNameReplier ) ;

                            }
                                __1
                                __( uidaF( nicNameReplier ) ) ;
                                ether.ifcSayF( tinP , T("unexpected ack received by ")+TF1(uidaF(nicNameMe))+T(" from ")+TF1(uidaF(nicNameReplier)) , flSAY_APPEND | flSAY_LOG ) ;
                            {
                            else if( !swsAck(  nicNameReplier ) )
                            }
                                __( nnd - nicNameReplier ) ;
                                swsNack.extractF( tinP , nnd ) ;
                                nicNameC nnd ;
                            {
                            if(  swsNack( nicNameReplier ) )

                            idNewsAck = idNewsAcked ;

                            souReply >> idNewsAcked ;
                            ZE( countT , idNewsAcked ) ;

                            souReply >> nicNameReplier ;
                            nicNameC nicNameReplier ;
                        {
                        case ifcIDnEWSiM_ACK :
                        case ifcIDnEWSiM_TIMEOUT : { break ; }
                    {
                    switch( idType )
                    souReply >> idType ;
                    ZE( countT , idType ) ;

                    souReplies >> souReply ;
                    soulC souReply( tinP , TAG( TAGiDnULL ) ) ;
                {
                while( souReplies )

                ether.ifcSayF( tinP , tEntry , flSAY_APPEND | flSAY_LOG ) ;
                tEntry += T("[")+TF1(idNewsMe)+tc+TF1(idNewsRef)+T("] s")+TF1(uidaF(nicNameMe))+T("<")+TF1(uidaF(nicNameFrom))+tb81+tNewsOrReplies+tb81+tHandlers+tb81+tDebugNotes ;
                TN( tEntry , "" ) ;
            {
            if( nicNameSingularity == nicNameMe )

            soulC& souReplies = souNewsOrReplies ;
        {
        else
        }
            }
                swDeclare = 0 ;
                souDeclare << souDebugNotes ;
                souDeclare << souHandlersA ;
                souDeclare << souReplies ;
                souDeclare << nicNameC() ; // nicNameAckTo
                souDeclare << nicNameImPending ;
                souDeclare << idNewsMe ;
                souDeclare << ++ idNewsDeclareLast ;
                souDeclare << (countT)( bDirect ? flNEWS_DIRECT | flNEWS_REPLIES : flNEWS_IMPLODE | flNEWS_REPLIES ) ;
                souDeclare.removeAllF( tinP ) ;
                
                souHandlersA << nicNameMe ;
                soulC souHandlersA( tinP , TAG( TAGiDnULL ) ) ;
                soulC souDebugNotes( tinP , TAG( TAGiDnULL ) ) ;
                
                souReplies << souReply ;
                soulC souReplies( tinP , TAG( TAGiDnULL ) ) ;
                
                souReply << idNewsMe ;
                souReply << nicNameMe ;
                soulC souReply( tinP , TAG( TAGiDnULL ) , flSOUL_null , (countT)ifcIDnEWSiM_ACK ) ;
            {
            if( !( F(flNews) & flNEWS_DOnOTaCK ) )

            }
                }
                    break ;
    
                    }
                        if( swDeclareNextTock < cGossip ) swDeclareNextTock = cGossip ;
                        souDeclare << souDebugNotes ;
                        souDeclare << souHandlers ;
                        souDeclare << souNews ;
                        souDeclare << nicNameAckTo ;
                        souDeclare << nicNameSingularity ;
                        souDeclare << idNewsRef ;
                        souDeclare << idNewsMe ;
                        souDeclare << flNews ;
                        souDeclare.removeAllF( tinP ) ;
    
                        souNews << nicNameData ;
                        soulC souNews( tinP , TAG( TAGiDnULL ) , flSOUL_null , idNewsType ) ;

                        __( F(flNews) & flNEWS_IMPLODE ) ; //THERE IS CODE FOR IMPLODING REPLIES BUT NOT NEWS
                    {
                    if( !bDirect )
    
                    ether.ifcSayF( tinP , T("[")+TF1(idNewsMe)+tc+TF1(idNewsRef)+T("] e")+TF1(uidaF(nicNameSingularity))+TPS(".",1+know.exTime,S1C('.'))+TF1(uidaF(nicNameFrom))+T(">")+TF1(uidaF(nicNameMe))+T(";")+TF1(idNewsType)+tc+TF1(cGossip)+tc+TF1(uidaF(nicNameData))+tb81+tNewsOrReplies+tb81+tHandlers+tb81+tDebugNotes , flSAY_APPEND | flSAY_LOG ) ;
                    freshKnownF( tinP , stKnow( nicNameSingularity ) ) ;
    
                    }
                        case ifcIDnEWSeX_DEL   : { newsDelF(   tinP , nicNameData ) ; break ; }
                        case ifcIDnEWSeX_FLASH : { newsFlashF( tinP , nicNameData ) ; break ; }
                        case ifcIDnEWSeX_HELLO : { newsHelloF( tinP , nicNameData ) ; break ; }
                    {
                    switch( idNewsType )
    
                    souNews >> nicNameData ;
                    nicNameC nicNameData ;
                {
                case ifcIDnEWSeX_DEL   :
                case ifcIDnEWSeX_FLASH :
                case ifcIDnEWSeX_HELLO :
            {
            switch( idNewsType )
            souNews >> idNewsType ;
            ZE( countT , idNewsType ) ;

            soulC& souNews = souNewsOrReplies ;
        {
        if( !( F(flNews) & flNEWS_REPLIES ) )
        boolT bDirect = !!( F(flNews) & flNEWS_DIRECT ) ;

        }
            if( tDebugNotes.csF( tinP ) ) tDebugNotes += T("|") ;
            }
                }
                    tDebugNotes += T(psttNote) ;
                    else                           tDebugNotes += tc ;
                    if( !tDebugNotes.csF( tinP ) ) tDebugNotes = ti ;
    
                    __( cb - 1 - sizeof( strokeS ) * ( psttNote->idAdam + CSpREFIX ) ) ;
                    __( idType - ifcIDtYPEsOULiTEM_strokeSptr ) ;
                {
                if( 1 < (countT)psttNote )

                const strokeS* const psttNote = (strokeS*)( 1 + souDebugNotes.pbFieldF( tinP , idType , flags , cb , idn ) ) ;
                ZE( countT , cb ) ;
                ZE( flagsT , flags ) ;
                ZE( countT , idType ) ;
            {
            for( countT idn = 1 ; idn <= cNotes ; idn ++ )
            const countT cNotes = souDebugNotes ;
            TN( ti , "|" ) ;
        {
        TN( tDebugNotes , "" ) ;
    
        }
            if( tHandlers.csF( tinP ) ) tHandlers += T("}") ;
            }
                tHandlers += TF1(uidaF(souHandlers.nicNameFieldF(tinP,idh))) ;

                //}
                //    tHandlers += T(uidaF(nn)) ;
                //    nicNameC& nn = *(nicNameC*)pbnn ;
                //{
                //if( pbnn )
                //__( cbd - 1 - sizeof( nicNameC ) ) ;
                //__( flags - ( flSOULiTEM_MADEoFcOUNToBJECTS | flSOULiTEM_INCREASINGiNsIGNIFICANCE ) ) ;
                //__( idType - ifcIDtYPEsOULiTEM_nicNameC ) ;
                //if( pbnn ) pbnn ++ ;
                //__Z( pbnn ) ;
                //const byteT* pbnn = souHandlers.pbFieldF( tinP , idType , flags , cbd , idh ) ;
                //ZE( countT , cbd ) ;
                //ZE( countT , flags ) ;
                //ZE( countT , idType ) ;
                //U:

                else                         tHandlers += tc ;
                if( !tHandlers.csF( tinP ) ) tHandlers = ti ;
            {
            for( countT idh = 1 ; idh <= cHandlers ; idh ++ )
            const countT cHandlers = souHandlers ;
            TN( ti , "{" ) ;
        {
        TN( tHandlers , "" ) ;
    
        }
            //if( tNewsOrReplies.csF( tinP ) ) tNewsOrReplies += T(".") ;
            }
                }
                    }
                        __1
                        __( idType ) ;
                    {
                    default :
                    }
                        break ;

                        tNewsOrReplies += TF1(uidaF(souNewsOrReplies.nicNameFieldF(tinP,2))) ;

                        //}
                        //    tNewsOrReplies += TF1(uidaF(nn)) ;
                        //    nicNameC& nn = *(nicNameC*)pbnn ;
                        //{
                        //if( pbnn )
                        //__( cbd - 1 - sizeof( nicNameC ) ) ;
                        //__( flags - ( flSOULiTEM_MADEoFcOUNToBJECTS | flSOULiTEM_INCREASINGiNsIGNIFICANCE ) ) ;
                        //__( idType - ifcIDtYPEsOULiTEM_nicNameC ) ;
                        //if( pbnn ) pbnn ++ ;
                        //__Z( pbnn ) ;
                        //const byteT* pbnn = souNewsOrReplies.pbFieldF( tinP , idType , flags , cbd , 2 ) ;
                        //ZE( countT , cbd ) ;
                        //ZE( countT , flags ) ;
                        //ZE( countT , idType ) ;
                        //U:

                        }
                            case ifcIDnEWSeX_DEL   : { tNewsOrReplies += T("d:") ; break ; }
                            case ifcIDnEWSeX_FLASH : { tNewsOrReplies += T("f:") ; break ; }
                            case ifcIDnEWSeX_HELLO : { tNewsOrReplies += T("d:") ; break ; }
                        {
                        switch( idType )
                    {
                    case ifcIDnEWSeX_DEL   :
                    case ifcIDnEWSeX_FLASH :
                    case ifcIDnEWSeX_HELLO :
                {
                switch( idType )
                countT idType = souNewsOrReplies.cFieldF( tinP , 1 ) ;
                //tNewsOrReplies = ti ;
            {
            else
            }
                }
                    }
                        }
                            }
                                break ;
                                tNewsOrReplies += (idType==ifcIDnEWSiM_ACK?T("a")+T("-")+TF1(uidaF(nicNameImPending))+T(".")+TF1(idNewsAcked):T("t"))+T(":")+TF1(uidaF(nicNameReplier)) ;
                                else                              tNewsOrReplies += tc ;
                                if( !tNewsOrReplies.csF( tinP ) ) /*tNewsOrReplies  = ti*/ ;

                                if( idType == ifcIDnEWSiM_ACK ) souReply >> idNewsAcked ;
                                ZE( countT , idNewsAcked ) ;

                                souReply >> nicNameReplier ;
                                nicNameC nicNameReplier ;
                            {
                            case ifcIDnEWSiM_ACK :
                            case ifcIDnEWSiM_TIMEOUT : flNews |= flNEWS_DOnOThOLD ;
                        {
                        switch( idType )
                        souReply >> idType ;
                        ZE( countT , idType ) ;
                        soulC souReply( tinP , TAG( TAGiDnULL ) , pbs , flSOUL_null , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                        __( idType - ifcIDtYPEsOULiTEM_soulC ) ;
                    {
                    if( pbs )
                    const byteT* pbs = souNewsOrReplies.pbFieldF( tinP , idType , flags , cb , idr ) ;
                    ZE( countT , cb ) ;
                    ZE( flagsT , flags ) ;
                    ZE( countT , idType ) ;
                {
                for( countT idr = 1 ; idr <= cReplies ; idr ++ )
                const countT cReplies = souNewsOrReplies ;
            {
            if( F(flNews) & flNEWS_REPLIES )
            //TN( ti , "." ) ;
        {
        TN( tNewsOrReplies , "" ) ;
        TN( tb81 , "" ) ; tb81 = TP("",0x18) ;
        TN( tc , "," ) ;
    
        soulP >> souDebugNotes ;
        soulC souDebugNotes( tinP , TAG( TAGiDnULL ) ) ;

        souHandlers << nicNameMe ;
        soulP >> souHandlers ;
        soulC souHandlers( tinP , TAG( TAGiDnULL ) ) ;

        soulP >> souNewsOrReplies ;
        soulC souNewsOrReplies( tinP , TAG( TAGiDnULL ) ) ;

        soulP >> cGossip ;
        ZE( countT , cGossip ) ;

        soulP >> nicNameFrom ;
        nicNameC nicNameFrom ;

        nicNameImPending = nicNameAckTo ? nicNameAckTo : nicNameSingularity ;

        soulP >> nicNameAckTo ;
        nicNameC nicNameAckTo ;

        soulP >> nicNameSingularity ;
        nicNameC nicNameSingularity ;

        soulP >> idNewsRef ;
        ZE( countT , idNewsRef ) ;

        soulP >> idNewsMe ;
        ZE( countT , idNewsMe ) ;

        soulP >> flNews ;
        ZE( flagsT , flNews ) ;

        __( idCmdCatch - ifcIDcMDsESSION_NEWS ) ;
        soulP >> idCmdCatch ;
        ZE( countT , idCmdCatch ) ;
    {
    if( bOnline && soulP )
{
boolT lnicC::shockF( tinS& tinP , soulC& soulP )

}
    }
        if( idaDeadP && idaDeadP <= cpln && ppln[ idaDeadP ] ) ppln[ idaDeadP ]->bOnlineF( tinP , 0 ) ;

        for( countT idn = 1 ; idn <= cpln ; idn ++ ) ppln[ idn ] = new( 0 , tinP , LF ) lnicC( tinP , etThreadP , *(nicNameC*)&stLNNA[ idn ] ) ;
        *ppln = 0 ;                                             // CONSTRUCT THE LOGICAL NIC HARDWARE
    {
    if( ppln )
    etThreadP.newF( tinP , LF , (countT*&)ppln , 1 + cpln ) ; ___( ppln ) ;
    
    cpln = stLNNA ;
    }
        }
            while( !idp ) stLNNA.sinkF( tinP , idp , nicNameC( 1 + ru , 1 + ru , 1 + ru , 1 + ru ) , flSTACKsINK_UNIQUE ) ;
            ZE( countT , idp ) ;
        {
        while( !etPrime && cTries -- )
        countT cTries = cLNicsP ;
        ranUniC ru( 0xffffffff , - 1 ) ;
        etherC& etPrime = etThreadP.etPrimeIF( tinP ) ;
    {
    stackC stLNNA( tinP , etThreadP , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ; // GENERATE A LIST OF ASSIGNED nicNameC VALUES

    TN( tp , "pushing " ) ;
    TN( td , "." ) ;
    TN( tb , " " ) ;
    TN( te , "\r\n" ) ;                                         // GENERALLY USEFUL STACK OBJECTS

    cGossipOrdered = cGossipP ;

    }
        if( etThreadP ) return ;
        __NZ( ppln ) ;
        if( etThreadP ) return ;
    {
    IFbEcAREFUL
{
voidT lnicC::genesisF( tinS& tinP , etherC& etThreadP , const countT cLNicsP , const countT cGossipP , const countT idaDeadP )

}
    //ether.ifcSayF( tinP , tEntry , flSAY_APPEND | flSAY_LOG ) ;

    ;

        +tb+ta+tc+TF3(know.idaExHit2    ,flFORMAT_null,3)
        +tb+t9+tc+TF3(know.idaExHit1    ,flFORMAT_null,3)
        +tb+t8+tc+TF3(know.idrExHit2    ,flFORMAT_null,3)
        +tb+t7+tc+TF3(know.idrExHit1    ,flFORMAT_null,3)
        +tb+t6+tc+TF3(know.exTime      ,flFORMAT_null,3)
        +tb+t5+tc+TF3(know.idrMe      ,flFORMAT_null,3)
        +tb+t4+tc+TF3(know.idaSingularity,flFORMAT_null,3)
        +tb+t3+tc+TF3(know.idaMe      ,flFORMAT_null,3)
        +tb+t2+tc+TF3(know.cKnown     ,flFORMAT_null,3)
        +tb+t1+tc+T(nicNameMe)

    TN( tEntry , "" ) ; tEntry = T(psttTitleP)+T(":")

    TN( ta , "idaExHit2" ) ;
    TN( t9 , "idaExHit1" ) ;
    TN( t8 , "idrExHit2" ) ;
    TN( t7 , "idrExHit1" ) ;
    TN( t6 , "exTime" ) ;
    TN( t5 , "idrMe" ) ;
    TN( t4 , "idaSingularity" ) ;
    TN( t3 , "idaMe" ) ;
    TN( t2 , "cKnown" ) ;
    TN( t1 , "nicNameMe" ) ;
    TN( te , "\r\n" ) ;
    TN( tc , ":" ) ;
    TN( tb , " " ) ;
{
voidT lnicC::logF( tinS& tinP , const strokeS* const psttTitleP )

}
    if( tinP.fingerprint ) ;
    }
        logF( tinP , bOnline ? T("DATA CABLE FIXED") : T("DATA CABLE KICKED OUT OF WALL SOCKET") ) ;
        bOnline = !!bOnlineP ;
    {
    if( !!bOnlineP - !!bOnline )
{
voidT lnicC::bOnlineF( tinS& tinP , const boolT bOnlineP )

}
    return bOnline ;
    if( tinP.fingerprint ) ;
{
boolT lnicC::bOnlineF( tinS& tinP )

}
    return uida ;

    }
        }
            break ;
            uida = idn ;
        {
        if( ppln[ idn ] && ppln[ idn ]->nicNameMe == nicNameP )
    {
    for( countT idn = 1 ; idn <= cpln ; idn ++ )
    ZE( countT , uida ) ;
{
countT lnicC::uidaF( const nicNameC& nicNameP )

}
    //if( tEntry.csF( tinP ) ) ether.ifcSayF( tinP , tEntry , flSAY_APPEND | flSAY_LOG ) ;

    }
        while( !ether && ~hDown ) ;
        }
            }
                tEntry += TF1(uidaF(nicName)) ;
                else                      tEntry += T(",") ;
                if( !tEntry.csF( tinP ) ) tEntry = TF1(uidaF(nicNameMe))+T(" loading swsNack: ") ;

                swsNack.sinkF( tinP , countTC() , nicName , flSTACKsINK_UNIQUE ) ;
            {
            if( nicName != nicNameMe )
            nicNameC nicName = *(nicNameC*)&stKnow.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        swNackTimeRemaining = TIMEoUT ;

        }
            swsAck >> nnb ;
            swsAck.sinkF( tinP , countTC() , nnb ) ; // TO ENSURE THAT ALL FLAVORS IN swsNack ARE ALSO IN swsAck
            nicNameC nnb ;
            __( swsAck ) ;
        {
        idNewsAck = idNewsDeclareP ;
    {
    if( stKnow )
    TN( tEntry , "" ) ;
{
voidT lnicC::loadNackF( tinS& tinP , const countT idNewsDeclareP )

}
    ether.ifcSayF( tinP , tEntry , flSAY_APPEND | flSAY_LOG ) ;

    }
        while( !ether && ~hDown ) ;
        }
            tEntry += TF1(uidaF(nicName)) ;
            else                      tEntry += T(",") ;
            if( !tEntry.csF( tinP ) ) tEntry = TF1(uidaF(nicNameMe))+T(" knows: ") ;
            nicNameC nicName = *(nicNameC*)&stKnow.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stKnow )
    TN( tEntry , "" ) ;
{
voidT lnicC::logKnowF( tinS& tinP )

;
}
    voidT                       logKnowF( tinS& tinP ) ;
    voidT                       loadNackF( tinS& tinP , const countT idNewsDeclareP ) ;
    boolT                       shockF( tinS& tinP , soulC& soulP ) ;
    boolT                       bOnlineF( tinS& tinP ) ;
    voidT                       bOnlineF( tinS& tinP , const boolT bOnlineP ) ;
    voidT                       tockF( tinS& tinP ) ;
    voidT                       tickF( tinS& tinP , const countT idTickP , const countT uidaP ) ;
    voidT                       readNewsF( tinS& tinP ) ;
    voidT                       logF( tinS& tinP , const strokeS* const psttTitleP ) ;
    voidT                       freshKnownF( tinS& tinP , const countT idaSingularityP = 0 , const countT cImDeadP = 0 , const boolT bDirectP = 0 ) ;
    voidT                       newsDelF( tinS& tinP , const nicNameC& nicNameP ) ;
    voidT                       newsNewF( tinS& tinP , const nicNameC& nicNameP ) ;
    voidT                       newsFlashF( tinS& tinP , const nicNameC& nicNameP ) ;
    voidT                       newsHelloF( tinS& tinP , const nicNameC& nicNameP ) ;
                                lnicC( tinS& tinP , etherC& etherP , const nicNameC& nicNameMeP ) ;
                                ~lnicC( voidT ) ;
                                NEWdELcLASSpROTOS( lnicC , etherC , thirdC )

    nicNameC                    nicNameMe ;

    public :

    switchC                     swNackTimeRemaining ;
    switchC                     swAckAok ;
    switchStackC                swsAck ;
    switchStackC                swsNack ;
    countT                      idNewsDeclareLast ;
    countT                      idTick ;
    switchC                     swIdTickPending ;
    switchStackC                swsDebugNotesPending ;
    switchStackC                swsRepliesPending ;
    nicNameC                    nicNameImPending ;
    countT                      cSawFlash ;
    switchC                     swDeclareSent ;
    switchC                     swDeclare_cImDead ;
    switchC                     swDeclareNextTock ;
    switchC                     swDeclare ;
    countT                      idNewsAck ;
    soulC                       souDeclare ;
    boolT                       bOnline ;
    strokeS*                    psttLogFile ;
    knowS                       know ;
    stackC                      stFlash ;
    stackC                      stDel ;
    stackC                      stNew ;
    stackC                      stHello ;
    stackC                      stKnow ; // "NICNAMES KNOWN TO ME"
    etherC&                     ether ;

    private :

    static countT               uidaF( const nicNameC& nicNameP ) ;
    static voidT                setupF( tinS& tinP ) ;
    static boolT                bFlashSeenByAllF( tinS& tinP , etherC& etThreadP ) ;
    static voidT                armageddonF( tinS& tinP , etherC& etThreadP , const strokeS* const psttLogFileP ) ;
    static voidT                genesisF( tinS& tinP , etherC& etThreadP , const countT cLNicsP , const countT cGossipP , const countT idaDeadP ) ;

    static countT               cExplosions ;
    static countT               cpln ;
    static lnicC**              ppln ;

    public :

    static const countT         idFlashMode ;
    static countT               cGossipOrdered ;
{
class lnicC // "LOGICAL NETWORK INTERFACE CARD"

;
}
    lnicC*                      pLnicExHit2 ;
    lnicC*                      pLnicExHit1 ;
    lnicC*                      pLnicImHit ;
    nicNameC                    nicNameExHit2 ;
    nicNameC                    nicNameExHit1 ;
    nicNameC                    nicNameImHit ;
    countT                      idaExHit2 ;
    countT                      idaExHit1 ;
    countT                      idaImHit ;
    countT                      idrExHit2 ;
    countT                      idrExHit1 ;
    countT                      idrImHit ;
    countT                      exTime ; //RELATIVE TIME IN THE EXPLOSION SEQUENCE; exTime 0 REFERS TO WHEN 1 EXPLODES, HITTING 2 3
    countT                      idrMe ; //MY RELATIVE ID IF THE SINGULARITY IS RELATIVE ID 1
    countT                      idaSingularity ;
    countT                      idaMe ;
    countT                      exTimeMax ; //RELATIVE TIME IN THE EXPLOSION SEQUENCE WHEN THE LA'TH NIC WOULD EXPLODE
    countT                      cKnown ;
    countT                      uidaMe ;
{
struct knowS

class lnicC ;

#define ifcIDnEWSiM_FLASH         6
#define ifcIDnEWSiM_TIMEOUT       5
#define ifcIDnEWSiM_ACK           4

#define ifcIDnEWSeX_DEL           3
#define ifcIDnEWSeX_FLASH         2
#define ifcIDnEWSeX_HELLO         1

#define ifcIDfLASHmODE_IMPLODE         2
#define ifcIDfLASHmODE_EXPLODE         1

#define TIMEoUT 0x30

#endif

    }
        }
            //etThread.strokeF( tinP , te ) ;
            }
                __( ida - idaF( idr , id1 , 8 ) ) ;
                //etThread.strokeF( tinP , TF3(idr,flFORMAT_null,9) ) ;
                countT idr = idrF(ida,id1,8) ;
            {
            for( countT ida = 1 ; ida <= 8 ; ida ++ )
            //etThread.strokeF( tinP , TF3(id1,flFORMAT_null,8)+tv ) ;
        {
        for( countT id1 = 1 ; id1 <= 8 ; id1 ++ )
        TN( tv , "|" ) ;                                            // GENERALLY USEFUL STACK OBJECTS
        TN( te , "\r\n" ) ;                                         // GENERALLY USEFUL STACK OBJECTS
    {
    // TEST idaF AND idrF (PUT THIS CODE INTO TODO

#if defined( NEVERdEFINED )

/*1*/WAKEhIDE( "simulator.2.power.explosive.communication" )/*1*/
/**/
*/
a nic with N names must behave exactly as if it was a set of N nics on N distinct hosts
i think only of logical nics, never of nics
 each nic is associated with ze or mo lnic
 every lnic is associated with exactly wo nic
def "logical nic": an imaginary device identified by a single, unique, nicNameC value
 4 billion participating nic cards will be supported
a cardinal name in the problem domain, and for me, is a countT value
for me, an actual name is a countT value
an actual name in the problem domain is a nicNameC value
i exemplify obtaining cardinal names from actual names
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

