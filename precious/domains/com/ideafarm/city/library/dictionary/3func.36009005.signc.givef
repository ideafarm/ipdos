
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ; // RACE: THREAD THAT WAS WAITING FOR THE SIGN WILL RACE WITH ME TO INSPECT cFunctionsPending AS IT TRIES TO DESTROY *this

    }
        }
            break ;
            grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        case ifcIDmODEsIGNgIVE_OFF :
        }
            break ;
            ungrabF( tinP , flGRABcUNGRABf_DEPOSITkISSiF ) ;
        {
        case ifcIDmODEsIGNgIVE_ON :
        }
            break ;

            }
                thirdC::dosPriorityIF( tinP , idDesireSave ) ;
                pGrabA->osTidLockF() = 0 ;
            {
            if( !time1P && !time2P )

            grabF( tinP , TAG( TAGiDnULL ) ) ;

            }
                tinP.pEther->osSleepF( tinP , time1P , time2P ) ;
                sleepC s( tinP, TAG( TAGiDnULL ) ) ;
            {
            if( time1P || time2P )

            ungrabF( tinP , flGRABcUNGRABf_DEPOSITkISSiF ) ;

            }
                //IF NO OTHER THREADS HAVE DONE THIS THEN I WILL NOT RELEASE ANYWO (THIS SIMPLIFIES RACE ANALYSIS)
                //MY TIDLOCK MEANS THAT MY FLASH CAN ONLY RELEASE OTHER THREADS THAT GOT INTO THE QUEUE BEFORE I LOCKED THE TID
                //LATER NOTE: TIDLOCK BLOCKS OTHER THREADS FROM BEGINNING THE GRAB RECIPE
                pGrabA->osTidLockF() = tinP.osTid ; //CONJ: THIS HAS NO BEHAVIORAL EFFECT SO IS NOT NEEDED
                thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
                idDesireSave = thirdC::dosPriorityIF( tinP ) ;
            {
            if( !time1P && !time2P )
            ZE( countT , idDesireSave ) ;

            }
                }
                    countT foo = 2 ;
                {
                if( idIn == 4 )
                idIn = 1 + incv02AM( idInLath ) ;
                static countT idInLath ;
            {
            if( tinP.monitor.idThread == 7 )
            ZE( countT , idIn ) ;
        {
        case ifcIDmODEsIGNgIVE_FLASH :
    {
    switch( idModeP )
    _IO_

    inc02AM( cFunctionsPending ) ;

    }
        if( POOP ) return ;
        __( ( time1P || time2P ) && idModeP != ifcIDmODEsIGNgIVE_FLASH ) ;
        IV( ifcIDmODEsIGNgIVE , idModeP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT signC::giveF( tinS& tinP , const countT idModeP , const countT time1P , const sCountT time2P )/*1*/

/**/
*/

 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00103a8.ifcIDmODEsIGNgIVE!||
 idModeP
 tinP
arguments
any thread can call giveTakeF on a signC object
 it is for that reason that such code is illegal
 this kind of code will work, but will cause exception notices to appear on the monitor displays
 a grabC object that is marked as grabbed by a thread that has ended is permanently ungrabbable
 when a thread calls me, it momemtarily ungrabs a grabC object and then grabs it again
 it is illegal for a thread to end while it has posession of any grabC objects
the calling thread must ensure that the signC is either given or destroyed before it ends
  all modes are equally efficient
  these recommendations are not motivated by efficiency
  these recommendations are motivated by the aesthetic of using the most restrictive code possible in order to maximize code readability
  use ON without OFF only when ON OFF does not give the required behavior
  use ON OFF only when FLASH does not give the required behavior
  use FLASH with nonze time only when ze time does not give the required behavior
  use FLASH with ze time whenever possible
 coding style guide
  it is good style and legal to call me with _ON and never call me with _OFF
  behavior is exactly as if FLASH was specified with a nonze time
 behavior if ifcIDmODEsIGNgIVE_ON _OFF is specified
  when the time expires, all pending waits are released exactly 1 more time
  all threads that begin to wait for the sign during the time interval will be appended to the list of threads being released multiple times
  all threads that are blocked waiting when i am called will be released multiple times until the time expires
 behavior if time is specified
  if no threads are blocked waiting, then the next thread to wait will be released immediately
  these threads will be released serially, in the order in which they became blocked
  all threads that are blocked waiting for the sign when i am called will be released exactly wo time
 default behavior
guaranteed behavior
i can be called by multiple threads without serialization
\<A HREF=\"5.10b0005.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$giveF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

