
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return id ;
    _OUT_

    }
        }
            }
                }
                    if( !id || idFirstP > ccBig ) idFirstP  = 0 ;_WQ

                    }
                        ;_WQ
                                : 0                 // SHOULD BE IMPOSSIBLE
                                ? idbDo + 1
                            : idbDo                 // SHOULD ALWAYS BE TRUE
                            ? id + ccSmall 

                        idFirstP = !bSSS
                    {
                    if( id )

                    if( id > idMax ) id = 0 ;_WQ
                    }
                        }
                            else if( !strComparePrivateF( psttBigP + CSpREFIX - 1 + id , psttSmall ) ) break ;
                            }
                                else                                                                 idbDo = 0 ;
                                if( sssAndF( tinP , psttSmallP , psttBigP , idsDo , idbDo ) ) break ;
                                idbDo = id ;_WQ
                                countT idsDo = 1 ;_WQ
                            {
                            if( bSSS )
                        {
                        if( bIgnoreQuotes || !bInQuote )
                        if( !bIgnoreQuotes ) bInQuote = strIsInQuoteF( tinP , sttQuoteP , id , psttBigP ) ;_WQ
                        ZE( boolT , bInQuote ) ;_WQ
                    {
                    for( id = idFirstP ; id <= idMax ; id ++ )
                    ZE( countT , idbDo ) ;_WQ
                {
                if( !POOP )
                countT idMax = bSSS ? ccBig : ccBig - ccSmall + 1 ;_WQ
            {
            else
            if( !bSSS && idFirstP - 1 + ccSmall > ccBig ) idFirstP = 0 ;
    
            countT ccSmall = psttSmall->idAdam ;_WQ
            countT ccBig   = idLastP && idLastP < psttBigP->idAdam ? idLastP : psttBigP->idAdam ;_WQ
        {
        if( !POOP )
    
        const strokeS* const psttSmall = ( psttSmallP && psttSmallP->idAdam ) ? psttSmallP : psttOneNull ;_WQ
        SETpREFIX( (strokeS*)psttOneNull , 1 , 0 ) ;_WQ
        const strokeS psttOneNull[] = { strokeS() , strokeS() , strokeS() , strokeS() } ;_WQ

        boolT bSSS = psttSmallP[ CSpREFIX ].idCaste == sc_ccSSS && psttSmallP[ CSpREFIX ].idAdam == sa_SSSaND ; // ENFORCE: ALL SSS MUST BE WRAPPED IN AND ; THIS IS JUST TO KEEP CODE SIMPLE
    {
    STRiDrECURSE( strIdF( tinP , idf , sttQuoteP , psttSmallP , psttBigP , idLastP , 1 ) )
    _INoLD_

    }
        if( POOP ) return 0 ;
        __( psttBigP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        __( psttSmallP && psttSmallP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return 0 ;
        __Z( idP ) ;_WQ
        __( idFirstP == 1 && (countT)sttQuoteP && !bIgnoreQuotes ) ;_WQ
        __Z( idFirstP ) ;_WQ
        __Z( psttBigP ) ;_WQ

        if( POOP ) return 0 ;
    {
    IFbEcAREFUL

    const boolT bIgnoreQuotes = sttQuoteP.idCaste == sc_IGNOREqUOTES ;_WQ
    SCOOP
{
/*1*/countT etherC::strIdF( tinS& tinP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* psttSmallP , const strokeS* psttBigP , const countT idLastP , sCountT idP )/*1*/

/**/
*/
  if not 0 then only the strokes between idFirstP and idLastP inclusive are inspected
  if 0 then the search is over the entire psttBigP string
  can be 0
 idLastP
 psttBigP
    this should not be done unless there is a good reason to do it, because any such specification can be wrapped so that it conforms to the current requirement
   U:: this is fully general, but i can be edited to support SSS specifications that do not begin in the woth position, if that is ever desired
  if this string begins with sc_ccSSS(sa_SSSaND), i look for the idP'th occurance of the specified string pattern (regular expressions)
   behavior is identical to that of a unit length string containing a null stroke
  this can also be null, or a null length string
  this string can include a null stroke
 psttSmallP
  i will ignore quotes if sttQuoteP.idCaste == sc_IGNOREqUOTES
 sttQuoteP
 idFirstP
arguments
 see doc for strIsInQuoteF for notes on how sttQuoteP is set at the beginning and at the end of a quote
 see doc for strIsInQuoteF for notes on which quote marks are recognized
 sttQuoteP is either 0 or contains the last quote mark encountered
initialize sttQuoteP to the quote state at idFirstP
quoted strokes are skipped when searching for the first match
idFirstP will point to the stroke after the one found
  \<A HREF=\"5.a910104.1.1.0.html\"\>a910104:  WAKEsHOW( "example.simplest.func.103005d.etherC.strIdF" )\</A\>
 simplest
examples
\<A HREF=\"5.103005d.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strIdF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

