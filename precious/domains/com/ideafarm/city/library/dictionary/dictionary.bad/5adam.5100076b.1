
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("aok [cFiles]: ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
if( cFiles ) ;
etThread.diskWalkF( tinP , cDirs , cFiles , T("///z/archive/") , (boolT&)(const boolT&)ether , diskWalkArchiveRefileCorrectDateCBF /*, countT* const pcArgP = 0 , countT* pModuloDirsP = 0 , countT* pModuloFilesP = 0*/ ) ;
static countT cFiles ;
static countT cDirs ;

TODO

}
    return bDoIt ;
    }
        }
            etThread.delF( tinP , posti ) ;

            }
                }
                    }
                        etThread.traceF( tinP , T("    [internal]:  ")+tInternalDateTime ) ;
                        etThread.traceF( tinP , T("    [external]:  ")+tExternalDateTime ) ;
                        etThread.traceF( tinP , tInternalName ) ;
                        etThread.traceF( tinP , tExternalName ) ;
                    {
                    if( etThread.strCompareF( tinP , tInternalDateTime , tExternalDateTime ) )

                    }
                        }
                            etThread.delF( tinP , psttGot ) ;
                            tExternalDateTime = T(psttGot) ;
                            etThread.strSubstringF( tinP , psttGot , idf , idl , tExternalName ) ; ___( psttGot ) ;
                            countT idl = idf - 1 + 0xd ;
                            countT idf = idHitE ;
                            ZE( strokeS* , psttGot ) ;
                        {

                        }
                            etThread.delF( tinP , psttGot ) ;
                            tInternalDateTime = T(psttGot) ;
                            etThread.strSubstringF( tinP , psttGot , idf , idl , tInternalName ) ; ___( psttGot ) ;
                            countT idl = idf - 1 + 0xd ;
                            countT idf = idHitI ;
                            ZE( strokeS* , psttGot ) ;
                        {
                    {
                    TN( tExternalDateTime , "" ) ;
                    TN( tInternalDateTime , "" ) ;
                {
                else
                }
                    if( !idHitE ) etThread.traceF( tinP , T("cannot find datetime in external name:  ")+tExternalName ) ;
                    if( !idHitI ) etThread.traceF( tinP , T("cannot find datetime in internal name:  ")+tInternalName ) ;
                {
                if( !idHitI || !idHitE )

                countT idHitE = etThread.strIdF( tinP, idf , sttq , tPatternDateAtTime , tExternalName ) ;
                idf = 1 ;

                }

                    idHitI = etThread.strIdF( tinP, idf , sttq , tPatternDateAtTime , tInternalName ) ;
                    idf = 1 ;

                    tInternalName = T(posti) ;
                {
                if( !idHitI )

                countT idHitI = etThread.strIdF( tinP, idf , sttq , tPatternDateAtTime , tInternalName ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                countT idf = 1 ;

                TN( tInternalName , postShort ) ;
                
                }
                    }
                        postc ++ ;

                        }
                            break ;
                            postShort = postc + 3 ;
                        {
                        if( postc[ 0 ] == '.' && postc[ 1 ] == '!' && postc[ 2 ] == '.' )
                    {
                    while( *postc )
                    osTextT* postc = posti ;
                {
                const osTextT* postShort = posti ;

                TN( tExternalName , postNameP ) ;

                ;

                    +S2(sa_SSSaNDeND,sc_ccSSS)
                    +S2(sa_SSSoReND,sc_ccSSS)
                        +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
                        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
                    +S2(sa_SSSoR,sc_ccSSS)
                    +S3(2,sc_ccSSSrEPEAT,2)
                    +S2(sa_SSSoReND,sc_ccSSS)
                        +T("012xz")
                    +S2(sa_SSSoR,sc_ccSSS)
                    +T("@")
                    +S2(sa_SSSoReND,sc_ccSSS)
                        +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
                        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
                    +S2(sa_SSSoR,sc_ccSSS)
                    +S3(7,sc_ccSSSrEPEAT,7)
                    +S2(sa_SSSaND,sc_ccSSS)
                    T("")

                TN( tPatternDateAtTime , "" ) ; tPatternDateAtTime =
                // "20130510@2359"
                //  yyyymmdd hhmm
            {
            else
            }
                etThread.traceF( tinP , T("error: file is null length: ")+T(postNameP) ) ;
            {
            else if( !posti || !costi )

            }
                etThread.traceF( tinP , T("error: could not read file: ")+T(postNameP) ) ;
                POOPR ;
            {
            if( POOP )

            tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , T(ifFileNameC(tinP,*tinP.pEtScratch,postNameP)) , 1 ) ; ___( posti ) ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;

            etherC& etThread = *tinP.pEther ;
        {
        else if( strstr( postNameP , ".meta.currentname" ) )
        }
        {
        if( bDir )
    
        boolT  bDir = postNameP[ costLike - 1 ] == '\\' ;
        countT costLike = tinP.brcRaw ;
        BOSdOnOTtEST( WHATgbo , strlen( postNameP ) )
        CONoUTrAW( "." ) ;
    {
    if( postNameP )
    ZE( boolT , bDoIt ) ;
    _IO_
{
/*1*/boolT diskWalkArchiveRefileCorrectDateCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloFilesP , const countT* const pModuloDirsP )/*1*/



/*1*/WAKEsHOWtEXT( "scratch.1.inactive.probably.tool.to.correct.dates.in.archive" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
