
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

if( bReboot ) etThread.osFireF( tinP ) ;

}
    }
        }
            }
                }
                    //}
                        //}
                    //        TELL( "hired self" )
                    //        { countT idAdam = DDNUMB ; etThread.ifcHireF( tinP , T("tool.gorilla.ephemeral.threads") , idAdam , 0 ) ; }
                    //        TELL( "hiring self" )                                       
                        //{
                        //else
                        //}
                        //    break ;
                        //    POPUP( "BURNIN PASS" ) ;
                        //{
                        //if( !( state.idMe % 0x400 ) )
                        //if( !( state.idMe % 0x400 ) ) bReboot = 1 ;
                    //{
                    //if( cAll == 0x10 )

                    if( !( cAll % 0x10 ) ) etThread.winSetTitleF( tinP , /*TF1(state.idMe)+tb+TF1(state.cThreads)+tb+*/TF1(cAll)+tb+TF1(cAlive) ) ;
                    cAll ++ ;
                    //state.cThreads ++ ;
                    }
                        etThread.beeClickF( tinP , 0x200 ) ;
                        //etThread.ifcSayF( tinP , TF1(cAll) , flSAY_APPEND | flSAY_LOG ) ;
                        etThread.strokeF( tinP , T("\r        \r")+TF1(cAll) ) ;
                    {
                    if( !( cAll % 0x10000 ) )
                {
                if( !etThread )
                etThread.osThreadF( tinP , countTC() , tmNullF ) ;
            {
            if( !ether )
            }
                //++ s ; ether.osSleepF( tinP , TUCK * 0x10 ) ;
                //sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
        {
        else
        }
            thirdC::dosPriorityIF( tinP , idDesireSave ) ;
            tinP.cYield = 0 ;
            thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) ) ;
            tinP.cYield = 0 ;
            thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_RUSH ) ;
            const countT idDesireSave = tinP.idDesire ;
        {
        //if( cAlive > 0x10 )
        //if( cAlive > 0x40 )
        if( cAlive > 0x100 )
    {
    while( !ether && !etThread )
    ranUniC ru( TOCK * 4 , 1 ) ;
    countT& cAlive = thirdC::os_cAllKidThreadsI_IF( tinP ) ;
    ZE( countT , cAll ) ;
    TN( tb , " " ) ;

    TN( tLog , "\\log.8140104" ) ;

    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIEST ) ;

    //U::COMMENTED OUT SO CAN HAVE MULTIPLE CELLS OF ME: stateS state( tinP , etThread ) ;
{
ZE( boolT , bReboot ) ;

//}
//    ++ s ; ether.osSleepF( tinP , TOCK * 0x40 ) ; //TO GIVE OTHER HOSTS TIME TO INITIALIZE
//    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
//{

TODO

DONE( tmNullF )
}
    ++ s ; etThread.osSleepF( tinP , TUCK * 0x10 ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{
TASK( tmNullF )

}
{
stateC( tinP , etherP , sizeof *this , 0 , translateStateF )
stateS::stateS( tinS& tinP , etherC& etherP ) :

TRANSLATEsTATE_END
    state.idMe ++ ;
TRANSLATEsTATE_MIDDLE
    case 1 : { state.idMe        = stateOther.idMe        ; }
    case 2 : { state.cThreads    = stateOther.cThreads    ; }
TRANSLATEsTATE_BEGIN( stateS , 2 )

;
}
    stateS( tinS& tinP , etherC& etherP ) ;

    countT cThreads ;
    countT idMe ;
    countT idVersion ;
{
struct stateS : public stateC

/*1*/WAKEhIDE( "tool.gorilla.ephemeral.threads" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

