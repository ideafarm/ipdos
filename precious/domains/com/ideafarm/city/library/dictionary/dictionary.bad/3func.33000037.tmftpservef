
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmFtpServeF )

}
    if( POOP ) POOPR
    }
        cDone ++ ;
        }
            //tinP.pEtScratch->delF( tinP , psttPeer ) ;
            //tinP.pEtScratch->ifcSayIF( tPrefix+T("client ")+T(nicNamePeer)+T(" \"")+T(psttPeer)+T("\"-") , flSAY_APPEND | flSAY_LOG ) ;
        
            //U:DEL( psoPassiveData ) ;
            DEL( pso ) ;
            //}
            //    POOPR
            //    TELL( "cleaning up" )
            //    }
            //        ++ s ; tinP.pEtScratch->osSleepF( tinP , TUCK * 0x80 ) ; //AS COURTESY
            //        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //    {
            //    //pso->readF( tinP , &bIn , 1 ) ;
            //    TELL( "cleaning up: waiting for client to write a byteT so that it can disconnect" )
            //    ZE( byteT , bIn ) ;
            //{
            //else
            if( POOP ) POOPR
        
            }
                etThread.delF( tinP , pstt1words ) ;
                etThread.delF( tinP , psttl ) ;
        
                }
                    }
                        }
                            break ;

                            if( !idArm ) bFlushLine = 1 ;

                            }
                                }
                                    break ;
                                    idArm = 0 ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    TN( tReply , "600 error\r\n" ) ;
                                    TELL( "writing nack for \"type\"" )
                                {
                                case ifcIDaRM_TYPEnACK :
                                }
                                    break ;
                                    idArm = 0 ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    TN( tReply , "200 ok\r\n" ) ;
                                    TELL( "writing ack for \"type i\"" )
                                {
                                case ifcIDaRM_TYPEaCKi :
                                }
                                    break ;
                                    idArm = 0 ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    TN( tReply , "600 error\r\n" ) ;
                                    TELL( "writing nack for \"pass\"" )
                                {
                                case ifcIDaRM_PASSCODEnACK :
                                }
                                    break ;
                                    idArm = 0 ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    TN( tReply , "230 ok\r\n" ) ;
                                    TELL( "writing ack for \"pass\"" )
                                {
                                case ifcIDaRM_PASSCODEaCK :
                                }
                                    break ;
                                    idArm = 0 ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    TN( tReply , "600 error\r\n" ) ;
                                    TELL( "writing nack for \"user\"" )
                                {
                                case ifcIDaRM_USERnACK :
                                }
                                    break ;
                                    idArm = 0 ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    TN( tReply , "331 ok\r\n" ) ;
                                    TELL( "writing ack for \"user\"" )
                                {
                                case ifcIDaRM_USERaCK :
                                }
                                    break ;

                                    etThread.delF( tinP , pbi ) ;
                                    if( cbi ) etThread.boxPutF( tinP , tLastFile , pbi , cbi ) ;

                                    }
                                        }
                                            pso->writeF( tinP , (osTextT*)tReply ) ;
                                            tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                            tReply = T("226 ok\r\n") ;
                                            }
                                                sData.writeF( tinP , pbi , cbi ) ;
                                                pso->writeF( tinP , (osTextT*)tReply ) ;

                                                }
                                                    }
                                                        break ;
                                                        POOPR ;
                                                    {
                                                    else
                                                    if( !POOP ) cbi ++ ;
                                                    sData.readF( tinP , pbi + cbi , 1 ) ;
                                                {
                                                while( cbi < cbia )
                                                POOPR //REDUNDANT; JUST TO MAKE SURE

                                                tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                            
                                                sData.connectF( tinP , idPortClient , nicNameClient , 1 , TOCK * 4 ) ;
                                                tinP.pEtScratch->strokeF( tinP , T("connecting to port ")+TF2(idPortClient,flFORMAT_NObIGITvALUES)+T(" of nn ")+T(nicNameClient)+T("\r\n") ) ;
                                                socketC sData( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                            {
                                            TN( tReply , "150 ok\r\n" ) ;
                                        {
                                        else
                                        }
                                            }
                                                }
                                                    break ;
                                                    POOPR ;
                                                {
                                                else
                                                if( !POOP ) cbi ++ ;
                                                psoPassiveData->readF( tinP , pbi + cbi , 1 ) ;
                                            {
                                            while( cbi < cbia )
                                            POOPR //REDUNDANT; JUST TO MAKE SURE
                                        {
                                        if( psoPassiveData )
                                    {
                                    if( pbi )
                                    etThread.newF( tinP , LF , pbi , cbia ) ; ___( pbi ) ;
                                    const countT cbia = TOCK * 0x40 ;
                                    ZE( countT , cbi ) ;
                                    ZE( byteT* , pbi ) ;

                                    cleanFileNameF( tinP , *tinP.pEtScratch , tLastFile ) ;
                                    tLastFile = T(psttc1) ;
                                    TELL( "preparing a reply to \"stor\"" )
                                    idArm = 0 ;

                                    //THIS IS A QUICK HACK JUST TO SUPPORT UPLOADING OF RELEASED IPDOS
                                {
                                case ifcIDaRM_STORE :
                                }
                                    break ;
                                    }
                                        tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                        pso->writeF( tinP , (osTextT*)tReply ) ;
                                        TN( tReply , "600 error\r\n" ) ;
                                        TELL( "writing nack for \"retr\"" )
                                    {
                                    else
                                    }
                                        bClientQuit = 1 ; //MS IE DOESN'T EVER SEND A QUIT (FUCKIN SHIT SOFTWARE)
                                        }
                                            //}
                                            //    *tinP.pEtScratch = 0 ;
                                            //    sData.readF( tinP , &bIn , 1 ) ;
                                            //    ZE( byteT , bIn ) ;
                                            //{
                                            //if( !etThread && !*tinP.pEtScratch )
                                            //IE DOESN'T EVER SEND ANYTHING AND DOES NOT DISCONNECT EITHER
                        
                                            pso->writeF( tinP , (osTextT*)tReply ) ;
                                            tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                            tReply = T("226 ok\r\n") ;
                                            sData.writeF( tinP , pbi , cbi ) ;
                                            pso->writeF( tinP , (osTextT*)tReply ) ;
                                            tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                            TN( tReply , "150 ok\r\n" ) ;
                        
                                            sData.connectF( tinP , idPortClient , nicNameClient , 1 , TOCK * 4 ) ;
                                            tinP.pEtScratch->strokeF( tinP , T("connecting to port ")+TF2(idPortClient,flFORMAT_NObIGITvALUES)+T(" of nn ")+T(nicNameClient)+T("\r\n") ) ;
                                            socketC sData( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                        {
                                        else
                                        }
                                            pso->writeF( tinP , (osTextT*)tReply ) ;
                                            tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                            TN( tReply , "226 ok\r\n" ) ;

                                            DEL( psoPassiveData ) ;
                                            psoPassiveData->writeF( tinP , pbi , cbi ) ;

                                            //pso->writeF( tinP , (osTextT*)tReply ) ;
                                            //tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                            //TN( tReply , "150 ok\r\n" ) ;
                                            //OPERA BROWSER DOES NOT EXPECT THIS
                                        {
                                        if( psoPassiveData )
                                        TELL( "writing a reply to \"retr\"" )
                                    {
                                    if( pbi )

                                    if( pbi ) { CHECKqUOTA( cbi ) ; if( bRefuse ) pbi = 0 ; }
                                    pbcbF( tinP , *tinP.pEtScratch , pbi , cbi , tLastFile , psttLever , swImage ) ;
                                    ZE( countT , cbi ) ;
                                    ZE( byteT* , pbi ) ;
                                    cleanFileNameF( tinP , *tinP.pEtScratch , tLastFile ) ;
                                    tLastFile = T(psttc1) ;
                                    TELL( "preparing a reply to \"retr\"" )
                                    idArm = 0 ;
                                {
                                case ifcIDaRM_RETRIEVE :
                                }
                                    break ;

                                    }
                                        tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                        pso->writeF( tinP , (osTextT*)tReply ) ;
                                        TN( tReply , "600 error\r\n" ) ;
                                        TELL( "writing nack for \"size\"" )
                                    {
                                    else
                                    }
                                        tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                        TN( tReply , "" ) ; tReply = tr ;
                    
                                        pso->writeF( tinP , (osTextT*)tr , tr.csF( tinP ) ) ;
                                        TELL( "writing a reply to \"size\"" )
                                        TN( tr , "" ) ; tr = T("213 ")+TF4(cbi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FOREIGN,0,0xa)+T("\r\n") ;
                                    {
                                    if( pbi )

                                    if( POOP ) { POOPR ; pbi = 0 ; }
                                    pbcbF( tinP , *tinP.pEtScratch , pbi , cbi , tLastFile , psttLever , swImage ) ;
                                    ZE( countT , cbi ) ;
                                    ZE( byteT* , pbi ) ;
                                    cleanFileNameF( tinP , *tinP.pEtScratch , tLastFile ) ;
                                    tLastFile = T(psttc1) ;
                                    TELL( "preparing a reply to \"size\"" )
                                    idArm = 0 ;
                                {
                                case ifcIDaRM_SIZE :
                                }
                                    break ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    TN( tReply , "200 ok\r\n" ) ;
                                    TELL( "writing reply to \"port\"" )
                        
                                    tinP.pEtScratch->delF( tinP , pstt1w ) ;
                                    }
                                        else { idPortClient <<= 8 ; idPortClient |= vv ; }
                                        }
                                            nicNameClient = idh ;
                                            idh |= vv ;
                                            countT idh = *(const countT*)nicNameClient << 8 ;
                                        {
                                        if( ++ idw < 5 ) //U: DOES NOT SUPPORT IPV6 (128 BIT nicName VALUES)
                        
                                        countT vv = tinP.pEtScratch->strDigitsToSCountF( tinP , psttc1 , 0xa , 1 ) ;
                                    {
                                    FORsTRINGSiN1( pstt1w )
                                    ZE( countT , idw ) ;
                                    tinP.pEtScratch->strWordsOldF( tinP , pstt1w , psttc1 , sttq , T(",") ) ; ___( pstt1w ) ;
                                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                    ZE( strokeS* , pstt1w ) ;
                        
                                    TELL( "preparing reply to \"port\"" )
                                    idArm = 0 ;
                                {
                                case ifcIDaRM_PORT :
                                }
                                    break ;
                                    }
                                        tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                        ( idArm == ifcIDaRM_STAT ? pso : psoPassiveData )->writeF( tinP , (osTextT*)tReply ) ;
                                        TN( tReply , "600 error\r\n" ) ;
                                        TELL( "writing nack for \"stat\" or \"list\"" )
                                    {
                                    else
                                    }
                                        pso->writeF( tinP , (osTextT*)tReply ) ;
                                        tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                        TELL( "writing reply to \"stat\" or \"list\"" )
                                        textC tReply = T("213-status\r\n- 111 222 333 ")+TF4(cbi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FOREIGN,0,0xa)+T(" 555 666 777 888 999\r\n213 status\r\n") ;
                                    {
                                    if( pbi )

                                    if( POOP ) { POOPR ; pbi = 0 ; }
                                    pbcbF( tinP , *tinP.pEtScratch , pbi , cbi , tLastFile , psttLever , swImage ) ;
                                    ZE( countT , cbi ) ;
                                    ZE( byteT* , pbi ) ;
                                    cleanFileNameF( tinP , *tinP.pEtScratch , tLastFile ) ;
                                    tLastFile = T(psttc1) ;
                                    ZE( strokeS* , psttn ) ;
                                    TELL( "preparing to reply to \"stat\" or \"list\"" )
                                    idArm = 0 ;
                                {
                                case ifcIDaRM_LIST :
                                case ifcIDaRM_STAT :
                            {
                            switch( idArm )

                            }
                                }
                                    break ;
                                    else                  idArm = ifcIDaRM_TYPEnACK ;
                                    SETiDaRM(               "i" , ifcIDaRM_TYPEaCKi )
                                {
                                case ifcIDaRM_TYPE :
                                }
                                    break ;

                                    }
                                        idArm = ifcIDaRM_PASSCODEnACK ;
                                        POOPR
                                    {
                                    else
                                    if( !POOP ) idArm = ifcIDaRM_PASSCODEaCK ;
                                    tinP.pEtScratch->diskMoveFileOrDirF( tinP , tDirNew+tShort , tDirOld+tShort ) ;

                                    TN( tShort  , "soul.ticket." ) ; tShort += T(psttc1)+T(".soul") ;
                                    TN( tDirNew , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets.used/" ) ;
                                    TN( tDirOld , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets/" ) ;
                                {
                                case ifcIDaRM_PASSWORD :
                                }
                                    break ;
                                    else                  idArm = ifcIDaRM_USERnACK ;
                                    SETiDaRM(         "visitor" , ifcIDaRM_USERaCK )
                                {
                                case ifcIDaRM_USER :
                            {
                            switch( idArm )
                        {
                        case 2 :
                        }
                            break ;

                            if( !idArm ) bFlushLine = 1 ;

                            }
                                }
                                    break ;
                                    __( bRefuse ) ;
                                    { nicNameC nnnu ; sockA.acceptF( tinP , psoPassiveData , countTC() , nnnu , bRefuse ) ; }
                                    ZE( boolT , bRefuse ) ;
                                    TELL( "\"pasv\": waiting for the client to connect" )
                                
                                    }
                                        pso->writeF( tinP , (osTextT*)to ) ;
                                        tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+to ) ;
                                        pso->writeF( tinP , (osTextT*)to ) ;
                                
                                        tinP.pEtScratch->delF( tinP , psttnp ) ;
                                        TN( to , "" ) ; to = T("227 entering passive mode (")+T(psttnp)+T(")\r\n") ;
                                        sockA.listenF( tinP ) ;
                                        tinP.pEtScratch->strFromIdPortNicNameF( tinP , psttnp , sockA.bindF( tinP , *tinP.pEtScratch ) ) ; ___( psttnp ) ;
                                        ZE( strokeS* , psttnp ) ;
                                    {
                                    socketC sockA( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                                    TELL( "writing a reply to \"pasv\"" )
                                    idArm = 0 ;
                                {
                                case ifcIDaRM_PASSIVE :
                                }
                                    break ;
                                    idArm = 0 ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    TN( tReply , "257 \"/\" is current directory.\r\n" ) ;
                                    TELL( "writing a reply to \"pwd\"" )
                                {
                                case ifcIDaRM_PWD :
                                }
                                    break ;
                                    idArm = 0 ;
                                    bClientQuit = 1 ;
                                    pso->writeF( tinP , (osTextT*)tReply ) ;
                                    tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                    TN( tReply , "221 ok\r\n" ) ;
                                    TELL( "writing ack for \"quit\"" )
                                {
                                case ifcIDaRM_QUIT :
                            {
                            switch( idArm )

                            }
                                pso->writeF( tinP , (osTextT*)tReply ) ;
                                tinP.pEtScratch->strokeF( tinP , T("REPLY: ")+tReply ) ;
                                TN( tReply , "502 command not implemented\r\n" ) ;
                                TELL( "writing a reply to a command that is not implemented" )
                            {
                            else
                            else SETiDaRM( "pasv" , ifcIDaRM_PASSIVE )
                            else SETiDaRM( "pwd"  , ifcIDaRM_PWD )
                            else SETiDaRM( "stor" , ifcIDaRM_STORE )
                            else SETiDaRM( "retr" , ifcIDaRM_RETRIEVE )
                            else SETiDaRM( "size" , ifcIDaRM_SIZE )
                            else SETiDaRM( "port" , ifcIDaRM_PORT )
                            else SETiDaRM( "list" , ifcIDaRM_LIST )
                            else SETiDaRM( "stat" , ifcIDaRM_STAT )
                            else SETiDaRM( "quit" , ifcIDaRM_QUIT )
                            else SETiDaRM( "type" , ifcIDaRM_TYPE )
                            else SETiDaRM( "pass" , ifcIDaRM_PASSWORD )
                                 SETiDaRM( "user" , ifcIDaRM_USER     )
                        {
                        case 1 :
                    {
                    switch( ++ idWord )

                    if( bFlushLine || !psttc1->idAdam ) continue ;
                {
                FORsTRINGSiN1( pstt1words )
                ZE( boolT  , bFlushLine ) ;
                ZE( countT , idArm ) ;
                ZE( countT , idWord ) ;

                countT cWords = tinP.pEtScratch->strWordsOldF( tinP , pstt1words , psttl , sttq ) ; ___( pstt1words ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , pstt1words ) ;
        
                }
                    tinP.pEtScratch->strokeF( tinP , T(" replacing goofy (and illegal) REST command with: ")+T(psttl)+T("\r\n") ) ;
                    tinP.pEtScratch->strMakeF( tinP , LF , psttl , T("retr ")+tLastFile ) ; ___( psttl ) ;
                    tinP.pEtScratch->delF( tinP , psttl ) ;
                {
                if( 1 == tinP.pEtScratch->strIdF( tinP , psttl , tRest ) && tLastFile.csF( tinP ) )
                //REPLACE GOOFY ILLEGAL USE OF R ESTART COMMAND (BY WIN98 CLIENT)
        
                tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttl ) ;
        
                }
                    break ;
                    etThread.delF( tinP , psttl ) ;
                    bClientQuit = 1 ;
                    POOPR
                {
                if( POOP || !psttl )
                TELL( "setting up to process wo line of a strokeS string" )
                //tinP.pEtScratch->ifcSayIF( tPrefix+T("\"")+T(psttl)+T("\"") , flSAY_APPEND | flSAY_LOG ) ; //U:
                tinP.pEtScratch->strokeF( tinP , T(" ")+T(psttl)+T("\r\n") ) ;
                pso->readWoLineF( tinP , psttl , 0x100 ) ; ___( psttl ) ; // MICROSOFT'S PIECE OF SHIT Internet Explorer DOES THIS; IT DOES NOT SEND "QUIT"
                TELL( "reading wo line of a strokeS string" )
            {
            while( !ether && !etThread && !POOP && !bClientQuit && !bRefuse )
            TN( tRest , "rest" ) ;
            TN( tLastFile , "" ) ;
            ZE( socketC* , psoPassiveData ) ;
            ZE( boolT , bClientQuit ) ;
            ZE( strokeS* , psttl ) ;
            ZE( countT , idPortClient ) ;
            nicNameC nicNameClient ;
        
            //tinP.pEtScratch->ifcSayIF( tPrefix+T("client ")+T(nicNamePeer)+T(" \"")+T(psttPeer)+T("\"+") , flSAY_APPEND | flSAY_LOG ) ;
            //tinP.pEtScratch->strokeF( tinP , T("client \"")+T(psttPeer)+T("\"+\r\n") ) ;
        
            pso->writeF( tinP , (osTextT*)T("220 ok\r\n") ) ;
            TELL( "writing welcome ack" )
        {
        else
        }
            DEL( pso ) ;
            pso->writeF( tinP , (osTextT*)T("600 too busy now\r\n") ) ;
        {
        if( bRefuse )

        if( !ether ) { CHECKqUOTA( TUCK ) }
        ZE( boolT , bRefuse ) ;
    
        //U::20200728@1950: SHOULD NOT BE ABLE TO GO IMPOTENT
        //U::CONJ: THIS CAN FAIL, CAUSING IMPOTENCE: tinP.pEtScratch->sockPsttHostF( tinP , psttPeer , nicNamePeer ) ; ___( psttPeer ) ;
        //ZE( strokeS* , psttPeer ) ;
        //{ ZE( countT , idp ) ; pso->peerNameF( tinP , idp , nicNamePeer ) ; } //IMPOTENCE DURING TERMINATION
        //nicNameC nicNamePeer ;
    
        TN( tPrefix , "ftp." ) ; tPrefix += TF2(idClient,flFORMAT_NObIGITvALUES)+T("| ") ;
        pso->etherF( tinP , *tinP.pEtScratch ) ;
        SCOOPS
    {
    IFsCRATCH

    }
        }
            batQuotaP.ungrabF( tinP ) ;
            if( POOP ) POOPR
            THREADmODE1rESTORE
            tinP.pEtScratch->boxPutF( tinP , tFileQuota , (byteT*)&cbForDay , sizeof cbForDay , 1 ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            countT cbForDay = TICK * 0x16 ;
            batQuotaP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( !etThread.diskFileExistsF( tinP , tFileQuota ) || timeNow.time2 > timeTouchP.time2 )

        etThread.osTimeNowF( tinP , timeNow.time1 , timeNow.time2 ) ;
        timeS timeNow ;
    {
    TN( tFileQuota , "///ideafarm/ephemeral/domains/com/ideafarm/ipdos/quotas/socket.io" ) ;

    timeS&    timeTouchP =    *(timeS*)pTaskP->c7 ;
    batonC&   batQuotaP  =   *(batonC*)pTaskP->c6 ;
    switchC&  swImage    =  *(switchC*)pTaskP->c5 ;
    strokeS*& psttLever  = *(strokeS**)pTaskP->c4 ;
    countT&   cDone      =   *(countT*)pTaskP->c3 ;
    countT    idClient   =             pTaskP->c2 ;
    socketC*  pso        =   (socketC*)pTaskP->c1 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c7 )
/*1*/TASK( tmFtpServeF )/*1*/

        batQuotaP.ungrabF( tinP ) ;
        }                                                                                                       \
            etThread.delF( tinP , pbi ) ;                                                                       \
            THREADmODE1rESTORE                                                                                  \
            }                                                                                                   \
                LOGrAW( tSay ) ;                                                                                \
                TN( tSay , "" ) ; tSay = TT(timeNow.time1,timeNow.time2)+T(": ftp refused request of ")+TF2((countT)(cbWantP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" bytes because remaining quota for day is only ")+TF2(*(countT*)pbi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(".\r\n") ; \
                etThread.osTimeNowF( tinP , timeNow.time1 , timeNow.time2 ) ;                                   \
                timeS timeNow ;                                                                                 \
            {                                                                                                   \
            if( bRefuse )                                                                                       \
                                                                                                                \
            }                                                                                                   \
                else       bRefuse = 0 ;                                                                        \
                if( POOP ) POOPR                                                                                \
                tinP.pEtScratch->boxPutF( tinP , tFileQuota , pbi , cbi , 1 ) ; ___( pbi ) ;                    \
                *(countT*)pbi -= (cbWantP) ;                                                                    \
            {                                                                                                   \
            else if( cbi == sizeof( countT ) && *(countT*)pbi >= (cbWantP) )                                    \
            if( POOP ) POOPR                                                                                    \
            tinP.pEtScratch->boxGetShadowF( tinP , pbi , cbi , tFileQuota , 1 ) ; ___( pbi ) ;                  \
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )                                               \
            ZE( countT , cbi ) ;                                                                              \
            ZE( byteT* , pbi ) ;                                                                              \
            bRefuse = 1 ;                                                                                       \
        {                                                                                                       \
        batQuotaP.grabF( tinP , TAG( TAGiDnULL ) ) ;                                                            \
                                                                                                                \
#define CHECKqUOTA(cbWantP)                                                                                     \

#define SETiDaRM(postOldCmdP,idArmP) if( !tinP.pEtScratch->strCompareF( tinP , psttc1 , T(postOldCmdP) ) ) idArm = idArmP ;

#define ifcIDaRM_TYPEnACK        0x12
#define ifcIDaRM_TYPEaCKi        0x11
#define ifcIDaRM_PASSCODEnACK    0x10
#define ifcIDaRM_PASSCODEaCK     0xf
#define ifcIDaRM_USERnACK        0xe
#define ifcIDaRM_USERaCK         0xd
#define ifcIDaRM_PASSIVE         0xc
#define ifcIDaRM_PWD             0xb
#define ifcIDaRM_STORE           0xa
#define ifcIDaRM_RETRIEVE        0x9
#define ifcIDaRM_SIZE            0x8
#define ifcIDaRM_PORT            0x7
#define ifcIDaRM_LIST            0x6
#define ifcIDaRM_STAT            0x5
#define ifcIDaRM_QUIT            0x4
#define ifcIDaRM_TYPE            0x3
#define ifcIDaRM_PASSWORD        0x2
#define ifcIDaRM_USER            0x1

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

