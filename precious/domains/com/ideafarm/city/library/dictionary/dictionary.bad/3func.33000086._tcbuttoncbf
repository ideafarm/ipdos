
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bHandled ;

    }
        }
            break ;

            }
                }
                    break ;
                    }
                        if( tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , flagsOld , sadamP ) ;
                        if( F(tc.flFeatures) & flTCfEATURE_ACTIONhIGHLIGHT ) sadamP.pStrike->sc.pPaper->sadamHighlightF( tinP , sadamP , flSADAMhIGHLIGHT_DOWN ) ;
                        tc.flagsTcState &= ~( F(flTCsTATE_DOWN) ) ;
                        const flagsT flagsOld = tc.flagsTcState ;
                    {
                    if( !bIn && F(tc.flagsTcState) & flTCsTATE_DOWN )
                {
                case ifcIDtYPEtOOL_MOUSEpOSITION :
                }
                    break ;
                    }
                        }
                            break ;
                            }
                                if( tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , flagsOld , sadamP ) ;
                                if( F(tc.flFeatures) & flTCfEATURE_ACTIONhIGHLIGHT ) sadamP.pStrike->sc.pPaper->sadamHighlightF( tinP , sadamP , flSADAMhIGHLIGHT_DOWN ) ;
                                tc.flagsTcState &= ~( F(flTCsTATE_DOWN) ) ;
                                const flagsT flagsOld = tc.flagsTcState ;
                            {
                            if( F(tc.flagsTcState) & flTCsTATE_DOWN )
                        {
                        case ifcIDtYPEaCTION_UP :
                        }
                            break ;
                            }
                                if( tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , flagsOld , sadamP ) ;
                                if( F(tc.flFeatures) & flTCfEATURE_ACTIONhIGHLIGHT ) sadamP.pStrike->sc.pPaper->sadamHighlightF( tinP , sadamP , flSADAMhIGHLIGHT_DOWN ) ;
                                else                                  tc.flagsTcState |=      flTCsTATE_ON    ;
                                if( F(tc.flagsTcState) & flTCsTATE_ON ) tc.flagsTcState &= ~( F(flTCsTATE_ON) ) ;
                                tc.flagsTcState |= flTCsTATE_DOWN ;
                                const flagsT flagsOld = tc.flagsTcState ;
                            {
                            if( !( F(tc.flagsTcState) & flTCsTATE_DOWN ) )
                        {
                        case ifcIDtYPEaCTION_DOWN :
                    {
                    if( bIn ) switch( idAction )
                {
                case ifcIDtYPEtOOL_MOUSEbUTTONlEFT :
            {
            switch( idTool )

            ;
            )
                (sCountT)idRow <= R( sadamP.pStrike->sc.mIdRowHot ) - 1.0 + R( sadamP.pStrike->sc.mRowsHot )
                (sCountT)idRow >= R( sadamP.pStrike->sc.mIdRowHot )                                   &&
                (sCountT)idCol <= R( sadamP.pStrike->sc.mIdColHot ) - 1.0 + R( sadamP.pStrike->sc.mColsHot ) &&
                (sCountT)idCol >= R( sadamP.pStrike->sc.mIdColHot )                                   &&
            (
            boolT bIn =

            const countT& idRow    = pcNotesP[ 5 ] ;
            const countT& idCol    = pcNotesP[ 4 ] ;
            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            }
                if( idTool != ifcIDtYPEtOOL_TAB && idTool != ifcIDtYPEtOOL_TABbACK && tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , tc.flagsTcState , sadamP ) ;
                const countT& idTool = pcNotesP[ 2 ] ;
            {
            if( !tc.pFlagsTcFeatureDisable || !( F(*tc.pFlagsTcFeatureDisable) & flTCfEATURE_KEYaCTION ) )
        {
        case ifcIDtYPEsTROKEcALLbACK_KEYBOARD :
        }
            break ;
            }
                }
                    }
                        if( tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , tc.flagsTcState , sadamP ) ;
                        if( F(tc.flFeatures) & flTCfEATURE_ACTIONhIGHLIGHT ) paperOldC::setFlashIF( tinP , sadamP , 2 , 1 , flSADAMhIGHLIGHT_DOWN ) ;
                    {
                    else
                    if( F(tc.flFeatures) & flTCfEATURE_HOTkEYgRABStAB ) etherP.osThreadF( TaRG1( tmGrabTabF ) , (countT)&sadamP ) ; //I AM CALLED BY callSadamsIF, WHICH HAS GRABBED A BUNCH OF sadamC IMAGES, SO I'VE GOT TO DO THIS ON ANOTHER THREAD
                {
                if( !( F(tc.flagsTcState) & flTCsTATE_DOWN ) )
            {
            if( !tc.pFlagsTcFeatureDisable || !( F(*tc.pFlagsTcFeatureDisable) & flTCfEATURE_HOTkEY ) )
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            break ;
            if( tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , flagsOld , sadamP ) ;
            tc.flagsTcState = flTCsTATE_null ;
            const flagsT flagsOld = tc.flagsTcState ;
        {
        case ifcIDtYPEsTROKEcALLbACK_ERASE :
        case ifcIDtYPEsTROKEcALLbACK_DESTROY :
        case ifcIDtYPEsTROKEcALLbACK_SLEEP :
        }
            break ;
            if( tc.pTcStateCBF ) bHandled = (*tc.pTcStateCBF)( tinP , etherP , tc.cArg , idTypeCallP , idEventP , pcNotesP , tc.flagsTcState , tc.flagsTcState , sadamP ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_TABlEAVING  :
        case ifcIDtYPEsTROKEcALLbACK_TABaRRIVING :
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER     :
        case ifcIDtYPEsTROKEcALLbACK_INoUTqUERY :
        case ifcIDtYPEsTROKEcALLbACK_DRAGeND :
        case ifcIDtYPEsTROKEcALLbACK_DRAGbEGIN :
    {
    switch( idTypeCallP )
    tcButtonC& tc = *(tcButtonC*)sadamP.features.fc.callBackArg ;

    //sadamHighlightF IS ALWAYS CALLED BEFORE THE CBF BECAUSE THE CBF MIGHT HIDE THE WINDOW
    ZE( boolT , bHandled ) ;

    _IO_
{
/*1*/boolT _export _tcButtonCBF( tinS& tinP , etherC& etherP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , sadamC& sadamP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

