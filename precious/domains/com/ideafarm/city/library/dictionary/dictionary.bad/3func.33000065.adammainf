
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return POOP ? ifcEXITcODEpROCESSiMPOTENT : ifcEXITcODEpROCESSaOK ;

    }
        { CONoUTrAW3( "adamMainF set   [pEther]" , processGlobal4I.tinVeryEarlyLateMain.pEther , "\r\n" ) ; }
        if( processGlobal4I.tinVeryEarlyLateMain.pEther )
    {
    if( processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH07 )
    //CS:DUPLICATE: 3612c002 3612c003
    //U:: TO FIND A BUG

    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINb1 ) ;
    }
        //tinP.pc Utility[ 0 ] -- ; //U::TO FIND A BUG
        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN91 ) ;
        }
            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN81 ) ;

            etherC::etRockIF( tinP ).traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
            OStEXTC(  ostoSay , tinP.pAdamGlobal1->cSpins4 , '0' ) ;
            OStEXTAK( ostoSay , "." ) ;
            OStEXTC(  ostoSay , tinP.pAdamGlobal1->cSpins3 , '0' ) ;
            OStEXTAK( ostoSay , "." ) ;
            OStEXTC(  ostoSay , tinP.pAdamGlobal1->cSpins2 , '0' ) ;
            OStEXTAK( ostoSay , "." ) ;
            OStEXTC(  ostoSay , tinP.pAdamGlobal1->cSpins1 , '0' ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , tinP.pAdamGlobal1->cYieldHighWater , 0 ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , tinP.pAdamGlobal1->idAdam , 0 ) ;
            OStEXTAK( ostoSay , "adamMainF [idAdam,cYieldHighWater,cSpins1,cSpins2,cSpins3,cSpins4]:    " ) ;
            OStEXT(   ostoSay , TUCK << 2 ) ;

            tinP.pAdamGlobal1->_etherC_.pHdll = 0 ;
            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN71 ) ;
            }
                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN61 ) ;
                }
                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN51 ) ;
                    }
                        }
                            while( !( F(thirdC::third_flagsProcessStateI_IF(tinP)) & flPROCESSsTATE_tmWindowsF_HASeNDED ) ) { ++ s ; thirdC::dosSleepRawIF( tinP , 250 ) ; }
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        thirdC::third_flagsProcessStateI_IF( tinP , flPROCESSsTATE_MAINtHREADcLEANUPiScOMPLETE , 1 ) ;
                        //if( idTypeP == ifcIDtYPEtLS_WINDOW && !idCmdShowP && !hPreviousWindowingClientP ) { ZE( countT , foo ) ; } //U:: CONJ: NOT NEEDED
                    {
                    if( idTypeP == ifcIDtYPEtLS_WINDOW )
                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN41 ) ;

                    if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN31 ) ;
        
                    if( thirdC::third_cThirdObjectsI_IF( tinP ) ) ;//TELLsYSc1( ifcIDtYPEtELLsYS_ERRORsOMEtHIRDoBJECTSeXIST )
                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN21 ) ;
                    }
                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN11 ) ;
                        }
                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN01 ) ;

                            }
                                THREADmODE4rESTORE
                                }
                                    cPending = 0 ;

                                    }
                                        thirdC::dosTellMonitorIF( tinP , tell , ifcIDbOOKStELL_APP ) ;
                                        tellC tell( tinP , LF , 0 , ifcIDtYPEtELLaPP_INoUTaRRAY , tinP.pbPendingInOutFramePackets , sizeof( countT ) + cPending * sizeof( tellInfoAppInOutFrameS ) ) ;
                                    {

                                    }
                                        BLAMMO ;
                                        LOGrAW5(    "adamMainF error: [cPending,cMax]: " , cPending , " " , CmAXpENDINGiNoUTfRAMEpACKETS , "\r\n" ) ;
                                        CONoUTrAW5( "adamMainF error: [cPending,cMax]: " , cPending , " " , CmAXpENDINGiNoUTfRAMEpACKETS , "\r\n" ) ;
                                    {
                                    if( cPending > CmAXpENDINGiNoUTfRAMEpACKETS )

                                    tellInfoAppInOutFrameS* pPending = (tellInfoAppInOutFrameS*)( tinP.pbPendingInOutFramePackets + sizeof( countT ) ) ;
                                {
                                if( cPending )

                                countT& cPending = *(countT*)tinP.pbPendingInOutFramePackets ;

                                THREADmODE4oN( flTHREADmODE4_INoUTfRAMEdOnOTcOLLECTaPPtELEMETRY | flTHREADmODE4_DOnOTfLUSHpENDINGaPPtELEMETRY ) ;
                            {
                            if( tinP.pbPendingInOutFramePackets )
                            //PSEUDOdUPLICATEcODE 360fc002 33000065
                            //THE CODE IS RETAINED BECAUSE tellC MIGHT USE *tinP.pPoolUse IN THE FUTURE, AND ALSO FLUSHING ESTABLISHES A KNOWN STATE (AN EMPTY BUFFER) FOR PROCESS TERMINATION
                            //THIS IS DONE HERE TO FLUSH PENDING inOutFrameC APP TELEMETRY WHILE poolC IS STILL AVAILABLE (AS OF THIS WRITING, tellC ALWAYS USES heap, SO WHETHER tinP.pPoolUse IS NONZE HAS NO EFFECT

                            }
                                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINf ) ;
                                if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINe ) ;
                                }
                                    // tinP IS DESTROYED HERE (BY etherC DT'OR)
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINd ) ;
                                    }
                                        TELL( "main: destroying ether" ) ;
                                        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                        TINSL
                                    {
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINc ) ;
                                    }
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINb ) ;

                                        TELL( "main: destroying etThread and tinP reference" ) ;

                                        //tinP.monitor.idWhat2 = 0 ;
                                        //ether.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;
                                        //ether.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
                                        //ether.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
                                        //ether.traceF( tinP , T("disabling where") ) ;

                                        //U::POOLS 2 3 4 WERE DESTROYED HERE

                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINa ) ;
                                        DEL( tinP.pAdamGlobal1->pBksLog ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN9 ) ;
                                        TELL( "main: destroying log" ) ;

                                        }
                                            if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                            TINSL
                                        {
                                        TELL( "main: inspecting phase 2" ) ;
        
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN8 ) ;
                                        DEL( tinP.pEtScratch ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN7 ) ;
                                        TELL( "main: destroying pEtScratch" ) ;
                                        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                        TELL( "main: inspecting phase" ) ;
                                        //if( etThread ) thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_etThreadONmainISiMPOTENT ;
                                        //tinP.pEther = 0 ;
                    
                                        tinP.tally.flushF( tinP , etThread ) ;
                                        tinP.tally.nowF( tinP , etThread ) ;
                                        tinP.tally.bTally = 0 ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN6 ) ;
                    
                                        }
                                            if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN5 ) ;
                                            thirdC::s_shutdown1IF( tinP ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN4 ) ;
                                            }
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN3 ) ;
                                                }
                                                    DEL( tinP.pAdamGlobal1->_deviceC_pStkJob ) ;
                                                    DELzOMBIE( pDisplay ) ;
                                                {
                                                if( idTypeP == ifcIDtYPEtLS_WINDOW )

                                                if( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_WHEREaLL ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;
                                                }
                                                    TELLsYSc1( ifcIDtYPEtELLsYS_AOKfYIjUSTcALLEDaDAMmAIN ) 
                                                    TELL( "main: returned from pMainF" ) ;
                                                    }
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN2 ) ;
                                                        tinP.unwatchedF() ;
                                                        //etherC::ifcSayIF( T("called pMainF") , flSAY_APPEND | flSAY_LOG ) ;
                                                        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                                        cryC cry0d( TOCK + 0x0d ) ;
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN1 ) ;
                                                        }
                                                            (*pMainF)( &main ) ; // ASSUME: WILL NOT RETURN UNTIL ALL KID THREADS HAVE ENDED, INCLUDING tmWatchF
                                                            _IO_
                                                        {
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN23 ) ;
                                                        cryC cry0c( TOCK + 0x0c ) ;

                                                        __( tinP.pAdamGlobal1->idMemorySpace - rootAdamGlobal1I.idMemorySpace ) ; // THIS ENSURES THAT ALL ADAMS WITHIN A PROCESS ARE USING THE SAME MEMORY SPACE (THEY HAVE ACCESS TO PROCESS GLOBALS THAT USE A MEMORY SPACE)

                                                        }
                                                            countT foo = 2 ;
                                                        {
                                                        if( idAdamWant == tinP.pAdamGlobal1->idAdam )
                                                        static countT idAdamWant = 0x401057b ; //TO FACILITATE WDW DEBUGGING

                                                        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                                        //etherC::ifcSayIF( T("calling pMainF") , flSAY_APPEND | flSAY_LOG ) ;
                                                        _IO_
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN13 ) ;
                                                    {
            
                                                    TELL( "main: calling pMainF" ) ;
                                                    TELLsYSc1( ifcIDtYPEtELLsYS_AOKfYIaBOUTtOcALLaDAMmAIN ) 
                                                    declareVmUsageTypeGF( tinP , (byteT*)pMainF , flVMuSAGEtYPE_CODEaDAM ) ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN03 ) ;
                                                    _IO_
                                                {
                                                else
                                                }
                                                    tinP.unwatchedF() ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINf2 ) ;
                                                    _IO_
                                                {
                                                if( !pMainF || ether )

                                                TELL( "main: mainS object constructed" ) ;
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINe2 ) ;
                    
                                                mainS main( tinP , ether , etThread , hDll , T("cid ")+tCid+T(" level 1") ) ;
                                                TELL( "main: constructing mainS object" ) ;

                                                }
                                                    __Z( pMainF ) ;
                                                    etThread.dllEntryF( tinP , pMainF , hDll , T("mainF") ) ;
                                                    __Z( hDll ) ;
                                                    etThread.delF( tinP , psttDll ) ;
                                                    TELL( "main: looking up the entry point" ) ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINd2 ) ;
                                                    _IO_
                                                {
                                                ZE( mainFT , pMainF ) ;

                                                }
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINc2 ) ;
                                                    }
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINb2 ) ;
                                                        }
                                                            etThread.dllOpenF( tinP , hDll , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.")+T(psttDll)+T(".ipdos-wd") ) ;
                                                            //hoverC hover( tinP , etThread , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/") ) ;
                                                        {
                                                        else
                                                        if( etThread.strIdF( tinP , S1C('/') , psttDll ) ) etThread.dllOpenF( tinP , hDll , psttDll ) ;

                                                        // state C IS OBSOLETED BY THE adam.perm POOL AND ALL state C CODE SHOULD BE MIGRATED AND THEN state C REMOVED
                                                        // THIS FEATURE IS BROKEN AND REQUIRES WORK

                                                        // THE OLD INSTANCE WILL COMPLETE ALL SERVICE TO EXISTING CLIENTS AND THEN TERMINATE
                                                        // THE NEW INSTANCE WILL IMMEDIATELY ASSUME RESPONSIBILITY FOR ACCEPTING NEW CLIENTS
                                                        // BY DEFAULT, ONLY ONE INSTANCE OF AN ADAM CAN EXIST AT A TIME IN A HOME
                                                        // THE FOLLOWING COMMENTS ARE OBSOLETE; MULTIPLE INSTANCES CAN COEXIST (SEE E.G. ifcIDaDAM_CLOUD); THE OLD HANDOFF CODE WAS DISABLED/REMOVED AND CODE RELATED TO SAVING AND LOADING ADAM STATE IS DISABLED OR IN AN UNKNOWN UNUSED STATE

                                                        // A MASTER FILE CAN BE UPDATED WHILE ITS CORRESPONDING HOVER FILE IS LOADED AND IN USE BY RUNNING PROCESSES

                                                        // THE MAIN (PERHAPS ONLY) REASON FOR THIS IS TO MAKE "HOT UPDATING" POSSIBLE
                                                        // IPDOS PROCESSES ARE NORMALLY LOADED FROM THE HOVER DIRECTORY
                                                        // THIS WILL BE DONE IF THE EXE IMAGE IS COMING FROM THE HOVER DIRECTORY

                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINa2 ) ;
                                                        _IO_
                                                    {
                                                    else
                                                    }
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN92 ) ;
                                                        etThread.dllOpenF( tinP , hDll , T("ideafarm.")+T(psttDll)+T(".ipdos-wm") ) ;
                                                        __( etThread.strIdF( tinP , S1C('/') , psttDll ) ) ;

                                                        // FOR EXAMPLE, WHEN INSTALLING THE BUILD FOLDER ON A NEW DEVELOPMENT COMPUTER, THE BUILD PROGRAMS (IN BENCH) WILL BUILD THE MASTER FILES AND THEN LOAD PROCESSES FROM THEM TO BUILD THE HOVER FILES
                                                        // IPDOS PROCESSES ARE ONLY LAUNCHED FROM THE MASTER DIRECTORY WHEN THE DESIRED IMAGE DOES NOT EXIST IN THE HOVER DIRECTORY
                                                        // THIS WILL BE DONE IF THE EXE IMAGE IS COMING FROM THE MASTER DIRECTORY

                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN82 ) ;
                                                        _IO_
                                                    {
                                                    else if( !etThread.strCompareF( tinP , T(thirdC::postBaseNameIF(tinP)) , T(ostoCopy) ) ) // THE SMUDGER THAT MAKES THE HOVER FILE WILL NOT REPLACE ostoCopy BUT IT WILL REPLACE THE STRING IN postBasenameIF
                                                    }
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN72 ) ;
                                                        etThread.dllOpenF( tinP , hDll , psttDll ) ;
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN62 ) ;
                                                        _IO_
                                                    {
                                                    if( etThread.strIdF( tinP , T("/IdeaFarm " "(tm) Removal Utility/") , psttDll ) )
                                                    ( (osTextT*)(const osTextT*)ostoCopy )[ 9 ] = '8' ;
                                                    OStEXTV( ostoCopy , "ideafarm.@1000001.ipdos-wm" )
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN52 ) ;
                                                    _IO_
                                                {
                                                TELL( "main: linking in the adam dll" ) ;

                                                TNCID ;
                                                //U:etThread.constructedInLine = 0 ;
                                                //U:etThread.postcConstructedInFile = ppostHowP[ 1 ] ;
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN42 ) ;

                                                }
                                                    pDisplay = new( 0 , tinP , pbDisplay , sizeof pbDisplay ) displayC( tinP , etThread , ((measureT)1e1) , 0 , 0 , flDEVICEc_NOsMOOTHIES ) ; //USE SMOOTHIES IN PRODUCTION BUT NOT FOR SOME TESTING
                                                    tinP.pAdamGlobal1->_deviceC_pStkJob = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_GIVEsIGNnEWpLATE , sizeof( drawJobS ) ) ; ___( tinP.pAdamGlobal1->_deviceC_pStkJob ) ;
                                                    _IO_
                                                {
                                                if( idTypeP == ifcIDtYPEtLS_WINDOW )        //U:: 20200314@1545: CT THIS STACK FAILS ON NONMONOTONIC GRAB.  TESTING OF NONMONOTONIC GRAB ENFORCEMENT DID NOT INCLUDE TESTS FOR GUI PROCESSES
                                                ZE( displayC* , pDisplay ) ;
                                                byteT pbDisplay[ sizeof( displayC ) ] ;
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN32 ) ;
            
                                                }
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN22 ) ;
                                                    sgnWatchReady.waitF( tinP ) ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN12 ) ;

                                                    }
                                                        sgnWatchReady.giveF( tinP ) ;
                                                        if( idTypeP == ifcIDtYPEtLS_WINDOW ) sgnWindowsReady.waitF( tinP ) ;
                                                    {
                                                    if( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS )

                                                    }
                                                        etThread.osThreadF( tinP , countTC() , tmWindowsF , 0 , flTHREADlAUNCH_null , 0 , (countT)&sgnWindowsReady , (countT)&psttTitle ) ;
                                                        thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_tmWindows ;
                                                    {
                                                    else
                                                    }
                                                        etThread.delF( tinP , psttTitle ) ;
                                                        etThread.winSetTitleF( tinP , psttTitle ) ;
                                                        sgnWindowsReady.giveF( tinP ) ;
                                                    {
                                                    if( idTypeP != ifcIDtYPEtLS_WINDOW )
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN02 ) ;

                                                    //ether.osSleepF( tinP , TOCK << 2 ) ;
                                                    //sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                                                    //etThread.winSetTitleF( tinP , T("tmWatchF launched ; napping for 4 tocks") ) ;
                                                    //TO FIND BUGS
                
                                                    //etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_NORMAL ) ;

                                                    else                                                                                     etThread.traceF( tinP , T("warning: build is configured for \"no system threads\"") ) ;
                                                    if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS ) ) etThread.osThreadF( tinP , countTC() , tmWatchF , 0 , flTHREADlAUNCH_null , 0 , (countT)&sgnWatchReady , (countT)&sgnWindowsReady ) ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINf1 ) ;

                                                    //etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;
        
                                                    signC sgnWindowsReady( tinP , TAG( TAGiDnULL ) ) ;
                                                    signC sgnWatchReady( tinP , TAG( TAGiDnULL ) ) ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINe1 ) ;
                                                    _IO_
                                                {
            
                                                __( &sadams - sadamsC::pSadamsIF( tinP ) ) ;
                                                sadamsC sadams( tinP , etThread , TAG( TAGiDnULL ) ) ;
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINd1 ) ;

                                                }
                                                    etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , 0x30 ) ;
                                                    _IO_
                                                {
                                                if( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_WHEREaLL )

                                                //etherC::ifcSayIF( T("ADAM CELL (idAdam,osPid): ")+TF1(processGlobal1I.idAdamRoot)+T(" ")+TF1(tinP.osPid)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                                                }
                                                    etThread.traceF( tinP , tTitle ) ; //RETAIN THIS; IT IS USEFUL TO DEFEND AGAINST ATTACK
                                                
                                                    ;
                                                        +t8+T("P_")+TF2(tinP.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("(")+TF4(tinP.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(")")
                                                        +t8+T("F_")+TF2(tinP.pAdamGlobal1->idGroupFireAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                        +t8+T("A+")+TF2(tinP.pAdamGlobal1->idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("(")+TF2(tinP.pAdamGlobal1->idAdam&0xfff,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(")")
                                                        +t8+T("A_")+TF2(rootAdamGlobal1I.idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("(")+TF2(processGlobal1I.idAdamRoot&0xfff,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(")")
                                                        +t8+T("M_")+TF2(tinP.pAdamGlobal1->idMemorySpace,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                        +t8+T("H_")+TF2(processGlobal1I.idHome,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                        T(postIPDOSsHORT)
                                                    TN( tTitle , "" ) ; tTitle =

                                                    TN( t8 , "        " ) ;
                                                    _IO_
                                                {
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINc1 ) ;

                                                }
                                                    #endif

                                                        etThread.strMakeF( tinP , LF , psttDll , TF3(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( psttDll ) ;

                                                    #else

                                                    }
                                                        break ;
                                                        etThread.strMakeF( tinP , LF , psttDll , psttc1 ) ; ___( psttDll ) ;
                    
                                                        if( !psttc1->idAdam || psttc1[ CSpREFIX ] == sttExclaim ) break ;
                                                        if( cSkip -- ) continue ;
                                                        //CONoUTrAW( T("parameter: \"")+T(psttc1)+T("\"\r\n") ) ;
                                                    {
                                                    FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )
                                                    strokeS sttExclaim('!') ;
                                                    countT cSkip = 1 ;

                                                    // THE TRAILING FO SYMBOLS AND ~ AND ` SHOULD NOT BE USED FOR PARAMETER KEYS BECAUSE THEY WOULD BE USEFUL AS OPERATORS
                                                    // RESERVED: ` ~ ! @ # $ % ^ & * - + =
                                                    // NEW CONFORMANCE SPEC:  PARAMETER KEYS CAN START WITH EITHER '!' OR '@', WITH POSSIBLE FUTURE USE OF '#', '$', '%', ... TO RESERVE SUCH USE OF ALL OF THE SYMBOLS IN THE TOPMOST ROW OF THE US KEYBOARD
                                                    // THIS DECISION TO USE '@' RATHER THAN '!' MIGHT BE THE BEGINNING OF CHANGING CONFORMANCE RULES TO ABANDON THE SPEC THAT ALL PARAMETER KEYS START WITH '!'
                                                    // 20181113@0922:

                                                    // OTHERWISE, THE SYMBOLIC ADAMS WOULD BE OF THE FORM "!aFind", AND SPECIFYING THEM WOULD CAUSE ME TO THINK THAT NO idAdam WAS SPECIFIED, UNLESS ALL OF THEIR POSSIBLE VALUES WERE HARDCODED IN ME
                                                    // '@' IS USED RATHER THAN '!' SO THAT I CAN LOOK AT ONLY THE WOTH CHARACTER TO DETECT THE ABSENCE OF AN idAdam SPECIFICATION IN THE WOTH PARAMETER AFTER THE EXE NAME
                                                    // 20181112@1144: THE WOTH ARGUMENT (IDENTIFYING idAdam) IS NOW ALLOWED TO BE SYMBOLIC, E.G. "@find", SO THIS CODE IS REPLACED WITH CODE THAT USES processGlobal1I.idAdamRoot

                                                    #if defined( NEVERdEFINED )
                                                    _IO_
                                                {
                                                ZE( strokeS* , psttDll ) ;
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINb1 ) ;
                                                _IO_
                                            {
                                            else
                                            }
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINa1 ) ;
                                                _IO_
                                            {
                                            if( ether )
                                            _IO_

                                            etThread.ifcDatumF( tinP , flDATUM1_CLASStRACEaLWAYShIRE , flDATUM2_null , 0 , 0 , 0 , (voidT*)DDNAME ) ;
                                            }
                                                etThread.osThreadF( tinP , countTC() , tmTimeNowF ) ;
                                                etThread.osThreadF( TaRG1( tmKillSocketF ) ) ; //A:ASSUME: thirdC::s_setupIF HAS ALREADY BEEN CALLED (LOOK FOR IT VERY EARLY DURING CT OF processGlobal3I)
                                            {
                                            if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS ) )
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN91 ) ;

                                            TELL( "main: parameters scanned" ) ;
                                            }
                                                //etThread.traceF( tinP , T("adam parameters (command line arguments) END [idAdam]:    ")+TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                }
                                                    //U::if( bOk ) etThread.strokeF( tinP , T("process parameter \"")+T(psttc1)+T("\" recognized\r\n") ) ;

                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!dead"              ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_LOGdEADLOCKS                     ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!hideWithIcon"      ) ) ) { thirdC::third_flagsModeProcess2I_IF(tinP) |= flMODEpROCESS2_HIDEwITHiCON                 ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!noSynchronousTells") ) ) { thirdC::third_flagsModeProcess2I_IF(tinP) |= flMODEpROCESS2_NOsYNCHRONOUStELLS           ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!noTells"           ) ) ) { thirdC::third_flagsModeProcess2I_IF(tinP) |= flMODEpROCESS2_SUPPRESStELLS                ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!noTellsHome"       ) ) ) { homeS::homeIF().flags |= flHOMEs_SUPPRESStELLS                                           ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!whereAll"          ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_WHEREaLL                         ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!noGlobalGrab"      ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_DISALLOWgRABoFiNTERPROCESSgRABs  ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!minimized"         ) ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_LAUNCHmINIMIZED            ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!quitAtShutdown"    ) ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_QUITaTsHUTDOWN             ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!quitAtLogoff"      ) ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_QUITaTlOGOFF               ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!log2monitor"       ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_LOG | flADAMmODE1_LOGtOmONITOR   ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!log2popup"         ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_LOG | flADAMmODE1_LOGtOpOPUP     ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!log2file"          ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_LOG | flADAMmODE1_LOGtOfILE      ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!faceHear"          ) ) ) { idArg = 3                                                                                ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!cUtility"          ) ) ) { idArg = 2                                                                                ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!idCitizenHirerI"   ) ) ) { idArg = 1                                                                                ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!bWatchSay"         ) ) ) { etThread.flagsWatch |=  flWATCH_SAY                                                      ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!bWatchEmployers"   ) ) ) { etThread.flagsWatch |=  flWATCH_EMPLOYERS                                                ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!bWatchTimeNo"      ) ) ) { etThread.flagsWatch &= ~( F(flWATCH_TIME) )                                              ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!debug"             ) ) ) { thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_DEBUG  ;                   ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!testAutoDoSleeps"  ) ) ) { etThread.flagsMode  |=  flTHIRDmODE_TESTaUTOdOsLEEPS                                     ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!testAuto"          ) ) ) { etThread.flagsMode  |=  flTHIRDmODE_TESTaUTO                                             ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!bWatchfulINo"      ) ) ) { ((thirdC&)ether).third_bWatchfulI_F( tinP ) = 0                                          ; bOk = 1 ; }
                                                    else if( !etThread.strCompareF( tinP , psttc1 , T("!bCarefulINo"       ) ) ) { ((thirdC&)ether).third_bCarefulI_F( tinP ) = 0                                           ; bOk = 1 ; }
                                                    //CS:CODEsYNC: 33000065 33000065
                                                    }
                                                        }
                                                            }
                                                                break ;
                                                                if( psttc1->idAdam && 1 == etThread.strIdF( tinP , idf , sttq , S1C('!') , psttc1 ) ) idArg = 0 ;
                                                                countT idf = 1 ;
                                                                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                                            {
                                                            case  3 :
                                                            case  2 : { idArg = 0 ; etherC::ether_cUtility_IF( tinP )          = etThread.strDigitsToSCountF( tinP , psttc1 ) ; bOk = 1 ; break ; }
                                                            case  1 : { idArg = 0 ; etThread.ether_idCitizenHirerI_F( tinP ) = etThread.strDigitsToSCountF( tinP , psttc1 ) ; bOk = 1 ; break ; }
                                                        {
                                                        switch( idArg )
                                                    {
                                                    if( idArg )
                                                    ZE( boolT , bOk ) ;

                                                    if( idTypeP == ifcIDtYPEtLS_WINDOW && !psttTitle && ( off ++ ) == 1 ) { etThread.strMakeF( tinP , LF , psttTitle , psttc1 ) ; ___( psttTitle ) ; }

                                                    //etThread.traceF( tinP , T("    [parameter]: ")+T(psttc1) ) ;
                                                {
                                                FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )
                                                ZE( countT , idArg ) ;
                                                ZE( countT , off ) ;
                                                //etThread.traceF( tinP , T("adam parameters (command line arguments) BEGIN [idAdam]:    ")+TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            TELL( "main: inspecting process parameters" ) ;

                                            etThread.etherScanProcessParametersF( tinP ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN81 ) ;

                                            }
                                                //}
                                                //    etThread.traceF( tinP , T("parameter: \"")+T(psttc1)+T("\"") ) ;
                                                //{
                                                //FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )

                                                }
                                                    }
                                                        etThread.strFuseSeparateF( tinP , etThread.ether_pstt1_processParametersI_F( tinP ) , tMonitor ) ;
                                                        etThread.strFuseSeparateF( tinP , etThread.ether_pstt1_processParametersI_F( tinP ) , tDriver  ) ;
                                                    {
                                                    )
                                                        )
                                                            )
                                                                *ppostHowP[ off + 1 ] == '!'
                                                            (
                                                            ||
                                                            cHowP == 1
                                                        (
                                                        &&
                                                        && !off
                                                           bOsSupportsServices
                                                    (
                                                    if
                                                    etThread.strFuseSeparateF( tinP , etThread.ether_pstt1_processParametersI_F( tinP ) , T(ppostHowP[off]) ) ; ___( etThread.ether_pstt1_processParametersI_F( tinP ) ) ;
                                                {
                                                for( countT off = 0 ; off < cHowP ; off ++ )

                                                etThread.strMakeF( tinP , LF , etThread.ether_pstt1_processParametersI_F( tinP ) , 0 , csttNeeded ) ; ___( etThread.ether_pstt1_processParametersI_F( tinP ) ) ;
                                                }
                                                    csttNeeded += 2 * CSpREFIX + tDriver.csF( tinP ) + tMonitor.csF( tinP ) ;
                                                    )
                                                        )
                                                            )
                                                                *ppostHowP[ off + 1 ] == '!'
                                                            (
                                                            ||
                                                            cHowP == 1
                                                        (
                                                        &&
                                                        && !off
                                                           bOsSupportsServices
                                                    (
                                                    if

                                                    csttNeeded += CSpREFIX + thirdC::c_strlenIF( tinP , ppostHowP[off] ) ;
                                                {
                                                for( countT off = 0 ; off < cHowP ; off ++ )
                                                countT csttNeeded = CSpREFIX ;

                                                }
                                                    tMonitor = TF1(ifcIDaDAM_KERNEL2MONITOR) ;
                                                    tDriver  = TF1(ifcIDaDAM_KERNEL1DRIVER)  ;
                                                {
                                                if( bOsSupportsServices )
                                                TN( tMonitor , "" ) ;
                                                TN( tDriver  , "" ) ;
                                            {
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN71 ) ;

                                            }
                                                etThread.strMakeF( tinP , LF , psttTitle , tAdam+t8b+T(postIPDOSsHORTlONG)+( processGlobal1I.idHome==1 ? T("") : T(" (home ")+TF2(processGlobal1I.idHome,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(")") ) ) ; ___( psttTitle ) ;

                                                TN( t8b , "        " ) ;
                                                if( !tAdam.csF( tinP ) ) tAdam = TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
                                                TN( tAdam , "" )       ; tAdam = T(mapAdam(tinP.pAdamGlobal1->idAdam)) ;

                                                mapCTC& mapAdam = processGlobal3S::_processGlobal3I_IF().mapAdam ;
                                            {
                                            ZE( strokeS* , psttTitle ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN61 ) ;

                                            tinP.time2    = timeBorn.time2 ;
                                            tinP.time1    = timeBorn.time1 ;
                                            etThread.osTimeNowF( tinP , timeBorn.time1 , timeBorn.time2 ) ;
                                            timeS timeBorn ;
                                            TELL( "main: informing ether of time and of process parameters" ) ;
        
                                            /*U:((thirdC&)ether).osRealtimeModeOnF( tinP ) ;*/
                    
                                            etThread.delF( tinP , psttDriverName ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN51 ) ;
                                        {
                                        if( !ether )
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN41 ) ;
            
                                        }
                                            bServiceManagerHiredMe = ifcDRIVERsTATUS_STARTING == ((thirdC&)ether).osDriverStatusF( tinP , T(psttDriverName) ) ;
                                            etThread.osDriverNameFromMasterF( tinP , psttDriverName , ifcIDaDAM_KERNEL2MONITOR ) ; ___( psttDriverName ) ;
                                            TELL( "main: setting bServiceManagerHiredMe" ) ;
                                        {
                                        if( ( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WITHINpROCESS ) && cHowP == 1 && bOsSupportsServices )
                                        ZE( strokeS* , psttDriverName ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN31 ) ;

                                        cryC cry0b( TOCK + 0x0b ) ;
                                        tinP.pAdamGlobal1->pBksLog = new( 0 , tinP , LF ) booksC( tinP , TAG( TAGiDnULL ) , "log" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER , TOCK ) ; ___( tinP.pAdamGlobal1->pBksLog ) ;
                                        cryC cry0a( TOCK + 0x0a ) ;
                                        TELL( "main: constructing log" ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN21 ) ;

                                        tinP.tally.bTally = 1 ;
                                        tinP.tally.nowF( tinP , etThread ) ;
                                        tinP.tally.resetF( tinP ) ;
                    
                                        tinP.pAdamGlobal1->pEtThreadMain = tinP.pEther = &etThread ;
                                        TELL( "main: " ) ;
                                        TELL( "main: ether and etThread constructed" ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN11 ) ;
        
                                        //__( tinP.monitor.idThread - ifcIDtHREADlOW_main ) ;
                                        scoopC scoop( tinP , LF , etThread ) ;
                                        TELL( "constructed tinP.pEtScratch" ) ;
                                        tinP.pEtScratch = new( 0 , tinP , LF ) etherC( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ; ___( tinP.pEtScratch ) ;
                                        TELL( "constructing tinP.pEtScratch" ) ;
                                        TELL( "constructed etThread" ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN01 ) ;

                                        if( processGlobal1I.idNumaNode ) etThread.traceF( tinP , T("NUMA:  this process will default to limiting itself to using a single NUMA node on NUMA computers [idNumaNode]: ")+TF2(processGlobal1I.idNumaNode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                        //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
                                        //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
                                        //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , 1 ) ;
                                        //tinP.monitor.idWhat2 = - 1 ;
                                        //etThread.traceF( tinP , T("enabling where") ) ;

                                        }
                                            if( pPoop ) ;
                                            poopC* pPoop = (poopC*)&(const poopC&)etThread ;
                                        {   //TO FACILITATE DEBUGGING (CAN SET A WATCHPOINT HERE TO BREAK WHEN pPoop->idSubType CHANGES)

                                        cryC cry09( TOCK + 0x09 ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINf ) ;
                                        etherC etThread( tinP , TAG( TAGiDnULL ) ) ;
                                        cryC cry08( TOCK + 0x08 ) ;
                                        TELL( "constructing etThread" ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINe ) ;
                                        _IO_
                                    {
                                    if( !ether )

                                    tinP.pEther = &ether ;
        
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINd ) ;
                                    cryC cry07( TOCK + 0x07 ) ;

                                    _IO_        // MUST BE CT AFTER ether BECAUSE DT OF ether WILL DESTROY THE CURRENT tinP
                                    TELL( "constructed ether" ) ;
                                    etherC ether( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_TINoWNER | flTHIRDmODE_QUITTER /* | flTHIRDmODE_CHECKpOOLoLD */ ) ; //DEBUGGING: TURN ON flTHIRDmODE_CHECKpOOLoLD HERE
                                    TELL( "constructing ether" ) ;
                                    cryC cry06( TOCK + 0x06 ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINc ) ;
        
                                    }
                                        //DELzOMBIE( pbnu ) ;
                                        //declareVmUsageTypeGF( tinP , pbnu , flVMuSAGEtYPE_DEFAULThEAP ) ;
                                        //byteT* pbnu = new byteT ;
                                        //U::NOW THAT I AM IN base, THE NEXT LINE EXERCISES THE OVERLOAD SO DOES NOT WORK
                                    {
                                    declareVmUsageTypeGF( tinP , (byteT*)declareVmUsageTypeGF , flVMuSAGEtYPE_CODEbASE ) ;
            
                                    tinP.idlTask  = ifcLINE ;
                                    tinP.idiTask  = DDNUMB ;
                                    putNegAM( tinP.fingerprint , FINGERnEG_TINs ) ;
                                    ___( &tinP ) ;                                          /*HERE*/
                                    TELL( "main: setting up" ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINb ) ;
                                    //_IO_  CANNOT DO THIS HERE, BECAUSE DT'OR FOR ether WILL DESTROY THE CURRENT tinP
                                    TINSL
                                {
                                if( bTinOk )
                                //_IO_    CANNOT CT HERE, BECAUSE tinP CURRENTLY REFERENCES THE PRIOR tinS

                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINa ) ;
                                cryC cry05( TOCK + 0x05 ) ;
                                }
                                    _MOLE
                                    TELL( "main: tinS, in poolOld is constructed" ) ;_
                                    }
                                        TELLsYSlIFInAME( postName ) ; //THE TELLsYSlIFInAME MUST BE ON THE SAME LINE AS THE CONSTRUCTOR CALL
                                        bTinOk = 1 ;_
                                    {
                                    if( pTin ) // pTin WILL BE TAGGED AT /*HERE*/
                                    TINSL
                                    tinS* pTin = new( 0 , tinP , LF ) tinS( tinP , TAG( TAGiDnULL ) , 0 , 0 , postName , flTINs_null , tinP.monitor.idThread == 1 ? ifcIDtINnAMED_tinInPoolMain : ifcIDtINnAMED_tinInPool ) ;_
                                    osTextT* postName = POSTtHREADnAMEmAIN ;_
                                    _MILE
                                {
                                ZE( boolT , bTinOk ) ;
                                cryC cry04( TOCK + 0x04 ) ;
                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN9 ) ;
        
                                //boolT bWorkNotRoot = !!thirdC::c_strcmpIF( tinP , ostoPoolAdamTemp , "root" ) ; /* HANDY FOR DEBUGGING */
        
                                }
                                    OStEXTAK( ostoPoolAdamTemp , "testAuto" )
                                    OStEXTcLEAR( ostoPoolAdamTemp )
                                {
                                else if( bTestAuto )
                                }
                                    //OStEXTAK( ostoPoolAdamTemp , "driver" )
                                    //OStEXTcLEAR( ostoPoolAdamTemp )
                                    //COMMENTED THIS OUT SO WILL USE LESS MEMORY, FOR SERVICE ON GODADDY VIRTUAL DEDICAED HOST THAT IS MEMORY CONSTRIAED
        
                                {
                                else if( cHowP == 1 ) //ASSUME: IF THERE ARE NO PARAMETERS THEN I WAS LAUNCHED BY THE WINDOWS SERVICE CONTROL MGR
                                }
                                    }
                                        OStEXTAK( ostoPoolAdamTemp , "testAuto" )
                                        OStEXTcLEAR( ostoPoolAdamTemp )
                                    {
                                    if( bTestAuto )
                                {
                                if( idTypeP == ifcIDtYPEtLS_WINDOW )
                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN8 ) ;
                                _IO_
                            {
                            if( !POOP )
                            ZE( boolT , bServiceManagerHiredMe ) ; // 1 IFF THE O.S. SUPPORTS "SERVICES" AND I AM THE INSTANCE BEING STARTED BY THE SERVICE MANAGER; WILL BE 0 IF I AM THE IDEAFARM DRIVER ON AN OS THAT DOES NOT SUPPORT "SERVICES"

                            if( !thirdC::third_idProcessOldI_IF( tinP ) ) thirdC::third_idProcessOldI_IF( tinP ) = - 1 ;
                            
                            //thirdC::third_flagsModeAdam2I_IF(tinP) |= flADAMmODE2_THREADcHATTER /*| flMODEpROCESS2_NOsYSTEMtHREADS*/ ;

                            cryC cry03( TOCK + 0x03 ) ;
                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN7 ) ;
                            #endif
                                poolC poolAdamTemp( tinP , TAG( TAGiDnULL ) , ostoPoolAdamTemp                 ) ; //MUST BE WOTH
                            #else
                                poolC poolAdamTemp( tinP , TAG( TAGiDnULL ) , ostoPoolAdamTemp , flPOOLc_NOTES ) ; //MUST BE WOTH
                            #if defined( ENABLEdROPnOTES )

                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN6 ) ;
                            // UNDEFINE ENABLEdROPnOTES IN PRODUCTION AND WHEN NOT CHECKING FOR LEAKS
                            cryC cry02( TOCK + 0x02 ) ;
                            
                            //CS:CODEsYNC: 0b50064 0b50064 21b0002 21b0003
                            //WHEN A BUG IS LOCATED THAT IS DUE TO CODE OUT OF SYNC, EDIT CODE TO CONDITIONALLY COMPILE BASED ON WHETHER ENABLEdROPnOTES IS DEFINED
                            //20141026@1654: IGNORE THIS CS COMMENT; IT IS UNUSEABLE SINCE IT REFERENCES OBSOLETE MODULE NUMBERS (BEFORE ALL FILES IN DICTIONARY WERE RENUMBERED TO A NEW NUMBERING SCHEME YEARS AGO)
                            
                            //TO DEBUG FOR LEAKS OR TO USE poolC::reportF, ENABLE THE  FLAG HERE AND ALSO ENABLE THE DEFINITION OF THE "ENABLEdROPnOTES" SYMBOLIC CONSTANT
                            
                            //U:: ifcIDsTATEsPACE_MULTIPLEaDAMS: REMOVE IN PRODUCTION AND WHEN NOT INVESTIGATING LEAKAGE
                            
                            OStEXTC(  ostoPoolAdamTemp , tinP.osPid , 0 )                   //20141129@1426: ADDED TO UNIQUIFY SO THAT MULTIPLE INSTANCES OF SAME idAdam CAN COEXIST
                            OStEXTAK( ostoPoolAdamTemp , "." )
                            OStEXTC(  ostoPoolAdamTemp , tinP.pAdamGlobal1->idAdam , 0 )
                            OStEXTAK( ostoPoolAdamTemp , "adam.temp." )
                            OStEXT( ostoPoolAdamTemp , TUCK << 2 )
                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN5 ) ;
                        {
                        if( !POOP )
                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN4 ) ;
                    {
                {
                cryC cry01( TOCK + 0x01 ) ;
                _IO_
                //QueryThreadCycleTime( (HANDLE)(-2) , (ULONG64*)&tinP.pc Utility04[ 0 ] ) ; //U:: TO FIND A BUG

                }
                    }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!threadChatter"            ) ) { thirdC::third_flagsModeAdam2I_IF( tinP    ) |= flADAMmODE2_THREADcHATTER ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!noSystemThreads"          ) ) { thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_NOsYSTEMtHREADS ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!noInterprocessGrabs"      ) ) { thirdC::third_flagsModeAdam1I_IF( tinP    ) |= flADAMmODE1_DISALLOWgRABoFiNTERPROCESSgRABs ; }
                        //else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!utility0"               ) ) { tinP.pc Utility[ 0 ] = 1 ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!utility"                  ) ) { thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_CHECKtINuTILITYeLEMENTS ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!debug1"                   ) ) { thirdC::third_flagsModeAdam1I_IF( tinP    ) |= flADAMmODE1_DEBUG1 ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!debug"                    ) ) { thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_DEBUG  ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!jot"                      ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_JOT ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!ignoreFireByOperator"     ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_IGNOREfIREbYoPERATOR ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!threadFiles"              ) ) { thirdC::third_flagsModeAdam1I_IF( tinP    ) |= flADAMmODE1_SEEtHREADSaSfILES ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!quietConsole"             ) ) { thirdC::third_flagsModeAdam1I_IF( tinP    ) |= flADAMmODE1_QUIETcONSOLE ; } // WIN32 DOES NOT PROVIDE A WAY TO QUERY WHETHER THIS PROCESS IS ATTACHED TO A CONSOLE; CALLING system( cls ) WHEN NOT ATTACHED CAUSES A CONSOLE WINDOW TO MOMENTARILY APPEAR; THE WORKAROUND IS TO USE A CMD LINE PARAMETER; DETACHED PROCESSES THAT ALLOCATE A CONSOLE MUST MAINTAIN (RESET) THIS FLAG
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!testAuto"                 ) ) { bTestAuto      = 1                        ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!idProcessOld"             ) ) { idArg          = 2                        ; }
                        else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!idTrial"                  ) ) { idArg          = 5                        ; }
                        //CS:CODEsYNC: 33000065 33000065
                        }
                            }
                                case 5 : { idArg = 0 ; thirdC::third_idTrialI_IF( tinP ) = thirdC::c_atoiIF( tinP , ppostHowP[ idp - 1 ] ) ; break ; }
                                case 2 : { idArg = 0 ; thirdC::third_idProcessOldI_IF( tinP ) = thirdC::c_atoiIF( tinP , ppostHowP[ idp - 1 ] ) ; break ; }
                            {
                            switch( idArg )
                        {
                        if( idArg )
                    {
                    for( countT idp = 1 ; idp <= cHowP ; idp ++ )
                    ZE( countT , idArg ) ;
        
                    }
                        thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_DRIVER ; //I WANT TO SET flMODEpROCESS1_DRIVER BIT AS SOON AS I KNOW THAT I AM THE DRIVER PROCESS, SO THAT I WILL GET POPUP IF AN EXCEPTION OCCURS
                        bPseudoService = 1 ;
                    {
                    else
                    }
                        thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_DRIVER ; //I WANT TO SET flMODEpROCESS1_DRIVER BIT AS SOON AS I KNOW THAT I AM THE DRIVER PROCESS, SO THAT I WILL GET POPUP IF AN EXCEPTION OCCURS
                    {
                    else if( bOsSupportsServices )
                    if( cHowP > 1 ) ;
                    ZE( boolT , bPseudoService ) ;

                    }
                        ppostHowP = ppostHow ;
                        cHowP = cHow ;
        
                        }
                            }
                                if( ( !off || !postOldCopy[ off - 1 ] ) && postOldCopy[ off ] ) ppostHow[ cHow ++ ] = postOldCopy + off ;
        
                                if( !postOldCopy[ off ] ) continue ;
                            {
                            for( countT off = 0 ; off < costCopy && cHow < sizeof ppostHow / sizeof ppostHow[ 0 ] ; off ++ )
        
                            if( postOldCopy[ 1 ] != ':' ) ppostHow[ cHow ++ ] = postUnk ; //WINDOWS CMD.EXE DOES NOT INCLUDE THE EXE FILE NAME WITH THE PARAMETER LIST FOR GUI PROCESSES
        
                            }
                                }
                                    off ++ ;
                                    if( !bQuote && postOldCopy[ off ] == ' ' ) postOldCopy[ off ] = 0 ;
                                    if( postOldCopy[ off ] == 0x22 ) bQuote = !bQuote ;
                                {
                                while( cToDo -- )
                                ZE( countT , off ) ;
                                countT cToDo = costCopy ;
                                ZE( boolT , bQuote ) ;
                            {
                            const countT costCopy = thirdC::c_strlenIF( postOldCopy ) ;
                            thirdC::c_strncpyIF( postOldCopy , postP , sizeof postOldCopy ) ;
                            osTextT postOldCopy[ 0x200 ] ;
                        {
                        const osTextT* postUnk = idTypeP == ifcIDtYPEtLS_WINDOW ? postUnk1 : postUnk2 ;
                        static const osTextT* const postUnk2 = "<withinDadProcess>" ;
                        static const osTextT* const postUnk1 = "<exeNameNotAvailable>" ;
                        ZE( countT , cHow ) ;
                        _IO_
                    {
                    if( idTypeP == ifcIDtYPEtLS_WINDOW || idTypeP == ifcIDtYPEtLS_WITHINpROCESS )
                {
                const boolT bOsSupportsServices = osId == 'w' ;
                const osTextT osId = thirdC::osIdIF( tinP ) ;
        
                ZE( boolT , bTestAuto ) ;
                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN3 ) ;
            {
            tinP.pAdamGlobal1->_etherC_.pHdll = &hDll ;
            handleC hDll( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DLL ) ; //MUST NOT BE CLOSED UNTIL tmWindowsF HAS ENDED, BECAUSE LATTER CAN CALL CALLBACK FUNCTIONS DEFINED IN THE ADAM
        
            }
                if( !thirdC::third_hWindowingClientIF( tinP ) ) BLAMMO
                ((handleC&)thirdC::third_hWindowingClientIF( tinP )).osF( ifcIDtYPEhANDLE_WINDOWINGcLIENT , hWindowingClientIP ) ;

                //BLAMMO ; //20120907@1304: TO PREVENT THE BLACK SCREEN THAT IGNORES ALL HUMAN INPUT BECAUSE THE GRAPHICS PRESENTATION SYSTEM IS BEING REWRITTEN
                //AllocConsole() ; //U::DO THIS IFF PARAMETER IS SPECIFIED !console
            {
            if( idTypeP == ifcIDtYPEtLS_WINDOW )

            OStEXTcLEAR( _ostoTmp )
            osTextC _ostRangerTag( _ostoTmp.costF() + 1 , _ostoTmp , _statRangerTag , _statRangerTag.cbF() ) ;
            staticC _statRangerTag( tinP , "rangerTag" , "sys" , 2 * sizeof( countT ) + _ostoTmp.costF() + 1 , ifcIDtYPEsTATICC_FOOT ) ;
            OStEXTAK( _ostoTmp , "RangerTag:threadStack.tm1F.1" )
            OStEXTAK( _ostoTmp , "!ifc" )
            OStEXT(   _ostoTmp , 0x80 )

            etherC::paperZitsOffF( tinP ) ;

            if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
            tinP.flagsThreadMode2 |= flTHREADmODE2_ADAMmAINtHREAD ;
            const osTextT* ppostHow[ 0x10 ] ; //WILL BE FILLED WITH REFERENCES TO SNIPS IN postOldCopy; ppostHowP WILL BE SET TO ME, SO I MUST EXIST WHILE ppostHowP IS VISIBLE
            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN2 ) ;
        {
        thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_NORMAL ) ;

        }
            if( pRegs ) ;
            poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;

            homeS& home = homeS::homeIF() ;
        {

        //tinP.pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
        _IO_

        //}
        //    }
        //        poolt( tinP , pbt ) ;
        //        byteT* pbt = poolt.newF( tinP , LF , cbWant ) ;
        //
        //        while( cDo -- ) cbWant <<= 1 ;
        //        countT cDo = expCb ;
        //        countT cbWant = 1 ;
        //    {
        //    for( countT expCb = 0 ; expCb < 0x1e ; expCb ++ )
        //    p oolC poolt( tinP , TAG( TAGiDnULL ) , "test" , 0x10 ) ;
        //{
        //REMOVE THIS, OR MAKE IT A TESTER TO VERIFY THAT THIS MUCH MEMORY IS AVAILABLE

        cryC cry00( TOCK + 0x00 ) ;
        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 ) ;
    {
{
/*1*/countT adamMainF( tinS& tinP , const countT idTypeP , countT cHowP , const osTextT** ppostHowP , countT hWindowingClientIP , countT hPreviousWindowingClientP , const osTextT* postP , countT idCmdShowP )/*1*/

//U::#define ADAMpHASE(idPhaseP) if( thirdC::third_idPhaseAdam_IF( tinP ) < (idPhaseP) ) thirdC::third_idPhaseAdam_IF( tinP ) = (idPhaseP)

#define ADAMpHASE(idPhaseP) if( thirdC::third_idPhaseAdam_IF( tinP ) < (idPhaseP) ) { thirdC::third_idPhaseAdam_IF( tinP ) = (idPhaseP) ; /*CONoUTrAW3( "[idPhase]: " , idPhaseP , "\r\n" ) ;*/ }

//U::MOVE TO SYMPOL DEF FILE

/**/
*/
/*
                                                   
//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

