
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bQuit ;

    ether.delF( tinP , pstt1w ) ;
    }
        if( bQuit ) break ;

        //U:: BEFORE HERE
        //ether.beeClickF( tinP , TUCK * 0x18 ) ; //U::

        ppsttRawWord[ 0 ] = psttOldC( tinP , ether , tWord ) ; ___( ppsttRawWord[ 0 ] ) ;
        for( countT off = sizeof ppsttRawWord / sizeof ppsttRawWord[ 0 ] - 1 ; off ; off -- ) ppsttRawWord[ off ] = ppsttRawWord[ off - 1 ] ;
        ether.delF( tinP , ppsttRawWord[ sizeof ppsttRawWord / sizeof ppsttRawWord[ 0 ] - 1 ] ) ;
    
        else *paStack << (strokeS*)tWord << (countT)ifcIDcMDbASE_CMDdEFAULT << this ;
        else if( ether.strCompareF( tinP , T(paStack->postOldClassNameIF(tinP)) , T("soulC") ) || !( F(((soulC*)paStack)->flags) & flSOUL_LIVE ) ) *paStack << (strokeS*)tWord O(*this) ;
        }
            if( pObject ) *paStack << (countT)ifcIDcMDbASE_CMDdEFAULT << pObject ;
            baseSoilXxxxC* pObject = (baseSoilXxxxC*)(countT)sw_pObject ;
        {
        else if( sw_pObject.idSlotOfLeverF( tinP , (countT)postLever ) )
        }
            }
                }
                    //else { POPUPsOIXLoLD( T(postName)+T(" is a ")+T(psttOldClass)+T(" object.  \".@\" requires either a stack or a list object") ) ; }
                    /*if( !ether.strCompareF( tinP , psttOldClass , T("soulC") ) )*/ paStack = (soulC*)pObject ;
                    //U::TEST FOR CLASS NAME "soulC" HERE
                {
                if( pObject )
                baseSoilXxxxC* pObject = (baseSoilXxxxC*)(countT)sw_pObject ;
            {
            if( sw_pObject.idSlotOfLeverF( tinP , (countT)(osTextT*)tWord ) )
            bAt = 0 ;
        {
        else if( bAt )
        else if( !ether.strCompareF( tinP , tWord , T(".@") ) ) bAt = 1 ;
        else if( !ether.strCompareF( tinP , tWord , T(".0") ) ) bLiteralNull = 1 ;
        }
            }
                *paStack << psttz ;
                ZE( strokeS* , psttz ) ;
                bLiteralNull = 0 ;
            {
            else
            if( !bLiteralNull ) bLiteralStrokesAt = 1 ;
        {
        else if( !ether.strCompareF( tinP , tWord , T(".") ) )
        }
            *paStack << (osTextT*)tWord ;
            bLiteralBytesAt = 0 ;
        {
        else if( bLiteralBytesAt )
        }
            *paStack << (countT)ether.strDigitsToSCountF( tinP , tWord ) ;
            //ether.strokeF( tinP , T("pushing \"")+tWord+T("\" as a countT\r\n") ) ;
            bLiteralCount = 0 ;
            __( bLiteralNull ) ;
        {
        else if( bLiteralCount )
        }
            }
                ((strokeS*)tWord)[ 2 ].idAdam = save ;
                *paStack << (strokeS*)tWord ; //THIS WORKS BECAUSE soulC::shiftLeftF DOES NOT ACCESS THE CLAIMED EXTRA STROKES
                ((strokeS*)tWord)[ 2 ].idAdam = csttExtra ; csttExtra = 0 ;
                countT save = ((strokeS*)tWord)[ 2 ].idAdam ;
            {
            else
            if( !csttExtra ) *paStack << (strokeS*)tWord ; //U::BUG? ZOMBIE?: IS THIS PLATE GUARANTEED TO BE POPPED BEFORE tWord IS DT? (THIS IS DONE MULTIPLE PLACES IN THIS FILE)
            //ether.strokeF( tinP , T("pushing \"")+tWord+T("\" as a strokeS@\r\n") ) ;
            bLiteralStrokesAt = 0 ;
        {
        else if( bLiteralStrokesAt )
        else if( scOff ) { __( bLiteralNull ) ; }
        }
            __( bLiteralNull ) ;
            scOff -- ;
        {
        if( !ether.strCompareF( tinP , tWord , T(postName) ) && !ether.strCompareF( tinP , ppsttRawWord[ 0 ] , T("on") ) && !ether.strCompareF( tinP , ppsttRawWord[ 1 ] , T(".") ) )
        //ether.beeClickF( tinP , TUCK * 0x20 ) ; //U::
    
        postLever = tWord ;

        }
            }
                 idCaretLag = idCaret ;

                }
                    }
                        ether.delF( tinP , psttw ) ;
                        }
                            tWord += T("")+sttv ;
                            strokeS sttv( idAdam , idCaste ) ;
    
                            if( !idAdam ) idAdam = ether.strDigitsToSCountF( tinP , psttw ) ;
    
                            else                                                                                                       idAdam = processGlobal3I.mapAdam( T(psttw) ) ; //SYMBOL CAN OPTIONALLY BE USED TO SPECIFY IDaDAM
                            if( psttw->idAdam == 3 && psttw[ CSpREFIX ] == sttSingleQuote && psttw[ CSpREFIX + 2 ] == sttSingleQuote ) idAdam = psttw[ CSpREFIX + 1 ].idAdam ;
                            ZE( countT , idAdam ) ;
                            cSeen = 0 ;
                        {
                        else if( cSeen == 3 )
                        if( cSeen == 2 ) idCaste = processGlobal3I.mapCaste( T(psttw) ) ; //SYMBOL MUST BE USED TO SPECIFY CASTE
                        ether.strSubstringF( tinP , psttw , idf4 , idl4 , psttc1 ) ; ___( psttw ) ;
                        ZE( strokeS* , psttw ) ;
                        countT idl4 = idCaret - 1 ;
                        countT idf4 = idCaretLag + 1 ;
                    {
                    else
                    }
                        }
                            cSeen = 0 ;
                            tWord += tCaret ;
                        {
                        if( cSeen == 2 )
                    {
                    else if( idCaret == idCaretLag + 1 )
                    }
                        }
                            ether.delF( tinP , psttw ) ;
                            tWord += T(psttw) ;
                            ether.strSubstringF( tinP , psttw , idf3 , idl3 , psttc1 ) ; ___( psttw ) ;
                            ZE( strokeS* , psttw ) ;
                            countT idl3 = idCaret - 1 ;
                            countT idf3 = idfSave ;
                        {
                        if( idCaret > 1 )
                    {
                    if( !idCaretLag )
                    cSeen ++ ;
                {
                else
                }
                    }
                        ether.delF( tinP , psttw ) ;
                        tWord += T(psttw) ;
                        ether.strSubstringF( tinP , psttw , idf2 , idl2 , psttc1 ) ; ___( psttw ) ;
                        ZE( strokeS* , psttw ) ;
                        ZE( countT , idl2 ) ;
                        countT idf2 = idCaretLag + 1 ;
                    {
                    if( idCaretLag && idCaretLag < psttc1->idAdam )
                {
                if( !idCaret )

                if( idCaret ) ether.strokeF( tinP , T("caret found at position ")+TF2(idCaret,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
                countT idCaret = ether.strIdF( tinP , idf , sttq , sttCaret , psttc1 ) ;
                countT idfSave = idf ;
            {
            while( idf )
            ZE( countT , cSeen ) ; //NUMBER OF CARETS SEEN FOR CURRENT SNIP
            ZE( countT , idCaste ) ;
            ZE( countT , idCaretLag ) ;
            countT idf = 1 ;
            TN( tCaret , "^" ) ;
            strokeS sttSingleQuote( '\'' ) ;
            strokeS sttCaret( '^' ) ;
        {
        else
        if( !ether.strIdF( tinP , S1C('^') , psttc1 ) ) tWord = T(psttc1) ;
        TN( tWord , "" ) ;

        // }
        //     }
        //         ether.delF( tinP , psttd ) ;
        //         ether.strokeF( tinP , T(psttd)+T("\r\n") ) ;
        //         soulC::dumpIF( tinP , psttd , *paStack ) ; ___( psttd ) ;
        //         ZE( strokeS* , psttd ) ;
        //     {
        // 
        //     ether.strokeF( tinP , T("----pushing \"")+T(psttc1)+T("\"---- current stack is: \"")+T(paStack->postNameF(tinP))+T("\" containing ")+TF2(*paStack,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" items\r\n") ) ;
        // {
        // if( !scOff && !scQuiet )

        //U:: AFTER HERE
    {
    FORsTRINGSiN1( pstt1w )
    ether.strWordsOldF( tinP , pstt1w , T(psttP) , sttq ) ; ___( pstt1w ) ;
    strokeS sttq ;
    ZE( strokeS* , pstt1w ) ;

    TINSL
{
/*1*/boolT soixlOldSpaceC::operator <<( const strokeS* const psttP )/*1*/

/**/
*/
the primary interface to a soixlOldSpaceC object, just like any baseSoilXxxxC derived object, is operator ()
my purpose is to provide an ancillary text stream interface that understands human readable input
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

