
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmRelayInitiatorF )
tinP.idPhase2 = 0 ;
}
    }
        while( cTries -- && ( !bRoot || ( cGossipPopped == cGossipInP ) ) ) { ++ s ; ether.osSleepF( tinP , TUCK * 0x80 ) ; }
        //P: A ROOT RELAY WILL CONTINUE IMMEDIATELY TO NEXT CYCLE IF IT HAS RECEIVED NEW GOSSIP
        countT cTries = /*U:: TUCK / 0x10 */ 1 ; //U::TO FIND A BUG
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        TELL( "napping" )
        //CONoUTrAW( "tmRelayInitiatorF: 0 napping\r\n" ) ;

        }
            }
                etThread( tinP , psBag ) ;
                relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                relayC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flRELAYpOP_UP|flRELAYpOP_DOWN , ifcIDtYPEbAG_CLIENTnULL ) ;
            {
            if( psBag )
            etThread( tinP , psBag , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psBag ) ;
        { //THIS IS TO STIMULATE THE POP STACKS SO THAT THE POP CLIENTS WILL KEEP THEIR CONNECTIONS CURRENT
        //CONoUTrAW( "tmRelayInitiatorF: 1 pop a null bag\r\n" ) ;

        }
            soul.removeAllF( tinP ) ;
            relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , soul , stIdptOpenP , stIdptGossipP , idptP ) ;
            cPops ++ ;
            static countT cPops ; //U::CONJ: NEEDS TO BE VISIBLE TO SOME OTHER SNIPPET
        {
        if( soul ) //U::CONJ: BUG: IS USING operator byteT*
        //CONoUTrAW( "tmRelayInitiatorF: 2 pop the soul\r\n" ) ;

        if( bHelloHandle ) relayC::helloToHandleIF( tinP , idptP , idSerialLathHeaderP ) ;

        }
            countT foo = 2 ;
        {
        if( ++ cHere == 4 )
        static countT cHere ;
        //U::
        //CONoUTrAW( "tmRelayInitiatorF: 3 say hello to handle\r\n" ) ;

        }
            idptHandleLag = idptHandleCopy ;
            if( idptHandleCopy && idptHandleCopy != idptHandleLag && idptHandleCopy != idptP ) bHelloHandle = 1 ; //P: ALL RELAYS SAY HELLO TO A NEW HANDLE RELAY
            idPortTimeC idptHandleCopy = relayC::handleQueryIF( tinP ) ;
        {
        //CONoUTrAW( "tmRelayInitiatorF: 4 set bHelloHandle\r\n" ) ;

        }
            swsIdptMediatorP.ungrabF( tinP ) ;
            swsIdptMediatorAltP.ungrabF( tinP ) ;

            THREADmODE1rESTORE
            swsIdptMediatorP.freeAllF( tinP ) ;

            }
                }
                    while( !stIdptOpenP.third && ~hDown ) ;
                    }
                        swsIdptMediatorP.extractF( 0 , tinP ) ;
                        swsIdptMediatorAltP.sinkF( tinP , countTC() , (byteT*)&idptm , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                        idPortTimeC& idptm = *(idPortTimeC*)&swsIdptMediatorP.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    //etThread.strokeF( tinP , T("pouring ")+TF1(swsIdptMediatorP)+T(" registered mediator cells of adam ")+TF1(idAdamMediatorP)+T("\r\n") ) ;
                {
                if( swsIdptMediatorP )
                idAdamMediatorP = swsIdptMediatorP.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swsIdptMediatorP.cFlavorsF( tinP ) ;

            swsIdptMediatorAltP.freeAllF( tinP ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            swsIdptMediatorAltP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            swsIdptMediatorP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( !( idCycle % 0x8 ) ) //02->001
        //CONoUTrAW( "tmRelayInitiatorF: 5 pour mediator list\r\n" ) ;

        relayC::handleRegisterMeIfIF( tinP , idptP ) ; //P: A RELAY WILL GRAB A HANDLE VACANCY
        UNGRABrELAYlISTS
        //CONoUTrAW( "tmRelayInitiatorF: 6 register myself as handle\r\n" ) ;

        //THREADmODE1rESTORE
        //}
        //    while( !stIdptPopClientP.third && ~hDown ) ;
        //    }
        //        //etThread.strokeF( tinP , T(nn)+tcol+T(idPort)+tcol+TT(tt.time1,tt.time2)+T(!hDown?"\r\n":" , ") ) ;
        //        const timeS&    tt     = idpt ;
        //        const nicNameC& nn     = (const nicNameC&)(const idPortC&)idpt ;
        //        countT          idPort = idpt ;
        //        idPortTimeC& idpt = *(idPortTimeC*)&stIdptOpenP.downF( tinP , hDown ) ;
        //    {
        //    do
        //    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        //    TN( tcol , ":" ) ;
        //{
        //if( stIdptOpenP )
        //THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        //CHATTER MY OPEN LIST

        }
            }
                bHelloHandle = 1 ; //P: A NONROOT RELAY THAT HAS NOT RECEIVED A PING LATELY WILL SAY HELLO TO HANDLE

                stIdptOpenP.extractF( 0 , tinP ) ;
                cLooksForNewPingP = 0 ;
            {
            else if( incv02AM( cLooksForNewPingP ) > 4 )
            }
                relayC::myListIF( tinP , soul , stIdptOpenP ) ;
                relayC::myListIF( tinP , soul , stIdptGossipP ) ;
                relayC::hdrBagIF( tinP , soul , idptP , idSerialLathHeaderP , flRELAYpOP_UP , ifcIDtYPEbAG_CLIENTpOPpING ) ;
                //etThread.traceF( tinP , T("loading ifcIDtYPEbAG_CLIENTpOPpING bag [cNodesOpen,cNodesGossip]:    ")+TF2(stIdptOpenP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(stIdptGossipP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                }
                    THREADmODE1rESTORE
                    while( !stIdptGossipP.third && ~hDown ) ;
                    }
                        }
                            relayC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                            if( stIdptGossipP( (byteT*)&idptTest , subtractIdPortsF  , - 1                    ) ) stIdptGossipP.extractF( 0 , tinP ) ;
                            if( stIdptOpenP(   (byteT*)&idptTest , subtractIdPortTimesF , (countT)&stIdptGossipP ) ) stIdptOpenP.extractF(   0 , tinP ) ;
                        {
                        if( !relayC::testIF( tinP , idptP , idSerialLathHeaderP , idptTest ) )
                        idPortTimeC& idptTest = *(idPortTimeC*)&stIdptGossipP.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                {
                if( stIdptGossipP )
                //P: A RELAY THAT THINKS THAT IT IS ROOT WILL TEST ALL GOSSIPPED RELAYS AND DELIST THOSE THAT FAIL
                //TEST ALL GOSSIPPED RELAYS

                }
                    relayC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                    if( stIdptGossipP( (byteT*)&idptAbsent5 , subtractIdPortsF  , - 1                    ) ) stIdptGossipP.extractF( 0 , tinP ) ;
                    if( stIdptOpenP(   (byteT*)&idptAbsent5 , subtractIdPortTimesF , (countT)&stIdptGossipP ) ) stIdptOpenP.extractF(   0 , tinP ) ;
                    //P: A RELAY THAT THINKS IT IS ROOT WILL DELIST AN ABSENT RELAY THAT IT EXPECTS TO BE AT ITS LEFT
                {
                if( idptAbsent5 )
                cGossipPopped = cGossipInP ;
                bRoot = 1 ;
                if( !( idCycle % 0x4 ) ) bHelloHandle = 1 ; //P: EVERY RELAY THAT THINKS THAT IT IS ROOT ALWAYS SAYS HELLO TO HANDLE
                //U: I DO NOT KNOW WHY THIS CAUSES CYCLING IF DONE EVERY CYCLE

                }
                    if( idpth && !relayC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idpth ) ) stIdptOpenP.sinkF( tinP , countTC() , (byteT*)&idpth , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ; //P: A ROOT RELAY ALWAYS KNOWS ABOUT A HANDLE RELAY
                    idPortTimeC idpth = relayC::handleQueryIF( tinP ) ;
                {
            {
            if( *pnRoot == idptP )

            bReadyP = 1 ;
            )
                ( ( *pnRoot != idptP ) || idCycle >= 0x1/*U::0x10*/ )
                &&
                ( !idptAbsent1 && !idptAbsent2 && !idptAbsent3 && !idptAbsent4 && !idptAbsent5 )
                &&
                bRollTaken
                &&
                !bReadyP
            (
            if
        {
        if( pnRoot )
        idPortTimeC* pnRoot = stIdptOpenP ? (idPortTimeC*)&stIdptOpenP[ 1 ] : 0 ;
        GRABrELAYlISTS
        ZE( countT , cGossipPopped ) ;
        ZE( boolT , bRoot ) ;
        //CONoUTrAW( "tmRelayInitiatorF: 7 root work\r\n" ) ;

        }
            }
                bHelloHandle = 1 ; //P: RELAY SAYS HELLO TO HANDLE WHENEVER WO OR MORE EXPECTED CLIENTS ARE ABSENT
            {
            if( idptAbsent1 || idptAbsent2 || idptAbsent3 || idptAbsent4 || idptAbsent5 )
    
            POURaBSENTrELAY( 5 )
            POURaBSENTrELAY( 4 )
            POURaBSENTrELAY( 3 )
            POURaBSENTrELAY( 2 )
            POURaBSENTrELAY( 1 )
    
            GOSSIPaBSENTrELAY( 5 )
            GOSSIPaBSENTrELAY( 4 )
            GOSSIPaBSENTrELAY( 3 )
            GOSSIPaBSENTrELAY( 2 )
            GOSSIPaBSENTrELAY( 1 )
    
            }
                }
                    while( !stIdptPopClientP.third && ~hDown ) ;
                    }
                        if( stRelayAbsent5( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent5.extractF( 0 , tinP ) ;
                        if( stRelayAbsent4( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent4.extractF( 0 , tinP ) ;
                        if( stRelayAbsent3( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent3.extractF( 0 , tinP ) ;
                        if( stRelayAbsent2( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent2.extractF( 0 , tinP ) ;
                        if( stRelayAbsent1( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent1.extractF( 0 , tinP ) ;
                        idPortTimeC& idpt = *(idPortTimeC*)&stIdptPopClientP.downF( tinP , hDown ) ;
                        //U: ISSUE: A CLIENT IS NOT REALLY ABSENT AS RIGHT IF IT IS PRESENT AS DOWN
                        //U: COUNT THE CLIENT AS PRESENT HERE ONLY IF THE CLIENT AGREES ABOUT THE TYPE OF WORK IT IS DOING
                        //P: RELAY WILL COUNT A CLIENT AS "PRESENT" EVEN IF THE CLIENT DISAGREES ABOUT THE TYPE OF WORK IT IS CONNECTED TO DO
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stIdptPopClientP )
            {
            relayC::idPortTimeClientsExpectedIF( tinP , stRelayAbsent5 , stIdptOpenP , stIdptGossipP , idptP , IDtYPErELAYpOPcLIENTwORK_RIGHT    ) ;
            relayC::idPortTimeClientsExpectedIF( tinP , stRelayAbsent4 , stIdptOpenP , stIdptGossipP , idptP , IDtYPErELAYpOPcLIENTwORK_LEFT     ) ;
            relayC::idPortTimeClientsExpectedIF( tinP , stRelayAbsent3 , stIdptOpenP , stIdptGossipP , idptP , IDtYPErELAYpOPcLIENTwORK_EXPLODE2 ) ;
            relayC::idPortTimeClientsExpectedIF( tinP , stRelayAbsent2 , stIdptOpenP , stIdptGossipP , idptP , IDtYPErELAYpOPcLIENTwORK_EXPLODE1 ) ;
            relayC::idPortTimeClientsExpectedIF( tinP , stRelayAbsent1 , stIdptOpenP , stIdptGossipP , idptP , IDtYPErELAYpOPcLIENTwORK_IMPLODE  ) ;
            stRelayAbsent5.purgeF( tinP ) ;
            stRelayAbsent4.purgeF( tinP ) ;
            stRelayAbsent3.purgeF( tinP ) ;
            stRelayAbsent2.purgeF( tinP ) ;
            stRelayAbsent1.purgeF( tinP ) ;
            bRollTaken = 1 ;
        {
        if( !( ++ idCycle % 0x2 ) )
        ZE( boolT , bHelloHandle ) ;
        idPortTimeC idptAbsent5 ;
        idPortTimeC idptAbsent4 ;
        idPortTimeC idptAbsent3 ;
        idPortTimeC idptAbsent2 ;
        idPortTimeC idptAbsent1 ;
        ZE( boolT , bRollTaken ) ;
        //CONoUTrAW( "tmRelayInitiatorF: 8 look for absentees\r\n" ) ;
    {
    while( !etThread && !stIdptOpenP.third && !ether && !bQuitP )
    idPortTimeC idptHandleLag ;
    ZE( countT , idCycle ) ;
    stackC stIdMe( tinP , etThread , TAG( TAGiDnULL ) ) ;
    stackC stRelayAbsent5Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent4Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent3Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent2Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent1Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent5( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent4( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent3( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    stackC stRelayAbsent1( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( idPortTimeC ) ) ;
    soulC soul( tinP , TAG( TAGiDnULL ) ) ;

    boolT&    bReadyP           =     *(boolT*)pTaskP->c6 ;
    countT&   cLooksForNewPingP =    *(countT*)pTaskP->c5 ;
    stackC&   stIdptPopClientP  =    *(stackC*)pTaskP->c4 ;
    RELAYiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
tinP.idPhase2 = 1 ;
/*1*/TASK( tmRelayInitiatorF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

