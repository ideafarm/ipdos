
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    {for( countT off = 0 ; off < sizeof ppsttHOD / sizeof ppsttHOD[ 0 ] ; off ++ ) delF( tinP , ppsttHOD[ off ] ) ;}
    {for( countT off = 0 ; off < sizeof ppsttTOH / sizeof ppsttTOH[ 0 ] ; off ++ ) delF( tinP , ppsttTOH[ off ] ) ;}

    }
        strFuseF( tinP , psttP , T("\r\n") ) ; ___( psttP ) ;
        }
            strFuseF( tinP , psttP , TP("",cPadL)+T(ppsttTOH[off])+TP("",cPadR) ) ; ___( psttP ) ;
        {
        for( countT off = 0 ; off < sizeof ppsttTOH / sizeof ppsttTOH[ 0 ] ; off ++ )
        strFuseF( tinP , psttP , T(" ") ) ; ___( psttP ) ;

        countT cPadR = cPad - cPadL ;
        countT cPadL = cPad / 2 ;
        countT cPad = cColP - 5 ;
    {

    }
        }
            else                             { strFuseF( tinP , psttP , T("+\r\n") ) ; ___( psttP ) ; }
            else if( oScan % cRowP )         { strFuseF( tinP , psttP , T("|\r\n") ) ; ___( psttP ) ; }
            if( oScan % cRowP == cRowP / 2 ) { strFuseF( tinP , psttP , T("| ")+TP(ppsttHOD[oScan/cRowP],0x10)+T("\r\n") ) ; ___( psttP ) ; }
        {
        else
        }
            else                             { strFuseF( tinP , psttP , T("@\r\n") ) ; ___( psttP ) ; }
            else if( oScan % cRowP )         { strFuseF( tinP , psttP , T("|\r\n") ) ; ___( psttP ) ; }
            if( oScan % cRowP == cRowP / 2 ) { strFuseF( tinP , psttP , T("| ")+TP(ppsttHOD[oScan/cRowP],0x10)+T("\r\n") ) ; ___( psttP ) ; }
        {
        else if( oScan / cRowP == oHourNow + 1 && oTickNow % 0x10 == 0xf )
        }
            else                             { strFuseF( tinP , psttP , T("@\r\n") ) ; ___( psttP ) ; }
            else if( oScan % cRowP )         { strFuseF( tinP , psttP , T("@\r\n") ) ; ___( psttP ) ; }
            if( oScan % cRowP == cRowP / 2 ) { strFuseF( tinP , psttP , T("@ ")+TP(ppsttHOD[oScan/cRowP],0x10)+T("\r\n") ) ; ___( psttP ) ; }
        {
        if( oScan / cRowP == oHourNow && oTickNow % 0x10 == 0xf )

        }
            cellScanClockF( tinP , *this , psttP , oScan % cRowP , od , oTickNow , cColP ) ;

            countT od = ( oScan / cRowP ) * 0x10 + oCol ;
        {
        for( countT oCol = 0 ; oCol < 0x10 ; oCol ++ )
    {
    for( sCountT oScan = cScan ; oScan >= 0 ; oScan -- )
    countT cScan = cRowP * 0x10 ;

    { ZE( sCountT , time2 ) ; strFuseF( tinP , psttP , TT(time1P,time2)+T("\r\n") ) ; ___( psttP ) ; }

    strMakeF( tinP , LF , ppsttTOH[ 0xf ] , T("fa'ti") ) ; ___( ppsttTOH[ 0xf ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0xe ] , T("ee'ti") ) ; ___( ppsttTOH[ 0xe ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0xd ] , T("de'ti") ) ; ___( ppsttTOH[ 0xd ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0xc ] , T("ce'ti") ) ; ___( ppsttTOH[ 0xc ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0xb ] , T("be'ti") ) ; ___( ppsttTOH[ 0xb ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0xa ] , T("ay'ti") ) ; ___( ppsttTOH[ 0xa ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x9 ] , T("ni'ti") ) ; ___( ppsttTOH[ 0x9 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x8 ] , T("ta'ti") ) ; ___( ppsttTOH[ 0x8 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x7 ] , T("ta'ti") ) ; ___( ppsttTOH[ 0x7 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x6 ] , T("ve'ti") ) ; ___( ppsttTOH[ 0x6 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x5 ] , T("se'ti") ) ; ___( ppsttTOH[ 0x5 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x4 ] , T("fi'ti") ) ; ___( ppsttTOH[ 0x4 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x3 ] , T("fo'ti") ) ; ___( ppsttTOH[ 0x3 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x2 ] , T("re'ti") ) ; ___( ppsttTOH[ 0x2 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x1 ] , T("oo'ti") ) ; ___( ppsttTOH[ 0x1 ] ) ;
    strMakeF( tinP , LF , ppsttTOH[ 0x0 ] , T("wo'ti") ) ; ___( ppsttTOH[ 0x0 ] ) ;
    {for( countT off = 0 ; off < sizeof ppsttTOH / sizeof ppsttTOH[ 0 ] ; off ++ ) ppsttTOH[ off ] = 0 ;}
    strokeS* ppsttTOH[ 0x10 ] ;

    strMakeF( tinP , LF , ppsttHOD[ 0xf ] , T("fa'ho") ) ; ___( ppsttHOD[ 0xf ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0xe ] , T("ee'ho") ) ; ___( ppsttHOD[ 0xe ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0xd ] , T("de'ho") ) ; ___( ppsttHOD[ 0xd ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0xc ] , T("ce'ho") ) ; ___( ppsttHOD[ 0xc ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0xb ] , T("be'ho") ) ; ___( ppsttHOD[ 0xb ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0xa ] , T("ay'ho") ) ; ___( ppsttHOD[ 0xa ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x9 ] , T("ni'ho") ) ; ___( ppsttHOD[ 0x9 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x8 ] , T("ta'ho") ) ; ___( ppsttHOD[ 0x8 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x7 ] , T("ta'ho") ) ; ___( ppsttHOD[ 0x7 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x6 ] , T("ve'ho") ) ; ___( ppsttHOD[ 0x6 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x5 ] , T("se'ho") ) ; ___( ppsttHOD[ 0x5 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x4 ] , T("fi'ho") ) ; ___( ppsttHOD[ 0x4 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x3 ] , T("fo'ho") ) ; ___( ppsttHOD[ 0x3 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x2 ] , T("re'ho") ) ; ___( ppsttHOD[ 0x2 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x1 ] , T("oo'ho") ) ; ___( ppsttHOD[ 0x1 ] ) ;
    strMakeF( tinP , LF , ppsttHOD[ 0x0 ] , T("wo'ho") ) ; ___( ppsttHOD[ 0x0 ] ) ;
    {for( countT off = 0 ; off < sizeof ppsttHOD / sizeof ppsttHOD[ 0 ] ; off ++ ) ppsttHOD[ off ] = 0 ;}
    strokeS* ppsttHOD[ 0x10 ] ;

    countT oHourNow = offHOUR( time1P ) ;
    countT oTickNow  = offTICK( time1P ) ;

    }
        strFuseF( tinP , psttP , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ csttEstimate + csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;
        countT csttEstimate = 0x10000 + ( cColP * 8 + 3 ) * ( cRowP * 8 + 3 ) + 3 * 0x10 * cRowP + 0x11 * 0x10 ;
    {
    if( !psttP )

    _IO_

    }
        if( POOP ) return ;
        __( cRowP < 2 ) ;
        __( cColP < 5 ) ;
        __( csttExtraP && psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::strClockOldF( tinS& tinP , strokeS*& psttP , const countT time1P , const countT cColP , const countT cRowP , const countT csttExtraP )/*1*/

/**/
*/
  must be 0 if psttP is not null
  is used when psttP is null
 csttExtraP
  must be at least 2
 cRowP
  must be at least 6 to look good
  must be at least 5
 cColP
  the time of day to highlight on the clock
 time1P
  if not null then must contain enough extra strokes to completely hold the clock
  if null then will be allocated
  can be null
 psttP
 tinP
arguments
  \<A HREF=\"5.8b30104.1.1.0.html\"\>8b30104:  WAKEsHOW( "example.simplest.func.1030118.etherC.strClockOldF" )\</A\>
 simplest
examples
\<A HREF=\"5.1030118.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strClockOldF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

