
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    walkF( tinP , slotsWalkTraceCBF , countTC() ) ;
    _IO_

    }
        if( POOP ) return ;
        __Z( tinP.pEther ) ; // *tinP.pEther RATHER THAN A  etherC& PARAMETER IS USED SO THAT IN THE FUTURE I CAN DO SOMETHING USEFUL WHEN NO INSTANCE OF etherC EXISTS
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT poolC::reportF( tinS& tinP )/*1*/

}
    }
        }
            }
                }
                    }
                        tinP.pEther->delF( tinP , psttg ) ;
                        etherC::etRockIF( tinP ).traceF( tinP , !tDump.csF( tinP ) ? psttg : (strokeS*)( T(psttg)+tDump ) ) ;
                        pn->glassF( tinP , psttg ) ; ___( psttg ) ;
                        ZE( strokeS* , psttg ) ;

                        }
                            }
                                else psttc += CSpREFIX ;
                                }
                                    psttc += CSpREFIX + psttc->idAdam ;

                                    tinP.pEther->delF( tinP , psttd ) ;
                                    tDump += tq+T(psttd)+tq ;
                                    if( tDump.csF( tinP ) ) tDump += tb4 ;

                                    }
                                        tinP.pEther->delF( tinP , psttDoomed ) ;
                                        tinP.pEther->strSubstringF( tinP , psttd , idf , idl , psttDoomed ) ; ___( psttd ) ;
                                        countT idl = TOCK ;
                                        countT idf = 1 ;
                                        strokeS* psttDoomed = psttd ; psttd = 0 ;
                                    {
                                    if( psttd->idAdam > TOCK )

                                    tinP.pEther->strReplaceAnyF( tinP , psttd , psttc , T(TbLACK) , T(" ") ) ; ___( psttd ) ;
                                    ZE( strokeS* , psttd ) ;
                                {
                                else if( psttc->idAdam )
                                }
                                    continue ;
                                    psttc += CSpREFIX ;
                                {
                                if( psttc->idAdam >= CSpREFIX && psttc[ CSpREFIX ].idCaste == sc_PREFIXlENGTH )

                                if( psttc->idCaste != sc_PREFIXlENGTH ) break ;
                            {
                            while( psttc < pstte )
                            //DISPLAY EACH STRING IN A STRING OF STRINGS WITH ARBITRARY NONUNIFORM NESTING

                            strokeS* pstte = psttRaw + CSpREFIX + psttRaw->idAdam ;
                            strokeS* psttc = psttRaw ;
                            strokeS* psttRaw = (strokeS*)( pbDataP + cbSlot * offb ) ;
                            countT cbSlot = 1 << pHeadP->expCbDrop ;
                        {
                        if( pn->idType == ifciDtYPEdROPnOTE_strokeS )
                        TN( tq , "\"" ) ;
                        TN( tb4 , "    " ) ;
                        TN( tDump , "" ) ;

                        const dropNoteS* pn = pNotesP + offb ;
                    {
                    //if( pbBitsOwnedP[ offByte ] >> offBit & 1 )

                    countT offBit  = offb % SB ;
                    countT offByte = offb / SB ;
                {
                for( countT offb = 0 ; offb < cBits ; offb ++ )
            {
            //if( cFound )

            }
                if( pbBitsOwnedP[ offByte ] >> offBit & 1 ) cFound ++ ;

                countT offBit  = offb % SB ;
                countT offByte = offb / SB ;
            {
            for( countT offb = 0 ; offb < cBits ; offb ++ )
            ZE( countT , cFound ) ;
            countT cBits = 1 << pHeadP->expSlots ;
        {
        if( pNotesP )

        }
            tinP.pEther->delF( tinP , psttg ) ;
            etherC::etRockIF( tinP ).traceF( tinP , psttg ) ;
            pHeadP->glassF( tinP , psttg ) ; ___( psttg ) ;
            ZE( strokeS* , psttg ) ;
        {
        if( pHeadP )
    {
    if( tinP.pEther )
{
voidT slotsWalkTraceCBF( tinS& tinP , countT& cArgP , const sexHeadS* pHeadP , const byteT* pbBitsOwnedP , const dropNoteS* pNotesP , const byteT* pbDataP )

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

