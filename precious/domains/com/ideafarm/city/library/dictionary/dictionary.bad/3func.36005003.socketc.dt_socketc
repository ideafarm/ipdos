
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
    
        if( pMapPortBind ) pMapPortBind->idPortSpecified = pMapPortBind->idPortActual = 0 ;
    
        *pEther = ecSave ;
    
        pEther->delF( tinP , psttPemPrivateKey   ) ;
        pEther->delF( tinP , psttPemCertificates ) ;

        }
            }
                pEther->delF( tinP , *pppczKTS[ off ] ) ;
                }
                    }
                        if( POOP ) POOPR
                        tinP.pEtScratch->boxZapF( tinP , tLong , 1 ) ;
                        SCOOPS
                    {
                    IFsCRATCH
            
                    TN( tLong , "" ) ; tLong = T("///desk/" POSTfOLDERsECURITYkEYdEPOSITORY)+(idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/")+tShort ;
                    textC tShort( tinP , TAG( TAGiDnULL ) , flTEXTc_null , *pppczKTS[ off ] , flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE , 8 , 0 , tDot ) ;
                    TN( tDot , "." ) ;
                {                                      //U::ALT: SET A FLAG TO REMEMBER THAT PEER'S KEY ALREADY EXISTED, SO DON'T DELETE IT
                if( /*off == 0 &&*/ *pppczKTS[ off ] ) //U::DELETE MY COPY OF THE PEER'S KEY IFF IT DID NOT OVERWRITE EXISTING COPY
            {
            for( countT off = 0 ; off < 2 ; off ++ )
            countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;
    
            countT** pppczKTS[] = { &pczKeyTopSecret , &pczKeyTopSecretPeer } ;
        {
    
        if( !( F(flags) & flSOCKETc_LEAVEsOCKEToPENwHENdIE ) && ~handle ) handle.closeIfF() ;
    
        bRead.ungrabF( tinP ) ;
        }
            etherC::sockStkIdleTimeoutersF( tinP ).ungrabF( tinP ) ;
            else                                                     __1
            if( etherC::sockStkIdleTimeoutersF( tinP )( (countT)this ) ) etherC::sockStkIdleTimeoutersF( tinP ).extractF( tinP ) ;
            etherC::sockStkIdleTimeoutersF( tinP ).grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( !( F(flags) & flSOCKETc_DOnOTrEGISTERtIMEoUT ) )
    
        }
            etherC::sockStkAcceptorsF( tinP ).ungrabF( tinP ) ;
            else                                                     __1
            if( etherC::sockStkAcceptorsF( tinP )( (countT)this ) ) etherC::sockStkAcceptorsF( tinP ).extractF( tinP ) ;
            etherC::sockStkAcceptorsF( tinP ).grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( bAcceptor && !( F(flags) & flSOCKETc_DOnOTrEGISTERaCCEPTOR ) )
    
        }
            etherC::sockStkQuittersF( tinP ).ungrabF( tinP ) ;
            else if( !fListening )                                 __1
            if( etherC::sockStkQuittersF( tinP )( (countT)this ) ) etherC::sockStkQuittersF( tinP ).extractF( tinP ) ;
            etherC::sockStkQuittersF( tinP ).grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( idType != ifcSOCKETtYPE_DATAgRAM && !( F(flags) & flSOCKETc_DOnOTrEGISTERqUITTER ) )
    
        }
            etherC::sockStkCatchersF( tinP ).ungrabF( tinP ) ;
            else                                                   __1
            if( etherC::sockStkCatchersF( tinP )( (countT)this ) ) etherC::sockStkCatchersF( tinP ).extractF( tinP ) ;
            etherC::sockStkCatchersF( tinP ).grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( bCatcher && !( F(flags) & flSOCKETc_DOnOTrEGISTERcATCHER ) )
    
        *pEther = 0 ;
        const countT ecSave = *pEther ;
    
        pEther->delF( tinP , psttName ) ;
    
        bRead.grabF( tinP , TAG( TAGiDnULL ) ) ;

        tinP.pAdamGlobal3->_socketC_.grab.ungrabF( tinP ) ;
        }
            DEL( tinP.pAdamGlobal3->_socketC_.pSwOdometer ) ;
    
            }
                //if( tinP.pc Utility[ 0 ] ) { LOGrAW( TD("socketC::~socketC/odometer/")+TF3(pOdometer->cbRead,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+T(" ")+TF3(pOdometer->cbWrite,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+T(tinP.pAdamGlobal3->_socketC_.nnLever)+T("\r\n") ) ; }
                pOdometer = (sockOdometerS*)&(countT&)*tinP.pAdamGlobal3->_socketC_.pSwOdometer ;
                tinP.pAdamGlobal3->_socketC_.nnLever = *(nicNameC*)tinP.pAdamGlobal3->_socketC_.pSwOdometer->leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = tinP.pAdamGlobal3->_socketC_.pSwOdometer->cFlavorsF( tinP ) ;
    
            if( !tinP.pAdamGlobal3->_socketC_.pSwOdometer ) { BLAMMO ; }
        {
        if( 1 == decv02AM( tinP.pAdamGlobal3->_socketC_.cRef ) )
        tinP.pAdamGlobal3->_socketC_.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        }
            THREADmODE1rESTORE
            }
                ++ s ; thirdC::dosSleepWinkIF( tinP ) ;
            {
            while( cFunctionsPending > 1 )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        {
    
        SCOOPP
    
        _IO_
        TINSL
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/socketC::~socketC( voidT )/*1*/

/**/
*/
 this is to avoid having an invalid pointer exist
i will deregister myself from stAcceptors even if i am impotent
 i do not refer to bRead or bWrite before closing the socket
i can be called while another thread is blocked on a read or a write
  \<A HREF=\"5.5420104.1.1.0.html\"\>5420104:  WAKEsHOW( "example.simplest.func.1070003.socketC.dt_socketC" )\</A\>
 simplest
examples
\<A HREF=\"5.1070003.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

