
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmRelayPopClientF )
}
    }
        POOPR
        etThread.traceF( tinP , T("probable coding error: still impotent 1") ) ;
    {
    if( POOP )

    }
        TELL( "tmRelayPopClientF: cleaning up" )
    
        DEL( pso ) ;
        }
            POOPR
            etThread.traceF( tinP , T("probable coding error: still impotent 2") ) ;
        {
        if( POOP )

        }
            }
                etThread( tinP , psBag ) ;
                TELL( "recycling soul" )
                }
                    }
                        }
                            break ;
                            etThread( tinP , psBag ) ;
                            bMoreToPop = 1 ;
                            idptServer = 0 ;
                            DEL( pso ) ;
                            }
                                psBag = 0 ;
                                stPop.insertF( tinP , (countT)psBag , ifcSTACKtYPE_PTR_soulC , 1 ) ;
                            {
                            if( !ether && !bQuitP )
                            etThread.traceF( tinP , T("could not write bag") ) ;
                            POOPRqUIET
                        {
                        if( POOP )
                        TELL( "reading ok-" )
                        VERIFYrELAY( *pso ) ;
                        TELL( "reading ok+ 5" )
                        pso->writeF( tinP , *psBag ) ;
                        TELL( "writing bang" )
                        //etThread.traceF( tinP , TF2(idWorkP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": writing [idType]:    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( idType != ifcIDtYPEbAG_CLIENTnULL )
                    countT idType = psBag->cFieldF( tinP , ifcIDfIELDbAG_IDtYPE ) ;
                {
                if( pso && !ether && !bQuitP && *psBag >= 4 ) //CODEsYNC df40104 df40104
                //P: CLIENTS THAT ARE QUITTING SILENTLY DISCARD ITEMS THAT THEY ARE SUPPOSE TO POP
                stPop >> psBag ;
                ZE( soulC* , psBag ) ;
                TELL( "pulling from stPop" )
            {
            while( stPop )
            //etThread.traceF( tinP , TF2(idWorkP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": writing from stPop [stPop]:    ")+TF2(stPop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            
            }
                if( !ether && !bQuitP ) relayC::idptServerIF( tinP , idptServerCorrect , stIdptOpenP , idptP , stIdptGossipP , idWorkP ) ;
                idptServerCorrect = 0 ;
                }
                    }
                        etThread.traceF( tinP , T("could not say hello to correct client") ) ;
                        idptServer = 0 ;
                        DEL( pso ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    TELL( "reading ok-" )
                    VERIFYrELAY( *pso ) ;
                    TELL( "reading ok+ 3" )
                    pso->writeF( tinP , sBagHello ) ;
                    //etThread.traceF( tinP , T("writing sBagHello") ) ;
    
                    sBagHello << idWorkP ;
                    relayC::hdrBagIF( tinP , sBagHello , idptP , idSerialLathHeaderP , flRELAYpOP_null , ifcIDtYPEbAG_CLIENTpOPhELLO ) ;
                    soulC sBagHello( tinP , TAG( TAGiDnULL ) ) ;
                    TELL( "writing hello" )
                {
                else
                }
                    idptServer = 0 ;
                    etThread.traceF( tinP , T("could not connect to correct client") ) ;
                    DEL( pso ) ;
                    POOPRqUIET
                {
                else if( POOP )
                }
                    idptServer = 0 ;
                    }
                        etThread.traceF( tinP , T("quitting, so am not going to connect to correct client") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    DEL( pso ) ;
                    //P: CLIENTS THAT ARE QUITTING ARE RUDE WHEN CLOSING CONNECTION
                {
                if( ether || bQuitP )
                pso->connectF( tinP , idptServer , (nicNameC&)idptServer ) ;
                TELL( "connecting" )
                idptServer = idptServerCorrect ;
                pso = new( 0 , tinP , LF ) socketC( tinP , *tinP.pEtScratch , TAG( TAGiDnULL )/*U:: , 0 , flSOCKETc_TOPsECRET*/ ) ; ___( pso ) ;
                TELL( "looping to write hello" )
            {
            while( !ether && !bQuitP && !pso && idptServerCorrect )
            
            }
                idptServer = 0 ;
                DEL( pso ) ;
                }
                    etThread.traceF( tinP , T("could not say bye to stale (incorrect) client") ) ;
                    POOPRqUIET
                {
                if( POOP )
                TELL( "reading ok-" )
                VERIFYrELAY( *pso ) ;
                TELL( "reading ok+ 2" )
                }
                    }
                        etThread( tinP , psBag ) ;
                        pso->writeF( tinP , *psBag ) ;
                        //etThread.traceF( tinP , T("writing *psBag") ) ;
                        relayC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flRELAYpOP_null , ifcIDtYPEbAG_CLIENTpOPbYE ) ;
                    {
                    if( psBag )
                    etThread( tinP , psBag , TAG( TAGiDnULL ) ) ;
                    ZE( soulC* , psBag ) ;
                {
                TELL( "writing bye" )
                //P: CLIENTS THAT ARE NOT QUITTING ARE POLITE WHEN CLOSING CONNECTION
            {
            if( pso && idptServer && idptServer != idptServerCorrect && !bQuitP && !ether )
    
            relayC::idptServerIF( tinP , idptServerCorrect , stIdptOpenP , idptP , stIdptGossipP , idWorkP ) ;
            idPortTimeC idptServerCorrect ;
            TELL( "calculating idPortTimeCorrect" )

            }
                //etThread.traceF( tinP , TF2(idWorkP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": waited  for a push") ) ;
                stPop.waitF( tinP ) ;
                //etThread.traceF( tinP , TF2(idWorkP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": waiting for a push") ) ;
            {    
            else
            else if( bMoreToPop ) bMoreToPop = 0 ;
            if( bWoth )           bWoth = 0 ;
            TELL( " waiting for a push onto stPop" )
        {
        while( !ether && !bQuitP )
        ZE( boolT , bMoreToPop ) ;
        idPortTimeC idptServer ;
        ZE( socketC* , pso ) ;
        boolT bWoth = 1 ;
        soulC sInOk( tinP , TAG( TAGiDnULL ) ) ;
    
        SCOOPS
    {
    IFsCRATCH


    ;
                    : *pStPop4P
                    ? *pStPop3P
                : idWorkP == IDtYPErELAYpOPcLIENTwORK_LEFT
                ? *pStPop2P
            : idWorkP == IDtYPErELAYpOPcLIENTwORK_EXPLODE2
            ? *pStPop1P
        : idWorkP == IDtYPErELAYpOPcLIENTwORK_EXPLODE1
        ? *pStPop0P
    stackC& stPop = idWorkP == IDtYPErELAYpOPcLIENTwORK_IMPLODE
    TELL( "setting up" )

    countT idWorkP = pTaskP->c4 ;
    RELAYiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
/*1*/TASK( tmRelayPopClientF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

