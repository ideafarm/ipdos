
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    etThread.delF( tinP , postxNotFound ) ;
    etThread.delF( tinP , pcIdName ) ;
    etThread.delF( tinP , posti ) ;
    }
        etThread = 0 ;
        cDone ++ ;

        }
            }
                lake.readCloseF( tinP , handle ) ;
                ppso[ off ]->writeF( tinP , postx , costx ) ;
            {
            else
            if( !postx ) ppso[ off ]->writeF( tinP , postxNotFound , costxNotFound ) ;

            if( *pcIdName ) lake.readF( tinP , postx , costx , handle , pcIdName , cSkip ) ;
            ZE( countT , cSkip ) ;
            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FISH ) ;
            ZE( countT , costx ) ;
            ZE( osTextT* , postx ) ;

            readRequestF( tinP , etThread , pcIdName , posti , *ppso[ off ] , dict ) ;

            //U:CONJ: WE DO NOT WANT THIS: ppso[ off ]->etherF( tinP , etThread ) ;
        {
        else
        if( etThread ) { DEL( ppso[ off ] ) ; }

        sIn.acceptF( tinP , ppso[ off ] , idPortPeer , nnPeer , countTC() ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        etThread = 0 ;
        DEL( ppso[ off ] ) ;

        off = cDone % CsLOTpSO ;
    {
    while( !ether && !etThread )
    etThread.flagsMode |= flTHIRDmODE_IMPOTENCEeXPECTED ;
    ZE( countT , cDone ) ;
    ZE( countT , off ) ;

    dictionary1C dict( tinP , etThread ) ;

    }
        costxNotFound = etThread.strMakeF( tinP , LF , postxNotFound , t0+tnf ) ; ___( postxNotFound ) ;
        textC t0 = T("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\nContent-Length: ")+TF4(tnf.csF(tinP),flFORMAT_FILLzE|flFORMAT_NObASE|flFORMAT_FOREIGN,8,0xa)+T("\r\n\r\n") ;
        TN( tnf , "not found" ) ;
    {
    ZE( countT   , costxNotFound ) ;
    ZE( osTextT* , postxNotFound ) ;
    lakeC lake( tinP , etThread ) ;

    etThread.newF( tinP , LF , pcIdName , CCiDnAMEmAX + 1 ) ; ___( pcIdName ) ;
    ZE( countT* , pcIdName ) ;

    etThread.newF( tinP , LF , posti , COSTiN ) ; ___( posti ) ;
    ZE( osTextT* , posti ) ;

    etThread.memSetF( tinP , (byteT*)ppso , sizeof( ppso ) ) ;
    socketC* ppso[ CsLOTpSO ] ;

    sIn.listenF( tinP ) ;
    sIn.bindF( tinP , ifcIDpORT_HTTP ) ;
    socketC sIn( tinP , etThread , TAG( TAGiDnULL ) ) ;

    etThread.strokeF( tinP , T("IdeaFarm " "(tm) City Http Server Lake\r\ni fill http requests using images in the lake\r\n\r\n") ) ;
{
else
}
    etThread.strokeF( tinP , T("Another af30104 appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tinP , TAG( TAGiDnULL ) , T("af30104") ) ;

TODO

}
    #endif

    else etThread.strokeF( tinP , T(" no \"/\" found in request: \"")+T(postRequestP)+T("\"\r\n") ) ;
    }
        }
            else etThread.strokeF( tinP , T(" no \".0\" found in request: \"")+T(postc)+T("\"\r\n") ) ;
            }
                if( ++ offn <= CCiDnAMEmAX ) pcIdNameP[ offn ] = 0 ;

                while( !etThread && postc && pcIdNameP[ offn ] ) ;
                }
                    if( postc ) postc ++ ;
                    postc = postew ;

                    }
                        if( !pcIdNameP[ offn ] ) pcIdNameP[ offn ] = - 1 ;
                        etThread.delF( tinP , psttn2 ) ;
                        pcIdNameP[ ++ offn ] = dictP( psttn2 ) ;
                        etThread.strMakeF( tinP , LF , psttn2 , T(postc) ) ; ___( psttn2 ) ;
                        ZE( strokeS* , psttn2 ) ;
                        if( postew ) *postew = 0 ;
                        postc ++ ;
                    {
                    else
                    }
                        else if( ++ offn < CCiDnAMEmAX ) pcIdNameP[ offn ] = - 1 ;
                        }
                            if( ++ offn < CCiDnAMEmAX ) pcIdNameP[ offn ] = thirdC::c_atoiIF( tinP , postc ) ;
                        {
                        if( cDigits <= 8 )
                        countT cDigits = postew ? postew - postc : poste - postc ;
                    {
                    if( *postc != '$' )
                    osTextT* postew = thirdC::c_strchrIF( tinP , postc , '.' ) ;
                {
                do

                etThread.strokeF( tinP , T(" ")+T(postc)+T("\r\n") ) ;

                countT offn = - 1 ;
                *poste = 0 ;
            {
            if( poste )
            osTextT* poste = thirdC::c_strstrIF( tinP , postc , ".0 " ) ;
        {
        else
        }
            pcIdNameP[ 2 ] = 0 ;
            pcIdNameP[ 1 ] = 1 ;
            pcIdNameP[ 0 ] = 1 ;
        {
        if( *postc == ' ' ) // RAW REQUEST BEGINS WITH "/ " SO SERVE THE WO'TH PAGE AS THE HOME PAGE

        postc ++ ;
    {
    if( postc )
    osTextT* postc = thirdC::c_strchrIF( tinP , postRequestP , '/' ) ;

    #else

    etThread.delF( tinP , psttw ) ;

    if( offn <= CCiDnAMEmAX ) pcIdNameP[ offn ++ ] = 0 ;
    }
        if( idf ) { etThread.strSubstringF( tinP , psttn , idf , sttq , S1C('/') , psttw ) ; ___( psttn ) ; }
        etThread.delF( tinP , psttn ) ;
        }
            }
                __( !pcIdNameP[ offn ++ ] ) ;
                etThread.delF( tinP , psttn2 ) ;
                pcIdNameP[ offn ] = dictP( psttn2 ) ;
                etThread.strSubstringF( tinP , psttn2 , idf , idl , psttn ) ; ___( psttn2 ) ;
                ZE( countT , idl ) ;
                countT idf = 2 ;
                ZE( strokeS* , psttn2 ) ;
            {
            else
            if( 1 != etThread.strIdF( tinP , sttDollar , psttn ) ) pcIdNameP[ offn ++ ] = etThread.strDigitsToSCountF( tinP , psttn ) ;
        {
        if( offn < CCiDnAMEmAX )
    {
    while( !etThread && psttn )
    if( psttw ) { etThread.strSubstringF( tinP , psttn , idf , sttq , S1C('/') , psttw ) ; ___( psttn ) ; }
    ZE( strokeS* , psttn ) ;
    //sttq = ze ;
    countT idf = 1 ;
    ZE( countT , offn ) ;

    }
        etThread.delF( tinP , psttl ) ;
        etThread.strWordF( tinP , psttw , psttl , sttq , S1C(' ') , 2 ) ; ___( psttw ) ;
        //sttq = ze ;
        etThread.strSubstringLineF( tinP , psttl , idf , sttq , T(postRequestP) ) ; ___( psttl ) ;
        countT idf = 1 ;
        ZE( strokeS* , psttl ) ;
    {
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , psttw ) ;

    #if defined( NEVERdEFINED )

    }
        while( !etThread && cNew && !thirdC::c_strchrIF( tinP , postRequestP , '\n' ) ) ;
        }
            off += cNew ;
            cNew = sInP.readF( tinP , postRequestP + off , COSTiN , flSOCKETcrEAD_STILLhUNGRYiSoK | flSOCKETcrEAD_JUSToNEmOUTHFUL ) ;
        {
        do
        ZE( countT , cNew ) ;
        ZE( countT , off ) ;
    {
    ZE( countT , ecnu ) ;

    }
        etThread.delF( tinP , psttPeer ) ;
        etThread.strokeF( tinP , psttPeer ) ;
        etThread.sockPsttHostF( tinP , psttPeer , nicNamePeer ) ; ___( psttPeer ) ;
        ZE( strokeS* , psttPeer ) ;
        { ZE( countT , idp ) ; sInP.peerNameF( tinP , idp , nicNamePeer ) ; }
        nicNameC nicNamePeer ;
    {
{
voidT readRequestF( tinS& tinP , etherC& etThread , countT* pcIdNameP , osTextT* const postRequestP , socketC& sInP , dictionary1C& dictP )

#define CCiDnAMEmAX 0x10
#define COSTiN 0x1000
#define CsLOTpSO 0x4

/*1*/WAKEhIDE( "city.http.server.lake" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

