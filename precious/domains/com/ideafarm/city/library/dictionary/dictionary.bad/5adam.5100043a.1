
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.delF( tinP , pbResponse ) ;
thirdC::logIF( tinP , T("==== END ========================================================================================================================") ) ;
}
    pbc += sizeof( rHeaderS ) + rHeader.cbData ;

    }
        default : { break ; }
        }
            break ;
            logLabelsF( tinP , pbData , (byteT*)&header ) ;

            etThread.delF( tinP , psttName ) ;
            thirdC::logIF( tinP , T("smtp server name: \"")+T(psttName)+T("\"") ) ;
            nameF( tinP , etThread , psttName , pbData , (byteT*)&header ) ; ___( psttName ) ;
            ZE( strokeS* , psttName ) ;

            pbData += sizeof( count01T ) ;
            thirdC::logIF( tinP , T("mx server rank: ")+TF1(cRank) ) ;
            countT cRank = *(count01T*)pbData ;
        {
        case 0xf : //MX
        }
            break ;
            logLabelsF( tinP , pbData , (byteT*)&header ) ;
        {
        case 0x2 : //NS
        }
            break ;
            thirdC::logIF( tinP , T("host address: ")+T(idh) ) ;
            nicNameC idh( SWAB4( *(countT*)pbData ) ) ;
        {
        case 0x1 : //A
    {
    switch( rHeader.idType )
    byteT* pbData = pbc + sizeof rHeader ;

    rHeader.logF( tinP ) ;
    rHeader.swabF() ;
    rHeaderS& rHeader = *(rHeaderS*)pbc ;
    logLabelsF( tinP , pbc , (byteT*)&header ) ;

    }
        thirdC::logIF( tinP , T(postSep) ) ;
        else if( cNote && cNote -- ) postSep = "==== NOTE =====================================================================================================================" ;
        else if( cAuth && cAuth -- ) postSep = "==== AUTHORITY ================================================================================================================" ;
             if( cAnsw && cAnsw -- ) postSep = "==== ANSWER ===================================================================================================================" ;
        ZE( osTextT* , postSep ) ;
    {
{
while( cResources -- )
countT cNote = header.cNotes       ;
countT cAuth = header.cAuthorities ;
countT cAnsw = header.cAnswers     ;
countT cResources = header.cAnswers + header.cAuthorities + header.cNotes ;

pbc += 2 * sizeof( count01T ) ;
) ;
    TF1( SWAB2( *(count01T*)( pbc + sizeof(count01T) ) )  )
    T(" idClass: "                                          )+
    TF1( SWAB2( *(count01T*)pbc )                          )+
    T(   "idType: "                                         )+
thirdC::logIF( tinP ,
logLabelsF( tinP , pbc , (byteT*)&header ) ;
thirdC::logIF( tinP , T("==== QUESTION =================================================================================================================") ) ;
byteT* pbc = pbResponse + sizeof( headerS ) ;

header.logF( tinP ) ;
thirdC::logIF( tinP , T("==== HEADER =================================================================================================================") ) ;
header.swabF() ;

headerS& header = *(headerS*)pbResponse ;

}
    etThread.delF( tinP , pbQuery ) ;
    so.readF( tinP , pbResponse , cbResponse , idPort , nicName ) ; ___( pbResponse ) ;
    nicNameC nicName ;
    ZE( countT , idPort ) ;

    so.writeF( tinP , 0x35 , so.nicNameF( tinP , etThread , T("NS4.BAYAREA.NET") ) , pbQuery , cbQuery ) ;
    so.bindF( tinP ) ;
    socketC so( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    queryF( tinP , etThread , pbQuery , cbQuery , T("ideafarm.com") , IDtYPE_MX ) ; ___( pbQuery ) ;
    //queryF( tinP , etThread , pbQuery , cbQuery , T("chevrolet.com") , IDtYPE_MX ) ; ___( pbQuery ) ;
    ZE( countT , cbQuery ) ;
    ZE( byteT* , pbQuery ) ;
{
ZE( countT , cbResponse ) ;
ZE( byteT* , pbResponse ) ;

TODO

#define IDtYPE_MX 0xf

}
    etThread.strConcatenateF( tinP , psttP , st_pstt , T(".") ) ; ___( psttP ) ;
    nameF( tinP , etThread , st_pstt , pbP , pbOriginP ) ;
    stackC st_pstt( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;

{
voidT nameF( tinS& tinP , etherC& etThread , strokeS*& psttP , const byteT* pbP , const byteT* const pbOriginP )

}
    }
        }
            }
                st_psttP << psttOldC( tinP , etThread , T(postw) ) ;
                if( postw ) postw[ cbLabel ] = 0 ;
                etThread.memCopyF( tinP , postw , pbLabel , cbLabel ) ;
                etThread.newF( tinP , LF , postw , cbLabel + 1 ) ; ___( postw ) ;
                ZE( osTextT* , postw ) ;
            {
            else
            if( !cbLabel ) break ;
            const osTextT* pbLabel =  pbP ; pbP += cbLabel ;
            countT         cbLabel = *pbP ; pbP += 1 ;
        {
        else
        else if( *pbP & 0xc0 ) thirdC::logIF( tinP , T("error: label is too long") ) ;
        }
            break ;
            nameF( tinP , etThread , st_psttP , pbr , pbOriginP ) ;
            const byteT* pbr = pbOriginP + ( SWAB2( *(count01T*)pbP ) & ~0xc000 ) ;
        {
        if( ( *pbP & 0xc0 ) == 0xc0 )
    {
    for(;;)
{
voidT nameF( tinS& tinP , etherC& etThread , stackC& st_psttP , const byteT* pbP , const byteT* const pbOriginP )

}
    etThread.delF( tinP , pstt1w ) ;
    }
        __( pbc - pbP - cbP ) ;

        *(count01T*)pbc = SWAB2( (count01T)1       ) ;           pbc += sizeof( count01T ) ; //CODE FOR THE "INTERNET" CLASS (REFERENCED BUT NOT SPECIFIED IN RFC1035)
        *(count01T*)pbc = SWAB2( (count01T)idTypeP ) ;           pbc += sizeof( count01T ) ;

        *pbc = 0 ;                                                 pbc ++     ;
        }
            etThread.memCopyF( tinP , pbc , (osTextT*)tw , cbw ) ; pbc += cbw ;
            *pbc = (byteT)cbw ;                                    pbc ++     ;

            countT cbw = tw.csF( tinP ) ;
            TN( tw , "" ) ; tw = T(psttc1) ;
        {
        FORsTRINGSiN1( pstt1w )

        etThread.memCopyF( tinP , pbc , (byteT*)&header , sizeof header ) ; pbc += sizeof header ;
        header.swabF() ;

        byteT* pbc = pbP ;
    {
    if( pbP )
    etThread.newF( tinP , LF , pbP , cbP ) ; ___( pbP ) ;
    cbP = sizeof header + costName + 2 * sizeof( count01T ) ;
    headerS header ;

    __( costName > 0x100 ) ; // RFC1035/3/1
    }
        costName += 1 + psttc1->idAdam ;
        __( psttc1->idAdam > 0x3f ) ; // RFC1035/3/1
        __( !psttc1->idAdam ) ;
    {
    FORsTRINGSiN1( pstt1w )
    countT costName = 1 ; // TRAILING NULL

    etThread.strWordsOldF( tinP , pstt1w , psttP , sttq , T(".") ) ; ___( pstt1w ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , pstt1w ) ;

    }
        if( etThread ) return ;
        __( !psttP->idAdam ) ;
        if( etThread ) return ;
        __( etThread.strIdF( tinP , sttBlank , psttP ) ) ;
        __Z( psttP ) ;
        __( cbP ) ;
        __NZ( pbP ) ;
        if( etThread ) return ;
    {
    IFbEcAREFUL

    strokeS sttBlank(' ') ;
{
voidT queryF( tinS& tinP , etherC& etThread , byteT*& pbP , countT& cbP , const strokeS* const psttP , const countT idTypeP )

}
    cbData        = SWAB2( cbData        ) ;
    secondsToLive = SWAB4( secondsToLive ) ;
    idClass       = SWAB2( idClass       ) ;
    idType        = SWAB2( idType        ) ;
{
voidT rHeaderS::swabF( voidT )

}
    cNotes       = SWAB2( cNotes       ) ;
    cAuthorities = SWAB2( cAuthorities ) ;
    cAnswers     = SWAB2( cAnswers     ) ;
    cQuerys   = SWAB2( cQuerys   ) ;
    idQuery      = SWAB2( idQuery      ) ;
{
voidT headerS::swabF( voidT )

}
    thirdC::logIF( tinP , T("header: cQuerys: ")+TF1(cQuerys)+T(" cAnswers: ")+TF1(cAnswers)+T(" cAuthorities: ")+TF1(cAuthorities)+T(" cNotes: ")+TF1(cNotes) ) ;
{
voidT headerS::logF( tinS& tinP )

}
{
cNotes( 0 )
cAuthorities( 0 ) ,
cAnswers( 0 ) ,
cQuerys( 1 ) ,
idError( 0 ) ,
reserved1( 0 ) ,
bCanRecurse( 0 ) ,
bPleaseRecurse( 0 ) ,
bTruncated( 0 ) ,
bAuthoritative( 0 ) ,
idType( 0 ) ,
bQuery( 1 ) ,
idQuery( ++ idQueryLast ) ,
headerS::headerS( voidT ) :

count01T headerS::idQueryLast ;

}
    thirdC::logIF( tinP , T("rHeader: idType: ")+TF1(idType)+T(" idClass: ")+TF1(idClass)+T(" secondsToLive: ")+TF1(secondsToLive)+T(" cbData: ")+TF1(cbData) ) ;
{
voidT rHeaderS::logF( tinS& tinP )

}
{
cbData( 0 )
secondsToLive( 0 ) ,
idClass( 0 ) ,
idType( 0 ) ,
rHeaderS::rHeaderS( voidT ) :

}
    if( osto001.costF() ) thirdC::logIF( tinP , T("label portion: \"")+T(osto001)+T("\"") ) ;

    }
        }
            }
                break ;
                pbP ++ ;
            {
            if( !*pbP )

            OStEXTAK( osto001 , "." )
            OStEXTAL( osto001 , pbLabel , cbLabel )

            osTextT* pbLabel =  pbP ; pbP += cbLabel ;
            countT   cbLabel = *pbP ; pbP += 1 ;
        {
        else
        else if( *pbP & 0xc0 ) thirdC::logIF( tinP , T("error: label is too long") ) ;
        }
            break ;
            pbP += 2 ;
            logLabelsF( tinP , pbr , pbOriginP ) ;
            byteT* pbr = pbOriginP + ( SWAB2( *(count01T*)pbP ) & ~0xc000 ) ;

            if( osto001.costF() ) thirdC::logIF( tinP , T("label portion before compressed portion: \"")+T(osto001)+T("\"") ) ;
        {
        if( ( *pbP & 0xc0 ) == 0xc0 )
    {
    for(;;) // ASSUME: *pbP IS INITIALLY NOT 0. CODE STRUCTURE REFLECTS NONCOMPRESSED, NULL TERMINATED FORMAT. COMPRESSION CODE ASSUMED TO ONLY OCCUR AT END (PER RFC SPEC)

    OStEXT( osto001 , 0x100 )
{
voidT logLabelsF( tinS& tinP , byteT*& pbP , byteT* const pbOriginP )
*/
  must point to the beginning of the header record for the message being parsed
 pbOriginP
  will point to the end of the label
  must point to the beginning of the label
 pbP
arguments
/*

;
}
    voidT swabF( voidT ) ;
    voidT logF( tinS& tinP ) ;
    rHeaderS( voidT ) ;

    count01T cbData ;
    countT    secondsToLive ;
    count01T idClass ;
    count01T idType ;
{
struct rHeaderS //THIS IS THE PART OF THE "RESOURCE RECORD" THAT FOLLOWS THE LABELS FOR THE RESOURCE

;
}
    voidT swabF( voidT ) ;
    voidT logF( tinS& tinP ) ;
    headerS( voidT ) ;

    count01T           cNotes              ;
    count01T           cAuthorities        ;
    count01T           cAnswers            ;
    count01T           cQuerys          ;
    byteT               idError         : 4 ;
    byteT               reserved1       : 3 ;
    byteT               bCanRecurse     : 1 ;
    byteT               bPleaseRecurse  : 1 ;
    byteT               bTruncated      : 1 ;
    byteT               bAuthoritative  : 1 ;
    byteT               idType          : 4 ;
    byteT               bQuery          : 1 ;
    count01T           idQuery             ;
    static count01T    idQueryLast         ;
{
struct headerS


#define SWAB4(cP) SWAB2( cP >> 0x10 ) | ( SWAB2( cP & 0xffff ) << 0x10 )

#define SWAB2(cP) (count01T)( ( (((count01T)(cP))&0xffff) >> 8 ) | ( (count01T)((cP)<<8) & 0xffff ) )

//BASELINE: 4240104

/*1*/WAKEhIDE( "example.dns.rr.mx.query" )/*1*/
/**/
*/
like 8340104 but handles arbitrary query name
obsoletes 8340104
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

