
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#undef BcANDYo
#undef BcANDY

}
    return value ;

    }
        }
            }
                }
                    delF( tinP , psttd ) ;_WQ

                    if( fNeg ) value *= - 1 ;_WQ

                    }
                        else break ;
                        }
                            value += cDelta ;_WQ
                            value *= radix ;_WQ
                        {
                        if( bOk )

                        }
                            else                                                                                                                                      bOk = 0 ;
                            else if( psttc[ off ].idAdam >= stt_qu.idAdam && psttc[ off ].idAdam <= stt_at.idAdam && (countT)psttc[ off ].idAdam - '?' + 62 < radix ) cDelta = psttc[ off ].idAdam - '?' + 62 ;
                            else if( psttc[ off ].idAdam >=  stt_A.idAdam && psttc[ off ].idAdam <=  stt_Z.idAdam && (countT)psttc[ off ].idAdam - 'A' + 36 < radix ) cDelta = psttc[ off ].idAdam - 'A' + 36 ;
                            else if( psttc[ off ].idAdam >=  stt_a.idAdam && psttc[ off ].idAdam <=  stt_z.idAdam && (countT)psttc[ off ].idAdam - 'a' + 10 < radix ) cDelta = psttc[ off ].idAdam - 'a' + 10 ;
                            else if( psttc[ off ].idAdam >=  stt_0.idAdam && psttc[ off ].idAdam <=  stt_9.idAdam && (countT)psttc[ off ].idAdam - '0'      < radix ) cDelta = psttc[ off ].idAdam - '0'      ;
                            else if( psttc[ off ].idCaste == sc_cALPHABET1 && ( ( psttc[ off ].idAdam & 0xf0000000 ) == sscDIGIT )                                  ) cDelta = psttc[ off ].idAdam & 0xffff   ;
                            if( !BcANDYo( off ) ) bOk = 0 ;
                        {
                        ZE( countT , cDelta ) ;_WQ
                        boolT bOk = 1 ;_WQ
                    {
                    for( countT off = 0 ; !POOP && off < cc ; off ++ )
                    _IO_ //U:: TO FIND A BUG
                {
                //GET ABSOLUTE VALUE

                }
                    }
                        }
                            }
                                if( psttc[ off ] == stt_bl ) break ;
                                _IO_ //U:: TO FIND A BUG
                            {

                            }
                                break ;
                                else { __( (countT)psttc[ off ] ) ; __1 }
                                }
                                    else if( psttc[ off ].idAdam >= stt_qu.idAdam && psttc[ off ].idAdam <= stt_at.idAdam ) radix = (countT)psttc[ off ] - '?' + 63 ;
                                    else if( psttc[ off ].idAdam >=  stt_A.idAdam && psttc[ off ].idAdam <=  stt_Z.idAdam ) radix = (countT)psttc[ off ] - 'A' + 37 ;
                                    else if( psttc[ off ].idAdam >=  stt_a.idAdam && psttc[ off ].idAdam <=  stt_z.idAdam ) radix = (countT)psttc[ off ] - 'a' + 11 ;
                                    else if( psttc[ off ].idAdam >=  stt_1.idAdam && psttc[ off ].idAdam <=  stt_9.idAdam ) radix = (countT)psttc[ off ] - '0' +  1 ;
                                    if( psttc[ off ].idCaste == sc_cALPHABET1 && ( psttc[ off ].idAdam & 0xf0000000 == sscDIGIT ) ) radix = psttc[ off ].idAdam & 0xffff ;
                                    _IO_ //U:: TO FIND A BUG
                                {
                                if( BcANDYo( off ) )
                                _IO_ //U:: TO FIND A BUG
                            {
                            if( bDebug1 )
                            boolT bDebug1 = psttc[ off - 1 ].idAdam == stt_un.idAdam && BcANDYo( off - 1 ) ;
                            //tinP.pc Utility[ 0xc ] = off | BM_HIGH ; //U:: TO FIND A BUG
                            _IO_ //U:: TO FIND A BUG
                        {
                        for( countT off = 1 ; off < cc ; off ++ )
                        _IO_ //U:: TO FIND A BUG
                    {

                    //tinP.pc Utility[ 0xd ] = cc           ; //U:: TO FIND A BUG
                    //tinP.pc Utility[ 0xe ] = cc | BM_HIGH ; //U:: TO FIND A BUG
                    cc = cs - ( psttc - psttPrefix - CSpREFIX ) ;_WQ
                    if( fNeg || ( psttc->idAdam == stt_pl.idAdam && BcANDY ) ) psttc ++ ;_WQ
                    fNeg = psttc->idAdam == stt_mi.idAdam && BcANDY ;_WQ
                    while( psttc->idAdam == stt_bl.idAdam && BcANDY ) psttc ++ ;_WQ
                    psttc += CSpREFIX ;_WQ
                    //tinP.pc Utility[ 0xf ] = cs | BM_HIGH ; //U:: TO FIND A BUG
                    countT cs = psttPrefix->idAdam ;_WQ
                    const strokeS* psttPrefix = psttc ;_WQ
                    _IO_ //U:: TO FIND A BUG
                {
                if( !POOP )

                _IO_ //U:: TO FIND A BUG
            {
            ZE( boolT , fNeg ) ;_WQ
            ZE( countT , cc ) ;_WQ
            strokeS* psttc = psttd ;_WQ
            //GET SIGN AND RADIX OVERRIDE

            const strokeS stt_un( '_' ) ;_WQ
            const strokeS stt_pl( '+' ) ;_WQ
            const strokeS stt_mi( '-' ) ;_WQ
            const strokeS stt_at( '@' ) ;_WQ
            const strokeS stt_qu( '?' ) ;_WQ
            const strokeS stt_bl( ' ' ) ;_WQ
            const strokeS stt_Z( 'Z' ) ;_WQ
            const strokeS stt_A( 'A' ) ;_WQ
            const strokeS stt_z( 'z' ) ;_WQ
            const strokeS stt_a( 'a' ) ;_WQ
            const strokeS stt_9( '9' ) ;_WQ
            const strokeS stt_1( '1' ) ;_WQ
            const strokeS stt_0( '0' ) ;_WQ
            //U: OPTIMIZE BY MAKING THESE STATIC

            _IO_
        {
        if( !POOP )

        __Z( psttd ) ;
        if( !bForeignP ) { strReverseF( tinP , psttd ) ; ___( psttd ) ; }
        strMakeF( tinP , LF , psttd , psttP ) ; ___( psttd ) ;_WQ
        ZE( strokeS* , psttd ) ;_WQ
    {
    if( psttP->idAdam )
    ZE( sCountT , value ) ;_WQ

    _IO_

    // NOTE: THIS FUNCTION WAS CODED ASSUMING FOREIGN DIGIT ORDERING.  AFTER THE CODE WAS COMPLETED, IT WAS DECIDED TO ORDER DIGITS IN INCREASING SIGNIFICANCE WITHIN IFC
    //U: OPTIMIZE TO ELIMINATE USE OF strReverseF BY REWRITING THIS FUNCTION

    }
        if( POOP ) return 0 ;
        __( psttP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return 0 ;
        __( radix > 64 ) ;_WQ
        __( radix < 2 ) ;_WQ
        __Z( psttP ) ;_WQ
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL

    if( !radix ) radix = 0x10 ;_WQ
    countT radix = defaultRadixP ;_WQ
    SCOOP
{
/*1*/sCountT etherC::strDigitsToSCountF( tinS& tinP , const strokeS* const psttP , const countT defaultRadixP , const boolT bForeignP )/*1*/

#define BcANDYo(offP) ( psttc[ offP ].idCaste == sc_cFROMaSCII || psttc[ offP ].idCaste == sc_cALPHABET1 )
#define BcANDY ( psttc->idCaste == sc_cFROMaSCII || psttc->idCaste == sc_cALPHABET1 )
//"candy": "candidate"

/**/
*/
  1: Foreign digit ordering (most significant digit occurs first (i.e. at left)
  0: IdeaFarm " "(tm) City digit ordering (least significant digit occurs first (i.e. at left)
  can be 0 or 1
 bForeignP
  if nonze, must be at least 2 and not more than 64_9
  can be 0, which implies radix 16_9
 defaultRadixP
 psttP
arguments
after an overflow, the resulting sign will still be correct
overflow is not detected
 if there is a valid radix override, terminates with the radix override
 if there is a radix override but it is invalid (not a radix 64_9 digit) then impotence occurs
 if there is no radix override, terminates with the first stroke that is not a value radix 16 digit
conversion terminates with the first nonnumeric stroke
the radix override value is always expressed in radix 64_9 (the digits are 0..9 a..z A..Z ? @)
  "-YZ?@_@" is the radix 64_9 value -YZ?@
  "-EFEF_F" is the radix 42_9 value -EFEF
  "-yzyz_z" is the radix 36_9 value -yzyz
  "-efef_f" is the radix 16_9 (hex) value -efef
  "89abcde" is the radix 16_9 value 89abcde
  "10"      is the radix 16_9 value 10
  "0"       is the value 0
 a radix can be specified by appending an underscore "_" followed by a single radix 64_9 digit [0..9 a..z A..Z ? @]
an explicit radix overrides defaultRadixP
the plus sign is legal
the negative sign must be the first nonblank character
the number can contain leading blanks
  \<A HREF=\"5.1910104.1.1.0.html\"\>1910104:  WAKEsHOW( "example.simplest.func.1030057.etherC.strDigitsToSCountF" )\</A\>
 simplest
examples
\<A HREF=\"5.1030057.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strDigitsToSCountF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

