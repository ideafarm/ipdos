
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return *pSession ;
    baton.ungrabF( tinP ) ;
    }
        ether.delF( tinP , psttPeer ) ;
        swSession = (countT)pSession ; //WORKS SINCE operator () SET THE LEVER AND I STILL HAVE THE GRAB
        pSession = new( 0 , tinP , LF ) sessionC( tinP , ether , TAG( TAGiDnULL ) , *this , idSessionLath , nnPeerP , psttPeer , psttUserP ) ; ___( pSession ) ;
        THREADmODE1rESTORE
        DEL( pSession ) ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

        }
            if( zsttPeer ) { ether.strMakeF( tinP , LF , psttPeer , zsttPeer ) ; ___( psttPeer ) ; }
            const strokeS* zsttPeer = pSession->zsttPeerF( tinP ) ;
        {
        else
        if( psttPeerP ) { ether.strMakeF( tinP , LF , psttPeer , psttPeerP ) ; ___( psttPeer ) ; }
        ZE( strokeS* , psttPeer ) ;
    {
    if( bFlushP || idle.time2 || idle.time1 > ifcTIMEtIMEOUTsESSION )
    timeS idle = pSession->idleF( tinP ) ;

    sessionC* pSession = &(*this)( tinP , nnPeerP , psttPeerP ) ;
    baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
    _IO_
{
/*1*/sessionC& sessionsC::registerConnectionF( tinS& tinP , const nicNameC& nnPeerP , const strokeS* const psttPeerP , const strokeS* const psttUserP , const boolT bFlushP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

