
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
CONoUTrAW( "shutdown/0\r\n" ) ; //U::
tinP.idPhase2 = 0 ;
TELL( "entering REST" )
}
    CONoUTrAW( "shutdown/1\r\n" ) ; //U::
    CONoUTrAW( "shutdown/2\r\n" ) ; //U::
    
    }
        etThread = 0 ;
        POPUP( "The IdeaFarm " "(tm) Driver is impotent." ) ;
        TELL( "displaying popup that driver is impotent" )
        PC
    {
    if( etThread )
    CONoUTrAW( "shutdown/3\r\n" ) ; //U::
    
    }
        CONoUTrAW( "shutdown/4\r\n" ) ; //U::

        }
            DEL( pwtf ) ;
            stRecycle_pwtFine >> *(countT*)&pwtf ;
            ZE( whereTalliesFineS* , pwtf ) ;
        {
        while( stRecycle_pwtFine )

        }
            DEL( pwtg ) ;
            stRecycle_pwtGross >> *(countT*)&pwtg ;
            ZE( whereTalliesGrossS* , pwtg ) ;
        {
        while( stRecycle_pwtGross )
        CONoUTrAW( "shutdown/purging where tallies recycling stacks\r\n" ) ; //U::

        }
            PURGE( Gross , swWhereTalliesGrossClass ,                     , cLeverTalliesGrossClass  )
            PURGE( Gross , swWhereTalliesGrossPhase , *(count4S*)(byteT*) , c4leverTalliesGrossPhase )
            PURGE( Fine  , swWhereTalliesFineAdam   , *(count4S*)(byteT*) , c4leverTalliesFineAdam   )
            PURGE( Fine  , swWhereTalliesFineClass  , *(count4S*)(byteT*) , c4leverTalliesFineClass  )
            PURGE( Fine  , swWhereTalliesFinePhase  , *(count5S*)(byteT*) , c5leverTalliesFinePhase  )
            CONoUTrAW( "constructed stDelete\r\n" ) ; //U::
            stackC stDelete( tinP , etThread , TAG( TAGiDnULL ) ) ;
            CONoUTrAW( "constructing stDelete\r\n" ) ; //U::
        {
        CONoUTrAW( "shutdown/purging where tallies switches\r\n" ) ; //U::

        TELL( "destroying accumulators" )
    
        if( etThread.diskFileExistsF( tinP , tActive ) ) etThread.diskFileOrDirDeleteF( tinP , tActive ) ;

        //__( thUnserializedPool ) ;
        sgnDone_tmCircleLogF.waitF( tinP ) ;
        CONoUTrAW( "shutdown/b\r\n" ) ; //U::
        bMonitorEnded = 1 ;
        //tinP.flagsThreadMode1 |= flTHREADmODE1_SUPPRESStELLmONITOR ; //U::FIGURE OUT A WAY TO AVOID SUPPRESSING TELLS; CONJ: SET A CALLBACK FUNCTION THAT CAN UNGRAB THE NAPKIN SO THAT THE EXCEPTION HANDLER CAN EMIT A NOTE
        //U::CONJ: THE GRABBING OF THE CIRCLE NAPKIN IS NOT NECESSARY
    
        etThread.boxPutF( tinP , tActive , "" , 1 ) ; //U::KLUGE NEEDED CAUSE PACKAGE IS DENIED ACCESS TO napHomeJot
        TN( tActive , "///d/ideafarm.sign.driverActive" ) ;
    
        OStEXTAK( napHomeJot  , postNAPhOSTjOTsTATUSrEADY ) ;
    
        //HIRE( T("fff") , 0x4010fff , 0x1000000 , 0x4010fff , 0x10000000 ) //U::DEBUGGING
        //HIRE( T("aff") , 0x4010ffa , 0x1000000 , 0x4010ffa , 0x10000000 ) //U::DEBUGGING
        //HIRE( T("scratch") , 0x4010ffc , 0x1000000 , 0x4010ffc , 0x10000000 )
    
        //U::etThread.osSessionF( tinP , countTC() , countTC() , 0x40104f1 , 0 ) ;
        //etThread.osSessionF( tinP , countTC() , countTC() , 0x4010351 , 0 ) ;
        //U::HIRE( T("city.driven.server.chat") , ifcIDaDAMoLD_CHATsERVER , 0x1000000 , 0x40104f1 , 0x10000000 )
        //while( cClones -- ) { countT idAdam = 0x40104e7 ; countT idCell = ++ idClone ; ether.ifcHireF( tinP , T("city.driver") , idAdam , T("!postHandoffOld ")+TF1(idAdam)+T(".")+TF1(idCell) , flHIRE_DISPLAYaUTO , nicNameC() ) ; }
        //countT cClones = 1 ;
        //ZE( countT , idClone ) ;
        //THIS PARAGRAPH IS OBSOLETE AND RETAINED FOR REFERENCE ONLY (DURING CODE TRANSITION)
    
        //etThread.osThreadF( tinP , countTC() , tmBlammoF ) ;
        //etThread.osThreadF( tinP , countTC() , tmLockupF   , 0                  , flTHREADlAUNCH_null , 0 , (countT)&g1 , (countT)&g2 , 2 ) ;
        //etThread.osThreadF( tinP , countTC() , tmLockupF   , 0                  , flTHREADlAUNCH_null , 0 , (countT)&g1 , (countT)&g2 , 1 ) ;
        etThread.osThreadF( tinP , countTC() , tmRptPoolF  , &sgnDone_tmRptPoolF  , flTHREADlAUNCH_null , 0 , (countT)&sgnDone_tmFireAllF , (countT)postPoolNames , (countT)pcRefPoolNames ) ;
        etThread.osThreadF( tinP , countTC() , tmWhereRptF , &sgnDone_tmWhereRptF , flTHREADlAUNCH_null , 0 , (countT)&c3wp ) ;
        etThread.osThreadF( tinP , countTC() , tmWhereF    , &sgnDone_tmWhereF    , flTHREADlAUNCH_null , 0 , (countT)&c3wp ) ;
        etThread.osThreadF( tinP , countTC() , tmRptMainF  , &sgnDone_tmRptMainF  , flTHREADlAUNCH_null , 0 , (countT)&c8rp1 , (countT)&c8rp2 , (countT)&c8rp3 , (countT)&c8rp4 , (countT)&c8rp5 ) ;
        etThread.osThreadF( tinP , countTC() , tmLogSnapF  , &sgnDone_tmLogSnapF  , flTHREADlAUNCH_null , 0 , (countT)&sgnDone_tmRptMainF , (countT)&pNapLog , (countT)&bDestroyCircleLog ) ;
        }
            while( !pNapLog && !etThread ) { ++ s ; etThread.osSleepF( tinP ) ; }
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        etThread.osThreadF( tinP , countTC() , tmCircleLogF      , &sgnDone_tmCircleLogF      , flTHREADlAUNCH_null , 0 , (countT)&pNapLog , (countT)&bDestroyCircleLog ) ;
    
        count3S c3wp( (countT)&c8w1 , (countT)&c8w2 , (countT)&c8w3 ) ;
        count8S c8w3( (countT)&stLifi , (countT)&stWhere , (countT)&wtGrossHost , (countT)&stRecycle_pwtGross , (countT)&stRecycle_pwtFine ) ;
        count8S c8w2( (countT)&swWhereTalliesFinePhase , (countT)&c4leverTalliesFineAdam , (countT)&swWhereTalliesFineAdam , (countT)&c4leverTalliesFineClass , (countT)&swWhereTalliesFineClass , (countT)&c5leverTallyActiveThread , (countT)&swWhereTallyActiveThread , (countT)&stTinWhere ) ;
        count8S c8w1( (countT)&sgnDone_tmRptPoolF , (countT)&sgnDone_tmWhereF , (countT)&bDestroyCircleMonitor , (countT)&cLeverTalliesGrossClass , (countT)&swWhereTalliesGrossClass , (countT)&c4leverTalliesGrossPhase , (countT)&swWhereTalliesGrossPhase , (countT)&c5leverTalliesFinePhase ) ;

        count8S c8rp5( (countT)&stRecycle_pwtFine ) ;
        count8S c8rp4( (countT)&wtGrossHost , (countT)&cLeverTalliesGrossClass , (countT)&swWhereTalliesGrossClass , (countT)&c5leverTallyActiveThread , (countT)&swWhereTallyActiveThread , (countT)&c5leverTallyTalking , (countT)&swWhereTallyTalking , (countT)&stRecycle_pwtGross ) ;
        count8S c8rp3( (countT)&conditionalGrab , (countT)&stRpt , (countT)&st_ST_osTidWoTree , (countT)&stIdSerialGrabExclude , (countT)&st_ST_osTidSleeping , (countT)&st_ST_osTidPseudoSleeping , (countT)&st_ST_osTidMessiah , (countT)&st_ST_osTidPseudoBelieving ) ;
        count8S c8rp2( (countT)&stBadGrabs , (countT)&stOsTidLoopedTmp , (countT)&stOsTidLooped , (countT)&stOsTidBad , (countT)&stPool , (countT)&stNapkin , (countT)&stTin , (countT)&bDestroyCircleLog ) ;
        count8S c8rp1( (countT)&bMonitorEnded , (countT)&stGrab , (countT)&stLifi , (countT)&stGrabbed , (countT)&stWanters , (countT)&stWanters2 , (countT)&stChecked , (countT)&stBadGrabsTmp ) ; // "c8r":"reporter parameters"
        
        countT  c2mpr = (countT)&c2mp ;
        count2S c2mp( (countT)&c8m1 , (countT)&c8m2 ) ; // "c8m": "monitor accumulators"
        count8S c8m2( (countT)postPoolNames , (countT)pcRefPoolNames , (countT)&c5leverTallyTalking , (countT)&swWhereTallyTalking ) ;
        count8S c8m1( (countT)&stGrab , (countT)&stLifi , (countT)&stPool , (countT)&stNapkin , (countT)&stTin , (countT)&stTinWhere , (countT)&pNapLog , (countT)&conditionalGrab ) ;

        stackC stRecycle_pwtFine( tinP , etThread , TAG( TAGiDnULL ) ) ;    
        stackC stRecycle_pwtGross( tinP , etThread , TAG( TAGiDnULL ) ) ;    
        whereTalliesGrossS wtGrossHost( tinP , etThread , TAG( TAGiDnULL ) ) ;
        switchC swTallyWhat( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_null , idWhatLever ) ;
        ZE( countT , idWhatLever ) ;
        grabS g2( tinP , TAG( TAGiDnULL ) ) ;
        grabS g1( tinP , TAG( TAGiDnULL ) ) ;
        static countT pcRefPoolNames[ CpOOLoLDnAMESmAX ] ;
        static osTextT postPoolNames[ CpOOLoLDnAMESmAX ][ COSTmAXpOOLoLDnAME + 1 ] ;    
        signC   sgnDone_tmWhereRptF( tinP , TAG( TAGiDnULL ) ) ;
        signC   sgnDone_tmWhereF( tinP , TAG( TAGiDnULL ) ) ;
        signC   sgnDone_tmRptMainF( tinP , TAG( TAGiDnULL ) ) ;
        signC   sgnDone_tmLogSnapF( tinP , TAG( TAGiDnULL ) ) ;
        signC   sgnDone_tmRptPoolF( tinP , TAG( TAGiDnULL ) ) ;
        signC   sgnDone_tmFireAllF( tinP , TAG( TAGiDnULL ) ) ;
        countT bGiven = sgnDone_tmCircleLogF ; //U::
        signC   sgnDone_tmCircleLogF( tinP , TAG( TAGiDnULL ) ) ;
        ZE( boolT , bMonitorEnded ) ;

        switchC swWhereTallyTalking( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , (byteT*)&c5leverTallyTalking , sizeof c5leverTallyTalking ) ;
        count5S c5leverTallyTalking ;

        switchC swWhereTalliesFineAdam( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , (byteT*)&c4leverTalliesFineAdam , sizeof c4leverTalliesFineAdam ) ;
        count4S c4leverTalliesFineAdam ;

        switchC swWhereTallyActiveThread( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , (byteT*)&c5leverTallyActiveThread , sizeof c5leverTallyActiveThread ) ;
        count5S c5leverTallyActiveThread ;

        switchC swWhereTalliesFineClass( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , (byteT*)&c4leverTalliesFineClass , sizeof c4leverTalliesFineClass ) ;
        count4S c4leverTalliesFineClass ;

        switchC swWhereTalliesFinePhase( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , (byteT*)&c5leverTalliesFinePhase , sizeof c5leverTalliesFinePhase ) ;
        count5S c5leverTalliesFinePhase ;

        switchC swWhereTalliesGrossPhase( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , (byteT*)&c4leverTalliesGrossPhase , sizeof c4leverTalliesGrossPhase ) ;
        count4S c4leverTalliesGrossPhase ;

        switchC swWhereTalliesGrossClass( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , cLeverTalliesGrossClass ) ;
        ZE( countT , cLeverTalliesGrossClass ) ;

        stackC  stWhere(                    tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB                /*flSTACKc_DOnOTsERIALIZE*/                                        , sizeof( whereOldS           ) ) ;
        stackC  st_ST_osTidPseudoBelieving( tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  st_ST_osTidMessiah(         tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  st_ST_osTidPseudoSleeping(  tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  st_ST_osTidSleeping(        tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  stIdSerialGrabExclude(      tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  st_ST_osTidWoTree(          tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  stRpt(                      tinP , etThread , TAG( TAGiDnULL ) ,                flSTACKc_FIFO /*flSTACKc_DOnOTsERIALIZE*/                                        , ifcSTACKtYPE_PTR_strokeS   ) ;
        stackC  stOsTidBad(                 tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  stOsTidLooped(              tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  stOsTidLoopedTmp(           tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  stBadGrabs(                 tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB                /*flSTACKc_DOnOTsERIALIZE*/                                        , sizeof( grabEntryS       ) ) ;
        stackC  stBadGrabsTmp(              tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  stChecked(                  tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  stWanters2(                 tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  stWanters(                  tinP , etThread , TAG( TAGiDnULL )                               /*flSTACKc_DOnOTsERIALIZE*/                                                                     ) ;
        stackC  stGrabbed(                  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB                /*flSTACKc_DOnOTsERIALIZE*/                                        , sizeof( grabEntryS       ) ) ;
        stackC  stNapkin(                   tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB                /*flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | */ , sizeof( napkinEntryS     ) ) ;
        stackC  stTinWhere(                 tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB                                                                                  , sizeof( tinEntryS        ) ) ;
        stackC  stLifi(                     tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB                /*flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | */ , sizeof( lifiEntryS       ) ) ;
        stackC  stGrab(                     tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB                /*flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | */ , sizeof( grabEntryS       ) ) ;

        //thirdC  thUnserializedPool(         tinP , TAG( TAGiDnULL ) , poolOldSetOldUnserialized ) ;
        //p oolC   poolOldSetOldUnserialized(           tinP , TAG( TAGiDnULL ) , T("monitor.unserialized.main.")+TF1(tinP.osPid)+T(".")+TF1(tinP.monitor.idThread) , flPOOLoLDc_UNSERIALIZED | flPOOLoLDc_UNSERIALIZEDmULTItHREAD ) ; U::flag: UNSERIALIZED
        //U::CONJ: OBSOLETE: 

        ZE( countT , conditionalGrab ) ;
        ZE( napkinC* , pNapLog ) ;
        ZE( boolT , bDestroyCircleLog ) ;
        ZE( boolT , bDestroyCircleMonitor ) ;
        //SOME OF THESE ARE HERE SO THAT tmRptMainF DOES NOT GENERATE grabS CT/DT NOTES
        
        OStEXTAK( napHomeJot  , "driver: getting ready" ) ;
        
        //U::SUSPECTED OF CAUSING LOCKUP DURING CT: stateS state( tinP , etThread ) ;
        PC
    {

    }    
        thirdC::third_flagsModeProcess1I_IF( tinP ) |= F(flMODEpROCESS1_JOT) ; //U::HERE TO DEBUG LOCKUP DURING QUIT
        OStEXTAK( napHomeJot  , "driver: inheriting state" ) ;
        }
            napHomeJot.formattingIsDoneF( tinP ) ;
            if( !etThread ) *napHomeJot = 0 ;
        {
        if( !( F(napHomeJot.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
        __( !(byteT*)napHomeJot ) ;
        __( (countT)napHomeJot - CBnAPjOT ) ;
        renameOldReportFilesF( tinP , etThread ) ;
        //etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIEST ) ;
        PC
    {
    napkinC napHomeJot( tinP , LF , (byteT*)bits , "napHomeJot" , 0 , CBnAPjOT ) ;
    bitsC bits( tinP , CbITSlIFI , 0 , 1 ) ;
    TELL( "setting up" )
    
    PC
    threadCheckC tc( tinP , TAG( TAGiDnULL ) ) ;
{
tinP.idPhase2 = 1 ;
thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_DEBUG1 ; //U::CAUSES THE DFLT EXCEPTION HANDLER TO SLEEP FOREVER
TODO

}
    etThread.delF( tinP , pstt1f ) ;
    FORsTRINGSiN1( pstt1f ) if( etThread.diskFileExistsF( tinP , psttc1 ) ) etThread.diskMoveFileOrDirF( tinP , T(psttc1)+tSuffix , psttc1 ) ;
    TN( tSuffix , "." ) ; tSuffix += TT(timeN1,timeN2) ;

    etThread.strFuseSeparateF( tinP , pstt1f , T("///d/ideafarm.rpt.monitor.where") ) ;
    etThread.strFuseSeparateF( tinP , pstt1f , T("///d/ideafarm.rpt.monitor.poolOlds") ) ;
    etThread.strFuseSeparateF( tinP , pstt1f , T("///d/ideafarm.rpt.monitor.main" ) ) ;
    etThread.strFuseSeparateF( tinP , pstt1f , T("///d/ideafarm.rpt.monitor.log"  ) , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 0x1000 ) ; ___( pstt1f ) ;
    ZE( strokeS* , pstt1f ) ;

    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE(  countT , timeN1 ) ;
    _IO_    TLNA( "renameOldReportFilesF" )
{
voidT renameOldReportFilesF( tinS& tinP , etherC& etThread )

#endif
DONE( tmLockupF )
}
    g2.ungrabF( tinP ) ;
    g1.ungrabF( tinP ) ;
    TELL( "ungrabbing" )
    ( idMe == 1 ? g2 : g1 ).grabF( tinP , TAG( TAGiDnULL ) ) ;
    TELL( "about to grab ooth" )
    }
        ++ s ; etThread.osSleepF( tinP , TOCK ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    TELL( "napping for a tock" )
    ( idMe == 1 ? g1 : g2 ).grabF( tinP , TAG( TAGiDnULL ) ) ;
    TELL( "about to grab woth" )

    etThread.strokeF( tinP , T("tmLockupF ")+TF1(idMe)+T("; osTid: ")+TF1(tinP.osTid)+T("; serial numbers: ")+TF1(g1.idMe)+ T(" ")+TF1(g2.idMe)+T("\r\n") ) ;

    countT idMe =          pTaskP->c3 ;
    grabS& g2   = *(grabS*)pTaskP->c2 ;
    grabS& g1   = *(grabS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmLockupF )
#if defined( NEVERdEFINED )

#endif
DONE( tmBlammoF )
TELL( "cleaning up")

}
    BLAMMO ;
    etThread.beeClickF( tinP ) ;
    TELL( "blammo")
{
if( !ether )

}
    ++ s ; ether.osSleepF( tinP , TOCK * 0x20 , 0 , flSLEEP_TALK ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{
TELL( "napping before blammo")
if( _restart ) CONoUTrAW( "the tmBlammoF thread has been restarted\r\n" ) ;
RESTART
TASK( tmBlammoF )
#if defined( NEVERdEFINED )

DONE( tmWhereRptF )
tinP.idPhase2 = 0 ;
TELL( "i'm outa here" )
}
    bDestroyCircleMonitor = 1 ;
    thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_SUPPRESStELLS ;
    TELL( "cleaning up" )
    }
        }
            }
                ++ s ; etThread.osSleepF( tinP , TUCK * 0x10 ) ;
                //etThread.strokeF( tinP , T("\r        \r")+TF1(cToDo) ) ;
            {
            while( !etThread && !sgnDone_tmWhereF && cToDo -- )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        TELL( "sleeping for up to 1 tick" )
        countT cToDo = TUCK * 0x10 ;
        //etThread.strokeF( tinP , T("\r\nwrote where report ")+TF1(idReport)+T("\r\n") ) ;

        //tinP.flagsThreadMode1 &= ~( F(flTHREADmODE1_DISALLOWtELLmONITOR) ) ;
            
        //Beep( 0x200 , 0x30 ) ;

        }
            etThread.delF( tinP , psttFileName ) ;
            etThread.delF( tinP , postBody ) ;
            }
                }
                    while( !etThread ) ;
                    }
                        else break ;
                        }
                            etThread.osSleepF( tinP , TUCK * 0x40 ) ;
                            POOPR
                        {
                        if( POOP )
                        fileWriteGF( T(psttFileName) , postBody , costBody ) ;
                    {
                    do
                    POOPIES
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                {
                etThread.delF( tinP , psttBody ) ;
                countT costBody = etThread.strMakeF( tinP , LF , postBody , psttBody ) ; ___( postBody ) ;
            {
            else
            if( sgnDone_tmWhereF ) etThread.delF( tinP , psttBody ) ;
            ZE( osTextT* , postBody ) ;
            TELL( "writing the report to disk" )

            st_psttrBody  >> psttBody ;
            st_psttrFileName >> psttFileName ;
            ZE( strokeS* , psttBody  ) ;
            ZE( strokeS* , psttFileName ) ;
        {
        while( st_psttrFileName )
        __( st_psttrFileName - st_psttrBody ) ;

        stTinWhereP.ungrabF( tinP ) ;
        if( !sgnDone_tmWhereF ) writeFineReportF( tinP , etThread , st_psttrBody , st_psttrFileName , swWhereTalliesFineClass , (byteT*)&c4leverTalliesFineClass , sizeof c4leverTalliesFineClass , stLifiP , idReport , stFlavor , stRecycle_pwtFineP , IDtYPErPT_CLASS  ) ;
        if( !sgnDone_tmWhereF ) writeFineReportF( tinP , etThread , st_psttrBody , st_psttrFileName , swWhereTalliesFineAdam  , (byteT*)&c4leverTalliesFineAdam  , sizeof c4leverTalliesFineAdam  , stLifiP , idReport , stFlavor , stRecycle_pwtFineP , IDtYPErPT_ADAM   ) ;
        if( !sgnDone_tmWhereF ) writeFineReportF( tinP , etThread , st_psttrBody , st_psttrFileName , swWhereTalliesFinePhase , (byteT*)&c5leverTalliesFinePhase , sizeof c5leverTalliesFinePhase , stLifiP , idReport , stFlavor , stRecycle_pwtFineP , IDtYPErPT_THREAD ) ;

        swWhereTalliesGrossPhase.ungrabF( tinP ) ;
        swWhereTalliesGrossPhase.freeNullsF( tinP ) ;
        }
            }
                pwtg = 0 ;
                stRecycle_pwtGrossP << (countT)pwtg ;
                pwtg->purgeF( tinP ) ;
                }
                    TELL( "cleaning up for this subject" )
            
                    st_psttrBody  << psttr ;
                    st_psttrFileName << psttOldC( tinP , etThread , tFileName ) ;
                    if( !psttr ) psttr = psttOldC( tinP , etThread , T("") ) ; //MIGHT BE 0 IF sgnDone_tmWhereF
                    }
                        etThread.delF( tinP , psttw ) ;
                        tFileName = T("\\")+T(psttw ) ;
                        etThread.strToFileNameF( tinP , psttw ) ;
                        etThread.strMakeF( tinP , LF , psttw , T("ideafarm.rpt.monitor.where.gross.thread.")+TF1(c4leverTalliesGrossPhase.c1)+T(".")+TF1(c4leverTalliesGrossPhase.c2)+T(".")+tLifiName+T(".")+TF1(c4leverTalliesGrossPhase.c3)+T(".")+TF1(c4leverTalliesGrossPhase.c4) ) ; ___( psttw ) ;
                        ZE( strokeS* , psttw ) ;
                    {
                    TN( tFileName , "" ) ;

                    etThread.strFuseF( tinP , psttr , tNotesG ) ;
                    TELL( "report explanatory notes" )
            
                    pwtg->swTally.ungrabF( tinP ) ;
                    pwtg->purgeF( tinP ) ;
        
                    }
                        etThread.delF( tinP , pbc2 ) ;
                        }
                            etThread.strFuseF( tinP , psttr , TF3(pwtg->swTally,flFORMAT_UNSIGNED,9)+tName+tc ) ;
                            TN( tName , "" ) ; tName = T(processGlobal4I.mapWhat(pwtg->idWhatLever)) ;
        
                            pwtg->idWhatLever = pwtg->swTally.leverF( tinP , c2f.c2 ) ;
                            count2S& c2f = *(count2S*)pbc2 ;
                        {
                        if( pbc2 && !sgnDone_tmWhereF )
                        stFlavor >> pbc2 ;
                        ZE( byteT* , pbc2 ) ;
                    {
                    while( stFlavor )
                    TELL( "report sorted tally values" )
            
                    }
                        }
                            stFlavor.sinkF( tinP , countTC() , (byteT*)&c2f , flSTACKsINK_null , subtractTallyF ) ; //U::NEXT: GET THIS TO SORT PROPERLY ON pwtg->swTally
                            count2S c2f( vv , idf ) ;
                        {
                        if( tallyMin <= vv )
                        countT vv = pwtg->swTally ;
                        pwtg->idWhatLever = pwtg->swTally.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !sgnDone_tmWhereF ; idf ++ )
                    countT cFlavors = pwtg->swTally.cFlavorsF( tinP ) ;
                    TELL( "sorting the tally plates by tally value" )
        
                    }
                        etThread.strMakeF( tinP , LF , psttr , t1g+TT(timeN1,timeN2)+t2+TF1(idReport)+t21+TF1(c4leverTalliesGrossPhase.c1)+tp+TF1(c4leverTalliesGrossPhase.c2)+tb+tLifiName+t22+TF1(c4leverTalliesGrossPhase.c3)+t23+TF1(c4leverTalliesGrossPhase.c4)+tc+t6 , cstte ) ; ___( psttr ) ;
        
                        countT cstte = 0x1000 + t1g.csF( tinP ) + t2.csF( tinP ) + t21.csF( tinP ) + t22.csF( tinP ) + t23.csF( tinP ) + t6.csF( tinP ) + tNotesG.csF( tinP ) + cLines * 0x200 ;
        
                        }
                            if( tallyMin <= vv ) cLines ++ ;
                            countT vv = pwtg->swTally ; //ASSUME: vv CANNOT BE 0
                            pwtg->idWhatLever = pwtg->swTally.leverF( tinP , idf ) ;

                        {
                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        tallyMin >>= 8 ; //THREASHHOLD
                        }
                            if( tallyMin < vv ) tallyMin = vv ;
                            countT vv = pwtg->swTally ; //ASSUME: vv CANNOT BE 0
                            pwtg->idWhatLever = pwtg->swTally.leverF( tinP , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        countT cFlavors = pwtg->swTally.cFlavorsF( tinP ) ;
                        ZE( countT , cLines ) ;
                    {
                    if( !sgnDone_tmWhereF )
                    pwtg->swTally.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    ZE( strokeS* , psttr ) ;
                    ZE( countT , tallyMin ) ;
                    TELL( "report title" )
            
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                    TELL( "getting time" )

                    }
                        stLifiP.ungrabF( tinP ) ;
                        }
                            tLifiName = T(old.postName) ;
                            lifiEntryS& old = *(lifiEntryS*)&(countT&)stLifiP[ 0 ] ;
                        {
                        if( ids )
                        stLifiP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_lifiEntryS_F ) ;
                        stLifiP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                         ZE( countT , ids ) ;
                        lifiEntryS entry( tinP , c4leverTalliesGrossPhase.c1 , c4leverTalliesGrossPhase.c2 , "" ) ;
                    {
                    TN( tLifiName , "unknown" ) ;
            
                    //tinP.flagsThreadMode1 |= flTHREADmODE1_DISALLOWtELLmONITOR ;
                    pwtg->bNewWhereRpt = 0 ;
                {
                if( pwtg->bNewWhereRpt /*U:: && ( !stTinWhereP || idCycle % 0x10 == 1 ) */ ) //ONLY EVERY TICK IF AM WATCHING WHERE WO OR MORE THREADS ARE
            {
            if( pwtg )
            whereTalliesGrossS*& pwtg = *(whereTalliesGrossS**)&(countT&)swWhereTalliesGrossPhase ;
            c4leverTalliesGrossPhase = *(count4S*)(byteT*)swWhereTalliesGrossPhase.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors && !sgnDone_tmWhereF ; idf ++ )
        countT cFlavors = swWhereTalliesGrossPhase.cFlavorsF( tinP ) ;
        swWhereTalliesGrossPhase.grabF( tinP , TAG( TAGiDnULL ) ) ;
        stTinWhereP.grabF( tinP , TAG( TAGiDnULL ) ) ; //THIS IS TO ENSURE THAT NO TALLY IMAGES ARE COPIED WHILE I AM REPORTING
        stackC st_psttrBody ( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
        stackC st_psttrFileName( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;

        //Beep( 0x200 , 0x30 ) ;
        idReport ++ ;
    {
    while( !etThread && !sgnDone_tmWhereF )
    stackC stFlavor( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , 2 * sizeof( countT ) ) ;
    ;
        tb+T("inward tally: tally from the outermost caller inward")+tc
        T("[TI]")+tc+
        tb+T("of the work on the subject thread.")+tc2+
        tb+T("snippets.  use this report to discover which system functions are doing most")+tc+
        tb+T("executing in the indicated in/out snippet, excluding time spent in nested")+tc+
        tb+T("each line reports the number of times that the subject thread was seen to be")+tc+
        tb+T("fine tally: tally of the innermost callee")+tc+
        T("[TF]")+tc+
        tb+T("be useful only if macros are used in application code to identify in/out snippets.")+tc2+
        tb+T("account for most of the work that the subject thread is doing. this report will")+tc+
        tb+T("this report only).  use this report to discover which broad sections of application code")+tc+
        tb+T("snippet begins with the name of the tin line. if yes then it is uninteresting (for")+tc+
        tb+T("either interesting or uninteresting; this is determined by whether the name of the")+tc+
        tb+T("until an interesting snippet is found. in/out snippets in adam definitions can be")+tc+
        tb+T("some \"uninteresting\" in/out snipets are suppressed by walking up the call nest")+tc+
        tb+T("executing in the indicated in/out snippet or in a nested snippet.  for this report,")+tc+
        tb+T("each line reports the number of times that the subject thread was seen to be")+tc+
        tb+T("gross tally: tally of the outermost caller")+tc+
        T("[TG]")+tc+
        tb+T("were all observed since the lath set of reports were written")+tc2+
        tb+T("just before unblocking sampling, i purge the tallies.  thus the tallies shown")+tc+
        tb+T("sampling does not occur while i am inspecting the tallies and compiling my reports")+tc+
        T("general note: effect of reporting on sampling")+tc+
        tb+T("if possible, a name for that in/out snippet is also reported")+tc2+
        tb+T("executing.  the line and file id of the in/out snippet is always reported. if")+tc+
        tb+T("source file. this report presents tallies of where the monitor has seen the indicated thread")+tc+
        tb+T("snippet.  every code line is identified by 2 numbers: an id for the line and an id for the")+tc+
        tb+T("call nest visibility is based on the identity of the woth code line of each in/out")+tc+
        T("general note: where sampling")+tc+
        tb+T("snippet is also visible.")+tc2+
        tb+T("adam definitions can define in/out snippets.  entry into and exit from such a")+tc+
        tb+T("visible.  entry into almost all system functions is visible in this way.  code in")+tc+
        tb+T("for example, when execution enters the definition of a system function, this is")+tc+
        tb+T("the tinS for each thread makes the current call nest for that thread visible.")+tc+
        T("general note: in/out source code snippets")+tc+
        tb+T("any executable source code line can be named.")+tc2+
        tb+T("given the name of the thread, i.e. it is given the name tinP.postThreadName.")+tc+
        tb+T("the constructor for the tinS of each thread, the \"tin line for the thread\", is")+tc+
        tb+T("the woth time that the line is executed.  the system source code line that calls")+tc+
        tb+T("any source code line can be named.  such names are calculated at early run time,")+tc+
        T("general note: named source code lines")+tc+
        tb+T("is to set idPhase2 to 1 if no particular value is preferred.")+tc2+
        tb+T("however, if idPhase3 is used, idPhase2 must be set to a nonze""ro value.  good style")+tc+
        tb+T("idPhase2, idPhase3 can represent any meaning; it is only used as a sort value.")+tc+
        tb+T("tinS::idPhase3 is provided so the another level of subdivision is possible.  like")+tc+
        tb+T("identify a particular data structure or socket client that is being serviced by the thread.")+tc+
        tb+T("setup, thread working, and thread cleanup, respectively.  or idPhase2 could be set to")+tc+
        tb+T("each instance of a thread class.  or idPhase2 can be set to 1,2,3 to indicate thread")+tc+
        tb+T("could be used, which would cause the monitor to write a separate where report for")+tc+
        tb+T("value can be used; this value is used only as a sort value. for example, tinS::idThread")+tc+
        tb+T("code can easily subdivide these subjects at run time by setting tinS::idPhase2. any")+tc+
        tb+T("each of these reports focuses on a single \"subject\".  unless subdivided by application")+tc+
        T("general note: the scope of this report (its \"subject\") (part 2 of 2)")+tc+
        tb+T("its subject is the code snippet \"tmFooF\".")+tc2+
        tb+T("etherC::osThreadF are the subject of wo of these reports; that report will indicate that")+tc+
        tb+T("thread main function then all threads launched by specifying \"tmFooF\" in a call to")+tc+
        tb+T("all threads launched with a specific thread main function.  for example, if tmFooF is a")+tc+
        tb+T("code, the subject of each reports is a single thread class.  \"thread class\" refers to")+tc+
        tb+T("each of these reports focuses on a single \"subject\".  unless subdivided by application")+tc+
        T("general note: the scope of this report (its \"subject\") (part 1 of 2)")+tc+
        tb+T("idReport: the number of generations of this report written since the IdeaFarm " "(tm) Operating System was started on this computer")+tc2+
        tb+T("the time of the report is represented according to the customs of IdeaFarm " "(tm) City")+tc+
        tb+T("(\"01 tock\" means 16 (base 10) tocks, or approximately 30 seconds)")+tc+
        tb+T("(a tock is approximately 1.33 seconds")+tc+
        tb+T("Local Monitor Report: this report is written every 01 tock by the IdeaFarm " "(tm) Operating System")+tc+
        tb+T("these programs are called \"IdeaFarm " "(tm) Cells\"")+tc+
        tb+T("some programs on this computer are using the IdeaFarm " "(tm) Operating System")+tc+
        tb+T("IdeaFarm " "(tm) Operating System: runs \"on top of\" this computer's base operating system (e.g. MS Windows)")+tc+
        tb+T("for support, see http://www.ideafarm.com or call Wo'O Ideafarm US 650-759-5306")+tc+
        T("[ID]")+tc+
        TPS(" \r\nexplanatory notes ",0x40,S1C('-'))+tc2+
    TN( tNotesF , "" ) ; tNotesF =
    ;
        tb+T("what tally: tally of what kind of code the thread is executing")+tc2
        T("[TW]")+tc+
        T("general notes: see the general notes for the Where Tallies Fine reports")+tc2+
        tb+T("idReport: the number of generations of this report written since the IdeaFarm " "(tm) Operating System was started on this computer")+tc2+
        tb+T("the time of the report is represented according to the customs of IdeaFarm " "(tm) City")+tc+
        tb+T("(\"01 tock\" means 16 (base 10) tocks, or approximately 30 seconds)")+tc+
        tb+T("(a tock is approximately 1.33 seconds")+tc+
        tb+T("Local Monitor Report: this report is written every 01 tock by the IdeaFarm " "(tm) Operating System")+tc+
        tb+T("these programs are called \"IdeaFarm " "(tm) Cells\"")+tc+
        tb+T("some programs on this computer are using the IdeaFarm " "(tm) Operating System")+tc+
        tb+T("IdeaFarm " "(tm) Operating System: runs \"on top of\" this computer's base operating system (e.g. MS Windows)")+tc+
        tb+T("for support, see http://www.ideafarm.com or call Wo'O Ideafarm US 650-759-5306")+tc+
        T("[ID]")+tc+
        TPS(" \r\nexplanatory notes ",0x40,S1C('-'))+tc2+
    TN( tNotesG , "" ) ; tNotesG =
    TN( tp , "." ) ;
    TN( tcb , ": " ) ;
    TN( tqc , "\"\r\n" ) ;
    TN( tq , "\"" ) ;
    TN( t6 , " \r\n[TW]\r\n" ) ;
    TN( t5 , " \r\n[TI]\r\n" ) ;
    TN( t4 , " \r\n[TF]\r\n" ) ;
    TN( t3 , "\r\n \r\n[TG]\r\n" ) ;
    TN( t23 , "\r\nSubPhase: " ) ;
    TN( t225 , "\r\nWhere: " ) ;
    TN( t22 , "\r\nPhase: " ) ;
    TN( t21 , "\r\nCode Snippet: " ) ;
    TN( t2 , "\r\nidReport: " ) ;
    TN( t1f , "[ID]\r\nIdeaFarm " "(tm) Operating System\r\nLocal Monitor Where Tallies Fine\r\n(see the explanatory notes at the end of this report)\r\n" ) ;
    TN( t1g , "[ID]\r\nIdeaFarm " "(tm) Operating System\r\nLocal Monitor Where Tallies Gross\r\n(see the explanatory notes at the end of this report)\r\n" ) ;
    TN( tb , " " ) ;
    TN( tc2 , "\r\n \r\n" ) ;
    TN( tc , "\r\n" ) ;
    ZE( countT , idReport ) ;
    ZE( countT , idCycle ) ;

    //CONoUTrAW3( "tmWhereRpt/" , *(countT*)( (byteT*)*(batonC**)&swWhereTalliesFineClass + 0x10c ) , "\r\n" ) ; //U::

    stackC&             stRecycle_pwtFineP         =             *(stackC*)c8t3P.c5 ;
    stackC&             stRecycle_pwtGrossP        =             *(stackC*)c8t3P.c4 ;
    whereTalliesGrossS& wtGrossHostP               = *(whereTalliesGrossS*)c8t3P.c3 ;
    stackC&             stWhereP                   =             *(stackC*)c8t3P.c2 ;
    stackC&             stLifiP                    =             *(stackC*)c8t3P.c1 ;
    stackC&             stTinWhereP                =             *(stackC*)c8t2P.c8 ;
    switchC&            swWhereTallyActiveThread   =            *(switchC*)c8t2P.c7 ;
    count5S&            c5leverTallyActiveThread   =            *(count5S*)c8t2P.c6 ;
    switchC&            swWhereTalliesFineClass    =            *(switchC*)c8t2P.c5 ;
    count4S&            c4leverTalliesFineClass    =            *(count4S*)c8t2P.c4 ;
    switchC&            swWhereTalliesFineAdam     =            *(switchC*)c8t2P.c3 ;
    count4S&            c4leverTalliesFineAdam     =            *(count4S*)c8t2P.c2 ;
    switchC&            swWhereTalliesFinePhase    =            *(switchC*)c8t2P.c1 ;
    count5S&            c5leverTalliesFinePhase    =            *(count5S*)c8t1P.c8 ;
    switchC&            swWhereTalliesGrossPhase   =            *(switchC*)c8t1P.c7 ;
    count4S&            c4leverTalliesGrossPhase   =            *(count4S*)c8t1P.c6 ;
    switchC&            swWhereTalliesGrossClass   =            *(switchC*)c8t1P.c5 ;
    countT&             cLeverTalliesGrossClass    =             *(countT*)c8t1P.c4 ;
    boolT&              bDestroyCircleMonitor      =              *(boolT*)c8t1P.c3 ;
    signC&              sgnDone_tmWhereF           =              *(signC*)c8t1P.c2 ;
    signC&              sgnDone_tmRptPoolF         =              *(signC*)c8t1P.c1 ;
    count8S&            c8t3P                      =             *(count8S*)c3pP.c3 ;
    count8S&            c8t2P                      =             *(count8S*)c3pP.c2 ;
    count8S&            c8t1P                      =             *(count8S*)c3pP.c1 ;
    count3S&            c3pP                       =          *(count3S*)pTaskP->c1 ;
    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 )
tinP.idPhase2 = 1 ;
TASK( tmWhereRptF )

}
    swP.ungrabF( tinP ) ;
    swP.freeNullsF( tinP ) ;
    }
        }
            pwtf = 0 ;
            stRecycle_pwtFineP << (countT)pwtf ;
            pwtf->purgeF( tinP ) ;
            }
                TELL( "cleaning up for this subject" )
        
                st_psttrBodyP  << psttr ;
                st_psttrFileNameP << psttOldC( tinP , etThread , tFileName ) ;
                }
                    etThread.delF( tinP , psttw ) ;
                    tFileName = T("\\")+T(psttw ) ;
                    etThread.strToFileNameF( tinP , psttw ) ;
                    etThread.strMakeF( tinP , LF , psttw , T("ideafarm.rpt.monitor.where.fine.")+T(bAdam?"adam.":(bClass?"class.":"thread."))+(bClass||bAdam?(bClass?T(processGlobal4I.mapAdamClass(c5l.c1)):TF1(c5l.c1)):TF1(c5l.c1)+T(".")+TF1(c5l.c2)+T(".")+tLifiName)+T(".")+TF1(processGlobal4I.mapWhat(bAdam||bClass?c5l.c2:c5l.c3))+T(".")+TF1(bAdam||bClass?c5l.c3:c5l.c4)+T(".")+TF1(bAdam||bClass?c5l.c4:c5l.c5) ) ; ___( psttw ) ;
                    ZE( strokeS* , psttw ) ;
                {
                TN( tFileName , "" ) ;

                etThread.strFuseF( tinP , psttr , tNotesF ) ;
                TELL( "report explanatory notes" )
        
                pwtf->swTally3.ungrabF( tinP ) ;
                pwtf->swTally2.ungrabF( tinP ) ;
                pwtf->swTally1.ungrabF( tinP ) ;
                pwtf->purgeF( tinP ) ;
    
                }
                    etThread.delF( tinP , pbc2 ) ;
                    }
                        psttOldCallNestF( tinP , etThread , psttr , stLifiP , 9 , pwtf->pczLever3 , 0 ) ;
                        etThread.strFuseF( tinP , psttr , tc ) ;
                        psttOldCallNestF( tinP , etThread , psttr , stLifiP , 9 , pwtf->pczLever3 , 1 ) ;
                     }
                            etThread.strFuseF( tinP , psttr , TPS((osTextT*)tw1,8,S1C(':'))+tb ) ;
                            TN( tw1 , "" ) ; tw1 = TF2(pwtf->swTally3,flFORMAT_UNSIGNED) ;
                        {
                        pwtf->pczLever3 = (countT*)pwtf->swTally3.leverF( tinP , c2f.c2 ) ;
                        count2S& c2f = *(count2S*)pbc2 ;
                    {
                    if( pbc2 && cFlavorLimit && cFlavorLimit -- )
                    stFlavorP >> pbc2 ;
                    ZE( byteT* , pbc2 ) ;
                {
                while( stFlavorP )
                countT cFlavorLimit = 8 ;
                TELL( "report sorted tally 3 values" )
        
                }
                    }
                        stFlavorP.sinkF( tinP , countTC() , (byteT*)&c2f , flSTACKsINK_null , subtractTallyF ) ; //U::NEXT: GET THIS TO SORT PROPERLY ON pwtf->swTally3
                        count2S c2f( vv , idf ) ;
                    {
                    if( tallyMin3 <= vv )
                    countT vv = pwtf->swTally3 ;
                    pwtf->pczLever3 = (countT*)pwtf->swTally3.leverF( tinP , idf ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                cFlavors = pwtf->swTally3.cFlavorsF( tinP ) ;
                TELL( "sorting the tally 3 plates by tally value" )
    
                etThread.strFuseF( tinP , psttr , t5 ) ; ___( psttr ) ;
        
                }
                    etThread.delF( tinP , pbc2 ) ;
                    }
                        etThread.strFuseF( tinP , psttr , TF3(pwtf->swTally2,flFORMAT_UNSIGNED,9)+TF4(pwtf->lifiLever2.c1,flFORMAT_UNSIGNED,0xc,0xa)+TF3(pwtf->lifiLever2.c2,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+tb+tName+tc ) ;
    
                        }
                            stLifiP.ungrabF( tinP ) ;
                            }
                                tName = T(old.postName) ;
                                lifiEntryS& old = *(lifiEntryS*)&(countT&)stLifiP[ 0 ] ;
                            {
                            if( ids )
                            stLifiP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_lifiEntryS_F ) ;
                            stLifiP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            ZE( countT , ids ) ;
                            lifiEntryS entry( tinP , pwtf->lifiLever2.c1 , pwtf->lifiLever2.c2 , "" ) ;
                        {
                        if( !tName.csF( tinP ) )
                        TN( tName , "" ) ; tName = T(processGlobal8I.source.postFileTitleF(tinP,processGlobal8I.source.idFileRankF(tinP,pwtf->lifiLever2.c2))) ;
    
                        pwtf->lifiLever2 = *(count2S*)(byteT*)pwtf->swTally2.leverF( tinP , c2f.c2 ) ;
                        count2S& c2f = *(count2S*)pbc2 ;
                    {
                    if( pbc2 )
                    stFlavorP >> pbc2 ;
                    ZE( byteT* , pbc2 ) ;
                {
                while( stFlavorP )
                TELL( "report sorted tally 2 values" )
        
                }
                    }
                        stFlavorP.sinkF( tinP , countTC() , (byteT*)&c2f , flSTACKsINK_null , subtractTallyF ) ; //U::NEXT: GET THIS TO SORT PROPERLY ON pwtf->swTally2
                        count2S c2f( vv , idf ) ;
                    {
                    if( tallyMin2 <= vv )
                    countT vv = pwtf->swTally2 ;
                    pwtf->lifiLever2 = *(count2S*)(byteT*)pwtf->swTally2.leverF( tinP , idf ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                cFlavors = pwtf->swTally2.cFlavorsF( tinP ) ;
                TELL( "sorting the tally 2 plates by tally value" )
    
                etThread.strFuseF( tinP , psttr , t4 ) ; ___( psttr ) ;
    
                }
                    etThread.delF( tinP , pbc2 ) ;
                    }
                        etThread.strFuseF( tinP , psttr , TF3(pwtf->swTally1,flFORMAT_UNSIGNED,9)+TF4(pwtf->lifiLever1.c1,flFORMAT_UNSIGNED,0xc,0xa)+TF3(pwtf->lifiLever1.c2,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+tb+tName+tc ) ;
    
                        }
                            stLifiP.ungrabF( tinP ) ;
                            }
                                tName = T(old.postName) ;
                                lifiEntryS& old = *(lifiEntryS*)&(countT&)stLifiP[ 0 ] ;
                            {
                            if( ids )
                            stLifiP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_lifiEntryS_F ) ;
                            stLifiP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            ZE( countT , ids ) ;
                            lifiEntryS entry( tinP , pwtf->lifiLever1.c1 , pwtf->lifiLever1.c2 , "" ) ;
                        {
                        if( !tName.csF( tinP ) )
                        TN( tName , "" ) ; tName = T(processGlobal8I.source.postFileTitleF(tinP,processGlobal8I.source.idFileRankF(tinP,pwtf->lifiLever1.c2))) ;
    
                        pwtf->lifiLever1 = *(count2S*)(byteT*)pwtf->swTally1.leverF( tinP , c2f.c2 ) ;
                        count2S& c2f = *(count2S*)pbc2 ;
                    {
                    if( pbc2 )
                    stFlavorP >> pbc2 ;
                    ZE( byteT* , pbc2 ) ;
                {
                while( stFlavorP )
                TELL( "report sorted tally 1 values" )
        
                }
                    }
                        stFlavorP.sinkF( tinP , countTC() , (byteT*)&c2f , flSTACKsINK_null , subtractTallyF ) ; //U::NEXT: GET THIS TO SORT PROPERLY ON pwtf->swTally1
                        count2S c2f( vv , idf ) ;
                    {
                    if( tallyMin1 <= vv )
                    countT vv = pwtf->swTally1 ;
                    pwtf->lifiLever1 = *(count2S*)(byteT*)pwtf->swTally1.leverF( tinP , idf ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                countT cFlavors = pwtf->swTally1.cFlavorsF( tinP ) ;
                TELL( "sorting the tally 1 plates by tally value" )
    
                }
                    etThread.strMakeF( tinP , LF , psttr , t1f+TT(timeN1,timeN2)+t2+TF1(idReportP)+(bAdam?t21b+TF1(c5l.c1):bClass?t21c+TF1(processGlobal4I.mapAdamClass(c5l.c1)):t21+TF1(c5l.c1)+tp+TF1(c5l.c2)+tb+tLifiName)+t225+T(processGlobal4I.mapWhat(bAdam||bClass?c5l.c2:c5l.c3))+t22+TF1(bAdam||bClass?c5l.c3:c5l.c4)+t23+TF1(bAdam||bClass?c5l.c4:c5l.c5)+t3 , cstte ) ; ___( psttr ) ;
                    countT cstte = 0x1000 + t1f.csF( tinP ) + t2.csF( tinP ) + t21.csF( tinP ) + t22.csF( tinP ) + t23.csF( tinP ) + t3.csF( tinP ) + t4.csF( tinP ) + t5.csF( tinP ) + tNotesF.csF( tinP ) + cLines * 0x200 ;
    
                    }
                        }
                            if( cc > 1 ) cLines += ( cc - 2 ) / 2 ;
                            countT cc = etThread.strBodyLengthF( tinP , (countT*)pwtf->swTally3.leverF( tinP , idf ) ) ;
                        {
                        if( tallyMin3 <= vv )
                        countT vv = pwtf->swTally3 ; //ASSUME: vv CANNOT BE 0
                        pwtf->pczLever3 = (countT*)pwtf->swTally3.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    tallyMin3 >>= 8 ; //THREASHHOLD
                    }
                        if( tallyMin3 < vv ) tallyMin3 = vv ;
                        countT vv = pwtf->swTally3 ; //ASSUME: vv CANNOT BE 0
                        pwtf->pczLever3 = (countT*)pwtf->swTally3.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    cFlavors = pwtf->swTally3.cFlavorsF( tinP ) ;
    
                    }
                        if( tallyMin2 <= vv ) cLines ++ ;
                        countT vv = pwtf->swTally2 ; //ASSUME: vv CANNOT BE 0
                        pwtf->lifiLever2 = *(count2S*)(byteT*)pwtf->swTally2.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    tallyMin2 >>= 8 ; //THREASHHOLD
                    }
                        if( tallyMin2 < vv ) tallyMin2 = vv ;
                        countT vv = pwtf->swTally2 ; //ASSUME: vv CANNOT BE 0
                        pwtf->lifiLever2 = *(count2S*)(byteT*)pwtf->swTally2.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    cFlavors = pwtf->swTally2.cFlavorsF( tinP ) ;
    
                    }
                        if( tallyMin1 <= vv ) cLines ++ ;
                        countT vv = pwtf->swTally1 ; //ASSUME: vv CANNOT BE 0
                        pwtf->lifiLever1 = *(count2S*)(byteT*)pwtf->swTally1.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    tallyMin1 >>= 8 ; //THREASHHOLD
                    }
                        if( tallyMin1 < vv ) tallyMin1 = vv ;
                        countT vv = pwtf->swTally1 ; //ASSUME: vv CANNOT BE 0
                        pwtf->lifiLever1 = *(count2S*)(byteT*)pwtf->swTally1.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = pwtf->swTally1.cFlavorsF( tinP ) ;
                    ZE( countT , cLines ) ;
                {
                pwtf->swTally3.grabF( tinP , TAG( TAGiDnULL ) ) ;
                pwtf->swTally2.grabF( tinP , TAG( TAGiDnULL ) ) ;
                pwtf->swTally1.grabF( tinP , TAG( TAGiDnULL ) ) ;
                ZE( strokeS* , psttr ) ;
                ZE( countT , tallyMin4 ) ;
                ZE( countT , tallyMin3 ) ;
                ZE( countT , tallyMin2 ) ;
                ZE( countT , tallyMin1 ) ;
                TELL( "report title" )
        
                etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT , timeN1 ) ;
                TELL( "getting time" )

                }
                    stLifiP.ungrabF( tinP ) ;
                    }
                        tLifiName = T(old.postName) ;
                        lifiEntryS& old = *(lifiEntryS*)&(countT&)stLifiP[ 0 ] ;
                    {
                    if( ids )
                    stLifiP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_lifiEntryS_F ) ;
                    stLifiP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                     ZE( countT , ids ) ;
                    lifiEntryS entry( tinP , c5l.c1 , c5l.c2 , "" ) ;
                {
                if( !bAdam && !bClass )
                TN( tLifiName , "unknown" ) ;
        
                //tinP.flagsThreadMode1 |= flTHREADmODE1_DISALLOWtELLmONITOR ;
                pwtf->bNewWhereRpt = 0 ;
            {
            if( pwtf->bNewWhereRpt /*U:: && ( !stTinWhereP || idCycle % 0x10 == 1 ) */ ) //ONLY EVERY TICK IF AM WATCHING WHERE WO OR MORE THREADS ARE
        {
        if( pwtf )
        whereTalliesFineS*& pwtf = *(whereTalliesFineS**)&(countT&)swP ;
        etThread.memCopyF( tinP , pbLeverP , (byteT*)swP.leverF( tinP , idf ) , cbLeverP ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swP.cFlavorsF( tinP ) ;
    swP.grabF( tinP , TAG( TAGiDnULL ) ) ;

    ;
        tb+T("inward tally: tally from the outermost caller inward")+tc
        T("[TI]")+tc+
        tb+T("of the work on the subject thread.")+tc2+
        tb+T("snippets.  use this report to discover which system functions are doing most")+tc+
        tb+T("executing in the indicated in/out snippet, excluding time spent in nested")+tc+
        tb+T("each line reports the number of times that the subject thread was seen to be")+tc+
        tb+T("fine tally: tally of the innermost callee")+tc+
        T("[TF]")+tc+
        tb+T("be useful only if macros are used in application code to identify in/out snippets.")+tc2+
        tb+T("account for most of the work that the subject thread is doing. this report will")+tc+
        tb+T("this report only).  use this report to discover which broad sections of application code")+tc+
        tb+T("snippet begins with the name of the tin line. if yes then it is uninteresting (for")+tc+
        tb+T("either interesting or uninteresting; this is determined by whether the name of the")+tc+
        tb+T("until an interesting snippet is found. in/out snippets in adam definitions can be")+tc+
        tb+T("some \"uninteresting\" in/out snipets are suppressed by walking up the call nest")+tc+
        tb+T("executing in the indicated in/out snippet or in a nested snippet.  for this report,")+tc+
        tb+T("each line reports the number of times that the subject thread was seen to be")+tc+
        tb+T("gross tally: tally of the outermost caller")+tc+
        T("[TG]")+tc+
        tb+T("were all observed since the lath set of reports were written")+tc2+
        tb+T("just before unblocking sampling, i purge the tallies.  thus the tallies shown")+tc+
        tb+T("sampling does not occur while i am inspecting the tallies and compiling my reports")+tc+
        T("general note: effect of reporting on sampling")+tc+
        tb+T("if possible, a name for that in/out snippet is also reported")+tc2+
        tb+T("executing.  the line and file id of the in/out snippet is always reported. if")+tc+
        tb+T("source file. this report presents tallies of where the monitor has seen the indicated thread")+tc+
        tb+T("snippet.  every code line is identified by 2 numbers: an id for the line and an id for the")+tc+
        tb+T("call nest visibility is based on the identity of the woth code line of each in/out")+tc+
        T("general note: where sampling")+tc+
        tb+T("snippet is also visible.")+tc2+
        tb+T("adam definitions can define in/out snippets.  entry into and exit from such a")+tc+
        tb+T("visible.  entry into almost all system functions is visible in this way.  code in")+tc+
        tb+T("for example, when execution enters the definition of a system function, this is")+tc+
        tb+T("the tinS for each thread makes the current call nest for that thread visible.")+tc+
        T("general note: in/out source code snippets")+tc+
        tb+T("any executable source code line can be named.")+tc2+
        tb+T("given the name of the thread, i.e. it is given the name tinP.postThreadName.")+tc+
        tb+T("the constructor for the tinS of each thread, the \"tin line for the thread\", is")+tc+
        tb+T("the woth time that the line is executed.  the system source code line that calls")+tc+
        tb+T("any source code line can be named.  such names are calculated at early run time,")+tc+
        T("general note: named source code lines")+tc+
        tb+T("is to set idPhase2 to 1 if no particular value is preferred.")+tc2+
        tb+T("however, if idPhase3 is used, idPhase2 must be set to a nonze""ro value.  good style")+tc+
        tb+T("idPhase2, idPhase3 can represent any meaning; it is only used as a sort value.")+tc+
        tb+T("tinS::idPhase3 is provided so the another level of subdivision is possible.  like")+tc+
        tb+T("identify a particular data structure or socket client that is being serviced by the thread.")+tc+
        tb+T("setup, thread working, and thread cleanup, respectively.  or idPhase2 could be set to")+tc+
        tb+T("each instance of a thread class.  or idPhase2 can be set to 1,2,3 to indicate thread")+tc+
        tb+T("could be used, which would cause the monitor to write a separate where report for")+tc+
        tb+T("value can be used; this value is used only as a sort value. for example, tinS::idThread")+tc+
        tb+T("code can easily subdivide these subjects at run time by setting tinS::idPhase2. any")+tc+
        tb+T("each of these reports focuses on a single \"subject\".  unless subdivided by application")+tc+
        T("general note: the scope of this report (its \"subject\") (part 2 of 2)")+tc+
        tb+T("its subject is the code snippet \"tmFooF\".")+tc2+
        tb+T("etherC::osThreadF are the subject of wo of these reports; that report will indicate that")+tc+
        tb+T("thread main function then all threads launched by specifying \"tmFooF\" in a call to")+tc+
        tb+T("all threads launched with a specific thread main function.  for example, if tmFooF is a")+tc+
        tb+T("code, the subject of each reports is a single thread class.  \"thread class\" refers to")+tc+
        tb+T("each of these reports focuses on a single \"subject\".  unless subdivided by application")+tc+
        T("general note: the scope of this report (its \"subject\") (part 1 of 2)")+tc+
        tb+T("idReport: the number of generations of this report written since the IdeaFarm " "(tm) Operating System was started on this computer")+tc2+
        tb+T("the time of the report is represented according to the customs of IdeaFarm " "(tm) City")+tc+
        tb+T("(\"01 tock\" means 16 (base 10) tocks, or approximately 30 seconds)")+tc+
        tb+T("(a tock is approximately 1.33 seconds")+tc+
        tb+T("Local Monitor Report: this report is written every 01 tock by the IdeaFarm " "(tm) Operating System")+tc+
        tb+T("these programs are called \"IdeaFarm " "(tm) Cells\"")+tc+
        tb+T("some programs on this computer are using the IdeaFarm " "(tm) Operating System")+tc+
        tb+T("IdeaFarm " "(tm) Operating System: runs \"on top of\" this computer's base operating system (e.g. MS Windows)")+tc+
        tb+T("for support, see http://www.ideafarm.com or call Wo'O Ideafarm US 650-759-5306")+tc+
        T("[ID]")+tc+
        TPS(" \r\nexplanatory notes ",0x40,S1C('-'))+tc2+
    TN( tNotesF , "" ) ; tNotesF =
    TN( tp , "." ) ;
    TN( tcb , ": " ) ;
    TN( tqc , "\"\r\n" ) ;
    TN( tq , "\"" ) ;
    TN( t6 , " \r\n[TW]\r\n" ) ;
    TN( t5 , " \r\n[TI]\r\n" ) ;
    TN( t4 , " \r\n[TF]\r\n" ) ;
    TN( t3 , "\r\n \r\n[TG]\r\n" ) ;
    TN( t23 , "\r\nSubPhase: " ) ;
    TN( t225 , "\r\nWhat: " ) ;
    TN( t22 , "\r\nPhase: " ) ;
    TN( t21c , "\r\nCellClass: " ) ;
    TN( t21b , "\r\nCell: " ) ;
    TN( t21 , "\r\nThread: " ) ;
    TN( t2 , "\r\nidReport: " ) ;
    TN( t1f , "[ID]\r\nIdeaFarm " "(tm) Operating System\r\nLocal Monitor Where Tallies Fine\r\n(see the explanatory notes at the end of this report)\r\n" ) ;
    TN( t1g , "[ID]\r\nIdeaFarm " "(tm) Operating System\r\nLocal Monitor Where Tallies Gross\r\n(see the explanatory notes at the end of this report)\r\n" ) ;
    TN( tb , " " ) ;
    TN( tc2 , "\r\n \r\n" ) ;
    TN( tc , "\r\n" ) ;

    boolT    bClass = idTypeP == IDtYPErPT_CLASS ;
    boolT    bAdam  = idTypeP == IDtYPErPT_ADAM ;
    count5S& c5l    = *(count5S*)pbLeverP ;
{
voidT writeFineReportF( tinS& tinP , etherC& etThread , stackC& st_psttrBodyP , stackC& st_psttrFileNameP , switchC& swP , byteT* const pbLeverP , const countT cbLeverP , stackC& stLifiP , const countT idReportP , stackC& stFlavorP , stackC& stRecycle_pwtFineP , const countT idTypeP )
#define IDtYPErPT_HOST           0x4
#define IDtYPErPT_CLASS          0x3
#define IDtYPErPT_ADAM           0x2
#define IDtYPErPT_THREAD         0x1

DONE( tmWhereF )
tinP.idPhase2 = 0 ;
}
    }
        TELL( "awakening" )
        }
            ++ s ; etThread.osSleepF( tinP ,TUCK * 0x10 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( !etThread && !sgnDone_tmRptPoolF )
        TELL( "going to raw nap" )

#endif
//U::
        }
            }
                }
                    }
                        TALLY( Fine  , Phase , c5lever  , c5lvf , (countT)&c5lvf )
                        _IO_
                    {
                    }
                        TALLY( Gross , Phase , c4lever  , c4lvg , (countT)&c4lvg )
                        _IO_
                    {
                    count5S c5lvf( copy1.idLineTinCt & 0xfff , copy1.idiFileTinCt , copy1.idWhat , copy1.idPhase , copy1.idPhase3 ) ;
                    count4S c4lvg( copy1.idLineTinCt & 0xfff , copy1.idiFileTinCt , copy1.idPhase , copy1.idPhase3 ) ;
                    _IO_
                {
                if( copy1.idPhase )
    
                }
                    }
                        TALLY( Fine  , Adam  , c4lever , c4lva       , (countT)&c4lva )
                        _IO_
                    {
                    }
                        TALLY( Fine  , Class , c4lever , c4lvc       , (countT)&c4lvc )
                        _IO_
                    {
                    }
                        TALLY( Gross , Class , cLever  , idAdamClass , idAdamClass    )
                        _IO_
                    {
                    count4S c4lva( copy1.idAdamRoot , copy1.idWhat , copy1.idPhase , copy1.idPhase3 ) ;
                    count4S c4lvc( idAdamClass              , copy1.idWhat , copy1.idPhase , copy1.idPhase3 ) ;
                    _IO_
                {
                if( copy1.idAdamRoot )
    
                }
                    default                       : { idAdamClass = ifcIDaDAMcLASS_APPLICATIONS   ; break ; }
                    case ifcIDaDAM_KERNEL3BANG    : { idAdamClass = ifcIDaDAMcLASS_KERNEL3BANG    ; break ; }
                    case ifcIDaDAM_KERNEL2MONITOR : { idAdamClass = ifcIDaDAMcLASS_KERNEL2MONITOR ; break ; }
                {
                if( copy1.idAdamRoot ) switch( copy1.idAdamRoot )
                ZE( countT , idAdamClass ) ;
    
                }
                    swWhereTallyActiveThread.ungrabF( tinP ) ;
                    ++ swWhereTallyActiveThread ;
                    c5leverTallyActiveThread = count5S( copy1.idLineTinCt , copy1.idiFileTinCt , copy1.idAdamRoot , copy1.idPhase , copy1.idPhase3 ) ;
                    swWhereTallyActiveThread.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    _IO_
                {
                if( copy1.idWhat > ifcIDwHAT_STOPnOWAITbOUNDARY )
    
                wtGrossHostP.swTally.ungrabF( tinP ) ;
                ++ wtGrossHostP.swTally ;
                wtGrossHostP.idWhatLever = copy1.idWhat ;
                wtGrossHostP.swTally.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( !sgnDone_tmRptPoolF )

            stWhereP >> pbCopy1 ;
            byteT* pbCopy1 = (byteT*)&copy1 ;
            whereOldS copy1 ;
            _IO_
        {
        while( stWhereP )
        TELL( "tallying" )

        stTinWhereP.ungrabF( tinP ) ;
        }
            while( !sgnDone_tmRptPoolF && !stTinWhereP.third && ~hDown ) ;
            }
                }
                    }
                        stWhereP << (byteT*)&copy1 ;
                        copy1.idiFileTinCt = entry.idiFileCt ;
                        copy1.idLineTinCt = entry.idLineCt ;
                    {
                    if( bOk && !sgnDone_tmRptPoolF )
    
                    }
                        }
                            }
                                }
                                    if( bOk ) bOk = !thirdC::c_memcmpIF( tinP , (byteT*)&copy1 , (byteT*)&copy2 , sizeof copy1 - CBwHEREsUFFIX ) && getNegAM( fingerprint1 ) == FINGERnEG_TINs && getNegAM( fingerprint2 ) == FINGERnEG_TINs ;
                                    thirdC::dosReadProcessMemoryIF( tinP , (byteT*)&fingerprint2 , sizeof fingerprint2 , bOk , (voidT*)entry.ip , entry.osPid ) ;
                                    bOk = 0 ;
                                {
                                if( bOk )
                                thirdC::dosReadProcessMemoryIF( tinP , (byteT*)&copy2 , sizeof copy2 - CBwHEREsUFFIX , bOk , (voidT*)( entry.ip + ( (byteT*)&tinP.idWhat - (byteT*)&tinP ) ) , entry.osPid ) ;
                                bOk = 0 ;
                            {
                            if( bOk )
                            thirdC::dosReadProcessMemoryIF( tinP , (byteT*)&copy1 , sizeof copy1 - CBwHEREsUFFIX , bOk , (voidT*)( entry.ip + ( (byteT*)&tinP.idWhat - (byteT*)&tinP ) ) , entry.osPid ) ;
                            bOk = 0 ;
                        {
                        if( bOk )
                        thirdC::dosReadProcessMemoryIF( tinP , (byteT*)&fingerprint1 , sizeof fingerprint1 , bOk , (voidT*)entry.ip , entry.osPid ) ;
                    {
                    else
                    }
                        bOk = !thirdC::c_memcmpIF( tinP , (byteT*)&copy1 , (byteT*)&copy2 , sizeof copy1 - CBwHEREsUFFIX ) && getNegAM( fingerprint1 ) == FINGERnEG_TINs && getNegAM( fingerprint2 ) == FINGERnEG_TINs ;
                        thirdC::c_memcpyIF( tinP , (byteT*)&fingerprint2 , (byteT*)ap_artmentOldC( tinP , entry.ip ) , sizeof fingerprint2 ) ;
                        thirdC::c_memcpyIF( tinP , (byteT*)&copy2 , (byteT*)pWhere , sizeof copy2 - CBwHEREsUFFIX ) ; //A COPY IS MADE EVEN IF IDA TO INCREASE THE PROBABILITY THAT THE DATA ARE CONSISTENT
                        thirdC::c_memcpyIF( tinP , (byteT*)&copy1 , (byteT*)pWhere , sizeof copy1 - CBwHEREsUFFIX ) ; //A COPY IS MADE EVEN IF IDA TO INCREASE THE PROBABILITY THAT THE DATA ARE CONSISTENT
                        whereOldS* pWhere   = (whereOldS*)( (byteT*)ap_artmentOldC( tinP , entry.ip ) + ( (byteT*)&tinP.idWhat - (byteT*)&tinP ) ) ;
                        thirdC::c_memcpyIF( tinP , (byteT*)&fingerprint1 , (byteT*)ap_artmentOldC( tinP , entry.ip ) , sizeof fingerprint1 ) ;
                    {
                    if( entry.bIda )
                    TELL( "making a copy of whereOldS from the entry's tinS" )
                    ZE( boolT , bOk ) ;
                    ZE( countT , fingerprint2 ) ;
                    ZE( countT , fingerprint1 ) ;
                    whereOldS copy2 ;
                    whereOldS copy1 ;
                {
                if( entry.idTinNamed != ifcIDtINnAMED_tinBreakG )

                tinEntryS& entry = *(tinEntryS*)&stTinWhereP.downF( tinP , hDown ) ;
                TELL( "getting a reference to an entry in stTinWhere" )
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            _IO_
        {
        if( !sgnDone_tmRptPoolF && stTinWhereP )
        TELL( "making whereOldS copies" )
        stTinWhereP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        TELL( "grabbing stTinWhere" ) //U:: CONJ: stTinWhereP IS OBSOLETE; stTin COULD BE USED; THERE IS NO NEED TO MAINTAIN A DISTINCT stTinWhereP
#if defined( NEVERdEFINED )
//U::

        //if( !( idCycle % 0x10 ) ) Beep( 0x100 , 0x30 ) ;
        }
            ++ s ; ether.osSleepF( tinP , TOCK * 0x1/*0*/ ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( ++ idCycle == 1 )
        _IO_
    {
    while( !etThread && !sgnDone_tmRptPoolF )
    TN( t8 , "8\r\n" ) ;
    TN( t7 , "7\r\n" ) ;
    TN( t6 , "6\r\n" ) ;
    TN( t5 , "5\r\n" ) ;
    TN( t4 , "4\r\n" ) ;
    TN( t3 , "3\r\n" ) ;
    TN( t2 , "2\r\n" ) ;
    TN( t1 , "1\r\n" ) ;
    ZE( countT , idCycle ) ;

    stackC&             stRecycle_pwtFineP         =             *(stackC*)c8t3P.c5 ;
    stackC&             stRecycle_pwtGrossP        =             *(stackC*)c8t3P.c4 ;
    whereTalliesGrossS& wtGrossHostP               = *(whereTalliesGrossS*)c8t3P.c3 ;
    stackC&             stWhereP                   =             *(stackC*)c8t3P.c2 ;
    stackC&             stLifiP                    =             *(stackC*)c8t3P.c1 ;
    stackC&             stTinWhereP                =             *(stackC*)c8t2P.c8 ;
    switchC&            swWhereTallyActiveThread   =            *(switchC*)c8t2P.c7 ;
    count5S&            c5leverTallyActiveThread   =            *(count5S*)c8t2P.c6 ;
    switchC&            swWhereTalliesFineClass    =            *(switchC*)c8t2P.c5 ;
    count4S&            c4leverTalliesFineClass    =            *(count4S*)c8t2P.c4 ;
    switchC&            swWhereTalliesFineAdam     =            *(switchC*)c8t2P.c3 ;
    count4S&            c4leverTalliesFineAdam     =            *(count4S*)c8t2P.c2 ;
    switchC&            swWhereTalliesFinePhase    =            *(switchC*)c8t2P.c1 ;
    count5S&            c5leverTalliesFinePhase    =            *(count5S*)c8t1P.c8 ;
    switchC&            swWhereTalliesGrossPhase   =            *(switchC*)c8t1P.c7 ;
    count4S&            c4leverTalliesGrossPhase   =            *(count4S*)c8t1P.c6 ;
    switchC&            swWhereTalliesGrossClass   =            *(switchC*)c8t1P.c5 ;
    countT&             cLeverTalliesGrossClass    =             *(countT*)c8t1P.c4 ;
    boolT&              bDestroyCircleMonitor      =              *(boolT*)c8t1P.c3 ;
    signC&              sgnDone_tmWhereF           =              *(signC*)c8t1P.c2 ;
    signC&              sgnDone_tmRptPoolF         =              *(signC*)c8t1P.c1 ;
    count8S&            c8t3P                      =             *(count8S*)c3pP.c3 ;
    count8S&            c8t2P                      =             *(count8S*)c3pP.c2 ;
    count8S&            c8t1P                      =             *(count8S*)c3pP.c1 ;
    count3S&            c3pP                       =          *(count3S*)pTaskP->c1 ;
    etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 )
tinP.idPhase2 = 1 ;
TASK( tmWhereF )

}
    return pwtf ;
    if( stRecycle_pwtFineP ) ; //U::
    if( !pwtf ) { pwtf = new( 0 , tinP , LF ) whereTalliesFineS( tinP , thirdP , TAG( TAGiDnULL ) ) ; ___( pwtf ) ; }
    //stRecycle_pwtFineP.ungrabF( tinP ) ;
    //if( stRecycle_pwtFineP ) stRecycle_pwtFineP >> *(countT*)&pwtf ;
    //stRecycle_pwtFineP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    ZE( whereTalliesFineS* , pwtf ) ;
{
whereTalliesFineS* pwtFineF( tinS& tinP , thirdC& thirdP , stackC& stRecycle_pwtFineP )

}
    return pwtg ;
    if( stRecycle_pwtGrossP ) ; //U::
    if( !pwtg ) { pwtg = new( 0 , tinP , LF ) whereTalliesGrossS( tinP , thirdP , TAG( TAGiDnULL ) ) ; ___( pwtg ) ; }
    //stRecycle_pwtGrossP.ungrabF( tinP ) ;
    //if( stRecycle_pwtGrossP ) stRecycle_pwtGrossP >> *(countT*)&pwtg ;
    //stRecycle_pwtGrossP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    ZE( whereTalliesGrossS* , pwtg ) ;
{
whereTalliesGrossS* pwtGrossF( tinS& tinP , thirdC& thirdP , stackC& stRecycle_pwtGrossP )

}
    TELL( "cleaning up after handling an entry in stTinWhere" )
    if( !wtfP.bNewWhereRpt ) wtfP.bNewWhereRpt = 1 ;
        
    wtfP.swTally3.ungrabF( tinP ) ;
    ++ wtfP.swTally3 ;
    wtfP.pczLever3 = pcloIn ;
    wtfP.swTally3.grabF( tinP , TAG( TAGiDnULL ) ) ;
    TELL( "tally 3 (outermost inward)" )
        
    }
        pcloIn[ offo ++ ] = copy1P.pLFnest[ ( ( idn & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
        pcloIn[ offo ++ ] = copy1P.pLFnest[   ( idn & OFFsLOTtINnESTmAX ) << 1       ] ;
    {
    for( countT idn = idnf ; idn <= copy1P.monitor.cInNest ; idn ++ )
    TELL( "making lever for tally 3 (outermost inward)" )
            
    ZE( countT , offo ) ;
    thirdC::c_memsetIF( tinP , (byteT*)pcloIn , sizeof pcloIn ) ;
    countT pcloIn[  3 + sizeof copy1P.pLFnest / sizeof copy1P.pLFnest[ 0 ] ] ;
    TELL( "allocating levers for tally 3" )
            
    wtfP.swTally2.ungrabF( tinP ) ;
    ++ wtfP.swTally2 ;
    wtfP.lifiLever2.c2 = copy1P.pLFnest[ ( ( copy1P.monitor.cInNest & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
    wtfP.lifiLever2.c1 = copy1P.pLFnest[   ( copy1P.monitor.cInNest & OFFsLOTtINnESTmAX ) << 1       ] ;
    TELL( "tally 2 (innermost)" )
    wtfP.swTally2.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }        
        wtfP.swTally1.ungrabF( tinP ) ;
        ++ wtfP.swTally1 ;
        wtfP.lifiLever1.c2 = copy1P.pLFnest[ ( ( idnfa & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
        wtfP.lifiLever1.c1 = copy1P.pLFnest[   ( idnfa & OFFsLOTtINnESTmAX ) << 1       ] ;
        wtfP.swTally1.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        //{ CONoUTrAW3( "accepting idnfa " , copy1P.pLFnest[ ( ( idnfa & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] , "\r\n" ) ; } //U::
        ) ;
            )
                1 == etThread.strIdF( tinP , tTinName , tLifiName )
                ) ||
                    copy1P.pLFnest[ ( ( idnfa & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] == copy1P.idiFileTinCt
                    copy1P.pLFnest[ ( ( idnfa & OFFsLOTtINnESTmAX ) << 1 )     ] == ( copy1P.idLineTinCt & 0xfff ) &&
                (
                copy1P.pLFnest[ ( ( idnfa & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] == 0x21001b0 ||
                copy1P.pLFnest[ ( ( idnfa & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] == 0x11001b0 ||
                copy1P.pLFnest[ ( ( idnfa & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] == 0x3000b71 ||
                copy1P.pLFnest[ ( ( idnfa & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] == 0x10000a0 ||
            (
            idnfa < copy1P.monitor.cInNest &&
        (
        while
        }
            }
                stLifiP.ungrabF( tinP ) ;
                }
                    tLifiName = T(old.postName) ;
                    lifiEntryS& old = *(lifiEntryS*)&(countT&)stLifiP[ 0 ] ;
                {
                else
                if( !ids ) tLifiName = tUnkStatic ;
                stLifiP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_lifiEntryS_F ) ;
                stLifiP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                ZE( countT , ids ) ;
                lifiEntryS entry( tinP , copy1P.pLFnest[ ( ( idnfa & OFFsLOTtINnESTmAX ) << 1 ) ] , copy1P.pLFnest[ ( ( idnfa & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] , "" ) ;
            {
            
            idnfa ++ ;
    
            //if( idnfa ) { CONoUTrAW5( "suppressing idnfa " , idnfa , tLifiName , copy1P.pLFnest[ ( ( idnfa & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] , "\r\n" ) ; } //U::
        {
        do
        idnfa -- ;
        TN( tLifiName , "unknown" ) ;
        TN( tUnkStatic , "unk or static" ) ;
    
        }
            stLifiP.ungrabF( tinP ) ;
            }
                tTinName = T(old.postName) ;
                lifiEntryS& old = *(lifiEntryS*)&(countT&)stLifiP[ 0 ] ;
            {
            if( ids )
            stLifiP.sinkF( tinP , ids , (byteT*)&entry2 , flSTACKsINK_QUERY , subtract_lifiEntryS_F ) ;
            stLifiP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            ZE( countT , ids ) ;
            lifiEntryS entry2( tinP , copy1P.idLineTinCt & 0xfff , copy1P.idiFileTinCt , "" ) ;
        {
        TN( tTinName , "unknown" ) ;
    
        TELL( "tally 1 (outermost)" )
        countT idnfa = idnf ;
    {
    const countT idnf = copy1P.monitor.cInNest < 1 + OFFsLOTtINnESTmAX ? 1 : ( copy1P.monitor.cInNest - OFFsLOTtINnESTmAX ) & OFFsLOTtINnESTmAX ;
{
voidT tallyF( tinS& tinP , etherC& etThread , whereTalliesFineS& wtfP , whereOldS& copy1P , stackC& stLifiP )

}
    if( tinP.fingerprint && etThread && stLifiP ) ; //SO MACRO CAN BE USED
    if( !wtgP.bNewWhereRpt ) wtgP.bNewWhereRpt = 1 ;

    wtgP.swTally.ungrabF( tinP ) ;
    ++ wtgP.swTally ;
    wtgP.idWhatLever = copy1P.idWhat ;
    wtgP.swTally.grabF( tinP , TAG( TAGiDnULL ) ) ;

{
voidT tallyF( tinS& tinP , etherC& etThread , whereTalliesGrossS& wtgP , whereOldS& copy1P , stackC& stLifiP )

//}
//    etThread.delF( tinP , psttl ) ;                                                         \
//    etThread.strokeF( tinP , psttl ) ;                                                    \
//    etThread.strFuseF( tinP , psttl , T("\r\n") ) ;                                         \
//    }                                                                                       \
//        }                                                                                   \
//            pc = pc->pTinBro ;                                                              \
//            etThread.strFuseF( tinP , psttl , tb+T(pc->postThreadName) ) ;                  \
//        {                                                                                   \
//        while( pc )                                                                         \
//        pc = pc->pTinBro ;                                                                  \
//        etThread.strFuseF( tinP , psttl , tb+T(pc->postThreadName) ) ;                      \
//        pc = pc->pTinKid ;                                                                  \
//    {                                                                                       \
//    if( pc->pTinKid )                                                                       \
//    tinS* pc = tinP.pTinDad ;                                                               \
//    etThread.strMakeF( tinP , LF , psttl , TF1(idP)+T(": ") , 0x1000 ) ; ___( psttl ) ;          \
//    ZE( strokeS* , psttl ) ;                                                              \
//    TN( tb , " " ) ;                                                                        \
//{                                                                                           \
//#define DEBUGmE(idP)                                                                        \
//U::

DONE( tmRptPoolF )
tinP.idPhase2 = 0 ;
}
    }
        }
            while( !etThread && !sgnDone_tmFireAllF && cToDo -- ) { ++ s ; etThread.osSleepF( tinP , TUCK * 0x4 ) ; }
            countT cToDo = TUCK * 0x4 ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        TELL( "sleeping for up to 01 tocks" )

        }
            etThread.delF( tinP , postr ) ;
            etThread.boxPutF( tinP , tFile , postr , costr ) ;
            etThread.delF( tinP , psttr ) ;
            countT costr = etThread.strMakeF( tinP , LF , postr , psttr ) ; ___( postr ) ;
            ZE( osTextT* , postr ) ;
            TELL( "writing the report to disk" )

            etThread.strFuseF( tinP , psttr , tNotes ) ; ___( psttr ) ;
        {
        if( !sgnDone_tmFireAllF )

        }
            }
                }
                    ) ;
                        T("\r\n")
                        tName+
                        TF3(ec,flFORMAT_UNSIGNED,9)+
                        TF3(cvun,flFORMAT_UNSIGNED,5)+
                        TF3(cvuc,flFORMAT_UNSIGNED,5)+
                        TF3(cvsn,flFORMAT_UNSIGNED,5)+
                        TF3(cvsc,flFORMAT_UNSIGNED,5)+
                        TF3(flagsBack,flFORMAT_UNSIGNED,9)+
                        TF3(cAccesses,flFORMAT_UNSIGNED,9)+
                        TF3(cCollisions,flFORMAT_UNSIGNED,9)+
                        TF3(cdUsed,flFORMAT_UNSIGNED,9)+
                        TF3(offHighWater,flFORMAT_UNSIGNED,9)+
                        TF3(offNewMin,flFORMAT_UNSIGNED,9)+
                        TF3((countT)(0x100*(measureT)(offHighWater)/cbPool),flFORMAT_UNSIGNED,4)+
                        TF3((countT)(0x100*(measureT)(cbUsed)/cbPool),flFORMAT_UNSIGNED,4)+
                        TF3(cbUsed,flFORMAT_UNSIGNED,9)+
                        TF3(cbPool,flFORMAT_UNSIGNED,9)+
                    etThread.strFuseF( tinP , psttr ,
    
                    flagsT flagsBack    = poo.flagsBackF( tinP ) ;
                    countT offNewMin    = poo.offNewMinF( tinP ) ;
                    countT offHighWater = poo.offHighWaterF( tinP ) ;
                    countT cAccesses    = poo.cAccessesF( tinP ) ;
                    countT cCollisions  = poo.cCollisionsF( tinP ) ;
                    countT cdUsed       = poo.cdUsedF( tinP ) ;
                    countT cbUsed       = poo.cbUsedF( tinP ) ;
                    countT cbPool       = poo.cbPoolF() ;
    
                    countT cvun         = poo.cViewsUnserializedNonclientF( tinP ) ;
                    countT cvuc         = poo.cViewsUnserializedClientF( tinP ) ;
                    countT cvsn         = poo.cViewsSerializedNonclientF( tinP ) ;
                    countT cvsc         = poo.cViewsSerializedClientF( tinP ) ;
                {
                else
                if( poo.ecF( tinP ) ) etThread.strFuseF( tinP , psttr , TPS("(poolOld is impotent)",0x6c,sDot)+tb+tName+tc ) ;
                if( 1 == etThread.strIdF( tinP , tPrefix , tName ) ) tName = T(postPoolNames+off*(COSTmAXpOOLoLDnAME+1)+tPrefix.csF(tinP)) ;
                TN( tName , postPoolNames + off * ( COSTmAXpOOLoLDnAME + 1 ) ) ;
                p oolC poo( tinP , TAG( TAGiDnULL ) , postPoolNames+off*(COSTmAXpOOLoLDnAME+1) , 0 , 0 , flPOOLoLDc_NOcLIENTrIGHTS , 1 ) ;
            {
            if( postPoolNames[ off * ( COSTmAXpOOLoLDnAME + 1 ) ] )
        {
        for( countT off = 0 ; off < CpOOLoLDnAMESmAX && !sgnDone_tmFireAllF ; off ++ )
        etThread.strFuseF( tinP , psttr , t3 ) ; ___( psttr ) ;
        TELL( "listing the poolOld names" )

        etThread.strFuseF( tinP , psttr , t1+TT(timeN1,timeN2)+t2+TF1(++idReport)+tc2 , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ tNotes.csF( tinP ) + 0x10000 ) ; ___( psttr ) ;
        ZE( strokeS* , psttr ) ;

        etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT , timeN1 ) ;
        TELL( "getting the time" )
    {
    while( !etThread && !sgnDone_tmFireAllF )

    strokeS sDot( '.' ) ;
    ;
        T("\r\n")
        TPS("name",0x20,sttd)+
        TPS("ec",8,sttd)+tb+
        TPS("cvun",4,sttd)+tb+
        TPS("cvuc",4,sttd)+tb+
        TPS("cvsn",4,sttd)+tb+
        TPS("cvsc",4,sttd)+tb+
        TPS("flagsBac",8,sttd)+tb+
        TPS("cAccesse",8,sttd)+tb+
        TPS("cCollisi",8,sttd)+tb+
        TPS("cdUsed",8,sttd)+tb+
        TPS("oHighWat",8,sttd)+tb+
        TPS("oNewMin",8,sttd)+tb+
        TPS("pth",3,sttd)+tb+
        TPS("ptu",3,sttd)+tb+
        TPS("cbUsed",8,sttd)+tb+
        TPS("cbPool",8,sttd)+tb+
    TN( t3 , "[PS]\r\n" ) ; t3 +=
    TN( t2 , "\r\nidReport: " ) ;
    TN( t1 , "IdeaFarm " "(tm) Operating System\r\nLocal Pools\r\n(see the explanatory notes at the end of this report)\r\n" ) ;
    ;
        tb+T("name: name of the poolOld, omitting the prefix \"")+tPrefix+T("\"")+tc2
        tb+T("ec" ": impotence code")+tc+
        tb+T("cvun: cViewsUnserializedNonclient")+tc+
        tb+T("cvuc" ": cViewsUnserializedClient")+tc+
        tb+T("cvsn: cViewsSerializedNonclient")+tc+
        tb+T("cvsc" ": cViewsSerializedClient")+tc+
        tb+T("flagsBack: flags")+tc+
        tb+T("cAccesses: number of successful grabs of this poolOld")+tc+
        tb+T("cCollisions: number of collisions while attempting to grab this poolOld")+tc+
        tb+T("cdUsed: number of undeleted drops")+tc+
        tb+T("oHighWater: highest offset at which a drop header has been allocated")+tc+
        tb+T("oNewMin: unless specified otherwise, the search for space for a new drop begins at this offset (rather than at offset 0) of the poolOld")+tc+
        tb+T("perTuckHighWater: ratio of offHighWater to cbPool (001 is \"all\")")+tc+
        tb+T("perTuckUsed: ratio of cbUsed to cbPool (001 is \"all\")")+tc+
        tb+T("cbUsed: bytes occupied by poolOld drops, including drop headers")+tc+
        tb+T("cbPool: size, in bytes, of the contiguous shared memory in which poolOld drops (including drop headers but not the poolOld header) reside")+tc+
        tb+T("each name is the name of the shared memory that backs poolC objects of the same name")+tc+
        tb+T("list of the poolOlds being used")+tc+
        T("[PS]")+tc+
        tb+T("idReport: the number of generations of this report written since the IdeaFarm " "(tm) Operating System was started on this computer")+tc2+
        tb+T("the time of the report is represented according to the customs of IdeaFarm " "(tm) City")+tc+
        tb+T("(\"01 tock\" means 16 (base 10) tocks, or approximately 30 seconds)")+tc+
        tb+T("(a tock is approximately 1.33 seconds")+tc+
        tb+T("Local Pool Report: this report is written every 01 tock by the IdeaFarm " "(tm) Operating System")+tc+
        tb+T("these programs are called \"IdeaFarm " "(tm) Cells\"")+tc+
        tb+T("some programs on this computer are using the IdeaFarm " "(tm) Operating System")+tc+
        tb+T("IdeaFarm " "(tm) Operating System: runs \"on top of\" this computer's base operating system (e.g. MS Windows)")+tc+
        tb+T("for support, see http://www.ideafarm.com or call Wo'O Ideafarm US 650-759-5306")+tc+
        T("[ID]")+tc+
        TPS(" \r\nexplanatory notes ",0x40,S1C('-'))+tc2+
    TN( tNotes , "" ) ; tNotes =
    TN( tPrefix , "poolC/2/" ) ;
    TN( tqc , "\"\r\n" ) ;
    TN( tq , "\"" ) ;
    TN( tb , " " ) ;
    TN( tc2 , "\r\n \r\n" ) ;
    TN( tc , "\r\n" ) ;
    TN( tFile , "///d/ideafarm.rpt.monitor.poolOlds" ) ;
    strokeS sttd('-') ;
    ZE( countT , idReport ) ;

    //countT*  pcRefPoolNames =  (countT*)pTaskP->c3 ;
    osTextT* postPoolNames    = (osTextT*)pTaskP->c2 ; //[ CpOOLoLDnAMESmAX ][ COSTmAXpOOLoLDnAME + 1 ]
    signC& sgnDone_tmFireAllF =  *(signC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;
tinP.idPhase2 = 1 ;
TASK( tmRptPoolF )

DONE( tmRptMainF )
tinP.idPhase2 = 0 ;
TELL( "i am outa here" )
}
    tinP.pEtText = 0 ;
    tinP.flagsThreadMode1 &= ~( F(flTHREADmODE1_DISALLOWgRAB) ) ;
    TELL( "cleaning up" )
    //POPUP( "tmRptMainF/about to set my done flag" ) ; //U::
    }
        }
            }
                }
                    etThread.osSleepF( tinP , TUCK * 0x4 ) ;
                    //etThread.strokeF( tinP , T("\r        \r")+TF1(cToDo) ) ;
                    ++ s ;
                {
                while( !etThread && !bMonitorEnded && cToDo -- )
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            countT cToDo = TUCK / 4  ;
            TELL( "nap for up to 01 tocks" )
            //etThread.strokeF( tinP , T("\r\nwrote main report ")+TF1(idReport)+T("\r\n") ) ;
    
            else stRpt.purgeF( tinP ) ;
            }
                etThread.delF( tinP , postr ) ;
                }
                    while( !etThread ) ;
                    }
                        else break ;
                        }
                            etThread.osSleepF( tinP , TUCK * 0x40 ) ;
                            CONoUT( "fileWriteGF failed.  will retry" ) ;
                            POOPR
                        {
                        if( POOP && !bMonitorEnded )
                        fileWriteGF( tOsFileName , postr , costr ) ;
                    {
                    do
                    POOPIES
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                {
                etThread.delF( tinP , psttr ) ;
                countT costr = etThread.strMakeF( tinP , LF , postr , psttr ) ; ___( postr ) ;
                ZE( osTextT* , postr ) ;
                etThread.strConcatenateF( tinP , psttr , stRpt ) ; ___( psttr ) ;
                ZE( strokeS* , psttr ) ;
                TELL( "write the report to disk" )
            {
            if( !bMonitorEnded )
        
            }
                stRpt << psttr8 ; psttr8 = 0 ;
                etThread.strFuseF( tinP , psttr8 , tNotes ) ; ___( psttr8 ) ;
                ZE( strokeS* , psttr8 ) ;
            {
            if( !bMonitorEnded )
            TELL( "explanatory notes" )
            
            //if( !setIfEqualsAM( conditionalGrab , 0 , 1 ) ) { BLAMMO ; } // THE flSTACKc_ALLOWmULTIPLEuNSERIALIZED stackC objects MUST NOT BE REFERENCED AFTER THIS
            //THREADmODE1rESTORE
            ////***********************************************************************************************************************
            //bGrabbedConditionalGrab = 0 ;
            //TELL( "resetting conditionalGrab" )

            }
                st_ST_osTidPseudoBelieving.purgeF( tinP ) ;
                st_ST_osTidMessiah.purgeF( tinP ) ;
                st_ST_osTidPseudoSleeping.purgeF( tinP ) ;
                st_ST_osTidSleeping.purgeF( tinP ) ;
                stIdSerialGrabExclude.purgeF( tinP ) ;
                stChecked.purgeF( tinP ) ;
                stWanters2.purgeF( tinP ) ;
                stWanters.purgeF( tinP ) ;
                stGrabbed.purgeF( tinP ) ;
                TELL( "purging stGrabbed stWanters stChecked" )
                stGrabbed.ungrabF( tinP ) ;
                }
                    while( !stGrabbed.third && ~hDown ) ;
                    }
                        etThread.delF( tinP , entry.pbCopy ) ;
                        grabEntryS& entry = *(grabEntryS*)&stGrabbed.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stGrabbed )
                stGrabbed.grabF( tinP , TAG( TAGiDnULL ) ) ;
                TELL( "deleting the grabS copies" )
            
                stOsTidLooped.purgeF( tinP ) ;
                TELL( "purging stOsTidLooped" )

                }
                    swWhereTalliesGrossClass.ungrabF( tinP ) ;
                    swWhereTalliesGrossClass.freeNullsF( tinP ) ;
                    }
                        }
                            }
                                pwtgc = 0 ;
                                stRecycle_pwtGrossP << (countT)pwtgc ;
                                pwtgc->purgeF( tinP ) ; //U::
                                writeGrossReportF( tinP , etThread , stRpt , *pwtgc , stFlavor ) ;
                                stRpt << psttOldC( tinP , etThread , T(" \r\n[CW]: ")+T(processGlobal4I.mapAdamClass(cLeverTalliesGrossClass))+T("\r\n") ) ;
                            {
                            if( pwtgc )
                            whereTalliesGrossS*& pwtgc = *(whereTalliesGrossS**)&(countT&)swWhereTalliesGrossClass ;
                            cLeverTalliesGrossClass = swWhereTalliesGrossClass.leverF( tinP , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cFlavors && !bMonitorEnded ; idf ++ )
                        countT cFlavors = swWhereTalliesGrossClass.cFlavorsF( tinP ) ;
                    {
                    swWhereTalliesGrossClass.grabF( tinP , TAG( TAGiDnULL ) ) ;

                    }
                        writeGrossReportF( tinP , etThread , stRpt , wtGrossHostP , stFlavor ) ;
                        stRpt << psttOldC( tinP , etThread , T(" \r\n[HW]\r\n") ) ;
                    {
                {
                if( !bMonitorEnded ) 
                TELL( "report HW" )

                if( !bMonitorEnded ) writeTalkingReportF( tinP , etThread , stRpt , swWhereTallyTalkingP     , c5leverTallyTalkingP     , stFlavor , stLifiP ) ;
                if( !bMonitorEnded ) writeActiveReportF( tinP  , etThread , stRpt , swWhereTallyActiveThread , c5leverTallyActiveThread , stFlavor , stLifiP ) ;
            
                stTin.ungrabF( tinP ) ;
                }
                    while( !stTin.third && ~hDown ) ;
                    }
                        etThread.delF( tinP , entry.pbCopy ) ;
                        tinEntryS& entry = *(tinEntryS*)&stTin.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stTin )
                TELL( "deleting the tinS copies" )

                }
                    }
                        while( !bMonitorEnded && !stTin.third && ~hDown ) ;
                        }
                            }
                                }
                                    }
                                        }
                                            stRpt << psttr5 ; psttr5 = 0 ;
                                            psttOldCallNestF( tinP , etThread , psttr5 , stLifiP , 0x12 + clf1 * 2 , tin.pLFnest            , 0 , clf2 ) ; ___( psttr5 ) ;
                                        {
                                        if( clf1 < tin.monitor.cInNest )
                                        stRpt << psttr5 ; psttr5 = 0 ;
                                        psttOldCallNestF( tinP , etThread , psttr5 , stLifiP , 0x12            , tin.pLFnest + 2 * idnf , 0 , clf1 ) ; ___( psttr5 ) ;
                                        stRpt << psttOldC( tinP , etThread , tc ) ;
                                        }
                                            stRpt << psttr5 ; psttr5 = 0 ;
                                            psttOldCallNestF( tinP , etThread , psttr5 , stLifiP , 0x12 + clf1 * 2 , tin.pLFnest            , 1 , clf2 ) ; ___( psttr5 ) ;
                                        {
                                        if( clf1 < tin.monitor.cInNest )
                                        stRpt << psttr5 ; psttr5 = 0 ;
                                        psttOldCallNestF( tinP , etThread , psttr5 , stLifiP , 0x12            , tin.pLFnest + 2 * idnf , 1 , clf1 ) ; ___( psttr5 ) ;
                                        countT clf2 = OFFsLOTtINnESTmAX + 1 - clf1 ;
                                        if( clf1 > tin.monitor.cInNest ) clf1 = tin.monitor.cInNest ;
                                        countT clf1 = OFFsLOTtINnESTmAX + 1 - idnf ;
    
                                        if( (sCountT)idnf < 1 ) idnf = 1 ;
                                        countT idnf = tin.monitor.cInNest - OFFsLOTtINnESTmAX ;
                                    {
                                    if( tin.monitor.cInNest )

                                    stRpt << psttr5 ; psttr5 = 0 ;
                                    etThread.strMakeF( tinP , LF , psttr5 , T(tin.postThreadName) ) ; ___( psttr5 ) ;

                                    }
                                        stRpt << psttr5 ; psttr5 = 0 ;
                                        etThread.strMakeF( tinP , LF , psttr5 , TPS((osTextT*)tw1,8,S1C(':'))+tb ) ;
                                        TN( tw1 , "" ) ; tw1 = TF2(tin.idThread,flFORMAT_UNSIGNED) ;
                                    {
                                    }
                                        stRpt << psttr5 ; psttr5 = 0 ;
                                        etThread.strMakeF( tinP , LF , psttr5 , TPS((osTextT*)tw1,8,S1C(':'))+tb ) ;
                                        TN( tw1 , "" ) ; tw1 = TF2(tin.osPid,flFORMAT_UNSIGNED) ;
                                    {
                                    ZE( strokeS* , psttr5 ) ;
                                {
                                else
                                }
                                    }
                                        stRpt << psttr5 ; psttr5 = 0 ;
                                        etThread.strFuseF( tinP , psttr5 , TF3(tin.monitor.cNewSteps,flFORMAT_UNSIGNED,9)+tType+tIdName+TF3(tin.osTid,flFORMAT_UNSIGNED,9)+TF3(tin.osPid,flFORMAT_UNSIGNED,9)+TF3(tin.idThread,flFORMAT_UNSIGNED,9)+TP(tin.postThreadName,0x20)+tb+TF3(tin.cNest,flFORMAT_UNSIGNED,4)+TF3(tin.pLFnest[((tin.monitor.cInNest&OFFsLOTtINnESTmAX)<<1)+1],flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+tMark2+(bMark?T("* "):T("  "))+T(tin.postTell)+(tin.postTellIf[0]?tBar:tNull)+T(tin.postTellIf)+tc ) ; ___( psttr5 ) ;
                                        ZE( strokeS* , psttr5 ) ;
                                    {

                                    }
                                        default                                      : { tIdName = T("???? ") ; break ; }
                                        case ifcIDtINnAMED_tinInPool                 : { tIdName = T("     ") ; break ; }
                                        case ifcIDtINnAMED_tinEarlyLate              : { tIdName = T("elat ") ; break ; }
                                        case ifcIDtINnAMED_tinInPoolMain             : { tIdName = T("main ") ; break ; }
                                        case ifcIDtINnAMED_tinEarlyLateMain          : { tIdName = T("mel3 ") ; break ; }
                                        case ifcIDtINnAMED_tinBreakG                 : { tIdName = T("brea ") ; break ; }
                                        case ifcIDtINnAMED_tinVeryEarlyLateMainG     : { tIdName = T("mel2 ") ; break ; }
                                        case ifcIDtINnAMED_tinHeartG                 : { tIdName = T("hear ") ; break ; }
                                        case ifcIDtINnAMED_tinVeryVeryEarlyLateMainG : { tIdName = T("mel1 ") ; break ; }
                                    {
                                    switch( tin.idTinNamed )
                                    TN( tIdName , "" ) ;
                                    TN( tType , "    " ) ;
                                    tMark2 = TP( (osTextT*)tMark2 , 3 ) ;
                                    }
                                        if( stOsTidLooped(              tin.osTid ) ) tMark2 += T("L") ;
                                        if( st_ST_osTidPseudoSleeping(  tin.osTid ) ) tMark2 += T("z") ;
                                        if( st_ST_osTidSleeping(        tin.osTid ) ) tMark2 += T("Z") ;
                                        if( st_ST_osTidMessiah(         tin.osTid ) ) tMark2 += T("M") ;
                                        if( st_ST_osTidPseudoBelieving( tin.osTid ) ) tMark2 += T("B") ;
                                    {
                                    if( tin.osTid )
                                    TN( tMark2 , " " ) ;
                                    boolT bMark = !tin.monitor.cNewSteps || ( tin.osTid && stOsTidLooped( tin.osTid ) ) ; // tin.osTid WILL BE 0 FOR tinBreakG
                                {
                                if( idPass == 1 )
                                tinS& tin = *(tinS*)entry.pbCopy ;
                            {
                            if( !bMonitorEnded && entry.pbCopy )

                            }
                                }
                                    etThread.memCopyF( tinP , entry.pbCopy , pbCopy , sizeof pbCopy ) ;
                                    etThread.newF( tinP , LF , entry.pbCopy , sizeof pbCopy ) ; ___( entry.pbCopy ) ;
                                {
                                if( pCopy ) // pCopy IS EITHER 0 OR A VALID IMAGE OF A tinS
                    
                                }
                                    }
                                        if( !bOk || getNegAM( pc2[ 0 ] ) != FINGERnEG_TINs || entry.idSerial != pc2[ 1 ] ) pCopy = 0 ;
                                        thirdC::dosReadProcessMemoryIF( tinP , (byteT*)pc2 , sizeof pc2 , bOk , (voidT*)entry.ip , entry.osPid ) ;
                                        bOk = 0 ;
                                        countT pc2[ 2 ] ; //CODE SYNC: ad40104 003002a: fingerprint idSerial MUST BE AT OFFSETS 0 4
                                    {
                                    else
                                    if( !bOk || getNegAM( pCopy->fingerprint ) != FINGERnEG_TINs || entry.idSerial != pCopy->idSerial ) pCopy = 0 ;
                                    thirdC::dosReadProcessMemoryIF( tinP , pbCopy , sizeof( tinS ) , bOk , (voidT*)entry.ip , entry.osPid ) ;
                                    ZE( boolT , bOk ) ;
                                {
                                else
                                }
                                    if( getNegAM( pCopy->fingerprint ) != FINGERnEG_TINs || entry.idSerial != pCopy->idSerial ) pCopy = 0 ;
                                    etThread.memCopyF( tinP , pbCopy , (byteT*)pCopyI , sizeof( tinS ) ) ;
                                    tinS* pCopyI = (tinS*)(byteT*)ap_artmentOldC( tinP , entry.ip ) ;
                                {
                                if( entry.bIda )
                                tinS* pCopy = (tinS*)pbCopy ;
                                byteT pbCopy[ sizeof( tinS ) ] ;

                                if( entry.pbCopy ) { BLAMMO ; }
                            {
                            if( idPass == 1 )

                            }
                                if( !ids ) continue ;
                                stOsTidBad.sinkF( tinP , ids , entry.osTid , flSTACKsINK_QUERY ) ;
                                ZE( countT , ids ) ;
                            {

                            tinEntryS& entry = *(tinEntryS*)&stTin.downF( tinP , hDown ) ;
                        {
                        do
                        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                        }
                            stRpt << psttr5 ; psttr5 = 0 ;
                            etThread.strFuseF( tinP , psttr5 , T(" \r\n[TD]\r\n") ) ; ___( psttr5 ) ;
                            ZE( strokeS* , psttr5 ) ;
                        {
                        if( idPass == 2 )
                    {
                    for( countT idPass = 1 ; idPass <= 2 && !bMonitorEnded ; idPass ++ )
                {
                if( !bMonitorEnded && stTin )
                TELL( "report TS: getting copies of the tinS objects" )
            
                //etThread.beeClickF( tinP , 0x8*thirdC::mathLog2IF( tinP , (measureT)(cNewSteps?cNewSteps:1) ) , TUCK*0x10 ) ;
                //etThread.strokeF( tinP , T("\r\n")+TF1(cNewSteps)+T("    ")+TF1((countT)thirdC::mathLog2IF( tinP ,(measureT)(cNewSteps?cNewSteps:1)))+T("\r\n") ) ;

                }
                    while( !bMonitorEnded && !stTin.third && ~hDown ) ;
                    }
                        }
                            }
                                cNewSteps += monitor.cNewSteps ;
                                thirdC::dosWriteProcessMemoryIF( tinP , countTC() , (voidT*)( entry.ip + ( (byteT*)&tinP.monitor - (byteT*)&tinP ) ) , entry.osPid , (byteT*)&monitor , sizeof monitor ) ;
                                stampF( tinP , etThread , monitor , idStep ) ;
                                monitorOldS& monitor = *(monitorOldS*)( &idStep + 1 ) ;
                                countT&   idStep  = *(countT*)pbCopy ;
                            {
                            if( bOk )
                            thirdC::dosReadProcessMemoryIF( tinP , pbCopy , sizeof pbCopy , bOk , (voidT*)( entry.ip + ( (byteT*)&tinP.monitor.idStep - (byteT*)&tinP ) ) , entry.osPid ) ;
                            ZE( boolT , bOk ) ;
                            byteT pbCopy[ sizeof( countT ) + sizeof( monitorOldS ) ] ;
                        {
                        else
                        }
                            cNewSteps += monitor.cNewSteps ;
                            stampF( tinP , etThread , monitor , idStep ) ;
                            monitorOldS& monitor = *(monitorOldS*)( &idStep + 1 ) ;
                            countT&   idStep  = *(countT*)( (byteT*)ap_artmentOldC( tinP , entry.ip ) + ( (byteT*)&tinP.monitor.idStep - (byteT*)&tinP ) ) ;
                        {
                        if( entry.bIda )
            
                        tinEntryS& entry = *(tinEntryS*)&stTin.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( !bMonitorEnded && stTin )
                stTin.grabF( tinP , TAG( TAGiDnULL ) ) ;
                ZE( countT , cNewSteps ) ;
            
                if( !bMonitorEnded ) { stRpt << psttr4 ; psttr4 = 0 ; }
                etThread.strFuseF( tinP , psttr4 , t8+tNewSteps+tb+tType+tb+tIdName+tb+tOsTid+tb+tPid+tb+tIdThread+tb+tThread+tb+tNest+tb+tIn+tWhat+tMarked+tTell+tc ) ;
                TELL( "report TS: stamping the original tinS objects" )
            
                if( !bMonitorEnded ) { stRpt << psttr4 ; psttr4 = 0 ; }
                stBadGrabs.ungrabF( tinP ) ;
                }
                    etThread.delF( tinP , pbEntry ) ;
                    }
                        etThread.strFuseF( tinP , psttr4 , TF3(entry.idSerial,flFORMAT_UNSIGNED,9)+TF3(entry.idiFileCt,flFORMAT_UNSIGNED,9)+TF3(entry.idLineCt,flFORMAT_UNSIGNED,9)+TF3(entry.osPid,flFORMAT_UNSIGNED,9)+TF3(entry.bIda,flFORMAT_UNSIGNED,9)+TF3(entry.ip,flFORMAT_UNSIGNED,9)+tc ) ; ___( psttr4 ) ;
                        grabEntryS& entry = *(grabEntryS*)pbEntry ;
                    {
                    if( !bMonitorEnded && pbEntry )
                    stBadGrabs >> pbEntry ;
                    ZE( byteT* , pbEntry ) ;
                {
                while( stBadGrabs )
                stBadGrabs.grabF( tinP , TAG( TAGiDnULL ) ) ;

                if( !bMonitorEnded ) { etThread.strFuseF( tinP , psttr4 , t7+tIdSerial+tb+tFile+tb+tLine+tb+tPid+tb+tBIda+tb+tIP+tc , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ ( stBadGrabs + 1 ) * 0x80 ) ; ___( psttr4 ) ; }
                ZE( strokeS* , psttr4 ) ;
                TELL( "report GS" )
                    
                stGrabbed.ungrabF( tinP ) ;
                }
                    etThread.delF( tinP , *(byteT**)&pGrabWantCopy ) ;
                    while( !bMonitorEnded && !stGrabbed.third && ~hDown ) ;
                    }
                        }
                            }
                                stOsTidBad.sinkF( tinP , countTC() , osTid , flSTACKsINK_UNIQUE ) ;
                                stOsTidLooped.sinkF( tinP , countTC() , osTid , flSTACKsINK_UNIQUE ) ;
                                stOsTidLoopedTmp >> osTid ;
                                ZE( countT , osTid ) ;
                            {
                            while( stOsTidLoopedTmp )
                    
                            }
                                stBadGrabs.sinkF( tinP , countTC() , (byteT*)pEntry , flSTACKsINK_UNIQUE , subtract_grabEntryS_F ) ;
                                stBadGrabsTmp >> *(countT*)&pEntry ;
                                ZE( grabEntryS* , pEntry ) ;
                            {
                            while( stBadGrabsTmp )
                        {
                        else
                        }
                            stOsTidLoopedTmp.purgeF( tinP ) ;
                            stBadGrabsTmp.purgeF( tinP ) ;
                        {
                        if( !bRpt )
                    
                        stWanters.purgeF( tinP ) ;
                        stChecked.sinkF( tinP , countTC() , entry.idSerial , flSTACKsINK_UNIQUE ) ;
                    
                        }
                            else etThread.delF( tinP , psttrLoop ) ;
                            }
                                bRpt = 1 ;
                                psttrLoop = 0 ;
                                stRpt << psttrLoop ;
                            {
                            if( bLoop && stWanters > 1 )
                            const boolT bSleep  = !bOsCall &&  !!( F(copy.flags) & flGRABs_PSEUDO ) ;
                            const boolT bOsCall = !!( F(copy.flags) & flGRABs_PSEUDOoScALL ) ;
                            const boolT bSign   = !!( F(copy.flags) & flGRABs_DOnOTrEGISTERiNtIN ) ;
                            grabS& copy = *(grabS*)entry.pbCopy ;
                        {
                        ZE( boolT , bRpt ) ;
                        etThread.strConcatenateF( tinP , psttrLoop , st_psttrLoop ) ; ___( psttrLoop ) ;
                        ZE( strokeS* , psttrLoop ) ;
                        boolT bLoop = wantersF( tinP , etThread , stWanters , &st_psttrLoop , entry , pGrabWantCopy , cGrabWant , stGrabbed , stIdSerialGrabExclude , stChecked , stBadGrabsTmp , stOsTidLoopedTmp , cIndent ) ;
                        }
                            st_psttrLoop << psttw ;
                            etThread.strMakeF( tinP , LF ,psttw , t6 ) ; ___( psttw ) ;
                            ZE( strokeS* , psttw ) ;
                        {
                        ZE( countT , cIndent ) ;
                        if( stIdSerialGrabExclude( entry.idSerial ) ) continue ;
                        grabEntryS& entry = *(grabEntryS*)&stGrabbed.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    stRpt << psttr3 ; psttr3 = 0 ;
                    etThread.strFuseF( tinP , psttr3 , t4+TF1(stGrabbed)+t5 ) ; ___( psttr3 ) ;
                    ZE( strokeS* , psttr3 ) ;
                    
                    etThread.memCopyF( tinP , (byteT*)pGrabWantCopy , (byteT*)pGrabWant , cbgwc ) ;
                    etThread.newF( tinP , LF , *(byteT**)&pGrabWantCopy , cbgwc ) ; ___( pGrabWantCopy ) ;
                    countT cbgwc = cGrabWant * sizeof( grabWantS ) ;
                    ZE( grabWantS* , pGrabWantCopy ) ;
                {
                if( !bMonitorEnded && stGrabbed )
                TELL( "report GT" )
                    
                }
                    etThread.delF( tinP , *(byteT**)&pGrabWantCopy ) ;
                    while( !bMonitorEnded && !stGrabbed.third && ~hDown && !etThread ) ;
                    }
                        }
                            }
                                }
                                    stRpt << psttOldC( tinP , etThread , tLine ) ;
                                    tLine += T("\r\n") ;
                                {
                                if( !bMonitorEnded )
                    
                                }
                                    tLine += T(" ")+TF1(pEntry->idSerial) ;
                                    stBadGrabs.sinkF( tinP , countTC() , (byteT*)pEntry , flSTACKsINK_UNIQUE , subtract_grabEntryS_F ) ;
                                    stBadGrabsTmp >> *(countT*)&pEntry ;
                                    ZE( grabEntryS* , pEntry ) ;
                                {
                                while( stBadGrabsTmp )
                                tLine += T(" /") ;
                            {
                            else //IF THE SLEEPING THREAD IS HOLDING UP OTHER THREADS
                            if( cSleepers < 2 ) stBadGrabsTmp.purgeF( tinP ) ;
                    
                            }
                                if( !st_ST_osTidSleeping( osTid ) ) st_ST_osTidPseudoSleeping.sinkF( tinP , countTC() , osTid , flSTACKsINK_UNIQUE ) ;
                    
                                tLine += T(" ")+TF1(osTid) ;
                                st_ST_osTidWoTree >> osTid ;
                                ZE( countT , osTid ) ;
                            {
                            while( st_ST_osTidWoTree )
                            countT cSleepers = st_ST_osTidWoTree ;
                    
                            while( !bMonitorEnded && !stGrabbed.third && ~hDown && !etThread ) ;
                            }
                                }
                                    stOsTidBad.sinkF( tinP , countTC() , osTid , flSTACKsINK_UNIQUE ) ;
                                    st_ST_osTidWoTree.sinkF(  tinP , countTC() , osTid , flSTACKsINK_UNIQUE ) ;
                                    stWanters >> osTid ;
                                    ZE( countT , osTid ) ;
                                {
                                while( stWanters )
                    
                                wantersF( tinP , etThread , stWanters , 0 , entryInner , pGrabWantCopy , cGrabWant , stGrabbed , stIdSerialGrabExclude , stChecked , stBadGrabsTmp , stOsTidLoopedTmp , cIndent ) ;
                                ZE( countT , cIndent ) ;
                                stIdSerialGrabExclude.sinkF( tinP , countTC() , copyInner.idMe , flSTACKsINK_UNIQUE ) ; //IF A GRAB IS GRABBED BY A SLEEPER THEN IT CANNOT BE INVOLVED IN A GRAB LOOP OR IN A OS CALL TREE
                                if( copyInner.osTid != copy.osTid || F(copyInner.flags) & flGRABs_DOnOTrEGISTERiNtIN ) continue ; //IF NOT OWNED BY THE SLEEPER OR IS A SIGN (SO SLEEPER IS NOT THE DESIGNATED UNGRABBER)
                                grabS& copyInner = *(grabS*)entryInner.pbCopy ;
                                grabEntryS& entryInner = *(grabEntryS*)&stGrabbed.downF( tinP , hDown ) ;
                            {
                            do
                            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    
                            st_ST_osTidSleeping.sinkF( tinP , countTC() , copy.osTid , flSTACKsINK_UNIQUE ) ;
                            st_ST_osTidWoTree.sinkF(  tinP , countTC() , copy.osTid , flSTACKsINK_UNIQUE ) ;
                            TN( tLine , "" ) ; tLine = TF3(copy.idMe,flFORMAT_UNSIGNED,8)+tb+TF3(copy.idiFileCt,flFORMAT_UNSIGNED,8)+tb+TF3(copy.idLineCt,flFORMAT_UNSIGNED,8) ;
                        {
                        if( bSleep )
                    
                        const boolT bSleep  = !bOsCall &&  !!( F(copy.flags) & flGRABs_PSEUDO ) ;
                        const boolT bOsCall = !!( F(copy.flags) & flGRABs_PSEUDOoScALL ) ;
                        const boolT bSign   = !!( F(copy.flags) & flGRABs_DOnOTrEGISTERiNtIN ) ;
                    
                        grabS& copy = *(grabS*)entry.pbCopy ;
                        grabEntryS& entry = *(grabEntryS*)&stGrabbed.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    
                    etThread.memCopyF( tinP , (byteT*)pGrabWantCopy , (byteT*)pGrabWant , cbgwc ) ;
                    etThread.newF( tinP , LF , *(byteT**)&pGrabWantCopy , cbgwc ) ; ___( pGrabWantCopy ) ;
                    countT cbgwc = cGrabWant * sizeof( grabWantS ) ;
                    ZE( grabWantS* , pGrabWantCopy ) ;
                {
                if( !bMonitorEnded && stGrabbed )
                stRpt << psttOldC( tinP , etThread , T(" \r\n[ZT]\r\n")+TPS("idSerial",8,sd)+tb+TPS("file",8,sd)+tb+TPS("line",8,sd)+tb+TPS("osTids",0x20,sd)+tc ) ;
                TELL( "report ZT" )
                    
                }
                    etThread.delF( tinP , *(byteT**)&pGrabWantCopy ) ;
                    while( !bMonitorEnded && !stGrabbed.third && ~hDown && !etThread ) ;
                    }
                        }
                            }
                                stRpt << psttOldC( tinP , etThread , tLine ) ;
                                tLine += T("\r\n") ;
                            {
                            if( !bMonitorEnded )
                    
                            }
                                }
                                    stOsTidBad.sinkF( tinP , countTC() , osTid , flSTACKsINK_UNIQUE ) ;
                                    st_ST_osTidPseudoBelieving.sinkF( tinP , countTC() , osTid , flSTACKsINK_UNIQUE ) ;
                                    tLine += T(" ")+TF1(osTid) ;
                                {
                                if( !bMonitorEnded )
                                st_ST_osTidWoTree >> osTid ;
                                ZE( countT , osTid ) ;
                            {
                            while( st_ST_osTidWoTree )
                            countT cBelievers = st_ST_osTidWoTree ;
                            TN( tLine , "" ) ; tLine = TF3(copy.idMe,flFORMAT_UNSIGNED,8)+tb+TF3(copy.idiFileCt,flFORMAT_UNSIGNED,8)+tb+TF3(copy.idLineCt,flFORMAT_UNSIGNED,8) ;
                    
                            }
                                while( !bMonitorEnded && !stGrabbed.third && ~hDown && !etThread ) ;
                                }
                                    }
                                        st_ST_osTidWoTree.sinkF(  tinP , countTC() , osTid , flSTACKsINK_UNIQUE ) ;
                                        stWanters2 >> osTid ;
                                        ZE( countT , osTid ) ;
                                    {
                                    while( stWanters2 )
                    
                                    wantersF( tinP , etThread , stWanters2 , 0 , entryInner , pGrabWantCopy , cGrabWant , stGrabbed , stIdSerialGrabExclude , stChecked , stBadGrabsTmp , stOsTidLoopedTmp , cIndent ) ;
                                    ZE( countT , cIndent ) ;
                    
                                    if( copyInner.osTid != osTid ) continue ; //IF NOT OWNED BY THE SLEEPER (U::WANTER?)
                                    grabS& copyInner = *(grabS*)entryInner.pbCopy ;
                                    grabEntryS& entryInner = *(grabEntryS*)&stGrabbed.downF( tinP , hDown ) ;
                                {
                                do
                                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                if( !bMonitorEnded ) st_ST_osTidWoTree.sinkF(  tinP , countTC() , osTid , flSTACKsINK_UNIQUE ) ;
                                stWanters >> osTid ;
                                ZE( countT , osTid ) ;
                            {
                            while( stWanters )
                    
                            wantersF( tinP , etThread , stWanters , 0 , entry , pGrabWantCopy , cGrabWant , stGrabbed , stIdSerialGrabExclude , stChecked , stBadGrabsTmp , stOsTidLoopedTmp , cIndent ) ;
                            ZE( countT , cIndent ) ;
                        {
                        if( bSign )
                    
                        const boolT bSleep  = !bOsCall &&  !!( F(copy.flags) & flGRABs_PSEUDO ) ;
                        const boolT bOsCall = !!( F(copy.flags) & flGRABs_PSEUDOoScALL ) ;
                        const boolT bSign   = !!( F(copy.flags) & flGRABs_DOnOTrEGISTERiNtIN ) ;
                    
                        grabS& copy = *(grabS*)entry.pbCopy ;
                        grabEntryS& entry = *(grabEntryS*)&stGrabbed.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    
                    etThread.memCopyF( tinP , (byteT*)pGrabWantCopy , (byteT*)pGrabWant , cbgwc ) ;
                    etThread.newF( tinP , LF , *(byteT**)&pGrabWantCopy , cbgwc ) ; ___( pGrabWantCopy ) ;
                    countT cbgwc = cGrabWant * sizeof( grabWantS ) ;
                    ZE( grabWantS* , pGrabWantCopy ) ;
                {
                if( !bMonitorEnded && stGrabbed )
                stGrabbed.grabF( tinP , TAG( TAGiDnULL ) ) ;

                stRpt << psttOldC( tinP , etThread , T(" \r\n[ST]\r\n")+TPS("idSerial",8,sd)+tb+TPS("file",8,sd)+tb+TPS("line",8,sd)+tb+TPS("osTids",0x20,sd)+tc ) ;
                TELL( "report ST" )
                    
                stGrab.ungrabF( tinP ) ;
                }
                    while( !bMonitorEnded && !stGrab.third && ~hDown ) ; // THE LAST TERM IS INTENDED TO CAUSE AN EARLY ESCAPE IF I WAS FIRED DURING THIS REPORTING CYCLE
                    }
                        }
                            stGrabbed << (byteT*)&entry ;
                            etThread.memCopyF( tinP , entry.pbCopy , (byteT*)pCopy , sizeof( grabS ) ) ;
                            etThread.newF( tinP , LF , entry.pbCopy , sizeof( grabS ) ) ; ___( entry.pbCopy ) ;
                        {
                        if( pCopy && pCopy->osTid && pCopy->idMe ) // pCopy IS EITHER 0 OR A VALID IMAGE OF A grabS
                            
                        }
                            }
                                if( !bOk || pCopy2->fingerprint != FINGERnEG_grabS || entry.idSerial != pCopy2->idMe ) pCopy = 0 ;
                                thirdC::dosReadProcessMemoryIF( tinP , pbCopy2 , sizeof( grabS ) , bOk , (voidT*)entry.ip , entry.osPid ) ;
                                bOk = 0 ;
                                grabS* pCopy2 = (grabS*)pbCopy2 ;
                                byteT pbCopy2[ sizeof( grabS ) ] ;
                            {
                            else
                            if( !bOk || pCopy->fingerprint != FINGERnEG_grabS || entry.idSerial != pCopy->idMe ) pCopy = 0 ;
                            thirdC::dosReadProcessMemoryIF( tinP , pbCopy , sizeof( grabS ) , bOk , (voidT*)entry.ip , entry.osPid ) ;
                            ZE( boolT , bOk ) ;
                        {
                        else
                        }
                            }
                                if( pCopyI->fingerprint != FINGERnEG_grabS || entry.idSerial != pCopyI->idMe ) pCopy = 0 ;
                                etThread.memCopyF( tinP , pbCopy , (byteT*)pCopyI , sizeof( grabS ) ) ;
                            {
                            if( pCopyI->fingerprint == FINGERnEG_grabS && entry.idSerial == pCopyI->idMe )
                            grabS* pCopyI = (grabS*)(byteT*)ap_artmentOldC( tinP , entry.ip ) ;
                        {
                        if( entry.bIda )
                        grabS* pCopy = (grabS*)pbCopy ;
                        byteT pbCopy[ sizeof( grabS ) ] ;
                    
                        grabEntryS& entry = *(grabEntryS*)&stGrab.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stGrab )
                stGrab.grabF( tinP , TAG( TAGiDnULL ) ) ;

                //CONoUTrAW3( "stGrab contains " , stGrab , " entries\r\n" ) ;
    
                stRpt << psttr2 ; psttr2 = 0 ;            
                etThread.strFuseF( tinP , psttr2 , t2+TF1(stGrab)+t3 ) ; ___( psttr2 ) ;
                ZE( strokeS* , psttr2 ) ;
                TELL( "report RG" )
            {
    
            stNapkin.ungrabF( tinP ) ;
            }
                while( !bMonitorEnded && !stNapkin.third && ~hDown ) ;
                }
                    stRpt << psttr ;
                    etThread.strFuseF( tinP , psttr , TF1(entry.osPid)+tb+T("\"")+T(entry.postName)+T("\"")+tc ) ; ___( psttr ) ;
                    ZE( strokeS* , psttr ) ;
                    napkinEntryS& entry = *(napkinEntryS*)&stNapkin.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( stNapkin )
            stNapkin.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
            stRpt << psttr1 ; psttr1 = 0 ;
            etThread.strFuseF( tinP , psttr1 , tB ) ; ___( psttr1 ) ;
            TELL( "report NS: listing the napkin images" )
            
            stPool.ungrabF( tinP ) ;
            }
                while( !bMonitorEnded && !stPool.third && ~hDown ) ;
                }
                    stRpt << psttr ;
                    etThread.strFuseF( tinP , psttr , TF1(entry.osPid)+tb+TF1(entry.idClient)+tb+T(entry.postName)+tc ) ; ___( psttr ) ;
                    ZE( strokeS* , psttr ) ;
                    poolOldEntryS& entry = *(poolOldEntryS*)&stPool.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( stPool )
            stPool.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
            stRpt << psttr1 ; psttr1 = 0 ;
            etThread.strFuseF( tinP , psttr1 , tA ) ; ___( psttr1 ) ;
            TELL( "report PS: listing the poolOld images" )

            }
                if( !( ++ idIn % 0x1000 ) ) etThread.ifcSayF( tinP , T("host.idSerialLath: ")+TF1(host.idSerialLath) , flSAY_APPEND | flSAY_LOG ) ;
                static countT idIn ;
            {
            else
            }
                etThread.osFireF( tinP ) ;
                etThread.ifcSayF( tinP , T("OS FIRED BECAUSE SERIAL NUMBERS ARE ALMOST EXHAUSTED !") , flSAY_APPEND | flSAY_LOG ) ;
            {
            if( host.idSerialLath > 0xffff0000 )

            stRpt << psttr1 ; psttr1 = 0 ;            
            etThread.strFuseF( tinP , psttr1 , t1+TF1(host.idSerialLath)+tc ) ;
            TELL( "report idSerialLath" )
            
                etThread.strFuseF( tinP , psttr1 , TF3(off+1,flFORMAT_UNSIGNED,3)+TF1(pfa[ off ].cHeartBeats )+tc ) ;
            for( countT off = 0 ; off < CfIREaLLrANKS ; off ++ )
            TELL( "report heartbeats" )
            
            etThread.strMakeF( tinP , LF , psttr1 , tTitle1+TT(timeN1,timeN2)+tTitle2+TF1(++idReport)+tTitle3 , ( CfIREaLLrANKS + 2 ) * 0x40 ) ; ___( psttr1 ) ;
            ZE( strokeS* , psttr1 ) ;
            TELL( "report title" )
        
            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
            TELL( "getting the time" )

            ////***********************************************************************************************************************
            //THREADmODE1oN( flTHREADmODE1_USEaSYNCHtELLmONITOR )
            //bGrabbedConditionalGrab = 1 ;
            //}
            //    while( setIfZeAM( conditionalGrab , 1 ) ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
            //    ZE( countT , ecz ) ;
            //    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //{
            //TELL( "conditionalGrab" )
            //U: IF A SETTING FILE EXISTS THEN ESCAPE FROM THIS GRAB AFTER 1 TICK, AFTER LOGGING THAT THIS IS BEING DONE (AND FLUSHING THE LOG TO DISK)
        {
        while( !etThread && !bMonitorEnded )
        stackC stFlavor( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , 2 * sizeof( countT ) ) ;
        stackC st_psttrLoop( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    
        ;        
            tb+T("like [HW] but displays data separately for kernel, bang, and application adams")+tc2
            tb+T("tally of what all ifc threads are doing on the local host within each adam class")+tc+
            T("[CW]")+tc+
            tb+T("for example, it might indicate that the thread is in a blocking base os call")+tc2+
            tb+T("tinS::idWhat is maintained by the system to indicate what the thread is doing")+tc+
            tb+T("tally of what all ifc threads are doing on the local host")+tc+
            T("[HW]")+tc+
            tb+T("considered")+tc2+
            tb+T("anyway in IFC code because IFC code is monitored, and the costs of monitoring must be")+tc+
            tb+T("a longer lived instance and reuse it.  (this compromises data hiding, but is done")+tc+
            tb+T("it is bad coding style to construct such objects ephemerally; instead, construct")+tc+
            tb+T("most monitor input is elicited by constructing objects containing grabS objects")+tc+
            tb+T("it is generally good to avoid unnecessary monitor input")+tc+
            tb+T("monitor input elicits monitor activity, which runs at RUSH priority")+tc+
            tb+T("shows which code lines are generating the most input to the monitor")+tc+
            tb+T("tally of talking to monitor")+tc+
            T("[TT]")+tc+
            tb+T("each line of this report presents that tally for the indicated thread")+tc2+
            tb+T("if a thread is actively working, that observation is tallied")+tc+
            tb+T("all threads are inspected for these tallies\r\n")+tc+
            tb+T("tally of actively working threads on the local host")+tc+
            T("[TA]")+tc+
            tb+T("for each TAG( TAGiDnULL ), a nest line displays the FI and, if possible, the name of the TAG( TAGiDnULL )")+tc2+
            tb+T("TAG( TAGiDnULL ) of each call nest level.")+tc+
            tb+T("the colon line displays osPid and idThread padded with colons, the thread name, and then the")+tc+
            tb+T("each entry consists of a \"colon line\" followed by 0 or more \"nest lines\".")+tc+
            tb+T("detailed list of \"interesting\" threads")+tc+
            T("[TD]")+tc+
            tb+T(" L: looped (involved in a grab loop)")+tc2+
            tb+T(" z: pseudoSleeping (indirectly sleeping)")+tc+
            tb+T(" Z: sleeping")+tc+
            //tb+T(" M: messiah (giver of a sign)")+tc+
            tb+T(" B: pseudoBeliever (directly or indirectly waiting for a sign)")+tc+
            tb+T("g codes (g is for grabS):")+tc+
            tb+T("thread: postThreadName: the name of the thread")+tc+
            tb+T("pid: the raw process id")+tc+
            tb+T("osTid: the raw thread id")+tc+
            tb+T("the features that make a thread interesting are documented in the preceding explanatory notes")+tc+
            tb+T("summary list of \"interesting\" threads")+tc+
            T("[TS]")+tc+
            tb+T("(a grabS object that is viewed by multiple cells appears in this list only wo time)")+tc2+
            tb+T("pid: osPid: the raw process id of the cell that constructed this grabS object")+tc+
            tb+T("line: idLineCt: the source code line in that file that constructs this grabS object")+tc+
            tb+T("file: idiFileCt: the source code file that contains the code line that constructs this grabS object")+tc+
            tb+T("idSerial: the serial number of the grabS object")+tc+
            tb+T("a grabS is interesting if it is involved in a grab loop or a sleep tree")+tc+
            tb+T("list of \"interesting\" grabS objects")+tc+
            T("[GS]")+tc+
            tb+T("interesting thread: each thread that is involved in a grab loop")+tc2+
            tb+T("interesting thread: each thread that is directly or indirectly waiting for a sign")+tc+
            tb+T("4 (OS CALL): the thread that \"has\" this object (tinS::pseudoGrab) is in a base os call")+tc+
            tb+T("3 (SLEEP): the thread that \"has\" this object (tinS::pseudoGrab) is asleep")+tc+
            tb+T("2 (WANTED SIGN): this object is being used as a signC and is wanted by wo or more threads")+tc+
            tb+T("1 (GRAB LOOP): the thread that has grabbed this object directly or indirectly also wants it")+tc+
            tb+T("a [GW] report is written for each grabbed grabS object that is \"interesting\", i.e. wo or more of the following applies:")+tc+
            tb+T("each of these multiline entries lists the threads that directly or indirectly want a grabbed grabS object")+tc+
            T("[GW]")+tc+
            tb+T("lists the grabS object views that are grabbed")+tc2+
            T("[GG]")+tc+
            tb+T("interesting thread: each thread that is directly or indirectly sleeping")+tc2+
            tb+T("each line of this report corresponds to wo tinS::grabPseudo that indicates sleeping")+tc+
            tb+T("indirectly want those objects are \"indirectly sleeping\"")+tc+
            tb+T("if a sleeping thread has grabbed some grabS objects, all threads that directly or")+tc+
            tb+T("sleep trees: all threads that are indirectly blocked because a thread is sleeping")+tc+
            T("[ZT]")+tc+
            tb+T("if 3 cells have opened a view to a grabS object that is grabbed, then that object contributes 3 to this tally")+tc2+
            tb+T("recursion does not affect the tallies reported here")+tc+
            tb+T("a thread that has grabbed a grabS can recursively grab that object (unless the grabS object is configured to disallow recursion)")+tc+
            tb+T("only wo thread at a time can grab a grabS object")+tc+
            T("[GT]")+tc+
            tb+T("(example) grabS object views: if there are 11 grabS objects, and wo of them can be seen by 3 cells, then there are 31 views")+tc2+
            tb+T("(def) grabS object views: this is the sum, over all grabS objects on the local host, of the number of cells that have opened a view of the grabS object")+tc+
            tb+T("some grabS objects can be viewed by multiple cells (processes) on the local host")+tc+
            tb+T("(please report all violations of this design specification)")+tc+
            tb+T("an ifc thread cannot stop (\"lock up\", \"hang\", etc.) without \"grabbing a grabS object\".")+tc+
            T("[RG]")+tc+
            tb+T("postName: name of the napkinC object that backs the view")+tc2+
            tb+T("osPid: the base operating system's id of the process that has this view open")+tc+
            tb+T("each view of memory, when opened by constructing a napkinC object, is listed here")+tc+
            tb+T("list of napkinC views")+tc+
            T("[NS]")+tc+
            tb+T("postName: name of the napkinC object that backs the poolC view")+tc2+
            tb+T("idClient: the id of this view (this poolC object) of the napkinC backing object")+tc+
            tb+T("osPid: the base operating system's id of the process that has this view open")+tc+
            tb+T("each view of such memory, when opened by constructing a poolC object, is listed here")+tc+
            tb+T("shared memory is used for dynamic memory allocation")+tc+
            tb+T("list of poolC views")+tc+
            T("[PS]")+tc+
            tb+T("idSerialLath: The lath (highest) serial number obtained on this host (by any cell)")+tc2+
            T("[SL]")+tc+
            tb+T("group 01 is reserved for cells that fire other cells")+tc2+
            tb+T("group f is reserved for the monitor (the cell that writes this report)")+tc+
            tb+T("cells are assigned to group 5 unless specified otherwise in the adam definition")+tc+
            tb+T("cHeartBeats: each cell increments this until its main function returns")+tc+
            tb+T("gr: idFireAllGroup")+tc+
            T("[FA]")+tc+
            tb+T("idReport: the number of generations of this report written since the IdeaFarm " "(tm) Operating System was started on this computer")+tc2+
            tb+T("the time of the report is represented according to the customs of IdeaFarm " "(tm) City")+tc+
            tb+T("(\"01 tock\" means 16 (base 10) tocks, or approximately 30 seconds)")+tc+
            tb+T("(a tock is approximately 1.33 seconds")+tc+
            tb+T("Local Monitor Report: this report is written every 01 tock by the IdeaFarm " "(tm) Operating System")+tc+
            tb+T("these programs are called \"IdeaFarm " "(tm) Cells\"")+tc+
            tb+T("some programs on this computer are using the IdeaFarm " "(tm) Operating System")+tc+
            tb+T("IdeaFarm " "(tm) Operating System: runs \"on top of\" this computer's base operating system (e.g. MS Windows)")+tc+
            tb+T("for support, see http://www.ideafarm.com or call Wo'O Ideafarm US 650-759-5306")+tc+
            T("[ID]")+tc+
            TPS(" \r\nexplanatory notes ",0x40,S1C('-'))+tc2+
        TN( tNotes , "" ) ; tNotes =
        TN( tB , " \r\n[NS]\r\n" ) ;
        TN( tA , " \r\n[PS]\r\n" ) ;
        TN( t9 , " \r\n[TD]\r\n" ) ;
        TN( tTell , "" ) ; tTell = TPS("tell|tellIf",0x20,sttu) ;
        TN( tWhat , " g " ) ;
        TN( tIn , "in_____" ) ;
        TN( tNest , "nes" ) ;
        TN( tThread , "" ) ; tThread = TPS("thread",0x20,sttu) ;
        TN( tIdThread , "" ) ; tIdThread = TPS("id",0x8,sttu) ;
        TN( tIdName , "" ) ; tIdName = TPS("name",4,sttu) ;
        TN( tType , "" ) ; tType = T("typ") ;
        TN( tMarked , "* " ) ;
        TN( tNewSteps , "" ) ; tNewSteps = TPS("steps",8,sttu) ;
        TN( tOsTid , "" ) ; tOsTid = TPS("osTid",8,sttu) ;
        TN( t8 , " \r\n[TS]\r\n" ) ;
        TN( tPid , "" ) ; tPid = TPS("pid",8,sttu) ;
        TN( tLine , "" ) ; tLine = TPS("line",8,sttu) ;
        TN( tFile , "" ) ; tFile = TPS("file",8,sttu) ;
        TN( tOsFileName , osFileNameC( tinP , etThread , "///d/ideafarm.rpt.monitor.main" ) ) ;
        TN( tIP , "" ) ; tIP = TPS("ip",8,sttu) ;
        TN( tBIda , "" ) ; tBIda = TPS("bIda",8,sttu) ;
        TN( tIdSerial , "" ) ; tIdSerial = TPS("idSerial",8,sttu) ;
        TN( t7 , "\r\n[GS]\r\n" ) ; 
        strokeS sttu('-') ;
        TN( t6 , " \r\n[GW]\r\n" ) ;
        TN( t5 , " grabS object views are grabbed\r\n" ) ;
        TN( t4 , "\r\n[GT] " ) ;
        TN( t3 , " grabS object views are registered\r\n" ) ;
        TN( t2 , " \r\n[RG] " ) ;
        TN( t1 , " \r\n[SL] idSerialLath: " ) ;
        TN( tTitle3 , "\r\n \r\n[FA]\r\ngr cHeartBeats\r\n" ) ;
        TN( tTitle2 , "\r\nidReport: " ) ;
        TN( tTitle1 , "[ID]\r\nIdeaFarm " "(tm) Operating System\r\nLocal Monitor Report\r\n(see the explanatory notes at the end of this report)\r\n" ) ;
        TN( tNull , "" ) ;
        TN( tb , " " ) ;
        TN( tc2 , "\r\n \r\n" ) ;
        TN( tc , "\r\n" ) ;
        TN( tBar , " | " ) ;
        TELL( "setting up: 2: stroke strings" )
    
        tinP.pEtText = &etThread ;
        tinP.flagsThreadMode1 |= flTHREADmODE1_DISALLOWgRAB ;
        ZE( countT , idStepReporterLath ) ;
        boolT bWoth = 1 ;
        ZE( countT , idReport ) ;
        monitorLookF( tinP , pGrabWant , cGrabWant , pGrabHave , cGrabHave ) ;
        ZE( countT     , cGrabHave ) ;
        ZE( grabHaveS* , pGrabHave ) ;
        ZE( countT     , cGrabWant ) ;
        ZE( grabWantS* , pGrabWant ) ;
        strokeS sd( '-' ) ;
        fireAllS* pfa = (fireAllS*)( pcn + 2 ) ;
        CTnAPfIREaLL
        TELL( "setting up: 1: misc" )
    {
    else
    }
        //if( bGrabbedConditionalGrab ) conditionalGrab = 0 ;
    {
    if( _restart )
    RESTART ;
    //ZE( boolT , bGrabbedConditionalGrab ) ;

    homeS& host = homeS::homeIF() ;

    stackC&             stRecycle_pwtFineP         =             *(stackC*)c8p5.c1 ;
    stackC&             stRecycle_pwtGrossP        =             *(stackC*)c8p4.c8 ;
    switchC&            swWhereTallyTalkingP       =            *(switchC*)c8p4.c7 ;
    count5S&            c5leverTallyTalkingP       =            *(count5S*)c8p4.c6 ;
    switchC&            swWhereTallyActiveThread   =            *(switchC*)c8p4.c5 ;
    count5S&            c5leverTallyActiveThread   =            *(count5S*)c8p4.c4 ;
    switchC&            swWhereTalliesGrossClass   =            *(switchC*)c8p4.c3 ;
    countT&             cLeverTalliesGrossClass    =             *(countT*)c8p4.c2 ;
    whereTalliesGrossS& wtGrossHostP               = *(whereTalliesGrossS*)c8p4.c1 ;
    stackC&             st_ST_osTidPseudoBelieving =             *(stackC*)c8p3.c8 ;
    stackC&             st_ST_osTidMessiah         =             *(stackC*)c8p3.c7 ;
    stackC&             st_ST_osTidPseudoSleeping  =             *(stackC*)c8p3.c6 ;
    stackC&             st_ST_osTidSleeping        =             *(stackC*)c8p3.c5 ;
    stackC&             stIdSerialGrabExclude      =             *(stackC*)c8p3.c4 ;
    stackC&             st_ST_osTidWoTree          =             *(stackC*)c8p3.c3 ;
    stackC&             stRpt                      =             *(stackC*)c8p3.c2 ;
    //countT&             conditionalGrab          =             *(countT*)c8p3.c1 ;
    boolT&              bDestroyCircleLog          =              *(boolT*)c8p2.c8 ;
    stackC&             stTin                      =             *(stackC*)c8p2.c7 ;
    stackC&             stNapkin                   =             *(stackC*)c8p2.c6 ;
    stackC&             stPool                     =             *(stackC*)c8p2.c5 ;
    stackC&             stOsTidBad                 =             *(stackC*)c8p2.c4 ;
    stackC&             stOsTidLooped              =             *(stackC*)c8p2.c3 ;
    stackC&             stOsTidLoopedTmp           =             *(stackC*)c8p2.c2 ;
    stackC&             stBadGrabs                 =             *(stackC*)c8p2.c1 ;
    stackC&             stBadGrabsTmp              =             *(stackC*)c8p1.c8 ;
    stackC&             stChecked                  =             *(stackC*)c8p1.c7 ;
    stackC&             stWanters2                 =             *(stackC*)c8p1.c6 ;
    stackC&             stWanters                  =             *(stackC*)c8p1.c5 ;
    stackC&             stGrabbed                  =             *(stackC*)c8p1.c4 ;
    stackC&             stLifiP                    =             *(stackC*)c8p1.c3 ;
    stackC&             stGrab                     =             *(stackC*)c8p1.c2 ;
    boolT&              bMonitorEnded              =              *(boolT*)c8p1.c1 ;

    count8S&    c8p5      = *(count8S*)pTaskP->c5 ;
    count8S&    c8p4      = *(count8S*)pTaskP->c4 ;
    count8S&    c8p3      = *(count8S*)pTaskP->c3 ;
    count8S&    c8p2      = *(count8S*)pTaskP->c2 ;
    count8S&    c8p1      = *(count8S*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;
tinP.idPhase2 = 1 ;
TASK( tmRptMainF )

}
    wtgP.swTally.ungrabF( tinP ) ;
    wtgP.purgeF( tinP ) ;
    }
        etThread.delF( tinP , pbc2 ) ;
        }
            stRptP << psttr5 ; psttr5 = 0 ;
            etThread.strFuseF( tinP , psttr5 , TF3(wtgP.swTally,flFORMAT_UNSIGNED,9)+tName+tc ) ;
            ZE( strokeS* , psttr5 ) ;
            TN( tName , "" ) ; tName = T(processGlobal4I.mapWhat(wtgP.idWhatLever)) ;
            
            wtgP.idWhatLever = wtgP.swTally.leverF( tinP , c2f.c2 ) ;
            count2S& c2f = *(count2S*)pbc2 ;
        {
        if( pbc2 )
        stFlavorP >> pbc2 ;
        ZE( byteT* , pbc2 ) ;
    {
    while( stFlavorP )
                
    }
        stFlavorP.sinkF( tinP , countTC() , (byteT*)&c2f , flSTACKsINK_null , subtractTallyF ) ;
        count2S c2f( vv , idf ) ;
        countT vv = wtgP.swTally ;
        wtgP.idWhatLever = wtgP.swTally.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = wtgP.swTally.cFlavorsF( tinP ) ;
    wtgP.swTally.grabF( tinP , TAG( TAGiDnULL ) ) ;
    TN( tc , "\r\n" ) ;
{
voidT writeGrossReportF( tinS& tinP , etherC& etThread , stackC& stRptP , whereTalliesGrossS& wtgP , stackC& stFlavorP )

}
    swWhereTallyActiveThreadP.ungrabF( tinP ) ;
    swWhereTallyActiveThreadP.freeAllF( tinP ) ;

    }
        etThread.delF( tinP , pbc2 ) ;
        }
            stRptP << psttOldC( tinP , etThread , TF3(c2f.c1,flFORMAT_UNSIGNED,9)+TF3(c5leverTallyActiveThreadP.c3,flFORMAT_UNSIGNED,9)+TF3(c5leverTallyActiveThreadP.c4,flFORMAT_UNSIGNED,9)+TF3(c5leverTallyActiveThreadP.c5,flFORMAT_UNSIGNED,9)+TF4(c5leverTallyActiveThreadP.c1&0xfff,flFORMAT_UNSIGNED,0xc,0xa)+TF3(c5leverTallyActiveThreadP.c2,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+tb+tName+tc ) ;
    
            }
                stLifiP.ungrabF( tinP ) ;
                }
                    tName = T(old.postName) ;
                    lifiEntryS& old = *(lifiEntryS*)&(countT&)stLifiP[ 0 ] ;
                {
                if( ids )
                stLifiP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_lifiEntryS_F ) ;
                ZE( countT , ids ) ;
                lifiEntryS entry( tinP , c5leverTallyActiveThreadP.c1 & 0xfff , c5leverTallyActiveThreadP.c2 , "" ) ;
                stLifiP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            TN( tName , "" ) ;

            c5leverTallyActiveThreadP = *(count5S*)swWhereTallyActiveThreadP.leverF( tinP , c2f.c2 ) ;
            count2S& c2f = *(count2S*)pbc2 ;
        {
        if( pbc2 )
        stFlavorP >> pbc2 ;
        ZE( byteT* , pbc2 ) ;
    {
    while( stFlavorP )

    }
        stFlavorP.sinkF( tinP , countTC() , (byteT*)&c2f , flSTACKsINK_null , subtractTallyF ) ;
        count2S c2f( vv , idf ) ;
        countT vv = swWhereTallyActiveThreadP ;

        c5leverTallyActiveThreadP = *(count5S*)swWhereTallyActiveThreadP.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swWhereTallyActiveThreadP.cFlavorsF( tinP ) ;
    stRptP << psttOldC( tinP , etThread , T(" \r\n[TA]\r\n") ) ;
    swWhereTallyActiveThreadP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    TN( tc , "\r\n" ) ;
    TN( tb , " " ) ;
{
voidT writeActiveReportF( tinS& tinP , etherC& etThread , stackC& stRptP , switchC& swWhereTallyActiveThreadP , count5S& c5leverTallyActiveThreadP , stackC& stFlavorP , stackC& stLifiP )

}
    swWhereTallyTalkingP.ungrabF( tinP ) ;
    swWhereTallyTalkingP.freeAllF( tinP ) ;

    }
        etThread.delF( tinP , pbc2 ) ;
        }
            stRptP << psttOldC( tinP , etThread , TF3(c2f.c1,flFORMAT_UNSIGNED,9)+TF3(c5leverTallyTalkingP.c3,flFORMAT_UNSIGNED,9)+TF3(c5leverTallyTalkingP.c4,flFORMAT_UNSIGNED,9)+TF3(c5leverTallyTalkingP.c5,flFORMAT_UNSIGNED,9)+TF4(c5leverTallyTalkingP.c1&0xfff,flFORMAT_UNSIGNED,0xc,0xa)+TF3(c5leverTallyTalkingP.c2,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+tb+tName+tc ) ;
    
            }
                stLifiP.ungrabF( tinP ) ;
                }
                    tName = T(old.postName) ;
                    lifiEntryS& old = *(lifiEntryS*)&(countT&)stLifiP[ 0 ] ;
                {
                if( ids )
                stLifiP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_lifiEntryS_F ) ;
                ZE( countT , ids ) ;
                lifiEntryS entry( tinP , c5leverTallyTalkingP.c1 & 0xfff , c5leverTallyTalkingP.c2 , "" ) ;
                stLifiP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            TN( tName , "" ) ;

            c5leverTallyTalkingP = *(count5S*)swWhereTallyTalkingP.leverF( tinP , c2f.c2 ) ;
            count2S& c2f = *(count2S*)pbc2 ;
        {
        if( pbc2 )
        stFlavorP >> pbc2 ;
        ZE( byteT* , pbc2 ) ;
    {
    while( stFlavorP )

    }
        stFlavorP.sinkF( tinP , countTC() , (byteT*)&c2f , flSTACKsINK_null , subtractTallyF ) ;
        count2S c2f( vv , idf ) ;
        countT vv = swWhereTallyTalkingP ;

        c5leverTallyTalkingP = *(count5S*)swWhereTallyTalkingP.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swWhereTallyTalkingP.cFlavorsF( tinP ) ;
    stRptP << psttOldC( tinP , etThread , T(" \r\n[TT]\r\n") ) ;
    swWhereTallyTalkingP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    TN( tc , "\r\n" ) ;
    TN( tb , " " ) ;
{
voidT writeTalkingReportF( tinS& tinP , etherC& etThread , stackC& stRptP , switchC& swWhereTallyTalkingP , count5S& c5leverTallyTalkingP , stackC& stFlavorP , stackC& stLifiP )

}
//CONoUTrAW( "-" ) ; //U::
    }
        off ++ ;

        }
            if( cLifiLimit && !( -- cLifiLimit ) ) break ;

            etThread.strFuseF( tinP , psttP , TP("",-1+cIndentP+off)+TF3(pczLifiP[off],flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+tb+tq+tName+tqc ) ;

            }
                stLifiP.ungrabF( tinP ) ;
                }
                    tName = T(old.postName) ;
                    lifiEntryS& old = *(lifiEntryS*)&(countT&)stLifiP[ 0 ] ;
                {
                if( ids )
                stLifiP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_lifiEntryS_F ) ;
                stLifiP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                ZE( countT , ids ) ;
                lifiEntryS entry( tinP , pczLifiP[ off - 1 ] & 0xfff , pczLifiP[ off ] , "" ) ;
            {
            if( !tName.csF( tinP ) )
            TN( tName , postf ) ;

            osTextT* postf = processGlobal8I.source.postFileTitleF( tinP , processGlobal8I.source.idFileRankF( tinP , pczLifiP[ off ] ) ) ;
        {
        if( off % 2 )
    {
    else while( pczLifiP[ off ] )
    }
        }
            off ++ ;
            if( off % 2 && cLifiLimit && !( -- cLifiLimit ) ) break ;
            etThread.strFuseF( tinP , psttP , tb+TF4(off%2?pczLifiP[off]:pczLifiP[off]&0xfff,flFORMAT_UNSIGNED|(off%2?flFORMAT_FILLzE:flFORMAT_null),7,off%2?0x10:0xa) ) ;
        {
        while( pczLifiP[ off ] )
    {
    if( bTerseP )
    off = 0 ;
    TN( tc , "\r\n" ) ;
    TN( tb , " " ) ;
    TN( tqc , "\"\r\n" ) ;
    TN( tq , "\"" ) ;
    cLifiLimit = cLifiLimitP ;

    }
        debug = cstta ; //U::
        etThread.strFuseF( tinP , psttP , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ cstta ) ;
        }
            off ++ ;
            }
                if( cLifiLimit && !( -- cLifiLimit ) ) break ;
                cstta += bTerseP ? 0x20 : 0x200 ;
            {
            if( off % 2 )
        {
        while( pczLifiP[ off ] )
        countT cstta = bTerseP ? 0 : 0x200 ;
    {
    if( !psttP )
    ZE( countT , debug ) ; //U::
    ZE( countT , off ) ;
    countT cLifiLimit = cLifiLimitP ;
//CONoUTrAW( "+" ) ; //U::
{
voidT psttOldCallNestF( tinS& tinP , etherC& etThread , strokeS*& psttP , stackC& stLifiP , const countT cIndentP , const countT* const pczLifiP , const boolT bTerseP , const countT cLifiLimitP = 0 )

}
    grabS::_lookIF( tinP , pGrabWantP , cGrabWantP , pGrabHaveP , cGrabHaveP ) ;
{
voidT monitorLookF( tinS& tinP , grabWantS*& pGrabWantP , countT& cGrabWantP , grabHaveS*& pGrabHaveP , countT& cGrabHaveP )

DONE( tmLogSnapF )
tinP.idPhase2 = 0 ;
}
    bDestroyCircleLog = 1 ;
    }
        }
            }
                thirdC::dosSleepIF( tinP , TUCK * 0x4 ) ;
                ++ s ;
            {
            while( !etThread && !sgnDone_tmRptMainF && cToDo -- )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        countT cToDo = TUCK * 0x4 ;
        TELL( "nap for up to 01 tocks" )

        }
            etThread.delF( tinP , pbCircle ) ;
            writeLogF( tinP , etThread , pbCircle + offBegin , cbCircle - offBegin , ++ idReport , timeN1 , timeN2 ) ;
            etThread.etherSnapCyrcleOldF( tinP , pbCircle , cbCircle , offBegin , pNapLog , T(POSTlOG) , CBlOG ) ;
            ZE( countT , offBegin ) ;
            ZE( countT , cbCircle ) ;
            ZE( byteT* , pbCircle ) ;
            __Z( pNapLog ) ;

            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
        {
        TELL( "snapping the log circle" )
    {
    while( !sgnDone_tmRptMainF )
    ZE( countT , idReport ) ;

    boolT&    bDestroyCircleLog  =    *(boolT*)pTaskP->c3 ;
    napkinC*& pNapLog            = *(napkinC**)pTaskP->c2 ;
    signC&    sgnDone_tmRptMainF =    *(signC*)pTaskP->c1 ;
{                     
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
tinP.idPhase2 = 1 ;
TASK( tmLogSnapF )

DONE( tmCircleLogF )
tinP.idPhase2 = 0 ;
ether.etherFireImpersonateMonitorIF( tinP ) ; // REDUNDANT EXCEPT WHEN GET HERE DUE TO AN EXCEPTION IN 2e40104
}
    DEL( pNapLog ) ;
    TELL( "cleaning up" )

    etThread.etherReadFromCyrcleOldF( tinP , pNapLog , cirLogF , countTC() , bDestroyCircleLog , T(POSTlOG) , CBlOG ) ;
U::NEED TO PASS IN A bitsC REFERENCE
    TELL( "calling etherReadFromCyrcleOldF" )
    boolT&    bDestroyCircleLog =    *(boolT*)pTaskP->c2 ;
    napkinC*& pNapLog           = *(napkinC**)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
tinP.idPhase2 = 1 ;
TASK( tmCircleLogF )

}
    return - sgn ; // HIGHEST TALLY IS "LIGHTEST"
    }
        if( tinP.fingerprint && c3P ) ;
    
        }                       
            else if( pc1->c2 > pc2->c2 ) sgn = - 1 ;
            else if( pc1->c2 < pc2->c2 ) sgn =   1 ; // LOWEST idf (LOWEST LEVER VALUE) IS LIGHTEST
            else if( pc1->c1 < pc2->c1 ) sgn = - 1 ;
                 if( pc1->c1 > pc2->c1 ) sgn =   1 ;
        {
        if( pc1 && pc2 )
    
        count2S* pc2 = (count2S*)c2P ;
        count2S* pc1 = (count2S*)c1P ;
    
        }
            etherC& ether = *(etherC*)pEther ;
        {
        if( pEther )
    {
    ZE( sCountT , sgn ) ;
    _IO_    //TLNA( "subtractTallyF" )

    }
    {
    IFbEcAREFUL
{
countT subtractTallyF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return 0 ;
    }
        TELL( "cirLogF/-" )
        if( tinP.fingerprint && etherP && cParmP && pbP && cbP ) ;
        TELL( "cirLogF/+" )
    {
    _IO_    TLNA( "cirLogF" )
{
countT cirLogF( tinS& tinP , etherC& etherP , countT& cParmP , const byteT* const pbP , const countT cbP )

}
    return bLoop ;
    TELL( "wantersF: ----" )

    }
        cIndentP -- ;
        }
            wanters0F( tinP , etThread , bLoop , stWantersP , pSt_psttrP , pGrabWantP , cGrabWantP , stGrabbedP , stIdSerialGrabExcludeP , stCheckedP , stBadGrabsTmpP , stOsTidLoopedTmpP , cIndentP , osTidWant ) ;

            if( !osTidWant ) break ; // pGrabWantP IS VOLATILE
            countT osTidWant = pGrabWantP[ ogw ].osTid ;

            if( copy.idMe != pGrabWantP[ ogw ].idGrab ) continue ;
            if( pGrabWantP[ ogw ].bDirty ) continue ;
        {
        else for( countT ogw = 0 ; ogw < cGrabWantP && !bLoop ; ogw ++ )
        }
            if( osTidHave ) wanters0F( tinP , etThread , bLoop , stWantersP , pSt_psttrP , pGrabWantP , cGrabWantP , stGrabbedP , stIdSerialGrabExcludeP , stCheckedP , stBadGrabsTmpP , stOsTidLoopedTmpP , cIndentP , osTidHave ) ;
        {
        if( bOsCall || bSleep )

        }       
            *pSt_psttrP << pstts ;
            etThread.strMakeF( tinP , LF , pstts , TP("",cIndentP++)+TF1(entryP.idSerial)+t1+T(" grabbed by ")+TF1(osTidHave)+T("\r\n") ) ; ___( pstts ) ;
            ZE( strokeS* , pstts ) ; //"s": "snippet"
        {
        if( pSt_psttrP )

        else if( bSleep  ) t1 = T(", a sleep, is"       ) ;
        else if( bOsCall ) t1 = T(", a base os call, is") ;
             if( bSign   ) t1 = T(", a sign, is") ;
        TN( t1 , "" ) ;

        if( !bSign ) stBadGrabsTmpP << (countT)&entryP ; //MADE CONDITIONAL TO FIX ZT REPORT; WAS UNCONDITIONAL

        const boolT bSleep  = !bOsCall && !!( F(copy.flags) & flGRABs_PSEUDO ) ;
        const boolT bOsCall = !!( F(copy.flags) & flGRABs_PSEUDOoScALL ) ;
        const boolT bSign   = !!( F(copy.flags) & flGRABs_DOnOTrEGISTERiNtIN ) ;
            
        //}       
        //    *pSt_psttrP << pstts ;
        //    etThread.strMakeF( tinP , LF , pstts , TP("",cIndentP)+T("grabS grabbed: ")+TF1(entryP.idSerial)+T(" ")+TF1(entryP.osPid)+T(" ")+TF1(entryP.bIda)+T(" ")+TF1(entryP.ip)+T(" ")+TF1(entryP.idLineCt)+T(" ")+TF3(entryP.idiFileCt,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T(" ")+T("\r\n") ) ; ___( pstts ) ;
        //    ZE( strokeS* , pstts ) ; //"s": "snippet"
        //{
        //if( pSt_psttrP )

        countT osTidHave = copy.osTid ;
        grabS& copy = *(grabS*)entryP.pbCopy ;
        if( !entryP.pbCopy ) { BLAMMO ; }
    {
    if( !stCheckedP( entryP.idSerial ) )
    _IO_    //TLNA( "wantersF" )
    ZE( boolT , bLoop ) ;
    TELL( "wantersF: ++++" )
{
boolT wantersF( tinS& tinP , etherC& etThread , stackC& stWantersP , stackC* pSt_psttrP , grabEntryS& entryP , const grabWantS* const pGrabWantP , const countT& cGrabWantP , stackC& stGrabbedP , stackC& stIdSerialGrabExcludeP , stackC& stCheckedP , stackC& stBadGrabsTmpP , stackC& stOsTidLoopedTmpP , countT& cIndentP )

}
    }
        }
            }
                while( !stGrabbedP.third && ~hDown ) ;
                }
                    }
                        stCheckedP.sinkF( tinP , countTC() , entry.idSerial , flSTACKsINK_UNIQUE ) ;
        
                        cIndentP -- ;
                        bLoopP = wantersF( tinP , etThread , stWantersP , pSt_psttrP , entry , pGrabWantP , cGrabWantP , stGrabbedP , stIdSerialGrabExcludeP , stCheckedP , stBadGrabsTmpP , stOsTidLoopedTmpP , cIndentP ) ;
                        cIndentP ++ ;
                    {
                    if( bWant )
                    
                    }
                        if( copy.osTid == osTidWantP && !( F(copy.flags) & flGRABs_DOnOTrEGISTERiNtIN ) ) bWant = 1 ;
                        grabS& copy = *(grabS*)entry.pbCopy ;
                    {
                    else if( entry.pbCopy )
                    }
                        if( pFrom && pFrom->osTid == osTidWantP && !( F(pFrom->flags) & flGRABs_DOnOTrEGISTERiNtIN ) ) bWant = 1 ;
                        grabS* pFrom = (grabS*)(byteT*)ap_artmentOldC( tinP , entry.ip ) ;
                    {
                    if( entry.bIda )

                    if( stIdSerialGrabExcludeP( entry.idSerial ) ) continue ;
                    grabEntryS& entry = *(grabEntryS*)&stGrabbedP.downF( tinP , hDown ) ;
                    ZE( boolT , bWant ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( stGrabbedP )
            //RECURSIVELY CALL MYSELF FOR EACH ENTRY THAT osTidWantP HAS, TO GET THE INDIRECT WANTERS
             
            }       
                *pSt_psttrP << pstts ;
                etThread.strMakeF( tinP , LF , pstts , TP("",cIndentP)+T("wanted by ")+TF1(osTidWantP)+T("\r\n") ) ; ___( pstts ) ;
                ZE( strokeS* , pstts ) ; //"s": "snippet"
            {
            if( pSt_psttrP )
        {
        else
        }
            //pThugMe->ungrabF() ;
            }       
                *pSt_psttrP << pstts ;
                etThread.strMakeF( tinP , LF , pstts , TP("",cIndentP)+T("**** LOOP! ****\r\n") ) ; ___( pstts ) ;
                ZE( strokeS* , pstts ) ; //"s": "snippet"
            {
            if( pSt_psttrP )
            bLoopP = 1 ;
        {
        if( !ids )
        stWantersP.sinkF( tinP , ids , osTidWantP , flSTACKsINK_UNIQUE ) ;
        ZE( countT , ids ) ;
        stOsTidLoopedTmpP << osTidWantP ;
    {
    _IO_    //TLNA( "wanters0F" )
{
voidT wanters0F( tinS& tinP , etherC& etThread , boolT& bLoopP , stackC& stWantersP , stackC* pSt_psttrP , const grabWantS* const pGrabWantP , const countT& cGrabWantP , stackC& stGrabbedP , stackC& stIdSerialGrabExcludeP , stackC& stCheckedP , stackC& stBadGrabsTmpP , stackC& stOsTidLoopedTmpP , countT& cIndentP , const countT osTidWantP )

boolT wantersF( tinS& tinP , etherC& etThread , stackC& stWantersP , stackC* pSt_psttrP , grabEntryS& entryP , const grabWantS* const pGrabWantP , const countT& cGrabWantP , stackC& stGrabbedP , stackC& stIdSerialGrabExcludeP , stackC& stCheckedP , stackC& stBadGrabsTmpP , stackC& stOsTidLoopedTmpP , countT& cIndentP ) ;

}
    TELL( "stampF: ----" )
    }
        mP.mStepsPerTuck = timeDelta2 ? 0.0 : (measureT)mP.cNewSteps * TUCK / timeDelta1 ;
        etThread.osTimeSubtractF( tinP , timeDelta1 , timeDelta2 , timeOld1 , timeOld2 ) ;
        sCountT timeDelta2 = mP.time2 ;
        countT  timeDelta1 = mP.time1 ;
    {
    if( timeOld1 || timeOld2 )

    mP.cNewSteps = mP.idStepLast - idStepLastOld ;

    countT idStepLastOld = mP.idStepLast ; mP.idStepLast = idStepP ;

    etThread.osTimeNowF( tinP , mP.time1 , mP.time2 ) ;
    sCountT timeOld2 = mP.time2 ; mP.time2 = 0 ;
    countT  timeOld1 = mP.time1 ; mP.time1 = 0 ;

    mP.idMonitorTock ++ ;
    mP.idMonitor = 1 ;
    _IO_    //TLNA( "stampF" )
    TELL( "stampF: ++++" )
{
voidT stampF( tinS& tinP , etherC& etThread , monitorOldS& mP , countT idStepP )

}
    TELL( "writeLog: ----" )
    etThread.delF( tinP , postl ) ;
    }
        while( !etThread ) ;
        }
            else break ;
            }
                etThread.osSleepF( tinP , TUCK * 0x40 ) ;
                CONoUT( "fileWriteGF failed.  will retry" ) ;
                POOPR
            {
            if( POOP )
            fileWriteGF( ostoFile , postl , costl ) ;
        {
        do
        OStEXTAK( ostoFile , ".rpt.monitor.log" ) ;
        OStEXTC( ostoFile , etherC::ifc_idHomeI_IF() , 0 ) ;
        OStEXTAK( ostoFile , "\\ideafarm." ) ;
        OStEXT( ostoFile , 0x100 )
        POOPIES
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    etThread.delF( tinP , psttl ) ;
    countT costl = etThread.strMakeF( tinP , LF , postl , psttl ) ; ___( postl ) ;
    ZE( osTextT* , postl ) ;

    ) ;

        tb+T("(the most recent text is at the end of this section")+tc2
        tb+T("the text written most recently to the circular log buffer")+tc+
        T("[LO]")+tc+
        tb+T("idReport: the number of generations of this report written since the IdeaFarm " "(tm) Operating System was started on this computer")+tc2+
        tb+T("the time of the report is represented according to the customs of IdeaFarm " "(tm) City")+tc+
        tb+T("(\"01 tock\" means 16 (base 10) tocks, or approximately 30 seconds)")+tc+
        tb+T("(a tock is approximately 1.33 seconds")+tc+
        tb+T("Local Monitor Log: this report is written every 01 tock by the IdeaFarm " "(tm) Operating System")+tc+
        tb+T("these programs are called \"IdeaFarm " "(tm) Cells\"")+tc+
        tb+T("some programs on this computer are using the IdeaFarm " "(tm) Operating System")+tc+
        tb+T("IdeaFarm " "(tm) Operating System: runs \"on top of\" this computer's base operating system (e.g. MS Windows)")+tc+
        tb+T("for support, see http://www.ideafarm.com or call Wo'O Ideafarm US 650-759-5306")+tc+
        T("[ID]")+tc+
        TPS(" \r\nexplanatory notes ",0x40,S1C('-'))+tc2+

    etThread.strFuseF( tinP , psttl ,
    TN( tb , " " ) ;
    TN( tc2 , "\r\n \r\n" ) ;
    TN( tc , "\r\n" ) ;
    
    if( pbc != pbe ) { BLAMMO ; }
    }
        etThread.strFuseF( tinP , psttl , T(pbData) ) ;

        }
            BLAMMO ;
        {
        if( cbDataVerify != cbData )

        countT&            cbDataVerify = *(countT*)pbc ; pbc += sizeof( countT ) ;
        const byteT* const pbData       =           pbc ; pbc += cbData ;
        countT&            cbData       = *(countT*)pbc ; pbc += sizeof( countT ) ;
    {
    while( pbc < pbe )
    etThread.strFuseF( tinP , psttl , T("[ID]\r\nIdeaFarm " "(tm) Operating System\r\nLocal Monitor Log\r\n[see the explanatory notes at the end of this report]\r\n")+TT(timeN1P,timeN2P)+T("\r\nidReport: ")+TF1(idReportP)+T("\r\n \r\n[LO]\r\n") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ cbCyrcleOldP + 0x1000 /*TITLE + EXPLANATORY NOTES*/ ) ;
    ZE( strokeS* , psttl ) ;

    const byteT* const pbe = pbCircleP + cbCyrcleOldP ;
    const byteT*       pbc = pbCircleP ;
    _IO_    TLNA( "writeLogF" )
    TELL( "writeLog: ++++" )
{
voidT writeLogF( tinS& tinP , etherC& etThread , const byteT* const pbCircleP , const countT cbCyrcleOldP , const countT idReportP , const countT timeN1P , const sCountT timeN2P )

    IDpHASErESTORE
    TELL( "cirMonitor: returning" )
    }
                    }
                        break ;
                        IDpHASErESTORE
                    
                        thirdC::thirdWriteToCyrcleOldIF( tinP , napLogP , tEntry , tEntry.csF( tinP ) + 1 ) ;
                        tEntry += T("\r\n") ;
    
                        }
                            etherP.delF( tinP , pstte ) ;
                            tEntry = T(pstte) ;
                            etherP.strTrimF( tinP , pstte , T(pbData) , T(TbLACKnEWlINE) ) ; ___( pstte ) ; //CAN EXHAUST THE WORKING POOLoLD
                            ZE( strokeS* , pstte ) ;
                        {
                        else
                        if( head.cbData > TOCK ) tEntry = T(pbData) ;
                        TN( tEntry , "" ) ;
                        
                        TELL( "cirMonitorF: LOG" )
                        IDpHASE( 0xb )
                    {
                    case ifcIDtYPEtELLsYS_LOG :
                    }
                        break ;
                        IDpHASErESTORE
                        }    
                            }    
                                }
                                    }    
                                        //}
                                        //    }
                                        //        break ;
                                        //        if( !( -- pcRefNapkinNames[ off ] ) ) postNapkinNames[ off * ( COSTmAXnAPKINnAME + 1 ) ] = 0 ;
                                        //    {
                                        //    if( !thirdC::c_strcmpIF( tinP , postNapkinNames + off * ( COSTmAXnAPKINnAME + 1 ) , info.postName ) )
                                        //{
                                        //for( countT off = 0 ; off < CnAPKINnAMESmAX ; off ++ )
                
                                        stNapkinP.ungrabF( tinP ) ;
                                        }
                                            thirdC::thirdWriteToCyrcleOldIF( tinP , napLogP , tEntry , tEntry.csF( tinP ) + 1 ) ;
                                            tEntry = TF3(etherC::ifc_idAdamG_IF( tinP ),flFORMAT_UNSIGNED,9)+T("| the monitor could not find a napkinC entry in stNapkinP: osPid: ")+TF1(entry.osPid)+T(" ; pvMe: ")+TF1((countT)entry.pvMe)+T(" ; idLineCt: ")+TF1(entry.idLineCt)+T(" ; idiFileCt: ")+TF3(entry.idiFileCt,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T(" ; pvd: ")+TF1((countT)entry.pvd)+T(" ; cbd: ")+TF1(entry.cbd)+T(" ; postName: \"")+TF1(entry.postName)+T("\"\r\n") ;
                                            TN( tEntry , "" ) ;
                                        {
                                        else
                                        if( ids ) stNapkinP.extractF( 0 , tinP ) ;
                                        stNapkinP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_napkinEntryS_F ) ;
                                        stNapkinP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                        ZE( countT , ids ) ;
                                    {
                                    _IO_    TLNA( "ifcIDtYPEtELLsYS_NAPKINdETACH" )
                                {
                                else
                                }
                                    }    
                                        //}
                                        //    }
                                        //        break ;
                                        //        pcRefNapkinNames[ off ] = 1 ;
                                        //        OStEXTA( postNapkinNames + off * ( COSTmAXnAPKINnAME + 1 )  , info.postName ) ;
                                        //    {
                                        //    if( !postNapkinNames[ off * ( COSTmAXnAPKINnAME + 1 ) ] )
                                        //{
                                        //if( off == CnAPKINnAMESmAX ) for( off = 0 ; off < CnAPKINnAMESmAX ; off ++ )
                                        //
                                        //}
                                        //    }
                                        //        break ;
                                        //        pcRefNapkinNames[ off ] ++ ;
                                        //    {
                                        //    if( !thirdC::c_strcmpIF( tinP , postNapkinNames + off * ( COSTmAXnAPKINnAME + 1 ) , info.postName ) )
                                        //{
                                        //for( countT off = 0 ; off < CnAPKINnAMESmAX ; off ++ )
                
                                        }
                                            //U::thirdC::thirdWriteToCyrcleOldIF( tinP , napLogP , tEntry , tEntry.csF( tinP ) + 1 ) ;
                                            tEntry = TF3(etherC::ifc_idAdamG_IF( tinP ),flFORMAT_UNSIGNED,9)+T("| the monitor could not sink unique a napkinC entry into stNapkinP: osPid: ")+TF1(entry.osPid)+T(" ; pvMe: ")+TF1((countT)entry.pvMe)+T(" ; idLineCt: ")+TF1(entry.idLineCt)+T(" ; idiFileCt: ")+TF3(entry.idiFileCt,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T(" ; pvd: ")+TF1((countT)entry.pvd)+T(" ; cbd: ")+TF1(entry.cbd)+T(" ; postName: \"")+TF1(entry.postName)+T("\"\r\n") ;
                                            TN( tEntry , "" ) ;
                                        {
                                        if( !ids )
                                        stNapkinP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_napkinEntryS_F ) ;
                                        ZE( countT , ids ) ;
                                    {
                                    _IO_    TLNA( "ifcIDtYPEtELLsYS_NAPKINfORMAT NAPKINaTTACH" )
                                {
                                if( head.idType != ifcIDtYPEtELLsYS_NAPKINdETACH )
                                napkinEntryS entry( tinP , head.osPid , info.pvMe , info.idLineCt , info.idiFileCt , info.pvd , info.cbd , info.postName , info.costName ) ;
                
                                tellInfoSysNapkinS& info = *(tellInfoSysNapkinS*)pbData ;
                            {
                            else
                            }
                                thirdC::thirdWriteToCyrcleOldIF( tinP , napLogP , tEntry , tEntry.csF( tinP ) + 1 ) ;
                                tEntry = TF3(etherC::ifc_idAdamG_IF( tinP ),flFORMAT_UNSIGNED,9)+T("| the monitor received an ifcIDtYPEtELLsYS_ERROReXCEPTION note with an incorrect data length\r\n") ;
                                TN( tEntry , "" ) ;
                            {
                            if( head.cbData != sizeof( tellInfoSysNapkinS ) )
                            TELL( "cirMonitor: NAPKINfORMAT NAPKINaTTACH NAPKINdETACH" )
                        {
                        _IO_    TLNA( "ifcIDtYPEtELLsYS_NAPKINfORMAT NAPKINaTTACH NAPKINdETACH" )
                        IDpHASE( 0xa )
                    {
                    case ifcIDtYPEtELLsYS_NAPKINdETACH :
                    case ifcIDtYPEtELLsYS_NAPKINaTTACH :
                    case ifcIDtYPEtELLsYS_NAPKINfORMAT :


                                }
                                        }
                                            }
                                                break ;
                                                if( !( -- pcRefPoolNames[ off ] ) ) postPoolNames[ off * ( COSTmAXpOOLoLDnAME + 1 ) ] = 0 ;
                                            {
                                            if( !thirdC::c_strcmpIF( tinP , postPoolNames + off * ( COSTmAXpOOLoLDnAME + 1 ) , info.postName ) )
                                        {
                                        for( countT off = 0 ; off < CpOOLoLDnAMESmAX ; off ++ )
                
                                {
                                else
                                }
                                        }
                                            }
                                                break ;
                                                pcRefPoolNames[ off ] = 1 ;
                                                OStEXTA( postPoolNames + off * ( COSTmAXpOOLoLDnAME + 1 )  , info.postName ) ;
                                            {
                                            if( !postPoolNames[ off * ( COSTmAXpOOLoLDnAME + 1 ) ] )
                                        {
                                        if( off == CpOOLoLDnAMESmAX ) for( off = 0 ; off < CpOOLoLDnAMESmAX ; off ++ )
                
                                        }
                                            }
                                                break ;
                                                pcRefPoolNames[ off ] ++ ;
                                            {
                                            if( !thirdC::c_strcmpIF( tinP , postPoolNames + off * ( COSTmAXpOOLoLDnAME + 1 ) , info.postName ) )
                                        {
                                        for( countT off = 0 ; off < CpOOLoLDnAMESmAX ; off ++ )
                
                                {
                                if( head.idType != ifcIDtYPEtELLsYS_POOLoLDdETACH )

                    //case ifcIDtYPEtELLsYS_POOLoLDdETACH :
                    //case ifcIDtYPEtELLsYS_POOLoLDaTTACH :
                    //case ifcIDtYPEtELLsYS_POOLoLDfORMAT :

                    }
                        break ;
                        IDpHASErESTORE
                        }    
                            }    
                                stGrabP.ungrabF( tinP ) ;
                                }
                                    thirdC::thirdWriteToCyrcleOldIF( tinP , napLogP , tEntry , tEntry.csF( tinP ) + 1 ) ;
                                    tEntry = TF3(etherC::ifc_idAdamG_IF( tinP ),flFORMAT_UNSIGNED,9)+T("| the monitor could not find a grab entry: idSerial: ")+TF1(entry.idSerial)+T(" ; ip: ")+TF1(entry.ip)+T(" ; idLineCt: ")+TF1(entry.idLineCt)+T(" ; idiFileCt: ")+TF3(entry.idiFileCt,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T("\r\n") ;
                                    TN( tEntry , "" ) ;
                                {
                                else
                                if( ids ) stGrabP.extractF( 0 , tinP ) ;
                                stGrabP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_grabEntryS_F ) ;
                                stGrabP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                ZE( countT , ids ) ;
                                entry.logF( tinP , napLogP ) ;
                                grabEntryS entry( tinP , info.idSerial , head.osTid , head.osPid , head.idType == ifcIDtYPEtELLsYS_GRABdTI || head.idType == ifcIDtYPEtELLsYS_GRABdEI , info.ip , info.idLineCt , info.idiFileCt ) ;
                                tellInfoSysGrabS& info = *(tellInfoSysGrabS*)pbData ;
                            {
                            else
                            }
                                thirdC::thirdWriteToCyrcleOldIF( tinP , napLogP , tEntry , tEntry.csF( tinP ) + 1 ) ;
                                tEntry = TF3(etherC::ifc_idAdamG_IF( tinP ),flFORMAT_UNSIGNED,9)+T("| the monitor received an ifcIDtYPEtELLsYS_GRABd note with an incorrect data length\r\n") ;
                                TN( tEntry , "" ) ;
                            {
                            if( head.cbData != sizeof( tellInfoSysGrabS ) )
                            TELL( "cirMonitor: GRABdTI GRABdTP GRABdEI GRABdEP" )
                        {
                        _IO_    TLNA( "ifcIDtYPEtELLsYS_GRABdTI" )
                        //CONoUTrAW( "-" ) ;
                        IDpHASE( 6 )
                    {
                    case ifcIDtYPEtELLsYS_GRABdEP :
                    case ifcIDtYPEtELLsYS_GRABdEI :
                    case ifcIDtYPEtELLsYS_GRABdTP :
                    case ifcIDtYPEtELLsYS_GRABdTI :
                    }
                        break ;
                        IDpHASErESTORE
                        }
                            }    
                                stGrabP.ungrabF( tinP ) ;
                                }
                                    thirdC::thirdWriteToCyrcleOldIF( tinP , napLogP , tEntry , tEntry.csF( tinP ) + 1 ) ;
                                    tEntry = TF3(etherC::ifc_idAdamG_IF( tinP ),flFORMAT_UNSIGNED,9)+T("| ")+T("the monitor could not sink unique a grab entry: idSerial: ")+TF1(entry.idSerial)+T(" ; ip: ")+TF1(entry.ip)+T(" ; idLineCt: ")+TF1(entry.idLineCt)+T(" ; idiFileCt: ")+TF3(entry.idiFileCt,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T("\r\n") ;
                                    TN( tEntry , "" ) ;
                                {
                                if( !ids )
                                stGrabP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_grabEntryS_F ) ;
                                stGrabP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                ZE( countT , ids ) ;
                                entry.logF( tinP , napLogP ) ;
                                grabEntryS entry( tinP , info.idSerial , head.osTid , head.osPid , head.idType == ifcIDtYPEtELLsYS_GRABcTI || head.idType == ifcIDtYPEtELLsYS_GRABaTI , info.ip , info.idLineCt , info.idiFileCt ) ;
                                tellInfoSysGrabS& info = *(tellInfoSysGrabS*)pbData ;
                            {
                            else
                            }
                                thirdC::thirdWriteToCyrcleOldIF( tinP , napLogP , tEntry , tEntry.csF( tinP ) + 1 ) ;
                                tEntry = TF3(etherC::ifc_idAdamG_IF( tinP ),flFORMAT_UNSIGNED,9)+T("| ")+T("the monitor received an ifcIDtYPEtELLsYS_GRABca note with an incorrect data length\r\n") ;
                                TN( tEntry , "" ) ;
                            {
                            if( head.cbData != sizeof( tellInfoSysGrabS ) )
                            TELL( "cirMonitor: GRABcTI GRABcTP GRABaTI GRABaTP" )
                        {
                        _IO_    TLNA( "ifcIDtYPEtELLsYS_GRABcTI" )
                        //CONoUTrAW( "+" ) ;
                        IDpHASE( 5 )
                    {
                    case ifcIDtYPEtELLsYS_GRABaTP :
                    case ifcIDtYPEtELLsYS_GRABaTI :
                    case ifcIDtYPEtELLsYS_GRABcTP :
                    case ifcIDtYPEtELLsYS_GRABcTI :
                    }
                        break ;
                        IDpHASErESTORE
                        }    
                            }    
                                etherP.delF( tinP , psttl ) ;
                                if( psttl ) thirdC::thirdWriteToCyrcleOldIF( tinP , napLogP , T(psttl) , psttl->idAdam + 1 ) ;
                                tin.strFuseF( tinP , etherP , psttl , 0 , flTINrPT1_null , flTINrPT2_null , flTINrPT1_pLFstepAll , flTINrPT2_null , 0 , 2 ) ; ; ___( psttl ) ;
                                etherP.strFuseF( tinP , psttl , T(" (advice) please always report to www.ideafarm.com that this information appeared, so that the quality of this software can be improved for you and also for others.\r\n tinS\r\n") ) ; ___( psttl ) ;
                                }
                                    etherP.delF( tinP , psttLine ) ;
                                    etherP.strFuseF( tinP , psttl , T(" (advice) try this ooth: ")+T(psttLine)+T("\r\n") ) ; ___( psttl ) ;
                                    etherP.strReplaceAnyF( tinP , psttLine , 0 , T(TbLACK) , T(" ") , 0 , 1 ) ;
                                    etherP.strTrimF( tinP , psttLine , T(info.postFix2) , T(TbLACKnEWlINE) ) ; ___( psttLine ) ;
                                    ZE( strokeS* , psttLine ) ;
                                {
                                if( *info.postFix2 )
                                }
                                    etherP.delF( tinP , psttLine ) ;
                                    etherP.strFuseF( tinP , psttl , T(" (advice) try this woth: ")+T(psttLine)+T("\r\n") ) ; ___( psttl ) ;
                                    etherP.strReplaceAnyF( tinP , psttLine , 0 , T(TbLACK) , T(" ") , 0 , 1 ) ;
                                    etherP.strTrimF( tinP , psttLine , T(info.postFix1) , T(TbLACKnEWlINE) ) ; ___( psttLine ) ;
                                    ZE( strokeS* , psttLine ) ;
                                {
                                etherP.strFuseF( tinP , psttl , T(" probable defect location: ")+T(info.postSuspect)+T("\r\n") ) ; ___( psttl ) ;
        
                                etherP.strFuseF( tinP , psttl , T(" bFixed: ")+TF1(info.bFixed)+T("\r\n cFixed: ")+T(info.cFixed)+T("\r\n") ) ; ___( psttl ) ;
        
                                else if( info.idException == ifcIDeVENTeXCEPTIONmONITORED_GRUNT       ) etherP.strFuseF( tinP , psttl , T(" idLine: ")+TF1(info.pcInfo[0])+T("\r\n idiFile: ")+TF3(info.pcInfo[1],flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T("\r\n rc" ": ")+TF1(info.pcInfo[2])+T("\r\n idLineNote: ")+TF1(info.pcInfo[3])+T("\r\n idiFileNote: ")+TF3(info.pcInfo[4],flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T("\r\n") ) ;
                                else if( info.idException == ifcIDeVENTeXCEPTIONmONITORED_ACCESSvIOLATION ) etherP.strFuseF( tinP , psttl , T(" bWrite: ")+TF1(info.pcInfo[0])+T("\r\n pvTarget: ")+TF1(info.pcInfo[1])+T("\r\n") ) ;
                                     if( info.idException == ifcIDeVENTeXCEPTIONmONITORED_NOTlISTED       ) etherP.strFuseF( tinP , psttl , T(" raw exception code: ")+TF1(info.pcInfo[0])+T("\r\n") ) ;
                                if( info.idException != ifcIDeVENTeXCEPTIONmONITORED_GRUNT ) { etherP.strFuseF( tinP , psttl , T(" pvOffendingCode: ")+TF1((countT)info.pvOffendingCode)+T("\r\n") ) ; ___( psttl ) ; }
                                etherP.strFuseF( tinP , psttl , T(processGlobal4I.mapExceptionType(info.idException))+T(" exception\r\n") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ 0x10000 ) ; ___( psttl ) ;
                                ZE( strokeS* , psttl ) ;
                                tinS& tin = *(tinS*)info.pbTin ;
                
                                tellInfoSysExceptionS& info = *(tellInfoSysExceptionS*)pbData ;
                            {
                            else
                            }
                                thirdC::thirdWriteToCyrcleOldIF( tinP , napLogP , tEntry , tEntry.csF( tinP ) + 1 ) ;
                                tEntry = TF3(etherC::ifc_idAdamG_IF( tinP ),flFORMAT_UNSIGNED,9)+T("| ")+T("the monitor received an ifcIDtYPEtELLsYS_ERROReXCEPTION note with an incorrect data length\r\n") ;
                                TN( tEntry , "" ) ;
                            {
                            if( head.cbData != sizeof( tellInfoSysExceptionS ) )
                            TELL( "cirMonitor: ERROReXCEPTION" )
                        {
                        _IO_    TLNA( "ifcIDtYPEtELLsYS_ERROReXCEPTION" )
                        CONoUTrAW( "cirMonitorF/ifcIDtYPEtELLsYS_ERROReXCEPTION\r\n" ) ; //U::
                        IDpHASE( 4 )
                    {
                    case ifcIDtYPEtELLsYS_ERROReXCEPTION :
                    }
                        break ;
                        IDpHASErESTORE
                        }
                            }    
                                }
                                    thirdC::thirdWriteToCyrcleOldIF( tinP , napLogP , tEntry , tEntry.csF( tinP ) + 1 ) ;
                                    tEntry = TF3(etherC::ifc_idAdamG_IF( tinP ),flFORMAT_UNSIGNED,9)+T("| ")+T("the monitor could not sink unique a lifi entry: lifi" ": ")+TF1(entry.idLine)+T(".")+TF3(entry.idiFile,flFORMAT_UNSIGNED|flFORMAT_FILLzE,7)+T(" ; postName: \"")+T(entry.postName)+T("\"\r\n") ;
                                    TN( tEntry , "" ) ;
                                {
                                if( !ids )

                                stLifiP.ungrabF( tinP ) ;
                                }
                                    }
                                        OStEXTA( old.postName  , entry.postName ) ;
                                        lifiEntryS& old = *(lifiEntryS*)&(countT&)stLifiP[ 0 ] ;
                                    {
                                    if( ids )
                                    stLifiP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_lifiEntryS_F ) ;
                                {
                                if( !ids )
                                stLifiP.sinkF( tinP , ids , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_lifiEntryS_F ) ;
                                stLifiP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                ZE( countT , ids ) ;

                                lifiEntryS entry( tinP , info.idLine , info.idiFile , info.postName ) ;
                                tellInfoSysLifiS& info = *(tellInfoSysLifiS*)pbData ;
                            {
                            else
                            }
                                thirdC::thirdWriteToCyrcleOldIF( tinP , napLogP , tEntry , tEntry.csF( tinP ) + 1 ) ;
                                tEntry = TF3(etherC::ifc_idAdamG_IF( tinP ),flFORMAT_UNSIGNED,9)+T("| ")+T("the monitor received an ifcIDtYPEtELLsYS_LIFInAME note with an incorrect data length\r\n") ;
                                TN( tEntry , "" ) ;
                            {
                            if( head.cbData != sizeof( tellInfoSysLifiS ) )
                            TELL( "cirMonitor: TAG( TAGiDnULL )nAME" )
                        {
                        _IO_    TLNA( "ifcIDtYPEtELLsYS_LIFInAME" )
                        //CONoUTrAW( "cirMonitorF/ifcIDtYPEtELLsYS_LIFInAME\r\n" ) ; //U::
                        IDpHASE( 3 )
                    {
                    case ifcIDtYPEtELLsYS_LIFInAME :

            swWhereTallyTalkingP.ungrabF( tinP ) ;
            ++ swWhereTallyTalkingP ;
            c5leverTallyTalkingP = count5S( head.idLineTalking&0xfff , head.idiFileTalking , head.idAdamRoot , head.idPhase2Talking , head.idPhase3Talking ) ;
            swWhereTallyTalkingP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        
        switchC&  swWhereTallyTalkingP  =   *(switchC*)c8m2.c4 ;
        count5S&  c5leverTallyTalkingP  =   *(count5S*)c8m2.c3 ;
        countT*   pcRefPoolNames        =     (countT*)c8m2.c2 ;
        osTextT*  postPoolNames         =    (osTextT*)c8m2.c1 ; //[ CpOOLoLDnAMESmAX ][ COSTmAXpOOLoLDnAME + 1 ]
        //countT&   conditionalGrabP    =    *(countT*)c8m1.c8 ;
        napkinC&  napLogP               = **(napkinC**)c8m1.c7 ;
        stackC&   stTinWhereP           =    *(stackC*)c8m1.c6 ;
        stackC&   stTinP                =    *(stackC*)c8m1.c5 ;
        stackC&   stNapkinP             =    *(stackC*)c8m1.c4 ;
        stackC&   stPoolP               =    *(stackC*)c8m1.c3 ;
        stackC&   stLifiP               =    *(stackC*)c8m1.c2 ;
        stackC&   stGrabP               =    *(stackC*)c8m1.c1 ;
        count8S&  c8m2                  =   *(count8S*)c2mp.c2 ;
        count8S&  c8m1                  =   *(count8S*)c2mp.c1 ;
        count2S&  c2mp                  =   *(count2S*)cParmP ;
    {
    _IO_    TLNA( "cirMonitorF" )
    IDpHASE( 2 )
//cirMonitorF

}
    return 1 ;
    CONoUTrAW( "\r\n**** bAcceptEventF entered; returning 1\r\n" ) ; //U::
    if( pTinP && infoP.idException && pcArgP ) ;
{
boolT bAcceptEventF( tinS* pTinP , tellInfoSysExceptionS& infoP , countT* pcArgP )

}
    return sgn ;
    if( tinP.fingerprint && c3P ) ;
    }                       
        else if( pe1->cbd       < pe2->cbd       ) sgn = - 1 ;
        else if( pe1->cbd       > pe2->cbd       ) sgn =   1 ;
        else if( pe1->pvd       < pe2->pvd       ) sgn = - 1 ;
        else if( pe1->pvd       > pe2->pvd       ) sgn =   1 ;
        else if( pe1->idiFileCt < pe2->idiFileCt ) sgn = - 1 ;
        else if( pe1->idiFileCt > pe2->idiFileCt ) sgn =   1 ;
        else if( pe1->idLineCt  < pe2->idLineCt  ) sgn = - 1 ;
        else if( pe1->idLineCt  > pe2->idLineCt  ) sgn =   1 ;
        else if( pe1->pvMe      < pe2->pvMe      ) sgn = - 1 ;
        else if( pe1->pvMe      > pe2->pvMe      ) sgn =   1 ;
        else if( pe1->osPid     < pe2->osPid     ) sgn = - 1 ;
             if( pe1->osPid     > pe2->osPid     ) sgn =   1 ;
    {                           
    if( pe1 && pe2 )
    ZE( sCountT , sgn ) ;

    napkinEntryS* pe2 = (napkinEntryS*)c2P ;
    napkinEntryS* pe1 = (napkinEntryS*)c1P ;

    }
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )
    _IO_

    }
    {
    IFbEcAREFUL
{
countT subtract_napkinEntryS_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return sgn ;
    if( tinP.fingerprint && c3P ) ;

    }                       
        else if( pe1->idLine  < pe2->idLine  ) sgn = - 1 ;
        else if( pe1->idLine  > pe2->idLine  ) sgn =   1 ;
        else if( pe1->idiFile < pe2->idiFile ) sgn = - 1 ;
             if( pe1->idiFile > pe2->idiFile ) sgn =   1 ;
    {
    if( pe1 && pe2 )
    ZE( sCountT , sgn ) ;

    lifiEntryS* pe2 = (lifiEntryS*)c2P ;
    lifiEntryS* pe1 = (lifiEntryS*)c1P ;

    }
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )
    _IO_

    }
    {
    IFbEcAREFUL
{
countT subtract_lifiEntryS_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return sgn ;
    if( tinP.fingerprint && c3P ) ;

    }                       
        else if( pe1->ip       < pe2->ip       ) sgn = - 1 ;
        else if( pe1->ip       > pe2->ip       ) sgn =   1 ;
        else if( pe1->bIda     < pe2->bIda     ) sgn = - 1 ;
        else if( pe1->bIda     > pe2->bIda     ) sgn =   1 ;
        else if( pe1->osPid    < pe2->osPid    ) sgn = - 1 ;
        else if( pe1->osPid    > pe2->osPid    ) sgn =   1 ;
        else if( pe1->idSerial < pe2->idSerial ) sgn = - 1 ;
             if( pe1->idSerial > pe2->idSerial ) sgn =   1 ;
    {
    if( pe1 && pe2 )
    ZE( sCountT , sgn ) ;

    grabEntryS* pe2 = (grabEntryS*)c2P ;
    grabEntryS* pe1 = (grabEntryS*)c1P ;

    }
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )
    _IO_

    }
    {
    IFbEcAREFUL
{
countT subtract_grabEntryS_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    swTally.freeAllF( tinP ) ;
    idWhatLever = bNewWhereRpt = 0 ;
{
voidT whereTalliesGrossS::purgeF( tinS& tinP )

}
{
swTally( tinP , third , idLineCtP , idiFileCtP , flSTACKc_null , idWhatLever )
idWhatLever( 0 ) ,
bNewWhereRpt( 0 ) ,
idiFileCt( idiFileCtP ) ,
idLineCt( idLineCtP ) ,
third( thirdP ) ,
whereTalliesGrossS::whereTalliesGrossS( tinS& tinP , thirdC& thirdP , const countT idLineCtP , const countT idiFileCtP ) :

}
    swTally3.freeAllF( tinP ) ;
    swTally2.freeAllF( tinP ) ;
    swTally1.freeAllF( tinP ) ;
    lifiLever2 = lifiLever1 = count2S() ;
    pczLever3 = 0 ;
    bNewWhereRpt = 0 ;
{
voidT whereTalliesFineS::purgeF( tinS& tinP )

}
{
swTally3( tinP , third , idLineCtP , idiFileCtP , flSTACKc_null , pczLever3 )
swTally2( tinP , third , idLineCtP , idiFileCtP , flSTACKc_null , (byteT*)&lifiLever2 , sizeof lifiLever2 ) ,
swTally1( tinP , third , idLineCtP , idiFileCtP , flSTACKc_null , (byteT*)&lifiLever1 , sizeof lifiLever1 ) ,
pczLever3( 0 ) ,
bNewWhereRpt( 0 ) ,
idiFileCt( idiFileCtP ) ,
idLineCt( idLineCtP ) ,
third( thirdP ) ,
whereTalliesFineS::whereTalliesFineS( tinS& tinP , thirdC& thirdP , const countT idLineCtP , const countT idiFileCtP ) :

NEWdELcLASStHIRD( whereTalliesGrossS , ifciDtYPEdROPnOTE_classDefinedInAdamDefinition2 )
NEWdELcLASStHIRD( whereTalliesFineS  , ifciDtYPEdROPnOTE_classDefinedInAdamDefinition1 )

;
}
    voidT purgeF( tinS& tinP ) ;
    whereTalliesFineS( tinS& tinP , thirdC& thirdP , const countT idLineCtP , const countT idiFileCtP ) ;
    NEWdELcLASSpROTOS( whereTalliesFineS , etherC , thirdC ) ;

    switchC swTally3 ;
    switchC swTally2 ;
    switchC swTally1 ;
    countT* pczLever3 ;
    count2S lifiLever2 ;
    count2S lifiLever1 ;
    boolT   bNewWhereRpt ;
    const countT idiFileCt ;
    const countT idLineCt ;
    thirdC& third ;
{
struct whereTalliesFineS

;
}
    voidT purgeF( tinS& tinP ) ;
    whereTalliesGrossS( tinS& tinP , thirdC& thirdP , const countT idLineCtP , const countT idiFileCtP ) ;
    NEWdELcLASSpROTOS( whereTalliesGrossS , etherC , thirdC ) ;

    switchC swTally ;
    countT  idWhatLever ;
    boolT   bNewWhereRpt ;
    const countT idiFileCt ;
    const countT idLineCt ;
    thirdC& third ;
{
struct whereTalliesGrossS

STATE0

    }
        swWhereTallies##gfP##subjectP.ungrabF( tinP ) ;                                                     \
        if(  pwt ) tallyF( tinP , etThread , *pwt , copy1 , stLifiP ) ;                                     \
        if( !pwt ) pwt = pNew ;                                                                             \
        __( !ids &&  pwt ? 3 : 0 ) ;                                                             \
        __(  ids && !pwt ? 2 : 0 ) ;                                                             \
        whereTallies##gfP##S*& pwt = *(whereTallies##gfP##S**)&(countT&)swWhereTallies##gfP##subjectP ;     \
        leverP##Tallies##gfP##subjectP = leverValueP ;                                                      \
        swWhereTallies##gfP##subjectP.grabF( tinP , TAG( TAGiDnULL ) ) ;                                               \
        ;                                                                                                   \
            : pwt##gfP##F( tinP , swWhereTallies##gfP##subjectP.third , stRecycle_pwt##gfP##P )             \
            ? 0                                                                                             \
        whereTallies##gfP##S* pNew = ids                                                                    \
        countT ids = swWhereTallies##gfP##subjectP.idSlotOfLeverF( tinP , (rawLeverP) ) ;                   \
    {                                                                                                       \
                                                                                                            \
#define TALLY(gfP,subjectP,leverP,leverValueP,rawLeverP)                                                    \

    }
        }                                                                       \
            DEL( *(whereTallies##gfP##S**)&c_pwt ) ;                            \
            stDelete >> c_pwt ;                                                 \
            ZE( countT , c_pwt ) ;                                            \
        {                                                                       \
        while( stDelete )                                                       \
                                                                                \
        swP.ungrabF( tinP ) ;                                                   \
        swP.freeAllF( tinP ) ;                                                  \
        }                                                                       \
            c_pwt = 0 ;                                                         \
            stDelete << c_pwt ;                                                 \
            countT& c_pwt = swP ;                                               \
            leverP = leverCastP##swP.leverF( tinP , idf ) ;                     \
        {                                                                       \
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )                        \
        countT cFlavors = swP.cFlavorsF( tinP ) ;                               \
        swP.grabF( tinP , TAG( TAGiDnULL ) ) ;                                             \
    {                                                                           \
                                                                                \
#define PURGE(gfP,swP,leverCastP,leverP)                                        \

#define CpOOLoLDnAMESmAX 0x20
#define CBlOG 0x10000
#define POSTlOG "napLog"

#include postADAMhEADER

/*1*/WAKEhIDE( "ifcIDaDAM_KERNEL2MONITOR" )/*1*/
/**/
*/
 i would run ok without a load, but would fail during termination with a load (bang simulator)
when i began, i compiled cleanly and ran, but not reliably
i began as an exact copy of adam.2e40104.*
 as 4fb is developed, code will be removed from me
this adam is a code mine for 4fb
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

