
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        cbP = 0 ;
        ether.delF( tinP , pbP ) ;
    {
    if( POOP )

    else __1
    }
        else __1
        }
            }
                ether.memCopyF( tinP , pbP , pbNapkin , cbP ) ;
                ether.newF( tinP , LF , pbP , cbP ) ; ___( pbP ) ;
                if( !POOP ) cbP = cbNapkin ;
                __( cbP ) ;
                countT cbNapkin = *(countT*)( pbNapkin - sizeof(countT) ) ;
            {
            if( pbNapkin )
        {
        else if( !ether.strCompareF( tinP , psttType , T("napkin.make") ) || !ether.strCompareF( tinP , psttType , T("napkin") ) )
        }
            if( !ether && pHoseProcessError ) { pHoseProcessError->getF( tinP , pbP , cbP ) ; ___( pbP ) ; }
        {
        else if( !ether.strCompareF( tinP , psttType , T("process.error") ) )
        }
            if( !ether && pHoseProcessOut ) { pHoseProcessOut->getF( tinP , pbP , cbP ) ; ___( pbP ) ; }
        {
        else if( !ether.strCompareF( tinP , psttType , T("process.out") ) )
        }
        {
        else if( !ether.strCompareF( tinP , psttType , T("process.in") ) )
        }
        {
        else if( !ether.strCompareF( tinP , psttType , T("process") ) )
        }
            #endif
                }
                    else break ;
                    }
                        }
                            ++ s ; ether.osSleepF( tinP ) ;
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        ether = 0 ;
                    {
                    if( POOP )
                    pBatHPC->ungrabF( tinP ) ;
                    ether.fileReadF( tinP , pbP , cbP , hHoseCommand ) ;
                    pBatHPC->grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                while( !ether )
                if( !POOP ) pbP[ cbP ] = 0 ;
                ether.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
                }
                    else break ;
                    }
                        }
                            ++ s ; ether.osSleepF( tinP ) ;
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        ether = 0 ;
                    {
                    if( POOP )
                    pBatHPC->ungrabF( tinP ) ;
                    ether.fileReadF( tinP , (byteT*)&cbP , cb1 , hHoseCommand ) ;
                    countT cb1 = sizeof cbP ;
                    pBatHPC->grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                while( !ether )
                //U:ASSUME: MESSAGES ARE SMALL ENOUGH THAT FILE POINTER WILL NEVER BE MOVED UNLESS THE ENTIRE MESSAGE CAN BE READ
                //U:NT: ENHANCE THIS CODE TO IMPLEMENT cbP == -1 I.E. CLIENT DOES NOT KNOW HOW MANY BYTES IT WILL WRITE TO THIS HOSE
            #elif defined( __NT__ )
                ether.fileReadF( tinP , pbP , cbP , handle , fStupidClient ) ;
                }
                    else                pbP[ cbP ] = 0 ;
                    if( fStupidClient ) ether.memSetF( tinP , pbP , cbP + 1 ) , *pbP = '\xDB' ;
                {
                if( !ether && pbP )
                ether.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
                if( cbP == - 1 ) fStupidClient = 1 , cbP = CBlIMITfROMsTUPIDcLIENT ;
                ether.fileReadF( tinP , (byteT*)&cbP , cb1 , handle ) ;
                countT cb1 = sizeof cbP ;
                ZE( boolT , fStupidClient ) ;
            #ifdef __OS2__
        {
        else if( !ether.strCompareF( tinP , psttType , T("tap") ) )
        }
            #endif
                }
                    else break ;
                    }
                        }
                            ++ s ; ether.osSleepF( tinP ) ;
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        ether = 0 ;
                    {
                    if( POOP )
                    pBatHPR->ungrabF( tinP ) ;
                    ether.fileReadF( tinP , pbP , cbP , hHoseReply ) ;
                    pBatHPR->grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                while( !ether )
                if( !POOP ) pbP[ cbP ] = 0 ;
                ether.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
                }
                    else break ;
                    }
                        }
                            ++ s ; ether.osSleepF( tinP ) ;
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        ether = 0 ;
                    {
                    if( POOP )
                    pBatHPR->ungrabF( tinP ) ;
                    ether.fileReadF( tinP , (byteT*)&cbP , cb1 , hHoseReply ) ;
                    countT cb1 = sizeof cbP ;
                    pBatHPR->grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                while( !ether )
                //U:ASSUME: MESSAGES ARE SMALL ENOUGH THAT FILE POINTER WILL NEVER BE MOVED UNLESS THE ENTIRE MESSAGE CAN BE READ
            #elif defined( __NT__ )
                ether.fileReadF( tinP , pbP , cbP , handle ) ;
                if( !POOP ) pbP[ cbP ] = 0 ;
                ether.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
                ether.fileReadF( tinP , (byteT*)&cbP , cb1 , handle ) ;
                countT cb1 = sizeof cbP ;
            #ifdef __OS2__
        {
        else if( !ether.strCompareF( tinP , psttType , T("hose") ) )
        }
            }
                }
                    cbP = 0 ;
                    ether.delF( tinP , pbP ) ;
                {
                if( POOP )

                ether.fileReadF( tinP , pbP , cbP , handle ) ;
                }
                    ether.delF( tinP , psttMapped ) ;
                    ether.fileOpenF( tinP , handle , flagsResult , psttMapped , ifcOPENaCCESS_WR , 0 , flOPENdETAILS_FAIL | flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , 0 , 0 , cOpenTries ) ;
                    ether.diskMakeDirIfNeededF( tinP , psttMapped ) ;
                    ZE( countT , flagsResult ) ;
                    ether.diskMapFileNameF( tinP , psttMapped , psttAll ) ; ___( psttMapped ) ;
                    ZE( strokeS* , psttMapped ) ;
                {
                if( !handle )
            {
            if( cbP )
            if( pbP ) pbP[ cbP ] = 0 ;
            if( !POOP ) { ether.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ; }
            cbP = cbFileF( tinP ) ;
        {
        if( psttType && !psttType->idAdam )
        __NZ( cbP ) ;
    {
    else if( !psttHost->idAdam )
    }
        so.writeF( tinP , soulo2 ) ;
        soulC soulo2( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_BYE ) ;

        souli.shiftRightF( tinP , pbP , cbP , ifcIDtYPEsOULiTEM_byteTptr ) ; ___( pbP ) ;
        __( idCmd - ifcIDcMDsESSION_GETfYLErEPLY ) ;
        souli >> idCmd ;
        ZE( countT , idCmd ) ;
        so.readF( tinP , souli ) ;
        soulC souli( tinP , TAG( TAGiDnULL ) ) ;

        so.writeF( tinP , soulo ) ;
        so.connectF( tinP , ifcPORToLD2_CHAT , socketC::nicNameIF( tinP , ether , T(WWWiDEAFARMcOM) ) ) ;
        socketC so( tinP , ether , TAG( TAGiDnULL ) ) ;

        soulo << psttName ;
        soulC soulo( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_GETfYLE ) ;
    {
    else if( !ether.strCompareF( tinP , psttType , T("fyle") ) )
    }
        }
            }
                ether.delF( tinP , pstti ) ;
                cbP = ether.strMakeF( tinP , pbP , pstti ) ; ___( pbP ) ;
                pSControl->readWoMultilineF( tinP , pstti , T(".") , 0x10000 ) ; ___( pbP ) ; //U: csttEstimateP
                ZE( strokeS* , pstti ) ;
            {
            if( !POOP )
            //U: info.fZombie = 0 ;
            verifyReplyF( tinP , 215 ) ;
            pSControl->writeF( tinP , (osTextT*)T("list newsgroups\r\n") ) ;

            //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
            infoBoxGetPutS info( tinP , ether , *pSControl ) ;

            __( cbP ) ;
        {
        else
        }
            }
                ether.delF( tinP , pstti ) ;
                cbP = ether.strMakeF( tinP , pbP , pstti ) ; ___( pbP ) ;
                pSControl->readWoMultilineF( tinP , pstti , T(".") , 0x10000 ) ; ___( pbP ) ; //U: csttEstimateP
                ZE( strokeS* , pstti ) ;
            {
            if( !POOP )
            //U: info.fZombie = 0 ;
            verifyReplyF( tinP , 220 ) ;
            ether.delF( tinP , psttIdWanted ) ;
            { textC txt = T("article ")+T(psttIdWanted)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }

            //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
            infoBoxGetPutS info( tinP , ether , *pSControl ) ;

            }
                ether.strFromF( tinP , psttIdWanted , idWanted , flFORMAT_NObASE|flFORMAT_FOREIGN , 0 , 10 ) ; ___( psttIdWanted ) ;
                cbP = 0 ;
                __Z( idWanted ) ;
                sCountT idWanted = cbP ;
            {
            ZE( strokeS* , psttIdWanted ) ;
        {
        if( psttName && psttName->idAdam )
    {
    else if( !ether.strCompareF( tinP , psttType , T("news") ) && pSControl )
    }
        }
            ether.delF( tinP , pstti ) ;
            cbP = ether.strMakeF( tinP , pbP , pstti ) ; ___( pbP ) ;
            pSControl->readWoMultilineF( tinP , pstti , T(".") , 0x10000 ) ; ___( pbP ) ; //U: csttEstimateP
            ZE( strokeS* , pstti ) ;
        {
        if( !POOP )

        //U: info.fZombie = 0 ;
        verifyReplyF( tinP ) ;
        ether.delF( tinP , psttIdWanted ) ;
        else { textC txt = T("retr ") + T(psttIdWanted) + T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }
        }
            ether.delF( tinP , psttTop ) ;
            { textC txt = T("top ") + T(psttIdWanted) + T(" ") + T(psttTop) + T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }
        {
        if( psttTop )
        //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
        infoBoxGetPutS info( tinP , ether , *pSControl ) ;

        }
            ether.strFromF( tinP , psttIdWanted , idWanted , flFORMAT_NObASE|flFORMAT_FOREIGN , 0 , 10 ) ; ___( psttIdWanted ) ;
            cbP = 0 ;
            __Z( idWanted ) ;
            }
                ether.strMakeF( tinP , psttTop , T("200") ) ; ___( psttTop ) ;
                idWanted = - idWanted ;
            {
            if( idWanted < 0 )
            sCountT idWanted = cbP ;
        {
        ZE( strokeS* , psttTop ) ;
        ZE( strokeS* , psttIdWanted ) ;
    {
    else if( !ether.strCompareF( tinP , psttType , T("pop") ) && pSControl )
    }
        //THREADmODE4rESTORE
        }
            __( bFail ) ;
            }
                }
                    bFail = 1 ;
                    POOPRqUIET
                {
                if( POOP )

                while( !ether && ( bNoQuitEarly || ( cTries && -- cTries ) ) ) ; // thirdC::thPrimeIF( tinP ) IS NOT CHECKED HERE BECAUSE IT WOULD HANG IF I AM CALLED DURING TERMINATION, AFTER thPrimeIF HAS BEEN DESTROYED
                }
                    TESTsCRATCH //U:: TO FIND A BUG
                    }
                        }
                            ++ s ; ether.osSleepF( tinP ) ;
                            ether.traceF( tinP , T("boxC::getF / napping for a wink") ) ;
                        {
                        if( bNoQuitEarly || cTries > 1 )

                        if( POOP ) POOPRqUIET

                        }
                            pSControl->connectF( tinP , /*port 80*/idPort , hidIfo , cOpenTries ) ;
                            nicNameC hidIfo = socketC::nicNameIF( tinP , ether , psttHost->idAdam ? psttHost : 0 ) ;
                        {
                        if( !POOP )

                        pSControl->etherF( tinP , *tinP.pEtScratch ) ;

                        __Z( pSControl ) ;
                        pSControl = new( 0 , tinP , LF ) socketC( tinP , ether , TAG( TAGiDnULL ) ) ; ___( pSControl ) ;
                        //DUPLICATEcODE: 36007001 36007005

                        DEL( pSControl ) ;

                        pSControl->etherF( tinP , etSave ) ;

                        POOPRqUIET
                    {
                    else
                    }
                        break ;
                        pSControl->etherF( tinP , etSave ) ;
                    {
                    if( !POOP )

                    ether.delF( tinP , postHeadPlus ) ;
                    }
                        TESTsCRATCH //U:: TO FIND A BUG

                        //ether.traceF( tinP , T("getF [name]:    ")+T(psttNameP) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ; //U:: TO FIND A BUG

                        }
                            }
                                }
                                    if( !bFail && pbP ) pbP[ costBody ] = 0 ;

                                    }
                                        #endif

                                            }
                                                }
                                                    }
                                                        if( !pSControl->readF( tinP , &ostWo , 1 ) ) { BLAMMO ; } ; // '\n'
                                                        if( !pSControl->readF( tinP , &ostWo , 1 ) ) { BLAMMO ; } ; // '\r'

                                                        }
                                                            }
                                                                costDo   -= costGot ;
                                                                cbP += costGot ;
                                                            {
                                                            if( !POOP )

                                                            __Z( costGot ) ;
                                                            countT costGot = pSControl->readF( tinP , pbP + cbP , costDo ) ;
                                                        {
                                                        while( costDo && !POOP )

                                                        if( !pSControl->readF( tinP , &ostWo , 1 ) ) { BLAMMO ; } ; // '\n'
                                                        osTextT ostWo ;
                                                    {
                                                    else
                                                    if( !costDo ) break ;

                                                    offl = - 1 ;
                                                    countT costDo = ether.strDigitsToSCountF( tinP , T(postLengthBuffer) , 0 , 1 ) ;
                                                    thirdC::c_strlwrIF( tinP , postLengthBuffer) ;
                                                    postLengthBuffer[ offl ] = 0 ;
                                                {
                                                if( postLengthBuffer[ offl ] == '\r' )

                                                if( !pSControl->readF( tinP , postLengthBuffer + offl , 1 ) ) { BLAMMO ; } ;
                                            {
                                            for( countT offl = 0 ; offl < sizeof postLengthBuffer - 1 ; offl ++ )
                                            osTextT postLengthBuffer[ TUCK ] = { 0 } ;
                                            ZE( countT , cbe ) ;

                                        #if defined( NEVERdEFINED )
                                        //U:: REWRITE TO SUPPORT CHUNKS WHILE AVOIDING SINGLE BYTE READS

                                        BLAMMO ;
                                    {
                                    else
                                    }
                                        }
                                            }
                                                bFail = 1 ;
                                                ether.delF( tinP , pbP ) ;
                                                //ether.traceF( tinP , T("getF: could not read socket 175") ) ;
                                                POOPRqUIET
                                            {
                                            if( POOP )
                                            pSControl->readF( tinP , postc , costBody - costzBodySome ) ;
                                            SCOOPS
                                        {
                                        IFsCRATCH

                                        if( costzBodySome ) { ether.memCopyF( tinP , postc , postzBodySome , costzBodySome ) ; postc += costzBodySome ; }
                                        osTextT* postc = pbP ;
                                    {
                                    if( !bChunked )
                                {
                                if( pbP )
                                ether.newF( tinP , LF , pbP , costBody + 1 ) ; ___( pbP ) ;
                                cbP = costBody ;
                            {
                            if( costBody )
                        {
                        if( !bFail )

                        }
                            ether.delF( tinP , pstt1Line ) ;
                            }
                                ether.delF( tinP , psttl ) ;
                                }
                                    ether.delF( tinP , psttValue ) ;
                                    ether.delF( tinP , psttKey ) ;
                                
                                    }
                                        }
                                            bChunked = !ether.strCompareF( tinP , psttValue , tChunked ) ;
                                        {
                                        else if( !ether.strCompareF( tinP , psttKey , tTransferEncoding ) )
                                        }
                                            bLengthSet = 1 ;
                                            costBody = ether.strDigitsToSCountF( tinP , psttValue , 0xa , 1 ) ;
                                        {
                                        if( !ether.strCompareF( tinP , psttKey , tKeyContentLength ) )
                                    
                                        ether.strTrimF( tinP , psttValue , 0 , T(TbLACKnEWlINE) ) ; ___( psttValue ) ;
                                        ether.strSubstringF( tinP , psttValue , idf , countTC() , psttl ) ; ___( psttValue ) ;
                                    {
                                    if( idf )
                                    ether.strConvertToLowerCaseF( tinP , psttKey ) ; ___( psttKey ) ;
                                    ether.strSubstringF( tinP , psttKey , idf , sttq , tColonWhite , psttl , 1 ) ; ___( psttKey ) ;
                                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                    countT idf = 1 ;
                                    ZE( strokeS* , psttValue ) ;
                                    ZE( strokeS* , psttKey ) ;
                                {
                                else  // HEADER LINE ASSUMED TO BE OF THE FORM, FOR EXAMPLE,  "Content-Length:1234"
                                }
                                    }
                                        ether.delF( tinP , pstt1w ) ;
                                        }
                                            break ;
                                            if( ether.strCompareF( tinP , psttc1 , t200 ) && ether.strCompareF( tinP , psttc1 , t307 ) ) { __1 } ;
                                            if( ++ idWord == 1 ) continue ;
                                        {
                                        FORsTRINGSiN1( pstt1w )
                                        ZE( countT , idWord ) ;
                                        ether.strWordsF( tinP , pstt1w , psttl , sttq ) ; ___( pstt1w ) ;
                                        ZE( strokeS* , pstt1w ) ;
                                    {
                                    if( !POOP )                        
                                    if( psttl->idAdam > TUCK ) { __( psttl->idAdam ) ; } // DEFENSIVE

                                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                    countT idf = 1 ;

                                    //ether.traceF( tinP , psttl ) ;

                                    bWoth = 0 ;
                                {
                                if( bWoth )

                                ether.strConvertToLowerCaseF( tinP , psttl , psttc1 ) ; ___( psttl ) ;
                                ZE( strokeS* , psttl ) ;
                            {
                            FORsTRINGSiN1( pstt1Line )
                            boolT bWoth = 1 ;

                            }
                                ether.strWordsF( tinP , pstt1Line , T(postHeadPlus) , sttq , T("\r\n") ) ; ___( pstt1Line ) ;
                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                            {
                            ZE( strokeS* , pstt1Line ) ;
                        {
                        ZE( boolT , bLengthSet ) ;
                        ZE( boolT , bChunked ) ;
                        TN( tChunked          , "chunked"            ) ;
                        TN( tTransferEncoding , "transfer-encoding:" ) ;
                        TN( tKeyConnection    , "connection"         ) ;
                        TN( tKeyUserAgent     , "user-agent"         ) ;
                        TN( tKeyContentLength , "content-length"     ) ;
                        TN( tColonWhite , ": " ) ;
                        ZE( strokeS* , psttAction ) ;
                        ZE( countT , costBody ) ;

                        }
                            costzBodySome = costHeadPlus - costHead - 4 ;
                            postzBodySome = postHeadPlus + costHead + 4 ;
                        {
                        if( costHeadPlus - costHead > 4 )
                        ZE( countT   , costzBodySome ) ;
                        ZE( osTextT* , postzBodySome ) ;
                    {
                    if( !bFail )

                    TESTsCRATCH //U:: TO FIND A BUG
                    }
                        TESTsCRATCH //U:: TO FIND A BUG
                        }
                            TESTsCRATCH //U:: TO FIND A BUG
                            //CONoUTrAW( "\r\n" USCORE127 "\r\n" ) ;
                            }
                                TESTsCRATCH //U:: TO FIND A BUG
                                }
                                    //CONoUTrAW( postc ) ;

                                    costHead += delta ;

                                    }
                                        *poste = 0 ;
                                        delta = poste - postc ;
                                        bEnd = 1 ;
                                    {
                                    if( poste )

                                    costRemain   -= delta ;
                                    postc        += delta ;
                                    costHeadPlus += delta ;

                                    osTextT* poste = !bFound ? 0 : postc + offFound ;

                                    }
                                        }
                                            break ;
                                            offFound = offi ;
                                            bFound = 1 ;
                                        {
                                        )
                                            && postc[ offi + 3 ] == '\n'
                                            && postc[ offi + 2 ] == '\r'
                                            && postc[ offi + 1 ] == '\n'
                                               postc[ offi     ] == '\r'
                                        (
                                        if
                                    {
                                    for( countT offi = 0 ; offi <= offMax ; offi ++ )
                                    countT offMax = delta - 4 ;
                                    ZE( countT , offFound ) ;
                                    ZE( boolT , bFound ) ;
                                {
                                else
                                if( !delta ) break ;
                                TESTsCRATCH //U:: TO FIND A BUG

                                }
                                    }
                                        break ;
                                        bFail = 1 ;
                                        ether.traceF( tinP , T("getF: could not read socket 175") ) ;
                                        POOPRqUIET
                                    {
                                    if( POOP )
                                    delta = pSControl->readF( tinP , postc , costRemain , flSOCKETcrEAD_JUSToNEmOUTHFUL | flSOCKETcrEAD_STILLhUNGRYiSoK ) ;
                                    SCOOPS
                                {
                                IFsCRATCH
                                ZE( countT , delta ) ;
                                TESTsCRATCH //U:: TO FIND A BUG
                            {
                            while( !bEnd )
                            ZE( boolT , bEnd ) ;
                            countT   costRemain = costaHeadPlus ;        
                            osTextT* postc      = postHeadPlus  ;
                            //CONoUTrAW( "\r\n" USCORE127 "\r\n" ) ;

                            //ether.memSetF( tinP , postHeadPlus , costaHeadPlus ) ;
                            TESTsCRATCH //U:: TO FIND A BUG
                        {
                        if( postHeadPlus )
                        ether.newF( tinP , LF , postHeadPlus , costaHeadPlus ) ; ___( postHeadPlus ) ;
                        const countT costaHeadPlus = TOCK >> 4 ;
                        TESTsCRATCH //U:: TO FIND A BUG
                    {
                    ZE( boolT    , bFail        ) ;
                    ZE( countT   , costHead     ) ;
                    ZE( countT   , costHeadPlus ) ;
                    ZE( osTextT* , postHeadPlus ) ;
                    TESTsCRATCH //U:: TO FIND A BUG

                    }
                        //etherC::etRockIF( tinP ).traceF( tinP , tRequest ) ;
                        pSControl->writeF( tinP , (osTextT*)tRequest ) ;

                        if( postBodyP ) tRequest += T(postBodyP) ;

                        tRequest += T("\r\n\r\n") ;

                        }
                            if( costBodyP  ) tRequest += T("\r\nContent-Length: ")+TF4(costBodyP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa) ;
                            if( !costBodyP ) costBodyP = thirdC::c_strlenIF( tinP , postBodyP ) ;
                        {
                        if( postBodyP )

                        TN( tRequest , "" ) ; tRequest = T(F(flagsP)&flBOXcgETf_HTTPpOST?"POST /":"GET /")+T(psttName)+T(" HTTP/1.1\r\nHost: ")+T(psttHost)+T("\r\nConnection: close") ;
                    {

                    pSControl->etherF( tinP , *tinP.pEtScratch ) ;
                    TESTsCRATCH //U:: TO FIND A BUG
                {
                do
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                countT cTries = cOpenTries ;
                TN( t307 , "307" ) ; //U:: 20190817@1559: EDIT TO FULLY SUPPORT TEMPORARY AND PERMANENT REDIRECTS (SILENTLY FOLLOW REDIRECTS UNLESS CALLER TELLS ME NOT TO)
                TN( t200 , "200" ) ;

                __NZ( &etSave != &ether ) ;
                etherC& etSave = pSControl->etherF( tinP ) ;
                TESTsCRATCH //U:: TO FIND A BUG

                SCOOPS
            {
            IFsCRATCH

            ZE( boolT , bFail ) ;
            boolT bNoQuitEarly = !cOpenTries ;
        {
        if( !POOP )

        }
            if( psttName->idAdam ) { __( psttName[ CSpREFIX ].idAdam == ' ' ) ; } //U: GOAL IS TO ENSURE THAT THERE ARE NO BLANKS ANYWHERE IN psttName
            //20190818@1037: COMMENTED OUT WITHOUT ANALYSIS: __( !psttName->idAdam ) ;
        {
        if( psttName )
        __( cbP ) ;
        __Z( pSControl ) ;
        //THREADmODE4oN( flTHREADmODE4_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY )
    {
    else if( ( !ether.strCompareF( tinP , psttType , T("http") ) || !ether.strCompareF( tinP , psttType , T("https") ) ) )
    }
        else         ether.delF( tinP , pbP ) ;
        if( !POOP ) cbP = cbFile ;
        DEL( pso ) ;
        verifyReplyF( tinP , 0xe2 ) ; // 226

        }
            }
                pso->readF( tinP , pbP , cbFile ) ;
                pbP[ cbFile ] = 0 ;
                ether.newF( tinP , LF , pbP , cbFile + 1 ) ; ___( pbP ) ;
            {
            if( cbFile ) //THIS WILL HANG FOREVER IF THE REMOTE HOST FAILS TO SEND ENOUGH BYTES
        {
        if( !POOP )

        verifyReplyF( tinP , 0x96 ) ; // 150
        __Z( pso ) ;
        __( bRefuse ) ;
        sData.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ;
        ZE( boolT , bRefuse ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        ZE( socketC* , pso ) ;

        { textC txt = T("retr ")+T(psttName)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }

        verifyReplyF( tinP , 200 ) ;
        ether.delF( tinP , pstthp ) ;
        { textC txt = T("port ")+T(pstthp)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }
        ether.strFromIdPortNicNameF( tinP , pstthp , idPort , nicName ) ; ___( pstthp ) ;
        ZE( strokeS* , pstthp ) ;
        { nicNameC nicNamenu ; sData.myNameF( tinP , idPort , nicNamenu ) ; }
        ZE( countT , idPort ) ;
        { ZE( countT , idpnu ) ; pSControl->myNameF( tinP , idpnu , nicName ) ; }
        nicNameC nicName ;
        sData.listenF( tinP ) ;
        sData.bindF( tinP ) ;
        socketC sData( tinP , ether , TAG( TAGiDnULL ) ) ;

        //U: info.fZombie = 0 ;
        }
            __( rc != 213 && rc != 211 ) ;
            ether.delF( tinP , psttReply ) ;
            cbFile = cbFileF( tinP , psttReply ) ;
            countT rc = pSControl->readWoReplyF( tinP , psttReply ) ; ___( psttReply ) ;
            ZE( strokeS* , psttReply ) ;
        {
        if( !POOP )
        ZE( sCountT , cbFile ) ;

        { textC txt = T("stat ")+T(psttName)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }
        __NZ( cbP ) ;

        //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
        infoBoxGetPutS info( tinP , ether , *pSControl ) ;
    {
    else if( !ether.strCompareF( tinP , psttType , T("ftp") ) && pSControl )
    }
        }
            cbP = 0 ;
            ether.delF( tinP , pbP ) ;
        {
        if( POOP )
        //U: info.fZombie = 0 ;

        pSControl->readF( tinP , pbP , cbP ) ;
        ether.newF( tinP , LF , pbP , cbP ) ; ___( pbP ) ;
        cbP = 2 * sizeof( countT ) ;

        //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
        infoBoxGetPutS info( tinP , ether , *pSControl ) ;
    {
    else if( !ether.strCompareF( tinP , psttHost , T(WWWiDEAFARMcOM) ) && !ether.strCompareF( tinP , psttType , T("dispatcher") ) && pSControl )
    }
        }
            cbP = 0 ;
            ether.delF( tinP , pbP ) ;
        {
        if( POOP )
        //U: info.fZombie = 0 ;

        pSControl->readF( tinP , pbP , cbP ) ;
        ether.newF( tinP , LF , pbP , cbP ) ; ___( pbP ) ;
        cbP = sizeof( sCountT ) + sizeof( countT ) ;

        //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
        infoBoxGetPutS info( tinP , ether , *pSControl ) ;
    {
    else if( !ether.strCompareF( tinP , psttHost , T(WWWiDEAFARMcOM) ) && !ether.strCompareF( tinP , psttType , T("time") ) && pSControl )
    }
        }
            }
                cbP = 0 ;
                ether.delF( tinP , pbP ) ;
            {
            if( POOP )

            }
                if( cbP ) pSControl->readF( tinP , pbP , cbP ) ;
                if( pbP ) pbP[ cbP ] = 0 ;
                ether.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
                __( cbAll - sizeof( countT ) - cbP ) ;
                pSControl->readF( tinP , (byteT*)&cbP , sizeof cbP ) ;
            {
            else
            }
                pSControl->readF( tinP , pbP , cbP ) ;
                ether.newF( tinP , LF , pbP , cbP ) ; ___( pbP ) ;
                cbP = cbAll ;
            {
            if( !!ether.strIdF( tinP , idf , sttq , S1C(' ') , psttName ) )
        {
        if( !POOP )
        }
            __1
            if( !( F(ether.flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) ) ether.etherPutLogF( tinP , psttName ) ;
        {
        if( !cbAll )
        //U: info.fZombie = 0 ;
        pSControl->readF( tinP , (byteT*)&cbAll , sizeof cbAll ) ;
        ZE( countT , cbAll ) ;
        { textC txt = T(psttName)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;

        //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
        infoBoxGetPutS info( tinP , ether , *pSControl ) ;
    {
    if( !ether.strCompareF( tinP , psttType , T("box.server") ) || !ether.strCompareF( tinP , psttType , T("box.server.adam") ) || !ether.strCompareF( tinP , psttType , T("box.server.deputy") ) && pSControl )
    // GET THE BACKING FILE BYTES
    _IO_

    }
        if( POOP ) return ;
        //U::FV( flBOXcgET , flagsP ) ;
        __Z( psttName ) ;
        __Z( psttType ) ;
        __Z( psttHost ) ;
        __NZ( pbP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
    SCOOP
{
/*1*/voidT boxC::getF( tinS& tinP , byteT*& pbP , countT& cbP , const flagsT flagsP , const osTextT* const postBodyP , countT costBodyP )/*1*/

/**/
*/
 cbP
 pbP
arguments
pbP and cbP must be ze, except where noted otherwise
 /napkin: get bytes from a napkin
 /napkin.make: get bytes from a napkin
  assumption:  messages are small enough to fit entirely within an internal buffer
 /tap/name: gets a message from a tap
  assumption:  messages are small enough to fit entirely within an internal buffer
 /hose/name: gets a message from a hose
 //name: gets the bytes of a local file
 host/news: retrieves the mail item whose id is specified in cbP (which must be nonze)
 host/pop: retrieves the mail item whose id is specified in cbP (which must be nonze)
 host/http: gets the remote file's bytes
 host/ftp: gets the remote file's bytes
  the time is returned in an timeS structure
 www.ideafarm.com/time: gets reference time from city center
gets all bytes contained in this box
  \<A HREF=\"5.6120104.1.1.0.html\"\>6120104:  WAKEsHOW( "example.simplest.func.1090005.boxC.getF" )\</A\>
 simplest
examples
\<A HREF=\"5.1090005.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$getF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

