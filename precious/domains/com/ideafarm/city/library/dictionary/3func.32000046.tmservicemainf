
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmServiceMainF )
}
    bServiceAdamReturnedG = 1 ; //U::DO THIS LATER
    }
        TELL( "tmServiceMainF: cleaning up" )
        }
            }
                TELL( "the driver has been fired" )
                ((thirdC&)etThread).osDriverFireF( tinP , tinP.pAdamGlobal1->postServiceName ) ;
                bServiceAdamReturnedG = 1 ;
                TELL( "firing the driver" )
            {
            if( /*ether &&*/ !bServiceFired )
            //THIS IS ILLEGAL; win32 SILENTLY CRAPS WHEN A SERVICE CALLS HIRE AND/OR FIRE FOR A SERVICE
    
            tinP.flagsThreadMode1 &= ~( F(flTHREADmODE1_DRIVERaDAM) ) ;
            if( !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
            TELL( "pMainF has returned" )
            (*pMainF)( &main ) ; //ASSUME: DEFINITION BLOCKS UNTIL QUITTING
            if( !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
            tinP.flagsThreadMode1 |= flTHREADmODE1_DRIVERaDAM ;
            TELL( "calling the adam" )
        {
        if( pMainF )
        BOSpOOP
        BOS( WHATgbo , BOSoK , SetServiceStatus( (SERVICE_STATUS_HANDLE)tinP.pAdamGlobal1->oshServiceStatus , (SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus ) )
        ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwWaitHint = 0 ;
        ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwCheckPoint = 0 ;
        ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwCurrentState = SERVICE_RUNNING ;
    
        mainS main( tinP , ether , etThread , hDll , T("cid ")+tCid+T(" level 1") ) ;
        TNCID ;
        __Z( pMainF ) ;
        etThread.dllEntryF( tinP , pMainF , hDll , T("mainF") ) ;
        ZE( mainFT , pMainF ) ;
        __Z( hDll ) ;
        etThread.delF( tinP , psttDll ) ;
        etThread.dllOpenF( tinP , hDll , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.")+T(psttDll)+T(".ipdos-wd") ) ;
    {

    }
        etThread.delF( tinP , psttw ) ;
        etThread.strSubstringF( tinP , psttDll , idf , countTC() , psttw ) ; ___( psttDll ) ;
        countT idf = 2 ;
        etThread.strWordF( tinP , psttw , T(*ppostHowP) , sttq , S1C('.') , 3 ) ; ___( psttw ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , psttw ) ;
        __Z( cHowP ) ;
    {
    ZE( strokeS* , psttDll ) ;

    BOSpOOP
    BOS( WHATgbo , BOSoK , SetServiceStatus( (SERVICE_STATUS_HANDLE)tinP.pAdamGlobal1->oshServiceStatus , (SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus ) )
    ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwWaitHint = 0x4000 ;
    ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwCheckPoint ++ ;
    ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwWin32ExitCode = NO_ERROR ;
    ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN ;
    ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwCurrentState = SERVICE_START_PENDING ;

    tinP.pAdamGlobal1->oshServiceStatus = tinP.brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , RegisterServiceCtrlHandler( tinP.pAdamGlobal1->postServiceName , serviceHandlerF ) )
    if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS ) ) { __( tinP.monitor.idThread - ifcIDtHREADlOW_tmWindowsOrServiceMainF ) ; }

    thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_SERVICE ;

    handleC&  hDll      = *(handleC*)pTaskP->c3 ;
    osTextT** ppostHowP = (osTextT**)pTaskP->c2 ;
    countT    cHowP     =            pTaskP->c1 ;
    thirdC&   thThread = etThread ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )

/*1*/TASK( tmServiceMainF ) // THIS THREAD WAS LAUNCHED BY THE O.S.; "TASK" AND "DONE" ARE BEING USED TO PROVIDE tinP, ether, etThread/*1*/

}
    }
        }
            break ;

            BOSpOOP
            BOS( WHATgbo , BOSoK , SetServiceStatus( (SERVICE_STATUS_HANDLE)tinP.pAdamGlobal1->oshServiceStatus , (SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus ) )
            ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwWaitHint = 0 ;
            ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwCheckPoint = 0 ;
            ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwCurrentState = SERVICE_STOPPED ;

            }
                }
                    ++ s; thirdC::dosSleepRawIF( tinP , 250 ) ; //MUST BE MUCH LOWER THAN THE dwWaitHint VALUE
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , SetServiceStatus( (SERVICE_STATUS_HANDLE)tinP.pAdamGlobal1->oshServiceStatus , (SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus ) )
                    ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwWaitHint = 8000 ;
                    ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwCheckPoint ++ ;
                {
                while( !bServiceAdamReturnedG && !etThread )
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            etThread.etherFireImpersonateMonitorIF( tinP ) ;
            bServiceFired = 1 ;

            //POPUP( "SERVICE_STOP_PENDING" ) ;
            BOSpOOP
            BOS( WHATgbo , BOSoK , SetServiceStatus( (SERVICE_STATUS_HANDLE)tinP.pAdamGlobal1->oshServiceStatus , (SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus ) )
            ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwWaitHint = 8000 ;
            ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwCheckPoint ++ ;
            ((SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus)->dwCurrentState = SERVICE_STOP_PENDING ;
            etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;
        {
        case SERVICE_CONTROL_SHUTDOWN :
        case SERVICE_CONTROL_STOP :
        }
            break ;
            BOSpOOP
            BOS( WHATgbo , BOSoK , SetServiceStatus( (SERVICE_STATUS_HANDLE)tinP.pAdamGlobal1->oshServiceStatus , (SERVICE_STATUS*)tinP.pAdamGlobal1->pcServiceStatus ) )
        {
        case SERVICE_CONTROL_INTERROGATE :
    {
    switch( fdwControl )
    ZE( boolT , bRemoveMyself ) ;

    tinS& tinP = *processGlobal1I.pTinDadService ; //THIS HAS BEEN VERIFIED FOR WINDOWS: I EXECUTE ON THE SAME THREAD THAT CALLED THE DISPATCHER
    etherC& etThread = *processGlobal1I.pEtThreadServiceEventHandler ;
    if( !processGlobal1I.pEtThreadServiceEventHandler ) return ;
{
VOID WINAPI serviceHandlerF( DWORD fdwControl ) // CALLED WITHIN StartServiceCtrlDispatcher; GUARANTEED TO BE ON THREAD 1

boolT bServiceAdamReturnedG ;
boolT bServiceFired ;

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

