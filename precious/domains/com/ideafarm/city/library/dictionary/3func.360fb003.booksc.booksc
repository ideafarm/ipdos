
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#undef MYaLLOC

}
    }
        *(flagsT*)&flagsCtBook &= ~( F(flBOOKc_RESETcREFoNcT) ) ;
        touchAllBooksF( tinP , &bnu ) ;
        ZE( boolT , bnu ) ;
    {
    if( tinP.pPoolUse && F(flagsP) & flBOOKSc_RESETcREFoNcT )

    THREADmODE3rESTORE

    //CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal3S::_processGlobal3I_IF().heap.cNewF()-processGlobal3S::_processGlobal3I_IF().heap.cDelF() , "    \r\n" ) ;

    //if( tinP.pEther ) tinP.pEther->trace F( tinP , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": ")+T(postNameShort)+T(": ")+T("ct - [offBookBackNow,CbOOKsLOTS]:    ")+TF2(offBookBackNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(CbOOKsLOTS,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG

    }
        else if( this == &processGlobal3I.bksWords ) processGlobal1I.flCt |= flCTdTg_bksWords        ;
        else if( this == &processGlobal3I.bksWord  ) processGlobal1I.flCt |= flCTdTg_bksWord         ;
        }
            THREADmODE4rESTORE
            processGlobal3I.bkTelemetryAppEarlyLate.purgeF( tinP ) ;
            writeF( tinP , pbi , cbi , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ELSEfILLtOeND , 0 ) ;
            CONoUTrAW3( "booksC: pouring early application telemetry [cbi]:    " , cbi , "\r\n" ) ;
            processGlobal3I.bkTelemetryAppEarlyLate.readF( tinP , pbi , cbi , offi ) ;      //U:: THIS STUDY IS LOW PRIORITY BECAUSE THE PENDING BUFFER DOES NOT YET EXIST AND 0 TELEMETRY IS POURED
            THREADmODE4oN( flTHREADmODE4_DOnOTfLUSHpENDINGaPPtELEMETRY ) ;                  //U:: WARRANTS FURTHER STUDY AND CRAFTWORK ; THE GOAL IS TO PREVENT OUT OF ORDER APP TELEMETRY DO TO APP TELEMETRY GENERATED DURING THIS POUR OPERATION
            ZE( countT , offi ) ;
            countT cbi = - 1 ;
            ZE( const byteT* , pbi  ) ;

            processGlobal1I.flCt |= flCTdTg_bksTelemetryApp ;
        {
        else if( this == &processGlobal3I.bksTelemetryApp )
        }
            processGlobal3I.bkTelemetrySysEarlyLate.purgeF( tinP ) ;
            writeF( tinP , pbi , cbi , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ELSEfILLtOeND , 0 ) ;
            CONoUTrAW3( "booksC: pouring early system telemetry [cbi]:    " , cbi , "\r\n" ) ;
            processGlobal3I.bkTelemetrySysEarlyLate.readF( tinP , pbi , cbi , offi ) ;
            ZE( countT , offi ) ;
            countT cbi = - 1 ;
            ZE( const byteT* , pbi  ) ;

            processGlobal1I.flCt |= flCTdTg_bksTelemetrySys ;
        {
        if( this == &processGlobal3I.bksTelemetrySys )
    
        if( PCPiDbOOKnOW[ 0 ] == 1 && PCPiDbOOKnOW[ 1 ] == 1 ) ((bookHeadS&)BOOKnOW).flags |= flBOOKhEADs_PRIORbOOKnOTcONTINUEDhERE ;

        NEWbOOK2sETfLAG
        THREADmODE3rESTORE
        new( 0 , tinP , PBbOOKbACKnOW , SIZEOF_bookC ) bookC( tinP , idLineCtP , idiFileCtP , pbBitsCtP , postBookNameScratch , idStateSpace , flagsCtBook , F(flagsCtBook) & flBOOKc_WRITER ? cbBodyNew : 0 , bFill , idMemorySpace ) ;
        THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
        NEWbOOK1bLAMMOiFcT
    {
    if( !POOP )

    //CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal3S::_processGlobal3I_IF().heap.cNewF()-processGlobal3S::_processGlobal3I_IF().heap.cDelF() , "    called setBookNameIdF\r\n" ) ;
    setBookNameIdF( tinP , F(flagsCt) & flBOOKSc_PURGEoNcT ? flBOOKScsELECT_PURGE : flBOOKScsELECT_null , 0 , pbQuitP ) ;
    //CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal3S::_processGlobal3I_IF().heap.cNewF()-processGlobal3S::_processGlobal3I_IF().heap.cDelF() , "    \r\n" ) ;

    //if( tinP.pEther ) tinP.pEther->trace F( tinP , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": ")+T(postNameShort)+T(": ")+T("ct [offBookBackNow]: ")+TF2(offBookBackNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": ct / incremented") ) ; //U:: TO FIND A BUG
    offBookBackNow ++ ;

    }
        //CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal3S::_processGlobal3I_IF().heap.cNewF()-processGlobal3S::_processGlobal3I_IF().heap.cDelF() , "    psttFindLike\r\n" ) ;
        }
            tinP.pEther->strMakeF( tinP , LF , psttFindLike , tLike ) ; ___( psttFindLike ) ;
            tLike += T("/ideafarm/ipdos/memorySpaces/")+T(thirdC::postUserNameIF())+T("/")+TF3(idMemorySpace?idMemorySpace:tinP.pAdamGlobal1->idMemorySpace,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T("/stateSpaces/")+TF2(idStateSpace,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("/")+T(postNameShort)+T(".booksC.1.book.*.bookC") ;
            TN( tLike , "///ideafarm/ephemeral/backed.up.daily/domains/com" ) ;
        {
        if( !( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE ) )
        //CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal3S::_processGlobal3I_IF().heap.cNewF()-processGlobal3S::_processGlobal3I_IF().heap.cDelF() , "    \r\n" ) ;

        thirdC::c_memcpyIF( tinP , postNameShort , postP , costaName ) ;
        thirdC::c_memsetIF( tinP , pbNapReadCursor , sizeof pbNapReadCursor ) ; // WOTH COUNT: MUST BE 0 IFF CURSOR NAPKIN IS NOT CT    //A:ASSUME: napkinC IMAGE ALWAYS BEGINS WITH A NONZE countT VALUE

        }
            thirdC::c_memsetIF( tinP , *(byteT**)&ppcpIdBook[ offb ] , cbaIdBook ) ;
        {
        for( countT offb = 0 ; offb < CbOOKsLOTS ; offb ++ )

        }
            }
                *(byteT**)&ppcpIdBook[ offb ] = processGlobal3I.heap.newF( tinP , idLineCtP , idiFileCtP , cbaIdBook ) ;
            {
            for( countT offb = 0 ; offb < CbOOKsLOTS ; offb ++ )

            thirdC::c_memsetIF( tinP , *(byteT**)&ppcpIdBook , cbaPointers ) ;
            thirdC::c_memsetIF( tinP , pbFlagsiBookBackCt    , cbaFlags    ) ;

            *(byteT**)&ppcpIdBook          = processGlobal3I.heap.newF( tinP , idLineCtP , idiFileCtP , cbaPointers   ) ;
            *(byteT**)&pcpIdBookScratchMax = processGlobal3I.heap.newF( tinP , idLineCtP , idiFileCtP , cbaIdBook     ) ;
            *(byteT**)&pcpIdBookScratchMin = processGlobal3I.heap.newF( tinP , idLineCtP , idiFileCtP , cbaIdBook     ) ;
            *(byteT**)&pcpIdBookScratch1   = processGlobal3I.heap.newF( tinP , idLineCtP , idiFileCtP , cbaIdBook     ) ;
            pbFlagsiBookBackCt             = processGlobal3I.heap.newF( tinP , idLineCtP , idiFileCtP , cbaFlags      ) ;
            pbBookBack                     = processGlobal3I.heap.newF( tinP , idLineCtP , idiFileCtP , cbaBooks      ) ;
            postBookNameScratch            = processGlobal3I.heap.newF( tinP , idLineCtP , idiFileCtP , costaBookName ) ;
            postNameShort                  = processGlobal3I.heap.newF( tinP , idLineCtP , idiFileCtP , costaName     ) ;

            byteT* const pbe = pbc + cbBooksNoPuseBackP ;
            byteT*       pbc = pbBooksNoPuseBackP ;
        {

        countT costaBookName = costaName + TUCK ; //U:: REPLACE "TUCK" WITH ACTUAL NEEDED
        countT costaName     = 1 + thirdC::c_strlenIF( tinP , postP )     ;
        countT cbaFlags      = 1 + ( CbOOKsLOTS ) / SB ;
        countT cbaBooks      = ( CbOOKsLOTS ) * SIZEOF_bookC       ;
        countT cbaPointers   = ( CbOOKsLOTS ) * sizeof( countT* )  ;
        countT cbaIdBook     = ccMaxIdBook * sizeof( countT )     ;
    {

    //CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal3S::_processGlobal3I_IF().heap.cNewF()-processGlobal3S::_processGlobal3I_IF().heap.cDelF() , "    \r\n" ) ;

    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP | flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )

    _IO_

    }
        if( POOP ) return ;
        __( idMemorySpaceP && !( F(tinP.flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tinP ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tinP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        //U:: DESIGN PROBLEM: INSTANCE SHARED BY MULTIPLE PROCESSES CANNOT PURGEoNcT: __NZ( F(flagsCt) & flBOOKSc_CYCLE && !( F(flagsCt) & flBOOKSc_PURGEoNcT ) ) ;
        __NZ( cbP && !( F(flagsP) & flBOOKSc_WRITER ) ) ;
        FV( flBOOKSc , flagsP ) ;
        }
            __Z( idStateSpaceP ) ; // !idStateSpaceP CAN BE ALLOWED IF THERE IS EVER A REASON TO DO SO, BUT THIS WOULD BE AN ODD APPLICATION BECAUSE THE CLIENT READER WOULD NEED TO KEEP UP WITH THE SERVER WRITER ; IF A SERVER WRITER FINISHED WRITING A bookC BEFORE THE CLIENT READER STARTED READING IT, THE DATA IN THE bookC WOULD BE LOST
        {
        else
        }
            __( CbOOKsLOTS > 2 ) ;
            __Z( cbBooksNoPuseBackP ) ;
            __Z( pbBooksNoPuseBackP ) ;
            __( !postP != !idStateSpaceP ) ;  //INSTANCES WITHOUT BACKING FILES MUST BE UNNAMED; THIS RESTRICTION CAN BE REMOVED ONCE I AM EDITED TO ENUMERATE SHARED MEMORY OBJECTS RATHER THAN BACKING FILES
            __( tinP.monitor.idThread != 1 ) ; //I WILL USE STATIC STORAGE SO WILL NOT BE THREAD SAFE; INTENDED ONLY FOR CT/DT OF INSTANCES IN STATIC STORAGE
        {
        if( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE )
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP

    //CONJ: THE CYCLING ISSUE IS ONLY FOR CONSTRUCTION; WRITING IS ALREADY SERIALIZED SO SHOULD WORK OK.  THIS SUGGESTS THAT SERIALIZING CONSTRUCTION WITH WRITING MIGHT SUFFICE
    //NOTE: SINGLE THREADED CYCLING WORKS AOK FOR ANY CbOOKsLOTS VALUE
    //CONJ: THE CURRENT CODE (20160621@1450) WILL WORK AOK FOR SHARED CYCLING AS LONG AS CbOOKsLOTS IS 1
    //FOR CYCLING, MULTITHREADING AND SHARING BY MULTIPLE WRITING PROCESSES NEEDS TO BE THOUGHT ABOUT
    //FOR CYCLING, offbookBackNow MUST BE SET TO POINT TO THE BOOK THAT CURRENTLY CONTAINS THE MOST RECENT WRITING
    //FOR CYCLING, ALL EXISTING FILES MUST BE OPENED.  THIS IS NOT CURRENTLY DONE
    //U:: CYCLING IS CURRENTLY NOT SUPPORTED CORRECTLY WHEN CbOOKsLOTS IS NOT 1

    //if( tinP.pEther ) tinP.pEther->trace F( tinP , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": ")+T(postNameShort)+T(": ")+T("ct + [offBookBackNow,CbOOKsLOTS]:    ")+TF2(offBookBackNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(CbOOKsLOTS,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG
{
bFill( bFillP )
psttFindLike( 0 ) ,
ppcpIdBook( 0 ) ,
cKeepInactive( cKeepInactiveP ) ,
grabBookNow( tinP , idLineCtP , idiFileCtP , pbBitsCtP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER | flGRABc_SHARElAYER , ifcIDgRABlAYER_bBOOKSc ) , // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
idMemorySpace( idMemorySpaceP ) ,
idStateSpace( idStateSpaceP ) ,
cbBodyNew( cbP ) ,
postBookNameScratch( 0 ) ,
postNameShort( 0 ) ,
) ,
    ( F(flagsP) & flBOOKSc_RESETcREFoNcT           ? flBOOKc_RESETcREFoNcT           : flBOOKc_null )
    ( F(flagsP) & flBOOKSc_DOnOTsERIALIZEnAPKINS   ? flBOOKc_DOnOTsERIALIZEnAPKIN    : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_LOCK                    ? flBOOKc_LOCK                    : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_DOnOTiNITIALIZEdATA     ? flBOOKc_DOnOTiNITIALIZEdATA     : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_USEgRABmEMORYsPACEoVERRIDE ? flBOOKc_USEgRABmEMORYsPACEoVERRIDE : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_DOnOTrEGISTERfILE       ? flBOOKc_DOnOTrEGISTERfILE       : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_DOnOTuSEpUSE            ? flBOOKc_DOnOTuSEpUSE            : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_WRITER                  ? flBOOKc_WRITER                  : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_DELETE                  ? flBOOKc_DELETE                  : flBOOKc_null ) |
(
flagsCtBook
flagsCt( flagsP ) ,
offBookBackNow( - 1 ) ,
pbFlagsiBookBackCt( 0 ) ,
pbBookBack( 0 ) ,
pcpIdBookScratchMax( 0 ) ,
pcpIdBookScratchMin( 0 ) ,
pcpIdBookScratch1(    0 ) ,
ccMaxIdBook( TUCK >> 5 ) , //20190116@0943: REDUCED FROM TUCK TO TUCK >> 5 IN ORDER TO CONSERVE heapC USAGE; AS OF THIS WRITING SOME CODE SUPPORTS LENGTHS > 1 COUNT BUT OTHER CODE LIMITS NAME TO A SINGLE COUNT
poop( flPOOP_SMELLY ) ,
/*1*/booksC::booksC( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postP , const countT idStateSpaceP , const flagsT flagsP , const countT cbP , const countT cKeepInactiveP , const byteT bFillP , byteT* const pbBooksNoPuseBackP , const countT cbBooksNoPuseBackP , const countT idMemorySpaceP , const boolT* pbQuitP ) :/*1*/

#define MYaLLOC(lvalueP,cbP) { if( pbc + cbP > pbe ) { BLAMMO ; } else { (lvalueP) = pbc ; pbc += (cbP) ; } }

/**/
*/
   if constructor quits then the instance will become impotent
  if not 0 then constructor will quit waiting for a backing file to appear when *pbQuitP becomes nonze
  if 0 then constructor will not return until it has seen at least wo backing file
  if not 0 then points to boolT
  can be 0
  affects only construction
 pbQuitP
 cbBooksNoPuseBackP
  this backing memory is use if, and only if, flBOOKSc_DOnOTuSEpUSE
 pbBooksNoPuseBackP
 cbP
 flagsP
  if 0 then instance does not persist after lath referencing process ends
  can be 0
 idStateSpaceP
    document the requirement in a comment
    use a string literal whenever feasible
   coding conformance
  if flBOOKSc_DOnOTuSEpUSE then postP must point to storage that will remain defined for the life of the instance
  if not 0 then idStateSpaceP must also not be 0
  if 0 then idStateSpaceP must also be 0
  can be 0
 postP
 pbBitsCtP
 idiFileCtP
 idLineCtP
 tinP
arguments
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

