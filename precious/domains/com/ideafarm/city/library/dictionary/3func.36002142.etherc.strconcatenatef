
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bSOS ;
    if( psttP && psttP->idAdam && psttP[ CSpREFIX ].idCaste == sc_PREFIXlENGTH ) bSOS = 1 ;

    if( bDelete ) delF( tinP , (strokeS*&)pstt1P ) ;
    }
        }
            if( psttDelimiterP && -- cIn ) strFuseF( tinP , psttP , psttDelimiterP ) ;
            #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000010.strConcatenateF_woSnip.h"
        {
        FORsTRINGSiN1( (strokeS*)pstt1P )
        ZE( boolT , bNullLag ) ;
        TN( tNull , "" ) ; tNull = T("") + S2( (countT)0 , sc_NULL ) ;
        strMakeF( tinP , LF , psttP , T("") , csttValue + csttExtraP ) ; //CALLER MUST TAG ___( psttP ) ;

        }
            if( psttDelimiterP ) csttValue += ( cIn - 1 ) * psttDelimiterP->idAdam ;
            csttValue = csttSnips ;
            }
                csttSnips += psttc1->idAdam ;
                cIn ++ ;
            {
            FORsTRINGSiN1( (strokeS*)pstt1P )
            ZE( countT , csttSnips ) ;
        {
        ZE( countT , cIn ) ;
        ZE( countT , csttValue ) ;
    {
    else
    }
        strMakeF( tinP , LF , psttP , pstt1P , csttExtraP ) ; //CALLER MUST TAG ___( psttP ) ;
    {
    if( !pstt1P->idAdam || pstt1P[ CSpREFIX ].idCaste != sc_PREFIXlENGTH )
    ZE( countT , cMarks ) ; //NOT RETURNED IN THIS OVERLOAD (U::THE HIGH ORDER BIT COULD BE USED FOR bSOS, OR A countT& PARAMETER)
    ZE( boolT , bSOS ) ;

    }
        bDelete = 1 ;
        psttP = 0 ;
        pstt1P = psttP ;
    {
    if( !pstt1P )
    ZE( boolT , bDelete ) ;

    const boolT  bSeparate = !!( F(flagsP) & flSTRcONCATENATE_SEPARATE ) ;
    const countT cExclude = pczIdCasteExcludeP ? thirdC::c_strlenIF( tinP , pczIdCasteExcludeP ) : 0 ;
    const countT cInclude = pczIdCasteIncludeP ? thirdC::c_strlenIF( tinP , pczIdCasteIncludeP ) : 0 ;

    _IO_

    }
        if( POOP ) return 0 ;
        __( F(flagsP) & flSTRcONCATENATE_COPY ) ;
        FV( flSTRcONCATENATE , flagsP )                                                                                        \
        __( !!psttP == !!pstt1P ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/boolT etherC::strConcatenateF( tinS& tinP , strokeS*& psttP , const strokeS* pstt1P , const strokeS* const psttDelimiterP , const flagsT flagsP , const countT* const pczIdCasteIncludeP , const countT* const pczIdCasteExcludeP , const countT csttExtraP )/*1*/

/**/
*/
  can be 0
 csttExtraP
  will be inserted between each snippet in st_psttP
  if not 0 then can be 0 length
  can be 0
 psttDelimiterP
  can be a string of strings of strings of strings, etc
  can be a string of strings of strings
  normally is a string of strings
  can be a simple string
   if 0 then psttP is replaced
  can be 0
 pstt1P
  must be 0
 psttP
 tinP
arguments
if psttP is a simple string then i just copy the string
i evaluate to 1 iff the resulting psttP is (still) a string of strings
i must be called repeatedly if nested concatenations are required
concatenates all strings in pstt1P into a single string
\<A HREF=\"5.1030185.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strConcatenateF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

