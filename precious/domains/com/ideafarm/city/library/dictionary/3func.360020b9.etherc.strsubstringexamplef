
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    delF( tinP , psttWhite ) ;

    }
        }
            }
                strReplaceF(    tinP , psttP , 0 , T(psttTokenP)+T(" ")+T(sttOpen) , T(psttTokenP)+T(sttOpen) ) ; // CALLER MUST TAG ___( psttP ) ;
                strReplaceAnyF( tinP , psttP , 0 , psttWhite                       , T(" ")                   ) ; // CALLER MUST TAG ___( psttP ) ;
                strSubstringF(  tinP , psttP , idfTrim , idlTrim        , psttBigP                 ) ; // CALLER MUST TAG ___( psttP ) ;
            {
            if( idfTrim && idlTrim )

            }
                if( psttBigP[ CSpREFIX - 1 + idfc ] == sttOpen ) idlTrim = strIdMatchingF( tinP , idfc , sttqc , psttBigP ) ;

                // idfc IS THE ID OF THE FIRST NONBLANK STROKE AFTER THE OCCURRANCE
                }
                    }
                        idfc = idfc2 ;
                        sttqc = sttqc2 ;
                    {
                    if( idfc == strIdAnyF( tinP , 0 , flSTRmATCH_null , idfc2 , sttqc2 , psttWhite , psttBigP ) )
                    countT idfc2 = idfc ;
                    strokeS sttqc2 = sttqc ;
                {

                countT idfc = idfTok + psttTokenP->idAdam ;
                strokeS sttqc = sttQuoteP ;
            {
            ZE( countT , idlTrim ) ;
            countT idfTrim = idfTok ;
        {
        if( idfTok && ( idfTok == 1 || !psttBigP[ CSpREFIX - 2 + idfTok ].bOkForIdentifiersF() ) )
        const countT idfTok = strIdF( tinP , 0 , flSTRmATCH_null , idFirstP , sttQuoteP , psttTokenP , psttBigP ) ;
    {
    while( !psttP && idFirstP )

    else             { strMakeF( tinP , LF , psttWhite , T(TbLACK) ) ; ___( psttWhite ) ; }
    if( psttWhiteP ) { strMakeF( tinP , LF , psttWhite , psttWhiteP    ) ; ___( psttWhite ) ; }
    ZE( strokeS* , psttWhite ) ;
    const strokeS sttOpen = (countT)sttOpenP ? sttOpenP : S1C('(') ;
    _IO_

    }
        if( POOP ) return ;
        __Z( psttTokenP ) ;
        __Z( psttBigP ) ;
        __Z( idFirstP ) ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::strSubstringExampleF( tinS& tinP , strokeS*& psttP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* const psttBigP , const strokeS* const psttTokenP , const strokeS sttOpenP , const strokeS* const psttWhiteP )/*1*/
/**/
*/
 psttWhite
 sttOpen
  must not be 0
 psttTokenP
  must not be 0
 psttBigP
 sttQuoteP
  must not be 0
 idFirstP
  must be 0
 psttP
arguments
extracts a function call from the string
  \<A HREF=\"5.9b10104.1.1.0.html\"\>9b10104:  WAKEsHOW( "example.simplest.func.10300d3.etherC.strSubstringExampleF" )\</A\>
 simplest
examples
\<A HREF=\"5.10300d3.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strSubstringExampleF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

