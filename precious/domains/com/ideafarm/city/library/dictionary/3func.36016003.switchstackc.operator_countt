
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cPlates ;
    if( pBaton ) pBaton->ungrabF( tinP ) ;

    }
        if( pStack ) cPlates = *pStack ;
        stackC* pStack = (stackC*)(countT)swMe ;
    {
    if( swMe.idSlotOfLeverF( tinP , query ) )

    }
        }
            default                                : { __( idLeverType ) ; __1                          ; break ; }
            case ifcIDtYPElEVER_PTR_soulC             : { query = (countT)pbLever                                           ; break ; }
            case ifcIDtYPElEVER_BLOBdOOMED                  :
            case ifcIDtYPElEVER_PTR_nicNameC          :
            case ifcIDtYPElEVER_PTR_osTextT           : { query = (countT)*(osTextT**)pbLever                               ; break ; }
            case ifcIDtYPElEVER_PTR_plateC            : { query = (countT)*(plateC**)pbLever                                ; break ; }
            case ifcIDtYPElEVER_PTR_strokeS           : { query = (countT)*(strokeS**)pbLever                               ; break ; }
            case ifcIDtYPElEVER_PTR_countT            : { query = (countT)*(countT**)pbLever                                ; break ; }
            case ifcIDtYPElEVER_PTR_lenPrefixedCountT :
            case ifcIDtYPElEVER_PTR_ptrStrokeS        :
            case ifcIDtYPElEVER_PTR_BLOB              :
            case ifcIDtYPElEVER_countT                : { query = *(countT*)pbLever                                         ; break ; }
            case ifcIDtYPElEVER_tid                   : { query = dosGetInfoBlocksIdThreadIF()                  ; break ; }
        {
        switch( idLeverType )
        const countT idLeverType = swMe.idLeverTypeF( tinP ) ;
        byteT* const pbLever = swMe.pbLeverF( tinP ) ;
    {
    ZE( countT , query ) ;

    else if( osTidOwner != tinP.osTid && !bDying && !( F(flagsSwitch) & flSTACKc_ALLOWmULTIPLEuNSERIALIZED ) ) BLAMMO ;
    else if( !osTidOwner ) osTidOwner = tinP.osTid ;
    if( pBaton ) pBaton->grabF( tinP , TAG( TAGiDnULL ) ) ;
    ZE( countT , cPlates ) ;

    }
        if( third ) return 0 ;
    {
    IFbEcAREFUL

    SCOOP
    TINSL
{
/*1*/switchStackC::operator countT ( voidT )/*1*/

/**/
*/
my behavior differs from stackC in that the latter does not grab itself
if the current lever 
  if there is no stack for the current thread (or lever) then none will be created
 case 2: if there is a stack for the current thread (or lever) and that stack is empty
 case 1: if there is not yet a stack for the current thread (or lever)
there are two cases in which the returned value is ze
evaluates to the number of items on the stack for the current thread
  \<A HREF=\"5.ce10104.1.1.0.html\"\>ce10104:  WAKEsHOW( "example.simplest.func.1210004.switchStackC.operator_countT" )\</A\>
 simplest
examples
\<A HREF=\"5.1210004.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

