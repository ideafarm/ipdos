
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        }
            DELzOMBIE( pzSessions ) ;
            sessionsC* pzSessions = (sessionsC*)pbSessions ;
        {
        if( bDeleteSessions )

        }
            while( cSession ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        TELL( "server: final wait (forever) for all sessions to end" )
    
        b_lever_idSession.ungrabF( tinP ) ;
        }
            }
                }
                    if( POOP ) POOPR
                    tinP.pEtScratch->sockCancelF( tinP , hSoc ) ;
                    SCOOPS
                    //}
                    //    thirdC::dosTellMonitorIF( tinP , tellC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEtELL_LOG , poste , sizeof poste ) ) ;
                    //    const osTextT poste[] = "ifcDrivenServerF: canceling a client session because i am quitting" ;
                    //{
                    const handleC& hSoc = pso->handleF( tinP ) ;
                    TELL( "server: canceling a client session" )
                {
                if( pso )
                socketC*& pso = (socketC*&)(countT&)sw_pso ;
                lever_idSession = sw_pso.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = sw_pso.cFlavorsF( tinP ) ;
        {
        b_lever_idSession.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        }
            }
                while( cSession && cTries -- ) { ++ s ; thirdC::dosSleepIF( tinP , time1nap ) ; }
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            TELL( "server: will wait for a while to see cSession = 0" )
    
            }
                time1nap = info2P.time1grace / cTries ;
                cTries >>= 1 ;
            {
            while( time1nap < TUCK * 0x40 && cTries > 1 )
            countT time1nap = info2P.time1grace / cTries ;
            countT cTries = 0x10 ;
        {
        else if( info2P.time1grace )
        }
            }
                while( cSession ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            TELL( "server: will wait forever until cSession is 0" )
        {
        if( info2P.time1grace == - 1 )
    
        if( info2P.bState ) if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->ungrabF( tinP ) ;

        }
            //A:  THREADmODE1rESTORE
            //A:  DEL( pState ) ;
            //A:  THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            //A:  info1P.ppbdVarying = 0 ;
            //A:  *info1P.ppbdVarying = 0 ; //U::BUG: MIGRATED FROM pbdVarying WITHOUT ADEQUATE STUDY; THIS FUNCTION COULD CONTAIN A BUG IN CODE HANDLING THIS MEMBER
            //A:  if( info2P.stateEndF ) (*info2P.stateEndF)( tinP , *this , *info1P.ppbdVarying , info2P.cbdVarying , info2P.cArg ) ;
            //A:  if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->grabF( tinP , TAG( TAGiDnULL ) ) ;
            //A: 20141130@1135: COMMENTED OUT AS PART OF ELIMINATION OF stateC
        {
        //if( pState )

        }
            info1P.sgnIdPortReplaced.giveF( tinP ) ;
            TELL( "server: cleaning up" )

            }
                TELL( "server: destroying listener socket" )
                info1P.idPort = 0 ;
                POOPR
    
                }
                    }
                        }
                            ZE( countT , tid ) ; tinP.pEtScratch->osThreadF( tinP , tid , info1P.tmF , 0 , flTHREADlAUNCH_SHOWpONY , 0 , (countT)pc8tp_tm ) ;
                            TELL( "server: launching server thread for this client" )

                            memCopyF( tinP , (byteT*)&pc8tp_tm2->c2 , (byteT*)&nnPeer , sizeof nnPeer ) ;
                            pc8tp_tm2->c1 = (countT)&sessions ;
                            pc8tp_tm1->c8 = (countT)&sw_cSessionWithPeer ;
                            pc8tp_tm1->c7 = (countT)&lever_nnPeer ;
                            pc8tp_tm1->c6 = info2P.cArg ;
                            pc8tp_tm1->c5 = (countT)&cSession ;
                            pc8tp_tm1->c4 = (countT)&sw_pso ;
                            pc8tp_tm1->c3 = (countT)&lever_idSession ;
                            pc8tp_tm1->c2 = (countT)&b_lever_idSession ;
                            pc8tp_tm1->c1 = idSessionLath ;

                            pc8tp_tm->c2 = (countT)pc8tp_tm2 ;
                            pc8tp_tm->c1 = (countT)pc8tp_tm1 ;
                        {
                        if( pc8tp_tm && pc8tp_tm1 && pc8tp_tm2 )
                        newF( tinP , LF , pc8tp_tm2 ) ; ___( pc8tp_tm2 ) ;
                        newF( tinP , LF , pc8tp_tm1 ) ; ___( pc8tp_tm1 ) ;
                        newF( tinP , LF , pc8tp_tm ) ; ___( pc8tp_tm ) ;
                        ZE( count8S* , pc8tp_tm2 ) ;
                        ZE( count8S* , pc8tp_tm1 ) ;
                        ZE( count8S* , pc8tp_tm ) ;

                        if( !POOP ) cSession ++ ;
                        //if( 0x401043a == processGlobal1I.idAdamRoot ) ifcSayIF( T("about to launch service thread: third is ")+T(third?"IMPOTENT":"potent") , flSAY_APPEND | flSAY_LOG ) ;
    
                        sw_cSessionWithPeer.ungrabF( tinP ) ;
                        ++ sw_cSessionWithPeer ;
                        lever_nnPeer = nnPeer ;
                        if( sw_cSessionWithPeer.cFlavorsF( tinP ) > 0x10/*U::INCREASE TO GIVE MORE PROTECTION AGAINST ATTACK*/ ) sw_cSessionWithPeer.freeAllF( tinP ) ;
                        sw_cSessionWithPeer.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
                        b_lever_idSession.ungrabF( tinP ) ;
                        sw_pso = (countT)pso ;
                        lever_idSession = ++ idSessionLath ;
                        b_lever_idSession.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        TELL( "server: preparing to serve the accepted socket" )
                    {
                    else if( pso )
                    }
                        DEL( pso ) ;
                        TELL( "server: deleting the accepted socket without serving it" )
                    {
                    if( info1P.bQuit || third || bSilent || POOP )

                    sw_cSessionWithPeer.ungrabF( tinP ) ;

                    }
                        //bSilent |= 1 ; //TO PREVENT WO PEER FROM OPENING MANY SESSIONS TO DOS ATTACK
                        //LOGrAW( "setting bSilent because this client's session count is high" ) ;
                        //U:: ENABLE AFTER SUPPRESSING THIS FOR DEADMAN
                    {
                    if( 0x10 < sw_cSessionWithPeer )

                    lever_nnPeer = nnPeer ;
                    sw_cSessionWithPeer.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    TELL( "server: detecting dos attack client" )
                    //U::EXCLUDE ZOMBIE SESSIONS FROM THE COUNT, SO HTTP CLIENT CAN INITIATE AN ARBITRARILY LONG BURST OF SESSIONS TO GET E.G. ALL IMAGES FOR A PAGE
    
                    ( bRefuse ? cRefused : cAccepted ) ++ ;
                    if( bRefuse ) { LOGrAW( "refusing a client\r\n" ) ; }

                    bSilent = 0/*diskFileExistsF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/ipdos/attackers/")+T(nnPeer) )*/ ;
    
                    //if( 0x401043a == processGlobal1I.idAdamRoot ) ifcSayIF( T("acceptF returned (2); bSilent: ")+TF1(bSilent) , flSAY_APPEND | flSAY_LOG ) ;
                    b_pnnSilent.ungrabF( tinP ) ;
                    }
                        }
                            break ;
                            LOGrAW3( "peer is on the silence list [nnPeer]: " , nnPeer , "\r\n" ) ;
                            bSilent = 1 ;
                        {
                        if( nnPeer == pnnSilent[ off ] )
                    {
                    for( countT off = 0 ; off < cnnSilent ; off ++ )
                    b_pnnSilent.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    ZE( boolT , bSilent ) ;
    
                    //if( 0x401043a == processGlobal1I.idAdamRoot ) ifcSayIF( T("acceptF returned (1); nnPeer: ")+T(nnPeer)+T("; bRefuse: ")+TF1(bRefuse) , flSAY_APPEND | flSAY_LOG ) ;
                    ___( pso ) ;
                    TELL( "server: a client has connected" )
                    sol.acceptF( tinP , pso , countTC() , nnPeer , bRefuse ) ; //IF ALL SESSIONS END WHILE BLOCKED HERE, WILL STILL REFUSE WO SESSION; THIS CAN BE FIXED BY FRESHING bRefuse AT END OF EACH SESSION THREAD IN DONEtMsERVER
                    TELL( "server: waiting for a client to connect" )
                    nicNameC nnPeer ;

                    }
                        LOGrAW( tSay ) ;
                        TN( tSay , "" ) ; tSay = TT(timeN1,timeN2)+T("| ifcDrivenServerF/too many sessions, so will refuse the next connection attempt\r\n") ;
                        osTimeNowF( tinP , timeN1 , timeN2 ) ;
                        ZE( sCountT , timeN2 ) ;
                        ZE( countT  , timeN1 ) ;
                    {
                    if( bRefuse )
                    boolT bRefuse = info2P.cSessionMax <= cSession ;
                    ZE( socketC* , pso ) ;
                    TELL( "server: beginning loop" )
                {
                while( !info1P.bQuit && !POOP )
                ZE( countT , cRefused ) ;
                ZE( countT , cAccepted ) ;
    
                LOGrAW3( "listener socket has been bound to port [idPort]: " , info1P.idPort , "\r\n" ) ;
                }   
                    info1P.sgnIdPortReplaced.giveF( tinP ) ;
                    sol.listenF( tinP ) ;
                    info1P.idPort = sol.bindF( tinP , info2P.idPortHint ) ;
                {
                if( !info1P.bQuit )

                if( info2P.psttName ) sol.nameF( tinP , info2P.psttName ) ;
                socketC sol( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_null , &info1P.time1idleTimeoutRead , &info1P.time1idleTimeoutWrite ) ;
                TELL( "server: constructing listener socket" )
                SCOOPS
            {
            while( !info1P.bQuit )
            threadC th( tinP , *this , TAG( TAGiDnULL ) , tmLoadSilentF , cArg_tmLoadSilent , flTHREADlAUNCH_SHOWpONY ) ;
            TELL( "server: launching thread tmLoadSilentF" )

            countT cArg_tmLoadSilent = (countT)pc8tp ;
            pc8tp->c3 = (countT)&cnnSilent ;
            pc8tp->c2 = (countT)&pnnSilent ;
            pc8tp->c1 = (countT)&b_pnnSilent ;
        {
        if( pc8tp )
        newF( tinP , LF , pc8tp ) ; ___( pc8tp ) ;
        ZE( count8S* , pc8tp ) ;

        ZE( countT    , cnnSilent ) ;
        ZE( nicNameC* , pnnSilent ) ;
        batonC b_pnnSilent( tinP , TAG( TAGiDnULL ) ) ;
        TELL( "server: continuing to set up" )
        //DUPLICATE CODE: 1030168 2540104

        }
            //A:  }
            //A:      if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->ungrabF( tinP ) ;
            //A:      if( info2P.stateBeginF ) (*info2P.stateBeginF)( tinP , *this , *info1P.ppbdVarying , info2P.cbdVarying , info2P.cArg ) ;
            //A:      info1P.ppbdVarying = (byteT**)&pState->pbdVarying ; //COMPILERbUG: WATCOM BARFS WITHOUT THE CAST
            //A:      if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->grabF( tinP , TAG( TAGiDnULL ) ) ;
            //A:  {
            //A:  if( pState )
            //A:  pState = new( 0 , tinP , LF ) stateC( tinP , *this , info1P.bHandedOff , 0 , info2P.cbdVarying , translateStateDrivenServerF , info2P.cArg , info2P.psttSuffix ) ; ___( pState ) ;
            //A:  tinP.pAdamGlobal1->pTranslateStateCallerCBF = info2P.translateStateF ;
            //A:  TELL( "server: constructing state" )
            //A: 20141130@1135: COMMENTED OUT AS PART OF ELIMINATION OF stateC
        {
        if( info2P.bState )
        //A: ZE( stateC* , pState ) ;
        ZE( countT , idSessionLath ) ;

        switchC sw_cSessionWithPeer( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , lever_nnPeer ) ;
        nicNameC lever_nnPeer ;
    
        switchC sw_pso( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , lever_idSession ) ;
        ZE( countT , lever_idSession ) ;

        batonC b_lever_idSession( tinP , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_NOTjEALOUS ) ; //20190730@1433: ADDED flBATONc_NOTjEALOUS
        ZE( countT , cSession ) ;
    
        if( !info2P.cSessionMax ) info2P.cSessionMax = CsESSIONmAXdFLTiFCdRIVENsERVER ;

        sessionsC& sessions = info2P.pSessions ? *info2P.pSessions : *(sessionsC*)pbSessions ;

        }
            bDeleteSessions = 1 ;
            new( 0 , tinP , pbSessions , sizeof pbSessions ) sessionsC( tinP , *this , TAG( TAGiDnULL ) ) ;
        {
        if( !info2P.pSessions )
        ZE( boolT , bDeleteSessions ) ;
        byteT pbSessions[ sizeof( sessionsC ) ] ;
        TELL( "server: setting up" )
    {
    IFsCRATCH
    _INoLD_

    }
        if( POOP ) return ;
        __( !info2P.bState && !!info2P.psttSuffix ) ;
        __( !info2P.bState && !!info2P.translateStateF ) ;
        __( !info2P.bState && info2P.cbdVarying ) ;
        __(  info2P.bState && tinP.pAdamGlobal1->_etherC_.cInServer ++ ) ;
        __( info1P.idPort ) ;
        __( !info1P.tmF ) ;
        __( info1P.ppbdVarying && !!*info1P.ppbdVarying ) ;
        __( F(flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) ;
        __( F(flagsMode) & flTHIRDmODE_QUITTER ) ;

        __( !( F(tinP.flagsThreadMode2) & flTHREADmODE2_ADAMmAINtHREAD ) && !( F(flagsMode) & flTHIRDmODE_TINoWNER ) ) ; // THESE 2 CHECKS ENSURE etThread IS BEING USED
        __(    F(tinP.flagsThreadMode2) & flTHREADmODE2_ADAMmAINtHREAD   &&    F(flagsMode) & flTHIRDmODE_TINoWNER   ) ; // THESE 2 CHECKS ENSURE etThread IS BEING USED (THIS LINE WILL DETECT THE USE OF etPrimeF() BUT WILL FAIL TO DETECT THE USE OF AN etherC OBJECT OTHER THAN ether AND etThread ON THREAD 1)

        if( POOP ) return ;
    {
    IFbEcAREFUL

    SCOOP
{
/*1*/voidT etherC::ifcDrivenServerF( tinS& tinP , serverInfo1S& info1P , serverInfo2S& info2P )/*1*/

/**/
*/
   use multiple concurrent sessions whenever possible
    let transaction failure data be captured, i.e. do not specify flTHIRDmODE_IMPOTENCEeXPECTED
    if the transaction fails, discard all uncommitted results, reconnect, and retry the connection at least 01 times, sleeping at least 04 tucks between each try
    do not commit results to permanent storage until the transaction has completed
   treat the session as a transaction
   retry connection establishment forever, or at least 01 times
  clients
  client
    the old instance continues to work until all of its client sessions have ended
    in this scenario, when a new instance is hired, it immediately becomes the listener for the hardcoded port
    this will allow sessions started with an old instance to coexist with a new instance that has taken over service of the hardcoded port
   if a hardcoded port is being served, use TASKdRIVENsERVERnEWsOCKET to switch each session to a new socket (bound to a dynamically allocated port)
   on asynch impotence, cancel all current sessions immediately by specifying time1graceP = 0
  server
 recommended protocol
  if not 0 then is called immediately before stateC object is destroyed
  normally is 0
  can be 0
 stateEndFP
  if not 0 then is called immediately after stateC object is constructed
  normally is 0
  can be 0
 stateBeginFP
   example: T("6a40104")
  used to give a distinct name so that multiple instances of the calling adam can coexist
  normally should be 0
  suffix for the state backing image
 psttSuffixP
   see pbdVaryingP for a description of how the caller must access its state information
  it is illegal for the definition of translateStateFP to store its pbToVaryingP parameter for later use by the caller
  can be 0
 translateStateFP
 cbdVaryingP
  only wo instance of me with bStateP can be called per process
  if 0 then the remaining parameters must default
  if not 0 then i will construct a stateC object
  can be 0
  defaults to 1
 bStateP
  when asynchronous impotence occurs, and for a short time afterward until my replacement starts, an attempted connection might fail or might be accepted and then canceled
  the new server, if any, is not told to start until all connections are gone
  this value, if not -1, is floored before use to the greatest nonupper multiple of TUCK * 04
  else i wait time1graceP and then abort any connections that still exist
  if -1 then i wait forever for client connections to close on their own
  can be 0
  time after asynchronous impotence is detected before all client connections are aborted
 time1graceP
  i do not look at the value of cArgP
  passed to tmFP and to translateStateFP
  can be 0
 cArgP
  if 0 then connections will be refused (closed immediately after acceptance) if there are CsESSIONmAXdFLTiFCdRIVENsERVER sessions
  can be 0
 cSessionMaxP
  if 0 then a port will be assigned
  can be 0
 idPortHintP
  will be reset to 0 when i stop listening
  will be revised each time, if any, that the socket is replaced
  will be set to the idPort assigned, which is guaranteed to initially be idPortHintP if the latter is not 0
  must be 0
 idPortP
  must be defined using the TASKdRIVENsERVER symbol
  must conform to the current argument requirements (see adam.0140104 or another adam class that uses me)
  must not be 0
 tmFP
  is not given until immediately after a socket bound to the new idPort is set to listening mode
  given each time that the value of idPortP changes, including its initial assignment and its final reset to 0
 sgnIdPortReplacedP
  see stateC::stateC
 bHandedOffP
 pBat_pbdVaryingP
   in other words, during termination a client session can continue to be served, but it must be "crippled" to prevent transactions that modify state
   if 0 then the current process must not do anything that implies a change in the state of its adam class
   0 indicates that the current process no longer "owns" the state of its adam class
  the protocol for accessing state is to grab the baton, test whether pbdVaryingP is 0, if not 0 access pbdVaryingP, and ungrab the baton
    just before state is frozen, b_pbdVaryingP is grabbed and pbdVaryingP is reset to 0
    during termination, state is frozen, handed off, and saved
   during termination, pbStateP will be 0 and the caller must not attempt to access its state information
   normally pbdVaryingP will be nonze and will point to cbdVaryingP bytes of state that the caller can use to record its current state
  during the execution of a tmFP thread, can be either 0 or nonze
  must be 0
 pbdVaryingP
 tinP
arguments
  thread 2 serves a private chat port, so that the calling adam can accept chat connections to receive commands and report results
  main thread serves port X, which is the primary duty of the calling adam
 example
before calling me on the main thread, launch other threads that call me with bStateP false, to serve ancillary ports
call me on the main thread, with bStateP true, to serve a port
i do not return control to the calling thread until all sessions have ended
provide me with a task definition and i will use it to serve the specified port
\<A HREF=\"5.1030168.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$ifcDrivenServerF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

