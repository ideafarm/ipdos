
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        }
            delF( tinP , pbOut ) ;
            if( !bSent ) boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/city/data/out/dat.")+TF3(flags1,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".")+TF3(idCitizenHirerI,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".")+TF3(time2,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".")+TF3(time1,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".")+TF3(idComputer,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".")+TF3(tinP.monitor.idThread,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) , pbOut , cbOut ) ;
    
            }
                }
                    delF( tinP , psttnu ) ;
                    tinP.pEtScratch->etherGetLogF( tinP , psttnu ) ;
                    ZE( strokeS* , psttnu ) ;
                    POOPR
                {
                if( POOP )
                bSent = !POOP ;
    
                }
                    sOut.writeMsgF( tinP , "!amDry" ) ;
                    sOut.writeMsgF( tinP , pbOut , cbOut ) ;
    
                    sOut.connectF( tinP , ifcPORToLD1rIVERrESERVED ) ;
                    socketC sOut( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                {
                SCOOPS
            {
            IFsCRATCH
            ZE( boolT , bSent ) ;
    
            //else          { boxPutUniqueF( tinP , psttu , tFile+T(".uid.unk.uid" )                                             , pbOut , cbOut ) ; ___( psttu ) ; }
            //if( psttUid ) { boxPutUniqueF( tinP , psttu , tFile+T(".uid.")+T(psttUid)+T(".uid") , pbOut , cbOut ) ; ___( psttu ) ; }
            //U: REPLACE ALL Uid CODE WITH CODE THAT USES idCitizenHirerI
    
            //delF( tinP , postUid ) ;
            //}
            //    memCopyF( tinP , pbOut + 0xb * sizeof(countT) + cbr + costUid , "\"" , 2 ) ;
            //    memCopyF( tinP , pbOut + 0xb * sizeof(countT) + cbr + costUid + 1 , pbP , cbd ) ;
            //    memCopyF( tinP , pbOut + 0xb * sizeof(countT) + cbr + costUid , " \"" , 2 ) ;
            //{
            //if( cbd )
            //memCopyF( tinP , pbOut + 0xb * sizeof(countT) + cbr , postUid                 , costUid        ) ;
            // ENABLE THE COMMENTED OUT CODE (AND EDIT) IN ORDER TO INCLUDE THE UID IN THE DATA
    
            if( cbd ) memCopyF( tinP , pbOut + 0xb * sizeof(countT) + processGlobal1I.cb_nicNameC_ + cbr , pbP                         , cbd              ) ;
                      memCopyF( tinP , pbOut + 0xb * sizeof(countT) + processGlobal1I.cb_nicNameC_       , (byteT*)pcResourceId        , cbr              ) ;
                      memCopyF( tinP , pbOut + 0xb * sizeof(countT)                          , (byteT*)&nicName            , processGlobal1I.cb_nicNameC_      ) ;
                      memCopyF( tinP , pbOut + 0xa * sizeof(countT)                          , (byteT*)&processGlobal1I.idAdamRoot            , sizeof(countT)   ) ; // a
                      memCopyF( tinP , pbOut +   9 * sizeof(countT)                          , (byteT*)&idComputer         , sizeof(countT)   ) ; // 9
                      memCopyF( tinP , pbOut +   8 * sizeof(countT)                          , (byteT*)&flags2             , sizeof(countT)   ) ; // 8
                      memCopyF( tinP , pbOut +   7 * sizeof(countT)                          , (byteT*)&flags1             , sizeof(countT)   ) ; // 8
                      memCopyF( tinP , pbOut +   6 * sizeof(countT)                          , (byteT*)&amountP            , sizeof(countT)   ) ; // 7
                      memCopyF( tinP , pbOut +   5 * sizeof(countT)                          , (byteT*)&cbd                , sizeof(countT)   ) ; // 6
                      memCopyF( tinP , pbOut +   3 * sizeof(countT)                          , (byteT*)&time2              , sizeof(countT)   ) ; // 4
                      memCopyF( tinP , pbOut +   2 * sizeof(countT)                          , (byteT*)&time1              , sizeof(countT)   ) ; // 3
                      memCopyF( tinP , pbOut +   1 * sizeof(countT)                          , (byteT*)&idCitizenHirerI     , sizeof(countT)   ) ; // 2
                      memCopyF( tinP , pbOut                                                 , (byteT*)&cbOutNet           , sizeof(countT)   ) ; // 1
            // KEEP THIS IN SYNC WITH headerS IN 3f30104
    
            const countT cbOutNet = cbOut - sizeof( countT ) ;
            newF( tinP , LF , pbOut , cbOut ) ; ___( pbOut ) ;
            countT cbOut = 0xb * sizeof( countT ) + processGlobal1I.cb_nicNameC_ + cbr + cbd ;
            countT cbr = ( strBodyLengthF( tinP , pcResourceId ) + 1 ) * sizeof( countT ) ; // EXCLUDING THE idFileImmutable OF THE OWNER OF THIS etherC OBJECT
            third.osTimeNowF( tinP , time1 , time2 ) ;
            ZE( sCountT , time2 ) ;
            ZE( countT , time1 ) ;
            }
                if( POOP ) POOPR
                nicName = socketC::nicNameIF( tinP , *tinP.pEtScratch ) ;
                SCOOPS
            {
            IFsCRATCH
            nicNameC nicName ;
            countT idComputer = diskIdF( tinP , T("///c") ) ;
            const countT idCitizenHirerI = ether_idCitizenHirerI_F( tinP ) ;
    
            //strMakeF( tinP , postUid , psttUid ) ;
            //ZE( countT , costUid ) ;
            //ZE( osTextT* , postUid ) ;
            //if( !psttUid ) strMakeF( tinP , psttUid , T("") ) ;
    
            ZE( byteT* , pbOut ) ;
        {
    
        //U:#endif
        if( bKeep )
        }
            // bKeep |= F(flags2P) & flDATUM2_OS2                    ;
            // bKeep |= F(flags2P) & flDATUM2_WINDOWS95              ;
            // bKeep |= F(flags2P) & flDATUM2_WINDOWS98              ;
            // bKeep |= F(flags2P) & flDATUM2_WINDOWSnT              ;
            // bKeep |= F(flags2P) & flDATUM2_LINUX                  ;
            // bKeep |= F(flags1P) & flDATUM1_ADAMlIFEtIME            ;
            // bKeep |= F(flags2P) & flDATUM2_strokeS                ;
            // bKeep |= F(flags2P) & flDATUM2_ScOUNT                 ;
            // bKeep |= F(flags2P) & flDATUM2_osTextT                ;
            // bKeep |= F(flags2P) & flDATUM2_NULLtERMINATED         ;
            // bKeep |= F(flags2P) & flDATUM2_countT                 ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStIMECARD           ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStIMER              ;
            // bKeep |= F(flags1P) & flDATUM1_CLASSwORK               ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStRACElEVEL2        ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStRACElEVEL1        ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStRACEaLWAYSfIREdLL ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStRACEaLWAYShIREdLL ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStRACEaLWAYSfIRE    ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStRACEaLWAYShIRE    ;
            // bKeep |= F(flags1P) & flDATUM1_CLASStACHOMETER         ;
            // bKeep |= F(flags1P) & flDATUM1_CLASSqUESTION           ;
            // bKeep |= F(flags1P) & flDATUM1_CLASSqUERY              ;
            // bKeep |= F(flags1P) & flDATUM1_CLASSjOURNAL            ;
               bKeep |= F(flags1P) & flDATUM1_CLASSeXCEPTIONjOURNAL   ;
               bKeep |= F(flags1P) & flDATUM1_CLASSeXCEPTIONiMPOTENCE ;
            // bKeep |= F(flags1P) & flDATUM1_CLASScOMMENToRCHID      ;
            // bKeep |= F(flags1P) & flDATUM1_CLASScOMMENToNION       ;
        {
        ZE( boolT , bKeep ) ;
        //U:#if defined( NEVERdEFINED )
    
        }
            default  : __1
            case '5' : { flags2 |= flDATUM2_WINDOWS95 ; break ; }
            case 'w' : { flags2 |= flDATUM2_WINDOWSnT ; break ; }
            case 'o' : { flags2 |= flDATUM2_OS2       ; break ; }
        {
        switch( third.osIdIF( tinP ) )
    
        flagsT flags2 = flags2P ;
        flagsT flags1 = flags1P ;
        if( pbP && !cbd && F(flags2P) & flDATUM2_osTextT ) cbd = strBodyLengthF( tinP , pbP ) + 1 ;
        countT cbd = cbP ;
    
        else                pcResourceId = &ze ;
        if( pcResourceIdP ) pcResourceId = pcResourceIdP ;
        ZE( const countT* , pcResourceId ) ;
        ZE( countT , ze ) ;
    {
    if( tinP.pEtScratch )

    _INoLD_

    }
        if( POOP ) return ;
        FV( flDATUM2 , flags2P ) ;
        FV( flDATUM1 , flags1P ) ;
        //__( !POOP && processGlobal1I.cb_nicNameC_ - 4 * sizeof( countT ) ) ;
        __( cbP && !pbP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::ifcDatumF( tinS& tinP , const flagsT flags1P , const flagsT flags2P , countT amountP , const countT* const pcResourceIdP , const byteT* const pbP , const countT cbP )/*1*/

/**/
*/
 cbP
 pbP
  do not specify an adam class within this, since the adam class is automatically prepended
   where pcPart is declared and initialized as: countT pcPart[] = { 1 , 3 , 5 , 7 , 0 } ;
  example: pcPart
  this is a null terminated string of countT objects
 pcResourceIdP
 amountP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010049.flDATUM1!||
 flagsP
arguments
  \<A HREF=\"5.7310104.1.1.0.html\"\>7310104:  WAKEsHOW( "example.simplest.func.103008d.etherC.ifcDatumF" )\</A\>
 simplest
examples
\<A HREF=\"5.103008d.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$ifcDatumF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

