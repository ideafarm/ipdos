
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmNodeOldChatRepliesF )
}
    }
        if( POOP ) POOPR
        TELL( "tmNodeOldChatRepliesF: cleaning up" )
        if( bWoth ) sgnUpTested.giveF( tinP ) ;
        }
            if( !sReply ) break ;
    
            soDn.writeF( tinP , sWrite ) ;
            etThread.traceF( tinP , T("writing sWrite (sNull or sReply)") ) ;
            TELL( "writing to below the reply soul read from above" )
            soulC& sWrite = soUp.etherF( tinP ) ? sNull : sReply ;
            soulC sNull( tinP , TAG( TAGiDnULL ) ) ;
    
            }
                break ;
                soDn.stopWaitingF( tinP ) ;
                }
                    thirdC::dosTellMonitorIF( tinP , tellC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEtELLsYS_LOG , ostoe , ostoe.costF() + 1 ) , ifcIDbOOKStELL_SYS ) ;
                    OStEXTV( ostoe , "!tinS tmNodeOldChatRepliesF: canceling soDn because soUp is impotent" )
                {
                //etText.strokeF( tinP , T("RcHAT/")+TF1(idRelay)+T("/tmNodeOldChatRepliesF/telling soDn to stop waiting for an order\r\n") ) ;
                POOPR
            {
            if( POOP )
            }
                sgnUpTested.giveF( tinP ) ;
                bWoth = 0 ;
            {
            if( bWoth )
    
            //else                      etText.strokeF( tinP , T("RcHAT/")+TF1(idRelay)+T("/tmNodeOldChatRepliesF/read a nonnull sReply from up\r\n") ) ;
            //else if( !sReply )        etText.strokeF( tinP , T("RcHAT/")+TF1(idRelay)+T("/tmNodeOldChatRepliesF/read a null sReply from up\r\n") ) ;
            //if( soUp.etherF( tinP ) ) etText.strokeF( tinP , T("RcHAT/")+TF1(idRelay)+T("/tmNodeOldChatRepliesF/could not read sReply from up\r\n") ) ;
    
            TELL( "handling the soulC read from above" )
            soUp.readF( tinP , sReply ) ;
            TELL( "reading from above a reply soulC" )
            soulC sReply( tinP , TAG( TAGiDnULL ) ) ;
            idTray ++ ;
        {
        while( !POOP && !etThread )
        ZE( countT , idTray ) ;
        boolT bWoth = 1 ;
    
        soUp.etherF( tinP , *tinP.pEtScratch ) ;
        soDn.etherF( tinP , *tinP.pEtScratch ) ;
        etherC& etText = etherC::etTextIF( tinP ) ;
        SCOOPS
    {
    IFsCRATCH

    countT   idRelay     =            pTaskP->c4 ;
    signC&   sgnUpTested =   *(signC*)pTaskP->c3 ;
    socketC& soUp        = *(socketC*)pTaskP->c2 ;
    socketC& soDn        = *(socketC*)pTaskP->c1 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
/*1*/TASK( tmNodeOldChatRepliesF )/*1*/
/**/
*/
\<A HREF=\"5.0b00015.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$tmNodeOldChatRepliesF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmNodePopClientF )
}
    }
        POOPR
        etThread.traceF( tinP , tWork+T(": probable coding error: still impotent 1") ) ;
    {
    if( POOP )

    }
        TELL( "tmNodePopClientF: cleaning up" )
    
        DEL( pso ) ;
        }
            POOPR
            etThread.traceF( tinP , tWork+T(": probable coding error: still impotent 2") ) ;
        {
        if( POOP )

        }
            }
                DEL( psBag ) ;
                TELL( "deleting soul" )
                }
                    }
                        }
                            break ;
                            etThread( tinP , psBag ) ;
                            bMoreToPop = 1 ;
                            idptServer = 0 ;
                            DEL( pso ) ;
                            }
                                psBag = 0 ;
                                stPop.insertF( tinP , (countT)psBag , ifcSTACKtYPE_PTR_soulC , 1 ) ;
                            {
                            if( !ether && !bQuitP )
                            etThread.traceF( tinP , tWork+T(": could not write bag to correct server") ) ;
                            POOPRqUIET
                        {
                        if( POOP )
                        TELL( "reading ok-" )
                        VERIFYrELAY( *pso ) ;
                        TELL( "reading ok+ 5" )
                        pso->writeF( tinP , *psBag ) ;
                        TELL( "writing bang" )
                        //etThread.traceF( tinP , tWork+T(": writing [idType]:    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( idType != ifcOLDiDtYPEbAG_CLIENTnULL )
                    countT idType = psBag->cFieldF( tinP , ifcIDfIELDbAG_IDtYPE ) ;
                {
                if( pso && !ether && !bQuitP && *psBag >= 4 ) //CODEsYNC df40104 df40104
                //P: CLIENTS THAT ARE QUITTING SILENTLY DISCARD ITEMS THAT THEY ARE SUPPOSE TO POP
                stPop >> psBag ;
                ZE( soulC* , psBag ) ;
                TELL( "pulling from stPop" )
            {
            while( stPop )
            //etThread.traceF( tinP , TF2(idWorkP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": writing from stPop [stPop]:    ")+TF2(stPop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            
            }
                }
                    nodeOldC::idptSelectPeerIF( tinP , idptServerCorrect , stIdptOpenP , idptP , stIdptGossipP , idWorkP , idWorkP == OLDiDtYPErELAYpOPcLIENTwORK_IMPLODE ? flSELECTpEER_TRACE : flSELECTpEER_null ) ;
                    if( idWorkP == OLDiDtYPErELAYpOPcLIENTwORK_IMPLODE ) etThread.traceF( tinP , tWork+T(": refreshing idptServerCorrect") ) ;
                {
                if( !ether && !bQuitP )
                idptServerCorrect = 0 ;
                }
                    }
                        etThread.traceF( tinP , tWork+T(": could not say hello to correct server") ) ;
                        idptServer = 0 ;
                        DEL( pso ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    TELL( "reading ok-" )
                    VERIFYrELAY( *pso ) ;
                    TELL( "reading ok+ 3" )
                    pso->writeF( tinP , sBagHello ) ;
                    //etThread.traceF( tinP , tWork+T(": writing sBagHello to correct server ") ) ;
    
                    sBagHello << idWorkP ;
                    nodeOldC::hdrBagIF( tinP , sBagHello , idptP , idSerialLathHeaderP , flOLDrELAYpOP_null , ifcOLDiDtYPEbAG_CLIENTpOPhELLO ) ;
                    soulC sBagHello( tinP , TAG( TAGiDnULL ) ) ;
                    TELL( "writing hello" )

                    etThread.traceF( tinP , tWork+T(": connected aok to correct server ")+tWork+T(" [idptServer port, nn]:    ")+TF2((countT)idptServer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((nicNameC&)idptServer) ) ;
                {
                else
                }
                    idptServer = 0 ;
                    etThread.traceF( tinP , tWork+T(": could not connect to correct server ")+tWork+T(" [idptServer port, nn]:    ")+TF2((countT)idptServer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((nicNameC&)idptServer) ) ;
                    DEL( pso ) ;
                    POOPRqUIET
                {
                else if( POOP )
                }
                    idptServer = 0 ;
                    }
                        etThread.traceF( tinP , tWork+T(": quitting, so am not going to connect to correct server") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    DEL( pso ) ;
                    //P: CLIENTS THAT ARE QUITTING ARE RUDE WHEN CLOSING CONNECTION
                {
                if( ether || bQuitP )
                pso->connectF( tinP , idptServer , (nicNameC&)idptServer ) ;
                TELL( "connecting" )
                idptServer = idptServerCorrect ;
                pso = new( 0 , tinP , LF ) socketC( tinP , *tinP.pEtScratch , TAG( TAGiDnULL )/*U:: , 0 , flSOCKETc_TOPsECRET*/ ) ; ___( pso ) ;
                TELL( "looping to write hello" )
            {
            while( !ether && !bQuitP && !pso && idptServerCorrect )
            
            }
                idptServer = 0 ;
                DEL( pso ) ;
                }
                    etThread.traceF( tinP , tWork+T(": could not say bye to stale (incorrect) server") ) ;
                    POOPRqUIET
                {
                if( POOP )
                TELL( "reading ok-" )
                VERIFYrELAY( *pso ) ;
                TELL( "reading ok+ 2" )
                }
                    }
                        DEL( psBag ) ;
                        pso->writeF( tinP , *psBag ) ;
                        //etThread.traceF( tinP , tWork+T(": writing *psBag") ) ;
                        nodeOldC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flOLDrELAYpOP_null , ifcOLDiDtYPEbAG_CLIENTpOPbYE ) ;
                    {
                    if( psBag )
                    soulC* psBag = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBag ) ;
                {
                TELL( "writing bye" )
                //P: CLIENTS THAT ARE NOT QUITTING ARE POLITE WHEN CLOSING CONNECTION
            {
            if( pso && idptServer && idptServer != idptServerCorrect && !bQuitP && !ether )
    
            nodeOldC::idptSelectPeerIF( tinP , idptServerCorrect , stIdptOpenP , idptP , stIdptGossipP , idWorkP , idWorkP == OLDiDtYPErELAYpOPcLIENTwORK_IMPLODE ? flSELECTpEER_TRACE : flSELECTpEER_null ) ;
            portTimeC idptServerCorrect ;
            TELL( "calculating portTimeCorrect" )

            }
                //etThread.traceF( tinP , tWork+T(": waited  for a push") ) ;
                stPop.waitF( tinP ) ;
                //etThread.traceF( tinP , tWork+T(": waiting for a push") ) ;
            {    
            else
            else if( bMoreToPop ) bMoreToPop = 0 ;
            if( bWoth )           bWoth = 0 ;
            TELL( " waiting for a push onto stPop" )
        {
        while( !ether && !bQuitP )
        ZE( boolT , bMoreToPop ) ;
        portTimeC idptServer ;
        ZE( socketC* , pso ) ;
        boolT bWoth = 1 ;
        soulC sInOk( tinP , TAG( TAGiDnULL ) ) ;
    
        SCOOPS
    {
    IFsCRATCH

    etThread.traceF( tinP , tWork+T(": setting up") ) ;

    }
        default                                : { BLAMMOiD( idWorkP | BM_HIGH ) ; break ; }
        case OLDiDtYPErELAYpOPcLIENTwORK_RIGHT    : { tWork = T("right")            ; break ; }
        case OLDiDtYPErELAYpOPcLIENTwORK_LEFT     : { tWork = T("left")             ; break ; }
        case OLDiDtYPErELAYpOPcLIENTwORK_EXPLODE2 : { tWork = T("up2")              ; break ; }
        case OLDiDtYPErELAYpOPcLIENTwORK_EXPLODE1 : { tWork = T("up1")              ; break ; }
        case OLDiDtYPErELAYpOPcLIENTwORK_IMPLODE  : { tWork = T("down")             ; break ; }
    {
    switch( idWorkP )
    TN( tWork , "" ) ;

    ;
                    : *pStPop4P
                    ? *pStPop3P
                : idWorkP == OLDiDtYPErELAYpOPcLIENTwORK_LEFT
                ? *pStPop2P
            : idWorkP == OLDiDtYPErELAYpOPcLIENTwORK_EXPLODE2
            ? *pStPop1P
        : idWorkP == OLDiDtYPErELAYpOPcLIENTwORK_EXPLODE1
        ? *pStPop0P
    stackC& stPop = idWorkP == OLDiDtYPErELAYpOPcLIENTwORK_IMPLODE
    TELL( "setting up" )

    countT idWorkP = pTaskP->c4 ;
    RELAYiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
/*1*/TASK( tmNodePopClientF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmNodeServerCatchBagF )
}
    if( !bSaidBye && !ether && !bQuitP ) ;
    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": thread ending\r\n" ) ; //U::

    if( POOP ) { BLAMMO ; } //U:: TO FIND A BUG

    }
        DEL( psBag ) ;

        }
            nodeOldC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
            idptPopClient >> *psBag ;
            nodeOldC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flOLDrELAYpOP_DOWN , ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP ) ;
        {
        if( bPop )

        UNGRABrELAYlISTS
        }
            else bPop = 1 ;
            }
                nodeOldC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptPopClient , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
            {
            if( pnRoot && *pnRoot == idptP )
            //P: SERVER WILL GOSSIP IF A POP CLIENT IMPLODING DOWNWARD TO IT DIED WITHOUT SAYING GOODBYE
        {
        if( idptPopClient && !bSaidBye && !bQuitP && idWork == OLDiDtYPErELAYpOPcLIENTwORK_IMPLODE ) //THIS CODE WILL NEVER GOSSIP ABOUT THE ROOT
        portTimeC* pnRoot = stIdptOpenP ? (portTimeC*)&stIdptOpenP[ 1 ] : 0 ;
        GRABrELAYlISTS
        ZE( boolT , bPop ) ;
    {
    if( psBag )
    soulC* psBag = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBag ) ;

    }
        stIdptPopClientP.ungrabF( tinP ) ;
        if( stIdptPopClientP( (byteT*)&idptPopClient , subtractIdPortTimesF , - 1 ) ) stIdptPopClientP.extractF( 0 , tinP ) ;
        stIdptPopClientP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( bPopClient )
    TELL( "tmNodeServerCatchBagF: cleaning up" )

    }
        DEL( psoP ) ;
        stPsoServerP.ungrabF( tinP ) ;
        if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
        stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( psoP )
    TELL( "deleting socket" )
    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": exited loop; deleting socket\r\n" ) ; //U::

    }
        }
            }
                break ;
                }
                    DEL( psoP ) ;
                    stPsoServerP.ungrabF( tinP ) ;
                    if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
                    stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( psoP )
                if( tTraceFail.csF( tinP ) ) etThread.traceF( tinP , tTraceFail ) ;
            {
            if( bFail )

            }
                }
                    }
                        }
                            tTraceFail = T("could not write sOk") ;
                            bFail = 1 ;
                            POOPRqUIET
                        {
                        if( POOP )
        
                        psoP->writeF( tinP , sOk ) ;
                        //P: SERVER NORMALLY REPLIES TO EACH COMMAND BY WRITING AN sOk
                        SCOOPS
                    {
                    IFsCRATCH
                    //etThread.traceF( tinP , T("writing sOk") ) ;
                    TELL( "writing ok" )
                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 1 writing ok\r\n" ) ; //U::
            
                    }
                        }
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 3 after doing\r\n" ) ; //U::
                            }
                                //etThread.traceF( tinP , T("called doWrapLocallyIfIF") ) ;
                                nodeOldC::doWrapLocallyIfIF( tinP , etThread , RELAYiNFOaRGS , pbsWrap , idptOrigin /*U::, 2*/ ) ;  //U:: 20210209@2012: COMMENTED OUT ", 2" WITHOUT ANALYSIS TO GET DUT TO WORK
                            {
                            if( pbsWrap )
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 4 doing\r\n" ) ; //U::
                            //etThread.traceF( tinP , T("called popIF") ) ;

                            nodeOldC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , sBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                            //etThread.traceF( tinP , T("calling popIF") ) ;
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 5 popping\r\n" ) ; //U::
            
                            }
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP\r\n" ) ; //U::
                                    TELL( "ifcOLDiDtYPEbAG_WRAP-" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP done\r\n" ) ; //U::
                                    if( pbsWrap ) nodeOldC::doWrapLocallyIfIF( tinP , etThread , RELAYiNFOaRGS , pbsWrap , idptOrigin , 1 ) ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP doing\r\n" ) ; //U::
        
                                    //if( pbsWrap ) { CONoUTrAW( "w" ) ; }
        
                                    }
                                        pbsWrap = sBag.pbFieldF( tinP , idTypesWrap , flagssWrap , cbsWrap , ifcIDfIELDbAG_WRAP ) ;
                                        ZE( countT , cbsWrap ) ;
                                        ZE( flagsT , flagssWrap ) ;
                                        ZE( countT , idTypesWrap ) ;
                                    {
        
                                    TELL( "ifcOLDiDtYPEbAG_WRAP+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP\r\n" ) ; //U::
                                    //etThread.traceF( tinP , T("ifcOLDiDtYPEbAG_WRAP") ) ;
                                {
                                case ifcOLDiDtYPEbAG_WRAP :
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPpING\r\n" ) ; //U::
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPpING-" )
            
                                    }
                                        DEL( psBag ) ;
                                        nodeOldC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                                        nodeOldC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flOLDrELAYpOP_DOWN , ifcOLDiDtYPEbAG_CLIENTpOPpONG ) ;
                                    {
                                    if( psBag )
                                    soulC* psBag = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBag ) ;
                                    //P: SERVER RESPONDS TO PING BY IMPLODE POPPING DOWNWARD A "PONG"
            
                                    }
                                        }
                                            DEL( psBag ) ;
                                            nodeOldC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                                            idptP   >> *psBag ;
                                            idptOld >> *psBag ;
                                            nodeOldC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flOLDrELAYpOP_DOWN , ifcOLDiDtYPEbAG_CLIENTpOPuNgOSSIP ) ;
                                        {
                                        if( psBag )
                                        soulC* psBag = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBag ) ;
            
                                        nodeOldC::handleRefreshTimeStampIF( tinP , idptP ) ;
        
                                        idptP.timeStampIfF( tinP , etThread ) ;
                                        idptOld = idptP ;
                                        portTimeC idptOld ;
                                        //P: WHENEVER SELF IS GOSSIPPED IN A PING, THE FALSELY GOSSIPPED SERVER IMPODE POPS DOWNWARD AN "UNGOSSIP" ITEM AFTER RETIMESTAMPING ITSELF
                                    {
                                    if( stIdptGossipP( (byteT*)&idptP , subtractIdPortsF , - 1 ) )
            
                                    }
                                        UNGRABrELAYlISTS
                                        }
                                            nodeOldC::hisListIF( tinP , stIdptOpenP , sBag , stIdptGossipP , idField ) ;
                                            nodeOldC::hisListIF( tinP , stIdptGossipP , sBag , stIdptGossipP , idField ) ;
                                            countT idField = ifcIDfIELDbAG_IDtYPE + 1 ;
                                        {
                                        stIdptGossipP.purgeF( tinP ) ;
                                        stIdptOpenP.purgeF( tinP ) ;
                                        GRABrELAYlISTS
                                        //P: SERVER REPLACES ITS LISTS IFF PING IS RECEIVED FROM ELDER
                                    {
                                    if( idptOrigin && idptOrigin - idptP < 0 )
                                    cLooksForNewPingP = 0 ;
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPpING+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPpING\r\n" ) ; //U::
                                {
                                case ifcOLDiDtYPEbAG_CLIENTpOPpING :
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOP*gOSSIP\r\n" ) ; //U::
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP-" )
                                    UNGRABrELAYlISTS
            
                                    }
                                        inc02AM( cGossipInP ) ;
                                        nodeOldC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                                        }
                                            if( !nodeOldC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idptGossipNew ) ) stIdptOpenP.sinkF( tinP , countTC() , (byteT*)&idptGossipNew , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
            
                                            }
                                                stIdptGossipP.extractF( 0 , tinP ) ;
                                            {
                                            else if( nodeOldC::bListedIF( tinP , stIdptGossipP , stIdptGossipP , idptGossip ) )
                                            }
                                                stIdptGossipP.extractF( 0 , tinP ) ;
                                            {
                                            if( stIdptGossipP( (byteT*)&idptGossip , subtractIdPortsF , - 1 ) )
            
                                            }
                                                stIdptOpenP.extractF( 0 , tinP ) ;
                                            {
                                            else if( nodeOldC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idptGossip ) )
                                            }
                                                stIdptOpenP.extractF( 0 , tinP ) ;
                                            {
                                            if( stIdptOpenP( (byteT*)&idptGossip , subtractIdPortTimesF , (countT)&stIdptGossipP ) )
                                            portTimeC idptGossipNew = portTimeC::fieldF( tinP , sBag , ifcIDfIELDbAG_IDtYPE + 1 + portTimeC::cFieldsF( tinP ) ) ;
                                        {
                                        else
                                        }
                                            stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptOrigin , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
                                            stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptGossip , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
                                            //P: GOSSIP HAS THE SAME EFFECT ON THE RELAY DOING THE GOSSIP AS ON THE VICTIM RELAY
                                        {
                                        if( idType == ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP )
                                        portTimeC idptGossip = portTimeC::fieldF( tinP , sBag , ifcIDfIELDbAG_IDtYPE + 1 ) ;
                                    {
                                    if( pnRoot && *pnRoot == idptP )
                                    //P: A SERVER WILL IGNORE GOSSIP UNLESS IT THINKS THAT IT IS ROOT
                                    portTimeC* pnRoot = stIdptOpenP ? (portTimeC*)&stIdptOpenP[ 1 ] : 0 ;
                                    GRABrELAYlISTS
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOP*gOSSIP\r\n" ) ; //U::
                                {
                                case ifcOLDiDtYPEbAG_CLIENTpOPuNgOSSIP :
                                case ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP :
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPbYE\r\n" ) ; //U::
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPbYE-" )
                                    bSaidBye = 1 ;
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPbYE+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPbYE\r\n" ) ; //U::
                                {
                                case ifcOLDiDtYPEbAG_CLIENTpOPbYE :
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPhELLO\r\n" ) ; //U::
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPhELLO-" )
        
                                    //CONoUTrAW5( "tmNodeServerCatchBagF (idThread,idWork): " , tinP.monitor.idThread , processGlobal3I.mapPopClientWork(idWork) , 0 , "\r\n" ) ;
        
                                    idWork = sBag.cFieldF( tinP , ifcIDfIELDbAG_IDwORK ) ;
                                    stIdptPopClientP.sinkF( tinP , countTC() , (byteT*)&idptPopClient , flSTACKsINK_null , subtractIdPortTimesF , - 1 ) ;
                                    bPopClient = 1 ;
                                    idptPopClient = idptOrigin ;
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPhELLO+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPhELLO\r\n" ) ; //U::
                                {
                                case ifcOLDiDtYPEbAG_CLIENTpOPhELLO :
                            {
                            switch( idType ) //ALL PROCESSING HERE MUST BE FAST; LONG PROCESSING SHOULD BE DONE AFTER POPPING
                            if( POOP ) { BLAMMO ; }
                            ZE( byteT* , pbsWrap ) ;
                            TELL( "local processing" )
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 7 switching on bag type\r\n" ) ; //U::
            
                            }
                                UNGRABrELAYlISTS
                                //P: A SERVER THAT THINKS THAT IT IS ROOT WILL ADD UNKNOWN ORIGIN RELAYS TO ITS LIST
                                }
                                    etThread.traceF( tinP , T("registered origin [cNodes,idptOrigin]:    ")+TF2(stIdptOpenP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(nn4,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    countT nn4 = *(const countT*)(nicNameC&)idptOrigin ;
                                    stIdptOpenP.sinkF( tinP , countTC() , (byteT*)&idptOrigin , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                {
                                if( ideMe == 1 && idptOrigin && !nodeOldC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idptOrigin ) )
                                countT ideMe = stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 8 after grabbing lists\r\n" ) ; //U::
                                GRABrELAYlISTS
                                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 9 grabbing lists\r\n" ) ; //U::
                            {
            
                            swsIdSerialReceivedP.ungrabF( tinP ) ;
                            }
                                //P: EACH SERVER IGNORES DUPLICATES OF UPWARD BOUND ITEMS THAT IT HAS ALREADY PROCESSED
                                }
                                    bAltSwsP = !bAltSwsP ;
                                    ((stackC&)swsId).purgeF( tinP ) ;
                                {
                                if( swsId > 0x100 )
                                THREADmODE1rESTORE
                                swsId.sinkF( tinP , countTC() , idSerial , flSTACKsINK_UNIQUE ) ;
                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                switchStackC& swsId = bAltSwsP ? swsIdSerialReceivedAltP : swsIdSerialReceivedP ;
                                TELL( "registering serial" )
                            {
                            )
                                )
                                    )
                                        idType == ifcOLDiDtYPEbAG_CLIENTpOPuNgOSSIP
                                        idType == ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP   ||
                                        idType == ifcOLDiDtYPEbAG_CLIENTpOPpONG     ||
                                    (
                                    bRoot &&
                                (
                                F(flags) & flOLDrELAYpOP_UP ||
                            (
                            if
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": a registering serial\r\n" ) ; //U::
            
                            UNGRABrELAYlISTS
                            }
                                //etThread.traceF( tinP , T("flipped flags from down to up [flags]:    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                flags |=      flOLDrELAYpOP_UP      ;
                                flags &= ~( F(flOLDrELAYpOP_DOWN) ) ;
                            {
                            )
                                idType != ifcOLDiDtYPEbAG_CLIENTpOPuNgOSSIP
                                idType != ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP    &&
                                idType != ifcOLDiDtYPEbAG_CLIENTpOPpONG      &&
                                bRoot                                     &&
                                F(flags) & flOLDrELAYpOP_DOWN                &&
                            (
                            if
                            //P: A SERVER THAT THINKS THAT IT IS ROOT WILL BANG MOST ITEMS IMPLODED DOWN INTO IT
                            //etThread.traceF( tinP , T("[bRoot]:    ")+TF2(bRoot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            const boolT bRoot = 1 == stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": b inspecting whether i am root\r\n" ) ; //U::
                            GRABrELAYlISTS
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": c.2 grabbing lists before inspecting for being root\r\n" ) ; //U::

                            //}
                            //    }
                            //        etThread.traceF( tinP , T("foreign") ) ;
                            //    {
                            //    if( nn4 != 0x266f9365 )
                            //    //etThread.traceF( tinP , T("[nn4]:    ")+TF2(nn4,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //    countT nn4 = *(const countT*)(nicNameC&)idptOrigin ;
                            //{

                            //etThread.traceF( tinP , T("not fooey already seen [idSerial,flags,itType]:    ")+TF2(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        else
                        }
                            //}
                            //    }
                            //        }
                            //            if( pbsTo && soulC::cFieldsIF( tinP , pbsTo ) ) { CONoUTrAW3( "ignoring directed bag " , idSerial , "\r\n" ) ; }
                            //
                            //            byteT* pbsTo = soulC::pbFieldIF( tinP , idTypesTo , flagssTo , cbsTo , ifcOLDiDfIELDwRAP_TO , pbsWrap ) ;
                            //            ZE( countT , cbsTo ) ;
                            //            ZE( flagsT , flagssTo ) ;
                            //            ZE( countT , idTypesTo ) ;
                            //        {
                            //        if( pbsWrap )
                            //        byteT* pbsWrap = sBag.pbFieldF( tinP , idTypesWrap , flagssWrap , cbsWrap , ifcIDfIELDbAG_WRAP ) ;
                            //        ZE( countT , cbsWrap ) ;
                            //        ZE( flagsT , flagssWrap ) ;
                            //        ZE( countT , idTypesWrap ) ;
                            //    {
                            //    if( idType == ifcOLDiDtYPEbAG_WRAP )
                            //{
                            //FOR DEBUGGING ONLY; MUST BE COMMENTED OUT IN PRODUCTION
        
                            swsIdSerialReceivedP.ungrabF( tinP ) ;
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": c.1 serial already seen\r\n" ) ; //U::
                            //etThread.traceF( tinP , T("already seen [idSerial,flags,itType]:    ")+TF2(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        if( swsIdSerialReceivedP( idSerial ) || swsIdSerialReceivedAltP( idSerial ) )
                        idPortOriginP = idptOrigin ;
                        swsIdSerialReceivedP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        //CONoUTrAW3( "tmCatchBagF " , idCatch , ": d.2 inspecting serial\r\n" ) ; //U::
                    {
                    else
                    }
                        tTraceFail = T("error: null serial") ;
                        bFail = 1 ;
                    {
                    if( !idSerial )
                    TN( tcr , "\r\n" ) ;
                    TELL( "handling soul" )
                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": e inspecting for null serial\r\n" ) ; //U::

                    //etThread.traceF( tinP , T("[idSerial,flags]:    ")+TF2(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            
                    countT   idType     = sBag.cFieldF( tinP , ifcIDfIELDbAG_IDtYPE ) ;
                    flagsT&  flags      = sBag.cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                    countT   idSerial   = sBag.cFieldF( tinP , ifcIDfIELDbAG_IDsERIAL ) ;
                    TELL( "inspecting received soul" )
                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": f preparing to inspect bag\r\n" ) ; //U::

                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": g inspecting psoP\r\n" ) ; //U::
                {
                else
                }
                    tTraceFail = T("i have been told to quit") ;
                    bFail = 1 ;
                {
                if( bQuitP )
                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": h inspecting bQuitP\r\n" ) ; //U::
        
                idptOriginLathGood = idptOrigin ;

                portTimeC idptOrigin = POOP ? idptNull : portTimeC::fieldF( tinP , sBag , ifcIDfIELDbAG_RELAYoRIGIN ) ;
                portTimeC idptNull ;
                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": j a bag has arrived\r\n" ) ; //U::
                idCatch = 1 + incv02AM( idCatchLath ) ;
                //etThread.traceF( tinP , T("processing a bag") ) ;
                cBagsCaught ++ ;
            {
            if( !bFail )

            //etThread.traceF( tinP , T("readed  a bag") ) ;
            }
                }
                    if( !cBagsCaught ) tTraceFail = T("could not read woth sBag, so client is gone without sending me a bag, so i'm done") ;
                    bFail = 1 ;
                    POOPRqUIET
                {
                if( POOP )
                psoP->readF( tinP , sBag ) ;
                SCOOPS
            {
            IFsCRATCH
            //etThread.traceF( tinP , T("reading a bag") ) ;

            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 0 waiting for a bag to arrive\r\n" ) ; //U::
            TELL( "reading soul" )

            sOk << ifcOLDiDtYPEbAG_SERVERoK ;
            soulC sOk(  tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
            soulC sBag( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
            ZE( boolT , bFail ) ;
        {
        IFsCRATCH
    {
    while( !etThread && !ether && !bQuitP && psoP )
    ZE( countT , cBagsCaught ) ;
    TN( tTraceFail , "" ) ;
    ZE( countT , idCatch ) ;
    static countT idCatchLath ;
    stackC stIdMe( tinP , etThread , TAG( TAGiDnULL ) ) ;
    ZE( boolT  , bSaidBye ) ;
    ZE( countT , idWork ) ;
    ZE( boolT  , bPopClient ) ;
    ZE( countT , idPingLath ) ;
    portTimeC idptOriginLathGood ;
    portTimeC idptPopClient ;

    stPsoServerP.sinkF( tinP , countTC() , (countT)psoP , flSTACKsINK_UNIQUE ) ;

    }
        psoP->etherF( tinP , *tinP.pEtScratch ) ;
    {
    IFsCRATCH

    countT&  cLooksForNewPingP =  *(countT*)pTaskP->c7 ;
    stackC&  stIdptPopClientP  =  *(stackC*)pTaskP->c6 ;
    socketC& sListenP          = *(socketC*)pTaskP->c5 ;
    socketC* psoP              =  (socketC*)pTaskP->c4 ;
    RELAYiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TELL( "setting up" )
/*1*/TASK( tmNodeServerCatchBagF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//



//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmNodeKillF )
}
    }
        }
            stPsoServerP.ungrabF( tinP ) ;
            }
                while( !etThread && !stPsoServerP.third && ~handle ) ;
                }
                    }
                        if( POOP ) POOPR
                        hSoc.closeIfF() ;
                        handleC& hSoc = *(handleC*)&pso->handleF( tinP ) ;
                        SCOOPS
                    {
                    if( pso )
                    __Z( pso ) ;
                    socketC* pso = (socketC*)stPsoServerP.downF( tinP , handle ) ;
                {
                do
                handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( !etThread && !stPsoServerP.third && stPsoServerP )
            stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {

        }
            if( POOP ) POOPR
            sock.connectF( tinP , idptP , (nicNameC&)idptP ) ;
            socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
            SCOOPS
        {
        IFsCRATCH

        if( pStPop4P ) { ZE( soulC* , psBag ) ; etThread( tinP , psBag , TAG( TAGiDnULL ) ) ; *pStPop4P << psBag ; }
        if( pStPop3P ) { ZE( soulC* , psBag ) ; etThread( tinP , psBag , TAG( TAGiDnULL ) ) ; *pStPop3P << psBag ; }
        if( pStPop2P ) { ZE( soulC* , psBag ) ; etThread( tinP , psBag , TAG( TAGiDnULL ) ) ; *pStPop2P << psBag ; }
        if( pStPop1P ) { ZE( soulC* , psBag ) ; etThread( tinP , psBag , TAG( TAGiDnULL ) ) ; *pStPop1P << psBag ; }
        if( pStPop0P ) { ZE( soulC* , psBag ) ; etThread( tinP , psBag , TAG( TAGiDnULL ) ) ; *pStPop0P << psBag ; }

        bQuitP = 1 ;
        //LOGrAW( "tmNodeKillF: setting bQuitP\r\n" ) ; //U::
        //P: WHEN A RELAY QUITS, IT DOES SO RUDELY
        TELL( "killing" )
   
    {

    etherC::loafIF( tinP ) ;
    TELL( "napping for life" )
    RELAYiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
/*1*/TASK( tmNodeKillF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmNodeInitiatorF )
tinP.idPhase2 = 0 ;
}
    }
        while( cTries -- && ( !bRoot || ( cGossipPopped == cGossipInP ) ) ) { ++ s ; ether.osSleepF( tinP , TUCK * 0x80 ) ; }
        //P: A ROOT RELAY WILL CONTINUE IMMEDIATELY TO NEXT CYCLE IF IT HAS RECEIVED NEW GOSSIP
        countT cTries = /*U:: TUCK / 0x10 */ 1 ; //U::TO FIND A BUG
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        TELL( "napping" )
        //CONoUTrAW( "tmNodeInitiatorF: 0 napping\r\n" ) ;

        }
            }
                DEL( psBag ) ;
                nodeOldC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                nodeOldC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flOLDrELAYpOP_UP|flOLDrELAYpOP_DOWN , ifcOLDiDtYPEbAG_CLIENTnULL ) ;
            {
            if( psBag )
            soulC* psBag = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBag ) ;

        { //THIS IS TO STIMULATE THE POP STACKS SO THAT THE POP CLIENTS WILL KEEP THEIR CONNECTIONS CURRENT
        //CONoUTrAW( "tmNodeInitiatorF: 1 pop a null bag\r\n" ) ;

        }
            soul.removeAllF( tinP ) ;
            nodeOldC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , soul , stIdptOpenP , stIdptGossipP , idptP ) ;
            cPops ++ ;
            static countT cPops ; //U::CONJ: NEEDS TO BE VISIBLE TO SOME OTHER SNIPPET
        {
        if( soul ) //U::CONJ: BUG: IS USING operator byteT*
        //CONoUTrAW( "tmNodeInitiatorF: 2 pop the soul\r\n" ) ;

        if( bHelloHandle ) nodeOldC::helloToHandleIF( tinP , idptP , idSerialLathHeaderP ) ;

        //CONoUTrAW( "tmNodeInitiatorF: 3 say hello to handle\r\n" ) ;

        }
            idptHandleLag = idptHandleCopy ;
            if( idptHandleCopy && idptHandleCopy != idptHandleLag && idptHandleCopy != idptP ) bHelloHandle = 1 ; //P: ALL RELAYS SAY HELLO TO A NEW HANDLE RELAY
            portTimeC idptHandleCopy = nodeOldC::handleQueryIF( tinP ) ;
        {
        //CONoUTrAW( "tmNodeInitiatorF: 4 set bHelloHandle\r\n" ) ;

        }
            swsIdptMediatorP.ungrabF( tinP ) ;
            swsIdptMediatorAltP.ungrabF( tinP ) ;

            THREADmODE1rESTORE
            swsIdptMediatorP.freeAllF( tinP ) ;

            }
                }
                    while( !stIdptOpenP.third && ~hDown ) ;
                    }
                        swsIdptMediatorP.extractF( 0 , tinP ) ;
                        swsIdptMediatorAltP.sinkF( tinP , countTC() , (byteT*)&idptm , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                        portTimeC& idptm = *(portTimeC*)&swsIdptMediatorP.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    //etThread.strokeF( tinP , T("pouring ")+TF1(swsIdptMediatorP)+T(" registered mediator cells of adam ")+TF1(idAdamMediatorP)+T("\r\n") ) ;
                {
                if( swsIdptMediatorP )
                idAdamMediatorP = swsIdptMediatorP.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swsIdptMediatorP.cFlavorsF( tinP ) ;

            swsIdptMediatorAltP.freeAllF( tinP ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            swsIdptMediatorAltP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            swsIdptMediatorP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( !( idCycle % 0x8 ) ) //02->001
        //CONoUTrAW( "tmNodeInitiatorF: 5 pour mediator list\r\n" ) ;

        nodeOldC::handleRegisterMeIfIF( tinP , idptP ) ; //P: A RELAY WILL GRAB A HANDLE VACANCY
        UNGRABrELAYlISTS
        //CONoUTrAW( "tmNodeInitiatorF: 6 register myself as handle\r\n" ) ;

        //THREADmODE1rESTORE
        //}
        //    while( !stIdptPopClientP.third && ~hDown ) ;
        //    }
        //        //etThread.strokeF( tinP , T(nn)+tcol+T(idPort)+tcol+TT(tt.time1,tt.time2)+T(!hDown?"\r\n":" , ") ) ;
        //        const timeS&    tt     = idpt ;
        //        const nicNameC& nn     = (const nicNameC&)(const portC&)idpt ;
        //        countT          idPort = idpt ;
        //        portTimeC& idpt = *(portTimeC*)&stIdptOpenP.downF( tinP , hDown ) ;
        //    {
        //    do
        //    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        //    TN( tcol , ":" ) ;
        //{
        //if( stIdptOpenP )
        //THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        //CHATTER MY OPEN LIST

        }
            }
                bHelloHandle = 1 ; //P: A NONROOT RELAY THAT HAS NOT RECEIVED A PING LATELY WILL SAY HELLO TO HANDLE

                stIdptOpenP.extractF( 0 , tinP ) ;
                cLooksForNewPingP = 0 ;
            {
            else if( incv02AM( cLooksForNewPingP ) > 4 )
            }
                nodeOldC::myListIF( tinP , soul , stIdptOpenP ) ;
                nodeOldC::myListIF( tinP , soul , stIdptGossipP ) ;
                nodeOldC::hdrBagIF( tinP , soul , idptP , idSerialLathHeaderP , flOLDrELAYpOP_UP , ifcOLDiDtYPEbAG_CLIENTpOPpING ) ;
                //etThread.traceF( tinP , T("loading ifcOLDiDtYPEbAG_CLIENTpOPpING bag [cNodesOpen,cNodesGossip]:    ")+TF2(stIdptOpenP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(stIdptGossipP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                }
                    THREADmODE1rESTORE
                    while( !stIdptGossipP.third && ~hDown ) ;
                    }
                        }
                            nodeOldC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                            if( stIdptGossipP( (byteT*)&idptTest , subtractIdPortsF  , - 1                    ) ) stIdptGossipP.extractF( 0 , tinP ) ;
                            if( stIdptOpenP(   (byteT*)&idptTest , subtractIdPortTimesF , (countT)&stIdptGossipP ) ) stIdptOpenP.extractF(   0 , tinP ) ;
                        {
                        if( !nodeOldC::testIF( tinP , idptP , idSerialLathHeaderP , idptTest ) )
                        portTimeC& idptTest = *(portTimeC*)&stIdptGossipP.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                {
                if( stIdptGossipP )
                //P: A RELAY THAT THINKS THAT IT IS ROOT WILL TEST ALL GOSSIPPED RELAYS AND DELIST THOSE THAT FAIL
                //TEST ALL GOSSIPPED RELAYS

                }
                    nodeOldC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                    if( stIdptGossipP( (byteT*)&idptAbsent5 , subtractIdPortsF  , - 1                    ) ) stIdptGossipP.extractF( 0 , tinP ) ;
                    if( stIdptOpenP(   (byteT*)&idptAbsent5 , subtractIdPortTimesF , (countT)&stIdptGossipP ) ) stIdptOpenP.extractF(   0 , tinP ) ;
                    //P: A RELAY THAT THINKS IT IS ROOT WILL DELIST AN ABSENT RELAY THAT IT EXPECTS TO BE AT ITS LEFT
                {
                if( idptAbsent5 )
                cGossipPopped = cGossipInP ;
                bRoot = 1 ;
                if( !( idCycle % 0x4 ) ) bHelloHandle = 1 ; //P: EVERY RELAY THAT THINKS THAT IT IS ROOT ALWAYS SAYS HELLO TO HANDLE
                //U: I DO NOT KNOW WHY THIS CAUSES CYCLING IF DONE EVERY CYCLE

                }
                    if( idpth && !nodeOldC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idpth ) ) stIdptOpenP.sinkF( tinP , countTC() , (byteT*)&idpth , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ; //P: A ROOT RELAY ALWAYS KNOWS ABOUT A HANDLE RELAY
                    portTimeC idpth = nodeOldC::handleQueryIF( tinP ) ;
                {
            {
            if( *pnRoot == idptP )

            bReadyP = 1 ;
            )
                ( ( *pnRoot != idptP ) || idCycle >= 0x1/*U::0x10*/ )
                &&
                ( !idptAbsent1 && !idptAbsent2 && !idptAbsent3 && !idptAbsent4 && !idptAbsent5 )
                &&
                bRollTaken
                &&
                !bReadyP
            (
            if
        {
        if( pnRoot )
        portTimeC* pnRoot = stIdptOpenP ? (portTimeC*)&stIdptOpenP[ 1 ] : 0 ;
        GRABrELAYlISTS
        ZE( countT , cGossipPopped ) ;
        ZE( boolT , bRoot ) ;
        //CONoUTrAW( "tmNodeInitiatorF: 7 root work\r\n" ) ;

        }
            }
                bHelloHandle = 1 ; //P: RELAY SAYS HELLO TO HANDLE WHENEVER WO OR MORE EXPECTED CLIENTS ARE ABSENT
            {
            if( idptAbsent1 || idptAbsent2 || idptAbsent3 || idptAbsent4 || idptAbsent5 )
    
            POURaBSENTnODE( 5 )
            POURaBSENTnODE( 4 )
            POURaBSENTnODE( 3 )
            POURaBSENTnODE( 2 )
            POURaBSENTnODE( 1 )
    
            GOSSIPaBSENTnODE( 5 )
            GOSSIPaBSENTnODE( 4 )
            GOSSIPaBSENTnODE( 3 )
            GOSSIPaBSENTnODE( 2 )
            GOSSIPaBSENTnODE( 1 )

            if( idptAbsent5 ) etThread.traceF( tinP , T("absent [idptAbsent5]:    ")+T((nicNameC&)idptAbsent5)+T(" ( ")+TF2((countT)idptAbsent5,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ;
            if( idptAbsent4 ) etThread.traceF( tinP , T("absent [idptAbsent4]:    ")+T((nicNameC&)idptAbsent4)+T(" ( ")+TF2((countT)idptAbsent4,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ;
            if( idptAbsent3 ) etThread.traceF( tinP , T("absent [idptAbsent3]:    ")+T((nicNameC&)idptAbsent3)+T(" ( ")+TF2((countT)idptAbsent3,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ;
            if( idptAbsent2 ) etThread.traceF( tinP , T("absent [idptAbsent2]:    ")+T((nicNameC&)idptAbsent2)+T(" ( ")+TF2((countT)idptAbsent2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ;
            if( idptAbsent1 ) etThread.traceF( tinP , T("absent [idptAbsent1]:    ")+T((nicNameC&)idptAbsent1)+T(" ( ")+TF2((countT)idptAbsent1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )") ) ;
    
            }
                }
                    while( !stIdptPopClientP.third && ~hDown ) ;
                    }
                        if( stRelayAbsent5( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent5.extractF( 0 , tinP ) ;
                        if( stRelayAbsent4( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent4.extractF( 0 , tinP ) ;
                        if( stRelayAbsent3( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent3.extractF( 0 , tinP ) ;
                        if( stRelayAbsent2( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent2.extractF( 0 , tinP ) ;
                        if( stRelayAbsent1( (byteT*)&idpt , subtractIdPortsF , - 1 ) ) stRelayAbsent1.extractF( 0 , tinP ) ;
                        portTimeC& idpt = *(portTimeC*)&stIdptPopClientP.downF( tinP , hDown ) ;
                        //U: ISSUE: A CLIENT IS NOT REALLY ABSENT AS RIGHT IF IT IS PRESENT AS DOWN
                        //U: COUNT THE CLIENT AS PRESENT HERE ONLY IF THE CLIENT AGREES ABOUT THE TYPE OF WORK IT IS DOING
                        //P: RELAY WILL COUNT A CLIENT AS "PRESENT" EVEN IF THE CLIENT DISAGREES ABOUT THE TYPE OF WORK IT IS CONNECTED TO DO
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stIdptPopClientP )
            {
            nodeOldC::portTimeClientsExpectedIF( tinP , stRelayAbsent5 , stIdptOpenP , stIdptGossipP , idptP , OLDiDtYPErELAYpOPcLIENTwORK_RIGHT    ) ;
            nodeOldC::portTimeClientsExpectedIF( tinP , stRelayAbsent4 , stIdptOpenP , stIdptGossipP , idptP , OLDiDtYPErELAYpOPcLIENTwORK_LEFT     ) ;
            nodeOldC::portTimeClientsExpectedIF( tinP , stRelayAbsent3 , stIdptOpenP , stIdptGossipP , idptP , OLDiDtYPErELAYpOPcLIENTwORK_EXPLODE2 ) ;
            nodeOldC::portTimeClientsExpectedIF( tinP , stRelayAbsent2 , stIdptOpenP , stIdptGossipP , idptP , OLDiDtYPErELAYpOPcLIENTwORK_EXPLODE1 ) ;
            nodeOldC::portTimeClientsExpectedIF( tinP , stRelayAbsent1 , stIdptOpenP , stIdptGossipP , idptP , OLDiDtYPErELAYpOPcLIENTwORK_IMPLODE  ) ;
            stRelayAbsent5.purgeF( tinP ) ;
            stRelayAbsent4.purgeF( tinP ) ;
            stRelayAbsent3.purgeF( tinP ) ;
            stRelayAbsent2.purgeF( tinP ) ;
            stRelayAbsent1.purgeF( tinP ) ;
            bRollTaken = 1 ;
        {
        if( !( ++ idCycle % 0x2 ) )
        ZE( boolT , bHelloHandle ) ;
        portTimeC idptAbsent5 ;
        portTimeC idptAbsent4 ;
        portTimeC idptAbsent3 ;
        portTimeC idptAbsent2 ;
        portTimeC idptAbsent1 ;
        ZE( boolT , bRollTaken ) ;
        //etThread.traceF( tinP , T("8 look for absentees") ) ;
    {
    while( !etThread && !stIdptOpenP.third && !ether && !bQuitP )
    portTimeC idptHandleLag ;
    ZE( countT , idCycle ) ;
    stackC stIdMe( tinP , etThread , TAG( TAGiDnULL ) ) ;
    stackC stRelayAbsent5Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    stackC stRelayAbsent4Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    stackC stRelayAbsent3Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    stackC stRelayAbsent2Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    stackC stRelayAbsent1Lag( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    stackC stRelayAbsent5( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    stackC stRelayAbsent4( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    stackC stRelayAbsent3( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    stackC stRelayAbsent2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    stackC stRelayAbsent1( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    soulC soul( tinP , TAG( TAGiDnULL ) ) ;

    boolT&    bReadyP           =     *(boolT*)pTaskP->c6 ;
    countT&   cLooksForNewPingP =    *(countT*)pTaskP->c5 ;
    stackC&   stIdptPopClientP  =    *(stackC*)pTaskP->c4 ;
    RELAYiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
tinP.idPhase2 = 1 ;
/*1*/TASK( tmNodeInitiatorF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmNodeTeatServerF )
}
    }
        }
            etThread.delF( tinP , pc4c ) ;
            etThread.delF( tinP , *(countT**)&pc4c->c3 ) ;
            etThread.delF( tinP , *(countT**)&pc4c->c1 ) ;
            stChannelExclude >> pc4c ;
            ZE( count4S* , pc4c ) ;
        {
        while( stChannelExclude )
    
        }
            etThread.delF( tinP , pc4c ) ;
            etThread.delF( tinP , *(countT**)&pc4c->c3 ) ;
            etThread.delF( tinP , *(countT**)&pc4c->c1 ) ;
            stChannelInclude >> pc4c ;
            ZE( count4S* , pc4c ) ;
        {
        while( stChannelInclude )
    
        DEL( psoP ) ;
    
        swsWrapRefP.ungrabF( tinP ) ;
        }
            THREADmODE1rESTORE
            swsWrapRefP.freeF( tinP ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            cLeverPayloadP = tinP.monitor.idThread ;
        {
    
        }
            }
                etThread.delF( tinP , pc2WrapRef ) ;
                etThread( tinP , *(soulC**)&pc2WrapRef->c1 ) ;
            {
            if( 1 == decv02AM( pc2WrapRef->c2 ) )
    
            stWrapRef >> *(countT*)&pc2WrapRef ;
            ZE( count2S* , pc2WrapRef ) ;
        {
        while( stWrapRef )
    
        sgnDone_tmNodeServerWrapToAppF.waitF( tinP ) ;
        }
            }
                stWrapRef << (countT)pc2WrapRef ;
                pc2WrapRef->c2 = 1 ;
                pc2WrapRef->c1 = 0 ;
            {
            if( pc2WrapRef )
            etThread.newF( tinP , LF , pc2WrapRef ) ; ___( pc2WrapRef ) ; //U::LEAKS SOMETIMES
            ZE( count2S* , pc2WrapRef ) ;
        {
        bQuit = 1 ;
        swsWrapRefP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        if( etThread ) { ((const poopC&)etThread).chatterF( tinP , LF ) ; LOGrAW( "tmNodeTeatServerF: etThread is impotent so BLAMMO\r\n" ) ; BLAMMO ; } //NEEDED TO PRECLUDE DEADLOCK GRABBING swsWrapRefP
    
        }
            }
                DEL( psWrap ) ; //MIGHT BE 0 IFF I CALLED nodeOldC::doWrapLocallyIfIF
    
                }
                    }
                        }
                            break ;
                            DEL( psGift ) ;
                            DEL( psWrapo ) ;
                            }
                                }
                                    }
                                        bQuit = 1 ;
                                        POOPR
                                    {
                                    if( POOP )
                                    psoP->writeF( tinP , *psWrapo ) ;
                                    SCOOPS
                                {
                                etThread.traceF( tinP , T("writing *psWrapo ifcOLDiDtYPEwRAP_QUERYrELAYiDpORTtIMEcaLLhOMES") ) ;
        
                                *psWrapo << *psGift ;
                                *psWrapo << (countT)ifcOLDiDtYPEwRAP_REPLYrELAYiDpORTtIMEcaLLhOMES ;
                                *psWrapo << (countT)1 ; // idVersion
                                *psWrapo << (countT)ifcIDpROTOCOL_RELAYwRAP ;
                                *psWrapo << (strokeS*)tTM ;
                                TN( tTM , "IdeaFarm " "(tm)" ) ;
        
                                UNGRABrELAYlISTS
                                }
                                    while( !stIdptOpenP.third && ~hDown ) ;
                                    do *(portTimeC*)&stIdptOpenP.downF( tinP , hDown ) >> *psGift ;
                                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( stIdptOpenP )
                                *psGift << (countT)stIdptOpenP ;
                                GRABrELAYlISTS
                            {
                            if( psGift && psWrapo )
                            soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psGift ) ;
                            soulC* psWrapo = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrapo ) ;
                        {
                        case ifcOLDiDtYPEwRAP_QUERYrELAYiDpORTtIMEcaLLhOMES :
                        }
                            break ;
                            DEL( psGift ) ;
                            DEL( psWrapo ) ;
                            }
                                }
                                    }
                                        bQuit = 1 ;
                                        POOPR
                                    {
                                    if( POOP )
                                    psoP->writeF( tinP , *psWrapo ) ;
                                    SCOOPS
                                {
                                etThread.traceF( tinP , T("writing *psWrapo ifcOLDiDtYPEwRAP_QUERYrELAYiDpORTtIMEc") ) ;
        
                                *psWrapo << *psGift ;
                                *psWrapo << (countT)ifcOLDiDtYPEwRAP_REPLYrELAYiDpORTtIMEc ;
                                *psWrapo << (countT)1 ; // idVersion
                                *psWrapo << (countT)ifcIDpROTOCOL_RELAYwRAP ;
                                *psWrapo << (strokeS*)tTM ;
                                TN( tTM , "IdeaFarm " "(tm)" ) ;
        
                                idptP >> *psGift ;
                            {
                            if( psGift && psWrapo )
                            soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psGift ) ;
                            soulC* psWrapo = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrapo ) ;
                        {
                        case ifcOLDiDtYPEwRAP_QUERYrELAYiDpORTtIMEc :
                        }
                            break ;
                            DEL( psGift ) ;
                            DEL( psWrapo ) ;
                            }
                                }
                                    }
                                        bQuit = 1 ;
                                        POOPR
                                    {
                                    if( POOP )
                                    psoP->writeF( tinP , *psWrapo ) ;
                                    SCOOPS
                                {
                                etThread.traceF( tinP , T("writing *psWrapo ifcOLDiDtYPEwRAP_QUERYrELAYrANK") ) ;
        
                                *psWrapo << *psGift ;
                                *psWrapo << (countT)ifcOLDiDtYPEwRAP_REPLYrELAYrANK ;
                                *psWrapo << (countT)1 ; // idVersion
                                *psWrapo << (countT)ifcIDpROTOCOL_RELAYwRAP ;
                                *psWrapo << (strokeS*)tTM ;
                                TN( tTM , "IdeaFarm " "(tm)" ) ;
        
                                *psGift << idRank ;
                                UNGRABrELAYlISTS
                                }
                                    while( !stIdptOpenP.third && ~hDown ) ;
                                    }
                                        THREADmODE1rESTORE
                                        //CONoUTrAW( TF1(++ids)+T(": ")+TT(time.time1,time.time2)+T(" ")+TF1((countT)idpt)+T(" ")+TF1((nicNameC&)idpt)+T("\r\n") ) ;
                                        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                        timeS time = idpt ;
                                        portTimeC& idpt = *(portTimeC*)&stIdptOpenP.downF( tinP , hDown ) ;
                                    {
                                    do
                                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    ZE( countT , ids ) ;
                                {
                                if( stIdptOpenP )
                                //CONoUTrAW( T("the requested idRank is ")+TF1(idRank)+T("\r\n") ) ;
                                countT idRank = stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                GRABrELAYlISTS
                            {
                            if( psGift && psWrapo )
                            soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psGift ) ;
                            soulC* psWrapo = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrapo ) ;
                        {
                        case ifcOLDiDtYPEwRAP_QUERYrELAYrANK :
                        }
                            break ;
                            }
                                DEL( psBag ) ;
                                if( bDontHoldBreath ) nodeOldC::doWrapLocallyIfIF( tinP , etThread , RELAYiNFOaRGS , *psWrap , idptP ) ;
            
                                nodeOldC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                                //tinP.pEther->traceF( tinP , T("tmNodeTeatServerF: calling popIF [bRoot,bDontHoldBreath]:    ")+TF2(bRoot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(bDontHoldBreath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                *psBag << *psWrap ;
                                nodeOldC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , bRoot ? flOLDrELAYpOP_UP : flOLDrELAYpOP_DOWN , ifcOLDiDtYPEbAG_WRAP ) ;
            
                                UNGRABrELAYlISTS
                                boolT bDontHoldBreath = bRoot /*&& stIdptOpenP < 4*/ ; //IF bDontHoldBreath THEN THE ROOT WILL NOT EVER GET ITS OWN POP
                                boolT bRoot = pnRoot && *pnRoot == idptP ;
                                portTimeC* pnRoot = stIdptOpenP ? (portTimeC*)&stIdptOpenP[ 1 ] : 0 ;
                                GRABrELAYlISTS
                            {
                            if( psBag )
                            soulC* psBag = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBag ) ;
        
                            if( pczChannel && pczChannel[ 0 ] == ifcOLDiDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcOLDiDcHANNELfUNCTION_MEDIATORrEGISTRATION ) { static countT idIn ; tinP.pEther->traceF( tinP , TF2(++idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" tmNodeTeatServerF: ifcOLDiDtYPEwRAP_GIFT (mediator registration channel)") ) ; }
        
                            }
                                THREADmODE1rESTORE
                                //tinP.pEther->traceF( tinP , T("wrap from app for channel ")+T(pczChannel) ) ;
                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                            {
                            else
                            if( bDebug ) { CONoUTrAW3( "teat read a secret wrap that contains " , (countT)*psWrap , " members\r\n" ) ; }
        
                                bDebug = 1 ;
                            if( pczChannel && pczChannel[ 0 ] == ifcOLDiDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcOLDiDcHANNELfUNCTION_MEDIATED && pczChannel[ 2 ] == ifcIDaDAM_SECRETsERVICE && pczChannel[ 3 ] == ifcIDaDAM_CONSOLE && pczChannel[ 4 ] == ifcOLDiDcHANNELfUNCTION_STROKEcONSOLE )
                            ZE( boolT , bDebug ) ;
        
                            countT* pczChannel = (countT*)psWrap->pbFieldF( tinP , countTC() , countTC() , countTC() , ifcOLDiDfIELDwRAP_CHANNEL ) ;
                        {
                        case ifcOLDiDtYPEwRAP_GIFT :
                        }
                            break ;
                            bQuit = 1 ;
                        {
                        case ifcOLDiDtYPEwRAP_QUIT : //OPTIONAL: CLIENTS ARE ASSUMED TO BE RUDE
                        }
                            break ;
                        {
                        case ifcOLDiDtYPEwRAP_CHANNELiNCLUDEpOPaLL :
                        }
                            break ;
                        {
                        case ifcOLDiDtYPEwRAP_CHANNELiNCLUDEpOP :
                        }
                            break ;
                            }
                                stChannel << pc4c ;
                                stackC& stChannel = idType == ifcOLDiDtYPEwRAP_CHANNELiNCLUDEpUSH ? stChannelInclude : stChannelExclude ;
        
                                if( pcFilter ) etThread.memCopyF( tinP , (byteT*)pcFilter , (byteT*)pcFilterFrom , ccFilter * sizeof( countT ) ) ;
                                etThread.newF( tinP , LF , pcFilter , ccFilter ) ; ___( pcFilter ) ;
                                ccFilter  = psWrap->cFieldF( tinP , ifcOLDiDfIELDwRAP_CCfILTER ) ;
                                countT* pcFilterFrom = (countT*)psWrap->pbFieldF( tinP , countTC() , countTC() , countTC() , ifcOLDiDfIELDwRAP_FILTER ) ;
        
                                ccTestMax = psWrap->cFieldF( tinP , ifcOLDiDfIELDwRAP_CCtESTmAX ) ;
        
                                if( pczTest ) etThread.memCopyF( tinP , (byteT*)pczTest , (byteT*)pczChannel , cca * sizeof( countT ) ) ;
                                etThread.newF( tinP , LF , pczTest , cca ) ; ___( pczTest ) ;
                                countT cca = 1 + etThread.strBodyLengthF( tinP , pczChannel ) ;
        
                                countT&  ccFilter  =  *(countT*)&pc4c->c4 ;
                                countT*& pcFilter  = *(countT**)&pc4c->c3 ;
                                countT&  ccTestMax =  *(countT*)&pc4c->c2 ;
                                countT*& pczTest   = *(countT**)&pc4c->c1 ;    
                            {
                            if( pc4c )
                            etThread.newF( tinP , LF , pc4c ) ; ___( pc4c ) ;
                            ZE( count4S* , pc4c ) ;
                            countT* pczChannel = (countT*)psWrap->pbFieldF( tinP , countTC() , countTC() , countTC() , ifcOLDiDfIELDwRAP_CHANNEL ) ;
                        {
                        case ifcOLDiDtYPEwRAP_CHANNELeXCLUDEpUSH :
                        case ifcOLDiDtYPEwRAP_CHANNELiNCLUDEpUSH :
                    {
                    switch( idType )
                    //CONoUTrAW3( "tmNodeTeatServerF [idType]: " , idType , "\r\n" ) ;
                    countT idType = psWrap->cFieldF( tinP , ifcOLDiDfIELDwRAP_IDtYPE ) ;
                {
                if( !bQuit )
    
                }
                    etThread.delF( tinP , psttTM ) ;
                    }
                        }
                            bQuit = 1 ;
                            POOPRqUIET
                            tinP.pEther->traceF( tinP , T("tmNodeTeatServerF / wrapper contains garbage") ) ;
                        {
                        if( POOP )
                        __( psWrap->cFieldF( tinP , ifcOLDiDfIELDwRAP_IDvERSION ) - 1 ) ; //idVersion
                        __( psWrap->cFieldF( tinP , ifcOLDiDfIELDwRAP_IDpROTOCOL ) - ifcIDpROTOCOL_RELAYwRAP ) ;
                        __( tinP.pEtScratch->strCompareF( tinP , psttTM , T("IdeaFarm " "(tm)") ) ) ;
                        __( idTypeTM - ifcIDtYPEsOULiTEM_strokeSptr ) ;
                        __Z( psttTM ) ;
                        SCOOPS
                    {

                    }
                        //CONoUTrAW( ostoSay ) ;
                        //OStEXTA(  ostoSay , "\"\r\n" ) ;
                        //OStEXTA(  ostoSay , T(psttTM) ) ;
                        //OStEXTAK( ostoSay , "tmNodeTeatServerF [psttTM]: \"" ) ;
                        //OStEXT( ostoSay , TUCK << 2 ) ;

                        etThread.strReplaceF( tinP , psttTM , 0 , ifcIDtYPEsTRrEPLACE_MAKEiMPORT , psttTM[ 2 ].idAdam ) ; ___( psttTM ) ;
                        etThread.strDecodeOldF( tinP , psttTM , pbfTM ) ; ___( psttTM ) ;
                    {
                    if( pbfTM && cbfTM )
                    ZE( strokeS* , psttTM ) ;
        
                    byteT* pbfTM = psWrap->pbFieldF( tinP , idTypeTM , flagsTM , cbfTM , ifcOLDiDfIELDwRAP_TRADEmARK ) ; //U::BUG: STRINGS OF STROKES ARE NOW ENCODED
                    ZE( countT , cbfTM ) ;
                    ZE( flagsT , flagsTM ) ;
                    ZE( countT , idTypeTM ) ;
                {
    
                }
                    }
                        break ;
                        DEL( psWrap ) ;
                        POOPR
                    {
                    if( POOP )
                    //CONoUTrAW3( "tmNodeTeatServerF: readF returned (" , idIn , ")\r\n" ) ;
                    countT idIn = 1 + incv02AM( idInLath ) ;
                    static countT idInLath ;
                    psoP->readF( tinP , *psWrap ) ;
                    SCOOPS
                {
            {
            if( psWrap )
            soulC* psWrap = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrap ) ;
        {
        while( !ether && !bQuitP && !bQuit && !etThread )
        etThread.traceF( tinP , T("tmNodeTeatServerF: client is ")+TF2(idAdamClient,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        etThread.osThreadF( tinP , countTC() , tmNodeServerWrapToAppF , &sgnDone_tmNodeServerWrapToAppF , flTHREADlAUNCH_null , 0 , (countT)&bQuit , (countT)&psoP , (countT)&stWrapRef , (countT)&stChannelInclude , (countT)&stChannelExclude , idAdamClient ) ;
        signC sgnDone_tmNodeServerWrapToAppF( tinP , TAG( TAGiDnULL ) ) ;

        }
            if( !idAdamClient ) bQuit = 1 ;
            DEL( psWrap ) ;
            }
                else       *psWrap >> idAdamClient ;
                if( POOP ) POOPR
                psoP->readF( tinP , *psWrap ) ;
                SCOOPS
            {
            if( psWrap )
            soulC* psWrap = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrap ) ;
        {
        ZE( countT , idAdamClient ) ;
        ZE( boolT , bQuit ) ;
    
        psoP->etherF( tinP , *tinP.pEtScratch ) ;
    
        stackC stChannelExclude( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count4S ) ;
        stackC stChannelInclude( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count4S ) ;
    
        swsWrapRefP.ungrabF( tinP ) ;
        THREADmODE1rESTORE
        stackC& stWrapRef = (stackC&)swsWrapRefP ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        cLeverPayloadP = tinP.monitor.idThread ;
        swsWrapRefP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    IFsCRATCH

    socketC* psoP = (socketC*)pTaskP->c4 ;
    RELAYiNFOtm
{
if( pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
/*1*/TASK( tmNodeTeatServerF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmNodeServerWrapToAppF )
}
    }
        }
            }
                etThread.delF( tinP , pc2WrapRef ) ;
                DEL( *(soulC**)&pc2WrapRef->c1 ) ;
            {
            if( 1 == decv02AM( pc2WrapRef->c2 ) )

            }
                }
                    }
                        bQuitP = 1 ;
                        etThread.traceF( tinP , T("could not write soul") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    psoP->writeF( tinP , *(soulC*)pc2WrapRef->c1 ) ;
                    scoopC scoop( tinP , LF , psoP->etherF( tinP ) ) ;
                    //etThread.traceF( tinP , T("writing soul") ) ;

                    }
                        }
                            portTimeC idptOrigin = portTimeC::fieldF( tinP , sWrap , ifcOLDiDfIELDwRAP_IDPToRIGIN ) ;
                        {
                        if( idType == ifcOLDiDtYPEwRAP_GIFT )
                        countT idType = sWrap.cFieldF( tinP , ifcOLDiDfIELDwRAP_IDtYPE ) ;
                        soulC& sWrap = *(soulC*)pc2WrapRef->c1 ;
                    {
                    //CONoUTrAW( "tmNodeServerWrapToAppF: trapping a bug\r\n" ) ;
                    //U::TO TRAP A BUG

                    //if( pczChannel && pczChannel[ 0 ] == ifcOLDiDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcOLDiDcHANNELfUNCTION_MEDIATORrEGISTRATION ) { CONoUTrAW( "tmNodeServerWrapToAppF: survived filters; writing to client\r\n" ) ; } //U::
                {
                if( bWrite )
    
                }
                    stChannelExcludeP.ungrabF( tinP ) ;
                    }
                        while( !stChannelExcludeP.third && ~hDown ) ;
                        }
                            }
                                break ;
                                bWrite = 0 ;
                            {
                            if( !etThread.strCompareF( tinP , pczChannel , pczTest , 0 , ccTestMax , pcFilter , ccFilter ) )
        
                            countT   ccFilter  =             pc4c->c4 ;
                            countT*& pcFilter  = *(countT**)&pc4c->c3 ;
                            countT   ccTestMax =             pc4c->c2 ;
                            countT*& pczTest   = *(countT**)&pc4c->c1 ;
                            count4S*& pc4c = *(count4S**)&stChannelExcludeP.downF( tinP , hDown ) ;
                        {
                        do
                        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( stChannelExcludeP )
                    stChannelExcludeP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( bWrite )
    
                stChannelIncludeP.ungrabF( tinP ) ;
                }
                    while( !stChannelIncludeP.third && ~hDown ) ;
                    }
                        }
                            break ;
                            bWrite = 1 ;
                        {
                        if( !etThread.strCompareF( tinP , pczChannel , pczTest , 0 , ccTestMax , pcFilter , ccFilter ) )
    
                        countT   ccFilter  =             pc4c->c4 ;
                        countT*& pcFilter  = *(countT**)&pc4c->c3 ;
                        countT   ccTestMax =             pc4c->c2 ;
                        countT*& pczTest   = *(countT**)&pc4c->c1 ;
                        count4S*& pc4c = *(count4S**)&stChannelIncludeP.downF( tinP , hDown ) ;
                    {
                    do
                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    bWrite = 0 ;
                {
                if( stChannelIncludeP )
                stChannelIncludeP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                boolT bWrite = 1 ;

                //if( pczChannel && pczChannel[ 0 ] == ifcOLDiDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcOLDiDcHANNELfUNCTION_MEDIATORrEGISTRATION ) { CONoUTrAW( "tmNodeServerWrapToAppF: this push is on the mediator reg channel\r\n" ) ; } //U::
    
                countT* pczChannel = (countT*)((soulC*)pc2WrapRef->c1)->pbFieldF( tinP , countTC() , countTC() , countTC() , ifcOLDiDfIELDwRAP_CHANNEL ) ;
            {
            if( !bQuitP )

            stWrapRefP >> *(countT*)&pc2WrapRef ;
            ZE( count2S* , pc2WrapRef ) ;
        {
        while( stWrapRefP )

        if( bQuitP ) break ;
            { tinP.pEther->traceF( tinP , T("tmNodeServerWrapToAppF: see a push for ifcIDaDAM_CONSOLE") ) ; }
        if( idAdamClient == ifcIDaDAM_CONSOLE )
        stWrapRefP.waitF( tinP ) ;
    {
    while( !ether && !bQuitP && !etThread && !stWrapRefP.third )

    countT        idAdamClient         =                 pTaskP->c6 ;
    stackC&       stChannelExcludeP    =       *(stackC*)pTaskP->c5 ;
    stackC&       stChannelIncludeP    =       *(stackC*)pTaskP->c4 ;
    stackC&       stWrapRefP           =       *(stackC*)pTaskP->c3 ;
    socketC*&     psoP                 =     *(socketC**)pTaskP->c2 ;
    boolT&        bQuitP               =        *(boolT*)pTaskP->c1 ;    
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
/*1*/TASK( tmNodeServerWrapToAppF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmNodeTeatAcceptorF )
}
    //LOGrAW7( "tit acceptor ending (ether,etThread.bQuitP): " , ether , " " , etThread , " " , bQuitP , "\r\n" ) ; //U::
    //CONoUTrAW7( "tit acceptor ending (ether,etThread.bQuitP): " , ether , " " , etThread , " " , bQuitP , "\r\n" ) ; //U::
    }
        home.idpTeat = portC() ;

        }
            else                 { DEL( pso ) ; }
            if( !bQuitP && pso ) etThread.osThreadF( tinP , countTC() , tmNodeTeatServerF , 0 , flTHREADlAUNCH_null , 0 , RELAYiNFOaRGcOUNTS , (countT)pso ) ;
            TELL( "launching tmNodeTeatServerF" )
    
            __( bRefuse ) ;
            sListen.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ;
            ZE( boolT , bRefuse ) ;
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            TELL( "waiting for a client to connect" )
            ZE( socketC* , pso ) ;
        {
        while( !etThread && !bQuitP )
    {
    if( home.idpTeat )

    sListen.listenF( tinP ) ;
    (countT&)home.idpTeat = sListen.bindF( tinP ) ;
    home.idpTeat = socketC::nicNameIF( tinP , etThread ) ;

    socketC sListen( tinP , etThread , TAG( TAGiDnULL ) ) ;

    homeS& home = homeS::homeIF() ;

    RELAYiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
/*1*/TASK( tmNodeTeatAcceptorF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmNodeBlowTeatF )
}
    }
        }
            DEL( psWrap ) ;
            }
                sockP.writeF( tinP , *psWrap ) ;
                //etThread.traceF( tinP , T("writing wrap to teat") ) ;
            {
            if( *psWrap )
            stRelayOutP >> *(countT*)&psWrap ;
            ZE( soulC* , psWrap ) ;
        {
        while( !bQuitWoConnectP && stRelayOutP )
        //etThread.traceF( tinP , T("waited  for push") ) ;
        stRelayOutP.waitF( tinP ) ;
        //etThread.traceF( tinP , T("waiting for push") ) ;
    {
    while( !bQuitWoConnectP && !etThread && !stRelayOutP.third )

    }
        DEL( psWrap ) ;
        }
            sockP.writeF( tinP , *psWrap ) ;
            *psWrap << tinP.pAdamGlobal1->idAdam ;
            tinP.pEther->traceF( tinP , T("identifying myself as ")+TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" to teat") ) ;
        {
        if( psWrap )
        soulC* psWrap = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrap ) ;
    {

    ZE( countT , idWrap ) ;
    TN( tTM , "IdeaFarm " "(tm)" ) ;

    stackC&  stRelayOutP     =  *(stackC*)pTaskP->c3 ;
    boolT&   bQuitWoConnectP =   *(boolT*)pTaskP->c2 ;
    socketC& sockP           = *(socketC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
/*1*/TASK( tmNodeBlowTeatF )/*1*/

//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmNodeTickleF )
}
    }
        if( POOP ) POOPR
        }
            }
                ether.osSleepF( tinP , TUCK * 0x40 ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                POOPR
            {
            else
            if( !POOP ) break ;
    
            VERIFYrELAY( sock ) ;
            sock.connectF( tinP , idPortP , (nicNameC&)idPortP ) ;
            socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) /*U::, 0 , flSOCKETc_TOPsECRET*/ ) ;
        {
        while( !ether && bWothP )
        soulC sInOk( tinP , TAG( TAGiDnULL ) ) ;
        SCOOPS
    {
    IFsCRATCH

    boolT&   bWothP  =   *(boolT*)pTaskP->c2 ;
    portC& idPortP = *(portC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
/*1*/TASK( tmNodeTickleF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


#include postADAMhEADER

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

