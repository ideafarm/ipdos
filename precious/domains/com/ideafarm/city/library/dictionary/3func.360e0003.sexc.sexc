
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG

    //}
    //    OStEXTAK( ostoSay , "\"" ) ;
    //    OStEXTA(  ostoSay , postNameP ) ;
    //    OStEXTAK( ostoSay , "\r\n sexC - [postName]: \"" ) ;
    //    OStEXT(   ostoSay , TUCK << 2 ) ;
    //{
    //if( tinP.pc Utility[ 0 ] )

    }
        TELLsYSc3LIFI( idTypeSay , (byteT*)&info , sizeof info , idLineCtP , idiFileCtP )
        info.idiFileCt  = idiFileCtP ;
        info.idLineCt   = idLineCtP ;
        info.pSex       = this ;
        thirdC::c_strcpyIF( tinP , info.postName , pzMetaHead->postName ) ;
        info.expSlots   = pzMetaHead->expSlots  ;
        info.expCbDrop  = pzMetaHead->expCbDrop ;
        info.osPid      = tinP.osPid ;
        tellInfoSysSexS info ;
        countT idTypeSay = ifcIDtYPEtELLsYS_SEXcT ;
    {
    if( !POOP )

    }
                                    pSexLifoConstructing = 0 ;
        tinP.pSexLifoConstructing = pSexLifoConstructing ;
        if( tinP.pSexLifoConstructing != this ) { BLAMMO ; }
    {
    if( pPoolContainsMe )

    tinP.tlsDelF( LF , countTC() ) ;
    tinP.tlsDelF( LF , countTC() ) ;
    tinP.tlsDelF( LF , countTC() ) ;
    tinP.tlsDelF( LF , countTC() ) ;
    //CS:CODEsYNC: 360e0003 360e0003

    }
        if( bSetResetFormatting        && !btrAM( pReg->pbSexBitFormatting , offSexBit ) ) { BLAMMO ; }
        if( !POOP && !bObeyReg && pReg &&  btsAM( pReg->pbSexBitFormatted  , offSexBit ) ) { BLAMMO ; }
    {
    if( pPoolContainsMe )

    }
        }
            }
                if( !bNest2 ) tinP.fliSexCtPendingExpCbDrop &= ~maskExpSlots  ;
                if( !bNest1 ) tinP.fliSexCtPendingExpCbDrop &= ~maskExpCbDrop ;
            {
            if( pPoolContainsMe )

            //CONoUTrAW( "\r\n-------------------------------------------------------------------------------------------------------------------\r\n" ) ;

            //------------------------------------------------------------------------------------------------------------------------------------------------------------
            // CLEAN UP
            //------------------------------------------------------------------------------------------------------------------------------------------------------------

            }
                }
                    }
                        if( offe == CsEXeNTRIES ) { LOGrAW( "sexC::sexC/registry is full\r\n" ) ; } //U: 20140605@1631: CONJ: THIS CAN HAPPEN IF EXIST MULTIPLE poolC INSTANCES OR IF EXIST MULTIPLE ADAMS (SEE osThreadAdamF)

                        }
                            grabot.ungrabF( tinP ) ;

                            }
                                }
                                    }
                                        break ;
                                        thirdC::c_strcpyIF( tinP , pe[ offe ].postName , pzMetaHead->postName ) ;
                                        pe[ offe ].cRef ++ ;
                                    {
                                    if( !pe[ offe ].cRef )
                                {
                                for( offe = 0 ; offe < CsEXeNTRIES ; offe ++ )
                            {
                            if( offe == CsEXeNTRIES )
                    
                            }
                                }
                                    break ;
                                    pe[ offe ].cRef ++ ;
                                {
                                if( !thirdC::c_strcmpIF( tinP , pe[ offe ].postName , pzMetaHead->postName ) )
                            {
                            for( offe = 0 ; offe < CsEXeNTRIES ; offe ++ )

                            grabot.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        ZE( countT , offe ) ;
                
                        sexGlobalEntryS* pe = (sexGlobalEntryS*)( pbNapkin + sizeof( grabotC ) ) ;
                        grabotC& grabot = *(grabotC*)pbNapkin ;
                    {
                    if( pbNapkin )
                    byteT* pbNapkin = processGlobal7I._sexC_napGlobalRegistry ;

                    }
                        countT foo = 2 ;
                    {
                    if( idIn == 23 )
                    countT idIn = 1 + incv02AM( idInLath ) ;
                    static countT idInLath ;
                {
                if( !thirdC::c_strstrIF( tinP , pzMetaHead->postName , postPOOLlEAKlOGGER ) )
                POOPIE
            {

            //------------------------------------------------------------------------------------------------------------------------------------------------------------
            // SPECIAL PROCESSING IF I AM PART OF THE poolC USED BY THE LEAKlOGGER ADAM
            //------------------------------------------------------------------------------------------------------------------------------------------------------------

            //}
            //    etherC::etRockIF( tinP ).traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
            //
            //    OStEXTAK( ostoSay , "\" " ) ;
            //    OStEXTA(  ostoSay , postNameP ) ;
            //    OStEXTAK( ostoSay , " \"" ) ;
            //    OStEXTCF( ostoSay , pbDataEnd , ' ' ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTCF( ostoSay , pbData , ' ' ) ;
            //    OStEXTA(  ostoSay , F(flagsState) & flSEXcsTATE_USINGnAPfORmETA ? " NAPKIN " : " pool   " ) ;
            //    OStEXTA(  ostoSay , F(flagsState) & flSEXcsTATE_USINGnAPfORdATA ? " NAPKIN " : " pool   " ) ;
            //    OStEXTC(  ostoSay , expSlotsP , ' ' ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , expCbDropP , ' ' ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , bRecursionCycle , ' ' ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , tinP.pAdamGlobal1->idAdam , ' ' ) ;
            //    OStEXTAK( ostoSay , "      sexC [idAdam,bRecursionCycle,expCbDrop,expSlots,n/p,pbData,pbDataEnd,postName]: " ) ;
            //    OStEXT(   ostoSay , TUCK << 2 ) ;
            //{

            //------------------------------------------------------------------------------------------------------------------------------------------------------------
            // DEBUGGING CHATTER
            //------------------------------------------------------------------------------------------------------------------------------------------------------------

            formatDataBlobF( tinP ) ; //NO ACTION IS NEEDED HERE TO PRESERVE STATE WHEN STATE FILE IS USED, SINCE THE FORMATTING INFORMATION IS ONLY USED TO DETECT MEMORY CORRUPTION SO NEED NOT BE SAVED AS STATE

            //------------------------------------------------------------------------------------------------------------------------------------------------------------
            // FORMAT pbData: ORIGINALLY, pbData WAS NOT FORMATTED.  FORMATTING WAS ADDED (20210128@1831) ONLY SO THAT MEMORY CORRUPTION CAN BE DETECTED.  THE FORMATTING INFORMATION IS NOT NEEDED FOR ANY OTHER PURPOSE.
            //------------------------------------------------------------------------------------------------------------------------------------------------------------

            }
                }
                    if( F(flagsState) & flSEXcsTATE_USINGnAPfORmETA && !( F(((napkinC*)pb_napMeta)->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) ) ((napkinC*)pb_napMeta)->formattingIsDoneF( tinP ) ;

                    }
                        }
                            countT foo = 2 ;
                        {
                        if( idIn == 2 )
                        countT idIn = 1 + incv02AM( idInLath ) ;
                        static countT idInLath ;
                    {
                    if( expCbDropP == 0x9 && expSlotsP == 8 )
            
                    }
                        __( expSlotsP  - pzMetaHead->expSlots  ) ;
                        __( expCbDropP - pzMetaHead->expCbDrop ) ;
                    {
                    else
                    }
                        if( pzMetaNote ) thirdC::c_memsetIF( tinP , (byteT*)pzMetaNote , sizeof( dropNoteS ) << pzMetaHead->expSlots ) ;
            
                        }
                            for( countT offo = 0 ; offo < cSlots ; offo ++ ) pzMetaNote[ offo ].idDelLath = pzMetaNote[ offo ].idNewLath = 0 ;
                            countT cSlots = 1 << pzMetaHead->expSlots ;
                        {
                        if( pzMetaNote )
            
                        }
                            while( cToDo -- ) btsLathAM( pbzMetaBitsOwned , 1 << pzMetaHead->expSlots ) ;
                            cToDo = pzMetaHead->cSlotsAvoidHi ;                                         // THE HIGH SLOTS ARE UNUSEABLE TO ENSURE HEADROOM OF sizeof( countT ) - 1 SO THAT HIGHEST BYTE CAN BE REFERENCED BY DWORD INSTRUCTION (E.G. movsd)
            
                            while( cToDo -- ) btsWothAM( pbzMetaBitsOwned , 1 << pzMetaHead->expSlots ) ;
                            countT cToDo = pzMetaHead->cSlotsAvoidLo ;                                  // THE LOW SLOTS ARE UNUSEABLE BECAUSE THEY OVERLAY napkinHeaderS FOR (*(napkinC*)pb_napData)
                                                                                                    // FOR SMALL SLOT SIZES (LESS THAN ALLOCATION GRAIN SIZE):
                        {
                        if( F(flagsState) & flSEXcsTATE_USINGnAPfORdATA )

                        // THIS DOES NOT HAVE TO BE DONE IF pbData WAS ALLOCATED USING THE POOL BECAUSE HEADROOM WAS CREATED WHEN THAT sexC WAS CONSTRUCTED
                        // IF DATA IS IN NAPKIN THEN MARK THE HIGH SLOTS AS UNUSEABLE SO THAT THERE IS ENOUGH HEADROOM FOR THE HIGHEST BYTE TO BE ACCESSED USING A DWORD INSTRUCTION
                        // 
                        // THIS DOES NOT HAVE TO BE DONE IF pbData WAS ALLOCATED USING THE POOL BECAUSE THERE IS NO OVERLAYED napkinC HEADER TO PROTECT
                        // IF DATA IS IN NAPKIN THEN MARK THE LOW SLOTS AS UNUSEABLE SO THAT THE DATA NAPKIN HEADER, WHICH THEY OVERLAY FOR SMALL SLOT SIZES, WON'T BE TRASHED

                        thirdC::c_memsetIF( tinP , pbzMetaBitsOwned , cbaBitsOwned ) ;
                    {
                    if( bFormat )
            
                    if( F(flagsCt) & fliSEXc_NOTES ) pzMetaNote = (dropNoteS*)( pbzMetaBitsOwned + cbaBitsOwned ) ;
            
                    cbaBitsOwned += CBtOaLIGN02( pbzMetaBitsOwned + cbaBitsOwned ) ;
                    countT cbaBitsOwned = 1 + ( 1 << expSlotsP ) / SB ;
            
                    pbzMetaBitsOwned = (byteT*)( pzMetaHead + 1 ) ;
            
                    __( flagsCt - pzMetaHead->flagsCtCopy ) ;

                    inc02AM( pzMetaHead->cRef ) ;
                    }
                        //CONoUTrAWd( "[expCbDrop,expSlots,bSmallSlots,USINGnAPfORdATA,cSlotsAvoidLo,cSlotsAvoidHi]: " , expCbDropP , " " , expSlotsP , " " , bSmallSlots , " " , !!( F(flagsState) & flSEXcsTATE_USINGnAPfORdATA ) , " " , pzMetaHead->cSlotsAvoidLo , " " , pzMetaHead->cSlotsAvoidHi , "\r\n" ) ; //U:: TO FIND A BUG

                        }
                            *(countT*)&pzMetaHead->cSlotsAvoidHi = 1 + ( sizeof( countT        ) - 2 ) / cbSlot ; // HEADROOM: sizeof( countT ) - 1 (ALWAYS 1 NOW THAT DROPhEADER IS USED; THIS LINE IS CODED GENERALLY TO WORK EVEN IF !( CBsEXdROPsEPARATOR + CBsEXdROPhEADER ))
                            *(countT*)&pzMetaHead->cSlotsAvoidLo = 1 + ( sizeof( napkinHeaderS ) - 1 ) / cbSlot ; // SOME PART OF NAPKIN HEADER IS UNDER THIS MANY SLOTS
                            countT cbSlot = ( CBsEXdROPsEPARATOR + CBsEXdROPhEADER ) + ( 1 << expCbDropP ) ;
                        {
                        if( F(flagsState) & flSEXcsTATE_USINGnAPfORdATA && bSmallSlots )

                        //CONoUTrAW9( "sexC formatting meta [USINGnAPfORdATA,bSmallSlots,expCbDropP,expSlotsP,]: " , !!( F(flagsState) & flSEXcsTATE_USINGnAPfORdATA ) , " " , bSmallSlots , " " , expCbDropP , " " , expSlotsP , "\r\n" ) ;

                        pzMetaHead = new( 0 , tinP , pbMeta , sizeof( sexHeadS ) ) sexHeadS( tinP , expCbDropP , expSlotsP , postNameP , flagsCt ) ;
                    {
                    else
                    if( !bFormat ) pzMetaHead = (sexHeadS*)pbMeta ;
                
                    ;
                                    : 1                                                                                 // ELSE FORMAT
                                    ? 0                                                                                 // THEN DO NOT FORMAT
                                : ((fileC*)pbFileMeta)->idOpenResultF( tinP  ) == ifcOPENrESULT_EXISTED                 // ELSE DID MY BACKING FILE ALREADY EXIST?
                                ? 1                                                                                     // THEN FORMAT
                            : !( F(flagsCt) & fliSEXc_MAPPEDtOdISK )                                                    // ELSE AM I STATELESS (NOT BACKED BY A DISK FILE)?
                            ? 0                                                                                         // THEN DO NOT FORMAT
                        : F(((napkinC*)pb_napMeta)->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED        // ELSE DID NAPKIN ALREADY EXIST?
                        ? 1                                                                                             // THEN FORMAT
                    const boolT bFormat = !( F(flagsState) & flSEXcsTATE_USINGnAPfORmETA )                                 // WAS LIST ALLOCATED FROM POOL?
                {
                else
                }
                    __( !( F(flagsCt) & fliSEXc_BROWSE ) ) ;
                {
                if( !pbMeta )
            {

            //------------------------------------------------------------------------------------------------------------------------------------------------------------
            // FORMAT pbMeta
            //------------------------------------------------------------------------------------------------------------------------------------------------------------

            __( !pbData ) ; //REDUNDANT BECAUSE ctNap???F WILL FAIL
            __( !pbMeta ) ; //REDUNDANT BECAUSE ctNap???F WILL FAIL

            }
                BLAMMO ; //U::PROVISIONAL: WITHOUT THIS, APP WILL STOP, AND SINCE I PRESUME TO BE HERE DUE TO A LEAK, IT'S BETTER TO BLAMMO

                //etRock.traceF( tinP , T("sexC::sexC: called  poolC::reportF; now calling BLAMMO") ) ;
                //pPoolContainsMe->reportF( tinP , *tinP.pEther ) ;
                //etRock.traceF( tinP , T("sexC::sexC: calling poolC::reportF") ) ;
                //etRock.traceF( tinP , T("sexC::sexC: could not allocate pbMeta for a poolC [expCbDropP,expSlotsP,idLineNewP,idiFileNewP]: ")+TF2(expCbDropP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(expSlotsP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF4(idLineNewP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(" ")+TF2(idiFileNewP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN) ) ;

                etRock.traceF( tinP , T("sexC::sexC: traced  pool tallies and memory grain report; now calling BLAMMO") ) ;
                etRock.traceMemoryGrainRptF( tinP ) ;
                etRock.tracePoolTalliesF( tinP ) ;
                etRock.traceF( tinP , T("sexC::sexC: tracing pool tallies and memory grain report") ) ;
                etRock.traceF( tinP , T("sexC::sexC: could not allocate pbMeta for a poolC [expCbDropP,expSlotsP,idLineNewP,idiFileNewP]: ")+TF2(expCbDropP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(expSlotsP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF4(idLineNewP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(" ")+TF2(idiFileNewP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN) ) ;

                etherC& etRock = etherC::etRockIF( tinP ) ;
            {
            if( !pbMeta && pPoolContainsMe )
            //CS: CODEsYNC: PSEUDODUPLICATE: 360e0003 360e0003

            }
                pbMetaEnd = pbMeta + cbaMeta ;
                pbMeta    = *(napkinC*)pb_napMeta ;

                ) ;
                    F(flagsP) & (fliSEXc_BROWSE|fliSEXc_READoNLY) ? ifcOPENsHAREDmEMORYhOW_nFeO : ifcOPENsHAREDmEMORYhOW_nCeO , /*tinP.pAdamGlobal1->idMemorySpace == ifcIDmEMORYsPACE_APPLICATION ? flNAPKINc_LOCK :*/ flNAPKINc_null , 1 , idMemorySpaceP
                    cbaMeta ,
                    ) ,
                            : (const handleC*)*(fileC*)pbFileMeta
                            ? 0
                        !idStateSpaceP
                    (
                    ) ,
                        )
                            tinP.pbF( 4 )
                            ) ,
                                "."
                                ) ,
                                    tinP.pbF( 3 )
                                    ) ,
                                        "."
                                        ) ,
                                            tinP.pbF( 2 )
                                            ) ,
                                                "."
                                                ) ,
                                                    postNameP
                                                    ) ,
                                                        tinP , tinP.pbF() , "sexC/meta/"
                                                    (
                                                    thirdC::c_strcpyIF
                                                    tinP ,
                                                (
                                                thirdC::c_strcatIF
                                                tinP ,
                                            (
                                            thirdC::c_strcatIF
                                            tinP ,
                                        (
                                        thirdC::c_strcatIF
                                        tinP ,
                                    (
                                    thirdC::c_strcatIF
                                    tinP ,
                                (
                                thirdC::c_strcatIF
                                tinP ,
                            (
                            thirdC::c_strcatIF
                            tinP ,
                        (
                        thirdC::c_strcatIF
                    (
                    tinP , idLineNewP , idiFileNewP , pbBitsCtP ,
                (
                new( 0 , tinP , pb_napMeta , sizeof pb_napMeta ) napkinC
                flagsState |= flSEXcsTATE_USINGnAPfORmETA ;

                if( bObeyReg && bMetaPool ) { BLAMMO ; }
            {
            if( !pbMeta )

            //------------------------------------------------------------------------------------------------------------------------------------------------------------
            // IF COULD NOT, THEN ALLOCATE pbMeta USING A napkinC TO OBTAIN A MEMORY ALLOCATION FROM THE BASE O.S.
            //------------------------------------------------------------------------------------------------------------------------------------------------------------
        {
        else
        }
            //U::DELETE THE BLOB THAT I JUST ALLOCATED
        {
        if( POOP )

        //SUPPRESSED WITHOUT ANALYSIS TO GET CORRECT FUNCTION FOR OO PROCESSES ACCESSING THE SAME PERSISTENT POOL: if( pPoolContainsMe ) { __NZ( pReg->pbSexBitFormatted[ offSexByte ] & maskSexByte ) ; } // BECOME IMPOTENT IF I JUST RECURSIVELY CALLED MYSELF FOR THE SAME SPECIFICATIONS: 20171012@1227

        }
            THREADmODE2rESTORE
            }
                if( !bObeyReg && pReg && !( pReg->pbSexBitFormatted[ offSexByte ] & maskSexByte ) && btsAM( pReg->pbSexBitMetaIsInPool , offSexBit ) ) { BLAMMO ; }

                }
                    }
                        }
                            DELlIST( fieldEditParamOutC , pOut ) ;
                            puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                        {

                        }
                            }
                                pbMetaEnd = pbMeta + cbaMeta ;
                                pbMeta    = (byteT*)(const osTextT*)pOut->vspBlob ;
                            {
                            if( !POOP )
                            __NZ( pOut->pNext ) ;
                        {
                        if( !POOP )
                        __Z( pOut ) ;
            
                        THREADmODE3rESTORE
                        flagsT flagsRC = listC::fieldIF( tinP , pOut , hListSex , pczField , _1_modePushIfNotExistC() + _1_pushC( 0 , cbaMeta ) + _1_modeQueryNewC() + _1_queryC() , idLineNewP , idiFileNewP , flLISToPEN_null , ifcIDgRABlAYER_8POOL5nEW) ;
                        THREADmODE3oN( flTHREADmODE3_DOnOTmAKEsEXiNpOOL )
                        ZE( fieldEditParamOutC* , pOut ) ;
            
                        listC::openIF( tinP , hListSex , pczListSex , flLISToPEN_null , ifcIDgRABlAYER_8POOL5nEW) ;
                        handleC hListSex( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                    {
                    if( ( 1 << expCbDropP != sizeof( listC ) || bListsExist ) ) // CREATION OF THE RECORD AND THE FIELD listC WOULD REQUIRE ME
            
                    }
                        if( ~hListField ) bListsExist = 1 ;
                        listC::openIF( tinP , hListField , hListSex , pczField , flLISToPEN_IFeXISTS , ifcIDgRABlAYER_8POOL5nEW) ;
                        handleC hListField( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                    {
                    if( ~hListSex )
                    listC::openIF( tinP , hListSex , pczListSex , flLISToPEN_IFeXISTS , ifcIDgRABlAYER_8POOL5nEW) ;
                    handleC hListSex( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                {
                ZE( boolT , bListsExist ) ;
            
                grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
            
                countT pczField[]   = { ifcIDrECORDfIELD_SEXcbACKINGbLOBlIST , 0 } ;
            
                puseC puseUse( tinP , *pPoolContainsMe ) ;
            {
            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
        
            // ALLOCATE pbMeta FROM *pPoolContainsMe TO AVOID THE OVERHEAD OF USING A napkinC AND ESCAPE THE BASE O.S. ALLOCATION GRAIN MINIMUM AND MINIMIZE ADDRESS SPACE FRAGMENTATION

            if( bObeyReg && !bMetaPool ) { BLAMMO ; }
        {
        )
            )
                )
                    !( F(tinP.flagsThreadMode3) & flTHREADmODE3_DOnOTmAKEsEXiNpOOL )
                    &&
                    // !( F(flagsCt) & fliSEXc_BROWSE )
                    // &&
                    pPoolContainsMe
                    &&
                    !bObeyReg
                (
                ||
                ( bObeyReg && bMetaPool )
            (
            &&
            pPoolContainsMe
            &&
            bEnableNesting
        (
        if

        //------------------------------------------------------------------------------------------------------------------------------------------------------------
        // TRY TO ALLOCATE pbMeta FROM A SIBLING sexC (ANOTHER sexC, EXISTING OR NEWLY CREATED, OF *pPoolContainsMe
        //------------------------------------------------------------------------------------------------------------------------------------------------------------

        }
            BLAMMO ; //U::PROVISIONAL: WITHOUT THIS, APP WILL STOP, AND SINCE I PRESUME TO BE HERE DUE TO A LEAK, IT'S BETTER TO BLAMMO

            //etRock.traceF( tinP , T("sexC::sexC: called  poolC::reportF; now calling BLAMMO") ) ;
            //pPoolContainsMe->reportF( tinP , *tinP.pEther ) ;
            //etRock.traceF( tinP , T("sexC::sexC: calling poolC::reportF") ) ;
            //etRock.traceF( tinP , T("sexC::sexC: could not allocate pbData for a poolC [expCbDropP,expSlotsP,idLineNewP,idiFileNewP]: ")+TF2(expCbDropP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(expSlotsP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF4(idLineNewP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(" ")+TF2(idiFileNewP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN) ) ;

            etRock.traceF( tinP , T("sexC::sexC: traced  pool tallies; now calling BLAMMO") ) ;
            etRock.tracePoolTalliesF( tinP ) ;
            etRock.traceF( tinP , T("sexC::sexC: tracing pool tallies") ) ;
            etRock.traceF( tinP , T("sexC::sexC: could not allocate pbData for a poolC [expCbDropP,expSlotsP,idLineNewP,idiFileNewP]: ")+TF2(expCbDropP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(expSlotsP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF4(idLineNewP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(" ")+TF2(idiFileNewP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN) ) ;

            etherC& etRock = etherC::etRockIF( tinP ) ;
        {
        if( !pbData && pPoolContainsMe )
        //CS: CODEsYNC: PSEUDODUPLICATE: 360e0003 360e0003

        pbDataEnd = !pbData ? 0 : pbData + ( ( CBsEXdROPsEPARATOR + CBsEXdROPhEADER ) + ( 1 << expCbDropP ) ) * ( 1 << expSlotsP ) ;

        }
            }
                if( pbData && !( F(((napkinC*)pb_napData)->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) ) ((napkinC*)pb_napData)->formattingIsDoneF( tinP ) ;
            {

            if( pbData && bSmallSlots ) pbData -= sizeof( napkinHeaderS ) ;
            pbData  = *(napkinC*)pb_napData ;

            }
                countT foo = 2 ;
            {
            if( expCbDropP == 0xe && expSlotsP == 0x3 ) //DT

            }
                countT foo = 2 ;
            {
            if( expCbDropP == 0x10 && expSlotsP == 0x1 ) //CT

            }
                ) ;
                    F(flagsP) & (fliSEXc_BROWSE|fliSEXc_READoNLY) ? ifcOPENsHAREDmEMORYhOW_nFeO : ifcOPENsHAREDmEMORYhOW_nCeO , /*tinP.pAdamGlobal1->idMemorySpace == ifcIDmEMORYsPACE_APPLICATION && expCbDropP + expSlotsP <= 0x14 ? flNAPKINc_LOCK :*/ flNAPKINc_null , 1 , idMemorySpaceP
                    cbaDataNapkin ,
                    ) ,
                            : (const handleC*)*(fileC*)pbFileData
                            ? 0
                        !idStateSpaceP
                    (
                    ) ,
                        tinP.pbF( 4 )
                        ) ,
                            "."
                            ) ,
                                tinP.pbF( 3 )
                                ) ,
                                    "."
                                    ) ,
                                        tinP.pbF( 2 )
                                        ) ,
                                            "."
                                            ) ,
                                                postNameP
                                                ) ,
                                                    tinP , tinP.pbF() , "sexC/data/"
                                                (
                                                thirdC::c_strcpyIF
                                                tinP ,
                                            (
                                            thirdC::c_strcatIF
                                            tinP ,
                                        (
                                        thirdC::c_strcatIF
                                        tinP ,
                                    (
                                    thirdC::c_strcatIF
                                    tinP ,
                                (
                                thirdC::c_strcatIF
                                tinP ,
                            (
                            thirdC::c_strcatIF
                            tinP ,
                        (
                        thirdC::c_strcatIF
                        tinP ,
                    (
                    thirdC::c_strcatIF
                    idLineNewP , idiFileNewP , pbBitsCtP ,
                    ) ,
                        tinP
                    (
                (
                new( 0 , tinP , pb_napData , sizeof pb_napData ) napkinC
            {

            flagsState |= flSEXcsTATE_USINGnAPfORdATA ;
            // WHEN SLOT SIZE IS LARGE, DATA BEGINS IN THE NORMAL PLACE (AT THE END OF THE NAPKIN HEADER) AND ADDITIONAL BYTES ARE ALLOCATED FOR HEADROOM (SO THAT THE HIGHEST VALID BYTE CAN BE READ USING A DWORD OPERATION SUCH AS movsd)
            // WHEN SLOT SIZE IS SMALL, DATA OVERLAYS THE NAPKIN HEADER AND NO ADDITIONAL BYTES ARE ALLOCATED.  INSTEAD, THE LOWEST AND HIGHEST SLOTS ARE MARKED AS UNAVAILABLE; THIS IS DONE TO AVOID THE EXTRA ALLOCATION UNIT REQUIRED FOR THE NAPKIN HEADER AND THE HEADROOM BYTES.  THE SLOTS SACRIFICED OCCUPY LESS MEMORY THAN THE ALLOCATION UNIT WOULD

            if( bObeyReg && bDataPool ) { BLAMMO ; }
        {
        if( !pbData )

        //------------------------------------------------------------------------------------------------------------------------------------------------------------
        // IF COULD NOT, THEN ALLOCATE pbData USING A napkinC TO OBTAIN A MEMORY ALLOCATION FROM THE BASE O.S.
        //------------------------------------------------------------------------------------------------------------------------------------------------------------
    {
    else
    }
        //U::DELETE THE BLOB THAT I JUST ALLOCATED
    {
    if( POOP )

    //SUPPRESSED WITHOUT ANALYSIS TO GET CORRECT FUNCTION FOR OO PROCESSES ACCESSING THE SAME PERSISTENT POOL: if( pPoolContainsMe ) { __NZ( pReg->pbSexBitFormatted[ offSexByte ] & maskSexByte ) ; } // BECOME IMPOTENT IF I JUST RECURSIVELY CALLED MYSELF FOR THE SAME SPECIFICATIONS

    }
        THREADmODE2rESTORE
        }
            if( !bObeyReg && pReg && !( pReg->pbSexBitFormatted[ offSexByte ] & maskSexByte ) && btsAM( pReg->pbSexBitDataIsInPool , offSexBit ) ) { BLAMMO ; }

            }
                //DO THIS IN MY DESTRUCTOR BUT ONLY IF I AM THE ONLY CLIENT: listC::deleteIF( tinP, pczListSex ) ;
        
                }
                    }
                        DELlIST( fieldEditParamOutC , pOut ) ;
                        puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                    {

                    }
                        if( !POOP ) pbData = (byteT*)(const osTextT*)pOut->vspBlob ;
                        __NZ( pOut->pNext ) ;
                    {
                    if( !POOP )
                    __Z( pOut ) ;
        
                    THREADmODE3rESTORE
                    flagsT flagsRC = listC::fieldIF( tinP , pOut , hListSex2 , pczField , _1_modePushIfNotExistC() + _1_pushC( 0 , cbaDataPool ) + _1_modeQueryNewC() + _1_queryC() , idLineNewP , idiFileNewP , flLISToPEN_null , ifcIDgRABlAYER_8POOL5nEW ) ;
                    THREADmODE3oN( flTHREADmODE3_DOnOTmAKEsEXiNpOOL )
                    ZE( fieldEditParamOutC* , pOut ) ;
        
                    listC::openIF( tinP , hListSex2 , pczListSex , flLISToPEN_null , ifcIDgRABlAYER_8POOL5nEW ) ; //U::BUG: THE grabitC::ungrabF BLAMMO OCCURS WITHIN THIS CALL
                    handleC hListSex2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                {
                )
                    ( 1 << expCbDropP != sizeof( listC ) || bListsExist )           // CREATION OF THE RECORD AND THE FIELD listC WOULD REQUIRE ME
                (
                if

                }
                    }
                        if( ~hListField ) bListsExist = 1 ;
                        listC::openIF( tinP , hListField , hListSex1 , pczField , flLISToPEN_IFeXISTS , ifcIDgRABlAYER_8POOL5nEW ) ;
                        handleC hListField( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                    {
                    if( ~hListSex1 )
                    listC::openIF( tinP , hListSex1 , pczListSex , flLISToPEN_IFeXISTS , ifcIDgRABlAYER_8POOL5nEW ) ;
                    handleC hListSex1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                {
            {
            ZE( boolT , bListsExist ) ;

            TELL( "ss.0" ) ; //U:: TO FIND A BUG
            grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
            TELL( "ss.1" ) ; //U:: TO FIND A BUG
        
            countT pczField[]   = { ifcIDrECORDfIELD_SEXcbACKINGbLOBdATA , 0 } ;
        
            puseC puseUse( tinP , *pPoolContainsMe ) ;
        {
        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
    
        // ALLOCATE pbData FROM *pPoolContainsMe TO AVOID THE OVERHEAD OF USING A napkinC AND ESCAPE THE BASE O.S. ALLOCATION GRAIN MINIMUM AND MINIMIZE ADDRESS SPACE FRAGMENTATION
        if( bObeyReg && !bDataPool ) { BLAMMO ; }
    {
    )
        )
            )
                !( F(tinP.flagsThreadMode3) & flTHREADmODE3_DOnOTmAKEsEXiNpOOL )
                &&
                // !( F(flagsCt) & fliSEXc_BROWSE )
                // &&
                pPoolContainsMe
                &&
                !bObeyReg
            (
            ||
            ( bObeyReg && bDataPool )
        (
        &&
        pPoolContainsMe
        &&
        bEnableNesting
    (
    if

    bEnableNesting = 0 ; //U:: ENABLE THIS IN PRODUCTION ; THIS IS DISABLED ONLY TO UNCLUTTER THE OUTPUT FROM listC::chatterIF
    static boolT bEnableNesting = 1 ; // SET TO 1 IN PRODUCTION; SET TO 0 TO DISABLE USAGE OF listC NESTING ; THIS IS STATIC TO FACILITATE MANIPULATION IN DEBUGGER

    //------------------------------------------------------------------------------------------------------------------------------------------------------------
    // TRY TO ALLOCATE pbData FROM A SIBLING sexC (ANOTHER sexC, EXISTING OR NEWLY CREATED, OF *pPoolContainsMe
    //------------------------------------------------------------------------------------------------------------------------------------------------------------

    //U:: D WAS HERE

    tinP.tlsNewF( LF , TUCK ) ;
    tinP.tlsNewF( LF , 0x10 ) ;    thirdC::c_itoaIF( tinP , tinP.pbF() , 0x10 , idStateSpaceP ) ;
    tinP.tlsNewF( LF , 0x10 ) ;    thirdC::c_itoaIF( tinP , tinP.pbF() , 0x10 , expCbDropP ) ;
    tinP.tlsNewF( LF , 0x10 ) ;    thirdC::c_itoaIF( tinP , tinP.pbF() , 0x10 , expSlotsP ) ;
    //CS:CODEsYNC: 360e0003 360e0003

    //------------------------------------------------------------------------------------------------------------------------------------------------------------
    // BUT IT IS RETAINED BECAUSE IT AVOIDS THE USE OF *pPoolContainsMe, WHICH COULD TRIGGER NESTED CONSTRUCTION OF OTHER sexC
    // NOW THAT napkinC'S ARE CONDITIONALLY CONSTRUCTED IN THE BODY OF THE sexC CONSTRUCTOR, TLS IS NOT NEEDED FOR CODING CONVENIENCE
    // TLS (tinS::newF pbF delF) WAS ORIGINALLY USED FOR CODING CONVENIENCE WHEN napkinC'S WERE UNCONDITIONALLY CONSTRUCTED
    // ALLOCATE THREAD LOCAL STORAGE
    //------------------------------------------------------------------------------------------------------------------------------------------------------------

    if( bSetResetFormatting && btsAM( pReg->pbSexBitFormatting , offSexBit ) ) { BLAMMO ; }
    const boolT bSetResetFormatting = !bObeyReg && !bNested && pReg ;
    //U:: D NOW HERE

    }
        }
            }
                }
                    bMetaPool = !!( pReg->pbSexBitMetaIsInPool[ offSexByte ] & maskSexByte ) ;
                    bDataPool = !!( pReg->pbSexBitDataIsInPool[ offSexByte ] & maskSexByte ) ;

                    while( !( pReg->pbSexBitFormatted[ offSexByte ] & maskSexByte ) ) thirdC::dosSleepWinkIF( tinP ) ;
                {
                if( bObeyReg )

                decv8AM( pReg->pbSex_cQueue[ offSexBit ] ) ;

                }
                    btrAM( pReg->pbSexBitMetaIsInPool , offSexBit ) ;
                    btrAM( pReg->pbSexBitDataIsInPool , offSexBit ) ;
                {
                if( !bObeyReg )

                if( offRef && !bNested ) bObeyReg = 1 ;

                bNested = !!( pReg->pbSexBitFormatting[ offSexByte ] & maskSexByte ) ; // CT OF sexC FOR A GIVEN SPEC IS SERIALIZED WITHIN slotsC::newF, SO IF THE FORMATTING BIT IS SET I MUST HAVE CALLED MYSELF

                if( offRef == 0xff ) { BLAMMO ; } // OVERFLOW
                countT offRef = incv8AM( pReg->pbSex_cRef[ offSexBit ] ) ;

                THREADmODE1rESTORE
                }
                    }
                        ++ s ; thirdC::dosSleepWinkIF( tinP ) ;
                        decv8AM( pReg->pbSex_cQueue[ offSexBit ] ) ;
                    {
                    while( incv8AM( pReg->pbSex_cQueue[ offSexBit ] ) )
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                {
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            {
            else
            if( !pReg ) { BLAMMO ; }
        {
        if( !POOP )

        //SUPPRESSED WITHOUT ANALYSIS TO GET CORRECT FUNCTION FOR OO PROCESSES ACCESSING THE SAME PERSISTENT POOL: __NZ( pReg->pbSexBitFormatted[ offSexByte ] & maskSexByte ) ;

        }
            }
                break ;
                pReg = pRegs + offr ;
            {
            if( !thirdC::c_strcmpIF( tinP , pRegs[ offr ].postPoolName , postPoolName ) )
        {
        for( countT offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )

        const osTextT* postPoolName = pPoolContainsMe->postNameF( tinP ) ;
        poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;
        homeS& home = homeS::homeIF() ;
    {
    if( pPoolContainsMe )

    //U::A WAS HERE

    //------------------------------------------------------------------------------------------------------------------------------------------------------------
    // SET bObeyReg IFF I AM NOT THE WOTH REFERENCE TO THE BIT FOR THIS sexC SPECIFICATION
    //------------------------------------------------------------------------------------------------------------------------------------------------------------

    //U::B WAS HERE

    //U:: C WAS HERE

    //------------------------------------------------------------------------------------------------------------------------------------------------------------
    // SET UP FOR WORK
    //------------------------------------------------------------------------------------------------------------------------------------------------------------

    //------------------------------------------------------------------------------------------------------------------------------------------------------------
    // 
    // WILL DETECT THIS AND BECOME IMPOTENT.  THE CALLER MUST DETECT THIS AND DESTROY ME RATHER THAN USE ME.  "SPECIFICATIONS" MEANS "[expCbDrop,expSlots]"
    // THE CALLER MUST CAST ME TO (const poopC&) TO DISCOVER WHETHER I WAS CONSTRUCTED AOK.  IF SOMETHING THAT I DO CAUSES A sexC WITH THE SAME SPEC TO BE CT'D, I
    // 
    // EXACTLY DETERMINES WHETHER THE poolC ATTEMPTS ARE SUPPRESSED AND WHETHER THOSE CIRCUMSTANCES CAN BE REDUCED OR ELIMINATED.
    // AT THE TIME OF THIS WRITING, THE ENHANCED CODE APPEARS TO WORK, BUT HAS NOT BEEN TESTED AND IS NOT UNDERSTOOD.  IN PARTICULAR, I DO NOT UNDERSTAND WHAT
    // 
    // THE UNHAPPIEST OUTCOME IS THAT A NEW sexC IS CONSTRUCTED RECURSIVELY THAT GETS BOTH pbData AND pbMeta USING napkinC.
    // RECURSIVELY.  THAT RECURSION WILL ALWAYS USE napkinC.  (I THINK THAT THIS IS TRUE.  U::STUDY THE CURRENT CODE TO SEE WHEN IT SUPPRESSES THE poolC ATTEMPTS.)
    // THAT A sexC INSTANCE THAT HAS AN AVAILABLE SLOT HAPPENS TO ALREADY EXIST FOR THE PARTICULAR SLOT SIZE NEEDED.  IF NOT, THEN A sexC WILL BE CONSTRUCTED
    // TO REDUCE FRAGMENTATION, THIS CODE NOW ATTEMPTS TO OBTAIN MEMORY FROM *pPoolContainsMe FOR pbData AND pbMeta.  THE HAPPIEST OUTCOME FOR SUCH A REQUEST IS
    // 
    // SUFFICIENTLY LARGE CONTIGUOUS PIECE.
    // ACTUAL AVAILABLE MEMORY BEING FAR BELOW THEORETICAL.  (napkinC CONSTRUCTION WOULD FAIL EVEN IF TOTAL AVAILABLE MEMORY WAS SUFFICIENT IF THERE ISN'T A
    // THE RANDOM ON DEMAND CONSTRUCTION OF 004 (1024_9 I.E. 1K) BASE O.S. MEMORY ALLOCATIONS OF VARIOUS SIZES WOULD FRAGMENT THE ADDRESS SPACE, RESULTING IN
    // poolC USES "OO POWER EXPANSION" TO CONSTRUCT sexC ("SLOTS EXTENTS") ON DEMAND.  IN THEORY, 02 INSTANCES COULD BE CONSTRUCTED FOR EACH OF 02 SLOT SIZES.
    // 
    // EACH SLOT IS ASSOCIATED WITH A SINGLE BIT IN pbMeta.  IF THAT BIT IS 0, THE SLOT IS AVAILABLE; ELSE THE SLOT IS "OWNED" (OR "IN USE").
    // *pPoolContainsMe, THE POINTER VALUE THAT IS RETURNED POINTS TO THE BEGINNING OF WO OF THESE SLOTS.  (THE SLOT SELECTED IS ALWAYS THE HIGHEST AVAILABLE SLOT.)
    // pbData IS SIMPLY A SEQUENCE OF 1 << expSlotsP "SLOTS", EACH OF SIZE 1 << expCbDropP.  WHEN APPLICATION CODE USES THE new OPERATOR TO REQUEST MEMORY FROM
    // OO napkinC's.  THE ONLY UNUSUAL FEATURE OF THE CODE WAS THAT THREAD LOCAL STORAGE WAS USED TO CALCULATE THE CONSTRUCTION ARGUMENTS FOR THESE OO napkinC'S.
    // WHEN ORIGINALLY WRITTEN, MY JOB WAS SIMPLY TO ASK THE BASE O.S. TO ALLOCATE OO SHARED MEMORY BLOBS, pbData AND pbMeta.  THESE BLOBS WERE OBTAINED USING
    // 
    // INTRODUCTION AND OVERVIEW
    // 
    //------------------------------------------------------------------------------------------------------------------------------------------------------------

    // A:ASSUME: sizeof( sexHeadS ) IS INTEGRAL MULTIPLE OF sizeof( countT )
    // 
    // WHEN THE BIT FOR A SLOT IS SET, THAT SLOT IS MARKED AS "OWNED" ("IN USE")
    // 
    // pzMetaNote                                       sizeof( dropNoteS ) << expSlotsP        1 dropNoteS FOR EACH OF 1 << expSlotsP SLOTS
    // 
    //                                                  CBtOaLIGN02( cbMetaNeeded )             PADDING TO ALIGN pzMetaNote TO countT BOUNDARY
    // 
    // pbzMetaBitsOwned                                 cbMetaNeeded                            1 BIT FOR EACH OF 1 << expSlotsP SLOTS
    // 
    // pbMeta == pzMetaHead                             sizeof( sexHeadS )                      sexHeadS
    // 
    // ADDRESS                                          LENGTH                                  DESCRIPTION
    // 
    // META LAYOUT

    ;

        )
                :            sizeof( countT        ) - 1     // ADD HEADROOM SO THAT THE LATH BYTE CAN BE READ USING A DWORD (countT) INSTRUCTION ; SINCE THE DATA WILL BE AN INTEGRAL MULTIPLE OF THE ALLOCATION UNIT, THIS HEADROOM WILL CAUSE AN ENTIRE ALLOCATION UNIT (1 TOCK) (64K) TO BE OBTAINED JUST TO GET THESE 3 BYTES
                ? - (sCountT)sizeof( napkinHeaderS )         // SUBTRACT FOR napHeaderS SO THAT THE BYTES ALLOCATED BY napkinC WILL BE AN INTEGRAL MULTIPLE OF THE ALLOCATION UNIT ; THIS RESULTS IN THE napHeaderS OVERLAYING SOME LOW DATA SLOTS, WHICH IS WHY THE FORMATTING CODE MUST MARK THOSE SLOTS AS UNAVAILABLE ; THE FORMATTING CODE WILL ALSO MARK SOME HIGH SLOTS AS UNAVAILABLE, IN ORDER TO GUARANTEE HEADROOM FOR ACCESSING THE HIGHEST BYTE
            bSmallSlots
        (
        +
        cbaDataNeeded
        
    countT cbaDataNapkin =
    countT cbaDataPool   = cbaDataNeeded ;
    countT cbaDataNeeded = ( 1 << expSlotsP ) * ( ( CBsEXdROPsEPARATOR + CBsEXdROPhEADER ) + ( 1 << expCbDropP ) ) ;
    /*FOR SMALL expCbDropP, SLOTS AT BOTTOM ARE UNUSEABLE; SEE sexHeadS::cSlotsAvoidLo*/

    if( F(flagsCt) & fliSEXc_NOTES ) cbaMeta += sizeof( dropNoteS ) << expSlotsP ;
    countT cbaMeta = sizeof( sexHeadS ) + cbNeededForBits + CBtOaLIGN02( cbNeededForBits ) ;
    countT cbNeededForBits = 1 + ( 1 << expSlotsP ) / SB ;

    //CONoUTrAW7( "sexC [bSmallSlots,expCbDropP,expSlotsP]: " , bSmallSlots , " " , expCbDropP , " " , expSlotsP , "\r\n" ) ;

    boolT bSmallSlots = ( CBsEXdROPsEPARATOR + CBsEXdROPhEADER ) + ( 1 << expCbDropP ) < ( 1 << thirdC::os_expCbAllocationGrain_IF( tinP ) ) ; // FOR SMALL SLOT SIZES, pbData WILL POINT TO THE napkinHeaderS CONTROL STRUCTURE, WHICH IS WHY THE LOW SLOTS MUST BE MARKED AS UNAVAILABLE

    //CONoUTrAW3( "[expGrain]: " , thirdC::os_expCbAllocationGrain_IF( tinP ) , "\r\n" ) ;

    }
        countT foo = 2 ;
    {
    if( expCbDropP == 0x10 )

    //U:: C NOW HERE

    countT pczListSex[] = { LISTnAME_ROOT , LISTnAME_ROOTsYSTEM1 , LISTnAME_HANDhOLD , LISTnAME_SEXc , BM_HIGH | expCbDropP , BM_HIGH | expSlotsP , 0 } ;
    //U::B NOW HERE

    const byteT  maskSexByte = (byteT)( 1 << ( offSexBit % SB ) ) ;
    const countT offSexByte  =                 offSexBit / SB ;
    const countT offSexBit   = expCbDropP * CsLOTeXTENTS + expSlotsP ;
    ZE( poolRegistrationS* , pReg ) ;
    ZE( boolT , bMetaPool ) ;
    ZE( boolT , bDataPool ) ;
    ZE( boolT , bObeyReg  ) ;
    ZE( boolT , bNested   ) ;
    //U::A NOW HERE

    }
        if( !bNest2 ) tinP.fliSexCtPendingExpSlots  |= maskExpSlots  ;
        if( !bNest1 ) tinP.fliSexCtPendingExpCbDrop |= maskExpCbDrop ;

                               tinP.pSexLifoConstructing = this ;
        pSexLifoConstructing = tinP.pSexLifoConstructing ;
    {
    if( pPoolContainsMe )

    }
        }
            pSexc = pSexc->pSexLifoConstructing ;
            }
                break ;
                bRecursionCycle = 1 ;
            {
            if( pSexc == this )
        {
        while( pSexc )
        sexC* pSexc = tinP.pSexLifoConstructing ;
    {
    if( pPoolContainsMe )               // I AM MAINLY FOR USE WITHIN poolC ; BUT AN APPLICATION CAN CT ME (pPoolContainsMe MUST BE 0)

    ZE( boolT , bRecursionCycle ) ;

    _IO_

    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP

    boolT bNest2 = !pPoolContainsMe ? 0 : !!( tinP.fliSexCtPendingExpSlots  & maskExpSlots  ) ;
    boolT bNest1 = !pPoolContainsMe ? 0 : !!( tinP.fliSexCtPendingExpCbDrop & maskExpCbDrop ) ;
    const flagsT maskExpSlots  = 1 << expSlotsP  ;
    const flagsT maskExpCbDrop = 1 << expCbDropP ;                              //U::REMOVE UNNECESSARY AND/OR UNUSED SERIALIZATION SUPPORT sexC poolC FOR poolRegistrationS

    thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG
{
pSexLifoConstructed( 0 )
offFoundLath( - 1 ) ,
pSexLifoConstructing( 0 ) ,
pbDataEnd( 0 ) ,
pbData( 0 ) ,
pzMetaNote( 0 ) ,
pbzMetaBitsOwned( 0 ) ,
pzMetaHead( 0 ) ,
pbMeta( 0 ) ,
idLathNewDel( 0 ) ,
idStateSpace( idStateSpaceP ) ,
flagsState( flSEXcsTATE_null ) ,
) ,
            )
                flagsP | fliSEXc_MAPPEDtOdISK
                ,
                ctFilesF( tinP , postNameP , expCbDropP , expSlotsP , idStateSpaceP )
            (
        :
        ? flagsP
    !idStateSpaceP
(
flagsCt
pPoolContainsMe( pPoolContainsMeP ) ,
/*1*/sexC::sexC( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const countT idLineNewP , const countT idiFileNewP , const osTextT* const postNameP , const countT expCbDropP , const countT expSlotsP , const flagsT flagsP , const countT idStateSpaceP , countT idMemorySpaceP , poolC* const pPoolContainsMeP ) :/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

