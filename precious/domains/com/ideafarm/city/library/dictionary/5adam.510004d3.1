
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    OSsLEEPf( 0x40 ) ;
    ph->bGrab = 0 ;                                    //LETgO

    }
        }
            }
                cbc -= cbThis ;
                pbc += cbThis ;

                if( pbWrite == pbEnd ) pbWrite = pbBegin ;
                pbWrite += cbThis ;
                etThread.strokeF( tinP , T("out: ")+TF1(c2o.c2)+T(" (part)\r\n") ) ;
                ph->cbWritten = cbwNew ;
                etThread.memCopyF( tinP , pbWrite , pbc , cbThis ) ;
            {
            if( !ether )
            while( cbwNew - ph->cbRead > CBmONITORbUFFER && !ether ) OSsLEEPf( 0x0 ) ;
            countT cbwNew = ph->cbWritten + cbThis ;

            countT cbThis = cbc - cbOver ;
            countT cbOver = pbWrite + cbc - pbEnd ;
        {
        else
        }
            }
                etThread.strokeF( tinP , T("out: ")+TF1(c2o.c2)+T("\r\n") ) ;
                cbc = 0 ;
                ph->cbWritten = cbwNew ;
                etThread.memCopyF( tinP , pbWrite , pbc , cbc ) ;
            {
            if( !ether )
            while( cbwNew - ph->cbRead > CBmONITORbUFFER && !ether ) OSsLEEPf( 0x0 ) ;
    
            countT cbwNew = ph->cbWritten + cbc ;
        {
        if( !bSplit )
        boolT bSplit = pbWrite + cbc > pbEnd ;
    {
    while( cbc && !ether )

    while( ph->offNextWrite > CBmONITORbUFFER ) ph->offNextWrite -= CBmONITORbUFFER ; //FASTER THAN %
    ph->offNextWrite += cbc ;

    byteT* pbWrite = pbBegin + ph->offNextWrite ;

    while( setIfZeAM( ph->bGrab , 1 ) && !ether ) OSsLEEPf( 0 ) ;  //GRAB

    cbc = sizeof( countT ) + 5 ;
    pbc = postOut ;
    *(countT*)postOut = 5 ;
    if( postOut[ 8 ] == 'z' ) postOut[ 8 ] = 'a' ;
    postOut[ 8 ] ++ ;
    osTextT postOut[] = "....--->a" ;
    //U:: TO TEST ad4

    countT cbc = sizeof c2o ;
    const byteT* pbc = (byteT*)&c2o ; //"pbc" : "pb cursor"
    ++ c2o.c2 ;
{
while( !ether )
count2S c2o( sizeof( countT ) ) ; //ENSURES THAT cbd AND idOut ARE CONTIGUOUS

byteT* pbEnd   = pbBegin + CBmONITORbUFFER ;
byteT* pbBegin = (byteT*)ph + sizeof( napMonitorHeaderS ) ;
else if( napMonitor != cbMonitor ) { BLAMMO ; }
}
    napMonitor.formattingIsDoneF( tinP ) ;
    etThread.memSetF( tinP , (byteT*)ph , sizeof( napMonitorHeaderS ) ) ;
{
else if( !( F(napMonitor.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
if( !ph ) { BLAMMO ; }
napMonitorHeaderS* ph = (napMonitorHeaderS*)(byteT*)napMonitor ;
napkinC napMonitor( tinP , LF , (byteT*)bits , "napMonitor" , 0 , cbMonitor ) ;
bitsC bits( tinP , CbITSlIFI , 0 , 1 ) ;
const countT cbMonitor = sizeof( napMonitorHeaderS ) + CBmONITORbUFFER ;
BLAMMO ; //U:: FOR DEBUGGING, TO VERIFY THAT NO WO ACCESSES napMonitorG

TODO

/*1*/WAKEhIDE( "craft.monitor.write" )/*1*/
/**/
*/
before writing an entry, i will sleep until all bytes that i want to use have been read
the final blob will be split if necessary so that the last byte of the buffer is used
the napkin is simply a circular buffer of length prefixed blobs
multiple instances of me can write to a napkin, which can be read by a "monitor"
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

