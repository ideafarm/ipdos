
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        etThread.delF( tinP , psttFile ) ;

        DEL( prPosts ) ;
        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        etThread.strMakeF( tinP , prPosts , T("<p>\r\n")+tOut+T("\r\n") , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        ZE( pbRefC* , prPosts ) ;

        TN( tOut , "" ) ; tOut = tSaidTimeForeign+tb4+tSaidCountryCode+tb4+tSaidZipUse+tb4+tSaidIdSubscriber0+tb4+tSaidFirstName+tb4+tSaidLastName+T(":\r\n<br>\r\n")+tSaidSpeech ;

        }
            etThread.delF( tinP , psttSaidCountryCode ) ;
            tSaidCountryCode = T(psttSaidCountryCode) ;
            said >> psttSaidCountryCode ; ___( psttSaidCountryCode ) ;
            ZE( strokeS* , psttSaidCountryCode ) ;

            etThread.delF( tinP , psttSaidState ) ;
            said >> psttSaidState ; ___( psttSaidState ) ;
            ZE( strokeS* , psttSaidState ) ;

            etThread.delF( tinP , psttSaidCity ) ;
            said >> psttSaidCity ; ___( psttSaidCity ) ;
            ZE( strokeS* , psttSaidCity ) ;

            etThread.delF( tinP , psttSaidAddressStreet ) ;
            said >> psttSaidAddressStreet ; ___( psttSaidAddressStreet ) ;
            ZE( strokeS* , psttSaidAddressStreet ) ;

            said >> nnPeer ;
            nicNameC nnPeer ;

            etThread.delF( tinP , psttSaidNnPeer ) ;
            said >> psttSaidNnPeer ; ___( psttSaidNnPeer ) ;
            ZE( strokeS* , psttSaidNnPeer ) ;

            etThread.delF( tinP , psttSaidZipUse ) ;
            tSaidZipUse = T(psttSaidZipUse) ;
            said >> psttSaidZipUse ; ___( psttSaidZipUse ) ;
            ZE( strokeS* , psttSaidZipUse ) ;

            etThread.delF( tinP , psttSaidAddressName ) ;
            said >> psttSaidAddressName ; ___( psttSaidAddressName ) ;
            ZE( strokeS* , psttSaidAddressName ) ;

            etThread.delF( tinP , psttSaidLastName ) ;
            tSaidLastName = T(psttSaidLastName) ;
            said >> psttSaidLastName ; ___( psttSaidLastName ) ;
            ZE( strokeS* , psttSaidLastName ) ;

            etThread.delF( tinP , psttSaidFirstName ) ;
            tSaidFirstName = T(psttSaidFirstName) ;
            said >> psttSaidFirstName ; ___( psttSaidFirstName ) ;
            ZE( strokeS* , psttSaidFirstName ) ;

            etThread.delF( tinP , psttSaidPaypalPayerEmail ) ;
            said >> psttSaidPaypalPayerEmail ; ___( psttSaidPaypalPayerEmail ) ;
            ZE( strokeS* , psttSaidPaypalPayerEmail ) ;

            etThread.delF( tinP , psttSaidIdSubscriber0 ) ;
            tSaidIdSubscriber0 = T(psttSaidIdSubscriber0) ;
            said >> psttSaidIdSubscriber0 ; ___( psttSaidIdSubscriber0 ) ;
            ZE( strokeS* , psttSaidIdSubscriber0 ) ;

            etThread.delF( tinP , psttValueSpeech ) ;
            tSaidSpeech = T(psttValueSpeech) ;
            said >> psttValueSpeech ; ___( psttValueSpeech ) ;
            ZE( strokeS* , psttValueSpeech ) ;

            etThread.delF( tinP , psttTimeForeign ) ;
            tSaidTimeForeign = T(psttTimeForeign) ;
            said >> psttTimeForeign ; ___( psttTimeForeign ) ;
            ZE( strokeS* , psttTimeForeign ) ;

            said >> *(countT*)&timeS2 ;
            ZE( sCountT , timeS2 ) ;

            said >> timeS1 ;
            ZE( countT , timeS1 ) ;

            said >> idFormat ;
            ZE( countT , idFormat ) ;

            said >> finger ;
            ZE( countT , finger ) ;

            etThread.boxGetShadowF( tinP , said , psttFile ) ;
            soulC said( tinP , TAG( TAGiDnULL ) ) ;
        {
        TN( tSaidCountryCode , "" ) ;
        TN( tSaidZipUse , "" ) ;
        TN( tSaidLastName , "" ) ;
        TN( tSaidFirstName , "" ) ;
        TN( tSaidIdSubscriber0 , "" ) ;
        TN( tSaidSpeech , "" ) ;
        TN( tSaidTimeForeign , "" ) ;

        stFile >> psttFile ;
        ZE( strokeS* , psttFile ) ;
    {
    while( stFile )
    TN( tb4 , "    " ) ;

    }
        while( ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                if( !ids ) etThread.delF( tinP , psttFile ) ; //SHOULD BE IMPOSSIBLE
                stFile.sinkF( tinP , ids , psttFile , flSTACKsINK_UNIQUE|flSTACKsINK_REVERSE ) ;
                ZE( countT , ids ) ;

                etThread.strMakeF( tinP , psttFile , pInfo->psttIfoName ) ; ___( psttFile ) ;
                ZE( strokeS* , psttFile ) ;
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tPath , &pat ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        TN( tPattern , "" ) ; tPattern = T("said.table")+T(bSandbox?".sandbox.*":".live.*") ;
        TN( tPath , "////factory3/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said/" ) ;
    {
    stackC stFile( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS , ifcIDgRABlAYER_7BASEmISC1 ) ;

    }
        }
            THREADmODE1rESTORE

            etThread.boxPutF( tinP , T("smtp.mailgun.org[admin]/b42/smtp/")+tHost+T("@ideafarm.com/")+tToUse+T("//wo@ideafarm.com/ideafarm.factory.reports@gmail.com") , tBody ) ;

            ;
                : tSaidPaypalPayerEmail
                ? tEmailSandboxMe
            textC& tToUse = bSandbox
            TN( tEmailSandboxMe , "ideafarmcity@gmail.com" ) ;

            tBody += T("time:  ")+tTimeForeign+T("\r\n") ;
            tBody += T("\r\nreference:  ")+tShort+T("\r\n") ;

            tBody += T("your post:\r\n\r\n")+tValueSpeech+T("\r\n\r\n") ;

            ) ;

                "\r\n"
                "\r\n"
                "Subject: Wo'O's Table:  You just posted this on Wo'O's Table Talk.\r\n"

            TN( tBody ,

            }
                etThread.delF( tinP , psttFile ) ;
                etThread.delF( tinP , psttShort ) ;
                etThread.delF( tinP , psttnu ) ;
                tShort = T(psttShort) ;
                etThread.strBisectF( tinP , psttnu , psttShort , psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttnu ) ;

                etThread.traceF( tinP , T("wrote   ")+T(psttFile) ) ;
                etThread.boxPutUniqueF( tinP , psttFile , tFile , WS( said ) ) ; ___( psttFile ) ;
                ZE( strokeS* , psttFile ) ;

                TN( tFile , "" ) ; tFile = T("////factory3/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/said/said.table")+T(bSandbox?".sandbox.":".live.")+T("@1@")+T(".")+tHost ;
            {
            TN( tShort , "" ) ;

            }
                if( !tHost.csF( tinP ) ) tHost = T("factories") ;
                etThread.delF( tinP , psttHost ) ;
                else       tHost = T(psttHost) ;
                if( POOP ) { POOPR ; }
                tinP.pEtScratch->sockPsttHostF( tinP , psttHost ) ; ___( psttHost ) ;
                ZE( strokeS* , psttHost ) ;

                SCOOPS
            {
            IFsCRATCH
            TN( tHost , "" ) ;

            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            said << (strokeS*)tSaidAddressStatus ;
            said << (strokeS*)tSaidAddressZip ;
            said << (strokeS*)tSaidAddressCountry ;
            said << (strokeS*)tSaidAddressCountryCode ;
            said << (strokeS*)tSaidAddressState ;
            said << (strokeS*)tSaidAddressCity ;
            said << (strokeS*)tSaidAddressStreet ;
            said << nnPeerP ;                                   // FORMAT 2
            said << (strokeS*)tSaidNnPeer ;
            said << (strokeS*)tSaidZipUse ;
            said << (strokeS*)tSaidAddressName ;
            said << (strokeS*)tSaidLastName ;
            said << (strokeS*)tSaidFirstName ;
            said << (strokeS*)tSaidPaypalPayerEmail ;
            said << (strokeS*)tSaidIdSubscriber0 ;
            said << (strokeS*)tValueSpeech ;
            said << (strokeS*)tTimeForeign ;
            said << (countT)timeN2 ;
            said << timeN1 ;
            said << (countT)2 ;             // IDfORMAT
            said << finger ;
            soulC said( tinP , TAG( TAGiDnULL ) ) ;

            putNegAM( *(countT*)&finger , FINGERnEG_WOtABLEsAID ) ;
            ZE( countT , finger ) ;

            textC tTimeForeign( ifcIDtEXTgEN_TIMEnOWfOREIGN , tinP , TAG( TAGiDnULL ) ) ;

            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
        {
        else if( tValueSpeech.csF( tinP ) )
        }
            DEL( prPosts ) ;
            if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

            etThread.strMakeF( tinP , prPosts , T("The secret is wrong.") , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
            ZE( pbRefC* , prPosts ) ;
        {
        if( !bSecretIsOK )
    {
    if( subscriberIdTry )

    }
        DEL( prPosts ) ;
        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

        etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;

        ) ;

            "</form>\r\n"
            "<input id=\"submit\" name=\"submit\" type=\"submit\" value=\"Speak!\"/>\r\n"
            "<textarea id=\"speech\" name=\"speech\" rows=\"4\" cols=\"120\" maxlength=\"5000\">Be respectful and lawful.  What is said cannot be unsaid.</textarea>\r\n"
            "<label for=\"speech\">Speech (5000 characters max):</label>\r\n"
            "<input id=\"secret\" name=\"secret\" type=\"password\" value=\"\"/>\r\n"
            "<label for=\"secret\">Secret:</label>\r\n"
            "<input id=\"subscriberid\" name=\"subscriberid\" type=\"text\" value=\"\"/>\r\n"
            "<label for=\"subscriberid\">Subscriber ID:</label>\r\n"
            "ideafarm.com/talk\" id=\"newpost\" method=\"post\" name=\"mypost\">\r\n"
            
        tSay += T(
        if( bSandbox ) tSay += T("factory1." ) ;
        TN( tSay , "<form action=\"https://" ) ;
        ZE( pbRefC* , prPosts ) ;
    {

    }
        while( ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                etThread.delF( tinP , psttValueAddressStatus ) ;
                tSaidAddressStatus = T(psttValueAddressStatus) ;
                rec >> psttValueAddressStatus ; ___( psttValueAddressStatus ) ;
                ZE( strokeS* , psttValueAddressStatus ) ;

                etThread.delF( tinP , psttValueAddressZip ) ;
                tSaidAddressZip = T(psttValueAddressZip) ;
                rec >> psttValueAddressZip ; ___( psttValueAddressZip ) ;
                ZE( strokeS* , psttValueAddressZip ) ;

                etThread.delF( tinP , psttValueAddressCountry ) ;
                tSaidAddressCountry = T(psttValueAddressCountry) ;
                rec >> psttValueAddressCountry ; ___( psttValueAddressCountry ) ;
                ZE( strokeS* , psttValueAddressCountry ) ;

                etThread.delF( tinP , psttValueAddressCountryCode ) ;
                tSaidAddressCountryCode = T(psttValueAddressCountryCode) ;
                rec >> psttValueAddressCountryCode ; ___( psttValueAddressCountryCode ) ;
                ZE( strokeS* , psttValueAddressCountryCode ) ;

                etThread.delF( tinP , psttValueAddressState ) ;
                tSaidAddressState = T(psttValueAddressState) ;
                rec >> psttValueAddressState ; ___( psttValueAddressState ) ;
                ZE( strokeS* , psttValueAddressState ) ;

                etThread.delF( tinP , psttValueAddressCity ) ;
                tSaidAddressCity = T(psttValueAddressCity) ;
                rec >> psttValueAddressCity ; ___( psttValueAddressCity ) ;
                ZE( strokeS* , psttValueAddressCity ) ;

                etThread.delF( tinP , psttValueAddressStreet ) ;
                tSaidAddressStreet = T(psttValueAddressStreet) ;
                rec >> psttValueAddressStreet ; ___( psttValueAddressStreet ) ;
                ZE( strokeS* , psttValueAddressStreet ) ;

                etThread.delF( tinP , psttValueAddressName ) ;
                tSaidAddressName = T(psttValueAddressName) ;
                rec >> psttValueAddressName ; ___( psttValueAddressName ) ;
                ZE( strokeS* , psttValueAddressName ) ;

                etThread.delF( tinP , psttValueLastName ) ;
                tSaidLastName = T(psttValueLastName) ;
                rec >> psttValueLastName ; ___( psttValueLastName ) ;
                ZE( strokeS* , psttValueLastName ) ;

                etThread.delF( tinP , psttValueFirstName ) ;
                tSaidFirstName = T(psttValueFirstName) ;
                rec >> psttValueFirstName ; ___( psttValueFirstName ) ;
                ZE( strokeS* , psttValueFirstName ) ;

                }
                    etThread.traceF( tinP , T(bSecretIsOK?"secret is OK":"secret is NOT ok") ) ;
                    bSecretIsOK = secretTry == secret ;                 //U::DO THIS ONLY IF THIS RECORD IS NOT AN "UNSUBSCRIBE"
                {
                if( subscriberIdTry == idSubscriber )

                rec >> secret ;
                ZE( countT , secret ) ;

                etThread.traceF( tinP , T("[tSaidIdSubscriber0]:    ")+tSaidIdSubscriber0 ) ;

                tSaidIdSubscriber0 = TF4(((countT*)&idSubscriber)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x40) ;
                rec >> ((countT*)&idSubscriber)[ 1 ] ;
                rec >> ((countT*)&idSubscriber)[ 0 ] ;
                ZE( count04T , idSubscriber ) ;

                etThread.delF( tinP , psttValueTransId ) ;
                rec >> psttValueTransId ; ___( psttValueTransId ) ;
                ZE( strokeS* , psttValueTransId ) ;

                etThread.delF( tinP , psttValueTransType ) ;
                rec >> psttValueTransType ; ___( psttValueTransType ) ;
                ZE( strokeS* , psttValueTransType ) ;

                etThread.delF( tinP , psttValueRewardBox ) ;
                rec >> psttValueRewardBox ; ___( psttValueRewardBox ) ;
                ZE( strokeS* , psttValueRewardBox ) ;

                etThread.delF( tinP , psttValueRewardBoxHidden ) ;
                rec >> psttValueRewardBoxHidden ; ___( psttValueRewardBoxHidden ) ;
                ZE( strokeS* , psttValueRewardBoxHidden ) ;

                etThread.delF( tinP , psttZipUse ) ;
                tSaidZipUse = T(psttZipUse) ;
                rec >> psttZipUse ; ___( psttZipUse ) ;
                ZE( strokeS* , psttZipUse ) ;

                etThread.delF( tinP , psttValuePaypalPayerEmail ) ;
                tSaidPaypalPayerEmail = T(psttValuePaypalPayerEmail) ;
                rec >> psttValuePaypalPayerEmail ; ___( psttValuePaypalPayerEmail ) ;
                ZE( strokeS* , psttValuePaypalPayerEmail ) ;

                etThread.delF( tinP , psttNnPeer ) ;
                tSaidNnPeer = T(psttNnPeer) ;
                rec >> psttNnPeer ; ___( psttNnPeer ) ;
                ZE( strokeS* , psttNnPeer ) ;

                etThread.delF( tinP , psttAction ) ;
                rec >> psttAction ; ___( psttAction ) ;
                ZE( strokeS* , psttAction ) ;

                rec >> *(countT*)&timeS2 ;
                ZE( sCountT , timeS2 ) ;

                rec >> timeS1 ;
                ZE( countT , timeS1 ) ;

                rec >> idFormat ;
                ZE( countT , idFormat ) ;

                rec >> finger ;
                ZE( countT , finger ) ;

                etThread.boxGetShadowF( tinP , rec , pInfo->psttIfoName ) ;
                soulC rec( tinP , TAG( TAGiDnULL ) ) ;

                etThread.traceF( tinP , T("found 1:    ")+T(fn) ) ;
                fileNameC fn( tinP , etThread , pInfo->psttIfoName ) ;
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tPath , &pat ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        TN( tPattern , "subscription.table.live.*" ) ;
        TN( tPath , "////factory3/d/ideafarm.home.102/ephemeral/backed.up.daily/domains/com/ideafarm/wo.o.s.table/subscriptions/" ) ;
    {
    TN( tSaidAddressStatus      , "" ) ;
    TN( tSaidAddressZip         , "" ) ;
    TN( tSaidAddressCountry     , "" ) ;
    TN( tSaidAddressCountryCode , "" ) ;
    TN( tSaidAddressState       , "" ) ;
    TN( tSaidAddressCity        , "" ) ;
    TN( tSaidAddressStreet      , "" ) ;
    TN( tSaidAddressName        , "" ) ;
    TN( tSaidLastName           , "" ) ;
    TN( tSaidFirstName          , "" ) ;
    TN( tSaidIdSubscriber0      , "" ) ;
    TN( tSaidZipUse             , "" ) ;
    TN( tSaidPaypalPayerEmail   , "" ) ;
    TN( tSaidNnPeer             , "" ) ;
    ZE( boolT , bSecretIsOK ) ;
    //VALIDATE THE SECRET

    countT secretTry       = etThread.strDigitsToSCountF( tinP , tValueSecret       , 0x40 ) ;
    countT subscriberIdTry = etThread.strDigitsToSCountF( tinP , tValueSubscriberId , 0x40 ) ; //U:: THIS WILL ONLY WORK IF THE ID IS <= MAXCOUNTT

    etThread.traceF( tinP , tKeySpeech      +T(":    ")+tValueSpeech       ) ;
    etThread.traceF( tinP , tKeySecret      +T(":    ")+tValueSecret       ) ;
    etThread.traceF( tinP , tKeySubscriberId+T(":    ")+tValueSubscriberId ) ;

    }
        }
            if( !etThread.strCompareF( tinP , psttLeverKVP , *pptKey[ offk ] ) ) *pptValue[ offk ] = T((strokeS*)(countT)swKVP) ;
        {
        for( countT offk = 0 ; offk < sizeof pptKey / sizeof pptKey[ 0 ] ; offk ++ )

        //}
        //    DEL( prPosts ) ;
        //    if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;
        //    etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        //
        //    etThread.traceF( tinP , tSay ) ;
        //    TN( tSay , "" ) ; tSay = T("<p>\r\n")+T(psttLeverKVP)+T(":    ")+T((strokeS*)(countT)swKVP) ;
        //
        //    ZE( pbRefC* , prPosts ) ;
        //{

        psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swKVP.cFlavorsF( tinP ) ;

    } ;
        &tValueSpeech       ,
        &tValueSecret       ,
        &tValueSubscriberId ,
    {
    textC* pptValue[] =

    } ;
        &tKeySpeech       ,
        &tKeySecret       ,
        &tKeySubscriberId ,
    {
    textC* pptKey[] =

    TN( tValueSpeech       , "" ) ;
    TN( tValueSecret       , "" ) ;
    TN( tValueSubscriberId , "" ) ;

    TN( tKeySpeech       , "speech"       ) ;
    TN( tKeySecret       , "secret"       ) ;
    TN( tKeySubscriberId , "subscriberid" ) ;

    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

    }
        DEL( prPosts ) ;
        if( prPosts ) meP.pushSnipF( tinP , stBodyP , *prPosts ) ;

        etThread.strMakeF( tinP , prPosts , tSay , 0 , flSTRmAKE_PREFIXlENGTH ) ; ___( prPosts ) ;
        ZE( pbRefC* , prPosts ) ;

        ) ;

            "<p>\r\n"
            "At the moment, this is an honor system, so please be honorable.<p>\r\n"
            "Other modes of behavior will be welcome once the software is developed to accommodate multiple \"tables\" and prevent disruptive behavior.\r\n"
            "</center>\r\n"
            "<br>\r\n"
            "Please join in as if this is a \"dinner table conversation\", and you are my friend and guest.\r\n"
            "<br>\r\n"
            "Wo'O's Table Talk is being developed, and currently has only this single page.\r\n"
            "<p>\r\n"
            "This forum is a meeting or assembly.\r\n"
            "<br>\r\n"
            "Penal Code 403: Every person who... willfully disturbs or breaks up any assembly or meeting... is guilty of a misdemeanor.\r\n"
            "<center>\r\n"
            "<p>\r\n"
            "Policy:  Subscriptions of California residents will never be cancelled or disabled.\r\n"
            "However, disruptive behavior (behavior that threatens or silences others or is materially disorderly) will be prosecuted to the full extent of applicable law.\r\n"
            "You may post any speech that is protected by the First Amendment, including hate speech and nondisruptive heckling.\r\n"
            "By posting here, you agree and stipulate to California (Santa Clara County) and United States of America jurisdiction.\r\n"
            "<p>\r\n"
            "<h1>Wo'O's Table Talk:  An Open Public Forum</h1>\r\n"

        TN( tSay ,
    {

    meP.pushSnipF( tinP , stBodyP , ifcIDsNIPpREDEFINED_HEADrAW ) ;
{
/*1*/voidT talkCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttUrlP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

