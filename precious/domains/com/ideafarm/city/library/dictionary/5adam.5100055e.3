
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            //win.baton.ungrabF( tinP ) ;
            //hintF( tinP , etherP , cArgP , paramP.vtHintClockBanner , 0 ) ; //U::ELICITS HINT CORRUPTION
            //win.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
            //windowOldC& win = *thirdC::pWinRootIF() ;

            cblIdRowMax = R( sadamStateP.prs->rsc.mIdRowHot - 1.0 + sadamStateP.prs->rsc.mRowsHot ) ;
            cblIdColMax = R( sadamStateP.prs->rsc.mIdColHot - 1.0 + sadamStateP.prs->rsc.mColsHot ) ;
            cblIdRowMin = R( sadamStateP.prs->rsc.mIdRowHot ) ;
            cblIdColMin = R( sadamStateP.prs->rsc.mIdColHot ) ;
            cblIdEvent  = idEventP ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buClockBannerLabelCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            //win.baton.ungrabF( tinP ) ;
            hintF( tinP , etherP , cArgP , paramP.vtHintClockBanner ) ;
            //win.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
            //windowOldC& win = *thirdC::pWinRootIF() ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
        }
            break ;
            }
                cblIdEvent = 0 ;

                if( bInP && idEventP == cblIdEvent && idColP >= cblIdColMin && idColP <= cblIdColMax && idRowP >= cblIdRowMin && idRowP <= cblIdRowMax ) bInP = 0 ;

                sCountT idRowP =          pcNotesP[ 4 ] ;
                sCountT idColP =          pcNotesP[ 3 ] ;
                boolT&  bInP   = *(boolT*)pcNotesP[ 2 ] ;
            {
            if( pcNotesP && pcNotesP[ 0 ] == 1 && pcNotesP[ 1 ] >= 3 )
        {
        case ifcIDtYPEsTROKEcALLbACK_INoUTqUERY :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buClockBannerCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

sCountT cblIdRowMax ;
sCountT cblIdColMax ;
sCountT cblIdRowMin ;
sCountT cblIdColMin ;
countT  cblIdEvent ;
//A:ASSUME: FLYOVER NOTIFICATIONS ARE IN REVERSE RENDER ORDER
//USED ONLY BY buClockBannerCBF buClockBannerLabelCBF

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            //win.baton.ungrabF( tinP ) ;
            hintF( tinP , etherP , cArgP , paramP.vtHintClock , 0 ) ;
            //win.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
            //windowOldC& win = *thirdC::pWinRootIF() ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buClockCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullAimTiltF( tinP , angh , angv , angt ) ;
            measureT angt = - 1.0 + 2.0 * paramP.offHullAimtTick / paramP.cHullAimtTicks ;
            measureT angv = - 1.0 + 2.0 * paramP.offHullAimvTick / paramP.cHullAimvTicks ;
            measureT angh = - 1.0 + 2.0 * paramP.offHullAimhTick / paramP.cHullAimhTicks ;

            if( ++ paramP.offHullAimtTick >= paramP.cHullAimtTicks ) paramP.offHullAimtTick = 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("tilt to the right") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeTiltRightCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullAimTiltF( tinP , angh , angv , angt ) ;
            measureT angt = - 1.0 + 2.0 * paramP.offHullAimtTick / paramP.cHullAimtTicks ;
            measureT angv = - 1.0 + 2.0 * paramP.offHullAimvTick / paramP.cHullAimvTicks ;
            measureT angh = - 1.0 + 2.0 * paramP.offHullAimhTick / paramP.cHullAimhTicks ;

            if( -- paramP.offHullAimtTick == - 1 ) paramP.offHullAimtTick = paramP.cHullAimtTicks - 1 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("tilt to the left") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeTiltLeftCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullAimTiltF( tinP , angh , angv , angt ) ;
            measureT angt = - 1.0 + 2.0 * paramP.offHullAimtTick / paramP.cHullAimtTicks ;
            measureT angv = - 1.0 + 2.0 * paramP.offHullAimvTick / paramP.cHullAimvTicks ;
            measureT angh = - 1.0 + 2.0 * paramP.offHullAimhTick / paramP.cHullAimhTicks ;

            if( ++ paramP.offHullAimvTick >= paramP.cHullAimvTicks ) paramP.offHullAimvTick = 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("aim up") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeAimUpCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullAimTiltF( tinP , angh , angv , angt ) ;
            measureT angt = - 1.0 + 2.0 * paramP.offHullAimtTick / paramP.cHullAimtTicks ;
            measureT angv = - 1.0 + 2.0 * paramP.offHullAimvTick / paramP.cHullAimvTicks ;
            measureT angh = - 1.0 + 2.0 * paramP.offHullAimhTick / paramP.cHullAimhTicks ;

            if( -- paramP.offHullAimvTick == - 1 ) paramP.offHullAimvTick = paramP.cHullAimvTicks - 1 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("aim down") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeAimDownCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullAimTiltF( tinP , angh , angv , angt ) ;
            measureT angt = - 1.0 + 2.0 * paramP.offHullAimtTick / paramP.cHullAimtTicks ;
            measureT angv = - 1.0 + 2.0 * paramP.offHullAimvTick / paramP.cHullAimvTicks ;
            measureT angh = - 1.0 + 2.0 * paramP.offHullAimhTick / paramP.cHullAimhTicks ;

            if( ++ paramP.offHullAimhTick >= paramP.cHullAimhTicks ) paramP.offHullAimhTick = 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("aim to the right") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeAimRightCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullAimTiltF( tinP , angh , angv , angt ) ;
            measureT angt = - 1.0 + 2.0 * paramP.offHullAimtTick / paramP.cHullAimtTicks ;
            measureT angv = - 1.0 + 2.0 * paramP.offHullAimvTick / paramP.cHullAimvTicks ;
            measureT angh = - 1.0 + 2.0 * paramP.offHullAimhTick / paramP.cHullAimhTicks ;

            if( -- paramP.offHullAimhTick == - 1 ) paramP.offHullAimhTick = paramP.cHullAimhTicks - 1 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("aim to the left") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeAimLeftCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullAimTiltF( tinP , angh , angv , angt ) ;
            measureT angt = - 1.0 + 2.0 * paramP.offHullAimtTick / paramP.cHullAimtTicks ;
            measureT angv = - 1.0 + 2.0 * paramP.offHullAimvTick / paramP.cHullAimvTicks ;
            measureT angh = - 1.0 + 2.0 * paramP.offHullAimhTick / paramP.cHullAimhTicks ;
            paramP.offHullAimtTick = paramP.cHullAimtTicks / 2 ;
            paramP.offHullAimvTick = paramP.cHullAimvTicks / 2 + AIMtICKvERTbIASdEBUG ;
            paramP.offHullAimhTick = paramP.cHullAimhTicks / 2 + AIMtICKhORZbIASdEBUG ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("reset hull aim and tilt") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeAimTiltResetCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullLocationF( tinP , paramP.xHullAt , paramP.yHullAt , paramP.zHullAt ) ;
            paramP.zHullAt += paramP.zMoveGrain * paramP.zMoveMultiplier ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("move up (increase z)") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeMoveUpCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullLocationF( tinP , paramP.xHullAt , paramP.yHullAt , paramP.zHullAt ) ;
            paramP.zHullAt -= paramP.zMoveGrain * paramP.zMoveMultiplier ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("move down (decrease z)") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeMoveDownCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullLocationF( tinP , paramP.xHullAt , paramP.yHullAt , paramP.zHullAt ) ;
            paramP.yHullAt += paramP.yMoveGrain * paramP.yMoveMultiplier ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("move north (increase y)") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeMoveNorthCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullLocationF( tinP , paramP.xHullAt , paramP.yHullAt , paramP.zHullAt ) ;
            paramP.yHullAt -= paramP.yMoveGrain * paramP.yMoveMultiplier ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("move south (decrease y)") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeMoveSouthCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullLocationF( tinP , paramP.xHullAt , paramP.yHullAt , paramP.zHullAt ) ;
            paramP.xHullAt += paramP.xMoveGrain * paramP.xMoveMultiplier ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("move east (increase x)") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeMoveEastCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullLocationF( tinP , paramP.xHullAt , paramP.yHullAt , paramP.zHullAt ) ;
            paramP.xHullAt -= paramP.xMoveGrain * paramP.xMoveMultiplier ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("move west (decrease x)") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeMoveWestCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            hintEyeF( tinP , etherP , cArgP ) ;
            paramP.eye.setHullLocationF( tinP , paramP.xHullAt , paramP.yHullAt , paramP.zHullAt ) ;
            paramP.zHullAt = ZhULLaTiNIT ;
            paramP.yHullAt = YhULLaTiNIT ;
            paramP.xHullAt = XhULLaTiNIT ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("move to absolute origin") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeMoveResetCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            filterGrabMouseF( tinP , cArgP ) ;
            popButtonsF( tinP , etherP , cArgP ) ;
            paramP.flags &= ~( F(flPARAM_EYEbUTTONSrENDERED) ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;

            if( F(paramP.flags) & flPARAM_FULLsCREEN && paramP.idView == ifcIDvIEW_HUGE ) break ; // HOVER PAD FOR MOUSE SO MOUSE CAN BE USED TO AIM AND TILT
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("remove eye control buttons") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeEscapeCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            hintEyeF( tinP , etherP , cArgP ) ;
            filterGrabMouseF( tinP , cArgP ) ;
            paramP.flags |= flPARAM_EYEbUTTONSrENDERED ;
            pushButtonsF( tinP , etherP , cArgP , paramP.buEyeEscape+T(" ")+paramP.buEyeMoveReset+T(" ")+paramP.buEyeAimTiltReset+T(" ")+paramP.buEyeMoveWest+T(" ")+paramP.buEyeMoveEast+T(" ")+paramP.buEyeMoveSouth+T(" ")+paramP.buEyeMoveNorth+T(" ")+paramP.buEyeMoveDown+T(" ")+paramP.buEyeMoveUp+T(" ")+paramP.buEyeAimLeft+T(" ")+paramP.buEyeAimRight+T(" ")+paramP.buEyeAimDown+T(" ")+paramP.buEyeAimUp+T(" ")+paramP.buEyeTiltLeft+T(" ")+paramP.buEyeTiltRight , CSTTmINbUTTONS , T("IdeaFarm " "(tm) Eye") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("display eye control buttons") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEyeEnterCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            replaceButtonsF( tinP , etherP , cArgP , tButtons , CSTTmINbUTTONS , T("IPDOS (tm)  buttons") ) ;
            if(      paramP.treeKt.rightF( 1 , 1 ) ) tButtons += T(" ")+paramP.buClimbRight ;
            if(      paramP.treeKt.leftF(  1 , 1 ) ) tButtons += T(" ")+paramP.buClimbLeft  ;
            if( 2 == paramP.treeKt.upF(    2 , 1 ) ) tButtons += T(" ")+paramP.buClimbUp    ;
            if( 2 == paramP.treeKt.downF(  2 , 1 ) ) tButtons += T(" ")+paramP.buClimbDown  ;
            TN( tButtons , "" ) ; tButtons = paramP.buEscape+T(" ")+paramP.buF1/*+T(" ")+paramP.buF2*/+T(" ")+paramP.buSubscribe ;

            resizeIfF( tinP , cArgP , etherP ) ;
            paramP.treeKt.rightF() ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("climb right") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buClimbRightCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            replaceButtonsF( tinP , etherP , cArgP , tButtons , CSTTmINbUTTONS , T("IPDOS (tm)  buttons") ) ;
            if(      paramP.treeKt.rightF( 1 , 1 ) ) tButtons += T(" ")+paramP.buClimbRight ;
            if(      paramP.treeKt.leftF(  1 , 1 ) ) tButtons += T(" ")+paramP.buClimbLeft  ;
            if( 2 == paramP.treeKt.upF(    2 , 1 ) ) tButtons += T(" ")+paramP.buClimbUp    ;
            if( 2 == paramP.treeKt.downF(  2 , 1 ) ) tButtons += T(" ")+paramP.buClimbDown  ;
            TN( tButtons , "" ) ; tButtons = paramP.buEscape+T(" ")+paramP.buF1/*+T(" ")+paramP.buF2*/+T(" ")+paramP.buSubscribe ;

            resizeIfF( tinP , cArgP , etherP ) ;
            paramP.treeKt.leftF() ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("climb left") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buClimbLeftCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            }
                replaceButtonsF( tinP , etherP , cArgP , tButtons , CSTTmINbUTTONS , T("IPDOS (tm)  buttons") ) ;
                if(      paramP.treeKt.rightF( 1 , 1 ) ) tButtons += T(" ")+paramP.buClimbRight ;
                if(      paramP.treeKt.leftF(  1 , 1 ) ) tButtons += T(" ")+paramP.buClimbLeft  ;
                if( 2 == paramP.treeKt.upF(    2 , 1 ) ) tButtons += T(" ")+paramP.buClimbUp    ;
                if( 2 == paramP.treeKt.downF(  2 , 1 ) ) tButtons += T(" ")+paramP.buClimbDown  ;
                TN( tButtons , "" ) ; tButtons = paramP.buEscape+T(" ")+paramP.buF1/*+T(" ")+paramP.buF2*/+T(" ")+paramP.buSubscribe ;

                resizeIfF( tinP , cArgP , etherP ) ;
                paramP.treeKt.upF( 2 ) ;
            {
            if( 2 == paramP.treeKt.upF( 2 , 1 ) )

            if( paramP.b1tutorial ) paramP.b1tutorial = 0 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("climb up") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buClimbUpCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            doDownF( tinP , etherP , cArgP ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("climb down") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buClimbDownCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            }
                }
                    }
                        hintF( tinP , etherP , cArgP , tReply ) ;
                        TN( tReply , "" ) ; tReply = T("\"")+S2(ifcRGB_B4|ifcRGB_G3,scOld_cPUSHcOLOR)+T(psttValue)+S2(0,scOld_POPcOLOR)+T("\" is not the key.  please join us by subscribing at www.ideafarm.com") ;
                        strokeS*& psttValue = *(strokeS**)paramP.prPrompt ;
                    {
                    else
                    //else popButtonsF( tinP , etherP , cArgP ) ;
                    }
                        setFloorF( tinP , etherP , cArgP , ifcIDfLOOR_DISCLOSURE ) ;
                        paramP.bInside = 1 ; //U::CONJ: bInside IS OBSOLETED BY setFloorF

                        paramP.prPrompt.freshF( tinP ) ;
                        etherP.delF( tinP , psttValue ) ;
                    {
                    if( !etherP.strCompareF( tinP , paramP.ppsttLoginSecret[ paramP.offLoginSecret ] , psttValue ) )
                
                    strokeS*& psttValue = *(strokeS**)paramP.prPrompt ;
                {
                if( sttNew.idAdam == saA1_TOOLENTER || sttNew.idAdam == saA1_TOOLENTERnUM )
                strokeS sttNew = strokeS::strokeIF( tinP , idTool ) ;
            {
            if( idAction == ifcIDtYPEaCTION_DOWN )
            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_KEYBOARD :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("enter the key to the city gate (get it from a friend or by becoming a resident") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
        }
            break ;
            //U::WON'T COMPILE CAUSE pPulp IS PRIVATE: if( idIn == 1 ) sadamStateP.prs->rsc.pPaper->x1.pPulp.x1.back.filterKeepNormalKeysF( tinP , sadamStateP.ssc.idAdam , 1 ) ;
            //U::COMPLETE DEVELOPMENT OF FILTERING TO CONCEAL ARCHITECTURE BY ELIMINATING SPECIAL KEYS FROM APPEARING IN PROMPT SADAM
            countT idIn = 1 + incv02AM( idInLath ) ;
            static countT idInLath ;
        {
        case ifcIDtYPEsTROKEcALLbACK_RENDER :

    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT prPromptCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            etherP.osHttpViewF( tinP , T(postSay) , 1 ) ;

            //etherP.beeClickF( tinP , TUCK * ( 1 + etherC::ether_cUtility_IF( tinP ) ) ) ;
            //++ etherC::ether_cUtility_IF( tinP ) ; //U:: TO STUDY CPU LOADING BY freshVolatileTextIF

            if( paramP.bInside )                           postSay = postInsider ;
            const osTextT* postSay = postNormal ;

            const osTextT postInsider[]   = "ideafarm.com//http/index.html" ;
            const osTextT postFamily[]    = "ideafarm.com//http/index.html" ;
            const osTextT postAdSpecial[] = "ideafarm.com//http/index.html" ;
            const osTextT postNormal[]    = "ideafarm.com//http/index.html" ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("click here while online to become a resident and obtain each new secret key") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buSubscribeCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            //Beep( TUCK * ( 1 + paramP.offLoginSecret ) , TUCK ) ; //U::
            //LOGrAW( T("secret: \"")+T(paramP.ppsttLoginSecret[paramP.offLoginSecret])+T("\"\r\n") ) ; //U::

            setFloorF( tinP , etherP , cArgP , ifcIDfLOOR_PROMPTfORsECRET ) ;
            paramP.offLoginSecret = (tcButtonC*)sadamStateP.ssc.pOwner - &paramP.buLoginKey1 ;
            paramP.bQuitTmUsers = 1 ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("click your name to enter the gate") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buLoginKeyCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            setFloorF( tinP , etherP , cArgP , ifcIDfLOOR_USERS ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("click here to approach the city gate") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buGateCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            loadSpeechF( tinP , etherP , cArgP , ifcIDsPEECH_CREDITS ) ;
            hintF( tinP , etherP , cArgP , T("the credits will begin in a moment") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("derivative work, and other, credits") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buCreditsCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            loadSpeechF( tinP , etherP , cArgP , ifcIDsPEECH_SERMON ) ;
            hintF( tinP , etherP , cArgP , T("the \"Sermon on the Font\" will begin in a moment") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("Sermon on the Font") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buSermonCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            loadSpeechF( tinP , etherP , cArgP , ifcIDsPEECH_INTRODUCTION ) ;
            hintF( tinP , etherP , cArgP , T("the introduction will begin in a moment") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("introduction for new operators") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buIntroCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            SW
            SW etherP.strokeF( tinP , T("\f")+tConsole ) ;
            TN( tConsole , "" ) ;  setConsoleF( tinP , etherP , tConsole , cArgP ) ;

            paramP.vtView.setF( tinP , T("")+S2(1+incv02AM(paramP.idEventViewSelectLath),sc_NULL) ) ;

            hintF( tinP , etherP , cArgP , paramP.tHintDefault , 0 ) ;
            setTmLongF( tinP , paramP.tHintDefault ) ;

            paramP.stSpeech.ungrabF( tinP ) ;
            purgeSpeechF( tinP , etherP , cArgP ) ;
            paramP.stSpeech.grabF( tinP , TAG( TAGiDnULL ) ) ;

            paramP.rReachRemaining = 1.0 / 16.0 ;
            etherP.strMakeF( tinP , LF , paramP.psttLabelRemaining , T("CITY") ) ; ___( paramP.psttLabelRemaining ) ; //THIS IS DONE HERE BECAUSE TIME REMAINING CLOCK IS ALSO USED ON BANNER AND AT BANNER TIME THE NOTE SHOULD BE ""

            setFloorF( tinP , etherP , cArgP , ifcIDfLOOR_CONSOLE ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("IPDOS (tm) operator's console") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buConsoleCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            Beep( TUCK * 0x8 , TUCK ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("test button") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buTestCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            etherP.boxPutF( tinP , T("///d/ideafarm.home.")+TF1(etherC::ifc_idHomeIdisk_IF())+T(".setting.flag.secure") , "." , 1 ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("secure this public access computer") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buSecureCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            paramP.vt2bigitHelp.setF( tinP ) ;
            paramP.bGameStarted = 1 ;

            doDownF( tinP , etherP , cArgP ) ;

            }
                resizeIfF( tinP , cArgP , etherP ) ;
                filterGrabMouseF( tinP , cArgP ) ;
                paramP.idView = ifcIDvIEW_HUGE ;
            {
            if( paramP.idView != ifcIDvIEW_HUGE )
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("start the bigit game!") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buStartGameCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T(":") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buFcCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T(":") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buFbCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T(":") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buFaCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T(":") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buF9CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T(":") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buF8CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T(":") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buF7CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T(":") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buF6CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T(":") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buF5CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T(":") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buF4CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T(":") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buF3CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            SW
            SW etherP.strokeF( tinP , T("\f")+tConsole ) ;

            else                                       setConsoleF(           tinP , etherP , tConsole , cArgP ) ;
            if( F(paramP.flags) & flPARAM_FULLsCREEN ) setFullScreenConsoleF( tinP , etherP , tConsole , cArgP ) ;
            //vtButtonsF( tinP , etherP , cArgP ) ;
            TN( tConsole , "" ) ;

            filterGrabMouseF( tinP , cArgP ) ;
            else                                            paramP.flags &= ~( F(flPARAM_FULLsCREEN) ) ;
            if( !( F(paramP.flags) & flPARAM_FULLsCREEN ) ) paramP.flags |= flPARAM_FULLsCREEN ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("1: toggle full screen presentation of the knowledge tree") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buF2CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            resizeIfF( tinP , cArgP , etherP ) ;
            filterGrabMouseF( tinP , cArgP ) ;
            if( ++ paramP.idView > ifcIDvIEW_max ) paramP.idView = ifcIDvIEW_min ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("2: cycle through alternate knowledge tree presentation formats") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buF1CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;

            else                                                                                                   ((thirdC&)etherP).winShowWindowF( tinP , paramP.win , idcWINsHOW_HIDE ) ;
            else if( etherC::ifc_idHomeIdisk_IF() == 1 && IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 == etherP.diskIdF( tinP , T("///c") ) ) etherP.etherFireImpersonateMonitorIF( tinP ) ;
            if( paramP.idFloor > ifcIDfLOOR_BANNER )                                                               setFloorF( tinP , etherP , cArgP , 0 , flSETfLOOR_ESCAPE ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , paramP.psttHintEscape ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buEscapeCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            loadSpeechF( tinP , etherP , cArgP , ifcIDsPEECH_ACCEPTANCE ) ;
            hintF( tinP , etherP , cArgP , T("welcome.  your orientation will begin in a moment") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("please do not lie to me when clicking here") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buAgreeCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( tinP.fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
            loadSpeechF( tinP , etherP , cArgP , ifcIDsPEECH_REFUSAL ) ;
            hintF( tinP , etherP , cArgP , T("thank you for being honest with me") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            hintF( tinP , etherP , cArgP , T("please do not lie to me when clicking here") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buDisagreeCBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

#include postADAMhEADER

/*1*//*callbacks*//*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

