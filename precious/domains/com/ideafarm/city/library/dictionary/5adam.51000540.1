
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;

etThread.strokeF( tinP , tAll ) ;

}
    tAll += T("")+SADAM(pSoul)+//SCBA(scbF) ;
    *pSoul << (strokeS*)tv ;
    etThread( tinP , pSoul , TAG( TAGiDnULL ) ) ;
    ZE( soulC* , pSoul ) ;
    TN( tv , post2 ) ;
    osTextT post2[] = { posta[ off ] , 0 } ;
{
for( countT off = 0 ; off < sizeof posta - 1 ; off ++ )
TN( tAll , "" ) ;
//TOO EXPENSIVE: osTextT posta[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,./<>?;':\"[]\\{}|`~!@#$%^&*()-_=+" ;
osTextT posta[] = "abcdefgh" ;

{ sadamCBFT pf = scbF ; } //VERIFY TYPE

TODO

}
    return 0 ; //CONTINUE CALLING IN THE CURRENT SNIP
    wP.baton.ungrabF( tinP ) ;
    if( stInvalidP && c8scratchAdamP.c1 && c8scratchSnipP.c1 && c8scratchSnipAdamP.c1 && idSnipP && psttSnipP && idsP && c8scratchEventP.c1 && bNoDrawP && flagsP && wP.bDoomed ) ;
    
    }
        }
            break ;
            }
                }
                    }
                        break ;
                        }
                            }
                                break ;
                                etherP.beeClickF( tinP , idSnipP * 0x220 , TUCK * 0x80 ) ;
                                )
                                    idRow <= c8scratchStrokeP.c4
                                    idCol <= c8scratchStrokeP.c3 &&
                                    idRow >= c8scratchStrokeP.c2 &&
                                    idCol >= c8scratchStrokeP.c1 &&
                                (
                                if
            
                                //POPUPcOUNT( "idsP: " , idsP ) ;
                                //POPUPcOUNT( "idSnipP: " , idSnipP ) ;
                            {
                            case ifcIDtYPEtOOL_MOUSEbUTTONlEFT :
                        {
                        switch( idTool )
                    {
                    case ifcIDtYPEaCTION_DOWN :
                {
                switch( idAction )
            
                thirdC& third = etherP ;
                const countT& idRow    = pcNotesP[ 5 ] ;
                const countT& idCol    = pcNotesP[ 4 ] ;
                const countT& idAction = pcNotesP[ 3 ] ;
                const countT& idTool   = pcNotesP[ 2 ] ;
            {
            if( pcNotesP[ 0 ] == 1 && pcNotesP[ 1 ] == 4 )
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            }
                }
                    }
                        }
                            break ;
                            else                                                                                etherP.etherFireImpersonateMonitorIF( tinP ) ;
                            if( F(thirdC::third_flagsModeProcess1I_IF( tinP )) & flMODEpROCESS1_IGNOREfIREbYoPERATOR ) thirdC::dosBeepIF( tinP , 0x3800 , TUCK * 0x20 ) ;
                        {
                        case ifcIDtYPEtOOL_ESCAPE :
                    {
                    switch( idTool )
                    ZE( boolT , bFreshFace ) ;
                {
                if( idAction == ifcIDtYPEaCTION_DOWN )
            
                const countT& idAction = pcNotesP[ 3 ] ;
                const countT& idTool = pcNotesP[ 2 ] ;
            {
            if( pcNotesP[ 0 ] == 1 && pcNotesP[ 1 ] == 2 )
        {
        case ifcIDtYPEsTROKEcALLbACK_KEY :
        }
            break ;
    
            THREADmODE1rESTORE
            wP.wrapRenderF( tinP , tButton ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //TO ALLOW DT OF stInvalid
            
            ;
            
                S2(0,scOld_POPoRIGIN)
                S2(CfROM2(cIdColMaxButton+2,1),scOld_mmMOVEpELtO)+
                S2(CfROM2(cIdColMinButton,cIdRowMinButton),scOld_mmLINEpELtO)+
                S2(CfROM2(cIdColMinButton,cIdRowMaxButton),scOld_mmLINEpELtO)+
                S2(CfROM2(cIdColMaxButton,cIdRowMaxButton),scOld_mmLINEpELtO)+
                S2(CfROM2(cIdColMaxButton,cIdRowMinButton),scOld_mmLINEpELtO)+
                S2(CfROM2(cIdColMinButton,cIdRowMinButton),scOld_mmMOVEpELtO)+
                tTitle+
                S2(flPUSHoRIGIN_WOwO,scOld_cPUSHoRIGIN)+
                T("")+
            
            tButton =
            TN( tButton , "" ) ;

            c8scratchStrokeP.c4 = R( wP.mIdRow ) - 1 + cIdRowMaxButton ;
            c8scratchStrokeP.c3 = R( wP.mIdCol ) - 1 + cIdColMaxButton ;
            c8scratchStrokeP.c2 = R( wP.mIdRow ) - 1 + cIdRowMinButton ;
            c8scratchStrokeP.c1 = R( wP.mIdCol ) - 1 + cIdColMinButton ;
            
            }
                cIdRowMaxButton = R( mIdRowMaxTitle ) + 2 ;
                cIdColMaxButton = R( mIdColMaxTitle ) + 2 ;
                cIdRowMinButton = R( mIdRowMinTitle ) - 2 ;
                cIdColMinButton = R( mIdColMinTitle ) - 2 ;
                wP.boundingRectF( tinP , mIdColMinTitle , mIdRowMinTitle , mColsTitle , mRowsTitle , tTitle ) ;
                ZE( measureT , mRowsTitle ) ;
                ZE( measureT , mColsTitle ) ;
                ZE( measureT , mIdRowMinTitle ) ;
                ZE( measureT , mIdColMinTitle ) ;
            {
            ZE( countT , cIdRowMaxButton ) ;
            ZE( countT , cIdColMaxButton ) ;
            ZE( countT , cIdRowMinButton ) ;
            ZE( countT , cIdColMinButton ) ;

            }
                etherP( tinP , psParams ) ;
                }
                    etherP.delF( tinP , psttTitle ) ;

                    tTitle = T(psttTitle) ;

                    (*psParams) >> psttTitle ;
                    ZE( strokeS* , psttTitle ) ;
                {
                if( psParams )
                wP.stqr_paperSouls >> psParams ;
                ZE( soulC* , psParams ) ;
            {
            TN( tTitle , "" ) ;

        {
        case ifcIDtYPEsTROKEcALLbACK_RENDER :
    {
    switch( idTypeCallP )
    wP.baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
boolT scbF( tinS& tinP , etherC& etherP , windowOldC& wP , stackC& stInvalidP , const countT idSnipP , const strokeS* const psttSnipP , const countT idsP , const flagsT flagsP , const boolT bNoDrawP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , count8S& c8scratchEventP , count8S& c8scratchAdamP , count8S& c8scratchSnipP , count8S& c8scratchSnipAdamP , count8S& c8scratchStrokeP )

/*1*/WAKEhIDE( "example.other.callback.strokes.control.button" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

