
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

REST

}
    }
        etThread.delF( tinP , pstt1m ) ;
        }
            ether.osSleepF( tinP , time1 ) ; //1
            etThread.strokeF( tinP , T("taking a nap for ")+TT(time1,0)+T("\r\n") ) ;
            countT time1 = ( CmIN - cToDo ) * TOCK ;
        {
        else
        }
            }
                etThread.delF( tinP , psttu ) ;
                etThread.boxPutUniqueF( tinP , psttu , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(DDNUMB)+T("/1.delta/delta") , WS( souDelta ) ) ; ___( psttu ) ;

                etThread.delF( tinP , psttu ) ;
                etThread.boxPutUniqueF( tinP , psttu , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(DDNUMB)+T("/1.arc/arc") , WS( souArchive ) ) ; ___( psttu ) ;
                ZE( strokeS* , psttu ) ;

                }
                    souDelta << (countT&)unixDeltaBig2 ;
                    souDelta << unixDeltaBig1 ;

                    }
                        DEL( psouWo ) ;
                        }
                            etThread.osTimeAddF( tinP , unixDeltaBig1 , unixDeltaBig2 , unixDeltaSmall1 , unixDeltaSmall2 ) ;
                            *psouWo >> (countT&)unixDeltaSmall2 ;
                            *psouWo >> unixDeltaSmall1 ;
                            *psouWo >> idVersion ;
                            *psouWo >> idType ;
                            *psouWo >> idAdam ;
                            ZE( sCountT , unixDeltaSmall2 ) ;
                            ZE( countT , unixDeltaSmall1 ) ;
                            ZE( countT , idVersion ) ;
                            ZE( countT , idType ) ;
                            ZE( countT , idAdam ) ;

                            souArchive << *psouWo ;
                        {
                        if( psouWo )
                        swsAll >> psouWo ;
                        ZE( soulC* , psouWo ) ;
                    {
                    while( swsAll )
                    ZE( sCountT , unixDeltaBig2 ) ;
                    ZE( countT  , unixDeltaBig1 ) ;

                    souDelta << psttEmail ;
                    souDelta << (countT)1 ; // IDvERSION
                    souDelta << (countT)2 ; // IDtYPE

                    souArchive << psttEmail ;
                    souArchive << (countT)1 ; // IDvERSION
                    souArchive << (countT)1 ; // IDtYPE
                {
                soulC souDelta( tinP , TAG( TAGiDnULL ) , flSOUL_null , DDNUMB ) ;
                soulC souArchive( tinP , TAG( TAGiDnULL ) , flSOUL_null , DDNUMB ) ;

                psttEmail = (strokeS*)swsAll.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swsAll.cFlavorsF( tinP ) ;

            }
                etThread.delF( tinP , pstt1m2 ) ;
                FORsTRINGSiN5( pstt1m2 ) etThread.boxZapF( tinP , psttc5 ) ;

                }
                    etThread.delF( tinP , pbs ) ;
                    }
                        etThread.delF( tinP , pstt1_accountHolderNotes ) ;
                        etThread.delF( tinP , pstt1_ifcDualTransactionNotes ) ;
                        etThread.delF( tinP , psttEmail ) ;

                        }
                            swsAll << psouWo ;

                            *psouWo << pstt1_accountHolderNotes ;
                            *psouWo << pstt1_ifcDualTransactionNotes ;
                            *psouWo << (countT&)timeN2 ;
                            *psouWo << timeN1 ;
                            *psouWo << idTrans ;
                            *psouWo << (countT&)unixDelta2 ;
                            *psouWo << unixDelta1 ;
                            *psouWo << idVersion ;
                            *psouWo << idType ;
                            *psouWo << idAdam ;
                        {
                        if( psouWo )
                        soulC* psouWo = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;

                        }
                            //etThread.ifcSayF( tinP , tLog , flSAY_APPEND | flSAY_LOG ) ;

                            FORsTRINGSiN4( pstt1_accountHolderNotes      ) tLog += T("ownerNote: ")+tQuote+T(psttc4)+tQuote+tCRLF ;
                            FORsTRINGSiN3( pstt1_ifcDualTransactionNotes ) tLog += T("ifcNote  : ")+tQuote+T(psttc3)+tQuote+tCRLF ;

                            ;

                                T("\r\n")
                                T(psttEmail)+tBlank+
                                TT(unixDelta1,unixDelta2)+tBlank+
                                TT(timeN1,timeN2)+tBlank+
                                TF1(idTrans)+tBlank+

                            TN( tLog , "" ) ; tLog =

                            souIn >> pstt1_accountHolderNotes      ; ___( pstt1_accountHolderNotes      ) ;
                            souIn >> pstt1_ifcDualTransactionNotes ; ___( pstt1_ifcDualTransactionNotes ) ;
                            souIn >> (countT&)unixDelta2 ;
                            souIn >> unixDelta1 ;
                            souIn >> psttEmail ; ___( psttEmail ) ;
                            souIn >> (countT&)timeN2 ;
                            souIn >> timeN1 ;
                            souIn >> idTrans ;

                            __( idVersion - 1 ) ;
                            souIn >> idVersion ;

                            __( idType - 1 ) ;
                            souIn >> idType ;

                            __( idAdam - ifcIDaDAMoLD_CENTRALbANKtELLER ) ;
                            souIn >> idAdam ;
                        {
                        ZE( strokeS* , pstt1_accountHolderNotes ) ;                        
                        ZE( strokeS* , pstt1_ifcDualTransactionNotes ) ;                        
                        ZE( sCountT , timeN2 ) ;
                        ZE( countT , timeN1 ) ;
                        ZE( countT , idTrans ) ;
                        ZE( sCountT , unixDelta2 ) ;
                        ZE( countT , unixDelta1 ) ;
                        ZE( countT , idVersion ) ;
                        ZE( countT , idType ) ;
                        ZE( countT , idAdam ) ;

                        souIn.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbs , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                        soulC souIn( tinP , TAG( TAGiDnULL ) ) ;

                        __( cbs - sizeof( countT ) - *(countT*)pbs ) ;
                    {
                    if( pbs )
                    etThread.boxGetShadowF( tinP , pbs , cbs , psttc2 ) ; ___( pbs ) ;
                    ZE( countT , cbs ) ;
                    ZE( byteT* , pbs ) ;
                {
                FORsTRINGSiN2( pstt1m2 )
                const countT cToDo2 = etThread.boxMenuF( tinP , soul1m2 , tWork+T("*") , 0 , CmAX ) ; ___( pstt1m2 ) ;
                ZE( strokeS* , pstt1m2 ) ;
            {
            switchStackC swsAll( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttEmail , flSTACKc_null , ifcSTACKtYPE_PTR_soulC ) ;
            ZE( strokeS* , psttEmail ) ;

            { ZE( countT , idFile ) ; FORsTRINGSiN1( pstt1m ) etThread.diskMoveFileOrDirF( tinP , tWork+TF1(idCycle)+tDot+TF1(++idFile)+tDot+TI(ifcIDtEXTgEN_UNIQUE) , psttc1 ) ; }

            etThread.strokeF( tinP , T("cycle ")+TF1(++idCycle)+T(": ")+TF1(cToDo)+T(" files\r\n") ) ;
        {
        if( cToDo >= CmIN ) //1
        const countT cToDo = etThread.boxMenuF( tinP , soul1m , tLikeIn , 0 , CmAX ) ; ___( pstt1m ) ;
        ZE( strokeS* , pstt1m ) ;
    {
    while( !ether && !etThread )
    ZE( countT , idCycle ) ;
    TN( tQuote , "\"" ) ;
    TN( tBlank , " " ) ;
    TN( tDot  , "." ) ;
    TN( tCRLF , "\r\n" ) ;
    TN( tWork   , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/" ) ; tWork += TF1(DDNUMB)+T("/" ) ;
    TN( tLikeIn , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/3440104/1.deltaBal/*" ) ;

    etThread.ifcChatF( tinP , 0 , DDNUMB , jobFillCourseF , jobHearOrderF ) ;
    stateS state( tinP , etThread ) ;
{

TODO

#define CmAX 0x1000
#define CmIN 0x4
//U: CmIN: 0x100

STATE0

}
    if( ether && *tinP.zEtScratch && cArgP && c8argP.c1 && sDataP && sNotesTextP && sNotesDataP && idChatSessionP ) ;

    }
        }
            break ;

            }
                }
                    break ;
                    etThread.delF( tinP , psttJobType ) ;

                    else __1
                    }
                    {
                    if( !etThread.strCompareF( tinP , psttJobType , T("!fooey") ) )

                    sOrderP >> psttJobType ; ___( psttJobType ) ;
                    ZE( strokeS* , psttJobType )
                {
                case ifcIDcMDjOBoRDER_NAMED :
                }
                    break ;

                    etThread.delF( tinP , psttBody ) ;
                    etThread.delF( tinP , psttFrom ) ;

                    }
                        etThread.delF( tinP , postBody ) ;
                        etThread.delF( tinP , psttu ) ;
                        etThread.boxPutUniqueF( tinP , psttu , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(DDNUMB)+T("/in/ignored/in") , postBody , costBody ) ;
                        ZE( strokeS* , psttu ) ;

                        countT costBody = etThread.strMakeF( tinP , postBody , psttBody ) ; ___( postBody ) ;
                        ZE( osTextT* , postBody ) ;
                    {

                    sOrderP >> psttBody ; ___( psttBody ) ;
                    ZE( strokeS* , psttBody ) ;

                    __( idAdamTo - DDNUMB ) ;
                    __Z(  idAdamTo ) ;
                    sOrderP >> idAdamTo ;
                    ZE( countT , idAdamTo ) ;

                    __(  psttFrom && !psttFrom->idAdam ) ;
                    __Z( psttFrom ) ;
                    sOrderP >> psttFrom ; ___( psttFrom ) ;
                    ZE( strokeS* , psttFrom ) ;
                {
                case ifcIDcMDjOBoRDER_MAIL :
            {
            switch( idJobType )

            sOrderP >> idJobType ;
            ZE( countT , idJobType ) ;
        {
        case 1 :
    {
    switch( idCourseP )

    __( idAdamP - DDNUMB ) ;
{
voidT jobFillCourseF( tinS& tinP , etherC& ether , etherC& etThread , soulC& sDataP , soulC& sNotesTextP , soulC& sNotesDataP , const countT idCourseP , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

}
    if( cArgP && c8argP.c1 && sOrderP && ether && idChatSessionP ) ;

    __( idAdamP - DDNUMB ) ;
{
voidT jobHearOrderF( tinS& tinP , etherC& ether , etherC& etThread , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

/*1*/WAKEhIDE( "ifcIDaDAMoLD_CENTRALbANKcOMPACTOR.sentient.central.banker.compactor" )/*1*/
/**/
*/
 this is because i do a file move; both directories must be in the same home directory
i must be hired on the same host that 3440104 is hired
\<A HREF=\"5.6440104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

