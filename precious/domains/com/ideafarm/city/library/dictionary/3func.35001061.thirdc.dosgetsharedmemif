
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    osTraceWrongNodeIF( tinP , (byteT*)handleP.cNoteF() , "dosGetSharedMemIF: cNote" ) ;

    #endif

        if( !( F(flagsP) & flOPENsHAREDmEMORY_DOnOTsERIALIZE ) && F(processGlobal1I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal1I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal3I.grabUniverse.ungrabF( tinP ) ;

        }
            }
                }
                    }
                        //}
                        //    CONoUTrAW( os ) ;
                        //    OStEXTAK( os , "\"\r\n" ) ;
                        //    OStEXTA(  os , ostoOsName ) ;
                        //    OStEXTAK( os , "old: \"" ) ;
                        //    OStEXT( os , TUCK << 1 ) ;
                        //{
                        //if( thirdC::c_strstrIF( ostoOsName , "grabUniverseC" ) )

                        handleP.osF( ifcIDtYPEhANDLE_SHAREDmEMORY , (countT)osh , 0 , (countT)pv ) ;
            
                        }
                            if( offr == CsHAREDmEMiNFO ) { BLAMMO ; }
                            }
                                }
                                    break ;
                                    processGlobal1I._thirdC_pSharedMemInfo[ offr ].pv  = pv ;
                                    processGlobal1I._thirdC_pSharedMemInfo[ offr ].osh = (countT)osh ;
                                    thirdC::c_strncpyIF( tinP , processGlobal1I._thirdC_pSharedMemInfo[ offr ].postName , ostoOsName , sizeof processGlobal1I._thirdC_pSharedMemInfo[ offr ].postName ) ;
                                {
                                if( !*processGlobal1I._thirdC_pSharedMemInfo[ offr ].postName )
                            {
                            for( offr = 0 ; offr < CsHAREDmEMiNFO ; offr ++ )
                            ZE( countT , offr ) ;
                        {
                        //DUPLICATED CODE: 1020068 1020061 1020132
        
                        //}
                        //    CONoUTrAW(  ostoLog ) ;
                        //    OStEXTAK( ostoLog , "\r\n" ) ;
                        //    OStEXTA(  ostoLog , ostoOsName ) ;
                        //    OStEXTAK( ostoLog , " old: " ) ;
                        //    OStEXTC(  ostoLog , pv , ' ' ) ;
                        //    OStEXT(   ostoLog , TUCK << 2 ) ;
                        //{
                        //if( thirdC::c_strstrIF( tinP , ostoOsName , "napSlab" ) )
                        //if( tinP.pc Utility[ 0 ] )
                    {
                    else
                    }
                        osh = 0 ;
                        BOSpOOP
                        BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                    {
                    if( POOP )
    
                    //__( IsBadReadPtr( pv , 1 ) ) ;
                    //U:: THE NEXT LINE, WHEN NOT COMMENTED OUT, WAS NOT REPORTED BY LINT

                    voidT* pv = (voidT*)tinP.brcRaw ;
                {
                else
                }
                    LOGrAW3( "DosGetSharedMem: MapViewOfFileExNuma returned " , tinP.brcRaw , "\r\n" ) ;
                    CONoUTrAW3( "DosGetSharedMem: MapViewOfFileExNuma returned " , tinP.brcRaw , "\r\n" ) ;
                    BOSdOnOTtEST( WHATgbo , GetLastError() )

                    osh = 0 ;
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                {
                if( POOP )
                BOSpOOP
                BOS( WHATgbo , BOSoK , MapViewOfFileExNuma( osh , osFlagsMap , 0 , 0 , 0 , 0 , thirdC::osOffNumaNodeValidChosenIF( processGlobal1I.idNumaNode ) ) )
    
                //}
                //    LOGrAW(    ostoSay ) ;
                //    CONoUTrAW( ostoSay ) ;
                //    
                //    OStEXTAK( ostoSay , "\r\n" ) ;
                //    OStEXTC(  ostoSay , tinP.brcRaw , 0 ) ;
                //    OStEXTAK( ostoSay , "\" dosGetSharedMemIF OpenFileMapping [osh]: " ) ;
                //    OStEXTA(  ostoSay , postP ) ;
                //    OStEXTAK( ostoSay , " \"" ) ;
                //    OStEXTC(  ostoSay , tinP.pAdamGlobal1->idAdam , 0 ) ;
                //    OStEXT(   ostoSay , TUCK << 2 ) ;
                //{
                //if( tinP.pc Utility[ 0 ] )

                HANDLE osh = (HANDLE)tinP.brcRaw ;
            {
            if( !POOP )

            THREADmODE1rESTORE
            BOSpOOP
            THREADmODE1oN( flTHREADmODE1_QUIETiMPOTENCE )
            BOS( WHATgbo , BOSoK , OpenFileMapping( osFlagsMap , 0 , ostoOsName ) )

            SECURITYaTTRIBUTE_saUNRESTRICTED( 0 ) ;
        {
        if( !POOP && !handleP )

        }
            }
                }
                    break ;
                    }
                        else handleP.osF( ifcIDtYPEhANDLE_SHAREDmEMORY , (countT)osh , 0 , tinP.brcRaw ) ;
                        }
                            osh = 0 ;
                            BOSpOOP
                            BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                        {
                        if( POOP )
                        BOSpOOP
                        BOS( WHATgbo , BOSoK , MapViewOfFileExNuma( osh , osFlagsMap , 0 , 0 , 0 , 0 , thirdC::osOffNumaNodeValidChosenIF( processGlobal1I.idNumaNode ) ) )
                    {
                    else
                    }
                        osh = 0 ;
                        BOSpOOP
                        BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                    {
                    if( POOP )
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , DuplicateHandle( oshMe , (HANDLE)processGlobal1I._thirdC_pSharedMemInfo[ offr ].osh , oshMe , &osh , 0 , 1 , DUPLICATE_SAME_ACCESS ) )
                    HANDLE oshMe = (HANDLE)tinP.brcRaw ;
                    BOSdOnOTtEST( WHATgbo , GetCurrentProcess() )
                    ZE( HANDLE , osh ) ;
                    __( !processGlobal1I._thirdC_pSharedMemInfo[ offr ].pv ) ;
                    __( !processGlobal1I._thirdC_pSharedMemInfo[ offr ].osh ) ;
                {
                if( !c_strcmpIF( tinP , processGlobal1I._thirdC_pSharedMemInfo[ offr ].postName , ostoOsName ) )
            {
            for( countT offr = 0 ; offr < CsHAREDmEMiNFO ; offr ++ )
        {

        if( !( F(flagsP) & flOPENsHAREDmEMORY_DOnOTsERIALIZE ) && F(processGlobal1I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal1I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal3I.grabUniverse.grabF( tinP , TAG( TAGiDnULL ) ) ;

        ;
            : FILE_MAP_ALL_ACCESS
            ? FILE_MAP_READ
        const flagsT osFlagsMap = F(flagsP) & flOPENsHAREDmEMORY_READoNLY

        c_zReplaceIF( tinP , (osTextT*)(const osTextT*)ostoOsName , '/' , '.' ) ;
        OStEXTA(  ostoOsName  , postP ) ;
        OStEXTAK( ostoOsName  , "." ) ;
        else                                                  { OStEXTCF( ostoOsName , idMemorySpaceP ? idMemorySpaceP : tinP.pAdamGlobal1->idMemorySpace , '0' ) ; }
        if( F(flagsP) & flOPENsHAREDmEMORY_ALLmEMORYsPACES )  { OStEXTAK( ostoOsName  , "_" ) ; }
        OStEXTAK( ostoOsName  , "." ) ;
        else                                                  { OStEXTC(  ostoOsName , processGlobal1I.idAdamRoot == ifcIDaDAM_TOOLnAPwORDvIEWER && tinP.pAdamGlobal1->_thirdC_.idHomeOverride ? tinP.pAdamGlobal1->_thirdC_.idHomeOverride : processGlobal1I.idHome , 0 ) ; }
        if( F(flagsP) & flOPENsHAREDmEMORY_ALLhOMES         ) { OStEXTAK( ostoOsName  , "_" ) ; }
        OStEXTAK( ostoOsName  , "." ) ;
        else                                                  { OStEXTA(  ostoOsName , thirdC::postUserNameIF() ) ; }
        if( F(flagsP) & flOPENsHAREDmEMORY_ALLuSERS         ) { OStEXTAK( ostoOsName  , "_" ) ; }
        OStEXTA(  ostoOsName  , postPrefix ) ;
        OStEXT(   ostoOsName , COSTnAPKINnAMEmAX + 1 )
        //CODEsYNC: DUPLICATE CODE 1020061 1020068

        ;
            :          "ideafarm.domains.com.ideafarm.1."
            ?  "Global\\ideafarm.domains.com.ideafarm.1."

        osTextT* postPrefix = c_strstrIF( tinP , postP , "napSlab" )

    #elif defined( __NT__ )

        if( !POOP ) handleP.osF( ifcIDtYPEhANDLE_SHAREDmEMORY , handleP.hInvalid + 1 , 0 , (countT)pv ) ;
        if( POOP ) pv = 0 ;
        BOSpOOP
        BOSI( WHATgbo , BOSfAIL , DosGetNamedSharedMem( &pv , ostoName , PAG_EXECUTE | PAG_READ | PAG_WRITE ) )
        OStEXTA( ostoName  , postP ) ;
        OStEXTAK( ostoName  , "\\sharemem\\" ) ;
        OStEXT( ostoName , COSToSfILEnAMEmAX + 11 )
        ZE( voidT* , pv ) ;

    #ifdef __OS2__
    _IO_

    }
        if( POOP ) return ;
        __( idMemorySpaceP && !( F(tinP.flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tinP ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tinP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        FV(flOPENsHAREDmEMORY,flagsP) ;
        __( idMemorySpaceP == ifcIDmEMORYsPACE_KERNEL && processGlobal1I.idAdamRoot != ifcIDaDAM_KERNEL2MONITOR && processGlobal1I.idAdamRoot != ifcIDaDAM_KERNEL1DRIVER ) ;
        __( COSToSfILEnAMEmAX < thirdC::c_strlenIF( tinP , postP ) ) ;
        __( !!thirdC::c_strchrIF( tinP , postP , '\\' ) ) ;
        //__( !!thirdC::c_strchrIF( tinP , postP , '/' ) ) ;
        __( !*postP ) ;
        if( POOP ) return ;
        __( ~handleP ) ;
        __Z( postP ) ;
        #endif
            { ZE( boolT , foo ) ; __( !foo && sizeof(countT) != sizeof(HANDLE) ) ;  }
        #if defined( __NT__ )
        if( POOP ) return ;
    {
    IFbEcAREFUL    
{
/*1*/voidT thirdC::dosGetSharedMemIF( tinS& tinP , handleC& handleP , const osTextT* const postP , const countT idMemorySpaceP , const flagsT flagsP )/*1*/

/**/
*/
 postP
 handleP
 pvP
arguments
the name must be less than 240 bytes
the name must not contain slash ('/') or backslash ('\\')
the memory must already be allocated and named
opens an existing allocation of shared memory
\<A HREF=\"5.1020068.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosGetSharedMemIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

