
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return rgbOverride ;

    //if( pTallyP ) { LOGrAW5( "spaceF [cGlyph,cPoint]: " , pTallyP->cGlyph , " " , pTallyP->cPoint , "\r\n" ) ; }

    if( pSpaceP && pSpaceFromPaperEpilogCBF ) (*pSpaceFromPaperEpilogCBF)( tinP , rgbOverride , rgbP , cArg ) ;

    }
        }
            }
                }
                    }
                        }
                            }
                                pSpaceP->pcSize[ offg ] ++ ;

                                else                              pSpaceP->pPoint[ offpo ++ ] = pPoint2[ offe ]          ;
                                if( pSurfaceCBF ) (*pSurfaceCBF)( pSpaceP->pPoint[ offpo ++ ] , pPoint2[ offe ] , cArg ) ;
                            {
                            else
                            if( pTallyP ) pTallyP->cPoint ++ ;
                        {
                        if( pbUse[ offe ] )
                    {
                    for( countT offe = 1 ; offe < sizeof pPoint2 / sizeof pPoint2[ 0 ] ; offe ++ ) // THE ZE'TH ELEMENT IS LAGGED OUTPUT SO IS NEVER CHECKED HERE
                
                    }
                        }
                            else                             pbUse[ offm ] = 1 ;
                            if( error <= surfaceErrorLimit ) break ;

                            measureT error   = mErrorx * mErrorx + mErrory * mErrory + mErrorz * mErrorz ;
                            measureT mErrorz = cError.z ;
                            measureT mErrory = cError.y ;
                            measureT mErrorx = cError.x ;
                    
                            cError.z = cm.z - ce.z ;
                            cError.y = cm.y - ce.y ;
                            cError.x = cm.x - ce.x ;
                            mPoint3S cError ;
                    
                            ce.z = R( 0.5 * ca.z + 0.5 * cb.z ) ;
                            ce.y = R( 0.5 * ca.y + 0.5 * cb.y ) ;
                            ce.x = R( 0.5 * ca.x + 0.5 * cb.x ) ;
                            mPoint3S ce ;
                        {

                        }
                            cb = pPoint2[ offb ] ;
                            cm = pPoint2[ offm ] ;
                            ca = pPoint2[ offa ] ;
                        {
                        else
                        }
                            (*pSurfaceCBF)( cb , pPoint2[ offb ] , cArg ) ;
                            (*pSurfaceCBF)( cm , pPoint2[ offm ] , cArg ) ;
                            (*pSurfaceCBF)( ca , pPoint2[ offa ] , cArg ) ;
                        {
                        if( pSurfaceCBF )
                        mPoint3S cb ;
                        mPoint3S cm ;
                        mPoint3S ca ;
                    
                        pPoint2[ offm ] = ( pPoint2[ offa ] + pPoint2[ offb ] ) / 2.0 ;
                    
                        countT offm = ( offb + offa ) >> 1 ;
                        countT offb = pcob[ oo ] ;
                        countT offa = pcoa[ oo ] ;
                    {
                    for( countT oo = 0 ; oo < sizeof pcoa / sizeof pcoa[ 0 ] ; oo ++ )
                
                    countT pcob[] = { 8 , 4 , 8 , 2 , 4 , 6 , 8 } ; //ALL SPREADS pcob[ oo ] - pcoa[ oo ] MUST BE EVEN
                    countT pcoa[] = { 0 , 0 , 4 , 0 , 2 , 4 , 6 } ;
                
                    pPoint2[ 8 ] = paperP.pPoint[ offpi ++  ] ;
                    pPoint2[ 0 ] = paperP.pPoint[ offpi - 1 ] ;
                    cPoint2S pPoint2[ 9 ] ;
                
                    pbUse[ 8 ] = 1 ;
                    BOSdOnOTtEST( WHATgbo , memset( pbUse + 1 , 0 , sizeof pbUse - 2 * sizeof( boolT ) ) )
                    boolT pbUse[ 9 ] ; //7 CANDIDATE POINTS PLUS THE OO ENDPOINTS
                {
                else
                }
                    }
                        pSpaceP->pcSize[ offg ] ++ ;

                        else                              pSpaceP->pPoint[ offpo ++ ] = paperP.pPoint[ offpi ++ ]          ;
                        if( pSurfaceCBF ) (*pSurfaceCBF)( pSpaceP->pPoint[ offpo ++ ] , paperP.pPoint[ offpi ++ ] , cArg ) ;
                    {
                    else
                    }
                        pTallyP->cPoint ++ ;
                        offpi ++ ;
                    {
                    if( pTallyP )
                    //DUPLICATED CODE: 35123004 35123004
                {
                if( !offp )
            {
            for( countT offp = 0 ; offp <= offpLath ; offp ++ )
        {
        else
        }
            }
                }
                    pSpaceP->pcSize[ offg ] ++ ;

                    else                              pSpaceP->pPoint[ offpo ++ ] = paperP.pPoint[ offpi ++ ]          ;
                    if( pSurfaceCBF ) (*pSurfaceCBF)( pSpaceP->pPoint[ offpo ++ ] , paperP.pPoint[ offpi ++ ] , cArg ) ;
                {
                else
                }
                    pTallyP->cPoint ++ ;
                    offpi ++ ;
                {
                if( pTallyP )
                //DUPLICATED CODE: 35123004 35123004
            {
            for( countT offp = 0 ; offp <= offpLath ; offp ++ )
        {
        if( F(flagsCt) & flSURFc_NOsMOOTHIES )

        const countT offpLath = paperP.pcSize[ offg ] - 1 ;

        }
            pSpaceP->pFlagsTail[ offg ] = flTAIL_SET ;

            else                              pSpaceP->pPointTail[ offg ] = paperP.pPointTail[ offg ]          ;
            if( pSurfaceCBF ) (*pSurfaceCBF)( pSpaceP->pPointTail[ offg ] , paperP.pPointTail[ offg ] , cArg ) ;
        {
        if( pSpaceP && F(paperP.pFlagsTail[offg]) & flTAIL_SET )
    {
    for( countT offg = 0 ; offg < paperP.cGlyph ; offg ++ )
    ZE( countT , rgbOverride ) ;
    ZE( countT , offpo ) ;
    ZE( countT , offpi ) ;

    }
        pTallyP->cPoint = 0 ;
        pTallyP->cGlyph = paperP.cGlyph ;

        if( F(flagsP) &flSURFcsPACE_NEWcYCLE && pSpaceFromPaperPrologCBF ) (*pSpaceFromPaperPrologCBF)( tinP , cArg ) ;
    {
    if( pTallyP )
{
/*1*/countT surfC::spaceF( tinS& tinP , spaceS* const pSpaceP , glyphTallyS* const pTallyP , const paperS& paperP , const countT rgbP , const flagsT flagsP , const measureT m01StepP ) const/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

