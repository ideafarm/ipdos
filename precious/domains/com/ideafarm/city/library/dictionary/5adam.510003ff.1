
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    etThread.delF( tinP , psttLevel ) ;
    }
        }
            }
                //U:sgnDone_tmRiverAndPour.waitF( tinP ) ;

                }
                    if( pMainF ) (*pMainF)( &main ) ;
                    mainS main( tinP , ether , etThread , T("cid ")+tCid+T(" level ")+T(psttLevel) ) ;
                    etThread.dllEntryF( tinP , pMainF , hDll , T("mainF") ) ;
                    ZE( mainFT , pMainF ) ;
                    etThread.dllOpenF( tinP , hDll , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/")+T(psttLevel)+T("/20401040.ipdos-wd") ) ;
                    ZE( countT , hDll ) ;
                    hoverC hoverLevel( tinP , etThread , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/")+T(psttLevel)+T("/") ) ;
                {

                if( tinP.fingerprint ) tinP.flagsThreadMode1 &= ~( F(flTHREADmODE1_SHOWpROGRESS) ) ;

                //U:{ ZE( countT , tnu ) ; etThread.osThreadF( tinP , tnu , tmRiverAndPourF , &sgnDone_tmRiverAndPour ) ; }
                //U:signC sgnDone_tmRiverAndPour( tinP , TAG( TAGiDnULL ) ) ;

                etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+S2(0,scOld_SYSmARK)+T("step 31 of 31") ) ;
            {
            else
            if( etThread ) ifcGATEeRROR( 21 )
        {
        //else
        //}
        //    etThread.delF( tinP , psttnu ) ;
        //    etThread.faceHearF( tinP , psttnu ) ;
        //    ZE( strokeS* , psttnu ) ;
        //    etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+T("press the enter key\r\nthen reopen the gate to use the new reliability setting")+S2(0,scOld_SYSmARK) ) ;
        //{
        //if( bRestartNeeded )
        //boolT bRestartNeeded = updateReliabilityLevelF( tinP , etThread , psttLevel , tCid ) ; ___( psttLevel ) ;
        //U: SUPPORT RELIABILITY LEVELS OTHER THAN 7use

        etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+S2(0,scOld_SYSmARK)+T("step 21 of 31") ) ;
    {
    else
    if( etThread ) ifcGATEeRROR( 11 )

    updateTimeAdjustmentF( tinP , etThread , tCid ) ;

    etThread.delF( tinP , psttOldCid ) ;
    TN( tCid , psttOldCid ) ;
    etThread.strWordF( tinP , psttLevel , pmp->psttDirectives , sttQuote , S1C(' ') , 4 ) ;
    etThread.delF( tinP , psttLevel ) ;
    __( !!etThread.strCompareF( tinP , psttLevel , T("level") ) ) ;
    etThread.strWordF( tinP , psttLevel , pmp->psttDirectives , sttQuote , S1C(' ') , 3 ) ;

    etThread.strWordF( tinP , psttOldCid , pmp->psttDirectives , sttQuote , S1C(' ') , 2 ) ;
    etThread.delF( tinP , psttOldCid ) ;
    __( !!etThread.strCompareF( tinP , psttOldCid , T("cid") ) ) ;
    etThread.strWordF( tinP , psttOldCid , pmp->psttDirectives , sttQuote , S1C(' ') , 1 ) ;

    strokeS sttQuote ;
    ZE( strokeS* , psttLevel ) ;
    ZE( strokeS* , psttOldCid ) ;

    etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+S2(0,scOld_SYSmARK)+T("step 11 of 31") ) ;
{
else
if( etThread ) ifcGATEeRROR( 01 )
__Z( pmp ) ;
etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+S2(0,scOld_SYSmARK)+T("step 01 of 31") ) ;

TODO

DONE( tmRiverAndPourF )
}
    DEL( pRiver ) ;

    }
        }
            etThread = 0 ;
            cFound = etThread.boxPourF( tinP , T("city.center.ideafarm.com") , T("///ideafarm/ephemeral/domains/com/ideafarm/city/data/new/") , T("///ideafarm/ephemeral/domains/com/ideafarm/city/data/out/") , 0x100000 , CbOXpOURmAX ) ;
        {
        if( !ether )
        if( !cFound ) etThread.osSleepF( tinP , TOCK * 0x10 ) ;
    {
    while( !ether && !etThread )
    ZE( countT , cFound ) ;

    else                                                   { /* etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+T("attaching to the river that flows to city center\r\n")+S2(0,scOld_SYSmARK) ) ; */ pRiver = new( 0 , tinP , LF ) riverC( tinP , etThread , socketC::nicNameIF( tinP , etThread , T("city.center.ideafarm.com") ) , ifcPORToLD1rIVERrESERVED ) ; }
    else if( idComputer == IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0              ) { /* etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+T("attaching to the river that flows to 0x01010102\r\n" )+S2(0,scOld_SYSmARK) ) ; */ pRiver = new( 0 , tinP , LF ) riverC( tinP , etThread , 0x01010102                                                           , ifcPORToLD1rIVERrESERVED ) ; }
         if( idComputer == IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 || bSolo )   /* etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+T("not attaching to the river\r\n"                      )+S2(0,scOld_SYSmARK) )   */ ;
    ZE( riverC* , pRiver ) ;

    }
        etThread.delF( tinP , psttv ) ;
        if( psttv ) bSolo = !etThread.strCompareF( tinP , psttv , T("me") ) ;
        etThread.osEnvironmentVariableF( tinP , psttv , T("ifcNicNameCityCenter") ) ; ___( psttv ) ;
        ZE( strokeS* , psttv ) ;
    {
    if( idComputer == IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 )
    ZE( boolT , bSolo ) ;
    countT idComputer = etThread.diskIdF( tinP , T("///c") ) ;
{
if( pTaskP )
TASK( tmRiverAndPourF )

}
    return bChanged ;

    }
        etThread.delF( tinP , postLevel ) ;
        etThread.boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/city/settings/")+T(psttOldCidP)+T("/reliability") , postLevel ) ;
        etThread.strMakeF( tinP , LF , postLevel , psttLevelP ) ; ___( postLevel ) ;
        ZE( osTextT* , postLevel ) ;
    {
    if( psttLevelP && psttLevelP->idAdam )

    }
        etThread.delF( tinP , psttLevelNew ) ;
        }
            etThread.strMakeF( tinP , LF , psttLevelP , psttLevelNew ) ; ___( psttLevelP ) ;
            etThread.delF( tinP , psttLevelP ) ;
            bChanged = 1 ;
        {
        if( psttLevelP && psttLevelNew && psttLevelNew->idAdam && etThread.strCompareF( tinP , psttLevelP , psttLevelNew ) )
        etThread.faceHearF( tinP , psttLevelNew ) ; ___( psttLevelNew ) ;
        ZE( strokeS* , psttLevelNew ) ;
        etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+S2(0,scOld_SYSmARK)+T("reliability=")+T(psttLevelP)+T("\r\nreliability?") ) ;
    {
    ZE( boolT , bChanged ) ;
{
boolT updateReliabilityLevelF( tinS& tinP , etherC& etThread , strokeS*& psttLevelP , const strokeS* const psttOldCidP )

}
    }
        //etThread.delF( tinP , psttw ) ;
        //etThread.strokeF( tinP , T(psttw)+T("\r\n")+S2(0,scOld_SYSmARK) ) ;
        //if( timeError.time2 >= 0 ) etThread.strokeF( tinP , T("+") ) ;
        //etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+T("local time contains an error of        ") ) ;
        //etThread.strFromTimeF( tinP , psttw , timeError.time1 , timeError.time2 ) ;

        //etThread.boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/city/settings/")+T(psttOldCidP)+T("/time.error") , (byteT*)&timeError , sizeof timeError ) ;
        }
            poolOld Side.timeError2 = timeError.time2 ;
            poolOld Side.timeError1 = timeError.time1 ;
            poolOld SideS& poolOld Side = (poolOld SideS&)>>>>(pool C&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<Thread ;
        {
        etThread.osTimeSubtractF( tinP , timeError.time1 , timeError.time2 , timeR1 , timeR2 ) ;
        etThread.osTimeAddF     ( tinP , timeError.time1 , timeError.time2 , time1  , time2  ) ;
        timeS timeError ;

        //etThread.delF( tinP , psttw ) ;
        //etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+T("the uncorrected time at this gate is  ")+T(psttw)+T("\r\n")+S2(0,scOld_SYSmARK) ) ;
        //etThread.strFromTimeF( tinP , psttw , time1 , time2 ) ;
        etThread.osTimeNowF( tinP , time1 , time2 , 1 ) ;
        ZE( sCountT , time2 ) ;
        ZE( countT , time1 ) ;

        //etThread.delF( tinP , psttw ) ;
        //etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+T("IdeaFarm " "(tm) City reference time is    ")+T(psttw)+T("\r\n")+S2(0,scOld_SYSmARK) ) ;
        //etThread.strFromTimeF( tinP , psttw , timeR1 , timeR2 ) ;
        //ZE( strokeS* , psttw ) ;
    {
    if( !etThread )

    SEE THE COMMENTS IN osTimeNowF
    THIS DEF WILL NOT BUILD BECAUSE timeError* MEMBERS OF poolOld SideS WERE ELIMINATE DURING ELIMINATION OF poolOld SideS
    NOTE:

    }
        etThread.delF( tinP , pbtr ) ;
        __Z( timeR2 ) ;
        }
            timeR2 = *(countT*)( pbtr + sizeof( sCountT ) ) ;
            timeR1 = *(sCountT*)pbtr ;
        {
        if( !etThread && pbtr && cbtr == sizeof( countT ) + sizeof( sCountT ) )
        etThread.boxGetShadowF( tinP , pbtr , cbtr , T("city.center.ideafarm.com//time") ) ;
        ZE( countT , cbtr ) ;
        ZE( byteT* , pbtr ) ; // "tr" = TIME REFERENCE
    {
    ZE( sCountT , timeR2 ) ;
    ZE( countT , timeR1 ) ;

    __Z( psttOldCidP ) ;
{
voidT updateTimeAdjustmentF( tinS& tinP , etherC& etThread , const strokeS* const psttOldCidP )

/*1*/WAKEhIDE( "city.gate.3" )/*1*/
/**/
*/
 boxPourF
this can fail due to hardcoded capacity limit
periodically pours data from the local home to city.center.ideafarm.com
gate
it is illegal to refer to this symbol in the definition of an adam
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

