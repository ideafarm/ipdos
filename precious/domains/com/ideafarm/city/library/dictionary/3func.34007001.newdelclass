
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


NEWdELcLASSb(         fileWindowsC                  )
NEWdELcLASSb(         fileWindowC                   )
NEWdELcLASSb(         paperS                        )
NEWdELcLASSb(         paperOldC                     )
NEWdELcLASSb(         out_countTstrz_C              )
NEWdELcLASSb(         out_countT_C                  )
NEWdELcLASSb(         out_byteTstrz_C               )
NEWdELcLASSb(         osTextC                       )
NEWdELcLASSb(         notEqual_countTstrz_C         )
NEWdELcLASSb(         notEqual_countT_C             )
NEWdELcLASSb(         notEqual_byteTstrz_C          )
NEWdELcLASSb(         netC                          )




        }
            return pvr ;
            voidT* pvr = operator new( cbP , 0 , tinP , pNapkinP ) ;
            if( !pNapkinP ) BLAMMOiD( 0x17 ) ;
            /*_IO_*/
        {
        voidT* napkinC::operator new[]( countT cbP , tinS& tinP , napkinC* const pNapkinP )

        }
            return pvr ;
            voidT* pvr = (voidT*)pbZombieP ;
            if( tinP.fingerprint ) ;
            if( cbZombieP - cbP ) BLAMMOiD( 0x16 ) ;
            if( !pbZombieP ) BLAMMOiD( 0x15 ) ;
            /*_IO_*/
        {
        voidT* napkinC::operator new[]( countT cbP , tinS& tinP , byteT* pbZombieP , const countT cbZombieP )

        }
            return pvr ;
            voidT* pvr = operator new( cbP , 0 , tinP , idLineP , idiFileP ) ;
            /*_IO_*/
        {
        voidT* napkinC::operator new[]( countT cbP , tinS& tinP , const countT idLineP , const countT idiFileP )

        }
            return pvr ;
            voidT* pvr = (voidT*)( (byteT*)pvn + cbaFoot ) ;

            }
                putNegAM( *(countT*)( (byteT*)pvn + cbaFoot - sizeof( countT ) ) , FINGERnEG_FOOTc2 ) ;
                putNegAM( *(countT*)pvn , FINGERnEG_FOOTc1 ) ;
                BLAMMOiD( 0x14 ) ;
            {
            if( cbaFoot )
            __Z( pvn ) ;

            if( pNapkinP && *pNapkinP == ( cbaFoot + cbP ) ) pvn = (voidT*)(byteT*)*pNapkinP ;
            ZE( voidT* , pvn ) ;

            countT cbaFoot = cbFootP ? cbFootP + 2 * sizeof( countT ) : 0 ;
            if( !pNapkinP ) BLAMMOiD( 0x13 ) ;
            /*_IO_*/
        {
        voidT* napkinC::operator new( countT cbP , const countT cbFootP , tinS& tinP , napkinC* const pNapkinP )

        }
            return pvr ;
            voidT* pvr = (voidT*)( pbZombieP + cbaFoot ) ;
            }
                putNegAM( *(countT*)( pbZombieP + cbaFoot - sizeof( countT ) ) , FINGERnEG_FOOTc2 ) ;
                putNegAM( *(countT*)pbZombieP , FINGERnEG_FOOTc1 ) ;
                BLAMMOiD( 0x12 ) ;
            {
            if( cbaFoot )
            if( tinP.fingerprint ) ;
            }
                BLAMMOiD( 0x11 ) ;
                tinP.pcUtility[ 4 ] = sizeof( batonC ) ;
                tinP.pcUtility[ 3 ] = cbP ;
                tinP.pcUtility[ 2 ] = cbaFoot ;
                tinP.pcUtility[ 1 ] = cbaFoot + cbP ;
                tinP.pcUtility[ 0 ] = cbZombieP ;
            {
            if( cbZombieP - ( cbaFoot + cbP ) )   /* DO A FULL BUILD (REFRESH HEADERS) IF THIS HAPPENS */
            countT cbaFoot = cbFootP ? cbFootP + 2 * sizeof( countT ) : 0 ;
            if( !pbZombieP ) BLAMMOiD( 0x10 ) ;
            /*_IO_*/
        {
        voidT* napkinC::operator new( countT cbP , const countT cbFootP , tinS& tinP , byteT* pbZombieP , const countT cbZombieP )

        }
            return pvr ;
            voidT* pvr = (voidT*)( (byteT*)pvn + cbaFoot ) ;
            }
                putNegAM( *(countT*)( (byteT*)pvn + cbaFoot - sizeof( countT ) ) , FINGERnEG_FOOTc2 ) ;
                putNegAM( *(countT*)pvn , FINGERnEG_FOOTc1 ) ;
                BLAMMOiD( 0xf ) ;
            {
            if( cbaFoot )
            __Z( pvn ) ;
            POSTPONEtEST( pvn ) ;

            else                *(byteT**)&pvn = processGlobal3I.heap.newF( tinP , LF , ( cbaFoot + cbP ) ) ;
            if( tinP.pPoolUse ) { PUSE.newF( tinP , LF , *(byteT**)&pvn , ( cbaFoot + cbP ) ) ; /*APP CODE MUST TAG: ___( pvn ) ;*/ }

            ZE( voidT* , pvn ) ;
            countT cbaFoot = cbFootP ? cbFootP + 2 * sizeof( countT ) : 0 ;
            /*_IO_*/
        {
        voidT* napkinC::operator new( countT cbP , const countT cbFootP , tinS& tinP , const countT idLineP , const countT idiFileP )

        }
            operator delete( pvP ) ;
            /*_IO_*/
            TINSL
        {
        voidT napkinC::operator delete[]( voidT* pvP )

        }
            }
                PUSE( tinP , *(byteT**)&pvP ) ;
            {
            if( pvP && !( F(tinP.flagsThreadMode2) & flTHREADmODE2_DOnOTcaLLdELif ) )

            if( idType == ifciDtYPEdROPnOTE_strokeS && ((strokeS*)pvP)->idCaste != sc_cADAM ) { BLAMMOiD( 0xc ) ; }
            countT idType = ifciDtYPEdROPnOTE_napkinC ;
            /*_IO_*/
            TINSL
        {
        voidT napkinC::operator delete( voidT* pvP )

//    #define NEWdELcLASS0(napkinC,napkinC,sizeof( napkinC ))
//NEWdELcLASS0( napkinC , napkinC , sizeof( napkinC ) )
//NEWdELcLASSb(         napkinC                       )
//U::20201124@2139: TO FIND A BUG



NEWdELcLASSb(         masterOldC                    )
NEWdELcLASSb(         marketC                       )
NEWdELcLASSb(         mapC                          )
NEWdELcLASSb(         mainRefsS                     )
NEWdELcLASSb(         listingC                      )
NEWdELcLASSb(         listing_listingVSP_C          )
NEWdELcLASSb(         listing_countTstrz_C          )
NEWdELcLASSb(         listing_countT_C              )
NEWdELcLASSb(         listing_blob_C                )
NEWdELcLASSb(         fileNameC                     )


/*1*//*NEWdELcLASS (all invocations)*//*1*/

/**/
*/
this set of NEWdELcLASSb invocations is split into groups because it takes a long time to compile the whole set, which can cause some cpu's to be idle wastefully
placing all NEWdELcLASS lines here also makes it a bit easier to define a new class, since wo less source file must be created
this is done primarily to accomodate _IO_ in the new delete definitions, which would refer to "this" pointer if the above lines appeared with the member functions for the varous classes
place all uses of NEWdELcLASSb here
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

