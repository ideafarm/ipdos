
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tinP , T("ok") ) ;

//qsF( pc , 0 , 7 ) ;

//static countT pc[ 8 ] = { 5 , 7 , 3 , 4 , 9 , 2 , 1 , 8 } ;

//tinP.pc Utility[ 0 ] -- ;
//}
//    }
//        bksFoo.writeF( tinP , (const byteT*)&cWrite , sizeof cWrite , 0 , 0 , flBOOKScwRITE_null ) ;
//        ++ cWrite ;
//        CONoUTrAW( "*" ) ;
//    {
//    while( cDo -- )
//    countT cDo = TUCK ;
//    booksC bksFoo( tinP , TAG( TAGiDnULL ) , "bksFoo" , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKSc_WRITER , TUCK >> 4 , 0 , 0 , 0 , 0 , 0 , 0 ) ;
//
//    ZE( countT , cWrite ) ;
//    
//{
//tinP.pc Utility[ 0 ] ++ ;




THREADmODE3rESTORE
}
    PUSE.newF( tinP , LF , pbLeak , TOCK << 6 ) ; ___( pbLeak ) ;
    ZE( byteT* , pbLeak ) ;
{
while( !ether )
THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )


TODO

}
    }
        qsF( pcP , offPartition + 1 , offHiP ) ;
        qsF( pcP , offLoP , offPartition ) ;
        countT offPartition = partitionF( pcP , offLoP , offHiP ) ;
    {
    if( offLoP < offHiP )
{
voidT qsF( countT* pcP , countT offLoP , countT offHiP )

}
    }
        pcP[ offHi ] = save ;
        pcP[ offLo ] = pcP[ offHi ] ;
        countT save = pcP[ offLo ] ;

        if( offLo >= offHi ) return offHi ;

        while( pcP[ offHi ] > pivot ) ;             // offHi WILL POINT TO LATEST   ELEMENT <= PIVOT
        do          offHi -- ;

        while( pcP[ offLo ] < pivot ) ;             // offLo WILL POINT TO EARLIEST ELEMENT >= PIVOT
        do          offLo ++ ;
    {
    for(;;)

    countT offHi = offHiP + 1 ;
    countT offLo = offLoP - 1 ;

    countT pivot = pivotF( pcP , offLoP , offHiP ) ;
{
countT partitionF( countT* pcP , countT offLoP , countT offHiP )

}
    return pc3[ 1 ] ;

    }
        if( !cSwitch ) break ;
        }
            }
                cSwitch ++ ;
                pc3[ offi     ] = save ;
                pc3[ offi - 1 ] = pc3[ offi     ] ;
                countT save     = pc3[ offi - 1 ] ;
            {
            if( pc3[ offi - 1 ] > pc3[ offi ] )
        {
        for( countT offi = 1 ; offi < sizeof pc3 / sizeof pc3[ 0 ] ; offi ++ )
        ZE( countT , cSwitch ) ;
    {
    for(;;)
    
    countT pc3[] = { pcP[ offLoP ] , pcP[ ( offLoP + offHiP ) / 2 ] , pcP[ offHiP ] } ;
{
countT pivotF( countT* pcP , countT offLoP , countT offHiP )

/*1*/WAKEsHOWtEXT( "doodle.quicksort" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
                                                                                                                                                    