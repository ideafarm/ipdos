
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        delF( tinP , pbQuery ) ;
        if( time1P || time2P ) sgnDone_tmTimeout.waitF( tinP ) ;
        sgnDone_tmAsk.waitF( tinP ) ;

        }
            }
                cbP = 0 ;
                delF( tinP , pbP ) ;
            {
            else
            if( pbP && cbP >= cbQuery ) bGoItIt = *(count01T*)pbP == *(count01T*)pbQuery ; // TEST FOR EQUALITY OF THE idQuery VALUES
            sockd.readF( tinP , pbP , cbP , idPort , nicName ) ; ___( pbP ) ;
            nicNameC nicName ;
            ZE( countT , idPort ) ;
        {
        while( !POOP && !bGoItIt && !etPrime && !bTimeout )
        etherC& etPrime = etPrimeIF( tinP ) ;

        if( time1P || time2P ) osThreadF( tinP , countTC() , tmTimeoutF , &sgnDone_tmTimeout , flTHREADlAUNCH_null , 0 , (countT)&sockd , (countT)&bGoItIt , (countT)&bTimeout , time1P , time2P , idPortMe ) ;
        osThreadF( tinP , countTC() , tmAskDnsF , &sgnDone_tmAsk , flTHREADlAUNCH_null , 0 , (countT)&sockd , (countT)&bGoItIt , (countT)&bTimeout , (countT)pbQuery , cbQuery ) ;
        signC sgnDone_tmTimeout( tinP , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmAsk( tinP , TAG( TAGiDnULL ) ) ;
        ZE( boolT , bTimeout ) ;
        ZE( boolT , bGoItIt ) ;
        dnsFormatQueryF( tinP , pbQuery , cbQuery , psttDomainP , idTypeP ) ; ___( pbQuery ) ;
        ZE( countT , cbQuery ) ;
        ZE( byteT* , pbQuery ) ;

        countT idPortMe = sockd.bindF( tinP ) ;
        socketC sockd( tinP , *this , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
    {

    _IO_

    }
        __Z( idTypeP ) ;
        __Z( psttDomainP ) ;
        __( cbP ) ;
        __NZ( pbP ) ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::dnsQueryF( tinS& tinP , byteT*& pbP , countT& cbP , const strokeS* const psttDomainP , const countT idTypeP , const countT time1P , const sCountT time2P )/*1*/

/**/
*/
  can be 0
 time2P
  can be 0
 time1P
 idTypeP
 psttDomainP
 cbP
 pbP
 tinP
arguments
the caller must test whether pbP is 0 to determine whether a reply was received
impotence will -not- occur if i do not receive a valid reply
else i will return if the specified time elapses without obtaining the information
if {time1P,time2P} is ze then i will block until i receive a recognized reply or until asynch impotence occurs
\<A HREF=\"5.103018f.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dnsQueryF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

