
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tinP , T("ok") ) ;
WAITuNTILaLMOSTaLONE( 1 )
etThread.traceF( tinP , T("waiting for all threads to finish") ) ;

}
    etThread.osThreadF( TaRG1( tmWorkerF ) , (countT)pptRoot[ offt ] , (countT)pcArgInner ) ;
{
for( countT offt = 0 ; offt < cRoot ; offt ++ )

}
    case IDcOMPUTER_FACTORY9 : { cRoot = 7 ; pptRoot[ 0 ] = &tFactory9Root1 ; pptRoot[ 1 ] = &tFactory9Root2 ; pptRoot[ 2 ] = &tFactory9Root3 ; pptRoot[ 3 ] = &tFactory9Root4 ; pptRoot[ 4 ] = &tFactory9Root5 ; pptRoot[ 5 ] = &tFactory9Root6 ; pptRoot[ 6 ] = &tFactory9Root7 ; break ; }
    case IDcOMPUTER_FACTORY3 : { cRoot = 1 ; pptRoot[ 0 ] = &tFactory3Root1                                                                                                                                                                                                       ; break ; }
    case IDcOMPUTER_FACTORY2 : { cRoot = 1 ; pptRoot[ 0 ] = &tFactory2Root1                                                                                                                                                                                                       ; break ; }
    //case IDcOMPUTER_FACTORY1 : { cRoot = 4 ; pptRoot[ 0 ] = &tFactory1Root1 ; pptRoot[ 1 ] = &tFactory1Root2 ; pptRoot[ 2 ] = &tFactory1Root3 ; pptRoot[ 3 ] = &tFactory1Root4                                                                                                    ; break ; }
    case IDcOMPUTER_FACTORY1 : { cRoot = 1 ; pptRoot[ 0 ] = &tRootTest                                                                                               ; break ; }
{                                //CS:CODEsYNC 51000760 51000760
switch( idComputer )
textC*  pptRoot[ 0x10 ] ; //CS:CODEsYNC 51000760 51000760
ZE( countT , cRoot ) ;

etThread.traceF( tinP , T("idComputer: ")+TF2(idComputer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
countT idComputer = etThread.diskIdF( tinP , T("///c") ) ;

TN( tRootTest , "///d/tmp/format8/" ) ;

TN( tFactory9Root7 , "///z/archive/" ) ;
TN( tFactory9Root6 , "///y/archive.snap/" ) ;
TN( tFactory9Root5 , "///y/archive/" ) ;
TN( tFactory9Root4 , "///x/archive/" ) ;
TN( tFactory9Root3 , "///w/archive/" ) ;
TN( tFactory9Root2 , "///e/archive/" ) ;
TN( tFactory9Root1 , "///d/archive.not.yet.verified/" ) ;

TN( tFactory3Root1 , "///e/archive/" ) ;

TN( tFactory2Root1 , "///d/archive.not.yet.verified/" ) ;

TN( tFactory1Root4 , "///g/archive.save.1999/" ) ;
TN( tFactory1Root3 , "///g/archive/" ) ;
TN( tFactory1Root2 , "///e/archive.part2/" ) ;
TN( tFactory1Root1 , "///d/archive.part1/" ) ;

countT pcArgInner[] = { (countT)&etThread , (countT)&sttq , (countT)&tSlash , (countT)&tSlashHey , (countT)&tDuplicatesSlash , (countT)&tDiscardsSlash , (countT)&tPatternOld } ;

strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

;

    +S2(sa_SSSaNDeND,sc_ccSSS)

        +T(".")
        // TERMINATOR

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERICf,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("._")                                                 // FOR SOME REASON, "_" SOMETIMES OCCURS WHEN SHOULD BE "."
        +S2(sa_SSSoR,sc_ccSSS)
        // SEQUENCE NUMBER








        +S2(sa_SSSoReND,sc_ccSSS)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("012xz")
        +S2(sa_SSSoR,sc_ccSSS)
        +T("@")
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(7,sc_ccSSSrEPEAT,7)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("._")                                                 // FOR SOME REASON, "_" SOMETIMES OCCURS WHEN SHOULD BE "."
        +S2(sa_SSSoR,sc_ccSSS)
        // DATETIME

        +S2(sa_SSSoReND,sc_ccSSS)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("012xz")
        +S2(sa_SSSoR,sc_ccSSS)
        +T("@")
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(7,sc_ccSSSrEPEAT,7)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("._")                                                 // FOR SOME REASON, "_" SOMETIMES OCCURS WHEN SHOULD BE "."
        +S2(sa_SSSoR,sc_ccSSS)
        // DATETIME

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(7,sc_ccSSSrEPEAT,7)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("._")                                                 // FOR SOME REASON, "_" SOMETIMES OCCURS WHEN SHOULD BE "."
        +S2(sa_SSSoR,sc_ccSSS)
        // IDoWNER

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(7,sc_ccSSSrEPEAT,7)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("._")                                                 // FOR SOME REASON, "_" SOMETIMES OCCURS WHEN SHOULD BE "."
        +S2(sa_SSSoR,sc_ccSSS)
        // IDoWNER

        +T("/!ideafarm.8.2")
        // CONSTANT

    +S2(sa_SSSaND,sc_ccSSS)
    T("")

TN( tPatternOld , "" ) ; tPatternOld =

TN( tSlashHey , "/!" ) ;
TN( tSlash    , "/" ) ;
TN( tDiscardsSlash   , "discards." DESTINATIONgEN "/" ) ;
TN( tDuplicatesSlash , "duplicates." DESTINATIONgEN "/" ) ;










TODO

DONE( tmWorkerF )
}
    _OUT_

    etThread.traceF( tinP , T("root ---- [cFiles,cDirs]:    ")+*ptRootP+tb4+TF2(cFiles,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(cDirs,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
    etThread.diskWalkF( tinP , cDirs , cFiles , *ptRootP , ether , flDISKwALK_null , workCBF , pcArgInnerP , 0 , 0 ) ;
    etThread.traceF( tinP , T("root ++++               :    ")+*ptRootP ) ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs ) ;

    TN( tb4 , "    " ) ;
    countT* pcArgInnerP = (countT*)pTaskP->c2 ;
    textC*  ptRootP     =  (textC*)pTaskP->c1 ;

    _INoLD_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )

}
    return 0 ;

    _OUT_
    }
        _OUT_
        }
            }
                DELzOMBIE( pFwsNew ) ;
                DELzOMBIE( pFwsOld ) ;

                }
                    }
                        }
                            etherP.traceF( tinP , T("could not rename to discardss") ) ;
                            POOPR
                        {
                        else
                        if( !POOP ) ; //etherP.traceF( tinP , T("renamed to discardss aok") ) ;
                        tinP.pEtScratch->diskMoveFileOrDirF( tinP , tNewPathRoot+tDiscardsSlashP+tNewLeafShort , tNameOld , 1 ) ;

                        etherP.traceF( tinP , T("content is different ; attempting to rename to discards") ) ;

                        DELzOMBIE( pFwsNew ) ;
                        DELzOMBIE( pFwsOld ) ;
                    {
                    else if( !bQuitP )
                    }
                        }
                            etherP.traceF( tinP , T("could not rename to duplicates") ) ;
                            POOPR
                        {
                        else
                        if( !POOP ) ; //etherP.traceF( tinP , T("renamed to duplicates aok") ) ;
                        tinP.pEtScratch->diskMoveFileOrDirF( tinP , tNewPathRoot+tDuplicatesSlashP+tNewLeafShort , tNameOld , 1 ) ;

                        //etherP.traceF( tinP , T("content is the same ; attempting to rename to duplicates") ) ;

                        DELzOMBIE( pFwsNew ) ;
                        DELzOMBIE( pFwsOld ) ;
                    {
                    if( bSame && !bQuitP )

                    }
                        }
                            }
                                etherP.traceF( tinP , T("different content [idWindow]:    ")+TF2(idWindow,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                bSame = 0 ;
                            {
                            else if( etherP.memCompareF( tinP , pbwOld , pbwNew , cbwOld ) )
                            else if( !pbwOld || !cbwOld ) break ;
                            }
                                etherP.traceF( tinP , T("different sizes (unexpected) [idWindow]:    ")+TF2(idWindow,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                bSame = 0 ;
                            {
                            if( cbwOld != cbwNew )

                            pFwsNew->getF( tinP , pbwNew , cbwNew ) ;
                            ZE( countT , cbwNew ) ;
                            ZE( byteT* , pbwNew ) ;

                            pFwsOld->getF( tinP , pbwOld , cbwOld ) ;
                            ZE( countT , cbwOld ) ;
                            ZE( byteT* , pbwOld ) ;

                            idWindow ++ ;
                        {
                        while( !bQuitP )
                        ZE( countT , idWindow ) ;
                    {
                    else
                    }
                        etherP.traceF( tinP , T("different sizes") ) ;
                        bSame = 0 ;
                    {
                    if( pFwsOld->cbFileLoF() != pFwsNew->cbFileLoF() || pFwsOld->cbFileHiF() != pFwsNew->cbFileHiF() )

                    boolT bSame = 1 ;
                {
                else
                }
                    }
                        etherP.traceF( tinP , T("could not rename") ) ;
                        POOPR
                    {
                    else
                    if( !POOP ) ; //etherP.traceF( tinP , T("renamed aok") ) ;
                    tinP.pEtScratch->diskMoveFileOrDirF( tinP , tNameNew , tNameOld , 1 ) ;

                    //etherP.traceF( tinP , T("could not ct both file windows ; attempting to rename") ) ;

                    DELzOMBIE( pFwsNew ) ;
                    DELzOMBIE( pFwsOld ) ;
                    POOPR ;
                {
                if( POOP )

                fileWindowsC* pFwsNew = new( 0 , tinP , pb_fwsNew , sizeof pb_fwsNew ) fileWindowsC( tinP , *tinP.pEtScratch , tNameNew , flFILEwINDOW_null , 1 ) ;
                fileWindowsC* pFwsOld = new( 0 , tinP , pb_fwsOld , sizeof pb_fwsOld ) fileWindowsC( tinP , *tinP.pEtScratch , tNameOld , flFILEwINDOW_null , 1 ) ;

                byteT pb_fwsNew[ sizeof( fileWindowsC ) ] ;
                byteT pb_fwsOld[ sizeof( fileWindowsC ) ] ;

                SCOOPS
            {
            IFsCRATCH

            //etherP.traceF( tinP , T("new duplicate: ")+tNewPathRoot+tDuplicatesSlashP+tNewLeafShort ) ;
            //etherP.traceF( tinP , T("         leaf: ")+tNewLeafShort ) ;
            //etherP.traceF( tinP , T("         root: ")+tNewPathRoot ) ;
            etherP.traceF( tinP , tNameNew ) ;

            }
                etherP.delF( tinP , psttNewLeafShort ) ;
                etherP.delF( tinP , psttNewPathRoot ) ;
                tNewLeafShort = T(psttNewLeafShort) ;
                tNewPathRoot  = T(psttNewPathRoot) ;
                etherP.strBisectF( tinP , psttNewPathRoot , psttNewLeafShort , tNameNew , tSlashP , - 3 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttNewPathRoot ) ; ___( psttNewLeafShort ) ;
                ZE( strokeS* , psttNewLeafShort ) ;
                ZE( strokeS* , psttNewPathRoot ) ;
            {
            TN( tNewLeafShort , "" ) ;
            TN( tNewPathRoot , "" ) ;

            }
                etherP.delF( tinP , psttSnip3 ) ;
                etherP.delF( tinP , psttSnip2 ) ;
                etherP.delF( tinP , psttSnip1 ) ;
                tNameNew = T(psttSnip1) ;

                if( psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x66 ].idAdam == '_' ) psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x66 ].idAdam = '.' ;
                if( psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x61 ].idAdam == '_' ) psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x61 ].idAdam = '.' ;
                if( psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x5d ].idAdam == '_' ) psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x5d ].idAdam = '.' ;
                if( psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x3c ].idAdam == '_' ) psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x3c ].idAdam = '.' ;
                if( psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x2e ].idAdam == '_' ) psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x2e ].idAdam = '.' ;
                if( psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x20 ].idAdam == '_' ) psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x20 ].idAdam = '.' ;
                if( psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x17 ].idAdam == '_' ) psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x17 ].idAdam = '.' ;
                if( psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x0e ].idAdam == '_' ) psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x0e ].idAdam = '.' ;
                if( psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x0c ].idAdam == '_' ) psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x0c ].idAdam = '.' ;
                if( psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x0a ].idAdam == '_' ) psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x0a ].idAdam = '.' ;

                etherP.strFuseF( tinP , psttSnip1 , psttSnip3 ) ;
                etherP.strSubstringF( tinP , psttSnip3 , idf , idl , tNameOld ) ; ___( psttSnip3 ) ;
                idl = 0 ;
                idf = idHitSlashHey - 1 + 0x68 ;
                ZE( strokeS* , psttSnip3 ) ;

                etherP.strFuseF( tinP , psttSnip1 , psttSnip2 ) ;
                etherP.strSubstringF( tinP , psttSnip2 , idf , idl , tNameOld ) ; ___( psttSnip2 ) ;
                idl = idHitSlashHey - 1 + 0x62 ;
                idf = idHitSlashHey - 1 + 0x41 ;
                ZE( strokeS* , psttSnip2 ) ;

                psttSnip1[ CSpREFIX - 1 + idHitSlashHey + 0x0b ].idAdam = '9' ;
                etherP.strSubstringF( tinP , psttSnip1 , idf , idl , tNameOld , tNameOld.csF( tinP ) ) ; ___( psttSnip1 ) ;
                countT idl = idHitSlashHey - 1 + 0x3c ;
                countT idf = 1 ;
                ZE( strokeS* , psttSnip1 ) ;
            {
            TN( tNameNew , "" ) ;

            etherP.traceF( tinP , tNameOld ) ;
            etherP.traceF( tinP , T("------------------------------------------------------------------") ) ;
        {
        if( idHitSlashHey && idHit == idHitSlashHey )
        //etherP.traceF( tinP , T("[idHit,name:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tNameOld ) ;

        countT idHit = etherP.strIdF( tinP, idf , sttqP , tPatternOldP , tNameOld ) ;
        idf = 1 ;

        if( !( cFilesP % ( TOCK >> 4 ) ) ) etherP.traceF( tinP , T("[cFiles]:    ")+TF2(cFilesP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        countT idHitSlashHey = etherP.strIdF( tinP, idf , sttqP , tSlashHeyP , tNameOld ) ;
        countT idf = 1 ;

        TN( tNameOld , ifName ) ;
        ifFileNameC ifName( tinP , etherP , postNameP ) ;

        textC&  tPatternOldP      =   *(textC*)pcArgP[ 6 ] ;
        textC&  tDiscardsSlashP   =   *(textC*)pcArgP[ 5 ] ;
        textC&  tDuplicatesSlashP =   *(textC*)pcArgP[ 4 ] ;
        textC&  tSlashHeyP        =   *(textC*)pcArgP[ 3 ] ;
        textC&  tSlashP           =   *(textC*)pcArgP[ 2 ] ;
        strokeS sttqP             = *(strokeS*)pcArgP[ 1 ] ;
        etherC& etherP            =  *(etherC*)pcArgP[ 0 ] ;
        _INoLD_
    {
    if( postNameP )
    _INoLD_
{
boolT workCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

// NEW: ////factory9/z/archive/1999/!ideafarm.9.2.00000000.00000001.19990903@1308.20150910@0202.7d84358e991c2d16afaa9d1acb468f55.001.meta.currentname
//                                  123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
//                                  0              1               2               3               4               5               6               7               8
//                                           * * *        *        *             *             *                                *   *    *


// NEW: ////factory9/z/archive/1999/!ideafarm.9.2.00000000.00000001.19990903@1308.20150910@0202    .7d84358e991c2d16afaa9d1acb468f55.     001.meta.currentname
// OLD: ////factory9/z/archive/1999/!ideafarm.8.2.00000000.00000001.19990903@1308.20150910@0202.001.7d84358e991c2d16afaa9d1acb468f55.00000001.meta.currentname
//      


#define DESTINATIONgEN "009"


/*1*/WAKEsHOWtEXT( "tool.archive.migrate.format.8.names.to.format.9" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
