
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            }
                }
                    *postToP = 0 ;
                    while( -- costaToP ) *( postToP ++ ) = *( postc ++ ) ;
                    if( costaToP > poste - postc + 1 ) costaToP = poste - postc + 1 ;
                {
                if( postc < poste )
                const osTextT* poste = thirdC::c_strstrIF( postc , "\\" ) ;
                postc += 1 + sizeof posth - 1 ;
            {
            if( postc + 1 == thirdC::c_strstrIF( postc , posth ) )
            osTextT posth[] =  ":\\ideafarm.home." ;
            ZE( countT , idHomeDisk ) ;

            const osTextT* postc = thirdC::postExeFileNameIF() ; //U::MIGRATE TO USE THIS TO GET IDHOME SINCE PATH NOT PRESENT IN CMD LINE FOR GUI PROCESS
        {
        if( !bDone && !thirdC::c_strcmpIF( postKeyP , "!idHome" ) )

        }
            bDone = 1 ;
            *postToP = 0 ;

            }
                }
                    *( postToP ++ ) = *( postc2 ++ ) ;
                    if( *postc2 == '\\' && ( postc2 == postc || postc2[ - 1 ] != '\\' ) ) postc2 ++ ;
                {
                while( costaToP -- )
                const osTextT* postc2 = postc ;
            {
            else
            if( !cEscape ) while( costaToP -- ) *( postToP ++ ) = *( postc ++ ) ;
    
            if( costaToP > poste - postc - cEscape ) costaToP = poste - postc - cEscape ;
    
            }
                }
                    postc2 ++ ;
                    if( *postc2 == '\\' && ( postc2 == postc || postc2[ - 1 ] != '\\' ) ) cEscape ++ ;
                {
                while( postc2 < poste )
                const osTextT* postc2 = postc ;
            {
            ZE( countT , cEscape ) ;

            // poste POINTS TO END OF VALUE
            else           while( *poste && ( *poste != '"' || *( poste - 1 ) == '\\' ) ) poste ++ ;
            if( !bQuoted ) while( *poste && *poste != ' ' ) poste ++ ;
            const osTextT* poste = postc ;

            // postc POINTS TO VALUE
            if( bQuoted ) postc ++ ;
            boolT bQuoted = *postc == '"' ;
            while( *postc == ' ' ) postc ++ ;
            postc = thirdC::c_strstrIF( postc , " " ) ;
        {
        if( postc )
        ZE( boolT , bDone ) ;

        const osTextT* postc = thirdC::c_strstrIF( postArgs , postKeyP ) ;
        const osTextT* const postToSave = postToP ;
    {
    else if( costaToP -- )
    }
        }
            //conGF( "\"\r\n" ) ;
            //conGF( postToP ) ;
            //conGF( "reordered: \"" ) ;

            }
                }
                    postToP ++ ;
                    if( postToP != postToSave - 1 ) { BLAMMO ; }

                    while( cToDo -- ) *( postToP -- ) = *( postArgs ++ ) ; 
                                      *( postToP -- ) = 0 ;

                    postToP += cToDo ;             //POSITION TO WRITE NULL TERMINATOR
                {
                else
                }
                                      *( postToP ++ ) = 0 ;
                    while( cToDo -- ) *( postToP ++ ) = *( postArgs ++ ) ; 
                {
                if( !bReverse )

                countT cToDo = poste - postArgs ; //EXCLUDES NULL TERMINATOR
            {
            if( postArgs <= poste )
            while( *poste && *poste != ' ' ) poste ++ ;
            const osTextT* poste = postArgs ;

            boolT bReverse = *postArgs != '@' ;     //DETECTS SYMBOLIC ADAM VALUE, E.G. "@find"

            osTextT* const postToSave = postToP ;

            //conGF( "\"\r\n" ) ;
            //conGF( postArgs ) ;
            //conGF( " \"" ) ;
            //conGF( (countT)postToP ) ;
            //conGF( "parameterC [postToP,postArgs]: " ) ;

            //I REVERSE THE BIGIT ORDER WHEN WRITING TO postToP UNLESS THE INPUT VALUE BEGINS WITH '!' INDICATING THAT IT IS A SYMBOLIC VALUE NOT NUMERIC
            //GET THE WOTH PARAMETER, WHICH IS idAdam IN FOREIGN BIGIT ORDER TO MAKE IT EASY FOR BRAIN DEAD BAT FILE PROGRAMS TO CONSTRUCT THE PARAMETER
        {
        else
        }
            //THE BASIC IDEA WAS TO SEARCH FOR A MEMORY SPACE NOT OCCUPIED BY A MONITOR (1050104)
            // COMMENTED OUT CAUSE I DON'T SEE WHY I WOULD EVER WANT TO SEARCH FOR AN INACTIVE HOME: if( !( processGlobal2I.idHome & fliIDhOME_HOMELESS ) ) processGlobal2I._thirdC_flagsModeProcess2 |= flMODEpROCESS2_IDhOSTsEARCH ; //U::USED TO ONLY BE DONE WHEN idHomeDiskOverrideG IS SET; THIS LINE MUST BE EDITED TO RESTORE THE ORIGINAL INTENDED FUNCTIONALITY, WHATEVER THAT WAS

            if( costaToP >= 0x9 ) thirdC::c_itoaIF( postToP , ifcIDaDAM_KERNEL1DRIVER ) ;
        {
        else if( bDriver )
        }
            if( costaToP >= 0x9 ) thirdC::c_itoaIF( postToP , 0x1000310 ) ;
        {
        if( bFiler )

        if( processGlobal2I.idHome & fliIDhOME_HOMELESS ) processGlobal2I._thirdC_flagsModeProcess2 |= /*flMODEpROCESS2_DOnOThIREaDAMS |*/ flMODEpROCESS2_DOnOTdISPLAYtHIRDpARTYaDS ;

        }
            bDriver = 1 ;
            //CONoUTrAW3( "\r\nparameterC 3 new [idHome]: " , processGlobal2I.idHome , "" ) ; //U::
            *(countT*)&processGlobal2I.idHome |= fliIDhOME_HOMELESS ;
            //CONoUTrAW3( "\r\nparameterC 3 old [idHome]: " , processGlobal2I.idHome , "" ) ; //U::
        {
        else if( postArgs == thirdC::c_strstrIF( postArgs , posti ) )
        if( !*postArgs ) bDriver = 1 ;
        osTextT posti[] =  "!installer" ;
        ZE( boolT , bDriver ) ;

        }
            }
                //CONoUTrAW3( "\r\nparameterC 2 new [idHome]: " , processGlobal2I.idHome , "" ) ; //U::
                *(countT*)&processGlobal2I.idHome |= fliIDhOME_HOMELESS ;
                //CONoUTrAW3( "\r\nparameterC 2 old [idHome]: " , processGlobal2I.idHome , "" ) ; //U::
            {
            if( !idHomeDisk )

            }
                #endif

                    CreateDirectory( processGlobal2I.postPathHomeTmp , 0 ) ;

                    *( posto ++ ) = 'p' ;
                    *( posto ++ ) = 'm' ;
                    *( posto ++ ) = 't' ;
                    *( posto ++ ) = '\\' ;
                    while( *posti != '\\' ) *( posto ++ ) = *( posti ++ ) ;
                    *( posto ++ ) = *( posti ++ ) ;
                    *( posto ++ ) = *( posti ++ ) ;
                    *( posto ++ ) = *( posti ++ ) ;
                    osTextT* posto = processGlobal2I.postPathHomeTmp ;
                    const osTextT* posti = postExe ;

                #if defined( __NT__ )

                }
                    *(countT*)&processGlobal2I.idHome |= flagSave ;
                    *(countT*)&processGlobal2I.idHome = idHomeDisk ;
                    countT flagSave = processGlobal2I.idHome & 0xff000000 ; //A: ASSUME: sizeof( countT ) == 4
                {
                if( idHomeDisk )
                idHomeDisk = thirdC::c_atoiIF( postExe + 1 + sizeof posth - 1 ) ;
            {
            if( postExe + 1 == thirdC::c_strstrIF( postExe , posth ) )
            osTextT posth[] =  ":\\ideafarm.home." ;
            ZE( countT , idHomeDisk ) ;
        {

        }
            bFiler = 1 ;
            //CONoUTrAW3( "\r\nparameterC 1 new [idHome]: " , processGlobal2I.idHome , "" ) ; //U::
            *(countT*)&processGlobal2I.idHome |= fliIDhOME_HOMELESS ;
            //CONoUTrAW3( "\r\nparameterC 1 old [idHome]: " , processGlobal2I.idHome , "" ) ; //U::
        {
        if( thirdC::c_strstrIF( postExe , "ideafarm.0130001" ) )
        ZE( boolT , bFiler ) ;
    {
    if( !postKeyP )

    const osTextT* const postToSave = postToP ;
    const osTextT* const postKeySave = postKeyP ;

    while( *postArgs && *postArgs == ' ' ) postArgs ++ ; //SKIP LEADING BLANKS
    while( *postArgs && *postArgs != ' ' ) postArgs ++ ; //SKIP EXE FILE NAME (USELESS SINCE NOT FULLY QUALIFIED FOR GUI PROCESSES)
    while( *postArgs && *postArgs == ' ' ) postArgs ++ ; //SKIP LEADING BLANKS
    const osTextT* postArgs = thirdC::postOldCmdLineIF() ;

    const osTextT* postExe  = thirdC::postExeFileNameIF() ;
{
/*1*/parameterC::parameterC( osTextT* postToP , countT costaToP , const osTextT* postKeyP )/*1*/

/**/
*/
   if the command line contains no words then ifcIDaDAM_KERNEL1DRIVER is implied
   this value is specified in the woth word of the command line
  if 0 then the idAdam value for this process is implied
  can be 0
 postKeyP
  if 0 then i do nothing
  can be 0
 costaToP
  must point to costaToP bytes that i may write to
 postToP
arguments
quoted parameter values are supported, and these can contain escaped characters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

