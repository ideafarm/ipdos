
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

ether.loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    etThread.traceF( tinP , cached.psttName ) ;
    cachedS& cached = *(cachedS*)&(countT&)swCache ;

    cLever = swCache.leverF( tinP , idf ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
etThread.traceF( tinP , TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
countT cFlavors = swCache.cFlavorsF( tinP ) ;

}
    new( 0 , tinP , (byteT*)pCached , sizeof( cachedS ) ) cachedS( tinP , etThread , psttName , pbBlob , cbBlob ) ; ___( pCached ) ;
    cachedS* pCached = (cachedS*)&(countT&)swCache ;
    cLever = (countT)thirdC::osTimeTicksSinceBootIF() + ++ bias ; // ">> 0x10" GRAINSIZE IS APPROX 1 FOREIGN MINUTE ON factory1
    static countT bias ;    //TO GUARANTEE UNIQUENESS

    etThread.memCopyF( tinP , pbBlob , "abcd" , cbBlob ) ;
    countT cbBlob = 4 ;

    etThread.newF( tinP , LF , pbBlob , 4 ) ; ___( pbBlob ) ;
    ZE( byteT* , pbBlob ) ;

    etThread.traceF( tinP , psttName ) ;
    etThread.strMakeF( tinP , psttName , T("name ")+TF2(8-cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; ___( psttName ) ;
    ZE( strokeS* , psttName ) ;
{
while( cDo -- )
static countT cDo = 8 ;

static switchC swCache( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKrEVERSE , cLever /*, 0 , sizeof( cachedS )*/ ) ;
static ZE( countT , cLever ) ;

TODO

}
    cbBlobP   = 0 ;
    pbBlobP   = 0 ;
    psttNameP = 0 ;
{
cbBlob( cbBlobP )
pbBlob( pbBlobP ) ,
psttName( psttNameP ) ,
ether( etherP ) ,
cachedS::cachedS( tinS& tinP , etherC& etherP , strokeS*& psttNameP , osTextT*& pbBlobP , countT& cbBlobP ) :

}
    ether.delF( tinP , *(byteT**)&pbBlob ) ;
    ether.delF( tinP , *(strokeS**)&psttName ) ;
    TINSL
{
cachedS::~cachedS( voidT )

NEWdELcLASS( 1 , cachedS )

} ;
    cachedS( tinS& tinP , etherC& etherP , strokeS*& psttNameP , osTextT*& pbBlobP , countT& cbBlobP ) ;
    ~cachedS( voidT ) ;
    NEWdELcLASSpROTOS

    const byteT*   pbBlob   ;
    countT         cbBlob   ;
    const strokeS* psttName ;
    etherC&        ether    ;
{
struct cachedS

/*1*/WAKEsHOWtEXT( "scratch.3.example.other.stackC.dynamic.resorting" )/*1*/
/**/
*/
 this is done by extracting and resinking items
i demonstrate how to use stackC to maintain a list of most recently used blobs
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
