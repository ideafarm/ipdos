
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;                            

etThread.traceF( tinP , T(USCORE127 " all filtered (end)") ) ;
etThread.delF( tinP , pstt1m ) ;
}
    break ; //U::

    }
        etThread.traceF( tinP , T("                ")+T("0              1               2               3") ) ;
        etThread.traceF( tinP , T("                ")+T("123456789abcdef0123456789abcdef0123456789abcdef0") ) ;
        etThread.traceF( tinP , T("                ")+tShortInspect ) ;
        etThread.traceF( tinP , T("[idHit,idf]:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    /*if( idHit )*/

    countT idHit = etThread.strIdF( tinP , idf , sttq , psttRegExp , tShortInspect , 0 , 1 ) ;
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    countT idf = 1 ;

    }
        etThread.delF( tinP , psttShortInspect ) ;
        etThread.delF( tinP , psttPathInspect ) ;
        tShortInspect = T(psttShortInspect) ;
        tPathInspect  = T(psttPathInspect) ;
        etThread.strBisectF( tinP , psttPathInspect , psttShortInspect , psttc2 , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathInspect ) ; ___( psttShortInspect ) ;
        ZE( strokeS* , psttShortInspect ) ;
        ZE( strokeS* , psttPathInspect ) ;
        TN( tSlash , "/" ) ;
    {
    TN( tShortInspect , "" ) ;
    TN( tPathInspect , "" ) ;
{
FORsTRINGSiN2( pstt1m )
etThread.diskFindFileOrDirF( tinP , pstt1m , tPathLike+tStar , 0 , 0 , 0 , 0 ) ; ___( pstt1m ) ;
TN( tb4 , "    " ) ;
TN( tStar , "*" ) ;
etThread.traceF( tinP , T(USCORE127 " all filtered (begin)") ) ;

etThread.traceF( tinP , T(USCORE127 " like (end)") ) ;
etThread.delF( tinP , pstt1m ) ;
}
    etThread.traceF( tinP , psttc1 ) ;
{
FORsTRINGSiN1( pstt1m )
etThread.diskFindFileOrDirF( tinP , pstt1m , tLike , 0 , 0 , 0 , 0 ) ; ___( pstt1m ) ;
ZE( strokeS* , pstt1m ) ;
etThread.traceF( tinP , T(USCORE127 " like (begin)") ) ;

regularExpressionFromWildcardF( tinP , etThread , psttRegExp , tShortLike ) ; ___( psttRegExp ) ;
ZE( strokeS* , psttRegExp ) ;

}
    etThread.delF( tinP , psttShortLike ) ;
    etThread.delF( tinP , psttPathLike ) ;
    tShortLike = T(psttShortLike) ;
    tPathLike  = T(psttPathLike) ;
    etThread.strBisectF( tinP , psttPathLike , psttShortLike , tLike , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathLike ) ; ___( psttShortLike ) ;
    ZE( strokeS* , psttShortLike ) ;
    ZE( strokeS* , psttPathLike ) ;
    TN( tSlash , "/" ) ;
{
TN( tShortLike , "" ) ;
TN( tPathLike , "" ) ;

TN( tLike , "///d/tmp/wildcard.test/*.signc.*" ) ;

TODO

}
    etherP.strMakeF( tinP , psttRegExpP , tre ) ; ___( psttRegExpP ) ;

    ;

        +S2(sa_SSSaNDeND,sc_ccSSS)
            //+S2(sa_SSSoReND,sc_ccSSS)
            //    +S2(sa_SSSmARKaNY,sc_cSSSmARK)
            //+S2(sa_SSSoR,sc_ccSSS)
            //+S3(0,sc_ccSSSrEPEAT,-1)
            //+T(".baton")
            +S2(sa_SSSoReND,sc_ccSSS)
                +S2(sa_SSSmARKaNY,sc_cSSSmARK)
            +S2(sa_SSSoR,sc_ccSSS)
            +S3(0,sc_ccSSSrEPEAT,-1)
        +S2(sa_SSSaND,sc_ccSSS)

        T("")

    TN( tre , "" ) ; tre =

    }
        }
            }
                break ;

                tre += tn + psttWildP[ CSpREFIX - 1 + ids ] ;
            {
            default :
            }
                }
                    etherP.delF( tinP , psttLiteral ) ;



                    ;

                        +S2(sa_SSSoReND,sc_ccSSS)
                            +S2(sa_SSSmARKaNY,sc_cSSSmARK)
                        +S2(sa_SSSoR,sc_ccSSS)
                        +S3(0,sc_ccSSSrEPEAT,-1)

                    tre += tn

                    etherP.strSubstringF( tinP , psttLiteral , idf , idl , psttWildP , 0 ) ; ___( psttLiteral ) ;
                    ZE( strokeS* , psttLiteral ) ;

                    countT idl = idsTest > psttWildP->idAdam ? 0 : idsTest - 1 ;
                    while( idsTest <= psttWildP->idAdam && psttWildP[ CSpREFIX - 1 + idsTest ].idAdam != '*' && psttWildP[ CSpREFIX - 1 + idsTest ].idAdam != '?' ) idsTest ++ ;        // IF NOT WILDCARD THEN KEEP SEARCHING
                    idsTest = idf + 1 ;

                    countT idfSave = idf ;
                {
                if( idf )

                countT idf = idsTest > psttWildP->idAdam ? 0 : idsTest ;
                while( idsTest <= psttWildP->idAdam && ( psttWildP[ CSpREFIX - 1 + idsTest ].idAdam == '*' || psttWildP[ CSpREFIX - 1 + idsTest ].idAdam == '?' ) ) idsTest ++ ;        // IF WILDCARD THEN KEEP SEARCHING
                countT idsTest = ids + 1 ;
                // FIND THE BEGINNING AND END OF THE WOTH LITERAL THAT FOLLOWS
            {
            case '*' :
            }
                break ;

                ;

                    +S2(sa_SSSoReND,sc_ccSSS)
                        +S2(sa_SSSmARKaNY,sc_cSSSmARK)
                    +S2(sa_SSSoR,sc_ccSSS)

                tre += tn
            {
            case '?' :
        {
        switch( psttWildP[ CSpREFIX - 1 + ids ].idAdam )
    {
    for( ids = 1 ; ids <= psttWildP->idAdam ; ids ++ )
    
    TN( tre , "" ) ;
    TN( tn , "" ) ;
{
voidT regularExpressionFromWildcardF( tinS& tinP , etherC& etherP , strokeS*& psttRegExpP , const strokeS* const psttWildP )

/*1*/WAKEsHOWtEXT( "scratch.3.dut.craft.etherC.emulation.of.filename.wildcards" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
