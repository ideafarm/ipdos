
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;                            

while( !ether && ~hFind && !POOP ) ;
}
    DEL( pInfo ) ;
    }
#endif
        }
            }
                }
                    }
                        etThread.delF( tinP , psttHe ) ;
                        etThread.traceF( tinP , TF2(*(countT*)pbEncodedHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tp4+T(psttHe) ) ;
                        etThread.strDecodeF( tinP , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                        ZE( strokeS* , psttHe ) ;
                    {
                    else
                    if( !pbEncodedHe || !cbEncodedHe ) break ;
                
                    countT       cbEncodedHe = pageHe ;
                    const byteT* pbEncodedHe = pageHe ;
                
                    pageC pageHe = jhsWo ;
                {
                while( !ether )

                jotC jhsWo( tinP , tShorter , flJOTc_null , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ;   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)

                etThread.traceF( tinP , tShorter ) ;
                etThread.traceF( tinP , tShort ) ;

                }
                    etThread.delF( tinP , psttShorter ) ;
                    tShorter = T(psttShorter) ;
                    etThread.strSubstringF( tinP , psttShorter , idf , sttq , tDotJotDot , tShort ) ; ___( psttShorter ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    ZE( countT , idl ) ;
                    countT idf = 1 ;
                    ZE( strokeS* , psttShorter ) ;
                {
                TN( tShorter , "" ) ;       // jotAccessEvents.hash.string.browser

                }
                    etThread.delF( tinP , psttShort ) ;
                    tShort = T(psttShort) ;
                    etThread.delF( tinP , psttnu ) ;
                    etThread.strBisectF( tinP , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                    ZE( strokeS* , psttShort ) ;
                    ZE( strokeS* , psttnu ) ;
                {
                TN( tShort , "" ) ;             // jotAccessEvents.hash.string.browser.jotC.index.booksC.1.book.00000001.00000001.bookC
            {
            if( !bDir )

            const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;

            //TN( tIfoName , pInfo->psttIfoName ) ;
        {
        if( 1 == etThread.strIdOptimizedClosureF( tinP , 0 , flSTRmATCH_null , countTC( 1 ) , strokeS( 0 , sc_IGNOREqUOTES ) , patternC( tinP , etThread , T("jotAccessEvents.hash.string.*.jotC.index.booksC.1.book.00000001.00000001.bookC") , flPATTERNc_WILDCARDmICROSOFT ) , pInfo1->psttIfcName ) )
#if defined( NEVERdEFINED )

        etThread.traceF( tinP , fn ) ;

        fileNameC fn( tinP , etThread , pInfo->psttIfoName ) ;
    {
    else
    }
        break ;
        DEL( pInfo ) ;
    {
    if( !pInfo || !pInfo->psttIfoName )

    etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tLike ) ;
    ZE( infoFileS* , pInfo ) ;
{
do
handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

TN( tLike , "///d/tmp/wildcard.test/*.signc.*" ) ;

TODO


}
    etherP.strBisectF( tinP , psttPath , psttShort , psttLong , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
    etherP.strMakeF( tinP , psttLong , psttP ) ; ___( psttLong ) ;

    }
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
psttShort( 0 )
psttPath( 0 ) ,
psttLong( 0 ) ,
ether( etherP ) ,
fileNameC::fileNameC( tinS& tinP , etherC& etherP , const strokeS* const psttP ) :

}
    ether.delF( tinP , psttShort ) ;
    ether.delF( tinP , psttPath ) ;
    ether.delF( tinP , psttLong ) ;
    TINSL
{
fileNameC::~fileNameC( voidT )

;
}
    inline const strokeS* pathF( voidT ) const { return psttPath ; }
    inline operator const strokeS*( voidT ) const { return psttShort ; }
    fileNameC( tinS& tinP , etherC& etherP , const strokeS* const psttP ) ;
    ~fileNameC( voidT ) ;

    public :

    strokeS* psttShort ;
    strokeS* psttPath ;
    strokeS* psttLong ;
    etherC&  ether ;
{
class fileNameC

/*1*/WAKEsHOWtEXT( "scratch.3.wildcard.helper.code" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
