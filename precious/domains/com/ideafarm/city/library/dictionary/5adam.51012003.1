
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;                            

etThread.traceF( tinP , T(USCORE127 " all filtered (end)") ) ;
etThread.delF( tinP , pcMaxOverride ) ;
etThread.delF( tinP , pcMinOverride ) ;
etThread.delF( tinP , pFlagsOverride ) ;
etThread.delF( tinP , pstt1m ) ;

}
    }
        etThread.delF( tinP , psttm ) ;
        etThread.traceF( tinP , T("match: ")+T(psttm) ) ;
        stMatch >> psttm ;
        ZE( strokeS* , psttm ) ;
    {
    while( stMatch )

    }
        //etThread.traceF( tinP , T("                ")+T("0              1               2               3") ) ;
        //etThread.traceF( tinP , T("                ")+T("123456789abcdef0123456789abcdef0123456789abcdef0") ) ;
        //etThread.traceF( tinP , T("                ")+tShortInspect ) ;
        //etThread.traceF( tinP , T("[idHit,idf]:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        etThread.traceF( tinP , tShortInspect ) ;
    {
    if( idHit )

    //U:: countT idHit = etThread.strIdOptimizedClosureF( tinP , &stMatch , flSTRmATCH_null , idf , sttq , psttRegExp , tShortInspect , flagsOptimize , pFlagsOverride , pcMinOverride , pcMaxOverride ) ;
        countT idHit = strIdOptimizedClosureF( tinP , etThread , &stMatch , flSTRmATCH_null , idf , sttq , psttRegExp , tShortInspect , flagsOptimize , pFlagsOverride , pcMinOverride , pcMaxOverride ) ;
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    countT idf = 1 ;
    stackC stMatch( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

    //etThread.traceF( tinP , T("?               ")+tShortInspect ) ;

    }
        etThread.delF( tinP , psttShortInspect ) ;
        etThread.delF( tinP , psttPathInspect ) ;
        tShortInspect = T(psttShortInspect) ;
        tPathInspect  = T(psttPathInspect) ;
        etThread.strBisectF( tinP , psttPathInspect , psttShortInspect , psttc2 , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathInspect ) ; ___( psttShortInspect ) ;
        ZE( strokeS* , psttShortInspect ) ;
        ZE( strokeS* , psttPathInspect ) ;
        TN( tSlash , "/" ) ;
    {
    TN( tShortInspect , "" ) ;
    TN( tPathInspect , "" ) ;
{
FORsTRINGSiN2( pstt1m )
etThread.diskFindFileOrDirF( tinP , pstt1m , tPathLike+tStar , 0 , 0 , 0 , 0 ) ; ___( pstt1m ) ;
TN( tb4 , "    " ) ;
TN( tStar , "*" ) ;
etThread.traceF( tinP , T(USCORE127 " all filtered (begin)") ) ;

ZE( strokeS* , pstt1m ) ;

etThread.strRegExpFromWildcardsF( tinP , psttRegExp , flagsOptimize , pFlagsOverride , pcMinOverride , pcMaxOverride , tShortLike ) ; ___( psttRegExp ) ; ___( pFlagsOverride ) ; ___( pcMinOverride ) ; ___( pcMaxOverride ) ;
ZE( countT* , pcMaxOverride  ) ;
ZE( countT* , pcMinOverride  ) ;
ZE( flagsT* , pFlagsOverride ) ;
ZE( flagsT  , flagsOptimize  ) ;
ZE( strokeS* , psttRegExp ) ;
etThread.traceF( tinP , T("wildcard expression:    ")+tShortLike ) ;

}
    etThread.delF( tinP , psttShortLike ) ;
    etThread.delF( tinP , psttPathLike ) ;
    tShortLike = T(psttShortLike) ;
    tPathLike  = T(psttPathLike) ;
    etThread.strBisectF( tinP , psttPathLike , psttShortLike , tLike , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathLike ) ; ___( psttShortLike ) ;
    ZE( strokeS* , psttShortLike ) ;
    ZE( strokeS* , psttPathLike ) ;
    TN( tSlash , "/" ) ;
{
TN( tShortLike , "" ) ;
TN( tPathLike , "" ) ;

}
    etThread.traceF( tinP , T(USCORE127 " like (end)") ) ;
    etThread.delF( tinP , pstt1m ) ;
    }
        etThread.traceF( tinP , psttc1 ) ;
    {
    FORsTRINGSiN1( pstt1m )
    etThread.diskFindFileOrDirF( tinP , pstt1m , tLike , 0 , 0 , 0 , 0 ) ; ___( pstt1m ) ;
    ZE( strokeS* , pstt1m ) ;
    etThread.traceF( tinP , T(USCORE127 " like (begin)") ) ;
{

//TN( tLike , "///d/tmp/wildcard.test/*.batonc.*" ) ;
//TN( tLike , "///d/tmp/wildcard.test/*.batoncthisistoolongthisistoolongthisistoolongthisistoolongthisistoolong.*" ) ;
//TN( tLike , "///d/tmp/wildcard.test/1*" ) ;

     TN( tLike , "///d/tmp/wildcard.test.2/*z*4*" ) ;
//G: TN( tLike , "///d/tmp/wildcard.test.2/*z*" ) ;
//G: TN( tLike , "///d/tmp/wildcard.test.2/*z" ) ;

//G:TN( tLike , "///d/tmp/wildcard.test.2/*" ) ;

TODO


//------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------------------------------

//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idHit ;

    }
        if( !idHit && pstMatchP ) pstMatchP->purgeF( tinP , cPlatesWas ) ;

        }
            }
                patch_cNote   = ( - 1 ) ;
                patch_idAdam  = ( - 1 ) ;

                }
                    }
                        }
                            patch_cNote  -- ;
                            patch_idAdam -- ;
                        {
                        else
                        }
                            patch_cNote  =   1 ;
                            patch_idAdam = - 1 ;                                        // END BY IGNORING THE SUBEXPRESSION
                        {
                        if( patch_cNote == cMinMe )

                            break ;
                        if( patch_idAdam == - 1 || ( patch_idAdam == cMinMe && F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) )
                    {
                    else
                    }
                        }
                            patch_cNote  ++ ;
                            patch_idAdam ++ ;
                        {
                        else
                        if( patch_idAdam == - 1 ) patch_idAdam = patch_cNote = cMinMe ;

                            break ;
                        if( patch_idAdam == cMaxMe )
                    {
                    if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG )

                    idFirstP = idfSave ;

                        break ;
                    if( idHit )                                                         //U:: TO FIND A BUG:  COMBINE THESE OO TESTS AND USE A SINGLE LINE

                    else if( foth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("----    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb43+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    else if( reth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("----    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb42+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    else if( ooth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("----    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb41+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                         if( woth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("----    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
     
                    //U:: idHit = strIdOptimizedClosureF( tinP , pstMatchP , flagsMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , flagsP , pFlagsOverrideP ? ( ++ pFlagsOverrideP ) -- : 0 , pcMinOverrideP ? ( ++ pcMinOverrideP ) -- : 0 , pcMaxOverrideP ? ( ++ pcMaxOverrideP ) -- : 0 , idLastP , idP ) ;
                    idHit = strIdOptimizedClosureF( tinP , etherP , pstMatchP , flagsMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , flagsP , pFlagsOverrideP ? ( ++ pFlagsOverrideP ) -- : 0 , pcMinOverrideP ? ( ++ pcMinOverrideP ) -- : 0 , pcMaxOverrideP ? ( ++ pcMaxOverrideP ) -- : 0 , idLastP , idP ) ;

                    else if( foth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("++++    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb43+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    else if( reth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("++++    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb42+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    else if( ooth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("++++    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb41+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                         if( woth_idsPatch == idsPatch ) tinP.pEther->traceF( tinP , T("++++    ")+TF2(idCall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(patch_cNote,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        ++ idCall ;

                    countT idfSave = idFirstP ;
                {
                for(;;)
                TN( tb43 , "                                                    " ) ;
                TN( tb42 , "                                    " ) ;
                TN( tb41 , "                    " ) ;
                TN( tb4  , "    " ) ;
                static countT idCall ;
                ZE( countT , csttOptimal ) ;

                else patch_idAdam = patch_cNote = cMaxMe ;                                  //MAXIMAL CLOSURE BEHAVIOR (WILL DECREASE THE LENGTH FROM THIS MAXIMUM UNTIL FIND A HIT
                }
                    }
                        patch_cNote  =   1 ;
                        patch_idAdam = - 1 ;                                                // BEGIN BY IGNORING THE SUBEXPRESSION
                    {
                    else
                    if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) patch_cNote = patch_idAdam = cMinMe ;
                {
                if( F(flagsMe) & flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG )                      //MINIMAL CLOSURE BEHAVIOR (WILL INCREASE THE LENGTH FROM THIS MINIMUM UNTIL FIND A HIT
            {
            if( !POOP )

            }
                break ; //U::

                }
                    if( cMaxMe > idFixedLath - 2 ) cMaxMe = idFixedLath - 2 ;
                    if( cMinMe < idFixedWoth - 2 ) cMinMe = idFixedWoth - 2 ;
                    if( idFixedWoth > 1 ) flagsMe |= F(flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE) ;
                {
                if( idsPatch < idFixedWoth )

                etherP.delF( tinP , psttf ) ;
                countT idFixedLath = etherP.strIdF( tinP , psttf , psttBigP , - 1 ) ;
                countT idFixedWoth = etherP.strIdF( tinP , psttf , psttBigP ,   1 ) ;

                etherP.traceF( tinP , T("topmost fixed length string [idf,idl,string]:    ")+TF2(c2f.c1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(c2f.c2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttf) ) ;
                etherP.strSubstringF( tinP , psttf , idf , idl , psttSmallP ) ; ___( psttf ) ;
                countT idl = c2f.c2 ;
                countT idf = c2f.c1 ;
                ZE( strokeS* , psttf ) ;

                count2S& c2f = *(count2S*)&stFixedLength[ 1 ] ;
            {
            while( stFixedLength )
            TN( tb4 , "    " ) ;

            ;
                : psttBigP->idAdam - 1
                ? *pcMaxOverrideP & ~BM_HIGH
            countT cMaxMe = pcMaxOverrideP && *pcMaxOverrideP && *pcMaxOverrideP & ~BM_HIGH < psttBigP->idAdam - 1          // "- 1" IS BECAUSE THIS IS MAX REPEAT COUNT TO TRY, AND "REPEAT COUNT" IS NET ( REPEATING 3 TIMES MEANS 4 CONSECUTIVE OCCURANCES

            ;
                : 0
                ? *pcMinOverrideP & ~BM_HIGH
            countT cMinMe = pcMinOverrideP && *pcMinOverrideP

            if( pcMaxOverrideP && *pcMaxOverrideP ) { __Z( *pcMaxOverrideP & BM_HIGH ) ; }      //ENFORCES THE USE OF BM_HIGH ; CODE WOULD WORK CORRECTLY WITHOUT THAT BIT EXCEPT WHEN THE VALUE 0 IS INTENDED AS A VALUE RATHER THAN AS A TRMINATOR ; SO ENFORCEMENT IS DONE TO PREVENT BUGS THAT ARE DIFFICULT TO ANALYZE
            if( pcMinOverrideP && *pcMinOverrideP ) { __Z( *pcMinOverrideP & BM_HIGH ) ; }      //ENFORCES THE USE OF BM_HIGH ; CODE WOULD WORK CORRECTLY WITHOUT THAT BIT EXCEPT WHEN THE VALUE 0 IS INTENDED AS A VALUE RATHER THAN AS A TRMINATOR ; SO ENFORCEMENT IS DONE TO PREVENT BUGS THAT ARE DIFFICULT TO ANALYZE

            //U::FV(flSTRiDoPTIMIZEDcLOSURE,flagsMe) ;

            ;
                : flagsP
                ? *pFlagsOverrideP
            flagsT flagsMe = pFlagsOverrideP && *pFlagsOverrideP

            ___( patch_cNote   - ( - 1 )        ) ;
            ___( patch_idCaste - sc_ccSSSrEPEAT ) ;
            ___( patch_idAdam  - ( - 1 )        ) ;

            countT& patch_cNote   = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].cNote   ;
            countT& patch_idCaste = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].idCaste ;
            countT& patch_idAdam  = *(countT*)&psttSmallP[ CSpREFIX - 1 + idsPatch ].idAdam  ;
        {
        else
        if( !idsPatch ) idHit = etherP.strIdF( tinP , pstMatchP , flagsMatchP , idFirstP , sttQuoteP , psttSmallP , psttBigP , idLastP , idP ) ;

        }
            else if(  woth_idsPatch != idsPatch &&  ooth_idsPatch != idsPatch &&  reth_idsPatch != idsPatch && !foth_idsPatch ) foth_idsPatch = idsPatch ;
            else if(  woth_idsPatch != idsPatch &&  ooth_idsPatch != idsPatch && !reth_idsPatch                               ) reth_idsPatch = idsPatch ;
            else if(  woth_idsPatch != idsPatch && !ooth_idsPatch                                                             ) ooth_idsPatch = idsPatch ;
                 if( !woth_idsPatch                                                                                           ) woth_idsPatch = idsPatch ;
        {
        if( idsPatch )
        static countT foth_idsPatch ;
        static countT reth_idsPatch ;
        static countT ooth_idsPatch ;
        static countT woth_idsPatch ;

        }
            }
                }
                    break ;
                    idsPatch = idsIn ;
                {
                if( psttSmallP[ CSpREFIX - 1 + idsIn ] == sttPatchRequest )
            {
            else                                                  for( countT idsIn = 1                  ; idsIn <= psttSmallP->idAdam ; idsIn ++ )
            }
                }
                    break ;
                    idsPatch = idsIn ;
                {
                if( psttSmallP[ CSpREFIX - 1 + idsIn ] == sttPatchRequest )
            {
            if( F(flagsP) & flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT ) for( countT idsIn = psttSmallP->idAdam ; idsIn                       ; idsIn -- )
            ZE( countT , offo ) ;
            strokeS sttPatchRequest( - 1 , sc_ccSSSrEPEAT , - 1 ) ;
        {
        ZE( countT , idsPatch ) ;

        countT cPlatesWas = pstMatchP ? *pstMatchP : 0 ;

        }
            while( !stFixedLength.third && ~hDown ) ;
            }
                etherP.delF( tinP , psttf ) ;
                etherP.traceF( tinP , T("fixed length string: ")+T(psttf) ) ;
                etherP.strSubstringF( tinP , psttf , idf , idl , psttSmallP ) ; ___( psttf ) ;
                countT idl = c2f.c2 ;
                countT idf = c2f.c1 ;
                ZE( strokeS* , psttf ) ;

                count2S& c2f = *(count2S*)&stFixedLength.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( stFixedLength )
    {
    if( csttMin <= psttBigP->idAdam && psttBigP->idAdam <= csttMax )
    ZE( countT , idHit ) ;

    strAndExpressionLengthMinMaxF( tinP , etherP , csttMin , csttMax , stFixedLength , countTC( 1 ) , psttSmallP , flagsP , pFlagsOverrideP , pcMinOverrideP , pcMaxOverrideP ) ;
    ZE( countT , csttMax ) ;
    ZE( countT , csttMin ) ;
    stackC stFixedLength( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB | flSTACKc_FIFO , 2 * sizeof( countT ) ) ;

    }
        if( POOP ) return 0 ;
        }
            __( F( pstMatchP->flagsF( tinP ) ) & flSTACKc_FIFO ) ; // IF FIFO THEN WILL CONTAIN INCORRECT CONTENTS
        {
        if( pstMatchP )
        __Z( psttBigP->idAdam ) ;
        __Z( psttSmallP->idAdam ) ;
        if( POOP ) return 0 ;
        __Z( idP ) ;
        //U::FV(flSTRiDoPTIMIZEDcLOSURE,flagsP) ;
        __Z( psttBigP ) ;
        __Z( psttSmallP ) ;
        __Z( idFirstP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
//U:: /*1*/countT etherC::strIdOptimizedClosureF( tinS& tinP , stackC* pstMatchP , const flagsT flagsMatchP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* psttSmallP , const strokeS* psttBigP , const flagsT flagsP , const flagsT* pFlagsOverrideP , const countT* pcMinOverrideP , const countT* pcMaxOverrideP , const countT idLastP , sCountT idP )/*1*/
/*1*/countT strIdOptimizedClosureF( tinS& tinP , etherC& etherP , stackC* pstMatchP , const flagsT flagsMatchP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* psttSmallP , const strokeS* psttBigP , const flagsT flagsP , const flagsT* pFlagsOverrideP = 0 , const countT* pcMinOverrideP = 0 , const countT* pcMaxOverrideP = 0 , const countT idLastP = 0 , sCountT idP = 1 )/*1*/

/**/                                          
*/
  if 2, then caller wants the ooth match, etc.
  normally 1, which means that the caller wants the woth match in psttBigP
 idP
  this is the lath position that will be inspected when looking for a match
  the position in psttBigP to end the search
 idLastP
   the effect of that example is that a match requires either 0 occurrances or at most 8 occurrances, and minimal closure is done
    then 1, then 2, ... then 7, but no more, even if psttBigP is very long
    then 0 is tried
    ignore is tried
   example: BM_HIGH | 7 , flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG , not flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE:
  whether "ignore" is tried is not affected
   for example, if the element contains BM_HIGH | 7, then optimization will search only 7 or fewer repeats (8 or fewer occurances)
  the value of each element, ignoring the high bit, overrides the default repeat maximum (which is psttBigP->idAdam - 2)
  if not 0 then must point to a null terminated array of countT values, and each of these values must have the high bit set (using BM_HIGH)
  may be 0
 pcMaxOverrideP
   the effect of that example is that a match requires either 0 occurrances or at least 8 occurrances, and minimal closure is done
    then 8, then 9, then 0xa, ...
    then 7 is tried
    ignore is tried
   example: BM_HIGH | 7 , flSTRiDoPTIMIZEDcLOSURE_SHORTtOlONG , not flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE:
  whether "ignore" is tried is not affected
   for example, if the element contains BM_HIGH | 7, then optimization will search only 7 or more repeats (8 or more occurances)
  the value of each element, ignoring the high bit, overrides the default repeat minimum (which is 0)
  if not 0 then must point to a null terminated array of countT values, and each of these values must have the high bit set (using BM_HIGH)
  may be 0
 pcMinOverrideP
  for example, optimization of the woth "closure iteration" value encountered (normally the leftmost) is controlled by the woth element of the array
  all other valid flags override the corresponding flag in flagsP for the "closure iteration" occurance that corresponds to each element of the array
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT in these values is ignored (has no effect)
  if not 0 then must point to a null terminated array of flagsT values, and each of these nonze values must be a valid flSTRiDoPTIMIZEDcLOSURE constant
  may be 0
 pFlagsOverrideP
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT only changes the order in which the "closure iteration" strokeS's are iterated
  the match evaluation is always done left to right, i.e. from the beginning of psttSmallP to the end
   for simple searches, this search order does not affect the result
  flSTRiDoPTIMIZEDcLOSURE_RIGHTtOlEFT indicates that the leftmost occurance changes the most rapidly during the search
  controls how i search
 flagsP
  the string to search within
 psttBigP
   to optimize closure, i call myself recursively for each occurrance, and for each occurance, i try every "repeat value" in a range until i either match or exhaust the range
   the special stroke value is S3(-1,sc_ccSSSrEPEAT,-1)
   to be a regular expression, must begin with S2(sa_SSSaND,sc_ccSSS)
  normally, an IPDOS (tm) regular expression  
  if it does not contain a particular special strokeS value, then i am just a thin wrapper for strIdF
  a search specification string
 psttSmallP
  a quote strokeS to use to delimit literals, or strokeS( 0 , sc_IGNOREqUOTES )
 sttQuoteP
  this is the woth position that will be inspected when looking for a match
  the position in psttBigP to start the search
 idFirstP
 tinP
parameters
 in such a search, the '*' will match 0 or more of any character but will not consume literal matches that follow the '*' in the search string
for example, i am used to conduct searches semantically equivalent to the '*' wildcard in a windows file name search
if psttSmallP is an IPDOS (tm) regular expression that contains "closure iteration" values, then i call myself recursively to search for a match, using flags that specify how i am to search
if psttSmallP does not contain a special strokeS value that requests "closure iteration", then i am just a thin wraper for strIdF
i evaluate to the id of the woth strokeS in psttBigP that matches psttSmallP
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

//------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------------------------------




//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    idsP = idsLath ;

    }
        idfFixed = 0 ;
        stFixedLengthP << (byteT*)&c2f ;
        count2S c2f( idfFixed , idsLath - 1 ) ;
    {
    if( idfFixed )

    }
        if( bArmPossibleIgnore ) bArmPossibleIgnore -- ;

        }
            repeatMin = repeatMax = 0 ;
            ;
                : csttMaxP + repeatMax + 1 ;                            // CAN OVERFLOW FOR BAD FORM PARAMETER VALUES (HIGH VALUES OTHER THAN -1)
                ? - 1
            if( csttMaxP != - 1     ) csttMaxP = repeatMax == - 1
            if( !bArmPossibleIgnore ) csttMinP += repeatMin + 1 ;

            }
                idfFixed = 0 ;
                }
                    stFixedLengthP << (byteT*)&c2f ;
                    count2S c2f( idfFixed , idsi - 1 ) ;
                {
                if( idfFixed < idsi )
            {
            if( bArmPossibleIgnore || repeatMin != repeatMax )
        {
        else
        }
            }
                idfFixed = 0 ;
                }
                    stFixedLengthP << (byteT*)&c2f ;
                    count2S c2f( idfFixed , idsi - 1 ) ;
                {
                if( idfFixed < idsi )
            {
            if( bPushFixedIf )

            }
                if( csttMaxP != - 1     ) csttMaxP += idRepeatMax ;
                if( !bArmPossibleIgnore ) csttMinP += idRepeatMin ;

                if( idRepeatMin != idRepeatMax ) bPushFixedIf = 1 ;
            {
            else
            }
                else cIgnore += idRepeatMax ;
                }
                    offPatch ++ ;

                    if( bArmPossibleIgnore || repeatMin != repeatMax ) bPushFixedIf = 1 ;

                    ;
                        : 0
                            : pcMaxOverrideP[ offPatch ] & ~BM_HIGH
                            ? - 1
                        ? pcMaxOverrideP[ offPatch ] == - 1
                    repeatMax = pcMaxOverrideP && pcMaxOverrideP[ offPatch ]

                    ;
                        : 0
                        ? pcMinOverrideP[ offPatch ] & ~BM_HIGH
                    repeatMin = pcMinOverrideP && pcMinOverrideP[ offPatch ]

                    if( pFlagsOverrideP && pFlagsOverrideP[ offPatch ] && !( F(pFlagsOverrideP[ offPatch ]) & flSTRiDoPTIMIZEDcLOSURE_DOnOTiGNORE ) ) bArmPossibleIgnore = 2 ;
                {
                if( idRepeatMax == - 1 )                                                //U:: THIS CODE IS INCORRECT IN THAT IT FAILS TO HANDLE "DO NOT IGNORE" FLAG AND ALSO FAILS TO HANDLE IGNORE POSSIBILITY
            {
            if( idRepeatMin == - 1 )
            ZE( boolT , bPushFixedIf ) ;

            countT idRepeatMax = psttRegExpP[ CSpREFIX - 1 + idsi ].cNote  ;
            countT idRepeatMin = psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam ;
            repeatMin = repeatMax = 0 ;
        {
        else if( psttRegExpP[ CSpREFIX - 1 + idsi ].idCaste == sc_ccSSSrEPEAT )
        }
            repeatMin = repeatMax = 0 ;
            ;
                : csttMaxP + repeatMax + 1 ;                            // CAN OVERFLOW FOR BAD FORM PARAMETER VALUES (HIGH VALUES OTHER THAN -1)
                ? - 1
            if( csttMaxP != - 1     ) csttMaxP = repeatMax == - 1
            if( !bArmPossibleIgnore ) csttMinP += repeatMin + 1 ;                                                               //U:: THIS IS INCORRECT WHEN THE "OR BLOCK" CONTAINS AN "AND BLOCK"
            idsi = etherP.strIdLathExpressionF( tinP , psttRegExpP , idsi ) ;

            }
                idfFixed = 0 ;
                }
                    stFixedLengthP << (byteT*)&c2f ;
                    count2S c2f( idfFixed , idsi - 1 ) ;
                {
                if( idfFixed < idsi )
            {
            if( idfFixed && ( bArmPossibleIgnore || repeatMin != repeatMax ) )
        {
        else if( psttRegExpP[ CSpREFIX - 1 + idsi ].idCaste == sc_ccSSS && psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam == sa_SSSoR )
        }
            idfFixed = 0 ;
            }
                stFixedLengthP << (byteT*)&c2f ;
                count2S c2f( idfFixed , idsi - 1 ) ;
            {
            if( idfFixed < idsi )

            repeatMin = repeatMax = 0 ;
        {
        else if( psttRegExpP[ CSpREFIX - 1 + idsi ].idCaste == sc_ccSSS && ( psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam == sa_SSSrEPORTmATCH || psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam == sa_SSSrEPORTmATCHeND ) )
        }
            repeatMin = repeatMax = 0 ;

            ;
                : csttMaxP + csttMax2 * ( repeatMax + 1 ) ;                            // CAN OVERFLOW FOR BAD FORM PARAMETER VALUES (HIGH VALUES OTHER THAN -1)
                ? - 1
            if( csttMaxP != - 1     ) csttMaxP = repeatMax == - 1
            if( !bArmPossibleIgnore ) csttMinP += csttMin2 * ( repeatMin + 1 ) ;

            }
                idfFixed = 0 ;
                }
                    stFixedLengthP << (byteT*)&c2f ;
                    count2S c2f( idfFixed , idsi - 1 ) ;
                {
                if( idfFixed < idsi )
            {
            if( idfFixed && ( bArmPossibleIgnore || csttMin2 != csttMax2 ) )

            strAndExpressionLengthMinMaxF( tinP , etherP , csttMin2 , csttMax2 , stFixedLengthP , idsInspect , psttRegExpP , flagsOptimizeP , pFlagsOverrideP , pcMinOverrideP , pcMaxOverrideP ) ;
            countT idsInspect = idsi ;
            ZE( countT , csttMax2 ) ;
            ZE( countT , csttMin2 ) ;
        {
        else if( psttRegExpP[ CSpREFIX - 1 + idsi ].idCaste == sc_ccSSS && psttRegExpP[ CSpREFIX - 1 + idsi ].idAdam == sa_SSSaND )
        }
            repeatMin = repeatMax = 0 ;

            idsi = etherP.strIdLathExpressionF( tinP , psttRegExpP , idsi ) ;

            idfFixed = 0 ;
            cIgnore -- ;
        {
        if( cIgnore )

        if( !idfFixed ) idfFixed = idsi ;                           // PRESUMED TO BE THE BEGINNING OF A FIXED LENGTH SUBSTRING
    {
    for( countT idsi = idsP + 1 ; idsi < idsLath ; idsi ++ )
    ZE( countT , idfFixed ) ;
    ZE( countT , repeatMax ) ;
    ZE( countT , repeatMin ) ;
    ZE( boolT  , bArmPossibleIgnore ) ;
    ZE( countT , cIgnore ) ;
    ZE( countT , offPatch ) ;
    const countT idsLath = etherP.strIdLathExpressionF( tinP , psttRegExpP , idsP ) ;

    }
        if( POOP ) return ;
        __( psttRegExpP[ CSpREFIX - 1 + idsP ].idAdam  - sa_SSSaND ) ;
        __( psttRegExpP[ CSpREFIX - 1 + idsP ].idCaste - sc_ccSSS  ) ;
        if( POOP ) return ;
        __Z( psttRegExpP ) ;
        __Z( idsP ) ;
        __NZ( csttMaxP ) ;
        __NZ( csttMinP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
voidT strAndExpressionLengthMinMaxF( tinS& tinP , etherC& etherP , countT& csttMinP , countT& csttMaxP , stackC& stFixedLengthP , countT& idsP , const strokeS* const psttRegExpP , const flagsT flagsOptimizeP , const flagsT* pFlagsOverrideP , const countT* pcMinOverrideP , const countT* pcMaxOverrideP )

/**/
*/
    this is not currently enforced but might be in the future
   if contains regular expressions, must begin with sa_SSSaND
  must be a valid search pattern
 psttRegExpP
  will point to the matching sa_SSSaNDeND
  must point to an sa_SSSaND
  must not be 0
 idsP
  will be the maximum number of strokes that the AND subexpression at idsP will consume
  must be 0
 csttMaxP
  will be the minimum number of strokes that the AND subexpression at idsP will consume
  must be 0
 csttMinP
 tinP
parameters
i return the minimum and maximum number of strokes that can be consumed by the subexpression at idsP
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//


/*1*/WAKEsHOWtEXT( "scratch.3.dut.craft.etherC.emulation.of.filename.wildcards" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
