
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        }
            }
                off += 1 + ether.strBodyLengthF( tinP , pcPart ) ;
                swUsage = qty ;
                pcPart = &pcUsage[ off ] ;
                countT qty = pcUsage[ off ++ ] ;
            {
            while( cResources -- )
            countT cResources = pcUsage[ off ++ ] ;
            ZE( countT , off ) ;

            // FORMAT OF pcUsage: FIRST countT IS cResources.  FOR EACH RESOURCE: qty , rid. rid is null terminated.
        {

        { FORsTRINGSiN1( pstt1LogImpotence ) { stLogImpotence << psttc1 ; } }
        { FORsTRINGSiN1( pstt1Log          ) { stLog          << psttc1 ; } }

        countT*  pcUsage           = (countT*) ( (byteT*)&pcc[ 7 ] + cbLog + cbLogImpotence ) ;
        strokeS* pstt1LogImpotence = (strokeS*)( (byteT*)&pcc[ 7 ] + cbLog                  ) ;
        strokeS* pstt1Log          = (strokeS*)(         &pcc[ 7 ]                          ) ;
    {
    if( !ether )

    __( *(countT*)pbSoulP - 6 * sizeof( countT ) - cbLog - cbLogImpotence - cbUsage ) ;

    countT cbUsage        = pcc[ 6 ] ;
    countT cbLogImpotence = pcc[ 5 ] ;
    countT cbLog          = pcc[ 4 ] ;

    countT* pcc = (countT*)pbSoulP ;

    _INoLD_

    if( ether ) return ;
    __( *(countT*)pbSoulP < 5 * sizeof( countT ) ) ;
    if( ether ) return ;
    __Z( pbSoulP ) ;
    if( ether ) return ;
{
swUsage( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , pcPart )
pcPart( 0 ) ,
stLogImpotence( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ,
stLog( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ,
mPayin(   pbSoulP ? ((measureT*)pbSoulP)[ 3 ] : 0 ) ,
cDatum(   pbSoulP ? ((countT*)  pbSoulP)[ 2 ] : 0 ) ,
idcHirer( pbSoulP ? ((countT*)  pbSoulP)[ 1 ] : 0 ) ,
baton( tinP , TAG( TAGiDnULL ) ) ,
ether( etherP ) ,
/*1*/carC::carC( tinS& tinP , etherC& etherP , const byteT* const pbSoulP )/*1*/ :

/**/
*/
pbSoulP must continue to exist until i am destroyed
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.1350004.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

