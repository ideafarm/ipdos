
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    ++ s ; ether.osSleepF( tinP , TOCK * ( bHiredKid ? 0x10 : 0x1 ) ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    }
        CONoUTrAW3( "" , ++ cIn , ": iduuHome is still 0\r\n" ) ;
        static countT cIn ;
    {
    else if( !home.iduuHome )
    }
//U::ENABLE IN PRODUCTION:         etThread.ifcHireF( tinP , T("ifcIDaDAM_KERNEL4iDhOME") , ifcIDaDAM_CONSOLE , T("!noTells !ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
        bHiredKid = 1 ;
    {
    if( home.iduuHome && !bHiredKid )

    else { CONoUTrAW( "home.idptRelay is still 0\r\n" ) ; }
    }
        etThread( tinP , psPayload ) ;
        }
            etThread.cioPutF( tinP , ether , count8S( ifcIDcHANNEL1_BYfUNCTION , ifcIDcHANNELfUNCTION_QUERYiDhOME ) , *psPayload ) ;
            /*if( (countT)home.idptRelay != ifcIDpORT_RELAYtEST )*/ etThread.strokeF( tinP , T(".\r\n") ) ;
            CONoUTrAW( etThread ? "etThread is impotent\r\n" : "putting query\r\n" ) ;
        
            *psPayload << home.iduuHome ;
            home.idptRelay >> *psPayload ;
        {
        if( psPayload )
        etThread( tinP , psPayload , TAG( TAGiDnULL ) ) ;
        ZE( soulC* , psPayload ) ;
    {
    if( home.idptRelay )

    etThread( tinP , psEnvelope ) ;
    }
        etThread.cioPutF( tinP , ether , 0 , *psEnvelope ) ;

        *psEnvelope << (countT)ifcIDtYPEwRAP_QUERYrELAYiDpORTtIMEc ;
        *psEnvelope << (countT)1 ; // idVersion
        *psEnvelope << (countT)ifcIDpROTOCOL_RELAYwRAP ;
        *psEnvelope << (strokeS*)tTM ;
    {
    if( psEnvelope )
    etThread( tinP , psEnvelope , TAG( TAGiDnULL ) ) ;

    etThread( tinP , psEnvelope ) ;
    }
        etThread.cioPutF( tinP , ether , 0 , *psEnvelope ) ;

        *psEnvelope << (countT)ifcIDtYPEwRAP_QUERYrELAYrANK ;
        *psEnvelope << (countT)1 ; // idVersion
        *psEnvelope << (countT)ifcIDpROTOCOL_RELAYwRAP ;
        *psEnvelope << (strokeS*)tTM ;
    {
    if( psEnvelope )
    etThread( tinP , psEnvelope , TAG( TAGiDnULL ) ) ;
    ZE( soulC* , psEnvelope ) ;
{
while( !ether && !etThread )
ZE( boolT , bHiredKid ) ;

}
    etThread( tinP , psEnvelope ) ;
    }
        etThread.cioPutF( tinP , ether , 0 , *psEnvelope ) ;

        *psEnvelope << (countT)0 ; // ccFilter
        psEnvelope->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_countTptr , (countT*)0 ) ; // pcFilter
        *psEnvelope << (countT)0 ; // ccTestMax ;
        *psEnvelope << (countT*)count8S( ifcIDcHANNEL1_BYfUNCTION , ifcIDcHANNELfUNCTION_REPLYiDhOME ) ;
        *psEnvelope << (countT)ifcIDtYPEwRAP_CHANNELiNCLUDEpUSH ;
        *psEnvelope << (countT)1 ; // idVersion
        *psEnvelope << (countT)ifcIDpROTOCOL_RELAYwRAP ;
        *psEnvelope << (strokeS*)tTM ;
    {
    if( psEnvelope )
    etThread( tinP , psEnvelope , TAG( TAGiDnULL ) ) ;

    etThread( tinP , psEnvelope ) ;
    }
        etThread.cioPutF( tinP , ether , 0 , *psEnvelope ) ;

        *psEnvelope << (countT)0 ; // ccFilter
        psEnvelope->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_countTptr , (countT*)0 ) ; // pcFilter
        *psEnvelope << (countT)0 ; // ccTestMax ;
        *psEnvelope << (countT*)count8S( ifcIDcHANNEL1_BYfUNCTION , ifcIDcHANNELfUNCTION_QUERYiDhOME ) ;
        *psEnvelope << (countT)ifcIDtYPEwRAP_CHANNELiNCLUDEpUSH ;
        *psEnvelope << (countT)1 ; // idVersion
        *psEnvelope << (countT)ifcIDpROTOCOL_RELAYwRAP ;
        *psEnvelope << (strokeS*)tTM ;
    {
    if( psEnvelope )
    etThread( tinP , psEnvelope , TAG( TAGiDnULL ) ) ;
    ZE( soulC* , psEnvelope ) ;
{
TN( tTM , "IdeaFarm " "(tm)" ) ;

etThread.cioSetGetF( tinP , cioGetF ) ;
etThread.cioSetArgF( tinP , cArg ) ;

}
    etThread.delF( tinP , pbi ) ;
    else if( pbi && cbi == sizeof( home.iduuHome ) ) home.iduuHome = *(countT*)pbi ;
    if( POOP ) POOPR
    tinP.pEtScratch->boxGetShadowF( tinP , pbi , cbi , tFileIdHome , 1 ) ; ___( pbi ) ;
    tinP.pEtScratch->boxZapF( tinP , tFileIdHome , 1 ) ; //U::
    SCOOPS

    TN( tFileIdHome , "///ideafarm/ephemeral/domains/com/ideafarm/" ) ; tFileIdHome += TF1(DDNUMB)+T("/iduuHome") ;
    ZE( countT , cbi ) ;
    ZE( byteT* , pbi ) ;
{
IFsCRATCH
homeS& home = homeS::homeIF() ;

countT cArg = (countT)&c8p ;
count8S c8p( (countT)&lever , (countT)&swIdp ) ;
switchC swIdp( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever , 0 , sizeof( idPortC ) ) ;
ZE( countT , lever ) ;

TODO

}
    if( idptOriginP ) ;
    DEL( psGiftP ) ; //OPTIONAL
    etherP.delF( tinP , pczChannelP ) ; //OPTIONAL
    }
        //CONoUTrAW( "cioGetF: _APPLICATION\r\n" ) ; //U::
        }
            }
                }
                    etherP.strokeF( tinP , T("my iduuHome is now ")+TF1(home.iduuHome)+T("\r\n") ) ;
                    etherP.boxPutF( tinP , tFileIdHome , (byteT*)&home.iduuHome , sizeof home.iduuHome ) ;
                    TN( tFileIdHome , "///ideafarm/ephemeral/domains/com/ideafarm/" ) ; tFileIdHome += TF1(DDNUMB)+T("/iduuHome") ;

                    home.iduuHome = iduuHomeAssigned ;
                {
                if( idptRelay == home.idptRelay && home.iduuHome != iduuHomeAssigned )
                if( (countT)idptRelay != ifcIDpORT_RELAYtEST ) etherP.strokeF( tinP , T("R\r\n") ) ;
                *psGiftP >> iduuHomeAssigned ;
                ZE( countT , iduuHomeAssigned ) ;
                idptRelay << *psGiftP ;
                idPortTimeC idptRelay ;
            {
            else if( pczChannelP[ 1 ] == ifcIDcHANNELfUNCTION_REPLYiDhOME )
            }
                }
                    etherP( tinP , psQuery ) ;
                    }
                        }
                            etherP( tinP , psGift ) ;
                            }
                                etherP.cioPutF( tinP , bQuitP , count8S( ifcIDcHANNEL1_BYfUNCTION , ifcIDcHANNELfUNCTION_REPLYiDhOME ) , *psGift ) ;
                            
                                *psGift << iduuHomeRequested ;
                                idptRequestor >> *psGift ;
                            {
                            if( psGift )
                            etherP( tinP , psGift , TAG( TAGiDnULL ) ) ;
                            ZE( soulC* , psGift ) ;
                        {
                        if( bReply )

                        swIdpP.ungrabF( tinP ) ;

                        else if( idpAssigned != idptRequestor ) { BLAMMO ; }
                        }
                            bReply = 1 ;
                            idpAssigned = idptRequestor ;
                        {
                        if( !idpAssigned )
                        ZE( boolT , bReply ) ;
    
                        idPortC& idpAssigned = *(idPortC*)&(countT&)swIdpP ;
                        leverP = iduuHomeRequested ;
    
                        if( !iduuHomeRequested ) { BLAMMO ; } //U: IN PRODUCTION I WILL NEED TO RETIRE AND REUSE LOW VALUES

                        }
                            iduuHomeRequested = heavyLever + 1 ;
                            countT heavyLever = swIdpP.leverF( tinP , swIdpP.cFlavorsF( tinP ) ) ;
                        {
                        if( !iduuHomeRequested )

                        }
                            }
                                }
                                    break ;
                                    iduuHomeRequested = leverP ;
                                {
                                if( idptRequestor == idpTest )
                                idPortC& idpTest = *(idPortC*)&(countT&)swIdpP ;
                                leverP = swIdpP.leverF( tinP , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            countT cFlavors = swIdpP.cFlavorsF( tinP ) ;
                        {
                        if( !iduuHomeRequested )

                        swIdpP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                        if( (countT)idptRequestor != ifcIDpORT_RELAYtEST ) etherP.strokeF( tinP , T("Q\r\n") ) ;
                        *psGiftP >> iduuHomeRequested ;
                        ZE( countT , iduuHomeRequested ) ;
                        idptRequestor << *psGiftP ;
                        idPortTimeC idptRequestor ;
                    {
                    if( psQuery )
                    etherP( tinP , psQuery , TAG( TAGiDnULL ) ) ;
                    ZE( soulC* , psQuery ) ;
                {
                if( home.idRank == 1 )
                CONoUTrAW( "got query\r\n" ) ;
            {
            if( pczChannelP[ 1 ] == ifcIDcHANNELfUNCTION_QUERYiDhOME )
        {
        if( pczChannelP && pczChannelP[ 0 ] == ifcIDcHANNEL1_BYfUNCTION )
        //etherP.strokeF( tinP , T("idRank ")+TF1(home.idRank)+T(" received application payload on channel ")+T(pczChannelP)+T("\r\n") ) ;
        //CONoUTrAW( "cioGetF: _APPLICATION\r\n" ) ; //U::
    {
    else if( idGiftTypeP == ifcIDtYPEgIFT_APPLICATION )
    }
        //CONoUTrAW( "cioGetF: _REPLYrELAYiDpORTtIMEc\r\n" ) ; //U::
        }
            home.idptRelay = idpt ;
            //etherP.strokeF( tinP , T("changing my time from ")+TT(tOld.time1,tOld.time2)+T(" to ")+TT(tNew.time1,tNew.time2)+T("\r\n") ) ; //U::

            const timeS& tNew = idpt ;
            const timeS& tOld = home.idptRelay ;
        {
        if( home.idptRelay != idpt )
        idpt << *psGiftP ;
        idPortTimeC idpt ;
        //etherP.strokeF( tinP , T("received my relay timestamp\r\n") ) ; //U::
        //CONoUTrAW( "cioGetF: _REPLYrELAYiDpORTtIMEc\r\n" ) ; //U::
    {
    else if( idGiftTypeP == ifcIDtYPEgIFT_REPLYrELAYiDpORTtIMEc )
    }
        //CONoUTrAW( "cioGetF: _REPLYrELAYrANK\r\n" ) ; //U::
        }
            home.idRank = idRank ;
            //etherP.strokeF( tinP , T("changing my idRank from ")+TF1(home.idRank)+T(" to ")+TF1(idRank)+T("\r\n") ) ; //U::
        {
        if( home.idRank != idRank )
        *psGiftP >> idRank ;
        ZE( countT , idRank ) ;
        //etherP.strokeF( tinP , T("received my relay rank\r\n") ) ; //U::
        //CONoUTrAW( "cioGetF: _REPLYrELAYrANK\r\n" ) ; //U::
    {
    if( idGiftTypeP == ifcIDtYPEgIFT_REPLYrELAYrANK )

    homeS& home = homeS::homeIF() ;

    switchC&     swIdpP    =     *(switchC*)c8p.c2 ;
    countT&      leverP    =      *(countT*)c8p.c1 ;
    count8S& c8p = *(count8S*)cArgP ;
{
voidT cioGetF( tinS& tinP , etherC& etherP , const boolT& bQuitP , const countT idGiftTypeP , soulC*& psGiftP , countT*& pczChannelP , countT& cArgP , const idPortTimeC& idptOriginP )

/*1*/WAKEhIDE( "ifcIDaDAM_KERNEL4iDhOME" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

