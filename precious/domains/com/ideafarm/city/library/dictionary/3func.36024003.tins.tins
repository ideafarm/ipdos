
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        //SAYnAME( " tinS/-\r\n" )
    
        }
            if( idTinNamed == ifcIDtINnAMED_tinBreakI ) thirdC::c_strncpyIF( tinP , postTell , "refusalsToClose:0    logoffsSeen:0" , sizeof postTell ) ; //CODEsYNC: 12f0006 10200cc
            thirdC::c_strncpyIF( tinP , postTell , "tinS::tinS: i am now registered" , sizeof postTell ) ;
            }
                TELLsYSc3LIFI( idTypeSay , (byteT*)&info , sizeof info , idLineCt , idiFileCt )
                info.idiFileCt  = idiFileCt ;
                info.idLineCt   = idLineCt ;
                info.idTinNamed = idTinNamed ;
                thirdC::c_strncpyIF( tinP , info.postThreadName , postThreadName , sizeof info.postThreadName ) ;
                info.idTin      = idTin ;
                //info.ip       = aptMe ? aptMe : (countT)this ;
                info.ip         = (countT)this ;
                info.idSerial   = idSerial ;
                tellInfoSysTinS info ;
                //countT idTypeSay = aptMe ? ifcIDtYPEtELLsYS_TINcTI : ifcIDtYPEtELLsYS_TINcTP ;
                countT idTypeSay = ifcIDtYPEtELLsYS_TINcTP ;
                //ap_artmentOldC aptMe( tinP , (byteT*)this ) ;
                thirdC::c_strncpyIF( tinP , postTell , "tinS::tinS: registering myself" , sizeof postTell ) ;
            {
            if( !( F(flags) & flTINs_CONSTRUCTqUIETLY ) )
    
            }
                }
                    TELLsYSc3LIFI( ifcIDtYPEtELLsYS_LIFInAME , (byteT*)&info , sizeof info , idLineCt , idiFileCt ) ;
                    info.costName = thirdC::c_strlenIF( tinP , info.postName ) ;
                    thirdC::c_strncpyIF( tinP , info.postName , postOverride , sizeof info.postName ) ;
                    info.idiFile = idiFileCt ;
                    info.idLine = idLineCt & 0xfff ;
                    tellInfoSysLifiS info ;
    
                    osTextT* postOverride = idiFileCt != 0x3000b71 ? postn : "earlyLate" ;
                {
                if( postn )
        
                }
                    if( idTinNamed == ifcIDtINnAMED_tinHeartI || idTinNamed == ifcIDtINnAMED_tinBreakI ) thirdC::c_strncpyIF( tinP , postThreadName , postn , sizeof postThreadName ) ;
                    }
                        }
                            break ;
                            if( !setIfZeAM( bDone , 1 ) ) postn = "earlyLateOrException" ;
                            static countT bDone ;
                        {
                        case ifcIDtINnAMED_tinEarlyLate :
                        case ifcIDtINnAMED_tinBreakI    : { postn = "tmBreakF" ; break ; }
                        case ifcIDtINnAMED_tinHeartI    : { postn = "tmHeartF" ; break ; }
                    {
                    switch( idTinNamed )
                {
                ZE( osTextT* , postn ) ;
            {
            if( idTinNamed == ifcIDtINnAMED_tinHeartI || idTinNamed == ifcIDtINnAMED_tinBreakI || idTinNamed == ifcIDtINnAMED_tinEarlyLate )
        
            if( idTinNamed == ifcIDtINnAMED_tinVeryVeryEarlyLateMainI && monitor.idThread <= ClOWtHREADS && !( ++ processGlobal1I.pcPhaseLow[ monitor.idThread ] ) ) { BLAMMO ; }

            TELL( "tinS: after setting processGlobal1I.flCt flag" )
            }
                }
                    case ifcIDtINnAMED_tinInPoolMain             : { processGlobal1I.flCt |= flCTdTg_tinMainInPool             ; break ; }
                    case ifcIDtINnAMED_tinVeryEarlyLateMainI     : { processGlobal1I.flCt |= flCTdTg_tinVeryEarlyLateMainI     ; break ; }
                    case ifcIDtINnAMED_tinVeryVeryEarlyLateMainI : { processGlobal1I.flCt |= flCTdTg_tinVeryVeryEarlyLateMainI ; break ; }
                {
                switch( idTinNamed )
    
                if( pTinF() != this ) { BLAMMO } ;
            {
            if( idTinNamed != ifcIDtINnAMED_tinHeartI && idTinNamed != ifcIDtINnAMED_tinBreakI )
            TELL( "tinS: setting processGlobal1I.flCt flag and testing pTinF()" )
        
            TINSL
    
            }
                thirdC::c_strncpyIF( tinP , postTell , "tinS::tinS: my image is now valid by raw construction" , sizeof postTell ) ;
                putNegAM( fingerprint , FINGERnEG_TINs ) ; //MY IMAGE IS NOW COMPLETELY VALID
                monitor.idDirty ++ ;
        
                }
                    thirdC::c_strncpyIF( tinP , processGlobal2I.pLowThread[ monitor.idThread ].postThreadName , postThreadName , sizeof processGlobal2I.pLowThread[ monitor.idThread ].postThreadName ) ;
                    processGlobal2I.pLowThread[ monitor.idThread ].osTid = osTid ;
                    if( processGlobal2I.pLowThread[ monitor.idThread ].osTid ) { BLAMMO ; }
                {
                if( monitor.idThread <= ClOWtHREADS )
                
                //U::WILL pPoop WORK?: declareVmUsageTypeGF( tinP , (byteT*)tinP.pPoop , flVMuSAGEtYPE_CPUsTACK , monitor.idThread , postThreadName ) ;
                thirdC::c_strncpyIF( tinP , postThreadName , postThreadNameP , sizeof postThreadName ) ;
        
                //monitor.pLFnest[ 3 ] = idiFileCt ;
                //monitor.pLFnest[ 2 ] = idLineCt & ~fliSTEP_FLAGmASK ;
                //monitor.cInNest = 1 ; //ENSURES THAT THE MONITOR WILL NEVER SEE A NULL monitor.cInNest (IF IT DOES, THERE IS A BUG)
                
                }
                    thirdC::c_memsetIF( tinP , postTellIf          , sizeof postTellIf ) ;
                    thirdC::c_memsetIF( tinP , postTellWait        , sizeof postTellWait ) ;
                    thirdC::c_strncpyIF( tinP , postTell , "constructing this tinS, object" , sizeof postTell ) ;
                {
                //thirdC::c_memsetIF( tinP , (byteT*)ppTinKid   , sizeof ppTinKid ) ;
                thirdC::c_memsetIF( tinP , (byteT*)pcUtility , sizeof pcUtility ) ;
                }
            
                    pFlagsThreadLevelMode[ off ] = flTHREADlEVELmODE_null ;
                    pIdProgressNest[       off ] = 0 ;
                    pEIPInNest[            off ] = 0 ;
                    pIdInNest[             off ] = 0 ;
                {
                for( countT off = 0 ; off <= OFFsLOTtINnESTmAX ; off ++ )
                {for( countT off = 0 ; off < sizeof monitor.pLFnest / sizeof monitor.pLFnest[ 0 ] ; off ++ ) monitor.pLFnest[ off ] = 0 ;}
                //O: USE thirdC::c_memsetIF
                
                {for( countT off = 0 ; off < sizeof pLFstep / sizeof pLFstep[ 0 ] ; off ++ ) pLFstep[ off ] = 0 ;}
                monitor.idDirty ++ ;
                
                const boolT bComments = !( F(flags) & flTINs_DISABLEcOMMENTS  ) ;
        
                }
                    LOGrAW( "+\r\n" ) ;
                    LOGrAW( postThreadNameP ) ;
                    //CONoUTnOtIN2( postThreadNameP , 1 ) ;
                {
                if( F(thirdC::third_flagsModeAdam2I_IF(*this)) & flADAMmODE2_THREADcHATTER )
        
                }
                    }
                        //LOG rAW3nOtIN( "/" , monitor.idThread , "/+\r\n" ) ;
                        //LOG rAWnOtIN( postThreadNameP ) ;
                        //LOG rAW3nOtIN( "" , pAdamGlobal1->idAdam , " " ) ;
                    {
                    //if( !thirdC::c_strcmpIF( postThreadNameP , "tmKillSocketF" ) )
                {
                if( F(thirdC::third_flagsModeAdam2I_IF(*this)) & flADAMmODE2_THREADcHATTER )

                TINSL
                ctTellCopyDoneF( (countT)this ) ;
            {
            else
            }
                if( pTinOld->pPoop != &pTinOld->poop ) { BLAMMO ; }
        
                thirdC::c_strncpyIF( postTell , "tinS::tinS: my image is now valid by copying my elder" , sizeof postTell ) ;

                if( thirdC::c_memcpyWithCallBackIF( (byteT*)this + CBtINpREFIX , (byteT*)&tinSelfOrElderP + CBtINpREFIX , sizeof( tinS ) - CBtINpREFIX - CBtINsUFFIX , ctTellCopyDoneF , (countT)this ) ) { BLAMMO ; } //CODE SYNC: 003002a 12f0002 12f0003

                putNegAM( tinSelfOrElderP.fingerprint , FINGERnEG_TINszOMBIE ) ; //FROM NOW UNTIL I REGISTER MYSELF, MONITOR WILL NOT BE ABLE TO SEE A tinS FOR THIS THREAD
                if( getNegAM( tinSelfOrElderP.fingerprint ) != FINGERnEG_TINs ) BLAMMO ;

                //SAYnAME( " tinS/ " ) CONoUTrAW( " copying from " ) ; CONoUTrAW( NAME( tinSelfOrElderP.idTinNamed ) ) ; CONoUTrAW( "\r\n" ) ;
                *(tinS**)&pTinOld = &tinSelfOrElderP ;
            {
            if( !( F(flags) & flTINs_NOeLDER ) )
        
            }
                idSerial  = ph ? 1 + incv02AM( ph->idSerialLath ) : 0 ;
                homeS* ph = ( F(processGlobal1I.flCt) & flCTdTg_napHomeI && !( F(processGlobal1I.flDt) & flCTdTg_napHomeI ) ) ? (homeS*)(byteT*)processGlobal3I.napHome : 0 ;
            {
            //U::VALIDATE flags...NOTE THAT flags IS NOT VALIDATED. THIS IS BECAUSE I DO NOT HAVE AN POOP TO SET U::CONJ: IT COULD BE VALIDATED NOW THAT I KNOW WHETHER I CAN USE tinP AS MY ELDER)    
        
            else            thirdC::c_memsetIF( tinSelfOrElderP , (byteT*)pbBitsCt , sizeof pbBitsCt ) ;
            if( pbBitsCtP ) thirdC::c_memcpyIF( tinSelfOrElderP , (byteT*)pbBitsCt , (byteT*)pbBitsCtP , sizeof pbBitsCt ) ;
        
            idDesireProcess = thirdC::dosPriorityProcessIF( tinSelfOrElderP ) ;
            idDesire = thirdC::dosPriorityIF( tinSelfOrElderP ) ;
        {

        thirdC::c_memsetIF( tinSelfOrElderP , (byteT*)postPad2                    , sizeof postPad2                    ) ;

        thirdC::c_memsetIF( tinSelfOrElderP , (byteT*)postThreadName              , sizeof postThreadName              ) ;

        thirdC::c_memsetIF( tinSelfOrElderP , (byteT*)postPad1                    , sizeof postPad1                    ) ;

        thirdC::c_memsetIF( tinSelfOrElderP , (byteT*)pPanLifiRecurseGrabbedLevel , sizeof pPanLifiRecurseGrabbedLevel ) ;

        thirdC::c_memsetIF( tinSelfOrElderP , (byteT*)pBookMark                   , sizeof pBookMark                   ) ;

        else                                            thirdC::c_memsetIF( tinSelfOrElderP , (byteT*)ppJot                           , sizeof ppJot ) ;
        if( F(flags) & flTINs_INHERITjOTrEGISTRATIONS ) thirdC::c_memcpyIF( tinSelfOrElderP , (byteT*)ppJot , (byteT*)pTinDadP->ppJot , sizeof ppJot ) ;

        thirdC::c_memsetIF( tinSelfOrElderP , (byteT*)pcGrabitRecurse             , sizeof pcGrabitRecurse             ) ;
        thirdC::c_memsetIF( tinSelfOrElderP , (byteT*)pcGrabitOsTid               , sizeof pcGrabitOsTid               ) ;
        thirdC::c_memsetIF( tinSelfOrElderP , (byteT*)ppbGrabitRecurse            , sizeof ppbGrabitRecurse            ) ;
    
        thirdC::c_memsetIF( tinSelfOrElderP , (byteT*)pcLevelUntagged             , sizeof pcLevelUntagged             ) ;
        thirdC::c_memsetIF( tinSelfOrElderP , (byteT*)ppbNewUntagged              , sizeof ppbNewUntagged              ) ;
    
        //SAYnAME( " tinS/+\r\n" )

        if( !idTinNamedP ) { BLAMMO ; }
    {
{
//idDesire_cGrab_pTinKid( 0 )
pSexLifoConstructing( 0 )
pSgnUtility( 0 ) ,
cSpins4( 0 ) ,
cSpins3( 0 ) ,
cSpins2( 0 ) ,
cSpins1( 0 ) ,
bSuppressInOutTrace( 0 ) ,
pbRecursiveParameters( 0 ) ,
pBarryUtility( 0 ) ,
fliSexCtPendingExpSlots( 0 ) ,
fliSexCtPendingExpCbSlot( 0 ) ,
cPoolDropDt( 0 ) ,
cPoolDropCt( 0 ) ,
valueExpectedByInOut( 0 ) ,
pcWatchedByInOut( 0 ) ,
cTls( 0 ) ,
flagsTrace_soulC( flTRACEsOULc_ON | flTRACEsOULc_INHERIT | flTRACEsOULc_countT | flTRACEsOULc_DUMP ) ,
cArmTrace_soulC( 0 ) ,
pClean( 0 ) ,
ta( tinSelfOrElderP ) ,
pBk0TraceScratch( 0 ) ,
pBk0TelemetryAppScratch( 0 ) ,
pBk0TelemetrySysScratch( 0 ) ,
pAdam( 0 ) ,
pPoolUse( tinSelfOrElderP.pAdamGlobal1->pPoolAdamTemp ) ,
odoSockCbWrite( 0 ) ,
odoSockCbRead( 0 ) ,
pSwsRecycle( 0 ) ,
pczl_pSwsRecycle( 0 ) ,
ccExitsWhere( sizeof tinSelfOrElderP.pAdamGlobal1->pcExitsWhere / sizeof tinSelfOrElderP.pAdamGlobal1->pcExitsWhere[ 0 ] ) ,
pcExitsWhere( tinSelfOrElderP.pAdamGlobal1->pcExitsWhere ) ,
pPoop( &poop ) ,
poop( flPOOP_SMELLY ) ,
pTieLath( 0 ) ,
postRptExceptionLath( 0 ) ,
//idiFileMileDad( 0 ) ,
//idLineMileDad( 0 ) ,
idiFileMile( 0 ) ,
idLineMile( 0 ) ,
cbTls( cbTlsP ) ,
pbTls( pbTlsP ) ,
cYield( 0 ) ,
idTinNamed( idTinNamedP ) ,
pTinOld( 0 ) ,
pRestart( 0 ) ,
pEtScratch( 0 ) ,
pEtText( 0 ) ,
pcQuit( 0 ) ,
//cGrab_pTinKid( 0 ) ,
//pTinBro( 0 ) ,
//pTinKid( 0 ) ,
//pTinDad( pTinDadP ) ,                                     //U::20180630@1405: WHY ARE THESE COMMENTED OUT?  CONJ: THEY ARE SET DURING COPYING OF THE IMAGE FROM DAD TO ME
ranUni( tinSelfOrElderP , MAXcOUNTT , idThreadP ) ,
cGrabitC_unregistered( 0 ) ,
cGrabitC_registered( 0 ) ,
cGrabitC_reset( 0 ) ,
cGrabitC_set( 0 ) ,
zap_pPanLifiRecurseGrabbedLevel_( (byteT*)pPanLifiRecurseGrabbedLevel , sizeof pPanLifiRecurseGrabbedLevel, flZAP_CT ) ,
msSleepWhenGrabbing( 0x40 + ( osTid & 0x1f ) << 3 ) ,
grabPseudo( tinSelfOrElderP , idLineCtP , idiFileCtP , 0 , flGRABc_tINSoBJECT | flGRABc_DISABLED | flGRABc_PSEUDO ) ,
pEther( 0 ) ,
pScoops( 0 ) ,
pScoopEtThread( 0 ) ,
monitor( tinSelfOrElderP , idThreadP ) ,
idBlammo( 0 ) ,
idiFile_brcLath( 0 ) ,
idLine_brcLath( 0 ) ,
brcLath( 0 ) ,
brcQuery( 0 ) ,
bosFail( 0 ) ,
brcm04Raw( 0 ) ,
brcRaw( 0 ) ,
cKidThreads( 0 ) ,
flagsThreadMode3( flTHREADmODE3_INoUT ) ,
flagsThreadMode2( flTHREADmODE2_null ) ,
flagsThreadMode1( flTHREADmODE1_UPDATEtIN ) ,
idPhase3( 0 ) ,
idPhase2( 0 ) ,
idPhase1( ifcIDpHASEtHREAD_PROLOG ) ,
idlTask( 0 ) ,
idiTask( 0 ) ,
cManna( 0 ) ,
cRain( 0 ) ,
time2( 0 ) ,
time1( 0 ) ,
osPid( dosGetInfoBlocksIdProcessIF( tinSelfOrElderP ) ) ,
osTid( ( putNegAM( fingerprint , FINGERnEG_TINszOMBIE ) , ( this == &processGlobal5I.tinBreak || this == &processGlobal4I.tinHeart ) ? 0 : dosGetInfoBlocksIdThreadIF() ) ) ,
idDesireProcess( 0 ) ,
idDesire( 0 ) ,
fingerprint( 0 ) ,
pAdamGlobal6( pTinDadP ? pTinDadP->pAdamGlobal6 : ( idTinNamedP == ifcIDtINnAMED_tinInPool ? tinSelfOrElderP.pAdamGlobal6 : &rootAdamGlobal6I ) ) ,
pAdamGlobal5( pTinDadP ? pTinDadP->pAdamGlobal5 : ( idTinNamedP == ifcIDtINnAMED_tinInPool ? tinSelfOrElderP.pAdamGlobal5 : &rootAdamGlobal5I ) ) ,
pAdamGlobal4( pTinDadP ? pTinDadP->pAdamGlobal4 : ( idTinNamedP == ifcIDtINnAMED_tinInPool ? tinSelfOrElderP.pAdamGlobal4 : &rootAdamGlobal4I ) ) ,
pAdamGlobal3( pTinDadP ? pTinDadP->pAdamGlobal3 : ( idTinNamedP == ifcIDtINnAMED_tinInPool ? tinSelfOrElderP.pAdamGlobal3 : &rootAdamGlobal3I ) ) ,
pAdamGlobal2( pTinDadP ? pTinDadP->pAdamGlobal2 : ( idTinNamedP == ifcIDtINnAMED_tinInPool ? tinSelfOrElderP.pAdamGlobal2 : &rootAdamGlobal2I ) ) ,
pAdamGlobal1( pTinDadP ? pTinDadP->pAdamGlobal1 : ( idTinNamedP == ifcIDtINnAMED_tinInPool ? tinSelfOrElderP.pAdamGlobal1 : &rootAdamGlobal1I ) ) ,
idiFileCt( idiFileCtP ) ,
idLineCt( idLineCtP ) ,
flags( flagsP ) ,
tally( tinSelfOrElderP ) ,
) ,
    (countT)this
    ,
        : (countT*)0
        ? (countT*)&pTinMainI
    idTinNamedP == ifcIDtINnAMED_tinInPoolMain
    ||
    idTinNamedP == ifcIDtINnAMED_tinVeryVeryEarlyLateMainI
(
top_pTinMainI_
idTin( 1 + incv02AM( processGlobal1I._tinS_idTinLath ) ) ,
idSerial( 0 ) ,
/*1*/tinS::tinS( tinS& tinSelfOrElderP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const countT idThreadP , tinS* const pTinDadP , const osTextT* const postThreadNameP , const flagsT flagsP , const countT idTinNamedP , byteT* const pbTlsP , const countT cbTlsP )/*1*/ :

// "tinSelfOrElderP": USUALLY SO, BUT NOT ALWAYS (AN EXCEPTION TIN WILL BE, YOU GUESSED IT, AN EXCEPTION (S))

//CONJ: THE PRECEDING COMMENT IS OBSOLETE AND NO LONGER TRUE
// THIS DEFINITION MUST WORK WHEN tinP REFERENCES BYTES THAT ARE ALL SET TO 0 ("tinS. processGlobal3I.tinVeryVeryEarlyLateMain( processGlobal3I.tinVeryVeryEarlyLateMain , TAG( TAGiDnULL ) , flTINs_CONSTRUCTqUIETLY ) ;")

/**/
*/
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.12f0006.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

