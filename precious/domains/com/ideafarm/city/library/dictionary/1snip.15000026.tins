
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


;
}
 friend countT dtTellCopyDoneF( countT c_thisP ) ;
 friend countT ctTellCopyDoneF( countT c_thisP ) ;

 FRIENDS_tinS
/**/

 private :

 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.3400d.tinS.pbF!||
 byteT* pbF( countT idP = 1 ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.3400c.tinS.tlsDelF!||
 voidT tlsDelF( byteT*& pbMeP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.3400b.tinS.tlsNewF!||
 byteT* tlsNewF( const countT cbP , const osTextT* const postNameP = 0 , const osTextT* const postGroupP = 0 ) ;
/*tls*/

 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34013.tinS.unwatchedF!||
 voidT unwatchedF( voidT ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.3400a.tinS.deregisterIfF!||
 voidT deregisterIfF( tinS& tinP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34009.tinS.walkF!||
 voidT walkF( tinS& tinRootP , tinWalkerFT tinWalkerFP , countT& cArgP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34008.tinS.rootF!||
 tinS& rootF( voidT ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34012.tinS.get_pIdProgressNest_F!||
 voidT get_pIdProgressNest_F( tinS& tinP , countT* const pcP , const countT ccP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34011.tinS.get_pEIPInNest_F!||
 voidT get_pEIPInNest_F( tinS& tinP , countT* const pcP , const countT ccP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34010.tinS.get_pIdInNest_F!||
 voidT get_pIdInNest_F( tinS& tinP , countT* const pcP , const countT ccP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.3400f.tinS.get_pFlagsThreadLevelMode_F!||
 voidT get_pFlagsThreadLevelMode_F( tinS& tinP , countT* const pcP , const countT ccP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.3400e.tinS.get_pLFstep_F!||
 voidT get_pLFstep_F( tinS& tinP , countT* const pcP , const countT ccP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34007.tinS.get_pLFnest_F!||
 voidT get_pLFnest_F( tinS& tinP , countT* const pcP , const countT ccP ) ;
 inline flagsT flagsF( voidT ) { return flags ; }
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34006.tinS.levelModeF!||
 voidT levelModeF( const flagsT flagsModeP = flTHREADlEVELmODE_null , sCountT cLevelsP = 0 , const sCountT offRelLevelP = 0 ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34005.tinS.zePointerFieldsF!||
 voidT zePointerFieldsF( tinS& tinP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34004.tinS.strFuseF!||
 voidT strFuseF( tinS& tinP , etherC& etherP , strokeS*& psttP , const countT csttExtraP = 0 , const flagsT flagsInclude1P = flTINrPT1_null , const flagsT flagsInclude2P = flTINrPT2_null , const flagsT flagsExclude1P = flTINrPT1_null , const flagsT flagsExclude2P = flTINrPT2_null , countT idFormatP = 0 , const countT cIndentP = 0 ) ;
/* commands */

 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34003.tinS.tinS!||
 tinS( tinS& tinSelfOrElderP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const countT idThreadP , tinS* const pTinDadP = 0 , const osTextT* const postThreadNameP = 0 , const flagsT flagsP = flTINs_null , const countT idTinNamedP = 0 , byteT* const pbTlsP = 0 , const countT cbTlsP = 0 ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34002.tinS.dt_tinS!||
 ~tinS( voidT ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34001.tinS.NEWdELcLASSppOOLoLD!||
 NEWdELcLASSpROTOS
/* birth , death */
/**/

 //CODEsYNCHeND: DO NOT CHANGE THIS CODE WITHOUT ALSO CHANGING THE SYNC CODE
 #define CBtINsUFFIX ( /*J*/ sizeof ppJot + /*A*/1 * sizeof( grabC ) + /*B*/( 1 /*+ 3 + ClOWtHREADS*/ ) * sizeof( tinS* ) + /*C*/4 * sizeof( countT ) + /*D*/sizeof( flagsT ) + /*E*/CBbITScT + /*F*/sizeof( signC* ) )

 /* suffix end (not sloshed (copied) from tinS to tinS) */
 signC*                 pSgnUtility ;                       /*F*/
 const byteT            pbBitsCt[ CBbITScT ] ;              /*E*/
 const countT           idiFileCt ;                         /*C*/
 const countT           idLineCt ;                          /*C*/
 flagsT                 flags ;                             /*D*/

 public :

 // tinS*               ppTinKid[ ClOWtHREADS ] ;           /*B*/ //U::TEMPORARY, TO DEBUG PROBLEM WITH pTinKid pTinBro LIST
 // tinS*               pTinKid ;                           /*B*/
 // tinS*               pTinBro ;                           /*B*/
 // tinS* const         pTinDad ;                           /*B*/
 // countT              idDesire_cGrab_pTinKid ;            /*C*/
 // countT              cGrab_pTinKid ;                     /*C*/
 grabC                  grabPseudo   ;                      /*A*/       // MUST BE CONSTRUCTED LATE ENOUGH THAT I CAN BE USED TO REGISTER IT WITH THE MONITOR 6a40104; I AM USED TO INFORM THE MONITOR THAT THE THREAD IS IN A SLEEP LOOP OR IS OTHERWISE STOPPED (E.G. IS IN A BLOCKING OS CALL)
 tinS* const            pTinOld ;                           /*B*/

 private :

 const countT           idTinNamed ;                        /*C*/
 const countT           idTin ;                             /*C*/

 jotC*                  ppJot[ CsLOTSjOTrEGISTRY ] ;        /*J*/      // THIS IS HERE SO THAT flTHREADlAUNCH_INHERITjOTrEGISTRATIONS CAN BE SUPPORTED

 /* suffix begin (not sloshed (copied) from tinS to tinS) */
 //ASSUME: FIELDS BEFORE HERE CAN BE COPIED AND RESET (SEE THE CT/DT OF processGlobal4I.tinVeryEarlyLateMain AND THE MAIN THREAD'S tinS, IN POOLoLD)

 bookMarkS              pBookMark[ TUCK ] ;    // USED BY pageC TO REGISTER A PENDING SMART POINTER ; INCREASE THE NUMBER OF ELEMENTS TO SUPPORT MORE SIMULTANEOUS pageC INSTANCES; 20180606: 01->TUCK WITHOUT ANALYSIS TO WORK AROUND PRODUCTION EXHAUSTION
 countT                 cSpins4 ;
 countT                 cSpins3 ;
 countT                 cSpins2 ;
 countT                 cSpins1 ;
 boolT                  bSuppressInOutTrace ;               // INCREMENTED WHEN CALL trace WITHIN inOutFrameC::*inOutFrameC
 byteT*                 pbRecursiveParameters ;             // PROTOCOL: (1) CODE MUST VERIFY THAT THIS IS NULL BEFORE SETTING IT.  (2) THE CODE THAT SETS THIS MUST ALSO RESET IT SO THAT OTHER CODE CAN USE IT.  USE THIS TO PASS PARAMETERS RECURSIVELY TO AVOID USING THE THREAD STACK
 sexC*                  pSexLifoConstructing ;              // USED BY sexC TO DETECT RECURSIVE CYCLING DURING CT
 barryC*                pBarryUtility ;                     // NOT REFERENCED BY tinS OR BY IPDOS SYSTEM CODE ; AVAILABLE FOR USE BY APPLICATION CODE
 flagsT                 fliSexCtPendingExpSlots ;
 flagsT                 fliSexCtPendingExpCbSlot ;
 countT                 cPoolDropDt ;
 countT                 cPoolDropCt ;
 timeS                  timeTraceLath ;
 timeS                  timeTraceWoth ;
 countT                 valueExpectedByInOut ;
 countT*                pcWatchedByInOut ;

 public :

 countT                 cTls ;
 flagsT                 flagsTrace_soulC ; //FLAGS MUST INCLUDE flTRACEsOULc_ON AND MUST NOT SPECIFY flTRACEsOULc_PURGE
 countT                 cArmTrace_soulC ; //APP CODE CAN SET THIS: 0:DISARMED; -1:traceF WILL BE CALLED FOR ALL SUBSEQUENT soulC NEW'D OR RETRIEVED FROM RECYCLING; N:COUNTDOWN TO THE NEW/RETRIEVED INSTANCE TO CALL traceF FOR
 countT                 ccExitsWhere ; //EXISTS SO CODE IN ADAM DEF CAN SEE THIS GLOBALS ARRAY
 countT*                pcExitsWhere ; //EXISTS SO CODE IN ADAM DEF CAN SEE THIS GLOBALS ARRAY
 public :
 const countT           cbTls ; //MUST BE BEFORE grabC OBJECTS AND OTHERS WHOSE CONSTRUCTORS CALL TAG OR TAGoR MACROS
 byteT* const           pbTls ; //MUST BE BEFORE grabC OBJECTS AND OTHERS WHOSE CONSTRUCTORS CALL TAG OR TAGoR MACROS; THIS STORAGE IS NOT INITIALIZED

 private :


 countT                 pcGrabitRecurse[  CmAXgRABITrECURSEiNtINs ] ;
 countT                 pcGrabitOsTid[    CmAXgRABITrECURSEiNtINs ] ;
 const byteT*           ppbGrabitRecurse[ CmAXgRABITrECURSEiNtINs ] ;
 cleanC*                pClean ;
 countT                 pcLevelUntagged[ CmAXuNTAGGED ] ;
 const byteT*           ppbNewUntagged[ CmAXuNTAGGED ] ;
 tinArgS                ta ;
 book0C*                pBk0TraceScratch ;
 book0C*                pBk0TelemetryAppScratch ;
 book0C*                pBk0TelemetrySysScratch ;
 adamC*                 pAdam ;
 poolC*                 pPoolUse ;
 countT                 odoSockCbWrite ;
 countT                 odoSockCbRead  ;
 switchStackC*          pSwsRecycle ;
 const countT*          pczl_pSwsRecycle ;
 tellInfoSysExceptionS*    pTieLath ;
 osTextT*               postRptExceptionLath ;
 countT                 idiFileMileDad ;
 countT                 idLineMileDad ;
 countT                 idiFileMile ;
 countT                 idLineMile ;
 countT                 cYield ;
 ranUniC                ranUni ;
 restartC*              pRestart ;
 etherC*                pEtScratch ;
 etherC*                pEtText ;       // USED IF !0

 countT                 cGrabitC_unregistered ;
 countT                 cGrabitC_registered ;
 countT                 cGrabitC_reset ;
 countT                 cGrabitC_set ;
 zapC                   zap_pPanLifiRecurseGrabbedLevel_ ;
 countT                 pPanLifiRecurseGrabbedLevel[ ( 1 + OFFgRABBEDmAX ) * 5 ] ; // [pandle,idLineGrab,idiFileGrab,cRecurse,idGrabLevel]  (A PANDLE IS A POINTER THAT IS BEING USED AS A HANDLE)
 countT                 msSleepWhenGrabbing ;
 const countT*          pcQuit ;
 strokeModeS            strokeMode ;
 tinTallyS              tally ;
 count4S                c4Tell ;
 osTextT                postPad2[ sizeof( countT ) - 1 ] ;
 osTextT                postThreadName[ COSTmAXtHREADnAME + 1 ] ;
 osTextT                postTellIf[ COSTmAXtELL + 1 ] ;
 osTextT                postTellWait[ COSTmAXtELL + 1 ] ;
 osTextT                postTell[ COSTmAXtELL + 1 ] ;
 osTextT                postPad1[ sizeof( countT ) - 1 ] ;

 countT                 idPhase3 ; //THIS IS ADJACENT TO pLFnest SO THAT MONITOR CAN GET BOTH WITH A SINGLE MEMORY READ
 countT                 idPhase2 ; //THIS IS ADJACENT TO pLFnest SO THAT MONITOR CAN GET BOTH WITH A SINGLE MEMORY READ
 countT                 idPhase1 ; //THIS IS ADJACENT TO pLFnest SO THAT MONITOR CAN GET BOTH WITH A SINGLE MEMORY READ
 countT                 cManna ;
 countT                 cRain ;
                        //CODEsYNC: 2e40104 003002a

 countT                 pIdProgressNest[ 1 + OFFsLOTtINnESTmAX ] ;
 countT                 pEIPInNest[     1 + OFFsLOTtINnESTmAX ] ;
 countT                 pIdInNest[     1 + OFFsLOTtINnESTmAX ] ;
 countT                 pLFstep[ ( 1 + OFFsLOTtINsTEPmAX ) << 1 ] ;
 flagsT                 pFlagsThreadLevelMode[ 1 + OFFsLOTtINnESTmAX ] ;
                        //CS:CODEsYNC: 003004f 003002a

 monitorS               monitor ;
 countT                 cKidThreads ;
 flagsT                 flagsThreadMode4 ;
 flagsT                 flagsThreadMode3 ;
 flagsT                 flagsThreadMode2 ;
 flagsT                 flagsThreadMode1 ;
 count04T               pcUtility04[ 4 ] ;
 countT                 pcUtility[ CCuTILITY ] ;
 countT                 idBlammo ;
 countT                 idiFile_brcLath ;
 countT                 idLine_brcLath ;
 countT                 brcLath ;  // LATH NONZE RETURN CODE FROM A BOS (BASE OPERATING SYSTEM, E.G. WIN32) CALL ON THIS THREAD
 countT                 brcQuery ; // LATH RETURN VALUE QUERIED BECAUSE bosFail WAS SET ON THIS THREAD
 boolT                  bosFail ;  // PASS/FAIL RESULT OF LATH BOS CALL
 measure04T             brcm04Raw ;
 countT                 brcRaw ;
 countT                 idlTask ;
 countT                 idiTask ;
 sCountT                time2 ;
 countT                 time1 ;
 adamGlobal6S*          pAdamGlobal6 ;
 adamGlobal5S*          pAdamGlobal5 ;
 adamGlobal4S*          pAdamGlobal4 ;
 adamGlobal3S*          pAdamGlobal3 ;
 adamGlobal2S*          pAdamGlobal2 ;
 adamGlobal1S*          pAdamGlobal1 ;
 countT        /*o 41*/ osPid ;   // MUST BE AFTER pEther. OFFSET IS HARDCODED IN 0d0000c.grabSleepF
 countT        /*o 01*/ osTid ;   // MUST BE AFTER pEther.  
 etherC*       /*o  8*/ pEther ;       // USED IF !0.              FOR USE BY STATIC thirdC FUNCTIONS, GLOBAL FUNCTIONS, AND OBJECTS SUCH AS strokeS THAT DO NOT CARRY THEIR OWN REFERENCES.  ADDED LATE.
 count04T               cCpuCycles2Or5Lath ;
 inOutFrameC*           pInOutFrame ;                       //THIS AND POSSIBLY ITS ACCOMPANYING MEMBERS MUST BE EARLY SINCE _IO_ IS USED DURING CT OF tinS
 count04T               cCpuCyclesWriteInOutTelemetry ;

 public :

 countT                 idDesireProcess ;
 countT                 idDesire ;              //MUST BE EARLY BECAUSE dosPriorityIF CAN BE (WHEN DEBUGGING) CALLED IN inOutFrameC CT/DT, AND BEFORE ANY SUCH CALLS idDesire MUST BE INITIALIZED

 private :

                        //END OF PREFIX: MEMBERS BEFORE THIS LINE ARE NOT SLOSHED (FROM/TO pTinOld)
                        //CODEsYNCH: 003002a 12f0002 12f0006
                        #define CBtINpREFIX ( 2 * sizeof( countT ) + sizeof( topC ) + sizeof( poopC ) + sizeof( poopC* ) + 2 * sizeof( scoopC* ) )

 scoopC*                pScoops ;
 scoopC*                pScoopEtThread ;
/* face 2 */


 const poopC*           pPoop ; //INITIALIZED TO &poop BEFORE poop IS CONSTRUCTED (THIS IS OK)

 public :

 poopC                  poop ; //MUST BE CT EARLY, BEFORE POOP MACRO IS INVOKED DURING tinS CONSTRUCTION

 private :

 topC                    top_pTinMainI_ ;
 countT         /*o  4*/ idSerial ;    // MUST BE CONTIGUOUS AND AT THE BEGINNING OF ME SO THAT MONITOR CAN READ THIS PAIR EFFICIENTLY
 countT         /*o  0*/ fingerprint ; // MUST BE CONTIGUOUS AND AT THE BEGINNING OF ME SO THAT MONITOR CAN READ THIS PAIR EFFICIENTLY
/* face 1 */

/**/
{
/*1*/struct _export tinS/*1*/

//TRY TO AVOID POINTER FIELDS, BECAUSE THIS IS A PITA TO SUPPORT IN ctF SINCE tinS, OBJECTS ARE ACCESSED BY MULTIPLE PROCESSES
//THE DEF OF voidT zePointerFieldsF( tinS& tinP ) MUST ALSO BE UPDATED
//WHEN ADDING FIELDS: ADD CODE TO tinS::ctF TO CORRECTLY DIGEST POINTER VALUES

//ASSUME: 0d00002 and 003*.tinS, ARE KEPT IN SYNC

/**/
*/
it is illegal to modify any member other than pc Utility in the definition of an adam
  \<A HREF=\"5.0600104.1.1.0.html\"\>0600104:  WAKEsHOW( "example.simplest.snip.15000026.tinS" )\</A\>
 simplest
examples
\<A HREF=\"5.15000026.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

