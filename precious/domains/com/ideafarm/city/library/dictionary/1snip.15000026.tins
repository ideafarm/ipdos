
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


;
}
 friend countT dtTellCopyDoneF( countT c_thisP ) ;
 friend countT ctTellCopyDoneF( countT c_thisP ) ;

 FRIENDS_tinS
/**/

 private :

 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.3400d.tinS.pbF!||
 byteT* pbF( countT idP = 1 ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.36024015.tins.tlsCheckF!||
 voidT tlsCheckF( voidT ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.3400c.tinS.tlsDelF!||
 voidT tlsDelF( const countT idLineP , const countT idiFileP , byteT*& pbMeP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.3400b.tinS.tlsNewF!||
 byteT* tlsNewF( const countT idLineP , const countT idiFileP , const countT cbP , const osTextT* const postNameP = 0 , const osTextT* const postGroupP = 0 ) ;
/*tls*/

 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.36024014.tins.flushPendingInOutFrameTelemetryIfF!||
 voidT flushPendingInOutFrameTelemetryIfF( voidT ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34013.tinS.unwatchedF!||
 voidT unwatchedF( voidT ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.3400a.tinS.deregisterIfF!||
 voidT deregisterIfF( tinS& tinP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34009.tinS.walkF!||
 voidT walkF( tinS& tinRootP , tinWalkerFT tinWalkerFP , countT& cArgP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34008.tinS.rootF!||
 tinS& rootF( voidT ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34012.tinS.get_pIdProgressNest_F!||
 voidT get_pIdProgressNest_F( tinS& tinP , countT* const pcP , const countT ccP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34011.tinS.get_pEIPInNest_F!||
 voidT get_pEIPInNest_F( tinS& tinP , countT* const pcP , const countT ccP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34010.tinS.get_pIdInNest_F!||
 voidT get_pIdInNest_F( tinS& tinP , countT* const pcP , const countT ccP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.3400f.tinS.get_pFlagsThreadLevelMode_F!||
 voidT get_pFlagsThreadLevelMode_F( tinS& tinP , countT* const pcP , const countT ccP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.3400e.tinS.get_pLFstep_F!||
 voidT get_pLFstep_F( tinS& tinP , countT* const pcP , const countT ccP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34007.tinS.get_pLFnest_F!||
 voidT get_pLFnest_F( tinS& tinP , countT* const pcP , const countT ccP ) ;
 inline flagsT flagsF( voidT ) { return flags ; }
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34006.tinS.levelModeF!||
 voidT levelModeF( const flagsT flagsModeP = flTHREADlEVELmODE_null , sCountT cLevelsP = 0 , const sCountT offRelLevelP = 0 ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34005.tinS.zePointerFieldsF!||
 voidT zePointerFieldsF( tinS& tinP ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34004.tinS.strFuseF!||
 voidT strFuseF( tinS& tinP , etherC& etherP , strokeS*& psttP , const countT csttExtraP = 0 , const flagsT flagsInclude1P = flTINrPT1_null , const flagsT flagsInclude2P = flTINrPT2_null , const flagsT flagsExclude1P = flTINrPT1_null , const flagsT flagsExclude2P = flTINrPT2_null , countT idFormatP = 0 , const countT cIndentP = 0 ) ;
/* commands */

 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34003.tinS.tinS!||
 tinS( tinS& tinSelfOrElderP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const countT idThreadP , tinS* const pTinDadP = 0 , const osTextT* const postThreadNameP = 0 , const flagsT flagsP = flTINs_null , const countT idTinNamedP = 0 , byteT* const pbTlsP = 0 , const countT cbTlsP = 0 ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34002.tinS.dt_tinS!||
 ~tinS( voidT ) ;
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34001.tinS.NEWdELcLASSppOOLoLD!||
 NEWdELcLASSpROTOS
/* birth , death */
/**/

 //CODEsYNCHeND: DO NOT CHANGE THIS CODE WITHOUT ALSO CHANGING THE SYNC CODE
 #define CBtINsUFFIX ( /*J*/ sizeof ppJot + /*A*/1 * sizeof( grabC ) + /*B*/( 1 /*+ 3 + ClOWtHREADS*/ ) * sizeof( tinS* ) + /*C*/4 * sizeof( countT ) + /*D*/sizeof( flagsT ) + /*E*/CBbITScT + /*F*/sizeof( signC* ) )

 /* suffix end (not sloshed (copied) from tinS to tinS) */
 signC*                  pSgnUtility ;                       /*F*/
 const byteT             pbBitsCt[ CBbITScT ] ;              /*E*/
 const countT            idiFileCt ;                         /*C*/
 const countT            idLineCt ;                          /*C*/
 flagsT                  flags ;                             /*D*/

 public :

 // tinS*                ppTinKid[ ClOWtHREADS ] ;           /*B*/ //U::TEMPORARY, TO DEBUG PROBLEM WITH pTinKid pTinBro LIST
 // tinS*                pTinKid ;                           /*B*/
 // tinS*                pTinBro ;                           /*B*/
 // tinS* const          pTinDad ;                           /*B*/
 // countT               idDesire_cGrab_pTinKid ;            /*C*/
 // countT               cGrab_pTinKid ;                     /*C*/
 grabC                   grabPseudo   ;                      /*A*/       // MUST BE CONSTRUCTED LATE ENOUGH THAT I CAN BE USED TO REGISTER IT WITH THE MONITOR 6a40104; I AM USED TO INFORM THE MONITOR THAT THE THREAD IS IN A SLEEP LOOP OR IS OTHERWISE STOPPED (E.G. IS IN A BLOCKING OS CALL)
 tinS* const             pTinOld ;                           /*B*/

 private :

 const countT            idTinNamed ;                        /*C*/
 const countT            idTin ;                             /*C*/

 jotC*                   ppJot[ CsLOTSjOTrEGISTRY ] ;        /*J*/      // THIS IS HERE SO THAT flTHREADlAUNCH_INHERITjOTrEGISTRATIONS CAN BE SUPPORTED

 /* suffix begin (not sloshed (copied) from tinS to tinS) */
 //ASSUME: FIELDS BEFORE HERE CAN BE COPIED AND RESET (SEE THE CT/DT OF processGlobal4I.tinVeryEarlyLateMain AND THE MAIN THREAD'S tinS, IN POOLoLD)

 bookMarkS               pBookMark[ CbOOKmARK ] ;    // USED BY pageC TO REGISTER A PENDING SMART POINTER ; INCREASE THE NUMBER
 countT                  cSpins4 ;
 countT                  cSpins3 ;
 countT                  cSpins2 ;
 countT                  cSpins1 ;
 boolT                   bSuppressInOutTrace ;               // INCREMENTED WHEN CALL trace WITHIN inOutFrameC::*inOutFrameC
 byteT*                  pbRecursiveParameters ;             // PROTOCOL: (1) CODE MUST VERIFY THAT THIS IS NULL BEFORE SETTING IT.  (2) THE CODE THAT SETS THIS MUST ALSO RESET IT SO THAT OTHER CODE CAN USE IT.  USE THIS TO PASS PARAMETERS RECURSIVELY TO AVOID USING THE THREAD STACK
 sexC*                   pSexLifoConstructing ;              // USED BY sexC TO DETECT RECURSIVE CYCLING DURING CT
 barryC*                 pBarryUtility ;                     // NOT REFERENCED BY tinS OR BY IPDOS SYSTEM CODE ; AVAILABLE FOR USE BY APPLICATION CODE
 flagsT                  fliSexCtPendingExpSlots ;
 flagsT                  fliSexCtPendingExpCbDrop ;
 countT                  cPoolDropDt ;
 countT                  cPoolDropCt ;
 timeS                   timeTraceLath ;
 timeS                   timeTraceWoth ;
 countT                  valueExpectedByInOut ;
 countT*                 pcWatchedByInOut ;

 flagsT                  flagsTrace_soulC ; //FLAGS MUST INCLUDE flTRACEsOULc_ON AND MUST NOT SPECIFY flTRACEsOULc_PURGE
 countT                  cArmTrace_soulC ; //APP CODE CAN SET THIS: 0:DISARMED; -1:traceF WILL BE CALLED FOR ALL SUBSEQUENT soulC NEW'D OR RETRIEVED FROM RECYCLING; N:COUNTDOWN TO THE NEW/RETRIEVED INSTANCE TO CALL traceF FOR
 countT                  ccExitsWhere ; //EXISTS SO CODE IN ADAM DEF CAN SEE THIS GLOBALS ARRAY
 countT*                 pcExitsWhere ; //EXISTS SO CODE IN ADAM DEF CAN SEE THIS GLOBALS ARRAY

 countT                  pcGrabitRecurse[  CmAXgRABITrECURSEiNtINs ] ;
 countT                  pcGrabitOsTid[    CmAXgRABITrECURSEiNtINs ] ;
 const byteT*            ppbGrabitRecurse[ CmAXgRABITrECURSEiNtINs ] ;
 cleanC*                 pClean ;
 tinArgS                 ta ;
 book0C*                 pBk0TraceScratch ;
 book0C*                 pBk0TelemetryAppScratch ;
 book0C*                 pBk0TelemetrySysScratch ;
 adamC*                  pAdam ;
 poolC*                  pPoolUse ;
 countT                  odoSockCbWrite ;
 countT                  odoSockCbRead  ;
 switchStackC*           pSwsRecycle ;
 const countT*           pczl_pSwsRecycle ;
 tellInfoSysExceptionS*  pTieLath ;
 osTextT*                postRptExceptionLath ;
 countT                  idiFileMileDad ;
 countT                  idLineMileDad ;
 countT                  idiFileMile ;
 countT                  idLineMile ;
 countT                  cYield ;
 ranUniC                 ranUni ;
 restartC*               pRestart ;
 etherC*                 pEtScratch ;
 etherC*                 pEtText ;       // USED IF !0

 countT                  cGrabitC_unregistered ;
 countT                  cGrabitC_registered ;
 countT                  cGrabitC_reset ;
 countT                  cGrabitC_set ;
 zapC                    zap_pPanLifiRecurseGrabbedLevel_ ;
 countT                  pPanLifiRecurseGrabbedLevel[ ( 1 + OFFgRABBEDmAX ) * 5 ] ; // [pandle,idLineGrab,idiFileGrab,cRecurse,idGrabLevel]  (A PANDLE IS A POINTER THAT IS BEING USED AS A HANDLE)
 countT                  msSleepWhenGrabbing ;
 const countT*           pcQuit ;
 strokeModeS             strokeMode ;
 tinTallyS               tally ;
 count4S                 c4Tell ;
 osTextT                 postPad2[ sizeof( countT ) - 1 ] ;
 osTextT                 postThreadName[ COSTmAXtHREADnAME + 1 ] ;
 osTextT                 postTellIf[ COSTmAXtELL + 1 ] ;
 osTextT                 postTellWait[ COSTmAXtELL + 1 ] ;
 osTextT                 postTell[ COSTmAXtELL + 1 ] ;
 osTextT                 postPad1[ sizeof( countT ) - 1 ] ;

 countT                  idPhase3 ; //THIS IS ADJACENT TO pLFnest SO THAT MONITOR CAN GET BOTH WITH A SINGLE MEMORY READ
 countT                  idPhase2 ; //THIS IS ADJACENT TO pLFnest SO THAT MONITOR CAN GET BOTH WITH A SINGLE MEMORY READ
 countT                  idPhase1 ; //THIS IS ADJACENT TO pLFnest SO THAT MONITOR CAN GET BOTH WITH A SINGLE MEMORY READ
 countT                  cManna ;
 countT                  cRain ;
                         //CODEsYNC: 2e40104 003002a

 countT                  pIdProgressNest[ 1 + OFFsLOTtINnESTmAX ] ;
 countT                  pEIPInNest[     1 + OFFsLOTtINnESTmAX ] ;
 countT                  pIdInNest[     1 + OFFsLOTtINnESTmAX ] ;
 countT                  pLFstep[ ( 1 + OFFsLOTtINsTEPmAX ) << 1 ] ;
 flagsT                  pFlagsThreadLevelMode[ 1 + OFFsLOTtINnESTmAX ] ;
                         //CS:CODEsYNC: 003004f 003002a

 monitorS                monitor ;
 countT                  cKidThreads ;
 flagsT                  flagsThreadMode4 ;
 flagsT                  flagsThreadMode3 ;
 flagsT                  flagsThreadMode2 ;
 flagsT                  flagsThreadMode1 ;
 count04T                pcUtility04[ 4 ] ;
 countT                  pcUtility[ CCuTILITY ] ;
 countT                  idBlammo ;
 countT                  idiFile_brcLath ;
 countT                  idLine_brcLath ;
 countT                  brcLath ;  // LATH NONZE RETURN CODE FROM A BOS (BASE OPERATING SYSTEM, E.G. WIN32) CALL ON THIS THREAD
 countT                  brcQuery ; // LATH RETURN VALUE QUERIED BECAUSE bosFail WAS SET ON THIS THREAD
 boolT                   bosFail ;  // PASS/FAIL RESULT OF LATH BOS CALL
 measure04T              brcm04Raw ;
 countT                  brcRaw ;
 countT                  idlTask ;
 countT                  idiTask ;
 sCountT                 time2 ;
 countT                  time1 ;
 adamGlobal6S*           pAdamGlobal6 ;
 adamGlobal5S*           pAdamGlobal5 ;
 adamGlobal4S*           pAdamGlobal4 ;
 adamGlobal3S*           pAdamGlobal3 ;
 adamGlobal2S*           pAdamGlobal2 ;
 adamGlobal1S*           pAdamGlobal1 ;
 countT        /*o 41*/  osPid ;   // MUST BE AFTER pEther. OFFSET IS HARDCODED IN 0d0000c.grabSleepF
 countT        /*o 01*/  osTid ;   // MUST BE AFTER pEther.  
 etherC*       /*o  8*/  pEther ;       // USED IF !0.              FOR USE BY STATIC thirdC FUNCTIONS, GLOBAL FUNCTIONS, AND OBJECTS SUCH AS strokeS THAT DO NOT CARRY THEIR OWN REFERENCES.  ADDED LATE.
 byteT*                  pbPendingInOutFramePackets ;
 count04T                cTime2Or5Lath ;
 count04T                cCpuCycles2Or5Lath ;
 inOutFrameC*            pInOutFrame ;                       //THIS AND POSSIBLY ITS ACCOMPANYING MEMBERS MUST BE EARLY SINCE _IO_ IS USED DURING CT OF tinS
 count04T                cTimeWriteInOutTelemetry ;
 count04T                cCpuCyclesWriteInOutTelemetry ;
 countT                  cTellsWriteInOutTelemetry ;

 public :

 countT                  cTlsDebug ;
 countT                  idDesireProcess ;
 countT                  idDesire ;              //MUST BE EARLY BECAUSE dosPriorityIF CAN BE (WHEN DEBUGGING) CALLED IN inOutFrameC CT/DT, AND BEFORE ANY SUCH CALLS idDesire MUST BE INITIALIZED
 const countT            cbTls ; //MUST BE BEFORE grabC OBJECTS AND OTHERS WHOSE CONSTRUCTORS CALL TAG OR TAGoR MACROS
 byteT* const            pbTls ; //MUST BE BEFORE grabC OBJECTS AND OTHERS WHOSE CONSTRUCTORS CALL TAG OR TAGoR MACROS; THIS STORAGE IS NOT INITIALIZED
 countT                  cTls ;

 private :

                         //END OF PREFIX: MEMBERS BEFORE THIS LINE ARE NOT SLOSHED (FROM/TO pTinOld)
                         //CODEsYNCH: 003002a 12f0002 12f0006
                         #define CBtINpREFIX ( 2 * sizeof( countT ) + sizeof( topC ) + sizeof( poopC ) + sizeof( poopC* ) + 2 * sizeof( scoopC* ) )

 scoopC*                 pScoops ;
 scoopC*                 pScoopEtThread ;
/* face 2 */


 const poopC*            pPoop ; //INITIALIZED TO &poop BEFORE poop IS CONSTRUCTED (THIS IS OK)

 public :

 poopC                   poop ; //MUST BE CT EARLY, BEFORE POOP MACRO IS INVOKED DURING tinS CONSTRUCTION

 private :

 topC                     top_pTinMainI_ ;
 countT         /*o  4*/  idSerial ;    // MUST BE CONTIGUOUS AND AT THE BEGINNING OF ME SO THAT MONITOR CAN READ THIS PAIR EFFICIENTLY
 countT         /*o  0*/  fingerprint ; // MUST BE CONTIGUOUS AND AT THE BEGINNING OF ME SO THAT MONITOR CAN READ THIS PAIR EFFICIENTLY
/* face 1 */

/**/
{
/*1*/struct _export tinS/*1*/

//TRY TO AVOID POINTER FIELDS, BECAUSE THIS IS A PITA TO SUPPORT IN ctF SINCE tinS, OBJECTS ARE ACCESSED BY MULTIPLE PROCESSES
//THE DEF OF voidT zePointerFieldsF( tinS& tinP ) MUST ALSO BE UPDATED
//WHEN ADDING FIELDS: ADD CODE TO tinS::ctF TO CORRECTLY DIGEST POINTER VALUES

//ASSUME: 0d00002 and 003*.tinS, ARE KEPT IN SYNC

/**/
*/
it is illegal to modify any member other than pc Utility in the definition of an adam
  \<A HREF=\"5.0600104.1.1.0.html\"\>0600104:  WAKEsHOW( "example.simplest.snip.15000026.tinS" )\</A\>
 simplest
examples
\<A HREF=\"5.15000026.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

