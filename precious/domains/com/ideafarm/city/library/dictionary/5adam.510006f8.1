
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.traceF( tinP , T("ok") ) ;

while( ~hFind && !ether && !POOP ) ;
}
    DEL( pInfo ) ;
    }
        etThread.delF( tinP , psttShort ) ;
        }
            etThread.delF( tinP , posti ) ;
            }
                parseF( tinP , etThread , fo , countTC() , posti , costi , 1 ) ; // "1":bAcceptHtml: ROOT CALL WILL ACCEPT HTML (ONLY HAS EFFECT IF ROOT IS text/html I.E. NOT MULTIPIART)

                fileC fo( tinP , (strokeS*)( tPathOut+T(psttShort) ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
            {
            if( posti && costi )
            
            etThread.boxGetShadowF( tinP , posti , costi , pInfo->psttIfoName ) ; ___( posti ) ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;
        {

        /*if( !( ++ idFile % TUCK ) )*/ etThread.traceF( tinP , psttShort ) ;

        etThread.delF( tinP , psttPath ) ;
        ___( psttShort ) ;
        ___( psttPath ) ;
        etThread.strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
        ZE( strokeS* , psttShort ) ;
        ZE( strokeS* , psttPath ) ;
    {
    if( pInfo && pInfo->psttIfoName && pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam != '/' )
    etThread.diskFindFileOrDirOldF( tinP , pInfo , hFind , tLike ) ; ___( pInfo ) ;
    ZE( infoFileS* , pInfo ) ;
{
do
handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
TN( tSlash , "/" ) ;
ZE( countT , idFile ) ;
TN( tPathOut , "///d/tmp/gmail.download/2.unwrapped/"                 ) ;

TN( tLike    , "///d/tmp/gmail.download/1.separated/mail.????????.eml") ;
//TN( tLike    , "///d/tmp/gmail.download/mail.test.eml") ;

TODO

}
    }
        etherP.delF( tinP , psttBoundary ) ;
        }
            etherP.delF( tinP , postLookEnd ) ;
            etherP.delF( tinP , postLook ) ;
            }
                }
                    postc = postEnd ;
                    offNestP -- ;
                    parseF( tinP , etherP , foP , offNestP , postBegin , postEnd - postBegin , bAcceptHtml ) ;
                    offNestP ++ ;

                    }
                        }
                            postEnd = poste ;
                            etherP.traceF( tinP , T("did not find final boundary marker") ) ;
                        {
                        if( !postEnd )
                        bFinal = 1 ;
                        postEnd = thirdC::c_strstrIF( tinP , postc , postLookEnd ) ;
                    {
                    if( !postEnd )
                    osTextT* postEnd = thirdC::c_strstrIF( tinP , postBegin , postLook ) ;
                    postBegin += costLook ;

                    etherP.fileWriteF( tinP , foP , postDivider , sizeof postDivider - 1 ) ;
                {
                else
                if( !postBegin ) break ;
                osTextT* postBegin = thirdC::c_strstrIF( tinP , postc , postLook ) ;
            {
            while( postc && postc < poste )
            ZE( boolT , bFinal ) ;
            osTextT* poste = postP + costP ;
            osTextT* postc = postP + offi ;

            const countT costLookEnd = thirdC::c_strlenIF( tinP , postLookEnd ) ;
            const countT costLook    = thirdC::c_strlenIF( tinP , postLook    ) ;
            etherP.delF( tinP , psttBoundary ) ;
            etherP.strMakeF( tinP , LF , postLookEnd , T("\r\n--")+T(psttBoundary)+T("--\r\n") ) ; ___( postLookEnd ) ;
            etherP.strMakeF( tinP , LF , postLook    , T("\r\n--")+T(psttBoundary)+T("\r\n"  ) ) ; ___( postLook    ) ;
            ZE( osTextT* , postLookEnd ) ;
            ZE( osTextT* , postLook ) ;

            }
                postP[ costP ] = save ;
                if( !thirdC::c_strstrIF( tinP , postP + offi , "text/plain" ) ) bAcceptHtml = 1 ;
                               postP[ costP ] = 0 ;
                osTextT save = postP[ costP ] ;
            {
            ZE( boolT , bAcceptHtml ) ;
        {
        else
        }
            else                   etherP.fileWriteF(      tinP          , foP , postP + offi , costP - offi ) ;
            if( bQuotedPrintable ) decodeQuotedPrintableF( tinP , etherP , foP , postP + offi , costP - offi ) ;
        {
        if( !psttBoundary )
    {
    if( !bQuashBody )

    if( !bQuashHeader ) writeAbridgedHeaderF( tinP , etherP , foP , tHead ) ;

    }
        etherP.delF( tinP , psttHeadLower ) ;

        }
            }
                }
                    etherP.delF( tinP , psttValue ) ;
                    if( etherP.strIdF( tinP , T("quoted-printable") , psttValue ) ) bQuotedPrintable = 1 ;
    
                    //etherP.traceF( tinP , psttValue ) ;
    
                    etherP.strSubstringF( tinP , psttValue , idf1 , sttq , tcrlf , psttHeadLower ) ; ___( psttValue ) ;
                    countT idf1 = idValue1 ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , psttValue ) ;
                {
                if( idValue1 <= psttHeadLower->idAdam )
                const countT idValue1 = idKey1 + ( bAtWoth ? tKey1Woth.csF( tinP ) : tKey1.csF( tinP ) ) ; // BEGINNING OF VALUE WITHIN HEAD
            {
            if( idKey1 )
    
            }
                if( idKey1Woth == 1 ) bAtWoth = idKey1 = 1 ;
                countT idKey1Woth = etherP.strIdF( tinP , tKey1Woth , psttHeadLower ) ;
            {
            if( !idKey1 )
            ZE( boolT , bAtWoth ) ;
    
            countT idKey1 = etherP.strIdF( tinP , tKey1 , psttHeadLower ) ;
            TN( tKey1     , "\r\ncontent-transfer-encoding:" ) ;
            TN( tKey1Woth ,     "content-transfer-encoding:" ) ;
        {                                                                                                           // Content-Transfer-Encoding: quoted-printable

        }
            }
                }
                    etherP.delF( tinP , psttValue ) ;
    
                    }
                        }
                            }
                                etherP.delF( tinP , psttbo ) ;
                                if( psttbo && psttbo->idAdam ) { etherP.strTrimF( tinP , psttBoundary , psttbo , 0 , T(" \"") ) ; ___( psttBoundary ) ; }   // REMOVE LEADING/TRAILING BLANKS AND DOUBLE QUOTES
                                etherP.strSubstringF( tinP , psttbo , idf2 , sttq , tcrlfsc , tHead , 1 ) ; ___( psttbo ) ;  // GET CHARS TO NEXT SEMICOLON OR EOL
                                countT idf2 = idValue1 + idValue2 - 1 ; // ID OF FIELD VALUE IN HEAD = ID OF VALUE IN HEAD + ID OF FIELD VALUE IN VALUE - 1
                                ZE( strokeS* , psttbo ) ;
    
                            {
                            if( idValue2 <= psttValue->idAdam )
                            countT idValue2 = idKey2 + tKey2.csF( tinP ) ; // BEGINNING OF FIELD VALUE WITHIN VALUE
                        {
                        if( idKey2 )
                        countT idKey2 = etherP.strIdF( tinP , tKey2 , psttValue ) ;
                        TN( tKey2 , "boundary=" ) ;
                    {
                    if( etherP.strIdF( tinP , T("multipart") , psttValue ) )
    
                    else if( etherP.strIdF( tinP , T("multipart/alternative"   ) , psttValue ) ) { if( offNestP      )              bQuashHeader = 1 ; }
                    else if( etherP.strIdF( tinP , T(" name="                  ) , psttValue ) )                       bQuashBody = bQuashHeader = 1 ; // TO QUASH PLAIN TEXT FILE ATTACHMENTS
                    else if( etherP.strIdF( tinP , T("message/"                ) , psttValue ) )                       bQuashBody = bQuashHeader = 1 ;
                    else if( etherP.strIdF( tinP , T("application/"            ) , psttValue ) )                       bQuashBody = bQuashHeader = 1 ;
                    else if( etherP.strIdF( tinP , T("video/"                  ) , psttValue ) )                       bQuashBody = bQuashHeader = 1 ;
                    else if( etherP.strIdF( tinP , T("audio/"                  ) , psttValue ) )                       bQuashBody = bQuashHeader = 1 ;
                    else if( etherP.strIdF( tinP , T("image/"                  ) , psttValue ) )                       bQuashBody = bQuashHeader = 1 ;
                    else if( etherP.strIdF( tinP , T("text/x-"                 ) , psttValue ) )                       bQuashBody = bQuashHeader = 1 ;
                    else if( etherP.strIdF( tinP , T("text/csv"                ) , psttValue ) )                       bQuashBody = bQuashHeader = 1 ;
                         if( etherP.strIdF( tinP , T("text/html"               ) , psttValue ) ) { if( !bAcceptHtmlP ) bQuashBody = bQuashHeader = 1 ; }
    
                    //etherP.traceF( tinP , psttValue ) ;
    
                    etherP.strSubstringF( tinP , psttValue , idf1 , sttq , tcrlf , psttHeadLower ) ; ___( psttValue ) ;
                    countT idf1 = idValue1 ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , psttValue ) ;
                {
                if( idValue1 <= psttHeadLower->idAdam )
                const countT idValue1 = idKey1 + ( bAtWoth ? tKey1Woth.csF( tinP ) : tKey1.csF( tinP ) ) ; // BEGINNING OF VALUE WITHIN HEAD
            {
            if( idKey1 )
    
            }
                if( idKey1Woth == 1 ) bAtWoth = idKey1 = 1 ;
                countT idKey1Woth = etherP.strIdF( tinP , tKey1Woth , psttHeadLower ) ;
            {
            if( !idKey1 )
            ZE( boolT , bAtWoth ) ;
    
            countT idKey1 = etherP.strIdF( tinP , tKey1 , psttHeadLower ) ;
            TN( tKey1     , "\r\ncontent-type:" ) ;
            TN( tKey1Woth ,     "content-type:" ) ;
        {                                                                                                           // Content-Type: multipart/alternative; boundary="===============8360180459455337976=="

        etherP.strConvertToLowerCaseF( tinP , psttHeadLower , tHead ) ; ___( psttHeadLower ) ;
        ZE( strokeS* , psttHeadLower ) ;
        TN( tcrlfsc , "\r\n;" ) ;
        TN( tcrlf   , "\r\n" ) ;
    {
    ZE( strokeS* , psttBoundary ) ;
    ZE( boolT , bQuashBody   ) ;
    ZE( boolT , bQuashHeader ) ;
    ZE( boolT , bQuotedPrintable ) ;

    }
        }
            offc = offi -- ; // NEXT LOOP WILL PROCESS WOTH NONBLANK CHAR THAT offc IS NOW POINTING TO
            
            while( postP[ offi ] == ' ' || postP[ offi ] == '\t' ) offi ++ ; // IGNORE LEADING BLANKS AFTER THE WOTH BLANK
            
            else tHead += tcrlf ;
            }
                offi ++ ;
                tHead += tb ;
            {
            if( postP[ offi ] == ' ' || postP[ offi ] == '\t' )
            
            offi ++ ; // BEGINNING OF NEXT LINE
            
            if( postP[ ++ offi ] != '\n' ) { BLAMMO ; }
            
            tHead += T( postP + offc ) ;
            
            postP[ offi ] = 0 ;
            
            if( offi == offc ) break ; // IF AT END OF HEADER
        {
        if( postP[ offi ] == '\r' )
    {                                                                                       // ACCUMULATE tHead
    for( offi = 0 ; offi < costP ; offi ++ )
    ZE( countT , offi ) ;
    ZE( countT  , offc ) ; //CURSOR TO CURRENT INPUT LINE
    TN( tcrlf   , "\r\n" ) ;
    TN( tb      , " " ) ;
    TN( tHead , "" ) ;

    //etherP.traceF( tinP , T("[bAcceptHtmlP]: ")+TF2(bAcceptHtmlP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    }
        if( POOP ) return ;
        }
            __1
            etherP.traceF( tinP , T("error: the input contains the string that i was going to use as a divider") ) ;
        {
        if( thirdC::c_strstrIF( tinP , postP , postDivider ) )
        if( POOP ) return ;
        __( !costP ) ;
        __( !postP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    static osTextT postDivider[] = "\r\n______________________________________________@_@__@_@______________________________________________\r\n\r\n" ; //THE APPARENT BLANKS IN THIS STRING ARE 0xff VALUES
    //A:ASSUME: THIS STRING WILL NEVER OCCUR IN THE INPUT ; THE INTENTION HERE IS TO MAKE THE OUTPUT MORE READABLE AND EASIER TO PARSE, SO I AM ELIMINATING THE BOUNDARY MARKERS USED BY MIME
{
voidT parseF( tinS& tinP , etherC& etherP , fileC& foP , countT& offNestP , osTextT* const postP , const countT costP , const boolT bAcceptHtmlP = 0 )

}
    }
        }
            }
                break ;

                else etherP.fileWriteF( tinP , foP , &ostWo , 1 ) ;
                }
                    }
                        bBytePending = 0 ;
                        etherP.fileWriteF( tinP , foP , &bBytePending , 1 ) ;
                    {
                    if( !( -- bEqualsPending ) )

                    else if( ostWo >= 'A' && ostWo <= 'F' ) bBytePending |= (osTextT)( ostWo - 'A' + 0xa ) ;
                         if( ostWo >= '0' && ostWo <= '9' ) bBytePending |= (osTextT)( ostWo - '0'       ) ;

                    bBytePending <<= 4 ;
                {
                if( bEqualsPending )
            {
            default :
            }
                break ;

                else                 etherP.fileWriteF( tinP , foP , &ostWo , 1 ) ;
                if( bEqualsPending ) bEqualsPending -- ;
            {
            case '\n' :
            case '\r' :
            }
                break ;
                bEqualsPending = 2 ; // GENERALLY MUST EAT OO MORE CHARS TO DECODE
            {
            case '=' :
        {
        switch( ostWo )
        osTextT ostWo = postP[ offi ] ;
    {
    for( countT offi = 0 ; offi < costP ; offi ++ )
    ZE( byteT , bBytePending   ) ;
    ZE( boolT , bEqualsPending ) ;
{
voidT decodeQuotedPrintableF( tinS& tinP , etherC& etherP , fileC& foP , osTextT* const postP , const countT costP )

}
    etherP.delF( tinP , pstt1Lines ) ;
    }
        etherP.delF( tinP , psttLower ) ;

        }
            etherP.fileWriteF( tinP , foP , tcrlf , tcrlf.csF( tinP ) ) ;
            etherP.fileWriteF( tinP , foP , tLine , tLine.csF( tinP ) ) ;
            TN( tLine , psttc1 ) ;
        {
        )
            )
                1 == etherP.strIdF( tinP , tLook8 , psttLower , 1 )
                1 == etherP.strIdF( tinP , tLook7 , psttLower , 1 ) ||
                1 == etherP.strIdF( tinP , tLook6 , psttLower , 1 ) ||
                1 == etherP.strIdF( tinP , tLook5 , psttLower , 1 ) ||
                1 == etherP.strIdF( tinP , tLook4 , psttLower , 1 ) ||
                1 == etherP.strIdF( tinP , tLook3 , psttLower , 1 ) ||
                1 == etherP.strIdF( tinP , tLook2 , psttLower , 1 ) ||
                1 == etherP.strIdF( tinP , tLook1 , psttLower , 1 ) ||
            (
            &&
            psttLower
        (
        if

        etherP.strConvertToLowerCaseF( tinP , psttLower , psttc1 ) ; ___( psttLower ) ;
        ZE( strokeS* , psttLower ) ;
    {
    FORsTRINGSiN1( pstt1Lines )
    etherP.strWordsF( tinP , pstt1Lines , psttHeadP , sttq , T("\r\n") ) ; ___( pstt1Lines ) ;
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , pstt1Lines ) ;

    TN( tLook8 , "from " ) ; // THIS LINE IS USEFUL BECAUSE IT CONTAINS A NORMALIZED TIME FOR THE EMAIL ITEM
    TN( tLook7 , "content-type:" ) ;
    TN( tLook6 , "date:" ) ;
    TN( tLook5 , "bc" "c" ":" ) ;
    TN( tLook4 , "cc" ":" ) ;
    TN( tLook3 , "to:" ) ;
    TN( tLook2 , "from:" ) ;
    TN( tLook1 , "subject:" ) ;
    TN( tcrlf , "\r\n" ) ;
{
voidT writeAbridgedHeaderF( tinS& tinP , etherC& etherP , fileC& foP , const strokeS* const psttHeadP )

/*1*/WAKEsHOWtEXT( "tool.mbox.file.2.unwrap.header.lines" )/*1*/
/**/
*/
i also filter out some header lines
i just look for "\r\nfrom " and divide the input file into separate output files beginning with that string
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

