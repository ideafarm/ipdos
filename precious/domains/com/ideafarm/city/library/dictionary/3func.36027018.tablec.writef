
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            if( bsl || idc == cCols ) { ether.strFuseF( tinP , psttP , T("\r\n") ) ; ___( psttP ) ; }

            }
                }
                    default      : { __1 break ; }
                    case _CT1_0f : { nicNameC& cc = _CT1_0fF(idr,idc) ; ether.strFuseF( tinP , psttP , T(cc) ) ; ___( psttP ) ; break ; }
                    case _CT1_0e : { count8S&  cc = _CT1_0eF(idr,idc) ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T(",")+TF1(cc.c3)+T(",")+TF1(cc.c4)+T(",")+TF1(cc.c5)+T(",")+TF1(cc.c6)+T(",")+TF1(cc.c7)+T(",")+TF1(cc.c8)+T("]") ) ; ___( psttP ) ; break ; }
                    case _CT1_0d : { count7S&  cc = _CT1_0dF(idr,idc) ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T(",")+TF1(cc.c3)+T(",")+TF1(cc.c4)+T(",")+TF1(cc.c5)+T(",")+TF1(cc.c6)+T(",")+TF1(cc.c7)+T("]") ) ; ___( psttP ) ; break ; }
                    case _CT1_0c : { count6S&  cc = _CT1_0cF(idr,idc) ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T(",")+TF1(cc.c3)+T(",")+TF1(cc.c4)+T(",")+TF1(cc.c5)+T(",")+TF1(cc.c6)+T("]") ) ; ___( psttP ) ; break ; }
                    case _CT1_0b : { count5S&  cc = _CT1_0bF(idr,idc) ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T(",")+TF1(cc.c3)+T(",")+TF1(cc.c4)+T(",")+TF1(cc.c5)+T("]") ) ; ___( psttP ) ; break ; }
                    case _CT1_0a : { count4S&  cc = _CT1_0aF(idr,idc) ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T(",")+TF1(cc.c3)+T(",")+TF1(cc.c4)+T("]") ) ; ___( psttP ) ; break ; }
                    case _CT1_09 : { count3S&  cc = _CT1_09F(idr,idc) ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T(",")+TF1(cc.c3)+T("]") ) ; ___( psttP ) ; break ; }
                    case _CT1_08 : { count2S&  cc = _CT1_08F(idr,idc) ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T("]") ) ; ___( psttP ) ; break ; }
                    case _CT1_06 : { ether.strFuseF( tinP , psttP , TF1(_CT1_06F(idr,idc)) ) ; ___( psttP ) ; break ; } //U: TSM
                    case _CT1_05 : { ether.strFuseF( tinP , psttP , TF1(_CT1_05F(idr,idc)) ) ; ___( psttP ) ; break ; }
                    case _CT1_04 : { ether.strFuseF( tinP , psttP , TF2(_CT1_04F(idr,idc),flFORMAT_UNSIGNED) ) ; ___( psttP ) ; break ; }
                    case _CT1_01 : { tableC& tbl = _CT1_01F( idr , idc ) ; tbl.writeF( tinP , psttP , csttEstimateP , flagsP ) ; ___( psttP ) ; break ; }
                {
                switch( idType )
            {
            else
            }
                }
                    /*default      :*/ { __1 /*break ;*/ }
                {
                //switch( idType )
                idType &= ~_CT2_2 ;
            {
            else if( idType & _CT2_2 )
            }
                }
                    default      : { __1 break ; }
                    case _CT1_07 : { ether.strFuseF( tinP , psttP , T("\"")+T(_CT1_07F(idr,idc))+T("\"") ) ; ___( psttP ) ; break ; }
                {
                switch( idType )
                idType &= ~_CT2_1 ;
            {
            else if( idType & _CT2_1 )
            }
                while( ~handle ) ;
                }
                    if( ~handle ) { ether.strFuseF( tinP , psttP , T(" , ") ) ; ___( psttP ) ; }

                    }
                        }
                            default      : { __1 break ; }
                            case _CT1_0f : { nicNameC& cc = *(nicNameC*)vv ; ether.strFuseF( tinP , psttP , T(cc) ) ; ___( psttP ) ; break ; }
                            case _CT1_0e : { count8S&  cc =  *(count8S*)vv ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T(",")+TF1(cc.c3)+T(",")+TF1(cc.c4)+T(",")+TF1(cc.c5)+T(",")+TF1(cc.c6)+T(",")+TF1(cc.c7)+T(",")+TF1(cc.c8)+T("]") ) ; ___( psttP ) ; break ; }
                            case _CT1_0d : { count7S&  cc =  *(count7S*)vv ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T(",")+TF1(cc.c3)+T(",")+TF1(cc.c4)+T(",")+TF1(cc.c5)+T(",")+TF1(cc.c6)+T(",")+TF1(cc.c7)+T("]") ) ; ___( psttP ) ; break ; }
                            case _CT1_0c : { count6S&  cc =  *(count6S*)vv ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T(",")+TF1(cc.c3)+T(",")+TF1(cc.c4)+T(",")+TF1(cc.c5)+T(",")+TF1(cc.c6)+T("]") ) ; ___( psttP ) ; break ; }
                            case _CT1_0b : { count5S&  cc =  *(count5S*)vv ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T(",")+TF1(cc.c3)+T(",")+TF1(cc.c4)+T(",")+TF1(cc.c5)+T("]") ) ; ___( psttP ) ; break ; }
                            case _CT1_0a : { count4S&  cc =  *(count4S*)vv ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T(",")+TF1(cc.c3)+T(",")+TF1(cc.c4)+T("]") ) ; ___( psttP ) ; break ; }
                            case _CT1_09 : { count3S&  cc =  *(count3S*)vv ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T(",")+TF1(cc.c3)+T("]") ) ; ___( psttP ) ; break ; }
                            case _CT1_08 : { count2S&  cc =  *(count2S*)vv ; ether.strFuseF( tinP , psttP , T("[")+TF1(cc.c1)+T(",")+TF1(cc.c2)+T("]") ) ; ___( psttP ) ; break ; }
                            case _CT1_06 : {                                 ether.strFuseF( tinP , psttP , TF1(*(measureT*)&vv) ) ; ___( psttP ) ; break ; } //U: TSM
                            case _CT1_05 : {                                 ether.strFuseF( tinP , psttP , TF1(vv) ) ; ___( psttP ) ; break ; }
                            case _CT1_04 : {                                 ether.strFuseF( tinP , psttP , TF2(vv,flFORMAT_UNSIGNED) ) ; ___( psttP ) ; break ; }
                            case _CT1_01 : { tableC& tbl  =   *(tableC*)vv ; tbl.writeF( tinP , psttP , csttEstimateP , flagsP ) ; ___( psttP ) ; break ; }
                        {
                        switch( idType2 )
                    {
                    else
                    }
                        }
                            /*default      :*/ { __1 /*break ;*/ }
                        {
                        //switch( idType2 )
                        idType2 &= ~_CT2_2 ;
                    {
                    else if( idType2 & _CT2_2 )
                    }
                        }
                            default      : { __1 break ; }
                            case _CT1_07 : { ether.strFuseF( tinP , psttP , T("\"")+T((strokeS*)vv)+T("\"") ) ; ___( psttP ) ; break ; }
                        {
                        switch( idType2 )
                        idType2 &= ~_CT2_1 ;
                    {
                    if( idType2 & _CT2_1 )
                    countT idType2 = idType ;

                    countT vv = stc.upF( tinP , handle ) ;
                {
                do
                handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                stackC& stc = _CT2_3F( idr , idc ) ;
                idType &= ~_CT2_3 ;
            {
            if( idType & _CT2_3 )

            countT idType = operator()( idr , idc ).c1 ;

            else                { ether.strFuseF( tinP , psttP , T(" , ") ) ; ___( psttP ) ; }
            else if( idc == 1 ) { ether.strFuseF( tinP , psttP , T("(")+TF1(idr)+T(")  ") ) ; ___( psttP ) ; }
                 if( bsl )      { ether.strFuseF( tinP , psttP , T("(")+TF1(idr)+T(",")+TF1(idc)+T(")  ") ) ; ___( psttP ) ; }
        {
        for( countT idc = 1 ; idc <= cCols ; idc ++ )
    {
    for( countT idr = 1 ; idr <= cRows ; idr ++ )
    ether.strFuseF( tinP , psttP , T("there are ")+TF1(cRows)+T(" rows in this table\r\n") ) ; ___( psttP ) ;

    }
        ether.strFuseF( tinP , psttP , T("col ")+TF1(idc)+T(" name: \"")+T(nameF(tinP,idc))+T("\"\r\n") ) ; ___( psttP ) ;
    {
    for( countT idc = 1 ; idc <= cCols ; idc ++ )
    ether.strFuseF( tinP , psttP , tBlammo ) ; ___( psttP ) ;

    textC tBlammo = tBlammo12 + tBlammo3 ;
    TN( tBlammo3 , " columns in this table\r\n" ) ;
    textC tBlammo12 = tBlammo1 + tBlammo2 ;
    TN( tBlammo2 , (strokeS*)TF1(cCols) ) ;
    TN( tBlammo1 , "there are " ) ;

    countT cCols = stNames ;
    countT cRows = stEvents ;

    ether.strFuseF( tinP , psttP , T(USCORE79 "\r\n\r\ninternal table name: \"")+T(psttName)+T("\"\r\n") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ csttEstimateP ) ;

    boolT bsl = F(flagsP) & flTABLEwRITE_ONElINEpERcOL ;
    _IO_

    }
        if( POOP ) return ;
        FV( flTABLEwRITE , flagsP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT tableC::writeF( tinS& tinP , strokeS*& psttP , const countT csttEstimateP , const flagsT flagsP )/*1*/

/**/
*/
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00100b5.flTABLEwRITE!||
 flagsP
  this function will fail if csttEstimateP is not enough
 csttEstimateP
  if not 0 then the psttP must point to a string with enough extra strokes to hold the entire dump
  if 0 then csttEstimateP must be enough to hold the entire dump
  can be 0 or not 0
 psttP
 tinP
arguments
appends a report of my contents to psttP
  \<A HREF=\"5.8620104.1.1.0.html\"\>8620104:  WAKEsHOW( "example.simplest.func.1320018.tableC.writeF" )\</A\>
 simplest
examples
\<A HREF=\"5.1320018.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$writeF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

