
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bOk ? 0 : jHe ;

    }
        if( !bOk && pBoolEdition[ idEditionP ] ) bOk = 1 ;                                       // SET bOk IF CONDITIONAL AND CONDITION IS SATISFIED

        }
            }
                break ;
                bOk = 0 ;
            {
            if( pBoolEdition[ offe ] )
        {
        for( countT offe = 0 ; offe < sizeof pBoolEdition / sizeof pBoolEdition[ 0 ] ; offe ++ ) // RESET bOk IF THIS BRANCH IS CONDITIONAL

        etherP.delF( tinP , psttDecoded ) ;
        } ;
            !!etherP.strIdF( tinP , sMarka2 , psttDecoded )
            !!etherP.strIdF( tinP , sMark92 , psttDecoded ) ,
            !!etherP.strIdF( tinP , sMark82 , psttDecoded ) ,
            !!etherP.strIdF( tinP , sMark72 , psttDecoded ) ,
            !!etherP.strIdF( tinP , sMark62 , psttDecoded ) ,
            !!etherP.strIdF( tinP , sMark52 , psttDecoded ) ,
            !!etherP.strIdF( tinP , sMark42 , psttDecoded ) ,
            !!etherP.strIdF( tinP , sMark32 , psttDecoded ) ,
            !!etherP.strIdF( tinP , sMark22 , psttDecoded ) ,
            !!etherP.strIdF( tinP , sMark12 , psttDecoded ) ,
        {
        boolT pBoolEdition[] =

        }
            etherP.strDecodeF( tinP , psttDecoded , psp ) ; ___( psttDecoded ) ;
            PSP( psp , valueHe ) ;
        {
        ZE( strokeS* , psttDecoded ) ;

        static strokeS sMarka2( 0x2a , sc_MARK ) ; // \9:                                     FLAG: CONDITIONALLY INCLUDE THIS BRANCH IFF idEditionP == 9
        static strokeS sMark92( 0x29 , sc_MARK ) ; // \8:                                     FLAG: CONDITIONALLY INCLUDE THIS BRANCH IFF idEditionP == 8
        static strokeS sMark82( 0x28 , sc_MARK ) ; // \7:                                     FLAG: CONDITIONALLY INCLUDE THIS BRANCH IFF idEditionP == 7
        static strokeS sMark72( 0x27 , sc_MARK ) ; // \6:                                     FLAG: CONDITIONALLY INCLUDE THIS BRANCH IFF idEditionP == 6
        static strokeS sMark62( 0x26 , sc_MARK ) ; // \5:                                     FLAG: CONDITIONALLY INCLUDE THIS BRANCH IFF idEditionP == 5
        static strokeS sMark52( 0x25 , sc_MARK ) ; // \4:                                     FLAG: CONDITIONALLY INCLUDE THIS BRANCH IFF idEditionP == 4
        static strokeS sMark42( 0x24 , sc_MARK ) ; // \3:                                     FLAG: CONDITIONALLY INCLUDE THIS BRANCH IFF idEditionP == 3
        static strokeS sMark32( 0x23 , sc_MARK ) ; // \2:                                     FLAG: CONDITIONALLY INCLUDE THIS BRANCH IFF idEditionP == 2
        static strokeS sMark22( 0x22 , sc_MARK ) ; // \1:                                     FLAG: CONDITIONALLY INCLUDE THIS BRANCH IFF idEditionP == 1
        static strokeS sMark12( 0x21 , sc_MARK ) ; // \0:                                     FLAG: CONDITIONALLY INCLUDE THIS BRANCH IFF idEditionP == 0 (THESE BRANCHES ARE COMMENTS BECAUSE idEditionP CANNOT BE 0)
    {
    if( bOk && idTypeHe == ifcIDtYPEbRANCHs_strokeSstr )
    boolT bOk = !!jHe ;

    }
        }
            }
                valueHe  = B(brHe).value  ;
                idTypeHe = B(brHe).idType ;
                BSP( brHe , jHe ) ;
            {
            else
            }
                 idTypeHe = 0 ;
                 etherP.traceF( tinP , T("branchS::bEditionF: error: following a branch pointer led nowhere") ) ;
            {
            if( !jHe )                                          //20180420@0954:  ADDED WITHOUT ANALYSIS TO HANDLE !jHe WHEN etherSoilF PROCESSES A KT WITH AN INTENTIONAL MISSING LABEL

            jHe = valueHe ;

            branchS* pDebug = (branchS*)valueHe ;
        {
        else
        if( jStart == valueHe ) { idTypeHe = jHe = 0 ; }

        etherP.traceF( tinP , T("branchS::bEditionF: [valueHe]:    ")+TF2(valueHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;    //U:: TO FIND A BUG
    {
    while( idTypeHe == ifcIDtYPEbRANCHs_branchSptr )

    }
        valueHe  = B(brHe).value  ;
        idTypeHe = B(brHe).idType ;
        BSP( brHe , jHe ) ;
    {
    ZE( countT , valueHe ) ;
    ZE( countT , idTypeHe ) ;

    countT       jHe    = jStart ;
    const countT jStart = jMeP ;

    }
        if( POOP ) return 0 ;
        __( idEditionP > 9 ) ;
        __Z( idEditionP ) ;
        __Z( jMeP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL

    }
        countT foo = 2 ;
    {
    if( idIn == 0x13 )

    countT idIn = 1 + incv02AM( idInLath ) ;
    static countT idInLath ;
{
/*1*/countT branchS::bEditionIF( tinS& tinP , etherC& etherP , const countT jMeP , const countT idEditionP )/*1*/

/**/
*/
putFileIF needs to push my nonze""ro return value into stNix
most callers can interpret it as a boolean
do not delete the pointer that i return
 if i am not a reference branch then i return my own address (this)
else i return the address of the branch that i reference
i return 0 iff this branch is included in the specified edition
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

