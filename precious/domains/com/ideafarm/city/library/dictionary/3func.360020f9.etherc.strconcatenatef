
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cMarks ;
    st_psttP.ungrabF( tinP ) ;
    }
        }
            }
                delF( tinP , psttc1 ) ;
                }
                    cMarks ++ ;
                    strFuseF( tinP , psttP , psttDelimiterP ) ; ___( psttP ) ;
                {
                if( psttDelimiterP && st_psttP )
                #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000010.strConcatenateF_woSnip.h"
                st_psttP >> psttc1 ;
                ZE( strokeS* , psttc1 ) ; //NAMED THIS FOR CONVENIENCE OF OTHER OVERLOAD
            {
            else
            }
                strFuseF( tinP , psttP , sttWo ) ; ___( psttP ) ;
                st_psttP >> pb_sttWo ;
                byteT* pb_sttWo = (byteT*)&sttWo ;
                strokeS sttWo ;
            {
            if( bSingles )
        {
        else while( st_psttP )
        }
            }
                }
                    }
                        st_psttP >> pb_sttWo ;
                        byteT* pb_sttWo = (byteT*)&sttWo ;
                        strokeS sttWo ;
                    {
                    while( st_psttP ) //PURGE DONE THIS WAY TO DEREGISTER sc_cADAM INSTANCES
                {
                else
                if( !bSingles ) st_psttP.purgeF( tinP ) ;
            {
            if( !bCopy )

            while( !POOP && ~handle ) ;
            }
                }
                    }
                        cMarks ++ ;
                        strFuseF( tinP , psttP , psttDelimiterP ) ; ___( psttP ) ;
                    {
                    if( psttDelimiterP && ~handle )
                    #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000010.strConcatenateF_woSnip.h"
                    strokeS* psttc1 = (strokeS*)( bUp ? st_psttP.upF( tinP , handle ) : st_psttP.downF( tinP , handle ) ) ; //NAMED THIS FOR CONVENIENCE OF OTHER OVERLOAD
                {
                else
                }
                    strFuseF( tinP , psttP , sttWo ) ; ___( psttP ) ;
                    strokeS& sttWo = *(strokeS*)&( bUp ? st_psttP.upF( tinP , handle ) : st_psttP.downF( tinP , handle ) ) ;
                {
                if( bSingles )
            {
            do
            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( bUp || bCopy )
        ZE( boolT , bNullLag ) ;
        TN( tNull , "" ) ; tNull = T("") + S2( (countT)0 , sc_NULL ) ;
    {
    if( st_psttP )

    strMakeF( tinP , LF , psttP , T("") , cstta ) ; // CALLER MUST TAG ___( psttP ) ;

    }
        }
            while( !POOP && ~handle ) ;
            }
                else        __1
                if( psttw ) cstta += psttw->idAdam + bSeparate * CSpREFIX ;
                strokeS* psttw = (strokeS*)st_psttP.downF( tinP , handle ) ;
            {
            do
            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        else
        if( bSingles ) cstta += st_psttP ;
    {
    if( st_psttP )
    countT cstta = csttExtraP + ( psttDelimiterP && st_psttP ? psttDelimiterP->idAdam * ( st_psttP - 1 ) : 0 ) ;
    st_psttP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    ZE( countT , cMarks ) ;

    const boolT  bUp       = !!( F(flagsP) & flSTRcONCATENATE_REVERSE  ) ; //DOES NOT REVERSE THE ORDER OF STROKES WITHIN EACH SNIPPET
    const boolT  bCopy     = !!( F(flagsP) & flSTRcONCATENATE_COPY     ) ;
    const countT cExclude  = pczIdCasteExcludeP ? thirdC::c_strlenIF( tinP , pczIdCasteExcludeP ) : 0 ;
    const countT cInclude  = pczIdCasteIncludeP ? thirdC::c_strlenIF( tinP , pczIdCasteIncludeP ) : 0 ;
    const boolT  bSeparate = !bSingles && !!( F(flagsP) & flSTRcONCATENATE_SEPARATE ) ;
    const boolT  bSingles  = idType != ifcSTACKtYPE_PTR_strokeS ;

    _IO_

    }
        if( POOP ) return 0 ;
        FV( flSTRcONCATENATE , flagsP )
        if( idType != ifcSTACKtYPE_PTR_strokeS && psttDelimiterP )
        __( idType != ifcSTACKtYPE_PTR_strokeS && ( idType != ifcSTACKtYPE_BLOB || st_psttP.cbDataF( tinP ) != sizeof( strokeS ) ) ) ;
        __NZ( psttP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    const countT idType = st_psttP.idTypeF( tinP ) ;
    SCOOP
{
/*1*/countT etherC::strConcatenateF( tinS& tinP , strokeS*& psttP , stackC& st_psttP , const strokeS* const psttDelimiterP , const flagsT flagsP , const countT* const pczIdCasteIncludeP , const countT* const pczIdCasteExcludeP , const countT csttExtraP )/*1*/

/**/
*/
 csttExtraP
  ignored if st_psttP is of type blob (each plate is a single strokeS image)
 pczIdCasteExcludeP
  ignored if st_psttP is of type blob (each plate is a single strokeS image)
 pczIdCasteIncludeP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001029e.flSTRcONCATENATE!||
 flagsP
  ignored if st_psttP is of type blob (each plate is a single strokeS image)
  will be inserted between each snippet in st_psttP
  if not 0 then can be 0 length
  can be 0
 psttDelimiterP
  type must be ifcSTACKtYPE_PTR_strokeS
 st_psttP
  must be 0
 psttP
 tinP
arguments
 each exclusion mark is tallied
 each delimiter is tallied
i evaluate to the number of markers inserted
concatenates all strings in st_psttP into a single string
\<A HREF=\"5.1030120.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strConcatenateF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

