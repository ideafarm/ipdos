
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;

}
    af1.walkF( tinP , associateCBF , 0 , flASSOCIATEcwALK_RECURSE , pcInclude , pcExclude ) ;

    //countT pcExclude[] = { IDG_vGooS | BM_HIGH2 , 0 } ;
    //countT pcExclude[] = { IDG_aGooS | BM_HIGH  , 0 } ;
    //countT pcExclude[] = { (countT)&ag3         , 0 } ;
    ZE( countT* , pcExclude ) ;

    //countT pcInclude[] = { IDG_vFooS | BM_HIGH2 , 0 } ;
    //countT pcInclude[] = { IDG_aFooS | BM_HIGH  , 0 } ;
    //countT pcInclude[] = { (countT)&af2           , (countT)&af3 , 0 } ;
    ZE( countT* , pcInclude ) ;

    //ag4 += af1 ; // ENABLE THIS LINE TO SEE THE EFFECT OF CIRCULAR VIEWING    
    ag3 += ag4 ;
    ag2 += ag3 ;
    ag1 += ag2 ;
    af4 += ag1 ;
    af3 += af4 ;
    af2 += af3 ;
    af1 += af2 ;
    
    aGooS ag4( tinP , etThread ) ;
    aGooS ag3( tinP , etThread ) ;
    aGooS ag2( tinP , etThread ) ;
    aGooS ag1( tinP , etThread ) ;
    
    aFooS af4( tinP , etThread ) ;
    aFooS af3( tinP , etThread ) ;
    aFooS af2( tinP , etThread ) ;
    aFooS af1( tinP , etThread ) ;
{

TODO

}
    return 0 ;

    }
        }
            CONoUTrAW7( "walker [idw,idGroup,idMe]: " , idw , " " , idGroup , "(" , idMe , ")\r\n" ) ;

            }
                case IDG_aGooS : { idMe = ((aGooS&)assWalker).idMe ; break ; }
                case IDG_aFooS : { idMe = ((aFooS&)assWalker).idMe ; break ; }
            {
            switch( idGroup )
            ZE( countT , idMe ) ;

            countT idGroup = assWalker.idGroupF() ;
            associateC& assWalker = *(associateC*)(*pStqWalkerP)[ idw ] ;
        {
        for( countT idw = 1 ; idw <= cWalker ; idw ++ )
        countT cWalker = *pStqWalkerP ;
    {
    if( pStqWalkerP )

    CONoUTrAWb( "associateCBF [idGroupViewer,idMeViewer,idGroupView,idGroupViewee,idMeViewee]: " , idGroupViewer , "(" , idMeViewer , ") is viewing a view of type " , idGroupView , " of subject " , idGroupViewee , "(" , idMeViewee , ")\r\n" ) ;

    }
        }
            break ;
            idMeViewee = (*(const vGooS*)&assViewP).idMeViewed ;
        {
        case IDG_vGooS :
        }
            break ;
            idMeViewee = (*(const vFooS*)&assViewP).idMeViewed ;
        {
        case IDG_vFooS :
    {
    switch( assViewP.idGroupF() )
    ZE( countT , idMeViewee ) ;
    countT idGroupViewee = assViewP.idGroupSubjectF() ;
    countT idGroupView   = assViewP.idGroupF() ;

    }
        }
            break ;
            idMeViewer = (*(const aGooS*)&viewerP).idMe ;
        {
        case IDG_aGooS :
        }
            break ;
            idMeViewer = (*(const aFooS*)&viewerP).idMe ;
        {
        case IDG_aFooS :
    {
    switch( viewerP.idGroupF() )
    ZE( countT , idMeViewer ) ;
    countT idGroupViewer = viewerP.idGroupF() ;
{
boolT associateCBF( tinS& tinP , const assViewC& assViewP , const associateC& viewerP , const countT cArgP , staqC* const pStqWalkerP )

}
{
idMeViewed( idMeViewedP )
assViewC( IDG_vGooS , idGroupSubjectP , cbaP ) ,
vGooS::vGooS( countT cbaP , countT idGroupSubjectP , countT idMeViewedP ) :

}
{
vGooS::~vGooS( voidT )

NEWdELcLASS( 1 , vGooS )

}
{
idMeViewed( idMeViewedP )
assViewC( IDG_vFooS , idGroupSubjectP , cbaP ) ,
vFooS::vFooS( countT cbaP , countT idGroupSubjectP , countT idMeViewedP ) :

}
{
vFooS::~vFooS( voidT )

NEWdELcLASS( 1 , vFooS )

}
    }
        new( 0 , tinP , pbaViewP , sizeof( vGooS ) ) vGooS( sizeof( vGooS ) , idGroup , idMe ) ;
    {
    if( cbaViewP >= sizeof( vGooS ) )
{
voidT aGooS::viewF( tinS& tinP , byteT* const pbaViewP , countT cbaViewP , associateC& viewerP )

}
{
idMe( 1 + incv02AM( idMeLathGoo ) )
associateC( tinP , etherP , IDG_aGooS , sizeof( vGooS ) ) ,
aGooS::aGooS( tinS& tinP , etherC& etherP ) :

}
    }
        new( 0 , tinP , pbaViewP , sizeof( vFooS ) ) vFooS( sizeof( vFooS ) , idGroup , idMe ) ;
    {
    if( cbaViewP >= sizeof( vFooS ) )
{
voidT aFooS::viewF( tinS& tinP , byteT* const pbaViewP , countT cbaViewP , associateC& viewerP )

}
{
idMe( 1 + incv02AM( idMeLathFoo ) )
associateC( tinP , etherP , IDG_aFooS , sizeof( vFooS ) ) ,
aFooS::aFooS( tinS& tinP , etherC& etherP ) :

;
}
    vGooS( countT cbaP , countT idGroupSubjectP , countT idMeViewedP ) ;
    virtual ~vGooS( voidT ) ;
    NEWdELcLASSpROTOS

    const countT idMeViewed ;
{
struct vGooS : public assViewC

;
}
    vFooS( countT cbaP , countT idGroupSubjectP , countT idMeViewedP ) ;
    virtual ~vFooS( voidT ) ;
    NEWdELcLASSpROTOS

    const countT idMeViewed ;
{
struct vFooS : public assViewC

;
}
    virtual voidT viewF( tinS& tinP , byteT* const pbaViewP , countT cbaViewP , associateC& viewerP ) ;
    aGooS( tinS& tinP , etherC& etherP ) ;

    const countT idMe ;
{
struct aGooS : public associateC

;
}
    virtual voidT viewF( tinS& tinP , byteT* const pbaViewP , countT cbaViewP , associateC& viewerP ) ;
    aFooS( tinS& tinP , etherC& etherP ) ;

    const countT idMe ;
{
struct aFooS : public associateC

countT idMeLathGoo ;
countT idMeLathFoo ;

#define IDG_vGooS               4
#define IDG_vFooS               3
#define IDG_aGooS               2
#define IDG_aFooS               1

/*1*/WAKEsHOWtEXT( "example.other.associateC.with.assViewC.heterogeneous" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

