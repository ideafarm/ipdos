
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.strokeF( tinP , T("\r\nok\r\n") ) ;
etThread.delF( tinP , postOldCode ) ;
}
    CONoUTrAW( "file has been written\r\n" ) ;
    etThread.boxPutF( tinP , T("///ideafarm/precious/domains/com/ideafarm/city/library/snip/1snip.19000006.genFileTitles.h") , postOldCode , posto - postOldCode ) ;
    CONoUTrAW( "putting file\r\n" ) ;
    }
        while( ~hFind && !ether ) ;
        }
            DEL( pInfo ) ;
            }
                etThread.delF( tinP , psttIdR ) ;
                etThread.delF( tinP , psttw ) ;
                
                //etThread.strokeF( tinP , T(psttw)+T("\r\n") ) ;
                //U::/*if( !( idCompressed % 0x10 ) )*/ etThread.strokeF( tinP , T("")+S2(saOLD_EDITeRASEbACKtOmARK,scOld_EDIT)+S2(0,scOld_SYSmARK) ) ;

                thirdC::c_strcpyIF( tinP , posto , tNew ) ; posto += tNew.csF( tinP ) ;

                TN( tNew , "" ) ; tNew = T("0x")+T(psttIdR)+T(" , \"\\0\\0\\0\\0")+T(psttw)+T("\"") ;
                etThread.strReplaceF( tinP , psttw , 0 , T("\"") , T("\\\"") , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttw ) ;
                if( !psttw ) { etThread.strMakeF( tinP , LF , psttw , T("") ) ; ___( psttw ) ; }
                
                if( postOldCode < posto ) { thirdC::c_strcpyIF( tinP , posto , " ,\r\n" ) ; posto += 4 ; }
                
                }
                    }
                        etThread.delF( tinP , psttd ) ;
                        etThread.strSubstringF( tinP , psttw , idf , idl , psttd ) ; ___( psttw ) ;
                        countT idl = psttd->idAdam - 2 ;
                        //sttq = ze ;
                        idf = 1 ;
                        psttw = 0 ;
                        strokeS* psttd = psttw ;
                    {
                    if( psttw->idAdam - 1 == etThread.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tCommentClose , psttw ) )
                    countT idf = 1 ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                {
                if( psttw )
            
                }
                    }
                        etThread.delF( tinP , psttd ) ;
                        etThread.strSubstringF( tinP , psttw , idf , idl , psttd ) ; ___( psttw ) ;
                        ZE( countT , idl ) ;
                        //sttq = ze ;
                        idf = 3 ;
                        strokeS* psttd = psttw ; psttw = 0 ;
                    {
                    if( 1 == etThread.strIdF( tinP , 0 , flSTRmATCH_null , idf , sttq , tCommentOpen , psttw ) )
                    countT idf = 1 ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                {
                else
                }
                    continue ;
                    etThread.traceF( tinP , T("\r\nERROR: NO TITLE FOUND IN FILE:  ")+T(pInfo->psttIfoName)+T("\r\n") ) ;
                {
                if( !psttw )
                    
                }
                    etThread.delF( tinP , pstta ) ;
                    }
                        idClass = 0 ;
                        etThread.delF( tinP , psttw ) ;
                        if( idClass == 1 ) break ; // ASSUME: DELIMITER CLASS 1 IS USED ALWAYS FOR FILE TITLE AND NEVER FOR ANYTHING ELSE
                        etThread.strSubstringDelimitedF( tinP , psttw , idClass , idf , sttq , pstta ) ; ___( psttw ) ;
                    {
                    while( !etThread && !ether && idf && !psttw )
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf = 1 ;
                    ZE( countT , idClass ) ;
                
                    etThread.strReverseF( tinP , pstta , 0 , T("\r\n") ) ; ___( pstta ) ;
                    etThread.delF( tinP , posta ) ;
                    etThread.strMakeF( tinP , LF , pstta , T(posta) ) ; ___( pstta ) ;
                    ZE( strokeS* , pstta ) ;
                
                    }
                        posta[ costa ] = 0 ;
                        if( costa ) etThread.fileReadF( tinP , posta , costa , hFile ) ;
                        ether.newF( tinP , LF , posta , costa + 1 ) ; ___( posta ) ;
                
                        DEL( pInfo ) ;
                        if( pInfo ) costa = pInfo->cbUsed ;
                        etThread.diskFileQueryF( tinP , pInfo , hFile ) ; ___( pInfo ) ;
                        ZE( infoFileS* , pInfo ) ;
                
                        etThread.fileOpenF( tinP , hFile , countTC() , pInfo->psttIfoName , ifcOPENaCCESS_R , 0 , flOPENdETAILS_FAIL | flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
                        handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                    {
                    //U::THIS CAUSES A LEAK: etThread.boxGetShadowF( tinP , posta , costa , pInfo->psttIfoName ) ; ___( posta ) ;
                
                    //etThread.strokeF( tinP , T("reading file \"")+T(pInfo->psttIfoName)+T("\"\r\n") ) ;
                    ZE( countT , costa ) ;
                    ZE( osTextT* , posta ) ;
                {
                ZE( strokeS* , psttw ) ;
                
                etThread.strFromF( tinP , psttIdR , idCompressed , flFORMAT_UNSIGNED | flFORMAT_FILLzE | flFORMAT_FOREIGN , 8 ) ; ___( psttIdR ) ;
                ZE( strokeS* , psttIdR ) ;
                idCompressed ++ ;
                
                if( !( cToDo % 0x10 ) ) { CONoUTrAW3( "\r               \rcToDo: " , cToDo , "\r" ) ; }
            {
            if( pInfo && !( F(pInfo->flags) & flFILEaTTR_DIRECTORY ) )
            tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , fnLike.pathF() , &pat ) ; ___( pInfo ) ;
            ZE( infoFileS* , pInfo ) ;
            cToDo -- ;
        {
        do
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

        patternC pat( tinP , etThread , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        fileNameC fnLike( tinP , etThread , *pptLike[ offl ] ) ;
    {
    for( countT offl = 0 ; !ether && offl < sizeof pptLike / sizeof pptLike[ 0 ] ; offl ++ )
    ZE( countT   , idCompressed ) ;
    TN( tCommentClose , "*" "/" ) ;
    TN( tCommentOpen  , "/" "*" ) ;
    
    osTextT* posto = postOldCode ;
{
if( postOldCode )
etThread.newF( tinP , LF , postOldCode , cToDo * TUCK ) ; ___( postOldCode ) ;
ZE( osTextT* , postOldCode ) ;
CONoUTrAW3( "\rcToDo: " , cToDo , "\r\n" ) ;

}
    while( ~hFind && !ether ) ;
    }
        DEL( pInfo ) ;
        }
            if( !( cToDo % 0x10 ) ) { CONoUTrAW3( "\r               \rcToDo: " , cToDo , "\r" ) ; }
            cToDo ++ ;
        {
        if( pInfo && !( F(pInfo->flags) & flFILEaTTR_DIRECTORY ) )
        tinP.pEtScratch->diskFindFileOrDirF( tinP , pInfo , hFind , fnLike.pathF() , &pat ) ; ___( pInfo ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

    patternC pat( tinP , etThread , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
    fileNameC fnLike( tinP , etThread , *pptLike[ offl ] ) ;
{
for( countT offl = 0 ; !ether && offl < sizeof pptLike / sizeof pptLike[ 0 ] ; offl ++ )
CONoUTrAW3( "\r\n               \rcToDo: " , cToDo , "\r" ) ;
ZE( countT , cToDo ) ;

textC* pptLike[] = { &tLike1 , &tLike2 , &tLike3 , &tLike4 } ;
//textC* pptLike[] = { &tLikeT } ;
//TN( tLikeT , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.34002.etherInitC.etherInitC" ) ;
TN( tLike4 , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/4boot.*" ) ;
TN( tLike3 , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.*" ) ;
TN( tLike2 , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.*" ) ;
TN( tLike1 , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/0*" ) ;

CONoUTrAW( "FILE IDRANK TITLE TABLE\r\n" ) ;

TODO

// FOR EXAMPLE, USING IT FOR A TEMPORARY LOOKFORWARD AND NOT RESETTING IT AFTER THE TEMPORARY LOOKFORWARD
//CONJ: THE CODE BEING EXERCISED ALSO CONTAINS DEFECTS IN THE WAY THAT sttQuote IS USED
//CONJ: CAN FIX THIS BY TELLING CODE TO IGNORE QUOTES
//U: THIS FUNCTION WILL FAIL IF THE FILE BEING SCANNED CONTAINS AN ODD NUMBER OF DOUBLE QUOTE MARKS

//U: SUPPORT IMPLICIT IDS AND TITLES FOR ????104 FILES (TO MAKE DISTRIBUTION FILES SMALLER)
//U::etThread.strokeF( tinP , T("")+S2(0,scOld_SYSmARK) ) ;

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_DEFtITLE.fileIdTable" )/*1*/
/**/
*/
applications can access costFileTitle efficiently using ((countT*)postFileTitle)[ - 1 ]
postFileTitle values should point to the end of these blanks
these blanks are intended to be overwritten with the value of costFileTitle for this title
each file title begins with sizeof( countT ) null bytes
writes the compressed file id + file title table
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

