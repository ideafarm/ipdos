
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    
    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / 0\r\n" ) ;
    if( pbUniverseOverride ) { DELzOMBIE( pbUniverseOverride ) ; }
    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / 1\r\n" ) ;

    }
        //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / 2\r\n" ) ;
        hNapkin.closeIfF() ; //pbNapkin WILL BE NULL IF CT'OR FAILED.  THIS TEST IS REQUIRED BECAUSE napkinC USES tinP.pEther RATHER THAN CARRYING ITS OWN etherC REFERENCE
        //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / 3\r\n" ) ;
        //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / 4\r\n" ) ;
    
        }
            //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / 5\r\n" ) ;
            }
                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / 6\r\n" ) ;
                DELzOMBIE( pd ) ;
                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / 7\r\n" ) ;
                grabotC* pd = (grabotC*)(byteT*)*this ;
            {
            else if( this == &processGlobal7I._sexC_napGlobalRegistry )
            }
                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / 8\r\n" ) ;
                }
                    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / 9\r\n" ) ;
                    DELzOMBIE( pDoomed ) ;
                    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / a\r\n" ) ;
                    ipMapHomeS* pDoomed = pCursor ++ ;
                {
                while( cToDo -- )
                countT cToDo = CiPmAPhOME ;
                ipMapHomeS* pCursor = (ipMapHomeS*)(byteT*)*this ;
                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / b\r\n" ) ;
            {
            else if( this == &processGlobal7I._socketC_napIpMapHome )
            }
                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / c\r\n" ) ;
                }
                    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / d\r\n" ) ;
                    DELzOMBIE( pDoomed ) ;
                    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / e\r\n" ) ;
                    grabWantS* pDoomed = processGlobal1I._grabC_pgw + ogw ;
                {
                for( countT ogw = 0 ; ogw < processGlobal1I._grabC_cgw ; ogw ++ )
                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / f\r\n" ) ;
    
                ph->grabSuperRandom.flags |= flGRABc_DISABLED ;
                ph->grabTimeUnique.flags  |= flGRABc_DISABLED ;
                homeS* ph = (homeS*)(byteT*)processGlobal3I.napHome ;
            {
            else if( this == &processGlobal3I._grabC_napGrabWant )
            }
                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / g\r\n" ) ;
                DELzOMBIE( ph ) ;
                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / h\r\n" ) ;
                homeS* ph = (homeS*)(byteT*)*this ;
            {
            else if( this == &processGlobal3I.napHome )
            }
                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / i\r\n" ) ;
                DELzOMBIE( ps ) ;
                //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / j\r\n" ) ;
                slabS* ps = (slabS*)(byteT*)*this ;
            {
            if( this == &processGlobal3I.napSlab )
            //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / k\r\n" ) ;
        {
        if( F(flagsState) & flNAPKINcsTATE_DYINGaLONE )
        //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / l\r\n" ) ;
    
        }
            TELLsYSc3LIFI( ifcIDtYPEtELLsYS_NAPKINdETACH , (byteT*)&ti , sizeof ti , idLineCt , idiFileCt )
            ti.idiFileCt = idiFileCt ;
            ti.idLineCt  = idLineCt ;
            ti.cbData    = ((napkinHeaderS*)pbNapkin)->cbData ;
            ti.pbData    = pbNapkin + sizeof( napkinHeaderS ) ;
            ti.costName  = thirdC::c_strlenIF( tinP , ti.postName ) ;
            thirdC::c_strncpyIF( tinP , ti.postName , postName , sizeof ti.postName ) ;
            ti.osPid     = tinP.osPid ;
            tellInfoSysNapkinS ti ;
        {
        else
        }
             processGlobal1I.flDt |= flCTdTg_napSlabI ;
        {
        else if( this == &processGlobal3I.napSlab )
        }
             processGlobal1I.flDt |= flCTdTg_napHomeI ;
        {
        if( this == &processGlobal3I.napHome ) //ASSUME: napHome IS CT WOTH
        //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / m\r\n" ) ;
    {
    if( pbNapkin )

    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / n\r\n" ) ;
    flushF( tinP ) ;
    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / o\r\n" ) ;
    dieF( tinP ) ;
    //if( tinP.pc Utility[ 0 ] ) CONoUTrAW( "~napkinC / p\r\n" ) ;

    _IO_
    
    LOGrAW(   ostoSay ) ;
    OStEXTAK( ostoSay , "\r\n" ) ;
    OStEXTA(  ostoSay , postName ) ;
    OStEXTAK( ostoSay , "    " ) ;
    OStEXTC(  ostoSay , tinP.pAdamGlobal1->idAdam , '0' ) ;
    OStEXTAK( ostoSay , "    " ) ;
    OStEXTC(  ostoSay , ((napkinHeaderS*)pbNapkin)->cRef , '0' ) ;
    OStEXTAK( ostoSay , "napkinC: ---- [cRef before ----   ,idAdam,postP]:    " ) ;
    OStEXT(   ostoSay , TUCK ) ;
    //U:: TO FIND A BUG

    }
        if( pbNapkin && !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) ) { __( bDataAreaFormatted - 1 ) ; }
    {
    IFbEcAREFUL
    SCOOP

    TINSL
{
/*1*/napkinC::~napkinC( voidT )/*1*/
/**/
*/
\<A HREF=\"5.15e0002.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

