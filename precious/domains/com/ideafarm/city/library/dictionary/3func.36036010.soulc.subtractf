
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return sgn ;

    _OUT_

    }
        }
            }
                }
                    if( !POOP ) sgn = ::subtractF( tinP , ether , pb1 , pb2 , cb1 , cb2 , bNum1 , bInc1 ) ;

                    cb2 -= 2 * sizeof( countT ) ;
                    cb1 -= 2 * sizeof( countT ) ;

                    pb2 += sizeof( countT ) ;
                    pb1 += sizeof( countT ) ;

                    __( bInc2 - bInc1 ) ;
                    __( bNum2 - bNum1 ) ;

                    boolT bInc2 = F(*(flagsT*)pb2) & flSOULiTEM_INCREASINGiNsIGNIFICANCE ;
                    boolT bInc1 = F(*(flagsT*)pb1) & flSOULiTEM_INCREASINGiNsIGNIFICANCE ;

                    boolT bNum2 = F(*(flagsT*)pb2) & flSOULiTEM_MADEoFcOUNToBJECTS ;
                    boolT bNum1 = F(*(flagsT*)pb1) & flSOULiTEM_MADEoFcOUNToBJECTS ;

                    pb2 += 2 * sizeof( countT ) ;
                    pb1 += 2 * sizeof( countT ) ;
                {
                else
                else if( !cb2 ) sgn =   1 ;
                else if( !cb1 ) sgn = - 1 ;
                if( !cb1 && !cb2 ) ;

                countT& cb2 = *(countT*)pb2 ;
                countT& cb1 = *(countT*)pb1 ;
            {
            else // pb1 pb2 NOW POINT TO ITEM idFieldP
            else if( !pb2 ) sgn =   1 ;
            else if( !pb1 ) sgn = - 1 ;
            if( !pb1 && !pb2 ) ;

            if( cSkip || pb2 >= pbe2 ) pb2 = 0 ;
            while( cSkip && pb2 < pbe2 ) cSkip -- , pb2 += sizeof( countT ) + *(countT*)pb2 ;
            cSkip = idFieldP - 1 ;

            if( cSkip || pb1 >= pbe1 ) pb1 = 0 ;
            while( cSkip && pb1 < pbe1 ) cSkip -- , pb1 += sizeof( countT ) + *(countT*)pb1 ;
            countT cSkip = idFieldP - 1 ;

            pb2 += sizeof( countT ) ; // pb1 pb2 NOW POINT TO THE ZE'ST ITEM
            pb1 += sizeof( countT ) ;

            const byteT* const pbe2 = pb2 + sizeof( countT ) + cbs2 ;
            const byteT* const pbe1 = pb1 + sizeof( countT ) + cbs1 ;
        {
        else
        else if( !cbs2 ) sgn =   1 ;
        else if( !cbs1 ) sgn = - 1 ;
        if( !cbs1 && !cbs2 ) ;

        countT& cbs2 = *(countT*)pb2 ;
        countT& cbs1 = *(countT*)pb1 ;
    {
    if( !POOP )

    __Z( pb2 ) ;
    __Z( pb1 ) ;
    POOPIE

    }
        idFormat2 = *(countT*)pb2 ; pb2 += sizeof( countT ) ;
                                    pb2 += sizeof( countT ) ;
    {
    if( pb2 && getNegAM( *(countT*)pb2 ) == FINGERnEG_SOULc )
    ZE( countT , idFormat2 ) ;

    }
        idFormat1 = *(countT*)pb1 ; pb1 += sizeof( countT ) ;
                                    pb1 += sizeof( countT ) ;
    {
    if( pb1 && getNegAM( *(countT*)pb1 ) == FINGERnEG_SOULc )
    ZE( countT , idFormat1 ) ;

    const byteT* pb2 = soulP ;
    const byteT* pb1 = *this ;
    ZE( sCountT , sgn ) ;

    _INoLD_

    }
        if( !idFieldP ) return 0 ;
    {
    IFbEcAREFUL    
    SCOOP
{
/*1*/sCountT soulC::subtractF( tinS& tinP , soulC& soulP , const countT idFieldP )/*1*/

/**/
*/
  must not be 0
 idFieldP
 soulP
 tinP
arguments
 -1: the item in *this is less than the item in soulP
 0: the item in *this is equal to the item in soulP soulP
 1: the item in *this is greater than the item in soulP
evaluates to one of re values (-1,0,1) depending on the relative sort ordering of field idFieldP in each operand
\<A HREF=\"5.14e0010.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$subtractF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

