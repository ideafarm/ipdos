
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_
    else __1
    }
        else __1
        }
            }
                ether.memCopyF( tinP , pbNapkin , pbP , cbw ) ;
                __( cbw > cbNapkin ) ;
                __Z( cbw ) ;
                countT cbNapkin = *(countT*)( pbNapkin - sizeof(countT) ) ;
            {
            if( pbNapkin )
            __Z( pbP ) ;
        {
        else if( !ether.strCompareF( tinP , psttType , T("napkin.make") ) || !ether.strCompareF( tinP , psttType , T("napkin") ) )
        }
        {
        else if( !ether.strCompareF( tinP , psttType , T("process.error") ) )
        }
        {
        else if( !ether.strCompareF( tinP , psttType , T("process.out") ) )
        }
            //U:
        {
        else if( !ether.strCompareF( tinP , psttType , T("process.in") ) )
        }
        {
        else if( !ether.strCompareF( tinP , psttType , T("process") ) )
        }
            #endif
                pBatHPR->ungrabF( tinP ) ;
                ether.fileWriteF( tinP , hHoseReply , pbP , cbw ) ;
                ether.fileWriteF( tinP , hHoseReply , (byteT*)&cbw , sizeof cbw ) ;
                __Z( hHoseReply ) ;
                pBatHPR->grabF( tinP , TAG( TAGiDnULL ) ) ;
            #elif defined( __NT__ )
                ether.fileWriteF( tinP , handle , pbP , cbw ) ;
                ether.fileWriteF( tinP , handle , (byteT*)&cbw , sizeof cbw ) ;
                __Z( handle ) ;
            #ifdef __OS2__
            __Z( pbP ) ;
        {
        else if( !ether.strCompareF( tinP , psttType , T("tap" ) ) )
        }
            #endif
                pBatHPC->ungrabF( tinP ) ;
                ether.fileWriteF( tinP , hHoseCommand , pbP , cbw ) ;
                ether.fileWriteF( tinP , hHoseCommand , (byteT*)&cbw , sizeof cbw ) ;
                __Z( hHoseCommand ) ;
                pBatHPC->grabF( tinP , TAG( TAGiDnULL ) ) ;
            #elif defined( __NT__ )
                ether.fileWriteF( tinP , handle , pbP , cbw ) ;
                ether.fileWriteF( tinP , handle , (byteT*)&cbw , sizeof cbw ) ;
                __Z( handle ) ;
            #ifdef __OS2__
            __Z( pbP ) ;
        {
        else if( !ether.strCompareF( tinP , psttType , T("hose") ) )
        }
            if( pbP ) ether.fileWriteF( tinP , handle , pbP , cbw ) ;
            }
                ether.delF( tinP , psttMapped ) ;
                ether.fileOpenF( tinP , handle , flagsResult , psttMapped , ifcOPENaCCESS_WR , 0 , flagsOpenDetails | flOPENdETAILS_FAIL | flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR , 0 , 0 , cOpenTries ) ;
                ether.diskMakeDirIfNeededF( tinP , psttMapped ) ;
                ZE( countT , flagsResult ) ;
                ether.diskMapFileNameF( tinP , psttMapped , psttAll ) ; ___( psttMapped ) ;
                ZE( strokeS* , psttMapped ) ;
            {
            if( !handle )
        {
        if( psttType && !psttType->idAdam )
    {
    else if( !psttHost->idAdam )
    }
        ether.delF( tinP , psttBody ) ;
        ether.delF( tinP , pstt1ToTo ) ;
        ether.delF( tinP , psttFrom ) ;

        verifyReplyF( tinP , 240 ) ;
        pSControl->writeF( tinP , (osTextT*)T(psttBody) ) ;

        verifyReplyF( tinP , 340 ) ;
        pSControl->writeF( tinP , (osTextT*)T("post\r\n") ) ;

        }
            ether.delF( tinP , psttBody2 ) ;
            ether.strFuseF( tinP , psttBody , T("\r\n.\r\n") ) ; ___( psttBody ) ;
            ether.strFuseF( tinP , psttBody , psttBody2 ) ; ___( psttBody ) ;
            ether.delF( tinP , psttBody1 ) ;
            ether.strReplaceF( tinP , psttBody2 , psttBody1 , T("\r\n.") , T("\r\n..") ) ; ___( psttBody2 ) ;
            ether.strMakeF( tinP , psttBody1 , T(pbP) ) ; ___( psttBody1 ) ;
            ZE( strokeS* , psttBody2 ) ;
            ZE( strokeS* , psttBody1 ) ;

            ether.strFuseF( tinP , psttBody , T("\r\n") ) ; ___( psttBody ) ;
            }
                if( idf ) { ether.strSubstringF( tinP , psttTo , idf , sttq , S1C('/') , psttName ) ; ___( psttTo ) ; }
                ether.delF( tinP , psttTo ) ;
                else __1
                }
                    ether.strFuseSeparateF( tinP , pstt1ToTo , psttTo , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 0x100000 ) ; ___( pstt1ToTo ) ;

                    ether.strFuseF( tinP , psttBody , psttTo ) ; ___( psttBody ) ;
                    else ether.strFuseF( tinP , psttBody , T(",") ) ; ___( psttBody ) ;
                    }
                        ether.strFuseF( tinP , psttBody , T("Newsgroups"": ") ) ; ___( psttBody ) ;
                        fFirst = 0 ;
                    {
                    if( fFirst )
                {
                if( psttTo->idAdam )
            {
            while( psttTo )
            boolT fFirst = 1 ;
            ether.strSubstringF( tinP , psttTo , idf , sttq , S1C('/') , psttName ) ; ___( psttTo ) ;
            ZE( strokeS* , psttTo ) ;

            ether.strFuseF( tinP , psttBody , T("\r\n") ) ; ___( psttBody ) ;
            ether.strFuseF( tinP , psttBody , psttFrom ) ; ___( psttBody ) ;
            ether.strFuseF( tinP , psttBody , T("From: ") ) ; ___( psttBody ) ;
            ether.strSubstringF( tinP , psttFrom , idf , sttq , S1C('/') , psttName ) ; ___( psttFrom ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ether.strMakeF( tinP , psttBody , T("") , CSeXTRAnEWSbODY ) ; ___( psttBody ) ;
        {
        ZE( strokeS* , psttBody ) ;
        ZE( strokeS* , pstt1ToTo ) ;
        ZE( strokeS* , psttFrom ) ;
        __Z( pbP ) ;
    {
    else if( psttHost->idAdam && !ether.strCompareF( tinP , psttType , T("news") ) && pSControl )
    }
        ether.delF( tinP , psttFile ) ;
        ether.boxPutUniqueF( tinP , psttFile , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/email.to.send/soul.email") , WS( sOut ) ) ;
        ZE( strokeS* , psttFile ) ;

        }
            ether.boxPutF( tinP , tFileBody , pbP , cbP ) ;
            //LOGrAW( T("boxC::putF: writing file \"")+tFileBody+T("\"\r\n") ) ;
            sOut << (strokeS*)tFileBody ;
            }
                ether.delF( tinP , psttu ) ;
                tFileBody = T("///ideafarm/ephemeral/domains/com/ideafarm/ipdos/tmp/")+T(psttu) ;
                ether.strUniqueF( tinP , psttu ) ; ___( psttu ) ;
                ZE( strokeS* , psttu ) ;
            {
            TN( tFileBody , "" ) ;
        {
        else
        if( F(flagsP) & flBOXcpUTf_FILEnAME ) sOut << (strokeS*)pbP ; //CALLER MUST PASS IN A strokeS* DISGUISED AS byteT*

        }
            ether( tinP , pStk_psttBc ) ;
            ether( tinP , pStk_psttOldCc ) ;
            ether( tinP , pStk_psttTo ) ;
            }
                }
                    }
                        }
                            ether.delF( tinP , psttw ) ;
                            sOut << psttw ;
                            *ppzStk[ off ] >> psttw ;
                            ZE( strokeS* , psttw ) ;
                        {
                        while( *ppzStk[ off ] )
                        sOut << (countT)*ppzStk[ off ] ;
                    {
                    for( countT off = 0 ; off < 3 ; off ++ )
                    stackC* ppzStk[] = { pStk_psttTo , pStk_psttOldCc , pStk_psttBc } ;
                {
                ether.delF( tinP , psttEmailFrom ) ;
                sOut << psttEmailFrom ;
    
                }
                    }
                        }
                            }
                                if( !ids ) ether.delF( tinP , psttw ) ;
                                pzStk->sinkF( tinP , ids , psttw , flSTACKsINK_UNIQUE ) ;
                                ZE( countT , ids ) ;
                                CONoUTrAW( T("  : \"")+T(psttw)+T("\"\r\n") ) ; //U::
                            {
                            else
                            }
                                ether.delF( tinP , psttw ) ;

                                else { BLAMMO ; }
                                else if(  pzStk == pStk_psttBc ) pzStk = pStk_psttTo ;
                                else if(  pzStk == pStk_psttOldCc ) pzStk = pStk_psttBc ;
                                     if(  pzStk == pStk_psttTo ) pzStk = pStk_psttOldCc ;
                                CONoUTrAW( "---- cycling ----\r\n" ) ;
                            {
                            if( !psttw->idAdam )

                            ether.strSubstringF( tinP , psttw , idf , sttq , sttSlash , psttName ) ; ___( psttw ) ;
                            ZE( strokeS* , psttw ) ;
                        {
                        while( idf )
                        stackC* pzStk = pStk_psttTo ;
                    {
                {

                //LOGrAW( T("fr: \"")+T(psttEmailFrom)+T("\"\r\n") ) ; //U::
                ether.strSubstringF( tinP , psttEmailFrom , idf , sttq , sttSlash , psttName ) ; ___( psttEmailFrom ) ;
                //LOGrAW( T("boxC::putF/[psttName]: \"")+T(psttName)+T("\"\r\n") ) ; //U::
                strokeS sttSlash( '/' ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                countT idf = 1 ;
                ZE( strokeS* , psttEmailFrom ) ;
                //PARSE FROM TO CC BC FROM psttName
            {
            if( pStk_psttTo && pStk_psttOldCc && pStk_psttBc )
            ether( tinP , pStk_psttBc , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
            ether( tinP , pStk_psttOldCc , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
            ether( tinP , pStk_psttTo , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
            ZE( stackC* , pStk_psttBc ) ;
            ZE( stackC* , pStk_psttOldCc ) ;
            ZE( stackC* , pStk_psttTo ) ;

            sOut << idPort ;
            sOut << psttHost ;
        {
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
        __Z( pbP ) ;
    {
    else if( psttHost->idAdam && !ether.strCompareF( tinP , psttType , T("smtp") ) )
    }
        }
            __( cbFileAfter != cbw ) ;
            __( rc != 213 ) ; //19980130.1752: CHANGED FROM 211
            ether.delF( tinP , psttReply ) ;
            cbFileAfter = cbFileF( tinP , psttReply ) ;
            countT rc = pSControl->readWoReplyF( tinP , psttReply ) ; ___( psttReply ) ;
            ZE( strokeS* , psttReply ) ;
        {
        if( !POOP )
        ZE( sCountT , cbFileAfter ) ;

        { textC txt = T("stat ")+T(psttName)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }

        verifyReplyF( tinP , 226 ) ;
        }
            verifyReplyF( tinP , 150 ) ;
            sData.writeF( tinP , pbP , cbw ) ;
            sData.connectF( tinP , idPortData , nicNameData ) ;
            socketC sData( tinP , ether , TAG( TAGiDnULL ) ) ;
            __Z( pbP ) ;
        {

        { textC txt = T("stor ")+T(psttName)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }

        }
            __Z( idPortData ) ;
            __Z( nicNameData ) ;
            __( rc != 227 ) ;
            ether.delF( tinP , psttReply ) ;
            readNicNameIdPortF( tinP , nicNameData , idPortData , psttReply ) ;
            countT rc = pSControl->readWoReplyF( tinP , psttReply ) ; ___( psttReply ) ;
            ZE( strokeS* , psttReply ) ;
        {
        if( !POOP )
        ZE( countT , idPortData ) ;
        nicNameC nicNameData ;

        pSControl->writeF( tinP , (osTextT*)T("pasv\r\n") ) ;

        __Z( cbw ) ;

        //U:{ ZE( countT , tnu ) ; ether.osThreadF( tinP , tnu , tmBoxGetPutDeadmanF , 0 , flTHREADlAUNCH_null , 0 , (countT)&info ) ; }
        infoBoxGetPutS info( tinP , ether , *pSControl ) ;
    {
    else if( psttHost->idAdam && !ether.strCompareF( tinP , psttType , T("ftp") ) && pSControl )
    }
        __( postOk[ 0 ] != 'o' || postOk[ 1 ] != 'k' ) ;
        __( 2 - pSControl->readF( tinP , postOk , 2 ) ) ;
        osTextT postOk[ 3 ] = { 0 , 0 , 0 } ;
        pSControl->writeF( tinP , pbP , cbw ) ;
        pSControl->writeF( tinP , (byteT*)&cbw , sizeof cbw ) ;
        { textC txt = T(psttName)+T("\r\n") ; pSControl->writeF( tinP , (osTextT*)txt ) ; }
        __Z( pbP ) ;
    {
    if( !ether.strCompareF( tinP , psttType , T("box.sucker") ) && pSControl )
    // PUT THE BACKING FILE BYTES
    if( pbP && !cbw ) cbw = ether.strBodyLengthF( tinP , pbP ) ;
    countT cbw = cbP ;
    _INoLD_

    }
        if( POOP ) return ;
        FV( flBOXcpUTf , flagsP ) ;
        __Z( psttName ) ;
        __Z( psttType ) ;
        __Z( psttHost ) ;
        __( cbP && !pbP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
    SCOOP
{
/*1*/voidT boxC::putF( tinS& tinP , const byteT* const pbP , const countT cbP , const flagsT flagsP )/*1*/

/**/
*/
 flagsP
  the terminating null byte will -not- be written
  if 0 then the null terminated string of bytes at pbP will be written
  can be 0
 cbP
  if 0 the cbP must also be 0
  if 0 then a null length file will be created
  can be 0
 pbP
arguments
 these limits involve the use of etherC::strFuseSeparateF
for some box types, this function will fail due to hardcoded capacity limits
 /napkin/name: writes the bytes to a napkin
 /napkin.make/name: writes the bytes to a napkin
 /tap/name: writes the bytes to a tap
 /hose/name: writes the bytes to a hose
 //name: writes the bytes to a local file
    it will be appended for you
   do not end your message with the termination sequence
    such lines will be modified so that they are sent correctly
    this includes lines that contain only a period
   the message can contain any printable ascii characters
   the next line should be the first line of the message
   the next line should be ze length
  the specified bytes should begin with a Subject: line
   a Newsgroups: header line is prepended to the article body
  the next parts of the name is used to specify newsgroups
   a From: header line is prepended to the article body
  the first part of the name is used as the "From:" email address
 host/news: posts an item to one or more newsgroups
   each ze length name part toggles between To: and Cc :
   To: or Cc : header lines are prepended to the body
  the next parts of the name are used as To: and Cc : email addresses
   a From: header line is prepended to the body
  the first part of the name is used as the "From:" email address
    it will be appended for you
   do not end your message with the termination sequence
    such lines will be modified so that they are sent correctly
    this includes lines that contain only a period
   the message can contain any printable ascii characters
   the next line should be the first line of the body of the message
   the next line should be ze length
   the first line should begin with "Subject: ", followed by a short phrase
  the specified bytes should begin with a Subject: line
   example: bill@chevrolet.com
   example: 123@odeafarm.com
   format: foo@bar.com
  in this case, "from" should be a valid email address
  host is the value that follows "@" in the "to" and "cc" email addresses  (20190823@1435: nawwh)
  if "host" is specified then i do my work by connecting to "host" as an smtp client
 host//smtp/from/to1/to2/to3//cc1/cc2/cc3//bcc1/bcc2/bcc3: sends a mail item
 some of the following is obsolete; see the code
 //smtp/from/to1/to2/to3//cc1/cc2/cc3//bcc1/bcc2/bcc3: sends a mail item
 host//ftp:  uses "stor" to store the bytes
puts the bytes into the box
  \<A HREF=\"5.7120104.1.1.0.html\"\>7120104:  WAKEsHOW( "example.simplest.func.1090006.boxC.putF" )\</A\>
 simplest
examples
\<A HREF=\"5.1090006.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$putF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

