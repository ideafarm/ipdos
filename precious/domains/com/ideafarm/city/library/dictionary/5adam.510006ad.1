
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        sgnDone_tmTime.waitF( tinP ) ;

        etherC::loafIF( tinP ) ;

        pDisplay->st_idEye << (countT)1 ;        
        *pDisplay += eye ;
    {
    if( pDisplay )
    
    #endif
        surff += paper ;
        surfe += paper ;
        surfd += paper ;
        surfc += paper ;
        surfb += paper ;
        surfa += paper ;
        surf9 += paper ;
        surf8 += paper ;
        surf7 += paper ;
        surf6 += paper ;
        surf5 += paper ;
        surf4 += paper ;
        surf3 += paper ;
        surf2 += paper ;
        surf1 += paper ;
    #if defined( ALL )
    //surf0 += paper ;

    surfPane   += paperPane ;
    surfDirect += paperDirect ;

    #endif
        *pDisplay += surff ;
        *pDisplay += surfe ;
        *pDisplay += surfd ;
        *pDisplay += surfc ;
        *pDisplay += surfb ;
        *pDisplay += surfa ;
        *pDisplay += surf9 ;
        *pDisplay += surf8 ;
        *pDisplay += surf7 ;
        *pDisplay += surf6 ;
        *pDisplay += surf5 ;
        *pDisplay += surf4 ;
        *pDisplay += surf3 ;
        *pDisplay += surf2 ;
        *pDisplay += surf1 ;
    #if defined( ALL )
    *pDisplay += surf0 ;

    *pDisplay += surfPane ;
    *pDisplay += surfDirect ;
    
    #endif
        surfC surff( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_f_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surfe( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_e_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surfd( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_d_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surfc( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_c_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surfb( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_b_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surfa( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_a_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surf9( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_9_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surf8( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_8_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surf7( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_7_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surf6( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_6_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surf5( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_5_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surf4( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_4_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surf3( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_3_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surf2( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_2_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
        surfC surf1( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_1_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;
    #if defined( ALL )
    surfC surf0( tinP , etThread , SURFACEtHICKNESS_polynomial , surface_0_CBF , (countT)pcArg , spaceFromPaperPrologCBF , spaceFromPaperEpilogCBF ) ;

    etThread.osThreadF( TaRG2( tmTimeF , sgnDone_tmTime ) , (countT)&spa ) ;
    signC sgnDone_tmTime( tinP , TAG( TAGiDnULL ) ) ;

    surfC surfPane( tinP , etThread , 0 , surface_pane_CBF , (countT)&spa ) ;

    surfC surfDirect( tinP , etThread ) ;
    
    countT pcArg[] = { (countT)&mAngle , (countT)pDisplay } ;
    ZE( measureT , mAngle ) ;
    
    etThread.delF( tinP , psttSayPane ) ;
    paperPane.strokeF( tinP , psttSayPane ) ;
    paperC paperPane( tinP , etThread , TUCK , TUCK ) ;
    
    etThread.delF( tinP , psttSayDirect ) ;
    paperDirect.strokeF( tinP , psttSayDirect ) ;
    paperC paperDirect( tinP , etThread , *pDisplay ) ;
    
    etThread.delF( tinP , psttSay ) ;
    //paper.strokeF( tinP , psttSay ) ;
    //paperC paper( tinP , etThread , TUCK , TUCK ) ;

    pDisplay->pDeviceCBF = displayCBF ;
    pDisplay->cArg       = (countT)pcArgDevice ;
    displayC* pDisplay   = displayC::pDisplayIF() ;

    countT pcArgDevice[] = { 0/*idCycle*/ , 0/*bUp*/ , (countT)&spa , (countT)&eye } ;

    if( cDo && cDo -- ) eye.moveF( tinP , vDeltaAt , - PI / ( TUCK << 2 ) , - PI / ( TUCK << 2 ) , - PI / ( TUCK << 2 ) ) ;
    countT cDo = 0 ;

    eye.moveF( tinP , vDeltaAt , aBad , aBad , aBad ) ;
    vectorOldC vDeltaAt( tinP , etThread ) ;
    eyeC eye( tinP , etThread ) ;

    spa.ab = 0.0 ;
    spa.ae = 0.0 ;
    spa.ah = 0.0 ;

    spa.sz = 1.0 ;
    spa.sy = 1.0 ;
    spa.sx = 1.0 ;

    spa.oz = + (sCountT)TUCK ;
    spa.oy = 0 ;
    spa.ox = 0 ;

    //spa.cy = TUCK >> 1 ;
    //spa.cx = TUCK >> 1 ;
    spa.cy = 0 ;
    spa.cx = 0 ;

    surfPaneS spa ;
{

}
    #endif

        }
            }
                default : { BLAMMO ; }
                case 4 :  {              APPENDcc( psttSay , sc_ccLINEpEL , 0                                , - ( PELsTEPrOWS << 1 ) * idGlyph ) ; break ; }
                case 3 :  {              APPENDcc( psttSay , sc_ccLINEpEL , - ( PELsTEPcOLS << 1 ) * idGlyph , 0                                ) ; break ; }
                case 2 :  {              APPENDcc( psttSay , sc_ccLINEpEL , 0                                ,   ( PELsTEPrOWS << 1 ) * idGlyph ) ; break ; }
                case 1 :  {              APPENDcc( psttSay , sc_ccLINEpEL ,   ( PELsTEPcOLS << 1 ) * idGlyph , 0                                ) ; break ; }
                case 0 :  { idGlyph ++ ; APPENDcc( psttSay , sc_ccMOVEpEL , -   PELsTEPcOLS                  , -   PELsTEPrOWS                  ) ; break ; }
            {
            switch( offp % POINTSpERgLYPH ) )

            //}
            //    APPENDcc( psttSay , sc_cCOLOR , rgb , 0 ) ;
            //
            //    }
            //        case 2 : { rgb = 0xff0000 ; break ; }
            //        case 1 : { rgb = 0x00ff00 ; break ; }
            //        case 0 : { rgb = 0x0000ff ; break ; }
            //    {
            //    switch( ( offGroup ++ ) % 3 )
            //    ZE( countT , rgb ) ;
            //{
            //if( !( offp % POINTSpERgROUP ) )
        {
        for( countT offp = 0 ; offp < CpOINTS ; offp ++ )
        ZE( countT , offGroup ) ;
        ZE( countT , idGlyph ) ;

        APPENDmm( psttSay , sc_mmMOVEtO , 0.5 , 0.5 ) ;
        APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;

    #else

        APPENDmm( psttSay , sc_mmLINEtO , 0.0 , 0.0 ) ;
        APPENDmm( psttSay , sc_mmLINEtO , 0.0 , 1.0 ) ;
        //APPENDcc( psttSay , sc_POPdETACHaTTACH , 0 , 0 ) ;
        //APPENDcc( psttSay , sc_cCOLOR , ifcRGB_G4 , 0 ) ;
        APPENDmm( psttSay , sc_mmLINEtO , 1.0 , 1.0 ) ;
        APPENDmm( psttSay , sc_mmLINEtO , 1.0 , 0.0 ) ;
        APPENDmm( psttSay , sc_mmMOVEtO , 0.0 , 0.0 ) ;
        APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;
        APPENDcc( psttSay , sc_cCOLOR , ifcRGB_R4 , 0 ) ;

    #elif defined( NEVERdEFINED )

        APPENDmm( psttSay , sc_mmLINEtO , 1.0 , 1.0 ) ;
        APPENDmm( psttSay , sc_mmMOVEtO , 0.0 , 0.0 ) ;
        APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;
        APPENDcc( psttSay , sc_cCOLOR , ifcRGB_R4 , 0 ) ;

    #elif defined( NEVERdEFINED1 )

        APPENDmm( psttSay , sc_mmLINEtO , 0.5 , 0.5 ) ;
        APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;
        APPENDcc( psttSay , sc_cCOLOR , ifcRGB_G4 , 0 ) ;

    #elif defined( NEVERdEFINED2 )

        //APPENDcc( psttSay , sc_ccLINEpEL , 1 , 1 ) ;
        //APPENDcc( psttSay , sc_ccLINEpEL , 1 , 1 ) ;
        //APPENDcc( psttSay , sc_ccLINEpEL , 1 , 1 ) ;
        //APPENDcc( psttSay , sc_ccLINEpEL , 1 , 1 ) ;
        //APPENDcc( psttSay , sc_ccLINEpEL , 1 , 1 ) ;
        //APPENDcc( psttSay , sc_ccLINEpEL , 1 , 1 ) ;
        //APPENDcc( psttSay , sc_ccLINEpEL , 1 , 1 ) ;
        //APPENDcc( psttSay , sc_ccLINEpEL , 1 , 1 ) ;
        //APPENDcc( psttSay , sc_ccLINEpEL , 1 , 1 ) ;
        APPENDcc( psttSay , sc_ccLINEpEL , 8 , 8 ) ;
        APPENDcc( psttSay , sc_ccMOVEpEL , 0x10 , 0x10 ) ;
        APPENDmm( psttSay , sc_mmMOVEtO , 0.0 , 0.0 ) ;
        APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;

    #elif defined( NEVERdEFINED3 )

        APPENDcc( psttSay , sc_ccLINEpEL , TUCK , TUCK ) ;
        APPENDcc( psttSay , sc_ccMOVEpEL , 2 , 2 ) ;
        //APPENDmm( psttSay , sc_mmLINEtO , 0.5 , 0.5 ) ;
        APPENDmm( psttSay , sc_mmMOVEtO , 0.0 , 0.0 ) ;
        APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;

    #elif defined( NEVERdEFINED4 )

        APPENDmm( psttSay , sc_mmLINEtO , 0.6 , 0.6 ) ;
        APPENDmm( psttSay , sc_mmMOVEtO , 0.4 , 0.4 ) ;
        APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;
        APPENDcc( psttSay , sc_cCOLOR , ifcRGB_G4 , 0 ) ;

    #elif defined( NEVERdEFINED5 )

        APPENDcc( psttSay , sc_ccLINEpEL , TUCK , 0 ) ;
        APPENDcc( psttSay , sc_ccMOVEpEL , 0x80 , 0x80 ) ;
        APPENDmm( psttSay , sc_mmMOVEtO , 0.0 , 0.0 ) ;
        APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;

    #elif defined( NEVERdEFINED6 )

        while( cToDo -- ) { APPENDcc( psttSay , sc_ccLINEpEL , 0x10 , 0 ) ; }
        countT cToDo = TUCK >> 4 ;
        
        APPENDcc( psttSay , sc_ccMOVEpEL , - 0x80 , 0x10 ) ;
        APPENDmm( psttSay , sc_mmMOVEtO , 0.0 , 0.0 ) ;
        APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;

    #elif defined( NEVERdEFINED7 )

        APPENDcc( psttSay , sc_ccLINEpEL ,   0x10 , - 0x10 ) ;
        APPENDcc( psttSay , sc_ccLINEpEL ,   0x10 , 0 ) ;
        
        APPENDcc( psttSay , sc_ccMOVEpEL , - 0x10 , 0x10 ) ;
        APPENDmm( psttSay , sc_mmMOVEtO , 0.0 , 0.0 ) ;
        APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;

    #elif defined( NEVERdEFINED8 )

        while( cToDo -- ) { APPENDcc( psttSay , sc_ccLINEpEL , 2 , 0 ) ; }
        countT cToDo = CpOINTS ;
        
        APPENDcc( psttSay , sc_ccMOVEpEL , - (sCountT)CpOINTS , + (sCountT)TUCK ) ;
        APPENDmm( psttSay , sc_mmMOVEtO , 0.0 , 0.0 ) ;
        APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;

    #elif defined( NEVERdEFINED9 )

        APPENDcc( psttSay , sc_ccLINEpEL , 0 , 0 ) ;
        
        APPENDmm( psttSay , sc_mmMOVEtO , 0.0 , 0.0 ) ;
        APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;

    #elif defined( NEVERdEFINEDa )

        }
            APPENDmm( psttSay , sc_mmLINEtO , 0.0 , 0.0 ) ;
            APPENDmm( psttSay , sc_mmLINEtO , 0.0 , 1.0 ) ;
            APPENDmm( psttSay , sc_mmLINEtO , 1.0 , 1.0 ) ;
            APPENDmm( psttSay , sc_mmLINEtO , 1.0 , 0.0 ) ;
        {
        //while( cToDo -- )
        //countT cToDo = ( CpOINTS >> 2 ) - 1 ;

        APPENDmm( psttSay , sc_mmMOVEtO , 0.0 , 0.0 ) ;
        //APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;
        APPENDcc( psttSay , sc_cCOLOR , ifcRGB_G4 , 0 ) ;

    #elif defined( NEVERdEFINEDb )

        APPENDmm( psttSay , sc_mmLINEtO , 1.0 , 0.0 ) ;
        APPENDmm( psttSay , sc_mmLINEtO , 0.0 , 1.0 ) ;

    #elif defined( NEVERdEFINEDc )

        }
            APPENDcc( psttSay , sc_cSYMBOL1 , offo % 4 == 3 ? ' ' : 'O' , 0 ) ;
        {
        for( countT offo = 0 ; offo < CpOINTS ; offo ++ )

    #elif defined( NEVERdEFINEDd )

            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_B4 , 0 ) ;

            APPENDmm( psttSay , sc_mmLINEtO , 0.0 , 0.0 ) ;
            APPENDmm( psttSay , sc_mmLINEtO , 0.0 , 1.0 ) ;
            APPENDmm( psttSay , sc_mmLINEtO , 1.0 , 1.0 ) ;
            APPENDmm( psttSay , sc_mmLINEtO , 1.0 , 0.0 ) ;
            APPENDmm( psttSay , sc_mmMOVEtO , 0.0 , 0.0 ) ;
            APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_G4 , 0 ) ;

            APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_W1 , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , ' ' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , ' ' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , ' ' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , ' ' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cSYMBOL1 , 'O' , 0 ) ;
            APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_R4 , 0 ) ;

    #elif defined( NEVERdEFINEDe )



    #if !defined( NEVERdEFINEDf )

    etThread.strMakeF( tinP , psttSay , 0 , /*CpOINTS << 1*/TUCK ) ; ___( psttSay ) ; //MUST BE LARGE ENOUGH FOR CpOINTS MOVE AND LINE STROKES PLUS COLOR STROKES PLUS INTERMEDIARY MOVE STROKES
{
ZE( strokeS* , psttSay ) ;
//CONSTRUCT THE STROKE STRING THAT DEFINES WHAT IS DISPLAYED

}
    APPENDmm( psttSayDirect , sc_mmLINEtO , tg , ta ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , tf , ta ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , tf , t6 ) ;
    APPENDmm( psttSayDirect , sc_mmMOVEtO , tg , t6 ) ;

    APPENDmm( psttSayDirect , sc_mmLINEtO , t0 , ta ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , t1 , ta ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , t1 , t6 ) ;
    APPENDmm( psttSayDirect , sc_mmMOVEtO , t0 , t6 ) ;

    APPENDmm( psttSayDirect , sc_mmLINEtO , t7 , t6 ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , t7 , ta ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , t9 , ta ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , t9 , t6 ) ;
    APPENDmm( psttSayDirect , sc_mmMOVEtO , t7 , t6 ) ;

    APPENDmm( psttSayDirect , sc_mmLINEtO , tg , tc ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , te , tc ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , te , t4 ) ;
    APPENDmm( psttSayDirect , sc_mmMOVEtO , tg , t4 ) ;

    APPENDmm( psttSayDirect , sc_mmLINEtO , t0 , tc ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , t2 , tc ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , t2 , t4 ) ;
    APPENDmm( psttSayDirect , sc_mmMOVEtO , t0 , t4 ) ;

    APPENDmm( psttSayDirect , sc_mmLINEtO , t6 , t4 ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , t6 , tc ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , ta , tc ) ;
    APPENDmm( psttSayDirect , sc_mmLINEtO , ta , t4 ) ;
    APPENDmm( psttSayDirect , sc_mmMOVEtO , t6 , t4 ) ;

    APPENDmm( psttSayDirect , sc_mmLINEtO , tc , tg ) ;
    APPENDmm( psttSayDirect , sc_mmMOVEtO , tc , t0 ) ;

    APPENDmm( psttSayDirect , sc_mmLINEtO , t4 , tg ) ;
    APPENDmm( psttSayDirect , sc_mmMOVEtO , t4 , t0 ) ;

    APPENDmm( psttSayDirect , sc_mmLINEtO , tg , t8 ) ;
    APPENDmm( psttSayDirect , sc_mmMOVEtO , t0 , t8 ) ;

    APPENDmm( psttSayDirect , sc_mmLINEtO , t8 , tg ) ;
    APPENDmm( psttSayDirect , sc_mmMOVEtO , t8 , t0 ) ;

    APPENDcc( psttSayDirect , sc_cCOLOR   , ifcRGB_R1 , 0 ) ;
    APPENDcc( psttSayDirect , sc_PUSHdETACH , 0 , 0 ) ;
    APPENDcc( psttSayDirect , sc_cPUSHiDgRID , 3 , 0 ) ;

    etThread.strMakeF( tinP , psttSayDirect , 0 , TUCK ) ; ___( psttSayDirect ) ;

    const measureT tg = 16.0 / 16.0 ;
    const measureT tf = 15.0 / 16.0 ;
    const measureT te = 14.0 / 16.0 ;
    const measureT td = 13.0 / 16.0 ;
    const measureT tc = 12.0 / 16.0 ;
    const measureT tb = 11.0 / 16.0 ;
    const measureT ta = 10.0 / 16.0 ;
    const measureT t9 =  9.0 / 16.0 ;
    const measureT t8 =  8.0 / 16.0 ;
    const measureT t7 =  7.0 / 16.0 ;
    const measureT t6 =  6.0 / 16.0 ;
    const measureT t5 =  5.0 / 16.0 ;
    const measureT t4 =  4.0 / 16.0 ;
    const measureT t3 =  3.0 / 16.0 ;
    const measureT t2 =  2.0 / 16.0 ;
    const measureT t1 =  1.0 / 16.0 ;
    const measureT t0 =  0.0 / 16.0 ;
{
ZE( strokeS* , psttSayDirect ) ;

}
    //APPENDmm( psttSayPane , sc_mmLINEtO , 1.0 , 0.9 ) ;
    //APPENDcc( psttSayPane , sc_cCOLOR   , ifcRGB_P4 , 0 ) ;
    //APPENDmm( psttSayPane , sc_mmMOVEtO , 0.0 , 0.9 ) ;
    
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 0.0 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 1.0 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 1.0 , 1.0 ) ;

    APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 0.0 ) ;
    APPENDcc( psttSayPane , sc_cCOLOR   , ifcRGB_Y4 , 0 ) ;
    APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 1.0 ) ;
    APPENDcc( psttSayPane , sc_cCOLOR   , ifcRGB_B4 , 0 ) ;
    APPENDmm( psttSayPane , sc_mmLINEtO , 1.0 , 1.0 ) ;
    APPENDcc( psttSayPane , sc_cCOLOR   , ifcRGB_G4 , 0 ) ;
    APPENDmm( psttSayPane , sc_mmLINEtO , 1.0 , 0.0 ) ;
    APPENDcc( psttSayPane , sc_cCOLOR   , ifcRGB_R4 , 0 ) ;
    APPENDmm( psttSayPane , sc_mmMOVEtO , 0.0 , 0.0 ) ;

    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 0.0 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 1.0 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 1.0 , 1.0 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 1.0 , 0.0 ) ;
    //APPENDmm( psttSayPane , sc_mmMOVEtO , 0.0 , 0.0 ) ;

    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 1.0 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.5 , 0.0 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 1.0 , 1.0 ) ;
    //APPENDmm( psttSayPane , sc_mmMOVEtO , 0.0 , 1.0 ) ;

    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.25 , 0.25 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.50 , 0.75 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.75 , 0.25 ) ;
    //APPENDmm( psttSayPane , sc_mmMOVEtO , 0.25 , 0.25 ) ;

    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 0.0 ) ;
    //APPENDcc( psttSayPane , sc_cCOLOR   , ifcRGB_R4 , 0 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 0.2 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 0.4 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.2 , 0.4 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.2 , 0.5 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 0.6 ) ;
    //APPENDcc( psttSayPane , sc_cCOLOR   , ifcRGB_C4 , 0 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 0.8 ) ;
    //APPENDcc( psttSayPane , sc_cCOLOR   , ifcRGB_Y4 , 0 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 0.0 , 1.0 ) ;
    //APPENDcc( psttSayPane , sc_cCOLOR   , ifcRGB_B4 , 0 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 1.0 , 1.0 ) ;
    //APPENDcc( psttSayPane , sc_cCOLOR   , ifcRGB_G4 , 0 ) ;
    //APPENDmm( psttSayPane , sc_mmLINEtO , 1.0 , 0.0 ) ;
    //APPENDcc( psttSayPane , sc_cCOLOR   , ifcRGB_R4 , 0 ) ;
    //APPENDmm( psttSayPane , sc_mmMOVEtO , 0.0 , 0.0 ) ;

    APPENDcc( psttSayPane , sc_PUSHdETACH , 0 , 0 ) ;
    APPENDcc( psttSayPane , sc_cPUSHiDgRID , 3 , 0 ) ;

    etThread.strMakeF( tinP , psttSayPane , 0 , TUCK ) ; ___( psttSayPane ) ;
{
ZE( strokeS* , psttSayPane ) ;

}
    aBad = 0 ;
    //aBad = PI * 5.0 / 4.0 ;
    aBad = etThread.strDigitsToMeasureF( tinP , tStr , 0 , 0 ) ;
    TN( tStr , "100+^0f56b4." ) ;
{
ZE( measureT , aBad ) ;

TODO

DONE( tmTimeF )
}
    }

        ++ s ; ether.osSleepF( tinP , TOCK >> 5 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    while( !ether )

    countT* pcPaneArgP = (countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmTimeF )

}
    //angleP -= delta ;
    //delta +=  (measureT)PI / (measureT)( TUCK << 2 ) ;
    //static measureT delta ;

    //angleP -= (measureT)PI / (measureT)( TUCK >> 1 ) ;
    
    measureT& angleP = *(measureT*)((countT*)cArgP)[ 0 ] ;
{
voidT spaceFromPaperPrologCBF( tinS& tinP , const countT cArgP )

}
    //rgbOverrideP = ( heat << shift ) | rgbP ;
    
    }
        }
            heat ++ ;

            if( shift == 0x18 ) shift = 0 ;
            shift += 8 ;
        {
        else
        if( bDown ) heat -- ;

        bDown = !bDown ;
    {
    if( !heat )
    heat ++ ;

    static boolT  bDown ;
    static countT shift ;
    static byteT heat ;
{
voidT _export spaceFromPaperEpilogCBF( tinS& tinP , countT& rgbOverrideP , const countT rgbP , const countT cArgP )

SURFACE( f )
SURFACE( e )
SURFACE( d )
SURFACE( c )
SURFACE( b )
SURFACE( a )
SURFACE( 9 )
SURFACE( 8 )
SURFACE( 7 )
SURFACE( 6 )
SURFACE( 5 )
SURFACE( 4 )
SURFACE( 3 )
SURFACE( 2 )
SURFACE( 1 )
SURFACE( 0 )

    }
        toP.y += displayP.cRowF() >> 1 ;                                                                                                                    \
        toP.x += displayP.cColF() >> 1 ;                                                                                                                    \
                                                                                                                                                            \
        toP.y = radius * tinP.brcm04Raw ;                                                                                                                   \
        BOSmEASURE04( WHATgbo , sin( aHeading2 ) )                                                                                                          \
        toP.x = radius * tinP.brcm04Raw ;                                                                                                                   \
        BOSmEASURE04( WHATgbo , cos( aHeading2 ) )                                                                                                          \
                                                                                                                                                            \
        measureT  aHeading2 = aHeading1 + angleP ;                                                                                                          \
        measureT  radius    = hypot( toP.x , toP.y ) ; /*WATCOM LIBRARY FUNCTION THAT IS EQUIVALENT TO sqrt( toP.x * toP.x + toP.y * toP.y )*/              \
        measureT  aHeading1 = atan2( toP.y , toP.x ) ;                                                                                                      \
        measureT& angleP    = *(measureT*)((countT*)cArgP)[ 0 ] ;                                                                                           \
                                                                                                                                                            \
        toP.y -= displayP.cRowF() >> 1 ;                                                                                                                    \
        toP.x -= displayP.cColF() >> 1 ;                                                                                                                    \
                                                                                                                                                            \
        displayC& displayP = *(displayC*)((countT*)cArgP)[ 1 ] ;                                                                                            \
                                                                                                                                                            \
        toP.z = TUCK * ( 1 + 0x##idP ) ;                                                                                                                    \
        toP.y = fromP.y << 1 ;                                                                                                                              \
        toP.x = fromP.x << 1 ;                                                                                                                              \
                                                                                                                                                            \
        TINSL                                                                                                                                               \
    {                                                                                                                                                       \
    voidT surface_##idP##_CBF( mPoint3S& toP , const cPoint2S& fromP , const countT cArgP )                                                                 \
                                                                                                                                                            \
#define SURFACE(idP)                                                                                                                                        \

#define SURFACEtHICKNESS_polynomial ((measureT)1e1)

}
    toP.z += spaP.oz ;
    toP.y += spaP.oy ;
    toP.x += spaP.ox ;
    // SHIFTING

    toP.z *= spaP.sz ;
    toP.y *= spaP.sy ;
    toP.x *= spaP.sx ;
    // SCALING

    }
        toP.z = - mx * tinP.brcm04Raw + mz * m1 ;
        toP.x =   mx * m1 + mz * tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , sin( spaP.ah ) )
        measure04T m1 = tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , cos( spaP.ah ) )

        measureT mz = toP.z ;
        measureT mx = toP.x ;
    {
    // HEADING

    }
        toP.z =   my * tinP.brcm04Raw + mz * m1 ;
        toP.y =   my * m1 - mz * tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , sin( - spaP.ae ) )
        measure04T m1 = tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , cos( - spaP.ae ) )

        measureT mz = toP.z ;
        measureT my = toP.y ;
    {
    // ELEVATION

    }
        toP.z = 0.0 ;
        toP.y = - rx * tinP.brcm04Raw + ry * m1 ;
        toP.x =   rx * m1 + ry * tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , sin( spaP.ab ) )
        measure04T m1 = tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , cos( spaP.ab ) )
    {
    // BANK

    measureT ry = (sCountT)( fromP.y - spaP.cy ) ;
    measureT rx = (sCountT)( fromP.x - spaP.cx ) ;

    surfPaneS& spaP = *(surfPaneS*)cArgP ;

    TINSL
{
voidT surface_pane_CBF( mPoint3S& toP , const cPoint2S& fromP , const countT cArgP )

}
    return 0 ;

    }
        }
            break ;

            }
                //USE FOR TESTING: *(measureT*)&processGlobal1S::_processGlobal1I_IF().pc Utility[ 3 ] = saP.oz ;

                //}
                //    }
                //        saP.oz += TUCK >> 4 ;
                //        bUpP = !bUpP ;
                //    {
                //    if( saP.oz < - (sCountT)( TUCK << 3 ) )
                //    saP.oz -= TUCK >> 4 ;
                //{
                //else
                //}
                //    }
                //        saP.oz -= TUCK >> 4 ;
                //        bUpP = !bUpP ;
                //    {
                //    if( (sCountT)( TUCK << 3 ) < saP.oz )
                //    saP.oz += TUCK >> 4 ;
                //{
                //if( bUpP )

                //}
                //    }
                //        saP.oz = 1 ;
                //        bUpP = !bUpP ;
                //    {
                //    if( !saP.oz )
                //    saP.oz >>= 1 ;
                //{
                //else
                //}
                //    }
                //        saP.oz >>= 1 ;
                //        bUpP = !bUpP ;
                //    {
                //    if( saP.oz > ( TUCK << 6 ) )
                //    saP.oz <<= 1 ;
                //{
                //if( bUpP )

                //*(measureT*)&processGlobal1S::_processGlobal1I_IF().pc Utility[ 2 ] = saP.ab += PI / ( TUCK >> 1 ) ;
                //*(measureT*)&processGlobal1S::_processGlobal1I_IF().pc Utility[ 1 ] = saP.ae += PI / ( TUCK >> 1 ) ;
                //*(measureT*)&processGlobal1S::_processGlobal1I_IF().pc Utility[ 0 ] = saP.ah += PI / ( TUCK >> 1 ) ;

                //eyeP.moveF( tinP , vDeltaAt , PI / ( TUCK << exp ) , PI / ( TUCK << exp ) , PI / ( TUCK << exp ) ) ;
                countT exp = !!bStep << 1 ;

                //vDeltaAt( 3 ) = 1.0 ;
                //vDeltaAt( 2 ) = 1.0 ;
                //vDeltaAt( 1 ) = 1.0 ;
                vectorOldC vDeltaAt( tinP , *tinP.pEther ) ;
            {
            if( !bStep || !( ++ idCycleP % ( TUCK >> ( 2 + ( bFast << 1 ) ) ) ) )

            eyeC&      eyeP         =      *(eyeC*)pcArgDeviceP[ 3 ] ;
            surfPaneS& saP          = *(surfPaneS*)pcArgDeviceP[ 2 ] ;
            boolT&     bUpP         =    *(boolT*)&pcArgDeviceP[ 1 ] ;
            countT&    idCycleP     =   *(countT*)&pcArgDeviceP[ 0 ] ;
            countT*    pcArgDeviceP = (countT*)cArgP ;
        {
        case ifcIDeVENTdEVICEc_NAPPING :
    {
    switch( idEventP )
{
countT displayCBF( tinS& tinP , deviceC& deviceP , const countT idEventP , const countT cArgP )

boolT bStep = 0 ;
boolT bFast = 1 ;

;
}
    measureT ab ; //"a":"angle" ; "b":"bank"
    measureT ae ; //"a":"angle" ; "e":"elevation"
    measureT ah ; //"a":"angle" ; "h":"heading"

    measureT sz ;
    measureT sy ;
    measureT sx ; //"s":"scale"

    sCountT oz ;
    sCountT oy ;
    sCountT ox ; //"o":"origin"

    countT cy ;
    countT cx ; //"c":"center" 
{
struct surfPaneS

//G:#define CpOINTS ( ( TUCK >> 3 ) + ( TUCK >> 4 ) )
//#define CpOINTS 0x12
//#define CpOINTS ( POINTSpERgROUP * 1 )

//#define POINTSpERgROUP ( ( POINTSpERgLYPH << 0 ) )
//#define POINTSpERgLYPH 5

//#define PELsTEPrOWS 8
//#define PELsTEPcOLS 8

//#define ALL

/*1*/WAKEsHOW( "playcraft.paperC.spaceC.pelC.windowC" )/*1*/

//20140915@1840: MOVED FROM SCRATCH 3 TO PERMANENT ADAM ID

/**/
*/
 loading final points array [time/CtRIBULATIONS]: 2
 rendering [time/CtRIBULATIONS]: 452
output
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

