
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

ether.loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    etThread.osThreadF( TaRG1( tmWorkerF ) , (countT)ptRoot[ offt ] , (countT)pcArgInner ) ;
{
for( countT offt = 0 ; offt < sizeof ptRoot / sizeof ptRoot[ 0 ] ; offt ++ )

textC* ptRoot[] = { /*&tRootE ,*/ &tRootG /*&tRootW , &tRootX , &tRootY , &tRootZ*/ } ;

//TN( tRootZ , "///z/archive/" ) ;
//TN( tRootY , "///y/archive/" ) ;
//TN( tRootX , "///x/archive/" ) ;
//TN( tRootW , "///w/archive/1999/" ) ;
//TN( tRootE , "///e/archive/" ) ;
TN( tRootG , "///g/archive/" ) ;

countT pcArgInner[] = { (countT)&etThread , (countT)&tPatternOld , (countT)&sttq } ;

strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

;

    +S2(sa_SSSaNDeND,sc_ccSSS)

        +T(".")
        // TERMINATOR

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +T(".")
        // SEQUENCE NUMBER

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +T(".")
        // SEQUENCE NUMBER

        +S2(sa_SSSoReND,sc_ccSSS)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("012xz")
        +S2(sa_SSSoR,sc_ccSSS)
        +T("@")
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(7,sc_ccSSSrEPEAT,7)
        +T(".")
        // DATETIME

        +S2(sa_SSSoReND,sc_ccSSS)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("012xz")
        +S2(sa_SSSoR,sc_ccSSS)
        +T("@")
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(7,sc_ccSSSrEPEAT,7)
        +T(".")
        // DATETIME

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(7,sc_ccSSSrEPEAT,7)
        +T(".")
        // IDoWNER

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(7,sc_ccSSSrEPEAT,7)
        +T(".")
        // IDoWNER

        +T("/!ideafarm.8.2")
        // CONSTANT

    +S2(sa_SSSaND,sc_ccSSS)
    T("")

TN( tPatternOld , "" ) ; tPatternOld =

// KEEP: ---------------------------------------------------------------------------------    ----------------------------------------------------------------------->
//  OLD: ///z/archive/1999/!ideafarm.8.2.00000000.00000001.19990903@1308.20150910@0202.001.001.7d84358e991c2d16afaa9d1acb468f55.00000001.meta.currentname
//       123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
//       0              1               2               3               4               5               6               7               8               9               a

// KEEP: -------------------------------------------------------------------------------------------    ----------------------------------------------------------------------->
//  OLD: ////factory9/z/archive/1999/!ideafarm.8.2.00000000.00000001.19990903@1308.20150910@0202.001.001.7d84358e991c2d16afaa9d1acb468f55.00000001.meta.currentname
//       123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
//       0              1               2               3               4               5               6               7               8               9               a

TODO

DONE( tmWorkerF )
}
    etThread.traceF( tinP , T("root ---- [cFiles,cDirs]:    ")+*ptRootP+tb4+TF2(cFiles,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(cDirs,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
    etThread.diskWalkF( tinP , cDirs , cFiles , *ptRootP , countTC() , cleanCBF , pcArgInnerP , 0 , 0 ) ;
    etThread.traceF( tinP , T("root ++++               :    ")+*ptRootP ) ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs ) ;

    TN( tb4 , "    " ) ;
    countT* pcArgInnerP = (countT*)pTaskP->c2 ;
    textC*  ptRootP     =  (textC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )


}
    return 0 ;

    }
        }
            }
                DELzOMBIE( pFwsNew ) ;
                DELzOMBIE( pFwsOld ) ;

                }
                    }
                        //}
                        //    etherP.traceF( tinP , T("could not rename") ) ;
                        //    POOPR
                        //{
                        //else
                        //if( !POOP ) etherP.traceF( tinP , T("renamed aok") ) ;
                        //tinP.pEtScratch->disk Move File Or Dir F( tinP , tNameNew , tNameOld , 1 ) ;

                        etherP.traceF( tinP , T("content is the same ; attempting to delete old (not really)") ) ;

                        DELzOMBIE( pFwsNew ) ;
                        DELzOMBIE( pFwsOld ) ;
                    {
                    if( bSame && !bQuitP )

                    }
                        }
                            }
                                etherP.traceF( tinP , T("different content [idWindow]:    ")+TF2(idWindow,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                bSame = 0 ;
                            {
                            else if( etherP.memCompareF( tinP , pbwOld , pbwNew , cbwOld ) )
                            else if( !pbwOld || !cbwOld ) break ;
                            }
                                etherP.traceF( tinP , T("different sizes (unexpected) [idWindow]:    ")+TF2(idWindow,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                bSame = 0 ;
                            {
                            if( cbwOld != cbwNew )

                            pFwsNew->getF( tinP , pbwNew , cbwNew ) ;
                            ZE( countT , cbwNew ) ;
                            ZE( byteT* , pbwNew ) ;

                            pFwsOld->getF( tinP , pbwOld , cbwOld ) ;
                            ZE( countT , cbwOld ) ;
                            ZE( byteT* , pbwOld ) ;

                            idWindow ++ ;
                        {
                        while( !bQuitP )
                        ZE( countT , idWindow ) ;
                    {
                    boolT bSame = 1 ;
                {
                else
                else if( pFwsOld->cbFileLoF() != pFwsNew->cbFileLoF() || pFwsOld->cbFileHiF() != pFwsNew->cbFileHiF() ) etherP.traceF( tinP , T("different sizes") ) ;
                }
                    }
                        etherP.traceF( tinP , T("could not rename") ) ;
                        POOPR
                    {
                    else
                    if( !POOP ) etherP.traceF( tinP , T("renamed aok") ) ;
                    tinP.pEtScratch->diskMoveFileOrDirF( tinP , tNameNew , tNameOld , 1 ) ;

                    etherP.traceF( tinP , T("could not ct both file windows ; attempting to rename") ) ;

                    DELzOMBIE( pFwsNew ) ;
                    DELzOMBIE( pFwsOld ) ;
                    POOPR ;
                {
                if( POOP )

                fileWindowsC* pFwsNew = new( 0 , tinP , pb_fwsNew , sizeof pb_fwsNew ) fileWindowsC( tinP , *tinP.pEtScratch , tNameNew , flFILEwINDOW_null , 1 ) ;
                fileWindowsC* pFwsOld = new( 0 , tinP , pb_fwsOld , sizeof pb_fwsOld ) fileWindowsC( tinP , *tinP.pEtScratch , tNameOld , flFILEwINDOW_null , 1 ) ;

                byteT pb_fwsNew[ sizeof( fileWindowsC ) ] ;
                byteT pb_fwsOld[ sizeof( fileWindowsC ) ] ;

                SCOOPS
            {
            IFsCRATCH

            etherP.traceF( tinP , T("new: ")+tNameNew ) ;

            }
                etherP.delF( tinP , psttSnip2 ) ;
                etherP.delF( tinP , psttSnip1 ) ;
                tNameNew = T(psttSnip1) ;
                etherP.strFuseF( tinP , psttSnip1 , psttSnip2 ) ;
                etherP.strSubstringF( tinP , psttSnip2 , idf , idl , tNameOld ) ; ___( psttSnip2 ) ;
                idl = 0 ;
                idf = 0x56 ;
                ZE( strokeS* , psttSnip2 ) ;

                etherP.strSubstringF( tinP , psttSnip1 , idf , idl , tNameOld , tNameOld.csF( tinP ) ) ; ___( psttSnip1 ) ;
                countT idl = 0x51 ;
                countT idf = 1 ;
                ZE( strokeS* , psttSnip1 ) ;
            {
            TN( tNameNew , "" ) ;

            etherP.traceF( tinP , T("old: ")+tNameOld ) ;
            etherP.traceF( tinP , T("------------------------------------------------------------------") ) ;
        {
        if( idHit == 0x12 )
        //etherP.traceF( tinP , T("[idHit,name:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tNameOld ) ;

        countT idHit = etherP.strIdF( tinP, idf , sttqP , tPatternOldP , tNameOld ) ;
        countT idf = 1 ;

        TN( tNameOld , ifName ) ;
        ifFileNameC ifName( tinP , etherP , postNameP ) ;

        strokeS sttqP        = *(strokeS*)pcArgP[ 2 ] ;
        textC&  tPatternOldP =   *(textC*)pcArgP[ 1 ] ;
        etherC& etherP       =  *(etherC*)pcArgP[ 0 ] ;
    {
    if( postNameP )
{
boolT cleanCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )



// NEW: ////factory9/z/archive/1999/!ideafarm.8.2.00000000.00000001.19990903@1308.20150910@0202.001.7d84358e991c2d16afaa9d1acb468f55.00000001.meta.currentname
// OLD: ////factory9/z/archive/1999/!ideafarm.8.2.00000000.00000001.19990903@1308.20150910@0202.001.001.7d84358e991c2d16afaa9d1acb468f55.00000001.meta.currentname


/*1*/WAKEsHOWtEXT( "tool.clean.archive.file.names" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
