
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return *this ;
    cSessions += ((datumSessionC*)&plateP)->cSessions ;

    ether.osTimeAddF( tinP , timeLived1 , timeLived2 , datum.timeLived1 , datum.timeLived2 ) ;

    }
        else { ether.strMakeF( tinP , LF , psttPeer , datum.psttPeer ) ; ___( psttPeer ) ; }
        }
            }
                ether.delF( tinP , psttd ) ;
                ether.strMakeF( tinP , LF , psttPeer , T(psttd)+T(" , ")+T(datum.psttPeer) ) ; ___( psttPeer ) ;
                strokeS* psttd = psttPeer ; psttPeer = 0 ;
            {
            if( ether.strCompareF( tinP , psttPeer , datum.psttPeer ) )
        {
        if( psttPeer )
    {
    if( datum.psttPeer )

    if( !nnPeer ) nnPeer = datum.nnPeer ;
    const datumSessionC& datum = *(datumSessionC*)&plateP ;
    TINSL
{
plateC& datumSessionC::operator +=( plateC& plateP )

}
    return psttRpt ;

    ) ;

        +T(psttPeer)
        +tb+TF3(cSessions,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)
        +tb+TT4(timeLived1,timeLived2,3,5)
        TF3(nnPeer.pcId[0],flFORMAT_NObIGITvALUES|flFORMAT_FILLzE|flFORMAT_UNSIGNED,8)

    ether.strMakeF( tinP , LF , psttRpt ,
    TN( tb , " " ) ;

    ether.delF( tinP , psttRpt ) ; //U::RECALC ONLY IF STALE
    TINSL
{
datumSessionC::operator const strokeS*( voidT )

}
    if( idFormat >= 5 ) soulP >> idSlideLath ;

    if( idFormat >= 5 ) soulP >> idAdLath ;

    if( idFormat >= 4 ) soulP >> cTouch ;

    ether.osTimeSubtractF( tinP , timeLived1 , timeLived2 , timeCt1 , timeCt2 ) ;
    timeLived2 = timeLathTouch2 ;
    timeLived1 = timeLathTouch1 ;

    soulP >> *(countT*)&timeLathTouch2 ;

    soulP >> timeLathTouch1 ;

    if( idFormat >= 6 ) soulP >> psttUser ;

    soulP >> psttPeer ;

    nnPeer << soulP ;

    soulP >> *(countT*)&timeCt2 ;

    soulP >> timeCt1 ;

    __Z( idSession ) ;
    soulP >> idSession ;

    if( idFormat >= 3 ) soulP >> idAdam ;

    }
        __1 ;
        __( idFormat ) ;
    {
    if( idFormat < 2 )
    soulP >> idFormat ;
    ZE( countT , idFormat ) ;

    __( finger - FINGERnEG_SESSIONcsOUL ) ;
    soulP >> finger ;
    ZE( countT , finger ) ;
{
idSlideLath( 0 )
idAdLath( 0 ) ,
cTouch( 0 ) ,
psttUser( 0 ) ,
cSessions( 1 ) ,
timeLived2( 0 ) ,
timeLived1( 0 ) ,
timeLathTouch2( 0 ) ,
timeLathTouch1( 0 ) ,
psttRpt( 0 ) ,
psttPeer( 0 ) ,
timeCt2( 0 ) ,
timeCt1( 0 ) ,
idSession( 0 ) ,
idAdam( 0 ) ,
ether( etherP ) ,
datumSessionC::datumSessionC( tinS& tinP , etherC& etherP , soulC& soulP ) :

}
{
idSlideLath( 0 )
idAdLath( 0 ) ,
cTouch( 0 ) ,
psttUser( 0 ) ,
cSessions( 0 ) ,
timeLived2( 0 ) ,
timeLived1( 0 ) ,
timeLathTouch2( 0 ) ,
timeLathTouch1( 0 ) ,
psttRpt( 0 ) ,
psttPeer( 0 ) ,
timeCt2( 0 ) ,
timeCt1( 0 ) ,
idSession( 0 ) ,
ether( *tinP.pEther ) ,
datumSessionC::datumSessionC( tinS& tinP ) :

}
    return scSgn ;
    if( bReverse ) scSgn = - scSgn ;
    if( !scSgn ) scSgn = nnPeer.pcId[ 0 ] - (*(datumSessionC*)&plateP).nnPeer.pcId[ 0 ] ;
    if( !scSgn ) scSgn = nnPeer.pcId[ 1 ] - (*(datumSessionC*)&plateP).nnPeer.pcId[ 1 ] ;
    if( !scSgn ) scSgn = nnPeer.pcId[ 2 ] - (*(datumSessionC*)&plateP).nnPeer.pcId[ 2 ] ;
    sCountT      scSgn = nnPeer.pcId[ 3 ] - (*(datumSessionC*)&plateP).nnPeer.pcId[ 3 ] ; //WILL GIVE NONSENSE RESULTS IF WO VALUE IS 0
    TINSL
{
sCountT datumSessionC::operator -( const plateC& plateP ) const

}
    return *this ;

    if( datum.psttRpt ) { ether.strMakeF( tinP , LF , psttRpt , datum.psttRpt ) ; ___( psttRpt ) ; }
    ether.delF( tinP , psttRpt ) ;

    if( datum.psttPeer ) { ether.strMakeF( tinP , LF , psttPeer , datum.psttPeer ) ; ___( psttPeer ) ; }
    ether.delF( tinP , psttPeer ) ;

    nnPeer          = datum.nnPeer ;
    timeLived2      = datum.timeLived2 ;
    timeLived1      = datum.timeLived1 ;
    timeLathTouch2  = datum.timeLathTouch2 ;
    timeLathTouch1  = datum.timeLathTouch1 ;
    timeCt2         = datum.timeCt2 ;
    timeCt1         = datum.timeCt1 ;
    idSession       = datum.idSession ;

    datumSessionC& datum = *(datumSessionC*)&plateP ;
    TINSL
{
plateC& datumSessionC::operator =( plateC& plateP )

}
    ether.delF( tinP , psttRpt ) ;
    ether.delF( tinP , psttPeer ) ;
    ether.delF( tinP , psttUser ) ;
    TINSL
{
datumSessionC::~datumSessionC( voidT )

}
    return *this ;
{
plateC& datumSessionC::operator >>( soulC& sP )

}
    return new( 0 , tinP , idLineP , idiFileP ) datumSessionC( tinP ) ;
{
datumSessionC* datumSessionC::newF( tinS& tinP , const countT idLineP , const countT idiFileP , po olC& poolOldSetOldP )

NEWdELcLASS( 1 , datumSessionC )

}
    bReverse = bReverseP ;
{
voidT datumSessionC::setModeF( const boolT bReverseP )

boolT datumSessionC::bReverse ;

#include postADAMhEADER

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

