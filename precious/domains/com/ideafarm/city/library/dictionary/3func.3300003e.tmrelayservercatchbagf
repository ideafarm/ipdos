
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmRelayServerCatchBagF )
}
    }
        if( !bSaidBye && !ether && !bQuitP ) ;
        //CONoUTrAW3( "tmCatchBagF " , idCatch , ": thread ending\r\n" ) ; //U::
    
        if( POOP ) { BLAMMO ; } //U:: TO FIND A BUG

        }
            etThread( tinP , psBag ) ;
    
            }
                relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                idptPopClient >> *psBag ;
                relayC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flRELAYpOP_DOWN , ifcIDtYPEbAG_CLIENTpOPgOSSIP ) ;
            {
            if( bPop )
    
            UNGRABrELAYlISTS
            }
                else bPop = 1 ;
                }
                    relayC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                    stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptPopClient , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
                {
                if( pnRoot && *pnRoot == idptP )
                //P: SERVER WILL GOSSIP IF A POP CLIENT IMPLODING DOWNWARD TO IT DIED WITHOUT SAYING GOODBYE
            {
            if( idptPopClient && !bSaidBye && !bQuitP && idWork == IDtYPErELAYpOPcLIENTwORK_IMPLODE ) //THIS CODE WILL NEVER GOSSIP ABOUT THE ROOT
            idPortTimeC* pnRoot = stIdptOpenP ? (idPortTimeC*)&stIdptOpenP[ 1 ] : 0 ;
            GRABrELAYlISTS
            ZE( boolT , bPop ) ;
        {
        if( psBag )
        etThread( tinP , psBag , TAG( TAGiDnULL ) ) ;
        ZE( soulC* , psBag ) ;
    
        }
            stIdptPopClientP.ungrabF( tinP ) ;
            if( stIdptPopClientP( (byteT*)&idptPopClient , subtractIdPortTimesF , - 1 ) ) stIdptPopClientP.extractF( 0 , tinP ) ;
            stIdptPopClientP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( bPopClient )
        TELL( "tmRelayServerCatchBagF: cleaning up" )
    
        }
            DEL( psoP ) ;
            stPsoServerP.ungrabF( tinP ) ;
            if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
            stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( psoP )
        TELL( "deleting socket" )
        //CONoUTrAW3( "tmCatchBagF " , idCatch , ": exited loop; deleting socket\r\n" ) ; //U::

        }
            }
                break ;
                }
                    DEL( psoP ) ;
                    stPsoServerP.ungrabF( tinP ) ;
                    if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
                    stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( psoP )
                etThread.traceF( tinP , tTraceFail ) ;
            {
            if( bFail )

            }
                }
                    }
                        }
                            tTraceFail = T("could not write sOk") ;
                            bFail = 1 ;
                            POOPRqUIET
                        {
                        if( POOP )
        
                        psoP->writeF( tinP , sOk ) ;
                        //P: SERVER NORMALLY REPLIES TO EACH COMMAND BY WRITING AN sOk
                        SCOOPS
                    {
                    IFsCRATCH
                    //etThread.traceF( tinP , T("writing sOk") ) ;
                    TELL( "writing ok" )
                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 1 writing ok\r\n" ) ; //U::
            
                    }
                        }
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 3 after doing\r\n" ) ; //U::
                            }
                                //etThread.traceF( tinP , T("called doWrapLocallyIfIF") ) ;
                                relayC::doWrapLocallyIfIF( tinP , etThread , RELAYiNFOaRGS , pbsWrap , idptOrigin /*U::, 2*/ ) ;  //U:: 20210209@2012: COMMENTED OUT ", 2" WITHOUT ANALYSIS TO GET DUT TO WORK
                            {
                            if( pbsWrap )
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 4 doing\r\n" ) ; //U::
                            //etThread.traceF( tinP , T("called popIF") ) ;

                            relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , sBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                            //etThread.traceF( tinP , T("calling popIF") ) ;
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 5 popping\r\n" ) ; //U::
            
                            }
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP\r\n" ) ; //U::
                                    TELL( "ifcIDtYPEbAG_WRAP-" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP done\r\n" ) ; //U::
                                    if( pbsWrap ) relayC::doWrapLocallyIfIF( tinP , etThread , RELAYiNFOaRGS , pbsWrap , idptOrigin , 1 ) ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP doing\r\n" ) ; //U::
        
                                    //if( pbsWrap ) { CONoUTrAW( "w" ) ; }
        
                                    }
                                        pbsWrap = sBag.pbFieldF( tinP , idTypesWrap , flagssWrap , cbsWrap , ifcIDfIELDbAG_WRAP ) ;
                                        ZE( countT , cbsWrap ) ;
                                        ZE( flagsT , flagssWrap ) ;
                                        ZE( countT , idTypesWrap ) ;
                                    {
        
                                    TELL( "ifcIDtYPEbAG_WRAP+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP\r\n" ) ; //U::
                                    //etThread.traceF( tinP , T("ifcIDtYPEbAG_WRAP") ) ;
                                {
                                case ifcIDtYPEbAG_WRAP :
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPpING\r\n" ) ; //U::
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPpING-" )
            
                                    }
                                        etThread( tinP , psBag ) ;
                                        relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                                        relayC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flRELAYpOP_DOWN , ifcIDtYPEbAG_CLIENTpOPpONG ) ;
                                    {
                                    if( psBag )
                                    etThread( tinP , psBag , TAG( TAGiDnULL ) ) ;
                                    ZE( soulC* , psBag ) ;
                                    //P: SERVER RESPONDS TO PING BY IMPLODE POPPING DOWNWARD A "PONG"
            
                                    }
                                        }
                                            etThread( tinP , psBag ) ;
                                            relayC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                                            idptP   >> *psBag ;
                                            idptOld >> *psBag ;
                                            relayC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flRELAYpOP_DOWN , ifcIDtYPEbAG_CLIENTpOPuNgOSSIP ) ;
                                        {
                                        if( psBag )
                                        etThread( tinP , psBag , TAG( TAGiDnULL ) ) ;
                                        ZE( soulC* , psBag ) ;
            
                                        relayC::handleRefreshTimeStampF( tinP , idptP ) ;
        
                                        idptP.timeStampIfF( tinP , etThread ) ;
                                        idptOld = idptP ;
                                        idPortTimeC idptOld ;
                                        //P: WHENEVER SELF IS GOSSIPPED IN A PING, THE FALSELY GOSSIPPED SERVER IMPODE POPS DOWNWARD AN "UNGOSSIP" ITEM AFTER RETIMESTAMPING ITSELF
                                    {
                                    if( stIdptGossipP( (byteT*)&idptP , subtractIdPortsF , - 1 ) )
            
                                    }
                                        UNGRABrELAYlISTS
                                        }
                                            relayC::hisListIF( tinP , stIdptOpenP , sBag , stIdptGossipP , idField ) ;
                                            relayC::hisListIF( tinP , stIdptGossipP , sBag , stIdptGossipP , idField ) ;
                                            countT idField = ifcIDfIELDbAG_IDtYPE + 1 ;
                                        {
                                        stIdptGossipP.purgeF( tinP ) ;
                                        stIdptOpenP.purgeF( tinP ) ;
                                        GRABrELAYlISTS
                                        //P: SERVER REPLACES ITS LISTS IFF PING IS RECEIVED FROM ELDER
                                    {
                                    if( idptOrigin && idptOrigin - idptP < 0 )
                                    cLooksForNewPingP = 0 ;
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPpING+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPpING\r\n" ) ; //U::
                                {
                                case ifcIDtYPEbAG_CLIENTpOPpING :
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOP*gOSSIP\r\n" ) ; //U::
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPgOSSIP-" )
                                    UNGRABrELAYlISTS
            
                                    }
                                        inc02AM( cGossipInP ) ;
                                        relayC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                                        }
                                            if( !relayC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idptGossipNew ) ) stIdptOpenP.sinkF( tinP , countTC() , (byteT*)&idptGossipNew , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
            
                                            }
                                                stIdptGossipP.extractF( 0 , tinP ) ;
                                            {
                                            else if( relayC::bListedIF( tinP , stIdptGossipP , stIdptGossipP , idptGossip ) )
                                            }
                                                stIdptGossipP.extractF( 0 , tinP ) ;
                                            {
                                            if( stIdptGossipP( (byteT*)&idptGossip , subtractIdPortsF , - 1 ) )
            
                                            }
                                                stIdptOpenP.extractF( 0 , tinP ) ;
                                            {
                                            else if( relayC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idptGossip ) )
                                            }
                                                stIdptOpenP.extractF( 0 , tinP ) ;
                                            {
                                            if( stIdptOpenP( (byteT*)&idptGossip , subtractIdPortTimesF , (countT)&stIdptGossipP ) )
                                            idPortTimeC idptGossipNew = idPortTimeC::fieldF( tinP , sBag , ifcIDfIELDbAG_IDtYPE + 1 + idPortTimeC::cFieldsF( tinP ) ) ;
                                        {
                                        else
                                        }
                                            stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptOrigin , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
                                            stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptGossip , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
                                            //P: GOSSIP HAS THE SAME EFFECT ON THE RELAY DOING THE GOSSIP AS ON THE VICTIM RELAY
                                        {
                                        if( idType == ifcIDtYPEbAG_CLIENTpOPgOSSIP )
                                        idPortTimeC idptGossip = idPortTimeC::fieldF( tinP , sBag , ifcIDfIELDbAG_IDtYPE + 1 ) ;
                                    {
                                    if( pnRoot && *pnRoot == idptP )
                                    //P: A SERVER WILL IGNORE GOSSIP UNLESS IT THINKS THAT IT IS ROOT
                                    idPortTimeC* pnRoot = stIdptOpenP ? (idPortTimeC*)&stIdptOpenP[ 1 ] : 0 ;
                                    GRABrELAYlISTS
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPgOSSIP+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOP*gOSSIP\r\n" ) ; //U::
                                {
                                case ifcIDtYPEbAG_CLIENTpOPuNgOSSIP :
                                case ifcIDtYPEbAG_CLIENTpOPgOSSIP :
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPbYE\r\n" ) ; //U::
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPbYE-" )
                                    bSaidBye = 1 ;
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPbYE+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPbYE\r\n" ) ; //U::
                                {
                                case ifcIDtYPEbAG_CLIENTpOPbYE :
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPhELLO\r\n" ) ; //U::
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPhELLO-" )
        
                                    //CONoUTrAW5( "tmRelayServerCatchBagF (idThread,idWork): " , tinP.monitor.idThread , processGlobal3I.mapPopClientWork(idWork) , 0 , "\r\n" ) ;
        
                                    idWork = sBag.cFieldF( tinP , ifcIDfIELDbAG_IDwORK ) ;
                                    stIdptPopClientP.sinkF( tinP , countTC() , (byteT*)&idptPopClient , flSTACKsINK_null , subtractIdPortTimesF , - 1 ) ;
                                    bPopClient = 1 ;
                                    idptPopClient = idptOrigin ;
                                    TELL( "ifcIDtYPEbAG_CLIENTpOPhELLO+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPhELLO\r\n" ) ; //U::
                                {
                                case ifcIDtYPEbAG_CLIENTpOPhELLO :
                            {
                            switch( idType ) //ALL PROCESSING HERE MUST BE FAST; LONG PROCESSING SHOULD BE DONE AFTER POPPING
                            if( POOP ) { BLAMMO ; }
                            ZE( byteT* , pbsWrap ) ;
                            TELL( "local processing" )
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 7 switching on bag type\r\n" ) ; //U::
            
                            }
                                UNGRABrELAYlISTS
                                //P: A SERVER THAT THINKS THAT IT IS ROOT WILL ADD UNKNOWN ORIGIN RELAYS TO ITS LIST
                                if( ideMe == 1 && idptOrigin && !relayC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idptOrigin ) ) stIdptOpenP.sinkF( tinP , countTC() , (byteT*)&idptOrigin , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                countT ideMe = stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 8 after grabbing lists\r\n" ) ; //U::
                                GRABrELAYlISTS
                                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 9 grabbing lists\r\n" ) ; //U::
                            {
            
                            swsIdSerialReceivedP.ungrabF( tinP ) ;
                            }
                                //P: EACH SERVER IGNORES DUPLICATES OF UPWARD BOUND ITEMS THAT IT HAS ALREADY PROCESSED
                                }
                                    bAltSwsP = !bAltSwsP ;
                                    ((stackC&)swsId).purgeF( tinP ) ;
                                {
                                if( swsId > 0x100 )
                                THREADmODE1rESTORE
                                swsId.sinkF( tinP , countTC() , idSerial , flSTACKsINK_UNIQUE ) ;
                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                switchStackC& swsId = bAltSwsP ? swsIdSerialReceivedAltP : swsIdSerialReceivedP ;
                                TELL( "registering serial" )
                            {
                            )
                                )
                                    )
                                        idType == ifcIDtYPEbAG_CLIENTpOPuNgOSSIP
                                        idType == ifcIDtYPEbAG_CLIENTpOPgOSSIP   ||
                                        idType == ifcIDtYPEbAG_CLIENTpOPpONG     ||
                                    (
                                    bRoot &&
                                (
                                F(flags) & flRELAYpOP_UP ||
                            (
                            if
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": a registering serial\r\n" ) ; //U::
            
                            UNGRABrELAYlISTS
                            }
                                //etThread.traceF( tinP , T("flipped flags from down to up [flags]:    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                flags |=      flRELAYpOP_UP      ;
                                flags &= ~( F(flRELAYpOP_DOWN) ) ;
                            {
                            )
                                idType != ifcIDtYPEbAG_CLIENTpOPuNgOSSIP
                                idType != ifcIDtYPEbAG_CLIENTpOPgOSSIP    &&
                                idType != ifcIDtYPEbAG_CLIENTpOPpONG      &&
                                bRoot                                     &&
                                F(flags) & flRELAYpOP_DOWN                &&
                            (
                            if
                            //P: A SERVER THAT THINKS THAT IT IS ROOT WILL BANG MOST ITEMS IMPLODED DOWN INTO IT
                            //etThread.traceF( tinP , T("[bRoot]:    ")+TF2(bRoot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            const boolT bRoot = 1 == stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": b inspecting whether i am root\r\n" ) ; //U::
                            GRABrELAYlISTS
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": c.2 grabbing lists before inspecting for being root\r\n" ) ; //U::
                            //etThread.traceF( tinP , T("not already seen [idSerial,flags]:    ")+TF2(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        else
                        }
                            //}
                            //    }
                            //        }
                            //            if( pbsTo && soulC::cFieldsIF( tinP , pbsTo ) ) { CONoUTrAW3( "ignoring directed bag " , idSerial , "\r\n" ) ; }
                            //
                            //            byteT* pbsTo = soulC::pbFieldIF( tinP , idTypesTo , flagssTo , cbsTo , ifcIDfIELDwRAP_TO , pbsWrap ) ;
                            //            ZE( countT , cbsTo ) ;
                            //            ZE( flagsT , flagssTo ) ;
                            //            ZE( countT , idTypesTo ) ;
                            //        {
                            //        if( pbsWrap )
                            //        byteT* pbsWrap = sBag.pbFieldF( tinP , idTypesWrap , flagssWrap , cbsWrap , ifcIDfIELDbAG_WRAP ) ;
                            //        ZE( countT , cbsWrap ) ;
                            //        ZE( flagsT , flagssWrap ) ;
                            //        ZE( countT , idTypesWrap ) ;
                            //    {
                            //    if( idType == ifcIDtYPEbAG_WRAP )
                            //{
                            //FOR DEBUGGING ONLY; MUST BE COMMENTED OUT IN PRODUCTION
        
                            swsIdSerialReceivedP.ungrabF( tinP ) ;
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": c.1 serial already seen\r\n" ) ; //U::
                            //etThread.traceF( tinP , T("already seen [idSerial,flags]:    ")+TF2(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        if( swsIdSerialReceivedP( idSerial ) || swsIdSerialReceivedAltP( idSerial ) )
                        idPortOriginP = idptOrigin ;
                        swsIdSerialReceivedP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        //CONoUTrAW3( "tmCatchBagF " , idCatch , ": d.2 inspecting serial\r\n" ) ; //U::
                    {
                    else
                    }
                        tTraceFail = T("error: null serial") ;
                        bFail = 1 ;
                    {
                    if( !idSerial )
                    TN( tcr , "\r\n" ) ;
                    TELL( "handling soul" )
                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": e inspecting for null serial\r\n" ) ; //U::

                    //etThread.traceF( tinP , T("[idSerial,flags]:    ")+TF2(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            
                    countT   idType     = sBag.cFieldF( tinP , ifcIDfIELDbAG_IDtYPE ) ;
                    flagsT&  flags      = sBag.cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                    countT   idSerial   = sBag.cFieldF( tinP , ifcIDfIELDbAG_IDsERIAL ) ;
                    TELL( "inspecting received soul" )
                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": f preparing to inspect bag\r\n" ) ; //U::

                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": g inspecting psoP\r\n" ) ; //U::
                {
                else
                }
                    tTraceFail = T("i have been told to quit") ;
                    bFail = 1 ;
                {
                if( bQuitP )
                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": h inspecting bQuitP\r\n" ) ; //U::
        
                idptOriginLathGood = idptOrigin ;

                idPortTimeC idptOrigin = POOP ? idptNull : idPortTimeC::fieldF( tinP , sBag , ifcIDfIELDbAG_RELAYoRIGIN ) ;
                idPortTimeC idptNull ;
                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": j a bag has arrived\r\n" ) ; //U::
                idCatch = 1 + incv02AM( idCatchLath ) ;
                //etThread.traceF( tinP , T("processing a bag") ) ;
            {
            if( !bFail )

            //etThread.traceF( tinP , T("readed  a bag") ) ;
            }
                }
                    tTraceFail = T("could not read sBag") ;
                    bFail = 1 ;
                    POOPRqUIET
                {
                if( POOP )

                psoP->readF( tinP , sBag ) ;
                SCOOPS
            {
            IFsCRATCH
            //etThread.traceF( tinP , T("reading a bag") ) ;

            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 0 waiting for a bag to arrive\r\n" ) ; //U::
            sBag.removeAllF( tinP ) ;
            TELL( "reading soul" )

            ZE( boolT , bFail ) ;
        {
        while( !etThread && !ether && !bQuitP && psoP )
        TN( tTraceFail , "" ) ;
        ZE( countT , idCatch ) ;
        static countT idCatchLath ;
        stackC stIdMe( tinP , etThread , TAG( TAGiDnULL ) ) ;
        ZE( boolT  , bSaidBye ) ;
        ZE( countT , idWork ) ;
        ZE( boolT  , bPopClient ) ;
        ZE( countT , idPingLath ) ;
        idPortTimeC idptOriginLathGood ;
        idPortTimeC idptPopClient ;

        sOk << ifcIDtYPEbAG_SERVERoK ;
        soulC sOk(  tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
        soulC sBag( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    
        stPsoServerP.sinkF( tinP , countTC() , (countT)psoP , flSTACKsINK_UNIQUE ) ;

        psoP->etherF( tinP , *tinP.pEtScratch ) ;
    {
    IFsCRATCH

    countT&  cLooksForNewPingP =  *(countT*)pTaskP->c7 ;
    stackC&  stIdptPopClientP  =  *(stackC*)pTaskP->c6 ;
    socketC& sListenP          = *(socketC*)pTaskP->c5 ;
    socketC* psoP              =  (socketC*)pTaskP->c4 ;
    RELAYiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TELL( "setting up" )
/*1*/TASK( tmRelayServerCatchBagF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

