
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    #endif

        }
            __1
            __( rc ) ;
            countT rc = tinP.brcRaw ;
            BOSdOnOTtEST( WHATgbo , GetLastError() )
        {
        if( !hP )

        }
            }
                break ;
                hP.osF( ifcIDtYPEhANDLE_DRAWINGtOOL , tinP.brcRaw ) ;
                BOSpOOP
                BOS( WHATgbo , BOSoK , CreateRectRgnIndirect( &info ) )

                else                          info.top    ++ ;
                if( info.top <= info.bottom ) info.bottom ++ ;
            
                else                          info.left  ++ ;
                if( info.left <= info.right ) info.right ++ ;
            
                info.bottom = idrTo ;
                info.right  = idcTo ;
                info.top    = idrFrom ;
                info.left   = idcFrom ;
                RECT info ;

                countT idrTo   = R( winOsRowIF( mIdRowTo   , cRowsDraw ) ) ;
                countT idrFrom = R( winOsRowIF( mIdRowFrom , cRowsDraw ) ) ;
                countT idcTo   = R( winOsColIF( mIdColTo               ) ) ;
                countT idcFrom = R( winOsColIF( mIdColFrom             ) ) ;

                const countT cRowsDraw = ((const HANDLEaPPnOTEScOUNTcLASS&)hDrawP).c2 ;

                const measureT mIdRowTo   = pcP ? *(measureT*)&pcP[ 3 ] : 0 ;
                const measureT mIdColTo   = pcP ? *(measureT*)&pcP[ 2 ] : 0 ;
                const measureT mIdRowFrom = pcP ? *(measureT*)&pcP[ 1 ] : 0 ;
                const measureT mIdColFrom = pcP ? *(measureT*)&pcP[ 0 ] : 0 ;
            {
            case ifcIDtYPEdRAWINGtOOL_REGIONrECTANGLE :
            }
                break ;

                }
                    //}
                    //    countT foo = 2 ;
                    //{
                    //if( c2p.c1 )
                    //GetObject( (HGDIOBJ)hP.osF( ifcIDtYPEhANDLE_DRAWINGtOOL ) , sizeof info , &info ) ;
                    //BITMAP info ;
    
                    //LOGrAWtID4( "ifcIDtYPEdRAWINGtOOL_BITMAP (cCols,cRows): " , pcP[ 0 ] , " " , pcP[ 1 ] ) ;
                    cAppNotes.c2 = pcP[ 1 ] ;
                    cAppNotes.c1 = pcP[ 0 ] ;
                    HANDLEaPPnOTEScOUNTcLASS& cAppNotes = hP ;

                    hP.osF( ifcIDtYPEhANDLE_DRAWINGtOOL , tinP.brcRaw ) ;
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , CreateCompatibleBitmap( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , pcP[ 0 ] , pcP[ 1 ] ) )
                {
                if( pcP )
            {
            case ifcIDtYPEdRAWINGtOOL_BITMAP :
            }
                break ;
                hP.osF( ifcIDtYPEhANDLE_DRAWINGtOOL , tinP.brcRaw ) ;
                BOSpOOP
                BOS( WHATgbo , BOSoK , CreateSolidBrush( (DWORD)*pcc ) )

                const countT* pcc = pcP ? pcP : &color ;
                countT color = ifcRGB_W4 ;
            {
            case ifcIDtYPEdRAWINGtOOL_BRUSH :
            }
                break ;
                hP.osF( ifcIDtYPEhANDLE_DRAWINGtOOL , tinP.brcRaw ) ;
                BOSpOOP
                BOS( WHATgbo , BOSoK , CreatePen( PS_SOLID , 1 , (DWORD)*pcc ) )

                const countT* pcc = pcP ? pcP : &color ;
                countT color = ifcRGB_W4 ;
            {
            case ifcIDtYPEdRAWINGtOOL_PEN :
            }
                break ;
                hP.osF( ifcIDtYPEhANDLE_DRAWINGtOOL , tinP.brcRaw ) ;
                BOSpOOP
                BOS( WHATgbo , BOSoK , CreateFontIndirect( &info ) )
    
                thirdC::c_strncpyIF( tinP , info.lfFaceName , "Terminal" , sizeof info.lfFaceName ) ;
                info.lfPitchAndFamily   = FIXED_PITCH | FF_MODERN ;
                //info.lfQuality          = DRAFT_QUALITY ;
                //info.lfClipPrecision    = CLIP_STROKE_PRECIS ;
                //info.lfOutPrecision     = OUT_STRING_PRECIS ;
                info.lfCharSet          = OEM_CHARSET ;
                //info.lfStrikeOut      = 0 ;
                //info.lfUnderline      = 0 ;
                //info.lfItalic         = 0 ;
                info.lfWeight           = 0xcb2 ;
                //info.lfOrientation    = 0 ;
                //info.lfEscapement     = 0 ;
                //info.lfWidth            =   7 ;
                info.lfHeight           = 0x10 ;
                pEtherContainsMe->memSetF( tinP , (byteT*)&info , sizeof info ) ;
                LOGFONT info ;
            {
            case ifcIDtYPEdRAWINGtOOL_FONT :
        {
        switch( idTypeP )

    #elif defined( __NT__ )
        //U:
    #if defined( __OS2__ )
    _IO_

    }
        if( POOP ) return ;
        __Z( idTypeP ) ;
        __( ~hP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
    SCOOP
{
/*1*/voidT thirdC::winOpenDrawingToolF( tinS& tinP , handleC& hP , const countT idTypeP , const handleC& hDrawP , const countT* const pcP )/*1*/

/**/
*/
  if not 0 then contains specifications for the tool
  can be 0
 pcP
 wP
 idTypeP
 hP
 tinP
arguments
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

