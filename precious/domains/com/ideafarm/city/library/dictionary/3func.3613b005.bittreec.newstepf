
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bDone ;

    _OUT_
    }
        }
            pp.cBits  -- ;
            pp.offBit ++ ;

            }
                }
                    pp.idThis = cElementsDispensed ;
                    *(countT*)&PtHIS->p1 |= cElementsDispensed ;                                         // THIS IS THE ID OF THE NEW NODE
                {
                else
                }
                    pp.pThis = pbn ;
                    *(countT*)&PtHIS->p1 |= (countT)pbn ;
                {
                if( pbRawBegin )

                bitNodeS* pbn = newNodeF( tinP ) ;
            {
            else
            }
                }
                    pp.idThis = idThisNew ;

                    //;
                    //    : (bitNodeS*)(const byteT*)(*pNapkins)[ idThisNew - 1 ]
                    //    ? 0
                    //pp.pThis = !idThisNew

                    countT idThisNew = BhIDE( BM_HIGH , PtHIS->p1 ) ;
                {
                else
                if( pbRawBegin ) pp.pThis = (bitNodeS*)BhIDE( BM_HIGH , PtHIS->p1 ) ;
            {
            if( BhIDE( BM_HIGH , PtHIS->p1 ) )
        {
        else
        }
            pp.cBits  -- ;
            pp.offBit ++ ;

            }
                }
                    pp.idThis = cElementsDispensed ;
                    *(countT*)&PtHIS->p0 |= cElementsDispensed ;                                         // THIS IS THE ID OF THE NEW NODE
                {
                else
                }
                    pp.pThis = pbn ;
                    *(countT*)&PtHIS->p0 |= (countT)pbn ;
                {
                if( pbRawBegin )

                bitNodeS* pbn = newNodeF( tinP ) ;
            {
            else
            }
                }
                    pp.idThis = idThisNew ;

                    //;
                    //    : (bitNodeS*)(const byteT*)(*pNapkins)[ idThisNew - 1 ]
                    //    ? 0
                    //pp.pThis = !idThisNew

                    countT idThisNew = BhIDE( BM_HIGH , PtHIS->p0 ) ;
                {
                else
                if( pbRawBegin ) pp.pThis = (bitNodeS*)BhIDE( BM_HIGH , PtHIS->p0 ) ;
            {
            if( BhIDE( BM_HIGH , PtHIS->p0 ) )
        {
        if( !pp.myBit )

        pp.myBit >>= SB - 1 - pp.offBit ;
        pp.myBit <<= SB - 1 - pp.offBit ;                                                                   // DISCARD HIGHER BITS

        pp.myBit <<= pp.offBit ;
        pp.myBit >>= pp.offBit ;                                                                            // DISCARD LOWER BITS

        pp.myBit = *pp.pbBits ;
    {
    else                                                                                                    // ATTACH A NODE FOR THE CURSORED BIT
    }
        bDone = 1 ;

        }
            }
                *(countT*)&PtHIS->p1 |= BM_HIGH ;                                                            // MARK THIS AS AN ESCAPE NODE (FOLLOW p1 TO CONTINUE WALKING)

                ;
                    : (bitNodeS*)cElementsDispensed
                    ?            pbn
                PtHIS->p1 = pbRawBegin

                PtHIS->p0 = (bitNodeS*)*pp.pcDatum ;

                // p1 WILL POINT TO THE NEW NODE, WHICH IS AN IDENTICAL COPY OF THE NODE THAT HAS BECOME THE ESCAPE NODE
                // p0 WILL CONTAIN THE VALUE OF *pcDatum
                // CONVERT *pThis INTO AN ESCAPE NODE

                *pbn = *PtHIS ;
                bitNodeS* pbn = newNodeF( tinP ) ;
            {
            if( pp.pcDatum )

            *(countT*)&PtHIS->p0 |= BM_HIGH ;                                                                       // INDICATE THAT THE PATH TO *pp.pThis HAS BEEN CREATED (NO EFFECT IF DUPLIATE)
        {
        if( !POOP )

        __NZ( BkEEP( BM_HIGH , *(countT*)&PtHIS->p0 ) ) ;                                                // FAIL IF ITEM ALREADY EXISTS






    {
    if( !pp.cBits )
    ZE( boolT , bDone ) ;

    }
        }
            pp.idThis = idThisNew ;
            //pp.pThis = (bitNodeS*)(*pNapkins)[ idThisNew - 1 ] ;
            countT idThisNew = BhIDE( BM_HIGH , PtHIS->p1 ) ;
        {
        else
        if( pbRawBegin ) pp.pThis = (bitNodeS*)BhIDE( BM_HIGH , PtHIS->p1 ) ;

        if( pp.pcDatum && !pp.cBits ) *pp.pcDatum = BhIDE( BM_HIGH , PtHIS->p0 ) ;
    {
    while( BkEEP( BM_HIGH , PtHIS->p1 ) )                                                                //SKIP ANY ESCAPE NODES

    }
                     pp.offBit %= SB ;
        pp.pbBits += pp.offBit /  SB ;
    {
    if( pp.offBit >= SB )                                                                                   // NORMALIZE SO pp.offBit IS [0-7]

    if( !pp.pbBits ) { BLAMMO ; }                                                                           // SOURCE BITS MUST BE SPECIFIED

    //tinP.pEther->traceF( tinP , TF3(espAM(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
    pp.cSteps ++ ;

    rParam_new_S& pp = *(rParam_new_S*)tinP.pbRecursiveParameters ;
    _INoLD_
{
/*1*/boolT bitTreeC::newStepF( tinS& tinP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

