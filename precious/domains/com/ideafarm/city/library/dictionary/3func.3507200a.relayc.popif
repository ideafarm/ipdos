
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        _OUT_
        }
            }
                }
                    }
                        //if( bDebug ) { CONoUTrAW3( "popping secret packet " , idSerialBag , " RIGHT\r\n" ) ; }
                        *pStPop4P << psBagCopy ; psBagCopy = 0 ;
                        }
                            flags &= ~( F(flRELAYpOP_DOWN) | F(flRELAYpOP_UP) ) ;
                            flagsT& flags = psBagCopy->cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                        {
                        if( bDudP )
                        *psBagCopy = sBagP ;
                    {
                    if( psBagCopy )
                    (*tinP.pEther)( tinP , psBagCopy , TAG( TAGiDnULL ) ) ;
                    ZE( soulC* , psBagCopy ) ;
                {
                if( pStPop4P )
                
                }
                    }
                        //if( bDebug ) { CONoUTrAW3( "popping secret packet " , idSerialBag , " LEFT\r\n" ) ; }
                        *pStPop3P << psBagCopy ; psBagCopy = 0 ;
                        }
                            flags &= ~( F(flRELAYpOP_DOWN) | F(flRELAYpOP_UP) ) ;
                            flagsT& flags = psBagCopy->cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                        {
                        if( bDudP )
                        *psBagCopy = sBagP ;
                    {
                    if( psBagCopy )
                    (*tinP.pEther)( tinP , psBagCopy , TAG( TAGiDnULL ) ) ;
                    ZE( soulC* , psBagCopy ) ;
                {
                if( pStPop3P )
            {
            if( bLateral )
            
            }
                }
                    //if( bDebug ) { CONoUTrAW3( "popping secret packet " , idSerialBag , " UP2\r\n" ) ; }
                    *pStPop2P << psBagCopy ; psBagCopy = 0 ;
                    }
                        flags &= ~( F(flRELAYpOP_DOWN) | F(flRELAYpOP_UP) ) ;
                        flagsT& flags = psBagCopy->cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                    {
                    if( bDudP )
                    *psBagCopy = sBagP ;
                {
                if( psBagCopy )
                (*tinP.pEther)( tinP , psBagCopy , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psBagCopy ) ;
            {
            if( flagsUp & 2 && pStPop2P )
        
            }
                }
                    //if( bDebug ) { CONoUTrAW3( "popping secret packet " , idSerialBag , " UP1\r\n" ) ; }
                    *pStPop1P << psBagCopy ; psBagCopy = 0 ;
                    }
                        flags &= ~( F(flRELAYpOP_DOWN) | F(flRELAYpOP_UP) ) ;
                        flagsT& flags = psBagCopy->cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                    {
                    if( bDudP )
                    *psBagCopy = sBagP ;
                {
                if( psBagCopy )
                (*tinP.pEther)( tinP , psBagCopy , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psBagCopy ) ;
            {
            if( flagsUp & 1 && pStPop1P )
    
            }
                (*tinP.pEther)( tinP , psWrap ) ;
                }
                    }
                        //CONoUTrAW3( "popIF: flagsUp: " , flagsUp , "\r\n" ) ;
                        (*tinP.pEther)( tinP , psTo ) ;
                        }
                            UNGRABrELAYlISTS
                            }
                                if( idRankTo ) flagsUp |= flagsUpF( idRankMe , idRankTo , idRankMax ) ;
    
                                //THREADmODE1rESTORE
                                //CONoUTrAW( T("popIF: idRankTo: ")+TF1(idRankTo)+T(" ")+T(idptTo)+T("\r\n") ) ;
                                //THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    
                                }
                                    if( idptTo ) idRankTo = stIdptOpenP( (byteT*)&idptTo , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                    idptTo << *psTo ;
                                    idPortTimeC idptTo ;
                                {
                                ZE( countT , idRankTo ) ;
                            {
                            if( idRankMe ) while( (countT)*psTo && flagsUp != 3 ) //U:: EDIT soulC TO ELIMINATE THE NEED TO CAST TO countT TO GET THE NUBMER OF ITEMS
                            const countT idRankMax = stIdptOpenP ;
                            //CONoUTrAW3( "popIF: idRankMe: " , idRankMe , "\r\n" ) ;
                            countT idRankMe = stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                            GRABrELAYlISTS
    
                            psTo->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbs , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                        {
                        if( psTo )
                        (*tinP.pEther)( tinP , psTo , TAG( TAGiDnULL ) ) ;
                        ZE( soulC* , psTo ) ; // WILL CONTAIN EITHER sTo OR sToMediator
    
                        }
                            //CONoUTrAW3( "popIF: bDebugUsingMediator: " , bDebugUsingMediator , "\r\n" ) ;
                            ;
                                : ( bDebugUsingMediator = 0 , psWrap->pbFieldF( tinP , idType , flags , cbf , ifcIDfIELDwRAP_TO         ) )
                                ? ( bDebugUsingMediator = 1 , psWrap->pbFieldF( tinP , idType , flags , cbf , ifcIDfIELDwRAP_TOmEDIATOR ) )
                            pbs = !( F(flagsPut) & flCIOpUT_IGNOREmEDIATORlIST ) && !psWrap->bKidEmptyF( tinP , ifcIDfIELDwRAP_TOmEDIATOR )
                            ZE( countT , cbf ) ;
                            ZE( flagsT , flags ) ;
                            ZE( countT , idType ) ;
    
                            flagsT flagsPut = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_FLAGS ) ;
                        {
                        ZE( byteT* , pbs ) ;
                        ZE( boolT , bDebugUsingMediator ) ;
    
                        flagsUp = bLateral = 0 ; //THIS IS A POINT TO POINT PACKET SO DON'T POP SIDE TO SIDE (REDUNDANT, TO MAKE BROADCAST MORE ROBOST)
                        //if( !psWrap->bKidEmptyF( tinP , ifcIDfIELDwRAP_TOmEDIATOR ) ) { CONoUTrAW( "sToMediator is not empty\r\n" ) ; }
                        //CONoUTrAW( "sTo is not empty\r\n" ) ;
                    {
                    if( !psWrap->bKidEmptyF( tinP , ifcIDfIELDwRAP_TO ) )
    
                    psWrap->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbsWrap , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                    //O: THIS IS EXPENSIVE; CAN ELIMINATE BY COPYING sTo TO THE OUTER ENVELOPE
                {
                if( psWrap )
                (*tinP.pEther)( tinP , psWrap , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psWrap ) ;
    
                byteT* pbsWrap = sBagP.pbFieldF( tinP , idTypesWrap , flagssWrap , cbfsWrap , ifcIDfIELDbAG_WRAP ) ;
                ZE( countT , cbfsWrap ) ;
                ZE( flagsT , flagssWrap ) ;
                ZE( countT , idTypesWrap ) ;
            {
            if( sBagP.cFieldF( tinP , ifcIDfIELDbAG_IDtYPE ) == ifcIDtYPEbAG_WRAP )
            flagsT flagsUp = 3 ; //BOTH UP LEFT AND UP RIGHT
            boolT bLateral = 1 ;
        {
        if( F(flags) & flRELAYpOP_UP )
    
        }
            }
                }
                    //if( bDebug ) { CONoUTrAW3( "popping secret packet " , idSerialBag , " DOWN\r\n" ) ; }
                    *pStPop0P << psBagCopy ; psBagCopy = 0 ;
                    }
                        flags &= ~( F(flRELAYpOP_DOWN) | F(flRELAYpOP_UP) ) ;
                        flagsT& flags = psBagCopy->cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                    {
                    if( bDudP )
                    *psBagCopy = sBagP ;
                {
                if( psBagCopy )
                (*tinP.pEther)( tinP , psBagCopy , TAG( TAGiDnULL ) ) ;
                ZE( soulC* , psBagCopy ) ;
            {
            if( pStPop0P )
        {
        if( F(flags) & flRELAYpOP_DOWN )
        flagsT flags = sBagP.cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
    
        }
            //if( bDebug ) { CONoUTrAW3( "popIF got a secret STROKEStOcONSOLE " , idSerialBag , "\r\n" ) ; }
        {
    
        }
            }
                }
                    }
                        idSerialBag = sBagP.cFieldF( tinP , ifcIDfIELDbAG_IDsERIAL ) ;
                        bDebug = 1 ;
                    {
                    if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATED && pczChannel[ 2 ] == ifcIDaDAM_SECRETsERVICE && pczChannel[ 3 ] == ifcIDaDAM_CONSOLE && pczChannel[ 4 ] == ifcIDcHANNELfUNCTION_STROKEcONSOLE )
                    countT* pczChannel = (countT*)soulC::pbFieldIF( tinP , idTypeChannel , flagsChannel , cbfChannel , ifcIDfIELDwRAP_CHANNEL , pbsWrap ) ;
                    ZE( countT , cbfChannel ) ;
                    ZE( flagsT , flagsChannel ) ;
                    ZE( countT , idTypeChannel ) ;
                {
                if( idType == ifcIDtYPEwRAP_GIFT )
                countT idType = soulC::cFieldIF( tinP , ifcIDfIELDwRAP_IDtYPE , pbsWrap ) ;
            {
            if( soulC::cFieldsIF( tinP , pbsWrap ) >= ifcIDfIELDwRAP_IDtYPE )
            
            byteT* pbsWrap = sBagP.pbFieldF( tinP , idTypesWrap , flagssWrap , cbfsWrap , ifcIDfIELDbAG_WRAP ) ;
            ZE( countT , cbfsWrap ) ;
            ZE( flagsT , flagssWrap ) ;
            ZE( countT , idTypesWrap ) ;
        {
        if( sBagP.cFieldF( tinP , ifcIDfIELDbAG_IDtYPE ) == ifcIDtYPEbAG_WRAP )
        ZE( countT , idSerialBag ) ;
        ZE( boolT , bDebug ) ;
        //U::
    
        _INoLD_
    
        //}
        //    }
        //        }
        //            LOGrAW( TF3(idrTo,flFORMAT_UNSIGNED,9)+TF1(flagsUp)+T("\r\n") ) ;
        //            flagsT flagsUp = flagsUpF( idrMe , idrTo , idrMax ) ;
        //        {
        //        for( countT idrTo = idrMe + 1 ; idrTo <= idrMax ; idrTo ++ )
        //        LOGrAW( T("\r\nidrMe: ")+TF1(idrMe)+T("\r\n") ) ;
        //    {
        //    for( countT idrMe = 1 ; idrMe <= idrMax ; idrMe ++ )
        //    LOGrAW( T("idrMax: ")+TF1(idrMax)+T("\r\n") ) ;
        //    const countT idrMax = 0x10 ;
        //{
        //if( !incv02AM( cIn ) )
        //static countT cIn ;
        //TESTER CODE FOR flagsUpF
    {
    IFsCRATCH
{
/*1*/voidT relayC::popIF( tinS& tinP , stackC* pStPop0P , stackC* pStPop1P , stackC* pStPop2P , stackC* pStPop3P , stackC* pStPop4P , soulC& sBagP , stackC& stIdptOpenP , stackC& stIdptGossipP , idPortTimeC& idptP , const boolT bDudP )/*1*/

//
//  n: (2**n)*x ................ (2**n)*x+(2**(n-1))-1 | (2**n)*x+(2**(n-1)) ............ (2**n)*(x+1)-1
//
//  4: 01x+0 01x+1 01x+2 01x+3 01x+4 01x+5 01x+6 01x+7 | 01x+8 01x+9 01x+a 01x+b 01x+c 01x+d 01x+e 01x+f
//  3: 8x+0        8x+1        8x+2        8x+3        | 8x+4        8x+5        8x+6        8x+7
//  2: 4x+0                    4x+1                    | 4x+2                    4x+3
//  1: 2x+0                                            | 2x+1
//  0: x
//
// x: idRankMeP

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

