
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pcLever ? *pcLever : *(countT*)pbnu ;
    if( !pcLever ) *(countT*)pbnu = 0 ;

    stackk.ungrabF( tinP ) ;
    }
        while( !third && ~hDown ) ;
        }
            }
                break ;
                pcLever = (countT*)c_pbLB ;
            {
            if( c_pbLB && !thirdC::c_memcmpIF( tinP , ( (byteT*)c_pbLB + sizeof( countT ) ) , (byteT*)&cP , cbData ) )
            countT c_pbLB = (countT)&stackk.downF( tinP , hDown ) ;
        {
        do
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stackk )
    stackk.grabF( tinP , TAG( TAGiDnULL ) ) ;
    ZE( countT* , pcLever ) ;

    }
        if( third ) return *(countT*)pbnu ;
    {
    IFbEcAREFUL

    SCOOP
    TINSL
{
/*1*/countT& switchC::operator () ( const countT& cP )/*1*/

/**/
*/
   for cP, specify a reference to the beginning of the value to be searched for
  cP is a reference so that i can be used when cbData is not sizeof( countT )
  the value to be searched for
 cP
arguments
 in such applications, the caller must serialize access to *this
 if *this is accessed by multiple threads, that volatile storage might contain a nonze value
if the value cP is not found, i evaluate to a reference to volatile storage that i set to 0
i evaluate to a reference to the wo'th lever that is associated with value cP
\<A HREF=\"5.1200022.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

