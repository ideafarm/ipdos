
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmWhereF )
}
    LOGrAWaDAM( ostoRpt ) ;
    
    }
        OStEXTAK( ostoRpt , "|\r\n" ) ;
        }
            OStEXTAK( ostoRpt , "\r\n" ) ;
            }
                OStEXTA( ostoRpt , postn ) ;
                OStEXTAK( ostoRpt , " " ) ;
            {
            if( postn )
            const osTextT* postn = processGlobal8I.source.postFileTitleF( tinP , c3s.c3 ) ;
            OStEXTC( ostoRpt , processGlobal8I.source.idFileImmutableF( tinP , c3s.c3 ) , ' ' ) ;
            OStEXTAK( ostoRpt , " " ) ;
            OStEXTC( ostoRpt , cExitsMe , ' ' ) ;
            OStEXTAK( ostoRpt , " " ) ;
    
            OStEXTC( ostoRpt , perTuck , ' ' ) ;
            countT perTuck = cExits ? ( cExitsMe * 0x100 ) / cExits : 0 ;
            countT cExitsMe = - c3s.c1 ;
            OStEXTAK( ostoRpt , "| " ) ;
    
            stSorter >> pb_c3s ;
            byteT* pb_c3s = (byteT*)&c3s ;
            count3S c3s ;
        {
        while( stSorter )
        OStEXTAK( ostoRpt , "\r\n| [ % , exits , idiFile , fileTitle ]\r\n|\r\n" ) ;
        OStEXTC( ostoRpt , cExits , 0 ) ;
        OStEXTAK( ostoRpt , "| EXITS\r\n|\r\n| tally: " ) ;
    {

    }
        }
            stSorter.sinkF( tinP , countTC() , (byteT*)&c3s , flSTACKsINK_null , subtractTallyF ) ;
            cExits -= c3s.c1 ;
            count3S c3s( - tinP.pAdamGlobal1->pcExitsWhere[ off ] , 0 , off ) ;
        {
        if( tinP.pAdamGlobal1->pcExitsWhere[ off ] )
    {
    for( countT off = 1 ; off < sizeof tinP.pAdamGlobal1->pcExitsWhere / sizeof tinP.pAdamGlobal1->pcExitsWhere[ 0 ] ; off ++ )
    ZE( countT , cExits ) ;

    }
        OStEXTAK( ostoRpt , "|\r\n" ) ;
        }
            OStEXTAK( ostoRpt , "\r\n" ) ;
            }
                OStEXTA( ostoRpt , postn ) ;
                OStEXTAK( ostoRpt , " " ) ;
            {
            if( postn )
            const osTextT* postn = processGlobal8I.source.postFileTitleF( tinP , processGlobal8I.source.idFileRankF( tinP , c3s.c3 ) ) ;
            OStEXTC( ostoRpt , c3s.c3 , ' ' ) ;
            OStEXTAK( ostoRpt , "_9) " ) ;
            OStEXTC9( ostoRpt , c3s.c2 ) ;
            OStEXTAK( ostoRpt , " (" ) ;
            OStEXTC( ostoRpt , c3s.c2 , ' ' ) ;
            OStEXTAK( ostoRpt , " " ) ;
            OStEXTC( ostoRpt , tally , ' ' ) ;
            OStEXTAK( ostoRpt , " " ) ;
    
            OStEXTC( ostoRpt , perTuck , ' ' ) ;
            countT perTuck = totalTally ? ( tally * 0x100 ) / totalTally : 0 ;
            countT tally = - c3s.c1 ;
            OStEXTAK( ostoRpt , "| " ) ;
    
            stSorter >> pb_c3s ;
            byteT* pb_c3s = (byteT*)&c3s ;
            count3S c3s ;
        {
        while( stSorter )
        OStEXTAK( ostoRpt , "\r\n|\r\n| [ % , tally , idLine , (idLine_9) , idiFile , fileTitle ]\r\n|\r\n" ) ;
        OStEXTC( ostoRpt , totalTally , 0 ) ;
        OStEXTAK( ostoRpt , "| WHERE\r\n|\r\n| tally: " ) ;
        }
            OStEXTAK( ostoRpt , "\r\n" ) ;
            OStEXTA( ostoRpt , tList ) ;
            OStEXTAK( ostoRpt , "FOCUS: CALLER OF " ) ;
            TN( tList , "" ) ; tList = T((countT*)c8idiFileFocus) ;
        {
        if( cFoci )
    {

    }
        }
            stSorter.sinkF( tinP , countTC() , (byteT*)&c3s , flSTACKsINK_null , subtractTallyF ) ;
            totalTally -= c3s.c1 ;
            count3S c3s( - swTally , c2Lever.c1 , c2Lever.c2 ) ;
            etThread.memCopyF( tinP , (byteT*)&c2Lever , (byteT*)swTally.leverF( tinP , idf ) , sizeof c2Lever ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    {
    countT cFlavors = swTally.cFlavorsF( tinP ) ;
    ZE( countT , totalTally ) ;

    }
        }
            OStEXTAK( ostoRpt , "|\r\n" ) ;
            }
                OStEXTAK( ostoRpt , "\r\n" ) ;
                else        { OStEXTC( ostoRpt , c3s.c2 , ' ' ) ; }
                if( postn ) { OStEXTA( ostoRpt , postn ) ; }

                if( !postn && cToDo ) postn = processGlobal4I.mapGroup( c3s.c2 ) ;

                const osTextT* postn = processGlobal4I.mapWhat( c3s.c2 ) ;
                OStEXTAK( ostoRpt , " " ) ;
                OStEXTC( ostoRpt , tally , ' ' ) ;
                OStEXTAK( ostoRpt , " " ) ;
        
                OStEXTC( ostoRpt , perTuck , ' ' ) ;
                countT perTuck = totalTallyWhat ? ( tally * 0x100 ) / totalTallyWhat : 0 ;
                countT tally = - c3s.c1 ;
                OStEXTAK( ostoRpt , "| " ) ;
        
                stSorter >> pb_c3s ;
                byteT* pb_c3s = (byteT*)&c3s ;
                count3S c3s ;
            {
            while( stSorter )
            OStEXTAK( ostoRpt , "\r\n|\r\n| [ % , tally , postWhat ]\r\n|\r\n" ) ;
            OStEXTC( ostoRpt , totalTallyWhat , 0 ) ;
            OStEXTA( ostoRpt , cToDo ? "THREAD WHEREABOUTS REPORT\r\n|\r\n| WHAT 1 (PREDEFINED CATEGORIES)\r\n|\r\n| tally: " : "THREAD WHEREABOUTS REPORT\r\n|\r\n| WHAT 2 (AD HOC CATEGORIES)\r\n|\r\n| tally: " ) ;
        {
    
        }
            stSorter.sinkF( tinP , countTC() , (byteT*)&c3s , flSTACKsINK_null , subtractTallyF ) ;
            totalTallyWhat -= c3s.c1 ;
            count3S c3s( - swTallyWhat12 , idWhat12 ) ;
            idWhat12 = swTallyWhat12.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swTallyWhat12.cFlavorsF( tinP ) ;
        ZE( countT , totalTallyWhat ) ;

        switchC& swTallyWhat12 = cToDo ? swTallyWhat1 : swTallyWhat2 ;
        countT&  idWhat12 = cToDo ? idWhat1 : idWhat2 ;
    {
    while( cToDo -- )
    countT cToDo = 2 ;
    OStEXT( ostoRpt , TOCK << 4 )        // 20180123@1526: TOCK -> TOCK << 4

    stackC stSorter( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( count3S ) ) ;

    }
        thirdC::dosSleepWinkIF( tinP ) ;

        }
            grabWhere.ungrabF( tinP ) ;
            //etThread.traceF( tinP , tSay0 ) ; //U:: COMMENT OUT IN PRODUCTION
            }
                }
                    }
                        }
                            }
                                ++ ( (countT&)swTally ) ;
    
                                c2Lever.c2 = where.pLFnest[ ( ( ( where.cInNest - cFoci ) & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
                                c2Lever.c1 = where.pLFnest[ ( ( ( where.cInNest - cFoci ) & OFFsLOTtINnESTmAX ) << 1 )     ] ;
                            {
                            if( bDo )

                            }
                                    if( pczFocus[ offFocus ] != where.pLFnest[ ( ( ( where.cInNest - offFocus ) & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ) bDo = 0 ;
                                for( countT offFocus = 0 ; bDo && offFocus < cFoci ; offFocus ++ )
                                countT* pczFocus = c8idiFileFocus ;
                            {
                            else
                            if( cFoci >= where.cInNest ) bDo = 0 ;
                            boolT bDo = 1 ;
                        {
                        else
                        }
                            ++ ( (countT&)swTally ) ;

                            }
                                countT foo = 2 ;
                            {
                            if( c2Lever.c2 == 0x33065 )

                            c2Lever.c2 = where.pLFnest[ ( ( where.cInNest & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
                            c2Lever.c1 = where.pLFnest[ ( ( where.cInNest & OFFsLOTtINnESTmAX ) << 1 )     ] ;
                        {
                        if( !cFoci )

                        //++ ( (countT&)swTallyWhat1 ) ;
                    {
                    //if( idWhat1 <= ifcIDwHAT_GOaDAM )
                    //if( idWhat1 <= 0x100 ) //CAN USE TO INVESTIGATE FIND LOCATION WITHIN A CODE SNIPPET

                    ++ ( (countT&)swTallyWhat2 ) ;
                    idWhat2 = where.idWhat2 ;

                    ++ ( (countT&)swTallyWhat1 ) ;
                    idWhat1 = where.idWhat1 ;

                    }
                        while( where.idDirty % 2 || where.idDirty != idDirtyVerify ) ;
                        }
                            idDirtyVerify = ppTinWhereI[ off ]->monitor.idDirty ;
                            thirdC::c_memcpyIF( tinP , pbWhere , (byteT*)&ppTinWhereI[ off ]->monitor , sizeof pbWhere ) ;
                        {
                        do
                        countT idDirtyVerify ; //INTENTIONALLY NOT INITIALIZED, FOR SPEED
                    {
                    whereS& where = *(whereS*)pbWhere ;
                    byteT pbWhere[ sizeof( whereS ) ] ;                    
                {
                if( ppTinWhereI[ off ] ) //U:: USE A grabC TO SERIALIZE SO DON'T GET BIT BY A DANGLING POINTER TO A DOOMED tinS, OBJECT
            {
            for( countT off = 0 ; off < cThreadsMaxWhereI ; off ++ )
            //etThread.traceF( tinP , tSay1 ) ; //U:: COMMENT OUT IN PRODUCTION
            grabWhere.grabF( tinP , TAG( TAGiDnULL ) ) ;
            //etThread.traceF( tinP , tSay2 ) ; //U:: COMMENT OUT IN PRODUCTION
        {
        if( cEnabledWhereI )
    {
    while( !etThread && !bQuitWhereI && !ether ) //COMMENT OUT !ether IF WANT TO LOOK AT QUIT BEHAVIOR
    //TN( tSay0 , "where is looking 0 napping " ) ; //U:: COMMENT OUT IN PRODUCTION
    //TN( tSay1 , "where is looking 1 got" ) ; //U:: COMMENT OUT IN PRODUCTION
    //TN( tSay2 , "where is looking 2 grabbing" ) ; //U:: COMMENT OUT IN PRODUCTION
    sgnReady.giveF( tinP ) ;
    switchC swTally( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pbLever , sizeof c2Lever ) ;
    const byteT* pbLever = (const byteT*)&c2Lever ;
    count2S c2Lever ;
    switchC swTallyWhat2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , idWhat2 ) ;
    ZE( countT , idWhat2 ) ;
    switchC swTallyWhat1( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , idWhat1 ) ;
    ZE( countT , idWhat1 ) ;
    countT  cFoci = etThread.strBodyLengthF( tinP , (countT*)c8idiFileFocus ) ;
    count8S c8idiFileFocus ;
    //count8S c8idiFileFocus( 0x4000611 ) ;
    //count8S c8idiFileFocus( 0x6000f71 , 0x5000a01 , 0x6000021 , 0x5000511 ) ;

    grabC&  grabWhere          =  *(grabC*)pTaskP->c7 ;
    countT& cThreadsMaxWhereI  = *(countT*)pTaskP->c6 ;
    tinS**  ppTinWhereI        =   (tinS**)pTaskP->c5 ;
    countT& idTypeReportWhereI = *(countT*)pTaskP->c4 ;
    countT& cEnabledWhereI     = *(countT*)pTaskP->c3 ;
    signC&  sgnReady           =  *(signC*)pTaskP->c2 ;
    boolT&  bQuitWhereI        =  *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
/*1*/TASK( tmWhereF )/*1*/

}
    return tally1 - tally2 ;
    if( tinP.fingerprint && pEther && c3P ) ;

    countT tally2 = *(countT*)c2P ;
    countT tally1 = *(countT*)c1P ;

    }
        if( !c1P || !c2P ) return 0 ;
    {
    IFbEcAREFUL
{
countT subtractTallyF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

