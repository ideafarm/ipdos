
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmcHttpServerWorkerF )

}
    }
        ++ s ; ether.osSleepF( tinP , TOCK >> 2 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;

        }
            stJobP.ungrabF( tinP ) ;

            }
                stJobP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                }
                    }
                        DELzOMBIE( pDoomed ) ;
                        dec02AM( jobP.cSession ) ;
                        taskDrivenServerJobS* pDoomed = &jobP ;

                        //etThread.traceF( tinP , T("DONE [cSession]:    ")+TF2(jobP.cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        /*etThread.delF( tinP , psttPeerP ) ;*/

                        jobP.sw_cSessionWithPeer.ungrabF( tinP ) ;
                        -- jobP.sw_cSessionWithPeer ;
                        jobP.lever_nnPeer = jobP.nnPeer ;
                        jobP.sw_cSessionWithPeer.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        jobP.sessions.unregisterConnectionF( tinP , jobP.nnPeer ) ;

                        }
                            jobP.b_lever_idSession.ungrabF( tinP ) ;
                            else                                                 __1
                            if( (countT)&psoP == (countT)&(countT&)jobP.sw_pso ) jobP.sw_pso.freeF( tinP ) ;
                            jobP.lever_idSession = jobP.idSession ;
                            DEL( psoP ) ;                                                                                                                               \
                            jobP.b_lever_idSession.grabF( tinP , TAG( TAGiDnULL ) ) ;                                                                                   \

                            etThread.etherDoHttpJobF( tinP , jobP , psoP , sessionP , idPortMeP , nnMeP ) ;
                            etThread.osTimeNowF( tinP , jobP.timeDoJob1 , jobP.timeDoJob2 ) ;

                            _IO_
                        {

                        TELL( "TASK: entering application code" )

                        }
                            /* }                                                                      */
                            /*     if( POOP ) { POOPR }                                               */
                            /*     }                                                                  */
                            /*         TELL( "returned from querying dns for peer name string" ) ;    */
                            /*         tinP.pEtScratch->sockPsttHostF( tinP , psttPeerP , nnPeerP ) ; */
                            /*         TELL( "querying dns for peer name string" ) ;                  */
                            /*     {                                                                  */
                            /*     if( nnPeerP.pcId[ 0 ] )                                            */
                            /* {                                                                      */
                            /* ZE( strokeS* , psttPeerP ) ;                                           */
                            /* THIS IS TOO SLOW (2 TOCKS)                                             */

                            if( POOP ) { POOPR ; }
                            psoP->myNameF( tinP , idPortMeP , nnMeP ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        nicNameC nnMeP ;
                        ZE( countT , idPortMeP ) ;

                        psoP->etherF( tinP , *tinP.pEtScratch ) ;
                        //etThread.traceF( tinP , T("TASKdRIVENsERVER [cSession]:    ")+TF2(jobP.cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( !etThread )
                    sessionC& sessionP = jobP.sessions.registerConnectionF( tinP , jobP.nnPeer , /*psttPeerP*/T("notQueried") ) ;

                    __Z( psoP ) ;
                    //etThread.traceF( tinP , T("U:: tmcHttpServerWorkerF / after ungrab") ) ;

                    jobP.b_lever_idSession.ungrabF( tinP ) ;
                    socketC*& psoP = (socketC*&)(countT&)jobP.sw_pso ;
                    jobP.lever_idSession = jobP.idSession ;

                    //tinP.pcUtility[ 0 ] = 0 ;
                    //tinP.pcUtility[ 1 ] = 0 ;
                    //tinP.pcUtility[ 2 ] = 0 ;
                    //tinP.pcUtility[ 3 ] = 0 ;

                    jobP.b_lever_idSession.grabF( tinP , TAG( TAGiDnULL ) ) ;

                    //tinP.pcUtility[ 3 ] = ((countT*)&jobCopy)[ 2 ] ;
                    //tinP.pcUtility[ 2 ] = ((countT*)&jobP)[ 2 ] ;
                    //tinP.pcUtility[ 1 ] = (countT)&jobP.b_lever_idSession ;
                    //tinP.pcUtility[ 0 ] = 0x12345678 ;
                    //etThread.traceF( tinP , T("U:: tmcHttpServerWorkerF / before grabbing") ) ;

                    TELL( "TASKdRIVENsERVER: setting up" )
                    TESTsCRATCH ;

                    etThread.osTimeNowF( tinP , jobP.timeJobPopped1 , jobP.timeJobPopped2 ) ;

                    //CONoUTrAW3( "tmcHttpServerWorkerF [&jobP.b_lever_idSession]:    " , &jobP.b_lever_idSession , "\r\n" ) ;
                    taskDrivenServerJobS& jobP = *(taskDrivenServerJobS*)_pbaJob ;
                {
                if( pbJob )

                stJobP.ungrabF( tinP ) ;

                stJobP >> pbJob ;
                byteT* pbJob = _pbaJob ;
                byteT _pbaJob[ sizeof( taskDrivenServerJobS ) ] ;

                //etThread.traceF( tinP , T("tmcHttpServerWorkerF popping a job [jobCopy[2]]:    ")+TF2(((countT*)&jobCopy)[2],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                //taskDrivenServerJobS jobCopy = *(taskDrivenServerJobS*)&(countT&)stJobP[ 1 ] ; //U:: TO FIND A BUG
            {
            while( stJobP )

            stJobP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( stJobP )
    {
    while( !ether )

    stackC& stJobP = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )

TELL( "preparing for work" ) ;
/*1*/TASK( tmcHttpServerWorkerF )/*1*/


/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

