
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUTbATONsTACKc_
    }
        ctF( tinP , bRestore ? &soul : 0 ) ;
        THREADmODE1rESTORE
        }
            }
                //__1 ;
                //NEXT LINE COMMENTED OUT TO ALLOW FILE TO NOT EXIST, IN WHICH CASE NO RESTORE IS DONE
                POOPR
            {
            else
            if( !POOP ) bRestore = 1 ;
            ((thirdC&)*tinP.pEtScratch).dosReadF( tinP , soul , hFile ) ;
            thirdC::dosOpenIF( tinP , tinP.pEther , hFile , countTC() , postOsFile , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_FAIL | flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , 0 , 0 , 1 ) ;
            handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            SCOOPS
        {
        IFsCRATCH
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        ZE( boolT , bRestore ) ;
        soulC soul( tinP , TAG( TAGiDnULL ) ) ;

        }
            thirdC::c_strncpyIF( tinP , postOsFile , postx , costa ) ;
            third.newF( tinP , LF , postOsFile , costa ) ; ___BITScT( postOsFile , 0xdeb ) ;
            const countT costa = third.c_strlenIF( tinP , postx ) + 1 ;
            osTextT* postx = osfn ;
            osFileNameC osfn( tinP , third , postFileP ) ;
        {
    {
    else
    if( !postFileP ) ctF( tinP ) ;

    }
        thirdC::c_memcpyIF( tinP , *(osTextT**)&postName , postNameP , 1 + costName ) ;
        thirdP.newF( tinP , LF , *(osTextT**)&postName , 1 + costName ) ; ___CT( postName ) ;
        countT costName = thirdC::c_strlenIF( tinP , postNameP ) ;
    {
    if( postNameP )

    _INbATONsTACKc_

    if( pBatonP ) { ___BITScT( pBaton , 0xdec ) ; }
    else            thirdC::c_memsetIF( tinP , (byteT*)pbBitsCt , sizeof pbBitsCt ) ;
    if( pbBitsCtP ) thirdC::c_memcpyIF( tinP , (byteT*)pbBitsCt , (byteT*)pbBitsCtP , sizeof pbBitsCt ) ;

    }
        if( third ) return ;
        FV( flSTACKc , flagsP ) ;
        if( third ) return ;
    {
    IFbEcAREFUL
    SCOOP

    ___CT( pBaton ) ;
{
)
    ) 
        //U:: ) 
            ) 
                sizeof( countT )
                :
                sizeof( timeS )
                ?
                idType == ifcSTACKtYPE_timeS
            (
        //U::     :
        //U::     SIZEOF_handleC
        //U::     ?
        //U::     idType == ifcSTACKtYPE_handleC
        //U:: (
        :
        processGlobal2I.cb_nicNameC_
        ?
        idType == ifcSTACKtYPE_nicNameC
    (
    :
    idTypeP
    ?
    F(flagsP) & flSTACKc_BLOB
(
cbData
pLeverLathRef( pLeverLathRefP ) ,
pXray( 0 ) ,
bDying( 0 ) ,
osTidOwner( 0 ) ,
cTabAge( 0 ) ,
pcTabIdSlot( 0 ) ,
ppTab( 0 ) ,
cTabs( 0 ) ,
pCbF( pCbFP ) ,
ranUni( tinP ) ,
flagsState( flSTACKsTATE_null ) ,
pbnu( 0 ) ,
pSgnEvent( 0 ) ,
cWaitingForEvent( 0 ) ,
bUp( 0 ) ,
idType( F(flagsP) & flSTACKc_BLOB ? ifcSTACKtYPE_BLOB : ( idTypeP ? idTypeP : ifcSTACKtYPE_countT ) ) ,
flags( idTypeP == ifcSTACKtYPE_measureT ? flagsP | flSTACKc_ALLOWzE : flagsP ) ,
recycleLever2( idTypeP ) ,
recycleLever1( flagsP ) ,
ppBottom( 0 ) ,
pSw_idLathRef( 0 ) ,
pSw_ppLathRef( 0 ) ,
pSw_idCursor(  0 ) ,
pSw_ppCursor(  0 ) ,
idLathRefDefault( 0 ) ,
ppLathRefDefault( 0 ) ,
idCursorDefault( 0 ) ,
ppCursorDefault( 0 ) ,
ppTop( 0 ) ,
postOsFile( 0 ) ,
poop( third ) ,
third( thirdP ) ,
cPlatesSnap( 0 ) ,
cPlates( 0 ) ,
bDoNotDeleteBaton( !!pBatonP ) ,
) ,
            //: new( 0 , tinP , LF ) batonC( tinP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , 0 , idGrabLayerP , flBATONc_NOTjEALOUS | flBATONc_SHARElAYER )
            : ( new( 0 , tinP , LF ) batonC( tinP , TAG( TAGiDnULL ) , 0 , idGrabLayerP , flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) )
            ? pBatonP
        : pBatonP
        ? 0
    F(flagsP) & flSTACKc_DOnOTsERIALIZE
(
pBaton
idiFileCt( idiFileCtP ) ,
idLineCt( idLineCtP ) ,
postName( 0 ) ,
baseSoilXxxxC( tinP.pAdamGlobal1->_stackC_.postOldClassName , postName ) ,
/*1*/stackC::stackC( tinS& tinP , thirdC& thirdP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const flagsT flagsP , const countT idTypeP , const countT idGrabLayerP , countT* pLeverLathRefP , const osTextT* const postFileP , cbFT pCbFP , const osTextT* const postNameP , batonC* const pBatonP )/*1*/ :

/**/
*/
     supporting 0 would not make sense because the caller would need at least 1 byteT of data to inspect to determine the length of the stored plate
    it must also not be 0
    this value must be not greater than cbData
   it is to return the number of bytes to copy
   this callback will receive the address of the source bytes
   if not 0 then will be called whenever a blob is to be put onto the stackC
  used only if flSTACKc_BLOB and blobs are not length prefixed
  if flSTACKc_BLOB and blobs are length prefixed then must be 0
  if not flSTACKc_BLOB then must be 0
  can be 0
 pCbFP
   it is implied by the flSTACKc_BLOB flag
  explicit specification of ifcSTACKtYPE_BLOB is illegal
    the value of this field is assigned into cbData, and ifcSTACKtYPE_BLOB is assigned into idType
   if flSTACKc_BLOB is set
      this enforcement can be defeated by using a cast
     if not 0, then the type declared here will be enforced
      for example, a pointer to a count4S object might be pushed, followed by a pointer to a string of strokeS objects
      if 0 then the stack object makes no assumptions about what the numbers placed on it are
     can be 0, unless flSTACKc_COPY is specified in flagsP
    this is a change from earlier behavior
    if 0 then ifcSTACKtYPE_countT is implied
    can be 0
   if flSTACKc_BLOB is not set
  the meaning of this field depends upon whether flSTACKc_BLOB is set in flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00100ae.ifcSTACKtYPE!||
 idTypeP
   when i am destroyed, if anyone is waiting for the sign, i will give it and wait for everyone to go away
   at least wo thread must use signC::waitF to wait for new plates to be added to or d eleted from the stack
  flSTACKc_GIVEsIGNnEWpLATE flSTACKc_GIVEsIGNdELpLATE
   when a stack object is being used to store countT values, the ability to specify flSTACKc_COPY would not be useful, so it is made illegal
  if flSTACKc_COPY is specified, then idTypeP must be neither 0 nor ifcSTACKtYPE_countT
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00100ad.flSTACK!||
 flagsP
 thirdP
arguments
an unlimited number of objects can be placed onto this stack object
constructs a stack object
  \<A HREF=\"5.bb10104.1.1.0.html\"\>bb10104:  WAKEsHOW( "example.simplest.func.1150001.stackC.stackC" )\</A\>
 simplest
examples
\<A HREF=\"5.1150001.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

