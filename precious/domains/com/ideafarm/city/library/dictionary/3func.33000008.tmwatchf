
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmWatchF )

//tinP.pc Utility[ 0 ] -- ; //U::TO FIND A BUG
}
    TELL( "tmWatchF: cleaning up" ) ;
    
    //}
    //    }
    //        }
    //            pRootI->letRefF() ;
    //            ((thirdC&)etp).winPostMessageF( tinP , *pRootI , idwm_CLOSE ) ;
    //        {
    //        if( pRootI )
    //        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;
    //
    //        etherC etp( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ;
    //        TELL( "posting CLOSE window message to the root window" ) ;
    //    {
    //    if( !( F(thirdC::third_flagsProcessStateI_IF(tinP)) & flPROCESSsTATE_WM_CLOSE_RECEIVED ) )
    //{
    //if( b_tmWindows )
    //U::CONJ: THIS IS OBSOLETED BY displayC AND IS NOW REDUNDANT WITH THE PRECEDING LINE

    if( pDisplay) ((thirdC&)etThread).winPostMessageF( tinP , *pDisplay , idwm_CLOSE ) ;
    displayC* pDisplay = displayC::pDisplayIF() ;
    
    while( !etThread && ( thirdC::third_idPhaseAdam_IF( tinP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAIN2 || cAllKidThreadsI + cAllOrphanThreadsI > 1 + 2 * b_tmWindows ) ) ; // tmWatchF tmWindowsF tmAnimateSadamsOnPaperF
    }
        }
            //U: MAYBE POPUP A BOX SAYING THAT I BECAME IMPOTENT BUT AM NOW POTENT AND WILL TRY AGAIN
            etThread = 0 ;
        {
        if( etThread )
    
        #endif
        }
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLpURGE  ) 
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLrEPORT ) 
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLoFF    ) 
            etThread.beeClickF( tinP , 0x3800 , TOCK ) ;
            }
                ++ s ; etThread.osSleepF( tinP , TOCK * 4 ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            etThread.beeClickF( tinP , 0x3800 , TOCK ) ;
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLoN     ) 
            bArmed = 0 ;
        {
        if( bArmed && ++ idTry >= 0x8 && !etThread && cAllKidThreadsI + cAllOrphanThreadsI > 1 + 2 * b_tmWindows )
        static boolT bArmed = 1 ;
        static countT idTry ;
        #if defined( NEVERdEFINED )
        //U:: DISABLED PENDING DEBUG AND TUNE OF 6a4
        TELL( "cleaning up for this cycle" ) ;
    
        }
            while( cAllKidThreadsI + cAllOrphanThreadsI > 1 + 2 * b_tmWindows && cTries -- ) { ++ s ; etThread.osSleepF( tinP , TUCK * 0x40 ) ; } // tmWindowsF tmAnimateSadamsOnPaperF
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        countT cTries = 0x10 ;
        TELL( "waiting until i and tmWindowsF and tmAnimateSadamsOnPaperF are the only child threads" ) ;
    
        if( stTasksWhenQuitting.third ) stTasksWhenQuitting.third = 0 ;
        //THIS BLOCK CAN RACE WITH OTHER THREADS, AFFECTING WHETHER THEY CAN REGISTER ACCEPTORS, CATCHERS, QUITTERS, ETC.
        //THIS IS BAD STYLE.  IT IS DONE HERE TO GIVE tmWatchF EVERY CHANCE TO SUCCEED
    {
    do
    
    countT& cFaceClientsI            = tinP.pAdamGlobal1->_etherC_.cFaceClients ;
    batonC& batFiringKids            = *tinP.pAdamGlobal1->_etherC_.pBatFiringKids ;
    boolT&  bNoNewKids               = tinP.pAdamGlobal1->_etherC_.bNoNewKids ;
    stackC& stTasksWhenQuitting      = *tinP.pAdamGlobal1->_thirdC_.pStkTasksWhenQuitting ;
    flagsT& flQuittingI              = tinP.pAdamGlobal1->_thirdC_.flQuitting ;
    countT& cAllOrphanThreadsI       = thirdC::os_cAllOrphanThreadsI_IF( tinP ) ;
    countT& cAllKidThreadsI          = thirdC::os_cAllKidThreadsI_IF( tinP ) ;
    TELL( "initializing references" ) ;
    
    ((thirdC&)etThread).thirdLaunchLateThreadsF( tinP ) ;
    TELL( "launching late threads" ) ;

    }
        if( tinP.pAdamGlobal1->_etherC_.pCalledWhenFiredF ) (*tinP.pAdamGlobal1->_etherC_.pCalledWhenFiredF)( tinP , tinP.pAdamGlobal1->_etherC_.pCalledWhenFiredArg ? *tinP.pAdamGlobal1->_etherC_.pCalledWhenFiredArg : ze ) ;
        ZE( countT , ze ) ;
    {

    tinP.pAdamGlobal1->flagsAdam |= flADAM_FIRED ;
    etThread.osThreadSwitchingDesireF( tinP , desireSave ) ;

    //}
    //    home.flags &= ~( F(flHOMEs_INoUTtRACE) ) ;
    //{
    //TELL( "resetting control flags (to default behavior)" ) ;

    }
        BLAMMO ;
        homeS::homeIF().flags |= flHOMEs_KILLsELFiMMEDIATELY ;
        thirdC::osFireIF( tinP ) ;
        etThread.traceF( tinP , T("calling osFireIF, setting flHOMEs_KILLsELFiMMEDIATELY, and then calling BLAMMO because a file existed in ")+tDirBlammo ) ;
        etThread.diskFileOrDirDeleteF( tinP , tDirBlammo , flFILEoRdIRdELETE_RECURSE , 1 ) ;
    {
    if( etThread.diskFileExistsF( tinP , tDirBlammo+T("*") ) )
    //DUPLICATE CODE: 33000008 33000008

    }
        ++ s ; etThread.osSleepF( tinP , TOCK ) ;
        TELL( "napping for a tock" ) ;

        //thirdC::osLogWrongNodeIF( tinP ) ;

#endif
        }
            LOGrAW( T("[time,idAdam,tallyAll]: ")+TT(timeN1,timeN2)+T("    ")+TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(tallyAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
        
            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
        
            }
                LOGrAW( T("    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(tally,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pczLever,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
            
                tallyAll += tally ;
                countT tally = swTally ;
                pczLever = (countT*)swTally.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swTally.cFlavorsF( tinP ) ;
            ZE( countT , tallyAll ) ;
            
            poolC::reportIF( tinP , pczLever , swTally ) ;
            switchC swTally( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , *(const countT**)&pczLever , 0 , 3 * sizeof( countT ) ) ;
            ZE( const countT* , pczLever ) ;
        
            LOGrAW3( "\r\npoolC tally report [idTick]: " , idCycle , "\r\n" ) ;
        {
        if( !( idCycle % ( TUCK << 0 ) ) ) //APPROXIMATELY ONCE PER TICK
        //if( !( idCycle % ( TUCK << 4 ) ) ) //APPROXIMATELY ONCE PER HOUR
#if defined( NEVERdEFINED )
//U:: 20210220@1114: REMOVE THIS OLD CODE, WHICH IS REPLACED WITH THE PRECEDING (OLD: ALL poolC INSTANCES.  NEW: ONLY THE CURRENT poolC INSTANCE

#endif
        }
            etRock.traceF( tinP , T("tmWatchF: traced pool tallies") ) ;
            etRock.tracePoolTalliesF( tinP ) ;
            etRock.traceF( tinP , T("tmWatchF: tracing pool tallies") ) ;
            etherC& etRock = etherC::etRockIF( tinP ) ;
        {
        if( !( idCycle % ( TUCK << 4 ) ) ) //APPROXIMATELY ONCE PER HOUR
#if defined( NEVERdEFINED )
//U:: COMMENTED OUT TO CONSERVE MEMORY WHILE STUDYING MEMORY USAGE

        //20210310@1246: ENABLED TO STUDY CHANNEL I/O BURN-IN TEST
        //20210228@0925: DISABLED
        //20210220@1100: ENABLED IN RESPONSE TO "OUT OF MEMORY" (CODE 8) WINDOWS ERROR
        //20130918@1315: THIS IS CPU COSTLY SO COMMENTED OUT.  AFAIK IT WORKS

        //}
        //    tinP.pAdamGlobal4->_adamC_grab.ungrabF( tinP ) ;
        //
        //    }
        //        pac = pac->pAdam ;
        //        pac->mannaF( tinP , 1.0 ) ;
        //    {                
        //    while( pac )
        //    adamC* pac = tinP.pAdamGlobal1->_adamC_pAdam ;
        //
        //    tinP.pAdamGlobal4->_adamC_grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
        //{
        //TELL( "distributing manna from heaven to adamC instances" ) ;
        //U::THIS IS DONE ACCORDING TO THE NUMBER OF SHARES THAT EACH adamC INSTANCE OWNS
        //U::SELL THE RESOURCE FLOW AND THEN DISTRIBUTE THE PROCEEDS EQUALLY TO ALL adamC INSTANCES THAT ARE ENTITLED TO A SHARE OF THAT

        if( !( idCycle % ( TUCK << 0 ) ) ) etThread.traceF( tinP , tSayTick ) ; //APPROXIMATELY ONCE PER TICK

        }
            }
                }
                    ++ s ; etThread.osSleepF( tinP , TOCK ) ;
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                {

                stQuitters.ungrabF( tinP ) ;
                }
                    while( !etThread && !stQuitters.third && ~handle ) ;
                    }
                        }
                            //*tinP.pEtScratch = 0 ;
                            hSoc.closeIfF() ; //U::ELIMINATING ALL USAGE OF "shutdown" WIN32 API
                            //CONoUTrAW3( "tmWatchF/closing quitter handle at " , (countT)&hSoc , "\r\n" ) ; //U::
                            //tinP.pEtScratch->sockCancelF( tinP , hSoc ) ;
                            //CONoUTrAW3( "********************* cancelling quitter socket " , (countT)pso , "\r\n" ) ;
                            //CONoUTrAW( "tmWatchF/cancelling a quitter socket\r\n" ) ;
                            handleC& hSoc = *(handleC*)&pso->handleF( tinP ) ;
                        {
                        if( pso )
                        __Z( pso ) ;
                        socketC* pso = (socketC*)stQuitters.downF( tinP , handle ) ;
                    {
                    do
                    handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( !etThread && !stQuitters.third && stQuitters )
                stQuitters.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            while( !etThread && !stQuitters.third && stQuitters )
            TELL( "canceling quitter sockets/+" ) ;
                
            }
                stCatchers.ungrabF( tinP ) ;
                }
                    while( !etThread && !stCatchers.third && ~handle ) ;
                    }
                        }
                            THREADmODE1rESTORE
                            }
                                if( POOP ) POOPR
                                sock.writeF( tinP , (countT)*pso , nicNameC() , ifcIDtYPEdATAGRAM_LETSaLLqUIT ) ;
                                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
                            {
                            SCOOPS
                            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //LEGACYwORKAROUND
                        {
                        if( pso ) 
                        __Z( pso ) ;
                        socketC* pso = (socketC*)stCatchers.downF( tinP , handle ) ;
                    {
                    do
                    handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( !etThread && stCatchers )
                stCatchers.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            IFsCRATCH
            TELL( "releasing threads blocked catching socket datagrams" ) ;
                
            stAcceptors.ungrabF( tinP ) ;
            }
                while( !etThread && !stAcceptors.third && ~handle ) ;
                }
                    }
                        THREADmODE1rESTORE
                        }
                            if( POOP ) POOPR
                            sock.connectF( tinP , (countT)*pso ) ;
                            socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //LEGACYwORKAROUND
                    {
                    if( pso ) 
                    __Z( pso ) ;
                    socketC* pso = (socketC*)stAcceptors.downF( tinP , handle ) ;
                {
                do
                handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( !etThread && stAcceptors )
            stAcceptors.grabF( tinP , TAG( TAGiDnULL ) ) ;
            TELL( "releasing threads blocked listening for new socket client connections" ) ;
        {
        if( ether )    

        stIdleTimeouters.ungrabF( tinP ) ;
        }
            while( !etThread && !stIdleTimeouters.third && ~handle ) ;
            }
                if( pso ) pso->cancelIfTimedOutF( tinP ) ;
                __Z( pso ) ;
                socketC* pso = (socketC*)stIdleTimeouters.downF( tinP , handle ) ;
            {
            do
            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( !etThread && stIdleTimeouters )
        stIdleTimeouters.grabF( tinP , TAG( TAGiDnULL ) ) ;
        if( stIdleTimeouters.third    ) stIdleTimeouters.third    = 0 ;
        TELL( "canceling sockets that are timed out" ) ;

        }
            }
                home.flags &= ~( F(flHOMEs_INoUTtRACE) ) ;
                if( F(home.flags) & flHOMEs_INoUTtRACE ) etThread.traceF( tinP , T("flHOMEs_INoUTtRACE turned off") ) ;
            {
            else
            }
                home.flags |= flHOMEs_INoUTtRACE ;
                if( !( F(home.flags) & flHOMEs_INoUTtRACE ) ) etThread.traceF( tinP , T("flHOMEs_INoUTtRACE turned on") ) ;
            {
            else if( etThread.diskFileExistsF( tinP , T("///ideafarm/controls/on/in.out.trace.txt") ) )
            }
                etThread.traceF( tinP , T("flHOMEs_INoUTtRACE off (control file created)") ) ;
                etThread.boxPutF( tinP , T("///ideafarm/controls/off/in.out.trace.txt") , "The contents of this file do not matter.\r\nTo save space, use any plain text editor to make this an empty file.\r\nIf you delete this file, it wll be recreated in its default control directory.\r\nTo turn this control on or off, move this file to the \"on\" or the \"off\" folder." ) ;
            {
            if( !etThread.diskFileExistsF( tinP , T("///ideafarm/controls/off/in.out.trace.txt") ) && !etThread.diskFileExistsF( tinP , T("///ideafarm/controls/on/in.out.trace.txt") ) )

            etThread.diskMakeDirF( tinP , T("///ideafarm/controls/on/") ) ;
            etThread.diskMakeDirF( tinP , T("///ideafarm/controls/off/") ) ;
        {
        TELL( "setting/resetting control flags" ) ;
        
        }
            pRootI->letRefF() ;
                
            //Shell_NotifyIcon( NIM_ADD , &info ) ;
            //    
            //thirdC::c_strncpyIF( tinP , info.szTip , oston , sizeof info.szTip ) ;
            //}
            //    OStEXTAK( oston , ")" )
            //    OStEXTC(  oston , processGlobal1I.idHome , 0 )
            //    OStEXTAK( oston , " (Home " )
            //{
            //if( processGlobal1I.idHome > 1 )
            //OStEXTAK( oston , "IPDOS (tm) IdeaFarm " "(tm) Piggyback Distributed Operating System" )
            //OStEXT( oston , 0x80 )
            //    
            //info.hIcon = LoadIcon( (HINSTANCE)thirdC::third_hWindowingClientIF( tinP ).osF( ifcIDtYPEhANDLE_WINDOWINGcLIENT ) , MAKEINTRESOURCE( 1 ) ) ;
            //info.uCallbackMessage = idwm_TASKbARiCON ;
            //info.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP ;
            //info.uID = 0x1 ;
            //info.hWnd = (HWND)( (const handleC&)*pRootI ).osF( ifcIDtYPEhANDLE_WINDOW ) ;
            //info.cbSize = sizeof info ;
            //NOTIFYICONDATA info ;
        {
        if( pRootI )
        windowOldC* pRootI = windowOldC::getRefIF( tinP ) ;

        tinP.pAdamGlobal5->grabGrabWatch.ungrabF( tinP ) ;
        if( tinP.pAdamGlobal1->pGrabWatch ) thirdC::dosBeepIF( tinP , TUCK * ( 1 + !!tinP.pAdamGlobal1->pGrabWatch->cGrabbedF() ) , TUCK ) ;
        tinP.pAdamGlobal5->grabGrabWatch.grabF( tinP , TAG( TAGiDnULL ) ) ;

        }
            }
                etThread.etherFireImpersonateMonitorIF( tinP ) ;
                LOGrAW3( "adam " , tinP.pAdamGlobal1->idAdam ,  "'s tmWatchF cannot see the driver\r\n" ) ; // ifcIDaDAM_CLOAK IS EXEMPT BECAUSE CLOAK LAUNCHES WOTH AND LAUNCHES THE DRIVER/MONITOR AS OF 20200525@1817
            {
            if( !( processGlobal1I.idHome & 0xff000000 ) && !thirdC::osTestWaterIF( tinP , ifcIDtYPEtESTwATER_LOOKfORdRIVER ) )

            }
                etThread.etherFireImpersonateMonitorIF( tinP ) ; // 20200620@1605: ENABLED THIS WITHOUT ANALYSIS (VERSIONING ENFORCEMENT USES A DNS RECORD)
                LOGrAW3( "adam " , tinP.pAdamGlobal1->idAdam ,  "'s tmWatchF sees that this version has been refused\r\n" ) ;
            {
            if( F(home.flags) & flHOMEs_VERSIONrEFUSED )
        {
        )
            )
                && !thirdC::osTestWaterIF( tinP , ifcIDtYPEtESTwATER_LOOKfORdRIVER )
                && !( processGlobal1I.idHome & 0xff000000 )
                   tinP.pAdamGlobal1->idAdam != ifcIDaDAM_CLOAK
            (
            ||
            F(home.flags) & flHOMEs_VERSIONrEFUSED
        (
        /*else*/ if
        //THIS APPEARS TO BE NECESSARY BECAUSE GUI PROCESS GetCommandLine() DOES NOT PROVIDE THE EXE FILE'S PATH, SO IS FLAGGED AS HOMELESS (BUT NOT WHEN RUN IN WDW)
        //U::COMMENTED OUT AS A WORKAROUND WHILE GETTING GUI PROCESS TO WORK

        //if( cSkip && cSkip -- ) ; //GIVES THIS PROCESS TIME TO GET STARTED AOK (SOME PROCESSES FAIL IF FIRED VERY EARLY DURING STARTUP)
        //S: SECURITY HOLE: SKIPPING LIKE THIS WILL ALLOW CODE TO DO LOTS OF WORK IN THE 02 TOCKS BEFORE THE VERSION REFUSAL BECOMES EFFECTIVE

        }
            etThread.etherFireImpersonateMonitorIF( tinP ) ;
            LOGrAW5( "adam " , tinP.pAdamGlobal1->idAdam ,  "'s tmWatchF sees that group " , tinP.pAdamGlobal1->idGroupFireAll , " has been fired\r\n" ) ;
        {
        if( tinP.pAdamGlobal1->idGroupFireAll && tinP.pAdamGlobal1->idGroupFireAll <= CfIREaLLrANKS && home.pFireAll[ tinP.pAdamGlobal1->idGroupFireAll - 1 ].bFire )
        thirdC::dosPriorityProcessIF( tinP ) ; //THIS ENFORCES RULE THAT USER CANNOT CHANGE THE PRIORITY CLASS OF AN IFC PROCESS; (IFC MAKES THIS ASSUMPTION SO THAT IT CAN USE YIELD WITHOUT HAVING CPU SPINS)

        //CONoUTrAW5( "tmWatchF [ether,cThreadsWatched]: " , ether , " " , tinP.pAdamGlobal1->cThreadsWatched , "\r\n" ) ;

        }
            }
                }
                    }
                        etRock.traceF( tinP , (strokeS*)postr , flTRACE_PARAMETERiSoStEXT /*| flTRACE_NOpREFIX*/ | flTRACE_KEEPcRlF ) ;
                        etherC::ifcBitDumpIF( tinP , postr + sizeof postProlog - 1 , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;
                
                        thirdC::c_strcpyIF( tinP , postr , postProlog ) ;
                        static osTextT postProlog[] = "memory readability dump:\r\n" ;
                        static byteT postr[ TUCK + CBrEADABILITYmAPdUMP ] ; // NOT THREAD SAFE WHEN A PROCESS IS RUNNING MULTIPLE ADAMS  U:: USE THE STACK SO IS THREAD SAFE
                    {
                    if( cbaNeeded == CBrEADABILITYmAPdUMP )
                                    
                    countT cbaNeeded = etherC::ifcBitDumpIF( tinP , 0 , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;
                    countT cbGrain = thirdC::osMemoryReadabilityMapIF( tinP , pbBits , sizeof pbBits ) ;
                                    
                    static byteT pbBits[ TUCK << 4 ] ; //EACH LINE OF REPORT WILL REPRESENT 1 TICK OF MEMORY
                {
                // TRACE OUT A MEMORY READABILITY MAP TO SHOW HOW MUCH MEMORY OF THE ADDRESS SPACE IS NOT YET COMMITTED
        
                etRock.traceF( tinP , T("tmWatchF: traced  pool tallies") ) ;
                etRock.tracePoolTalliesF( tinP ) ;
                etRock.traceF( tinP , T("tmWatchF: tracing pool tallies") ) ;
        
                etherC& etRock = etherC::etRockIF( tinP ) ;
            {
            else
            if( !bTraceMemoryReadability ) ; // etRock.traceF( tinP , T("not tracing memory usage [idAdam]:    ")+TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        if( !( idCycle % ( TUCK >> 1 ) ) )

        if( ++ idCycle > TUCK >> 4 && !( idCycle % 0x10 ) ) poolC::deleteEmptiesIfIF( tinP ) ; // SUPPRESSED FOR WOTH 01 TOCK TO ALLOW adamMainF TO CALL pMainF AND pMainF TO DO ITS INITIALIZATION ; THIS IS AN OPTIMIZATION TO AVOID UNNECESSARY DT/CT OF sexC INSTANCES WITH SAME SPECIFICATIONS

        }
            BLAMMO ;
            homeS::homeIF().flags |= flHOMEs_KILLsELFiMMEDIATELY ;
            thirdC::osFireIF( tinP ) ;
            etThread.traceF( tinP , T("calling osFireIF, setting flHOMEs_KILLsELFiMMEDIATELY, and then calling BLAMMO because a file existed in ")+tDirBlammo ) ;
            etThread.diskFileOrDirDeleteF( tinP , tDirBlammo , flFILEoRdIRdELETE_RECURSE , 1 ) ;
        {
        if( etThread.diskFileExistsF( tinP , tDirBlammo+T("*") ) )
        //DUPLICATE CODE: 33000008 33000008

        }
            BLAMMO ;
            etThread.traceF( tinP , T("etRock is impotent") ) ;
        {
        if( etRock )
    {
    while( ( !ether || tinP.pAdamGlobal1->cThreadsWatched > b_tmWindows << 1 ) && !etThread ) // tmWindowsF tmAnimateSadamsOnPaperF
    TN( tSayTick , "tick" ) ;
    TN( tDirBlammo , "///ideafarm/controls/blammo/" ) ;

    //}
    //    }
    //        if( !etThread.strCompareF( tinP , psttc1 , tHit ) ) bTraceMemoryReadability = 1 ;
    //    {
    //    FORsTRINGSiN1( pstt1Param )
    //    TN( tHit , "zap..CDN_ACCESS_LOGS" ) ;
    //    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tinP ) ;
    //{
    //if( tinP.pAdamGlobal1->idAdam == ifcIDaDAM_CLOUD )

    //ZE( boolT , bTraceMemoryReadability ) ;

    ;
        tinP.pAdamGlobal1->idAdam == ifcIDaDAM_KERNEL2MONITOR
           //tinP.pAdamGlobal1->idAdam == ifcIDaDAM_ROOThTTPsERVER
    boolT bTraceMemoryReadability =                                  //U:: TO FIND A LEAK (DISABLE THIS IN PRODUCTION)

    countT desireSave = etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZY ) ;

    const boolT b_tmWindows = !!( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_tmWindows ) ;
    //if( stQuitters.third          ) stQuitters.third          = 0 ;
    //if( stCatchers.third          ) stCatchers.third          = 0 ;
    //if( stAcceptors.third         ) stAcceptors.third         = 0 ;
    stackC& stQuitters               = *tinP.pAdamGlobal1->_etherC_.pStkQuitters ;
    stackC& stCatchers               = *tinP.pAdamGlobal1->_etherC_.pStkCatchers ;
    stackC& stAcceptors              = *tinP.pAdamGlobal1->_etherC_.pStkAcceptors ;
    stackC& stIdleTimeouters = *tinP.pAdamGlobal1->_etherC_.pStkIdleTimeouters ;
    ZE( countT , idCycle ) ;
    //countT cSkip = 0x20 ;
    TN( tb , " " ) ;

    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    ZE( countT , idLook ) ;
    homeS& home = homeS::homeIF() ;

    tinP.unwatchedF() ;

    //U:://--------------------------------------------------------------------------
    //U::
    //U::    else if( getNegAM( pcn[ 0 ] ) != FINGERnEG_NAPfIREcELLmONITOR ) { BLAMMO ; }
    //U::    else if( napFireAll != 2 * sizeof( countT ) + CfIREaLLrANKS * sizeof( fireAllS ) ) { BLAMMO ; }
    //U::    }
    //U::        napFireAll.formattingIsDoneF( tinP ) ;
    //U::        putNegAM( pcn[ 0 ] , FINGERnEG_NAPfIREcELLmONITOR ) ;
    //U::        pcn[ 1 ] = processGlobal1I.idAdamRoot ;
    //U::
    //U::        for( countT off = 0 ; off < CfIREaLLrANKS ; off ++ ) home.pFireAll[ off ].bFire = home.pFireAll[ off ].cHeartBeats = home.pFireAll[ off ].cHearts = 0 ;
    //U::        fireAllS* home.pFireAll = (fireAllS*)( pcn + 2 ) ;
    //U::    {
    //U::    else if( !( F(napFireAll.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
    //U::    if( !pcn ) { BLAMMO ; }
    //U::    countT* pcn = (countT*)(byteT*)napFireAll ;
    //U::    /* THIS IS CREATE SO THAT THE CELL MONITOR CAN BE RUN WITHOUT THE DRIVER (FOR DEBUGGING) */
    //U::    napkinC napFireAll( tinP , LF , (byteT*)bits , "tmWatchF/napFireAll" , 0 , 2 * sizeof( countT ) + CfIREaLLrANKS * sizeof( fireAllS ) ) ;
    //U::    bitsC bits( tinP , CbITSlIFI , 0 , 1 ) ;
    //U::    /*CODE SYNCH: 1610009 0010262*/
    //U::
    //U:://--------------------------------------------------------------------------

    TELL( "waiting for asynch impotence" ) ;
    //__( tinP.monitor.idThread - ifcIDtHREADlOW_tmWatchF ) ;

    }
        sgnWatchReady.giveF( tinP ) ;
        sgnWindowsReady.waitF( tinP ) ;

        signC& sgnWindowsReady = *(signC*)pTaskP->c2 ;
        signC& sgnWatchReady   = *(signC*)pTaskP->c1 ;
    {
    //I CANNOT JUST LAUNCH tmWatchF LATER BECAUSE THAT WOULD CHANGE idThread VALUES FOR SYSTEM THREADS (MY idThread WOULD DEPEND UPON WINDOWING AND PROBABLY ALSO ON A RACE CONDITION INVOLVING THREAD STARTUP)
    //THIS BLOCK IS TO ENSURE THAT tmWindowsF AND tmAnimateSadamsF GET STARTED BEFORE I CHECK FOR THEIR PRESENCE
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
//tinP.pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
/*1*/TASK( tmWatchF )/*1*/
/**/
*/
/*

/**/
*/
then i cause tmWindowsF to end
i wait for all other child threads other than tmWindowsF to end
\<A HREF=\"5.0b00013.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$tmWatchF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

