
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.ifcSayF( tinP , T("final aok\r\n") , flSAY_APPEND | flSAY_LOG ) ;

}
    DEL( pLake ) ;
    etUsesPoolPrime.delF( tinP , pbPackLag ) ;
    TELL( "cleaning up" ) ;
    }
        else if( bMake ) etThread.osSleepF( tinP , TICK ) ;
        if( bWoPass ) break ;
        //etThread.ifcSayF( tinP , T("bf30104 cycle ")+tIdCycle+T(" this cycle has ended") , flSAY_APPEND | flSAY_LOG ) ;
        TELL( "ending a cycle" ) ;

        }
            ether.beeClickF( tinP , 0x200 , TOCK * 1 ) ;
            //etThread.ifcSayF( tinP , T("bf30104 cycle ")+tIdCycle+T(" a fresh pack file has been made") , flSAY_APPEND | flSAY_LOG ) ;
            makePackF( tinP , ether , etThread , st1 , st2 , st3 , st4 , bTest , state ) ;
            //etThread.ifcSayF( tinP , T("bf30104 cycle ")+tIdCycle+T(" beginning to make a fresh pack file") , flSAY_APPEND | flSAY_LOG ) ;
            ether.beeClickF( tinP , 0x100 , TOCK * 1 ) ;
            TELL( "making a pack of fish" ) ;
        {
        if( !ether && bMake )

        }
            ether.beeClickF( tinP , 0x800 , TOCK * 1 ) ;
            if( !ether ) etThread.ifcSayF( tinP , T("bf30104 cycle ")+tIdCycle+T(" the current pack file is loaded") , flSAY_APPEND | flSAY_LOG ) ;
            loadPackF( tinP , ether , etThread , etUsesPoolPrime , pLake , pbPackLag ) ;
            //etThread.ifcSayF( tinP , T("bf30104 cycle ")+tIdCycle+T(" beginning to load the current pack file") , flSAY_APPEND | flSAY_LOG ) ;
            ether.beeClickF( tinP , 0x700 , TOCK * 1 ) ;
            TELL( "loading a pack of fish into the lake" ) ;
        {
        if( bLoad )

        TN( tIdCycle , "" ) ; tIdCycle = TF1(++idCycle) ;
        TELL( "beginning a cycle" ) ;
    {
    while( !ether && !etThread )
    ZE( lakeC* , pLake ) ;
    ZE( countT , idCycle ) ;
    ZE( byteT* , pbPackLag ) ;
    etherC etUsesPoolPrime( tinP , TAG( TAGiDnULL ) ) ;
    stateS state( tinP , etThread ) ;
{

setupF( tinP , etThread , st1 , st2 , st3 , st4 , bTest ) ;
stackC st4( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
stackC st3( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
stackC st2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
stackC st1( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;

//U:etThread.flagsMode |= flTHIRDmODE_CHECKpOOLoLD ;

etThread.ifcSayF( tinP , T("IdeaFarm " "(tm) City Publisher\r\ni periodically write the city knowledge tree and associated html files\r\n") , flSAY_APPEND | flSAY_LOG ) ;
TN( tLog , "///d/log.ifc.html" ) ;

const boolT bLoad   = etThread.etherParameterF( tinP , T("!load")   ) ;
const boolT bMake   = etThread.etherParameterF( tinP , T("!make")   ) ;
const boolT bTest   = etThread.etherParameterF( tinP , T("!test")   ) ;
const boolT bWoPass = etThread.etherParameterF( tinP , T("!woPass") ) ; //U: THESE ARE OBSOLETE NOW THAT I CYCLE CONTINUOUSLY AS PART OF ifc11 SYSTEM

//etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_LAZIEST ) ; // I ALSO TAKE NAPS FREQUENTLY TO MAKE EXTRA SURE THAT I DO NOT INTERFERE WITH HTTP SERVICE
((thirdC&)etThread).third_bWatchful_F( tinP ) = 0 ;
TELL( "preparing for work" ) ;
TODO

// ---- LOAD PACK: END --------------------------------------------------------------------------------------------------------------------------------------------

}
    }
        }
            }
                }
                    __( !poolC::poolOldRootIF( tinP ).offNewMinF( tinP ) ) ;
                    }
                        poolC::poolOldRootIF( tinP ).poolOldDelIF( tinP , (voidT*)pbPad ) ; pbPad = 0 ;
                        poolC::poolOldRootIF( tinP ).flagsBackF( tinP ) &= ~( F(flPOOLoLDbACK_NOcURSORrESET) ) ;
                        poolC::poolOldRootIF( tinP ).setPoolNewMinF( tinP ) ;
                        }
                            db.idiOwner     = tinP.idiOwner ;
                            db.cbUsedReally = cba ;
                            db.idType       = ifciDtYPEdROPnOTE_byteT ;
                            //DROPnOTErEF( pbPad ) ;
                        {
                        if( pbPad )
                        byteT* pbPad = (byteT*)poolC::poolOldRootIF( tinP ).poolNewF( tinP , LF , cba ) ; ___( pbPad ) ;
                        countT cba = cbSoFar * 2 ;
                    {
                    __( !!poolC::poolOldRootIF( tinP ).offNewMinF( tinP ) ) ;
    
                    }
                        poolC::poolOldRootIF( tinP ).poolOldDelIF( tinP , (voidT*)pbAt ) ; pbAt = 0 ;
                        cbSoFar = ap_artmentOldC( tinP , pbAt ) ;
                        }
                            db.idiOwner     = tinP.idiOwner ;
                            db.cbUsedReally = 0 ;
                            db.idType       = ifciDtYPEdROPnOTE_byteT ;
                            //DROPnOTErEF( pbAt ) ;
                        {
                        if( pbAt )
                        byteT* pbAt = (byteT*)poolC::poolOldRootIF( tinP ).poolNewF( tinP , LF , 0 ) ; ___( pbAt ) ;
                    {
                    ZE( countT , cbSoFar ) ;
                {
                if( !bNewMinIsSet )
    
                }
                    stockOneImageFishF( tinP , etThread , lake , pcNameFlag  , T("///d/ideafarm.work/backed.up.daily/images/gif/flag.100x50.gif") , T("image/gif" ) , bNewMinIsSet ) ;
                    stockOneImageFishF( tinP , etThread , lake , pcNameMural , T("///d/ideafarm.work/backed.up.daily/images/jpeg/mural.jpg"      ) , T("image/jpeg") , bNewMinIsSet ) ;
                    //stockOneImageFishF( tinP , etThread , lake , pcNameFlag  , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/image/gif/flag.100x50.gif") , T("image/gif" ) , bNewMinIsSet ) ;
                    //stockOneImageFishF( tinP , etThread , lake , pcNameMural , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/image/jpg/mural.jpg"      ) , T("image/jpeg") , bNewMinIsSet ) ;
                    countT pcNameFlag[]  = { 2 , 1 , 0 } ;
                    countT pcNameMural[] = { 2 , 2 , 0 } ;
                {
    
                //etThread.ifcSayF( tinP , T("time to load ")+TF1(cPacks)+T(" packs containing ")+T(cFish)+T(" fish into the lake: ")+TT(time1b,time2b) , flSAY_APPEND | flSAY_LOG ) ;
                etThread.osTimeSubtractF( tinP , time1b , time2b , time1as , time2as ) ;
                etThread.osTimeNowF( tinP , time1b , time2b ) ;
                ZE( sCountT , time2b ) ;
                ZE( countT , time1b ) ;
            {
            if( !ether && !etThread )
    
            time2a = time2bs ;
            time1a = time1bs ;
            etThread.osTimeSubtractF( tinP , time1b , time2b , time1a , time2a ) ;
            sCountT time2bs = time2b ;
            countT time1bs = time1b ;
            etThread.osTimeNowF( tinP , time1b , time2b ) ;
            ZE( sCountT , time2b ) ;
            ZE( countT , time1b ) ;
    
                                              //WO APPROACH: USE THE WO'TH NAME VALUE AS A SERIAL NUMBER AND PASS THROUGH THE ENTIRE LAKE DELETING SERIAL NUMBERS BELOW OR AT THE BACKING PACK THAT IS ABOUT TO BE DELETED
                                              //U: IF A FISH BECOMES OBSOLETE WITHOUT BEING REPLACED, IT WILL REMAIN IN THE LAKE EVEN THOUGH THE pbPack THAT IT POINTS TO HAS BEEN DELETED
            pbPackLagP = pbPack ; pbPack = 0 ; //pbPack CANNOT BE DELETED UNTIL AFTER ALL FISH THAT REFER TO IT ARE DELETED
            etUsesPoolPrime.delF( tinP , pbPackLagP ) ;
            }
                etThread.delF( tinP , pcName ) ;
                etThread.delF( tinP , psttw ) ;
                }
                    }
                        THREADmODE1rESTORE
                        lake.writeF( tinP , pcName , pbBlob , cbBlob , 1 ) ;
                        THREADmODE1oN( flTHREADmODE1_POOLoLDsECTION1 ) ;
                    {
                    else
                    if( !bNewMinIsSet ) lake.writeF( tinP , pcName , pbBlob , cbBlob , 1 ) ;
    
                    pcName[ off ] = 0 ;
                    }
                        etThread.delF( tinP , psttn ) ;
                        }
                            if( !pcName[ off ] ) pcName[ off ] = - 1 ;
                            etThread.delF( tinP , psttn2 ) ;
                            pcName[ off ] = dict( psttn2 ) ;
                            etThread.strSubstringF( tinP , psttn2 , idf , idl , psttn ) ; ___( psttn2 ) ;
                            ZE( countT , idl ) ;
                            countT idf = 2 ;
                            ZE( strokeS* , psttn2 ) ;
                        {
                        else
                        if( 1 != etThread.strIdF( tinP , sttDollar , psttn ) ) pcName[ off ] = etThread.strDigitsToSCountF( tinP , psttn ) ;
                        etThread.strSubstringLineF( tinP , psttn , idf , sttq , psttw , 1 , T(".") ) ; ___( psttn ) ;
                        ZE( strokeS* , psttn ) ;
                    {
                    for( countT off = 0 ; off < cWords ; off ++ )
                    //sttq = ze ;
                    countT idf = 1 ;
                {
                if( pcName )
    
                etThread.newF( tinP , LF , pcName , cWords + 1 ) ; ___( pcName ) ;
                ZE( countT* , pcName ) ;
                countT cWords = etThread.strCLinesF( tinP , psttw , T(".") ) ;
    
                /*if( !( cFish % 0x100 ) )*/ etherC::ifcSayIF( TF1(cFish)+T(": \"")+T(psttName)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
    
                etThread.strWordF( tinP , psttw , psttName , sttq , S1C('/') , - 1 ) ; ___( psttw ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttw ) ;
    
                byteT*   pbBlob   = (byteT*)  ( pbPack + off ) ; off += cbBlob ;
                countT   cbBlob   = *(countT*)( pbPack + off ) ; off += sizeof( countT ) ;
                strokeS* psttName = (strokeS*)( pbPack + off ) ; off += sizeof( strokeS ) * ( CSpREFIX + psttName->idAdam ) ;
    
                cFish ++ ;
            {
            while( !ether && !etThread && off < cbPack )
            countT off = sizeof( countT ) ;
    
            }
                etThread.boxPutF( tinP , tPackLoaded , (byteT*)&c2l , sizeof c2l ) ;
                etThread.osTimeNowF( tinP , c2l.c1 , (sCountT&)c2l.c2 ) ;
                count2S c2l ;
            {
    
            //U:if( !etThread ) { __( *(countT*)pbPack - /*U:ifcIDfILEtYPE_PACKED*/0x29978341 ) ; }
            __( !poolC::poolOldRootIF( tinP ).bMineF( tinP , pbPack ) ) ;
            if( !etThread ) { __( cbPack < sizeof( countT ) ) ; }
            __( etUsesPoolPrime ) ;
            etUsesPoolPrime.boxGetShadowF( tinP , pbPack , cbPack , tPack ) ; ___( pbPack ) ;
            ZE( countT , cbPack ) ;
            ZE( byteT* , pbPack ) ;
        {
        if( !ether )

        while( !ether && etThread.diskFileExistsF( tinP , tPackLoaded ) ) ether.osSleepF( tinP , TOCK * 0x10 ) ;

        if( !bNewMinIsSet ) poolC::poolOldRootIF( tinP ).flagsBackF( tinP ) |= flPOOLoLDbACK_NOcURSORrESET ;
        const boolT bNewMinIsSet = !!poolC::poolOldRootIF( tinP ).offNewMinF( tinP ) ;
        ZE( countT , cFish ) ;
        ZE( countT , cPacks ) ;
        strokeS sttDollar( '$' ) ;
        dictionary1C dict( tinP , etThread ) ;

        sCountT time2as = time2a ;
        countT time1as = time1a ;
        etThread.osTimeNowF( tinP , time1a , time2a ) ;
        ZE( sCountT , time2a ) ;
        ZE( countT , time1a ) ;

        TN( tPackLoaded , "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/pack.loaded." ) ; tPackLoaded += TF1(etThread.diskIdF(tinP,T("///c"))) ;
        TN( tPack       , "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/pack" ) ;

        lakeC& lake = *pLakeP ;
    {
    if( pLakeP )
    TN( tLog , "///d/log.ifc.html" ) ;

    if( !pLakeP ) pLakeP = new( 0 , tinP , LF ) lakeC( tinP , etThread ) ;
{
voidT loadPackF( tinS& tinP , etherC& ether , etherC& etThread , etherC& etUsesPoolPrime , lakeC*& pLakeP , byteT*& pbPackLagP )
*/
  write the 2 image fish
    writes the blob to the lake, using name pcName
     if the '.' word begins with '$', the remaining substring is queried in the dictionary
    set pcName using the '.' words in the last '/' word in name
    get psttName cbBlob pbBlob
   for each fish
   initialize offset to sizeof( countT )
   read the pack box 
  for each pack file (no wildcard is used, so always just processes -the- pack file
 while not fired
pseudocode
/*

}
    //etherC::ifcSayIF( T("stockOneImageFishF: ")+TF1(pcP)+T("  \"")+T(psttP)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
    etThread.delF( tinP , pbBlob ) ;
    }
        THREADmODE1rESTORE
        lakeP.writeF( tinP , pcP , pbBlob , cbBlob , 1 ) ;
        THREADmODE1oN( flTHREADmODE1_POOLoLDsECTION1 ) ;
    {
    else
    if( !bNewMinIsSetP ) lakeP.writeF( tinP , pcP , pbBlob , cbBlob , 1 ) ;

    etThread.delF( tinP , pbi ) ;
    etThread.memCopyF( tinP , pbBlob + cb0 , pbi , cbi ) ;
    etThread.memCopyF( tinP , pbBlob       , t0  , cb0 ) ;
    etThread.newF( tinP , LF , pbBlob , cbBlob ) ; ___( pbBlob ) ;
    cbBlob = cb0 + cbi ;
    countT cb0 = t0.csF( tinP ) ;

    textC t0 = T("HTTP/1.0 200 OK\r\nContent-Type: ")+T(psttTypeP)+T("\r\nContent-Length: ")+TF4(cbi,flFORMAT_FILLzE|flFORMAT_NObASE|flFORMAT_FOREIGN,8,0xa)+T("\r\n\r\n") ;

    etThread.boxGetShadowF( tinP , pbi , cbi , psttP ) ; ___( pbi ) ;
    ZE( countT , cbi ) ;
    ZE( byteT* , pbi ) ;
    ZE( countT   , cbBlob ) ;
    ZE( osTextT* , pbBlob ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
{
voidT stockOneImageFishF( tinS& tinP , etherC& etThread , lakeC& lakeP , const countT* const pcP , const strokeS* const psttP , const strokeS* const psttTypeP , const boolT bNewMinIsSetP )
*/
 writes reply blob to lake using name pcP
 makes reply blob by concatenating reply header with blob
 reads blob from box psttP
pseudocode
/*

#define CCiDnAMEmAX 0x10

// ---- LOAD PACK: BEGIN ------------------------------------------------------------------------------------------------------------------------------------------


// ---- MAKE PACK: END --------------------------------------------------------------------------------------------------------------------------------------------

}
    if( bTestP ) ;
    if( !ether && !etThread ) stateP.idStep = 0 ;
    //etherC::ifcSayIF( T("pass ")+TF1(stateP.idPass)+T(" done") , flSAY_APPEND | flSAY_LOG ) ;

    FORsTRINGSiN1( pstt1m ) etThread.diskFileOrDirDeleteF( tinP , psttc1 ) ;
    etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/pack.loaded.*") ) ;
    ZE( strokeS* , pstt1m ) ;

    STEP( onePackF( tinP , etThread ) ) ;

    tinP.flagsThreadMode1 = flagsThreadMode1Save ;

    for( countT idt = 1 ; idt <= cTrees ; idt ++ ) STEP( etThread.boxPutHtmlFromKnowledgeTreeBaseF( tinP , 1 , (strokeS*)st1P[ idt ] , (strokeS*)st2P[ idt ] , (strokeS*)st3P[ idt ] , tCopy , (strokeS*)st4P[ idt ] , 0x100000 , 1 ) ) ;
    const countT cTrees = st2P ;
    TN( tCopy , "(c) IdeaFarm " "(tm) City" ) ;
    __( st2P - st4P ) ;
    __( st2P - st3P ) ;

    //STEP( verifyExampleSimplestExistsF( tinP , etThread , bTestP                          ) ) ;
    //STEP( insertInstanceSectionF(       tinP , etThread , bTestP                          ) ) ;
    //STEP( findFunctionCallInstancesF(   tinP , etThread , bTestP , S1C('(') , T(TbLACK) ) ) ;
    //STEP( writeSymbolBaseF(             tinP , etThread , bTestP                          ) ) ;
    //STEP( writeVisiblesHtmlF(           tinP , etThread , bTestP                          ) ) ;
    //STEP( listVisibleDefinitionsF(      tinP , etThread , bTestP                          ) ) ;
    //U: //STEP( testAutoF(                    tinP , etThread , bTestP                          ) ) ;
    //U: STEP( etThread.ifcHireF( tinP , T("city.publisher") , ifcIDaDAMoLD_MAKEaLLaDAMS , T(bTestP?"!test":"") , flHIRE_WAIT ) ) ;

    tinP.flagsThreadMode1 |= flTHREADmODE1_WATCHfORaSYNCHiMPOTENCE ;
    flagsT flagsThreadMode1Save = tinP.flagsThreadMode1 ;

    ZE( countT , idStep ) ;
    //etherC::ifcSayIF( T("pass ")+TF1(++stateP.idPass)+T(" begun") , flSAY_APPEND | flSAY_LOG ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
{
voidT makePackF( tinS& tinP , etherC& ether , etherC& etThread , stackC& st1P , stackC& st2P , stackC& st3P , stackC& st4P , boolT bTestP , stateS& stateP )

    }
        }                                                                                                                               \
            /*(>>>>(p oolC&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<Thread).walkF( tinP , 0 , info , flPOOLoLDwALK_INCLUDEdROPSoTHERcLIENTS ) ;*/                                     \
            //etherC::ifcSayIF( T(#expP) , flSAY_APPEND | flSAY_LOG ) ;                                                                            \
            TN( tLogPool , "///d/ideafarm.log.thirdC" ) ;                                                                               \
            ZE( countT , info ) ;                                                                                                     \
            expP ;                                                                                                                      \
            //etherC::ifcSayIF( T("pass ")+TF1(stateP.idPass)+T(" step ")+TF1(stateP.idStep)+T(": " #expP) , flSAY_APPEND | flSAY_LOG ) ;              \
            stateP.idStep = idStep ;                                                                                                    \
            //etherC::ifcSayIF( T(#expP) , flSAY_APPEND | flSAY_LOG ) ;                                                                                \
            TN( tLog , "///d/log.ifc.html" ) ;                                                                                          \
        {                                                                                                                               \
        if( ++ idStep > stateP.idStep && !ether && !etThread )                                                                          \
    {                                                                                                                                   \
                                                                                                                                        \
#define STEP(expP)                                                                                                                      \

}
    }
        // /* 44 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("e") , T("etherC") ) ;
        // /* 74 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("f3") , T("templates") ) ;
        // /* 64 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("3") , T("dissertation") , T("Wo'O Ideafarm's Ph.D. Dissertation") ) ;
        // /* 54 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("2") , T("symbols") ) ;
        // /* 34 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("a2") , T("thirdC") ) ;
        // THESE ARE DONE LAST BECAUSE THEY ARE LARGE

        // ALPHABETICAL END
        // /* 24 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("e2") , T("vectorOldC") ) ;
        // /* 14 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("d2") , T("tinS") ) ;
        // /* 04 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("c2") , T("timeS") ) ;
        // /* f3 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("b2") , T("thirdParties") ) ;
        // /* e3 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("92") , T("textIdFileC") ) ;
        // /* d3 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("82") , T("textC") ) ;
        // /* c3 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("72") , T("taskS") ) ;
        // /* b3 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("62") , T("tableC") ) ;
        // /* a3 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("52") , T("switchStackC") ) ;
        // /* 93 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("42") , T("switchC") ) ;
        // /* 83 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("32") , T("strokeS") ) ;
        // /* 73 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("22") , T("stackC") ) ;
        // /* 63 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("12") , T("sqMatrixOldC") ) ;
        // /* 53 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("02") , T("socketC") ) ;
        // /* 43 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("f1") , T("signC") ) ;
        // /* 23 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("d1") , T("sCountC") ) ;
        // /* 13 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("e3") , T("riverC") ) ;
        // /* 03 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("d3") , T("pricerC") ) ;
        // /* e2 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("c1") , T("poolC") ) ;
        // /* d2 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("b1") , T("plateS") ) ;
        // /* c2 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("a1") , T("peekS") ) ;
        // /* b2 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("91") , T("osFileNameC") ) ;
        // /* a2 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("81") , T("maxC") ) ;
        // /* 92 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("71") , T("mapC") ) ;
        // /* 82 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("61") , T("mainS") ) ;
        // /* 72 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("b3") , T("lakeC") ) ;
        // /* 62 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("51") , T("infoFileS") ) ;
        // /* 52 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("41") , T("infoDiskS") ) ;
        // /* 42 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("31") , T("infoDisk1S") ) ;
        // /* 32 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("21") , T("infoDisk1bS") ) ;
        // /* 22 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("11") , T("infoDisk1aS") ) ;
        // /* 12 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("01") , T("infoBoxGetPutS") ) ;
        // /* 02 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("a3") , T("impotenceS") ) ;
        // /* f1 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("f")  , T("ifFileNameC") ) ;
        // /* e1 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("93") , T("ap_artmentOldC") ) ;
        // /* d1 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("83") , T("dictionary1C") ) ;
        // /* c1 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("d")  , T("count8S") ) ;
        // /* b1 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("c")  , T("count7S") ) ;
        // /* a1 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("b")  , T("count6S") ) ;
        // /* 91 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("a")  , T("count5S") ) ;
        // /* 81 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("9")  , T("count4S") ) ;
        // /* 71 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("8")  , T("count3S") ) ;
        // /* 61 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("7")  , T("count2S") ) ;
        // /* 51 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("73") , T("countTC") ) ;
        // /* 41 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("63") , T("carC") ) ;
        // /* 31 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("53") , T("buoyFileC") ) ;
        // /* 21 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("43") , T("buoyDireC") ) ;
        // /* 11 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("33") , T("buoyDictionaryC") ) ;
        // /* 01 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("23") , T("buoyBookOfLifeC") ) ;
        // /* f0 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("13") , T("buoyC") ) ;
        // /* e0 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("6")  , T("boxC") ) ;
        // /* d0 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("5")  , T("batonC") ) ;
        // /* c0 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("4")  , T("batonBoxC") ) ;
        // /* b0 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("03") , T("anchorC") ) ;
        // ALPHABETICAL BEGIN
    {
    if( !bTestP )

    // /* a0 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("f2") , T("busC") ) ;
    // /* U:WHAT IS THIS NUMERIC COMMENT MEAN? */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("04") , T("test") ) ;

    // /* 00 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("102") , T("102") , T("resume: Wo'O Ideafarm") ) ;

    // /* 00 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("301") , T("301") , T("IdeaFarm " "(tm) City Market Plaza") ) ;
    // /* 00 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("201") , T("201") , T("IdeaFarm " "(tm) City Free Trade Zone") ) ;
    // /* 00 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("101") , T("101") , T("IdeaFarm " "(tm) ROC: pseudo perfect markets") ) ;

    /* 90 */ htmlJobF( tinP , etThread , st1P , st2P , st3P , st4P , T("1") , T("ideafarm") , T("IdeaFarm " "(tm) City Knowledge Tree") ) ;
{
voidT setupF( tinS& tinP , etherC& etThread , stackC& st1P , stackC& st2P , stackC& st3P , stackC& st4P , boolT bTestP )

}
    etThread.strMakeF( tinP , LF , psttw , T("///ideafarm/precious/domains/com/ideafarm/city/library/base/")+T(psttOldClassP)+T(".base") ) ; st4P << psttw ; psttw = 0 ;
    etThread.strMakeF( tinP , LF , psttw , psttTitle                                                                           ) ; st3P << psttw ; psttw = 0 ;
    etThread.strMakeF( tinP , LF , psttw , T(WWWiDEAFARMcOM "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/1.")+T(psttIdP)         ) ; st2P << psttw ; psttw = 0 ;
    etThread.strMakeF( tinP , LF , psttw , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/packs/1.")+T(psttIdP)           ) ; st1P << psttw ; psttw = 0 ;

    ZE( strokeS* , psttw ) ;

    const strokeS* const psttTitle = psttTitleP ? psttTitleP : psttOldClassP ;
{
voidT htmlJobF( tinS& tinP , etherC& etThread , stackC& st1P , stackC& st2P , stackC& st3P , stackC& st4P , const strokeS* const psttIdP , const strokeS* const psttOldClassP , const strokeS* const psttTitleP = 0 )

}
    }
        etThread.delF( tinP , pba ) ;
        }
            etThread.boxPutF( tinP , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/pack") , pba , cba ) ;
            //etherC::ifcSayIF( T("writing combined pack") , flSAY_APPEND | flSAY_LOG ) ;

            }
                etThread.delF( tinP , pc2p ) ;
                }
                    etThread.delF( tinP , pbPack ) ;
                    off += cbPack - sizeof( countT ) ;
                    etThread.memCopyF( tinP , pba + off , pbPack + sizeof( countT ) , cbPack - sizeof( countT ) ) ;
                    byteT* pbPack = (byteT*)pc2p->c2 ;
                    countT cbPack = pc2p->c1 ;
                {
                if( pc2p )
                stPacks >> pc2p ;
                ZE( count2S* , pc2p ) ;
                if( !( idPack % 0x100 ) ) etherC::ifcSayIF( T("copying pack ")+TF1(++idPack)+T(" of ")+TF1(cToDo)+T(" to combined image") , flSAY_APPEND | flSAY_LOG ) ;
            {
            while( stPacks )
            countT off = sizeof( countT ) ;

            *(countT*)pba = ifcIDfILEtYPE_PACKED ;
        {
        if( pba )
        etThread.newF( tinP , LF , pba , cba ) ; ___( pba ) ;
        ZE( byteT* , pba ) ;
        idPack = 0 ;

        while( handle ) ;
        }
            if( pc2p ) cba += pc2p->c1 - sizeof( countT ) ;
            count2S* pc2p = (count2S*)stPacks.downF( tinP , handle ) ;
        {
        do
        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        countT cba = sizeof( countT ) ;
    {
    if( stPacks )

    }
        etThread.delF( tinP , pstt1m ) ;
        }
            }
                }
                    stPacks << pc2p ;
                    pc2p->c2 = (countT)pbPack ;
                    pc2p->c1 = cbPack ;
                {
                if( pc2p )
                etThread.newF( tinP , LF , pc2p ) ; ___( pc2p ) ;
                ZE( count2S* , pc2p ) ;
            {
            if( !etThread )

            if( !etThread ) { __( *(countT*)pbPack - ifcIDfILEtYPE_PACKED ) ; }
            if( !etThread ) { __( cbPack < sizeof( countT )               ) ; }
            etThread.boxGetShadowF( tinP , pbPack , cbPack , psttc1 ) ; ___( pbPack ) ;
            ZE( countT , cbPack ) ;
            ZE( byteT* , pbPack ) ;

            if( !( idPack % 0x100 ) ) etherC::ifcSayIF( T("reading pack ")+TF1(++idPack)+T(" of ")+TF1(cToDo)+T(" from disk") , flSAY_APPEND | flSAY_LOG ) ;
        {
        FORsTRINGSiN1( pstt1m )

        cToDo = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/packs/" "*") ) ; ___( pstt1m ) ;
        ZE( strokeS* , pstt1m ) ;
    {
    stackC stPacks( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_count2S ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
    ZE( countT , cToDo ) ;
    ZE( countT , idPack ) ;
{
voidT onePackF( tinS& tinP , etherC& etThread )
// THIS CODE IS DUPLICATED IN 9e30104 AND IN dd30104

//U: USE A MACRO TO GEN THE CODE FOR THESE BOOLEAN FUNCTIONS

}
    etThread.delF( tinP , pstt1m ) ;
    }
        etThread.boxPutHtmlFromKnowledgeTreeBaseF( tinP , 1 , tHtmlLocal+tIdi , tHtml+tIdi , tIdi , tCopy , psttc1 , 0x100000 ) ;
        if( !( cToDo % 0x100 ) ) etherC::ifcSayIF( TF3(--cToDo,0,6) , flSAY_APPEND | flSAY_LOG ) ;

        etThread.delF( tinP , psttIdi ) ;
        TN( tIdi , psttIdi ) ;
        etThread.delF( tinP , psttw ) ;
        etThread.strWordF( tinP , psttIdi , psttw , sttq , S1C('.') , 2 ) ; ___( psttIdi ) ;
        ZE( strokeS* , psttIdi ) ;
        etThread.strWordF( tinP , psttw , psttc1 , sttq , S1C('/') , - 1 ) ; ___( psttw ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , psttw ) ;
        //etherC::ifcSayIF( T("writeVisiblesHtmlF/")+T(psttc1) , flSAY_APPEND | flSAY_LOG ) ;

        //if( bSkip ) continue ;
        //if( bSkip && !etThread.strCompareF( tinP , psttc1 , tSkipTo ) ) bSkip = 0 ;
    {
    FORsTRINGSiN1( pstt1m )
    //TN( tSkipTo , "" ) ; tSkipTo = tKt+T("5b10104.base") ;
    //boolT bSkip = 1 ;
    ZE( countT , idFile ) ;
    else         { cToDo = etThread.boxMenuF( tinP , soul1m , tKt+T("*.base") ) ; ___( pstt1m ) ; }
    if( bTestP ) { cToDo = etThread.boxMenuF( tinP , soul1m , tKt+T("6230104.base") ) ; ___( pstt1m ) ; }
    ZE( countT , cToDo ) ;
    ZE( strokeS* , pstt1m ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
    TN( tCopy , "(c) IdeaFarm " "(tm) City" ) ;
    TN( tHtmlLocal , "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/packs/5." ) ;
    TN( tHtml , WWWiDEAFARMcOM "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/5." ) ;
    TN( tKt2 , ".kt" ) ;
    }
        etThread.delF( tinP , psttm ) ;
        tKt = T(psttm) ;
        etThread.diskMapFileNameF( tinP , psttm , tKt ) ; // MAPPED WO TIME HERE, FOR SPEED
        ZE( strokeS* , psttm ) ;
    {
    TN( tKt  , "///ideafarm/ephemeral/domains/com/ideafarm/gen/kt/visible." ) ;
{
voidT writeVisiblesHtmlF( tinS& tinP , etherC& etThread , const boolT bTestP )

}
    baton.ungrabF( tinP ) ;

    __( idDeathType ) ;
    __( value ) ;
    else         etThread.osProcessF( value , idDeathType , tinP , T("///d/ideafarm.work/backed.up.never/gen/exe/released.i00005/01000030.ipdos-we") , T("de30104 !woPass") ) ;
    if( bTestP ) etThread.osProcessF( value , idDeathType , tinP , T("///d/ideafarm.work/backed.up.never/gen/exe/released.i00005/01000030.ipdos-we") , T("de30104 !woPass !test") ) ;
    ZE( countT , idDeathType ) ;
    ZE( countT , value ) ;

    baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
    batonC baton( tinP , TAG( TAGiDnULL ) , T("ifc.hog") ) ;
{
voidT testAutoF( tinS& tinP , etherC& etThread , const boolT bTestP )

}
    etThread.delF( tinP , pstt1mEx ) ;
    }
        etThread.delF( tinP , psttv ) ;
        }
            etThread.delF( tinP , pstts ) ;
            }
                }
                    etThread.delF( tinP , posts ) ;
                    etThread.boxPutF( tinP , tSubjectFile , posts , costs ) ;
                    countT costs = etThread.strMakeF( tinP , LF , posts , pstts ) ; ___( posts ) ;
                    ZE( osTextT* , posts ) ;
                    etThread.strReverseF( tinP , pstts , 0 , T("\r\n") ) ; ___( pstts ) ;
                {
                if( bModified )

                }
                    }
                        bModified = 1 ;
                        etThread.strInsertF( tinP , pstts , idlList , tLink ) ; ___( pstts ) ;
                        idlList ++ ;
                    {
                    if( !bListed )

                    }
                        etThread.delF( tinP , psttwl ) ;

                        bListed = !!etThread.strIdF( tinP , idfListed , sttqListed , tLink , psttwl ) ;
                        strokeS sttqListed( (countT)0 , sc_IGNOREqUOTES ) ;
                        countT idfListed = 1 ;

                        etThread.strSubstringF( tinP , psttwl , idfwl , idlwl , pstts ) ; ___( psttwl ) ;
                        countT idlwl = idlList ;
                        countT idfwl = idfList ;
                        ZE( strokeS* , psttwl ) ;
                    {
                    if( idfList <= idlList )
                    ZE( boolT , bListed ) ;

                    etThread.delF( tinP , psttTitleOfSubject ) ;
                    textC tLink = t1+tIdi+t2+tIdi+T(":  ")+T(psttTitleOfSubject)+t3 ;
                    TN( t3 , "\\</A\\>\r\n" ) ;
                    TN( t2 , ".1" ".0\\\"\\>" ) ;
                    TN( t1 , "  \\<A HREF=\\\"http://" WWWiDEAFARMcOM "/5." ) ;

                    }
                        if( !psttTitleOfSubject ) { etThread.strMakeF( tinP , LF , psttTitleOfSubject , T("") ) ; ___( psttTitleOfSubject ) ; }
                        }
                            else if( psttTitleOfSubject )    etThread.delF( tinP , psttTitleOfSubject ) ;
                                 if( idClass == 1 ) break ;
                            etThread.strSubstringDelimitedF( tinP , psttTitleOfSubject , idClass , idf , sttq , psttv ) ; ___( psttTitleOfSubject ) ;
                            ZE( countT , idClass ) ;
                        {
                        while( !etThread && idf )
                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                        countT idf = 1 ;
                    {                        
                    ZE( strokeS* , psttTitleOfSubject ) ;

                    if( idlList ) idlList -- ;
                    countT idlList = idNextSectionF( tinP , etThread , pstts , idfList ) ;
                {
                if( !bSuppress )

                }
                    }
                        else idfList = idw + tSim.csF( tinP ) ;
                        }
                            bModified = 1 ;
                            idfList = idw ;
                            etThread.strInsertF( tinP , pstts , idw , T(" simplest\r\n") ) ;
                            idw = idws + tExa.csF( tinP ) ; // COULD NOT FIND THE "simplest" LINE, SO MAKE simplest LINE
                        {
                        if( !idw )
                        idw = etThread.strIdF( tinP , idf , sttq , tSim , pstts ) ;
                        const countT idws = idf = idw ; // FOUND examples LINE AT idws
                    {
                    else
                    }
                        }
                            bModified = 1 ;
                            idfList = idw ;
                            etThread.strInsertF( tinP , pstts , idw , T("examples\r\n simplest\r\n") ) ;
                            idw += 6 ;
                        {
                        else
                        }
                            bSuppress = 1 ;
                            etherC::ifcSayIF( T("could not find the expected \"\\r\\n/" "*\\r\\n\" in file \"")+tSubjectFile+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
                        {
                        if( !idw )
                        idw = etThread.strIdF( tinP , idf , sttq , T("\r\n/" "*\r\n") , pstts ) ;
                        idf = 1 ; // COULD NOT FIND THE "examples" LINE, SO MAKE examples/simplest LINES
                    {
                    if( !idw )                                
                    countT idw = etThread.strIdF( tinP , idf , sttq , tExa , pstts ) ;
                    idf = 1 ;
                    TN( tSim , "\r\n simplest\r\n" ) ;
                    TN( tExa , "\r\nexamples\r\n" ) ;
                {
                ZE( countT , idfList ) ; // MAKE SURE THAT THE SUBJECT FILE CONTAINS THE "example/simplest" LINES, AND SET idfList
                ZE( boolT , bSuppress ) ;
                ZE( boolT , bModified ) ;
            {
            if( pstts )

            }
                etThread.delF( tinP , psttQuotedPart ) ;
                }
                    }
                        etThread.strReverseF( tinP , pstts , 0 , T("\r\n") ) ; ___( pstts ) ;
                        etThread.delF( tinP , posts ) ;
                        etThread.strMakeF( tinP , LF , pstts , T(posts) ) ; ___( pstts ) ;

                        etThread.boxGetShadowF( tinP , posts , costs , tSubjectFile , 1 ) ; ___( posts ) ;
                        ZE( countT   , costs ) ;
                        ZE( osTextT* , posts ) ;
                    {
                    if( etThread.diskFileExistsF( tinP , tSubjectFile ) )

                    etThread.delF( tinP , psttw ) ;
                    tSubjectFile = tDic+T(psttw) ;
                    etThread.strSubstringF( tinP , psttw , idf , idl , psttQuotedPart ) ; ___( psttw ) ;
                    ZE( strokeS* , psttw ) ;
                    ZE( countT , idl ) ;
                {
                if( psttQuotedPart && 1 == etThread.strIdF( tinP , idf , sttq , T("example.simplest.") , psttQuotedPart ) && idf )
                countT idf = 1 ;

                etThread.strWordF( tinP , psttQuotedPart , tTitle , sttq , S1C(0x22) , 2 ) ; ___( psttQuotedPart ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttQuotedPart ) ;
            {
            if( !bBase )
            ZE( strokeS* , pstts ) ;
            TN( tSubjectFile , "" ) ;

            }
                }
                    etThread.delF( tinP , postv ) ;
                    etThread.boxPutF( tinP , psttc1 , postv , costv ) ;
                    etThread.delF( tinP , psttv2 ) ;
                    countT costv = etThread.strMakeF( tinP , LF , postv , psttv2 ) ; ___( postv ) ;
                    ZE( osTextT* , postv ) ;
                    etThread.strReverseF( tinP , psttv2 , psttv , T("\r\n") ) ; ___( psttv2 ) ;
                    ZE( strokeS* , psttv2 ) ;

                    }
                        etThread.strInsertF( tinP , psttv , idlList , tLink ) ; ___( psttv ) ;
                        idlList ++ ;
                    {
                    if( !bListed )

                    }
                        etThread.delF( tinP , psttwl ) ;

                        bListed = !!etThread.strIdF( tinP , idfListed , sttqListed , tLink , psttwl ) ;
                        strokeS sttqListed( (countT)0 , sc_IGNOREqUOTES ) ;
                        countT idfListed = 1 ;

                        etThread.strSubstringF( tinP , psttwl , idfwl , idlwl , psttv ) ; ___( psttwl ) ;
                        countT idlwl = idlList ;
                        countT idfwl = idfList ;
                        ZE( strokeS* , psttwl ) ;
                    {
                    if( idfList <= idlList )
                    ZE( boolT , bListed ) ;

                    if( idlList ) idlList -- ;
                    countT idlList = idNextSectionF( tinP , etThread , psttv , idfList ) ;
                {
                if( !bSuppress )

                }
                    else idfList = idw + 6 ;
                    }
                        bSuppress = 1 ;
                        etherC::ifcSayIF( T("could not find the expected \"\\r\\n/" "*\\r\\n\" in file \"")+T(psttc1)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
                    {
                    if( !idw )
                    idw = etThread.strIdF( tinP , idf , sttq , T("\r\n/" "*\r\n") , psttv ) ;
                    idf = 1 ;
                {
                else
                if( idw ) bSuppress = 1 ;
                countT idw = etThread.strIdF( tinP , idf , sttq , tLink , psttv ) ;
                idf = 1 ;
                textC tLink = T("\\<A HREF=\\\"http://" WWWiDEAFARMcOM "/5.")+tIdi+T(".1.0\\\"\\>definition\\</A\\>\r\n") ;
                ZE( countT , idfList ) ;
                ZE( boolT , bSuppress ) ;
            {
            // INSERT A "DEFINITION" LINK LINE INTO FILE COMMENTS

            }
                etThread.delF( tinP , postx ) ;
                etThread.boxPutF( tinP , tKt+tIdi+tKt2 , postx , costx ) ;
                else        { costx = etThread.strMakeF( tinP , LF , postx , T("/" "/" "|" "|" "!" "k" "t" "|"    )+T(psttc1)+T("!||\r\n")+tIdi+T(":  ")+tTitle+T("\r\n") ) ; ___( postx ) ; }
                if( bBase ) { costx = etThread.strMakeF( tinP , LF , postx , T("/" "/" "|" "|" "!" "r" "a" "w" "|")+T(psttc1)+T("!||\r\n")+tIdi+T(":  ")+tTitle+T("\r\n") ) ; ___( postx ) ; }
                ZE( countT , costx ) ;
                ZE( osTextT* , postx ) ; // WRITE THE BASE FILE
            {

            }
                etThread.delF( tinP , psttTitle ) ;
                tTitle = T(psttTitle) ;
                if( !psttTitle ) { etThread.strMakeF( tinP , LF , psttTitle , T("") ) ; ___( psttTitle ) ; }
                }
                    else if( psttTitle )    etThread.delF( tinP , psttTitle ) ;
                         if( idClass == 1 ) break ;
                    etThread.strSubstringDelimitedF( tinP , psttTitle , idClass , idf , sttq , psttv ) ; ___( psttTitle ) ;
                    ZE( countT , idClass ) ;
                {
                while( !etThread && idf )
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                countT idf = 1 ;
                ZE( strokeS* , psttTitle ) ;
            {
            TN( tTitle , "" ) ;

            }
                etThread.delF( tinP , psttIdi ) ;
                tIdi = T(psttIdi) ;
                etThread.delF( tinP , psttw ) ;
                etThread.strWordF( tinP , psttIdi , psttw , sttqId , S1C('.') , 2 ) ; ___( psttIdi ) ;
                ZE( strokeS* , psttIdi ) ;
                strokeS sttqId( (countT)0 , sc_IGNOREqUOTES ) ;

                __Z( psttw ) ;
                etThread.strWordF( tinP , psttw , psttc1 , sttqw , S1C('/') , - 1 ) ; ___( psttw ) ;
                strokeS sttqw( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttw ) ;
            {
            TN( tIdi , "" ) ;
        {
        if( bBase || etThread.strIdF( tinP , idf , sttq , T("\r\n//VISIBLE\r\n") , psttv ) )
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;

        }
            etThread.delF( tinP , postv ) ;
            etThread.strReverseF( tinP , psttv , 0 , T("\r\n") ) ; ___( psttv ) ;
            etThread.strMakeF( tinP , LF , psttv , T(postv) ) ; ___( psttv ) ;
            etThread.boxGetShadowF( tinP , postv , costv , psttc1 , 1 ) ; ___( postv ) ;
            ZE( countT , costv ) ;
            ZE( osTextT* , postv ) ;
        {
        ZE( strokeS* , psttv ) ;

        //if( cToDo == cToDoSave && !etThread.strCompareF( tinP , psttc1 , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/5adam.0000104") ) ) continue ;

        }
            bBase = 1 != etThread.strIdF( tinP , idf , sttq , tDic+T("adam.") , psttc1 ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        ZE( boolT , bBase ) ;
        if( !( cToDo % 0x100 ) ) etherC::ifcSayIF( TF3(cToDo,0,6) , flSAY_APPEND | flSAY_LOG ) ;
    {
    FORsTRINGSiN1( pstt1mEx )
    const countT cToDoSave = cToDo ;
    else         { cToDo = etThread.boxMenuF( tinP , soul1mEx , tDic+T("*") ) ; ___( pstt1mEx ) ; }
    }
        cToDo += etThread.boxMenuF( tinP , soul1mEx , tDic+T("adam.6230104.*") ) ; ___( pstt1mEx ) ;
        cToDo  = etThread.boxMenuF( tinP , soul1mEx , tDic+T("func.1330004.*") ) ; ___( pstt1mEx ) ;
    {
    if( bTestP )
    ZE( countT , cToDo ) ;
    ZE( strokeS* , pstt1mEx ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
    TN( tKt2 , ".base" ) ;
    }
        etThread.delF( tinP , psttm ) ;
        tKt = T(psttm) ;
        etThread.diskMapFileNameF( tinP , psttm , tKt ) ; // MAPPING THIS WO TOO, FOR SPEED
        ZE( strokeS* , psttm ) ;
    {
    TN( tKt  , "///ideafarm/ephemeral/domains/com/ideafarm/gen/kt/visible." ) ;
    }
        etThread.delF( tinP , psttm ) ;
        tDic = T(psttm) ;
        etThread.diskMapFileNameF( tinP , psttm , tDic ) ; // NEED TO MAP tDic CAUSE WILL SEARCH FOR IT IN FILE NAMES IN MENU
        ZE( strokeS* , psttm ) ;
    {
    TN( tDic , "///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/" ) ;
{
voidT listVisibleDefinitionsF( tinS& tinP , etherC& etThread , const boolT bTestP )

}
    }
        etThread.delF( tinP , psttd ) ;
        stackDef >> psttd ;
        ZE( strokeS* , psttd ) ;        
    {
    while( stackDef )

    }
        etThread.delF( tinP , psttf ) ;

        etThread.boxPutHtmlFromKnowledgeTreeBaseF( tinP , 1 , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/packs/6.$")+T(psttf) , T(WWWiDEAFARMcOM "///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/6.$")+T(psttf) , psttf , tCopy , tBase , 0x100000 ) ;
        TN( tCopy , "(c) IdeaFarm " "(tm) City" ) ;

        etThread.delF( tinP , posti ) ;
        etThread.boxPutF( tinP , tBase , posti , costi ) ;
        textC tBase = T("///ideafarm/ephemeral/domains/com/ideafarm/gen/kt/instances.")+T(psttf)+T(".base") ;
        etThread.delF( tinP , psttImage ) ;
        else costi = etThread.strMakeF( tinP , LF , posti , T("none") ) ; ___( posti ) ;
        }
            costi = etThread.strMakeF( tinP , LF , posti , psttImage ) ; ___( posti ) ;
            etThread.strReverseF( tinP , psttImage , 0 , T("\r\n") ) ; ___( psttImage ) ;
        {
        if( psttImage ? psttImage->idAdam : 0 )
        ZE( countT   , costi ) ;
        ZE( osTextT* , posti ) ;

        }
            etThread.delF( tinP , psttl ) ;
            etThread.strFuseF( tinP , psttImage , psttl , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ 0x10000 ) ; ___( psttImage ) ;
            else          { etThread.strFuseF( tinP , psttImage , T("\r\n") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ 0x10000 ) ; ___( psttImage ) ; }
            if( !bPrior ) bPrior = 1 ;
            stackLine >> psttl ;
            ZE( strokeS* , psttl ) ;        
        {
        while( stackLine )
        etThread.strMakeF( tinP , LF , psttImage , T("") , 0x10000 ) ; ___( psttImage ) ;
        ZE( strokeS* , psttImage ) ;
        ZE( boolT , bPrior ) ;

        }
            while( hTour ) ;
            }
                }
                    if( psttExample ) stackLine.sinkF( tinP , idSlot , psttExample ) ;
                    ZE( countT , idSlot ) ;
                    etThread.strSubstringExampleF( tinP , psttExample , idfd , sttqd , psttd , psttf , sttOpenP , psttWhiteP ) ; ___( psttExample ) ;
                    ZE( strokeS* , psttExample ) ;
                {
                while( idfd )
                countT idfd = 1 ;
                strokeS sttqd( (countT)0 , sc_IGNOREqUOTES ) ;
                strokeS* psttd = (strokeS*)stackDef.upF( tinP , hTour ) ;
                if( !( ( ++ idTourStop ) % 0x10 ) ) etherC::ifcSayIF( T("3 functions not yet processed: ")+TF3(stackFun,0,6)+T(": tour stop ")+TF1(idTourStop) , flSAY_APPEND | flSAY_LOG ) ;
            {
            do
            ZE( countT , hTour ) ;
            ZE( countT , idTourStop ) ;
        {
        stackC stackLine( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

        stackFun >> psttf ;
        ZE( strokeS* , psttf ) ;        
    {
    while( stackFun )

    }
        etThread.delF( tinP , pstt1mFun ) ;
        }
            if( psttf && S1C('F') != psttf[ CSpREFIX - 1 + psttf->idAdam ] || ( stackFun.sinkF( tinP , idSlot , psttf , flSTACKsINK_UNIQUE ) , !idSlot ) ) etThread.delF( tinP , psttf ) ;
            ZE( countT , idSlot ) ;
            etThread.strWordF( tinP , psttf , psttc1 , sttq , S1C('.') , - 1 , 1 ) ; ___( psttf ) ;
            ZE( strokeS* , psttf ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            //etherC::ifcSayIF( T("2 building stack of function names")+TF3(--cToDo,0,6) , flSAY_APPEND | flSAY_LOG ) ;
        {
        FORsTRINGSiN1( pstt1mFun )
        else         { cToDo = etThread.boxMenuF( tinP , soul1mFun , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.*"        ) ) ; ___( pstt1mFun ) ; }
        if( bTestP ) { cToDo = etThread.boxMenuF( tinP , soul1mFun , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.1330004.*") ) ; ___( pstt1mFun ) ; }
        ZE( countT , cToDo ) ;
        ZE( strokeS* , pstt1mFun ) ;
    {
    stackC stackFun( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

    }
        etThread.delF( tinP , pstt1mEx ) ;
        }
            stackDef << psttd ;
            etThread.strReverseF( tinP , psttd , 0 , T("\r\n") ) ; ___( psttd ) ;
            etThread.delF( tinP , postd ) ;
            etThread.strMakeF( tinP , LF , psttd , T(postd) ) ; ___( psttd ) ;
            ZE( strokeS* , psttd ) ;
            etThread.boxGetShadowF( tinP , postd , costd , psttc1 , 1 ) ; ___( postd ) ;
            ZE( countT , costd ) ;
            ZE( osTextT* , postd ) ;
            //etherC::ifcSayIF( T("1 building stack of reversed defs ")+TF3(--cToDo,0,6) , flSAY_APPEND | flSAY_LOG ) ;
        {
        FORsTRINGSiN1( pstt1mEx )
        else         { cToDo = etThread.boxMenuF( tinP , soul1mEx , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.*"      ) ) ; ___( pstt1mEx ) ; }
        if( bTestP ) { cToDo = etThread.boxMenuF( tinP , soul1mEx , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/5adam.6230104") ) ; ___( pstt1mEx ) ; }
        ZE( countT , cToDo ) ;
        ZE( strokeS* , pstt1mEx ) ;
    {
    stackC stackDef( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    TN( tLog , "///d/log.ifc.html" ) ;
{
voidT findFunctionCallInstancesF( tinS& tinP , etherC& etThread , const boolT bTestP , const strokeS sttOpenP , const strokeS* const psttWhiteP )

}
    etThread.delF( tinP , pstt1mEx ) ;
    }
        etThread.delF( tinP , pstti ) ;
        }
            etThread.delF( tinP , posti ) ;
            etThread.boxPutF( tinP , psttc1 , posti , costi ) ;
            if( !( cToDo % 0x100 ) ) etherC::ifcSayIF( TF3(cToDo,0,6) , flSAY_APPEND | flSAY_LOG ) ;
            costi = etThread.strMakeF( tinP , LF , posti , pstti ) ; ___( posti ) ;
            etThread.strReverseF( tinP , pstti , 0 , T("\r\n") ) ; ___( pstti ) ;
        {
        if( bModified )

        if( !( cToDo % 0x100 ) ) etherC::ifcSayIF( TF3(cToDo,0,6) , flSAY_APPEND | flSAY_LOG ) ;
        }
            }
                }
                    bModified = 1 ;
                    etThread.strInsertF( tinP , pstti , idw , tLink ) ; ___( pstti ) ;
                    if( !( cToDo % 0x100 ) ) etherC::ifcSayIF( TF3(cToDo,0,6) , flSAY_APPEND | flSAY_LOG ) ;

                    textC tLink = t1+tName+t2 ;
                    TN( t2 , ".0\\\"\\>instances\\</A\\>\r\n" ) ;
                    TN( t1 , "\\<A HREF=\\\"http://" WWWiDEAFARMcOM "/6.$" ) ;

                    etThread.delF( tinP , psttName ) ;
                    TN( tName , psttName ) ;
                    etThread.strWordF( tinP , psttName , psttc1 , sttq , S1C('.') , - 1 ) ; ___( psttName ) ;
                    //sttq = ze ;
                    ZE( strokeS* , psttName ) ;

                    idw += 6 ;
                {
                else
                if( !idw ) etherC::ifcSayIF( T("could not find the expected \"\\r\\n/" "*\\r\\n\" in file \"")+T(psttc1)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
                countT idw = etThread.strIdF( tinP , idf , sttq , T("\r\n/" "*\r\n") , pstti ) ;
                //sttq = ze ;
                idf = 1 ;
            {
            if( !etThread.strIdF( tinP , idf , sttq , tIns , pstti ) )
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            TN( tIns , "\r\n\\<A HREF=\\\"http://" WWWiDEAFARMcOM "/6." ) ;
        {
        ZE( boolT , bModified ) ;

        etThread.strReverseF( tinP , pstti , 0 , T("\r\n") ) ; ___( pstti ) ;
        etThread.delF( tinP , posti ) ;
        etThread.strMakeF( tinP , LF , pstti , T(posti) ) ; ___( pstti ) ;
        ZE( strokeS* , pstti ) ;
        if( !( cToDo % 0x100 ) ) etherC::ifcSayIF( TF3(cToDo,0,6) , flSAY_APPEND | flSAY_LOG ) ;

        etThread.boxGetShadowF( tinP , posti , costi , psttc1 , 1 ) ; ___( posti ) ;
        ZE( countT   , costi ) ;
        ZE( osTextT* , posti ) ;

        { countT idf = 1 ; strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ; if( etThread.strIdF( tinP , idf , sttq , tOperator , psttc1 ) ) continue ; }

        if( !( cToDo % 0x100 ) ) etherC::ifcSayIF( TF3(--cToDo,0,6) , flSAY_APPEND | flSAY_LOG ) ;
    {
    FORsTRINGSiN1( pstt1mEx )
    TN( tLog , "///d/log.ifc.html" ) ;
    TN( tOperator , ".operator" ) ;

    else         { cToDo = etThread.boxMenuF( tinP , soul1mEx , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.*F"        ) ) ; ___( pstt1mEx ) ; }
    if( bTestP ) { cToDo = etThread.boxMenuF( tinP , soul1mEx , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.1330004.*F") ) ; ___( pstt1mEx ) ; }
    ZE( countT , cToDo ) ;
    ZE( strokeS* , pstt1mEx ) ;
{
voidT insertInstanceSectionF( tinS& tinP , etherC& etThread , const boolT bTestP )

}
    etThread.delF( tinP , pstt1m ) ;
    }
        etThread.delF( tinP , psttd ) ;
        etThread.delF( tinP , psttw ) ;

        etherC::ifcSayIF( T("no example simplest exists for: ")+T(psttw) , flSAY_APPEND | flSAY_LOG ) ;
        )
            ( idf = 1 , !etThread.strIdF( tinP , idf , sttq , T("example.simplest.")+T(psttw) , psttd ) ) // "example.simplest.func.1234001.fooC.barF"
            ( idf = 1 , !etThread.strIdF( tinP , idf , sttq , T("\r\nit is illegal to refer to this symbol in the definition of an adam\r\n") , psttd ) ) &&
        (
        if // FOR SPEED, sttq IS NOT REINITIALIZED FOR THE OO'TH strIdF CALL, SINCE IT SHOULD NOT HAVE CHANGED

        etThread.strWordF( tinP , psttw , psttc1 , sttq , S1C('/') , - 1 ) ; ___( psttw ) ; // "func.1234001.fooC.barF"
        ZE( strokeS* , psttw ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( countT , idf ) ;

        }
            etThread.delF( tinP , postd ) ;
            etThread.strMakeF( tinP , LF , psttd , T(postd) ) ; ___( psttd ) ;
            etThread.boxGetShadowF( tinP , postd , costd , psttc1 , 1 ) ; ___( postd ) ;
            ZE( countT , costd ) ;
            ZE( osTextT* , postd ) ;
        {
        ZE( strokeS* , psttd ) ;

        if( !( cToDo % 0x100 ) ) etherC::ifcSayIF( T("cToDo: ")+TF3(--cToDo,0,8) , flSAY_APPEND | flSAY_LOG ) ;

        if( etThread ) break ;
    {
    FORsTRINGSiN1( pstt1m ) // FOR EACH SYMBOL DEFINITION
    TN( tLog , "///d/log.ifc.html" ) ;

    }
        cToDo += etThread.boxMenuF( tinP , soul1m , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.*") ) ; ___( pstt1m ) ;
        cToDo  = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.*") ) ; ___( pstt1m ) ;
    {    
    else
    if( bTestP ) { cToDo = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/3func.1330004.*") ) ; ___( pstt1m ) ; }
    ZE( countT , cToDo ) ;
    ZE( strokeS* , pstt1m ) ;
{
voidT verifyExampleSimplestExistsF( tinS& tinP , etherC& etThread , const boolT bTestP )

}
    return idNextSection ;

    }
        idNextSection = idcr + 2 ;

        if(    !idcr || idcr >  psttP->idAdam - 2 || psttP[ CSpREFIX + 1 + idcr ] == S1C(' ') ) idcr = 0 ;
        while(  idcr && idcr <= psttP->idAdam - 2 && psttP[ CSpREFIX + 1 + idcr ] == S1C(' ') ) idcr = etThread.strIdF( tinP , idf , sttq , tCr , psttP ) ;
        countT                                                                                idcr = etThread.strIdF( tinP , idf , sttq , tCr , psttP ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = idFirstP ;    
        TN( tCr , "\r\n" ) ;
    {
    else
    if( psttP && psttP[ CSpREFIX - 1 + idFirstP ] != S1C(' ') ) idNextSection = idFirstP ;

    ZE( countT , idNextSection ) ;
{
countT idNextSectionF( tinS& tinP , etherC& etThread , const strokeS* const psttP , const countT idFirstP )

}
    etThread.delF( tinP , postx ) ;
    etThread.boxPutF( tinP , T("///ideafarm/precious/domains/com/ideafarm/city/library/base/symbols.base") , postx , costx ) ;
    etThread.delF( tinP , pstto ) ;
    countT costx = etThread.strMakeF( tinP , LF , postx , pstto ) ; ___( postx ) ;
    ZE( osTextT* , postx ) ;

    etThread.strReverseF( tinP , pstto , 0 , T("\r\n") ) ; ___( pstto ) ;

    etThread.delF( tinP , pstt1m ) ;
    }
        etThread.delF( tinP , psttw2 ) ;
        etThread.delF( tinP , psttw1 ) ;
        etThread.strFuseF( tinP , pstto , T(psttw2)+t1+T(psttw1)+t2 ) ; ___( pstto ) ;

        etThread.strWordF( tinP , psttw2 , psttc1 , sttq2 , sttd2 , - 1 ) ; ___( psttw2 ) ;
        strokeS sttq2( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , psttw2 ) ;

        etThread.strWordF( tinP , psttw1 , psttc1 , sttq1 , sttd1 , - 1 ) ; ___( psttw1 ) ;
        strokeS sttq1( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , psttw1 ) ;
    {
    FORsTRINGSiN1( pstt1m )
    TN( t2 , "!||\r\n" ) ;
    TN( t1 , "\r\n//||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/" ) ;
    strokeS sttd2( '.' ) ;
    strokeS sttd1( '/' ) ;
    etThread.strMakeF( tinP , LF , pstto , T("") , cToDo * 0x400 ) ; ___( pstto ) ;
    ZE( strokeS* , pstto ) ;
    else         { cToDo = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010???.*") ) ; ___( pstt1m ) ; }
    if( bTestP ) { cToDo = etThread.boxMenuF( tinP , soul1m , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010001.*") ) ; ___( pstt1m ) ; }
    ZE( countT , cToDo ) ;
    ZE( strokeS* , pstt1m ) ;
{
voidT writeSymbolBaseF( tinS& tinP , etherC& etThread , const boolT bTestP )

// ---- MAKE PACK: BEGIN ------------------------------------------------------------------------------------------------------------------------------------------

}
{
stateC( tinP , etherP , sizeof *this , 0 , translateStateF )
stateS::stateS( tinS& tinP , etherC& etherP ) :

TRANSLATEsTATE_END
    state.idMe ++ ;
TRANSLATEsTATE_MIDDLE
    case 1 : { state.idMe = stateOther.idMe ; state.idPass = stateOther.idPass ; state.idStep = stateOther.idStep ; }
TRANSLATEsTATE_BEGIN( stateS , 1 )

;
}
    stateS( tinS& tinP , etherC& etherP ) ;

    countT idStep ;
    countT idPass ;
    countT idMe ;
    countT idVersion ;
{
struct stateS : public stateC

/*1*/WAKEhIDE( "city.publisher" )/*1*/
/**/
*/
  if specified, then a small lake pack is made that focuses on func.1330004.busC.cSubscribersF
 !test
command line parameters
obsoleted by b840104 c840104
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

