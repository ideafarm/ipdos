
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    while( !ether && ~hFind1 && !POOP ) ;
    }
        DEL( pInfo1 ) ;
        }
            }
                }
                    }
                        while( !ether && ~hFind2 && !POOP ) ;
                        }
                            DEL( pInfo2 ) ;
                            }
                                if( !bDir ) etThread.boxZapF( tinP , tIfoName2 ) ;

                                const boolT bDir = pInfo2->psttIfoName[ CSpREFIX - 1 + pInfo2->psttIfoName->idAdam ].idAdam == '/' ;

                                TN( tIfoName2 , pInfo2->psttIfoName ) ;
                            {
                            else
                            }
                                break ;
                                DEL( pInfo2 ) ;
                            {
                            if( !pInfo2 || !pInfo2->psttIfoName )

                            etThread.diskFindFileOrDirF( tinP , pInfo2 , hFind2 , tPath , &pat2 ) ;
                            ZE( infoFileS* , pInfo2 ) ;
                        {
                        do
                        handleC hFind2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                        patternC pat2( tinP , etThread , tShorter+tDotMetaDotStar , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

                        etThread.diskMoveFileOrDirF( tinP , tToFolder+tName , tIfoName1 ) ;
                        etThread.traceF( tinP , tName ) ;
                    {
                    if( tName.csF( tinP ) )

                    }
                        etThread.delF( tinP , posti ) ;
                        else       tName = T(posti) ;
                        if( POOP ) { POOPR }
                        tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , tLongFileCurrentname , 1 ) ; ___( posti ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;

                        SCOOPS
                    {
                    IFsCRATCH
                    TN( tName , "" ) ;

                    TN( tLongFileCurrentname , "" ) ; tLongFileCurrentname = tPath + tShorter + tDotMetaCurrentname ;

                    }
                        etThread.delF( tinP , psttShorter ) ;
                        tShorter = T(psttShorter) ;
                        etThread.delF( tinP , psttnu ) ;
                        etThread.strBisectF( tinP , psttShorter , psttnu , tShort , tDot , - 2 ) ; ___( psttShorter ) ; ___( psttnu ) ;
                        ZE( strokeS* , psttnu ) ;
                        ZE( strokeS* , psttShorter ) ;
                    {
                    TN( tShorter , "" ) ;

                    }
                        etThread.delF( tinP , psttShort ) ;
                        etThread.delF( tinP , psttPath ) ;
                        tShort = T(psttShort) ;
                        tPath  = T(psttPath) ;
                        etThread.strBisectF( tinP , psttPath , psttShort , pInfo1->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttPath ) ;
                    {
                    TN( tShort , "" ) ;
                    TN( tPath , "" ) ;
                {
                if( !bDir )

                const boolT bDir = pInfo1->psttIfoName[ CSpREFIX - 1 + pInfo1->psttIfoName->idAdam ].idAdam == '/' ;

                TN( tIfoName1 , pInfo1->psttIfoName ) ;
            {
            if( 1 == etThread.strIdOptimizedClosureF( tinP , 0 , flSTRmATCH_null , countTC( 1 ) , sttq , patternC( tinP , etThread , T("*.data.*") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) , pInfo1->psttIfoName ) )
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        {
        else
        }
            break ;
            DEL( pInfo1 ) ;
        {
        if( !pInfo1 || !pInfo1->psttIfoName )

        etThread.diskFindFileOrDirF( tinP , pInfo1 , hFind1 , tPath1 ) ;
        ZE( infoFileS* , pInfo1 ) ;
    {
    do
    handleC hFind1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

    TN( tToFolder , "///d/tmp/unarchived/" ) ;
    //TN( tToFolder , "///d/tmp/desk/extracted.from.archive/" ) ;
    TN( tDotMetaDotStar     , ".meta.*" ) ;
    TN( tDotMetaCurrentname , ".meta.currentname" ) ;
    TN( tb4 , "    " ) ;
    TN( tDot , "." ) ;
    TN( tSlash , "/" ) ;
    TN( tPath1 , "" ) ; tPath1 = T("///d/tmp/unarchive/") ;
    //TN( tPath1 , "" ) ; tPath1 = T("///d/tmp/desk/20191112@0952.archive.20190121.caltrain.incident/*") ;
{

TODO

/*1*/WAKEhIDE( "tool.extract.from.archive" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
