
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

CONoUTrAW( "ok\r\n" ) ;

THREADmODE2rESTORE
}
    }
        }
            }
                else       etThread.osThreadF( TaRG1( tmListServeF ) , (countT)pso , (countT)&puseMaster ) ;
                if( POOP ) { DEL( pso ) ; }
                __( bRefuse ) ;
                socket.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ; ___( pso ) ;
                ZE( boolT , bRefuse ) ;
                ZE( countT , idPortPeer ) ;
                nicNameC nnPeer ;
                ZE( socketC* , pso ) ;
            {
            while( !ether && !POOP )
    
            /*PROD*/ if( idCycle == 1 ) ether.osThreadAdamF( tinP , ifcIDaDAM_LISTsERVERmONEYbUCKETS ) ;
    
            socket.listenF( tinP ) ;
            homeS::homeIF().idPortListServerIdAccountDescription = socket.bindF( tinP ) ;
            socketC socket( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    
            ++ idCycle ;
        {
        while( !ether )
        ZE( countT , idCycle ) ;
    {
    IFsCRATCH

    puseC puseWork1( tinP , ifcIDpOOL_ADAMtEMP ) ; //--------------------------------------------------------------------------------------
    puseC puseMaster( tinP , "list.idAccount.to.description" , flPOOLc_null , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
{
THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

TODO

#endif
DONE( tmTestQueryF )
}
    #endif
    }
        }
            etThread.delF( tinP , psttNameOut ) ;
            //CONoUTrAW( T("[psttNameOut]: \"")+T(psttNameOut)+T("\"\r\n") ) ;
            sIn >> psttNameOut ; ___( psttNameOut ) ;
            ZE( strokeS* , psttNameOut ) ;
        
            etThread.delF( tinP , psttNameIn ) ;
            //CONoUTrAW( T("[psttNameIn]: \"")+T(psttNameIn)+T("\"\r\n") ) ;
            sIn >> psttNameIn ; ___( psttNameIn ) ;
            ZE( strokeS* , psttNameIn ) ;
        
            etThread.delF( tinP , psttTitle ) ;
            //CONoUTrAW( T("[psttTitle]: \"")+T(psttTitle)+T("\"\r\n") ) ;
            sIn >> psttTitle ; ___( psttTitle ) ;
            ZE( strokeS* , psttTitle ) ;
        
            sIn >> flagsMemberOf ;
            ZE( flagsT , flagsMemberOf ) ;
    
            sIn >> idMode ;
            ZE( countT , idMode ) ;
    
            sIn >> flagsMode ;
            ZE( flagsT , flagsMode ) ;
        {
        if( !POOP )
    
        __Z( bSubExists ) ;
        sIn >> bSubExists ;
        ZE( boolT , bSubExists ) ;
    
        __Z( bAccExists ) ;
        sIn >> bAccExists ;
        ZE( boolT , bAccExists ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << idSub ; //idSub
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_QUERYsUBACCOUNTdESCRIPTION ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //QUERY DESCRIPTION

    }
        if( !POOP ) { //CONoUTrAW5( "[bDone,idSub]: " , bDone , " " , idSub , "\r\n" ) ; }
        __( idSubv - idSub ) ;
        sIn >> idSubv ;
        ZE( countT , idSubv ) ;
    
        sIn >> bDone ;
        ZE( boolT , bDone ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << (strokeS*)T("3joe@") ; //SfIELD_postEmailPenpalContainsAnd
        sOut << (countT)1 ;
        sOut << (strokeS*)T("3@hoo.com") ; //SfIELD_postEmailPenpalContainsOr
        sOut << (countT)1 ;
        sOut << (strokeS*)T("3doo@coo.com") ; //SfIELD_postEmailPenpalExactOr
        sOut << (countT)1 ;
        sOut << (strokeS*)T("3!rull") ; //SfIELD_postRecipe
        sOut << (countT)1 ;
        sOut << (strokeS*)T("3!null") ; //SfIELD_postAutoresponse
        sOut << (countT)1 ;
        sOut << (countT)0 ; //SfIELD_cEmailRelayDrawings
        sOut << (strokeS*)T("3foo@goo.com") ; //SfIELD_postEmailRelay
        sOut << (countT)1 ;
        sOut << (strokeS*)T("myOut3") ; //SfIELD_postNameOut
        sOut << (strokeS*)T("myIn3") ; //SfIELD_postNameIn
        sOut << (strokeS*)T("myTitle3") ; //SfIELD_postTitle
        sOut << (countT)fliSUBACCOUNTmODE_null ;
        sOut << idSub ;
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_SETsUBACCOUNTdESCRIPTION ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //REPLACE DESCRIPTION AFTER DELETION OF DESCRIPTION

    }
        if( !POOP ) { //CONoUTrAW3( "[bDone]: " , bDone , "\r\n" ) ; }
        sIn >> bDone ;
        ZE( boolT , bDone ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << idSub ;
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_DELETEsUBACCOUNTdESCRIPTION ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //DELETE SUB

    }
        }
            etThread.delF( tinP , psttNameOut ) ;
            //CONoUTrAW( T("[psttNameOut]: \"")+T(psttNameOut)+T("\"\r\n") ) ;
            sIn >> psttNameOut ; ___( psttNameOut ) ;
            ZE( strokeS* , psttNameOut ) ;
        
            etThread.delF( tinP , psttNameIn ) ;
            //CONoUTrAW( T("[psttNameIn]: \"")+T(psttNameIn)+T("\"\r\n") ) ;
            sIn >> psttNameIn ; ___( psttNameIn ) ;
            ZE( strokeS* , psttNameIn ) ;
        
            etThread.delF( tinP , psttTitle ) ;
            //CONoUTrAW( T("[psttTitle]: \"")+T(psttTitle)+T("\"\r\n") ) ;
            sIn >> psttTitle ; ___( psttTitle ) ;
            ZE( strokeS* , psttTitle ) ;
        
            sIn >> flagsMemberOf ;
            ZE( flagsT , flagsMemberOf ) ;
    
            sIn >> idMode ;
            ZE( countT , idMode ) ;
    
            sIn >> flagsMode ;
            ZE( flagsT , flagsMode ) ;
        {
        if( !POOP )
    
        __Z( bSubExists ) ;
        sIn >> bSubExists ;
        ZE( boolT , bSubExists ) ;
    
        __Z( bAccExists ) ;
        sIn >> bAccExists ;
        ZE( boolT , bAccExists ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << idSub ; //idSub
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_QUERYsUBACCOUNTdESCRIPTION ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //QUERY DESCRIPTION

    }
        if( !POOP ) { //CONoUTrAW5( "[bDone,idSub]: " , bDone , " " , idSub , "\r\n" ) ; }
        __( idSubv - idSub ) ;
        sIn >> idSubv ;
        ZE( countT , idSubv ) ;
    
        sIn >> bDone ;
        ZE( boolT , bDone ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << (strokeS*)T("2joe@") ; //SfIELD_postEmailPenpalContainsAnd
        sOut << (countT)1 ;
        sOut << (strokeS*)T("2@hoo.com") ; //SfIELD_postEmailPenpalContainsOr
        sOut << (countT)1 ;
        sOut << (strokeS*)T("2doo@coo.com") ; //SfIELD_postEmailPenpalExactOr
        sOut << (countT)1 ;
        sOut << (strokeS*)T("2!rull") ; //SfIELD_postRecipe
        sOut << (countT)1 ;
        sOut << (strokeS*)T("2!null") ; //SfIELD_postAutoresponse
        sOut << (countT)1 ;
        sOut << (countT)0 ; //SfIELD_cEmailRelayDrawings
        sOut << (strokeS*)T("2foo@goo.com") ; //SfIELD_postEmailRelay
        sOut << (countT)1 ;
        sOut << (strokeS*)T("myOut2") ; //SfIELD_postNameOut
        sOut << (strokeS*)T("myIn2") ; //SfIELD_postNameIn
        sOut << (strokeS*)T("myTitle2") ; //SfIELD_postTitle
        sOut << (countT)fliSUBACCOUNTmODE_null ;
        sOut << idSub ;
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_SETsUBACCOUNTdESCRIPTION ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //REPLACE DESCRIPTION
    #if defined( NEVERdEFINED )

    }
        if( !POOP ) { //CONoUTrAW3( "delete account [bDone]: " , bDone , "\r\n" ) ; }
        sIn >> bDone ;
        ZE( boolT , bDone ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_DELETEaCCOUNTdESCRIPTION ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //DELETE ACCOUNT

    }
        if( !POOP ) { //CONoUTrAW3( "test idSub[bExisted]: " , bExisted , "\r\n" ) ; }
        sIn >> bExisted ;
        ZE( boolT , bExisted ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << (countT)fliSUBACCOUNTmODE_DELETED        ; //flagsExclude
        sOut << (countT)fliSUBACCOUNTmODE_OWNERcONFIRMED ; //flagsRequire
        sOut << (countT)( idSub + 1 ) ;
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_TESTiDsUB ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //TEST IDsUB

    }
        if( !POOP ) { //CONoUTrAW3( "test idSub [bExisted]: " , bExisted , "\r\n" ) ; }
        sIn >> bExisted ;
        ZE( boolT , bExisted ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << (countT)fliSUBACCOUNTmODE_DELETED        ; //flagsExclude
        sOut << (countT)fliSUBACCOUNTmODE_OWNERcONFIRMED ; //flagsRequire
        sOut << idSub ;
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_TESTiDsUB ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //TEST IDsUB

    }
        if( !POOP ) { //CONoUTrAW3( "test idAccount [bExisted]: " , bExisted , "\r\n" ) ; }
        sIn >> bExisted ;
        ZE( boolT , bExisted ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_TESTiDaCCOUNT ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //TEST IDaCCOUNT

    }
        }
            }
                etThread.delF( tinP , psttEmailPenpalContainsAnd ) ;
                //CONoUTrAW( T("[psttEmailPenpalContainsAnd]: \"")+T(psttEmailPenpalContainsAnd)+T("\"\r\n") ) ;
                sIn >> psttEmailPenpalContainsAnd ; ___( psttEmailPenpalContainsAnd ) ;
                ZE( strokeS* , psttEmailPenpalContainsAnd ) ;
            {
            while( cEmailPenpalContainsAnd -- )
    
            //CONoUTrAW3( "[cEmailPenpalContainsAnd]: " , cEmailPenpalContainsAnd , "\r\n" ) ;
            sIn >> cEmailPenpalContainsAnd ;
            ZE( countT , cEmailPenpalContainsAnd ) ;
    
            }
                etThread.delF( tinP , psttEmailPenpalContainsOr ) ;
                //CONoUTrAW( T("[psttEmailPenpalContainsOr]: \"")+T(psttEmailPenpalContainsOr)+T("\"\r\n") ) ;
                sIn >> psttEmailPenpalContainsOr ; ___( psttEmailPenpalContainsOr ) ;
                ZE( strokeS* , psttEmailPenpalContainsOr ) ;
            {
            while( cEmailPenpalContainsOr -- )
    
            //CONoUTrAW3( "[cEmailPenpalContainsOr]: " , cEmailPenpalContainsOr , "\r\n" ) ;
            sIn >> cEmailPenpalContainsOr ;
            ZE( countT , cEmailPenpalContainsOr ) ;
    
            }
                etThread.delF( tinP , psttEmailPenpalExactOr ) ;
                //CONoUTrAW( T("[psttEmailPenpalExactOr]: \"")+T(psttEmailPenpalExactOr)+T("\"\r\n") ) ;
                sIn >> psttEmailPenpalExactOr ; ___( psttEmailPenpalExactOr ) ;
                ZE( strokeS* , psttEmailPenpalExactOr ) ;
            {
            while( cEmailPenpalExactOr -- )
    
            //CONoUTrAW3( "[cEmailPenpalExactOr]: " , cEmailPenpalExactOr , "\r\n" ) ;
            sIn >> cEmailPenpalExactOr ;
            ZE( countT , cEmailPenpalExactOr ) ;
    
            }
                etThread.delF( tinP , psttRecipe ) ;
                //CONoUTrAW( T("[psttRecipe]: \"")+T(psttRecipe)+T("\"\r\n") ) ;
                sIn >> psttRecipe ; ___( psttRecipe ) ;
                ZE( strokeS* , psttRecipe ) ;
            {
            while( cRecipe -- )
    
            //CONoUTrAW3( "[cRecipe]: " , cRecipe , "\r\n" ) ;
            sIn >> cRecipe ;
            ZE( countT , cRecipe ) ;
    
            }
                etThread.delF( tinP , psttAutoresponse ) ;
                //CONoUTrAW( T("[psttAutoresponse]: \"")+T(psttAutoresponse)+T("\"\r\n") ) ;
                sIn >> psttAutoresponse ; ___( psttAutoresponse ) ;
                ZE( strokeS* , psttAutoresponse ) ;
            {
            while( cAutoresponse -- )
    
            //CONoUTrAW3( "[cAutoresponse]: " , cAutoresponse , "\r\n" ) ;
            sIn >> cAutoresponse ;
            ZE( countT , cAutoresponse ) ;
    
            }
                etThread.delF( tinP , psttEmailRelay ) ;
                //CONoUTrAW( T("[psttEmailRelay]: \"")+T(psttEmailRelay)+T("\"\r\n") ) ;
                sIn >> psttEmailRelay ; ___( psttEmailRelay ) ;
                ZE( strokeS* , psttEmailRelay ) ;
            {
            while( cEmailRelay -- )
    
            //CONoUTrAW3( "[cEmailRelay]: " , cEmailRelay , "\r\n" ) ;
            sIn >> cEmailRelay ;
            ZE( countT , cEmailRelay ) ;
    
            etThread.delF( tinP , psttNameOut ) ;
            //CONoUTrAW( T("[psttNameOut]: \"")+T(psttNameOut)+T("\"\r\n") ) ;
            sIn >> psttNameOut ; ___( psttNameOut ) ;
            ZE( strokeS* , psttNameOut ) ;
        
            etThread.delF( tinP , psttNameIn ) ;
            //CONoUTrAW( T("[psttNameIn]: \"")+T(psttNameIn)+T("\"\r\n") ) ;
            sIn >> psttNameIn ; ___( psttNameIn ) ;
            ZE( strokeS* , psttNameIn ) ;
        
            etThread.delF( tinP , psttTitle ) ;
            //CONoUTrAW( T("[psttTitle]: \"")+T(psttTitle)+T("\"\r\n") ) ;
            sIn >> psttTitle ; ___( psttTitle ) ;
            ZE( strokeS* , psttTitle ) ;
    
            sIn >> flagsMemberOf ;
            ZE( flagsT , flagsMemberOf ) ;
    
            sIn >> idMode ;
            ZE( countT , idMode ) ;
    
            sIn >> flagsMode ;
            ZE( flagsT , flagsMode ) ;
        {
        if( !POOP )
    
        __Z( bSubExists ) ;
        sIn >> bSubExists ;
        ZE( boolT , bSubExists ) ;
    
        __Z( bAccExists ) ;
        sIn >> bAccExists ;
        ZE( boolT , bAccExists ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << idSub ; //idSub
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_QUERYsUBACCOUNTdESCRIPTION ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //QUERY DESCRIPTION

    }
        }
            //CONoUTrAW( T("[idSub]: \"")+T(idSub)+T("\"\r\n") ) ;
            sIn >> idSub ;
            ZE( countT , idSub ) ;
        {
        while( cIdSub -- )

        //CONoUTrAW3( "[cIdSub]: " , cIdSub , "\r\n" ) ;
        sIn >> cIdSub ;
        ZE( countT , cIdSub ) ;

        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDsUB ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //ENUMERATE IDsUB

    }
        }
            //CONoUTrAW( T("[idAccount]: \"")+T(idAccount)+T("\"\r\n") ) ;
            sIn >> idAccount ;
            ZE( countT , idAccount ) ;
        {
        while( cIdAccount -- )

        //CONoUTrAW3( "[cIdAccount]: " , cIdAccount , "\r\n" ) ;
        sIn >> cIdAccount ;
        ZE( countT , cIdAccount ) ;

        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //ENUMERATE IDaCCOUNT

    }
        //CONoUTrAW3( "[flagsMode]: " , flagsMode , "\r\n" ) ;
        if( bExists ) sIn >> flagsMode ;
        ZE( flagsT , flagsMode ) ;

        sIn >> bExists ;
        ZE( boolT , bExists ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_QUERYaCCOUNTdESCRIPTION ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //QUERY ACCOUNT

    }
        if( !idSub ) idSub = idSubNew ;
        //CONoUTrAW5( "[bDone,idSub]: " , bDone , " " , idSubNew , "\r\n" ) ;
        sIn >> idSubNew ;
        ZE( countT , idSubNew ) ;
    
        sIn >> bDone ;
        ZE( boolT , bDone ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << (strokeS*)T("1joe4@") ; //SfIELD_postEmailPenpalContainsAnd
        sOut << (strokeS*)T("1joe3@") ; //SfIELD_postEmailPenpalContainsAnd
        sOut << (strokeS*)T("1joe2@") ; //SfIELD_postEmailPenpalContainsAnd
        sOut << (strokeS*)T("1joe1@") ; //SfIELD_postEmailPenpalContainsAnd
        sOut << (countT)4 ;
        sOut << (strokeS*)T("14@hoo.com") ; //SfIELD_postEmailPenpalContainsOr
        sOut << (strokeS*)T("13@hoo.com") ; //SfIELD_postEmailPenpalContainsOr
        sOut << (strokeS*)T("12@hoo.com") ; //SfIELD_postEmailPenpalContainsOr
        sOut << (strokeS*)T("11@hoo.com") ; //SfIELD_postEmailPenpalContainsOr
        sOut << (countT)4 ;
        sOut << (strokeS*)T("1doo4@coo.com") ; //SfIELD_postEmailPenpalExactOr
        sOut << (strokeS*)T("1doo3@coo.com") ; //SfIELD_postEmailPenpalExactOr
        sOut << (strokeS*)T("1doo2@coo.com") ; //SfIELD_postEmailPenpalExactOr
        sOut << (strokeS*)T("1doo1@coo.com") ; //SfIELD_postEmailPenpalExactOr
        sOut << (countT)4 ;
        sOut << (strokeS*)T("1!rull4") ; //SfIELD_postRecipe
        sOut << (strokeS*)T("1!rull3") ; //SfIELD_postRecipe
        sOut << (strokeS*)T("1!rull2") ; //SfIELD_postRecipe
        sOut << (strokeS*)T("1!rull1") ; //SfIELD_postRecipe
        sOut << (countT)4 ;
        sOut << (strokeS*)T("1!null4") ; //SfIELD_postAutoresponse
        sOut << (strokeS*)T("1!null3") ; //SfIELD_postAutoresponse
        sOut << (strokeS*)T("1!null2") ; //SfIELD_postAutoresponse
        sOut << (strokeS*)T("1!null1") ; //SfIELD_postAutoresponse
        sOut << (countT)4 ;
        sOut << (countT)7 ; //SfIELD_cEmailRelayDrawings
        sOut << (strokeS*)T("1foo8@goo.com") ; //SfIELD_postEmailRelay
        sOut << (strokeS*)T("1foo7@goo.com") ; //SfIELD_postEmailRelay
        sOut << (strokeS*)T("1foo6@goo.com") ; //SfIELD_postEmailRelay
        sOut << (strokeS*)T("1foo5@goo.com") ; //SfIELD_postEmailRelay
        sOut << (strokeS*)T("1foo4@goo.com") ; //SfIELD_postEmailRelay
        sOut << (strokeS*)T("1foo3@goo.com") ; //SfIELD_postEmailRelay
        sOut << (strokeS*)T("1foo2@goo.com") ; //SfIELD_postEmailRelay
        sOut << (strokeS*)T("1foo1@goo.com") ; //SfIELD_postEmailRelay
        sOut << (countT)8 ;
        sOut << (strokeS*)T("myOut1") ; //SfIELD_postNameOut
        sOut << (strokeS*)T("myIn1") ; //SfIELD_postNameIn
        sOut << (strokeS*)T("myTitle1") ; //SfIELD_postTitle
        sOut << (countT)fliSUBACCOUNTmODE_null ; //SfIELD_flagsMode
        sOut << (countT)0 ; //idSub
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_SETsUBACCOUNTdESCRIPTION ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    while( cTries -- )
    countT cTries = 0x20 ;
    ZE( countT , idSub ) ;
    //SET SUBACCOUNT

    }
        //CONoUTrAW3( "[bDone]: " , bDone , "\r\n" ) ;
        sIn >> bDone ;
        ZE( boolT , bDone ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << (strokeS*)0 ; //psttHelloGreeting ;
        sOut << (strokeS*)0 ; //psttDirectoryGreeting ;
        sOut << (strokeS*)0 ; //psttPaypalProtectionEligibility ;
        sOut << (strokeS*)0 ; //psttPaypalPayerStatus ;
        sOut << (strokeS*)0 ; //psttPaypalPayerId ;
        sOut << (strokeS*)0 ; //psttPaypalPayerEmail ;
        sOut << (strokeS*)0 ; //psttCharset ;
        sOut << (strokeS*)0 ; //psttZipAt ;
        sOut << (strokeS*)0 ; //psttResidenceCountry ;
        sOut << (strokeS*)0 ; //psttLastName ;
        sOut << (strokeS*)0 ; //psttFirstName ;
        sOut << (strokeS*)0 ; //psttAddressStatus ;
        sOut << (strokeS*)0 ; //psttAddressCountry ;
        sOut << (strokeS*)0 ; //psttAddressZip ;
        sOut << (strokeS*)0 ; //psttAddressCountryCode ;
        sOut << (strokeS*)0 ; //psttAddressState ;
        sOut << (strokeS*)0 ; //psttAddressCity ;
        sOut << (strokeS*)0 ; //psttAddressStreet ;
        sOut << (strokeS*)0 ; //psttAddressName ;
        sOut << (countT)( fliACCOUNTmODE_LISTmEdIRECTORY | fliACCOUNTmODE_OWNERcONFIRMED ) ;
        sOut << (countT)1 ; //idAccount
        sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_SETaCCOUNTdESCRIPTION ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    //SET ACCOUNT

    }
        ++ s ; ether.osSleepF( tinP , TOCK >> 2 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    while( !homeS::homeIF().idPortListServerIdAccountDescription )
{
if( pTaskP )
TASK( tmTestQueryF )
#if defined( NEVERdEFINED )

DONE( tmListServeF )
}
    }
        DEL( psoP ) ;
        if( POOP ) POOPR

        }
            psoP->writeF( tinP , sOut ) ;
            }
                }
                    break ;
                    __1 ;
                    __( idCmd ) ;
                    _IO_
                {
                default :
                }
                    break ;
                    }
                        PUSE( tinP , *(byteT**)&pczListSubaccounts ) ;
                        }
                            sOut << arg.cValueFound ; //NUMBER OF SUBACCOUNTS THAT WERE NOT FLAGGED AS CONFIRMED (AND NOW ARE)

                            THREADmODE2rESTORE
                            }
                        
                                TELL( "CONFIRMoWNERaLLsUBACCOUNTS/called listOld2012F" )
                                PUSE.listOld2012F( tinP , pczListSubaccounts , ifcIDhOWlIST_FIFO , &arg , 0 , listingInspectConfirmCBF ) ;
                                _IO_
                                TELL( "CONFIRMoWNERaLLsUBACCOUNTS/calling listOld2012F" )
                                puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                            {
                            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                            listWalkArgOldS arg( tinP ) ;
                            //handleC hListSubs( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LIST oLD ) ; //U::WHY IS THIS HERE? IT IS NOT REFERENCED
                            grabitC grabit( tinP , TAG( TAGiDnULL ) ) ;

                            etherC::strStretchIF( tinP , pczListSubaccounts , count2S( LISTnAME_ROOTaPPLICATION ) , idAccount ) ;
                            pczListSubaccounts[ offo     ] = 0                      ;
                            pczListSubaccounts[ offo - 1 ] = GfIELD_listSubaccounts ;
                            for( countT offo = 0 ; offo < ccListSubaccounts ; offo ++ ) pczListSubaccounts[ offo ] = LISTnAME_PLACEhOLDER ;
                        {
                        if( pczListSubaccounts )
                        countT* pczListSubaccounts = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccListSubaccounts + 1 ) ) ; ___( pczListSubaccounts ) ;
                        const countT ccListSubaccounts = 2 + sizeof idAccount ;
                    {
                    if( !POOP )

                    //CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_CONFIRMoWNERaLLsUBACCOUNTS: " , idAccount , "\r\n" ) ;

                    __Z( idAccount ) ;
                    sIn >> idAccount ;
                    ZE( countT , idAccount ) ;
                    _IO_
                {
                case ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_CONFIRMoWNERaLLsUBACCOUNTS :
                }
                    break ;
                    //CONoUTrAW5( "QUERY [bDone,idSub]: " , bDone , " " , idSub , "\r\n" ) ; //U::

                    sOut << idSub ;
                    sOut << bDone ;
                    }
                        PUSE( tinP , *(byteT**)&pczAccount ) ;
                        }
                            }
                                }
                                    bDone = 1 ;
                                    THREADmODE2rESTORE
                                    }
                                        PUSE.ungrabListOld2012F( tinP , hListSub ) ;
                                        puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
                                    {
                                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
        
                                    SqUERYmULTIPLEoStEXT( hListSub , SfIELD_postEmailPenpalContainsAnd )
                                    SqUERYmULTIPLEoStEXT( hListSub , SfIELD_postEmailPenpalContainsOr  )
                                    SqUERYmULTIPLEoStEXT( hListSub , SfIELD_postEmailPenpalExactOr     )
                                    SqUERYmULTIPLEoStEXT( hListSub , SfIELD_postRecipe                 )
                                    SqUERYmULTIPLEoStEXT( hListSub , SfIELD_postAutoresponse           )
                                    SqUERYlONEcOUNT(      hListSub , SfIELD_cEmailRelayDrawings        )
                                    SqUERYmULTIPLEoStEXT( hListSub , SfIELD_postEmailRelay             )
                                    SqUERYlONEoStEXT(     hListSub , SfIELD_postNameOut                )
                                    SqUERYlONEoStEXT(     hListSub , SfIELD_postNameIn                 )
                                    SqUERYlONEoStEXT(     hListSub , SfIELD_postTitle                  )
                                    SqUERYlONEcOUNT(      hListSub , SfIELD_flagsMemberOf              )
                                    SqUERYlONEcOUNT(      hListSub , SfIELD_idMode                     )
                                    SqUERYlONEcOUNT(      hListSub , SfIELD_flagsMode                  )
                                {
                                if( ~hListSub )
    
                                sOut << (countT)!!~hListSub ;

                                }
                                    PUSE( tinP , *(byteT**)&pczSub ) ;
                                    }
                                        }
                                            THREADmODE2rESTORE
                                            }
                                                PUSE.openKidListOld2012F( tinP , hListSub , hListAcc , pczSub , flLISTwALKoLD_DOnOTcREATElIST ) ;
                                                puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                            {
                                            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                                        {
                                        if( !POOP )
        
                                        etherC::strStretchIF( tinP , pczSub , count2S( GfIELD_listSubaccounts ) , idSub ) ;
                                        pczSub[ offo ] = 0 ;
                                        for( countT offo = 0 ; offo < ccSub ; offo ++ ) pczSub[ offo ] = LISTnAME_PLACEhOLDER ;
                                    {
                                    if( pczSub )
                                    countT* pczSub = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccSub + 1 ) ) ; ___( pczSub ) ;
                                    const countT ccSub = 1 + sizeof idSub ;
                                {
                                if( !POOP )
                                handleC hListSub( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LIST oLD ) ;

                                //CONoUTrAW5( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_QUERYsUBACCOUNTdESCRIPTION: " , idAccount , "." , idSub , "\r\n" ) ;
    
                                __( idSub == - 1 ) ;
                                __Z( idSub ) ;
                                sIn >> idSub ;
                            {
                            if( ~hListAcc )

                            sOut << (countT)!!~hListAcc ;
                            THREADmODE2rESTORE
                            }
                                PUSE.openListOld2012F( tinP , hListAcc , pczAccount , flLISTwALKoLD_DOnOTcREATElIST ) ;
                                puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                            {
                            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                            handleC hListAcc( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LIST oLD ) ;
                            grabitC grabit( tinP , TAG( TAGiDnULL ) ) ;

                            etherC::strStretchIF( tinP , pczAccount , count2S( LISTnAME_ROOTaPPLICATION ) , idAccount ) ;
                            pczAccount[ offo ] = 0 ;
                            for( countT offo = 0 ; offo < ccAccount ; offo ++ ) pczAccount[ offo ] = LISTnAME_PLACEhOLDER ;
                        {
                        if( pczAccount )
                        countT* pczAccount = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccAccount + 1 ) ) ; ___( pczAccount ) ;
                        const countT ccAccount = 1 + sizeof idAccount ;
                    {
                    if( !POOP )
                    ZE( boolT , bDone ) ;

                    //}
                    //    THREADmODE2rESTORE
                    //    }
                    //        PUSE.listOld2012F( tinP , count2S( LISTnAME_ROOTaPPLICATION ) , ifcIDhOWlIST_FIFO , arg ) ;
                    //        _IO_
                    //        arg.flagsInspect = flAPTiNSPECT_CHATTERtOcONSOLE | flAPTiNSPECT_RECURSE ; 
                    //        listWalkArgOldS arg( tinP ) ;
                    //        puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                    //    {
                    //    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                    //{
                    //CHATTER THE ENTIRE LIST (COMMENT OUT IN PRODUCTION)

                    __Z( idAccount ) ;
                    sIn >> idAccount ;
                    ZE( countT , idAccount ) ;
                    ZE( countT , idSub ) ;
                    _IO_
                {
                case ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_QUERYsUBACCOUNTdESCRIPTION :
                }
                    break ;
                    }
                        PUSE( tinP , *(byteT**)&pczListSubaccounts ) ;
                        }
                            }
                                etThread( tinP , pStk_idNameFound ) ;
                                etThread( tinP , pStk_pcName      ) ;
                                }
                                    }
                                        PUSE( tinP , *(byteT**)&pcName ) ;
                                        }
                                            if( *pStk_pcName ) thirdC::c_memcpyIF( tinP , (byteT*)pcLag4 , (byteT*)pcName , sizeof pcLag4 ) ;
    
                                            sOut << uu.idSub ;
                                            uu.pbSub[ 0 ] = *(byteT*)&pcName[ 3 ] ;
                                            uu.pbSub[ 1 ] = *(byteT*)&pcName[ 2 ] ;
                                            uu.pbSub[ 2 ] = *(byteT*)&pcName[ 1 ] ;
                                            uu.pbSub[ 3 ] = *(byteT*)&pcName[ 0 ] ;
    
                                            uu ;
                                            }
                                                byteT  pbSub[ sizeof( countT ) ] ;
                                                countT idSub ;
                                            {
                                            union
                                        {
                                        if( pcName[ 0 ] && pcName[ 1 ] && pcName[ 2 ] && pcName[ 3 ] && thirdC::c_memcmpIF( tinP , (byteT*)pcLag4 , (byteT*)pcName , sizeof pcLag4 ) )
    
                                        *pStk_pcName >> pcName ;
                                        ZE( countT* , pcName ) ;
                                    {
                                    while( *pStk_pcName )
                                    countT pcLag4[] = { 0 , 0 , 0 , 0 } ;
    
                                    sOut << cSub ;
                                    }
                                        while( ~hWalk ) ;
                                        }
                                            }
                                                if( ~hWalk ) thirdC::c_memcpyIF( tinP , (byteT*)pcLag4 , (byteT*)pcName , sizeof pcLag4 ) ;
                                                cSub ++ ;
                                            {
                                            if( pcName[ 0 ] && pcName[ 1 ] && pcName[ 2 ] && pcName[ 3 ] && thirdC::c_memcmpIF( tinP , (byteT*)pcLag4 , (byteT*)pcName , sizeof pcLag4 ) )
    
                                            countT*& pcName = *(countT**)&pStk_pcName->downF( tinP , hWalk ) ;
                                        {
                                        do
                                        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        countT pcLag4[] = { 0 , 0 , 0 , 0 } ;
                                    {
                                    if( *pStk_pcName )
                                    ZE( countT , cSub ) ;
                                    //COUNT THE UNIQUE NAMES, INSPECTING ONLY THE WOTH 4 ELEMENTS
    
                                    }
                                        }
                                            }
                                                *pStk_pcName << pcName ; pcName = 0 ;
                                                //CONoUTrAW( T("listname push: ")+T(pcName)+T("\r\n") ) ;
                                                pcName[ offNestLevel + 1 ] = 0 ;
                                            {
                                            if( !*pStk_idNameFound )
    
                                            offNestLevelLag = offNestLevel ;
    
                                            pcName[ offNestLevel ] = idName ;
    
                                            }
                                                *pStk_pcName << pcName ; pcName = pcNameNew ;
                                                pcName[ offNestLevelLag + 1 ] = 0 ;
    
                                                thirdC::c_memcpyIF( tinP , (byteT*)pcNameNew , (byteT*)pcName , sizeof( countT ) * offNestLevelLag ) ;
                                                __Z( pcNameNew ) ;
                                                countT* pcNameNew = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( offNestLevelMax + 2 ) ) ; ___( pcNameNew ) ;
                                            {
                                            if( offNestLevelLag + 1 != offNestLevel )
                                            __( offNestLevelLag + 1 <  offNestLevel ) ; //POSITOINS MAY NOT BE SKIPPED
    
                                            *pStk_idNameFound >> pb_pc2 ;
                                        {
                                        while( *pStk_idNameFound )
                                        byteT*  pb_pc2       = (byteT*)pc2 ;
                                        countT& idName       = pc2[ 1 ] ;
                                        countT& offNestLevel = pc2[ 0 ] ;
                                        countT  pc2[ 2 ]                ;
                                        countT  offNestLevelLag = - 1 ;
    
                                        __Z( pcName ) ;
                                        countT* pcName = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( offNestLevelMax + 2 ) ) ; ___( pcName ) ;
                                    {
                                    if( offNestLevelMax != - 1 )
                                    //STACK ALL NAMES
    
                                    }
                                        while( ~hWalk ) ;
                                        }
                                            if( offNestLevelMax < (sCountT)offNestLevel ) offNestLevelMax = offNestLevel ;
                                            countT& offNestLevel = pStk_idNameFound->downF( tinP , hWalk ) ;
                                        {
                                        do
                                        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    if( *pStk_idNameFound )
                                    sCountT offNestLevelMax = - 1 ;
    
                                    THREADmODE2rESTORE
                                    }
                                        TELL( "ENUMERATEiDsUB/called listOld2012F" )
                                        PUSE.listOld2012F( tinP , hListSubs , ifcIDhOWlIST_FIFO , &arg , 0 ) ;
                                        _IO_
                                        TELL( "ENUMERATEiDsUB/calling listOld2012F" )
                                        if( !hListSubs ) { BLAMMO ; } //U::TO FIND A BUG
                                        TELL( "ENUMERATEiDsUB/checking handle" )
                                        arg.pStk_idNameFound = pStk_idNameFound ;
                                        arg.flagsInspect = flAPTiNSPECT_RECURSE ;
                                        listWalkArgOldS arg( tinP ) ;
                                        puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
                                    {
                                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                                {
                                if( pStk_idNameFound )
                                etThread( tinP , pStk_pcName      , TAG( TAGiDnULL ) , flSTACKc_FIFO                 , ifcSTACKtYPE_PTR_countT ) ;
                                etThread( tinP , pStk_idNameFound , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_BLOB , 2 * sizeof( countT )    ) ;
                                ZE( stackC* , pStk_pcName ) ;
                                ZE( stackC* , pStk_idNameFound ) ;
                            {
                            if( !POOP )

                            __Z( hListSubs ) ;
                            THREADmODE2rESTORE
                            }
                                PUSE.openListOld2012F( tinP , hListSubs , pczListSubaccounts ) ;
                                puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                            {
                            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                            handleC hListSubs( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LIST oLD ) ;
                            grabitC grabit( tinP , TAG( TAGiDnULL ) ) ;

                            etherC::strStretchIF( tinP , pczListSubaccounts , count2S( LISTnAME_ROOTaPPLICATION ) , idAccount ) ;
                            pczListSubaccounts[ offo     ] = 0                      ;
                            pczListSubaccounts[ offo - 1 ] = GfIELD_listSubaccounts ;
                            for( countT offo = 0 ; offo < ccListSubaccounts ; offo ++ ) pczListSubaccounts[ offo ] = LISTnAME_PLACEhOLDER ;
                        {
                        if( pczListSubaccounts )
                        countT* pczListSubaccounts = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccListSubaccounts + 1 ) ) ; ___( pczListSubaccounts ) ;
                        const countT ccListSubaccounts = 2 + sizeof idAccount ;
                    {
                    if( !POOP )

                    //CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDsUB: " , idAccount , "\r\n" ) ;

                    __Z( idAccount ) ;
                    sIn >> idAccount ;
                    ZE( countT , idAccount ) ;
                    _IO_
                {
                case ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDsUB :
                }
                    break ;
                    sOut << bDone ;

                    }
                        PUSE( tinP , *(byteT**)&pczField ) ;
                        }
                            THREADmODE2rESTORE
                            }
                                if( F(arg.cValueAttached) & fliSUBACCOUNTmODE_DELETED ) bDone = 1 ;
                                TELL( "DELETEsUBACCOUNTdESCRIPTION/called listOld2012F" )
                                PUSE.listOld2012F( tinP , pczField , ifcIDhOWlIST_FIFO , &arg , 0 ) ;
                                _IO_
                                TELL( "DELETEsUBACCOUNTdESCRIPTION/calling listOld2012F" )

                                arg.cValueAttachSpec    = fliSUBACCOUNTmODE_DELETED ;
                                arg.flagsInspect        = flAPTiNSPECT_ORvALUE ;
                                listWalkArgOldS arg( tinP ) ;
                                puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
                            {
                            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                            //CONoUTrAW( T("[pczField]: ")+T(pczField)+T("\r\n") ) ; //U::
                            *pcSuffix2 = SfIELD_flagsMode ;
                            countT* pcSuffix2 = pcSuffix1 + 1 + sizeof idSub ;
                            etherC::strStretchIF( tinP , pcSuffix1 , count2S( GfIELD_listSubaccounts ) , idSub     ) ;
                            countT* pcSuffix1 = pczField + 1 + sizeof idAccount ;
                            etherC::strStretchIF( tinP , pczField   , count2S( LISTnAME_ROOTaPPLICATION   ) , idAccount ) ;
                            pczField[ offo ] = 0 ;
                            for( countT offo = 0 ; offo < ccField ; offo ++ ) pczField[ offo ] = LISTnAME_PLACEhOLDER ;
                        {
                        if( !POOP )

                        __Z( pczField ) ;
                        countT* pczField = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccField + 1 ) ) ; ___( pczField ) ;
                        const countT ccField = 3 + sizeof idAccount + sizeof idSub ;
                    {
                    if( !POOP )

                    //CONoUTrAW5( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_DELETEsUBACCOUNTdESCRIPTION: " , idAccount , "." , idSub , "\r\n" ) ;

                    __Z( idSub ) ;
                    sIn >> idSub ;
                    ZE( countT , idSub ) ;

                    __Z( idAccount ) ;
                    sIn >> idAccount ;
                    ZE( countT , idAccount ) ;

                    ZE( boolT , bDone ) ;
                    _IO_
                {
                case ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_DELETEsUBACCOUNTdESCRIPTION :
                }
                    break ;
                    sOut << bExisted ;

                    }
                        PUSE( tinP , *(byteT**)&pczSub ) ;
                        }
                            }
                                THREADmODE2rESTORE
                                }
                                    bExisted = 0 ;
                                    )
                                        F(arg.cValueFound) & flagsExclude
                                        arg.cValueFound & flagsRequire != flagsRequire ||
                                    (
                                    if
                        
                                    TELL( "TESTiDsUB/called listOld2012F" )
                                    PUSE.listOld2012F( tinP , hListSub , pc2 , ifcIDhOWlIST_FIFO , &arg , 0 , listingInspectOldCBF ) ;
                                    _IO_
                                    TELL( "TESTiDsUB/calling listOld2012F" )
                                    if( !hListSub ) { BLAMMO ; } //U::TO FIND A BUG
                                    TELL( "TESTiDsUB/checking handle" )
                                    arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;
                                    listWalkArgOldS arg( tinP ) ;
                                    countT pc2[] = { SfIELD_flagsMode , 0 } ;
                                    puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
                                {
                                THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                                sIn >> flagsExclude ;
                                ZE( flagsT , flagsExclude ) ;

                                sIn >> flagsRequire ;
                                ZE( flagsT , flagsRequire ) ;
                                bExisted = 1 ;
                            {
                            if( ~hListSub )

                            THREADmODE2rESTORE
                            }
                                PUSE.openListOld2012F( tinP , hListSub , pczSub , flLISTwALKoLD_DOnOTcREATElIST ) ;
                                puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                            {
                            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                            handleC hListSub( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LIST oLD ) ;
                            grabitC grabit( tinP , TAG( TAGiDnULL ) ) ;

                            etherC::strStretchIF( tinP , pcSuffix , count2S( GfIELD_listSubaccounts ) , idSub     ) ;
                            etherC::strStretchIF( tinP , pczSub   , count2S( LISTnAME_ROOTaPPLICATION   ) , idAccount ) ;
                            countT* pcSuffix = pczSub + 1 + sizeof idAccount ;
                            pczSub[ offo ] = 0 ;
                            for( countT offo = 0 ; offo < ccSub ; offo ++ ) pczSub[ offo ] = LISTnAME_PLACEhOLDER ;
                        {
                        if( !POOP )

                        __Z( pczSub ) ;
                        countT* pczSub = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccSub + 1 ) ) ; ___( pczSub ) ;
                        const countT ccSub = 2 + sizeof idAccount + sizeof idSub ;
                    {
                    if( !POOP )
                    ZE( boolT , bExisted ) ;

                    //CONoUTrAW5( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_TESTiDsUB: " , idAccount , "." , idSub , "\r\n" ) ;

                    __Z( idSub ) ;
                    sIn >> idSub ;
                    ZE( countT , idSub ) ;

                    __Z( idAccount ) ;
                    sIn >> idAccount ;
                    ZE( countT , idAccount ) ;
                    _IO_
                {
                case ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_TESTiDsUB :
                }
                    break ;
                    //CONoUTrAW5( "SET [bDone,idSub]: " , bDone , " " , idSub , "\r\n" ) ; //U::

                    sOut << idSub ;
                    sOut << bDone ;
                    }
                        PUSE( tinP , *(byteT**)&pczAccount ) ;
                        }
                            }
                                }
                                    }
                                        bDone = 1 ;
                                        THREADmODE2rESTORE
                                        }
                                            PUSE.ungrabListOld2012F( tinP , hListSub ) ;
                                            puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
                                        {
                                        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
        
                                        }
                                            SpUSHfIFOoStEXT( hListSub , SfIELD_postEmailPenpalContainsAnd ) ;
                                            etThread.delF( tinP , psttEmailPenpalContainsAnd ) ;
                                            postzValue = tValue ;
                                            tValue = T(psttEmailPenpalContainsAnd) ;
                                            if( psttEmailPenpalContainsAnd ) etThread.strConvertToLowerCaseF( tinP , psttEmailPenpalContainsAnd ) ;                                                                                               \
                                            sIn >> psttEmailPenpalContainsAnd ; ___( psttEmailPenpalContainsAnd ) ;
                                            ZE( strokeS* , psttEmailPenpalContainsAnd ) ;
                                        {
                                        while( cEmailPenpalContainsAnd -- )
                                        sIn >> cEmailPenpalContainsAnd ;
                                        ZE( countT , cEmailPenpalContainsAnd ) ;
        
                                        }
                                            SpUSHfIFOoStEXT( hListSub , SfIELD_postEmailPenpalContainsOr ) ;
                                            etThread.delF( tinP , psttEmailPenpalContainsOr ) ;
                                            postzValue = tValue ;
                                            tValue = T(psttEmailPenpalContainsOr) ;
                                            if( psttEmailPenpalContainsOr ) etThread.strConvertToLowerCaseF( tinP , psttEmailPenpalContainsOr ) ;                                                                                               \
                                            sIn >> psttEmailPenpalContainsOr ; ___( psttEmailPenpalContainsOr ) ;
                                            ZE( strokeS* , psttEmailPenpalContainsOr ) ;
                                        {
                                        while( cEmailPenpalContainsOr -- )
                                        sIn >> cEmailPenpalContainsOr ;
                                        ZE( countT , cEmailPenpalContainsOr ) ;
        
                                        }
                                            SpUSHfIFOoStEXT( hListSub , SfIELD_postEmailPenpalExactOr ) ;
                                            etThread.delF( tinP , psttEmailPenpalExactOr ) ;
                                            postzValue = tValue ;
                                            tValue = T(psttEmailPenpalExactOr) ;
                                            if( psttEmailPenpalExactOr ) etThread.strConvertToLowerCaseF( tinP , psttEmailPenpalExactOr ) ;                                                                                               \
                                            sIn >> psttEmailPenpalExactOr ; ___( psttEmailPenpalExactOr ) ;
                                            ZE( strokeS* , psttEmailPenpalExactOr ) ;
                                        {
                                        while( cEmailPenpalExactOr -- )
                                        sIn >> cEmailPenpalExactOr ;
                                        ZE( countT , cEmailPenpalExactOr ) ;
        
                                        }
                                            SpUSHfIFOoStEXT( hListSub , SfIELD_postRecipe ) ;
                                            etThread.delF( tinP , psttRecipe ) ;
                                            postzValue = tValue ;
                                            tValue = T(psttRecipe) ;
                                            sIn >> psttRecipe ; ___( psttRecipe ) ;
                                            ZE( strokeS* , psttRecipe ) ;
                                        {
                                        while( cRecipe -- )
                                        sIn >> cRecipe ;
                                        ZE( countT , cRecipe ) ;
        
                                        }
                                            SpUSHfIFOoStEXT( hListSub , SfIELD_postAutoresponse ) ;
                                            etThread.delF( tinP , psttAutoResponse ) ;
                                            postzValue = tValue ;
                                            tValue = T(psttAutoResponse) ;
                                            sIn >> psttAutoResponse ; ___( psttAutoResponse ) ;
                                            ZE( strokeS* , psttAutoResponse ) ;
                                        {
                                        while( cAutoResponse -- )
                                        sIn >> cAutoResponse ;
                                        ZE( countT , cAutoResponse ) ;
        
                                        SpUSHfIFOcOUNT( hListSub , SfIELD_cEmailRelayDrawings , cEmailRelayDrawings ) ;
                                        if( cEmailRelaySave < 2 || cEmailRelayDrawings >= cEmailRelaySave ) cEmailRelayDrawings = 0 ;
                                        //POPUPcOUNT( "SETsUBACCOUNTdESCRIPTION: received [cEmailRelayDrawings]: " , cEmailRelayDrawings ) ; //U::
                                        sIn >> cEmailRelayDrawings ;
                                        ZE( countT , cEmailRelayDrawings ) ;
        
                                        }
                                            SpUSHfIFOoStEXT( hListSub , SfIELD_postEmailRelay ) ;
                                            etThread.delF( tinP , psttEmailRelay ) ;
                                            postzValue = tValue ;
                                            tValue = T(psttEmailRelay) ;
                                            if( psttEmailRelay ) etThread.strConvertToLowerCaseF( tinP , psttEmailRelay ) ;
                                            sIn >> psttEmailRelay ; ___( psttEmailRelay ) ;
                                            ZE( strokeS* , psttEmailRelay ) ;
                                        {
                                        while( cEmailRelay -- )
                                        const countT cEmailRelaySave = cEmailRelay ;
                                        sIn >> cEmailRelay ;
                                        ZE( countT , cEmailRelay ) ;
        
                                        SpUSHfIFOoStEXT( hListSub , SfIELD_postNameOut ) ;
                                        etThread.delF( tinP , psttNameOut ) ;
                                        postzValue = tValue ;
                                        tValue = T(psttNameOut) ;
                                        sIn >> psttNameOut ; ___( psttNameOut ) ;
                                        ZE( strokeS* , psttNameOut ) ;
        
                                        SpUSHfIFOoStEXT( hListSub , SfIELD_postNameIn ) ;
                                        etThread.delF( tinP , psttNameIn ) ;
                                        postzValue = tValue ;
                                        tValue = T(psttNameIn) ;
                                        sIn >> psttNameIn ; ___( psttNameIn ) ;
                                        ZE( strokeS* , psttNameIn ) ;
        
                                        SpUSHfIFOoStEXT( hListSub , SfIELD_postTitle ) ;
                                        etThread.delF( tinP , psttTitle ) ;
                                        tValue = T(psttTitle) ;
                                        sIn >> psttTitle ; ___( psttTitle ) ;
                                        ZE( strokeS* , psttTitle ) ;
        
                                        SpUSHfIFOcOUNT( hListSub , SfIELD_flagsMemberOf , fliSUBACCOUNTmEMBERoF_null ) ;
                                        SpUSHfIFOcOUNT( hListSub , SfIELD_idMode        , ifcIDmODEsUBACCOUNT_NORMAL ) ;
        
                                        SpUSHfIFOcOUNT( hListSub , SfIELD_flagsMode     , flagsMode ) ;
                                        sIn >> flagsMode ;
                                        ZE( flagsT , flagsMode ) ;
        
                                        //THESE ARE STORED AS PLACEHOLDERS FOR FUTURE ENHANCEMENT
        
                                        ZE( osTextT* , postzValue ) ;
                                        TN( tValue , "" ) ;
                                    {
                                    if( ~hListSub )
    
                                    // hListSub IS AN OPEN HANDLE TO idSub AND idSub IS NONZE AND HAS NO DESCRIPTION
                                    }
                                        PUSE( tinP , *(byteT**)&pczSub ) ;
                                        }
                                            }
                                                }
                                                    break ;
                                                    }
                                                        THREADmODE2rESTORE
                                                        }
                                                            PUSE.unlistOld2012F( tinP , hListSub , &arg ) ;
                                                            arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;
                                                            listWalkArgOldS arg( tinP ) ;
                                                            puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                                        {
                                                        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                                                    {
                                                    if( ~hListSub ) //SHOULD ALWAYS BE TRUE; HERE TO ENSURE NO BLAMMO IN unlistOld2012F
    
                                                    }
                                                        break ;
                                                        __1 ;
                                                        hListSub.closeIfF() ;
                                                    {
                                                    if( !bExisted )
                                                {
                                                else
                                                }
                                                    }
                                                        hListSub.closeIfF() ;
                                                        idSub = 0 ;
                                                    {
                                                    else
                                                    if( !bExisted ) break ;
                                                {
                                                if( bNoSubSpecified )
        
                                                }
                                                    THREADmODE2rESTORE
                                                    }
                                                        bExisted = PUSE.openKidListOld2012F( tinP , hListSub , hListAcc , pczSub ) ;
                                                        puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                                    {
                                                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                                                {
                                                if( !POOP )
                                                ZE( boolT , bExisted ) ;
        
                                                etherC::strStretchIF( tinP , pczSub , count2S( GfIELD_listSubaccounts ) , idSub ) ;
                                                pczSub[ offo ] = 0 ;
                                                for( countT offo = 0 ; offo < ccSub ; offo ++ ) pczSub[ offo ] = LISTnAME_PLACEhOLDER ;
            
                                                }
                                                    __( idSub == - 1 ) ;
                                                    __Z( idSub ) ;
                                                    idSub = etherC::ranUniI_IF( tinP ) * (measureT)MAXcOUNTT ;
                                                    bNoSubSpecified = 1 ;
                                                {
                                                if( !idSub )
                                                ZE( boolT , bNoSubSpecified ) ;
                                            {
                                            for(;;)
                                        {
                                        if( pczSub )
                                        countT* pczSub = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccSub + 1 ) ) ; ___( pczSub ) ;
                                        const countT ccSub = 1 + sizeof idSub ;
                                    {
                                    handleC hListSub( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LIST oLD ) ;
    
                                    //CONoUTrAW5( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_SETsUBACCOUNTdESCRIPTION: " , idAccount , "." , idSub , "\r\n" ) ;
                                {
                                if( !POOP )

                                __( idSub == - 1 ) ;
                                sIn >> idSub ;

                                __Z( hListAcc ) ; //IF I CREATED THE ACCOUNT THEN IT HAS NO DESCRIPTION
                                }
                                    THREADmODE2rESTORE
                                    }
                                        PUSE.openListOld2012F( tinP , hListAcc , pczAccount ) ;
                                        puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                    {
                                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                                {
                                handleC hListAcc( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LIST oLD ) ;
                                grabitC grabit( tinP , TAG( TAGiDnULL ) ) ;
                            {

                            etherC::strStretchIF( tinP , pczAccount , count2S( LISTnAME_ROOTaPPLICATION ) , idAccount ) ;
                            pczAccount[ offo ] = 0 ;
                            for( countT offo = 0 ; offo < ccAccount ; offo ++ ) pczAccount[ offo ] = LISTnAME_PLACEhOLDER ;
                        {
                        if( pczAccount )
                        countT* pczAccount = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccAccount + 1 ) ) ; ___( pczAccount ) ;
                        const countT ccAccount = 1 + sizeof idAccount ;
                    {
                    if( idAccount )
                    ZE( boolT , bDone ) ;

                    sIn >> idAccount ;
                    ZE( countT , idAccount ) ;
                    ZE( countT , idSub ) ;
                    _IO_
                {
                case ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_SETsUBACCOUNTdESCRIPTION :
                }
                    break ;
                    CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/0 [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG

                    }
                        CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/1 [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                        }
                            CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/2 [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                            etThread( tinP , pStk_idNameFound ) ;
                            etThread( tinP , pStk_pcName      ) ;
                            }
                                CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/3 [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                                }
                                    PUSE( tinP , *(byteT**)&pcName ) ;
                                    }
                                        if( *pStk_pcName ) thirdC::c_memcpyIF( tinP , (byteT*)pcLag4 , (byteT*)pcName , sizeof pcLag4 ) ;
    
                                        sOut << uu.idAccount ;
                                        uu.pbAccount[ 0 ] = *(byteT*)&pcName[ 3 ] ;
                                        uu.pbAccount[ 1 ] = *(byteT*)&pcName[ 2 ] ;
                                        uu.pbAccount[ 2 ] = *(byteT*)&pcName[ 1 ] ;
                                        uu.pbAccount[ 3 ] = *(byteT*)&pcName[ 0 ] ;
    
                                        uu ;
                                        }
                                            byteT  pbAccount[ sizeof( countT ) ] ;
                                            countT idAccount ;
                                        {
                                        union
                                    {
                                    if( pcName[ 0 ] && pcName[ 1 ] && pcName[ 2 ] && pcName[ 3 ] && thirdC::c_memcmpIF( tinP , (byteT*)pcLag4 , (byteT*)pcName , sizeof pcLag4 ) )
    
                                    *pStk_pcName >> pcName ;
                                    ZE( countT* , pcName ) ;
                                {
                                while( *pStk_pcName )
                                countT pcLag4[] = { 0 , 0 , 0 , 0 } ;
                                CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/4 [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
    
                                sOut << cAccount ;
                                }
                                    while( ~hWalk ) ;
                                    }
                                        }
                                            if( ~hWalk ) thirdC::c_memcpyIF( tinP , (byteT*)pcLag4 , (byteT*)pcName , sizeof pcLag4 ) ;
                                            cAccount ++ ;
                                        {
                                        if( pcName[ 0 ] && pcName[ 1 ] && pcName[ 2 ] && pcName[ 3 ] && thirdC::c_memcmpIF( tinP , (byteT*)pcLag4 , (byteT*)pcName , sizeof pcLag4 ) )
    
                                        countT*& pcName = *(countT**)&pStk_pcName->downF( tinP , hWalk ) ;
                                    {
                                    do
                                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    countT pcLag4[] = { 0 , 0 , 0 , 0 } ;
                                {
                                if( *pStk_pcName )
                                ZE( countT , cAccount ) ;
                                CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/5 [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                                //COUNT THE UNIQUE NAMES, INSPECTING ONLY THE WOTH 4 ELEMENTS
    
                                }
                                    CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/6 [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                                    PUSE( tinP , *(byteT**)&pcName ) ;
                                    }
                                        }
                                            *pStk_pcName << pcName ; pcName = 0 ;
                                            pcName[ offNestLevel = 1 ] = 0 ;
                                        {
                                        if( !*pStk_idNameFound )
    
                                        offNestLevelLag = offNestLevel ;
    
                                        pcName[ offNestLevel ] = idName ;
    
                                        }
                                            *pStk_pcName << pcName ; pcName = pcNameNew ;
                                            pcName[ offNestLevelLag + 1 ] = 0 ;
    
                                            thirdC::c_memcpyIF( tinP , (byteT*)pcNameNew , (byteT*)pcName , sizeof( countT ) * offNestLevelLag ) ;
                                            __Z( pcNameNew ) ;
                                            countT* pcNameNew = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( offNestLevelMax + 2 ) ) ; ___( pcNameNew ) ;
                                        {
                                        if( offNestLevelLag + 1 != offNestLevel )
                                        __( offNestLevelLag + 1 <  offNestLevel ) ; //POSITOINS MAY NOT BE SKIPPED
    
                                        *pStk_idNameFound >> pb_pc2 ;
                                    {
                                    while( *pStk_idNameFound )
                                    byteT*  pb_pc2       = (byteT*)pc2 ;
                                    countT& idName       = pc2[ 1 ] ;
                                    countT& offNestLevel = pc2[ 0 ] ;
                                    countT  pc2[ 2 ]                ;
                                    countT  offNestLevelLag = - 1 ;
    
                                    __Z( pcName ) ;
                                    countT* pcName = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( offNestLevelMax + 2 ) ) ; ___( pcName ) ;
                                    CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/7 [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                                {
                                if( offNestLevelMax != - 1 )
                                CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/8 [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                                //STACK ALL NAMES
    
                                }
                                    while( ~hWalk ) ;
                                    }
                                        if( offNestLevelMax < (sCountT)offNestLevel ) offNestLevelMax = offNestLevel ;
                                        countT& offNestLevel = pStk_idNameFound->downF( tinP , hWalk ) ;
                                    {
                                    do
                                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( *pStk_idNameFound )
                                sCountT offNestLevelMax = - 1 ;
                                CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/9 [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
    
                                THREADmODE2rESTORE
                                }
                                    TELL( "ENUMERATEiDaCCOUNT/called listOld2012F" )
                                    PUSE.listOld2012F( tinP , hListAccs , ifcIDhOWlIST_FIFO , &arg , 0 ) ; //U::baseGrabC NOT REGISTERED IN TIN SEEN 2009.07.20 2009.12.31
                                    _IO_
                                    TELL( "ENUMERATEiDaCCOUNT/calling listOld2012F" )
                                    if( !hListAccs ) { BLAMMO ; } //U::TO FIND A BUG
                                    TELL( "ENUMERATEiDaCCOUNT/checking handle" )
                                    arg.pStk_idNameFound = pStk_idNameFound ;
                                    arg.flagsInspect = flAPTiNSPECT_RECURSE ;
                                    listWalkArgOldS arg( tinP ) ;
                                    puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
                                {
                                THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                                CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/a [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                            {
                            if( pStk_idNameFound )
                            etThread( tinP , pStk_pcName      , TAG( TAGiDnULL ) , flSTACKc_FIFO                 , ifcSTACKtYPE_PTR_countT ) ;
                            etThread( tinP , pStk_idNameFound , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_BLOB , 2 * sizeof( countT )    ) ;
                            ZE( stackC* , pStk_pcName ) ;
                            ZE( stackC* , pStk_idNameFound ) ;
                            CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/b [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                        {
                        if( !POOP )

                        CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/c [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                        __Z( hListAccs ) ;
                        CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/d [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                        THREADmODE2rESTORE
                        }
                            PUSE.openListOld2012F( tinP , hListAccs , count2S( LISTnAME_ROOTaPPLICATION ) ) ;
                            puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        {
                        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                        handleC hListAccs( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LIST oLD ) ;
                        grabitC grabit( tinP , TAG( TAGiDnULL ) ) ;
                        CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/e [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                    {
                    if( !POOP )
                    //CONoUTrAW( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT\r\n" ) ;
                    _IO_
                    CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT/f [poop]: " , POOP , "\r\n" ) ; //U::TO FIND A BUG
                {
                case ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT :
                }
                    break ;
                    sOut << bExisted ;

                    }
                        PUSE( tinP , *(byteT**)&pczAccount ) ;
                        }
                            THREADmODE2rESTORE
                            }
                                bExisted = PUSE.openListOld2012F( tinP , hListAcc , pczAccount , flLISTwALKoLD_DOnOTcREATElIST ) ;
                                puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                            {
                            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                            handleC hListAcc( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LIST oLD ) ;
                            grabitC grabit( tinP , TAG( TAGiDnULL ) ) ;

                            etherC::strStretchIF( tinP , pczAccount   , count2S( LISTnAME_ROOTaPPLICATION   ) , idAccount ) ;
                            pczAccount[ offo ] = 0 ;
                            for( countT offo = 0 ; offo < ccAccount ; offo ++ ) pczAccount[ offo ] = LISTnAME_PLACEhOLDER ;
                        {
                        if( !POOP )

                        __Z( pczAccount ) ;
                        countT* pczAccount = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccAccount + 1 ) ) ; ___( pczAccount ) ;
                        const countT ccAccount = 1 + sizeof idAccount ;
                    {
                    if( !POOP )
                    ZE( boolT , bExisted ) ;

                    //CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_TESTiDaCCOUNT: " , idAccount , "\r\n" ) ;

                    __Z( idAccount ) ;
                    sIn >> idAccount ;
                    ZE( countT , idAccount ) ;
                    _IO_
                {
                case ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_TESTiDaCCOUNT :
                }
                    break ;
                    }
                        sOut << bExisted ;

                        PUSE( tinP , *(byteT**)&pczAccount ) ;
                        }
                            THREADmODE2rESTORE
                            }
                                bExisted = PUSE.unlistOld2012F( tinP , pczAccount ) ; //DOES NOT REMOVE idAccount; IT'S LIST STILL EXISTS BUT IS NOW EMPTY; ONCE AN idAccount IS CREATED, IT CAN BE DISABLED (BY MAKING IT EMPTY) BUT IT IS NEVER FORGOTTEN SO WILL NEVER BE REASSIGNED USING A RANDOM DRAWING
                                puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                            {
                            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                            etherC::strStretchIF( tinP , pczAccount   , count2S( LISTnAME_ROOTaPPLICATION   ) , idAccount ) ;
                            pczAccount[ offo ] = 0 ;
                            for( countT offo = 0 ; offo < ccAccount ; offo ++ ) pczAccount[ offo ] = LISTnAME_PLACEhOLDER ;
                        {
                        if( !POOP )
                        ZE( boolT , bExisted ) ;

                        __Z( pczAccount ) ;
                        countT* pczAccount = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccAccount + 1 ) ) ; ___( pczAccount ) ;
                        const countT ccAccount = 1 + sizeof idAccount ;
                    {
                    if( !POOP )

                    //CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_DELETEaCCOUNTdESCRIPTION: " , idAccount , "\r\n" ) ;

                    __Z( idAccount ) ;
                    sIn >> idAccount ;
                    ZE( countT , idAccount ) ;
                    _IO_
                {
                case ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_DELETEaCCOUNTdESCRIPTION :
                }
                    break ;
                    }
                        PUSE( tinP , *(byteT**)&pczDesc ) ;
                        }
                            }
                                bDone = 1 ;
                                }
                                    THREADmODE2rESTORE
                                    }
                                        PUSE.ungrabListOld2012F( tinP , hListDesc ) ;
                                        puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
                                    {
                                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttHelloGreeting               ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttDirectoryGreeting           ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttPaypalProtectionEligibility ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttPaypalPayerStatus           ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttPaypalPayerId               ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttPaypalPayerEmail            ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttCharset                     ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttZipAt                       ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttResidenceCountry            ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttLastName                    ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttFirstName                   ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttAddressStatus               ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttAddressCountry              ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttAddressZip                  ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttAddressCountryCode          ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttAddressState                ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttAddressCity                 ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttAddressStreet               ) ;
                                    AqUERYlONEoStEXT( hListDesc , AfIELD_psttAddressName                 ) ;
                                    AqUERYlONEcOUNT(  hListDesc , AfIELD_flagsMode                       ) ;
                                {
                                if( ~hListDesc )
    
                                sOut << (countT)!!~hListDesc ;
                                //CONoUTrAW5( "idAcc " , idAccount , " description exists: " , !!~hListDesc , "\r\n" ) ;

                                }
                                    THREADmODE2rESTORE
                                    }
                                        PUSE.openListOld2012F( tinP , hListDesc , pczDesc , flLISTwALKoLD_DOnOTcREATElIST ) ;
                                        puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                    {
                                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                                {
                                handleC hListDesc( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LIST oLD ) ;
                                grabitC grabit( tinP , TAG( TAGiDnULL ) ) ;
                            {

                            *( pczDesc + 1 + sizeof idAccount ) = GfIELD_listDescription ;
                            etherC::strStretchIF( tinP , pczDesc , count2S( LISTnAME_ROOTaPPLICATION ) , idAccount ) ;
                            pczDesc[ offo ] = 0 ;
                            for( countT offo = 0 ; offo < ccDesc ; offo ++ ) pczDesc[ offo ] = LISTnAME_PLACEhOLDER ;
                        {
                        if( pczDesc )
                        countT* pczDesc = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccDesc + 1 ) ) ; ___( pczDesc ) ;
                        const countT ccDesc = 2 + sizeof idAccount ;
                    {
                    if( !POOP )
                    ZE( boolT , bDone ) ;

                    //CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_QUERYaCCOUNTdESCRIPTION: " , idAccount , "\r\n" ) ;

                    __Z( idAccount ) ;
                    sIn >> idAccount ;
                    ZE( countT , idAccount ) ;
                    _IO_
                {
                case ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_QUERYaCCOUNTdESCRIPTION :
                }
                    break ;

                    sOut << bDone ;
                    }
                        PUSE( tinP , *(byteT**)&pczDesc ) ;
                        }
                            }
                                }
                                    THREADmODE2rESTORE
                                    }
                                        PUSE.ungrabListOld2012F( tinP , hListDesc ) ;
                                        puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
                                    {
                                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                                {
                                if( ~hListDesc )

                                }
                                    bDone = 1 ;

                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttHelloGreeting               ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttDirectoryGreeting           ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttPaypalProtectionEligibility ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttPaypalPayerStatus           ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttPaypalPayerId               ) ;
                                    ApUSHfIFOoStEXTlOWER(   hListDesc , AfIELD_psttPaypalPayerEmail            ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttCharset                     ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttZipAt                       ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttResidenceCountry            ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttLastName                    ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttFirstName                   ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttAddressStatus               ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttAddressCountry              ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttAddressZip                  ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttAddressCountryCode          ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttAddressState                ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttAddressCity                 ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttAddressStreet               ) ;
                                    ApUSHfIFOoStEXT(        hListDesc , AfIELD_psttAddressName                 ) ;
    
                                    ApUSHfIFOcOUNT(         hListDesc , AfIELD_flagsMemberOf , fliACCOUNTmEMBERoF_null ) ;
                                    ApUSHfIFOcOUNT(         hListDesc , AfIELD_idMode        , ifcIDmODEaCCOUNT_NORMAL ) ;
                                    ApUSHfIFOcOUNT(         hListDesc , AfIELD_flagsMode     , flagsMode               ) ;
                                    //THESE ARE STORED AS PLACEHOLDERS FOR FUTURE ENHANCEMENT
    
                                    sIn >> flagsMode ;
                                    ZE( flagsT , flagsMode ) ;
    
                                    ZE( strokeS* , psttw ) ;
                                    ZE( osTextT* , postzValue ) ;
                                    TN( tValue , "" ) ;
                                {
                                if( !POOP )

                                __Z( hListDesc ) ;
                                }
                                    THREADmODE2rESTORE
                                    }
                                        PUSE.unlistOld2012F( tinP , hListDesc , &arg ) ;
                                        arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;
                                        listWalkArgOldS arg( tinP ) ;
                                        PUSE.openListOld2012F( tinP , hListDesc , pczDesc ) ;
                                        puseC puseAccount( puseMasterP ) ; //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                    {
                                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                                {
                                handleC hListDesc( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LIST oLD ) ;
                                grabitC grabit( tinP , TAG( TAGiDnULL ) ) ;
                            {

                            *( pczDesc + 1 + sizeof idAccount ) = GfIELD_listDescription ;
                            etherC::strStretchIF( tinP , pczDesc , count2S( LISTnAME_ROOTaPPLICATION ) , idAccount ) ;
                            pczDesc[ offo ] = 0 ;
                            for( countT offo = 0 ; offo < ccDesc ; offo ++ ) pczDesc[ offo ] = LISTnAME_PLACEhOLDER ;
                        {
                        if( pczDesc )
                        countT* pczDesc = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccDesc + 1 ) ) ; ___( pczDesc ) ;
                        const countT ccDesc = 2 + sizeof idAccount ;
                    {
                    if( idAccount )
                    ZE( boolT , bDone ) ;

                    //CONoUTrAW3( "ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_SETaCCOUNTdESCRIPTION: " , idAccount , "\r\n" ) ;

                    sIn >> idAccount ;
                    ZE( countT , idAccount ) ;
                    _IO_
                {
                case ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_SETaCCOUNTdESCRIPTION :
            {
            switch( idCmd )

            sOut << (countT)1 ; //idFormat
            sOut << (countT)FINGERnEG_LISTsERVERrEPLY ;
            soulC sOut( tinP , TAG( TAGiDnULL ) ) ;

            sIn >> idCmd ;
            ZE( countT , idCmd ) ;

            __( idFormat - 1 ) ;
            sIn >> idFormat ;
            ZE( countT , idFormat ) ;

            __( finger - FINGERnEG_LISTsERVERcMD ) ;
            sIn >> finger ;
            ZE( countT , finger ) ;

            psoP->readF( tinP , sIn ) ;
            soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
            _IO_
        {
        while( !ether && !POOP )

        psoP->etherF( tinP , *tinP.pEtScratch ) ;
        SCOOPS
    {
    IFsCRATCH
    _IO_

    puseC&    puseMasterP =  *(puseC*)pTaskP->c2 ;
    socketC*  psoP      = (socketC*)pTaskP->c1 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmListServeF )

}
    return heavy ;

    }
        }
            }
                }
                    break ;
                    }
                        }
                            break ;
                            }
                                //CONoUTrAW3( "listingInspectConfirmCBF new [pFlagsMode]: " , *pFlagsMode , "\r\n" ) ;  //U::
                                }
                                    *pFlagsMode |= fliSUBACCOUNTmODE_OWNERcONFIRMED ;
                                    argP.cValueFound ++ ;
                                {
                                if( pFlagsMode && !( F(*pFlagsMode) & fliSUBACCOUNTmODE_OWNERcONFIRMED ) )
                                //CONoUTrAW3( "listingInspectConfirmCBF old [pFlagsMode]: " , *pFlagsMode , "\r\n" ) ;  //U::
                                countT* pFlagsMode = Ac OUNT ;
                            {
                            if( pczListNameP[ ccListName  - 1 ] == SfIELD_flagsMode )
                            countT ccListName = thirdC::c_strlenIF( tinP , pczListNameP ) ;
                        {
                        case ifcIDtYPEmIXINdATUM_countT : //listing_countT_C
                    {
                    switch( pdListing->idTypeDatumF() )
                {
                case fliLISTINGc_MIXINdATUM :
                }
                    break ;

                    }
                        PUSE( tinP , *(byteT**)&pczListNameKid ) ;
                        puseC puse( tinP , ifcIDpOOL_ADAMtEMP ) ;
                    {

                    }
                        argP.flagsWalk = flagsSave ;

                        -- *(countT*)&argP.offNestLevel ;
                        aList.walkOldF( tinP , ifcIDmODEaPTsINK_LEADsHOES , &argP , 0 , listingInspectConfirmCBF , pczListNameKid ) ;
                        ++ *(countT*)&argP.offNestLevel ;

                        argP.flagsWalk |= flLISTwALKoLD_DOnOTuNGRABlIST ;
                        flagsT flagsSave = argP.flagsWalk ;
    
                        pczListNameKid[ ccDad    ] = 0 ;
                        pczListNameKid[ ccDad ++ ] = A lIST.idNameF() ;
                        thirdC::c_memcpyIF( tinP , (byteT*)pczListNameKid , (byteT*)pczListNameP , sizeof( countT ) * ccDad ) ;
                    {
                    if( pczListNameKid )

                    }
                        pczListNameKid = (countT*)PUSE.newF( tinP , LF , sizeof( countT ) * ( ccDad + 2 ) ) ; ___( pczListNameKid ) ;
                        puseC puse( tinP , ifcIDpOOL_ADAMtEMP ) ;
                    {
                    ZE( countT* , pczListNameKid ) ;
                    countT ccDad = thirdC::c_strlenIF( tinP , pczListNameP ) ;
                    
                    listC& aList = A lIST ;
                {
                case fliLISTINGc_MIXINlIST : // listC
            {
            switch( pdListing->flagsF() & fliLISTINGc_maskTypeBits )
        {
        if( !POOP )

        __( !listingC::bIsListingIF( tinP , aptP ) ) ;
        listingC* pdListing = &APT( listingC , aptP ) ;
    {
    if( aptP )
    ZE( sCountT , heavy ) ;

    _IO_

    if( POOP ) return 0 ;
{
sCountT listingInspectConfirmCBF( tinS& tinP , aptC& aptP , listWalkArgOldS& argP , const countT* pczListNameP )

    }
        etThread( tinP , pStk_cValueFound ) ;                                                                                                                   \
        }                                                                                                                                                       \
            }                                                                                                                                                   \
                PUSE( tinP , postv ) ;                                                                                                                          \
                sOut << ( postv ? (strokeS*)T(postv) : (strokeS*)0 ) ;                                                                                          \
                *pStk_cValueFound >> *(countT*)&postv ;                                                                                                         \
                ZE( osTextT* , postv ) ;                                                                                                                      \
            {                                                                                                                                                   \
            while( *pStk_cValueFound )                                                                                                                          \
            sOut << (countT)*pStk_cValueFound ;                                                                                                                 \
                                                                                                                                                                \
            THREADmODE2rESTORE                                                                                                                                  \
            }                                                                                                                                                   \
                PUSE.listOld2012F( tinP , handleP , pc2 , ifcIDhOWlIST_FIFO , &arg , 0 , listingInspectOldCBF ) ;                                                         \
                _IO_                                                                                                                                            \
                countT pc2[] = { (cNameP) , 0 } ;                                                                                                               \
                                                                                                                                                                \
                arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;                                                                                                    \
                arg.pStk_cValueFound = pStk_cValueFound ;                                                                                                       \
                arg.flagsInspect = flAPTiNSPECT_RETURNcOPY ;                                                                                                    \
                listWalkArgOldS arg( tinP ) ;                                                                                                                      \
                puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/                   \
            {                                                                                                                                                   \
            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )                                                                                                   \
        {                                                                                                                                                       \
        if( pStk_cValueFound )                                                                                                                                  \
        etThread( tinP , pStk_cValueFound , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;                                                                                \
        ZE( stackC* , pStk_cValueFound ) ;                                                                                                                    \
    {                                                                                                                                                           \
                                                                                                                                                                \
#define SqUERYmULTIPLEoStEXT(handleP,cNameP)                                                                                                                    \

    }
        PUSE( tinP , postv ) ;                                                                                                                                  \
        sOut << ( postv ? (strokeS*)T(postv) : (strokeS*)0 ) ;                                                                                                  \
        THREADmODE2rESTORE                                                                                                                                      \
        }                                                                                                                                                       \
            postv = (osTextT*)arg.cValueFound ;                                                                                                                 \
                                                                                                                                                                \
            PUSE.listOld2012F( tinP , handleP , pc2 , ifcIDhOWlIST_FIFO , &arg , 0 , listingInspectOldCBF ) ;                                                             \
            _IO_                                                                                                                                                \
            countT pc2[] = { (cNameP) , 0 } ;                                                                                                                   \
                                                                                                                                                                \
            arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;                                                                                                        \
            arg.flagsInspect = flAPTiNSPECT_RETURNcOPY ;                                                                                                        \
            listWalkArgOldS arg( tinP ) ;                                                                                                                          \
            puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/                       \
        {                                                                                                                                                       \
        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )                                                                                                       \
        ZE( osTextT* , postv ) ;                                                                                                                              \
    {                                                                                                                                                           \
                                                                                                                                                                \
#define SqUERYlONEoStEXT(handleP,cNameP)                                                                                                                        \

    }
        sOut << cValue ;                                                                                                                                        \
        THREADmODE2rESTORE                                                                                                                                      \
        }                                                                                                                                                       \
            cValue = arg.cValueFound ;                                                                                                                          \
            PUSE.listOld2012F( tinP , handleP , pc2 , ifcIDhOWlIST_FIFO , &arg , 0 , listingInspectOldCBF ) ;                                                             \
            _IO_                                                                                                                                                \
            arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;                                                                                                        \
            listWalkArgOldS arg( tinP ) ;                                                                                                                          \
            countT pc2[] = { (cNameP) , 0 } ;                                                                                                                   \
            puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/                       \
        {                                                                                                                                                       \
        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )                                                                                                       \
        ZE( countT , cValue ) ;                                                                                                                               \
    {                                                                                                                                                           \
                                                                                                                                                                \
#define SqUERYlONEcOUNT(handleP,cNameP)                                                                                                                         \

    }
        PUSE( tinP , postv ) ;                                                                                                                                  \
        sOut << ( postv ? (strokeS*)T(postv) : (strokeS*)0 ) ;                                                                                                  \
        /*CONoUTrAW( T(tinP.postThreadName)+T("| AqUERY [")+TF2(cNameP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("]: \"")+T(postv)+T("\"\r\n") ) ;   */       \
        THREADmODE2rESTORE                                                                                                                                      \
        }                                                                                                                                                       \
            postv = (osTextT*)arg.cValueFound ;                                                                                                                 \
                                                                                                                                                                \
            PUSE.listOld2012F( tinP , handleP , pc2 , ifcIDhOWlIST_FIFO , &arg , 0 , listingInspectOldCBF ) ;                                                             \
            _IO_                                                                                                                                                \
            countT pc2[] = { (cNameP) , 0 } ;                                                                                                                   \
                                                                                                                                                                \
            arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;                                                                                                        \
            arg.flagsInspect = flAPTiNSPECT_RETURNcOPY ;                                                                                                        \
            listWalkArgOldS arg( tinP ) ;                                                                                                                          \
            puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/                       \
        {                                                                                                                                                       \
        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )                                                                                                       \
        ZE( osTextT* , postv ) ;                                                                                                                              \
    {                                                                                                                                                           \
                                                                                                                                                                \
#define AqUERYlONEoStEXT(handleP,cNameP)                                                                                                                        \

    }
        sOut << cValue ;                                                                                                                                        \
        THREADmODE2rESTORE                                                                                                                                      \
        }                                                                                                                                                       \
            cValue = arg.cValueFound ;                                                                                                                          \
                                                                                                                                                                \
            PUSE.listOld2012F( tinP , handleP , pc2 , ifcIDhOWlIST_FIFO , &arg , 0 , listingInspectOldCBF ) ;                                                             \
            _IO_                                                                                                                                                \
            arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;                                                                                                        \
            listWalkArgOldS arg( tinP ) ;                                                                                                                          \
            countT pc2[] = { (cNameP) , 0 } ;                                                                                                                   \
            puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/                       \
        {                                                                                                                                                       \
        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )                                                                                                       \
        ZE( countT , cValue ) ;                                                                                                                               \
    {                                                                                                                                                           \
                                                                                                                                                                \
#define AqUERYlONEcOUNT(handleP,cNameP)                                                                                                                         \

    }
        THREADmODE2rESTORE                                                                                                                                      \
        }                                                                                                                                                       \
            PUSE.listOld2012F( tinP , handleP , pc2 , ifcIDhOWlIST_FIFO , &arg , li stingAttachOldCBF , listingInspectOldCBF ) ;                                              \
            _IO_                                                                                                                                                \
            countT pc2[] = { (cNameP) , 0 } ;                                                                                                                   \
            arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;                                                                                                        \
            arg.cValueAttachSpec = (countT)postzValue ;                                                                                                         \
            arg.idTypeAttach = ifcIDtYPElISTING_OStEXTsTRz ;                                                                                                    \
            listWalkArgOldS arg( tinP ) ;                                                                                                                          \
            puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/                       \
        {                                                                                                                                                       \
        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )                                                                                                       \
    {                                                                                                                                                           \
    postzValue = tValue ;                                                                                                                                       \
                                                                                                                                                                \
#define SpUSHfIFOoStEXT(handleP,cNameP)                                                                                                                         \

    }
        THREADmODE2rESTORE                                                                                                                                      \
        }                                                                                                                                                       \
            PUSE.listOld2012F( tinP , handleP , pc2 , ifcIDhOWlIST_FIFO , &arg , li stingAttachOldCBF , listingInspectOldCBF ) ;                                              \
            _IO_                                                                                                                                                \
            countT pc2[] = { (cNameP) , 0 } ;                                                                                                                   \
            arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;                                                                                                        \
            arg.cValueAttachSpec = (countT)postzValue ;                                                                                                         \
            arg.idTypeAttach = ifcIDtYPElISTING_OStEXTsTRz ;                                                                                                    \
            listWalkArgOldS arg( tinP ) ;                                                                                                                          \
            puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/                       \
        {                                                                                                                                                       \
        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )                                                                                                       \
    {                                                                                                                                                           \
    postzValue = tValue ;                                                                                                                                       \
    etThread.delF( tinP , psttw ) ;                                                                                                                             \
    tValue = T(psttw) ;                                                                                                                                         \
    if( psttw ) etThread.strConvertToLowerCaseF( tinP , psttw ) ;                                                                                               \
    sIn >> psttw ; ___( psttw ) ;                                                                                                                               \
                                                                                                                                                                \
#define ApUSHfIFOoStEXTlOWER(handleP,cNameP)                                                                                                                    \

    }
        THREADmODE2rESTORE                                                                                                                                      \
        }                                                                                                                                                       \
            PUSE.listOld2012F( tinP , handleP , pc2 , ifcIDhOWlIST_FIFO , &arg , li stingAttachOldCBF , listingInspectOldCBF ) ;                                              \
            _IO_                                                                                                                                                \
            countT pc2[] = { (cNameP) , 0 } ;                                                                                                                   \
            arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;                                                                                                        \
            arg.cValueAttachSpec = (countT)postzValue ;                                                                                                         \
            arg.idTypeAttach = ifcIDtYPElISTING_OStEXTsTRz ;                                                                                                    \
            listWalkArgOldS arg( tinP ) ;                                                                                                                          \
            puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/                       \
        {                                                                                                                                                       \
        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )                                                                                                       \
    {                                                                                                                                                           \
    postzValue = tValue ;                                                                                                                                       \
    etThread.delF( tinP , psttw ) ;                                                                                                                             \
    tValue = T(psttw) ;                                                                                                                                         \
    sIn >> psttw ; ___( psttw ) ;                                                                                                                               \
                                                                                                                                                                \
#define ApUSHfIFOoStEXT(handleP,cNameP)                                                                                                                         \

    }
        THREADmODE2rESTORE                                                                                                                                      \
        }                                                                                                                                                       \
            PUSE.listOld2012F( tinP , handleP , pc2 , ifcIDhOWlIST_FIFO , &arg , li stingAttachOldCBF , listingInspectOldCBF ) ;                                              \
            _IO_                                                                                                                                                \
            countT pc2[] = { (cNameP) , 0 } ;                                                                                                                   \
            arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;                                                                                                        \
            arg.cValueAttachSpec = (countT)cValueP ;                                                                                                            \
            arg.idTypeAttach = ifcIDtYPElISTING_COUNTt ;                                                                                                        \
            listWalkArgOldS arg( tinP ) ;                                                                                                                          \
            puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/                       \
        {                                                                                                                                                       \
        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )                                                                                                       \
    {                                                                                                                                                           \
                                                                                                                                                                \
#define SpUSHfIFOcOUNT(handleP,cNameP,cValueP)                                                                                                                  \

    }
        THREADmODE2rESTORE                                                                                                                                      \
        }                                                                                                                                                       \
            PUSE.listOld2012F( tinP , handleP , pc2 , ifcIDhOWlIST_FIFO , &arg , li stingAttachOldCBF , listingInspectOldCBF ) ;                                              \
            _IO_                                                                                                                                                \
            countT pc2[] = { (cNameP) , 0 } ;                                                                                                                   \
            arg.flagsWalk = flLISTwALKoLD_DOnOTuNGRABlIST ;                                                                                                        \
            arg.cValueAttachSpec = (countT)cValueP ;                                                                                                            \
            arg.idTypeAttach = ifcIDtYPElISTING_COUNTt ;                                                                                                        \
            listWalkArgOldS arg( tinP ) ;                                                                                                                          \
            puseC puseAccount( puseMasterP ) ; /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/                       \
        {                                                                                                                                                       \
        THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )                                                                                                       \
    {                                                                                                                                                           \
                                                                                                                                                                \
#define ApUSHfIFOcOUNT(handleP,cNameP,cValueP)                                                                                                                  \

#define SfIELD_cEmailRelayDrawings              LISTnAMEaDAMoLD_d
#define SfIELD_postEmailPenpalContainsAnd       LISTnAMEaDAMoLD_c
#define SfIELD_postEmailPenpalContainsOr        LISTnAMEaDAMoLD_b
#define SfIELD_postEmailPenpalExactOr           LISTnAMEaDAMoLD_a
#define SfIELD_postRecipe                       LISTnAMEaDAMoLD_9
#define SfIELD_postAutoresponse                 LISTnAMEaDAMoLD_8
#define SfIELD_postEmailRelay                   LISTnAMEaDAMoLD_7
#define SfIELD_postNameOut                      LISTnAMEaDAMoLD_6
#define SfIELD_postNameIn                       LISTnAMEaDAMoLD_5
#define SfIELD_postTitle                        LISTnAMEaDAMoLD_4
#define SfIELD_flagsMemberOf                    LISTnAMEaDAMoLD_3
#define SfIELD_idMode                           LISTnAMEaDAMoLD_2
#define SfIELD_flagsMode                        LISTnAMEaDAMoLD_1
//IT IS ILLEGAL TO CHANGE THIS LIST EXCEPT BY ADDING NEW DEFS TO THE TOP (SfIELD_*) CONSTANTS CAN BE RENAMED BUT CANNOT BE CHANGED SEMANTICALLY

#define AfIELD_psttHelloGreeting                LISTnAMEaDAMoLD_61
#define AfIELD_psttDirectoryGreeting            LISTnAMEaDAMoLD_51
#define AfIELD_psttPaypalProtectionEligibility  LISTnAMEaDAMoLD_41
#define AfIELD_psttPaypalPayerStatus            LISTnAMEaDAMoLD_31
#define AfIELD_psttPaypalPayerId                LISTnAMEaDAMoLD_21
#define AfIELD_psttPaypalPayerEmail             LISTnAMEaDAMoLD_11
#define AfIELD_psttCharset                      LISTnAMEaDAMoLD_01
#define AfIELD_psttZipAt                        LISTnAMEaDAMoLD_f
#define AfIELD_psttResidenceCountry             LISTnAMEaDAMoLD_e
#define AfIELD_psttLastName                     LISTnAMEaDAMoLD_d
#define AfIELD_psttFirstName                    LISTnAMEaDAMoLD_c
#define AfIELD_psttAddressStatus                LISTnAMEaDAMoLD_b
#define AfIELD_psttAddressCountry               LISTnAMEaDAMoLD_a
#define AfIELD_psttAddressZip                   LISTnAMEaDAMoLD_9
#define AfIELD_psttAddressCountryCode           LISTnAMEaDAMoLD_8
#define AfIELD_psttAddressState                 LISTnAMEaDAMoLD_7
#define AfIELD_psttAddressCity                  LISTnAMEaDAMoLD_6
#define AfIELD_psttAddressStreet                LISTnAMEaDAMoLD_5
#define AfIELD_psttAddressName                  LISTnAMEaDAMoLD_4
#define AfIELD_flagsMemberOf                    LISTnAMEaDAMoLD_3
#define AfIELD_idMode                           LISTnAMEaDAMoLD_2
#define AfIELD_flagsMode                        LISTnAMEaDAMoLD_1
//IT IS ILLEGAL TO CHANGE THIS LIST EXCEPT BY ADDING NEW DEFS TO THE TOP (SfIELD_*) CONSTANTS CAN BE RENAMED BUT CANNOT BE CHANGED SEMANTICALLY

#define GfIELD_listSubaccounts                  LISTnAMEaDAMoLD_2
#define GfIELD_listDescription                  LISTnAMEaDAMoLD_1
//IT IS ILLEGAL TO CHANGE THIS LIST EXCEPT BY ADDING NEW DEFS TO THE TOP (SfIELD_*) CONSTANTS CAN BE RENAMED BUT CANNOT BE CHANGED SEMANTICALLY
//"G": "GROUP"

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_LISTsERVERiDaCCOUNTdESCRIPTION" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

