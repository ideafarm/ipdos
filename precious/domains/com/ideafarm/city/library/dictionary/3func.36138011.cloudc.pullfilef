
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        __Z( bOk ) ;

        }
            }
                }
                    etPrime.osSleepF( tinP , TOCK ) ;
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                    etScratch.traceF( tinP , T("will retry after napping for a tock") ) ;

                    etScratch.delF( tinP , pbP ) ;

                    POOPR ;
                {
                else
                }
                    break ;
                    bOk = 1 ;
                {
                if( !POOP )

                }
                    pbP[ cbP ] = 0 ;
                    }
                        }
                            }
                                pbc += cbGot ;
                                cDo -= cbGot ;
                            {
                            else
                            if( POOP ) break ;

                            __Z( cbGot ) ;
                            countT cbGot = ss.readF( tinP , pbc , cDo ) ;
                        {
                        while( cDo )
                        countT cDo = cbP ;
                        byteT* pbc = pbP ;
                    {
                    if( !POOP )

                    __Z( pbP ) ;
                    etScratch.newF( tinP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
                {
                if( cbP )
            {
            if( !POOP )

            }
                }
                    else if( !POOP ) offb = - 1 ;
                    if( !offb ) break ;

                    }
                        }
                            etScratch.delF( tinP , psttw ) ;
                            cbP = etScratch.strDigitsToSCountF( tinP , psttw , 0xa , 1 ) ;
                            etScratch.strSubstringF( tinP , psttw , idf , idl , psttLine ) ; ___( psttw ) ;
                            ZE( strokeS* , psttw ) ;

                            ZE( countT , idl ) ;
                            while( psttLine[ CSpREFIX - 1 + idf ] == sttBlank ) idf ++ ;
                            countT idf = tContentLength.csF( tinP ) + 1 ;
                            strokeS* psttLine = tLine ;
                        {
                        if( 1 == etScratch.strIdF( tinP , tContentLength , tLine ) )
                        strokeS sttBlank( ' ' ) ;
                    {
                    if( !POOP )

                    }
                        __NZ( ostLF != '\n' ) ;
                        __Z( ss.readF( tinP , &ostLF , 1 ) ) ;
                        osTextT ostLF ;

                        }
                            //etScratch.traceF( tinP , T("header line: ")+T(postBuffer) ) ;
                            postBuffer[ offb ] = 0 ;
                        {
                        if( offb )
                    {
                    if( !POOP )

                    }
                        }
                            }
                                __1
                                etRock.traceF( tinP , T("[tSay]: ")+tSay ) ;
                                etRock.traceF( tinP , T("pullFileF / exception: did not expect [tLine]: ")+tLine ) ;
                            {
                            if( !etScratch.strIdF( tinP , tReplyCode200_OK , tLine ) )

                            }
                                break ;
                                etherC::etRockIF( tinP ).traceF( tinP , T("authorization refused") ) ;
                            {
                            if( POOP )
                            __NZ( 1 == etScratch.strIdF( tinP , tReplyCode401_Unauthorized , tLine ) ) ;
                        {
                        if( !POOP )

                        __Z( offb ) ;
                        bWoth = 0 ;
                    {
                    if( bWoth )

                    TN( tLine , postBuffer ) ;
                    postBuffer[ offb ] = 0 ;
                {
                if( !POOP && postBuffer[ offb ] == '\r' )         // IF I HAVE A LINE OF HEADER

                __Z( ss.readF( tinP , postBuffer + offb , 1 ) ) ;
            {
            for( offb = 0 ; !POOP && offb < sizeof postBuffer ; offb ++ )
            TN( tContentLength , "Content-Length:" ) ;
            boolT bWoth = 1 ;
            ZE( countT , offb ) ;
            osTextT postBuffer[ TOCK ] ;

            // 
            // my.iddisk
            // administrator.email@foo.com
            // 
            // Date: Mon, 08 Dec 2014 04:14:34 GMT
            // X-Trans-Id: tx567c206bc36246dab9325-00548525aaiad3
            // Content-Type: application/octet-stream
            // X-Timestamp: 1418012073.44724
            // Etag: f1290729de5a5ba08b49016a88a0f740
            // Last-Modified: Mon, 08 Dec 2014 04:14:34 GMT
            // Accept-Ranges: bytes
            // Content-Length: 39
            // HTTP/1.1 200 OK
            // 
            // SAMPLE REPLY

            ss.writeF( tinP , (osTextT*)tSay , (countT)tSay.csF( tinP ) ) ;
            ss.connectF( tinP , 443 , socketC::nicNameIF( tinP , etScratch , tHost ) ) ;
            socketC ss( tinP , etScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL ) ;

            }
                etScratch.delF( tinP , psttShortUrlEncoded ) ;
                }
                    bHandle.ungrabF( tinP ) ;
                    tSay = T("GET ")+tUrlCloudAgent+T("/")+T(psttCloudContainerP)+T("/")+T(psttShortUrlEncoded)+T(" HTTP/1.1\r\nHost: ")+tHost+T("\r\nX-Auth-Token: ")+cloudInfo.tRackspaceAccessToken+T("\r\n\r\n") ;
                    cloudInfoS& cloudInfo = *(cloudInfoS*)hCloud.osF( ifcIDtYPEhANDLE_CLOUD ) ;
                    bHandle.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {

                //  
                // X-Auth-Token: f064c46a782c444cb4ba4b6434288f7c
                // Host: storage.clouddrive.com
                // GET /v1/MossoCloudFS_0672d7fa-9f85-4a81-a3ab-adb66a880123/archive/shortEncodedName HTTP/1.1
                // 
                // EXAMPLE

                etScratch.strToUrlF( tinP , psttShortUrlEncoded , psttShortP ) ; ___( psttShortUrlEncoded ) ;
                ZE( strokeS* , psttShortUrlEncoded ) ;
            {
            if( !tSay.csF( tinP ) )

            //}
            //    __1 ;
            //    bWoth = 0 ;
            //{
            //if( bWoth ) //U:: TO FIND A BUG
        {
        )
            )
                )
                    ( bNoQuitEarly || cTriesRemaining -- )
                    &&
                    !etPrime
                (
                ||
                bNoQuit
            (
            &&
            !POOP
        (
        while
        TN( tSay , "" ) ;

        countT cTriesRemaining = cTriesP ;
        boolT bNoQuitEarly     = !cTriesP ;
        boolT bNoQuit          = cTriesP == - 1 ;

        //boolT bWoth = 1 ; //U::TO FIND A BUG
        etherC& etScratch = *tinP.pEtScratch ;
        etherC& etPrime   = etherC::etPrimeIF( tinP ) ;
        ZE( boolT , bOk ) ;

        SCOOPS
    {
    IFsCRATCH

    //etRock.traceF( tinP , T("the GET utterance has been appended to the log") ) ;
    //LOGrAW( tSay ) ;

    _IO_

    }
        if( POOP ) return ;
        __Z( psttShortP ) ;
        __Z( psttCloudContainerP ) ;
        __NZ( cbP ) ;
        __NZ( pbP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    etherC& etRock = etherC::etRockIF( tinP ) ;

    SCOOP
{
/*1*/voidT cloudC::pullFileF( tinS& tinP , byteT*& pbP , countT& cbP , const strokeS* const psttCloudContainerP , const strokeS* const psttShortP , const countT cTriesP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

