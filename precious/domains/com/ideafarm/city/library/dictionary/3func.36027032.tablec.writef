
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        }
            }
                }
                    default      : { __1 break ; }
                    case _CT1_0f : { nicNameC&  cc = _CT1_0fF( idr , idc ) ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , processGlobal1I.cb_nicNameC_ ) ; break ; }
                    case _CT1_0e : { count8S&  cc = _CT1_0eF( idr , idc ) ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                    case _CT1_0d : { count7S&  cc = _CT1_0dF( idr , idc ) ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                    case _CT1_0c : { count6S&  cc = _CT1_0cF( idr , idc ) ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                    case _CT1_0b : { count5S&  cc = _CT1_0bF( idr , idc ) ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                    case _CT1_0a : { count4S&  cc = _CT1_0aF( idr , idc ) ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                    case _CT1_09 : { count3S&  cc = _CT1_09F( idr , idc ) ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                    case _CT1_08 : { count2S&  cc = _CT1_08F( idr , idc ) ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                    case _CT1_06 : { measureT& cc = _CT1_06F( idr , idc ) ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                    case _CT1_05 : { sCountT&  cc = _CT1_05F( idr , idc ) ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                    case _CT1_04 : { countT&   cc = _CT1_04F( idr , idc ) ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                    case _CT1_01 : { tableC&  tbl = _CT1_01F( idr , idc ) ; tbl.writeF( tinP , handleP )                                 ; break ; }
                {
                switch( idType )
            {
            else
            }
                }
                    /*default      :*/ { __1 /*break ;*/ }
                {
                //switch( idType )
                idType &= ~_CT2_2 ;
            {
            else if( idType & _CT2_2 )
            }
                }
                    default      : { __1 break ; }

                    }
                        break ;
                        if( pstto ) ether.fileWriteF( tinP , handleP , (byteT*)pstto , ( CSpREFIX + pstto->idAdam ) * sizeof( strokeS ) ) ;
                        __Z( pstto ) ;
                        strokeS*& pstto = _CT1_07F(idr,idc) ;
                    {
                    case _CT1_07 :
                {
                switch( idType )
                idType &= ~_CT2_1 ;
            {
            else if( idType & _CT2_1 )
            }
                while( ~hndStack ) ;
                }
                    }
                        }
                            default      : { __1 break ; }
                            case _CT1_0f : { nicNameC& cc = *(nicNameC*)vv ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , processGlobal1I.cb_nicNameC_ ) ; break ; }
                            case _CT1_0e : { count8S& cc = *(count8S*)vv ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                            case _CT1_0d : { count7S& cc = *(count7S*)vv ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                            case _CT1_0c : { count6S& cc = *(count6S*)vv ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                            case _CT1_0b : { count5S& cc = *(count5S*)vv ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                            case _CT1_0a : { count4S& cc = *(count4S*)vv ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                            case _CT1_09 : { count3S& cc = *(count3S*)vv ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                            case _CT1_08 : { count2S& cc = *(count2S*)vv ; ether.fileWriteF( tinP , handleP , (byteT*)&cc , sizeof cc ) ; break ; }
                            case _CT1_06 : {                               ether.fileWriteF( tinP , handleP , (byteT*)&vv , sizeof vv ) ; break ; }
                            case _CT1_05 : {                               ether.fileWriteF( tinP , handleP , (byteT*)&vv , sizeof vv ) ; break ; }
                            case _CT1_04 : {                               ether.fileWriteF( tinP , handleP , (byteT*)&vv , sizeof vv ) ; break ; }
                            case _CT1_01 : { tableC& tbl = *(tableC*)vv ; tbl.writeF( tinP , handleP )                                  ; break ; }
                        {
                        switch( idType2 )
                    {
                    else
                    }
                        }
                            /*default      :*/ { __1 /*break ;*/ }
                        {
                        //switch( idType2 )
                        idType2 &= ~_CT2_2 ;
                    {
                    else if( idType2 & _CT2_2 )
                    }
                        }
                            default      : { __1 break ; }
                            }
                                break ;
                                if( pstto ) ether.fileWriteF( tinP , handleP , (byteT*)pstto , ( CSpREFIX + pstto->idAdam ) * sizeof( strokeS ) ) ;
                                __Z( pstto ) ;
                                strokeS* pstto = (strokeS*)vv ;
                            {
                            case _CT1_07 :
                        {
                        switch( idType2 )
                        idType2 &= ~_CT2_1 ;
                    {
                    if( idType2 & _CT2_1 )
                    countT idType2 = idType ;

                    else                                     vv = stc.upF( tinP , hndStack ) ;
                    if( F(stc.flagsF(tinP)) & flSTACKc_FIFO ) vv = stc.downF( tinP , hndStack ) ; // ITEMS ARE WRITTEN IN THE ORDER THAT THEY WERE PLACED ONTO THE STACK

                    ZE( countT , vv ) ;
                {
                do
                handleC hndStack( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                }
                    ether.fileWriteF( tinP , handleP , (byteT*)&cPlates , sizeof cPlates ) ;
                    countT cPlates = stc ;
                    ether.fileWriteF( tinP , handleP , (byteT*)&idType , sizeof idType ) ;
                    ether.fileWriteF( tinP , handleP , (byteT*)&flags  , sizeof flags  ) ;
                    countT idType = stc.idTypeF( tinP ) ;
                    flagsT flags  = stc.flagsF( tinP ) ;
                {

                stackC& stc = _CT2_3F( idr , idc ) ;
                idType &= ~_CT2_3 ;
            {
            if( idType & _CT2_3 )

            ether.fileWriteF( tinP , handleP , (byteT*)&idType , sizeof idType ) ;
            countT idType = operator()( idr , idc ).c1 ;
        {
        for( countT idc = 1 ; idc <= cCols ; idc ++ )
    {
    for( countT idr = 1 ; idr <= cRows ; idr ++ )

    ether.fileWriteF( tinP , handleP , (byteT*)&cCols , sizeof cCols ) ;
    ether.fileWriteF( tinP , handleP , (byteT*)&cRows , sizeof cRows ) ;

    countT cCols = stNames ;
    countT cRows = stEvents ;

    _INoLD_

    }
        if( POOP ) return ;
        __Z( handleP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT tableC::writeF( tinS& tinP , const handleC& handleP )/*1*/

/**/
*/
  must be an open file handleP with write access
  must not be 0
 handleP
 tinP
arguments
 information about the table, other than the number of rows and columns, is not written
 the contents of each cell are written
 the numbers of rows and of columns are written
writes my data contents to the file specified by handleP
  \<A HREF=\"5.e620104.1.1.0.html\"\>e620104:  WAKEsHOW( "example.simplest.func.1320032.tableC.writeF" )\</A\>
 simplest
examples
\<A HREF=\"5.1320032.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$writeF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

