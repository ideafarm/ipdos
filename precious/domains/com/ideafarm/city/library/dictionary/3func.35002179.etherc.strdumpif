
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    ether.delF( tinP , psttRead ) ;
    }
        ether.strFuseF( tinP , psttP , tle ) ;
        }
            ether.delF( tinP , psttRead ) ;
            ether.strFuseF( tinP , psttP , psttRead ) ;
        {
        if( psttRead )
    {
    if( bPerLineP && ( cbP + cPadSave ) % bPerLineP )

    }
        }
            }
                ether.strFuseF( tinP , psttP , tge ) ;
            {
            else if( bPerGroupP && !( idb % bPerGroupP ) )
            }
                ether.strFuseF( tinP , psttP , tle ) ;
                }
                    ether.strMakeF( tinP , psttRead , T(" ") , bPerLineP * 2 ) ; ___( psttRead ) ;
                    ether.delF( tinP , psttRead ) ;
                    ether.strFuseF( tinP , psttP , psttRead ) ;
                {
                if( psttRead )
            {
            if( bPerLineP  && !( idb % bPerLineP ) )
    
            if( psttRead ) ether.strFuseF( tinP , psttRead , tp1 ) ;
            ether.strFuseF( tinP , psttP , tp2 ) ;
            cPad -- ;
        {
        else
        }
            pbP ++ ;
            }
                }
                    ether.strFuseF( tinP , psttRead , tge ) ;
                {
                if( bPerGrouprP && !( idb % bPerGrouprP ) )
                ether.strFuseF( tinP , psttP , tge ) ;
            {
            else if( bPerGroupP && !( idb % bPerGroupP ) )
            }
                ether.strFuseF( tinP , psttP , tle ) ;
                }
                    ether.strMakeF( tinP , psttRead , T(" ") , bPerLineP * 2 ) ; ___( psttRead ) ;
                    ether.delF( tinP , psttRead ) ;
                    ether.strFuseF( tinP , psttP , psttRead ) ;
                {
                if( psttRead )
            {
            if( bPerLineP  && !( idb % bPerLineP ) )
    
            }
                ether.strFuseF( tinP , psttRead , T(pb2) ) ;
                if( *pb2 < 0x20 || *pb2 > 0x7f ) *pb2 = bReadableP ;
                osTextT pb2[] = { *pbP , 0 } ;
            {
            if( psttRead )
            ether.strFuseF( tinP , psttP , TF3(*pbP,fl3,2) ) ;

            ;
                : flFORMAT_UNSIGNED | flFORMAT_FILLzE | flFORMAT_NObIGITvALUES
                ? flFORMAT_UNSIGNED | flFORMAT_FILLzE | flFORMAT_NObIGITvALUES | flFORMAT_FOREIGN
            flagsT fl3 = F(flagsP) & flSTRdUMP_FOREIGN

        {
        if( pbP < pbe )
        ++ idb ;
    {
    while( pbP < pbe || cPad )
    ZE( countT , idb ) ;
    const byteT* pbe = pbP + cbP ;
    TN( tp1 , " " ) ;
    TN( tp2 , "  " ) ;
    TN( tge , " " ) ;
    TN( tle , "\r\n" ) ;

    if( bReadableP ) { ether.strMakeF( tinP , psttRead , T(" ") , bPerLineP * 2 ) ; ___( psttRead ) ; }
    ZE( strokeS* , psttRead ) ;

    POSTPONEtEST( psttP ) ;
    ether.strMakeF( tinP , psttP , T("") , 2 * ( cbP + cPad + cLineEnds ) + cGroupEnds + cGrouprEnds + !!bReadableP * cLineEnds * ( 1 + bPerLineP ) ) ; //CALLER MUST TAG ___( psttP ) ;

    ;
            : ( cbP + cPad ) / bPerGrouprP + ( cbP + cPad ) % bPerGrouprP - cLineEnds
            ? 0
        : !bPerGrouprP
        ? 0
    countT cGrouprEnds = !bReadableP
    countT cGroupEnds  = bPerGroupP  ? ( cbP + cPad ) / bPerGroupP  + ( cbP + cPad ) % bPerGroupP  - cLineEnds : 0 ;
    countT cLineEnds   = bPerLineP   ? ( cbP + cPad ) / bPerLineP   + ( cbP + cPad ) % bPerLineP   : 0 ;
    countT cPadSave    = cPad ;
    countT cPad        = bPerLineP   ? ( bPerLineP - cbP % bPerLineP ) % bPerLineP : 0 ;
    etherC& ether = *tinP.pEther ;

    _INoLD_
    
    }
        if( POOP ) return ;
        FV(flSTRdUMP,flagsP) ;
        __( !tinP.pEther ) ;
        __( bReadableP && ( bReadableP < 0x20 || bReadableP > 0x7f ) ) ;
        __( bPerGrouprP && bPerLineP % bPerGrouprP ) ;
        __( bPerGrouprP && !bReadableP ) ;
        __( bPerGrouprP && !bPerLineP ) ;
        __( bPerGroupP && bPerLineP % bPerGroupP ) ;
        __( bPerGroupP && !bPerLineP ) ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT etherC::strDumpIF( tinS& tinP , strokeS*& psttP , const byteT* pbP , const countT cbP , const flagsT flagsP , const countT bPerLineP , const countT bPerGroupP , const byteT bReadableP , const countT bPerGrouprP )/*1*/

/**/
*/
 bPerGrouprP
   '~'
   '@'
   '*'
   ' '
   '.'
  example values
  must either be 0 or a readable ascii value
  will be displayed in place of a byte value < 0x20 or > 0x7f
 bReadableP
  if not 0 then bPerLineP must be an integral multiple of bPerGroupP
  bytes per group
 bPerGroupP
  bytes per line
 bPerLineP
 cbP
 pbP
 psttP
 tinP
arguments
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

