
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUTbATONsTACKc_
    }
        }
            }
                }
                    default : { __( idType ) ; break ; }
                    }
                        break ;
                        }
                            PLATE_countT_REF( ppNewP ) = (countT)pSoul ;
                            soulC* pSoul = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) , pbs , flSOUL_null , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ; ___BITScT( pSoul , 0xdff ) ;
                            const byteT* pbs = soulSrc ;
                            soulC& soulSrc = *(soulC*)valueP ;
                        {
                        if( valueP )
                        __Z( valueP ) ;
                    {
                    case ifcSTACKtYPE_PTR_soulC :
                    }
                        break ;
                        PLATE_countT_REF( ppNewP ) = (countT)pn ;
                        third.c_memcpyIF( tinP , (byteT*)pn , (byteT*)valueP , cca * sizeof( countT ) ) ;
                        third.newF( tinP , LF , pn , cca ) ; ___BITScT( pn , 0xe00 ) ;
                        ZE( countT* , pn ) ;
                        countT cca = tinP.pEther->strBodyLengthF( tinP , (countT*)valueP ) + 1 ;
                    {
                    case ifcSTACKtYPE_PTR_countT :
                    }
                        break ;
                        PLATE_countT_REF( ppNewP ) = (countT)pn ;
                        third.c_memcpyIF( tinP , pn , (osTextT*)valueP , costa ) ;
                        third.newF( tinP , LF , pn , costa ) ; ___BITScT( pn , 0xe01 ) ;
                        const countT costa = third.c_strlenIF( tinP , (osTextT*)valueP ) + 1 ;
                        ZE( byteT* , pn ) ;
                    {
                    case ifcSTACKtYPE_PTR_byteT        :
                    case ifcSTACKtYPE_PTR_nicNameC     : { ZE( nicNameC* , pn ) ; third.newF( tinP , LF , pn ) ; third.c_memcpyIF( tinP , (byteT*)pn , (byteT*)valueP , processGlobal2I.cb_nicNameC_ )     ; ___BITScT( pn , 0xe02 ) ; PLATE_countT_REF( ppNewP ) = (countT)pn ; break ; }
                    case ifcSTACKtYPE_PTR_count8S      : { ZE( count8S*  , pn ) ; third.newF( tinP , LF , pn ) ; third.c_memcpyIF( tinP , (byteT*)pn , (byteT*)valueP , sizeof( count8S ) ) ; ___BITScT( pn , 0xe03 ) ; PLATE_countT_REF( ppNewP ) = (countT)pn ; break ; }
                    case ifcSTACKtYPE_PTR_count7S      : { ZE( count7S*  , pn ) ; third.newF( tinP , LF , pn ) ; third.c_memcpyIF( tinP , (byteT*)pn , (byteT*)valueP , sizeof( count7S ) ) ; ___BITScT( pn , 0xe04 ) ; PLATE_countT_REF( ppNewP ) = (countT)pn ; break ; }
                    case ifcSTACKtYPE_PTR_count6S      : { ZE( count6S*  , pn ) ; third.newF( tinP , LF , pn ) ; third.c_memcpyIF( tinP , (byteT*)pn , (byteT*)valueP , sizeof( count6S ) ) ; ___BITScT( pn , 0xe05 ) ; PLATE_countT_REF( ppNewP ) = (countT)pn ; break ; }
                    case ifcSTACKtYPE_PTR_count5S      : { ZE( count5S*  , pn ) ; third.newF( tinP , LF , pn ) ; third.c_memcpyIF( tinP , (byteT*)pn , (byteT*)valueP , sizeof( count5S ) ) ; ___BITScT( pn , 0xe06 ) ; PLATE_countT_REF( ppNewP ) = (countT)pn ; break ; }
                    case ifcSTACKtYPE_PTR_count4S      : { ZE( count4S*  , pn ) ; third.newF( tinP , LF , pn ) ; third.c_memcpyIF( tinP , (byteT*)pn , (byteT*)valueP , sizeof( count4S ) ) ; ___BITScT( pn , 0xe07 ) ; PLATE_countT_REF( ppNewP ) = (countT)pn ; break ; }
                    case ifcSTACKtYPE_PTR_count3S      : { ZE( count3S*  , pn ) ; third.newF( tinP , LF , pn ) ; third.c_memcpyIF( tinP , (byteT*)pn , (byteT*)valueP , sizeof( count3S ) ) ; ___BITScT( pn , 0xe08 ) ; PLATE_countT_REF( ppNewP ) = (countT)pn ; break ; }
                    case ifcSTACKtYPE_PTR_count2S      : { ZE( count2S*  , pn ) ; third.newF( tinP , LF , pn ) ; third.c_memcpyIF( tinP , (byteT*)pn , (byteT*)valueP , sizeof( count2S ) ) ; ___BITScT( pn , 0xe09 ) ; PLATE_countT_REF( ppNewP ) = (countT)pn ; break ; }
                    }
                        break ;
                        PLATE_countT_REF( ppNewP ) = (countT)pn ;
                        third.c_memcpyIF( tinP , (byteT*)pn , (byteT*)valueP , cba ) ;
                        third.newF( tinP , LF , pn , cba ) ; ___BITScT( pn , 0xe0a ) ;
                        ZE( strokeS* , pn ) ;
                        countT cba = ( CSpREFIX + ((strokeS*)valueP)->idAdam ) * sizeof( strokeS ) ;
                    {
                    case ifcSTACKtYPE_PTR_strokeS :
                {
                switch( idType )
            {
            else
            if( !( F(flags) & flSTACKc_COPY ) || !valueP ) PLATE_countT_REF( ppNewP ) = valueP ;
        {
        else
        }
            else         third.c_memsetIF( tinP , (byteT*)ppNewP + sizeof( plateS ) , cbd , 0 ) ;
            if( valueP ) third.c_memcpyIF( tinP , (byteT*)ppNewP + sizeof( plateS ) , (byteT*)valueP , cbd ) ;
        {
        if( !cbData || cbData != sizeof( countT ) || idType == ifcSTACKtYPE_BLOB )

        LATHrEF

        ppNewP->resetF() ; // DATA SECTION IS NOT INITIALIZED
    {
    if( ppNewP )
    __Z( ppNewP ) ;

    else                           { third.newF( tinP , LF , (byteT*&)ppNewP , sizeof( plateS ) + cbd ) ; ___CT( ppNewP ) ; }
    if( F(flags) & flSTACKc_XRAY ) ppNewP = (plateS*)&(*pXray)[ 0 ] ;

    }
        __( cbData < cbd ) ;
        __Z( cbd ) ;
        cbd = (*pCbF)( tinP , *pEtherContainsMe , (byteT*)valueP ) ;
    {
    else
    else if( !pCbF ) cbd = cbData ;
    if( !cbData ) cbd = sizeof( countT ) + *(countT*)valueP ;
    countT cbd ; //INTENTIONALLY NOT INITIALIZED, FOR SPEED

    if( F(flags) & flSTACKc_LOCKwHENzEpUSHED && !valueP ) flagsState |= flSTACKsTATE_LOCKED ;

    _INbATONsTACKc_

    }
        if( third ) return ;
        __( F(flagsState) & flSTACKsTATE_LOCKED ) ;
        else                                       { __(                              !valueP && !( F(flags) & flSTACKc_ALLOWzE ) ) ; }
        else if( idType ==         ifcSTACKtYPE_timeS    ) { __(             !*(timeS*)valueP && !( F(flags) & flSTACKc_ALLOWzE ) ) ; }
             if( idType ==         ifcSTACKtYPE_nicNameC ) { __(          !*(nicNameC*)valueP && !( F(flags) & flSTACKc_ALLOWzE ) ) ; }
        if( third ) return ;
        __( valueP < TOCK && F(flags) & flSTACKc_DISALLOWsMALLvALUE ) ;
        __( ( !cbData || cbData != sizeof( countT ) || idType == ifcSTACKtYPE_BLOB ) && !valueP && !( F(flags) & flSTACKc_ALLOWzE ) ) ;
        }
            __( cbData != sizeof( countT ) ) ;
            __Z( valueP ) ;
            __( idType == ifcSTACKtYPE_countT ) ;
            __Z( idType ) ;
        {
        if( F(flags) & flSTACKc_COPY )
        }
            __Z( pEtherContainsMe ) ;
            pEtherContainsMe = third.third_pEtherContainsMe_F() ;
        {
        if( pCbF )
        __NZ( ppNewP ) ;
        if( third ) return ;
    {
    IFbEcAREFUL
    etherC* pEtherContainsMe ; //INTENTIONALLY UNINITIALIZED, FOR SPEED.  IS RARELY USED, BUT WHEN USED, I MUST BE FAST
    SCOOP
{
/*1*/voidT stackC::newPlateF( tinS& tinP , plateS*& ppNewP , const countT valueP )/*1*/

/**/
*/
if flSTACKc_COPY is set, then valueP is assumed to contain the nonze address of an object of a known type, which is copied to a newly allocated poolOld drop, whose address is placed onto the stack
if flSTACKc_COPY is not set, then valueP is placed onto the stack object
    to use this capability, see stackC::stackC
     the caller must specify a callback function that can inspect an image and return its length
     the caller must know, when the stackC is constructed, the maximum possible length
    requirements
   varying length images that are not length prefixed are also supported
     the data section of the plate will begin with a countT value containing the number of data bytes that follow it
    in this case, i interpret valueP as containing the address of the length prefixed string of bytes that i am to copy to the data portion of the new plate
    in this case, a stackC object is a stack of length prefixed varying length images
   for some idType values, cbData will be 0
  for masters: it is possible to stack together images that are of varying sizes
   in this case, i interpret valueP as containing the address of cbData bytes that i am to copy to the data portion of the new plate
   in this case, a stackC object is a stack of images, each of size cbData bytes
   for some idType values, cbData will be a nonze value other than sizeof( countT )
  for journeymen: it is possible to stack together images that are of a size other than sizeof( countT )
   in this case, i interpret valueP as wo such value, to be copied to the data portion of the new plate
   in this case, a stackC object is a stack of countT values or addresses
   by default, cbData is sizeof( countT ), which is also the size of an address
  for apprentices: think of a stackC as a stack of countT objects, which are either values or pointers to values
   this reflects a coding style principle that 0 should mean "invalid value" for a variable rather than be a member of the set of valid values
   this means that a stackC object will not accept a 0 value unless it is told in advance to do so
   flSTACKc_ALLOWzE will not be set unless the code that constructs me specifies it
  if flSTACKc_ALLOWzE is set, can be 0 unless the stackC is a pointer type
 valueP
  must be 0
 ppNewP
arguments
 increment cPlates
 insert the plate into the chain
 adjust references
each caller must...
after calling this function, stackC::extractF( tinP ) can be used to remove the item that it references
i make no assumptions about where the caller will place the plate in the stack
the caller must place the plate onto the stack
my job is to update my data completely to reflect the presence of the new plate without actually placing the plate onto the stack
this function zees the internal cursor that is used to make operator [] speedy
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.1150027.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$newPlateF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

