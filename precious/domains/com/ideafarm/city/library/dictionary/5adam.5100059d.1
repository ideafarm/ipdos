
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        ++ s ; tinP.pEtScratch->osSleepF( tinP , TOCK * 0x4 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    
        etThread.delF( tinP , pstt1m ) ;
        }
            CONoUTrAW( (!flagsFail?T("aok"):T("flagsFail:")+TF2(flagsFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED))+T("\r\n") ) ;

            }
                flagsFail |= flFAIL_COULDnOTmOVEfILE ;
                POOPR
            {
            if( POOP )
            tinP.pEtScratch->delF( tinP , psttShort ) ;

            tinP.pEtScratch->diskMoveFileOrDirF( tinP , tWhere+T(psttShort) , psttc1 ) ;

            ;
                    : tSent
                    ? tNotSent
                : flagsFail
                ? tNotSentAbandoned

            TN( tWhere , "" ) ; tWhere = bFailPermanent

            CONoUTrAW( "moving the file\r\n" ) ;

            }
                flagsFail |= flFAIL_COULDnOTgETsHORTfILEnAME ;
                POOPR
            {
            if( POOP )

            tinP.pEtScratch->strWordF( tinP , psttShort , psttc1 , sttq , sSlash , - 1 ) ; ___( psttShort ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , psttShort ) ;
            CONoUTrAW( "cleaning up 3\r\n" ) ;

            }
                CONoUTrAW( "unknown error\r\n" ) ;
                flagsFail |= flFAIL_UNKNOWNeRROR ;
                POOPR
            {
            if( POOP )
            CONoUTrAW( "cleaning up 2\r\n" ) ;

            }
                stBc.purgeF( tinP ) ;
                stCc.purgeF( tinP ) ;
                stTo.purgeF( tinP ) ;

                etThread.delF( tinP , psttFileBody ) ;

                CONoUTrAW( "cleaning up 1\r\n" ) ;
                etThread( tinP , pStkEmailRelay ) ;
                etThread.delF( tinP , psttFrom ) ;
                }
                    }
                        }
                            CONoUTrAW( T("end of handling list ")+TF2(offs,flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
                            }
                                while( ~hWalk ) ;
                                }
                                    CONoUTrAW( T("end of recipient \"")+T(psttr)+T("\"\r\n") ) ;
                                    etThread.delF( tinP , psttBccLine ) ;
    
                                    CONoUTrAW( "destroyed socket\r\n" ) ;
                                    }
                                        CONoUTrAW( "writing quit: aok; destroying socket\r\n" ) ;
                                        }
                                            break ;
                                            etThread.delF( tinP , psttBccLine ) ;
                                            CONoUTrAW( "writing quit: failed\r\n" ) ;
                                            flagsFail |= flFAIL_QUITcOMMANDrEJECTED ;
                                            POOPR
                                        {
                                        if( POOP )
                                        sockc.verifyReplyF( tinP , 221 ) ;
                                        CONoUTrAW( "writing quit: verifying reply\r\n" ) ;
                                        sockc.writeF( tinP , (osTextT*)T("quit\r\n") ) ;
        
                                        CONoUTrAW( "writing data: aok; writing quit\r\n" ) ;

                                        //}
                                        //    break ;
                                        //
                                        //    }
                                        //        etThread.boxPutF( tinP , T("//smtp/" ifcEMAIL_MAILoUT "/")+T(psttFrom) , tReply , tReply.csF( tinP ) ) ;
                                        //
                                        //        ) ;
                                        //
                                        //            "Your email was sent.\r\n"
                                        //            "\r\n"
                                        //            "Subject: Your email was sent\r\n"
                                        //
                                        //        TN( tReply ,
                                        //    {
                                        //    //NOTIFY from THAT EMAIL WAS SENT
                                        //    CONoUTrAW( T("an email was sent.  notifying \"")+T(psttFrom)+T("\"\r\n") ) ;
                                        //{
                                        //else if( etThread.strCompareF( tinP , psttFrom , T(ifcEMAIL_MAILoUT) ) )
                                        //THIS CAN CYCLE INFINITELY

                                        }
                                            break ;
                                            etThread.delF( tinP , psttBccLine ) ;

                                            }
                                                etThread.boxPutF( tinP , T("//smtp/" ifcEMAIL_MAILoUT "/")+T(psttFrom) , tReply , tReply.csF( tinP ) ) ;

                                                ) ;

                                                    "       will avoid a bug in the censoring software.)\r\n"
                                                    "       the brackets so that they appear as \"[ ]\".  (Adding the space between the brackets\r\n"
                                                    "    2. If your email contains a '[' followed immediately by a ']', put a space between\r\n"
                                                    "\r\n"
                                                    "    1. Remove all references to web sites that might be listed as spamming sites.\r\n"
                                                    "\r\n"
                                                    "Tips:\r\n"
                                                    "\r\n"
                                                    "Please resend your email after editing it to avoid this \"no spam\" censoring.\r\n"
                                                    "\r\n"
                                                    "recipient.\r\n"
                                                    "It thinks that your note is spam, so is refusing to relay it to your intended\r\n"
                                                    "That relay combats spam by refusing to handle items that appeaer to be spam.\r\n"
                                                    "\r\n"
                                                    "    k2smtpout.secureserver.net\r\n"
                                                    "\r\n"
                                                    "Email sent by the IDEAFARM.COM email server is relayed through\r\n"
                                                    "\r\n"
                                                    "Subject: Your email could not be sent\r\n"

                                                TN( tReply ,
                                                CONoUTrAW( T("could not send; notifying\"")+T(psttFrom)+T("\"\r\n") ) ;
                                            {
                                            //SEND A REJECTED NOTICE TO from

                                            //}
                                            //    }
                                            //        __( logBodySnipFromFileF( tinP , etThread , psttc1 ) ) ;
                                            //    {
                                            //    FORsTRINGSiN1( psttFileBody )
                                            //{
                                            //else
                                            //if( !ISsTRINGoFsTRINGS( psttFileBody ) ) { __( logBodySnipFromFileF( tinP , etThread , psttFileBody ) ) ; }
                                            //
                                            //}
                                            //    CONoUTrAW( tHeaders ) ;
                                            //    TN( tHeaders , "" ) ; tHeaders = (!bIncoming?tFrToCcOutgoing:tFrToCcIncoming)+T(psttBccLine) ;
                                            //{
                                            //LOG THE DATA

                                            bFailPermanent = 1 ;
                                            flagsFail |= flFAIL_BODYrEJECTED ;
                                            POOPR
                                        {
                                        if( POOP )
                                        sockc.verifyReplyF( tinP , 250 ) ; //WILL FAIL IF ANTISPAM RELAYER REFUSES DATA BECAUSE IT CONTAINS REFERENCE TO BLACKLISTED (SPAMMER) WEB SITE
                                        CONoUTrAW( "writing data: verifying reply\r\n" ) ;
                                        }
                                            sockc.writeF( tinP , "\r\n.\r\n" , 5 ) ;
    
                                            }
                                               break ;
                                               etThread.delF( tinP , psttBccLine ) ;
                                               POOPR
                                            {
                                            if( POOP )
    
                                            }
                                                }
                                                    }
                                                        break ;
                                                        etThread.delF( tinP , psttBccLine ) ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    __( writeBodySnipFromFileF( tinP , etThread , sockc , psttc1 , flagsFail ) ) ;
                                                {
                                                FORsTRINGSiN1( psttFileBody )
                                            {
                                            else
                                            if( !ISsTRINGoFsTRINGS( psttFileBody ) ) { __( writeBodySnipFromFileF( tinP , etThread , sockc , psttFileBody , flagsFail ) ) ; }
    
                                            }
                                                sockc.writeF( tinP , (osTextT*)tHeaders , tHeaders.csF( tinP ) ) ;
                                                TN( tHeaders , "" ) ; tHeaders = (!bIncoming?tFrToCcOutgoing:tFrToCcIncoming)+T(psttBccLine) ;
                                            {
                                        {
                            
                                        CONoUTrAW( "writing data cmd: aok; writing data\r\n" ) ;
                                        }
                                            break ;
                                            etThread.delF( tinP , psttBccLine ) ;
                                            CONoUTrAW( "writing data cmd: failed\r\n" ) ;
                                            flagsFail |= flFAIL_DATAcOMMANDrREJECTED ;
                                            POOPR
                                        {
                                        if( POOP )
                                        sockc.verifyReplyF( tinP , 354 ) ;
                                        CONoUTrAW( "writing data cmd: verifying reply\r\n" ) ;
                                        sockc.writeF( tinP , (osTextT*)T("data\r\n") ) ;
                            
                                        CONoUTrAW( "writing rcpt to: aok; writing data cmd\r\n" ) ;
                                        }
                                            break ;
                                            etThread.delF( tinP , psttBccLine ) ;
                                            CONoUTrAW( "writing rcpt to: failed\r\n" ) ;
                                            flagsFail |= flFAIL_RCPTtOrEJECTED ;
                                            POOPR
                                        {
                                        if( POOP )
                                        sockc.verifyReplyF( tinP , 250 ) ;
                                        CONoUTrAW( "writing rcpt to: verifying reply\r\n" ) ;
                                        { textC txt = T("rcpt to:<")+T(psttr)+T(">\r\n") ; sockc.writeF( tinP , (osTextT*)txt ) ; }
                            
                                        CONoUTrAW( "mail from: aok; writing rcpt to\r\n" ) ;
                                        }
                                            break ;
                                            etThread.delF( tinP , psttBccLine ) ;
                                            CONoUTrAW( "mail from: failed\r\n" ) ;
                                            flagsFail |= flFAIL_MAILfROMrEJECTED ;
                                            POOPR
                                        {
                                        if( POOP )
                                        sockc.verifyReplyF( tinP , 250 ) ;
                                        CONoUTrAW( "mail from: verifying reply\r\n" ) ;
                                        { textC txt = T("mail from:<")+T(psttFrom)+T(">\r\n") ; sockc.writeF( tinP , (osTextT*)txt ) ; }
                    
                                        CONoUTrAW( "helloed: writing mail from\r\n" ) ;
                                        }
                                            break ;
                                            etThread.delF( tinP , psttBccLine ) ;
                                            CONoUTrAW( "hello: failed\r\n" ) ;
                                            flagsFail |= flFAIL_HELLOrEJECTED ;
                                            POOPR
                                        {
                                        if( POOP )
                                        sockc.verifyReplyF( tinP , 250 ) ;
                                        CONoUTrAW( "hello: verifying reply\r\n" ) ;
                                        sockc.writeF( tinP , (osTextT*)T("helo ipdos.ideafarm.com\r\n") ) ; //U: QUERY FOR MY REAL psttName
                        
                                        CONoUTrAW( "connected: writing hello\r\n" ) ;
                                        }
                                            break ;
                                            etThread.delF( tinP , psttBccLine ) ;
                                            CONoUTrAW( "connecting: failed\r\n" ) ;
                                            flagsFail |= flFAIL_COULDnOTcONNECT ;
                                            POOPR
                                        {
                                        if( POOP )
    
                                        sockc.verifyReplyF( tinP , 220 ) ;
    
                                        CONoUTrAW( "connecting: verifying reply\r\n" ) ;
                                        sockc.connectF( tinP , 25 , hidServer ) ;
                                        //CONoUTrAW( "connecting\r\n" ) ;
        
                                        }
                                            etThread.delF( tinP , psttServer ) ;
                                            hidServer = socketC::nicNameIF( tinP , *tinP.pEtScratch , psttServer ) ;
        
                                            etThread.delF( tinP , psttMxExclude ) ;
                                            etThread.delF( tinP , psttRelayServer ) ;
                                            }
                                                etThread.delF( tinP , psttMxName ) ;
                                                else                                                                                                                               { tinP.pEtScratch->strMakeF(     tinP , psttServer , psttRelayServer                   ) ; ___( psttServer ) ; }
                                                if( !psttRelayServer || !psttRelayServer->idAdam || ( psttMxExclude && !tinP.pEtScratch->strCompareF( tinP , psttMxExclude , psttMxName ) ) ) { tinP.pEtScratch->dnsNicNamesF( tinP , psttServer , psttMxName , ifcIDtYPEdNSqUERY_MX ) ; ___( psttServer ) ; }
        
                                                tinP.pEtScratch->strWordF( tinP , psttMxName , psttr , sttq , strokeS('@') , -1 ) ; ___( psttMxName ) ;
                                                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                                ZE( strokeS* , psttMxName ) ;
                                            {
                                            ZE( strokeS* , psttServer ) ;
                        
                                            }
                                                //CONoUTrAW( T("mx exclude  : \"")+T(psttMxExclude)+T("\"\r\n") ) ;
                                                //CONoUTrAW( T("relay server: \"")+T(psttRelayServer)+T("\"\r\n") ) ;
                                                //etThread.delF( tinP , psttSetting ) ;
                                                //}
                                                //    etThread.delF( tinP , pstt1l ) ;
                                                //    }
                                                //        else break ;
                                                //        else if( !psttMxExclude   ) { tinP.pEtScratch->strMakeF( tinP , LF , psttMxExclude   , psttc1 ) ; ___( psttMxExclude   ) ; }
                                                //             if( !psttRelayServer ) { tinP.pEtScratch->strMakeF( tinP , LF , psttRelayServer , psttc1 ) ; ___( psttRelayServer ) ; }
                                                //    {
                                                //    FORsTRINGSiN1( pstt1l )
                                                //    tinP.pEtScratch->strWordsOldF( tinP , pstt1l , psttSetting , sttq , T("\r\n") ) ; ___( pstt1l ) ;
                                                //    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                                //    ZE( strokeS* , pstt1l ) ;
                                                //{
                                                //if( psttSetting )
                                                //tinP.pEtScratch->boxGetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF( tinP , psttSetting , T("///d/ideafarm.home.")+TF1(etherC::ifc_idHomeIdisk_IF())+T(".setting.keyValue.smtprelay") ) ; ___( psttSetting ) ;
                                                //U:: 20190728@1932:  REWRITE TO USE A SETTING RATHER THAN HARDCODE

                                                //tinP.pEtScratch->strMakeF( tinP , LF , psttRelayServer , T("") ) ; ___( psttRelayServer ) ;
                                                U:: THIS CODE IS OBSOLETE; SEE 750

                                                ZE( strokeS* , psttSetting ) ;
                                            {
                                            ZE( strokeS* , psttMxExclude ) ;
                                            ZE( strokeS* , psttRelayServer ) ;
                                        {
                                        nicNameC hidServer ;
    
                                        socketC sockc( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                        countT idleTimeAllowedWrite = TOCK * 0x4 ;
                                        countT idleTimeAllowedRead  = TOCK * 0x4 ;
                                        countT timeAllowedConnected = TICK >> 2 ;
                                        //countT idleTimeAllowedWrite = TOCK * 0x10 ;
                                        //countT idleTimeAllowedRead  = TOCK * 0x10 ;
                                    {
    
                                    }
                                        tinP.pEtScratch->strFuseF( tinP , psttBccLine , T(">\r\n") ) ;
                                        tinP.pEtScratch->strFuseF( tinP , psttBccLine , psttr ) ;
                                        tinP.pEtScratch->strFuseF( tinP , psttBccLine , T("Bcc" ": <") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ 3 + psttr->idAdam ) ; ___( psttBccLine ) ;
                                    {
                                    if( offs == 2 )
                                    ZE( strokeS* , psttBccLine ) ;
    
                                    }
                                        while( ~hWalk ) ;
                                        }
                                            }
                                                break ;
                                                bIncoming = 1 ;
                                            {
                                            if( !tinP.pEtScratch->strCompareF( tinP , psttr , psttw ) )
                                            strokeS* psttw = (strokeS*)pStkEmailRelay->downF( tinP , hWalk ) ;
                                        {
                                        do
                                        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    if( *pStkEmailRelay )
                                    ZE( boolT , bIncoming ) ;
    
                                    CONoUTrAW( T("beginning of recipient \"")+T(psttr)+T("\"\r\n") ) ;
                                    strokeS* psttr = (strokeS*)ppzStk[ offs ]->downF( tinP , hWalk ) ;
                                {
                                do
                                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( *ppzStk[ offs ] )
                            CONoUTrAW( T("beginning of handling ")+TF2(*ppzStk[offs],flFORMAT_NObIGITvALUES)+T(" recipients for list ")+TF2(offs,flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
                        {
                        for( countT offs = 0 ; offs < 3 && !flagsFail ; offs ++ )
                        stackC* ppzStk[] = { &stTo , &stCc , &stBc } ;
                    {
                    else
                    }
                        flagsFail |= flFAIL_DURINGpARSING ;
                        POOPR
                    {
                    if( POOP )
    
                    }
                        etThread.delF( tinP , psttFrToCc ) ;
                        *pptFrToCc[ offc ] = T(psttFrToCc) ;
    
                        }
                            }
                                }
                                    while( ~hWalk ) ;
                                    }
                                        tinP.pEtScratch->strFuseF( tinP , psttFrToCc , T(">\r\n") ) ;
                                        tinP.pEtScratch->strFuseF( tinP , psttFrToCc , psttw ) ;
                                        tinP.pEtScratch->strFuseF( tinP , psttFrToCc , T(!off?"To: <":"Cc" ": <") ) ;
                                        strokeS* psttw = (strokeS*)ppzStk[ off ]->downF( tinP , hWalk ) ;
                                    {
                                    do
                                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( *ppzStk[ off ] )
                            {
                            for( countT off = 0 ; off < 2 ; off ++ )
                            stackC* ppzStk[] = { &stTo , &stCc } ;
                        {
    
                        tinP.pEtScratch->strFuseF( tinP , psttFrToCc , T(">\r\n") ) ;
                        tinP.pEtScratch->strFuseF( tinP , psttFrToCc , psttFrom ) ;
                        tinP.pEtScratch->strFuseF( tinP , psttFrToCc , T("<") ) ;
                        if( csttName ) tinP.pEtScratch->strFuseF( tinP , psttFrToCc , T("\"")+tName+T("\" ") ) ;
                        tinP.pEtScratch->strFuseF( tinP , psttFrToCc , T("From: ") ) ;
                        tinP.pEtScratch->strMakeF( tinP , LF , psttFrToCc , 0 , cstta ) ; ___( psttFrToCc ) ;
    
                        const countT cstta = csttFrToCc + cFrToCcLines * 0x10 + csttName ; //0x10 IS MORE THAN NEEDED (0xa)
    
                        const countT csttName = !tName.csF( tinP ) ? 0 : tName.csF( tinP ) + 3 ;
                        textC& tName = !offc ? tNameOut : tNameIn ;
                        
                        ZE( strokeS* , psttFrToCc ) ;
                    {
                    for( countT offc = 0 ; offc <= 1 ; offc ++ )
                    textC* pptFrToCc[] = { &tFrToCcOutgoing , &tFrToCcIncoming } ;

                    //}
                    //    tinP.pEtScratch->strMakeF( tinP , LF , psttFrom , T("hello@ideafarm.com") ) ; ___( psttFrom ) ;
                    //    tinP.pEtScratch->delF( tinP , psttFrom ) ;
                    //{
                    //if( !tinP.pEtScratch->strCompareF( tinP , psttFrom , T(ifcEMAIL_HELLO) ) )
                    //SUPPORT FOR hello@ideafarm.com COMMENTED OUT DUE TO DECISION TO NOT PROVIDE ANY FUNCTIONALITY TO ANONYMOUS INTERNET USERS
                    //CS:CODEsYNC: b750104 3a50104
                    //MAPPING GLOBAL ALIASES
    
                    TN( tFrToCcIncoming , "" ) ;
                    TN( tFrToCcOutgoing , "" ) ;
    
                    }
                        }
                            }
                                }
                                    *pStkEmailRelay << psttw ;
                                    *info.pStkEmailRelay >> psttw ; ___( psttw ) ;
                                    ZE( strokeS* , psttw ) ;
                                {
                                if( info.pStkEmailRelay ) while( *info.pStkEmailRelay )
    
                                tNameOut = T(info.psttNameOut) ;
                                tNameIn  = T(info.psttNameIn) ;
                            
                                subaccountS info( tinP , etThread , cPassAccount , cPassSubaccount , flSUBACCOUNT_QUERYeMAILrELAY | flSUBACCOUNT_QUERYnAMEiN | flSUBACCOUNT_QUERYnAMEoUT ) ;
                            {
    
                            }
                                etThread.delF( tinP , psttw ) ;
                                tEmailOwner = T(psttw) ;
                                queryEmailFromIdAccountF( tinP , psttw , cPassAccount ) ; ___( psttw ) ;
                                ZE( strokeS* , psttw ) ;
                            {
                        {
                        else if( cPassAccount && cPassSubaccount )
                        if( POOP ) POOPR
    
                        }
                            etThread.delF( tinP , psttw ) ;
                            }
                                etThread.delF( tinP , pstt1w ) ;
                                }
                                    }
                                        }
                                            break ;
                                            }
                                                }
                                                    if( idWord ++ == 4 ) break ;
            
                                                    else { __( tinP.pEtScratch->strCompareF( tinP , psttc2 , T("doubleblind") ) ) ; }
                                                    }
                                                        if( pco ) *pco = tinP.pEtScratch->strDigitsToSCountF( tinP , psttc2 , 36 ) ;
                
                                                        }
                                                            case 3 : { pco = &cPassAccount    ; break ; }
                                                            case 2 : { pco = &cPassSubaccount ; break ; }
                                                        {
                                                        switch( idWord )
                                                        ZE( countT* , pco ) ;
                            
                                                        }
                                                            break ;
                                                            POOPR
                                                        {
                                                        if( POOP )
                                                        __( !tinP.pEtScratch->strIsDigitsF( tinP , psttc2 , 36 ) ) ;                           // REJECT IF NOT ALL DIGITS
                                                    {
                                                    if( idWord <= 3 )
                                                {
                                                FORsTRINGSiN2( pstt1w )
            
                                                countT idWord = 6 - cWords ; // 1 OR 2
                                            {
                                            else
                                            if( POOP ) POOPR
            
                                            __( cWords > 5 ) ;
                                            __( cWords < 4 ) ;
                                        {
                                        case 1 : // [idItem].fdee86.trswwh1.doubleblind.1
                                    {
                                    switch( idFormat )
            
                                    }
                                        if( BlATHsTRING1 ) idFormat = tinP.pEtScratch->strDigitsToSCountF( tinP , psttc1 , 36 ) ;
                                    {
                                    FORsTRINGSiN1( pstt1w )
                                {
                                if( pstt1w )
                                const countT cWords = tinP.pEtScratch->strWordsOldF( tinP , pstt1w , psttw , sttq , T(".") ) ; ___( pstt1w ) ;
                                ZE( strokeS* , pstt1w ) ;
                            {
                            else if( psttw && psttw->idAdam )
                            if( POOP ) POOPR
                            tinP.pEtScratch->strSubstringF( tinP , psttw , idf , sttq , S1C('@') , psttFrom ) ; ___( psttw ) ;
                            countT idf = 1 ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                            ZE( strokeS* , psttw ) ;
                        {
                        ZE( countT , idFormat        ) ; // 4
                        ZE( countT , cPassAccount    ) ; // 3
                        ZE( countT , cPassSubaccount ) ; // 2
                    {
                    TN( tNameIn , "" ) ;
                    TN( tNameOut , "" ) ;
                {
                if( pStkEmailRelay )
                etThread( tinP , pStkEmailRelay , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkEmailRelay ) ;
                ZE( stackC* , pStkEmailRelay ) ;
                TN( tEmailOwner , "" ) ;
                //PARSE psttFrom AND LOOKUP ACCOUNT OWNER NAME

                //else { //CONoUTrAW( "bad news, bro! psttFileBody is null or short\r\n" ) ; }
                }
                    etThread.delF( tinP , psttDump ) ;
                    //CONoUTrAW( T("****DUMPbEGIN\r\n")+T(psttDump)+T("\r\n****DUMPeND\r\n") ) ;
                    etThread.strDumpIF( tinP , psttDump , (byteT*)psttFileBody , sizeof( strokeS ) * ( CSpREFIX * 2 + 1 ) , sizeof( strokeS ) , sizeof( countT ) ) ; ___( psttDump ) ;
                    ZE( strokeS* , psttDump ) ;

                    //CONoUTrAW3( "ISsTRINGoFsTRINGS evaluates to " , ISsTRINGoFsTRINGS( psttFileBody ) , "\r\n" ) ;
                    //else                                                      { //CONoUTrAW( "STRING OF STRINGS? NO!\r\n" ) ; }
                    //if( psttFileBody[ CSpREFIX ].idCaste == sc_PREFIXlENGTH ) { //CONoUTrAW( "STRING OF STRINGS? yes\r\n" ) ; }
                {
                if( psttFileBody && psttFileBody->idAdam > CSpREFIX )

                sIn >> psttFileBody ; ___( psttFileBody ) ;
                ZE( strokeS* , psttFileBody ) ;

                }
                    }
                        }
                            }
                                *ppzStk[ off ] << psttw ; psttw = 0 ;
                                if( off < 2 ) csttFrToCc += psttw->idAdam ;
                            {
                            if( psttw )
                            }
                                case 2 : { CONoUTrAW( T("Bc" ": \"")+T(psttw)+T("\"\r\n") ) ; break ; }
                                case 1 : { CONoUTrAW( T("Cc" ": \"")+T(psttw)+T("\"\r\n") ) ; break ; }
                                case 0 : { CONoUTrAW( T("To: \"")+T(psttw)+T("\"\r\n") ) ; break ; }
                            {
                            switch( off )
                            sIn >> psttw ; ___( psttw ) ;
                            ZE( strokeS* , psttw ) ;
                        {
                        while( cPlates -- )
                        if( off < 2 ) cFrToCcLines += cPlates ;
                        sIn >> cPlates ;
                        ZE( countT , cPlates ) ;
                    {
                    for( countT off = 0 ; off < 3 ; off ++ )
                    stackC* ppzStk[] = { &stTo , &stCc , &stBc } ;
                {
                countT csttFrToCc = psttFrom->idAdam ;
                countT cFrToCcLines = 1 ;

                sIn >> psttFrom ; ___( psttFrom ) ;
                ZE( strokeS* , psttFrom ) ;
            {
            else
            }
                flagsFail |= flFAIL_COULDnOTgETsHADOW ;
                POOPR ;
            {
            if( POOP )
            ZE( boolT , bFailPermanent ) ;
            tinP.pEtScratch->boxGetShadowF( tinP , sIn , psttc1 ) ;
            soulC sIn( tinP , TAG( TAGiDnULL ) ) ;

            ZE( flagsT , flagsFail ) ;
            CONoUTrAW( TT(timeN1,timeN2)+T(" | mailing out ")+T(psttc1)+T(": ") ) ;
        {
        FORsTRINGSiN1( pstt1m )
        etThread.boxMenuF( tinP , soul , tToSend+tStar , 0 , 0x10 ) ; ___( pstt1m ) ;
        ZE( strokeS* , pstt1m ) ;

        }
            etThread.delF( tinP , pstt1m ) ;
            }
                etThread.delF( tinP , psttPart2 ) ;
                etThread.delF( tinP , psttPart1 ) ;
                etThread.diskMoveFileOrDirF( tinP , tToSend+T(psttPart2) , psttc1 ) ;
                etThread.strBisectF( tinP , psttPart1 , psttPart2 , psttc1 , 0 , - 1 ) ; ___( psttPart1 ) ; ___( psttPart2 ) ;
                ZE( strokeS* , psttPart2 ) ;
                ZE( strokeS* , psttPart1 ) ;
            {
            FORsTRINGSiN1( pstt1m )
            etThread.boxMenuF( tinP , pstt1m , tNotSent+tStar , 0 , 0x10 ) ; ___( pstt1m ) ;
            etThread.boxMenuF( tinP , soul , tNotSent+tStar , 0 , 0x10 ) ; ___( pstt1m ) ;
            ZE( strokeS* , pstt1m ) ;

            timeL2 = timeE2 ;
            timeL1 = timeE1 ;
        {
        if( timeE2 || timeE1 > TICK * 0x10 )
        
        etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeL1 , timeL2 ) ;
        etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
        ZE( sCountT , timeE2 ) ;
        ZE( countT  , timeE1 ) ;

        etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;
    {
    while( !ether && !etThread )
    ZE( sCountT , timeL2 ) ;
    ZE( countT  , timeL1 ) ;
    TN( tLeadingDoubleDot , "\r\n.." ) ;
    TN( tLeadingDot , "\r\n." ) ;
    TN( tDotRN , ".\r\n" ) ;
    stackC stBc( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stCc( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stTo( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    strokeS sSlash( '/' , sc_cFROMaSCII ) ;
    TN( tStar , "*" ) ;
    etThread.osThreadAdamF( tinP , ifcIDaDAM_ROOTfORMdATAeATER ) ;

    etThread.diskMakeDirIfNeededF( tinP , tNotSentAbandoned ) ;
    etThread.diskMakeDirIfNeededF( tinP , tNotSent ) ;
    etThread.diskMakeDirIfNeededF( tinP , tSent ) ;
    etThread.diskMakeDirIfNeededF( tinP , tToSend ) ;

    TN( tNotSentAbandoned , "" ) ; tNotSentAbandoned = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/email.notsentabandoned/") ;
    TN( tNotSent          , "" ) ; tNotSent          = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/email.notsent/") ;
    TN( tSent             , "" ) ; tSent             = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/email.sent/") ;
    TN( tToSend           , "" ) ; tToSend           = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/email.to.send/") ;

    const countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;

    SCOOPS
{
IFsCRATCH

}
    ++ s ; ether.osSleepF( tinP , TOCK * 0x10 ) ; //TO AVOID LOADING SERVER DURING SYSTEM GEN
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{

TODO

}
    return bFail ;
    }
        }
            }
                DEL( pInfo ) ;
                }
                    }
                        etherP.delF( tinP , posti ) ;
                        }
                            etherP.strFuseF( tinP , psttP , T(posti) ) ; ___( psttP ) ;
                            etherP.fileReadF( tinP , posti , cToDo , hFileBody ) ;
                        {
                        if( posti )
                        etherP.newF( tinP , LF , posti , costa ) ; ___( posti ) ;
                        ZE( osTextT* , posti ) ;
            
                        const countT costa = cToDo ;

                        if( cToDo > csttMaxP ) cToDo = csttMaxP ;

                        countT cToDo = pInfo->cbUsed ;
                        //CONoUTrAW3( "writing data: body file is " , pInfo->cbUsed , " bytes\r\n" ) ;
                    {
                    if( !bFail )
    
                    }
                        bFail = 1 ;
                        DEL( pInfo ) ;
                        //CONoUTrAW( "writing data: body file is too large\r\n" ) ;
                        POOPR
                    {
                    if( pInfo->cbUsedHigh )
                {
                if( !bFail && pInfo )
        
                }
                    bFail = 1 ;
                    //CONoUTrAW( "writing data: could not get info for body file\r\n" ) ;
                    POOPR
                {
                if( POOP )
                tinP.pEtScratch->diskFileQueryF( tinP , pInfo , hFileBody ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            if( !bFail )
    
            }
                bFail = 1 ;
                //CONoUTrAW( "writing data: could not open the body file\r\n" ) ;
                POOPR
            {
            if( POOP )
            tinP.pEtScratch->fileOpenF( tinP , hFileBody , countTC() , psttFileBodyP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
            handleC hFileBody( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            //CONoUTrAW( T("opening body file\r\n") ) ;
        {
    {
    else
    }
        bFail = 1 ;
    {
    else if( !etherP.diskFileExistsF( tinP , psttFileBodyP ) )
    }
        }
            etherP.strMakeF( tinP , LF , psttP , tBody ) ; ___( psttP ) ;
            etherP.delF( tinP , psttb ) ;
            TN( tBody , "" ) ; tBody = T(psttb) ;
            etherP.strSubstringF( tinP , psttb , idf , idl , psttFileBodyP ) ; ___( psttb ) ;
            ZE( countT , idl ) ;
            countT idf = tLit.csF( tinP ) + 1 ;
            ZE( strokeS* , psttb ) ;
        {
        if( tLit.csF( tinP ) < psttFileBodyP->idAdam )
    {
    if( 1 == etherP.strIdF( tinP , tLit , psttFileBodyP ) )
    TN( tLit , "!literal:" ) ;

    ZE( boolT , bFail ) ;
    _IO_
{
boolT getBodySnipFromFileF( tinS& tinP , etherC& etherP , strokeS*& psttP , const strokeS* const psttFileBodyP , const countT csttMaxP = TOCK )

}
    return bFail ;
    }
        //U::CANNOT DO THIS HERE BECAUSE THERE MIGHT BE MUTLIPLE RECIPIENTS, EACH OF WHICH NEEDS THIS FILE TO EXIST: if( !bFail && etherP.diskFileExistsF( tinP , psttFileBodyP ) ) etherP.boxZapF( tinP , psttFileBodyP ) ;

        }
            }
                DEL( pInfo ) ;
                }
                    }
                        etherP.delF( tinP , posti ) ;
                        }
                            }
                                }
                                    }
                                        }
                                            break ;
                                            if( bNew ) bNew = 0 ;
                                        {
                                        default :
                                        }
                                            break ;
                                            }
                                                CONoUTrAW( "." ) ;
                                                bNew = 0 ;
                                            {
                                            if( bNew )
                                        {
                                        case '.' :
                                        }
                                            break ;
                                            if( !bNew ) bNew = 1 ;
                                        {
                                        case '\n' :
                                        case '\r' :
                                    {
                                    switch( posti[ offi ] )
                                    CONoUTrAW( post2 ) ;
                                    osTextT post2[] = { posti[ offi ] , 0 } ;
                                {
                                for( countT offi = 0 ; offi < cNibble ; offi ++ )
            
                                cToDo -= cNibble ;
                                etherP.fileReadF( tinP , posti , cNibble , hFileBody ) ;
                                countT cNibble = costa < cToDo ? costa : cToDo ;
                            {
                            while( cToDo )
                            boolT bNew = 1 ;
                        {
                        if( posti )
                        etherP.newF( tinP , LF , posti , costa ) ; ___( posti ) ;
                        ZE( osTextT* , posti ) ;
            
                        const countT costa = TOCK < cToDo ? TOCK : cToDo ;
                        countT cToDo = pInfo->cbUsed ;
                        //CONoUTrAW3( "writing data: body file is " , pInfo->cbUsed , " bytes\r\n" ) ;
                    {
                    if( !bFail )
    
                    }
                        bFail = 1 ;
                        DEL( pInfo ) ;
                        //CONoUTrAW( "writing data: body file is too large\r\n" ) ;
                        POOPR
                    {
                    if( pInfo->cbUsedHigh )
                {
                if( !bFail && pInfo )
        
                }
                    bFail = 1 ;
                    //CONoUTrAW( "writing data: could not get info for body file\r\n" ) ;
                    POOPR
                {
                if( POOP )
                tinP.pEtScratch->diskFileQueryF( tinP , pInfo , hFileBody ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            if( !bFail )
    
            }
                bFail = 1 ;
                //CONoUTrAW( "writing data: could not open the body file\r\n" ) ;
                POOPR
            {
            if( POOP )
            tinP.pEtScratch->fileOpenF( tinP , hFileBody , countTC() , psttFileBodyP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
            handleC hFileBody( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            //CONoUTrAW( T("opening body file\r\n") ) ;
        {
    {
    else
    }
        bFail = 1 ;
    {
    else if( !etherP.diskFileExistsF( tinP , psttFileBodyP ) )
    }
        }
            CONoUTrAW( tBody ) ;
            etherP.delF( tinP , psttb ) ;
            TN( tBody , "" ) ; tBody = T(psttb) ;
            etherP.strSubstringF( tinP , psttb , idf , idl , psttFileBodyP ) ; ___( psttb ) ;
            ZE( countT , idl ) ;
            countT idf = tLit.csF( tinP ) + 1 ;
            ZE( strokeS* , psttb ) ;
        {
        if( tLit.csF( tinP ) < psttFileBodyP->idAdam )
        //CONoUTrAW( T("sending literal value\r\n") ) ;
    {
    if( 1 == etherP.strIdF( tinP , tLit , psttFileBodyP ) )
    TN( tLit , "!literal:" ) ;

    //CONoUTrAW( T("processing body file \"")+T(psttFileBodyP)+T("\"\r\n") ) ;
    ZE( boolT , bFail ) ;
    _IO_
{
boolT logBodySnipFromFileF( tinS& tinP , etherC& etherP , const strokeS* const psttFileBodyP )

}
    return bFail ;

    }
        //U::CANNOT DO THIS HERE BECAUSE THERE MIGHT BE MUTLIPLE RECIPIENTS, EACH OF WHICH NEEDS THIS FILE TO EXIST: if( !bFail && etherP.diskFileExistsF( tinP , psttFileBodyP ) ) etherP.boxZapF( tinP , psttFileBodyP ) ;

        }
            }
                DEL( pInfo ) ;
                }
                    }
                        etherP.delF( tinP , posti ) ;
                        }
                            }
                                }
                                    }
                                        }
                                            break ;
                                            if( bNew ) bNew = 0 ;
                                        {
                                        default :
                                        }
                                            break ;
                                            }
                                                sockP.writeF( tinP , "." , 1 ) ;
                                                bNew = 0 ;
                                            {
                                            if( bNew )
                                        {
                                        case '.' :
                                        }
                                            break ;
                                            if( !bNew ) bNew = 1 ;
                                        {
                                        case '\n' :
                                        case '\r' :
                                    {
                                    switch( posti[ offi ] )
                                    sockP.writeF( tinP , posti + offi , 1 ) ;
                                {
                                for( countT offi = 0 ; offi < cNibble ; offi ++ )
            
                                cToDo -= cNibble ;
                                etherP.fileReadF( tinP , posti , cNibble , hFileBody ) ;
                                countT cNibble = costa < cToDo ? costa : cToDo ;
                            {
                            while( cToDo )
                            boolT bNew = 1 ;
                        {
                        if( posti )
                        etherP.newF( tinP , LF , posti , costa ) ; ___( posti ) ;
                        ZE( osTextT* , posti ) ;
            
                        const countT costa = TOCK < cToDo ? TOCK : cToDo ;
                        countT cToDo = pInfo->cbUsed ;
                        //CONoUTrAW3( "writing data: body file is " , pInfo->cbUsed , " bytes\r\n" ) ;
                    {
                    if( !bFail )
    
                    }
                        bFail = 1 ;
                        DEL( pInfo ) ;
                        //CONoUTrAW( "writing data: body file is too large\r\n" ) ;
                        flagsFailP |= flFAIL_DATAbODYfILEtOOlARGE ;
                        POOPR
                    {
                    if( pInfo->cbUsedHigh )
                {
                if( !bFail && pInfo )
        
                }
                    bFail = 1 ;
                    //CONoUTrAW( "writing data: could not get info for body file\r\n" ) ;
                    flagsFailP |= flFAIL_DATAcANNOTgETbODYfILEiNFO ;
                    POOPR
                {
                if( POOP )
                tinP.pEtScratch->diskFileQueryF( tinP , pInfo , hFileBody ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            if( !bFail )
    
            }
                bFail = 1 ;
                //CONoUTrAW( "writing data: could not open the body file\r\n" ) ;
                flagsFailP |= flFAIL_DATAcANNOToPENfILE ;
                POOPR
            {
            if( POOP )
            tinP.pEtScratch->fileOpenF( tinP , hFileBody , countTC() , psttFileBodyP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
            handleC hFileBody( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            //CONoUTrAW( T("opening body file\r\n") ) ;
        {
    {
    else
    }
        bFail = 1 ;
        flagsFailP |= flFAIL_DATAfILEdOESnOTeXIST ;
    {
    else if( !etherP.diskFileExistsF( tinP , psttFileBodyP ) )
    }
        }
            sockP.writeF( tinP , (osTextT*)tBody , tBody.csF( tinP ) ) ;
            etherP.delF( tinP , psttb ) ;
            TN( tBody , "" ) ; tBody = T(psttb) ;
            etherP.strSubstringF( tinP , psttb , idf , idl , psttFileBodyP ) ; ___( psttb ) ;
            ZE( countT , idl ) ;
            countT idf = tLit.csF( tinP ) + 1 ;
            ZE( strokeS* , psttb ) ;
        {
        if( tLit.csF( tinP ) < psttFileBodyP->idAdam )
        //CONoUTrAW( T("sending literal value\r\n") ) ;
    {
    if( 1 == etherP.strIdF( tinP , tLit , psttFileBodyP ) )
    TN( tLit , "!literal:" ) ;

    //CONoUTrAW( T("processing body file \"")+T(psttFileBodyP)+T("\"\r\n") ) ;
    ZE( boolT , bFail ) ;
{
boolT writeBodySnipFromFileF( tinS& tinP , etherC& etherP , socketC& sockP , const strokeS* const psttFileBodyP , flagsT& flagsFailP )

}
    }
        sIn >> psttP ; ___( psttP ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinP , sOut ) ;
        sOut << cPassAccountSP ;
        sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKeMAILfROMiDaCCOUNT ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinP , homeS::homeIF().idPortListServerEmailIdAccount ) ;
        socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;

        SCOOPS
    {
    IFsCRATCH

    if( POOP ) return ;
    __NZ( psttP ) ;
    if( POOP ) return ;
{
voidT queryEmailFromIdAccountF( tinS& tinP , strokeS*& psttP , const countT cPassAccountSP )
//DUPLICATE CODE: b750104 3a50104

#define flFAIL_DATAfILEdOESnOTeXIST                 0x8000
#define flFAIL_DATAbODYfILEtOOlARGE                 0x4000
#define flFAIL_DATAcANNOTgETbODYfILEiNFO            0x2000
#define flFAIL_DATAcANNOToPENfILE                   0x1000
#define flFAIL_COULDnOTmOVEfILE                     0x0800
#define flFAIL_COULDnOTgETsHORTfILEnAME             0x0400
#define flFAIL_UNKNOWNeRROR                         0x0200
#define flFAIL_QUITcOMMANDrEJECTED                  0x0100
#define flFAIL_BODYrEJECTED                         0x0080
#define flFAIL_DATAcOMMANDrREJECTED                 0x0040
#define flFAIL_RCPTtOrEJECTED                       0x0020
#define flFAIL_MAILfROMrEJECTED                     0x0010
#define flFAIL_HELLOrEJECTED                        0x0008
#define flFAIL_COULDnOTcONNECT                      0x0004
#define flFAIL_DURINGpARSING                        0x0002
#define flFAIL_COULDnOTgETsHADOW                    0x0001

/*1*/WAKEhIDE( "ifcIDaDAM_ROOTmAILoUT" )/*1*/

/**/
*/
watches a directory containing email to send
/*

//OBSOLETES d750104
//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

