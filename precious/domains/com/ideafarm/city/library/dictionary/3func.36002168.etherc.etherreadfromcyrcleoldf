
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_
    }
        ph->cbRead += cbThis ;

        if( pbic == pbEnd ) pbic = pbBegin ;
        pbic += cbThis ;

        }
            }
                }
                    cbToDo = sizeof size2 ;
                    pboc = (byteT*)&size2 ;
                    bSize2 = 1 ;
                {
                else
                }
                    delF( tinP , pbData ) ;
                    else                              ++ cIgnoredP ;
                    if( size2 == size1 && pCyrcleOldFP ) bAbort = (*pCyrcleOldFP)( tinP , *this , cParmP , pbData , size1 ) ;

                    putNegAM( ((countT*)pbic2)[ - 1 ] , FINGERnEG_CYRCLEoLDwRITEsMUDGE ) ;
                    cbToDo = sizeof finger1 ;
                    pboc = (byteT*)&finger1 ;
                    bFinger1 = 1 ;
                    bFinger2 = 0 ;
                {
                else if( bFinger2 )
                }
                    cbToDo = sizeof finger2 ;
                    pboc = (byteT*)&finger2 ;
                    bFinger2 = 1 ;
                    bFlags2 = 0 ;
                {
                else if( bFlags2 )
                }
                    cbToDo = sizeof flags2 ;
                    pboc = (byteT*)&flags2 ;
                    bFlags2 = 1 ;
                    bSize2 = 0 ;
                {
                else if( bSize2 )
                }
                    cbToDo = pbData ? size1 : 0 ;
                    pboc = pbData ;
                    pbData[ size1 ] =  0 ;
                    if( !pbData ) { BLAMMO ; }

                    }
                    {
                    if( size1 >= TOCK )

                    _OUT_
                    }
                        newF( tinP , LF , pbData , size1 + 1 ) ; ___( pbData ) ;
                    {
                    _INoLD_

                    }
                    {
                    if( size1 >= TOCK )

                    if( size1 == - 1 ) { BLAMMO ; } ;
                    bSize1 = 0 ;
                {
                else if( bSize1 )
                }
                    }
                        }
                            cRetryFlags = CrETRYcYRCLEoLDrEAD ;
                            cbToDo = 0 ;
                            pboc = 0 ;
                            bSearch = 1 ;
                            bFlags1 = 0 ;
                        {
                        else
                        }
                            ++ s ; osSleepF( tinP , TUCK * 0x20 ) ;
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    
                            cbToDo = sizeof flags1 ;
                            pboc = (byteT*)&flags1 ;
                            pbic2 -= sizeof flags1 ;
                        {
                        if( cRetryFlags -- )

                        LOGrAW( tLog ) ;
                        tLog += T("\r\n") ;
                        if( !( F(flags1) & flCYRCLEoLDwRITE_CLEAN ) ) tLog += T(" DIRTY") ;
                        if( !bOk ) tLog += T(" TRASHED") ;
                        TN( tLog , "" ) ; tLog = TT(timeN1,timeN2)+T(" | flags1:")+TF2(flags1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" is trashed or says \"dirty\" and cRetryFlags is ")+TF2(cRetryFlags,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" within etherReadFromCyrcleOldF: ") ;
                        
                        osTimeNowF( tinP , timeN1 , timeN2 ) ;
                        ZE( sCountT , timeN2 ) ;
                        ZE( countT , timeN1 ) ;
                    {
                    else
                    }
                        cbToDo = sizeof size1 ;
                        pboc = (byteT*)&size1 ;
                        bSize1 = 1 ;
                        bFlags1 = 0 ;
                    {
                    if( bOk && F(flags1) & flCYRCLEoLDwRITE_CLEAN )

                    FiSvALID( bOk , flCYRCLEoLDwRITE , flags1 ) ;
                    ZE( boolT , bOk ) ;
                {
                else if( bFlags1 )
                }
                    putNegAM( ((flagsT*)pbic2)[ - 1 ] , FINGERnEG_CYRCLEoLDwRITEsMUDGE ) ;
                    cbToDo = sizeof flags1 ;
                    pboc = (byteT*)&flags1 ;
                    bFlags1  = 1 ;
                    bFinger1 = 0 ;
                {
                if( bFinger1 )
            {
            if( !cbToDo )

            }
                *( pboc ++ ) = *( pbic2 ++ ) ;
                cbToDo -- ;
            {
            if( cbToDo )

            }
                else break ;
                }
                    cbToDo = sizeof finger1 ;
                    pboc = (byteT*)&finger1 ;
                    bFinger1 = 1 ;
                    bSearch = 0 ;
                {
                if( pbic2 < pbic2e )

                _OUT_
                while( getNegAM( *(countT*)pbic2 ) != FINGERnEG_CYRCLEoLDwRITE && ++ pbic2 < pbic2e ) ;  //U:: READ FROM HIGH ADDRESS OBSERVED HERE 2008: READ FROM 0001f94
                _INoLD_

                }
                    LOGrAW( tLog ) ;
                    TN( tLog , "" ) ; tLog = TT(timeN1,timeN2)+T(" | search ")+TF2(idIn,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" within etherReadFromCyrcleOldF\r\n") ;

                    osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                {

                countT idIn = 1 + incv02AM( idInLath ) ;
                static countT idInLath ;
                //U:: TO FIND A BUG

                thirdC::dosBeepIF( tinP , TUCK , TUCK ) ; //U::
                //BLAMMO ; //2008.07.05: CONJ: SEARCH SHOULD NEVER BE NEEDED: 
            {
            if( bSearch )
        {
        while( pbic2 < pbic2e && !POOP )
        countT cRetryFlags = CrETRYcYRCLEoLDrEAD ;
        const byteT* pbic2e = pbic + cbThis ;
        const byteT* pbic2  = pbic ;



        countT cbThis = (sCountT)cbOver >= 0 ? cbNew - cbOver : cbNew ;
        countT cbOver = pbic + cbNew - pbEnd ;

        if( (sCountT)cbNew < 0 ) cbNew = 0x7fffffff ; //A:ASSUME: sizeof( countT ) IS 02
        countT cbNew  = ph->cbWritten - ph->cbRead ;


        //FOR THE BENEFIT OF THE EXCEPTION HANDLER PROCESSING AN EXCEPTION IN cirMonitorF IN 2e40104, GRABBING IS UNDESIRABLE HERE BECAUSE THE EXCEPTION HANDLER WANTS TO WRITE TO THE CIRCLE DURING THE CALL TO pCyrcleOldFP

        }
            }
                }
                    etherSnapCyrcleOldF( tinP , pbSnapP , cbSnapP , offBeginSnapP , *pNapkinP ) ;
                    bSnapP = 0 ;
                {
                else if( !pbSnapP && !cbSnapP && !offBeginSnapP )
                if( !bSnapP ) { ++ s ; thirdC::dosSleepRawIF( tinP , 0x20 ) ; }
            {
            while( ph->cbWritten == ph->cbRead && !POOP && !bQuitP )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {

        }
            continue ;
            bQuitSeen = 1 ;
            cbReadQuit = ph->cbWritten ; //U::THIS IS OBSOLETED BY flCYRCLEoLD_CLOSING: NAWWWH
            ph->flags |= flCYRCLEoLD_CLOSING ;
        {
        if( bQuitP && !bQuitSeen )
    {
    while( !POOP && !bAbort && ( !bQuitSeen || ph->cbRead < cbReadQuit ) )
    if( pSgnReadyP ) pSgnReadyP->giveF( tinP ) ;
    ZE( boolT , bQuitSeen ) ;
    ZE( countT , cbReadQuit ) ;
    ZE( boolT , bAbort ) ;
    ZE( countT , cEntries ) ;
    countT cbToDo = sizeof finger1 ;
    byteT* pboc = (byteT*)&finger1 ;
    const byteT* pbic = pbBegin ;
    ZE( byteT* , pbData ) ;
    ZE( countT , size2 ) ;
    ZE( countT , size1 ) ;
    ZE( flagsT , flags2 ) ;
    ZE( flagsT , flags1 ) ;
    ZE( countT , finger2 ) ;
    ZE( countT , finger1 ) ;
    ZE( boolT , bSize2 ) ;
    ZE( boolT , bSize1 ) ;
    ZE( boolT , bFlags2 ) ;
    ZE( boolT , bFlags1 ) ;
    ZE( boolT , bFinger2 ) ;
    boolT bFinger1 = 1 ;
    ZE( boolT , bSearch ) ;

    byteT* pbEnd   = pbBegin + cbCyrcleOldP ;
    byteT* pbBegin = (byteT*)ph + sizeof( cyrcleOldHeaderS ) ;
    else if( napCyrcleOld != sizeof( cyrcleOldHeaderS ) + cbCyrcleOldP ) { BLAMMO ; }
    if( !ph ) { BLAMMO ; }
    cyrcleOldHeaderS* ph = (cyrcleOldHeaderS*)(byteT*)napCyrcleOld ;
    napkinC& napCyrcleOld = *pNapkinP ;
    __Z( pNapkinP ) ;
    }
        }
            else if( *pNapkinP != sizeof( cyrcleOldHeaderS ) + cbCyrcleOldP ) { BLAMMO ; }
            }
                pNapkinP->formattingIsDoneF( tinP ) ;
                ph->flags = flCYRCLEoLD_null ;
                memSetF( tinP , (byteT*)ph , sizeof( cyrcleOldHeaderS ) ) ;
            {
            else if( !( F(pNapkinP->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
            if( !ph ) { BLAMMO ; }
            cyrcleOldHeaderS* ph = (cyrcleOldHeaderS*)(byteT*)*pNapkinP ;
        {
        if( pNapkinP )

        pNapkinP = new( 0 , tinP , LF ) napkinC( tinP , LF , (byteT*)bits_pNapkinP_P , textC( tinP , LF , (byteT*)bits_pNapkinP_P , flTEXTc_null , psttNapkinP ) , 0 , sizeof( cyrcleOldHeaderS ) + cbCyrcleOldP , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_null , - 1 , idMemorySpaceP ) ; ___( pNapkinP ) ;
    {
    if( !pNapkinP )
    _INoLD_

    }
        if( POOP ) return ;
        __( idMemorySpaceP && !( F(tinP.flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tinP ) >= ifcIDpHASEaDAM_PROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tinP ) < ifcIDpHASEaDAM_EPILOGaDAMmAINa1 ) ;
        __Z( cbCyrcleOldP )
        __Z( psttNapkinP )
        __NZ( pNapkinP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::etherReadFromCyrcleOldF( tinS& tinP , napkinC*& pNapkinP , bitsC& bits_pNapkinP_P , cyrcleOldFT pCyrcleOldFP , countT& cParmP , boolT& bQuitP , const strokeS* const psttNapkinP , const countT cbCyrcleOldP , countT& cIgnoredP , byteT*& pbSnapP , countT& cbSnapP , countT& offBeginSnapP , boolT& bSnapP , const countT idMemorySpaceP , signC* const pSgnReadyP )/*1*/

/**/
*/
  the size of the data portion of the circular buffer
 cbCyrcleOldP
  another napkin with the same name can be, but normally is not, constructed by this process
  the name of the napkinC that contains the circular buffer
 psttNapkinP
   all entries existing when bQuitP is woth seen are processed; then i quit
  when this value transitions from ze i process the extant transactions and then quit
  i read but do not modify this value
 bQuitP
  i simply pass it along to pCyrcleOldFP
  i do not use this value
 cParmP
  if not 0 then will be called for each entry in the circular buffer
  normally is not 0
  can be 0
 pCyrcleOldFP
  caller is responsible for deleting after la'th call
  will be allocated on the wo'th call
  on wo'th call, must be 0
 pNapkinP
 tinP
arguments
\<A HREF=\"5.10301b8.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$etherReadFromCyrcleOldF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

