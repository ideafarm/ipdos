
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    if( idPass == 2 ) etThread.delF( tinP , postBufferBodyLarge ) ;
    etThread.delF( tinP , postBufferHead ) ;

    }
        ostInLag1 = ostIn ;
        ostInLag2 = ostInLag1 ;
        ostInLag3 = ostInLag2 ;
        ostInLag4 = ostInLag3 ;
        ostInLag5 = ostInLag4 ;
        ostInLag6 = ostInLag5 ;

        }
            }
                }
                    }
                        }
                            }
                                }
                                    if( !POOP ) thirdC::c_strcpyIF( tinP , postOuterBoundary , postb ) ;
                                    __( poste - postb > sizeof postOuterBoundary - 1 ) ;
                                    *poste = 0 ; //THIS MODIFIES THE HEADER IN THE BUFFER ; THIS CAN GOOF UP FUTURE CODE CHANGES ; IF NECESSARY, REWRITE THIS TO AOID MODIFYING postBufferHead
                                {
                                if( poste )
                                osTextT* poste = thirdC::c_strstrIF( tinP , postb , "\"" ) ;
                                postb += sizeof postLookBoundary - 1 ;
                            {
                            if( postb )
                            osTextT* postb = thirdC::c_strstrIF( tinP , postContentType , postLookBoundary ) ;
                        {
                        if( thirdC::c_strstrIF( tinP , postContentType , "multipart/alternative" ) )

                        //Content-Type: multipart/alternative; 	boundary="===============2670898874187650734=="

                        *poste = 0 ; //THIS MODIFIES THE HEADER IN THE BUFFER ; THIS CAN GOOF UP FUTURE CODE CHANGES ; IF NECESSARY, REWRITE THIS TO AOID MODIFYING postBufferHead
                    {
                    if( poste )
                    osTextT* poste = thirdC::c_strstrIF( tinP , postContentType , "\r\n" ) ;
                    postContentType += 2 ;
                {
                if( postContentType )
                osTextT* postContentType = thirdC::c_strstrIF( tinP , postBufferHead , "\r\nContent-Type:" ) ;
            {
            if( idPass == 2 )

            bMime = !!thirdC::c_strstrIF( tinP , postBufferHead , "\r\nMIME-Version:" ) ;

            offCursorBody = costIn ;
            etThread.fileWriteF( tinP , fo , postBufferHead , offbhNext ) ;
            bHeader = 0 ;
        {
        )
            && ostInLag3 == '\r'
            && ostInLag2 == '\n'
            && ostInLag1 == '\r'
            && ostIn     == '\n'
            bHeader
        (
        if

        }
            }
                }
                    break ;

                    }
                        //CONoUTrAW( post3 ) ;
                        //osTextT post3[] = { ' ' , ostIn , 0 } ;

                        postBufferHead[ offbhNext ++ ] = ostIn ;
                        postBufferHead[ offbhNext ++ ] = ' ' ;
                        bLazyCRLFpending = 0 ;
                    {
                    if( ostIn != ' ' )
                {
                case 3 :
                }
                    break ;
                    //CONoUTrAW( post2 ) ;
                    //osTextT post2[] = { ostIn , 0 } ;

                    postBufferHead[ offbhNext ++ ] = ostIn ;
                {
                case 0 :
            {
            switch( bLazyCRLFpending ) //OBEYS bLazyCRLFpending

            }
                }
                    break ;
                    }
                        //CONoUTrAW( "\r\n" ) ;
                        postBufferHead[ offbhNext ++ ] = '\n' ;
                        postBufferHead[ offbhNext ++ ] = '\r' ;
                        bLazyCRLFpending = 0 ;
                    {
                    else
                    if( ostIn == ' ' || ostIn == '\t' ) bLazyCRLFpending ++ ;
                {
                case 2 :
                case 1 : { if( ostIn == '\n' ) bLazyCRLFpending ++  ; break ; }
                case 0 : { if( ostIn == '\r' ) bLazyCRLFpending ++  ; break ; }
            {
            switch( bLazyCRLFpending ) //UPDATES bLazyCRLFpending
        {
        else
        }
            else              postBufferBodyLarge[ offbblNext ++ ] = ostIn ;
            if( idPass == 1 ) etThread.fileWriteF( tinP , fo , &ostIn , 1 ) ; // THIS LINE WILL WRITE THE "From" THAT BEGINS EACH NEW HEADER OTHER THAN THE WOTH HEADER
        {
        if( !bHeader )

        }
            etThread.traceF( tinP , T("beginning to process header [costBodyMax,costIn]: ")+TF2(costBodyMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(costIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            else              { offbhNext = 4 ;thirdC::c_memcpyIF( tinP , postBufferHead , "From" , 4 ) ; }
            if( idPass == 1 )   offbhNext = 0 ;

            }

                offbblNext = 0 ;

                emitAbridgementF( tinP , etThread , fo , postBufferBodyLarge , bMime , postOuterBoundary ) ;
                postBufferBodyLarge[ offbblNext ] = 0 ;

                offbblNext -= 4 ; // REMOVE "From"
            {
            else
            }
                if( costBodyMax < costBodyCursored ) costBodyMax = costBodyCursored ;
                countT costBodyCursored = costIn - 5 - offCursorBody ; // THE CURSORED BODY INCLUDES ITS TERMINATING CRLF (IMMEDIATELY BEFORE "From ")
            {
            if( idPass == 1 )

            bHeader = 1 ;
        {
        )
            && ostInLag6 == '\r'
            && ostInLag5 == '\n'
            && ostInLag4 == 'F'
            && ostInLag3 == 'r'
            && ostInLag2 == 'o'
            && ostInLag1 == 'm'
            && ostIn     == ' '
            !bHeader
        (
        if

        costIn ++ ;

        }
            break ;

            }
                }
                    emitAbridgementF( tinP , etThread , fo , postBufferBodyLarge , bMime , postOuterBoundary ) ;
                    postBufferBodyLarge[ offbblNext ] = 0 ;
                {
                else
                }
                    if( costBodyMax < costBodyCursored ) costBodyMax = costBodyCursored ;
                    countT costBodyCursored = costIn - offCursorBody ;
                {
                if( idPass == 1 )
            {
            if( !bHeader )
        {
        if( !cba )
        etThread.fileReadF( tinP , &ostIn , cba , fi , 1 ) ;
        countT cba = 1 ;
    {
    while( !ether && !POOP )
    osTextT postLookBoundary[] = "boundary=\"" ;
    osTextT postOuterBoundary[ TUCK ] = "fooey" ;
    ZE( boolT , bMime ) ;
    TN( tb4 , "    " ) ;
    ZE( countT , offCursorBody ) ;
    ZE( countT , costIn ) ;
    ZE( boolT , bLazyCRLFpending ) ;
    ZE( osTextT , ostInLag6 ) ;
    ZE( osTextT , ostInLag5 ) ;
    ZE( osTextT , ostInLag4 ) ;
    ZE( osTextT , ostInLag3 ) ;
    ZE( osTextT , ostInLag2 ) ;
    ZE( osTextT , ostInLag1 ) ;
    ZE( osTextT , ostIn     ) ;

    ZE( countT , offbblNext ) ;
    ZE( countT , offbhNext ) ;

    }
        __Z( postBufferBodyLarge  ) ;
        etThread.newF( tinP , LF , postBufferBodyLarge  , costBodyMax + 1 ) ; ___( postBufferBodyLarge  ) ;
    {
    if( idPass == 2 )

    __Z( postBufferHead ) ;
    etThread.newF( tinP , LF , postBufferHead , TOCK ) ; ___( postBufferHead ) ;
    ZE( osTextT* , postBufferBodyLarge ) ;
    ZE( osTextT* , postBufferHead ) ;

    fileC   fo( tinP , (strokeS*)T( idPass == 1 ?                                          "///d/tmp/gmail.download/2unwrapped.ttt" : "///d/tmp/gmail.download/3abridged.ttt" ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
    fileC   fi( tinP , (strokeS*)T( idPass == 1 ? "///d/tmp/gmail.download/gmail.mbox" : "///d/tmp/gmail.download/2unwrapped.ttt" ) ) ;
    //fileC fi( tinP , (strokeS*)T( idPass == 1 ? "///d/tmp/gmail.download/1small.ttt" : "///d/tmp/gmail.download/2unwrapped.ttt" ) ) ;

    boolT bHeader = 1 ;
{
for( countT idPass = 1 ; idPass <= 2 ; idPass ++ ) // 1: UNWRAP HEADER LINES, CALCULATE SIZE OF LARGEST BODY ; 2: SUPPRESS SOME PARTS OF EACH BODY
ZE( countT , costBodyMax ) ;

//BLAMMO ;

//}
//    etThread.delF( tinP , postIn ) ;
//
//    etThread.boxPutF( tinP , T("///d/tmp/gmail.download/1small.ttt") , postIn , costaIn ) ;
//
//    }
//        etThread.fileReadF( tinP , postIn , cba , fi ) ;
//        countT cba = costaIn ;
//        fileC fi( tinP , (strokeS*)T("///d/tmp/gmail.download/gmail.mbox") ) ;
//    {
//    etThread.newF( tinP , LF , postIn , costaIn ) ; ___( postIn ) ;
//    countT costaIn = TOCK << 4 ;
//    ZE( osTextT* , postIn ) ;
//{
// THIS STUFF JUST CREATES A SMALL FILE THAT I CAN USE DURING PLAYCRAFTING OF THIS ADAM

TODO

}
    }
        }
            eatPartsF( tinP , etherP , foP , postBufferInP , postOuterBoundaryP ) ;
            etherP.traceF( tinP , T("boundary marker: ")+T(postOuterBoundaryP) ) ;
        {
        if( !POOP )

        __Z( postOuterBoundaryP && *postOuterBoundaryP ) ;
    {
    else
    if( !bMimeP ) etherP.fileWriteF( tinP , foP , postBufferInP , strlen( postBufferInP ) ) ; //U::FOR TESTING ONLY: THIS SHOULD RESULT IN AN OUTPUT FILE THAT IS IDENTICAL TO PASS 2 INPUT FILE

    etherP.traceF( tinP , T( bMimeP ? "the body will be parsed as a MIME body" : "the body will NOT be parsed as a MIME body" ) ) ;
{
voidT emitAbridgementF( tinS& tinP , etherC& etherP , fileC& foP , osTextT* postBufferInP , const boolT bMimeP , const osTextT* const postOuterBoundaryP )

}
    //U::    etherP.fileWriteF( tinP , foP , postBufferInP , strlen( postBufferInP ) ) ; //U::FOR TESTING ONLY: THIS SHOULD RESULT IN AN OUTPUT FILE THAT IS IDENTICAL TO PASS 2 INPUT FILE
    }
        }
            }
                postc = poste ;

                eatHeaderBodyF( tinP , etherP , foP , postc , poste ? poste - postc : thirdC::c_strlenIF( tinP , postc ) ) ;

                osTextT* poste = thirdC::c_strstrIF( tinP , postc , postLookMarker ) ;

                postc += costLookMarker + 2 ; //A:ASSUME: MARKERS ARE ALWAYS FOLLOWED BY CRLF
            {
            else
            if( !postc ) break ;
            postc = thirdC::c_strstrIF( tinP , postc , postLookMarker ) ;
        {
        while( postc )
        osTextT* postc = postP ;

        *postEnd = 0 ;
    {
    if( postEnd )
    osTextT* postEnd = thirdC::c_strstrIF( tinP , postP , postLookMarkerEnd ) ;

    thirdC::c_strcpyIF( tinP , postLookMarkerEnd , T(postLookMarker)+T("--") ) ;
    osTextT postLookMarkerEnd[ TUCK ] ;

    const countT costLookMarker = thirdC::c_strlenIF( tinP , postLookMarker ) ;
    thirdC::c_strcpyIF( tinP , postLookMarker , T("--")+T(postbP) ) ;
    osTextT postLookMarker[ TUCK ] ;
{
voidT eatPartsF( tinS& tinP , etherC& etherP , fileC& foP , osTextT* postP , const osTextT* const postbP )

}
    }
        }
            etherP.fileWriteF( tinP , foP , "---- END ------\r\n" , 0x11 ) ;
            etherP.fileWriteF( tinP , foP , postP , costP - costHead - 2 ) ;
            etherP.fileWriteF( tinP , foP , "---- BODY -----\r\n" , 0x11 ) ;

            postP = postHdrEnd + 2 ;

            //etherP.fileWriteF( tinP , foP , "---- END ------\r\n" , 0x11 ) ;
            //etherP.fileWriteF( tinP , foP , postP , costHead ) ;
            //etherP.fileWriteF( tinP , foP , "---- HEAD -----\r\n" , 0x11 ) ;
        {
        if( bWantHeadF( tinP , etherP , postP , costHead ) )

        countT costHead = postHdrEnd - postP ;

        postHdrEnd += 2 ;
    {
    if( postHdrEnd )
    osTextT* postHdrEnd = thirdC::c_strstrIF( tinP , postP , "\r\n\r\n" ) ;
{
voidT eatHeaderBodyF( tinS& tinP , etherC& etherP , fileC& foP , osTextT* postP , const countT costP )

}
    return bWant ;

    postP[ costP ] = save ;

    boolT bWant = !thirdC::c_strstrIF( tinP , postP , "image/" ) ;
    //boolT bWant = thirdC::c_strstrIF( tinP , postP , "text/plain" ) && thirdC::c_strstrIF( tinP , postP , "7bit" ) ;

    postP[ costP ] = 0 ;
    osTextT save = postP[ costP ] ;
{
boolT bWantHeadF( tinS& tinP , etherC& etherP , osTextT* postP , const countT costP )

/*1*/WAKEsHOWtEXT( "doodle tool abridge mbox file" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

