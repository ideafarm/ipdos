
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
        _OUT_
    
        tinP.pAdamGlobal3->_socketC_.grab.ungrabF( tinP ) ;
        pOdometer->cbWrite += tinP.odoSockCbWrite - _odoSockCbWriteOpen ;
        pOdometer->cbRead  += tinP.odoSockCbRead  - _odoSockCbReadOpen  ;
        pOdometer = (sockOdometerS*)&(countT&)*tinP.pAdamGlobal3->_socketC_.pSwOdometer ;
        tinP.pAdamGlobal3->_socketC_.nnLever = nnPeer ;
        tinP.pAdamGlobal3->_socketC_.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        bWrite.ungrabF( tinP ) ;
    
        if( idleTimeAllowedWrite ) FRESHtIMEaTOMIC( *pEther , timeLathWrite.time1 , timeLathWrite.time2 )
    
        }
            }
                pEther->delF( tinP , pcCode ) ;
                else                     writeF( tinP , (byteT*)pcCode , sizeof( count01T ) * ccCode ) ;
                if( !pcCode || !ccCode ) __1
        
                mom( tinP , pcCode , ccCode , pbOut , cbOut , pczPillNameP , bPinP ) ; ___( pcCode ) ;
                ZE( countT    , ccCode ) ;
                ZE( count01T* , pcCode ) ;
        
                countT cbOut = pbOut ? sizeof( countT ) + cbTrailer : 0 ;
                if( pbOut ) pbOut += cbHeader ;
    
                //countT cbOut = pbOut ? cbHeader + sizeof( countT ) + cbTrailer : 0 ;
    
                }
                    cbTrailer = *(countT*)pbc ;
                    }
                        idFormat = *(countT*)pbc ; pbc += sizeof( countT ) ;
                                                   pbc += sizeof( countT ) ;
                        cbHeader = sizeof( countT ) * 2 ;
                    {
                    if( pbc && getNegAM( *(countT*)pbc ) == FINGERnEG_SOULc )
                    const byteT* pbc = pbOut ;
                    ZE( countT , idFormat ) ;
                {
                ZE( countT , cbTrailer ) ;
                ZE( countT , cbHeader ) ;
                const byteT* pbOut = soulP ;
            {
            else if( !*pEther )
            }
                THREADmODE1rESTORE

                else                                               pEther->sockWriteF(     tinP , handle      , soulP       ) ;
                if( F(flagsMode) & flSOCKETcmODE_CRYPTfOREIGNsSL ) pEther->openSsl_writeF( tinP , handle , WS( soulP ) ) ;

                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            {
            if( F(flags) & flSOCKETc_NOsECRECY )
        {
        if( bPayload )
    
        }
            }
                }
                    /*default :*/ { __( idCmdTopSecretP ) ; /*break ;*/ }
                {
                //switch( idCmdTopSecretP )
                bPayload = 0 ;
            {
            if( idCmdTopSecretP != ifcIDcMDsOCKETtOPsECRET_PAYLOAD )
    
            writeF( tinP , (byteT*)&idCmdTopSecretP , sizeof idCmdTopSecretP ) ;
            if( !idCmdTopSecretP ) idCmdTopSecretP = ifcIDcMDsOCKETtOPsECRET_PAYLOAD ;
    
    
            }
                }
                    break ;
    
                    (*pEther)( tinP , pSoul ) ;
                    }
                        }
                            (*pEther)( tinP , psFinger ) ;
                            }
                                writeF( tinP , *psFinger ) ;
                                *psFinger << (countT)FINGERnEG_SOCKETsECREThANDSHAKE ;
                            {
                            if( psFinger )
                            (*pEther)( tinP , psFinger , TAG( TAGiDnULL ) ) ;
                            ZE( soulC* , psFinger ) ;
    
                            pEther->delF( tinP , pcCode ) ;
                            }
                                writeF( tinP , (byteT*)pcCode , ccCode * sizeof( count01T ) ) ;
                                writeF( tinP , (byteT*)&ccCode , sizeof ccCode ) ;
        
                                writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;
                                countT idCmd = ifcIDcMDsOCKETtOPsECRET_3APPLYtHISpINrEFERENCE ;
                            {
                            else
                            if( !pcCode || !ccCode ) __1
                    
                            mom( tinP , pcCode , ccCode , 0 , 0 , pczKeyTopSecretPeer , 1 ) ; ___( pcCode ) ;
                            ZE( countT    , ccCode ) ;
                            ZE( count01T* , pcCode ) ;
                        {
    
                        //CONoUT( "sending reference" ) ;
                    {
                    if( pSoul )
                    (*pEther)( tinP , pSoul , TAG( TAGiDnULL ) ) ;
                    ZE( soulC* , pSoul ) ;
                    idPhaseTopSecret = ifcIDpHASEsOCKETtOPsECRET_4SECURED ;
                {
                case ifcIDpHASEsOCKETtOPsECRET_3SENDpINrEFERENCE :
                }
                    }
                        }
                            break ;
                            }
                                writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;
                                countT idCmd = ifcIDcMDsOCKETtOPsECRET_2SENDpINiMAGEsECRETLY ;
                            {
                            if( homeS::homeIF().cSecretServerRegistrationsSeen )
                        {
                        else
                        if( pEther->diskFileExistsF( tinP , tLongPeer ) ) idPhaseTopSecret = ifcIDpHASEsOCKETtOPsECRET_3SENDpINrEFERENCE ;
    
                        TN( tLongPeer , "" ) ; tLongPeer = T("///desk/" POSTfOLDERsECURITYkEYdEPOSITORY)+(idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/")+tShort ;
                        countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;
                        textC tShort( tinP , TAG( TAGiDnULL ) , flTEXTc_null , (countT*)pczKeyTopSecretPeer , flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE , 8 , 0 , tDot ) ;
                        TN( tDot , "." ) ;
                    {
                    else
                    if( !pczKeyTopSecretPeer ) break ;
                {
                case ifcIDpHASEsOCKETtOPsECRET_2REQUESTpINiMAGE :
                }
                    break ;
    
                    }
                        (*pEther)( tinP , pSoul ) ;
                        }
                            writeF( tinP , *pSoul ) ;
                            homeS::homeIF().idptRelay >> *pSoul ;
                            *pSoul << pczKeyTopSecret ;
                        {
                        if( pSoul )
                        (*pEther)( tinP , pSoul , TAG( TAGiDnULL ) ) ;
                        ZE( soulC* , pSoul ) ;
        
                        writeF( tinP , (byteT*)&idCmd , sizeof idCmd ) ;
                        countT idCmd = ifcIDcMDsOCKETtOPsECRET_1MYpINnAMEiS ;
        
                        idPhaseTopSecret = ifcIDpHASEsOCKETtOPsECRET_2REQUESTpINiMAGE ;
                    {
                    if( pczKeyTopSecret && homeS::homeIF().idptRelay )
                {
                case ifcIDpHASEsOCKETtOPsECRET_1SENDpINnAME :
            {
            switch( idPhaseTopSecret )
    
            BLAMMO ; //U::flSOCKETc_TOPsECRET IS NOT YET SUPPORTED; IT WORKS AND CODING IS COMPLETE, BUT DEADLOCK OCCURS 1/2 OF TIME; DISABLED PENDING COMPLETION OF MONITOR
        {
        if( F(flags) & flSOCKETc_TOPsECRET )
        boolT bPayload = 1 ;
    
        bWrite.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        const countT _odoSockCbWriteOpen = tinP.odoSockCbWrite ;
        const countT _odoSockCbReadOpen  = tinP.odoSockCbRead  ;
    
        _INoLD_
    
        }
            }
                return ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL    
        SCOOPP
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/voidT socketC::writeF( tinS& tinP , soulC& soulP , const countT* const pczPillNameP , const boolT bPinP , countT idCmdTopSecretP )/*1*/

/**/
*/
  if flSOCKETc_TOPsECRET and not 0 then soulP is interpreted as arguments to the specified command
   equivalent to specifying ifcIDcMDsOCKETtOPsECRET_PAYLOAD
  if flSOCKETc_TOPsECRET and 0 then soulP is handled as data to be sent
  if not flSOCKETc_TOPsECRET then ignored
  normally 0
 idCmdTopSecretP
 bPinP
   only a reference to that pill file will be sent over the connection
  if not 0 then the codes for the soulP image will be written to a pill file
  normally 0
 pczPillNameP
  else see idCmdTopSecretP
  if not flSOCKETc_TOPsECRET then the image of soulP is written
 soulP
 tinP
arguments
\<A HREF=\"5.1070028.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$writeF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

