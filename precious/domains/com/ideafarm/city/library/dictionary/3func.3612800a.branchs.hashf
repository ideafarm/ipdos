
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            BLAMMO ; // CALLER SHOULD CALL ME ONLY FOR STROKE STRING BRANCHES
        {
        default :
        }
            break ;

            }
                }
                    DELzOMBIE( pPageRelease ) ;

                    }
                        }
                            else                   stHashCollisionsP.sinkF( tinP , countTC() , B(brThis).hashv , flSTACKsINK_UNIQUE ) ;
                            if( !( bits & mask ) ) bits |= mask ;
                        
                            countT& bits = barryHashP( tinP , B(brThis).hashv , mask , offBit ) ;
                            countT offBit ; //INTENTIONALLY UNINITIALIZED FOR SPEED
                            countT mask   ; //INTENTIONALLY UNINITIALIZED FOR SPEED
                        {
                        if( !POOP )
                
                        __Z( B(brThis).hashv ) ;
                        }
                            B(brThis).hashv = - 1 ;
                            etherC::etRockIF( tinP ).traceF( tinP , T("::hashF returned a null hash") ) ;
                        {
                        if( !B(brThis).hashv )

                        B(brThis).hashv = myHash ;

                        BSP( brThis , jbrMeP ) ;
                    {

                    DELzOMBIE( pPageEncoded ) ;
                    countT myHash = ::hashF( (const byteT*)*pPageEncoded + sizeof( countT ) , cbe + sizeof( countT ) , 0 ) ; // HASHES EVERYTHING AFTER THE FINGERPRINT INCLUDING THE cbe FIELD
                    countT cbe = ((countT*)(const byteT*)*pPageEncoded)[ 1 ] ;
                {
                else
                }
                    DELzOMBIE( pPageRelease ) ;
                    DELzOMBIE( pPageEncoded ) ;
                    etherC::etRockIF( tinP ).traceF( tinP , T("branchS::hashF / invalid finger in encoding") ) ;
                {
                if( POOP )
            
                __( ((countT*)(const byteT*)*pPageEncoded)[ 0 ] - FINGERnEG_STReNCODEf ) ;

                pageC* pPageEncoded = new( 0 , tinP , pb_pageEncoded , sizeof pb_pageEncoded ) pageC( jotC::readIF( tinP , value ) ) ; //U::BUG: THIS MIGHT BE IN ANOTHER BOOK
                byteT pb_pageEncoded[ sizeof( pageC ) ] ;

                pageReleaseC* pPageRelease = new( 0 , tinP , pb_pageRelease , sizeof pb_pageRelease ) pageReleaseC( tinP , (const byteT*)this ) ;
                byteT pb_pageRelease[ sizeof( pageReleaseC ) ] ;
            {
            if( value )
        {
        case ifcIDtYPEbRANCHs_strokeSstr :
    {
    switch( idType )    
{
/*1*/voidT branchS::hashF( tinS& tinP , const countT jbrMeP , barryC& barryHashP , stackC& stHashCollisionsP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

