
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    ctCheckF() ;

    }
        if( !( F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERtHREADS ) && F(flagsCt2) & flGRABITc_DESIREcHANGEoNdEMAND ) thirdC::dosPriorityIF( tinP , idDesire ) ;
        




        //U::PROD: if( pbo && !btrAM( pbo , offo ) ) { BLAMMO ; } //U::20150816@1011 PISS WHILE BUILDING ARCHIVE REPORT FOR 2009; 20150922@0000 PISS WHILE BUILDING ARCHIVE REPORT FOR 2015; 20151129@1642 monitor tmReportF

        }
            //20170529@0730: 651 during startup
            //20170106@0926: tmReportF in 4fb
            BLAMMO ;
            //}
            //    tinP.pEther->traceF( tinP , T("btrAM failed / cRef: ")+TF2(cRef,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ; flagsi" ": ")+TF2(flagsi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ; idTypeDatum: ")+TF2(idTypeDatum,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            //    tinP.pEther->traceF( tinP , T("[cGrabitC_set,cGrabitC_reset]: ")+TF2(tinP.cGrabitC_set,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(tinP.cGrabitC_reset,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            //    byteT    idTypeDatum = (byteT)listing.idTypeDatumF() ;
            //    byteT    flagsi      =        listing.flagsF() ;
            //    count01T cRef        =        listing.cRefPrivate2F() ;
            //    listingC& listing = *(listingC*)( pbo - sizeof( count01T ) ) ;
            //{
            //if( tinP.pc Utility[ 0 ] )

            }
                tinP.pEther->traceF( tinP , T("    should match [correct,pbPad[offp]]: ")+TF2(GRABITbYTEiNITIALvALUE,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(pbPad[offp],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                LOGrAW5(                      "    should match [correct,pbPad[offp]]: " ,    GRABITbYTEiNITIALvALUE                                           , " " ,    pbPad[ offp ] , "\r\n" ) ;
            {
            for( countT offp = 0 ; offp < sizeof pbPad ; offp ++ )

            tinP.pEther->traceF( tinP , T("grabitC::ungrabF error: already ungrabbed; memory has been trashed if these numbers don't match [correct,*pbo,bitsDefault]: ")+TF2(GRABITbYTEiNITIALvALUE,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(*pbo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(bitsDefault,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            LOGrAW7(                  "\r\ngrabitC::ungrabF error: already ungrabbed; memory has been trashed if these numbers don't match [correct,*pbo,bitsDefault]: " ,    GRABITbYTEiNITIALvALUE                                           , " " ,    *pbo                                           , " " ,    bitsDefault                                           , "\r\n" ) ;

            tinP.pEther->traceF( tinP , T("grabitC::ungrabF error: already ungrabbed [tinP.cGrabitC_set,tinP.cGrabitC_reset]: ")+TF2(tinP.cGrabitC_set,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(tinP.cGrabitC_reset,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            LOGrAW5(                  "\r\ngrabitC::ungrabF error: already ungrabbed [tinP.cGrabitC_set,tinP.cGrabitC_reset]: " ,    tinP.cGrabitC_set                                           , " " ,    tinP.cGrabitC_reset , "\r\n" ) ;

            tinP.pEther->traceF( tinP , T("grabitC::ungrabF error: [offo,savebyte1,savebyte2]: ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(savebyte1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(savebyte2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            LOGrAW7(                  "\r\ngrabitC::ungrabF error: [offo,savebyte1,savebyte2]: " , offo , " " , savebyte1 , " " , savebyte2 , "\r\n" ) ;

            countT savebyte2 = *pbo ;

            LOGrAW( " ... awakening\r\n" ) ;
            THREADmODE1rESTORE
            thirdC::dosSleepRawIF( tinP , 4000 ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            //}
            //    LOGrAW( "pcTrace dump: END\r\nnapping for 4000 ms..." ) ;
            //    }
            //        }
            //            LOGrAWf( "" , processGlobal1I.pcTrace1[ offHe ] , "    " , processGlobal1I.pcTrace2[ offHe ] , "    " , processGlobal1I.pcTrace3[ offHe ] , "    " , processGlobal1I.pcTrace4[ offHe ] , "    " , processGlobal1I.pcTrace5[ offHe ] , "    " , processGlobal1I.pcTrace6[ offHe ] , "    " , processGlobal1I.pcTrace7[ offHe ] , "\r\n" ) ;
            //        {
            //        if( offPass || processGlobal1I.pcTrace3[ offHe ] == (countT)pbo && processGlobal1I.pcTrace4[ offHe ] == offo )
            //    {
            //    for( countT offHe = 0 ; offHe < processGlobal1I.cTrace ; offHe ++ )
            //    LOGrAW3( "pcTrace dump: BEGIN [offPass]: " , offPass , "\r\n" ) ;
            //{
            //for( countT offPass = 0 ; offPass <= 0 ; offPass ++ )

            *(countT*)0 = 1 ; //INTENTIONAL BLAMMO
        {
        //if( !( pcKey ? btrKeyedAM( pbo , *pcKey , offo , tinP.monitor.idThread ) : btrAM( pbo , offo ) ) )


        if( !bOk )
        }
            bOk = btrAM( pbo , offo ) ;
        {
        else
        }
                *(countT*)0 = 1 ; //INTENTIONAL BLAMMO
            if( !bOk )
            bOk = btrKeyedAM( pbo , *pcKey , offo , tinP.monitor.idThread ) ;
        {
        if( pcKey )
        ZE( boolT , bOk ) ;

        }
            countT foo = 2 ;
        {
        if( offTraceMe < sizeof processGlobal1I.pcTrace1 / sizeof processGlobal1I.pcTrace1[ 0 ] && !processGlobal1I.pcTrace2[ offTraceMe ] )
        countT savebyte1 = *pbo ;
        //U:: TO FIND A BUG

        }
            //processGlobal1I.pcTrace7[ offTraceMe ] = idiFileP ;
            //processGlobal1I.pcTrace6[ offTraceMe ] = idLineP ;
            processGlobal1I.pcTrace5[ offTraceMe ] = tinP.monitor.idThread ;
            processGlobal1I.pcTrace4[ offTraceMe ] = offo ;
            processGlobal1I.pcTrace3[ offTraceMe ] = (countT)pbo ;
            processGlobal1I.pcTrace2[ offTraceMe ] = *pbo ;
            processGlobal1I.pcTrace1[ offTraceMe ] = 2 ;            // 1:GRAB 2:UNGRAB
        {
        if( offTraceMe < sizeof processGlobal1I.pcTrace1 / sizeof processGlobal1I.pcTrace1[ 0 ] )
        countT offTraceMe = incv02AM( processGlobal1I.cTrace ) ;
        //U:: TO FIND A BUG

        byteT mask = (byteT)( 1 << offo ) ;
        //U:: TO FIND A BUG

        tinP.cGrabitC_reset ++ ; //U:: TO FIND A BUG

        //}
        //    emitWordsIF( tinP , ifcLINE , IDFILE , pcSuffix , 4 ) ;
        //    countT pcSuffix[] = { 3 , (countT)pbo , offo , 0x1110 } ; //0x1110: "resetting bit to 0"
        //{                                                                                           //U::TO FIND A BUG
        //if( tinP.pAdamGlobal1->idAdam == ifcIDaDAM_PISS )

        if( pcGOT && *pcGOT == tinP.osTid ) *pcGOT = 0 ;
    {
    else
    if( pcGOT && *pcGOT == tinP.osTid && pcGR && *pcGR ) -- *pcGR ;
 
    countT gotMe = tinP.osTid ; // DONE THIS WAY SO THAT GRAB LOGIC IS THE SAME FOR (1) NO RECURSION (2) RECURSION USING grabotC (3) RECURSION USING tinP

    ;
        : poff_cGrabberRecurse                                    
        ? (countT*)( (byteT*)this + (countT)poff_cGrabberRecurse )
    countT* pcGR = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES

    ;
        : poff_cGrabberOsTid                                    
        ? (countT*)( (byteT*)this + (countT)poff_cGrabberOsTid )
    countT* pcGOT = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES

    ;
        : poff_key
        ? (countT*)( (byteT*)this + (countT)poff_key )
    countT* pcKey = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES

    ;
        : poff_bo
        ? (byteT*)this + (countT)poff_bo
    byteT* pbo = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES

    tinP.cGrabitC_unregistered ++ ; //U:: TO FIND A BUG
    unregisterF( tinP ) ;

    _INoLD_

    SCOOP
{
/*1*/voidT grabitC::ungrabF( tinS& tinP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

