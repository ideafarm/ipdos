
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        etThread( tinP , psWrap ) ;
        }
            }
                swsWrapRefP.ungrabF( tinP ) ;
                }
                    }
                        }
                            swsWrapRefP << (countT)pc2WrapRef ; //W: WARNING: THESE DUPLICATE POINTERS MUST ONLY BE DELETED WHEN !cRef, I.E. ONLY WO TIME
                            cLeverPayloadP = swsWrapRefP.leverF( tinP , idf ) ;
                            //CONoUTrAW( "doWrapLocallyIfIF: pushed a wrap ref\r\n" ) ; //U::
                        {
                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        pc2WrapRef->c2 = cFlavors ; //cRef
                        pc2WrapRef->c1 = (countT)psWrap ; psWrap = 0 ;
                    {
                    if( pc2WrapRef )
                    etThread.newF( tinP , LF , pc2WrapRef ) ; ___( pc2WrapRef ) ;
                    ZE( count2S* , pc2WrapRef ) ;
                {
                else
                if( !cFlavors ) etThread( tinP , psWrap ) ;
                countT cFlavors = swsWrapRefP.cFlavorsF( tinP ) ;
                swsWrapRefP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                //}
                //    }
                //        }
                //            }
                //                etThread( tinP , psGift ) ;
                //                }
                //                    etThread( tinP , psSecret ) ;
                //                    }
                //                        etThread.delF( tinP , psttw ) ;
                //                        }
                //                            etThread.delF( tinP , psttw2 ) ;
                //                            }
                //                                etThread.delF( tinP , psttw3 ) ;
                //                                }
                //                                    etThread.strokeF( tinP , T("\f")+TF1(idMsg1Lath)+T(" ")+TF1(idMsg2Lath)+T(bM?" MEDIATED":" FINAL") ) ;
                //
                //                                    ( bM ? idMsg1Lath : idMsg2Lath ) = idMessage ;
                //                                    static countT idMsg2Lath ;
                //                                    static countT idMsg1Lath ;
                //
                //                                    countT bM = soulC::cFieldsIF( tinP , pbsToM ) ;
                //                                    byteT* pbsToM = psWrap->pbFieldF( tinP , idTypesToM , flagssToM , cbfsToM , ifcIDfIELDwRAP_TOmEDIATOR ) ;
                //                                    ZE( countT , cbfsToM ) ;
                //                                    ZE( flagsT , flagssToM ) ;
                //                                    ZE( countT , idTypesToM ) ;
                //                                {
                //                                countT idMessage = etThread.strDigitsToSCountF( tinP , psttw3 ) ;
                //                                etThread.strSubstringF( tinP , psttw3 , idf , idl , psttw2 ) ; ___( psttw3 ) ;
                //                                countT idl = idBlank - 1 ;
                //                                countT idf = 1 ;
                //                                ZE( strokeS* , psttw3 ) ;
                //                            {
                //                            if( idBlank )
                //                            countT idBlank = etThread.strIdF( tinP , T(" ") , psttw2 ) ;
                //                            etThread.strSubstringF( tinP , psttw2 , idf , idl , psttw ) ; ___( psttw2 ) ;
                //                            ZE( countT , idl ) ;
                //                            countT idf = idColon + 1 ;
                //                            ZE( strokeS* , psttw2 ) ;
                //                        {
                //                        if( idColon )
                //                        countT idColon = etThread.strIdF( tinP , T(":") , psttw ) ;
                //    
                //                        *psSecret >> psttw ; ___( psttw ) ;
                //                        ZE( strokeS* , psttw ) ;
                //                    {
                //                    if( psSecret )
                //                    etThread.cioGetSecretF( tinP , psSecret , *psGift ) ; ___( psSecret ) ;
                //                    ZE( soulC* , psSecret ) ;
                //
                //                    psGift->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                //                {
                //                if( psGift )
                //                etThread( tinP , psGift , TAG( TAGiDnULL ) ) ;
                //                ZE( soulC* , psGift ) ;
                //            {
                //            if( pbsGift )
                //
                //            byteT* pbsGift = soulC::pbFieldIF( tinP , idTypeGift , flagsGift , cbGift , ifcIDfIELDwRAP_GIFT , pbsWrapP ) ;
                //            ZE( countT , cbGift ) ;
                //            ZE( flagsT , flagsGift ) ;
                //            ZE( countT , idTypeGift ) ;
                //        {
                //        if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATED && pczChannel[ 2 ] == ifcIDaDAM_SECRETsERVICE && pczChannel[ 3 ] == ifcIDaDAM_CONSOLE && pczChannel[ 4 ] == ifcIDcHANNELfUNCTION_STROKEcONSOLE )
                //
                //        countT* pczChannel = (countT*)soulC::pbFieldIF( tinP , idTypeC , flagsC , cbC , ifcIDfIELDwRAP_CHANNEL , pbsWrapP ) ;
                //        ZE( countT , cbC ) ;
                //        ZE( flagsT , flagsC ) ;
                //        ZE( countT , idTypeC ) ;
                //    {
                //    if( pbidType && *(countT*)pbidType == ifcIDtYPEwRAP_GIFT )
                //
                //    byteT* pbidType = soulC::pbFieldIF( tinP , idTypeidType , flagsidType , cbidType , ifcIDfIELDwRAP_IDtYPE , pbsWrapP ) ;
                //    ZE( countT , cbidType ) ;
                //    ZE( flagsT , flagsidType ) ;
                //    ZE( countT , idTypeidType ) ;
                //{
                //THIS BLOCK WILL FAIL IF THE SECRET IS EMPTY OR NOT OF THE EXPECTED CONTENTS
                //THIS BLOCK IS JUST FOR DEBUGGING AND SHOULD BE COMMENTED OUT IN PRODUCTION

                }
                    }
                        }
                            }
                                etThread( tinP , psGift ) ;
                                }
                                    }
                                        if( idCmd == ifcIDcMDrEGISTERmEDIATOR_AMaLIVE && idAdam == ifcIDaDAM_SECRETsERVICE ) homeS::homeIF().cSecretServerRegistrationsSeen ++ ;
                            
                                        *psGift >> idAdam ;
                                        ZE( countT , idAdam ) ;
                                        *psGift >> idCmd ;
                                        ZE( countT , idCmd ) ;
                                    {
                                    if( *psGift == 2 )
                            
                                    psGift->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                                {
                                if( psGift )
                                etThread( tinP , psGift , TAG( TAGiDnULL ) ) ;
                                ZE( soulC* , psGift ) ;
                            {
                            if( pbsGift )

                            byteT* pbsGift = soulC::pbFieldIF( tinP , idTypeGift , flagsGift , cbGift , ifcIDfIELDwRAP_GIFT , pbsWrapP ) ;
                            ZE( countT , cbGift ) ;
                            ZE( flagsT , flagsGift ) ;
                            ZE( countT , idTypeGift ) ;
                        {
                        if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATORrEGISTRATION )
                
                        countT* pczChannel = (countT*)soulC::pbFieldIF( tinP , idTypeC , flagsC , cbC , ifcIDfIELDwRAP_CHANNEL , pbsWrapP ) ;
                        ZE( countT , cbC ) ;
                        ZE( flagsT , flagsC ) ;
                        ZE( countT , idTypeC ) ;
                    {
                    if( pbidType && *(countT*)pbidType == ifcIDtYPEwRAP_GIFT )
                
                    byteT* pbidType = soulC::pbFieldIF( tinP , idTypeidType , flagsidType , cbidType , ifcIDfIELDwRAP_IDtYPE , pbsWrapP ) ;
                    ZE( countT , cbidType ) ;
                    ZE( flagsT , flagsidType ) ;
                    ZE( countT , idTypeidType ) ;
                {
                //CONoUTrAW( "doWrapLocallyIfIF: bDo is true\r\n" ) ;
            {
            if( bDo )
        
            }
                }
                    etThread( tinP , psTo ) ;
                    }
                        }
                            }
                                }
                                    break ;
                                    bTargeted = bDo = 1 ;
                                {
                                if( idptTo == idptP )
                                idptTo << *psTo ;
                                idPortTimeC idptTo ;
                            {
                            while( (countT)*psTo )
                            bDo = 0 ;
                        {
                        if( *psTo )
            
                        psTo->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbsToOrToM , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                    {
                    if( psTo )
                    etThread( tinP , psTo , TAG( TAGiDnULL ) ) ;
                    ZE( soulC* , psTo ) ;
                {
                if( pbsToOrToM )
        
                byteT* pbsToOrToM = psWrap->pbFieldF( tinP , idTypesToOrToM , flagssToOrToM , cbfsToOrToM , bToMediators ? ifcIDfIELDwRAP_TOmEDIATOR : ifcIDfIELDwRAP_TO ) ;
                ZE( countT , cbfsToOrToM ) ;
                ZE( flagsT , flagssToOrToM ) ;
                ZE( countT , idTypesToOrToM ) ;

                //bDo WAS RESET HERE ; ON 2011.01.13 THE RESET LINE WAS MOVED SO THAT RESET ONLY OCCURS IF *psTo ; WAS NOT GETTING OWN WRAP ON A DUT WITH RELAY IN LONE HOME
        
                boolT bToMediators = !( F(flagsPut) & flCIOpUT_IGNOREmEDIATORlIST ) && !psWrap->bKidEmptyF( tinP , ifcIDfIELDwRAP_TOmEDIATOR ) ;
                flagsT flagsPut = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_FLAGS ) ;
            {
            if( !psWrap->bKidEmptyF( tinP , ifcIDfIELDwRAP_TO ) )
            boolT bDo = 1 ;
            ZE( boolT , bTargeted ) ; //U::

            psWrap->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbsWrapP , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
        {
        if( psWrap )
        etThread( tinP , psWrap , TAG( TAGiDnULL ) ) ;
        ZE( soulC* , psWrap ) ;
    {
    if( !idPhaseP || idPhaseP == 2 )

    }
        }
            }
                }
                    }
                        swsIdptMediatorP.ungrabF( tinP ) ;

                        }
                            }
                                break ;
                                }
                                    if( ids ) ppSws[ off ]->extractF( 0 , tinP ) ;
                                    ppSws[ off ]->sinkF( tinP , ids , (byteT*)&idptOriginP , flSTACKsINK_QUERY , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                    ZE( countT , ids ) ;
                                {
                                for( countT off = 0 ; off < 2 ; off ++ )

                                switchStackC* ppSws[] = { &swsIdptMediatorP , &swsIdptMediatorAltP } ;

                                THREADmODE1rESTORE
                                etThread.strokeF( tinP , T("m-: ")+TF1(idAdam)+T(" ")+T(idptOriginP)+T("\r\n") ) ;
                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                            {
                            case ifcIDcMDrEGISTERmEDIATOR_AMdEAD  :
                            }
                                break ;
                                swsIdptMediatorP.sinkF( tinP , countTC() , (byteT*)&idptOriginP , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;

                                //THREADmODE1rESTORE
                                //etThread.strokeF( tinP , T("m+: ")+TF1(idAdam)+T(" ")+T(idptOriginP)+T("\r\n") ) ;
                                //THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                            {
                            case ifcIDcMDrEGISTERmEDIATOR_AMaLIVE :
                        {
                        switch( idCmd )

                        idAdamMediatorP = idAdam ;
                        swsIdptMediatorP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                                
                        countT idAdam = *(countT*)pb_idAdam ;
                        countT idCmd  = *(countT*)pb_idCmd ;
                    {
                    if( idptOriginP && pb_idCmd && pb_idAdam )
    
                    byteT* pb_idAdam = soulC::pbFieldIF( tinP , idType2 , flags2 , cb2 , 2 , pbsGift ) ;
                    ZE( countT , cb2 ) ;
                    ZE( flagsT , flags2 ) ;
                    ZE( countT , idType2 ) ;
    
                    byteT* pb_idCmd = soulC::pbFieldIF( tinP , idType1 , flags1 , cb1 , 1 , pbsGift ) ;
                    ZE( countT , cb1 ) ;
                    ZE( flagsT , flags1 ) ;
                    ZE( countT , idType1 ) ;
    
                    byteT* pbsGift = soulC::pbFieldIF( tinP , idTypeGift , flagsGift , cbGift , ifcIDfIELDwRAP_GIFT , pbsWrapP ) ;
                    ZE( countT , cbGift ) ;
                    ZE( flagsT , flagsGift ) ;
                    ZE( countT , idTypeGift ) ;
                {
                if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATORrEGISTRATION )
                                
                countT* pczChannel = (countT*)soulC::pbFieldIF( tinP , idTypec , flagsc , cbc , ifcIDfIELDwRAP_CHANNEL , pbsWrapP ) ;
                ZE( countT , cbc ) ;
                ZE( flagsT , flagsc ) ;
                ZE( countT , idTypec ) ;
            {
            if( soulC::cFieldsIF( tinP , pbsWrapP ) >= ifcIDfIELDwRAP_GIFT && soulC::cFieldIF( tinP , ifcIDfIELDwRAP_IDtYPE , pbsWrapP ) == ifcIDtYPEwRAP_GIFT )
    
            }
                }
                    }
                        }
                            off += 4 ;
            
                            }
                                //}
                                //    THREADmODE1rESTORE
                                //    etThread.strokeF( tinP , T("patched to ")+TF1(*(countT*)pb_idPort)+T(*(nicNameC*)pb_nn)+T("\r\n") ) ; //U::
                                //    etThread.strokeF( tinP , T("patched from ")+T(idptm)+T("\r\n") ) ; //U::
                                //    etThread.strokeF( tinP , T("top plate is ")+T(idptms)+T("\r\n") ) ; //U::
                                //    idPortTimeC& idptms = *(idPortTimeC*)&swsIdptMediatorP[ 1 ] ;
                                //    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                //{
    
                                *(countT*)pb_time2  = time.time2 ;
                                *(countT*)pb_time1  = time.time1 ;
                                const timeS& time   = idptm ;
                                *(nicNameC*)pb_nn   = (nicNameC&)idptm ;
                                *(countT*)pb_idPort = idptm ;
        
                                swsIdptMediatorP.ungrabF( tinP ) ;
                                swsIdptMediatorAltP.ungrabF( tinP ) ;
    
                                //THREADmODE1rESTORE
                                //etThread.strokeF( tinP , T("patched null mediator to ")+TF1(idAdamMediatorP)+T(" mediator\r\n")+T(idptm)+T("\r\n") ) ; //U::
                                //THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                                }
                                    LOGrAW7( bAlt ? "could not assign a mediator because -->" : "could not assign a mediator because <--" , swsIdptMediatorP , " " , swsIdptMediatorAltP , " cells of " , idAdamMediator , " are registered\r\n" ) ;
                                    CONoUTrAW7( bAlt ? "could not assign a mediator because -->" : "could not assign a mediator because <--" , swsIdptMediatorP , " " , swsIdptMediatorAltP , " cells of " , idAdamMediator , " are registered\r\n" ) ;
                                {
                                if( !idptm )
                                swsm.randomF( tinP , pb_idptm ) ;
                                byteT* pb_idptm = (byteT*)&idptm ;
                                idPortTimeC idptm ;
                                switchStackC& swsm = bAlt ? swsIdptMediatorAltP : swsIdptMediatorP ;

                                ;
                                        : 1
                                        ? 0
                                    : swsIdptMediatorP
                                    ? ( tinP.ranUni % TUCK ) / TUCK * 2
                                const boolT bAlt = swsIdptMediatorP && swsIdptMediatorAltP
                                idAdamMediatorP = idAdamMediator ;
    
                                swsIdptMediatorAltP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                swsIdptMediatorP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            {
                            else if( !*(countT*)pb_idPort )
                            if( !pb_time2 ) break ;
        
                            byteT* pb_time2 = soulC::pbFieldIF( tinP , idType_time2 , flags_time2 , cb_time2 , off + 4 , pbsToM ) ;
                            ZE( countT , cb_time2 ) ;
                            ZE( flagsT , flags_time2 ) ;
                            ZE( countT , idType_time2 ) ;
        
                            byteT* pb_time1 = soulC::pbFieldIF( tinP , idType_time1 , flags_time1 , cb_time1 , off + 3 , pbsToM ) ;
                            ZE( countT , cb_time1 ) ;
                            ZE( flagsT , flags_time1 ) ;
                            ZE( countT , idType_time1 ) ;
        
                            byteT* pb_nn = soulC::pbFieldIF( tinP , idType_nn , flags_nn , cb_nn , off + 2 , pbsToM ) ;
                            ZE( countT , cb_nn ) ;
                            ZE( flagsT , flags_nn ) ;
                            ZE( countT , idType_nn ) ;
        
                            byteT* pb_idPort = soulC::pbFieldIF( tinP , idType_idPort , flags_idPort , cb_idPort , off + 1 , pbsToM ) ;
                            ZE( countT , cb_idPort ) ;
                            ZE( flagsT , flags_idPort ) ;
                            ZE( countT , idType_idPort ) ;
                        {
                        for(;;)
                        ZE( countT , off ) ;
                        if( idPortTimeC::cFieldsF( tinP ) - 4 ) { BLAMMO ; }
    
                        countT idAdamMediator = pczChannel[ 2 ] ;
                    {
                    if( pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATED && pczChannel[ 2 ] )
                {
                if( pczChannel && pbsToM )
        
                byteT* pbsToM = soulC::pbFieldIF( tinP , idTypesToM , flagssToM , cbsToM , ifcIDfIELDwRAP_TOmEDIATOR , pbsWrapP ) ;
                ZE( countT , cbsToM ) ;
                ZE( flagsT , flagssToM ) ;
                ZE( countT , idTypesToM ) ;

                countT* pczChannel = (countT*)soulC::pbFieldIF( tinP , idTypeC , flagsC , cbC , ifcIDfIELDwRAP_CHANNEL , pbsWrapP ) ;
                ZE( countT , cbC ) ;
                ZE( flagsT , flagsC ) ;
                ZE( countT , idTypeC ) ;
            {
            if( pbidType && *(countT*)pbidType == ifcIDtYPEwRAP_GIFT )
        
            byteT* pbidType = soulC::pbFieldIF( tinP , idTypeidType , flagsidType , cbidType , ifcIDfIELDwRAP_IDtYPE , pbsWrapP ) ;
            ZE( countT , cbidType ) ;
            ZE( flagsT , flagsidType ) ;
            ZE( countT , idTypeidType ) ;
        {
        if( pnRoot && *pnRoot == idptP )
        UNGRABrELAYlISTS
        idPortTimeC* pnRoot = stIdptOpenP ? (idPortTimeC*)&stIdptOpenP[ 1 ] : 0 ;
        GRABrELAYlISTS
    {
    if( !idPhaseP || idPhaseP == 1 )

    RELAYiNFOf
{
/*1*/voidT relayC::doWrapLocallyIfIF( tinS& tinP , etherC& etThread , RELAYiNFOpARMS , const byteT* const pbsWrapP , const idPortTimeC& idptOriginP , const countT idPhaseP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

