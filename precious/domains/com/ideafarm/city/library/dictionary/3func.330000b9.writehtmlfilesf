
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( psttOldCopyrightP ) ;
    ether.delF( tinP , psttLikeShort ) ;
    ether.delF( tinP , psttLikeLocal ) ;

    }
        ether.delF( tinP , pba ) ;
        ether.boxPutF( tinP , psttLikeLocal , pba , cba , cOpenTriesP ) ;

        }
            }
                ether.delF( tinP , pc3b ) ;
                }
                    ether.delF( tinP , postFinal ) ;
                    }
                        off += costFinal ;
                        ether.memCopyF( tinP , pba + off , postFinal , costFinal ) ;
                    {
                    if( costFinal )

                    off += sizeof( countT ) ;
                    ether.memCopyF( tinP , pba + off , (byteT*)&costFinal , sizeof costFinal ) ;

                    ether.delF( tinP , psttName ) ;
                    off += cbn ;
                    ether.memCopyF( tinP , pba + off , (byteT*)psttName , cbn ) ;
                    countT cbn = sizeof( strokeS ) * ( CSpREFIX + psttName->idAdam ) ;

                    osTextT* postFinal  = (osTextT*)pc3b->c3 ;
                    countT   costFinal  =           pc3b->c2 ;
                    strokeS* psttName   = (strokeS*)pc3b->c1 ;
                {
                if( pc3b && pc3b->c1 && pc3b->c3 )
                stOneFile >> pc3b ;
                ZE( count3S* , pc3b ) ;
            {
            while( stOneFile )
            countT off = sizeof( countT ) ;
            *(countT*)pba = ifcIDfILEtYPE_PACKED ;
        {
        if( pba )

        ether.newF( tinP , LF , pba , cba ) ; ___( pba ) ;
        ZE( byteT* , pba ) ;

        }
            while( ~handle ) ;
            }
                else                               __1
                if( pc3b && pc3b->c1 && pc3b->c3 ) cba += sizeof( strokeS ) * ( CSpREFIX + ((strokeS*)pc3b->c1)->idAdam ) + sizeof( countT ) + pc3b->c2 ;
                count3S* pc3b = (count3S*)stOneFile.downF( tinP , handle ) ;
            {
            do
            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        countT cba = sizeof( countT ) ;
    {
    if( bOneFileP && stOneFile )

    __( STOP ) ;
    }
        }
            else                                          { pHtmlDownFrom = pHtml ; pHtml = pHtml->pD ; }
            else if( pHtml->pL )                          { pHtmlDownFrom = pHtml ; pHtml = pHtml->pL ; }
            if( pHtml->pR && pHtml->pR != pHtmlDownFrom ) { fDown = 0 ;             pHtml = pHtml->pR ; }    
        {
        else
        }
            }
                else            pHtml = pHtml->pD ;
                if( pHtml->pL ) pHtml = pHtml->pL ;
                pHtmlDownFrom = pHtml ;
                fDown = 1 ;
            {
            else
            else if( pHtml->pR ) pHtml = pHtml->pR ;
                 if( pHtml->pU ) pHtml = pHtml->pU ;
        {
        if( !fDown )

        }
            }
                }
                    }
                        stOneFile << pc3b ;
                        pc3b->c3 = (countT)pbFinal ;
                        pc3b->c2 = cbaFinal ;
                        pc3b->c1 = (countT)psttName ;
                        ether.strMakeF( tinP , psttName , tFile ) ; ___( psttName ) ;
                        ZE( strokeS* , psttName ) ;
                    {
                    if( pc3b )
                    ether.newF( tinP , LF , pc3b ) ; ___( pc3b ) ;
                    ZE( count3S* , pc3b ) ;
                {
                else
                }
                    ether.delF( tinP , pbFinal ) ;
                    ether.boxPutF( tinP , tFile , pbFinal , cbaFinal , cOpenTriesP ) ;
                {
                if( !bOneFileP )
                textC tFile = T(psttLikeLocal) + ( pHtml->psttName->idAdam ? T(".")+T(pHtml->psttName) : T("") ) + ( bOneFileP ? T("") : T(".0.html") ) ;

                }
                    __( offo - cbaFinal ) ;
                    *(countT*)( pbFinal + offo ) =  tBody.csF( tinP ) ; offo += sizeof( countT ) ; ether.memCopyF( tinP , pbFinal + offo , tBody  ,  tBody.csF( tinP ) ) ; offo +=  tBody.csF( tinP ) ; pbFinal[ offo ++ ] = 0 ;
                    *(countT*)( pbFinal + offo ) = tTitle.csF( tinP ) ; offo += sizeof( countT ) ; ether.memCopyF( tinP , pbFinal + offo , tTitle , tTitle.csF( tinP ) ) ; offo += tTitle.csF( tinP ) ; pbFinal[ offo ++ ] = 0 ;
                    *(countT*)( pbFinal + offo ) =   tDad.csF( tinP ) ; offo += sizeof( countT ) ; ether.memCopyF( tinP , pbFinal + offo , tDad   ,   tDad.csF( tinP ) ) ; offo +=   tDad.csF( tinP ) ; pbFinal[ offo ++ ] = 0 ;
                    ZE( countT , offo ) ;
                {
                if( pbFinal )
                ether.newF( tinP , LF , pbFinal , cbaFinal ) ; ___( pbFinal ) ;
                countT cbaFinal = 3 * ( sizeof( countT ) + 1 ) + tDad.csF( tinP ) + tTitle.csF( tinP ) + tBody.csF( tinP ) ;
                ZE( byteT* , pbFinal ) ;

                // postBody
                // costBody
                // postTitle
                // costTitle
                // postDad
                // costDad
                //IMAGE LAYOUT

                ether.delF( tinP , psttDad ) ;
                ether.delF( tinP , psttStack ) ;
                TN( tBody , "" ) ; tBody = T(psttStack) ;
                TN( tTitle , pHtml->postIdea ) ;
                TN( tDad  , "" ) ; tDad = T(psttDad) ;

                //OLD: ether.delF( tinP , psttFinal ) ;
                //OLD: countT costFinal = ether.strMakeF( tinP , postFinal , psttFinal ) ; ___( postFinal ) ;
                //OLD: ZE( osTextT* , postFinal ) ;

                //OLD: }
                //OLD:     ether.delF( tinP , psttd ) ;
                //OLD:     ether.strSubstringF( tinP , psttFinal , idf , idl , psttd ) ; ___( psttFinal ) ;
                //OLD:     ZE( countT , idl ) ;
                //OLD:     countT idf = ether.strIdF( tinP , T("<!--") , psttd ) ;
                //OLD:     strokeS* psttd = psttFinal ; psttFinal = 0 ;
                //OLD:     strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                //OLD: {
                //OLD: if( !bOneFileP )

                //OLD: }
                //OLD:     ether.strMakeF( tinP , psttFinal , TEXThTTPhEADER(tHtml.csF(tinP)) + tHtml ) ; ___( psttFinal ) ;
                //OLD:     TN( tHtml , "" ) ; tHtml = TEXThTMLhEADER( tTitle ) + TEXThTMLbODYpREFIX + tBody + TEXThTMLbODYsUFFIX ;
                //OLD: 
                //OLD:     TN( tTitle , pHtml->postIdea ) ;
                //OLD:     TN( tBody , "" ) ; tBody = T(psttStack) ;
                //OLD: {
                //OLD: ZE( strokeS* , psttFinal ) ;

                ether.strReverseF( tinP , psttStack , 0 , T("\r\n") ) ; ___( psttStack ) ;
                if( !pHtml->psttName->idAdam ) { ether.strMakeF( tinP , pHtml->postIdea , psttTitleP ) ; ___( pHtml->postIdea ) ; }

                }
                    }
                        ether.strSubstringF( tinP , psttDad , idf , idd , pHtml->psttName ) ; ___( psttDad ) ;
                        countT idf = 1 ;
                        idd -- ;
                        __( idd == 1 ) ;
                    {
                    if( idd )
                    countT idd = ether.strIdF( tinP , countTC( 1 ) , sttq , S1C('.') , pHtml->psttName , 0 , - 1 ) ;

                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                {
                if( pHtml->psttName && pHtml->psttName->idAdam )
                ZE( strokeS* , psttDad ) ;

                }
                    pHtmlKid = pHtmlKid->pR ;
                    }
                        else                     { ether.strFuseF( tinP , psttStack ,                                                                                       T(pHtmlKid->postIdea)           ) ; ___( psttStack ) ; }
                        if( pHtmlKid->psttName ) { ether.strFuseF( tinP , psttStack , T("<A HREF=\"")+T(psttLikeShort)+T(".")+T(pHtmlKid->psttName)+T(/*".html"*/ ".0.html" "\">")+T(pHtmlKid->postIdea)+T("</A>") ) ; ___( psttStack ) ; }
                        //if( pHtmlKid->psttName ) { ether.strFuseF( tinP , psttStack , T("<A HREF=\"http://")+T(psttLikeShort)+T(".")+T(pHtmlKid->psttName)+T(/*".html"*/ ".0" "\">")+T(pHtmlKid->postIdea)+T("</A>") ) ; ___( psttStack ) ; }
                        else              ether.strFuseF( tinP , psttStack , T("\r\n") ) ; ___( psttStack ) ;
                        if( !fPrevious2 ) fPrevious2 = 1 ;
                    {
                    if( pHtmlKid->postIdea )
                {
                while( !ether && pHtmlKid )
                __Z( pHtmlKid ) ;
                pHtmlKid = pHtml->pU ;
                ZE( htmlS* , pHtmlKid ) ;
                ether.strMakeF( tinP , psttStack , T("") , cSonsP * 0x1000 ) ;
                ZE( strokeS* , psttStack ) ;
                ZE( boolT , fPrevious2 ) ;
                ZE( countT , idSon ) ;
                //etherC::ifcSayIF( T("writeHtmlFilesF/file/\"")+T(pHtml->psttName)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
            {
            if( pHtml->psttName )
        {
        if( !fDown )
    {
    while( !STOP && pHtml )
    stackC stOneFile( tinP , ether , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_count3S  ) ;
    pHtml = pHtmlRootP ;
    ZE( boolT , fDown ) ;
    ZE( htmlS* , pHtmlDownFrom ) ;
    ZE( htmlS* , pHtml ) ;
    ZE( countT , idLathI ) ;
    //etherC::ifcSayIF( T("writeHtmlFilesF/about to write each html file") , flSAY_APPEND | flSAY_LOG ) ;
    TN( tLog , "///d/ideafarm.log.html" ) ;

    ether.strReplaceF( tinP , psttLikeShort , psttLikeP , T("www.ideafarm.com///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/") , T("") ) ;
    //ether.strReplaceF( tinP , psttLikeShort , psttLikeP , T("www.ideafarm.com///ideafarm/ephemeral/domains/com/ideafarm/gen/lake/") , T("www.ideafarm.com/") ) ;
    ZE( strokeS* , psttLikeShort ) ;

    }
        ether.strSubstringF( tinP , psttLikeLocal , ids , idl , psttLikeP ) ; ___( psttLikeLocal ) ;
        ZE( countT , idl ) ;
        __( ids == psttLikeP->idAdam ) ;
        __Z( ids ) ;
        countT ids = ether.strIdF( tinP , S1C('/') , psttLikeP ) ;
    {
    else
    if( psttLikeLocalP ) { ether.strMakeF( tinP , psttLikeLocal , psttLikeLocalP ) ; ___( psttLikeLocal ) ; }
    ZE( strokeS* , psttLikeLocal ) ;

    if( ether ) return ;
    __Z( pHtmlRootP ) ;
    __Z( psttTitleP ) ;
    __Z( psttLikeP ) ;
    if( ether ) return ;
{
/*1*/voidT writeHtmlFilesF( tinS& tinP , etherC& ether , const boolT bOneFileP , const strokeS* const psttLikeLocalP , const strokeS* const psttLikeP , const strokeS* const psttTitleP , const strokeS* const psttOldCopyrightP , htmlS*& pHtmlRootP , const countT cSonsP , countT cOpenTriesP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

