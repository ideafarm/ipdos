
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tinP , T("ok") ) ;

}
    }
        ++ s ; etThread.osSleepF( tinP , TOCK ) ;
    {
    while( ws.cWorkers )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    etThread.traceF( tinP , T("waiting for worker") ) ;

    }
        //etThread.traceF( tinP , T("napped") ) ;
        ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        //etThread.traceF( tinP , T("napping") ) ;

        }
            ether.ifcHireF( tinP , T("ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE1") , ifcIDaDAM_ACCESSeVENTS2bOOKtOGETHER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; // flHIRE_DISPLAYaUTO CAN BE COMMENTED OUT TO AVOID WDW FOR ROOT CLOUD INSTANCE WHICH IS USUALLY NOT INTERESTING
            ether.traceF( tinP , T("hiring book together") ) ;          // THIS IS DONE NOW SO THAT I AM NOT RACING WITH BOOKtOGETHER WHILE I AM IGNORING EXISTING BOOKtOGETHER EVENTS
            bIgnoreInput = 0 ;
        {
        if( bIgnoreInput )

        if( bQuit ) break ;

        THREADmODE1rESTORE
        }
            }
                }
                    bDestroyOutputBooks = 0 ;
                    ws.destroyBooksF( tinP ) ;

                    }
                        ++ s ; etThread.osSleepF( tinP , TOCK ) ;
                        etThread.traceF( tinP , T("waiting to destroy books [cPending]:    ")+TF2(ws.st_pPageEvent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    while( ws.st_pPageEvent )
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                {
                else
                }
                    }
                        }
                            ++ s ; etThread.osSleepF( tinP , TOCK >> 3 ) ;
                            etThread.traceF( tinP , T("waiting for queue to shrink [cPending]:    ")+TF2(ws.st_pPageEvent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        while( ws.st_pPageEvent > TUCK )
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    if( ws.st_pPageEvent > ( TUCK << 1 ) )                // THE QUEUE LENGTH MUST BE SMALL SO THAT IT IS IMPOSSIBLE FOR A QUEUED ITEM TO BE IN A BOOK OTHER THAN THE BOOK IMMEDIATELY PRECEDING THE BOOK BEING READ, ASSUMING THAT I ONLY KEEP WO INACTIVE BOOK

                    //if( bPrefix ) bQuit2 = 1 ; //U:: TO FIND A BUG

                    bPrefix = !bPrefix ;

                    else          pbi = 0 ;
                    if( bDelete ) PUSE( tinP , *(byteT**)&pbi ) ;

                    ;
                        : sizeof( countT )
                        ? *(countT*)pbi
                    cbi = bPrefix

                    }
                        }
                            }
                                bDestroyOutputBooks = 1 ;
                                etThread.traceF( tinP , T("pausing to delete output books [ws.idIn]:    ")+TF2(ws.idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            if( !( ws.idIn % ( TOCK << 0 ) ) || ws.swBooksByIdJots.cFlavorsF( tinP ) > TUCK )

                            if( ws.idIn < TUCK || !( ws.idIn % TUCK ) ) etThread.traceF( tinP , T("[ws.idIn,cOutputFlavors]:    ")+TF2(ws.idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ws.swBooksByIdJots.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            ++ ws.idIn ;
                            ws.st_pPageEvent << *(countT*)&pPageEvent ;
                        {
                        else
                        }
                            DEL( pPageEvent ) ; // I AM INITIALIZING AND ASSUMING THAT ALL EXISTING BOOKED EVENTS HAVE ALREADY BEEN "PAGE BOOKED"
                        {
                        if( bIgnoreInput )

                        __( (countT)*pPageEvent - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                        }
                            break ;
                            hRead = hReadSave ;
                            cbi = cbiSave ;
                        {
                        if( !(const byteT*)*pPageEvent )        //SHOULD BE IMPOSSIBLE SINCE "ALL OR NONE" USED FOR WRITING BOOKTOGETHER AND I'VE ALREADY READ THE PREFIX

                        THREADmODE3rESTORE
                        bksAccessEvents.readF( tinP , *pPageEvent , hRead , flBOOKScrEAD_null ) ;
                        pPageEvent = new( 0 , tinP , LF ) pageC( tinP , bksAccessEvents , cbi ) ; ___( pPageEvent ) ;
                        THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                        ZE( pageC* , pPageEvent ) ;
                    {
                    else
                    }
                        __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                        }
                            break ;
                            hRead = hReadSave ;
                            cbi = cbiSave ;
                        {
                        if( !pbi )
                        bDelete = bksAccessEvents.readF( tinP , pbi , cbi , hRead , flBOOKScrEAD_null , &bQuit ) ;
                    {
                    if( bPrefix )
                    ZE( boolT , bDelete ) ;

                    HANDLEaPPnOTEScOUNTcLASS ch = hRead ;

                    handleC hReadSave = hRead ;
                    countT cbiSave = cbi ;
                {
                if( !bDestroyOutputBooks )
            {
            while( !bQuit && !bQuit2 && !POOP )
            boolT bPrefix = 1 ;
            countT cbi = sizeof( countT ) ;
            ZE( const byteT* , pbi ) ;

            // *****************************************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
            // ********                    *************************************************************************************************************************************************************************************************************************
            // ********  EAT BOOK ENTRIES  *************************************************************************************************************************************************************************************************************************
            // ********                    *************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
        {
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    {
    while( !bQuit && !bQuit2 && !POOP )
    boolT bIgnoreInput = 1 ;
    ZE( boolT , bDestroyOutputBooks ) ;
    ZE( boolT , bQuit2 ) ;
    handleC hRead( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
    etThread.traceF( tinP , T("ACCESSeVENTS3bOOKfOReACHuRI / enering loop to read events") ) ;

    }
        etThread.osThreadF( tinP , countTC() , tmWorkerF , 0 , flTHREADlAUNCH_INHERITjOTrEGISTRATIONS , TOCK , (countT)&ws , (countT)&bksAccessEvents ) ;
        inc02AM( ws.cWorkers ) ;
    {
    while( cDo -- )
    countT cDo = 0x40 ;
    etThread.traceF( tinP , T("ACCESSeVENTS3bOOKfOReACHuRI / launching workers") ) ;

    workS ws( tinP , etThread ) ;
    etThread.traceF( tinP , T("ACCESSeVENTS3bOOKfOReACHuRI / ct ws") ) ;

    TN( tb4 , "    " ) ;
    booksC bksAccessEvents( tinP , TAG( TAGiDnULL ) , "bksAccessEvents.1.raw" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_null , 0 , 1 , 0 , 0 , 0 , 0 , &bQuit ) ;
    const boolT& bQuit = *(const boolT*)&(const countT&)ether ;
    etThread.traceF( tinP , T("ACCESSeVENTS3bOOKfOReACHuRI / ct bksAccessEvents") ) ;
{

TODO

DONE( tmWorkerF )
}
    dec02AM( wsP.cWorkers ) ;
    }
        }
            THREADmODE1rESTORE
            }
                wsP.st_pPageEvent.ungrabF( tinP ) ;
                }
                    wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    }
                        THREADmODE3rESTORE
                        DEL( pPageEvent ) ;
                        THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )

                        }
                            etThread.delF( tinP , psttBrowser ) ;
                            etThread.delF( tinP , psttProtocol ) ;
                            etThread.delF( tinP , psttQuery ) ;
                            etThread.delF( tinP , psttUri ) ;
                            etThread.delF( tinP , psttContainer ) ;
                            etThread.delF( tinP , psttLogBucket ) ;
                            etThread.delF( tinP , psttMethod ) ;

                            }
                                wsP.swBooksByIdJots.ungrabF( tinP ) ;

                                booksOut.writeF( tinP , (byteT*)&cbo , sizeof cbo , WS( sBookEntryOut ) , flBOOKScwRITE_ALLOWoDDlENGTH | flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ELSEfILLtOeND , 0 ) ;
                                countT cbo = sBookEntryOut.cbF( tinP ) ;

                                booksC& booksOut = *(booksC*)&(countT&)wsP.swBooksByIdJots ;

                                }
                                    }
                                        booksC* pBooks = new( 0 , tinP , pba , sizeof( booksC ) ) booksC( tinP , TAG( TAGiDnULL ) , tBooksOut , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER , TOCK ) ; ___( pBooks ) ;

                                        TN( tBooksOut , "" ) ; tBooksOut = T("bksPageAccessEvents.")+TF3(pcIdJots[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+tDot+TF3(pcIdJots[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ;
                                    {
                                    if( !POOP )

                                    __Z( pba ) ;
                                    byteT* pba = (byteT*)&(countT&)wsP.swBooksByIdJots ;
                                {
                                if( !wsP.swBooksByIdJots.idSlotOfLeverF( tinP , (countT)pcIdJots ) )
                                wsP.pcIdJots = pcIdJots ;
                                wsP.swBooksByIdJots.grabF( tinP , TAG( TAGiDnULL ) ) ;

                                countT pcIdJots[] = { pidj[ 3 ] , pidj[ 2 ] } ;     // URI , CONTAINER:    URI IS WOTH BECAUSE IT VARIES MORE SO WILL MATCH LESS (OPTIMIZE SWITCH LEVER FOR SPEED: MISMATCH WILL BE DETECTED SOONER AS COMPARE LEFT TO RIGHT)

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                        *********************************************************************************************************************************************************************************************************************
                                // ********  BOOK THE EVENT soulC  *********************************************************************************************************************************************************************************************************************
                                // ********                        *********************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************


                                sBookEntryOut << pidj[ 6 ] ;                        // BROWSER
                                sBookEntryOut << cbRequest ;                        // CB REQUEST BODY (OR REPLY BODY?)
                                sBookEntryOut << code ;                             // HTTP RESPONSE CODE
                                sBookEntryOut << pidj[ 5 ] ;                        // PROTOCOL
                                sBookEntryOut << pidj[ 4 ] ;                        // QUERY
                                sBookEntryOut << pidj[ 1 ] ;                        // BUCKET
                                sBookEntryOut << pidj[ 0 ] ;                        // METHOD
                                sBookEntryOut << nnHe ;
                                sBookEntryOut << *(countT*)&timeW2 ;
                                sBookEntryOut << timeW1 ;
                                sBookEntryOut << (countT)1 ;
                                sBookEntryOut << finger ;       finger = 0 ;

                                soulC sBookEntryOut( tinP , TAG( TAGiDnULL ) ) ;

                                putNegAM( finger, FINGERnEG_ACCESSeVENTiDjOTfORmOstsTRINGS ) ;
                                ZE( countT , finger ) ;

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // ********  CONSTRUCT EVENT soulC  ********************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************

                                }
                                    if( !pidj[ offi ] ) { BLAMMO ; }

                                    ppjhs[ offi ]->ungrabF( tinP ) ;
                                    //if( offi == 3 ) etThread.traceF( tinP , T("serialized processing ---- for offi==3 [hash]:    ")+TF2(ph[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    }
                                        etThread.traceF( tinP , T("stored  [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[ offi ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                        }
                                            wsP.sws_idJotUriByHash.ungrabF( tinP ) ;
                                            wsP.sws_idJotUriByHash.sinkF( tinP , countTC() , pidj[ offi ] , flSTACKsINK_UNIQUE ) ;
                                            wsP.leverHashUri = hashUri ;
                                            wsP.sws_idJotUriByHash.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                        {
                                        else if( offi == 3 )
                                        }
                                            wsP.sws_idJotContainerByHash.ungrabF( tinP ) ;
                                            wsP.sws_idJotContainerByHash.sinkF( tinP , countTC() , pidj[ offi ] , flSTACKsINK_UNIQUE ) ;
                                            wsP.leverHashContainer = hashContainer ;
                                            wsP.sws_idJotContainerByHash.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                        {
                                        if( offi == 2 )
                                        pidj[ offi ] = (countT)pbEncoded ;
                                        etThread.strEncodeF( tinP , pbEncoded , psttzv , 0 , sizeof( countT ) , (const byteT*)&ph[ offi ] ) ; ___( pbEncoded ) ;
                                        ZEJ( byteT* , pbEncoded , *ppjhs[ offi ] ) ;
                                        //etThread.traceF( tinP , T("storing [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[ offi ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                        _IO_
                                    {
                                    if( !pidj[ offi ] )

                                    }
                                        }
                                            break ;
                                            }
                                                }
                                                    etThread.delF( tinP , psttHe ) ;
                                                    }
                                                        //etThread.traceF( tinP , T("found   [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                                        pidj[ offi ] = ppjhs[ offi ]->idLathReadF() ;
                                                    {
                                                    if( !etThread.strCompareF( tinP , psttzv , psttHe ) )
                                                    //etThread.traceF( tinP , T("comparing [offi,psttzv,psttHe]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv)+tb4+T(psttHe) ) ;
                                                    etThread.strDecodeF( tinP , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                                                    ZE( strokeS* , psttHe ) ;
                                                {
                                                else if( *(countT*)pbEncodedHe == ph[ offi ] )
                                                if( !pbEncodedHe || !cbEncodedHe ) break ;

                                                countT       cbEncodedHe = pageHe ;
                                                const byteT* pbEncodedHe = pageHe ;

                                                pageC pageHe = *ppjhs[ offi ] ;
                                                //CS:PSEUDOdUPLICATE this this
                                            {
                                            while( !pidj[ offi ] )
                                            ppjhs[ offi ]->resetLathReadF() ;
                                            _IO_
                                        {
                                        default :   // SEARCH JOT SEQUENTIALLY
                                        }
                                            break ;

                                            wsP.sws_idJotUriByHash.ungrabF( tinP ) ;

                                            }
                                                while( !etThread && ~hWalk ) ;
                                                }
                                                    }
                                                        etThread.delF( tinP , psttHe ) ;
                                                        }
                                                            break ;
                                                            etThread.delF( tinP , psttHe ) ;
                                                            pidj[ offi ] = idJot ;
                                                        {
                                                        if( !etThread.strCompareF( tinP , psttzv , psttHe ) )
                                                        etThread.strDecodeF( tinP , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                                                        ZE( strokeS* , psttHe ) ;

                                                        }
                                                            continue ;
                                                            etThread.traceF( tinP , T("error: unexpected hash [offi,idJot,actualHash,expectedHash]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(*(countT*)pbEncodedHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ph[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        {
                                                        if( *(countT*)pbEncodedHe != ph[ offi ] )
                                                    {
                                                    if( pbEncodedHe && cbEncodedHe )

                                                    countT       cbEncodedHe = pageHe ;
                                                    const byteT* pbEncodedHe = pageHe ;

                                                    pageC pageHe = jotUse[ idJot ] ;
                                                    //CS:PSEUDOdUPLICATE this this

                                                    jotC& jotUse = *ppjhs[ offi ] ;

                                                    countT idJot = wsP.sws_idJotUriByHash.downF( tinP , hWalk ) ;
                                                {
                                                do
                                                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            {
                                            if( wsP.sws_idJotUriByHash )

                                            wsP.leverHashUri = hashUri ;
                                            wsP.sws_idJotUriByHash.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                        {
                                        case 3 :    // LOOK UP idJotUri
                                        }
                                            break ;

                                            wsP.sws_idJotContainerByHash.ungrabF( tinP ) ;

                                            }
                                                while( !etThread && ~hWalk ) ;
                                                }
                                                    }
                                                        etThread.delF( tinP , psttHe ) ;
                                                        }
                                                            break ;
                                                            etThread.delF( tinP , psttHe ) ;
                                                            pidj[ offi ] = idJot ;
                                                        {
                                                        if( !etThread.strCompareF( tinP , psttzv , psttHe ) )
                                                        etThread.strDecodeF( tinP , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                                                        ZE( strokeS* , psttHe ) ;

                                                        }
                                                            continue ;
                                                            etThread.traceF( tinP , T("error: unexpected hash [offi,idJot,actualHash,expectedHash]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(*(countT*)pbEncodedHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ph[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        {
                                                        if( *(countT*)pbEncodedHe != ph[ offi ] )
                                                    {
                                                    if( pbEncodedHe && cbEncodedHe )

                                                    countT       cbEncodedHe = pageHe ;
                                                    const byteT* pbEncodedHe = pageHe ;

                                                    pageC pageHe = jotUse[ idJot ] ;
                                                    //CS:PSEUDOdUPLICATE this this

                                                    jotC& jotUse = *ppjhs[ offi ] ;

                                                    countT idJot = wsP.sws_idJotContainerByHash.downF( tinP , hWalk ) ;
                                                {
                                                do
                                                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            {
                                            if( wsP.sws_idJotContainerByHash )

                                            wsP.leverHashContainer = hashContainer ;
                                            wsP.sws_idJotContainerByHash.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                        {
                                        case 2 :    // LOOK UP idJotContainer
                                    {
                                    switch( offi )

                                    //}
                                        //}
                                        //    countT foo = 2 ;
                                        //{
                                        //if( idIn == 2 )

                                        //etThread.traceF( tinP , T("off==3 [idIn,uri]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(ppsttzValue[offi]) ) ;

                                        //countT idIn = 1 + incv02AM( idInLath ) ;
                                        //static countT idInLath ;
                                    //{
                                    //if( offi == 3 )
                                    //U:: TO FIND A BUG

                                    //if( offi == 3 ) etThread.traceF( tinP , T("serialized processing ++++ for offi==3 [hash]:    ")+TF2(ph[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    ppjhs[ offi ]->grabF( tinP , TAG( TAGiDnULL ) ) ;

                                    if( offi != 2 && offi != 3 ) ph[ offi ] = hashF( (byteT*)psttzv , sizeof( strokeS ) * ( CSpREFIX + psttzv->idAdam ) , 0 ) ;          // I ALREADY HAVE HASH FOR OFFSETS 2 3

                                    strokeS* psttzv = ppsttzValue[ offi ] ;
                                    _IO_
                                {
                                for( countT offi = 0 ; offi < sizeof ppsttzValue / sizeof ppsttzValue[ 0 ] ; offi ++ )
                        
                                countT   ph[]          = { 0             , 0             , hashContainer , hashUri     , 0             , 0             , 0               } ; // "ph":"pHash"                                    CS:CODEsYNC: this this this this
                                countT   pidj[]        = { 0             , 0             , 0             , 0           , 0             , 0             , 0               } ; // "pidj":"pIdJot"                                 CS:CODEsYNC: this this this this
                                strokeS* ppsttzValue[] = { psttMethod    , psttLogBucket , psttContainer , psttUri     , psttQuery     , psttProtocol  , psttBrowser     } ; // STROKE STRING                                   CS:CODEsYNC: this this this this
                                jotC*    ppjhs[]       = { &wsP.jhsOther , &wsP.jhsOther , &wsP.jhsOther , &wsP.jhsUri , &wsP.jhsQuery , &wsP.jhsOther , &wsP.jhsBrowser } ; // "ppjhs":"ppJotHashStrings"                        CS:CODEsYNC: this this this this
                                // CONTAINER (OFFSET 2) MUST HAVE LOWER OFFSET THAN URI (OFFSET 3) IN THESE ARRAYS SO THAT I HAVE idJotContainer WHEN I NEED TO LOOK UP idJotUri

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                             ****************************************************************************************************************************************************************************************************************
                                // ********  GET IDjOT VALUES , HASHES  ****************************************************************************************************************************************************************************************************************
                                // ********                             ****************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************

                                const countT hashUri       = hashF( (byteT*)psttUri       , sizeof( strokeS ) * ( CSpREFIX + psttUri->idAdam       ) , 0 ) ;
                                const countT hashContainer = hashF( (byteT*)psttContainer , sizeof( strokeS ) * ( CSpREFIX + psttContainer->idAdam ) , 0 ) ;

                                //}
                                //    etThread.traceF( tinP , T("[nnHe,time,method,bucket,container,uri,query,protocol,code,cb,browser]:    ")+tSay ) ;
                                //
                                //    ;
                                //
                                //        +tb4+tBrowser
                                //        +tb4+TF4(cbRequest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                                //        +tb4+TF4(code,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                                //        +tb4+tProtocol
                                //        +tb4+tQuery
                                //        +tb4+tUri
                                //        +tb4+tContainer
                                //        +tb4+tLogBucket
                                //        +tb4+tMethod
                                //        +tb4+TT(timeW1,timeW2)
                                //        T(nnHe)
                                //
                                //    TN( tSay , "" ) ; tSay =
                                //
                                //    TN( tBrowser   , psttBrowser   ) ;
                                //    TN( tProtocol  , psttProtocol  ) ;
                                //    TN( tQuery     , psttQuery     ) ;
                                //    TN( tUri       , psttUri       ) ;
                                //    TN( tContainer , psttContainer ) ;
                                //    TN( tLogBucket , psttLogBucket ) ;
                                //    TN( tMethod    , psttMethod    ) ;
                                //{

                                // A:ASSUME:  THIS CODE ASSUMES THAT EVENTS ARE UNIQUELY IDENTIFIED BY [hash,idJot,time,nn]; MULTIPLE EVENTS WILL RESULT IN MULTIPLE VALUES FOR THE FIELDS

                                //etThread.traceF( tinP , T(psttUri) ) ;

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // ********  PROCESS WO BOOK ENTRY  ********************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                _IO_
                            {
                            else
                            if( getNegAM( finger ) != FINGERnEG_ACCESSeVENTrAW || idFormat != 1 ) etThread.traceF( tinP , T("unexpected format [finger,idFormat]:    ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            sBookEntryIn >> psttBrowser ;             ___( psttBrowser ) ;
                            sBookEntryIn >> cbRequest ;
                            sBookEntryIn >> code ;
                            sBookEntryIn >> psttProtocol ;            ___( psttProtocol ) ;
                            sBookEntryIn >> psttQuery ;               ___( psttQuery ) ;
                            sBookEntryIn >> psttUri ;                 ___( psttUri ) ;
                            sBookEntryIn >> psttContainer ;           ___( psttContainer ) ;
                            sBookEntryIn >> psttLogBucket ;           ___( psttLogBucket ) ;
                            sBookEntryIn >> psttMethod ;              ___( psttMethod ) ;
                            sBookEntryIn >> nnHe ;
                            sBookEntryIn >> *(countT*)&timeW2 ;
                            sBookEntryIn >> timeW1 ;
                            sBookEntryIn >> idFormat ;
                            sBookEntryIn >> finger ;

                            ZE( strokeS* , psttBrowser   ) ;
                            ZE( countT   , cbRequest     ) ;
                            ZE( countT   , code          ) ;
                            ZE( strokeS* , psttProtocol  ) ;
                            ZE( strokeS* , psttQuery     ) ;
                            ZE( strokeS* , psttUri       ) ;
                            ZE( strokeS* , psttContainer ) ;
                            ZE( strokeS* , psttLogBucket ) ;
                            ZE( strokeS* , psttMethod    ) ;
                            nicNameC       nnHe            ;
                            ZE( sCountT  , timeW2        ) ;
                            ZE( countT   , timeW1        ) ;
                            ZE( countT   , idFormat      ) ;
                            ZE( countT   , finger        ) ;

                            }
                                etThread.delF( tinP , pbPageCopy ) ;
                                }
                                    sBookEntryIn.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbPageCopy , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;

                                    bksAccessEventsP.unlockF( tinP ) ;
                                    etThread.memCopyF( tinP , pbPageCopy , pbzPage , cbzPage ) ;
                                    const byteT* pbzPage = *pPageEvent ;
                                    bksAccessEventsP.lockF( tinP , TAG( TAGiDnULL ) ) ;
                                {
                                if( !POOP )

                                __Z( pbPageCopy ) ;
                                etThread.newF( tinP , LF , pbPageCopy , cbzPage ) ; ___( pbPageCopy ) ;
                                ZE( byteT* , pbPageCopy ) ;

                                countT cbzPage = *pPageEvent ;
                            {
                            soulC sBookEntryIn( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( !ether )

                        _IO_
                    {
                    if( pPageEvent )

                    wsP.st_pPageEvent.ungrabF( tinP ) ;
                    wsP.st_pPageEvent >> *(countT*)&pPageEvent ;
                    ZE( pageC* , pPageEvent ) ;
                    _IO_
                {
                while( wsP.st_pPageEvent )
                wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;

                stackC stOldIdJotUri(       tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_countT ) ;
                stackC stOldIdJotContainer( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_countT ) ;

                _IO_
            {
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            _IO_
        {
        else
        }
            //etThread.traceF( tinP , T("napped") ) ;
            ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //etThread.traceF( tinP , T("napping") ) ;

            if( ether ) break ;
        {
        if( !wsP.st_pPageEvent )
        _IO_
    {
    while( !etThread && !POOP )

    TN( tDot , "." ) ;
    TN( tb4 , "    " ) ;

    booksC& bksAccessEventsP = *(booksC*)pTaskP->c2 ;
    workS&  wsP              =  *(workS*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )

}
{
swBooksByIdJots(          tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , *(const byteT**)&pcIdJots , 2 * sizeof( countT ) , 0 , sizeof( booksC ) , ifcIDgRABlAYER_7BASEmISC3 )
sws_idJotUriByHash(       tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , leverHashUri       , flSTACKc_null , ifcSTACKtYPE_countT , ifcIDgRABlAYER_7BASEmISC3 ) ,
sws_idJotContainerByHash( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , leverHashContainer , flSTACKc_null , ifcSTACKtYPE_countT , ifcIDgRABlAYER_7BASEmISC3 ) ,
idOut( 0 ) ,
idIn( 0 ) ,
cWorkers( 0 ) ,
st_pPageEvent( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_countT ) ,
jhsOther(      tinP , "jotAccessEvents.hash.string.other"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [STRING]; WO JOT PER UNIQUE STRING
jhsBrowser(    tinP , "jotAccessEvents.hash.string.browser" , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsQuery(      tinP , "jotAccessEvents.hash.string.query"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsUri(        tinP , "jotAccessEvents.hash.string.uri"     , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
workS::workS( tinS& tinP , etherC& etherP ) :

}
    swBooksByIdJots.ungrabF( tinP ) ;

    //etherC::etRockIF( tinP ).traceF( tinP , T("destroyed  all output books [idOut,cFlavors,heap.cNew-cDel]:    ")+TF2(idOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(processGlobal3S::_processGlobal3I_IF().heap.cNewF()-processGlobal3S::_processGlobal3I_IF().heap.cDelF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    swBooksByIdJots.freeAllF( tinP ) ;

    }
        //etherC::etRockIF( tinP ).traceF( tinP , T("destroying a book [idf,cFlavors]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        //tinP.pc Utility[ 0 ] -- ; //U:: TO FIND A BUG
        DELzOMBIE( pBooks ) ;
        //tinP.pc Utility[ 0 ] ++ ; //U:: TO FIND A BUG
        booksC* pBooks = (booksC*)&(countT&)swBooksByIdJots ;
        pcIdJots = (const countT*)swBooksByIdJots.leverF( tinP , idf ) ;
        //etherC::etRockIF( tinP ).traceF( tinP , T("destroying a book [idf,cFlavors]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )

    //etherC::etRockIF( tinP ).traceF( tinP , T("destroying all output books [idOut,cFlavors]:    ")+TF2(idOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    countT cFlavors = swBooksByIdJots.cFlavorsF( tinP ) ;

    swBooksByIdJots.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT workS::destroyBooksF( tinS& tinP )

}
    destroyBooksF( tinP ) ;
    TINSL
{
workS::~workS( voidT )

;
}
    voidT destroyBooksF( tinS& tinP ) ;
    workS( tinS& tinP , etherC& etherP ) ;
    ~workS( voidT ) ;

    switchC       swBooksByIdJots ;
    const countT* pcIdJots ;

    switchStackC  sws_idJotUriByHash ;
    countT        leverHashUri ;

    switchStackC  sws_idJotContainerByHash ;
    countT        leverHashContainer ;

    countT        idOut ;
    countT        idIn ;
    countT        cWorkers ;

    stackC        st_pPageEvent ;

    jotC          jhsOther   ;
    jotC          jhsBrowser ;
    jotC          jhsQuery   ;          //CS:CODEsYNC: 73a 740 (THESE MUST BE CT IN THE SAME ORDER SO THAT THE SAME TAG VALES ARE ASSIGNED
    jotC          jhsUri     ;          // EVERY JOT INSTANCE CONTAINS HASH PREFIXED STRINGS TO KEEP CODE SIMPLE EVEN THOUGH THE HASH IS NOT USEFUL FOR THE STRINGS IN jhsOther
{
struct workS

//OBSOLETED BY 51000745

/*1*/WAKEhIDE( "ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE1" )/*1*/
/**/
*/
 if this happens, all page books must be manually deleted and then regenerated (by editing my code to make me enabled during the initial reading)
 it is critically important to never fire me when new events have been booked but i have not yet "page booked" them
 i enable myself only after reading all existing booked events, when i nap for the woth time
during initialization, i assume that all existing booked events have already been "page booked' and ignore them
 on output, each access event is written to a book dedicated to the corresponding idJot pair that identifies [container] [uri]
 the idJot values identify strings that i place into jotC instances
 on output, each access event soulC contains idJot values rather than string values
 on input, each access event soulC is self sufficient in that it contains string values
i "divide and conquer" by distributing access events to a dedicated booksC instance for each hash of [container] || [uri]
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
