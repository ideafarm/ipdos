
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    //if( !cbMax ) cbMax = - 1 ;
    //cbMax <<= 1 ;

    //if( cbMax == -1 ) break ;

    poolC::deleteEmptiesIfIF( tinP ) ;
    }
        }
            poolC::deleteEmptiesIfIF( tinP ) ;
            }
                poolC::deleteEmptiesIfIF( tinP ) ;
                }
                    }
                        }
                            }
                                }
                                    }
                                        }
                                            etThread.delF( tinP , psttShortest ) ;
                                            }
                                                etThread.delF( tinP , psttShort ) ;

                                                if( !bShortest ) etThread.diskFileOrDirDeleteF( tinP , tPathArchive+T(psttShort) ) ;

                                                etThread.traceF( tinP , T(bShortest?"keep     ":/*cbFileUse==cbFile?*/"delete   "/*:"delete ? "*/)+T(psttShort) ) ;
                                                boolT bShortest = !etThread.strCompareF( tinP , psttShort , psttShortest ) ;
                                                swsNameByBlobPart >> psttShort ;
                                                ZE( strokeS* , psttShort ) ;
                                            {
                                            while( swsNameByBlobPart )

                                            }
                                                __Z( psttShortest ) ;
                                                while( !ether && ~hWalk ) ;
                                                }
                                                    }
                                                        if( !psttShortest                                           ) { etThread.strMakeF( tinP , psttShortest , psttfns ) ; ___( psttShortest ) ; }
                                                        if(  psttShortest && psttfns->idAdam < psttShortest->idAdam ) etThread.delF( tinP , psttShortest ) ;
                                                    {
                                                    if( !bIgnore )

                                                    boolT bIgnore = bFoundNotPicture && etThread.strIdF( tinP , tPicture , psttfns ) ;
                                                    strokeS* psttfns = (strokeS*)swsNameByBlobPart.downF( tinP , hWalk ) ;
                                                {
                                                do
                                                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                            {
                                            ZE( strokeS* , psttShortest ) ;

                                            }
                                                while( !ether && ~hWalk ) ;
                                                }
                                                    }
                                                        break ;
                                                        bFoundNotPicture = 1 ;
                                                    {
                                                    if( !etThread.strIdF( tinP , tPicture , psttfns ) )
                                                    strokeS* psttfns = (strokeS*)swsNameByBlobPart.downF( tinP , hWalk ) ;
                                                {
                                                do
                                                handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            {
                                            ZE( boolT , bFoundNotPicture ) ;
                                        {
                                        else
                                        if( !bIdentical ) etThread.traceF( tinP , T("WARNING: blob parts were identical but whole files were not.  no files were deleted for this set") ) ;
                                    {
                                    if( !POOP )

                                    }
                                        etThread.delF( tinP , *(byteT**)&phFile ) ;
                                        }
                                            DELzOMBIE( phDoomed ) ;
                                            handleC* phDoomed = phFile + offh ;
                                        {
                                        for( countT offh = 0 ; offh < cBuf ; offh ++ )

                                        etThread.delF( tinP , pbBuf ) ;
                                        }
                                            }
                                                }
                                                    }
                                                        }
                                                            break ;
                                                            bIdentical = 0 ;
                                                        {
                                                        if( etThread.memCompareF( tinP , pbBuf , pbBuf + offb * TOCK , cbBite ) )
                                                    {
                                                    for( countT offb = 0 ; offb < cBuf ; offb ++ )
                                                {
                                                if( !POOP )

                                                }
                                                    __NZ( cbWant - cbBite ) ;
                                                    etThread.fileReadF( tinP , pbBuf + offb * TOCK , cbWant , phFile[ offb ] ) ;
                                                    countT cbWant = cbBite ;
                                                {
                                                for( countT offb = 0 ; offb < cBuf ; offb ++ )

                                                cbDo -= cbBite ;
                                                countT cbBite = cbDo < TOCK ? cbDo : TOCK ;
                                            {
                                            while( cbDo )
                                            countT cbDo = cbFile ;

                                            }
                                                etThread.fileOpenF( tinP , phFile[ offb ] , countTC() , tPathArchive+T((strokeS*)swsNameByBlobPart[offb+1]) , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO ) ;
                                                new( 0 , tinP , (byteT*)( phFile + offb ) , sizeof( handleC ) ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                                            {
                                            for( countT offb = 0 ; offb < cBuf ; offb ++ )
                                        {
                                        if( !POOP )

                                        etThread.newF( tinP , LF , *(byteT**)&phFile , sizeof( handleC ) * cBuf ) ; ___( phFile ) ;
                                        ZE( handleC* , phFile ) ;

                                        __Z( pbBuf ) ;
                                        etThread.newF( tinP , LF , pbBuf , TOCK * cBuf ) ; ___( pbBuf ) ;
                                        ZE( byteT* , pbBuf ) ;
                                        countT cBuf = swsNameByBlobPart ;

                                        //  IF ALL BUFFERS ARE NOT IDENTICAL THEN RESET FLAG AND BREAK
                                        //  READ THE NEXT TOCK (OR FINAL PORTION) OF EACH FILE
                                        // DO UNTIL ENTIRE FILE SIZE HAS BEEN PROCESSED
                                        // ALLOCATE A TOCK BUFFER FOR EACH FILE
                                        //RECIPE

                                        //VERIFY THAT THE FILES ARE REALLY IDENTICAL
                                    {
                                    if( cbFileUse < cbFile )
                                    boolT bIdentical = 1 ;

                                    etThread.traceF( tinP , T("for size ")+TF2(cbFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(", found ")+TF2((countT)swsNameByBlobPart,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" duplicates") ) ;
                                {
                                else
                                }
                                    etThread.delF( tinP , psttShort ) ;
                                    swsNameByBlobPart >> psttShort ;
                                    ZE( strokeS* , psttShort ) ;
                                {
                                if( swsNameByBlobPart == 1 || !cbFile )

                                pbLeverBlobPart = (byteT*)swsNameByBlobPart.leverF( tinP , idfBlobPart ) ;
                            {
                            for( countT idfBlobPart = 1 ; idfBlobPart <= cFlavorsBlobPart ; idfBlobPart ++ )
                            countT cFlavorsBlobPart = swsNameByBlobPart.cFlavorsF( tinP ) ;
                            //FOR EACH BLOB VALUE, REPORT AND DELETE DUPLICATES

                            poolC::deleteEmptiesIfIF( tinP ) ;
                            }
                                }
                                    etThread.delF( tinP , pbLeverBlobPart ) ;
                                
                                    if( !POOP ) swsNameByBlobPart << psttShort ;
                                    __NZ( cbWant - cbFileUse ) ;
                                    etThread.fileReadF( tinP , pbLeverBlobPart , cbWant , hFile ) ;
                                    countT cbWant = cbFileUse ;
                                
                                    etThread.fileOpenF( tinP , hFile , countTC() , tPathArchive+T(psttShort) , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO ) ;
                                    handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                                    
                                    etThread.newF( tinP , LF , pbLeverBlobPart , cbFileUse ) ; ___( pbLeverBlobPart ) ;
                                {
                                else
                                }
                                    etThread.delF( tinP , pbLeverBlobPart ) ;
                                    if( !POOP ) swsNameByBlobPart << psttShort ;
                                    __NZ( cbIn - cbFile ) ;
                                    etThread.boxGetShadowF( tinP , pbLeverBlobPart , cbIn , tPathArchive+T(psttShort) ) ; ___( pbLeverBlobPart ) ;
                                    ZE( countT , cbIn ) ;
                                {
                                if( cbFileUse == cbFile )

                                swsNameByHash >> psttShort ; ___( psttShort ) ;
                                ZE( strokeS* , psttShort ) ;
                            {
                            while( swsNameByHash )
                            switchStackC swsNameByBlobPart( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , *(const byteT**)&pbLeverBlobPart , cbFileUse , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
                            ZE( byteT* , pbLeverBlobPart ) ;
                            // LOAD swsNameByBlobPart WITH FILE NAMES SWITCHED ON THE BLOB VALUE

                            cLeverHash = swsNameByHash.leverF( tinP , idfHash ) ;
                        {
                        for( countT idfHash = 1 ; idfHash <= cFlavorsHash ; idfHash ++ )
                        //FOR EACH HASH
                    {
                    if( cFlavorsHash < cFiles ) // LOOK FOR DUPLICATES ONLY IF I HAVE FEWER DISTINCT HASHES THAN FILES
                    countT cFlavorsHash = swsNameByHash.cFlavorsF( tinP ) ;

                    }
                        }

                            }
                                swsNameByHash << psttShort ;
                                etThread.delF( tinP , pbIn ) ;
                                cLeverHash = hashF( pbIn , cbFileUse , 0 ) ;
                            {
                            else            
                            if( POOP ) etThread.delF( tinP , pbIn ) ;

                            __NZ( cbWant - cbFileUse ) ;
                            etThread.fileReadF( tinP , pbIn , cbWant , hFile ) ;
                            countT cbWant = cbFileUse ;
                        
                            etThread.fileOpenF( tinP , hFile , countTC() , tPathArchive+T(psttShort) , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO ) ;
                            handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                            
                            etThread.newF( tinP , LF , pbIn , cbFileUse ) ; ___( pbIn ) ;
                            ZE( byteT* , pbIn ) ;
                        {
                        else
                        }
                            }
                                }
                                    swsNameByHash << psttShort ;
                                    etThread.delF( tinP , pbIn ) ;
                                    cLeverHash = hashF( pbIn , cbIn , 0 ) ;
                                {
                                else
                                if( POOP ) etThread.delF( tinP , pbIn ) ;

                                __NZ( cbIn - cbFile ) ;
                                etThread.boxGetShadowF( tinP , pbIn , cbIn , tPathArchive+T(psttShort) ) ; ___( pbIn ) ;
                                ZE( countT , cbIn ) ;
                                ZE( byteT* , pbIn ) ;
                            {
                            else
                            if( !cbFile ) etThread.delF( tinP , psttShort ) ;
                        {
                        if( cbFileUse == cbFile )

                        //etThread.traceF( tinP , psttShort ) ;
                        soulSws >> psttShort ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                    {
                    while( !ether && cDo -- )
                    countT cDo = cFiles ;
                    switchStackC swsNameByHash( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cLeverHash , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
                    ZE( countT , cLeverHash ) ;
                    // LOAD swsNameByHash WITH FILE NAMES SWITCHED ON THE HASH VALUE CALCULATED FROM THE BLOB VALUE
                {

                ;
                    : TICK
                    ? cbFile
                countT cbFileUse = cbFile < TICK

                //etThread.traceF( tinP , T("stacking names by hash [soulSws,cbFile,cFiles]:    ")+TF2((countT)soulSws,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cbFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                soulSws >> cFiles ;
                soulSws >> cbFile ;
                ZE( countT , cFiles ) ;
                ZE( countT , cbFile ) ;
            {
        {
        while( !ether && soulSws )
        TN( tPicture , ".picture." ) ;
        etThread.traceF( tinP , T("eating soulSws") ) ;

        poolC::deleteEmptiesIfIF( tinP ) ;
        etThread.traceF( tinP , T("deleting empty pools") ) ;
        }
            etThread.traceF( tinP , T("destroying swsFiles") ) ;
            }
                }
                    while( !ether && ~hWalk ) ;
                    }
                        soulSws << psttfns ;
                        //etThread.traceF( tinP , psttfns ) ;
                        strokeS* psttfns = (strokeS*)swsFiles.downF( tinP , hWalk ) ;
                    {
                    do
                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                    soulSws << (countT)swsFiles ;
                {
                if( !POOP )

                __Z( swsFiles ) ;

                soulSws << cLeverCbFile ;

                etThread.traceF( tinP , T("loading soulSws [idfFiles,cbFile]:    ")+TF2(idfFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cLeverCbFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                cLeverCbFile = swsFiles.leverF( tinP , idfFiles ) ;
            {
            for( countT idfFiles = 1 ; !ether && idfFiles <= cFlavorsFiles ; idfFiles ++ )
            countT cFlavorsFiles = swsFiles.cFlavorsF( tinP ) ;
            etThread.traceF( tinP , T("loading soulSws") ) ;

            etThread.diskWalkF( tinP , cDirs , cFiles , tPathArchive , (countT&)(const countT&)ether , diskWalkCBF , pcArgs ) ;
            ZE( countT , cFiles ) ;
            ZE( countT , cDirs ) ;

            countT pcArgs[] = { (countT)&etThread , (countT)&cLeverCbFile , (countT)&swsFiles , (countT)(strokeS*)tSlash /*, cbMin , cbMax*/ } ;

            //etThread.traceF( tinP , T("[cbMin,cbMax]:    ")+TF2(cbMin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cbMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            //;
            //
            //        : ( cbMax >> 1 ) + 1
            //        ? 0x80000001
            //    : cbMax == - 1
            //    ? 1
            //
            //countT cbMin = cbMax == TUCK

            switchStackC swsFiles( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cLeverCbFile , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
            ZE( countT , cLeverCbFile ) ;
            etThread.traceF( tinP , T("loading swsFiles") ) ;
        {
        soulC soulSws( tinP , TAG( TAGiDnULL ) , flSOUL_null , "sws.cb.name" ) ;
    {
{
//for(;;)
//countT cbMax = TUCK << 6 ;

TN( tSlash , "/" ) ;
//TN( tPathArchive , "///d/ideafarm.home.101/IdeaFarm (tm)/SYSTEM/Drop Files Here To Archive/" ) ;
TN( tPathArchive , "///d/ideafarm.home.101/IdeaFarm (tm)/SYSTEM/arc.jpg/" ) ;

TODO

}
    return 0 ;

    DEL( pInfo ) ;

    etherP.delF( tinP , psttfn ) ;
    }
        swsFilesP << psttfnShort ; psttfnShort = 0 ;
        cLeverCbFileP = pInfo->cbUsed ;
        etherP.traceF( tinP , psttfnShort ) ;

        }
            etherP.delF( tinP , psttfnPath ) ;
            ___( psttfnShort ) ;
            ___( psttfnPath ) ;
            etherP.strBisectF( tinP , psttfnPath , psttfnShort , psttfn , psttSlashP , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
            ZE( strokeS* , psttfnPath ) ;
        {
        ZE( strokeS* , psttfnShort ) ;
    {
    //if( !pInfo->cbUsedHigh && cbMinP <= pInfo->cbUsed && pInfo->cbUsed <= cbMaxP )

    etherP.diskFileQueryF( tinP , pInfo , hFile ) ;
    ZE( infoFileS* , pInfo ) ;

    etherP.fileOpenF( tinP , hFile , countTC() , psttfn , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO ) ;
    handleC hFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;

    if( !( cFilesP % TUCK ) ) etherP.traceF( tinP , T("loaded ")+TF2(cFilesP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" files") ) ;

    etherP.strMakeFromOsTextF( tinP , psttfn , iffn ) ; ___( psttfn ) ;
    ZE( strokeS* , psttfn ) ;
    ifFileNameC iffn( tinP , etherP , postNameP ) ;

    //const countT   cbMaxP        =                 pcArgP[ 5 ] ;
    const countT   cbMinP        =                 pcArgP[ 4 ] ;
    const strokeS* psttSlashP    = (const strokeS*)pcArgP[ 3 ] ;
    switchStackC&  swsFilesP     = *(switchStackC*)pcArgP[ 2 ] ;
    countT&        cLeverCbFileP =       *(countT*)pcArgP[ 1 ] ;
    etherC&        etherP        =       *(etherC*)pcArgP[ 0 ] ;
{
boolT diskWalkCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

#define CBfILEhiGHwATERdONEaOK 0x1fd4f28

/*1*/WAKEsHOWtEXT( "tool.report.or.delete.archive.duplicates" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

