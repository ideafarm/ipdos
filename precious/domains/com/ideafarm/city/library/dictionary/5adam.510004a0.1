
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    ether.osSleepF( tinP , TOCK * 0x10 ) ;

    }
        }
            etThread.strokeF( tinP , TF3(info.swInUse,flFORMAT_UNSIGNED,9)+TF3(info.pczLifi[0],flFORMAT_UNSIGNED,9)+TF3(info.pczLifi[1],flFORMAT_UNSIGNED,9)+tc ) ;
            info.pczLifi = (countT*)info.swInUse.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = info.swInUse.cFlavorsF( tinP ) ;
        TN( tc , "\r\n" ) ;
    
        ) ;
            T("\r\n \r\n")
            T("\r\ncDropsInUse  : ")+TF1(info.cDrops-info.cDropsDeleted)+
            T("\r\ncDropsDeleted: ")+TF1(info.cDropsDeleted)+
            T("\r\ncDrops       : ")+TF1(info.cDrops)+
            T(  "\freport       : ")+TF1(++idCycle)+
        etThread.strokeF( tinP , 
        poolOldr.walkF( tinP , poolOldWalker_4a40104_F , c_info , flPOOLoLDwALK_INCLUDEdROPSoTHERcLIENTS ) ;
        
        c_info = (countT)&info ;
        infoS info( tinP , etThread ) ;
        ZE( countT , c_info ) ;
    
        //p oolC poolOldr( tinP , TAG( TAGiDnULL ) , "144" ) ;
        //p oolC& poolOldr = etThread ;
        p oolC poolOldr( tinP , TAG( TAGiDnULL ) ) ;
    {
{
while( !ether && !etThread )
ZE( countT , idCycle ) ;

TODO

}
    return bCorrupt ;
    if( infoP && tinP.fingerprint && idClientP && flagsWalkerP ) ;

    }
        }
            }
                ++ info.swInUse ;
                info.c5lifi.c3 = 0 ;
                //info.c5lifi.c4 = idiFileNote ;
                //info.c5lifi.c3 = idLineNote ;
                info.c5lifi.c2 = idiFile ;
                info.c5lifi.c1 = idLine ;
            {
            else
            if( F(flags) & flDROP_DELETED ) ++ info.cDropsDeleted ;
            ++ info.cDrops ;

            countT  cbUsedReally       = db.cbUsedReally ;
            countT  idType             = db.idType ;    
            countT  idiFileNote        = db.idiFileNote ;
            countT  idLineNote         = db.idLineNote ;
            countT  idiFile            = db.idiFile ;
            countT  idLine             = db.idLine ;
            countT  cbd                = DHcbYTES ;
            countT  ids                = DHiDsTEP ;
            countT  idt                = DHiDtHREAD ;
            countT  idc                = DHiDcLIENT ;
            flagsT& flags              = DHfLAGS ; // ASSUME: sizeof( flagsT ) == sizeof( countT )
            //DROPnOTErEF( pvP ) ;
        {
        else
        }
        {
        if( bCorrupt )
        if( DHgUARD - POOLoLDdROPgUARD ) bCorrupt |= 1 ;
    {
    else
    }
    {
    if( !pvP )

    infoS& info = *(infoS*)infoP ;
    ZE( boolT , bCorrupt ) ;

    }
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    POOPIES //U::
{
boolT poolOldWalker_4a40104_F( tinS& tinP , voidT* const pvP , countT& idClientP , countT& infoP , const flagsT flagsWalkerP )

}
{
swInUse( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , pczLifi )
pczLifi( c5lifi ) ,
cDropsDeleted( 0 ) ,
cDrops( 0 ) ,
cReportLines( 0 ) ,
infoS::infoS( tinS& tinP , etherC& etherP ) :

;
}
    infoS( tinS& tinP , etherC& etherP ) ;

    switchC  swInUse ;
    countT*  pczLifi ;
    count5S  c5lifi ;
    countT   cDropsDeleted ;
    countT   cDrops ;
    countT   cReportLines ;
{
struct infoS

#define COSTmAXdUMP       0x80
//THESE DO NOT NEED TO BE THE SAME VALUE; THEY ARE UNRELATED
#define COSTmAXdbtASSUMED 0x80

/*1*/WAKEhIDE( "tool.monitor.poolOld" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

