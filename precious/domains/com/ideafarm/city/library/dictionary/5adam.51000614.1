
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    //U::sgnDone_tmLoadSilent.waitF( tinP ) ;

    TELL( "cleaning up" ) ;
    }
        *tinP.pEtScratch = 0 ; //U: WORKAROUND TO SEE WHETHER PREVENTS BLOCK IN bindF
        TELL( "destroying the catching socket" ) ;
        }
            tinP.pEtScratch->delF( tinP , pbq ) ;
            }
                if( bFireOs ) tinP.pEtScratch->osFireF( tinP ) ;

                //CONoUTrAW( "done\r\n" ) ;
                TELL( "query packet handled" ) ;
                }
                    tinP.pEtScratch->delF( tinP , pbr ) ;

                    //while( cTries -- ) sockd.writeF( tinP , idp , nnPeer , pbr , cbr ) ;
                    //KEEP THE REPLY SUPPRESSED UNTIL I FULLY UNDERSTAND HOW TO PREVENT ME FROM BEING USED MALICIOUSLY
                    //U::DISABLED TO PREVENT ME FROM BEING USED TO ATTACK SPOOFED REQUESTER

                    countT cTries = 8 ;
                    TELL( "writing a reply" ) ;

                    tinP.pEtScratch->dnsReplyF( tinP , pbr , cbr , pbq , stsReplies , 1 , idError ) ;
                    ZE( countT , cbr ) ;
                    ZE( byteT* , pbr ) ;
                    TELL( "composing a reply" ) ;
                    //CONoUTrAW( "emitting reply\r\n" ) ;
                {
                else
                }
                    CONoUTrAW( "silent\r\n" ) ;
                {
                if( bSilent )
    
                }
                    tinP.pEtScratch->delF( tinP , psttPeer ) ;
                    TELL( "cleaning up after handling the query datagram" ) ;

                    }
                        }
                            DEL( ps ) ;
                            }
                                TELL( "cleaning up after handling a single query" ) ;
                                tinP.pEtScratch->delF( tinP , psttw ) ;
                                }
                                    }
                                        break ;
                                        idError = ifcIDeRRORdNS_QUERYnOTsUPPORTED ;
                                        //tinP.pEtScratch->strokeF( tinP , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": nOTsUPPORTED: ")+T(psttw)+T("\r\n") ) ;
                                        TELL( "ifcIDeRRORdNS_QUERYnOTsUPPORTED" ) ;
                                        //CONoUTrAW3( "type " , idType , " [not supported]\r\n" ) ;
                                    {
                                    default :
                                    }
                                        break ;
                                        idError = ifcIDeRRORdNS_QUERYnOTsUPPORTED ;
                                        //tinP.pEtScratch->strokeF( tinP , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": OPTION: ")+T(psttw)+T("\r\n") ) ;
                                        TELL( "ifcIDtYPEdNSqUERY_OPTION" ) ;
                                        //CONoUTrAW( "OPTION\r\n" ) ;
                                    {
                                    case ifcIDtYPEdNSqUERY_OPTION :
                                    }
                                        break ;
                                        if( !tinP.pEtScratch->strCompareF( tinP , psttw , tRoot ) ) rec_SOA_F( tinP , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , psttw , tNs1 , tEmail ) ;
                                        //tinP.pEtScratch->strokeF( tinP , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": SOA: ")+T(psttw)+T("\r\n") ) ;
                                        TELL( "ifcIDtYPEdNSqUERY_SOA" ) ;
                                        //CONoUTrAW( "SOA\r\n" ) ;
                                    {
                                    case ifcIDtYPEdNSqUERY_SOA :
                                    }
                                        break ;
            
                                        }
                                            rec_NS_F( tinP , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , psttw , tNs2 ) ;
                                            rec_NS_F( tinP , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , psttw , tNs1 ) ;
                                        {
                                        if( !tinP.pEtScratch->strCompareF( tinP , psttw , tRoot ) )
                                        //tinP.pEtScratch->strokeF( tinP , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": NS: ")+T(psttw)+T("\r\n") ) ;
                                        TELL( "ifcIDtYPEdNSqUERY_NS" ) ;
                                        //CONoUTrAW( "NS\r\n" ) ;
                                    {
                                    case ifcIDtYPEdNSqUERY_NS :
                                    }
                                        break ;
                                        }
                                            rec_A_F(  tinP , stsReplies , ifcIDtYPEdNSrEPLY_NOTE   , tMail , nnRoot ) ;
                                            rec_MX_F( tinP , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , psttw , tMail ) ;
                                        {
                                        if( !tinP.pEtScratch->strCompareF( tinP , psttw , tRoot ) )
                                        tinP.pEtScratch->strokeF( tinP , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": MX: ")+T(psttw)+T("\r\n") ) ;
                                        TELL( "ifcIDtYPEdNSqUERY_MX" ) ;
                                        //CONoUTrAW( "MX\r\n" ) ;
                                    {
                                    case ifcIDtYPEdNSqUERY_MX :
                                    }
                                        break ;
            
                                        else        rec_A_F( tinP , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , psttw , nnOut ) ;
                                        if( bNope ) ;//tinP.pEtScratch->ifcSayF( tinP , T("NOPE: \"")+T(psttw)+T("\"\r\n") , flSAY_APPEND | flSAY_LOG ) ;
            
                                        else bNope = 1 ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tAllowVersion  ) ) nnOut = nnAllow ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tRefuseVersion ) ) nnOut = nnRefuse ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tSingularity   ) ) nnOut = nnSingularity ; //MIGHT BE 0.  THIS MEANS THAT A SINGULARITY IS NOT REGISTERED
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tNs5           ) ) nnOut = nnRoot ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tNs            ) ) nnOut = nnRoot ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tMail          ) ) nnOut = nnRoot ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tFtp           ) ) nnOut = nnRoot ;
                                        else if( tinP.pEtScratch->strIdF(       tinP , tHostOk , psttw        ) ) { nnOut = nnRoot /*ANY NONZE VALUE WILL DO*/ ; } //U: ASSUME: I AM LIVING ON THE HOST THAT IS TO BE FIRED
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tFireOs        ) ) { nnOut = nnRoot ; bFireOs = 1 ; } //U: ASSUME: I AM LIVING ON THE HOST THAT IS TO BE FIRED
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tWww           ) ) nnOut = nnRoot ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tRoot          ) ) nnOut = nnRoot ;
                                        }
                                            tinP.pEtScratch->delF( tinP , psttDigits ) ;
                                            //tinP.pEtScratch->ifcSayF( tinP , T("idComputer=")+TF1(idComputer)+T(" nnOut=")+T(nnOut)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                                            swNicName.ungrabF( tinP ) ;
                                            nnOut = *(nicNameC*)&(countT&)swNicName ;
                                            idComputer = tinP.pEtScratch->strDigitsToSCountF( tinP , psttDigits ) ;
                                            swNicName.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                            tinP.pEtScratch->strWordF( tinP , psttDigits , psttw , sttq , S1C('.') ) ; ___( psttDigits ) ; ;
                                            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                            ZE( strokeS* , psttDigits ) ;
                                        {
                                        else if( tinP.pEtScratch->strIdF( tinP , tQueryHostSuffix , psttw ) )
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tIfc5        ) ) nnOut = nnRoot ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tIfc1        ) ) nnOut = nnRoot ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tPort3Space  ) ) nnOut = nnRelayPortCraft ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tPort2Space  ) ) nnOut = nnRelayPortTest ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tPort1Space  ) ) nnOut = nnRelayPort ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tNn3Space    ) ) nnOut = nnRoot ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tNn2Space    ) ) nnOut = nnRoot ;
                                        else if( !tinP.pEtScratch->strCompareF( tinP , psttw , tNn1Space    ) ) nnOut = nnRoot ;

                                        }
                                            //tinP.pEtScratch->ifcSayF( tinP , T("looked up teacher's nicNameC value: ")+T("idComputer=")+TF1(idComputer)+T(" nnOut=")+T(nnOut)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                                            swNicName.ungrabF( tinP ) ;
                                            nnOut = *(nicNameC*)&(countT&)swNicName ;
                                            idComputer = 0x4c3b8d9f  ; // SERIAL OF DRIVE ///c ON IFC12 (LAPTOP)
                                            swNicName.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                        {
                                        if( !tinP.pEtScratch->strCompareF( tinP , psttw , tTeacher ) )
                                        ZE( boolT , bNope ) ;

                                        //CONoUTrAW( T("A: \"")+T(psttw)+T("\"\r\n") ) ;
            
                                        nicNameC nnOut ;
                                        //CONoUTrAW( TF1(idClient)+T(" ")+T(nnPeer)+T(" ")+T(psttPeer)+T(": A: \"")+T(psttw)+T("\"\r\n") ) ;
                                        //tinP.pEtScratch->strokeF( tinP , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": A: \"")+T(psttw)+T("\"\r\n") ) ;
                                        //tinP.pEtScratch->ifcSayF( tinP , TF1(idClient)+T(" ")+T(nnPeer)+T(" ")+T(psttPeer)+T(": A: \"")+T(psttw)+T("\"\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                                        TELL( "ifcIDtYPEdNSqUERY_A" ) ;
                                        //CONoUTrAW( "A\r\n" ) ;
                                    {
                                    case ifcIDtYPEdNSqUERY_A :
                                {
                                else if( idClass == 1 ) switch( idType )
                                if( bSilent ) ;//tinP.pEtScratch->ifcSayF( tinP , T("---- SILENT REFUSAL: ")+T(nnPeer)+T(" ")+T(psttPeer)+T(": A: ")+T(psttw)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
            
                                *ps >> idClass ;
                                ZE( countT , idClass ) ;
            
                                *ps >> idType ;
                                ZE( countT , idType ) ;

                                tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttw ) ; ___( psttw ) ;
                                *ps >> psttw ;
                                ZE( strokeS* , psttw ) ;
                                TELL( "preparing to respond to a single query" ) ;
                            {
                            if( ps )
                            stsQueries >> ps ;
                            ZE( soulC* , ps ) ;
                            TELL( "handling a query" ) ;
                        {
                        while( stsQueries )
                        TELL( "counting the remaining queries" ) ;
                    {
                    else
                    }
                        bSilent = 1 ;
                        POOPR ;
                    {
                    if( POOP )

                    }
                        tinP.pEtScratch->delF( tinP , pbNU ) ;
                        tinP.pEtScratch->dnsParseF( tinP , pbNU , countTC() , stsQueries , stsRepliesNU , pbq , cbq ) ;
                        ZE( byteT* , pbNU ) ;

                        stsRepliesNU.purgeF( tinP ) ;
                        stsQueries.purgeF( tinP ) ;
                    {
                    TELL( "parsing the queries" ) ;
                    //CONoUTrAW( "parsing the queries\r\n" ) ;

                    //tinP.pEtScratch->sockPsttHostF( tinP , psttPeer , nnPeer ) ; ___( psttPeer ) ;
                    TELL( "transcribing the peer nicName" ) ;
                    ZE( strokeS* , psttPeer ) ;
                    //etThread.strokeF( tinP , TF1(idClient)+tb+T(nnPeer)+tBar+T("parsing request")+te ) ;

                    ++ idClient ;
                {
                else
                }
                    CONoUTrAW( "request refused (nnNopeRefuse1)\r\n" ) ;
                    idError = ifcIDeRRORdNS_QUERYrEFUSED ;
                {
                if( nnPeer == nnNopeRefuse1 )

                ZE( boolT , bFireOs ) ;

                countT idError = ifcIDeRRORdNS_AOK ;
            {
            if( pbq && cbq )

            //b_pnnSilent.ungrabF( tinP ) ;
            //}
            //    }
            //        break ;
            //        bSilent = 1 ;
            //    {
            //    if( nnPeer == pnnSilent[ off ] )
            //{
            //for( countT off = 0 ; off < cnnSilent ; off ++ )
            //b_pnnSilent.grabF( tinP , TAG( TAGiDnULL ) ) ;
            ZE( boolT , bSilent ) ;

            TELL( "preparing to handle a query packet" ) ;
            //CONoUTrAW( "request received\r\n" ) ;
            sockd.readF( tinP , pbq , cbq , idp , nnPeer ) ; ___( pbq ) ;
            //CONoUTrAW( "ho hum\r\n" ) ;
            TELL( "waiting for a query datagram" ) ;
            nicNameC nnPeer ;
            ZE( countT , idp ) ;
            ZE( countT , cbq ) ;
            ZE( byteT* , pbq ) ;
        {
        while( !POOP && !ether && !etThread && !*tinP.pEtScratch )

        //nicNameC nnRoot2 = etThread.sockNicNameF( tinP , T("69.0.244.16") ) ;

        nicNameC nnAllow(  0x00ff00ff ) ;
        nicNameC nnRefuse( 0xff00ff00 ) ;
        //if( etThread.diskIdF( tinP , T("///c") ) != 0x2c1f032d ) nnRoot  = etThread.sockNicNameF( tinP , T("69.0.243.16") ) ;
        //nicNameC nnRoot( NICnAMElOCAL ) ;    // 127.1.1.1 //U:
        //nicNameC nnRoot( 0x40ef0525 ) ;    // ifc5: 64.239.5.37
        //nicNameC nnRoot( 0xd8a2a931 ) ;    // ifc4: 216.162.169.49
        //nicNameC nnRoot( 0x0a010102 ) ;    // 10.1.1.2 //U:

        nicNameC nnRelayPortCraft = nicNameC( ifcIDpORT_RELAYcRAFT ) ;
        nicNameC nnRelayPortTest  = nicNameC( ifcIDpORT_RELAYtEST ) ;
        nicNameC nnRelayPort      = nicNameC( ifcIDpORT_RELAY ) ;
        nicNameC nnRoot           = nnThisHost ;
        nicNameC nnThisHost       = socketC::nicNameIF( tinP , etThread ) ;
        //nicNameC nnThisHost     = etThread.sockNicNameF( tinP ) ;

        TN( tPort3Space      , "port.3.space.ideafarm.com" ) ;
        TN( tPort2Space      , "port.2.space.ideafarm.com" ) ;
        TN( tPort1Space      , "port.1.space.ideafarm.com" ) ;
        TN( tNn3Space        , "nicname.3.space.ideafarm.com" ) ;
        TN( tNn2Space        , "nicname.2.space.ideafarm.com" ) ;
        TN( tNn1Space        , "nicname.1.space.ideafarm.com" ) ;
        TN( tAllowVersion    , "2.version.ipdos.ideafarm.com" ) ;
        TN( tRefuseVersion   , "1.version.ipdos.ideafarm.com" ) ;
        TN( tQueryHostSuffix ,        ".host.ideafarm.com" ) ;
        TN( tTeacher         , "teacher.host.ideafarm.com" ) ;
        TN( tIfc5            ,    "ifc5.host.ideafarm.com" ) ;
        TN( tIfc1            ,    "ifc1.host.ideafarm.com" ) ;
        TN( te     , "\r\n" ) ;
        TN( tb     , " " ) ;
        TN( tBar   , "| " ) ;
        TN( tLog   , "///d/ideafarm.log.port.53.dns" ) ;
        TN( tNs5   ,    "ns5.ideafarm.com" ) ;
        TN( tNs4   ,    "ns4.ideafarm.com" ) ;
        TN( tNs3   ,    "ns3.ideafarm.com" ) ;
        TN( tNs2   ,    "ns2.ideafarm.com" ) ;
        TN( tNs1   ,    "ns1.ideafarm.com" ) ;
        TN( tNs    ,     "ns.ideafarm.com" ) ;
        TN( tSingularity , "singularity.ideafarm.com" ) ;
        TN( tFtp   ,     "ftp.ideafarm.com" ) ;
        TN( tHostOk , ".!hostxk.ideafarm.com" ) ;
        TN( tFireOs ,  "!fire.ideafarm.com" ) ;
        TN( tWww   ,     "www.ideafarm.com" ) ;
        TN( tMail  ,    "mail.ideafarm.com" ) ;
        TN( tTest  ,    "test.ideafarm.com" ) ;
        TN( tEmail ,       ifcEMAIL_DNS ) ;
        TN( tRoot  ,         "ideafarm.com" ) ;
    
        sockd.bindF( tinP , ifcPORToLD2_DNS ) ;
        socketC sockd( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
        TELL( "preparing to catch query datagrams" ) ;
        stsReplies.purgeF( tinP ) ;
        stsQueries.purgeF( tinP ) ;
        *tinP.pEtScratch = 0 ;
    {
    while( !POOP && !ether && !etThread )
    stackC stsQueries(   tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stsReplies(   tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stsRepliesNU( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    ZE( countT , idClient ) ;

    ether.loafIF( tinP ) ; //U::DISABLE ME UNTIL I AM ENHANCED TO IGNORE OBVIOUS DDOS CLIENTS THAT PEG MY CPU

    etThread.osThreadF( tinP , countTC() , tmHireF ) ;
    //CONoUTrAW( "launching tmHireF\r\n" ) ; //U::
    //etThread.osThreadF( tinP , countTC() , tmLoadSilentF , &sgnDone_tmLoadSilent , flTHREADlAUNCH_null , 0 , (countT)&b_pnnSilent , (countT)&pnnSilent , (countT)&cnnSilent ) ;
    signC sgnDone_tmLoadSilent( tinP , TAG( TAGiDnULL ) ) ;
    //CONoUTrAW( "main/1\r\n" ) ; //U::

    const nicNameC nnNopeRefuse1 = etThread.sockNicNameF( tinP , T("1.2.3.4") ) ; // example.reply.with.refusal
    ZE( countT    , cnnSilent ) ;
    ZE( nicNameC* , pnnSilent ) ;
    batonC b_pnnSilent( tinP , TAG( TAGiDnULL ) ) ;
    //PSEUDODUPLICATE CODE: 1030168 2540104

    //CONoUTrAW( "main/2\r\n" ) ; //U::
    stateS state( tinP , etThread ) ;
    //CONoUTrAW( "main/3\r\n" ) ; //U::

    SCOOPS
{
IFsCRATCH

//CONoUTrAW( "main/4\r\n" ) ; //U::
count4S  c4p( (countT)&nnSingularity , (countT)&bParams , (countT)&idComputer , (countT)&swNicName ) ;
switchC swNicName( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idComputer , 0 , sizeof( nicNameC ) ) ;
ZE( countT , idComputer ) ;
batonC bParams( tinP , TAG( TAGiDnULL ) ) ;
nicNameC nnSingularity ;

//CONoUTrAW( "main/5\r\n" ) ; //U::
TELL( "preparing for work" ) ;
TODO

DONE( tmLoadSilentF )
}
    b_pnnSilent.ungrabF( tinP ) ;
    cnnSilent = 0 ;
    etThread.delF( tinP , pnnSilent ) ;
    b_pnnSilent.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        ether.osSleepF( tinP , TOCK * 0x10 ) ;

        etThread.delF( tinP , psttAll ) ;
        }
            etThread.delF( tinP , pstt1Lines ) ;
            b_pnnSilent.ungrabF( tinP ) ;
            }
                etThread.delF( tinP , psttnn ) ;
                etThread.strokeF( tinP , T("i will silently ignore: ")+T(pnnSilent[off-1])+T(" (\"")+T(psttnn)+T("\")\r\n") ) ;
                pnnSilent[ off ++ ] = etThread.strDigitsToNicNameF( tinP , psttnn ) ;
                etThread.strWordF( tinP , psttnn , psttc1 , sttq , S1C(';') ) ; ___( psttnn ) ;
                ZE( strokeS* , psttnn ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            {
            FORsTRINGSiN1( pstt1Lines )
            ZE( countT , off ) ;
            etThread.newF( tinP , LF , pnnSilent , cnnSilent ) ; ___( pnnSilent ) ;
            cnnSilent = etThread.strWordsOldF( tinP , pstt1Lines , psttAll , sttq , T("\r\n") ) ; ___( pstt1Lines ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1Lines ) ;

            cnnSilent = 0 ;
            etThread.delF( tinP , pnnSilent ) ;

            b_pnnSilent.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( psttAll )
        bFile.ungrabF( tinP ) ;
        etThread.boxGetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF( tinP , psttAll , T("///d/ideafarm.")+TF1(etherC::ifc_idHomeI_IF())+T(".setting.keyValue.nnSilent") ) ; ___( psttAll ) ;
        bFile.grabF( tinP , TAG( TAGiDnULL ) ) ;
        batonC bFile( tinP , TAG( TAGiDnULL ) , T("setting.keyValue.nnSilent") ) ;
        ZE( strokeS* , psttAll ) ;
    {
    while( !etThread && !ether )

    countT&    cnnSilent   =    *(countT*)pTaskP->c3 ;
    nicNameC*& pnnSilent   = *(nicNameC**)pTaskP->c2 ;
    batonC&    b_pnnSilent =    *(batonC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmLoadSilentF )
//DUPLICATED CODE: 1030168 2540104

DONE( tmHireF )

//ether.osThread AdamF( tinP , ifcIDaDAM_HOMEfLAGS ) ;
ether.ifcHireF( tinP , T("U::TO FIND A WINDOWS RESOURCE LEAK") , ifcIDaDAM_HOMEfLAGS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; //U:: TO FIND A WINDOWS RESOURCE LEAK

TASK( tmHireF ) // SEPARATE THREAD BECAUSE HIRING REQUIRES DNS TO BE ACTIVE : COMMENT PROBABLY OBSOLETE

STATE0

}
    }
        stsRepliesP << ps ;

        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // cSerial
        *ps << (countT)0 ; // cSerial
        *ps << psttEmailP ;
        *ps << psttNsP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_SOA ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_SOA_F( tinS& tinP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttNsP , const strokeS* const psttEmailP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_NS ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_NS_F( tinS& tinP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;
        *ps << (countT)0 ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_MX ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_MX_F( tinS& tinP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_A ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_A_F( tinS& tinP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )

/*PRODUCTION*/ /*1*/WAKEhIDE( "ifcIDaDAM_DNS.port.53.dns" )/*1*/

/**/
*/
 i simply map names (many to 1 and 1 to many) into ip addresses and tell the client to not cache
i do not use the canonical name concept
 initially, this was a copy of 254 for which ifcChat was eliminated since ifcChat is obsoleted by relayC
 2010.12.23: brought back into service for development on laptop after not being used for many years
obsoletes 254
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

