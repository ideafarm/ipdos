
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


// DEADLOCK HOW: 4 THREADS EVERY 2 TOCKS + LOAD BY UPLOADING SNAP
                            
REST

thirdC::third_flagsModeProcess2I_IF(tinP) &= ~( F(flMODEpROCESS2_DEBUG) ) ;
}
    }
        //}
        //    homeS::homeIF().flags |= flHOMEs_FIREtHIShOME ;
        //    CONoUTrAW( "setting flHOMEs_FIREtHIShOME\r\n" ) ;
        //{
        //if( idCycle == 4 )

        //if( !( idCycle % ( TUCK * 0x4 ) ) ) PUSE.walkF( tinP , ifcIDtYPEpOOLoLDwALK_DESTRUCTION , countTC() , flPOOLoLDwALK_INCLUDEdROPSoTHERcLIENTS ) ;
    
        ++ s ; ether.osSleepF( tinP , TOCK * 4 ) ;
    
        }
            while( cToDo -- ) etThread.osThreadF( TaRG1( tmStompF ) ) ;
            countT cToDo = etherC::ifc_idHomeIdisk_IF() > TUCK ? 1 : 0x20 ; //0x40 TO REALLY TEST HARD OR TO SAMEO FAILURES DURING DEBUGGING; 0x10 FOR PRODUCTION; 0x40 REQUIRES cDrops TOCK, WHICH CAUSES LOTS OF PAGING
            //countT cToDo = 0x8 ;
            //LOGrAW3( "\r\nLAUNCH " , idCycle , "\r\n" ) ;
            //CONoUTrAW3( "\r\nLAUNCH " , idCycle , "\r\n" ) ;
            //LOGrAW( "LAUNCHING STOMP THREAD\r\n" ) ;
            //etThread.beeClickF( tinP ) ;
            cSuppressed = 0 ;
            //etherC::ether_cUtility_IF( tinP ) = 0 ; //U::TO FIND A BUG
        {
        else
        }
            }
                LOGrAW3( "\r\nSUPPRESS " , idCycle , "\r\n" ) ;
                CONoUTrAW3( "\r\nSUPPRESS " , idCycle , "\r\n" ) ;
                //LOGrAW( TT(timeN1,timeN2)+T(": tmStompF launches suppressed because i currently have ")+TF2(cKids,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" kid threads\r\n") ) ;
            {
            if( cSuppressed <= 8 )
            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
            ++ cSuppressed ;
            //etherC::ether_cUtility_IF( tinP ) = 1 ; //U::TO FIND A BUG
        {
        if( cKids > 0x10 )
        countT cKids = tinP.cKidThreads ;
    
        //}
        //    }
        //        etThread.newF( tinP , LF , pbLeak , 1 ) ; ___( pbLeak ) ; //INTENTIONAL LEAK, TO TEST LEAK LOGGER
        //        ZE( byteT* , pbLeak ) ;
        //    {
        //    _IO_
        //{
    
        ++ idCycle ;
    {
    _IO_
{
while( !ether )
ZE( countT , cSuppressed ) ;
ZE( countT , idCycle ) ;
sleepC s( tinP , TAG( TAGiDnULL ) ) ;
thirdC::third_flagsModeProcess2I_IF(tinP) |= flMODEpROCESS2_DEBUG ;
//STOMP ON HTTP SERVER

//}
//    }
//        else { LOGrAW( "not blammoing cause have been fired\r\n" ) ; }
//        }
//            BLAMMO ;
//            LOGrAW( "blammoing\r\n" ) ;
//        {
//        if( !ether )
//        ++ s ; ether.osSleepF( tinP , TICK ) ;
//        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
//        LOGrAW( "sleeping before blammoing\r\n" ) ;
//
//        etThread.diskFileOrDirDeleteF( tinP , tFile ) ;
//        LOGrAW( "deleting ideafarm.blammo\r\n" ) ;
//    {
//    if( etThread.diskFileExistsF( tinP , tFile ) )
//    LOGrAW( "looking for ideafarm.blammo\r\n" ) ;
//    TN( tFile , "///d/ideafarm.blammo" ) ;
//{

//}
//    byteT* pb2 = PUSE.newF( tinP , LF , 1 ) ; //SHOULD BLAMMO
//    byteT* pb1 = PUSE.newF( tinP , LF , 1 ) ; //INTENTIONALLY NOT TAGGED
//{

//}
//    etThread.delF( tinP , postr ) ;
//    LOGrAW( postr ) ;
//    LOGrAW( "GORILLA: memory readability map:\r\n" ) ;
//    etherC::ifcBitDumpIF( tinP , postr , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;
//    etThread.newF( tinP , LF , postr , cbaNeeded ) ; ___( postr ) ;
//    ZE( osTextT* , postr ) ;
//    
//    LOGrAW3( "[cbaNeeded]: " , cbaNeeded , "\r\n" ) ;
//    countT cbaNeeded = etherC::ifcBitDumpIF( tinP , 0 , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;
//    countT cbGrain = thirdC::osMemoryReadabilityMapIF( tinP , pbBits , sizeof pbBits ) ;
//    
//{
//DISPLAY A MEMORY READABILITY MAP

etherC::loafIF( tinP ) ;

//else etherC::loafIF( tinP ) ;
//}
//    homeS::homeIF().flags |= flHOMEs_FIREtHIShOME ;
//    CONoUTrAW( "setting flHOMEs_FIREtHIShOME\r\n" ) ;
//{
//if( /*etherC::ifc_idHomeIdisk_IF() > 1 &&*/ etherC::ifc_idHomeIdisk_IF() < TUCK )

//}
//    CONoUTrAW( T("[idAccount,email]: ")+TF3(idAccount,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+tEmailFoo+T("\r\n") ) ;
//    sIn >> idAccount ;
//    ZE( countT , idAccount ) ;
//
//    __( idFormat - 1 ) ;
//    sIn >> idFormat ;
//    ZE( countT , idFormat ) ;
//
//    __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
//    sIn >> finger ;
//    ZE( countT , finger ) ;
//
//    sock.readF( tinP , sIn ) ;
//    soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
//
//    sock.writeF( tinP , sOut ) ;
//
//    sOut << (strokeS*)tEmailFoo ;
//    sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKiDaCCOUNTfROMeMAIL ;
//    sOut << (countT)1 ;
//    sOut << (countT)FINGERnEG_LISTsERVERcMD ;
//    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
//
//    TN( tEmailFoo , "foo@goo.com" ) ;
//
//    sock.connectF( tinP , homeS::homeIF().idPortListServerEmailIdAccount ) ;
//    socketC sock( tinP , etThread , TAG( TAGiDnULL ) ) ;
//
//    if( POOP ) break ;
//    __( !homeS::homeIF().idPortListServerEmailIdAccount ) ;
//{
//while( !ether && !etThread )
//TEST idAccount QUERY
 
//U:: etThread.osThreadAdamF( tinP , ifcIDaDAM_GORILLAlISTS ) ; //PRODUCTION

TODO

byteT pbBits[ TUCK << 4 ] ;

DONE( tmStompF )
}
    }
        }
            CONoUTrAW( "tmStompF/FAIL\r\n" ) ;
            POOPR
        {
        else
        if( !POOP ) { CONoUTrAW( "tmStompF/pass\r\n" ) ; }
    
        }
            etThread.delF( tinP , postBody ) ;
            }
                postBody[ costBody ] = 0 ;
                countT costActual = sockc.readF( tinP , postBody , costBody ) ;
            {
            if( postBody )
            etThread.newF( tinP , LF , postBody , costBody + 1 ) ; ___( postBody ) ;
            ZE( osTextT* , postBody ) ;
        {
        if( !POOP )
        __Z( costBody ) ;
    
        }
            }
                etThread.delF( tinP , pstt1w ) ;
                }
                    }
                        else if( !etThread.strCompareF( tinP , tContentLength , psttc1 ) ) bArmed = 1 ;
                        }
                            break ;
                            costBody = etThread.strDigitsToSCountF( tinP , psttc1 , 0xa , 1 ) ;
                        {
                        if( bArmed )
                    {
                    FORsTRINGSiN1( pstt1w )
                    ZE( boolT , bArmed ) ;
                {
                else if( cWords == 2 && !costBody )
                }
                    break ;
                    etThread.delF( tinP , pstt1w ) ;
                {
                if( !cWords )
                etThread.delF( tinP , psttLine ) ;
                countT cWords = etThread.strWordsOldF( tinP , pstt1w , psttLine , sttq ) ; ___( pstt1w ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , pstt1w ) ;

                }
                    break ;
                    etThread.delF( tinP , psttLine ) ;
                {
                if( POOP )
                __Z( psttLine ) ;
        
                osTextT ostEscape = sockc.readWoLineF( tinP , psttLine , TOCK ) ; ___( psttLine ) ;
                ZE( strokeS* , psttLine ) ;
            {
            while( !POOP && !ether )
            TN( tContentLength , "Content-Length:" ) ;
        {
        ZE( countT , costBody ) ;
    
        sockc.writeF( tinP , "GET /deadman1 HTTP/1.0\r\n\r\n" ) ;
        sockc.connectF( tinP , 80 , socketC::nicNameIF( tinP , etThread , T("ideafarm.com") ) ) ;
        socketC sockc( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;

        SCOOPS
    {
    IFsCRATCH
{
if( pTaskP )
TASK( tmStompF )

*/
/*

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_ROOTgORILLA" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

