
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
    
        tinP.pAdamGlobal3->_socketC_.grab.ungrabF( tinP ) ;
        pOdometer->cbWrite += tinP.odoSockCbWrite - _odoSockCbWriteOpen ;
        pOdometer->cbRead  += tinP.odoSockCbRead  - _odoSockCbReadOpen  ;
        pOdometer = (sockOdometerS*)&(countT&)*tinP.pAdamGlobal3->_socketC_.pSwOdometer ;
        tinP.pAdamGlobal3->_socketC_.nnLever = nnPeer ;
        tinP.pAdamGlobal3->_socketC_.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        bRead.ungrabF( tinP ) ;
    
        if( idleTimeAllowedRead ) FRESHtIMEaTOMIC( *pEther , timeLathRead.time1 , timeLathRead.time2 )
    
        }
            __( CBlIMITfROMsTUPIDcLIENT <= off ) ;
            off += cba ;
            if( idp ) break ;
            if( idp && !*pEther ) postP[ idp - 1 ] = 0 ;
            }
                if( postd ) idp = postd - postP + 1 ;
                postd = (osTextT*)thirdC::c_strstrIF( tinP , postP , "\r\n\r\n" ) ;
                ZE( osTextT* , postd ) ;
            {
            else
            if( postP[ 0 ] == '\r' && postP[ 1 ] == '\n' ) idp = 1 ;
            ZE( countT , idp ) ;
            if( !cba ) break ;
            postP[ off + cba ] = 0 ;
            countT cba = readF( tinP , postP + off , CBlIMITfROMsTUPIDcLIENT - off , flSOCKETcrEAD_STILLhUNGRYiSoK | flSOCKETcrEAD_JUSToNEmOUTHFUL ) ;
        {
        while( !*pEther )
        ZE( countT , off ) ;
    
        pEther->newF( tinP , LF , postP , CBlIMITfROMsTUPIDcLIENT + 1 ) ; ___( postP ) ;
        if( !csttEstimateP ) csttEstimateP = 0x100 ;
        _IO_
        bRead.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        const countT _odoSockCbWriteOpen = tinP.odoSockCbWrite ;
        const countT _odoSockCbReadOpen  = tinP.odoSockCbRead  ;
    
        }
            }
                return ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL    
        SCOOPP
    {
    inc02AM( cFunctionsPending ) ;
{
/**//*1*/voidT socketC::readToNullLineF( tinS& tinP , osTextT*& postP , countT csttEstimateP )/*1*/
*/
  if the actual line input is longer than this, no error will occur but bad coding style warnings will be generated
  if 0 then 100 is implied
  can be 0
 csttEstimateP
 fConPutP
 postP
arguments
assumption: the multiline message is no more than CBlIMITfROMsTUPIDcLIENT bytes long
this overload is more efficient than the one that returns a string of strokeS's
the terminating "\r\n\r\n" is excluded from the returned string
the end of the message is marked by a line containing no characters
gets one multiline message from the peer
 this function will, in general, read more than it should from the peer socket
U: do not use this function; it does not work correctly
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.1070017.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$readToNullLineF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

