
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cItems ;

    _OUT_

    }
        }
            if( !pstt1FoundP && !pGrabP ) { strFuseF( tinP , pstt1FoundP , T("") , pSoulP , pGrabP , csttExtraP ) ; ___( pstt1FoundP ) ; }

            }
                delF( tinP , psttw ) ;
                }
                    strFuseSeparateF( tinP , pstt1FoundP , psttw , 0 , 0 , pSoulP , pGrabP , cstte ) ; ___( pstt1FoundP ) ;
                    cItems ++ ;
                {
                if( !bDup )

                }
                    }
                        }
                            break ;
                            bDup = 1 ;
                        {
                        if( !strCompareF( tinP , psttc1 , psttw ) )
                    {
                    FORsTRINGSiN1( pstt1FoundP )
                {
                if( pstt1FoundP )
                ZE( boolT , bDup ) ;

                stFound >> psttw ;
                ZE( strokeS* , psttw ) ;
            {
            while( stFound )

            }
                while( !POOP && ~hDown ) ;
                }
                    else if( psttw ) cstte += CSpREFIX + psttw->idAdam ;
                    if( bWoth ) bWoth = 0 ;
                    strokeS* psttw = (strokeS*)stFound.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                boolT bWoth = 1 ;
            {
            if( stFound )
            countT cstte = csttExtraP ;

            delF( tinP , psttPath ) ;
            }
                }
                    diskFindFileOrDirF( tinP , psttA , handle , psttPath , pPatternP ) ; ___( psttA ) ;

                    }
                        break ;
                        if( ~handle ) handle.closeIfF() ;
                    {
                    if( ( tinP.pcQuit && *tinP.pcQuit ) || ( cMaxP && !cRem ) )

                    else delF( tinP , psttA ) ;
                    }
                        if( cRem ) cRem -- ;
                        stFound << psttA ; psttA = 0 ;
                    {
                    if( !bDots )

                    }
                        delF( tinP , psttw ) ;
                        ;
                            !strCompareF( tinP , psttw , T(".") )
                            !strCompareF( tinP , psttw , T("..") ) ||
                        bDots = 

                        strWordF( tinP , psttw , psttA , sttq , S1C('/') , - 1 - bDir ) ; ___( psttw ) ;
                        ZE( strokeS* , psttw ) ;
                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;

                        boolT bDir = psttA && psttA[ CSpREFIX - 1 + psttA->idAdam ].idAdam == '/' ;
                    {
                    ZE( boolT , bDots ) ;
                    //if( !( cRem % TUCK ) ) { CONoUTrAW( "." ) ; }
                {
                while( psttA )
                countT cRem = cMaxP ;

                diskFindFileOrDirF( tinP , psttA , handle , psttPath , pPatternP ) ; ___( psttA ) ;
                ZE( strokeS* , psttA ) ;
                handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {
            else
            }
                }
                    if( ( tinP.pcQuit && *tinP.pcQuit ) || ( cMaxP && !cRem ) ) break ;
                
                    }
                        DEL( pInfoDisk ) ;
                        }
                            delF( tinP , psttPath2 ) ;
                            cRem   -= cFoundHere ;
                            delF( tinP , pstt2Found ) ;
                            }
                                stFound << psttv ;
                                strokeS* psttv = psttOldC( tinP , *this , psttc2 ) ; ___( psttv ) ; //U::O: CONVERT THIS FUNCTION TO TAKE A stackC PARAMETER, AND WRITE AN OVERLOAD WRAPPER TO RETURN A STRING OF STRINGS
                            {
                            FORsTRINGSiN2( pstt2Found )
                            countT cFoundHere = diskFindFileOrDirF( tinP , pstt2Found , psttPath2 , pPatternP , pSoulP , pGrabP , csttExtraP , cRem ) ; ___( pstt2Found ) ;
                            ZE( strokeS* , pstt2Found ) ;
                            delF( tinP , psttTmp ) ;
                            strFuseF( tinP , psttPath2 , psttTmp ) ; ___( psttPath2 ) ;
                            strSubstringF( tinP , psttTmp , idf , idLathI , psttPath ) ; ___( psttTmp ) ;
                            ZE( countT , idLathI ) ;
                            countT idf = 5 ;
                            ZE( strokeS* , psttTmp ) ;
                            strMakeF( tinP , psttPath2 , psttDisk , psttPath ? psttPath->idAdam : 0 ) ; ___( psttPath2 ) ;
                            ZE( strokeS* , psttPath2 ) ;
                        {
                        if( pInfoDisk->bLocal )
                    {
                    if( pInfoDisk )

                    }
                        if( POOP ) { POOPRqUIET ; }
                        tinP.pEtScratch->diskInfoF( tinP , pInfoDisk , psttDisk , 1 ) ; ___( pInfoDisk ) ; //U::NOT IN HERE
                        SCOOPS
                    {
                    ZE( infoDiskS* , pInfoDisk ) ;
                {
                for( psttDisk[ CSpREFIX + 3 ] = S1C('c') ; psttDisk[ CSpREFIX + 3 ] <= S1C('z') ; ++ psttDisk[ CSpREFIX + 3 ] )

                countT cRem = cMaxP ;
                psttDisk[ CSpREFIX + 3 ] = 0 ;
                psttDisk[ CSpREFIX + 2 ] = '/' ;
                psttDisk[ CSpREFIX + 1 ] = '/' ;
                psttDisk[ CSpREFIX     ] = '/' ;
                SETpREFIX( psttDisk , 4 ,0 ) ;
                strokeS psttDisk[ CSpREFIX + 4 ] ;
            {
            else if( psttPath && ( psttPath[ CSpREFIX + 3 ] == S1C('*') || psttPath[ CSpREFIX + 3 ] == S1C('?') ) )
            if( POOP ) ;

            else { diskMapFileNameF( tinP , psttPath , psttPathP ) ; ___( psttPath ) ; }
            }
                strFuseF(            tinP , psttPath , psttPathP ) ; ___( psttPath ) ;
            {
            )
                )
                    )
                       && psttPathP[ CSpREFIX + 4 ] == S1C('/')
                          psttPathP[ CSpREFIX + 3 ] != S1C('/')           // LOCAL MAPPED NAME OF FORM "///d/path/short"
                    (
                    ||
                    )
                       && psttPathP[ CSpREFIX + 4 ] != S1C('/')
                          psttPathP[ CSpREFIX + 3 ] == S1C('/')           // NETBIOS      NAME OF FORM "////netbios/d/path/short"
                    (
                (
                &&
                && psttPathP[ CSpREFIX + 2 ] == S1C('/')
                && psttPathP[ CSpREFIX + 1 ] == S1C('/')
                && psttPathP[ CSpREFIX     ] == S1C('/')
                   psttPathP->idAdam > 5
            (
            if
            ZE( strokeS* , psttPath ) ;
        {
        stackC stFound( tinP , third , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
    {
    IFsCRATCH
    ZE( countT , cItems ) ;

    _INoLD_

    }
        if( POOP ) return 0 ;
        __( psttPathP->idCaste != sc_PREFIXlENGTH ) ;
        __( psttPathP->idAdam < 6 ) ;
        if( POOP ) return 0 ;
        __Z( psttPathP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/countT etherC::diskFindFileOrDirF( tinS& tinP , strokeS*& pstt1FoundP , const strokeS* const psttPathP , const patternC* pPatternP , soulC* pSoulP , grabC* pGrabP , const countT csttExtraP , const countT cMaxP )/*1*/

/**/
*/
  if not 0, then is the maximum number of matching files to report in pstt1FoundP
  can be 0
 cMaxP
 csttExtraP
  must not specify a root directory, e.g. T("///x/")
  must not be 0
 psttPathP
  if no files are found, pstt1FoundP will be set to the null string
   use the FORsTRINGSiN1 macro to obtain each string
  will contain a string of strings
   a file will not be included in the append if it is already present in the list
  if not 0 then must be a string of strings, and my results will be appended
  can be 0 or not 0
 pstt1FoundP
arguments
i will not 
 if i quit early for this reason, my results are useable but incomplete
i will silently quit early if *tinP.pcQuit
if a wildcard ("*" or "?") is specified for the disk, remote drives are excluded from the search
evaluates to the number of files found
  \<A HREF=\"5.b210104.1.1.0.html\"\>b210104:  WAKEsHOW( "example.simplest.func.103001c.etherC.diskFindFileOrDirOldF" )\</A\>
 simplest
examples
\<A HREF=\"5.103001c.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$diskFindFileOrDirOldF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

