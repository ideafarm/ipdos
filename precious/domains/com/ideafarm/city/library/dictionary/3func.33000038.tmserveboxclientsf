
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmServeBoxClientsF )

}
    DEL( pso ) ;
    TELL( "cleaning up: final" )
    __( pso->readF( tinP , &bnu , 1 , flSOCKETcrEAD_STILLhUNGRYiSoK ) ) ; // PEER WILL NEVER WRITE A BYTE, BUT WILL CLOSE CONN INSTEAD
    TELL( "cleaning up: waiting for client to disconnect" )
    ZE( byteT , bnu ) ;
    etThread.delF( tinP , psttList ) ;
    }
        if( bTalk ) etThread.strokeF( tinP , T("\r" BLANK79 "\r") ) ;
        }
            etThread.delF( tinP , pbAll ) ;
            pso->writeF( tinP , pbAll , cbAll ) ;
            __Z( cbAll ) ;
        {
        else
        }
            __( cbAll ) ;
        {
        if( !pbAll )
        pso->writeF( tinP , (byteT*)&cbAll , sizeof cbAll ) ;
        if( bTalk ) etThread.strokeF( tinP , T("Sending aggregate.") ) ;

        while( p1Root ) delete p1Root ; // DO NOT USE DEL HERE

        }
            }
                p1c = p1c->pR ;

                }
                    pbc += p1c->cbd ;
                    etThread.memCopyF( tinP , pbc , p1c->pbd , p1c->cbd ) ;
                {
                if( p1c->pbd )

                pbc += sizeof p1c->cbd ;
                etThread.memCopyF( tinP , pbc , (byteT*)&p1c->cbd , sizeof p1c->cbd ) ;
            {
            while( p1c )
            pbc = pbAll ;
            ZE( byteT* , pbc ) ;
            p1c = p1Root ;

            etThread.newF( tinP , LF , pbAll , cbAll ) ; ___( pbAll ) ;
            }
                p1c = p1c->pR ;
                cbAll += p1c->cbd ;
                cbAll += sizeof p1c->cbd ;
            {
            while( p1c )
            p1c = p1Root ;
            ZE( link189S* , p1c ) ;
        {

        }
            etThread.delF( tinP , psttw ) ;

            if( bTalk ) etThread.strokeF( tinP , T("\r\n") ) ;

            }
                }
                    if( POOP ) POOPR
                    if( POOP && bTalk ) etThread.strokeF( tinP , T(" (does not exist)") ) ;
                    if( p1c ) { box.getF( tinP , p1c->pbd , p1c->cbd ) ; ___( p1c->pbd ) ; } // SHOULD ALWAYS BE TRUE
                    boxC box( tinP , *tinP.pEtScratch , psttw , 0 , 0 , 0 , 1 ) ;
                {
                if( bTalk ) etThread.strokeF( tinP , psttw ) ;
                SCOOPS
            {
            IFsCRATCH

            }
                etThread.delF( tinP , psttFileId ) ;
                if( bTalk ) etThread.strokeF( tinP , T(psttFileId)+T("\t") ) ;
                etThread.strFromF( tinP , psttFileId , ++ fileId ) ; ___( psttFileId ) ;
                ZE( strokeS* , psttFileId ) ;
            {

            }
                }
                    }
                        p1c = p1c->pR ;
                        p1c->pR->pL = p1c ;
                    {
                    if( p1c->pR )
                    p1c->pR = new( 0 , tinP , LF ) link189S( etThread , p1Root ) ; ___( p1c->pR ) ;
                {
                if( p1c ) // SHOULD ALWAYS BE TRUE
                while( p1c && p1c->pR ) p1c = p1c->pR ;
                p1c = p1Root ;
            {
            else
            }
                p1c = p1Root = new( 0 , tinP , LF ) link189S( etThread , p1Root ) ; ___( p1Root ) ; ___( p1Root ) ;
            {
            if( !p1Root )
            ZE( link189S* , p1c ) ;

            if( idl ) idf ++ ;
            etThread.strSubstringF( tinP , psttw , idf , idl , psttList ) ; ___( psttw ) ;
            ZE( strokeS* , psttw ) ;
            }
                sttq = sttqs ;
                idf = idfs ;
                if( idl > 1 ) idl -- ;
                __( idl == 1 ) ;
                idl = etThread.strIdF( tinP , idf , sttq , S1C(' ') , psttList ) ;
                strokeS sttqs = sttq ;
                countT idfs = idf ;
            {
        {
        while( idf )
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        ZE( countT , idl ) ;
        countT idf = 1 ;
        ZE( link189S* , p1Root ) ;
        ZE( countT , fileId ) ;
        batonC bFileId( tinP , TAG( TAGiDnULL ) ) ;
        // ALLOCATE p1Root TO POINT TO A CHAIN OF LINKS CONTAINING THESE BOXES

        ZE( countT , cbAll ) ;
        ZE( byteT* , pbAll ) ;
        TELL( "processing wo line of a received strokeS string" )
    {
    else
    }
        pso->writeF( tinP , (osTextT*)T("ok") ) ;
        TELL( "writing ack to \"!quit\"" )
        etThread.etherFireImpersonateMonitorIF( tinP ) ;
    {
    if( !etThread.strCompareF( tinP , psttList , T("!quit") ) )
    pso->readWoLineF( tinP , psttList , 0x10000 ) ; ___( psttList ) ;
    TELL( "reading wo line of a strokeS string" )
    ZE( strokeS* , psttList ) ;

    pso->etherF( tinP , etThread ) ;
    boolT  bTalk =           pTaskP->c2 ;
    socketC* pso = (socketC*)pTaskP->c1 ;
    TELL( "setting up" )
{
if( !etThread )
__( !pTaskP || !pTaskP->c1 ) ;
/*1*/TASK( tmServeBoxClientsF )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

