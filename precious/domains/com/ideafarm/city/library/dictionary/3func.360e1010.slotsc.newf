
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbo ;

    THREADmODE1rESTORE
    }
        ++ s ; thirdC::dosSleepRWinkIF( tinP ) ;

        if( pbo || F(flagsP) & flSLOTScnEW_DOnOTbLOCK ) break ;

        }
            }
                inc02AM( pcTallyOut[ offs ] ) ;
                pGrabNewElt[ offs ].ungrabF( tinP ) ; // -------------------------------------------------------------------------------------------------

                ppSex[ offs ] = pSexNew ;

                                               pPoolContainsMe->pSexLifoConstructed = pSexNew ;
                pSexNew->pSexLifoConstructed = pPoolContainsMe->pSexLifoConstructed           ;

                }
                    POSTPONEtEST( pbo ) ;
                    dropHeader = dropHeader << CbITSeXPsLOTS | ( offs - expSlotsMin ) ;
                    BLAMMOiFcANNOTsHIFTlEFT( dropHeader , CbITSeXPsLOTS ) ;
                    countT& dropHeader = ((countT*)pbo)[ - 1 ] ;
                {
                if( pbo )

                //20180509@1131:  WHEN sexC NESTING IS DISABLED, sexC INSTANCES CAN BE CONSTRUCTED WITH NO SLOTS AVAILABLE, SO CANNOT DO THIS:  if( !pbo ) { BLAMMO ; } // TO MAKE SURE THAT sexC::sexC SETS IMPOTENCE IF IT FAILS FOR EITHER REASON (RECURSION OR INSUFFICIENT CONTIGUOUS MEMORY)
                pbo = pSexNew->newF( tinP , idLineP , idiFileP ) ;
            {
            else //U::BUG: SHOULD BE "else if( pSexNew )"
            }
                inc02AM( pcTallyOut[ offs ] ) ;
                pGrabNewElt[ offs ].ungrabF( tinP ) ; // -------------------------------------------------------------------------------------------------
                DELzOMBIE( pSexNew ) ;
            {
            if( pSexNew && (const poopC&)*pSexNew ) // *pSexNew CT FAILED, EITHER BECAUSE IT DETECTED THAT IT CT'D ITSELF RECURSIVELY OR BECAUSE INSUFFICIENT CONTIGUOUS MEMORY IS AVAILABLE

            sexC* pSexNew = new( 0 , tinP , pbzaUse , sizeof( sexC ) ) sexC( tinP , TAG( TAGiDnULL ) , idLineP , idiFileP , ostoName , expCbSlot , offs , flagsc , idStateSpace , idMemorySpace , pPoolContainsMe ) ;

            if( pbzaUse == (byteT*)ppSex[ offs ] ) { BLAMMO ; }
            byteT* pbzaUse = ( !bNested ? pbza1 : pbza2 ) + offs * sizeof( sexC ) ;

            OStEXTCF( ostoName , offs , '0' ) ;
            OStEXTAK( ostoName , ".slotsC.sex." ) ;
            OStEXTA(  ostoName , postName ) ;
            OStEXT(   ostoName , TUCK << 2 )

            boolT bNest2 = !!( tinP.fliSexCtPendingExpSlots  & maskExpSlots  ) ;
            boolT bNest1 = !!( tinP.fliSexCtPendingExpCbSlot & maskExpCbSlot ) ;
            const flagsT maskExpSlots  = 1 << offs      ;
            const flagsT maskExpCbSlot = 1 << expCbSlot ;

            //if( bNested > 1 ) { BLAMMO ; }
            //countT bNested = pGrabNewElt[ offs ].cGrabbedF() - 1 ;
            //20170928@1030: DISABLED WITHOUT ANALYIS TO WORKAROUND: SEE PRECEDING CODE THAT NOW MERELY CONTNINUES THE LOOP

            }
                continue ;
                offPass = - 1 ;
                inc02AM( pcTallyOut[ offs ] ) ;
                pGrabNewElt[ offs ].ungrabF( tinP ) ; // --------------------------------------------------------------------------------------------
            {
            if( ppSex[ offs ] )

            }
                continue ;
                offPass = - 1 ;
                inc02AM( pcTallyOut[ offs ] ) ;
                pGrabNewElt[ offs ].ungrabF( tinP ) ; // --------------------------------------------------------------------------------------------
            {
            if( bNested > 1 )
            countT bNested = pGrabNewElt[ offs ].cGrabbedF() - 1 ;              //20170928@1030: ADDED WITHOUT ANALYIS TO WORKAROUND: SEE THE COMMENTED OUT BLAMMO CODE THAT FOLLOWS

            inc02AM( pcTallyIn[ offs ] ) ;
            pGrabNewElt[ offs ].grabF( tinP , TAG( TAGiDnULL ) ) ; // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

            }
                break ;
                inc02AM( pcTallyOut[ offs ] ) ;

                }
                    continue ; // INTENTIONALLY NOT SERIALIZED, FOR SPEED.  WILL BE RECHECKED WITHIN SERIALIZED BLOCK OF CODE
                    inc02AM( pcTallyOut[ offs ] ) ;
                {
                if( ppSex[ offs ] )
                inc02AM( pcTallyIn[ offs ] ) ;
            {
            for( ; offs < sizeof ppSex / sizeof ppSex[ 0 ] ; offs ++ )
            countT offs = expSlotsMin ;                                         //ALLOCATE THE SMALLEST UNALLOCATED EXTENT

            if( F(flagsCt) & flSLOTSc_NOTES    ) flagsc |= fliSEXc_NOTES    ;
            if( F(flagsCt) & flSLOTSc_READoNLY ) flagsc |= fliSEXc_READoNLY ;
            if( F(flagsCt) & flSLOTSc_BROWSE   ) flagsc |= fliSEXc_BROWSE   ;
            flagsT flagsc = fliSEXc_null ;
        {
        if( !( F(flagsP) & flSLOTScnEW_DOnOTcTsEXc ) )

        if( pbo ) break ;

        }
            inc02AM( pcTallyOut[ offs ] ) ;
            }
                }
                    break ;
                    inc02AM( pcTallyOut[ offs ] ) ;

                    POSTPONEtEST( pbo ) ; //20140604@1949: ONLY DO THIS IF pbo

                    dropHeader = dropHeader << CbITSeXPsLOTS | ( offs - expSlotsMin ) ;
                    BLAMMOiFcANNOTsHIFTlEFT( dropHeader , CbITSeXPsLOTS ) ;
                    countT& dropHeader = ((countT*)pbo)[ - 1 ] ;
                {
                if( pbo )

                pbo = ppSex[ offs ]->newF( tinP , idLineP , idiFileP ) ;
            {
            if( ppSex[ offs ] )
            inc02AM( pcTallyIn[ offs ] ) ;
        {
        for( sCountT offs = sizeof ppSex / sizeof ppSex[ 0 ] - 1 ; - 1 + (sCountT)expSlotsMin < offs ; offs -- )

        if( offPass > 1 ) { BLAMMO ; }
    {
    for( countT offPass = 0 ; ; offPass ++ ) //IF !flSLOTScnEW_DOnOTbLOCK, WILL BLOCK UNTIL SUCCEED IN GETTING A DROP ALLOCATED

    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    ZE( byteT* , pbo ) ;
    //THIS ENCOURAGES DENSITY SO REDUCES PAGING
    //USE THE LARGEST AVAILABLE SEX TO ALLOW SMALLER EXTENTS TO BECOME EMPTY AND BE DELETED
    if( F(flagsCt) & flSLOTSc_READoNLY ) { BLAMMO ; }
    if( F(tinP.flagsThreadMode2) & flTHREADmODE2_DISALLOWpUSE ) { BLAMMO ; }
    _IO_

    }
        if( POOP ) return 0 ;
        FV( flSLOTScnEW , flagsP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL                 //20131223@1504: ADDED WITHOUT ANALYSIS; BEFORE, I WOULD DO WORK EVEN IF POOP
{
/*1*/byteT* slotsC::newF( tinS& tinP , const countT idLineP , const countT idiFileP , const flagsT flagsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

