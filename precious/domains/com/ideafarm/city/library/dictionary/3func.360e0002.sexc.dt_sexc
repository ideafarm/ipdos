
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        DELzOMBIE( pDoomed ) ;
        pDoomed = (fileC*)pbFileData ;
        DELzOMBIE( pDoomed ) ;
        fileC* pDoomed = (fileC*)pbFileMeta ;
        puseC puse( tinP , ifcIDpOOL_ADAMtEMP ) ;
    {
    if( F(flagsCt) & fliSEXc_MAPPEDtOdISK ) //CLOSING THE BACKING FILES BEFORE DELETING THE SHARED MEMORY THAT IS MAPPED TO THEM IS OK ACCORDING TO WIN32 DOC

    }
        //U:: pbMeta IS BACKED BY A DATABASE LISTING THAT SHOULD BE DELETED IF I AM THE ONLY REFERENCE TO IT
    {
    else
    }
        DELzOMBIE( pnDoomed ) ;
        napkinC* pnDoomed = (napkinC*)pb_napMeta ;
    {
    if( F(flagsState) & flSEXcsTATE_USINGnAPfORmETA )

    }
        DELzOMBIE( pnDoomed ) ;
        napkinC* pnDoomed = (napkinC*)pb_napData ;
    {
    if( F(flagsState) & flSEXcsTATE_USINGnAPfORdATA )

    //------------------------------------------------------------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        }
            DELzOMBIE( pzMetaHead ) ;

            }
                }
                    //if( cLeaks ) BOSnOvALUE( WHATsn , OS sLEEPf( -1 ) )

                    }
                        }
                            //}
                            //    LOGrAW( "\"\r\n" ) ;
                            //    LOGrAW( postBuf ) ;
                            //    LOGrAW( "content: \"" ) ;
                            //
                            //    CONoUTrAW( "\"\r\n" ) ;
                            //    CONoUTrAW( postBuf ) ;
                            //    CONoUTrAW( "content: \"" ) ;
                            //
                            //    *posto = 0 ;
                            //    while( cDo -- ) *( posto ++ ) = ( pstti ++ )->idAdam ;
                            //    countT cDo = ((strokeS*)pbx)->idAdam ;
                            //    osTextT* posto = postBuf ;
                            //    strokeS* pstti = (strokeS*)pbx + CSpREFIX ;
                            //    osTextT postBuf[ TUCK << 2 ] ;
                            //{
                            //COMMENT OUT IN PRODUCTION.  CODE LIKE THIS CAN BE USED TO FIND LEAKS: strokeS STRING

                            //}
                            //    LOGrAW( "\r\n" ) ;
                            //    LOGrAW( pbx ) ;
                            //    //LOGrAW( "content: \"" ) ;
                            //
                            //    CONoUTrAW( "\r\n" ) ;
                            //    CONoUTrAW( pbx + offx ) ;
                            //    //CONoUTrAW( "content: \"" ) ;
                            //
                            //    countT offx = thirdC::c_strstrIF( pbx , postTest ) == pbx ? sizeof postTest - 1 : 0 ;
                            //    static osTextT postTest[] = POSThHOMEdRIVE ":\\ideafarm.home.1\\ephemeral\\backed.up.daily\\domains\\com\\ideafarm\\ipdos\\memorySpaces\\ifo20111122\\4\\stateSpaces\\" ;
                            //{
                            //if( pzMetaNote[ offs ].idLineTagged == 0x5f )
                            //COMMENT OUT IN PRODUCTION.  CODE LIKE THIS CAN BE USED TO FIND LEAKS: osTextT STRING

                            LOGrAW(    ostoSay ) ;
                            CONoUTrAW( ostoSay ) ;

                            OStEXTAK( ostoSay , "\r\n" ) ;
                            }
                                OStEXTC(  ostoSay , idName , 0 ) ;
                                OStEXTAK( ostoSay , " listC: " ) ;
                            {
                            if( idName )
                            OStEXTAK( ostoSay , ")" ) ;
                            OStEXTC(  ostoSay , pzMetaNote[ offs ].idLineTagged2 , 0 ) ;
                            OStEXTAK( ostoSay , "(" ) ;
                            OStEXTC(  ostoSay , pzMetaNote[ offs ].idiFileTagged2 , 0 ) ;
                            OStEXTAK( ostoSay , ") " ) ;
                            OStEXTC(  ostoSay , pzMetaNote[ offs ].idLineTagged , 0 ) ;
                            OStEXTAK( ostoSay , "(" ) ;
                            OStEXTC(  ostoSay , pzMetaNote[ offs ].idiFileTagged , 0 ) ;
                            OStEXTAK( ostoSay , " " ) ;
                            OStEXTC(  ostoSay , pbx , '0' ) ;
                            OStEXTAK( ostoSay , "\" leak: " ) ;
                            OStEXTA(  ostoSay , pzMetaHead->postName ) ;
                            OStEXTAK( ostoSay , "\"" ) ;
                            OStEXT(   ostoSay , TUCK << 1 ) ;

                            ;
                                : 0
                                ? ((listC*)pbx)->nameF()
                            countT idName = listingC::bIsListingIF( tinP , (listingC*)pbx , fliLISTINGc_MIXINlIST )
                            byteT* pbx = pbData + offs * cbSlot + CBsEXdROPhEADER ;

                            cLeaks ++ ;
                        {
                        if( bOwned )

                        continue ;
                        )
                            offs >= offSlotsUseableEnd 
                            ||
                            offs <  offSlotsUseableBegin
                        (
                        if
                    
                        }
                            mask = 1 ;
                            pbo ++ ;
                        {
                        if( !mask )
                        mask <<= 1 ;
                        boolT bOwned = *pbo & mask ;
                    {
                    for( countT offs = 0 ; offs < cSlots ; offs ++ )

                    ZE( countT , cLeaks ) ;
                    byteT mask = 1 ;
                    byteT* pbo = pbzMetaBitsOwned ;
                    const countT offSlotsUseableEnd   = cSlots - pzMetaHead->cSlotsAvoidHi ;
                    const countT offSlotsUseableBegin =          pzMetaHead->cSlotsAvoidLo ;
                    const countT cSlots = 1 << pzMetaHead->expSlots ;
                    const countT cbSlot = 1 << pzMetaHead->expCbSlot ;
                {
                if( pzMetaNote )

                ;
                    : 0
                    ? (dropNoteS*)( pbzMetaBitsOwned + cbaBitsOwned )
                dropNoteS* pzMetaNote = F(pzMetaHead->flagsCtCopy) & fliSEXc_NOTES

                cbaBitsOwned += CBtOaLIGN02( pbzMetaBitsOwned + cbaBitsOwned ) ;
                countT cbaBitsOwned = 1 + ( 1 << pzMetaHead->expSlots ) / SB ;

                byteT* pbzMetaBitsOwned = (byteT*)( pzMetaHead + 1 ) ;
            {
            if( bFoo )
            boolT bFoo = 1 ;
            //U::IF A FLAG IS SET THEN LOG ALL SLOTS THAT ARE FLAGGED AS OWNED AND, IF NOTE EXISTS, REPORT THE CONTENT OF THE NOTE FOR EACH
        {
        if( 1 == decv02AM( pzMetaHead->cRef ) )

        //------------------------------------------------------------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------------------------------------------------------------

        }
            }
                THREADmODE1rESTORE
    
                decv8AM( pReg->pbSex_cQueue[ offSexBit ] ) ;

                if( !offRef ) { BLAMMO ; } // UNDERFLOW (SHOULD BE IMPOSSIBLE )
                if( offRef == 1 ) btrAM( pReg->pbSexBitFormatted  , offSexBit ) ;
    
                countT offRef = decv8AM( pReg->pbSex_cRef[ offSexBit ] ) ;              // THE VALUES IN MY ELEMENTS REMAIN AND MUST BE CLEARED  BEFORE REUSE

                }
                    ++ s ; thirdC::dosSleepWinkIF( tinP ) ;
                    decv8AM( pReg->pbSex_cQueue[ offSexBit ] ) ;
                {
                while( incv8AM( pReg->pbSex_cQueue[ offSexBit ] ) )
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                const countT offSexBit = pzMetaHead->expCbSlot * CsLOTeXTENTS + pzMetaHead->expSlots ;
            {
            else
            if( !pReg ) { BLAMMO ; }

            }
                }
                    }
                        break ;
                        pReg = pRegs + offr ;
                    {
                    if( !thirdC::c_strcmpIF( tinP , pRegs[ offr ].postPoolName , postPoolName ) )
                {
                for( countT offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )

                const osTextT* postPoolName = pPoolContainsMe->postNameF( tinP ) ;
                poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;
                homeS& home = homeS::homeIF() ;
            {
            ZE( poolRegistrationS* , pReg ) ;
        {
        if( pPoolContainsMe )

        //------------------------------------------------------------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------------------------------------------------------------

        }
            }
                }
                    BLAMMO ;
                    LOGrAW( "sexC::~sexC/i could not find myself in the registry\r\n" ) ;
                {
                if( offe == CsEXeNTRIES )

                grabot.ungrabF( tinP ) ;
                }
                    }
                        break ;
                        if( !( -- pe[ offe ].cRef ) ) thirdC::c_memsetIF( tinP , pe[ offe ].postName , sizeof pe[ offe ].postName ) ;
                    {
                    if( !thirdC::c_strcmpIF( tinP , pe[ offe ].postName , pzMetaHead->postName ) )
                {
                for( ; offe < CsEXeNTRIES ; offe ++ )
                ZE( countT , offe ) ;
                grabot.grabF( tinP , TAG( TAGiDnULL ) ) ;
        
                sexGlobalEntryS* pe = (sexGlobalEntryS*)( pbNapkin + sizeof( grabotC ) ) ;
                grabotC& grabot = *(grabotC*)pbNapkin ;

                grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( pbNapkin )
            byteT* pbNapkin = processGlobal7I._sexC_napGlobalRegistry ;
        {
        if( !thirdC::c_strstrIF( tinP , pzMetaHead->postName , postPOOLlEAKlOGGER ) )

        //------------------------------------------------------------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------------------------------------------------------------

        //}
        //    etherC::etRockIF( tinP ).traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
        //    
        //    OStEXTAK( ostoSay , "\" " ) ;
        //    OStEXTA(  ostoSay , pzMetaHead->postName ) ;
        //    OStEXTAK( ostoSay , " \"" ) ;
        //    OStEXTCF( ostoSay , pbDataEnd , ' ' ) ;
        //    OStEXTAK( ostoSay , " " ) ;
        //    OStEXTCF( ostoSay , pbData , ' ' ) ;
        //    OStEXTA(  ostoSay , F(flagsState) & flSEXcsTATE_USINGnAPfORmETA ? " NAPKIN " : " pool   " ) ;
        //    OStEXTA(  ostoSay , F(flagsState) & flSEXcsTATE_USINGnAPfORdATA ? " NAPKIN " : " pool   " ) ;
        //    OStEXTC(  ostoSay , pzMetaHead->expSlots , ' ' ) ;
        //    OStEXTAK( ostoSay , " " ) ;
        //    OStEXTC(  ostoSay , pzMetaHead->expCbSlot , ' ' ) ;
        //    OStEXTAK( ostoSay , "          " ) ;
        //    OStEXTC(  ostoSay , tinP.pAdamGlobal1->idAdam , ' ' ) ;
        //    OStEXTAK( ostoSay , "---- ~sexC [idAdam                ,expCbSlot,expSlots,n/p,pbData,pbDataEnd,postName]: " ) ;
        //    OStEXT(   ostoSay , TUCK << 2 ) ;
        //{
    {
    if( pzMetaHead )

    //CONoUTrAW( "\"\r\n" ) ;
    //CONoUTrAW( pzMetaHead->postName ) ;
    //CONoUTrAW( "~sexC [postName]: \"" ) ;

    //------------------------------------------------------------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        TELLsYSc3( idTypeSay , (byteT*)&info , sizeof info )
        info.pSex       = this ;
        thirdC::c_strcpyIF( tinP , info.postName , pzMetaHead->postName ) ;
        info.expSlots   = pzMetaHead->expSlots  ;
        info.expCbSlot  = pzMetaHead->expCbSlot ;
        info.osPid      = tinP.osPid ;
        tellInfoSysSexS info ;
        countT idTypeSay = ifcIDtYPEtELLsYS_SEXdT ;
    {

    _IO_

    }
        if( POOP ) return ; // IF CT'OR FAILED, IT IS RESPONSIBLE FOR CLEANING UP 
    {
    IFbEcAREFUL
    SCOOP

    TINSL
{
/*1*/sexC::~sexC( voidT )/*1*/


/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

