
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    }
        { bDebugIsSet = 0 ; CONoUTrAW5( "~inOutFrameC RESET [idIn,pEther]" , idIn , " " , processGlobal4I.tinVeryEarlyLateMain.pEther , "\r\n" ) ; }
        else if(  bDebugIsSet && !processGlobal4I.tinVeryEarlyLateMain.pEther )
        { bDebugIsSet = 1 ; CONoUTrAW5( "~inOutFrameC set   [idIn,pEther]" , idIn , " " , processGlobal4I.tinVeryEarlyLateMain.pEther , "\r\n" ) ; }
        if(      !bDebugIsSet &&  processGlobal4I.tinVeryEarlyLateMain.pEther )

        countT idIn = 1 + incv02AM( idInLath ) ;
        static countT idInLath ;
    {
    if( processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH07 )
    //CS:DUPLICATE: 3612c002 3612c003
    //U:: TO FIND A BUG

    tinP.pInOutFrame = pDad ;

    }
        THREADmODE4rESTORE

        }
            tinP.cCpuCyclesWriteInOutTelemetry += deltaCpuCycles5 ;
            tinP.cTellsWriteInOutTelemetry ++ ;
        {
        if( !( F(flagsCt) & flINoUTfRAMEc_DEFERwRITINGaPPtELEMETRY ) )

        if( pDad ) pDad->audit.dCpuCyclesAuditKidBook += deltaCpuCycles5 ;
        deltaCpuCycles5 -= say.cCpuCycles4 ;
        tinP.cCpuCycles2Or5Lath = deltaCpuCycles5 ; //NOT DELTA YET
        QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&deltaCpuCycles5 ) ;
        count04T deltaCpuCycles5 ;  //INTENTIONALLY UNINITIALIZED FOR SPEED

        }
            THREADmODE4rESTORE
            TELLaPPc3LIFI( ifcIDtYPEtELLaPP_INoUT , (byteT*)&say , sizeof say , idLineCt , idiFileCt )
            THREADmODE4oN( flTHREADmODE4_INoUTfRAMEdEFERwRITINGaPPtELEMETRY ) ;

            }
                CONoUTrAW5( "tell singleton [LF]:    " , idLineCt , " " , idiFileCt , "\r\n" ) ;
            {
            if( processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH07 )    //U:: TO FIND A BUG
        {
        if( !bDone && !( F(flagsCt) & flINoUTfRAMEc_DEFERwRITINGaPPtELEMETRY ) )

        }
            }
                bDone = 1 ;
                pPending[ cPending ++ ] = say ;

                //}
                //    CONoUTrAW7( "tell to pending [LF,cPending(before)]:    " , idLineCt , " " , idiFileCt , "        " , cPending , "\r\n" ) ;
                //{
                //if( processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH07 )    //U:: TO FIND A BUG
            {
            if( cPending < CmAXpENDINGiNoUTfRAMEpACKETS )

            }
                }
                    cPending = 0 ;

                    THREADmODE4rESTORE
                    }
                        thirdC::dosTellMonitorIF( tinP , tell , ifcIDbOOKStELL_APP ) ;
                        tellC tell( tinP , idLineCt , idiFileCt , 0 , ifcIDtYPEtELLaPP_INoUTaRRAY , tinP.pbPendingInOutFramePackets , sizeof( countT ) + cPending * sizeof( tellInfoAppInOutFrameS ) ) ;
                    {
                    THREADmODE4oN( flTHREADmODE4_INoUTfRAMEdEFERwRITINGaPPtELEMETRY ) ;

                    }
                        CONoUTrAW7( "tell [LF,cPending]:    " , idLineCt , " " , idiFileCt , "         " , cPending , "\r\n" ) ;
                    {
                    if( processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH07 )    //U:: TO FIND A BUG
                {
                else if( cPending >= cMax * 7 / 8 )  // 1/8 OF THE CAPACITY IS USED TO ACCUMULATE WHEN I CANNOT EMIT TELEMETRY
                }
                    while( cRemain ) ;
                    }
                        pbc += cbSay - sizeof( countT ) ;   // THIS WILL CAUSE THE LAST countT IN THE RANGE JUST WRITTEN TO BE USED AS cPendingPatch FOR THE NEXT WRITE

                        THREADmODE4rESTORE
                        }
                            thirdC::dosTellMonitorIF( tinP , tell , ifcIDbOOKStELL_APP ) ;
                            tellC tell( tinP , idLineCt , idiFileCt , 0 , ifcIDtYPEtELLaPP_INoUTaRRAY , pbc , cbSay ) ;
                        {
                        THREADmODE4oN( flTHREADmODE4_INoUTfRAMEdEFERwRITINGaPPtELEMETRY ) ;

                        }
                            CONoUTrAW9( "tell [LF,cPendingPatch,cRemain]:    " , idLineCt , " " , idiFileCt , "        " , cPendingPatch , " " , cRemain , "\r\n" ) ;
                        {
                        if( processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH07 )    //U:: TO FIND A BUG

                        countT cbSay = sizeof( countT ) + cPendingPatch * sizeof( tellInfoAppInOutFrameS ) ;
                        cRemain -= cPendingPatch ;
                        if( cPendingPatch > cMax ) cPendingPatch = cMax ;
                        cPendingPatch = cRemain ;
                        countT& cPendingPatch = *(countT*)pbc ;             // THIS CLOBBERS THE LAST countT IN THE DATA WRITTEN IN THE LATH ITERATION
                    {
                    do
                    byteT* pbc = tinP.pbPendingInOutFramePackets ;
                    countT cRemain = cPending ;
                {
                if( cPending > cMax )

                ;
                    : ( CBtELLmAX - sizeof( countT ) ) / sizeof( tellInfoAppInOutFrameS )
                    ? CmAXpENDINGiNoUTfRAMEpACKETS
                countT cMax = tinP.pPoolUse
            {
            if( !( F(flagsCt) & flINoUTfRAMEc_DEFERwRITINGaPPtELEMETRY ) )        // EMIT THE PENDING PACKETS IF I CAN

            tellInfoAppInOutFrameS* pPending = (tellInfoAppInOutFrameS*)( tinP.pbPendingInOutFramePackets + sizeof( countT ) ) ;
            countT&                 cPending =                *(countT*)  tinP.pbPendingInOutFramePackets                      ;
        {
        if( tinP.pbPendingInOutFramePackets )
        ZE( boolT , bDone ) ;

        THREADmODE4oN( flTHREADmODE4_INoUTfRAMEdOnOTcOLLECTaPPtELEMETRY )

        say.dCpuCyclesDt = say.cCpuCycles4 - say.cCpuCycles3 ;

        if( pDad ) pDad->audit.dCpuCyclesAuditKidDt += say.cCpuCycles4 - say.cCpuCycles3 ;
        QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&say.cCpuCycles4 ) ;
        QueryPerformanceCounter( (LARGE_INTEGER*)&say.cTime4 ) ;
    {
    if( !( F(flagsCt) & flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY ) )

//#endif

    //if( tinP.idTinNamed != ifcIDtINnAMED_tinHeartI ) thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG
    tinP.monitor.idWhat1 = idWhat1Save ;_
    processGlobal1I.pcUtility[ 5 ] ++ ; //U::TO FIND A BUG
    processGlobal1I.pcUtility[ 1 ] -- ; //U::TO FIND A BUG

    }
        _MOLE
        tinP.monitor.idWhat2 = idWhat2Save ;_
        }
            //}
            //    }
            //        else                               { BLAMMO ; }
            //        if( tinP.pcLevelUntagged[ offi ] ) tinP.pcLevelUntagged[ offi ] -- ;_
            //    {
            //    if( tinP.ppbNewUntagged[ offi ] )
            //{
            //for( countT offi = 0 ; offi < sizeof tinP.ppbNewUntagged / sizeof tinP.ppbNewUntagged[ 0 ] ; offi ++ )

            thirdC::inOutChatterIfIF( tinP ) ;_

            }
                tinP.bSuppressInOutTrace -- ;_
                }
                    //U::SUSPECTED DEADLOCK: ((etherC*)0)->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;_

                    }
                        OStEXTA( ostoSay , postTitle ) ;_
                    {
                    if( postTitle )
                    const osTextT* postTitle = processGlobal7S::_processGlobal7I_IF().source.postFileTitleF( tinP , processGlobal7S::_processGlobal7I_IF().source.idFileRankF( tinP , idiFileCt ) ) ;_
                    OStEXTAK( ostoSay , ") --    " ) ;_
                    OStEXTC9( ostoSay , idLineCt ) ;_
                    OStEXTAK( ostoSay , "(" ) ;_
                    OStEXTC(  ostoSay , idiFileCt , 0 ) ;_
                    OStEXT(   ostoSay , TUCK << 2 ) ;_
                {
                if( !( tinP.bSuppressInOutTrace ++ ) && tinP.monitor.idThread != ifcIDtHREADlOW_tmHeartF && tinP.monitor.idThread != ifcIDtHREADlOW_break && tinP.monitor.idThread != ifcIDtHREADlOW_tmKillSocketF && tinP.monitor.idThread != ifcIDtHREADlOW_tmWatchF && tinP.monitor.idThread != ifcIDtHREADlOW_tmTimeNowF )
            {
            if( ph && ph->flags & F(flHOMEs_INoUTtRACE) )
            homeS* ph = &homeS::homeIF() ;_

            tinP.monitor.idDirty ++ ;_

            tinP.pLFstep[ offos2New + 1 ] = idiFileCt ;_
            tinP.pLFstep[ offos2New     ] = idLineCt & ~fliSTEP_FLAGmASK | fliSTEP_NESTcHANGE | fliSTEP_NESToUT ;_

            const countT offosNew  =   tinP.monitor.idStep        & OFFsLOTtINsTEPmAX ; const countT offos2New = offosNew << 1 ;_
            tinP.monitor.cInNest -- ;_
            tinP.monitor.idStep ++ ;_

            tinP.pFlagsThreadLevelMode[ offon      ] = pFlagsThreadLevelModeSave ;_
            tinP.pIdProgressNest[       offon      ] = idProgressNestSave ;_
            tinP.pEIPInNest[            offon      ] = eipInNestSave ;_
            tinP.pIdInNest[             offonk     ] = 0 ;_
            tinP.monitor.pLFnest[       offon2 + 1 ] = idFileNestSave ;_
            tinP.monitor.pLFnest[       offon2     ] = idLineNestSave ;_

            }
                if( off && off < tinP.ccExitsWhere ) inc02AM( tinP.pcExitsWhere[ off ] ) ;_
                countT off = idFileRankCt ;_
            {
            IFwHEREiSwATCHING

            if( tinP.tally.bTally ) tinP.tally.pcExits[ IDFILE ] ++ ;_

            const countT offonk = ( tinP.monitor.cInNest + 1 ) & OFFsLOTtINnESTmAX ; // "k" IS FOR "KID"
            const countT offon  =   tinP.monitor.cInNest       & OFFsLOTtINnESTmAX ; const countT offon2 = offon << 1 ;_
            const countT offos  =   tinP.monitor.idStep        & OFFsLOTtINsTEPmAX ; const countT offos2 = offos << 1 ;_

            tinP.monitor.idDirty ++ ;_
        {
        if( F(tinP.flagsThreadMode1) & flTHREADmODE1_UPDATEtIN && !( tinP.monitor.idDirty % 2 ) )

        //}
        //    }
        //        BLAMMO ;_
        //        LOGrAW5( "process global [valueExpectedByInOut,*pcWatchedByInOut]: " , pg1.valueExpectedByInOut , " != " , *pg1.pcWatchedByInOut , "\r\n" ) ;_
        //    {
        //    if( pg1.pcWatchedByInOut && *pg1.pcWatchedByInOut != pg1.valueExpectedByInOut )
        //    processGlobal1S& pg1 = processGlobal1S::_processGlobal1I_IF() ;_
        //{
        //
        //}
        //    BLAMMO ;_
        //    LOGrAW5( "tinP [valueExpectedByInOut,*pcWatchedByInOut]: " , tinP.valueExpectedByInOut , " != " , *tinP.pcWatchedByInOut , "\r\n" ) ;_
        //{
        //if( tinP.pcWatchedByInOut && *tinP.pcWatchedByInOut != tinP.valueExpectedByInOut )
    {
    if( F(flagsCt) & flINoUTfRAMEc_REGISTERcALLnEST )

    processGlobal1I.pcUtility[ 4 ] ++ ; //U::TO FIND A BUG
    processGlobal1I.pcUtility[ 1 ] ++ ; //U::TO FIND A BUG

    //if( tinP.idTinNamed != ifcIDtINnAMED_tinHeartI ) thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG
    tinP.monitor.idWhat1 = ifcIDwHAT_GOiNoUTdT ;_

//#if defined( NEVERdEFINED )

    }
        }
            }
                BLAMMO ;
                CONoUTrAW( ostoSay ) ;
                OStEXTAK( ostoSay , "\r\n" ) ;
                OStEXTCF( ostoSay , ((countT*)&say.dCpuCyclesInNet)[0] , '0' ) ;
                OStEXTAK( ostoSay , "." ) ;
                OStEXTCF( ostoSay , ((countT*)&say.dCpuCyclesInNet)[1] , '0' ) ;
                OStEXTAK( ostoSay , "\r\n dCpuCyclesInNet:    " ) ;
                OStEXTCF( ostoSay , ((countT*)&say.dCpuCyclesIn)[0] , '0' ) ;
                OStEXTAK( ostoSay , "." ) ;
                OStEXTCF( ostoSay , ((countT*)&say.dCpuCyclesIn)[1] , '0' ) ;
                OStEXTAK( ostoSay , "\r\n    dCpuCyclesIn:    " ) ;
                OStEXTCF( ostoSay , ((countT*)&dAuditTotal)[0] , '0' ) ;
                OStEXTAK( ostoSay , "." ) ;
                OStEXTCF( ostoSay , ((countT*)&dAuditTotal)[1] , '0' ) ;
                OStEXTAK( ostoSay ,     "    dAuditTotal :    " ) ;
                OStEXT( ostoSay , TUCK ) ;
            {
            if( dAuditTotal != say.dCpuCyclesIn )

            say.dCpuCyclesInNet = deltaIn - ( dAuditTotal - audit.dCpuCyclesAuditKidBetween ) ;

            ;

                + audit.dCpuCyclesAuditKidBook
                + audit.dCpuCyclesAuditKidDt
                + audit.dCpuCyclesAuditKidIn
                + audit.dCpuCyclesAuditKidCt
                  audit.dCpuCyclesAuditKidBetween

            count04T dAuditTotal =
        {
        //if( !( F(flagsCt) & flINoUTfRAMEc_DEFERwRITINGaPPtELEMETRY ) )

        say.dCpuCyclesIn = say.cCpuCycles3 - say.cCpuCycles2 ;

        else                                             audit.dCpuCyclesAuditKidBetween += say.cCpuCycles3 - tinP.cCpuCycles2Or5Lath ;
        if( tinP.cCpuCycles2Or5Lath == say.cCpuCycles2 ) audit.dCpuCyclesAuditKidBetween += deltaIn ;

        if( pDad ) pDad->audit.dCpuCyclesAuditKidIn += deltaIn ;
        count04T deltaIn = say.cCpuCycles3 - say.cCpuCycles2 ;
        QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&say.cCpuCycles3 ) ;
        QueryPerformanceCounter( (LARGE_INTEGER*)&say.cTime3 ) ;
    {
    if( !( F(flagsCt) & flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY ) )

    }
        { bDebugIsSet = 0 ; CONoUTrAW5( "~inOutFrameC RESET [idIn,pEther]" , idIn , " " , processGlobal4I.tinVeryEarlyLateMain.pEther , "\r\n" ) ; }
        else if(  bDebugIsSet && !processGlobal4I.tinVeryEarlyLateMain.pEther )
        { bDebugIsSet = 1 ; CONoUTrAW5( "~inOutFrameC set   [idIn,pEther]" , idIn , " " , processGlobal4I.tinVeryEarlyLateMain.pEther , "\r\n" ) ; }
        if(      !bDebugIsSet &&  processGlobal4I.tinVeryEarlyLateMain.pEther )

        countT idIn = 1 + incv02AM( idInLath ) ;
        static countT idInLath ;
    {
    if( processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH07 )
    //CS:DUPLICATE: 3612c002 3612c003
    //U:: TO FIND A BUG

    tinS& tinP = tinCt ; _MILE  _
{
/*1*/inOutFrameC::~inOutFrameC( voidT )/*1*/

boolT bDebugIsSet ;

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

