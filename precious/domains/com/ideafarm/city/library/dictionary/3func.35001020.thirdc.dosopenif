
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //LOGrAW( TF2(processGlobal1I.idAdamRoot,flFORMAT_NObIGITvALUES)+T(": dosOpenIF/")+T(postP)+T("/-\r\n") ) ;
    _OUT_
    }
        }
            BOSpOOP
            BOS( WHATgbo , BOSoK , DeleteFile( ostoNameTag ) )
            hTag.closeIfF() ;
        {
        if( ~hTag && !handleP )

        }
            }
                }
                    tinP.pAdamGlobal1->_thirdC_.pSwFileOpen->ungrabF( tinP ) ;
                    }
                        //pThird->delF( tinP , pbz ) ;
                        DEL( pInfo ) ;
                    {
                    else
                    if( !POOP ) *tinP.pAdamGlobal1->_thirdC_.pSwFileOpen = (countT)pInfo ;

                    //U::__( !!*tinP.pAdamGlobal1->_thirdC_.pSwFileOpen ) ;
                    }
                        __NZ( pInfoLag ) ;
                        fileOpenS* pInfoLag = (fileOpenS*)(countT)*tinP.pAdamGlobal1->_thirdC_.pSwFileOpen ;
                    {
                    if( !!*tinP.pAdamGlobal1->_thirdC_.pSwFileOpen )
                    //U::

                    tinP.pAdamGlobal1->_thirdC_.cLever_pSwFileOpen = handleP.osF( ifcIDtYPEhANDLE_FILE ) ;
                    tinP.pAdamGlobal1->_thirdC_.pSwFileOpen->grabF( tinP , TAG( TAGiDnULL ) ) ;
    
                    __( !pInfo->hTag != !ostoNameTag.costF() ) ;

                    fileOpenS* pInfo = new( 0 , tinP , pbz , sizeof( fileOpenS ) ) fileOpenS( tinP , *pThird , postP , ostoNameTag.costF() ? (const osTextT*)ostoNameTag : 0 , idAccessP , idShareP , flagsDetailsP , idHowP , flagsAttributeP , cbP , hTag ) ;
                    puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;

                    }
                        handleP.osF( ifcIDtYPEhANDLE_FILE , osh , 0 , flFILEhANDLEnOTE_OPENrEGISTERED ) ;
                        handleP.resetF() ;
                        countT osh = handleP.osF( ifcIDtYPEhANDLE_FILE ) ;
                    {
                {
                if( pbz )
                pThird->newF( tinP , LF , pbz , sizeof( fileOpenS ) ) ; ___( pbz ) ;  //U::LEAKS ; 20190129@1340: pbz IS (SOMETIMES? ALWAYS?) WRITTEN TO pSwFileOpen SO MIGHT OR MIGHT NOT BE A LEAK
                ZE( byteT* , pbz ) ;
            {
            if( tinP.pPoolUse && pThird && !POOP && !( F(flagsDetailsP) & flOPENdETAILS_DOnOTrEGISTER ) && ~hTag )
    
            //}
            //    //U: LOG THIS ostoEntry
            //    OStEXTAK( ostoEntry  , "\"" ) ;
            //    OStEXTA( ostoEntry  , postP ) ;
            //    OStEXTAK( ostoEntry  , " \"" ) ;
            //    OStEXTC( ostoEntry  , rc , 0 ) ;
            //    OStEXTAK( ostoEntry  , "thirdC::dosOpenIF: DosOpen failed with rc = " ) ;
            //    OStEXT( ostoEntry , 0x80 )
            //{
            //if( rc )
    
            __Z( handleP ) ;

            BOSpOOP

            #endif
                }
                    case ERROR_SHARING_VIOLATION : { idResultP = ifcOPENrESULT_ERRORsHARINGvIOLATION ; break ; }
                {
                switch( tinP.brcLath )
            #if defined( __NT__ )

            //}
            //    LOGrAW( ostoSay ) ;
            //
            //    OStEXTAK( ostoSay , "\"\r\n" ) ;
            //    OStEXTA(  ostoSay , postP ) ;
            //    OStEXTAK( ostoSay , " \"" ) ;
            //    OStEXTC(  ostoSay , idShareP , 0 ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , idAccessP , 0 ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , bNoQuitEarly , 0 ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , tinP.brcLath , 0 ) ;
            //    OStEXTAK( ostoSay , "dosOpenIF [brcLath,bNoQuitEarly,idAccessP,idShareP,postP]: " ) ;
            //    OStEXT(   ostoSay , TUCK << 1 ) ;
            //{
            //if( tinP.bosFail && tinP.pPoop->flagsF() & flPOOP_SMELLY )
            //THIS DOES NOT WORK

            #endif
                else          idResultP = 0 ;
                if( ~handleP ) idResultP = openResultIfFromOsIF( tinP , idResultP ) ;
            #ifdef __OS2__
            //LOG1020022( !handleP ) ;
    
            }
                while( !POOP && !handleP && ( bNoQuitEarly || ( cTriesP && -- cTriesP ) ) ) ; // thirdC::thPrimeIF( tinP ) IS NOT CHECKED HERE BECAUSE IT WOULD HANG IF I AM CALLED DURING TERMINATION, AFTER thPrimeIF HAS BEEN DESTROYED
                }
                    }
                        ++ s ; dosSleepIF( tinP , TOCK ) ;

                        LOGrAW(   ostoSay ) ;
                        OStEXTAK( ostoSay , "\"\r\n" ) ;
                        OStEXTA(  ostoSay , postP ) ;
                        OStEXTAK( ostoSay , ": \"" ) ;
                        OStEXTC(  ostoSay , ++ cFail , 0 ) ;
                        OStEXTAK( ostoSay , "DosOpenIF/cannot open [postP] " ) ;
                        OStEXT(   ostoSay , TUCK << 1 ) ;
                    {
                    if( !handleP && ( !cTriesP || cTriesP > 1 ) ) // thirdC::thPrimeIF( tinP ) IS NOT CHECKED HERE BECAUSE IT WOULD HANG IF I AM CALLED DURING TERMINATION, AFTER thPrimeIF HAS BEEN DESTROYED (THIS IS ALSO WHY I DO NOT LOG ANYTHING HERE)
        
                    if( pThird && F(pThird->flagsMode) & flTHIRDmODE_TESTaUTO ) break ;
        
                    #endif

                        //}
                        //    CONoUTrAW( "\"\r\n" ) ;
                        //    CONoUTrAW( postP ) ;
                        //    CONoUTrAW3( "[rc]: " , rc , "\r\nfile: \"" ) ;
                        //{
                        //if( rc )
                        //OBSOLETED BY chatterF CALL WITHIN POOPR
        
                        if( rc ) handleP.closeIfF() ;
        
                        }
                            idResultP = ifcOPENrESULT_EXISTED ;
                            rc = 0 ;
                        {
                        )
                            )
                                ( how == OPEN_ALWAYS   ) 
                                ||
                                ( how == CREATE_ALWAYS )
                            (
                            &&
                            rc == ERROR_ALREADY_EXISTS
                        (
                        if

                        if( !rc && idHowP == ifcOPENhOW_nFeO || idHowP == ifcOPENhOW_nFeR ) idResultP = ifcOPENrESULT_EXISTED ;

                        }
                            handleP.osF( ifcIDtYPEhANDLE_FILE , osh ) ;
                            rc = tinP.brcRaw ;
                            BOSdOnOTtEST( WHATgbo , GetLastError() )
                            countT osh = tinP.brcRaw ;
                            BOS( WHATgbo , BOShANDLE , CreateFile( postP , flagsAccess , flagsShare , &sa , how , flagsDetails , 0 ) )
                            BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                            SECURITYaTTRIBUTE_saUNRESTRICTED( 1 ) ; //U:: SET bInherit IN OBEDIENCE TO A PARAMETRIC FLAG
                        {
                        ZE( countT , rc ) ;
        
                    #elif defined( __NT__ )
        
                        if( rc ) handleP.closeIfF() ;
        
                        handleP.osF( ifcIDtYPEhANDLE_FILE , (countT)osh ) ;
                        rc = tinP.brcRaw ;
                        BOS( WHATsfw , BOSfAIL , DosOpen( postP , &osh , (ULONG*)&idResultP , cbP , flagsAttribute , how , flagsAccess | flagsShare | flagsDetails , 0 ) )
                        ZE( HFILE , osh ) ;
        
                    #ifdef __OS2__
                {
                do
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                ZE( countT , cFail ) ;
            {
            boolT bNoQuitEarly = !cTriesP ;
    
            }
                }
                    }
                        }
                            thirdC::dosOpenIF( tinP , hTag , countTC() , ostoNameTag , ifcOPENaCCESS_W , 0 , flOPENdETAILS_WRITEnOW | flOPENdETAILS_FAIL  , ifcOPENhOW_nCeF ) ;

                            ostoNameTag.truncateF( TUCK ) ;
                            OStEXTC(  ostoNameTag , tinP.monitor.idStep , 0 ) ;
                            OStEXTAK( ostoNameTag , "." ) ;
                            OStEXTC(  ostoNameTag , tinP.monitor.idThread , 0 ) ;
                            OStEXTAK( ostoNameTag , "." ) ;
                            OStEXTC(  ostoNameTag , processGlobal1I.idAdamRoot , 0 ) ;
                            OStEXTAK( ostoNameTag , "." ) ;
                        {
                        else
                        }
                            LOGrAW( ostoSay ) ;

                            OStEXTAK( ostoSay , "\r\n" ) ;
                            OStEXTA(  ostoSay , postP ) ;
                            OStEXTAK( ostoSay , "    " ) ;
                            OStEXTC(  ostoSay , ostoNameTag.costF() - TUCK , 0 ) ;
                            OStEXTA(  ostoSay , "error: cannot create validation file because root file name is too long [costExcess,postP]:  " ) ;
                            OStEXT(   ostoSay , TUCK << 2 ) ;
                        {
                        if( ostoNameTag.costF() > TUCK )    // OTHER CODE CAN ASSUME THAT THE FULL postTag IS IN THE NAME, BUT MAY NOT ASSUME THAT THE SUFFIX IS COMPLETE
                        OStEXTA(  ostoNameTag , postTag ) ;
                        OStEXTA(  ostoNameTag , postP ) ;
                    {
                    if( ( idAccessP == ifcOPENaCCESS_WR || idAccessP == ifcOPENaCCESS_W ) && !thirdC::c_strstrIF( tinP , postP , postTag ) )
                {
                if( pThird && !POOP )

                dosFileDeleteIfCorruptIF( tinP , postP ) ;
            {
            if( !( F(flagsDetailsP) & flOPENdETAILS_DOnOTvALIDATE ) )
        {
        handleC hTag( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
        OStEXT( ostoNameTag , TUCK << 1 )

        const flagsT flagsAttribute = fileAttrOsFromIfIF( tinP , flagsAttributeP ) ;
        const countT how            = openHowOsFromIfIF( tinP , idHowP ) ;
        const flagsT flagsDetails   = openDetailsOsFromIfIF( tinP , flagsDetailsP ) ;
        const flagsT flagsShare     = openShareOsFromIfIF( tinP , idShareP ) ;
        const flagsT flagsAccess    = openAccessOsFromIfIF( tinP , idAccessP ) ;

        }
            pThird->pEtherContainsMe->diskMakeDirIfNeededF( tinP , tFile ) ;
            TN( tFile , ifFileNameC( tinP , *pThird , postP ) ) ;
        {
        if( !( F(flagsDetailsP) & flOPENdETAILS_DOnOTmAKEdIRiFnEEDED ) && !( F(tinP.flagsThreadMode2) & flTHREADmODE2_DISALLOWpUSE ) && pThird && pThird->pEtherContainsMe && tinP.pPoolUse )
        thirdC* pThird = tinP.pEther ? &(thirdC&)*tinP.pEther : 0 ;
    {
    _INoLD_

    }
        if( POOP ) return ;
        #endif
            __( cbP ) ;
            __( sizeof( countT ) != sizeof( HANDLE ) || fnu ) ;
        #elif defined( __NT__ )
            __( sizeof( countT ) != sizeof( ULONG ) || fnu ) ;
            __( sizeof( countT ) != sizeof( HFILE ) || fnu ) ;
        #ifdef __OS2__
        ZE( boolT , fnu ) ;
        __NZ( !( F(flagsDetailsP) & flOPENdETAILS_DOnOTvALIDATE ) && F(flagsDetailsP) & flOPENdETAILS_DOnOTrEGISTER ) ; // VALIDATION REQUIRES REGISTRATION SO THAT THE TAG FILE CAN BE DELETED WHEN THE HANDLE IS CLOSED
        FV( flOPENdETAILS , flagsDetailsP ) ;
        __Z( postP ) ;
        __( idResultP ) ;
        __( ~handleP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    

    const countT         costTag = thirdC::c_strlenIF( tinP , postTag ) ;
    const osTextT* const postTag = ".!writing" ;
    //LOGrAW( TF2(processGlobal1I.idAdamRoot,flFORMAT_NObIGITvALUES)+T(": dosOpenIF/")+T(postP)+T("/+\r\n") ) ;
{
/*1*/voidT thirdC::dosOpenIF( tinS& tinP , handleC& handleP , countT& idResultP , const osTextT* const postP , const countT idAccessP , const countT idShareP , const flagsT flagsDetailsP , const countT idHowP , const flagsT flagsAttributeP , const countT cbP , countT cTriesP )/*1*/

#endif

            tinP.pEther->etherPutLogF( tinP , textC(tinP,TAG( TAGiDnULL ),flTEXTc_null,"1020022: could not open \"") + textC(tinP,TAG( TAGiDnULL ),flTEXTc_null,postP) + textC(tinP,TAG( TAGiDnULL ),flTEXTc_null,"\".") ) ;
        if( bFailP && !( pThird && F(pThird->flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) && tinP.pEther )                            \
                                                                                                                                      \
    #define LOG1020022(bFailP)                                                                                                        \

#if defined( NEVERdEFINED )

/**/
*/
  if not 0 then will try cTriesP times
  if 0 then will retry forever
 cTriesP
  os/2: the number of bytes to allocate when creating a new file
  windows: must be 0
 cbP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010010.flFILEaTTR!||
 flagsAttributeP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010014.ifcOPENhOW!||
 idHowP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010011.flOPENdETAILS!||
 flagsDetailsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010016.ifcOPENsHARE!||
 idShareP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010015.ifcOPENaCCESS!||
 idAccessP
 postP
  os/2: idResultP will be set to a value that indicates what action was taken
   idResultP will contain ifcOPENrESULT_EXISTED or 0 when i return
  windows: idResultP is always set to 0 (no longer true)
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010013.ifcOPENrESULT!||
 idResultP
 handleP
arguments
i assume that i am the only thread that is opening a file of the specified name
\<A HREF=\"5.1020022.1.0.html\"\>definition\</A\>
    
\<A HREF=\"6.$dosOpenIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

