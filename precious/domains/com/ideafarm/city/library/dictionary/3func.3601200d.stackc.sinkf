
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUTbATONsTACKc_
    sinkF( tinP , idSlotP , (countT)psttP , flagsP , pSubtractF , subtractionParmP ) ;
    if( !pSubtractF ) pSubtractF = subtractStringsF ;
    ifc4FT pSubtractF = pSubtractFP ;
    _INbATONsTACKc_

    if( third ) return ;
    __( F(flags) & flSTACKc_XRAY ) ;
    __( idType && idType - ifcSTACKtYPE_PTR_strokeS ) ;
    FV( flSTACKsINK , flagsP ) ;
    __Z( psttP ) ;
    __( idSlotP ) ;
    if( third ) return ;
    SCOOP   
{
/*1*/voidT stackC::sinkF( tinS& tinP , countT& idSlotP , const strokeS* const psttP , const flagsT flagsP , ifc4FT pSubtractFP , const countT subtractionParmP )/*1*/

}
    return scSgn ;

    }
        scSgn = ether.strCompareF( tinP , (strokeS*)c1P + csPrefixIgnore , (strokeS*)c2P + csPrefixIgnore ) ;
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )
    ZE( sCountT , scSgn ) ;

    countT csPrefixIgnore = c3P * CSpREFIX ; // WILL BE 0 FOR NORMAL STRINGS.  WILL BE CSpREFIX FOR "STRINGS OF STRINGS", SO THAT THE PREFIX FOR THE CONTAINING STRING IS IGNORED.  GENERALLY, WILL CAUSE ME TO IGNORE THE PREFIES OF ALL CONTAINING STRINGS

    if( c3P > 4 ) { BLAMMO ; }      // NOT LIKELY TO NEED MORE THAN 4 NESTS.  INTENDED TO TRAP GARBAGE VALUES OF c3P

    }
    {
    IFbEcAREFUL
{
/**/countT subtractStringsF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )
*/
   if 3 etc. etc.
   if 2 then i will assume "string of strings of strings"
   if 1 then c1P and c2P are assumed to be strings of strings and i will compare the woth string in each set, ignoring subsequent strings in the string
  else gives the "string of strings" nesting level
  if 0 then c1P and c2P point to plain strokeS strings
 subtractionParmP
 pSubtractFP
 ||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001008b.flSTACKsINK_!||
 flagsP
 psttP
 idSlotP
 tinP
arguments
after calling this function, stackC::extractF( tinP ) can be used to remove the item that it references
  the function must be of type ifc3FT, i.e.: "countT (*ifc3FT)( tinS& tinP , countT& , countT& , countT& )"
   }
   return ether.strCompareF( tinP , (strokeS*)c1P , (strokeS*)c2P ) ;
   etherC& ether = *(etherC*)pEther ;
   if( !pEther ) return ;
{
   countT subtractStringsF( countT& pEther , countT& c1P , countT& c2P )
  cast its parameters, as in this example (which is the default subtration function)
  pDensityFP should be a function that returns the "density" of the object
   an item will not sink past another item of the same density
  iow, this function preserves ordering
 the new item sinks until the item below it is equally or more dense than it is
like operator << except the new item "sinks" into the stack
  \<A HREF=\"5.2d10104.1.1.0.html\"\>2d10104:  WAKEsHOW( "example.simplest.func.115000d.stackC.sinkF" )\</A\>
 simplest
examples
\<A HREF=\"5.115000d.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$sinkF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

