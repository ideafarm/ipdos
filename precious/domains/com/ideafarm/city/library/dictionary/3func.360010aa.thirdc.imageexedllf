
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


// master def is in 314

}
    }
        #endif

            }
                }
                    }
                        }
                            __( pInfoP->postDescription[ pInfoP->costDescriptionAlloc - 1 ] ) ;
                            pInfoP->costDescriptionAlloc = pPeInfo3[ off ].SizeOfRawData ;
                            pInfoP->postDescription = (osTextT*)( pbP + pPeInfo3[ off ].PointerToRawData ) ;
                        {
                        else if( !c_strcmpIF( tinP , pbSectionName , ".desc" ) )
                        }
                            }
                                pInfo ++ ;

                                }
                                    }
                                        break ;
                                        pInfoP->ppostDllUsed[ off ] = pbUsedName ;
                                    {
                                    if( !pInfoP->ppostDllUsed[ off ] )
                                {
                                for( countT off = 0 ; off < CpOSTdLLuSED ; off ++ )

                                if( pInfoP->pSt_postDllUsed ) *pInfoP->pSt_postDllUsed << (countT)pbUsedName ;
                                byteT* pbUsedName =  pbOff + pInfo->offName ;
                            {
                            while( pInfo->offName )
                            byteT* pbOff = (byteT*)pInfo - pPeInfo3[ off ].VirtualAddress ;
                            oneImportImageExeDllS* pInfo = (oneImportImageExeDllS*)( pbP + pPeInfo3[ off ].PointerToRawData ) ;
                        {
                        else if( !c_strcmpIF( tinP , pbSectionName , ".idata" ) )
                        }
                            //}
                            //    }
                            //        *pInfoP->pSt_postFuncNameExported << (countT)postFuncName ;
                            //        osTextT* postFuncName = (osTextT*)pbOff + pcOffFuncName[ off ] ;
                            //    {
                            //    for( countT off = 0 ; off < pInfo->NumberOfNames ; off ++ )
                            //    countT* pcOffFuncName = (countT*)( pbOff + (countT)pInfo->AddressOfNames ) ;
                            //{
                            //if( pInfoP->pSt_postFuncNameExported )
                            //THIS LOOP CAUSED A THREAD STOP WHEN THE CB_rOOTpOOLoLDiNsET (THIS CONSTANT HAS BEEN ELIMINATED) IS SMALL
                            //DISABLED AS A SPEED AND SPACE OPTIMIZATION; ENABLE THIS CODE WHEN WANT TO RUN c550104 TO GET REPORT

                            pInfoP->postImageName = pbOff + pInfo->Name ;

                            byteT* pbOff = (byteT*)pInfo - pPeInfo3[ off ].VirtualAddress ;
                            IMAGE_EXPORT_DIRECTORY* pInfo = (IMAGE_EXPORT_DIRECTORY*)( pbP + pPeInfo3[ off ].PointerToRawData ) ;
                        {
                        if( !c_strcmpIF( tinP , pbSectionName , ".edata" ) )
                        if( POOP ) break ; //c_strcmpIF WILL RETURN 0 IF IMPOTENT

                        if( pInfoP->pSt_postSectionName ) *pInfoP->pSt_postSectionName << (countT)pbSectionName ;
                        const byteT* const pbSectionName = (const byteT*)pPeInfo3[ off ].Name ;
                    {
                    for( countT off = 0 ; !*this && off < pPeInfo->NumberOfSections ; off ++ )

                    IMAGE_SECTION_HEADER*  pPeInfo3 = (IMAGE_SECTION_HEADER*) ( (byteT*)pPeInfo2 + sizeof( IMAGE_OPTIONAL_HEADER ) ) ;
                    IMAGE_OPTIONAL_HEADER* pPeInfo2 = (IMAGE_OPTIONAL_HEADER*)( (byteT*)pPeInfo  + sizeof( IMAGE_FILE_HEADER     ) ) ;

                    pInfoP->bDll = !!( pPeInfo->Characteristics & IMAGE_FILE_DLL ) ;
                {
                if( !POOP )
                __( ((ULONG*)pPeInfo)[ - 1 ] - 0x4550 ) ;
                IMAGE_FILE_HEADER* pPeInfo  = (IMAGE_FILE_HEADER*)( pbP + pDosInfo->e_lfanew + sizeof( countT ) ) ;
            {
            if( !POOP )
            __( *(USHORT*)pDosInfo - 0x5a4d ) ;
            IMAGE_DOS_HEADER* pDosInfo = (IMAGE_DOS_HEADER*)pbP ;

        #elif defined( __NT__ )

            //U:

        #if defined( __OS2__ )
    {
    if( pInfoP )
    __Z( pInfoP ) ;
    pInfoP = new( 0 , tinP , LF ) imageExeDllC( tinP , *this ) ; ___( pInfoP ) ;

    }
        if( POOP ) return ;
        __Z( pbP ) ;
        __NZ( pInfoP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT thirdC::imageExeDllF( tinS& tinP , imageExeDllC*& pInfoP , const byteT* const pbP )/*1*/

;
}
    countT offFuncAddrList ;
    countT offName ;
    countT pad[ 2 ] ;
    countT offFuncNameList ;
{
struct oneImportImageExeDllS

/**/
*/
\<A HREF=\"5.10200d0.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$imageExeDllF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

