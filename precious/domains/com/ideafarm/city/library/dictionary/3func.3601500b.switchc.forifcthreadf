
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbLB ? ((countT*)pbLB)[ 1 ] : *(countT*)pbnu ;
    //OUT
    if( pBaton ) pBaton->ungrabF( tinP ) ;

    }
        third.delF( tinP , pbLB ) ;
        }
            stackk << pbLB ;
            ((countT*)pbLB)[ 1 ] = 0 ;
            *(countT*)pbLB = query ;
        {
        if( pbLB )
        third.newF( tinP , LF , pbLB , sizeof( countT ) + cbData ) ; ___BITScT( pbLB , 0xe52 ) ;
    {
    if( !pbLB )

    }
        else                                                   pbLB = 0 ;
        if( !third && bHitF( tinP , query , *(countT*)pbLB ) ) break ;
        __Z( pbLB ) ;
        pbLB = (byteT*)&stackk[ idp ] ; //U::EDIT THIS DEF TO USE A SINK QUERY (SEE FOR EXAMPLE freeF)
    {
    for( countT idp = 1 ; !third && idp <= cPlates ; idp ++ )

    ZE( byteT* , pbLB ) ;
    const countT cPlates = stackk ;
    const countT query = tinP.monitor.idThread ;
    else if( osTidOwner != tinP.osTid && !bDying && !( F(stackk.flagsF(tinP)) & flSTACKc_ALLOWmULTIPLEuNSERIALIZED ) ) BLAMMO ;
    else if( !osTidOwner ) osTidOwner = tinP.osTid ;
    if( pBaton ) pBaton->grabF( tinP , TAG( TAGiDnULL ) ) ;

    //IN
    //THESE LINES HERE CAN BE ENABLED IF NEEDED.  THEY ARE COMMENTED OUT ONLY FOR COSMETIC REASONS (TO IMPROVE THE READABILITY OF THE TRACE INFORMATION IN tinS)
    //OTHERWISE, I WOULD APPEAR ALL OVER THE PLACE BECAUSE IN, OUT CALL ME FOR EVERY FUNCTION
    //IN, OUT ARE SUPPRESSED SO THAT THIS FUNCTION DOES NOT APPEAR IN tinP'S TRACE FOR THIS THREAD

    }
        if( third ) return *(countT*)pbnu ;
        __( !tinP.monitor.idThread ) ;
        if( third ) return *(countT*)pbnu ;
        __( idLeverType - ifcIDtYPElEVER_countT ) ;
        if( third ) return *(countT*)pbnu ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/countT& switchC::forIfcThreadF( tinS& tinP )/*1*/

/**/
*/
the switchC object must have been constructed with a lever of type countT& specified
like operator countT& except uses tinP.monitor.idThread as the lever value
  \<A HREF=\"5.e230104.1.1.0.html\"\>e230104:  WAKEsHOW( "example.simplest.func.120000d.switchC.forIfcThreadF" )\</A\>
 simplest
examples
\<A HREF=\"5.120000d.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$forIfcThreadF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

