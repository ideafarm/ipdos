
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return ostEscaped ;
    TESTsCRATCH //U:: TO FIND A BUG

    }
        ether.delF( tinP , postBodyP ) ;
        ether.delF( tinP , psttAgentP ) ;
        ether.delF( tinP , psttQueryKVP ) ;
        ether.delF( tinP , psttNameP ) ;
    {
    if( bFailP )

    ether.delF( tinP , psttAction ) ;

    }
        TESTsCRATCH //U:: TO FIND A BUG
        }
            ether.delF( tinP , pstt1e ) ;
            }
                ether.delF( tinP , psttv ) ;
                ether.delF( tinP , psttk ) ;
                }
                    psttLeverKVP = 0 ;
                    swKVP = (countT)psttv ; psttv = 0 ;
                    //LOGrAW( T("value registered:\r\n--------\r\n")+T(psttv)+T("\r\n--------\r\n") ) ; //U::
                    psttLeverKVP = psttk ;

                    //ether.traceF( tinP , T("form field [key,value]:    ")+T(psttk)+T("    \"")+T(psttv)+T("\"") ) ;
                    //LOGrAW( T("form value:\r\n-------------------\r\n")+T(psttv)+T("\r\n-------------------\r\n") ) ;
                    
                    }
                        ether.delF( tinP , psttd ) ;
                        ether.strSubstringF( tinP , psttv , idf , idl , psttd ) ; ___( psttv ) ;
                        countT idl = csMax ;
                        countT idf = 1 ;
                        strokeS* psttd = psttv ; psttv = 0 ;
                    {
                    if( psttv->idAdam > csMax ) 

                    countT csMax = TOCK ; //20200703@1637: ELIMINATE THIS CHOKE IN ORDER TO ACCOMMODATE Wo'O's Table Talk POSTS ; (note comment peanut ARE NOT CURRENTLY USED)

                    //;
                    //                : TUCK
                    //                ? TUCK << 2
                    //            !ether.strCompareF( tinP , psttk , T("comment") )
                    //            !ether.strCompareF( tinP , psttk , T("peanut" ) ) ||
                    //            !ether.strCompareF( tinP , psttk , T("note"   ) ) ||
                    //        :
                    //        ? TOCK
                    //const countT csMax = 1 == ether.strIdF( tinP , T("autoresponse.") , psttk )

                    }
                        ether.delF( tinP , psttd ) ;
                        ether.strSubstringF( tinP , psttk , idf , idl , psttd ) ; ___( psttk ) ;
                        countT idl = TUCK ;
                        countT idf = 1 ;
                        strokeS* psttd = psttk ; psttk = 0 ;
                    {
                    if( psttk->idAdam > TUCK ) 
                
                    ether.strTrimF( tinP , psttk , 0 , T(TbLACKnEWlINE) ) ; ___( psttk ) ;
                    ether.strConvertToLowerCaseF( tinP , psttk ) ; ___( psttk ) ;
                    //LOGrAW( T("value after translation from url:\r\n--------\r\n")+T(psttv)+T("\r\n--------\r\n") ) ; //U::
                    ether.strFromUrlF( tinP , psttv ) ; ___( psttv ) ;
                    ether.strFromUrlF( tinP , psttk ) ; ___( psttk ) ;
                {
                if( psttk && psttv )
                        
                //LOGrAW( T("raw value:\r\n--------\r\n")+T(psttv)+T("\r\n--------\r\n") ) ; //U::
                if( idf ) ether.strSubstringF( tinP , psttv , idf , sttq , sttEq , psttc1 ) ; ___( psttv ) ;
                          ether.strSubstringF( tinP , psttk , idf , sttq , sttEq , psttc1 ) ; ___( psttk ) ;
                ZE( strokeS* , psttv ) ;
                ZE( strokeS* , psttk ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                countT idf = 1 ;
            {
            FORsTRINGSiN1( pstt1e )
            strokeS sttEq( '=' ) ;
            ether.strWordsOldF( tinP , pstt1e , psttQueryKVP , sttq , T("&") ) ; ___( pstt1e ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1e ) ;
        {
        if( !bFailP && !POOP && psttQueryKVP ) // STORE THE KEY/VALUE PAIRS

        }
            }
                ether.delF( tinP , psttd ) ;
                ether.strMakeF( tinP , psttQueryKVP , ( psttd ? T(psttd)+T("&") : T("") )+tBody ) ; ___( psttQueryKVP ) ; //ASSUME: psttQueryKVP IS OF FORM T("aaaa=1111&bbbb=2222&cccc=3333&dddd=4444")
                psttQueryKVP = 0 ;
                strokeS* psttd = psttQueryKVP ;
                TN( tBody , "" ) ; tBody = T(postBodyP) ;
                        
                //CONoUTrAW( T("--------\r\n")+T(postBodyP)+T("\r\n--------\r\n") ) ; //U::
                //LOGrAW( T("raw body:\r\n--------\r\n")+T(postBodyP)+T("\r\n--------\r\n") ) ; //U::

                if( postBodyP ) postBodyP[ costBody ] = 0 ;
            {
            if( !bFailP )

            }
                }
                    bFailP = 1 ;
                    ether.delF( tinP , postBodyP ) ;
                    //ether.traceF( tinP , T("readRequestF: could not read socket 175") ) ;
                    POOPRqUIET
                {
                if( POOP )
                psoP->readF( tinP , postBodyP , costBody ) ;
                SCOOPS
            {
            IFsCRATCH

            ether.newF( tinP , LF , postBodyP , costBody + 1 ) ; ___( postBodyP ) ;
        {
        if( costBody )
        TESTsCRATCH //U:: TO FIND A BUG
    {
    if( !bFailP )

    }
        TESTsCRATCH //U:: TO FIND A BUG
        ether.delF( tinP , psttl ) ;
        }
            ether.delF( tinP , psttValue ) ;
            ether.delF( tinP , psttKey ) ;
        
            }
                }
                    ether.strMakeF( tinP , psttAgentP , psttValue ) ; ___( psttAgentP ) ;
                    if( psttAgentP ) ether.delF( tinP , psttAgentP ) ;
                {
                else if( !ether.strCompareF( tinP , psttKey , tKeyUserAgent     ) )
                }
                    bCloseP = !ether.strCompareF( tinP , psttValue , T("close") ) ;
                    //ether.traceF( tinP , tKeyConnection+T(" header line encountered:   ")+T(psttValue) ) ;
                {
                else if( !ether.strCompareF( tinP , psttKey , tKeyConnection    ) )
                     if( !ether.strCompareF( tinP , psttKey , tKeyContentLength ) ) costBody = ether.strDigitsToSCountF( tinP , psttValue , 0xa , 1 ) ;
            
                ether.strTrimF( tinP , psttValue , 0 , T(TbLACKnEWlINE) ) ; ___( psttValue ) ;
                ether.strSubstringF( tinP , psttValue , idf , countTC() , psttl ) ; ___( psttValue ) ;
            {
            if( idf )
            ether.strConvertToLowerCaseF( tinP , psttKey ) ; ___( psttKey ) ;
            ether.strSubstringF( tinP , psttKey , idf , sttq , tColonWhite , psttl , 1 ) ; ___( psttKey ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttValue ) ;
            ZE( strokeS* , psttKey ) ;
        {
        else  // HEADER LINE ASSUMED TO BE OF THE FORM, FOR EXAMPLE,  "Content-Length:1234"
        }
            }
                swMapUrl.ungrabF( tinP ) ;

                }
                    }
                        }
                            ether.strWordF( tinP , psttQueryKVP , psttUrlNew , sttq , sttQuest , 2 ) ; ___( psttQueryKVP ) ;
                            ether.strWordF( tinP , psttNameP    , psttUrlNew , sttq , sttQuest , 1 ) ; ___( psttNameP    ) ;
                        {
                        else
                        }
                            ether.strMakeF( tinP , psttNameP , psttUrlNew ) ; ___( psttNameP ) ;
                        {
                        if( !ether.strIdF( tinP , sttQuest , psttUrlNew ) ) // HTTP/1.0 KEYvALUE PAIRS
                        strokeS sttQuest( '?' ) ;

                        ether.delF( tinP , psttQueryKVP ) ;
                        ether.delF( tinP , psttNameP ) ;
                    {
                    if( psttUrlNew )

                    ether.traceF( tinP , T("readRequestF / overriding Url [new]:    ")+T(psttUrlNew) ) ;
                    ether.traceF( tinP , T("readRequestF / overriding Url [old]:    ")+tUrlOld       ) ;
                    strokeS*& psttUrlNew = *(strokeS**)&(countT&)swMapUrl ;
                {
                if( swMapUrl.idSlotOfLeverF( tinP , (countT)psttLeverUrl ) )

                psttLeverUrl = tUrlOld ;

                swMapUrl.grabF( tinP , TAG( TAGiDnULL ) ) ;

                TN( tUrlOld , "" ) ; tUrlOld = T(psttNameP)+T("?")+T(psttQueryKVP) ;
            {

            }
                ether.delF( tinP , psttw ) ;

                //LOGrAW( T("from url[psttQueryKVP]: \"")+T(psttQueryKVP)+T("\"\r\n") ) ;

                ether.strWordF( tinP , psttQueryKVP , psttw , sttq , sttQuest , 2 ) ; ___( psttQueryKVP   ) ;
                ether.strWordF( tinP , psttNameP    , psttw , sttq , sttQuest , 1 ) ; ___( psttNameP      ) ;
                psttNameP = 0 ;
                strokeS* psttw = psttNameP ;
            {
            if( psttNameP && ether.strIdF( tinP , sttQuest , psttNameP ) ) // HTTP/1.0 KEYvALUE PAIRS
            strokeS sttQuest( '?' ) ;
        
            ether.strWordF( tinP , psttNameP , psttl , sttq , sttb , 2 ) ; ___( psttNameP ) ;
            ether.strConvertToLowerCaseF( tinP , psttAction ) ; ___( psttAction ) ;
            ether.strWordF( tinP , psttAction , psttl , sttq , sttb , 1 ) ; ___( psttAction ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            strokeS sttb( ' ' ) ;

            //if( !bCloseP ) ether.traceF( tinP , T("i did not set bCloseP") ) ;

            }
                ether.delF( tinP , pstt1w ) ;
                }
                    }
                        }
                            bCloseP = 1 ;
                            //ether.traceF( tinP , T("    setting bClose") ) ;
                        {
                        if( !ether.strCompareF( tinP , psttc1 , T("http/1.0") ) || !ether.strCompareF( tinP , psttc1 , T("HTTP/1.0") ) )
                    {
                    if( BlATHsTRING1 )
                    //ether.traceF( tinP , T("    ")+T(psttc1) ) ;
                {
                FORsTRINGSiN1( pstt1w )
                ether.strWordsOldF( tinP , pstt1w , psttl , sttq , T(" ") ) ; ___( pstt1w ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , pstt1w ) ;
            {

            //ether.traceF( tinP , psttl ) ;
        {
        else if( !psttAction ) // IF WO'TH LINE
        }
            break ;
            ether.delF( tinP , psttl ) ;
        {
        if( !psttl || !psttl->idAdam )

        }
            break ;
            ether.delF( tinP , psttl ) ;
        {
        if( ostEscaped )

        //ether.traceF( tinP , T("[line]: \"")+T(psttl)+T("\"") ) ;
        //LOGrAW( T("\"")+T(psttl)+T("\"\r\n") ) ; //U::        
        }
            }
                break ;
                ether.delF( tinP , psttl ) ;
                bFailP = 1 ;
                //ether.traceF( tinP , T("readRequestF: could not read socket 175") ) ;
                POOPRqUIET
            {
            if( POOP )
            ostEscaped = psoP->readWoLineF( tinP , psttl , TOCK /*TUCK * 8*/ , postEscapeP ) ; ___( psttl ) ; //TUCK*2 NOT ENOUGH FOR Accepts: HEADER LINE ; 20200703@1617: "TUCK * 8" -> "TOCK" TO SUPPORT FORM QUERIES CONTINING textarea SUBMISSIONS
            SCOOPS
        {
        IFsCRATCH
        ZE( strokeS* , psttl ) ;
        TESTsCRATCH //U:: TO FIND A BUG
    {
    while( !ether && !POOP ) //READ THE HEADER LINES
    //LOGrAW( "http request:\r\n" DASH127 "\r\n" ) ;
    TN( tKeyConnection    , "connection"     ) ;
    TN( tKeyUserAgent     , "user-agent"     ) ;
    TN( tKeyContentLength , "content-length" ) ;
    TN( tColonWhite , ": " ) ;
    ZE( osTextT  , ostEscaped ) ;
    ZE( strokeS* , psttAction ) ;
    ZE( countT , costBody ) ;
    _IO_

    __( bCloseP ) ;

    TESTsCRATCH //U:: TO FIND A BUG
    scoopC scoop( tinP , LF , ether ) ;  //U:: 20201021@1350: ADDED WITHOUT ANALYSIS.  ALL MEMBER FUNCTIONS OF CLASSES WITH AN ether MEMBER SHOULD DO THIS
{
/*1*/osTextT httpServerC::readRequestF( tinS& tinP , boolT& bFailP , strokeS*& psttNameP , strokeS*& psttQueryKVP , switchC& swKVP , strokeS*& psttLeverKVP , strokeS*& psttAgentP , osTextT*& postBodyP , boolT& bCloseP , socketC* psoP , const osTextT* const postEscapeP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

