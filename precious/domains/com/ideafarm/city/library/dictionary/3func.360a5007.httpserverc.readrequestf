
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return ostEscaped ;

    _OUT_
    ether.delF( tinP , psttAction ) ;
    ether.delF( tinP , psttKV ) ;
    }
        tinP.pEtScratch->delF( tinP , pstt1e ) ;
        }
            tinP.pEtScratch->delF( tinP , psttv ) ;
            tinP.pEtScratch->delF( tinP , psttk ) ;
            }
                psttLeverKVP = 0 ;
                swKVP = (countT)psttv ; psttv = 0 ;
                //LOGrAW( T("value registered:\r\n--------\r\n")+T(psttv)+T("\r\n--------\r\n") ) ; //U::
                psttLeverKVP = psttk ;

                //ether.traceF( tinP , T("form field [key,value]:    ")+T(psttk)+T("    \"")+T(psttv)+T("\"") ) ;
                //LOGrAW( T("form value:\r\n-------------------\r\n")+T(psttv)+T("\r\n-------------------\r\n") ) ;
                
                }
                    ether.delF( tinP , psttd ) ;
                    ether.strSubstringF( tinP , psttv , idf , idl , psttd ) ; ___( psttv ) ;
                    countT idl = csMax ;
                    countT idf = 1 ;
                    strokeS* psttd = psttv ; psttv = 0 ;
                {
                if( psttv->idAdam > csMax ) 

                ;
                                : TUCK
                                ? TUCK << 2
                            !ether.strCompareF( tinP , psttk , T("comment") )
                            !ether.strCompareF( tinP , psttk , T("peanut" ) ) ||
                            !ether.strCompareF( tinP , psttk , T("note"   ) ) ||
                        :
                        ? TOCK
                const countT csMax = 1 == ether.strIdF( tinP , T("autoresponse.") , psttk )

                }
                    ether.delF( tinP , psttd ) ;
                    ether.strSubstringF( tinP , psttk , idf , idl , psttd ) ; ___( psttk ) ;
                    countT idl = TUCK ;
                    countT idf = 1 ;
                    strokeS* psttd = psttk ; psttk = 0 ;
                {
                if( psttk->idAdam > TUCK ) 
            {
            else
            if( POOP ) { POOPR ; }
        
            tinP.pEtScratch->strTrimF( tinP , psttk , 0 , T(TbLACKnEWlINE) ) ; ___( psttk ) ;
            tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttk ) ; ___( psttk ) ;
            //LOGrAW( T("value after translation from url:\r\n--------\r\n")+T(psttv)+T("\r\n--------\r\n") ) ; //U::
            tinP.pEtScratch->strFromUrlF( tinP , psttv ) ; ___( psttv ) ;
            tinP.pEtScratch->strFromUrlF( tinP , psttk ) ; ___( psttk ) ;
                    
            //LOGrAW( T("raw value:\r\n--------\r\n")+T(psttv)+T("\r\n--------\r\n") ) ; //U::
            tinP.pEtScratch->strSubstringF( tinP , psttv , idf , sttq , sttEq , psttc1 ) ; ___( psttv ) ;
            tinP.pEtScratch->strSubstringF( tinP , psttk , idf , sttq , sttEq , psttc1 ) ; ___( psttk ) ;
            ZE( strokeS* , psttv ) ;
            ZE( strokeS* , psttk ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        FORsTRINGSiN1( pstt1e )
        strokeS sttEq( '=' ) ;
        tinP.pEtScratch->strWordsOldF( tinP , pstt1e , psttKV , sttq , T("&") ) ; ___( pstt1e ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , pstt1e ) ;
    {
    if( !POOP && psttKV ) // STORE THE KEY/VALUE PAIRS

    }
        ether.delF( tinP , psttd ) ;
        ether.strMakeF( tinP , psttKV , ( psttd ? T(psttd)+T("&") : T("") )+tBody ) ; ___( psttKV ) ; //ASSUME: psttKV IS OF FORM T("aaaa=1111&bbbb=2222&cccc=3333&dddd=4444")
        psttKV = 0 ;
        strokeS* psttd = psttKV ;
        TN( tBody , "" ) ; tBody = T(postBodyP) ;
                    
        //CONoUTrAW( T("--------\r\n")+T(postBodyP)+T("\r\n--------\r\n") ) ; //U::
        //LOGrAW( T("raw body:\r\n--------\r\n")+T(postBodyP)+T("\r\n--------\r\n") ) ; //U::

        if( postBodyP ) postBodyP[ costBody ] = 0 ;
        psoP->readF( tinP , postBodyP , costBody ) ;
        tinP.pEtScratch->newF( tinP , LF , postBodyP , costBody + 1 ) ; ___( postBodyP ) ;
    {
    if( costBody )

    }
        tinP.pEtScratch->delF( tinP , psttl ) ;
        }
            tinP.pEtScratch->delF( tinP , psttValue ) ;
            tinP.pEtScratch->delF( tinP , psttKey ) ;
        
            }
                tinP.pEtScratch->strMakeF( tinP , psttAgentP , psttValue ) ; ___( psttAgentP ) ;
                if( psttAgentP ) ether.delF( tinP , psttAgentP ) ;
            {
            else if( !tinP.pEtScratch->strCompareF( tinP , psttKey , tKeyUserAgent     ) )
            else if( !tinP.pEtScratch->strCompareF( tinP , psttKey , tKeyConnection    ) ) bCloseP = !!tinP.pEtScratch->strCompareF( tinP , psttValue , T("close") ) ;
                 if( !tinP.pEtScratch->strCompareF( tinP , psttKey , tKeyContentLength ) ) costBody = tinP.pEtScratch->strDigitsToSCountF( tinP , psttValue , 0xa , 1 ) ;
        
            tinP.pEtScratch->strTrimF( tinP , psttValue , 0 , T(TbLACKnEWlINE) ) ; ___( psttValue ) ;
            tinP.pEtScratch->strSubstringF( tinP , psttValue , idf , idl , psttl ) ; ___( psttValue ) ;
            ZE( countT , idl ) ;
            tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttKey ) ; ___( psttKey ) ;
            tinP.pEtScratch->strSubstringF( tinP , psttKey , idf , sttq , tColonWhite , psttl , 1 ) ; ___( psttKey ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttValue ) ;
            ZE( strokeS* , psttKey ) ;
        {
        else  // HEADER LINE ASSUMED TO BE OF THE FORM, FOR EXAMPLE,  "Content-Length:1234"
        }
            }
                tinP.pEtScratch->delF( tinP , psttw ) ;

                //LOGrAW( T("from url[psttKV]: \"")+T(psttKV)+T("\"\r\n") ) ;

                tinP.pEtScratch->strWordF( tinP , psttKV    , psttw , sttq , sttQuest , 2 ) ; ___( psttKV   ) ;
                tinP.pEtScratch->strWordF( tinP , psttNameP , psttw , sttq , sttQuest , 1 ) ; ___( psttNameP ) ;
                psttNameP = 0 ;
                strokeS* psttw = psttNameP ;
            {
            if( tinP.pEtScratch->strIdF( tinP , sttQuest , psttNameP ) ) // HTTP/1.0 KEYvALUE PAIRS
            strokeS sttQuest( '?' ) ;
        
            tinP.pEtScratch->strWordF( tinP , psttNameP , psttl , sttq , sttb , 2 ) ; ___( psttNameP ) ;
            tinP.pEtScratch->strConvertToLowerCaseF( tinP , psttAction ) ; ___( psttAction ) ;
            tinP.pEtScratch->strWordF( tinP , psttAction , psttl , sttq , sttb , 1 ) ; ___( psttAction ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            strokeS sttb( ' ' ) ;

            }
                ether.delF( tinP , pstt1w ) ;
                }
                    }
                        if( !tinP.pEtScratch->strCompareF( tinP , psttc1 , T("http/1.0") ) || !tinP.pEtScratch->strCompareF( tinP , psttc1 , T("HTTP/1.0") ) ) bCloseP = 1 ;
                    {
                    if( BlATHsTRING1 )
                {
                FORsTRINGSiN1( pstt1w )
                tinP.pEtScratch->strWordsOldF( tinP , pstt1w , psttl , sttq , T(" ") ) ; ___( pstt1w ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , pstt1w ) ;
            {
        {
        else if( !psttAction ) // IF WO'TH LINE
        }
            break ;
            tinP.pEtScratch->delF( tinP , psttl ) ;
        {
        if( !psttl || !psttl->idAdam )

        }
            break ;
            tinP.pEtScratch->delF( tinP , psttl ) ;
        {
        if( ostEscaped )

        //ether.traceF( tinP , T("[line]: \"")+T(psttl)+T("\"") ) ;
        //LOGrAW( T("\"")+T(psttl)+T("\"\r\n") ) ; //U::        
        ostEscaped = psoP->readWoLineF( tinP , psttl , TUCK * 8 , postEscapeP ) ; ___( psttl ) ; //TUCK*2 NOT ENOUGH FOR Accepts: HEADER LINE
        ZE( strokeS* , psttl ) ;
    {
    while( !ether && !POOP ) //READ THE HEADER LINES
    //LOGrAW( "http request:\r\n" DASH127 "\r\n" ) ;
    TN( tKeyConnection    , "connection"     ) ;
    TN( tKeyUserAgent     , "user-agent"     ) ;
    TN( tKeyContentLength , "content-length" ) ;
    TN( tColonWhite , ": " ) ;
    ZE( osTextT  , ostEscaped ) ;
    ZE( strokeS* , psttAction ) ;
    ZE( strokeS* , psttKV ) ;
    ZE( countT , costBody ) ;
    _INoLD_

    __( bCloseP ) ;
{
/*1*/osTextT httpServerC::readRequestF( tinS& tinP , strokeS*& psttNameP , switchC& swKVP , strokeS*& psttLeverKVP , strokeS*& psttAgentP , osTextT*& postBodyP , boolT& bCloseP , socketC* psoP , const osTextT* const postEscapeP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

