
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return ostEscaped ;

    }
        ether.delF( tinP , postBodyP ) ;
        ether.delF( tinP , psttAgentP ) ;
        ether.delF( tinP , psttQueryKVP ) ;
        ether.delF( tinP , psttNameP ) ;
    {
    if( bFailP )

    ether.delF( tinP , psttAction ) ;
    }
        ether.delF( tinP , pstt1e ) ;
        }
            ether.delF( tinP , psttv ) ;
            ether.delF( tinP , psttk ) ;
            }
                psttLeverKVP = 0 ;
                swKVP = (countT)psttv ; psttv = 0 ;
                //LOGrAW( T("value registered:\r\n--------\r\n")+T(psttv)+T("\r\n--------\r\n") ) ; //U::
                psttLeverKVP = psttk ;

                //ether.traceF( tinP , T("form field [key,value]:    ")+T(psttk)+T("    \"")+T(psttv)+T("\"") ) ;
                //LOGrAW( T("form value:\r\n-------------------\r\n")+T(psttv)+T("\r\n-------------------\r\n") ) ;
                
                }
                    ether.delF( tinP , psttd ) ;
                    ether.strSubstringF( tinP , psttv , idf , idl , psttd ) ; ___( psttv ) ;
                    countT idl = csMax ;
                    countT idf = 1 ;
                    strokeS* psttd = psttv ; psttv = 0 ;
                {
                if( psttv->idAdam > csMax ) 

                countT csMax = TOCK ; //20200703@1637: ELIMINATE THIS CHOKE IN ORDER TO ACCOMMODATE Wo'O's Table Talk POSTS ; (note comment peanut ARE NOT CURRENTLY USED)

                //;
                //                : TUCK
                //                ? TUCK << 2
                //            !ether.strCompareF( tinP , psttk , T("comment") )
                //            !ether.strCompareF( tinP , psttk , T("peanut" ) ) ||
                //            !ether.strCompareF( tinP , psttk , T("note"   ) ) ||
                //        :
                //        ? TOCK
                //const countT csMax = 1 == ether.strIdF( tinP , T("autoresponse.") , psttk )

                }
                    ether.delF( tinP , psttd ) ;
                    ether.strSubstringF( tinP , psttk , idf , idl , psttd ) ; ___( psttk ) ;
                    countT idl = TUCK ;
                    countT idf = 1 ;
                    strokeS* psttd = psttk ; psttk = 0 ;
                {
                if( psttk->idAdam > TUCK ) 
            
                ether.strTrimF( tinP , psttk , 0 , T(TbLACKnEWlINE) ) ; ___( psttk ) ;
                ether.strConvertToLowerCaseF( tinP , psttk ) ; ___( psttk ) ;
                //LOGrAW( T("value after translation from url:\r\n--------\r\n")+T(psttv)+T("\r\n--------\r\n") ) ; //U::
                ether.strFromUrlF( tinP , psttv ) ; ___( psttv ) ;
                ether.strFromUrlF( tinP , psttk ) ; ___( psttk ) ;
            {
            if( psttk && psttv )
                    
            //LOGrAW( T("raw value:\r\n--------\r\n")+T(psttv)+T("\r\n--------\r\n") ) ; //U::
            if( idf ) ether.strSubstringF( tinP , psttv , idf , sttq , sttEq , psttc1 ) ; ___( psttv ) ;
                      ether.strSubstringF( tinP , psttk , idf , sttq , sttEq , psttc1 ) ; ___( psttk ) ;
            ZE( strokeS* , psttv ) ;
            ZE( strokeS* , psttk ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        FORsTRINGSiN1( pstt1e )
        strokeS sttEq( '=' ) ;
        ether.strWordsOldF( tinP , pstt1e , psttQueryKVP , sttq , T("&") ) ; ___( pstt1e ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , pstt1e ) ;
    {
    if( !POOP && psttQueryKVP ) // STORE THE KEY/VALUE PAIRS

    }
        ether.delF( tinP , psttd ) ;
        ether.strMakeF( tinP , psttQueryKVP , ( psttd ? T(psttd)+T("&") : T("") )+tBody ) ; ___( psttQueryKVP ) ; //ASSUME: psttQueryKVP IS OF FORM T("aaaa=1111&bbbb=2222&cccc=3333&dddd=4444")
        psttQueryKVP = 0 ;
        strokeS* psttd = psttQueryKVP ;
        TN( tBody , "" ) ; tBody = T(postBodyP) ;
                    
        //CONoUTrAW( T("--------\r\n")+T(postBodyP)+T("\r\n--------\r\n") ) ; //U::
        //LOGrAW( T("raw body:\r\n--------\r\n")+T(postBodyP)+T("\r\n--------\r\n") ) ; //U::

        if( postBodyP ) postBodyP[ costBody ] = 0 ;
        psoP->readF( tinP , postBodyP , costBody ) ;
        ether.newF( tinP , LF , postBodyP , costBody + 1 ) ; ___( postBodyP ) ;
    {
    if( costBody )

    }
        ether.delF( tinP , psttl ) ;
        }
            ether.delF( tinP , psttValue ) ;
            ether.delF( tinP , psttKey ) ;
        
            }
                }
                    ether.strMakeF( tinP , psttAgentP , psttValue ) ; ___( psttAgentP ) ;
                    if( psttAgentP ) ether.delF( tinP , psttAgentP ) ;
                {
                else if( !ether.strCompareF( tinP , psttKey , tKeyUserAgent     ) )
                }
                    bCloseP = !ether.strCompareF( tinP , psttValue , T("close") ) ;
                    ether.traceF( tinP , tKeyConnection+T(" header line encountered:   ")+T(psttValue) ) ;
                {
                else if( !ether.strCompareF( tinP , psttKey , tKeyConnection    ) )
                     if( !ether.strCompareF( tinP , psttKey , tKeyContentLength ) ) costBody = ether.strDigitsToSCountF( tinP , psttValue , 0xa , 1 ) ;
            
                ether.strTrimF( tinP , psttValue , 0 , T(TbLACKnEWlINE) ) ; ___( psttValue ) ;
                ether.strSubstringF( tinP , psttValue , idf , countTC() , psttl ) ; ___( psttValue ) ;
            {
            if( idf )
            ether.strConvertToLowerCaseF( tinP , psttKey ) ; ___( psttKey ) ;
            ether.strSubstringF( tinP , psttKey , idf , sttq , tColonWhite , psttl , 1 ) ; ___( psttKey ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttValue ) ;
            ZE( strokeS* , psttKey ) ;
        {
        else  // HEADER LINE ASSUMED TO BE OF THE FORM, FOR EXAMPLE,  "Content-Length:1234"
        }
            }
                ether.delF( tinP , psttw ) ;

                //LOGrAW( T("from url[psttQueryKVP]: \"")+T(psttQueryKVP)+T("\"\r\n") ) ;

                ether.strWordF( tinP , psttQueryKVP , psttw , sttq , sttQuest , 2 ) ; ___( psttQueryKVP   ) ;
                ether.strWordF( tinP , psttNameP    , psttw , sttq , sttQuest , 1 ) ; ___( psttNameP      ) ;
                psttNameP = 0 ;
                strokeS* psttw = psttNameP ;
            {
            if( psttNameP && ether.strIdF( tinP , sttQuest , psttNameP ) ) // HTTP/1.0 KEYvALUE PAIRS
            strokeS sttQuest( '?' ) ;
        
            ether.strWordF( tinP , psttNameP , psttl , sttq , sttb , 2 ) ; ___( psttNameP ) ;
            ether.strConvertToLowerCaseF( tinP , psttAction ) ; ___( psttAction ) ;
            ether.strWordF( tinP , psttAction , psttl , sttq , sttb , 1 ) ; ___( psttAction ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            strokeS sttb( ' ' ) ;

            if( !bCloseP ) ether.traceF( tinP , T("i did not set bCloseP") ) ;

            }
                ether.delF( tinP , pstt1w ) ;
                }
                    }
                        }
                            bCloseP = 1 ;
                            ether.traceF( tinP , T("    setting bClose") ) ;
                        {
                        if( !ether.strCompareF( tinP , psttc1 , T("http/1.0") ) || !ether.strCompareF( tinP , psttc1 , T("HTTP/1.0") ) )
                    {
                    if( BlATHsTRING1 )
                    ether.traceF( tinP , T("    ")+T(psttc1) ) ;
                {
                FORsTRINGSiN1( pstt1w )
                ether.strWordsOldF( tinP , pstt1w , psttl , sttq , T(" ") ) ; ___( pstt1w ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , pstt1w ) ;
            {

            ether.traceF( tinP , psttl ) ;
        {
        else if( !psttAction ) // IF WO'TH LINE
        }
            break ;
            ether.delF( tinP , psttl ) ;
        {
        if( !psttl || !psttl->idAdam )

        }
            break ;
            ether.delF( tinP , psttl ) ;
        {
        if( ostEscaped )

        //ether.traceF( tinP , T("[line]: \"")+T(psttl)+T("\"") ) ;
        //LOGrAW( T("\"")+T(psttl)+T("\"\r\n") ) ; //U::        
        }
            }
                break ;
                bFailP = 1 ;
                ether.traceF( tinP , T("readRequestF: could not read socket 175") ) ;
                POOPRqUIET
            {
            if( POOP )
            ostEscaped = psoP->readWoLineF( tinP , psttl , TOCK /*TUCK * 8*/ , postEscapeP ) ; ___( psttl ) ; //TUCK*2 NOT ENOUGH FOR Accepts: HEADER LINE ; 20200703@1617: "TUCK * 8" -> "TOCK" TO SUPPORT FORM QUERIES CONTINING textarea SUBMISSIONS
            SCOOPS
        {
        IFsCRATCH
        ZE( strokeS* , psttl ) ;
    {
    while( !ether && !POOP ) //READ THE HEADER LINES
    //LOGrAW( "http request:\r\n" DASH127 "\r\n" ) ;
    TN( tKeyConnection    , "connection"     ) ;
    TN( tKeyUserAgent     , "user-agent"     ) ;
    TN( tKeyContentLength , "content-length" ) ;
    TN( tColonWhite , ": " ) ;
    ZE( osTextT  , ostEscaped ) ;
    ZE( strokeS* , psttAction ) ;
    ZE( countT , costBody ) ;
    _IO_

    __( bCloseP ) ;
{
/*1*/osTextT httpServerC::readRequestF( tinS& tinP , boolT& bFailP , strokeS*& psttNameP , strokeS*& psttQueryKVP , switchC& swKVP , strokeS*& psttLeverKVP , strokeS*& psttAgentP , osTextT*& postBodyP , boolT& bCloseP , socketC* psoP , const osTextT* const postEscapeP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

