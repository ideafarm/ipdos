
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    OStEXTAK( napHomeJot  , "login: bequesting state" ) ;
    OStEXTAK( napHomeJot  , "login: cleaning up" ) ;

    }
        }
            ++ s ; ether.osSleepF( tinP , TUCK * 0x40 ) ;
            }
                HIRE( T("os.login") , 0x401012a , 0x10000000 , 0x401012a , 0x10000000 )
                //U::etThread.osSessionF( tinP , countTC() , countTC() , ifcIDaDAMoLD_COMMANDcONSOLE , 0 ) ;
                //U::etThread.osMessageBoxF( tinP , T(postORIENTATION) , T("IdeaFarm " "(tm) City: Operator Console Orientation") ) ;
                TELL( "hiring console" ) ;
                bRequestConsole = 0 ;
            {
            if( bRequestConsole )

            }
                bRequestConsole = 1 ;
                etThread.diskFileOrDirDeleteF( tinP , tConsole ) ;
            {
            if( etThread.diskFileExistsF( tinP , tConsole ) ) //U::KLUGE PENDING RESOLUTION OF SECURITY PROBLEM WITH napHomeJot AND PACKAGE
        {
        while( !ether && !etThread )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        TN( tConsole , "///d/ideafarm.sign.wantTour" ) ;
    {

    etThread.osThreadF( tinP , countTC() , tmTimeRemainingF ) ;

    OStEXTAK( napHomeJot  , postNAPhOSTjOTsTATUSrEADY ) ;

    }
        etThread.delF( tinP , psttIdAdam ) ;
        }
            HIRE( T("os.login") , idAdam , 0x1000000 , idAdam , 0x1000000 )
            __Z( idAdam ) ;
            countT idAdam = etThread.strDigitsToSCountF( tinP , psttIdAdam ) ;
            TELL( "setting up/hiring a cell" )
        {
        if( psttIdAdam )
        etThread.boxGetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF( tinP , psttIdAdam , T("///d/ideafarm.")+TF1(etherC::ifc_idHomeI_IF())+T(".setting.keyValue.idAdamHire") ) ; ___( psttIdAdam ) ;
        TELL( "setting up/reading setting file to see who to hire" )
        ZE( strokeS* , psttIdAdam ) ;
    {

    //etThread.ifcHireF( tinP , T("hired by ")+TF1(DDNUMB) , ifcIDaDAMoLD_VIEWjOT ) ;

    //etThread.osClipboardLetGoF( tinP ) ;
    //etThread.osClipboardWriteF( tinP , T("http://www.ideafarm.com/1.14.0") ) ;
    //etThread.osClipboardGrabF( tinP ) ;
    OStEXTAK( napHomeJot  , "login: setting up" ) ;

    stateS state( tinP , etThread ) ;
    OStEXTAK( napHomeJot  , "login: inheriting state" ) ;
{

}
    napConsoleRequest.formattingIsDoneF( tinP ) ;
    if( !etThread ) bRequestConsole = 0 ;
{
if( !( F(napConsoleRequest.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
boolT& bRequestConsole = *(boolT*)(byteT*)napConsoleRequest ;
__( !(byteT*)napConsoleRequest ) ;
__( (countT)napConsoleRequest - sizeof( boolT ) ) ;
napkinC napConsoleRequest( tinP , LF , (byteT*)bits , "napConsoleRequest" , 0 , sizeof( boolT ) ) ;

}
    napHomeJot.formattingIsDoneF( tinP ) ;
    if( !etThread ) *napHomeJot = 0 ;
{
if( !( F(napHomeJot.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
__( !(byteT*)napHomeJot ) ;
__( (countT)napHomeJot - CBnAPjOT ) ;
napkinC napHomeJot( tinP , LF , (byteT*)bits , "napHomeJot" , 0 , CBnAPjOT ) ;
bitsC bits( tinP , CbITSlIFI , 0 , 1 ) ;

TODO

DONE( tmTimeRemainingF )

}
    *tinP.zEtScratch = 0 ;
    }
        ++ s ; ether.osSleepF( tinP , TOCK * 0x10 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    idType = idType == 1 ? 2 : 1 ;
    
    }
        while( cTries -- ) sockd.writeF( tinP , idType == 1 ? ifcPORToLD2_ENABLEpRIVATEhTTP1 : ifcPORToLD2_ENABLEpRIVATEhTTP2 , nnIfc , (byteT*)pnn , cnnOut * sizeof( nicNameC ) ) ;
        tinP.zEtScratch->strokeF( tinP , T("throwing ")+TF1(cTries)+T(" datagrams requesting access to private http\r\n") ) ; //U::
        countT cTries = 0x8 ;
    
        countT cnnOut = cnn <= cnnMax ? cnn : cnnMax ;
        const countT cnnMax = ifcCBdATAGRAMmAX / sizeof( nicNameC ) ;
    
        socketC::nicNameIF( tinP , *tinP.zEtScratch , pnn , cnn ) ;
        ZE( countT , cnn ) ;
        ZE( nicNameC* , pnn ) ;
        //CODE SYNC: ea40104 a210104
    {
    if( timeR1 || timeR2 )
    
    }
        CONoUTrAW( T("time remaining of type ")+TF1(idType)+T(": ")+TT(timeR1,timeR2)+T("\r\n") ) ;
        }
            sData >> (countT&)timeR2 ;
            sData >> timeR1 ;

            *psCourse >> sData ;
            *psCourse >> sCodes ;
            soulC sData( tinP , TAG( TAGiDnULL ) ) ;
            soulC sCodes( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( psCourse )
        stCourses >> psCourse ;
        ZE( soulC* , psCourse ) ;
        //U::__( stCourses - 1 ) ;

        else            { CONoUTrAW( "!queryTimeRemaining job aok\r\n" ) ; }    
        if( *tinP.zEtScratch ) { CONoUTrAW( "!queryTimeRemaining job FAILED\r\n" ) ; }    
        tinP.zEtScratch->ifcJobF( tinP , stCourses , 0x4010120 , sOrder , stOrders , T("!queryTimeRemaining") , 1 , nnIfc ) ;
        stOrders << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
        stackC stOrders(  tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
        stackC stCourses( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
    
        sOrder << qq.idType ;
        sOrder << qq.idComputer ;
        sOrder << (strokeS*)T("!queryTimeRemaining") ;
        sOrder << ifcIDcMDjOBoRDER_NAMED ;
        soulC sOrder( tinP , TAG( TAGiDnULL ) ) ;
    {
            
    ZE( sCountT , timeR2 ) ;
    ZE( countT , timeR1 ) ;
    tinP.zEtScratch->memCopyF( tinP , pbq + sizeof( countT ) , (byteT*)&qq , sizeof qq ) ;
    *(countT*)pbq = 1 ;
    byteT pbq[ sizeof( countT ) + sizeof qq ] ;
    qq.idType = idType ;
    qq.idComputer = tinP.zEtScratch->diskIdF( tinP , T("///d/") ) ;
    queryTimeRemainingS qq ;
                
    countT idPortMe = sockd.bindF( tinP ) ;
    socketC sockd( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
    nicNameC nnIfc = socketC::nicNameIF( tinP , *tinP.zEtScratch , T("www.ideafarm.com") ) ;
{
while( !ether && !etThread )
countT idType = 1 ; //CYCLE 1,2,1,2,...

}
    ++ s ; ether.osSleepF( tinP , TOCK * 0x40 ) ; //IF I AM www.ideafarm.com, THIS GIVES ME TIME FOR BRAIN TO OPEN; U::CONJ: THIS IS NOT NEEDED NOW THAT I USE etScratch
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
{

//U::DEBUG WHY THIS IS STILL NEEDED
    
TASK( tmTimeRemainingF )


    "  If you are prompted to type something, what you have typed will appear in the upper half of the \"window\"." \
    "  The lines of text in that window are to be read from the bottom up." \
    "  That window occupies the entire display." \
    "Each \"program\" is allowed to display one \"window\"." \
    "\r\n" \
    "  Please do not judge this book by its cover!\r\n" \
    "  Refinement of this subsystem will be done later." \
    "The graphical presentation subsystem used by IdeaFarm " "(tm) City will probably seem ridiculously crude to you." \
                                                                                                                            \
#define postORIENTATION                                                                                                     \

STATE0

/*1*/WAKEhIDE( "ifcIDaDAMoLD_LOGIN.os.login" )/*1*/
/**/
*/
U::
Instructions:\r\n\r\n

    REMOVAL:\r\n\r\n

        The default behavior of the IdeaFarmCity service is to\r\n
        remove itself when it is stopped.  This occurs when you\r\n
        reboot the computer or when you use the Services object to\r\n
        explicitly stop the service.\r\n\r\n

    COMPLETE REMOVAL:\r\n\r\n

        1. Stop the IdeaFarmCity service.

        2. Delete all ideafarm.* files in c :\ .

        3. Find and delete the "\ideafarm.home.*\" directory (folder),
           which was created on the local drive with the most free space.

    OPERATOR CONSOLE:\r\n\r\n


    CONFIGURATION:\r\n\r\n

        Configuration is done by using a plain text (ascii) editor
        (such as Notepad on Windows) to create settings files in c :\.
        Each setting is stored in a separate file.

        REMOVAL: To prevent automatic removal, create a file with the
        name "\ideafarm.1.setting.keyValue.keep".  The contents of this
        file do not matter; create it with size 0 bytes if you know how.
        
        EDITOR: The IdeaFarmCity service uses the default system editor
        (Notepad on Windows) to display text.  To specify another editor,
        create a file called "\ideafarm.1.setting.keyValue.editor"

        DRIVE: To tell the installer to use a particular (local) drive,
        simply create an x:\ideafarm.home.* directory on the desired drive
        x: before installing.

        DRIVE: To move the IdeaFarmCity service's files to another drive,
        stop the service and then manually move the x:\ideafarm.home.*
        directory to the root directory of the desired (local) drive.
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

