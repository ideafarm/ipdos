
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


    }                                                                                                                                               \
        return (classP*)P(pv) ;                                                                                                                     \
        }                                                                                                                                           \
            }                                                                                                                                       \
                if( pCBF ) (*pCBF)( tinP , (byteT*)this , ifcIDeVENTvsp_WrEFcT , cRefWriteOld , cRefF() , cArg ) ;                                  \
                count##bitsCRefWriteP##T cRefWriteOld = incv##bitsCRefWriteP##AM( cRefWrite ) ;                                                     \
                count##bitsCRefWriteP##T& cRefWrite = *(count##bitsCRefWriteP##T*)&( (byteT*)&((count##bitsCRefP##T*)P(pv))[ offCRefP ] )[ offCRefWriteP ] ; \
                flags |= flVSP_NONCONSTANTrEFdISPENSED ;                                                                                            \
            {                                                                                                                                       \
            if( !( F(flags) & flVSP_NONCONSTANTrEFdISPENSED ) )                                                                                     \
            /*if( !thirdC::bCanAccessMemoryIF( (byteT*)P(pv) , cbTestP ) ) { BLAMMO ; }*/                                                           \
            if( !( F(tinP.flagsThreadMode3) & flTHREADmODE3_ALLOWwRITEABLEpOINTERgET ) ) { BLAMMO ; }                                               \
            TINSL                                                                                                                                   \
        {                                                                                                                                           \
        if( P(pv) )                                                                                                                                 \
    {                                                                                                                                               \
    classSPP##VSP::operator classP*( voidT )                                                                                                        \
                                                                                                                                                    \
    }                                                                                                                                               \
        }                                                                                                                                           \
            }                                                                                                                                       \
                if( pCBF ) (*pCBF)( thirdC::third_tinS_ref_IF() , (byteT*)this , ifcIDeVENTvsp_WrEFdT , cRefWriteOld , cRefF() , cArg ) ;           \
                count##bitsCRefWriteP##T  cRefWriteOld = decv##bitsCRefWriteP##AM( cRefWrite ) ;                                                    \
                count##bitsCRefWriteP##T& cRefWrite = *(count##bitsCRefWriteP##T*)&( (byteT*)&((count##bitsCRefP##T*)P(pv))[ offCRefP ] )[ offCRefWriteP ] ; \
                flags &= ~F(flVSP_NONCONSTANTrEFdISPENSED) ;                                                                                        \
            {                                                                                                                                       \
            if( F(flags) & flVSP_NONCONSTANTrEFdISPENSED )                                                                                          \
            /*if( !thirdC::bCanAccessMemoryIF( (byteT*)P(pv) , cbTestP ) ) { BLAMMO ; }*/                                                           \
        {                                                                                                                                           \
        if( P(pv) )                                                                                                                                 \
    {                                                                                                                                               \
    voidT classSPP##VSP::gaspDispensedF( voidT )                                                                                                    \
                                                                                                                                                    \
    NEWdELcLASSb( classSPP##VSP )                                                                                                                   \
                                                                                                                                                    \
    classSPP##VSP& classSPP##VSP::operator =( const classSPP##SP&   spP ) { if( F(flags) & flVSP_LOCKED && (const classP*)spP  ) { BLAMMO ; } gaspDispensedF() ; gaspF() ; pv = (classP*)PyES( spP.pv  ) ;                                       cryF() ; return *this ; } \
    classSPP##VSP& classSPP##VSP::operator =( const classSPP##VSP& vspP ) { if( F(flags) & flVSP_LOCKED && (const classP*)vspP ) { BLAMMO ; } gaspDispensedF() ; gaspF() ; pv = (classP*)PyES( vspP.pv ) ; pCBF = vspP.pCBF ; cArg = vspP.cArg ; cryF() ; return *this ; } \
    classSPP##VSP& classSPP##VSP::operator =( classP* pvP               ) { if( F(flags) & flVSP_LOCKED && pvP                 ) { BLAMMO ; } gaspDispensedF() ; gaspF() ; pv = (classP*)PyES( pvP     ) ;                                       cryF() ; return *this ; } \
                                                                                                                                                    \
    { cryF() ; }                                                                                                                                    \
    flags( flagsP )                                                                                                                                 \
    cArg( cArgP ) ,                                                                                                                                 \
    pCBF( pCBFP ) ,                                                                                                                                 \
    classSPP##SP( (classP*)PyES( pvP ) ) ,                                                                                                          \
    classSPP##VSP::classSPP##VSP( classP* pvP , vspCBFT pCBFP , countT cArgP , flagsT flagsP ) :                                                    \
                                                                                                                                                    \
    { cryF() ; }                                                                                                                                    \
    flags( F(flagsP) ? flagsP : vspP.flags & ~( F(flVSP_NONCONSTANTrEFdISPENSED) ) )                                                                \
    cArg(  pCBFP || cArgP ? cArgP : vspP.cArg ) ,                                                                                                   \
    pCBF( pCBFP ? pCBFP : vspP.pCBF ) ,                                                                                                             \
    classSPP##SP( (classP*)PyES( vspP.pv ) ) ,                                                                                                      \
    classSPP##VSP::classSPP##VSP( const classSPP##VSP& vspP , vspCBFT pCBFP , countT cArgP , flagsT flagsP ) :                                      \
                                                                                                                                                    \
    { cryF() ; }                                                                                                                                    \
    flags( flagsP )                                                                                                                                 \
    cArg( cArgP ) ,                                                                                                                                 \
    pCBF( pCBFP ) ,                                                                                                                                 \
    classSPP##SP( (classP*)PyES( spP.pv  ) ) ,                                                                                                      \
    classSPP##VSP::classSPP##VSP( const classSPP##SP& spP , vspCBFT pCBFP , countT cArgP , flagsT flagsP ) :                                        \
                                                                                                                                                    \
    classSPP##VSP::~classSPP##VSP( voidT ) { gaspDispensedF() ; gaspF() ; }                                                                         \
                                                                                                                                                    \
    SMARTpOINTERfUNCTIONdEFS( classSPP , classP , offCRefP , bitsCRefP , cbTestP )                                                                  \
                                                                                                                                                    \
#define VERYsMARTpOINTERfUNCTIONdEFS(classSPP,classP,offCRefP,bitsCRefP,cbTestP,offCRefWriteP,bitsCRefWriteP)                                       \

/*1*//*VERYsMARTpOINTERfUNCTIONdEFS(classSPP,classP,offCRefP,bitsCRefP,cbTestP,offCRefWriteP,bitsCRefWriteP)*//*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

