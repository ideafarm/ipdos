
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        }
            break ;
            stAgain << idPacketNext ;
            //etThread.strokeF( tinP , T("packet ")+TF1(idPacketNext)+T(" requesting resend\r\n") ) ;
        {
        else
        }
            ++ idPacketNext ;
            if( idPacket != idPacketNext ) { BLAMMO ; }
            etThread.strokeF( tinP , T("packet ")+TF1(idPacket)+T(" received\r\n") ) ;
            stGen >> idPacket ;
            ZE( countT , idPacket ) ;
        {
        if( stGen[ 1 ] == idPacketNext )
    {
    while( stGen && !ether && !etThread )

    stGen.waitF( tinP ) ;
{
while( !ether && !etThread )
countT idPacketNext = 1 ;

etThread.osThreadF( tinP , countTC() , tmGenF , 0 , flTHREADlAUNCH_null , 0 , (countT)&stGen , (countT)&stAgain ) ;

stackC stAgain( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;
stackC stGen( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_GIVEsIGNnEWpLATE ) ;

TODO

DONE( tmGenF )
}
    stGenP.sinkF( tinP , countTC() , (countT)-1 ) ;
    }
        while( cTries -- && !stAgainP ) { ++ s ; ether.osSleepF( tinP , TUCK * 0x10 ) ; }
        countT cTries = 0x10 ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;

        else            stGenP.sinkF( tinP , countTC() , ++ idPacket , flSTACKsINK_UNIQUE ) ;
        if( !cDrawing ) ++ idPacket ;//etThread.strokeF( tinP , T("packet ")+TF1(++idPacket)+T(" omitted\r\n") ) ;
        countT cDrawing = ru ;

        }
            stGenP.sinkF( tinP , countTC() , idPacketAgain , flSTACKsINK_UNIQUE ) ;
            //etThread.strokeF( tinP , T("packet ")+TF1(idPacketAgain)+T(" sending again\r\n") ) ;
            stAgainP >> idPacketAgain ;
            ZE( countT , idPacketAgain ) ;
        {
        while( stAgainP )
    {
    while( !ether && !etThread )
    ZE( countT , idPacket ) ;

    ranUniC ru( 0x4 , - 1 ) ;

    stackC& stAgainP = *(stackC*)pTaskP->c2 ;
    stackC& stGenP   = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmGenF )

/*1*/WAKEhIDE( "doodle.ifc.streams.reliable.communication" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

