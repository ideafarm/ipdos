
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return POOP ? ifcEXITcODEpROCESSiMPOTENT : ifcEXITcODEpROCESSaOK ;
    //tinP.pc Utility[ 0 ] -- ; //U::TO FIND A BUG
    _OUT_
    ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAINa1 ) ;
    if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
    ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN91 ) ;
    }
        ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN81 ) ;

        tinP.pEther->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
        OStEXTC(  ostoSay , tinP.pAdamGlobal1->cSpins4 , '0' ) ;
        OStEXTAK( ostoSay , "." ) ;
        OStEXTC(  ostoSay , tinP.pAdamGlobal1->cSpins3 , '0' ) ;
        OStEXTAK( ostoSay , "." ) ;
        OStEXTC(  ostoSay , tinP.pAdamGlobal1->cSpins2 , '0' ) ;
        OStEXTAK( ostoSay , "." ) ;
        OStEXTC(  ostoSay , tinP.pAdamGlobal1->cSpins1 , '0' ) ;
        OStEXTAK( ostoSay , "    " ) ;
        OStEXTC(  ostoSay , tinP.pAdamGlobal1->cYieldHighWater , 0 ) ;
        OStEXTAK( ostoSay , "    " ) ;
        OStEXTC(  ostoSay , tinP.pAdamGlobal1->idAdam , 0 ) ;
        OStEXTAK( ostoSay , "adamMainF [idAdam,cYieldHighWater,cSpins1,cSpins2,cSpins3,cSpins4]:    " ) ;
        OStEXT(   ostoSay , TUCK << 2 ) ;

        tinP.pAdamGlobal1->_etherC_.pHdll = 0 ;
        ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN71 ) ;
        }
            _OUT_
            ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN61 ) ;
            }
                ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN51 ) ;
                }
                    }
                        while( !( F(thirdC::third_flagsProcessStateI_IF(tinP)) & flPROCESSsTATE_tmWindowsF_HASeNDED ) ) { ++ s ; thirdC::dosSleepRawIF( tinP , 250 ) ; }
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    thirdC::third_flagsProcessStateI_IF( tinP , flPROCESSsTATE_MAINtHREADcLEANUPiScOMPLETE , 1 ) ;
                    //if( idTypeP == ifcIDtYPEtLS_WINDOW && !idCmdShowP && !hPreviousWindowingClientP ) { ZE( countT , foo ) ; } //U:: CONJ: NOT NEEDED
                {
                if( idTypeP == ifcIDtYPEtLS_WINDOW )
                ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN41 ) ;

                if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN31 ) ;
    
                if( thirdC::third_cThirdObjectsI_IF( tinP ) ) ;//TELLc1( ifcIDtYPEtELL_ERRORsOMEtHIRDoBJECTSeXIST )
                ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN21 ) ;
                }
                    ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN11 ) ;
                    }
                        ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN01 ) ;
                        }
                            ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAINf ) ;
                            _OUT_
                            if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                            ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAINe ) ;
                            }
                                ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAINd ) ;
                                }
                                    TELL( "main: destroying ether" ) ;
                                    if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                    TINSL
                                {
                                _OUT_
                                ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAINc ) ;
                                }
                                    ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAINb ) ;

                                    TELL( "main: destroying etThread and tinP reference" ) ;

                                    //U::POOLS 2 3 4 WERE DESTROYED HERE

                                    ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAINa ) ;
                                    DEL( tinP.pAdamGlobal1->pBksLog ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN9 ) ;
                                    TELL( "main: destroying log" ) ;

                                    }
                                        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                        TINSL
                                    {
                                    TELL( "main: inspecting phase 2" ) ;
    
                                    ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN8 ) ;
                                    DEL( tinP.pEtScratch ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN7 ) ;
                                    TELL( "main: destroying pEtScratch" ) ;
                                    if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                    TELL( "main: inspecting phase" ) ;
                                    //if( etThread ) thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_etThreadONmainISiMPOTENT ;
                                    //tinP.pEther = 0 ;
                
                                    tinP.tally.flushF( tinP , etThread ) ;
                                    tinP.tally.nowF( tinP , etThread ) ;
                                    tinP.tally.bTally = 0 ;
                                    ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN6 ) ;
                
                                    }
                                        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                        ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN5 ) ;
                                        }
                                            THREADmODE1rESTORE
                                            etThread.socksShutdownF( tinP ) ;
                                            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                        {
                                        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }

                                        _OUT_
                                        ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN4 ) ;
                                        }
                                            _OUT_
                                            ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN3 ) ;
                                            }
                                                DEL( tinP.pAdamGlobal1->_deviceC_pStkJob ) ;
                                                DELzOMBIE( pDisplay ) ;
                                            {
                                            if( idTypeP == ifcIDtYPEtLS_WINDOW )

                                            if( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_WHEREaLL ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;
                                            }
                                                _OUT_
                                                TELLc1( ifcIDtYPEtELL_AOKfYIjUSTcALLEDaDAMmAIN ) 
                                                TELL( "main: returned from pMainF" ) ;
                                                }
                                                    _OUT_
                                                    ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN2 ) ;
                                                    tinP.unwatchedF() ;
                                                    //etherC::ifcSayIF( T("called pMainF") , flSAY_APPEND | flSAY_LOG ) ;
                                                    if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                                    cryC cry0d( TOCK + 0x0d ) ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EPILOGaDAMmAIN1 ) ;
                                                    }
                                                        _OUT_
                                                        (*pMainF)( &main ) ; // ASSUME: WILL NOT RETURN UNTIL ALL KID THREADS HAVE ENDED, INCLUDING tmWatchF
                                                        _INoLD_
                                                    {
                                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN23 ) ;
                                                    cryC cry0c( TOCK + 0x0c ) ;

                                                    __( tinP.pAdamGlobal1->idMemorySpace - rootAdamGlobal1I.idMemorySpace ) ; // THIS ENSURES THAT ALL ADAMS WITHIN A PROCESS ARE USING THE SAME MEMORY SPACE (THEY HAVE ACCESS TO PROCESS GLOBALS THAT USE A MEMORY SPACE)

                                                    }
                                                        countT foo = 2 ;
                                                    {
                                                    if( idAdamWant == tinP.pAdamGlobal1->idAdam )
                                                    static countT idAdamWant = 0x401057b ; //TO FACILITATE WDW DEBUGGING

                                                    if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                                                    //etherC::ifcSayIF( T("calling pMainF") , flSAY_APPEND | flSAY_LOG ) ;
                                                    _INoLD_
                                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN13 ) ;
                                                {
        
                                                TELL( "main: calling pMainF" ) ;
                                                TELLc1( ifcIDtYPEtELL_AOKfYIaBOUTtOcALLaDAMmAIN ) 
                                                declareVmUsageTypeGF( tinP , (byteT*)pMainF , flVMuSAGEtYPE_CODEaDAM ) ;
                                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN03 ) ;
                                                _INoLD_
                                            {
                                            else
                                            }
                                                _OUT_
                                                tinP.unwatchedF() ;
                                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINf2 ) ;
                                                _INoLD_
                                            {
                                            if( !pMainF || ether )

                                            TELL( "main: mainS object constructed" ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINe2 ) ;
                
                                            mainS main( tinP , ether , etThread , hDll , T("cid ")+tCid+T(" level 1") ) ;
                                            TELL( "main: constructing mainS object" ) ;

                                            }
                                                _OUT_
                                                __Z( pMainF ) ;
                                                etThread.dllEntryF( tinP , pMainF , hDll , T("mainF") ) ;
                                                __Z( hDll ) ;
                                                etThread.delF( tinP , psttDll ) ;
                                                TELL( "main: looking up the entry point" ) ;
                                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINd2 ) ;
                                                _INoLD_
                                            {
                                            ZE( mainFT , pMainF ) ;

                                            }
                                                _OUT_
                                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINc2 ) ;
                                                }
                                                    _OUT_
                                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINb2 ) ;
                                                    }
                                                        etThread.dllOpenF( tinP , hDll , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.")+T(psttDll)+T(".ipdos-wd") ) ;
                                                        //hoverC hover( tinP , etThread , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/") ) ;
                                                    {
                                                    else
                                                    if( etThread.strIdF( tinP , S1C('/') , psttDll ) ) etThread.dllOpenF( tinP , hDll , psttDll ) ;

                                                    // state C IS OBSOLETED BY THE adam.perm POOL AND ALL state C CODE SHOULD BE MIGRATED AND THEN state C REMOVED
                                                    // THIS FEATURE IS BROKEN AND REQUIRES WORK

                                                    // THE OLD INSTANCE WILL COMPLETE ALL SERVICE TO EXISTING CLIENTS AND THEN TERMINATE
                                                    // THE NEW INSTANCE WILL IMMEDIATELY ASSUME RESPONSIBILITY FOR ACCEPTING NEW CLIENTS
                                                    // BY DEFAULT, ONLY ONE INSTANCE OF AN ADAM CAN EXIST AT A TIME IN A HOME
                                                    // THE FOLLOWING COMMENTS ARE OBSOLETE; MULTIPLE INSTANCES CAN COEXIST (SEE E.G. ifcIDaDAM_CLOUD); THE OLD HANDOFF CODE WAS DISABLED/REMOVED AND CODE RELATED TO SAVING AND LOADING ADAM STATE IS DISABLED OR IN AN UNKNOWN UNUSED STATE

                                                    // A MASTER FILE CAN BE UPDATED WHILE ITS CORRESPONDING HOVER FILE IS LOADED AND IN USE BY RUNNING PROCESSES

                                                    // THE MAIN (PERHAPS ONLY) REASON FOR THIS IS TO MAKE "HOT UPDATING" POSSIBLE
                                                    // IPDOS PROCESSES ARE NORMALLY LOADED FROM THE HOVER DIRECTORY
                                                    // THIS WILL BE DONE IF THE EXE IMAGE IS COMING FROM THE HOVER DIRECTORY

                                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINa2 ) ;
                                                    _INoLD_
                                                {
                                                else
                                                }
                                                    _OUT_
                                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN92 ) ;
                                                    etThread.dllOpenF( tinP , hDll , T("ideafarm.")+T(psttDll)+T(".ipdos-wm") ) ;
                                                    __( etThread.strIdF( tinP , S1C('/') , psttDll ) ) ;

                                                    // FOR EXAMPLE, WHEN INSTALLING THE BUILD FOLDER ON A NEW DEVELOPMENT COMPUTER, THE BUILD PROGRAMS (IN BENCH) WILL BUILD THE MASTER FILES AND THEN LOAD PROCESSES FROM THEM TO BUILD THE HOVER FILES
                                                    // IPDOS PROCESSES ARE ONLY LAUNCHED FROM THE MASTER DIRECTORY WHEN THE DESIRED IMAGE DOES NOT EXIST IN THE HOVER DIRECTORY
                                                    // THIS WILL BE DONE IF THE EXE IMAGE IS COMING FROM THE MASTER DIRECTORY

                                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN82 ) ;
                                                    _INoLD_
                                                {
                                                else if( !etThread.strCompareF( tinP , T(thirdC::postBaseNameIF(tinP)) , T(ostoCopy) ) ) // THE SMUDGER THAT MAKES THE HOVER FILE WILL NOT REPLACE ostoCopy BUT IT WILL REPLACE THE STRING IN postBasenameIF
                                                }
                                                    _OUT_
                                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN72 ) ;
                                                    etThread.dllOpenF( tinP , hDll , psttDll ) ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN62 ) ;
                                                    _INoLD_
                                                {
                                                if( etThread.strIdF( tinP , T("/IdeaFarm " "(tm) Removal Utility/") , psttDll ) )
                                                ( (osTextT*)(const osTextT*)ostoCopy )[ 9 ] = '8' ;
                                                OStEXTV( ostoCopy , "ideafarm.@1000001.ipdos-wm" )
                                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN52 ) ;
                                                _INoLD_
                                            {
                                            TELL( "main: linking in the adam dll" ) ;

                                            TNCID ;
                                            //U:etThread.constructedInLine = 0 ;
                                            //U:etThread.postcConstructedInFile = ppostHowP[ 1 ] ;
                                            ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN42 ) ;

                                            }
                                                _OUT_
                                                pDisplay = new( 0 , tinP , pbDisplay , sizeof pbDisplay ) displayC( tinP , etThread , ((measureT)1e1) , 0 , 0 , flDEVICEc_NOsMOOTHIES ) ; //USE SMOOTHIES IN PRODUCTION BUT NOT FOR SOME TESTING
                                                tinP.pAdamGlobal1->_deviceC_pStkJob = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_GIVEsIGNnEWpLATE , sizeof( drawJobS ) ) ; ___( tinP.pAdamGlobal1->_deviceC_pStkJob ) ;
                                                _INoLD_
                                            {
                                            if( idTypeP == ifcIDtYPEtLS_WINDOW )        //U:: 20200314@1545: CT THIS STACK FAILS ON NONMONOTONIC GRAB.  TESTING OF NONMONOTONIC GRAB ENFORCEMENT DID NOT INCLUDE TESTS FOR GUI PROCESSES
                                            ZE( displayC* , pDisplay ) ;
                                            byteT pbDisplay[ sizeof( displayC ) ] ;
                                            ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN32 ) ;
        
                                            }
                                                _OUT_
                                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN22 ) ;
                                                sgnWatchReady.waitF( tinP ) ;
                                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN12 ) ;

                                                }
                                                    sgnWatchReady.giveF( tinP ) ;
                                                    if( idTypeP == ifcIDtYPEtLS_WINDOW ) sgnWindowsReady.waitF( tinP ) ;
                                                {
                                                if( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS )

                                                }
                                                    etThread.osThreadF( tinP , countTC() , tmWindowsF , 0 , flTHREADlAUNCH_null , 0 , (countT)&sgnWindowsReady , (countT)&psttTitle ) ;
                                                    thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_tmWindows ;
                                                {
                                                else
                                                }
                                                    etThread.delF( tinP , psttTitle ) ;
                                                    etThread.winSetTitleF( tinP , psttTitle ) ;
                                                    sgnWindowsReady.giveF( tinP ) ;
                                                {
                                                if( idTypeP != ifcIDtYPEtLS_WINDOW )
                                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN02 ) ;

                                                //ether.osSleepF( tinP , TOCK << 2 ) ;
                                                //sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                                                //etThread.winSetTitleF( tinP , T("tmWatchF launched ; napping for 4 tocks") ) ;
                                                //TO FIND BUGS
            
                                                //etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_NORMAL ) ;

                                                else                                                                                     etThread.traceF( tinP , T("warning: build is configured for \"no system threads\"") ) ;
                                                if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS ) ) etThread.osThreadF( tinP , countTC() , tmWatchF , 0 , flTHREADlAUNCH_null , 0 , (countT)&sgnWatchReady , (countT)&sgnWindowsReady ) ;
                                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINf1 ) ;

                                                //etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;
    
                                                signC sgnWindowsReady( tinP , TAG( TAGiDnULL ) ) ;
                                                signC sgnWatchReady( tinP , TAG( TAGiDnULL ) ) ;
                                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINe1 ) ;
                                                _INoLD_
                                            {
        
                                            __( &sadams - sadamsC::pSadamsIF( tinP ) ) ;
                                            sadamsC sadams( tinP , etThread , TAG( TAGiDnULL ) ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINd1 ) ;

                                            }
                                                _OUT_
                                                etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , 0x30 ) ;
                                                _INoLD_
                                            {
                                            if( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_WHEREaLL )

                                            //etherC::ifcSayIF( T("ADAM CELL (idAdam,osPid): ")+TF1(processGlobal1I.idAdamRoot)+T(" ")+TF1(tinP.osPid)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                                            }
                                                _OUT_
                                                etThread.traceF( tinP , tTitle ) ; //RETAIN THIS; IT IS USEFUL TO DEFEND AGAINST ATTACK
                                            
                                                ;
                                                    +t8+T("P_")+TF2(tinP.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("(")+TF4(tinP.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(")")
                                                    +t8+T("F_")+TF2(tinP.pAdamGlobal1->idGroupFireAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                    +t8+T("A+")+TF2(tinP.pAdamGlobal1->idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("(")+TF2(tinP.pAdamGlobal1->idAdam&0xfff,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(")")
                                                    +t8+T("A_")+TF2(rootAdamGlobal1I.idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("(")+TF2(processGlobal1I.idAdamRoot&0xfff,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(")")
                                                    +t8+T("M_")+TF2(tinP.pAdamGlobal1->idMemorySpace,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                    +t8+T("H_")+TF2(processGlobal1I.idHome,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                    T(postIPDOSsHORT)
                                                TN( tTitle , "" ) ; tTitle =

                                                TN( t8 , "        " ) ;
                                                _INoLD_
                                            {
                                            ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINc1 ) ;

                                            }
                                                _OUT_
                                                #endif

                                                    etThread.strMakeF( tinP , psttDll , TF3(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( psttDll ) ;

                                                #else

                                                }
                                                    break ;
                                                    etThread.strMakeF( tinP , psttDll , psttc1 ) ; ___( psttDll ) ;
                
                                                    if( !psttc1->idAdam || psttc1[ CSpREFIX ] == sttExclaim ) break ;
                                                    if( cSkip -- ) continue ;
                                                    //CONoUTrAW( T("parameter: \"")+T(psttc1)+T("\"\r\n") ) ;
                                                {
                                                FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )
                                                strokeS sttExclaim('!') ;
                                                countT cSkip = 1 ;

                                                // THE TRAILING FO SYMBOLS AND ~ AND ` SHOULD NOT BE USED FOR PARAMETER KEYS BECAUSE THEY WOULD BE USEFUL AS OPERATORS
                                                // RESERVED: ` ~ ! @ # $ % ^ & * - + =
                                                // NEW CONFORMANCE SPEC:  PARAMETER KEYS CAN START WITH EITHER '!' OR '@', WITH POSSIBLE FUTURE USE OF '#', '$', '%', ... TO RESERVE SUCH USE OF ALL OF THE SYMBOLS IN THE TOPMOST ROW OF THE US KEYBOARD
                                                // THIS DECISION TO USE '@' RATHER THAN '!' MIGHT BE THE BEGINNING OF CHANGING CONFORMANCE RULES TO ABANDON THE SPEC THAT ALL PARAMETER KEYS START WITH '!'
                                                // 20181113@0922:

                                                // OTHERWISE, THE SYMBOLIC ADAMS WOULD BE OF THE FORM "!aFind", AND SPECIFYING THEM WOULD CAUSE ME TO THINK THAT NO idAdam WAS SPECIFIED, UNLESS ALL OF THEIR POSSIBLE VALUES WERE HARDCODED IN ME
                                                // '@' IS USED RATHER THAN '!' SO THAT I CAN LOOK AT ONLY THE WOTH CHARACTER TO DETECT THE ABSENCE OF AN idAdam SPECIFICATION IN THE WOTH PARAMETER AFTER THE EXE NAME
                                                // 20181112@1144: THE WOTH ARGUMENT (IDENTIFYING idAdam) IS NOW ALLOWED TO BE SYMBOLIC, E.G. "@find", SO THIS CODE IS REPLACED WITH CODE THAT USES processGlobal1I.idAdamRoot

                                                #if defined( NEVERdEFINED )
                                                _INoLD_
                                            {
                                            ZE( strokeS* , psttDll ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINb1 ) ;
                                            _INoLD_
                                        {
                                        else
                                        }
                                            _OUT_
                                            ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINa1 ) ;
                                            _INoLD_
                                        {
                                        if( ether )
                                        _INoLD_

                                        etThread.ifcDatumF( tinP , flDATUM1_CLASStRACEaLWAYShIRE , flDATUM2_null , 0 , 0 , 0 , (voidT*)DDNAME ) ;
                                        if( !( F(thirdC::third_flagsModeProcess2I_IF(tinP)) & flMODEpROCESS2_NOsYSTEMtHREADS ) ) etThread.osThreadF( tinP , countTC() , tmTimeNowF ) ;
                                        etThread.socksSetupF( tinP ) ; /*U:NEEDED FOR ifcDatumF.  THIS FORCES FULL TIME CONNECT ON Windows USERS*/
                                        ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN91 ) ;

                                        TELL( "main: parameters scanned" ) ;
                                        }
                                            //etThread.traceF( tinP , T("adam parameters (command line arguments) END [idAdam]:    ")+TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            }
                                                //U::if( bOk ) etThread.strokeF( tinP , T("process parameter \"")+T(psttc1)+T("\" recognized\r\n") ) ;

                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!dead"              ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_LOGdEADLOCKS                     ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!hideWithIcon"      ) ) ) { thirdC::third_flagsModeProcess2I_IF(tinP) |= flMODEpROCESS2_HIDEwITHiCON                 ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!noSynchronousTells") ) ) { thirdC::third_flagsModeProcess2I_IF(tinP) |= flMODEpROCESS2_NOsYNCHRONOUStELLS           ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!noTells"           ) ) ) { thirdC::third_flagsModeProcess2I_IF(tinP) |= flMODEpROCESS2_SUPPRESStELLS                ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!noTellsHome"       ) ) ) { homeS::homeIF().flags |= flHOMEs_SUPPRESStELLS                                           ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!whereAll"          ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_WHEREaLL                         ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!noGlobalGrab"      ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_DISALLOWgRABoFiNTERPROCESSgRABs  ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!minimized"         ) ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_LAUNCHmINIMIZED            ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!quitAtShutdown"    ) ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_QUITaTsHUTDOWN             ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!quitAtLogoff"      ) ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_QUITaTlOGOFF               ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!log2monitor"       ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_LOG | flADAMmODE1_LOGtOmONITOR   ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!log2popup"         ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_LOG | flADAMmODE1_LOGtOpOPUP     ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!log2file"          ) ) ) { thirdC::third_flagsModeAdam1I_IF( tinP ) |= flADAMmODE1_LOG | flADAMmODE1_LOGtOfILE      ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!faceHear"          ) ) ) { idArg = 3                                                                                ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!cUtility"          ) ) ) { idArg = 2                                                                                ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!idCitizenHirerI"   ) ) ) { idArg = 1                                                                                ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!bWatchSay"         ) ) ) { etThread.flagsWatch |=  flWATCH_SAY                                                      ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!bWatchEmployers"   ) ) ) { etThread.flagsWatch |=  flWATCH_EMPLOYERS                                                ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!bWatchTimeNo"      ) ) ) { etThread.flagsWatch &= ~( F(flWATCH_TIME) )                                              ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!debug"             ) ) ) { thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_DEBUG  ;                   ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!testAutoDoSleeps"  ) ) ) { etThread.flagsMode  |=  flTHIRDmODE_TESTaUTOdOsLEEPS                                     ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!testAuto"          ) ) ) { etThread.flagsMode  |=  flTHIRDmODE_TESTaUTO                                             ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!bWatchfulINo"      ) ) ) { ((thirdC&)ether).third_bWatchfulI_F( tinP ) = 0                                          ; bOk = 1 ; }
                                                else if( !etThread.strCompareF( tinP , psttc1 , T("!bCarefulINo"       ) ) ) { ((thirdC&)ether).third_bCarefulI_F( tinP ) = 0                                           ; bOk = 1 ; }
                                                //CS:CODEsYNC: 33000065 33000065
                                                }
                                                    }
                                                        }
                                                            break ;
                                                            if( psttc1->idAdam && 1 == etThread.strIdF( tinP , idf , sttq , S1C('!') , psttc1 ) ) idArg = 0 ;
                                                            countT idf = 1 ;
                                                            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                                        {
                                                        case  3 :
                                                        case  2 : { idArg = 0 ; etherC::ether_cUtility_IF( tinP )          = etThread.strDigitsToSCountF( tinP , psttc1 ) ; bOk = 1 ; break ; }
                                                        case  1 : { idArg = 0 ; etThread.ether_idCitizenHirerI_F( tinP ) = etThread.strDigitsToSCountF( tinP , psttc1 ) ; bOk = 1 ; break ; }
                                                    {
                                                    switch( idArg )
                                                {
                                                if( idArg )
                                                ZE( boolT , bOk ) ;

                                                if( idTypeP == ifcIDtYPEtLS_WINDOW && !psttTitle && ( off ++ ) == 1 ) { etThread.strMakeF( tinP , psttTitle , psttc1 ) ; ___( psttTitle ) ; }

                                                //etThread.traceF( tinP , T("    [parameter]: ")+T(psttc1) ) ;
                                            {
                                            FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )
                                            ZE( countT , idArg ) ;
                                            ZE( countT , off ) ;
                                            //etThread.traceF( tinP , T("adam parameters (command line arguments) BEGIN [idAdam]:    ")+TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        {
                                        TELL( "main: inspecting process parameters" ) ;

                                        etThread.etherScanProcessParametersF( tinP ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN81 ) ;

                                        }
                                            //}
                                            //    etThread.traceF( tinP , T("parameter: \"")+T(psttc1)+T("\"") ) ;
                                            //{
                                            //FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )

                                            }
                                                }
                                                    etThread.strFuseSeparateF( tinP , etThread.ether_pstt1_processParametersI_F( tinP ) , tMonitor ) ;
                                                    etThread.strFuseSeparateF( tinP , etThread.ether_pstt1_processParametersI_F( tinP ) , tDriver  ) ;
                                                {
                                                )
                                                    )
                                                        )
                                                            *ppostHowP[ off + 1 ] == '!'
                                                        (
                                                        ||
                                                        cHowP == 1
                                                    (
                                                    &&
                                                    && !off
                                                       bOsSupportsServices
                                                (
                                                if
                                                etThread.strFuseSeparateF( tinP , etThread.ether_pstt1_processParametersI_F( tinP ) , T(ppostHowP[off]) ) ; ___( etThread.ether_pstt1_processParametersI_F( tinP ) ) ;
                                            {
                                            for( countT off = 0 ; off < cHowP ; off ++ )

                                            etThread.strMakeF( tinP , etThread.ether_pstt1_processParametersI_F( tinP ) , 0 , csttNeeded ) ; ___( etThread.ether_pstt1_processParametersI_F( tinP ) ) ;
                                            }
                                                csttNeeded += 2 * CSpREFIX + tDriver.csF( tinP ) + tMonitor.csF( tinP ) ;
                                                )
                                                    )
                                                        )
                                                            *ppostHowP[ off + 1 ] == '!'
                                                        (
                                                        ||
                                                        cHowP == 1
                                                    (
                                                    &&
                                                    && !off
                                                       bOsSupportsServices
                                                (
                                                if

                                                csttNeeded += CSpREFIX + thirdC::c_strlenIF( tinP , ppostHowP[off] ) ;
                                            {
                                            for( countT off = 0 ; off < cHowP ; off ++ )
                                            countT csttNeeded = CSpREFIX ;

                                            }
                                                tMonitor = TF1(ifcIDaDAM_KERNEL2MONITOR) ;
                                                tDriver  = TF1(ifcIDaDAM_KERNEL1DRIVER)  ;
                                            {
                                            if( bOsSupportsServices )
                                            TN( tMonitor , "" ) ;
                                            TN( tDriver  , "" ) ;
                                        {
                                        ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN71 ) ;

                                        }
                                            etThread.strMakeF( tinP , psttTitle , tAdam+t8b+T(postIPDOSsHORTlONG)+( processGlobal1I.idHome==1 ? T("") : T(" (home ")+TF2(processGlobal1I.idHome,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(")") ) ) ; ___( psttTitle ) ;

                                            TN( t8b , "        " ) ;
                                            if( !tAdam.csF( tinP ) ) tAdam = TF2(tinP.pAdamGlobal1->idAdam,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
                                            TN( tAdam , "" )       ; tAdam = T(mapAdam(tinP.pAdamGlobal1->idAdam)) ;

                                            mapCTC& mapAdam = processGlobal3S::_processGlobal3I_IF().mapAdam ;
                                        {
                                        ZE( strokeS* , psttTitle ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN61 ) ;

                                        tinP.time2    = timeBorn.time2 ;
                                        tinP.time1    = timeBorn.time1 ;
                                        etThread.osTimeNowF( tinP , timeBorn.time1 , timeBorn.time2 ) ;
                                        timeS timeBorn ;
                                        TELL( "main: informing ether of time and of process parameters" ) ;
    
                                        /*U:((thirdC&)ether).osRealtimeModeOnF( tinP ) ;*/
                
                                        etThread.delF( tinP , psttDriverName ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN51 ) ;
                                    {
                                    if( !ether )
                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN41 ) ;
        
                                    }
                                        bServiceManagerHiredMe = ifcDRIVERsTATUS_STARTING == ((thirdC&)ether).osDriverStatusF( tinP , T(psttDriverName) ) ;
                                        etThread.osDriverNameFromMasterF( tinP , psttDriverName , ifcIDaDAM_KERNEL2MONITOR ) ; ___( psttDriverName ) ;
                                        TELL( "main: setting bServiceManagerHiredMe" ) ;
                                    {
                                    if( ( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WITHINpROCESS ) && cHowP == 1 && bOsSupportsServices )
                                    ZE( strokeS* , psttDriverName ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN31 ) ;

                                    cryC cry0b( TOCK + 0x0b ) ;
                                    tinP.pAdamGlobal1->pBksLog = new( 0 , tinP , LF ) booksC( tinP , TAG( TAGiDnULL ) , "log" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER , TOCK ) ; ___( tinP.pAdamGlobal1->pBksLog ) ;
                                    cryC cry0a( TOCK + 0x0a ) ;
                                    TELL( "main: constructing log" ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN21 ) ;

                                    tinP.tally.bTally = 1 ;
                                    tinP.tally.nowF( tinP , etThread ) ;
                                    tinP.tally.resetF( tinP ) ;
                
                                    tinP.pAdamGlobal1->pEtThreadMain = tinP.pEther = &etThread ;
                                    TELL( "main: " ) ;
                                    TELL( "main: ether and etThread constructed" ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN11 ) ;
    
                                    //__( tinP.monitor.idThread - ifcIDtHREADlOW_main ) ;
                                    scoopC scoop( tinP , etThread ) ;
                                    TELL( "constructed tinP.pEtScratch" ) ;
                                    tinP.pEtScratch = new( 0 , tinP , LF ) etherC( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ; ___( tinP.pEtScratch ) ;
                                    TELL( "constructing tinP.pEtScratch" ) ;
                                    TELL( "constructed etThread" ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN01 ) ;

                                    if( processGlobal1I.idNumaNode ) etThread.traceF( tinP , T("NUMA:  this process will default to limiting itself to using a single NUMA node on NUMA computers [idNumaNode]: ")+TF2(processGlobal1I.idNumaNode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    }
                                        if( pPoop ) ;
                                        poopC* pPoop = (poopC*)&(const poopC&)etThread ;
                                    {   //TO FACILITATE DEBUGGING (CAN SET A WATCHPOINT HERE TO BREAK WHEN pPoop->idSubType CHANGES)

                                    cryC cry09( TOCK + 0x09 ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINf ) ;
                                    etherC etThread( tinP , TAG( TAGiDnULL ) ) ;
                                    cryC cry08( TOCK + 0x08 ) ;
                                    TELL( "constructing etThread" ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINe ) ;
                                {
                                if( !ether )

                                tinP.pEther = &ether ;
                                _INoLD_
    
                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINd ) ;
                                cryC cry07( TOCK + 0x07 ) ;
                                TELL( "constructed ether" ) ;
                                etherC ether( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_TINoWNER | flTHIRDmODE_QUITTER /* | flTHIRDmODE_CHECKpOOLoLD */ ) ; //DEBUGGING: TURN ON flTHIRDmODE_CHECKpOOLoLD HERE
                                TELL( "constructing ether" ) ;
                                cryC cry06( TOCK + 0x06 ) ;
                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINc ) ;
    
                                }
                                    //DELzOMBIE( pbnu ) ;
                                    //declareVmUsageTypeGF( tinP , pbnu , flVMuSAGEtYPE_DEFAULThEAP ) ;
                                    //byteT* pbnu = new byteT ;
                                    //U::NOW THAT I AM IN base, THE NEXT LINE EXERCISES THE OVERLOAD SO DOES NOT WORK
                                {
                                declareVmUsageTypeGF( tinP , (byteT*)declareVmUsageTypeGF , flVMuSAGEtYPE_CODEbASE ) ;
        
                                tinP.idlTask  = ifcLINE ;
                                tinP.idiTask  = DDNUMB ;
                                putNegAM( tinP.fingerprint , FINGERnEG_TINs ) ;
                                ___( &tinP ) ;                                          /*HERE*/
                                TELL( "main: setting up" ) ;
                                ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINb ) ;
                                TINSL
                            {
                            if( bTinOk )
                            _INoLD_

                            ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAINa ) ;
                            cryC cry05( TOCK + 0x05 ) ;
                            }
                                _MOLE
                                TELL( "main: tinS, in poolOld is constructed" ) ;_
                                }
                                    TELLlIFInAME( postName ) ; //THE TELLlIFInAME MUST BE ON THE SAME LINE AS THE CONSTRUCTOR CALL
                                    bTinOk = 1 ;_
                                {
                                if( pTin ) // pTin WILL BE TAGGED AT /*HERE*/
                                TINSL
                                tinS* pTin = new( 0 , tinP , LF ) tinS( tinP , TAG( TAGiDnULL ) , 0 , 0 , postName , flTINs_null , tinP.monitor.idThread == 1 ? ifcIDtINnAMED_tinInPoolMain : ifcIDtINnAMED_tinInPool ) ;_
                                osTextT* postName = POSTtHREADnAMEmAIN ;_
                                _MILE
                            {
                            ZE( boolT , bTinOk ) ;
                            cryC cry04( TOCK + 0x04 ) ;
                            ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN9 ) ;
    
                            //boolT bWorkNotRoot = !!thirdC::c_strcmpIF( tinP , ostoPoolAdamTemp , "root" ) ; /* HANDY FOR DEBUGGING */
    
                            }
                                OStEXTAK( ostoPoolAdamTemp , "testAuto" )
                                OStEXTcLEAR( ostoPoolAdamTemp )
                            {
                            else if( bTestAuto )
                            }
                                //OStEXTAK( ostoPoolAdamTemp , "driver" )
                                //OStEXTcLEAR( ostoPoolAdamTemp )
                                //COMMENTED THIS OUT SO WILL USE LESS MEMORY, FOR SERVICE ON GODADDY VIRTUAL DEDICAED HOST THAT IS MEMORY CONSTRIAED
    
                            {
                            else if( cHowP == 1 ) //ASSUME: IF THERE ARE NO PARAMETERS THEN I WAS LAUNCHED BY THE WINDOWS SERVICE CONTROL MGR
                            }
                                }
                                    OStEXTAK( ostoPoolAdamTemp , "testAuto" )
                                    OStEXTcLEAR( ostoPoolAdamTemp )
                                {
                                if( bTestAuto )
                            {
                            if( idTypeP == ifcIDtYPEtLS_WINDOW )
                            ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN8 ) ;
                        {
                        if( !POOP )
                        ZE( boolT , bServiceManagerHiredMe ) ; // 1 IFF THE O.S. SUPPORTS "SERVICES" AND I AM THE INSTANCE BEING STARTED BY THE SERVICE MANAGER; WILL BE 0 IF I AM THE IDEAFARM DRIVER ON AN OS THAT DOES NOT SUPPORT "SERVICES"

                        if( !thirdC::third_idProcessOldI_IF( tinP ) ) thirdC::third_idProcessOldI_IF( tinP ) = - 1 ;
                        
                        //thirdC::third_flagsModeAdam2I_IF(tinP) |= flADAMmODE2_THREADcHATTER /*| flMODEpROCESS2_NOsYSTEMtHREADS*/ ;

                        cryC cry03( TOCK + 0x03 ) ;
                        ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN7 ) ;
                        #endif
                            poolC poolAdamTemp( tinP , TAG( TAGiDnULL ) , ostoPoolAdamTemp                 ) ; //MUST BE WOTH
                        #else
                            poolC poolAdamTemp( tinP , TAG( TAGiDnULL ) , ostoPoolAdamTemp , flPOOLc_NOTES ) ; //MUST BE WOTH
                        #if defined( ENABLEdROPnOTES )
                        ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN6 ) ;
                        // UNDEFINE ENABLEdROPnOTES IN PRODUCTION AND WHEN NOT CHECKING FOR LEAKS
                        cryC cry02( TOCK + 0x02 ) ;
                        
                        //CS:CODEsYNC: 0b50064 0b50064 21b0002 21b0003
                        //WHEN A BUG IS LOCATED THAT IS DUE TO CODE OUT OF SYNC, EDIT CODE TO CONDITIONALLY COMPILE BASED ON WHETHER ENABLEdROPnOTES IS DEFINED
                        //20141026@1654: IGNORE THIS CS COMMENT; IT IS UNUSEABLE SINCE IT REFERENCES OBSOLETE MODULE NUMBERS (BEFORE ALL FILES IN DICTIONARY WERE RENUMBERED TO A NEW NUMBERING SCHEME YEARS AGO)
                        
                        //TO DEBUG FOR LEAKS OR TO USE poolC::reportF, ENABLE THE  FLAG HERE AND ALSO ENABLE THE DEFINITION OF THE "ENABLEdROPnOTES" SYMBOLIC CONSTANT
                        
                        //U:: ifcIDsTATEsPACE_MULTIPLEaDAMS: REMOVE IN PRODUCTION AND WHEN NOT INVESTIGATING LEAKAGE
                        
                        OStEXTC(  ostoPoolAdamTemp , tinP.osPid , 0 )                   //20141129@1426: ADDED TO UNIQUIFY SO THAT MULTIPLE INSTANCES OF SAME idAdam CAN COEXIST
                        OStEXTAK( ostoPoolAdamTemp , "." )
                        OStEXTC(  ostoPoolAdamTemp , tinP.pAdamGlobal1->idAdam , 0 )
                        OStEXTAK( ostoPoolAdamTemp , "adam.temp." )
                        OStEXT( ostoPoolAdamTemp , TUCK << 2 )
                        ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN5 ) ;
                    {
                    if( !POOP )
                    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN4 ) ;
                {
            {
            cryC cry01( TOCK + 0x01 ) ;
            _INoLD_

            }
                }
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!threadChatter"            ) ) { thirdC::third_flagsModeAdam2I_IF( tinP    ) |= flADAMmODE2_THREADcHATTER ; }
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!noSystemThreads"          ) ) { thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_NOsYSTEMtHREADS ; }
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!noInterprocessGrabs"      ) ) { thirdC::third_flagsModeAdam1I_IF( tinP    ) |= flADAMmODE1_DISALLOWgRABoFiNTERPROCESSgRABs ; }
                    //else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!utility0"               ) ) { tinP.pc Utility[ 0 ] = 1 ; }
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!utility"                  ) ) { thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_CHECKtINuTILITYeLEMENTS ; }
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!debug1"                   ) ) { thirdC::third_flagsModeAdam1I_IF( tinP    ) |= flADAMmODE1_DEBUG1 ; }
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!debug"                    ) ) { thirdC::third_flagsModeProcess2I_IF( tinP ) |= flMODEpROCESS2_DEBUG  ; }
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!jot"                      ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_JOT ; }
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!ignoreFireByOperator"     ) ) { thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_IGNOREfIREbYoPERATOR ; }
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!threadFiles"              ) ) { thirdC::third_flagsModeAdam1I_IF( tinP    ) |= flADAMmODE1_SEEtHREADSaSfILES ; }
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!quietConsole"             ) ) { thirdC::third_flagsModeAdam1I_IF( tinP    ) |= flADAMmODE1_QUIETcONSOLE ; } // WIN32 DOES NOT PROVIDE A WAY TO QUERY WHETHER THIS PROCESS IS ATTACHED TO A CONSOLE; CALLING system( cls ) WHEN NOT ATTACHED CAUSES A CONSOLE WINDOW TO MOMENTARILY APPEAR; THE WORKAROUND IS TO USE A CMD LINE PARAMETER; DETACHED PROCESSES THAT ALLOCATE A CONSOLE MUST MAINTAIN (RESET) THIS FLAG
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!testAuto"                 ) ) { bTestAuto      = 1                        ; }
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!idProcessOld"             ) ) { idArg          = 2                        ; }
                    else if( !thirdC::c_strcmpIF( tinP , ppostHowP[ idp - 1 ] , "!idTrial"                  ) ) { idArg          = 5                        ; }
                    //CS:CODEsYNC: 33000065 33000065
                    }
                        }
                            case 5 : { idArg = 0 ; thirdC::third_idTrialI_IF( tinP ) = thirdC::c_atoiIF( tinP , ppostHowP[ idp - 1 ] ) ; break ; }
                            case 2 : { idArg = 0 ; thirdC::third_idProcessOldI_IF( tinP ) = thirdC::c_atoiIF( tinP , ppostHowP[ idp - 1 ] ) ; break ; }
                        {
                        switch( idArg )
                    {
                    if( idArg )
                {
                for( countT idp = 1 ; idp <= cHowP ; idp ++ )
                ZE( countT , idArg ) ;
    
                }
                    thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_DRIVER ; //I WANT TO SET flMODEpROCESS1_DRIVER BIT AS SOON AS I KNOW THAT I AM THE DRIVER PROCESS, SO THAT I WILL GET POPUP IF AN EXCEPTION OCCURS
                    bPseudoService = 1 ;
                {
                else
                }
                    thirdC::third_flagsModeProcess1I_IF( tinP ) |= flMODEpROCESS1_DRIVER ; //I WANT TO SET flMODEpROCESS1_DRIVER BIT AS SOON AS I KNOW THAT I AM THE DRIVER PROCESS, SO THAT I WILL GET POPUP IF AN EXCEPTION OCCURS
                {
                else if( bOsSupportsServices )
                if( cHowP > 1 ) ;
                ZE( boolT , bPseudoService ) ;

                }
                    _OUT_
                    ppostHowP = ppostHow ;
                    cHowP = cHow ;
    
                    }
                        }
                            if( ( !off || !postOldCopy[ off - 1 ] ) && postOldCopy[ off ] ) ppostHow[ cHow ++ ] = postOldCopy + off ;
    
                            if( !postOldCopy[ off ] ) continue ;
                        {
                        for( countT off = 0 ; off < costCopy && cHow < sizeof ppostHow / sizeof ppostHow[ 0 ] ; off ++ )
    
                        if( postOldCopy[ 1 ] != ':' ) ppostHow[ cHow ++ ] = postUnk ; //WINDOWS CMD.EXE DOES NOT INCLUDE THE EXE FILE NAME WITH THE PARAMETER LIST FOR GUI PROCESSES
    
                        }
                            }
                                off ++ ;
                                if( !bQuote && postOldCopy[ off ] == ' ' ) postOldCopy[ off ] = 0 ;
                                if( postOldCopy[ off ] == 0x22 ) bQuote = !bQuote ;
                            {
                            while( cToDo -- )
                            ZE( countT , off ) ;
                            countT cToDo = costCopy ;
                            ZE( boolT , bQuote ) ;
                        {
                        const countT costCopy = thirdC::c_strlenIF( postOldCopy ) ;
                        thirdC::c_strncpyIF( postOldCopy , postP , sizeof postOldCopy ) ;
                        osTextT postOldCopy[ 0x200 ] ;
                    {
                    const osTextT* postUnk = idTypeP == ifcIDtYPEtLS_WINDOW ? postUnk1 : postUnk2 ;
                    static const osTextT* const postUnk2 = "<withinDadProcess>" ;
                    static const osTextT* const postUnk1 = "<exeNameNotAvailable>" ;
                    ZE( countT , cHow ) ;
                    _INoLD_
                {
                if( idTypeP == ifcIDtYPEtLS_WINDOW || idTypeP == ifcIDtYPEtLS_WITHINpROCESS )
            {
            const boolT bOsSupportsServices = osId == 'w' ;
            const osTextT osId = thirdC::osIdIF( tinP ) ;
    
            ZE( boolT , bTestAuto ) ;
            ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN3 ) ;
        {
        tinP.pAdamGlobal1->_etherC_.pHdll = &hDll ;
        handleC hDll( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DLL ) ; //MUST NOT BE CLOSED UNTIL tmWindowsF HAS ENDED, BECAUSE LATTER CAN CALL CALLBACK FUNCTIONS DEFINED IN THE ADAM
    
        }
            if( !thirdC::third_hWindowingClientIF( tinP ) ) BLAMMO
            ((handleC&)thirdC::third_hWindowingClientIF( tinP )).osF( ifcIDtYPEhANDLE_WINDOWINGcLIENT , hWindowingClientIP ) ;

            //BLAMMO ; //20120907@1304: TO PREVENT THE BLACK SCREEN THAT IGNORES ALL HUMAN INPUT BECAUSE THE GRAPHICS PRESENTATION SYSTEM IS BEING REWRITTEN
            //AllocConsole() ; //U::DO THIS IFF PARAMETER IS SPECIFIED !console
        {
        if( idTypeP == ifcIDtYPEtLS_WINDOW )

        OStEXTcLEAR( _ostoTmp )
        osTextC _ostRangerTag( _ostoTmp.costF() + 1 , _ostoTmp , _statRangerTag , _statRangerTag.cbF() ) ;
        staticC _statRangerTag( tinP , "rangerTag" , "sys" , 2 * sizeof( countT ) + _ostoTmp.costF() + 1 , ifcIDtYPEsTATICC_FOOT ) ;
        OStEXTAK( _ostoTmp , "RangerTag:threadStack.tm1F.1" )
        OStEXTAK( _ostoTmp , "!ifc" )
        OStEXT(   _ostoTmp , 0x80 )

        etherC::paperZitsOffF( tinP ) ;

        if( tinP.monitor.idThread == 1 && !( ++ processGlobal1I.pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
        tinP.flagsThreadMode2 |= flTHREADmODE2_ADAMmAINtHREAD ;
        const osTextT* ppostHow[ 0x10 ] ; //WILL BE FILLED WITH REFERENCES TO SNIPS IN postOldCopy; ppostHowP WILL BE SET TO ME, SO I MUST EXIST WHILE ppostHowP IS VISIBLE
        ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN2 ) ;
    {
    thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_NORMAL ) ;

    }
        if( pRegs ) ;
        poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;

        homeS& home = homeS::homeIF() ;
    {

    //tinP.pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
    _INoLD_

    //}
    //    }
    //        poolt( tinP , pbt ) ;
    //        byteT* pbt = poolt.newF( tinP , LF , cbWant ) ;
    //
    //        while( cDo -- ) cbWant <<= 1 ;
    //        countT cDo = expCb ;
    //        countT cbWant = 1 ;
    //    {
    //    for( countT expCb = 0 ; expCb < 0x1e ; expCb ++ )
    //    p oolC poolt( tinP , TAG( TAGiDnULL ) , "test" , 0x10 ) ;
    //{
    //REMOVE THIS, OR MAKE IT A TESTER TO VERIFY THAT THIS MUCH MEMORY IS AVAILABLE

    cryC cry00( TOCK + 0x00 ) ;
    ADAMpHASE( ifcIDpHASEaDAM_PROLOGaDAMmAIN1 ) ;
{
/*1*/countT adamMainF( tinS& tinP , const countT idTypeP , countT cHowP , const osTextT** ppostHowP , countT hWindowingClientIP , countT hPreviousWindowingClientP , const osTextT* postP , countT idCmdShowP )/*1*/

#define ADAMpHASE(idPhaseP) if( thirdC::third_idPhaseAdam_IF( tinP ) < (idPhaseP) ) thirdC::third_idPhaseAdam_IF( tinP ) = (idPhaseP)

//U::MOVE TO SYMPOL DEF FILE

/**/
*/
/*
                                                   
//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

