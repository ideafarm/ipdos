
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

}
    etThread.traceF( tinP , T("waited  for workers") ) ;
    }
        ++ s ; etThread.osSleepF( tinP , TOCK ) ;
    {
    while( ws.cWorkers )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    etThread.traceF( tinP , T("waiting for workers") ) ;
    ws.bFireWorkers = 1 ;

    }
        etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE1 napped") ) ;
        ++ s ; ether.osSleepF( tinP , TOCK << 2 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE1 napping [cIn,cOut]:    ")+TF2(cIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        THREADmODE1rESTORE
        }
            }
                }
                    }
                        ++ s ; ether.osSleepF( tinP , TOCK >> 3 ) ;
                        etThread.traceF( tinP , T("waiting for queue to shrink [cPending]:    ")+TF2(ws.st_pPageEvent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    while( ws.st_pPageEvent > CwORKERS )
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                {                                                         // QUEUE LENGTH SHOULD ALSO BE KEPT SMALL FOR QUIT QUALITY, SINCE ALL QUEUED EVENTS MUST BE PROCESSED BEFORE I CAN DIE
                if( ws.st_pPageEvent > ( CwORKERS << 1 ) )                // THE QUEUE LENGTH MUST BE SMALL SO THAT IT IS IMPOSSIBLE FOR A QUEUED ITEM TO BE IN A BOOK OTHER THAN THE BOOK IMMEDIATELY PRECEDING THE BOOK BEING READ, ASSUMING THAT I ONLY KEEP WO INACTIVE BOOK

                bPrefix = !bPrefix ;

                else          pbi = 0 ;
                if( bDelete ) PUSE( tinP , *(byteT**)&pbi ) ;

                ;
                    : sizeof( countT )
                    ? *(countT*)pbi
                cbi = bPrefix

                }
                    //if( ws.idIn < TUCK || !( ws.idIn % TUCK ) ) etThread.traceF( tinP , T("[ws.idIn,cOutputFlavors]:    ")+TF2(ws.idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ws.swBooksByByte.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    ++ ws.idIn ;
                    cIn ++ ;
                    ws.st_pPageEvent << *(countT*)&pPageEvent ;

                    __( (countT)*pPageEvent - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;

                        THREADmODE3rESTORE
                        DEL( pPageEvent ) ;
                        THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                        BLAMMO ;                                                //SHOULD BE IMPOSSIBLE SINCE "ALL OR NONE" USED FOR WRITING BOOKTOGETHER AND I'VE ALREADY READ THE PREFIX
                    {
                    if( !(const byteT*)*pPageEvent )

                    THREADmODE3rESTORE
                    bksAccessEvents.readF( tinP , *pPageEvent , hRead , flBOOKScrEAD_null , 0 , &hCursor ) ;
                    pPageEvent = new( 0 , tinP , LF ) pageC( tinP , bksAccessEvents , cbi ) ; ___( pPageEvent ) ;
                    THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                    ZE( pageC* , pPageEvent ) ;
                {
                else
                }
                    __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;
                    {
                    if( !pbi )
                    bDelete = bksAccessEvents.readF( tinP , pbi , cbi , hRead , flBOOKScrEAD_STILLhUNGRYiSoK , 0 , &hCursor ) ;
                {
                if( bPrefix )
                ZE( boolT , bDelete ) ;

                HANDLEaPPnOTEScOUNTcLASS ch = hRead ;

                handleC hReadSave = hRead ;
                countT cbiSave = cbi ;
            {
            while( !bQuit && !POOP )
            handleC hCursor( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKSrEADcURSOR ) ;
            boolT bPrefix = 1 ;
            countT cbi = sizeof( countT ) ;
            ZE( const byteT* , pbi ) ;

            // *****************************************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
            // ********                    *************************************************************************************************************************************************************************************************************************
            // ********  EAT BOOK ENTRIES  *************************************************************************************************************************************************************************************************************************
            // ********                    *************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
        {
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    {
    while( !bQuit && !POOP )
    handleC hRead( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
    //etThread.traceF( tinP , T("ACCESSeVENTS3bOOKfOReACHuRI / enering loop to read events") ) ;

    }
        etThread.osThreadF( tinP , countTC() , tmWorkerF , 0 , flTHREADlAUNCH_INHERITjOTrEGISTRATIONS , TOCK , (countT)&ws , (countT)&bksAccessEvents ) ;
        inc02AM( ws.cWorkers ) ;
    {
    while( cDo -- )
    countT cDo = CwORKERS ;
    //etThread.traceF( tinP , T("ACCESSeVENTS3bOOKfOReACHuRI / launching workers") ) ;

    workS ws( tinP , etThread ) ;
    //etThread.traceF( tinP , T("ACCESSeVENTS3bOOKfOReACHuRI / ct ws") ) ;

    TN( tb4 , "    " ) ;
    booksC bksAccessEvents( tinP , TAG( TAGiDnULL ) , "bksAccessEvents.1.raw" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_null , 0 , 1 , 0 , 0 , 0 , 0 , &bQuit ) ;
    //etThread.traceF( tinP , T("ACCESSeVENTS3bOOKfOReACHuRI / ct bksAccessEvents") ) ;

    const boolT& bQuit = *(const boolT*)&(const countT&)ether ;
{

ether.ifcHireF( tinP , T("ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE1") , ifcIDaDAM_ACCESSeVENTS4bOOKbYhASHbYTE2 , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

TODO

DONE( tmWorkerF )
}
    //tinP.monitor.idWhat2 = 0 ;
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;

    dec02AM( wsP.cWorkers ) ;
    }
        }
            THREADmODE1rESTORE
            }
                wsP.st_pPageEvent.ungrabF( tinP ) ;
                }
                    wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    }
                        THREADmODE3rESTORE
                        DEL( pPageEvent ) ;
                        THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )

                        }
                            //tinP.monitor.idWhat2 = 0x01000000 ;           //WHERE INTERVAL
                            etThread.delF( tinP , psttBrowser ) ;
                            etThread.delF( tinP , psttProtocol ) ;
                            etThread.delF( tinP , psttQuery ) ;
                            etThread.delF( tinP , psttUri ) ;
                            etThread.delF( tinP , psttContainer ) ;
                            etThread.delF( tinP , psttLogBucket ) ;
                            etThread.delF( tinP , psttMethod ) ;

                            }
                                //tinP.monitor.idWhat2 = 0x02000000 ;           //WHERE INTERVAL
                                wsP.swBooksByByte.ungrabF( tinP ) ;

                                inc02AM( cOut ) ;

                                booksOut.writeF( tinP , (byteT*)&cbo , sizeof cbo , WS( sBookEntryOut ) , flBOOKScwRITE_ALLOWoDDlENGTH | flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ELSEfILLtOeND , 0 ) ;
                                countT cbo = sBookEntryOut.cbF( tinP ) ;

                                //etThread.traceF( tinP , T("ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE1: writing an event") ) ;

                                booksC& booksOut = *(booksC*)&(countT&)wsP.swBooksByByte ;
                                //tinP.monitor.idWhat2 = 0x03000000 ;           //WHERE INTERVAL

                                }
                                    //etThread.traceF( tinP , T("swBooks [cFlavors]:    ")+TF2(wsP.swBooksByByte.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    }
                                        new( 0 , tinP , pba , sizeof( booksC ) ) booksC( tinP , TAG( TAGiDnULL ) , tBooksOut , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER , TOCK << 4 ) ;
                                        TN( tBooksOut , "" ) ; tBooksOut = T("bksAccessEvents.2.hash1.")+TF3(wsP.lever_cByte,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,2)+T(".accessEvents") ;
                                    {
                                    if( !POOP )

                                    __Z( pba ) ;
                                    byteT* pba = (byteT*)&(countT&)wsP.swBooksByByte ;
                                {
                                if( !wsP.swBooksByByte.idSlotOfLeverF( tinP , wsP.lever_cByte ) )
                                wsP.lever_cByte = ph[ 3 ] & 0xff ;
                                wsP.swBooksByByte.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                //tinP.monitor.idWhat2 = 0x04000000 ;           //WHERE INTERVAL

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                        *********************************************************************************************************************************************************************************************************************
                                // ********  BOOK THE EVENT soulC  *********************************************************************************************************************************************************************************************************************
                                // ********                        *********************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************


                                sBookEntryOut << cbReply ;                          // f CB REPLY BODY
                                sBookEntryOut << code ;                             // e HTTP RESPONSE CODE
                                sBookEntryOut << pidj[ 4 ] ;                        // d QUERY
                                sBookEntryOut << pidj[ 3 ] ;                        // c URI
                                sBookEntryOut << pidj[ 2 ] ;                        // b CONTAINER
                                sBookEntryOut << pidj[ 1 ] ;                        // a BUCKET
                                sBookEntryOut << pidj[ 0 ] ;                        // 9 METHOD
                                sBookEntryOut << pidj[ 5 ] ;                        // 8 PROTOCOL
                                sBookEntryOut << pidj[ 6 ] ;                        // 7 BROWSER
                                sBookEntryOut << nnHe ;                             // 6 
                                sBookEntryOut << *(countT*)&timeW2 ;                // 5 
                                sBookEntryOut << timeW1 ;                           // 4 
                                sBookEntryOut << ph[ 3 ] ;                          // 3 URI HASH:  THIS IS AN OPTIMIZATION TO AVOID MULTIPLE RETRIEVALS FROM jotC AS PROCESSING PROCEEDS THROUGH SORTING TO FINAL OUTPUT
                                sBookEntryOut << (countT)1 ;                        // 2 
                                sBookEntryOut << finger ;       finger = 0 ;        // 1 

                                soulC sBookEntryOut( tinP , TAG( TAGiDnULL ) ) ;

                                putNegAM( finger, FINGERnEG_ACCESSeVENTiDjOTfORmOstsTRINGS ) ;
                                ZE( countT , finger ) ;
                                //tinP.monitor.idWhat2 = 0x05000000 ;           //WHERE INTERVAL

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // ********  CONSTRUCT EVENT soulC  ********************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************

                                }
                                    if( !pidj[ offi ] ) { BLAMMO ; }

                                    ppjhs[ offi ]->ungrabF( tinP ) ;
                                    }
                                        //tinP.monitor.idWhat2 = 0x06000000 + offi ;           //WHERE INTERVAL
                                        }
                                            }
                                                etThread.traceF( tinP , T("could not register string for fast retrieval [offi,hash,idj]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(ph[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pidj[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            if( !bStored )

                                            }
                                                }
                                                    }
                                                        break ;
                                                        bStored = 1 ;
                                                        overflow.pHij[ offs ].idJot = pidj[ offi ] ;
                                                    {
                                                    if( !setIfZeAM( overflow.pHij[ offs ].hash , ph[ offi ] ) )
                                                {
                                                for( countT offs = 0 ; offs < CsLOTSoVERFLOW ; offs ++ )
                                                overflowBucketS& overflow = *ppOverflow[ offi ] ;
                                            {
                                            if( !bStored )

                                            }
                                                }
                                                    break ;
                                                    bStored = 1 ;
                                                    bucket.pHij[ offs ].idJot = pidj[ offi ] ;
                                                {
                                                if( !setIfZeAM( bucket.pHij[ offs ].hash , ph[ offi ] ) )
                                            {
                                            for( countT offs = 0 ; offs < CsLOTSpERhASH01 ; offs ++ )
                                            hash01BucketS& bucket = ( ppBucket[ offi ] )[ ph[ offi ] & 0xffff ] ;
                                            ZE( boolT , bStored ) ;
                                        {

                                        //etThread.traceF( tinP , T("stored  [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[ offi ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                        pidj[ offi ] = (countT)pbEncoded ;
                                        etThread.strEncodeF( tinP , pbEncoded , psttzv , 0 , sizeof( countT ) , (const byteT*)&ph[ offi ] ) ; ___( pbEncoded ) ;
                                        ZEJ( byteT* , pbEncoded , *ppjhs[ offi ] ) ;
                                        //etThread.traceF( tinP , T("storing [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[ offi ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;

                                        //tinP.monitor.idWhat2 = 0x07000000 + offi ;           //WHERE INTERVAL

                                        _IO_
                                    {
                                    if( !pidj[ offi ] )

                                    //}
                                    //    //tinP.monitor.idWhat2 = 0x08000000 + offi ;           //WHERE INTERVAL
                                    //    if( offi == 3 ) etThread.traceF( tinP , T("sequential search ended") ) ;
                                    //    }
                                    //        }
                                    //            etThread.delF( tinP , psttHe ) ;
                                    //            }
                                    //                if( offi == 3 ) etThread.traceF( tinP , T("found (sequential search)  [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                    //                pidj[ offi ] = ppjhs[ offi ]->idLathReadF() ;
                                    //            {
                                    //            if( !etThread.strCompareF( tinP , psttzv , psttHe ) )
                                    //            //etThread.traceF( tinP , T("comparing [offi,psttzv,psttHe]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv)+tb4+T(psttHe) ) ;
                                    //            etThread.strDecodeF( tinP , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                                    //            ZE( strokeS* , psttHe ) ;
                                    //        {
                                    //        else if( *(countT*)pbEncodedHe == ph[ offi ] )
                                    //        if( !pbEncodedHe || !cbEncodedHe ) break ;
                                    //
                                    //        countT       cbEncodedHe = pageHe ;
                                    //        const byteT* pbEncodedHe = pageHe ;
                                    //
                                    //        pageC pageHe = *ppjhs[ offi ] ;
                                    //        //CS:PSEUDOdUPLICATE this this
                                    //    {
                                    //    while( !pidj[ offi ] )
                                    //    ppjhs[ offi ]->resetLathReadF() ;
                                    //    if( offi == 3 ) etThread.traceF( tinP , T("sequential search begun") ) ;
                                    //    //tinP.monitor.idWhat2 = 0x09000000 + offi ;           //WHERE INTERVAL
                                    //    _IO_
                                    //{                                                   // SEARCH SEQUENTIALLY
                                    //if( !pidj[ offi ] )
                                    // FOR SPEED, I DO NOT DO A SEQUENTIAL SEARCH.  IF I DO NOT FIND A HIT IN THE HASH LOOKUP, I ASSUME THAT THERE IS NO HIT.  THIS IS REASONABLE SINCE I MAINTAIN THE HASH LOOKUP TABLE IN REAL TIME

                                    }
                                        //tinP.monitor.idWhat2 = 0x0a000000 + offi ;           //WHERE INTERVAL
                                        }
                                            }
                                                }
                                                    }
                                                        if( pidj[ offi ] ) break ;

                                                        etThread.delF( tinP , psttHe ) ;
                                                        }
                                                            //etThread.traceF( tinP , T("found (lookup overflow)  [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                                            pidj[ offi ] = overflow.pHij[ offs ].idJot ;
                                                        {
                                                        if( !etThread.strCompareF( tinP , psttzv , psttHe ) )
                                                        //etThread.traceF( tinP , T("comparing (lookup overflow) [offi,psttzv,psttHe]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv)+tb4+T(psttHe) ) ;
                                                        etThread.strDecodeF( tinP , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                                                        ZE( strokeS* , psttHe ) ;
                                                    {
                                                    else if( *(countT*)pbEncodedHe == ph[ offi ] )      // SHOULD ALWAYS BE TRUE; IF NOT THEN THE HASH LOOKUP IS IN ERROR
                                                    if( !pbEncodedHe || !cbEncodedHe ) break ;

                                                    countT       cbEncodedHe = pageHe ;
                                                    const byteT* pbEncodedHe = pageHe ;

                                                    pageC pageHe = ( *ppjhs[ offi ] )[ overflow.pHij[ offs ].idJot ] ;
                                                {
                                                if( overflow.pHij[ offs ].hash == ph[ offi ] )
                                            {
                                            for( countT offs = 0 ; offs < CsLOTSoVERFLOW ; offs ++ )
                                            overflowBucketS& overflow = *ppOverflow[ offi ] ;
                                        {
                                        if( !pidj[ offi ] )

                                        //tinP.monitor.idWhat2 = 0x0b000000 + offi ;           //WHERE INTERVAL
                                        }
                                            }
                                                }
                                                    if( pidj[ offi ] ) break ;

                                                    etThread.delF( tinP , psttHe ) ;
                                                    }
                                                        //etThread.traceF( tinP , T("found (lookup hash)  [offi,idJot]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pidj[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv) ) ;
                                                        pidj[ offi ] = bucket.pHij[ offs ].idJot ;
                                                    {
                                                    if( !etThread.strCompareF( tinP , psttzv , psttHe ) )
                                                    //etThread.traceF( tinP , T("comparing (lookup hash) [offi,psttzv,psttHe]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzv)+tb4+T(psttHe) ) ;
                                                    etThread.strDecodeF( tinP , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                                                    ZE( strokeS* , psttHe ) ;
                                                {
                                                else if( *(countT*)pbEncodedHe == ph[ offi ] )      // SHOULD ALWAYS BE TRUE; IF NOT THEN THE HASH LOOKUP IS IN ERROR
                                                if( !pbEncodedHe || !cbEncodedHe ) break ;

                                                countT       cbEncodedHe = pageHe ;
                                                const byteT* pbEncodedHe = pageHe ;

                                                pageC pageHe = ( *ppjhs[ offi ] )[ bucket.pHij[ offs ].idJot ] ;
                                            {
                                            if( bucket.pHij[ offs ].hash == ph[ offi ] )
                                        {
                                        for( countT offs = 0 ; offs < CsLOTSpERhASH01 ; offs ++ )
                                        hash01BucketS& bucket = ( ppBucket[ offi ] )[ ph[ offi ] & 0xffff ] ;
                                        //tinP.monitor.idWhat2 = 0x0c000000 + offi ;           //WHERE INTERVAL

                                        _IO_
                                    {                                                   // USE HASH TO LOOK UP CANDIDATE idJot VALUES
 
                                    ppjhs[ offi ]->grabF( tinP , TAG( TAGiDnULL ) ) ;

                                    ph[ offi ] = hashF( (byteT*)psttzv , sizeof( strokeS ) * ( CSpREFIX + psttzv->idAdam ) , 0 ) ;

                                    strokeS* psttzv = ppsttzValue[ offi ] ;

                                    _IO_
                                {
                                for( countT offi = 0 ; offi < sizeof ppsttzValue / sizeof ppsttzValue[ 0 ] ; offi ++ )
                                //tinP.monitor.idWhat2 = 0x0d000000 ;           //WHERE INTERVAL

                                countT           ph[]          = { 0                  , 0                  , 0                  , 0                , 0                  , 0                  , 0                    } ; // "ph":"pHash"                                    CS:CODEsYNC: this this this this
                                countT           pidj[]        = { 0                  , 0                  , 0                  , 0                , 0                  , 0                  , 0                    } ; // "pidj":"pIdJot"                                 CS:CODEsYNC: this this this this

                                overflowBucketS* ppOverflow[]  = { wsP.pOverflowOther , wsP.pOverflowOther , wsP.pOverflowOther , wsP.pOverflowUri , wsP.pOverflowQuery , wsP.pOverflowOther , wsP.pOverflowBrowser } ;
                                hash01BucketS*   ppBucket[]    = { wsP.pBucketOther   , wsP.pBucketOther   , wsP.pBucketOther   , wsP.pBucketUri   , wsP.pBucketQuery   , wsP.pBucketOther   , wsP.pBucketBrowser   } ;
                                jotC*            ppjhs[]       = { &wsP.jhsOther      , &wsP.jhsOther      , &wsP.jhsOther      , &wsP.jhsUri      , &wsP.jhsQuery      , &wsP.jhsOther      , &wsP.jhsBrowser      } ; // "ppjhs":"ppJotHashStrings"                      CS:CODEsYNC: this this this this
 
                                strokeS*         ppsttzValue[] = { psttMethod         , psttLogBucket      , psttContainer      , psttUri          , psttQuery          , psttProtocol       , psttBrowser          } ; // STROKE STRING                                   CS:CODEsYNC: this this this this

                                //                                 0                    1                    2                    3                  4                    5                    6

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                             ****************************************************************************************************************************************************************************************************************
                                // ********  GET IDjOT VALUES , HASHES  ****************************************************************************************************************************************************************************************************************
                                // ********                             ****************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************

                                //}
                                //    etThread.traceF( tinP , T("[nnHe,time,method,bucket,container,uri,query,protocol,code,cb,browser]:    ")+tSay ) ;
                                //
                                //    ;
                                //
                                //        +tb4+tBrowser
                                //        +tb4+TF4(cbReply,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                                //        +tb4+TF4(code,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                                //        +tb4+tProtocol
                                //        +tb4+tQuery
                                //        +tb4+tUri
                                //        +tb4+tContainer
                                //        +tb4+tLogBucket
                                //        +tb4+tMethod
                                //        +tb4+TT(timeW1,timeW2)
                                //        T(nnHe)
                                //
                                //    TN( tSay , "" ) ; tSay =
                                //
                                //    TN( tBrowser   , psttBrowser   ) ;
                                //    TN( tProtocol  , psttProtocol  ) ;
                                //    TN( tQuery     , psttQuery     ) ;
                                //    TN( tUri       , psttUri       ) ;
                                //    TN( tContainer , psttContainer ) ;
                                //    TN( tLogBucket , psttLogBucket ) ;
                                //    TN( tMethod    , psttMethod    ) ;
                                //{

                                // A:ASSUME:  THIS CODE ASSUMES THAT EVENTS ARE UNIQUELY IDENTIFIED BY [hash,idJot,time,nn]; MULTIPLE EVENTS WILL RESULT IN MULTIPLE VALUES FOR THE FIELDS

                                //etThread.traceF( tinP , T(psttUri) ) ;

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // ********  PROCESS WO BOOK ENTRY  ********************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                _IO_
                            {
                            else
                            if( getNegAM( finger ) != FINGERnEG_ACCESSeVENTrAW || idFormat != 1 ) etThread.traceF( tinP , T("unexpected format [finger,idFormat]:    ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //tinP.monitor.idWhat2 = 0x0e000000 ;           //WHERE INTERVAL

                            inc02AM( wsP.pczTallyByDuck[ timeW2 >> 8 & 0xff ] ) ;

                            sBookEntryIn >> psttBrowser ;             ___( psttBrowser ) ;
                            sBookEntryIn >> cbReply ;
                            sBookEntryIn >> code ;
                            sBookEntryIn >> psttProtocol ;            ___( psttProtocol ) ;
                            sBookEntryIn >> psttQuery ;               ___( psttQuery ) ;
                            sBookEntryIn >> psttUri ;                 ___( psttUri ) ;
                            sBookEntryIn >> psttContainer ;           ___( psttContainer ) ;
                            sBookEntryIn >> psttLogBucket ;           ___( psttLogBucket ) ;
                            sBookEntryIn >> psttMethod ;              ___( psttMethod ) ;
                            sBookEntryIn >> nnHe ;
                            sBookEntryIn >> *(countT*)&timeW2 ;
                            sBookEntryIn >> timeW1 ;
                            sBookEntryIn >> idFormat ;
                            sBookEntryIn >> finger ;

                            ZE( strokeS* , psttBrowser   ) ;
                            ZE( countT   , cbReply       ) ;
                            ZE( countT   , code          ) ;
                            ZE( strokeS* , psttProtocol  ) ;
                            ZE( strokeS* , psttQuery     ) ;
                            ZE( strokeS* , psttUri       ) ;
                            ZE( strokeS* , psttContainer ) ;
                            ZE( strokeS* , psttLogBucket ) ;
                            ZE( strokeS* , psttMethod    ) ;
                            nicNameC       nnHe            ;
                            ZE( sCountT  , timeW2        ) ;
                            ZE( countT   , timeW1        ) ;
                            ZE( countT   , idFormat      ) ;
                            ZE( countT   , finger        ) ;
                            //tinP.monitor.idWhat2 = 0x0f000000 ;           //WHERE INTERVAL

                            }
                                etThread.delF( tinP , pbPageCopy ) ;
                                }
                                    sBookEntryIn.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbPageCopy , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;

                                    bksAccessEventsP.unlockF( tinP ) ;
                                    etThread.memCopyF( tinP , pbPageCopy , pbzPage , cbzPage ) ;
                                    const byteT* pbzPage = *pPageEvent ;
                                    bksAccessEventsP.lockF( tinP , TAG( TAGiDnULL ) ) ;
                                {
                                if( !POOP )

                                __Z( pbPageCopy ) ;
                                etThread.newF( tinP , LF , pbPageCopy , cbzPage ) ; ___( pbPageCopy ) ;
                                ZE( byteT* , pbPageCopy ) ;

                                countT cbzPage = *pPageEvent ;
                            {
                            soulC sBookEntryIn( tinP , TAG( TAGiDnULL ) ) ;
                            //tinP.monitor.idWhat2 = 0x10000000 ;           //WHERE INTERVAL
                        {

                        _IO_
                    {
                    if( pPageEvent )

                    wsP.st_pPageEvent.ungrabF( tinP ) ;
                    wsP.st_pPageEvent >> *(countT*)&pPageEvent ;
                    ZE( pageC* , pPageEvent ) ;
                    _IO_
                {
                while( wsP.st_pPageEvent )
                wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;

                _IO_
            {
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            _IO_
        {
        else
        }
            //etThread.traceF( tinP , T("napped") ) ;
            ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //etThread.traceF( tinP , T("napping") ) ;

            if( wsP.bFireWorkers ) break ;
        {
        if( !wsP.st_pPageEvent )
        _IO_
    {
    while( !etThread && !POOP )

    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , 1 ) ;
    //tinP.monitor.idWhat2 = - 1 ;

    TN( tDot , "." ) ;
    TN( tb4 , "    " ) ;

    booksC& bksAccessEventsP = *(booksC*)pTaskP->c2 ;
    workS&  wsP              =  *(workS*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )

}
    }
        }
            __Z( pOverflow ) ;
            etherP.delF( tinP , pbZe ) ;
            }
                bkOverflow.readF( tinP , *(const byteT**)&pOverflow , cbzi , offi ) ;
                ZE( countT , offi ) ;
                countT cbzi = cbZe ;

                bkOverflow.writeF( tinP , countTC() , pbZe , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLoRnONE ) ; //FORMATS IFF NOT YET FORMATTED
                countT cb1 = cbZe ;

                thirdC::c_memsetIF( tinP , pbZe , cbZe) ;
            {
            if( pbZe )
            etherP.newF( tinP , LF , pbZe , cbZe ) ; ___( pbZe ) ;
            countT cbZe = bkOverflow.cbBodyF() ;
            ZE( byteT* , pbZe ) ;
        {                               // INITIALIZE bkIdJotByHashOverflow

        }
            __Z( pBucket ) ;
            etherP.delF( tinP , pbZe ) ;
            }
                bkArray.readF( tinP , *(const byteT**)&pBucket , cbzi , offi ) ;
                ZE( countT , offi ) ;
                countT cbzi = cbZe ;

                bkArray.writeF( tinP , countTC() , pbZe , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLoRnONE ) ; //FORMATS IFF NOT YET FORMATTED
                countT cb1 = cbZe ;

                thirdC::c_memsetIF( tinP , pbZe , cbZe) ;
            {
            if( pbZe )
            etherP.newF( tinP , LF , pbZe , cbZe ) ; ___( pbZe ) ;
            countT cbZe = bkArray.cbBodyF() ;
            ZE( byteT* , pbZe ) ;
        {                               // INITIALIZE bkIdJotByHashArray

        overflowBucketS*& pOverflow  = *pppOverflow[   offa ] ;
        hash01BucketS*&   pBucket    = *pppBucket[     offa ] ;
        bookC&            bkOverflow = *ppBkOverflow[  offa ] ;
        bookC&            bkArray    = *ppBkArray[     offa ] ;
    {
    for( countT offa = 0 ; offa < sizeof ppBkArray / sizeof ppBkArray[ 0 ] ; offa ++ )

    overflowBucketS** pppOverflow[]   = { &pOverflowUri             , &pOverflowQuery             , &pOverflowBrowser             , &pOverflowOther             } ;
    hash01BucketS**   pppBucket[]     = { &pBucketUri               , &pBucketQuery               , &pBucketBrowser               , &pBucketOther               } ;
    bookC*            ppBkOverflow[]  = { &bkIdJotByHashOverflowUri , &bkIdJotByHashOverflowQuery , &bkIdJotByHashOverflowBrowser , &bkIdJotByHashOverflowOther } ;
    bookC*            ppBkArray[]     = { &bkIdJotByHashArrayUri    , &bkIdJotByHashArrayQuery    , &bkIdJotByHashArrayBrowser    , &bkIdJotByHashArrayOther    } ;

    }
        __Z( pczTallyByDuck ) ;
        etherP.delF( tinP , pcZe ) ;
        }
            bkTallyByDuck.readF( tinP , *(const byteT**)&pczTallyByDuck , cbzi , offi ) ;
            ZE( countT , offi ) ;
            countT cbzi = cbZe ;

            bkTallyByDuck.writeF( tinP , flResult , (byteT*)pcZe , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLoRnONE ) ; //FORMATS IFF NOT YET FORMATTED
            countT cb1 = cbZe ;
            ZE( flagsT , flResult ) ;

            thirdC::c_memsetIF( tinP , (byteT*)pcZe , cbZe ) ;
            const countT cbZe = sizeof( countT ) * TUCK ;
        {
        if( pcZe )
        etherP.newF( tinP , LF , pcZe , TUCK ) ; ___( pcZe ) ;
        ZE( countT* , pcZe ) ;
    {                               // INITIALIZE bkTallyByDuck
{
swBooksByByte( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , lever_cByte , 0 , sizeof( booksC ) , ifcIDgRABlAYER_7BASEmISC3 )
lever_cByte( 0 ) ,
idOut( 0 ) ,
idIn( 0 ) ,
cWorkers( 0 ) ,
bFireWorkers( 0 ) ,
st_pPageEvent( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_countT ) ,

pOverflowOther(   0 ) ,
pOverflowBrowser( 0 ) ,
pOverflowQuery(   0 ) ,
pOverflowUri(     0 ) ,

pBucketOther(   0 ) ,
pBucketBrowser( 0 ) ,
pBucketQuery(   0 ) ,
pBucketUri(     0 ) ,

bkIdJotByHashOverflowOther(   tinP , TAG( TAGiDnULL ) , "bkIdJotByHashOverflowOther"   , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE ,        sizeof( overflowBucketS ) ) ,
bkIdJotByHashOverflowBrowser( tinP , TAG( TAGiDnULL ) , "bkIdJotByHashOverflowBrowser" , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE ,        sizeof( overflowBucketS ) ) ,
bkIdJotByHashOverflowQuery(   tinP , TAG( TAGiDnULL ) , "bkIdJotByHashOverflowQuery"   , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE ,        sizeof( overflowBucketS ) ) ,
bkIdJotByHashOverflowUri(     tinP , TAG( TAGiDnULL ) , "bkIdJotByHashOverflowUri"     , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE ,        sizeof( overflowBucketS ) ) ,

bkIdJotByHashArrayOther(      tinP , TAG( TAGiDnULL ) , "bkIdJotByHashArrayOther"      , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE , TOCK * sizeof( hash01BucketS   ) ) ,
bkIdJotByHashArrayBrowser(    tinP , TAG( TAGiDnULL ) , "bkIdJotByHashArrayBrowser"    , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE , TOCK * sizeof( hash01BucketS   ) ) ,
bkIdJotByHashArrayQuery(      tinP , TAG( TAGiDnULL ) , "bkIdJotByHashArrayQuery"      , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE , TOCK * sizeof( hash01BucketS   ) ) ,
bkIdJotByHashArrayUri(        tinP , TAG( TAGiDnULL ) , "bkIdJotByHashArrayUri"        , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE , TOCK * sizeof( hash01BucketS   ) ) ,

pczTallyByDuck( 0 ) ,
bkTallyByDuck( tinP , TAG( TAGiDnULL ) , "bkTallyByDuck" , ifcIDsTATEsPACE_SINGLEaDAM( tinP ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE , sizeof( countT ) * TUCK ) ,

jhsOther(      tinP , "jotAccessEvents.hash.string.other"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [STRING]; WO JOT PER UNIQUE STRING
jhsBrowser(    tinP , "jotAccessEvents.hash.string.browser" , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsQuery(      tinP , "jotAccessEvents.hash.string.query"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jhsUri(        tinP , "jotAccessEvents.hash.string.uri"     , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ,   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
workS::workS( tinS& tinP , etherC& etherP ) :

}
    swBooksByByte.ungrabF( tinP ) ;

    //etherC::etRockIF( tinP ).traceF( tinP , T("destroyed  all output books [idOut,cFlavors,heap.cNew-cDel]:    ")+TF2(idOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(processGlobal3S::_processGlobal3I_IF().heap.cNewF()-processGlobal3S::_processGlobal3I_IF().heap.cDelF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    swBooksByByte.freeAllF( tinP ) ;

    }
        //etherC::etRockIF( tinP ).traceF( tinP , T("destroying a book [idf,cFlavors]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        DELzOMBIE( pBooks ) ;
        booksC* pBooks = (booksC*)&(countT&)swBooksByByte ;
        lever_cByte = swBooksByByte.leverF( tinP , idf ) ;
        //etherC::etRockIF( tinP ).traceF( tinP , T("destroying a book [idf,cFlavors]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )

    //etherC::etRockIF( tinP ).traceF( tinP , T("destroying all output books [idOut,cFlavors]:    ")+TF2(idOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    countT cFlavors = swBooksByByte.cFlavorsF( tinP ) ;

    swBooksByByte.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
voidT workS::destroyBooksF( tinS& tinP )

}
    destroyBooksF( tinP ) ;
    TINSL
{
workS::~workS( voidT )

countT cOut ;
countT cIn ;

;
}
    voidT destroyBooksF( tinS& tinP ) ;
    workS( tinS& tinP , etherC& etherP ) ;
    ~workS( voidT ) ;

    switchC          swBooksByByte ;
    countT           lever_cByte ;

    countT           idOut ;
    countT           idIn ;
    countT           cWorkers ;
    boolT            bFireWorkers ;

    stackC           st_pPageEvent ;

    overflowBucketS* pOverflowOther ;
    overflowBucketS* pOverflowBrowser ;
    overflowBucketS* pOverflowQuery ;
    overflowBucketS* pOverflowUri ;

    hash01BucketS*   pBucketOther ;
    hash01BucketS*   pBucketBrowser ;
    hash01BucketS*   pBucketQuery ;
    hash01BucketS*   pBucketUri ;

    bookC            bkIdJotByHashOverflowOther ;
    bookC            bkIdJotByHashOverflowBrowser ;
    bookC            bkIdJotByHashOverflowQuery ;
    bookC            bkIdJotByHashOverflowUri ;

    bookC            bkIdJotByHashArrayOther ;
    bookC            bkIdJotByHashArrayBrowser ;
    bookC            bkIdJotByHashArrayQuery ;
    bookC            bkIdJotByHashArrayUri ;

    countT*          pczTallyByDuck ;
    bookC            bkTallyByDuck ;

    jotC             jhsOther   ;
    jotC             jhsBrowser ;
    jotC             jhsQuery   ;          //CS:CODEsYNC: 73a 740 (THESE MUST BE CT IN THE SAME ORDER SO THAT THE SAME TAG VALES ARE ASSIGNED
    jotC             jhsUri     ;          // EVERY JOT INSTANCE CONTAINS HASH PREFIXED STRINGS TO KEEP CODE SIMPLE EVEN THOUGH THE HASH IS NOT USEFUL FOR THE STRINGS IN jhsOther
{
struct workS

;
}
    hashIdJotS pHij[ CsLOTSoVERFLOW ] ;
{
struct overflowBucketS

;
}
    hashIdJotS pHij[ CsLOTSpERhASH01 ] ;
{
struct hash01BucketS

;
}
    countT idJot ;
    countT hash ;
{
struct hashIdJotS

#define CwORKERS        ( TUCK >> 4 )
#define CsLOTSoVERFLOW  ( TUCK >> 0 )
#define CsLOTSpERhASH01 ( TUCK >> 4 )

//OBSOLETES 51000741: I ELIMINATE THE NEED TO LOOK UP IDjOTuRI BY USING booksC TO SORT BY HASH (BYTE BY BYTE)

/*1*/WAKEhIDE( "ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE1" )/*1*/
/**/
*/
 if this happens, all page books must be manually deleted and then regenerated (by editing my code to make me enabled during the initial reading)
 it is critically important to never fire me when new events have been booked but i have not yet "page booked" them
 i enable myself only after reading all existing booked events, when i nap for the woth time
during initialization, i assume that all existing booked events have already been "page booked' and ignore them
 on output, each access event is written to a book dedicated to the corresponding idJot pair that identifies [container] [uri]
 the idJot values identify strings that i place into jotC instances
 on output, each access event soulC contains idJot values rather than string values
 on input, each access event soulC is self sufficient in that it contains string values
i "divide and conquer" by distributing access events to a dedicated booksC instance for each hash of [container] || [uri]
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
