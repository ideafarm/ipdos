
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cbMsgInLast ;
    dec02AM( cFunctionsPending ) ;
    }
    
        if( idleTimeAllowedRead ) FRESHtIMEaTOMIC( *pEther , timeLathRead.time1 , timeLathRead.time2 )
    
        tinP.pAdamGlobal3->_socketC_.grab.ungrabF( tinP ) ;
        pOdometer->cbWrite += tinP.odoSockCbWrite - _odoSockCbWriteOpen ;
        pOdometer->cbRead  += tinP.odoSockCbRead  - _odoSockCbReadOpen  ;
        pOdometer = (sockOdometerS*)&(countT&)*tinP.pAdamGlobal3->_socketC_.pSwOdometer ;
        tinP.pAdamGlobal3->_socketC_.nnLever = nnPeer ;
        tinP.pAdamGlobal3->_socketC_.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        }
            THREADmODE1rESTORE

            else                                               pEther->sockReadF(     tinP , handle      , pbP , cbMsgInLast ) ;
            if( F(flagsMode) & flSOCKETcmODE_CRYPTfOREIGNsSL ) pEther->openSsl_readF( tinP , pbP , cbMsgInLast , handle ) ;

            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            if( pbP ) pbP[ cbMsgInLast ] = 0 ;
            pEther->newF( tinP , LF , pbP , cbMsgInLast + 1 ) ; ___( pbP ) ;
        {
        if( cbMsgInLast )
        __Z( cbMsgInLast ) ;
        THREADmODE1rESTORE

        else                                               pEther->sockReadF(     tinP , handle      , (byteT*)&cbMsgInLast , sizeof cbMsgInLast ) ;
        if( F(flagsMode) & flSOCKETcmODE_CRYPTfOREIGNsSL ) pEther->openSsl_readF( tinP , (byteT*)&cbMsgInLast , sizeof cbMsgInLast , handle ) ;

        }
            idMsgInLast = idMsgIn ;
            __( idMsgIn - idMsgInLast - 1 ) ;
            else                                               pEther->sockReadF(     tinP , handle      , (byteT*)&idMsgIn , sizeof idMsgIn ) ;
            if( F(flagsMode) & flSOCKETcmODE_CRYPTfOREIGNsSL ) pEther->openSsl_readF( tinP , (byteT*)&idMsgIn , sizeof idMsgIn , handle ) ;
            ZE( countT , idMsgIn ) ;
        {
    
        }
             __( idType - 1 ) ;
            else                                               pEther->sockReadF(     tinP , handle      , (byteT*)&idType  , sizeof idType ) ;
            if( F(flagsMode) & flSOCKETcmODE_CRYPTfOREIGNsSL ) pEther->openSsl_readF( tinP , (byteT*)&idType  , sizeof idType , handle ) ;
            ZE( countT , idType ) ;
        {

        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    
        bRead.grabF( tinP , TAG( TAGiDnULL ) ) ; // THIS IS RELEASED BY readMsgOkF OR readMsgNokF
    
        const countT _odoSockCbWriteOpen = tinP.odoSockCbWrite ;
        const countT _odoSockCbReadOpen  = tinP.odoSockCbRead  ;
    
        _IO_
    
        }

            }
                return 0 ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )

            __NZ( pbP ) ;

            }
                return 0 ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL    
        SCOOPP
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/countT socketC::readMsgF( tinS& tinP , byteT*& pbP )/*1*/

/**/
*/
  must be 0
 pbP
arguments
this function appends a null byte to the data, which is not included in the length value that is returned
this function evaluates to the number of bytes of data received (and placed into pbP)
 call readMsgNokF if the data cannot be processed
 call readMsgOkF after the data received has been processed
 readMsgOkF will release it without grabbing it
 this function grabs the socketC object but does not release it
the caller -must- follow this call with a call to readMsgOkF (or readMsgNokF)
  both ends of a connection should use writeMsgF, readMsgF, and readMsgOkF (or readMsgNack)
 this protocol is subject to change
   cbr must equal the cbP just sent
   idMsgr must equal the idMsg just sent
   2 indicates that this is an ack
  then reads 2, idMsgr, cbr
   idMsg is consecutive from 1 and is unique for each message going out from a socket
   1 indicates that this is a message (rather than an ack)
  writes 1, idMsg, cbP, pbP
 the remote peer is assumed to have written a message using the following protocol
reads specified bytes to the peer using the IFC message protocol
  \<A HREF=\"5.3930104.1.1.0.html\"\>3930104:  WAKEsHOW( "example.simplest.func.107001a.socketC.readMsgF" )\</A\>
 simplest
examples
\<A HREF=\"5.107001a.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$readMsgF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

