
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    tinP.pAdamGlobal5->frPaper.grab.ungrabF( tinP ) ;
    _OUT_

    }
        THREADmODE1rESTORE
        }
            }
                tinP.pAdamGlobal5->frPaper.grab.ungrabF( tinP ) ;
                //winRoot.tinP.pAdamGlobal5->frPaper.grab.ungrabF( tinP ) ;
                requestTabFreshIF( tinP ) ;

                }
                    }
                        }
                            ether.delF( tinP , psttNew ) ;

                            }
                                //ether.beeClickF( tinP , TUCK << 1 ) ;
                                //ether.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;
                                //ether.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
                                //ether.etherWhereF( tinP , ifcIDaCTIONwHERE_DISABLE ) ;
                            {
                            //if( idIn == 1 )

                            x1.pPulp->x1.back.wrapRenderF( tinP , psttNew , 0 ) ;

                            }
                                //ether.etherWhereF( tinP , ifcIDaCTIONwHERE_ENABLE ) ;
                                //ether.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
                                //ether.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , 1 ) ;
                                //ether.beeClickF( tinP , TUCK << 0 ) ;
                            {
                            //if( idIn == 1 )
                        {
                        if( psttNew )
    
                        else { ether.delF( tinP , psttAll ) ; }
                        }
                            ether.delF( tinP , psttAll ) ;
                            ether.strSubstringF( tinP , psttNew , idf , idl , psttAll ) ; ___( psttNew ) ;
                            ZE( countT , idl ) ;
                            countT idf = cStrokesRendered + 1 ;
                        {
                        else if( cStrokesRendered < psttAll->idAdam )
                        if( !cStrokesRendered ) { psttNew = psttAll ; psttAll = 0 ; }
                        ZE( strokeS* , psttNew ) ;
                        ether.strConcatenateF( tinP , psttAll , stDef , 0 , flSTRcONCATENATE_COPY | flSTRcONCATENATE_REVERSE ) ; ___( psttAll ) ;
                        ZE( strokeS* , psttAll ) ;
                    {
                    if( stDef )

                    if( bErase ) purgeF( tinP ) ;
                {
                if( !bSuppress )
                //4. PASS THROUGH stDef TO RENDER
        
                }
                    }
                        }
                            }
                                break ;
                                stDef << (byteT*)&sttWo ;
                                if( sttWo.idCaste == sc_cADAM ) sttWo.registerF() ;
                            {
                            default :
                            }
                                break ;
            
                                }
                                    bErase = 1 ;
                                    *(measureT*)&x1.pPulp->stqr_mIdRowHighWater[ 1 ] = 0.0f ;
                                    x1.pPulp->mIdRowNow = x1.pPulp->mIdColNow = 1.0f ;
                                    cStrokesRendered = 0 ;    
        
                                    }
                                        }
                                            break ;
                                            }
                                                default : { break ; }
                                                }
                                                    break ;
                        
                                                    }
                                                        if( sttWo.idCaste == scOld_SYSmARK ) break ;
                                                        stDef >> pb_sttWo2 ;
                                                        byteT* pb_sttWo2 = (byteT*)&sttWo2 ;
                                                        strokeS sttWo2 ;
                                                    {
                                                    while( stDef )
                                                {
                                                case saOLD_EDITeRASEbACKtOmARK :
                                            {
                                            switch( sttWo.idAdam )
                                        {
                                        case scOld_EDIT :
                                        }
                                            break ;
                                            }
                                                }
                                                    break ;
                        
                                                    }
                                                        stDef >> pb_sttWo2 ;
                                                        byteT* pb_sttWo2 = (byteT*)&sttWo2 ;
                                                        strokeS sttWo2 ;
                                                    {
                                                    while( stDef ) //PURGE DONE THIS WAY TO DEREGISTER sc_cADAM INSTANCES
                                                {
                                                case '\f' :
                                            {
                                            switch( sttWo.idAdam )
                                        {
                                        case sc_cFROMcONTROL :
                                    {
                                    switch( sttWo.idCaste )
    
                                    stDef << (byteT*)&sttWo ;
            
                                    THREADmODE1rESTORE //LEGACY WORKAROUND
                                    callSadamsIF( tinP , ether , ifcIDtYPEsTROKEcALLbACK_DESTROY , 0 , 0 , flCALLsADAMS_null , 0 , this ) ;
                                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //LEGACY WORKAROUND
                                {
                                else
                                if( sttWo.idCaste != scOld_EDIT && sttWo.idAdam != '\f' ) stDef << (byteT*)&sttWo ;
                            {
                            case scOld_EDIT :
                            case sc_cFROMcONTROL :
                        {
                        switch( sttWo.idCaste )
                        const strokeS& sttWo = psttP[ CSpREFIX - 1 + ids ] ;
                    {
                    for( countT ids = 1 ; ids <= psttP->idAdam ; ids ++ )

                    }
                        }
                            stDef << (byteT*)&S2(0,scOld_WRAPoN) ;
                            stDef << (byteT*)&S3(96.0,scOld_mmFRAMEcELLS,24.0) ;
                            stDef << (byteT*)&S2(0,scOld_POPfRAMEdETACH) ;
                            stDef << (byteT*)&S3(mRelMarginTo,scOld_mmFRAMEtO,mRelMarginTo) ;
                            stDef << (byteT*)&S3(mRelMarginFrom,scOld_mmMOVEtO,mRelMarginFrom) ;
                            stDef << (byteT*)&S2(0,scOld_FRAMEdETACH) ;

                            const measureT mRelMarginTo   = 1.0 - 1.0 / 64.0 ;
                            const measureT mRelMarginFrom =       1.0 / 64.0 ;
                        {
                        if( bImpliedTextCells )
                        const boolT bImpliedTextCells = !cStrokesRendered ; //&& psttP->idAdam && ( psttP[ CSpREFIX ].idCaste == sc_cALPHABET1 || psttP[ CSpREFIX ].idCaste == sc_cADAM ) ;
                        //ALWAYS DONE NOW.  APP CODE THAT DOES NOT WANT TO USE THIS DEFAULT, WHICH IS FOR TEXT, CAN USE scOld_cPUSHoFFfRAME TO SET offFrame TO 1


                        // 
                        //   3. THE TOP FRAME IS SIZED FOR 96_9 COLUMNS AND 24_9 ROWS OF TEXT AND WRAP IS ON       ; THIS IS ACCESSED BY DEFAULT
                        //   2. MIDDLE FRAME IS THE ENTIRE DISPLAY LESS A THIN MARGIN ON ALL EDGES AND WRAP IS OFF ; TO ACCESS, RENDER S2(1,scOld_cPUSHoFFfRAME)
                        //   1. THE LOWEST FRAME COINCIDES WITH THE BOUNDARY PELS OF THE DISPLAY AND WRAP IS OFF   ; TO ACCESS, RENDER S2(2,scOld_cPUSHoFFfRAME)
                        // 
                        // I SET UP 3 STROKING FRAMES
                        //
                        // BEHAVIOR
                    {
                {
                else
                }
                    bErase = 1 ;
                    *(measureT*)&x1.pPulp->stqr_mIdRowHighWater[ 1 ] = 0.0f ;
                    x1.pPulp->mIdRowNow = x1.pPulp->mIdColNow = 1.0f ;
        
                    cStrokesRendered = 0 ;    
                    THREADmODE1rESTORE //LEGACY WORKAROUND
                    callSadamsIF( tinP , ether , ifcIDtYPEsTROKEcALLbACK_DESTROY , 0 , 0 , flCALLsADAMS_null , 0 , this ) ;
                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //LEGACY WORKAROUND
                {
                else if( !psttP )
                if( bSuppress ) ;
                ZE( boolT , bErase ) ;
                // 3. APPLY ALL EDITS TO stDef. (VARIABLES ARE NOT EVALUATED)  IN SOME CASES, I RESET cStrokesRendered AND ERASE THE BITMAP
        
                countT cStrokesRendered = stDef ;
    
                if( !psttP ) bSuppress = x1.pPulp->x1.back.backSuppressRefreshF( tinP , *this ) ;
                ZE( boolT , bSuppress ) ;
    
                //winRoot.tinP.pAdamGlobal5->frPaper.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
                //windowOldC& winRoot = *thirdC::p WinRootIF() ;
    
                thirdC& third = ether ;
                tinP.pAdamGlobal5->frPaper.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( !POOP )
            SCOOP
        {
        else
        }
            }
                }
                    }
                        }
                            break ;
                            }
                                thirdC::dosWriteStdOutIF( tinP , post2 ) ;
                                const osTextT post2[] = { (osTextT)psttP[ CSpREFIX - 1 + ids ].idAdam , 0 } ;
                            {
                            if( psttP[ CSpREFIX - 1 + ids ].idAdam <= 0xff )
                        {
                        case sc_cALPHABET1 :
                        case sc_cFROMaSCII :
                        }
                            break ;
                            }
                                default: { break ; }
                                }
                                    break ;
                                    thirdC::dosWriteStdOutIF( tinP , post2 ) ;
                                    const osTextT post2[] = { (osTextT)psttP[ CSpREFIX - 1 + ids ].idAdam , 0 } ;
                                {
                                case '\n' :
                                case '\r' :
                                case '\f' : { thirdC::c_systemIF( tinP , "cls" ) ; break ; }
                            {
                            switch( psttP[ CSpREFIX - 1 + ids ].idAdam )
                        {
                        case sc_cFROMcONTROL :
                    {
                    switch( psttP[ CSpREFIX - 1 + ids ].idCaste )
                {
                for( countT ids = 1 ; ids <= psttP->idAdam ; ids ++ )
                //U:ENABLE THIS CODE ONLY IF THERE IS A CONSOLE
            {
            if( psttP && !( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_QUIETcONSOLE ) )
        {
        if( !c_this )
        const countT c_this = (countT)this ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

        // 1. WHEN THERE ARE NO WINDOWS, I DO NOT TOUCH stFace.  INSTEAD, I SIMPLY WRITE TO THE CONSOLE, IF ANY
        //
        // OPTIMIZATIONS

        // 4. PASS THROUGH stFace TO RENDER
        // 3. APPLY ALL EDITS TO stFace
        // 2. cStrokesRendered = stFace
        // 1. VALIDATE PARAMETERS
        // 
        //RECIPE DETAIL
        //
        // 2. TALK psttP OUT TO CLIENTS, IF ANY
        // 1. AS DIRECTED BY psttP, EDIT THE STRING STACK (AND THE BITMAP AND THE windowOldC OBJECT)
        //
        //RECIPE SUMMARY

        // ASSUME: THE CURRENT STRING (IN stFace) HAS BEEN RENDERED INTO THE BITMAP AND INTO THE WINDOW
        //
        // AFTER I COMPLETE MY EDITS TO BOTH THE STACK AND THE BITMAP, I NOTIFY THE OS THAT THE BITMAP HAS CHANGED
        // I AM ALSO RESPONSIBLE FOR MAINTAINING A BITMAP WHICH IS TO ALWAYS CONFORM TO THE SPECIFICATION
        // THIS STACK IS THE DEFINITIVE SPECIFICATION OF WHAT IS TO APPEAR IN THE WINDOW
        // MY JOB IS TO MODIFY A FIFO STACK OF STROKE STRINGS, USUALLY BY PUSHING ANOTHER STRING ONTO THE STACK.
        //
        //CONCEPTS
    {
    if( !psttP || psttP->idAdam ) // !psttP IS A REQUEST TO RERENDER ALL EXISTING STROKES

    //if( !psttP ) { LOGcALLnEST( "strokeF(0)" ) ; }
    tinP.pAdamGlobal5->frPaper.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;

    _INoLD_

    //if( tinP.pc Utility[ 0 ] ) idIn = 1 + incv02AM( idInLath ) ;
    //ZE( countT , idIn ) ;
    //static countT idInLath ;
{
/*1*/voidT paperOldC::strokeF( tinS& tinP , const strokeS* psttP )/*1*/

//U::REWRITE THIS TO ELIMINATE ALL CASTE CODING AND TO USE A MORE EFFICIENT stackC (STORE strokeS SINGLES IN PLACE IN A sizeof( strokeS ) blob stackC AND ELIMINATE MAKING SINGLES STACK FOR EDITING

// IT IS LEGAL FOR this TO BE 0, SO THIS SOURCE FILE MUST BE NAMED 3func.34* (NONMEMBER FUNCTIONS) RATHER THAN 3func.35* (MEMBER FUNCTIONS)

/**/
*/
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00101c4.fl FACEtALK!||
 flagsP
  it is probably bad code style for an adam to specify 0 for psttP
  if 0 then the bitmap is erased and all existing strokes are rerendered into it
 psttP
 tinP
arguments
this function is serialized so that it will block as needed when window repainting is in progress
  \<A HREF=\"5.e110104.1.1.0.html\"\>e110104:  WAKEsHOW( "example.simplest.func.103000f.etherC.strokeF" )\</A\>
  \<A HREF=\"5.2000104.1.1.0.html\"\>2000104:  WAKEsHOW( "example.simplest.func.103000f.etherC.strokeF" )\</A\>
 simplest
examples
\<A HREF=\"5.103000f.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strokeF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

