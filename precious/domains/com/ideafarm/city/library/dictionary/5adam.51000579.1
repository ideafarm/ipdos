
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

THREADmODE2rESTORE0( flagsSave )
}
    THREADmODE2oN0( flTHREADmODE2_UNLOCKpOOLiDENTITY )
    THREADmODE2sAVE0( flagsSave )
    etThread.loafIF( tinP ) ;
    
    if( etherC::ifc_idHomeIdisk_IF() != TUCK ) ether.osThreadAdamF( tinP , ifcIDaDAM_ROOThTTPsERVER ) ;
    //ether.ifcHireF( tinP , T("ifcIDaDAM_KERNEL3PANICdOOR") , ifcIDaDAM_ROOThTTPsERVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
    
    etThread.osThreadF( TaRG1( tmDoorF ) , ifcIDpORT_DOOR      , (countT)&tDoor      , (countT)&tUdpErrorDoor      , (countT)&pusePeanut ) ;
    etThread.osThreadF( TaRG1( tmDoorF ) , ifcIDpORT_PANICdOOR , (countT)&tPanicDoor , (countT)&tUdpErrorPanicDoor , (countT)&pusePeanut ) ;
    
    THREADmODE2rESTORE0( flagsSave )
    puseC puse( tinP , ifcIDpOOL_ADAMtEMP ) ;
    puseC pusePeanut( tinP , "list.lath.peanut" , flPOOLc_null , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
    THREADmODE2oN0( flTHREADmODE2_UNLOCKpOOLiDENTITY )
    THREADmODE2sAVE0( flagsSave )
{
ZE( flagsT , flagsSave ) ;

) ;

    "Follow the 0x01 with a 0x00 to request help information.\r\n"
    "All datagrams must begin with 0x01.\r\n"
    "IdeaFarm " "(tm) City <> Door\r\n"
    "Well Known Port 902 UDP <> ideafarm-door\r\n"
    "IPDOS (tm) <> IdeaFarm " "(tm) Piggyback Distributed Operating System\r\n"

TN( tUdpErrorDoor ,

) ;

    "Follow the 0x01 with a 0x00 to request help information.\r\n"
    "All datagrams must begin with 0x01.\r\n"
    "IdeaFarm " "(tm) City <> Panic Door\r\n"
    "Well Known Port 903 UDP <> ideafarm-panic\r\n"
    "IPDOS (tm) <> IdeaFarm " "(tm) Piggyback Distributed Operating System\r\n"

TN( tUdpErrorPanicDoor ,

TN( tDoor      , "Door" ) ;
TN( tPanicDoor , "Panic Door" ) ;

TODO

DONE( tmDoorF )
}
    }
        }
            etThread.delF( tinP , pbi ) ;
            }
                }
                    }
                        break ;
                        sCatch.writeF( tinP , idPort , nicName , tUdpErrorP , tUdpErrorP.csF( tinP ) ) ;
                    {
                    default : //INVALID idFormat, SO REPLY WITH INSTRUCTIONS
                    }
                        break ;
    
                        }
                            }
                                sCatch.writeF( tinP , idPort , nicName , postr , sizeof postr - 1 ) ;
                                osTextT postr[] = "That command was not understood.  Nothing was done.\r\nSend the command \"space help ;\" (without quotes)\r\nto receive help information." ;
                            {
                            else
                            }
                                etThread.delF( tinP , postr ) ;
                                sCatch.writeF( tinP , idPort , nicName , postr , costr ) ;
                                etThread.delF( tinP , psttReply ) ;
                                countT costr = etThread.strMakeF( tinP , postr , psttReply ) ; ___( postr ) ;
                                ZE( osTextT* , postr ) ;
                            {
                            if( psttReply )
        
                            obeyF( tinP , cArgApp , psttReply , T(pbi+1) ) ; ___( psttReply ) ;
                            ZE( strokeS* , psttReply ) ;
                        {
                        else
                        }
                            sCatch.writeF( tinP , idPort , nicName , postr , sizeof postr - 1 ) ;
                            osTextT postr[] = "Send the command \"space help ;\" (without quotes) to receive help information." ;
                        {
                        else if( cbi >= 2 && !pbi[ 1 ] )
                        }
                            sCatch.writeF( tinP , idPort , nicName , postr , sizeof postr - 1 ) ;
                            osTextT postr[] = "The idFormat byte must be followed by a null terminated ASCII string that contains SOIL (tm) commands.\r\nSend the command \"space help ;\" (without quotes) to receive help information." ;
                        {
                        if( cbi < 2 )
                    {
                    case 1 : //CURRENT idFormat
                {
                switch( pbi[ 0 ] ) //idFormat OF PACKET
            {
            if( !ether && pbi && cbi )
        
            sCatch.readF( tinP , pbi , cbi , idPort , nicName ) ; ___( pbi ) ;
            nicNameC nicName ;
            ZE( countT , idPort ) ;
            ZE( countT , cbi ) ;
            ZE( byteT* , pbi ) ;
        {
        while( !etThread && !ether )
        //U::ENHANCE TO SUPPORT SESSION CONCEPT FOR DATAGRAM "SESSIONS"
    
        httpServerC server( tinP , arg1 , arg2 ) ;
        arg2.pHttpRawCommandServerCBF        = httpRawCommandServerCBF ;
        arg2.pHttpFreshenCacheCBF            = httpFreshenCacheCBF ;
        arg2.pHttpLoadContentDynamicF        = httpLoadContentDynamicCBF ;
        arg2.pHttpLoadContentStaticF         = httpLoadContentStaticCBF ;
        httpServerC_arg2S arg2 ;
        httpServerC_arg1S arg1( TAG( TAGiDnULL ) , etThread , idPortP + 2 * !!( etherC::ifc_idHomeIdisk_IF() == TUCK ) , cArgApp , tTitleP ) ;
        countT cArgApp = (countT)&c8p ;
        count8S c8p( (countT)&pusePeanutP , idPortP == ifcIDpORT_PANICdOOR ) ;

        sCatch.bindF( tinP , idPortP + 2 * !!( etherC::ifc_idHomeIdisk_IF() == TUCK ) ) ; //DONE BEFORE CT server TO AVOID RACING, WHICH IS A PROBLEM IF PORT MAPPING IS IN EFFECT
        socketC sCatch( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
    {

    puseC& pusePeanutP   = *(puseC*)pTaskP->c4 ;
    textC& tUdpErrorP    = *(textC*)pTaskP->c3 ;
    textC& tTitleP       = *(textC*)pTaskP->c2 ;
    const countT idPortP =          pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmDoorF )

}
    }
        }
            }
                sockP.writeF( tinP , postr , sizeof postr - 1 ) ;
                osTextT postr[] = "That command was not understood.  Nothing was done.\r\n" ;
            {
            else
            }
                etThread.delF( tinP , postr ) ;
                sockP.writeF( tinP , postr , costr ) ;
                etThread.delF( tinP , psttReply ) ;
                countT costr = etThread.strMakeF( tinP , postr , psttReply ) ; ___( postr ) ;
                ZE( osTextT* , postr ) ;
            {
            if( psttReply )
            bQuit = obeyF( tinP , cArgP , psttReply , T(postOldCmd) , flDOORoBEY_null , &session ) ; ___( psttReply ) ;
            sessionC& session = sessionsP( tinP , nnPeerP ) ;
            ZE( strokeS* , psttReply ) ;
        {
        if( !bQuit && bComplete )

        }
            }
                break ;
                bComplete = 1 ;
                postOldCmd[ ++ offi ] = 0 ;
                sockP.writeF( tinP , "\r\n" , 2 ) ;
            {
            if( postOldCmd[ offi ] == ';' )

            }
                break ;
                bQuit = 1 ;
                POOPR
            {
            if( POOP )
            sockP.readF( tinP , postOldCmd + offi , 1 ) ; //IF CLIENT IS GONE THEN POOP AND bIn REMAINS 0
            postOldCmd[ offi ] = 0 ;
        {
        for( countT offi = 0 ; offi < sizeof postOldCmd - 1 ; offi ++ )
        ZE( boolT , bComplete ) ;
        osTextT postOldCmd[ TUCK ] ;

        }
            else          sockP.writeF( tinP , postOldCmdBannerDoor  , sizeof postOldCmdBannerDoor  - 1 ) ;
            if( bPanicP ) sockP.writeF( tinP , postOldCmdBannerPanic , sizeof postOldCmdBannerPanic - 1 ) ;
    
            ;

                "\r\n"
                "\r\n"
                "For help information, enter \"space help ;\" (without the quote marks)."
                "\r\n"
                "elapses without receiving anything from you.\r\n"
                "This connection will time out if 8 TICK (45 foreign minutes)\r\n" //CS:CODEsYNC: f750104 f750104
                "\r\n"
                "to prior commands.\r\n"
                "You can continue to enter commands while sentient objects are responding\r\n"
                "I am now in command mode.\r\n"
                "\r\n"
                "\r\n"
                "+----------------------------------------------------------------------------+\r\n"
                "|                                                                            |\r\n"
                "|              SOIL (tm) <> Sentient Object Interface Language               |\r\n"
                "|                                                                            |\r\n"
                "|                            IdeaFarm " "(tm) Space                             |\r\n"
                "|                                                                            |\r\n"
                "|                         System Port 902/tcp: Door                          |\r\n"
                "|                                                                            |\r\n"
                "|    IPDOS (tm) <> IdeaFarm " "(tm) Piggyback Distributed Operating System     |\r\n"
                "|                                                                            |\r\n"
                "+----------------------------------------------------------------------------+\r\n"
                "\r\n"
                "\r\n"
    
            osTextT postOldCmdBannerDoor[] =

            ;

                "\r\n"
                "\r\n"
                "For help information, enter \"space help ;\" (without the quote marks)."
                "\r\n"
                "elapses without receiving anything from you.\r\n"
                "This connection will time out if 8 TICK (45 foreign minutes)\r\n" //CS:CODEsYNC: f750104 f750104
                "\r\n"
                "to prior commands.\r\n"
                "You can continue to enter commands while sentient objects are responding\r\n"
                "I am now in command mode.\r\n"
                "\r\n"
                "\r\n"
                "+----------------------------------------------------------------------------+\r\n"
                "|                                                                            |\r\n"
                "|              SOIL (tm) <> Sentient Object Interface Language               |\r\n"
                "|                                                                            |\r\n"
                "|                            IdeaFarm " "(tm) Space                             |\r\n"
                "|                                                                            |\r\n"
                "|                      System Port 903/tcp: Panic Door                       |\r\n"
                "|                                                                            |\r\n"
                "|    IPDOS (tm) <> IdeaFarm " "(tm) Piggyback Distributed Operating System     |\r\n"
                "|                                                                            |\r\n"
                "+----------------------------------------------------------------------------+\r\n"
                "\r\n"
                "\r\n"
    
            osTextT postOldCmdBannerPanic[] =

            bWoth = 0 ;
        {
        if( bWoth && idEscapedP == '!' )
    {
    while( !bQuit && !bQuitP && !etThread && !POOP )
    ZE( boolT , bQuit ) ;
    boolT bWoth = 1 ;

    time1idleTimeoutWriteP = time1idleTimeoutReadP = TICK * 0x8 ; //CS:CODEsYNC: f750104 f750104

    boolT bPanicP = c8p.c2 ;
    count8S& c8p = *(count8S*)cArgP ;
{
voidT httpRawCommandServerCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , countT& cArgP , socketC& sockP , countT& time1idleTimeoutReadP , countT& time1idleTimeoutWriteP , sessionsC& sessionsP , nicNameC& nnPeerP , const countT idEscapedP )

}
{
voidT httpLoadContentStaticCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP )

}
    meP.storeReplyF( tinP , ifcIDfORMhTTPrEPLY_BIGhEAD , T("/") , 0 , ifcIDsNIPpREDEFINED_HTTPoKtEXThTML , T(bPanicP?"Panic Door to IdeaFarm " "(tm) Space":"Door to IdeaFarm " "(tm) Space") , T("SOIL (tm) <> Sentient Object Interface Language") , T("SOIL (tm) <> Sentient Object Interface Language") , T("Where humans and robots converse...") , T("") , T("") , homeOld20190809CBF ) ;

    boolT bPanicP = c8p.c2 ;
    count8S& c8p = *(count8S*)cArgP ;
{
voidT httpLoadContentDynamicCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP )

}
{
voidT httpFreshenCacheCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , sessionsC& sessionsP , countT& cArgP , const boolT bCleanupP )

}
    meP.pushSnipF( tinP , stBodyP , ( session.psttKeyDefPending ? tFormDefine : tForm ) + tContent ) ;

    }
        tFormDefine = tFormPart1+tFormPart2+T("Enter the definition and then click \"Done\":")+tFormPart3+tFormPart4+T(session.psttKeyDefPending)+tFormPart5 ;

        ) ;
    
            "<P>\r\n"
            "</CENTER>\r\n"
                "</FORM>\r\n"
                    "</TABLE>\r\n"
                        "</TR>\r\n"
                            "</TD>\r\n"
                                "</SCRIPT>\r\n"
                                    "// -->\r\n"
                                        "document.getElementById( \"idiDef\" ).focus() ;\r\n"
                                    "<!--\r\n"
                                "<SCRIPT LANGUAGE=\"JavaScript\">\r\n"
                                "</textarea>\r\n"
                                " here."
    
        TN( tFormPart5 ,

        ) ;
    
                                "Type the definition of "
                                "<BR><textarea id=idiDef rows=\"20\" cols=\"80\" name=\"def\" onclick=\"select() ;\">\r\n"
                                "<INPUT TYPE=SUBMIT value=\"Done\">\r\n"

                            "<TD rowspan=3 style=\"background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ; align=center\">\r\n"
                        "<TR>\r\n"
    
        TN( tFormPart4 ,

        ) ;
    
                        "</TR>\r\n"
                            "</TD>\r\n"
                                "</SPAN>\r\n"
    
        TN( tFormPart3 ,

        ) ;
    
                                "<SPAN class=\"spaXSmall\">"
                            "<TD colspan=3 style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; align=center\">\r\n"
                        "<TR>\r\n"
    
        TN( tFormPart2 ,

        ) ;
    
                    "<TABLE style=\"border-width: thick ; border-style: ridge ; border-color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ; background-color:" ifcCOLORhTMLwHAT_BACKnORMAL  " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ;\">\r\n"
                "<FORM METHOD=\"POST\" NAME=\"defineform\">\r\n"
            "<CENTER>\r\n"
    
        TN( tFormPart1 ,
    {
    TN( tFormDefine , "" ) ;

    }
        }
            else               tForm = tFormPart1+tFormPart2+T("The SOIL (tm) command in the box contains errors.  Edit it, or clear it and then press the Enter key for help.")+tFormPart3+tFormPart4+T(pzsttCmd)      +tFormPart5 ;
            if( !pzsttCmd )    tForm = tFormPart1+tFormPart2+T("Press the Enter key now to command the object named \"space\" to display help information."                    )+tFormPart3+tFormPart4+T("space help ;")+tFormPart5 ;
        {
        else
        else if( idShow == 1 ) tForm = tFormPart1+tFormPart2+T("Enter a SOIL (tm) command in the white box, or press the Enter key for help."                                  )+tFormPart3+tFormPart4                  +tFormPart5 ;
        if( pMemory->bOk )     tForm = tFormPart1                                                                                                                                          +tFormPart4                  +tFormPart5 ;

        ) ;
    
            "<P>\r\n"
            "</CENTER>\r\n"
                "</FORM>\r\n"
                    "</TABLE>\r\n"
                        "</TR>\r\n"
                            "</TD>\r\n"
                                "</SCRIPT>\r\n"
                                    "// -->\r\n"
                                        "document.getElementById( \"idiCmd\" ).focus() ;\r\n"
                                    "<!--\r\n"
                                "<SCRIPT LANGUAGE=\"JavaScript\">\r\n"
                                "\" ONCLICK=\"select() ;\"><BR>\r\n"
    
        TN( tFormPart5 ,

        ) ;
    
                                "<INPUT ID=idiCmd TYPE=\"text\" MAXLENGTH=\"1024\" SIZE=\"128\" NAME=\"cmd\" value=\""
                            "<TD rowspan=3 style=\"background-color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ; align=center\">\r\n"
                        "<TR>\r\n"
    
        TN( tFormPart4 ,

        ) ;
    
                        "</TR>\r\n"
                            "</TD>\r\n"
                                "</SPAN>\r\n"
    
        TN( tFormPart3 ,

        ) ;
    
                                "<SPAN class=\"spaXSmall\">"
                            "<TD colspan=3 style=\"background-color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ; color:" ifcCOLORhTMLwHAT_BACKnORMAL " ; align=center\">\r\n"
                        "<TR>\r\n"
    
        TN( tFormPart2 ,

        ) ;
    
                    "<TABLE style=\"border-width: thick ; border-style: ridge ; border-color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ; background-color:" ifcCOLORhTMLwHAT_BACKnORMAL  " ; color:" ifcCOLORhTMLwHAT_FOREnORMAL  " ;\">\r\n"
                "<FORM METHOD=\"POST\" NAME=\"cmdform\">\r\n"
            "<CENTER>\r\n"
    
        TN( tFormPart1 ,
    {
    TN( tForm , "" ) ;

    }
        while( ~hWalk ) ;
        }
            tContent += T(pstte)+tbr ;
            strokeS* pstte = (strokeS*)session.stJournal.upF( tinP , hWalk ) ;
        {
        do
        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        TN( tbr , "<BR>" ) ;
    {

    session.stJournal.purgeF( tinP , TUCK >> 3 ) ;
    }
        }
            etThread.delF( tinP , psttReply ) ;
            }
                pMemory->bOk = 1 ;
                session.stJournal << psttv ; psttv = 0 ;
                psttv = psttOldC( tinP , etThread , psttReply ) ; ___( psttv ) ;
                session.stJournal << psttv ; psttv = 0 ;
                strokeS* psttv = psttOldC( tinP , etThread , T("<SPAN CLASS=\"spaXXSmall\" STYLE=\"color:" ifcCOLORhTMLwHAT_FOREnOTEbRIGHT  " ;\">")+(bDef?T("<pre>")+T(pzsttCmd)+T("</pre>"):T(pzsttCmd))+T("</SPAN>") ) ; ___( psttv ) ;
            {
            if( psttReply )
            obeyF( tinP , cArgP , psttReply , pzsttCmd , flDOORoBEY_HTML | flDOORoBEY_FIXEDwIDTHfONT , &session ) ; ___( psttReply ) ;
            ZE( strokeS* , psttReply ) ;
            pzsttCmd = (strokeS*)(countT)swKVP ;
        {
        if( bCmd || bDef )

        const boolT bDef = !etThread.strCompareF( tinP , psttLeverKVP , T("def") ) ;
        const boolT bCmd = !etThread.strCompareF( tinP , psttLeverKVP , T("cmd") ) ;

        psttLeverKVP = (strokeS*)swKVP.leverF( tinP , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swKVP.cFlavorsF( tinP ) ;
    TN( tContent , "" ) ;
    pMemory->bOk = 0 ;
    ZE( strokeS* , pzsttCmd ) ;

    }
        pMemory = (sessionMemoryS*)(byteT*)session ;
        etThread.memSetF( tinP , pbMemory , sizeof( sessionMemoryS ) ) ;
        etThread.newF( tinP , LF , pbMemory , sizeof( sessionMemoryS ) ) ; ___( pbMemory ) ;
        byteT*& pbMemory = session ;
    {
    if( !pMemory )
    sessionMemoryS* pMemory = (sessionMemoryS*)(byteT*)session ;

    countT idShow = session.dispenseIdF( tinP , ClEVERdISPENSEiD_SHOW ) ;
    sessionC& session = sessionsP( tinP , nnPeerP , psttPeerAgentP ) ;
{
voidT homeOld20190809CBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttUrlP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )

}
    return bQuit ;

    }
        POOPR ;
    
        }
            (*tinP.pEtScratch)( tinP , pStkWords ) ;
            }
                }
                    }
                        break ;
                        }
                            tinP.pEtScratch->delF( tinP , psttw ) ;
                            POOPR

                            }
                                peanutsF( tinP , *tinP.pEtScratch , psttReplyP ) ; ___( psttReplyP ) ;
                            {
                            else if( !tinP.pEtScratch->strCompareF( tinP , psttw , T("peanutz" ) ) )  //U::PROTECT WITH ACCT LOGIN
                            else if( !tinP.pEtScratch->strCompareF( tinP , psttw , T("calendar") ) ) idDo = 5 ;
                            else if( !tinP.pEtScratch->strCompareF( tinP , psttw , T("define"  ) ) ) idDo = 4 ;
                            else if( !tinP.pEtScratch->strCompareF( tinP , psttw , T("echo"    ) ) ) idDo = 3 ;
                            else if( !tinP.pEtScratch->strCompareF( tinP , psttw , T("home"    ) ) ) idDo = 2 ;
                            else if( !tinP.pEtScratch->strCompareF( tinP , psttw , T("port"    ) ) ) idDo = 1 ;
                            }
                                break ;
                                tinP.pEtScratch->delF( tinP , psttw ) ;
                                POOPR

                                tinP.pEtScratch->strMakeF( tinP , psttReplyP , T(bOk?"ok\r\n":"no\r\n") ) ; ___( psttReplyP ) ;

                                }
                                    else tFile += T("/")+T(psttzw) ;
                                    else if( !tinP.pEtScratch->strCompareF( tinP , psttzw , T("bcc") ) ) tFile += T(bSawCC?"/":"//") ;
                                    }
                                        tFile += T("/") ;
                                        bSawCC = 1 ;
                                    {
                                    else if( !tinP.pEtScratch->strCompareF( tinP , psttzw , T("cc") ) )
                                    else if( !tinP.pEtScratch->strCompareF( tinP , psttzw , T("body") ) ) bBody = 1 ;
                                    }
                                        break ;

                                        else       bOk = 1 ;
                                        if( POOP ) POOPR
                                        tinP.pEtScratch->delF( tinP , postb ) ;
                                        tinP.pEtScratch->boxPutF( tinP , tFile , postb , costb ) ;
                                        countT costb = tinP.pEtScratch->strMakeF( tinP , postb , psttzw ) ; ___( postb ) ;
                                        ZE( osTextT* , postb ) ;
                                    {
                                    if( bBody )

                                    strokeS* psttzw = psttWordF( tinP , psttw , pSessionP ) ;
                                    *pStkWords >> psttw ; ___( psttw ) ;
                                    tinP.pEtScratch->delF( tinP , psttw ) ;
                                {
                                while( *pStkWords )
                                ZE( boolT , bOk ) ;
                                ZE( boolT , bBody ) ;
                                ZE( boolT , bSawCC ) ;
                                TN( tFile , "//smtp" ) ;
                            {
                            else if( !tinP.pEtScratch->strCompareF( tinP , psttw , T("mail") ) ) // FORMAT: mail [from] [to] [to] cc [cc] [cc] bcc [bcc] [bcc] body [body] ;
                            }
                                break ;
                                tinP.pEtScratch->delF( tinP , psttw ) ;
                                POOPR

                                clockF( tinP , *tinP.pEtScratch , psttReplyP ) ; ___( psttReplyP ) ;
                            {
                            else if( !tinP.pEtScratch->strCompareF( tinP , psttw , T("clock") ) )
                            }
                                break ;
                                tinP.pEtScratch->delF( tinP , psttw ) ;
                                POOPR

                                reportF( tinP , (*tinP.pEtScratch) , psttReplyP , flagsP ) ; ___( psttReplyP ) ;
                            {
                            else if( !tinP.pEtScratch->strCompareF( tinP , psttw , T("report") ) )
                            }
                                break ;
                                tinP.pEtScratch->delF( tinP , psttw ) ;
                                POOPR

                                helpF( tinP , (*tinP.pEtScratch) , cArgP , psttReplyP , flagsP ) ; ___( psttReplyP ) ;
                            {
                            else if( !tinP.pEtScratch->strCompareF( tinP , psttw , T("help") ) )
                            }
                                break ;
                                tinP.pEtScratch->delF( tinP , psttw ) ;
                                POOPR

                                }
                                    else { tinP.pEtScratch->strMakeF( tinP , psttReplyP , T("done.  i will be dying momentarily...\r\n") ) ; ___( psttReplyP ) ; }
                                    }
                                        tinP.pEtScratch->strMakeF( tinP , psttReplyP , T("could not fire the os\r\n") ) ; ___( psttReplyP ) ;
                                        POOPR ;
                                    {
                                    if( POOP )
                                    tinP.pEtScratch->osFireF( tinP ) ;
                                {
                                else
                                if( !bPanicP ) { tinP.pEtScratch->strMakeF( tinP , psttReplyP , T("yeah, right.\r\n") ) ; ___( psttReplyP ) ; }
                            {
                            else if( !tinP.pEtScratch->strCompareF( tinP , psttw , T("booot") ) ) //U::DO NOT DOCUMENT UNTIL SESSIONS ARE SECURED WITH LOGIN, AND THIS COMMAND IS SECURED
                            }
                                break ;
                                tinP.pEtScratch->delF( tinP , psttw ) ;
                                POOPR

                                bQuit = 1 ;
                                tinP.pEtScratch->strMakeF( tinP , psttReplyP , T("ok. bye.\r\n") ) ; ___( psttReplyP ) ;
                            {
                            else if( !tinP.pEtScratch->strCompareF( tinP , psttw , T("bye") ) )
                            }
                                idDo = 0 ;
                                }
                                    }
                                        break ;
                                        calendarF( tinP , *tinP.pEtScratch , psttReplyP , scDaysOff ) ; ___( psttReplyP ) ;
                                        const sCountT scDaysOff = tinP.pEtScratch->strDigitsToSCountF( tinP , psttzw ) ;
                                        strokeS* psttzw = psttWordF( tinP , psttw , pSessionP ) ;
                                    {
                                    case 5 :
                                    }
                                        break ;
                                        tinP.pEtScratch->strMakeF( tinP , psttReplyP , T("ok\r\n") ) ; ___( psttReplyP ) ;
    
                                        }
                                            }
                                                *pStkWords >> psttv ; ___( psttv ) ;
                                                tinP.pEtScratch->delF( tinP , psttv ) ;
                                                strokeS*& psttv = *(strokeS**)&(countT&)pSessionP->swStringVariable ;
                                                pSessionP->psttzKey = psttw ;
                                            {
                                            else
                                            }
                                                pSessionP->psttKeyDefPending = psttw ; psttw = 0 ;
                                                tinP.pEtScratch->delF( tinP , pSessionP->psttKeyDefPending ) ;
                                            {
                                            if( !*pStkWords )
                                        {
                                        if( pSessionP )
                                    {
                                    case 4 :
                                    }
                                        break ;
                                        tinP.pEtScratch->strMakeF( tinP , psttReplyP , T("<pre>")+T(psttzw)+T("</pre>\r\n") ) ; ___( psttReplyP ) ;
                                        strokeS* psttzw = psttWordF( tinP , psttw , pSessionP ) ;
                                    {
                                    case 3 :
                                    }
                                        break ;
                                        tinP.pEtScratch->strMakeF( tinP , psttReplyP , T(nnHome)+T(" ok\r\n") ) ; ___( psttReplyP ) ;
                                        nnHome = socketC::nicNameIF( tinP , (*tinP.pEtScratch) , psttzw ) ;
                                        strokeS* psttzw = psttWordF( tinP , psttw , pSessionP ) ;
                                    {
                                    case 2 :
                                    }
                                        break ;
                                        tinP.pEtScratch->strMakeF( tinP , psttReplyP , T("ok\r\n") ) ; ___( psttReplyP ) ;
                                        idPortHome = tinP.pEtScratch->strDigitsToSCountF( tinP , psttzw ) ;
                                        strokeS* psttzw = psttWordF( tinP , psttw , pSessionP ) ;
                                    {
                                    case 1 :
                                {
                                switch( idDo )
                            {
                            if( idDo )
    
                            *pStkWords >> psttw ; ___( psttw ) ;
                            ZE( strokeS* , psttw ) ;
                        {
                        while( *pStkWords )
                        ZE( countT , idDo ) ;
                    {
                    case IDoBJECT_space :
                {
                switch( idObject )
            {
            if( !bContinue )
        
            tinP.pEtScratch->delF( tinP , pstt1w ) ;
            }
                }
                    *pStkWords << psttw ;
                    strokeS* psttw = psttOldC( tinP , (*tinP.pEtScratch) , psttc1 ) ; ___( psttw ) ;
                {
                else
                }
                    if( tinP.pEtScratch->strCompareF( tinP , psttc1 , T(";") ) ) bContinue = 1 ;
                {
                else if( BlATHsTRING1 )
                }
                    if( !tinP.pEtScratch->strCompareF( tinP , psttc1 , T("space") ) ) idObject = IDoBJECT_space ;
                {
                if( BwOTHsTRING1 )
            {
            FORsTRINGSiN1( pstt1w )
            ZE( boolT  , bContinue ) ;
            ZE( countT , idObject ) ;
            tinP.pEtScratch->strWordsOldF( tinP , pstt1w , psttOldCmdP , sttq ) ; ___( pstt1w ) ;
            strokeS sttq ;
            ZE( strokeS* , pstt1w ) ;
        
            (*tinP.pEtScratch)( tinP , pStkWords , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
            ZE( stackC* , pStkWords ) ;
        
            if( psttReplyP ) { BLAMMO ; }
        {
        else
        }
            tinP.pEtScratch->strMakeF( tinP , psttReplyP , T("ok\r\n") ) ; ___( psttReplyP ) ;
            tinP.pEtScratch->strMakeF( tinP , psttv , psttOldCmdP ) ; ___( psttv ) ;
            tinP.pEtScratch->delF( tinP , psttv ) ;
            tinP.pEtScratch->delF( tinP , pSessionP->psttKeyDefPending ) ;
            strokeS*& psttv = *(strokeS**)&(countT&)pSessionP->swStringVariable ;
            pSessionP->psttzKey = pSessionP->psttKeyDefPending ;
        {
        if( pSessionP->psttKeyDefPending )
    
        POOPR ;
    {
    IFsCRATCH
    ZE( boolT , bQuit ) ;

    boolT bPanicP = c8p.c2 ;
    count8S& c8p = *(count8S*)cArgP ;
{
boolT obeyF( tinS& tinP , countT& cArgP , strokeS*& psttReplyP , const strokeS* const psttOldCmdP , const flagsT flagsP = flDOORoBEY_null , sessionC* pSessionP = 0 )

}
    return psttzw ;

    }
        }
            psttzw = *(strokeS**)&(countT&)pSessionP->swStringVariable ;
            pSessionP->psttzKey = psttzw ;
        {
        if( pSessionP->swStringVariable.idSlotOfLeverF( tinP , (countT)psttzw ) )
    {
    if( pSessionP )
    strokeS* psttzw = psttP ;
{
strokeS* psttWordF( tinS& tinP , strokeS* const psttP , sessionC* pSessionP = 0 )

}
    etherP.strFuseF( tinP , psttP , tEnd ) ;
    }
        }
            }
                }
                    }
                        etherP.delF( tinP , pbTin ) ;
                        }
                            }
                                }
                                    }
                                        ) ;
                
                                            TF2(tinc.monitor.pPanLifiGrabbing[2],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+top+TF2(tinc.monitor.pPanLifiGrabbing[1],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcp+tcr
                    
                                        etherP.strFuseF( tinP , psttP ,
                                    {
                                    if( tinP.pPanLifiRecurseGrabbedLevel[ off ] )
                                {
                                for( countT off = 0 ; off < offEnd ; off += 5 )
                                const countT offEnd = OFFgRABBEDmAX * 5 ;

                                ) ;

                                    +tb+TF2(tinc.monitor.pPanLifiGrabbing[2],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+top+TF2(tinc.monitor.pPanLifiGrabbing[2],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcp
                                    TF3(tinc.monitor.idThread,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TP(tinc.postThreadName,0x20)

                                etherP.strFuseF( tinP , psttP ,
                            {
                            if( tinc.monitor.pPanLifiGrabbing[ 0 ] )
                            //CONoUTrAW( T("[osPid,bIda,ip]:")+tb+TF2(osPid,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb+TF2(bIda,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb+TF2(ip,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcr ) ;
        
                            tinS& tinc = *(tinS*)pbTin ;
                        {
                        if( pbTin && cbTin == sizeof( tinS ) )
                        sIn2.shiftRightF( tinP , pbTin , cbTin , ifcIDtYPEsOULiTEM_byteTptr ) ; ___( pbTin ) ;
                        ZE( countT , cbTin ) ;
                        ZE( byteT* , pbTin ) ;
                    {
                    if( bOk )
                    
                    sIn2 >> bOk ;
                    ZE( countT , bOk ) ;
    
                    __( idReply - ifcIDrEPLYmONITOR_IMAGE ) ;
                    sIn2 >> idReply ;
                    ZE( countT , idReply ) ;
                    
                    sockm.readF( tinP , sIn2 ) ;
                    soulC sIn2( tinP , TAG( TAGiDnULL ) ) ;
                    
                    sockm.writeF( tinP , sOut2 ) ;
                    sOut2 << sizeof( tinS ) ;
                    sOut2 << ip ;
                    sOut2 << osPid ;
                    sOut2 << (countT)ifcIDcMDmONITOR_IMAGE ;
                    soulC sOut2( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( !bIda )

                sIn >> ip ;
                ZE( countT , ip ) ;

                sIn >> bIda ;
                ZE( boolT , bIda ) ;

                sIn >> osPid ;
                ZE( countT , osPid ) ;
            {
            while( cTin -- )
            sIn >> cTin ;
            ZE( countT , cTin ) ;
    
            etherP.strFuseF( tinP , psttP , T("memory space: ")+TF2(idMemorySpace,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tcr ) ;
            sIn >> idMemorySpace ;
            ZE( countT , idMemorySpace ) ;
        {
        while( cFlavorsMemory -- )
    
        sIn >> cFlavorsMemory ;
        ZE( countT , cFlavorsMemory ) ;
    {
    while( sIn )
    
    __( idReply - ifcIDrEPLYmONITOR_tinS ) ;
    sIn >> idReply ;
    ZE( countT , idReply ) ;
    
    sockm.readF( tinP , sIn ) ;
    soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
    
    sockm.writeF( tinP , sOut ) ;
    sOut << (countT)ifcIDcMDmONITOR_tinS ;
    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;

    etherP.strMakeF( tinP , psttP , tBegin+T("IPDOS (tm) <> IdeaFarm " "(tm) Piggyback Distributed Operating System")+tcr+T("Performance Monitor")+tcr , TOCK ) ; ___( psttP ) ;

    TN( tEnd   , !( F(flagsP) & flDOORoBEY_FIXEDwIDTHfONT ) ? "" : "</SPAN></PRE>" ) ;
    TN( tBegin , !( F(flagsP) & flDOORoBEY_FIXEDwIDTHfONT ) ? "" : "<PRE><SPAN style=\"font-family:monospace\">" ) ;

    TN( tcp  , ")" ) ;
    TN( top  , "(" ) ;
    TN( tb   , " " ) ;
    TN( tcr  , "\r\n" ) ;
    
    //sockm.connectF( tinP , 0x40c , socketC::nicNameIF( tinP , etherP , T("ideafarm.com") ) ) ;
    //sockm.connectF( tinP , home.idPortKernelMonitor , socketC::nicNameIF( tinP , etherP , T("10.1.1.1") ) ) ;

    else                         sockm.connectF( tinP , idPortHome , nnHome ) ;
    if( !idPortHome || !nnHome ) sockm.connectF( tinP , home.idPortKernelMonitor ) ;

    socketC sockm( tinP , etherP , TAG( TAGiDnULL ) ) ;
    
    homeS& home = homeS::homeIF() ;
{
voidT reportF( tinS& tinP , etherC& etherP , strokeS*& psttP , const flagsT flagsP = flDOORoBEY_null )

}
    etherP.delF( tinP , psttw ) ;
    etherP.strMakeF( tinP , psttP , T("<span class=\"spaXSmall\"><pre>")+T(psttw)+T("</pre></span>") ) ; ___( psttP ) ;
    etherP.strClockOldF( tinP , psttw , time1 ) ; ___( psttw ) ;
    ZE( strokeS* , psttw ) ;
    
    etherP.osTimeNowF( tinP , time1 , *(sCountT*)&countTC() ) ;
    ZE( countT , time1 ) ;
{
voidT clockF( tinS& tinP , etherC& etherP , strokeS*& psttP )

}
    etherP.delF( tinP , psttw ) ;
    etherP.strMakeF( tinP , psttP , T("<pre>")+T(psttw)+T("</pre>") ) ; ___( psttP ) ;
    etherP.strCalendarF( tinP , psttw , time2 + scDaysOffP ) ; ___( psttw ) ;
    ZE( strokeS* , psttw ) ;
    
    etherP.osTimeNowF( tinP , countTC() , time2 ) ;
    ZE( sCountT , time2 ) ;
{
voidT calendarF( tinS& tinP , etherC& etherP , strokeS*& psttP , const sCountT scDaysOffP = 0 )

}
    }
        etherP.strMakeF( tinP , psttP , tContent ) ; ___( psttP ) ;
        tContent += T("</PRE></SPAN>") ;
        }
            tContent += tpa ;
            }
                DEL( pDatum ) ;
                tContent += T(((datumPeanutC*)pDatum)->psttOldCommentF())+tcr ;
                sws_pDatum >> pDatum ;
                ZE( plateC* , pDatum ) ;
            {
            while( sws_pDatum )
    
            tContent += TF2(((datumPeanutC*)pDatumLever)->idAdamF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tsp+T(((datumPeanutC*)pDatumLever)->psttUrlF())+tpa ;
            pDatumLever = (datumPeanutC*)sws_pDatum.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        TN( tpa , "\r\n\r\n" ) ;
        TN( tcr , "\r\n" ) ;
        TN( tsp , " " ) ;
        countT cFlavors = sws_pDatum.cFlavorsF( tinP ) ;
    
        }
            etherP.delF( tinP , pstt1m ) ;
            }
                etherP.delF( tinP , psttShort ) ;
                etherP.delF( tinP , psttDirOld ) ;
                etherP.delF( tinP , psttDirNew ) ;
                }
                    }
                        }
                            datumPeanutC::setModeF() ;
                            sws_pDatum.sinkF( tinP , countTC() , pDatum ) ;
                            datumPeanutC::setModeF( 1 ) ;
                            pDatumLever = pDatum ;
                            datumPeanutC* pDatum = new( 0 , tinP , LF ) datumPeanutC( tinP , etherP , sIn ) ; ___( pDatum ) ;
                        {
                        else
                        }
                            LOGrAW( T("bad form file: ")+T(psttc1)+T("\r\n") ) ;
                            POOPR
                        {
                        if( POOP )
                            
                        etherP.boxGetShadowF( tinP , sIn , tAllNew ) ;
                        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    else
                    if( POOP ) { POOPR ; }
                    tinP.pEtScratch->diskMoveFileOrDirF( tinP , tAllNew , T(psttDirOld)+tShort ) ;
                    TN( tAllNew , "" ) ; tAllNew = T(psttDirNew)+tShort ;
                    TN( tShort , "" ) ; tShort = T(psttShort) ;
                {
                if( psttDirNew && psttDirOld && psttShort )
                etherP.strReplaceF( tinP , psttDirNew , psttDirOld , tOldDir , tNewDir ) ; ___( psttDirNew ) ;
                etherP.strBisectF( tinP , psttDirOld , psttShort , psttc1 , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttDirOld ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttDirOld ) ;
                ZE( strokeS* , psttDirNew ) ;
            {
            FORsTRINGSiN1( pstt1m )
            etherP.boxMenuF( tinP , soul , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF2(ifcIDaDAM_ROOTfORMdATAeATER,flFORMAT_NObIGITvALUES)+T("/arc/form.peanut*") , 0 , TUCK ) ; ___( pstt1m ) ;
            TN( tNewDir , "/arc.seen/" ) ;
            TN( tOldDir , "/arc/" ) ;
            ZE( strokeS* , pstt1m ) ;
        {
        switchStackC sws_pDatum( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pDatumLever , flSTACKc_null , ifcSTACKtYPE_PTR_plateC ) ;
        ZE( plateC* , pDatumLever ) ;
    
        tContent = T("<SPAN STYLE=\"font-family: monospace\"><PRE>") ;
        TN( tContent , "" ) ;
    {
    IFsCRATCH
{
voidT peanutsF( tinS& tinP , etherC& etherP , strokeS*& psttP )

}
    }
        if( cbGrab != sizeof( grabC ) || getNegAM( ((grabC*)pbGrabP)->finger ) != FINGERnEG_BASEgRABc ) etherP.delF( tinP , pbGrabP ) ;
        sIn3.shiftRightF( tinP , pbGrabP , cbGrab , ifcIDtYPEsOULiTEM_byteTptr ) ; ___( pbGrabP ) ;
        ZE( countT , cbGrab ) ;
    {
    if( bOk )
                                    
    sIn3 >> bOk ;
    ZE( countT , bOk ) ;
                    
    __( idReply - ifcIDrEPLYmONITOR_IMAGE ) ;
    sIn3 >> idReply ;
    ZE( countT , idReply ) ;
                                    
    sockP.readF( tinP , sIn3 ) ;
    soulC sIn3( tinP , TAG( TAGiDnULL ) ) ;
                                    
    sockP.writeF( tinP , sOut3 ) ;
    sOut3 << sizeof( grabC ) ;
    sOut3 << (countT)pForeignGrabP ;
    sOut3 << osPidP ;
    sOut3 << (countT)ifcIDcMDmONITOR_IMAGE ;
    soulC sOut3( tinP , TAG( TAGiDnULL ) ) ;
{
voidT image_grabC_F( tinS& tinP , etherC& etherP , byteT*& pbGrabP , socketC& sockP , baseGrabC* pForeignGrabP , countT osPidP )

}

    ) ; ___( psttP ) ;

        +tListEnd
        //WORKS, BUT NOT PROTECTED BY LOGIN PRIVILEGES, SO DON'T REVEAL THIS: +tListItem+T("space mail from@foo.com to1@bar.com to2@bar.com cc cc1@goo.com cc2@goo.com bcc bcc1@hoo.com bcc2@hoo.com body \"Subject: This is a one line message.\" ;\r\n")
        +tListItem+T("space clock ;\r\n")
        +tListItem+T("space calendar 1- ; (calendar with yesterday's date highlighted)\r\n")
        +tListItem+T("space calendar 0 ; (calendar with today's date highlighted)\r\n")
        +tListItem+T("space define myKey ; (to enter a multiline value)\r\n")
        +tListItem+T("space define myKey \"myValue1 myValue2 myValue3\" ;\r\n")
        +tListItem+T("space echo fooey ;\r\n")
        +tListItem+T("space home ideafarm.com ; (\"ideafarm.com\" is an example value; can also be \"192.86.24.07\".)\r\n")
        +tListItem+T("space port 123 ; (\"123\" is an example value.)\r\n")
        +tListItem+T("space report ;\r\n")
        +tListItem+T("space help ;\r\n")
        +tListItem+T("space bye ; (has no effect for datagram and http sessions; for raw telnet sessions, server will close the connection)\r\n")
        +tListBegin
        +tpa
        )
            "Here is a list of all commands that you can use here:\r\n"
        +T(
        +tpa
        )
                    "attack and to investigate software failures.\r\n"
                    "Panic Doors, are used mainly by IdeaFarm " "(tm) Operations to defend the system against\r\n"
                    "to your account.  If you are a normal user, you are at the right place.  The alternative,\r\n"
                    "upon whether you are logged on and, if you are logged on, what privileges are granted\r\n"
                    "During your session at this Door, what you will be allowed to do will depend\r\n"
                    "You are interacting with IPDOS (tm) using the Door of an IPDOS (tm) Home.\r\n"
                :
                    "investigate software failures.\r\n"
                    "used mainly by IdeaFarm " "(tm) Operations to defend the system against attack and to\r\n"
                    "to your account.  Normal users are not allowed to do much at a Panic Door; those are\r\n"
                    "upon whether you are logged on and, if you are logged on, what privileges are granted\r\n"
                    "During your session at this Panic Door, what you will be allowed to do will depend\r\n"
                    "You are interacting with IPDOS (tm) using the Panic Door of an IPDOS (tm) Home.\r\n"
                ?
            bPanicP
        +T(
        +tpa
        )
            "is a command.  Words after the command are adverbs.  A semicolon ';' terminates each command.\r\n"
            "SOIL (tm) consists of a sequence of commands.  Each command begins with the name of the object being addressed.  The next word\r\n"
            "To communicate with objects in IdeaFarm " "(tm) Space, you use SOIL (tm) <> Sentient Object Interface Language.  Speech in\r\n"
        +T(
        +tpa
        )
            "information before continuing here.\r\n"
            "IPDOS (tm).  If you have not, click \"ideas\" now at the top of any page of the IDEAFARM.COM web site and read the IPDOS (tm)\r\n"
            "This introduction assumes that you have read the One Minute Introduction to IPDOS (tm) and the Five Minute Introduction to\r\n"
        +T(
        +tCenterOff
        +T("Introduction")+tpa
        +T("IPDOS (tm) <> IdeaFarm " "(tm) Piggyback Distributed Operating System")+tpa
        tCenterOn

    etherP.strMakeF( tinP , psttP ,

    TN( tListEnd   , !( F(flagsP) & flDOORoBEY_HTML ) ? "" : "</UL>" ) ;
    TN( tListItem  , !( F(flagsP) & flDOORoBEY_HTML ) ? "    " : "<LI>" ) ;
    TN( tListBegin , !( F(flagsP) & flDOORoBEY_HTML ) ? "" : "<UL>" ) ;
    TN( tCenterOff , !( F(flagsP) & flDOORoBEY_HTML ) ? "" : "</CENTER>" ) ;
    TN( tCenterOn  , !( F(flagsP) & flDOORoBEY_HTML ) ? "" : "<CENTER>" ) ;
    TN( tpa        , !( F(flagsP) & flDOORoBEY_HTML ) ? "\r\n\r\n" : "<P>" ) ;
    TN( tbr        , !( F(flagsP) & flDOORoBEY_HTML ) ? "\r\n" : "<BR>" ) ;
    
    homeS& home = homeS::homeIF() ;

    boolT bPanicP = c8p.c2 ;
    count8S& c8p = *(count8S*)cArgP ;
{
voidT helpF( tinS& tinP , etherC& etherP , countT& cArgP , strokeS*& psttP , const flagsT flagsP = flDOORoBEY_null )

countT idPortHome ;
nicNameC nnHome ;

#include postHEADER

//OBSOLETES 0850104, WHICH FORMERLY SERVED WO OF THE DOORS AND I SERVED THE OTHER

/*1*/WAKEhIDE( "ifcIDaDAM_KERNEL3PANICdOOR" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

