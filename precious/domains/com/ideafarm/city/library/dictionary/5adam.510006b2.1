
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
//etThread.traceF( tinP , T("bye") ) ;
//
//if( _restart < 0x10 ) *pcBlammo = 0xbbbbbbbb ;
//
//}
//    etThread.traceF( tinP , T("[_restart]: ")+TF2(_restart,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
//{
//if( _restart )
//
//_restart.flags |= flRESTARTc_QUIET ;
//RESTART
//
//ZE( countT* , pcBlammo ) ;

etThread.osThreadF( TaRG1( tmWorkF ) ) ;

TODO

DONE( tmWorkF )
}
    RESTART
{
if( pTaskP )



                    if( tinP.monitor.idThread <= ClOWtHREADS && !( ++ processGlobal1S::_processGlobal1I_IF().pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                    _IO_
                    if( tinP.idPhase1 < ifcIDpHASEtHREAD_WORKING ) tinP.idPhase1 = ifcIDpHASEtHREAD_WORKING ;
                    (countT&)_stackTop = espAM() ;
                    staticC _stackTop( tinP , "appStackTop" , "tin" ) ;
                    TELL( "TASK0: entering application code" )
                    if( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_WHEREaLL && !( F(tinP.flagsThreadMode1) & flTHREADmODE1_NOwHERE ) ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
                    }
                        etThread.boxPutF( tinP , psttThreadFile , "T" ) ;
                        etThread.strMakeF( tinP , LF , psttThreadFile , T("///ideafarm/ephemeral/tmp/threads/")+TF1(tinP.osPid)+tDot+TF1(DDNUMB)+tDot+T("tmWorkF")+tDot+TF1(tinP.monitor.idThread) ) ; ___( psttThreadFile ) ;
                        TN( tDot , "." ) ;
                    {
                    if( F( ((thirdC&)etThread).third_flagsModeAdam1I_IF( tinP ) ) & flADAMmODE1_SEEtHREADSaSfILES )
                    etThread.osTimeNowF( tinP , tinP.time1 , tinP.time2 ) ;
                    /*etherC::ifcSayIF( T("ADAM CELL (idAdam,osPid): ")+TF1(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T(" ")+TF1(tinP.osPid)+T(" ")+TF1(tinP.osTid)+T(" \"")+T(tinP.postThreadName)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;*/
                {

                tinP.pEther = &etThread ;
                TELL( "TASK0: final setup" )

                /*POPUP( TF1(tinP.monitor.idThread)+T(" ")+T(tinP.postThreadName)+T("\r\n") ) ;*/

                tinP.pScoopEtThread = new( 0 , tinP , LF ) scoopC( tinP , etThread ) ; ___( tinP.pScoopEtThread  ) ;
                etherC& etThread  = *pEtThread ;
            {
            if( pEtThread && tinP.pEtScratch )
            ZE( strokeS* , psttThreadFile ) ;
            TELL( "TASK0: after newing etThread" )
            tinP.pEtScratch = new( 0 , tinP , LF ) etherC( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ; ___( tinP.pEtScratch ) ;
            etherC* pEtThread  = new( 0 , tinP , LF ) etherC( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_TINoWNER | flTHIRDmODE_null ) ; ___( pEtThread ) ;
            TELL( "TASK0: newing etThread" )

            if( pTaskP && F( pTaskP->flagsThreadMode1Dad ) & flTHREADmODE1_NOwHERE                 ) tinP.flagsThreadMode1 |= flTHREADmODE1_NOwHERE                 ;
            if( pTaskP && F( pTaskP->flagsThreadMode1Dad ) & flTHREADmODE1_YELL                    ) tinP.flagsThreadMode1 |= flTHREADmODE1_YELL                    ;
            if( pTaskP && F( pTaskP->flagsThreadMode1Dad ) & flTHREADmODE1_WATCHfORaSYNCHiMPOTENCE ) tinP.flagsThreadMode1 |= flTHREADmODE1_WATCHfORaSYNCHiMPOTENCE ;
            if( pTaskP && F( pTaskP->flagsThreadMode1Dad ) & flTHREADmODE1_QUIETiMPOTENCE          ) tinP.flagsThreadMode1 |= flTHREADmODE1_QUIETiMPOTENCE          ;
            if( pTaskP && F( pTaskP->flagsThreadMode1Dad ) & flTHREADmODE1_SHOWpROGRESS            ) tinP.flagsThreadMode1 |= flTHREADmODE1_SHOWpROGRESS            ;
            TELL( "TASK0: setting flagsThreadMode1" )
            /*CODEsYNC: 00100df 0010055*/

            tinP.pcQuit = &(const countT&)ether ;
            tinP.monitor.idProcessOld = thirdC::third_idProcessOldI_IF( tinP ) ;
            tinP.idlTask  = ifcLINE ;
            tinP.idiTask  = DDNUMB ;
            TELL( "TASK0: setting miscellaneous fields in tinP" )
            etherC& etRock = etherC::etRockIF( tinP ) ;
            etherC& ether = etherC::etPrimeIF( tinP ) ;
            TINSL
        {
        if( bTinOk )
        TELL( "TASK0: after newing either a tinS in the working poolOld" )
        /* AFTER THIS LINE, DO NOT CONSTRUCT ANY OBJECTS THAT HAVE DESTRUCTORS (BECAUSE DECREMENTING cAllKidThreadsI cAllOrphanThreadsI MUST BE THE VERY LAST THING THAT THIS THREAD DOES) */

        }
            }
                ___( pTin ) ;
                TINSL
                /*pTinF() = pTin ;*/
                bTinOk = 1 ;
            {
            if( pTin )
            tinS* pTin = new( 0 , tinP , LF ) tinS( tinP , TAG( TAGiDnULL ) , pTaskP->idThread , pTinDad , "tmWorkF" , flTINs_null , ifcIDtINnAMED_tinInPool ) ;
            TELL( "TASK0: newing a tinS in the working poolOld" )
            tinS* const pTinDad = F(pTaskP->flags) & flTHREADlAUNCH_ORPHAN ? 0 : pTaskP->pTinDad ;
        {
        ZE( boolT , bTinOk ) ;
        taskS* pTaskP = (taskS*)argP ;
        TELL( "TASK0: workF+" )

        OStEXTcLEAR( _ostoTmp )
        osTextC _ostRangerTag( _ostoTmp.costF() + 1 , _ostoTmp , _statRangerTag , _statRangerTag.cbF() ) ;
        staticC _statRangerTag( tinP , "rangerTag" , "sys" , 2 * sizeof( countT ) + _ostoTmp.costF() + 1 , ifcIDtYPEsTATICC_FOOT ) ;
        OStEXTC(  _ostoTmp , tinP.monitor.idThread , 0 )
        OStEXTAK( _ostoTmp , "." )
        OStEXTA(  _ostoTmp , tinP.postThreadName )
        OStEXTAK( _ostoTmp , "RangerTag:threadStack." )
        OStEXTAK( _ostoTmp , "!ifc" )
        OStEXT(   _ostoTmp , 0x80 )

        _IO_ TELLsYSlIFInAME( "tmWorkF" )
        if( tinP.monitor.idThread <= ClOWtHREADS && !( ++ processGlobal1S::_processGlobal1I_IF().pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
        TINSL
    {
    countT tmWorkF_workF( countT argP )

//TASK( tmWorkF )

//20140915@1840: MOVED FROM SCRATCH 8 TO PERMANENT ADAM ID

/*1*/WAKEsHOWtEXT( "scr" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

