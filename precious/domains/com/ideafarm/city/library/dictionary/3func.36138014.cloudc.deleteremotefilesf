
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    ether.delF( tinP , postBody ) ;
    }
        __NZ( bPermanentFailure ) ;

        }
            }
                // break ;
                // 
                // }
                //     continue ;
                //     etPrime.osSleepF( tinP , TOCK << 4 ) ;
                //     sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                // 
                //     etherC::etRockIF( tinP ).traceF( tinP , T("deleteRemoteFileF / unexpected reply (other than \"no content\" or \"not found\") ; will retry after napping 01 tock") ) ;
                //     etherC::etRockIF( tinP ).traceF( tinP , tHear ) ;
                //     POOPR
                // {
                // if( POOP )
                // __( !ether.strIdF( tinP , tReplyCode204_NoContent , tHear ) && !ether.strIdF( tinP , tReplyCode404_NotFound , tHear ) ) ;
                // 
                // }
                //     break ;
                //     etherC::etRockIF( tinP ).traceF( tinP , T("authorization refused") ) ;
                //     bPermanentFailure = 1 ;
                //     POOPR
                // {
                // if( POOP )
                // __NZ( 1 == ether.strIdF( tinP , tReplyCode401_Unauthorized , tHear ) ) ;
                // 
                // }
                //     }
                //         break ;
                //         etherC::etRockIF( tinP ).traceF( tinP , T("deleteRemoteFileF / connect , write, or read failed ; not forgiven") ) ;
                //         bPermanentFailure = 1 ;
                //     {
                //     else
                //     }
                //         continue ;
                //         etPrime.osSleepF( tinP , TOCK << 4 ) ;
                //         sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                // 
                //         etherC::etRockIF( tinP ).traceF( tinP , T("deleteRemoteFileF / connect , write, or read failed ; forgiven ; will retry after napping 01 tock.  (")+TF2(cForgive,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" remain)") ) ;
                //     {
                //     if( cForgive -- )
                // 
                //     POOPR
                // {
                // if( POOP )
                //U:: THIS CODEmINE IS FROM ANOTHER MEMBER FUNCTION ; USE IT TO ADD REPLY VALIDATION (THE CURRENT CODE DOES NOT INSPECT THE REPLY)

                //etherP.boxPutF( tinP , T("///d/tmp/x/goo.ttt") , tIn , tIn.csF( tinP ) ) ;
                //}
                //    }
                //        }
                //            tIn = T(postJson) ;
                //
                //            }
                //                }
                //                    case '}' : { if( !( -- idLevel ) ) bNix = 1 ; break ; }
                //                    case ']' :
                //
                //                    case '{' : {        ++ idLevel              ; break ; }
                //                    case '[' :
                //                {
                //                switch( *postc )
                //
                //                }
                //                    break ;
                //                    *postc = 0 ;
                //                {
                //                if( bNix )
                //            {
                //            for( osTextT* postc = postJson ; *postc ; postc ++ )
                //            ZE( boolT  , bNix ) ;
                //            ZE( countT , idLevel ) ;
                //        {
                //        if( postJson )
                //
                //        if( postJsonSq && postJsonSq < postJson ) postJson = postJsonSq ;
                //        osTextT* postJson   = thirdC::c_strstrIF( tinP , postBody , "{" ) ;
                //        osTextT* postJsonSq = thirdC::c_strstrIF( tinP , postBody , "[" ) ;
                //    {
                //    if( postBody )
                //    osTextT* postBody = thirdC::c_strstrIF( tinP , postHear , "\r\n\r\n" ) ;
                //{
                //TN( tIn , "" ) ; // WILL CONTAIN A SINGLE, TRIMMED JSON WORD

                break ; // I ASSUME THAT THE DELETION REQUEST WAS SUCCESSFUL ; I DO NOT INSPECT THE REPLY
                etherC::etRockIF( tinP ).traceF( tinP , T("deleteRemoteFilesF / requested  deletion (i did not inspect the response)") ) ;

                LOGrAW( "------------ REPLY BODY END -----------------------------\r\n" ) ;
                LOGrAW( postHearBody ) ;
                LOGrAW( "------------ REPLY BODY BEGIN -----------------------------\r\n" ) ;

                }
                    }
                        }
                            }
                                if( !ss.readF( tinP , &ostWo , 1 ) ) { BLAMMO ; } ; // '\n'
                                if( !ss.readF( tinP , &ostWo , 1 ) ) { BLAMMO ; } ; // '\r'

                                postHearBody[ costHearBody ] = 0 ; //20170602@1459 ADDED WITHOUT ANALYSIS WHILE ADDING LOGGING OF SAY AND REPLY
                                costHearBody += costDo ;
                                if( costDo != ss.readF( tinP , postHearBody + costHearBody , costDo ) ) { BLAMMO ; } ;

                                if( !ss.readF( tinP , &ostWo , 1 ) ) { BLAMMO ; } ; // '\n'
                                osTextT ostWo ;
                            {
                            else
                            if( !costDo ) break ;

                            offl = - 1 ;
                            countT costDo = ether.strDigitsToSCountF( tinP , T(postHearLength) , 0 , 1 ) ;
                            postHearLength[ offl ] = 0 ;
                        {
                        if( postHearLength[ offl ] == '\r' )
                        
                        if( !ss.readF( tinP , postHearLength + offl , 1 ) ) { BLAMMO ; } ;
                    {
                    for( countT offl = 0 ; offl < sizeof postHearLength - 1 ; offl ++ )

                    osTextT  postHearLength[ TUCK ] = { 0 } ;
                {
                else
                }
                    etherC::etRockIF( tinP ).traceF( tinP , T("deleteRemoteFilesF: !bChunked so not logging reply") ) ;
                {
                if( !bChunked )
                ZE( countT , costHearBody ) ;
                osTextT postHearBody[ TOCK ] = { 0 } ;

                }
                    }
                        if( *postLength ) costBody = thirdC::c_atoiForeignIF( postLength ) ;

                        }
                            }
                                break ;
                                *postc = 0 ;
                            {
                            if( *postc == '\r' || *postc == '\n' )
                        {
                        for( osTextT* postc = postLength ; *postc ; postc ++ )

                        postLength += sizeof postKey - 1 ;
                    {
                    if( postLength )
                    osTextT* postLength = thirdC::c_strstrIF( tinP , postHearHead , postKey ) ;
                    osTextT postKey[] = "Content-Length:" ;

                    if( thirdC::c_strstrIF( tinP , postHearHead , "Transfer-Encoding: chunked" ) )  bChunked = 1 ;

                    LOGrAW( "------------ deleteRemoteFilesF: REPLY HEAD END -----------------------------\r\n" ) ;
                    LOGrAW( postHearHead ) ;
                    LOGrAW( "------------ deleteRemoteFilesF: REPLY HEAD BEGIN -----------------------------\r\n" ) ;

                    postHearHead[ costHearHead ] = 0 ;
                    }
                        }
                            break ;
                            costHearHead -= 3 ;
                        {
                        else if( costHearHead >= 3 && !thirdC::c_memcmpIF( tinP , postHearHead + costHearHead - 3 , "\r\n\r\n" , 4 ) )
                        }
                            continue ;
                            etherC::etRockIF( tinP ).traceF( tinP , T("deleteRemoteFileF / did not receive a fulll reply ; will retry with a new connection.") ) ;
                            POOPR
                        {
                        if( !costIn )                                                                                                       //20180303@1506: OBSERVED !costIn
                        
                        countT costIn = ss.readF( tinP , postHearHead + costHearHead , 1 ) ;
                    {
                    for( ; costHearHead < sizeof postHearHead - 1 ; costHearHead ++ )
                {
                ZE( countT , costBody ) ;
                ZE( boolT , bChunked ) ;
                ZE( countT , costHearHead ) ;
                osTextT postHearHead[ TOCK ] = { 0 } ;

                ss.writeF( tinP , postBody , costBody ) ;
                ss.writeF( tinP , (osTextT*)tSay , (countT)tSay.csF( tinP ) ) ;
                ss.connectF( tinP , 443 , socketC::nicNameIF( tinP , etScratch , tHost ) ) ;
                socketC ss( tinP , etScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL ) ;
                etherC::etRockIF( tinP ).traceF( tinP , T("deleteRemoteFilesF / requesting deletion") ) ;
            {
            while( !etPrime && !POOP )
            //countT cForgive = 0x2 ;
            etherC& etScratch = *tinP.pEtScratch ;
            ZE( countT , costHear ) ;
            //char postHear[ TOCK ] ; 

            SCOOPS
        {
        IFsCRATCH
        ZE( boolT , bPermanentFailure ) ;

        LOGrAW( "------------ deleteRemoteFilesF: REQUEST BODY END -----------------------------\r\n" ) ;
        LOGrAW( postBody ) ;
        LOGrAW( "------------ deleteRemoteFilesF: REQUEST BODY BEGIN -----------------------------\r\n" ) ;

        LOGrAW( "------------ deleteRemoteFilesF: REQUEST HEAD END -----------------------------\r\n" ) ;
        LOGrAW( tSay ) ;
        LOGrAW( "------------ deleteRemoteFilesF: REQUEST HEAD BEGIN -----------------------------\r\n" ) ;

        }
            bHandle.ungrabF( tinP ) ;
            tSay = T("DELETE ")+tUrlCloudAgent+T("/?bulk-delete=yes HTTP/1.1\r\nHost: ")+tHost+T("\r\nX-Auth-Token: ")+cloudInfo.tRackspaceAccessToken+T("\r\nAccept: application/json\r\nContent-Type: text/plain\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;
            cloudInfoS& cloudInfo = *(cloudInfoS*)hCloud.osF( ifcIDtYPEhANDLE_CLOUD ) ;
            bHandle.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        TN( tSay , "" ) ;

        // Content-Length: 1234
        // Content-Type: text/plain
        // X-Auth-Token: f064c46a782c444cb4ba4b6434288f7c
        // Host: storage.clouddrive.com
        // DELETE /v1/MossoCloudFS_0672d7fa-9f85-4a81-a3ab-adb66a880123?bulk-delete=yes HTTP/1.1
        // EXAMPLE

        }
            costBody = postc - postBody ;

            *postc = 0 ; // FOR DEBUGGING CONVENIENCE ; WILL NOT BE SENT TO SERVER
            }
                ether.delF( tinP , poste ) ;
                postc += coste ;
                ether.memCopyF( tinP , postc , poste , coste ) ;

                if( postc + coste > posteBody ) { BLAMMO ; }

                ether.delF( tinP , pstte ) ;
                countT coste = ether.strMakeF( tinP , poste , tSlashContainerSlash+T(pstte)+tcr ) ; ___( poste ) ;
                ZE( osTextT* , poste ) ;

                ether.delF( tinP , psttfn ) ;
                ether.strToUrlF( tinP , pstte , psttfn ) ; ___( pstte ) ;
                ZE( strokeS* , pstte ) ;

                sDoomedFileNamesP >> psttfn ; ___( psttfn ) ;
                ZE( strokeS* , psttfn ) ;

                if( cFiles ++ == CfILESmAXpERbULKdELETE ) break ;
            {
            while( !etPrime && sDoomedFileNamesP )
            ZE( countT , cFiles ) ;

            osTextT* postc = postBody ;
        {
        ZE( countT , costBody ) ;

        //EACH LOOP BUILDS AND EMITS WO BULK DELETION REQUEST
        etherC::etRockIF( tinP ).traceF( tinP , T("deleteRemoteFilesF / building a request [cFiles]: ")+TF2((countT)sDoomedFileNamesP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( !etPrime && !POOP && sDoomedFileNamesP )
    TN( tSlashContainerSlash , "" ) ; tSlashContainerSlash = T("/")+T(psttCloudContainerP)+T("/") ;
    TN( tcr , "\r\n" ) ;

    osTextT* posteBody = postBody + costaBody - 1 ;
    ether.newF( tinP , LF , postBody , costaBody ) ; ___( postBody ) ;
    countT costaBody = CfILESmAXpERbULKdELETE * ( ( COSTcLOUDfILEnAMEmAX << 2 ) + 2 ) + 1 ; // "<< 2" IS WORST CASE ENCODING EXPANSION; "+ 2" IS CRLF, AND "+ 1" IS TERMINATING NULL
    ZE( osTextT* , postBody ) ;

    etherC& etPrime   = etherC::etPrimeIF( tinP ) ;

    _INoLD_

    }
        if( POOP ) return ;
        __Z( sDoomedFileNamesP ) ;
        __Z( psttCloudContainerP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    SCOOP
{
/*1*/voidT cloudC::deleteRemoteFilesF( tinS& tinP , const strokeS* const psttCloudContainerP , soulC& sDoomedFileNamesP )/*1*/

#define CfILESmAXpERbULKdELETE ( 10000 - 1 )
//1 IS SUBTRACTED DEFENSIVELY SO THAT I WILL NOT FAIL IF SERVER ONLY ALLOWS WO LESS THAN THE CLAIMED MAXIMUM NUMBER OF FILES

/**/
*/
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

