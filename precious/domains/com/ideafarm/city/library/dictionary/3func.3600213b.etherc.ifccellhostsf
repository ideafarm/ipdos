
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    __( bFail ) ;
    }
        while( bFail && ( bNoQuit || ( !cTriesP && !etPrime ) || ( cTriesP && -- cTriesP ) ) ) ;
        }
            }
                ++ s ; ( bNoQuit ? (etherC&)*tinP.pEtScratch : etPrime ).osSleepF( tinP , TOCK * 0x10 ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( bFail )

            else       bFail = 0 ;
            if( POOP ) POOPR

            sChat2.writeF( tinP , sOut3 ) ;
            soulC sOut3( tinP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcIDcMDsESSION_BYE ) ;
    
            }
                b_idaLeverP.ungrabF( tinP ) ;
                b_idhLeverP.ungrabF( tinP ) ;
                }
                    }
                        }
                            tblCellsP.newObjectF( tinP , *pNicName ) ;
                            tblCellsP.newObjectF( tinP , idaLeverP   ) ;
                            tblCellsP.newEventF( tinP ) ;
                            stDelete_nicNameC_ptrP << pNicName ;
    
                            swsNicNameP << pNicName2 ;
                            *pNicName2 = *pNicName = idhLeverP ;
                        {
                        if( pNicName && pNicName2 )
                        tinP.pEtScratch->newF( tinP , LF , pNicName2 ) ; ___( pNicName2 ) ;
                        tinP.pEtScratch->newF( tinP , LF , pNicName  ) ; ___( pNicName  ) ;
                        ZE( nicNameC* , pNicName2 ) ;
                        ZE( nicNameC* , pNicName  ) ;
    
                        swsIdAdamP << idaLeverP ;
                        sIn2 >> idaLeverP ;
                        idaLeverP = 0 ;
                    {
                    while( cAdams -- )
    
                    sIn2 >> cAdams ;
                    ZE( countT , cAdams ) ;
    
                    idhLeverP << sIn2 ;
                    idhLeverP = 0 ;
                {
                while( cFlavors -- )
                b_idhLeverP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                b_idaLeverP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
                sIn2 >> cFlavors ;
                ZE( countT , cFlavors ) ;
            {
    
            __( idReply - ifcIDcMDsESSION_QUERYaDAMSrEPLY ) ;
            sIn2 >> idReply ;
            idReply = 0 ;
    
            sChat2.readF( tinP , sIn2 ) ;
            sChat2.writeF( tinP , sOut2 ) ;
            soulC sOut2( tinP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcIDcMDsESSION_QUERYaDAMS ) ;
            soulC sIn2( tinP , TAG( TAGiDnULL ) ) ;
    
            }
                }
                    tblHostsP.newObjectF( tinP , *pStk_pNicName ) ;
                    }
                        }
                            *pStk_pNicName << pNicName ;
                            *pNicName << sIn1 ;
                            *pNicName = 0 ;
                            //(pNicName WILL BE DELETED WHEN pStk_pNicName IS DELETED) stDelete_nicNameC_ptrP << pNicName ;
                        {
                        if( pNicName )
                        tinP.pEtScratch->newF( tinP , LF , pNicName ) ; ___( pNicName ) ;
                        ZE( nicNameC* , pNicName ) ;
                    {
                    while( cNicName -- )
                    sIn1 >> cNicName ;
                    ZE( countT , cNicName ) ;
    
                    tblHostsP.newObjectF( tinP , *pNicNameRegistrand     ) ;
                    tblHostsP.newObjectF( tinP , psttOldCommentUsedByIFC   ) ; stDelete_strokeS_ptrP << psttOldCommentUsedByIFC   ;
                    tblHostsP.newObjectF( tinP , psttOldCommentUsedByOwner ) ; stDelete_strokeS_ptrP << psttOldCommentUsedByOwner ;
                    tblHostsP.newObjectF( tinP , psttNameUsedByInternet ) ; stDelete_strokeS_ptrP << psttNameUsedByInternet ;
                    tblHostsP.newObjectF( tinP , psttNameUsedByIFC      ) ; stDelete_strokeS_ptrP << psttNameUsedByIFC      ;
                    tblHostsP.newObjectF( tinP , psttNameUsedByOwner    ) ; stDelete_strokeS_ptrP << psttNameUsedByOwner    ;
                    tblHostsP.newObjectF( tinP , psttEmailOwner         ) ; stDelete_strokeS_ptrP << psttEmailOwner         ;
                    tblHostsP.newObjectF( tinP , idComputer             ) ;
                    tblHostsP.newEventF( tinP ) ;
    
                    *pNicNameRegistrand << sIn1    ;
                    sIn1 >> psttOldCommentUsedByIFC   ; ___( psttOldCommentUsedByIFC   ) ;
                    sIn1 >> psttOldCommentUsedByOwner ; ___( psttOldCommentUsedByOwner ) ;
                    sIn1 >> psttNameUsedByInternet ; ___( psttNameUsedByInternet ) ;
                    sIn1 >> psttNameUsedByIFC      ; ___( psttNameUsedByIFC      ) ;
                    sIn1 >> psttNameUsedByOwner    ; ___( psttNameUsedByOwner    ) ;
                    sIn1 >> psttEmailOwner         ; ___( psttEmailOwner         ) ;
                    sIn1 >> idComputer             ;
    
                    ZE( strokeS* , psttOldCommentUsedByIFC   ) ;
                    ZE( strokeS* , psttOldCommentUsedByOwner ) ;
                    ZE( strokeS* , psttNameUsedByInternet ) ;
                    ZE( strokeS* , psttNameUsedByIFC      ) ;
                    ZE( strokeS* , psttNameUsedByOwner    ) ;
                    ZE( strokeS* , psttEmailOwner         ) ;
                    ZE( countT   , idComputer             ) ;
    
                    *pNicNameRegistrand = 0 ;
                    stDelete_stackC_ptrP << (countT)pStk_pNicName ;
                    stDelete_nicNameC_ptrP << pNicNameRegistrand ;
                {
                if( pNicNameRegistrand && pStk_pNicName )
    
                stackC* pStk_pNicName = new( 0 , tinP , LF ) stackC( tinP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_nicNameC ) ; ___( pStk_pNicName ) ;
                tinP.pEtScratch->newF( tinP , LF , pNicNameRegistrand ) ; ___( pNicNameRegistrand ) ;
                ZE( nicNameC* , pNicNameRegistrand ) ;
            {
            while( cHosts -- )
    
            sIn1 >> cHosts ;
            ZE( countT , cHosts ) ;
    
            __( idReply - ifcIDcMDsESSION_QUERYnICnAMErEPLY ) ;
            sIn1 >> idReply ;
            ZE( countT , idReply ) ;
    
            sChat2.readF( tinP , sIn1 ) ;
            sChat2.writeF( tinP , sOut1 ) ;
            soulC sOut1( tinP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcIDcMDsESSION_QUERYnICnAME ) ;
            soulC sIn1( tinP , TAG( TAGiDnULL ) ) ;
    
            sChat2.connectF( tinP , idPort2 , idhIfc ) ;
            socketC sChat2( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
    
            }
                souli >> idPort2 ;
                __( idReply - ifcIDcMDsESSION_NEWsOCKETrEPLY ) ;
                souli >> idReply ;
                ZE( countT , idReply ) ;
                sChat.readF( tinP , souli ) ;
                soulC souli( tinP , TAG( TAGiDnULL ) ) ;
    
                sChat.writeF( tinP , soulo ) ;
                soulC soulo( tinP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcIDcMDsESSION_NEWsOCKET ) ;
    
                sChat.connectF( tinP , ifcPORToLD2_CHAT , idhIfc ) ;
                socketC sChat( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
            {
            ZE( countT , idPort2 ) ;
            nicNameC idhIfc = socketC::nicNameIF( tinP , *tinP.pEtScratch , T(WWWiDEAFARMcOM) ) ;
    
            ZE( boolT , bOk ) ;
        {
        do
        SCOOPS
    {
    IFsCRATCH
    boolT bFail = 1 ;
    boolT bNoQuit = cTriesP == - 1 ;
    etherC& etPrime = etPrimeIF( tinP ) ;

    tblHostsP.newColF( tinP , T("nicNameAll") ) ;
    tblHostsP.newColF( tinP , T("nicNameRegistrand") ) ;
    tblHostsP.newColF( tinP , T("commentUsedByIFC") ) ;
    tblHostsP.newColF( tinP , T("commentUsedByOwner") ) ;
    tblHostsP.newColF( tinP , T("nameUsedByInternet") ) ;
    tblHostsP.newColF( tinP , T("nameUsedByIFC") ) ;
    tblHostsP.newColF( tinP , T("nameUsedByOwner") ) ;
    tblHostsP.newColF( tinP , T("emailOwner") ) ;
    tblHostsP.newColF( tinP , T("idComputer") ) ;

    tblCellsP.newColF( tinP , T("nicName") ) ;
    tblCellsP.newColF( tinP , T("idAdam") ) ;

    _INoLD_

    }
        if( POOP ) return ;
        //U: VERIFY THAT IS IN INITIAL PHASE AND THAT NO COLS HAVE YET BEEN DEFINED
        __( tblHostsP.cRowsF( tinP ) ) ;
        __( tblCellsP.cRowsF( tinP ) ) ;
        __( stDelete_nicNameC_ptrP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_nicNameC ) ;
        __( stDelete_strokeS_ptrP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_strokeS ) ;
        __( swsIdAdamP.cFlavorsF( tinP ) ) ;
        __( swsIdAdamP.idTypeF( tinP ) - ifcSTACKtYPE_countT ) ;
        __( swsNicNameP.cFlavorsF( tinP ) ) ;
        __( swsNicNameP.idTypeF( tinP ) - ifcSTACKtYPE_PTR_nicNameC ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::ifcCellHostsF( tinS& tinP , switchStackC& swsNicNameP , countT& idaLeverP , batonC& b_idaLeverP , switchStackC& swsIdAdamP , nicNameC& idhLeverP , batonC& b_idhLeverP , tableC& tblCellsP , tableC& tblHostsP , stackC& stDelete_strokeS_ptrP , stackC& stDelete_nicNameC_ptrP , stackC& stDelete_stackC_ptrP , countT cTriesP )/*1*/

/**/
*/
  if > 0 then i will retry this many times and impotence will -not- occur if i cannot get the information
  if -1 then will retry forever even after asynch impotence occurs
  if 0 then will retry forever until asynch impotence occurs
  can be 0
 cTriesP
  must be explicitly purged by calling DEL( pStack ) for each value
 stDelete_stackC_ptrP
  need not be explicitly purged
  must not be destructed before tblHostsP
 stDelete_nicNameC_ptrP
  need not be explicitly purged
  must not be destructed before tblHostsP
 stDelete_strokeS_ptrP
  must be empty
  columns must not yet be defined
  recommended internal name: T("hosts")
 tblHostsP
  must be empty
  columns must not yet be defined
  recommended internal name: T("cells")
 tblCellsP
 b_idhLeverP
 idhLeverP
  must use an nicNameC lever
  must be of type ifcSTACKtYPE_countT
  must be empty
 swsIdAdamP
 b_idaLeverP
 idaLeverP
  must use a countT idAdam lever
  must be of type ifcSTACKtYPE_PTR_nicNameC
  must be empty
 swsNicNameP
 tinP
  | 
  | }
  |     DEL( pStk ) ;
  |     stDelete_stackC_ptr >> pStk ;
  |     ZE( stackC* , pStk ) ;
  | {
  | while( stDelete_stackC_ptr )
  | 
  | !tblHosts ;
  | !tblCells ;
  | 
  | etThread.ifcCellHostsF( tinP , swsNicName , idaLever , b_idaLever , swsIdAdam , idhLever , b_idhLever , tblCells , tblHosts , stDelete_strokeS_ptr , stDelete_nicNameC_ptr , stDelete_stackC_ptr ) ;
  | 
  | stackC stDelete_stackC_ptr(  tinP , etThread , TAG( TAGiDnULL ) ) ;
  | stackC stDelete_nicNameC_ptr( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_nicNameC ) ;
  | stackC stDelete_strokeS_ptr( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
  | 
  | tableC tblHosts( tinP , etThread , T("hosts") ) ;
  | tableC tblCells( tinP , etThread , T("cells") ) ;
  | 
  | switchStackC swsIdAdam( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idhLever ) ;
  | batonC b_idhLever( tinP , TAG( TAGiDnULL ) ) ;
  | nicNameC idhLever ;
  | 
  | switchStackC swsNicName( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idaLever , ifcSTACKtYPE_PTR_nicNameC ) ;
  | batonC b_idaLever( tinP , TAG( TAGiDnULL ) ) ;
  | ZE( countT , idaLever ) ;
  | 
   the only part that is not required is the 2 "!tbl" lines, which log the contents of the tables
  most of this snippet is required
 cut and paste code snippet
arguments
\<A HREF=\"5.103017c.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$ifcCellHostsF.0.html\"\>instances\</A\>
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

