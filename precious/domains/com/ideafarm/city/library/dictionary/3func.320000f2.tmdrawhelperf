
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmDrawHelperF )
dec02AM( tinP.pAdamGlobal1->_deviceC_cHelper ) ;
}
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;

    }
        }
            stJob.ungrabF( tinP ) ;
            }
                _OUT_
                stJob.grabF( tinP , TAG( TAGiDnULL ) ) ;

                if( cPendingWas == 1 && job.pSgnAllDone ) job.pSgnAllDone->giveF( tinP ) ;
                countT cPendingWas = decv02AM( *job.pcPending ) ;

                grabHelper.ungrabF( tinP ) ;
                etThread.osThreadSwitchingDesireF( tinP , idDesireSave ) ;
                }
                    BOS( WHATgbd , BOSoK , DeleteObject( oshPen ) )
                    BOS( WHATgbd , BOSoK , SelectObject( deviceP.oshDeviceMemoryF() , oshPenWas ) )
                    BOS( WHATgbd , BOSoK , PolyPolyline( deviceP.oshDeviceMemoryF() , pPel->pPoint , (DWORD*)pPel->pcSize , pPel->cGlyph ) )
                    HPEN oshPenWas = (HPEN)tinP.brcRaw ;
                    BOS( WHATgbd , BOSoK , SelectObject( deviceP.oshDeviceMemoryF() , oshPen ) )
                    HPEN oshPen = (HPEN)tinP.brcRaw ;
                    BOS( WHATgbd , BOSoK , CreatePen( PS_SOLID , 1 , pPel->rgbOverride ? pPel->rgbOverride : job.rgb ) )
                {
                countT idDesireSave = etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
                grabHelper.grabF( tinP , TAG( TAGiDnULL ) ) ;

                while( bFail ) ;
                }
                    _OUT_
                    }
                        _OUT_
                        cPointMax = cPointMaxSave ;
                        }
                            FEGeND

                                FEPeND

                                    offpi ++ ;

                                    }
                                        offReflect = 0 ;
                                    
                                        }
                                            }
                                                pPel->pPoint[ offpo ++ ] = pPel->pPoint[ offpoLath ] ;
                                                pPel->pcSize[ offgo    ] ++ ;
                                                offgo ++ ;
                                                FEPfAILbREAKiF
                                            {
                                            if( offp != cpin - 1 )

                                            if( bFail ) break ;                                    
                                            }
                                                pPel->pPoint[ offpo ++ ].y =                       pPel->pPoint[ offpr ++ ].y ;
                                                pPel->pPoint[ offpo    ].x = deviceP.cColF() - 1 - pPel->pPoint[ offpr    ].x ;
                                                pPel->pcSize[ offgo    ] ++ ;
                                                FEPfAILbREAKiF
                                            {
                                            while( cReflect && cReflect -- )
                                            countT offpr = offpo - cReflect - offReflect ;
                                    
                                            offgo ++ ;
                                        {
                                        else
                                        }
                                            if( offp == cpin - 1 ) cOmittedMoves ++ ;
                                    
                                                            cReflect = 0 ;
                                            cReflections += cReflect ;
                                            cBehindSnips ++ ;
                                        {
                                        if( !offPassout )
                                    
                                        countT offpoLath = offpo - 1 ;
                                    {
                                    if( cReflect )

                                    }
                                        bLeftLag = bLeft ;

                                        pPel->pPoint[ offpo ++ ].y = deviceP.cRowF() - 1 - offRow ;
                                        pPel->pPoint[ offpo    ].x =                       offCol ;
                                        pPel->pcSize[ offgo    ] ++ ;
                                        FEPfAILbREAKiF

                                        countT offRow = R( ( PI / 2.0 + pDirection[ offpi ].aElevation ) / PI           * (measureT)( deviceP.cRowF() - 1 ) )  ;
                                        countT offCol = R( ( PI       + pDirection[ offpi ].aHeading   ) / ( 2.0 * PI ) * (measureT)( deviceP.cColF() - 1 ) )  ;

                                        }
                                            if( bLeft ) pDirection[ offpi ].aHeading = - PI ;

                                            ;
                                                : bLeftLag
                                                ? !!( F(pfin[offgi]) & flTAIL_LEFT )
                                            bLeft = !offp && bClosed
                                        {
                                        if( pDirection[ offpi ].aHeading == PI )

                                        boolT bLeft = ppin[ offpi ].x < 0.0 ;
                                    {
                                    else
                                    }
                                        }
                                            else if( ppin[ offpi ].x > 0.0 ) pfin[offgi] &= ~( F(flTAIL_LEFT) ) ;
                                                 if( ppin[ offpi ].x < 0.0 ) pfin[offgi] |=      flTAIL_LEFT    ;
                                        {
                                        if( bClosed )
                                    {
                                    if( !offPassout )

                                    }
                                        }
                                            }
                                                           cRun = 0 ;
                                                cReflect = cRun ;
                                                offReflect = 1 ;
                                            {
                                            if( cRun > 1 )
                                        {
                                        else
                                        }
                                            if( offp == cpin - 1 && cRun > 1 ) cReflect = cRun ;
                                            cRun ++ ;
                                        {
                                        if( !ppin[ offpi ].x && ppin[ offpi ].z < 0.0 )
                                    {

                                FEP

                                ZE( boolT , bLeftLag ) ;
                                const boolT  bClosed = F(pfin[offgi]) & flTAIL_SET ;
                                const countT offpiWoth = offpi ;
                                ZE( countT , offReflect ) ;
                                ZE( countT , cReflect ) ;
                                ZE( countT , cRun ) ;

                                if( offPassout ) pPel->pcSize[ offgo ] = 0 ;

                            FEG

                            }
                                cOmittedMoves = cReflections = cBehindSnips = 0 ;
                                pPel->rgbOverride = pSpace->rgbOverride ;
                                new( 0 , tinP , (byteT*)pPel , sizeof( pelS ) ) pelS( tinP , cGlyph , cPointMax ) ;

                                cPointMax = cpOutLath + cReflections + cBehindSnips - cOmittedMoves ;
                                countT cGlyph = cgin + ( cBehindSnips << 1 ) - cOmittedMoves ;
                            {
                            if( offPassout )
                        {
                        for( countT offPassout = 0 ; offPassout <= 1 ; offPassout ++ )
                        cPointMax = 0 ;
                        countT cPointMaxSave = cPointMax ;
                        ZE( countT , cOmittedMoves  ) ;
                        ZE( countT , cReflections ) ;
                        ZE( countT , cBehindSnips ) ; // LONELY x=0 POINTS ARE NOT COUNTED ; THERE SHOULD NOT BE ANY OF THOSE ; IF ANY EXIST, THEY WILL NOT BE REFLECTED

                        //LOGiN( "emit  " )

                        SETiNoUTfRAME
                        _INoLD_
                    {                                                                           // EMIT

                    }
                        _OUT_
                        }
                            cpOutLath = offpo ;

                            FEGeND

                                FEPeND

                                    }
                                        if( bFail ) break ;
                                        }
                                            }
                                                ppout[ offpo ++ ] = pPoint3[ offe ] ;
                                                psout[ offgo ] ++ ;
                                                FEPfAILbREAKiF
                                                pDirection[ offpo ] = pDir[ offe ] ;
                                            {
                                            if( pbUse[ offe ] )
                                        {
                                        for( countT offe = 1 ; offe < sizeof pPoint3 / sizeof pPoint3[ 0 ] ; offe ++ ) // THE ZE'TH ELEMENT IS LAGGED OUTPUT SO IS NEVER CHECKED HERE
                                    
                                        }
                                            }
                                                else                                     pbUse[ offm ] = 1 ;
                                                if( error <= deviceP.surfaceErrorLimit ) break ;

                                                //LOGrAW( T("smoothie test [thresh,error]: ")+TFF(deviceP.surfaceErrorLimit)+T(" ")+TFF(error)+T("\r\n") ) ;
                                    
                                                measureT error   = mErrorx * mErrorx + mErrory * mErrory ;
                                                measureT mErrory = cError.y ;
                                                measureT mErrorx = cError.x ;
                                        
                                                cError.y = pcamb[ 1 ].y - ce.y ;
                                                cError.x = pcamb[ 1 ].x - ce.x ;
                                                cPoint2S cError ;
                                        
                                                ce.y = R( 0.5 * pcamb[ 0 ].x + 0.5 * pcamb[ 2 ].y ) ;
                                                ce.x = R( 0.5 * pcamb[ 0 ].x + 0.5 * pcamb[ 2 ].x ) ;
                                                cPoint2S ce ;
                                            {
                                            if( !bFail )

                                            }
                                                }
                                                    out.y = deviceP.cRowF() - 1 - offRow ;
                                                    out.x =                       offCol ;

                                                    countT offRow = R( ( PI / 2.0 + aElevation ) / PI           * (measureT)( deviceP.cRowF() - 1 ) )  ;
                                                    countT offCol = R( ( PI       + aHeading   ) / ( 2.0 * PI ) * (measureT)( deviceP.cColF() - 1 ) )  ;
                                                {
                                                if( !bFail )

                                                }
                                                    bFail |= pSpacec->pEye->directionF( tinP , aHeading , aElevation , vEye ) ;
                                                    aElevation = aHeading = 0 ;

                                                    vEye( 3 ) = in.z ;
                                                    vEye( 2 ) = in.y ;
                                                    vEye( 1 ) = in.x ;
                                                    vectorOldC vEye( tinP , etThread ) ;

                                                    mPoint3S& in  = pPoint3[ poff[ o012 ] ] ;

                                                    pbDir[ poff[ o012 ] ] = 1 ;
                                                {
                                                if( !pbDir[ poff[ o012 ] ] )
                                                measureT& aElevation = pDir[ poff[ o012 ] ].aElevation ;
                                                measureT& aHeading   = pDir[ poff[ o012 ] ].aHeading   ;

                                                cPoint2S& out = pcamb[ o012 ] ;
                                            {
                                            for( countT o012 = 0 ; o012 <= 2 ; o012 ++ )
                                            ZE( boolT , bFail ) ;
                                            cPoint2S pcamb[ 3 ] ;
                                        
                                            countT poff[ 3 ] = { offa , offm , offb } ;
                                        
                                            pPoint3[ offm ] = ( pPoint3[ offa ] + pPoint3[ offb ] ) / 2.0 ;

                                            countT offm = ( offb + offa ) >> 1 ;
                                            countT offb = pcob[ oo ] ;
                                            countT offa = pcoa[ oo ] ;
                                        {
                                        for( countT oo = 0 ; oo < sizeof pcoa / sizeof pcoa[ 0 ] ; oo ++ )
                                    
                                        #endif

                                            countT pcob[] = { 8 , 4 , 8 , 2 , 4 , 6 , 8 } ; //ALL SPREADS pcob[ oo ] - pcoa[ oo ] MUST BE EVEN
                                            countT pcoa[] = { 0 , 0 , 4 , 0 , 2 , 4 , 6 } ;

                                            BOSdOnOTtEST( WHATgbo , memset( pbDir , 0 , sizeof pbDir ) )
                                            boolT pbDir[ 9 ] ;

                                            directionS pDir[ 9 ] ;
                                    
                                            pPoint3[ 8 ] = ppin[ offpi ++  ] ;
                                            pPoint3[ 0 ] = ppin[ offpi - 1 ] ;
                                            mPoint3S pPoint3[ 9 ] ;
                                        
                                            pbUse[ 8 ] = 1 ;
                                            BOSdOnOTtEST( WHATgbo , memset( pbUse + 1 , 0 , sizeof pbUse - 2 * sizeof( boolT ) ) )
                                            boolT pbUse[ 9 ] ; //7 CANDIDATE POINTS PLUS THE OO ENDPOINTS

                                        #else

                                            countT pcob[] = { 2 } ; //ALL SPREADS pcob[ oo ] - pcoa[ oo ] MUST BE EVEN
                                            countT pcoa[] = { 0 } ;

                                            BOSdOnOTtEST( WHATgbo , memset( pbDir , 0 , sizeof pbDir ) )
                                            boolT pbDir[ 3 ] ;

                                            directionS pDir[ 3 ] ;
                                    
                                            pPoint3[ 2 ] = ppin[ offpi ++  ] ;
                                            pPoint3[ 0 ] = ppin[ offpi - 1 ] ;
                                            mPoint3S pPoint3[ 3 ] ;
                                        
                                            pbUse[ 2 ] = 1 ;
                                            BOSdOnOTtEST( WHATgbo , memset( pbUse + 1 , 0 , sizeof pbUse - 2 * sizeof( boolT ) ) )
                                            boolT pbUse[ 3 ] ; //1 CANDIDATE POINTS PLUS THE OO ENDPOINTS

                                        #if defined( ROUGH )
                                    {
                                    else
                                    }
                                        ppout[ offpo ++ ] = ppin[ offpi ++ ] ;
                                        psout[ offgo ] ++ ;
                                        FEPfAILbREAKiF

                                        }
                                            eye.directionF( tinP , pDirection[ offpo ].aHeading , pDirection[ offpo ].aElevation , vNow , flEYEdIRECTION_null ) ;
                                            pDirection[ offpo ].aElevation = 0.0 ;
                                            pDirection[ offpo ].aHeading   = 0.0 ;

                                            vNow( 3 ) = ppin[ offpi ].z ;
                                            vNow( 2 ) = ppin[ offpi ].y ;
                                            vNow( 1 ) = ppin[ offpi ].x ;
                                            vectorOldC vNow( tinP , etThread ) ;
                                        {   // THE NEXT PHASE WILL EXPECT pDirection[ offpo ] TO BE SET FOR ALL POINTS INCLUDING THE ZE'TH POINT OF EACH GLYPH
                                        //DUPLICATE CODE: 320000f2 320000f2
                                    {
                                    if( !offp )

                                FEP
                        
                            FEG
                        {
                        else
                        }
                            cpOutLath = offpo ;

                            FEGeND

                                FEPeND

                                    ppout[ offpo ++ ] = ppin[ offpi ++ ] ;
                                    psout[ offgo ] ++ ;
                                    FEPfAILbREAKiF

                                    }
                                        eye.directionF( tinP , pDirection[ offpo ].aHeading , pDirection[ offpo ].aElevation , vNow , flEYEdIRECTION_null ) ;
                                        pDirection[ offpo ].aElevation = 0.0 ;
                                        pDirection[ offpo ].aHeading   = 0.0 ;

                                        vNow( 3 ) = ppin[ offpi ].z ;
                                        vNow( 2 ) = ppin[ offpi ].y ;
                                        vNow( 1 ) = ppin[ offpi ].x ;
                                        vectorOldC vNow( tinP , etThread ) ;
                                    {   // THE NEXT PHASE WILL EXPECT pDirection[ offpo ] TO BE SET FOR ALL POINTS INCLUDING THE ZE'TH POINT OF EACH GLYPH
                                    //DUPLICATE CODE: 320000f2 320000f2

                                FEP

                            FEG
                        {
                        if( F(deviceP.flagsF()) & flDEVICEc_NOsMOOTHIES )
                    
                        //LOGiN( "smooth" )

                        SETiNoUTfRAME
                        _INoLD_
                    {                                                                           // INSERT SMOOTHIES
                    ZE( countT , cpOutLath ) ;

                    }
                        _OUT_
                        FEGeND

                            FEPeND

                                offpi ++ ;
                                vLag = vNow ;
                                aHeadingLag = aHeading ;

                                }
                                    }
                                        ppout[ offpo ++ ].z = vTmp( 3 ) ;
                                        ppout[ offpo    ].y = vTmp( 2 ) ;
                                        ppout[ offpo    ].x = vTmp( 1 ) ;
                                        psout[ offgo    ] ++ ;
                                        FEPfAILbREAKiF
                                
                                        }
                                            eye.directionF( tinP , aHeading , aElevation , vTmp , vNext , flEYEdIRECTION_SNAPhEADINGtOpI ) ; // TWEAK TMP TOWARD NEXT
                                            aElevation = aHeading = 0.0 ;
                                        {
                                        if( ahNow != PI || vNext( 1 ) )  // IF NOW IS NOT DIRECTLY BEHIND OR LAG IS NOT DIRECTLY BEHIND
                                        vTmp = vNow ;
                                
                                        vNext( 3 ) = ppin[ offpiNext ].z ;
                                        vNext( 2 ) = ppin[ offpiNext ].y ;
                                        vNext( 1 ) = ppin[ offpiNext ].x ;
                                        const countT offpiNext = offpi + 1 ;
                                        vectorOldC vNext( tinP , etThread ) ;
                    
                                        }            
                                            }            
                                                pfout[ offgo ] = flTAIL_null ;
                                                psout[ offgo ] = 0 ;
                                                offgo ++ ;                          // SPLIT THE GLYPH INTO OO GLYPHS
                                            {
                                            if( psout[ offgo ] && aeNow != halfpi && aeNow != - halfpi ) // IF NOT WOTH POINT AND NOT DIRECTLY ABOVE OR BELOW ME
                                            measureT halfpi = PI / 2.0 ;
                                        {
                                    {
                                    if( offp != cpin - 1 ) // FOR CLOSED GLYPHS, TWEAKING NEXT HERE WOULD RESULT IN "DOUBLE COUNTING" ERASURE SO IS NOT DONE
                                
                                    }
                                        ppout[ offpo ++ ].z = vTmp( 3 ) ;
                                        ppout[ offpo    ].y = vTmp( 2 ) ;
                                        ppout[ offpo    ].x = vTmp( 1 ) ;
                                        psout[ offgo    ] ++ ;
                                        FEPfAILbREAKiF
                            
                                        }
                                            eye.directionF( tinP , aHeading , aElevation , vTmp , vLag , flEYEdIRECTION_SNAPhEADINGtOpI ) ; // TWEAK TMP TOWARD LAG
                                            aElevation = aHeading = 0.0 ;
                                        {
                                        if( ahNow != PI || vLag( 1 ) )  // IF NOW IS NOT DIRECTLY BEHIND OR LAG IS NOT DIRECTLY BEHIND    U::BUG: THE CODE DOES NOT EXACTLY DO THIS BECAUSE IT DOES NOT TEST vLag( 3 ) < 0
                                        vTmp = vNow ;
                                    {
                                    if( offp )

                                    measureT aeNow = aElevation ; //ADDED 20121023@1626 TO ELIMINATE SUSPECTED BUG
                                    measureT ahNow = aHeading ;   //ADDED 20121023@1626 TO ELIMINATE SUSPECTED BUG

                                    //U::BUG: ZE'TH POINT FAILS IN A GLYPH OF EXACTLY 2 POINTS; IN A GLYPH OF MORE THAN 2 POINTS
                                {
                                else
                                }
                                    ppout[ offpo ++ ].z = vNow( 3 ) ;
                                    ppout[ offpo    ].y = vNow( 2 ) ;
                                    ppout[ offpo    ].x = vNow( 1 ) ;
                                    psout[ offgo ] ++ ;
                                    FEPfAILbREAKiF
                                {
                                if( !eye.directionF( tinP , aHeading , aElevation , vNow , flEYEdIRECTION_SNAPhEADINGtOpI ) )
                                aElevation = aHeading = 0.0 ;
                                measureT& aElevation = pDirection[ offpo ].aElevation ;
                                measureT& aHeading   = pDirection[ offpo ].aHeading ;

                                vNow( 3 ) = ppin[ offpi ].z ;
                                vNow( 2 ) = ppin[ offpi ].y ;
                                vNow( 1 ) = ppin[ offpi ].x ;
                                vectorOldC vNow( tinP , etThread ) ; // "now":"the input point being handled" ; "lag":"the preceding input point" ; "next":"the next input point"

                            FEP

                            ZE( measureT , aHeadingLag ) ;

                            }
                                vLag( 3 ) = ptin[ offgi ].z ;
                                vLag( 2 ) = ptin[ offgi ].y ;
                                vLag( 1 ) = ptin[ offgi ].x ;
                            {
                            if( bClosed )

                            const boolT  bClosed   = F(pfin[offgi]) & flTAIL_SET ;
                            const countT offpiWoth = offpi ;

                        FEG

                        vectorOldC vTmp( tinP , etThread ) ;
                        vectorOldC vLag( tinP , etThread ) ;

                        //LOGiN( "tweak " )

                        SETiNoUTfRAME
                        _INoLD_
                    {                                                                           // TWEAK: REPLACE AN "DIRECTION EXCEPTION" POINT WITH A PAIR OF NEARBY POINTS

                    }
                        _OUT_
                        if( cgin ) ;

                        popParmsAM( cbp ) ;

                        bFail = insertX0PointAM( cPointMax ) ;

                        }
                            countT foo = 2 ;
                        {
                        if( idJob == 2 )

                        pushParmsAM( (countT*)&iop , cbp ) ;
                        countT cbp = sizeof iop / sizeof( countT ) ;
                        iopS iop( cgin , psin , ppin , cgout , psout , ppout ) ;

                        }
                            if( F(pfout[offgi]) & flTAIL_SET ) ptout[ offgi ] = ptin[ offgi ] ;

                            pfout[ offgi ] = pfin[ offgi ] ;
                            psout[ offgi ] = psin[ offgi ] ;
                        {
                        for( countT offgi = 0 ; offgi < cgin ; offgi ++ )
                        cgout = cgin ;

                        SETiNoUTfRAME
                        _INoLD_
                    {                                                                           // INSERT BEHIND POINTS AND ABOVE BELOW COINCIDE POINTS

                    }
                        if( pmB ) ;

                        mA.mulF( mB ) ;
                        matrix3C mA( (measureT*)ppin , cPinOriginal , (measureT*)ppout ) ;

                        }
                            }
                                mA.mulF( mB ) ;
                                matrix3C mA( (measureT*)( ptin + offgi ) , 1 , (measureT*)( ptout + offgi ) ) ;
                            {
                            if( F(pfout[offgi]) & flTAIL_SET )

                            pfout[ offgi ] = pfin[ offgi ] ;
                            cPinOriginal += psout[ offgi ] = psin[ offgi ] ;
                        {
                        for( countT offgi = 0 ; offgi < cgin ; offgi ++ )
                        cgout = cgin ;

                        matrix3C mB( (measureT*)pmB , 3 ) ;
                        const measureT* pmB = eye ;

                        SETiNoUTfRAME
                    {                                                                           // WORLD COORDINATES TO EYE COORDINATES
                    ZE( countT , cPinOriginal ) ;

                    directionS* pDirection  = (directionS*)(const byteT*)aTmp9 ;

                    mPoint3S* ppPoint[]     = {           pSpace->pPoint     , (mPoint3S*)(const byteT*)aTmp4 , (mPoint3S*)(const byteT*)aTmp8 } ;
                    mPoint3S* ppPointTail[] = {           pSpace->pPointTail , (mPoint3S*)(const byteT*)aTmp3 , (mPoint3S*)(const byteT*)aTmp7 } ;
                    flagsT*   pFlagsTail[]  = {           pSpace->pFlagsTail ,   (countT*)(const byteT*)aTmp2 ,   (countT*)(const byteT*)aTmp6 } ;
                    countT*   ppcSize[]     = {           pSpace->pcSize     ,   (countT*)(const byteT*)aTmp1 ,   (countT*)(const byteT*)aTmp5 } ;
                    countT*   ppcGlyph[]    = { (countT*)&pSpace->cGlyph     ,                    &cGlyphScr1 ,                    &cGlyphScr2 } ;
                    ZE( countT , offd ) ; //"d":"dataset"

                    ZE( countT , cGlyphScr2  ) ;
                    ZE( countT , cGlyphScr1 ) ;

                    }
                        cPointMax = aTmp1.ceaF() - 1 ; // "- 1": TO ALLOW UP TO 2 POINTS TO BE OUTPUTTED BETWEEN CHECKS (USED BY TWEAKING AND BY INSERTION OF BEHIND AND ABOVEbELOW POINTS
                        bFreshenMaxPoints = 0 ;        //THE ASSUMPTION IS MADE HERE THAT ALL TMP ARRAYS ARE ALWAYS TWEAKED TO THE SAME CAPACITY
                    {
                    if( bFreshenMaxPoints )

                    }
                        _OUT_
                        bFreshenMaxPoints = 1 ;

                        aTmp9[ cea ] ;
                        aTmp8[ cea ] ;
                        aTmp7[ cea ] ;
                        aTmp6[ cea ] ;
                        aTmp5[ cea ] ;
                        aTmp4[ cea ] ;
                        aTmp3[ cea ] ;
                        aTmp2[ cea ] ;
                        aTmp1[ cea ] ; //THE ASSUMPTION IS FULFILLED HERE THAT ALL TMP ARRAYS ARE ALWAYS TWEAKED TO THE SAME CAPACITY
                        cea <<= 1 ;

                        bFail = 0 ;
                        _INoLD_
                    {
                    if( bFail )
                    idTry ++ ;
                    _INoLD_
                {
                do
                ZE( countT , idTry ) ; //U::TO FIND A BUG
                ZE( boolT , bFail ) ;

                const countT cRow = deviceP.cRowF() ;
                const countT cCol = deviceP.cColF() ;

                eyeC& eye = *pSpacec->pEye ;

                pelS*         pPel    = job.pPel    ;
                const spaceS* pSpace  = job.pSpace  ;
                const spaceC* pSpacec = job.pSpacec ;

                //LOGrAW( "tmDrawHelperF / job received\r\n" ) ;

                idJob ++ ;
                stJob.ungrabF( tinP ) ;
                }
                    stJob >> pbJob ;
                    byteT* pbJob = (byteT*)&job ;
                {
                drawJobS job ;
                _INoLD_
            {
            while( stJob )
            stJob.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        else
        if( F(tinP.pAdamGlobal1->_deviceC_flagsHelper) & flDEVICEchELPER_QUIT ) break ;

        stJob.waitF( tinP ) ;
    {
    for(;;)
    ZE( countT , idJob ) ; //U::TO FIND A BUG
    ZE( countT , cPointMax ) ;
    boolT bFreshenMaxPoints = 1 ;

    grabC& grabHelper = tinP.pAdamGlobal5->_deviceC_grabHelper ;

    // I USE grabHelper TO SERIALIZE MY PROCESSING OF JOBS AS NEEDED (E.G. WHEN ACTUALLY WRITING TO THE DEVICE)
    // I ASSUME THAT deviceP IS GRABBED BY THE THREAD THAT IS PUSHING JOBS

    arrayC aTmp9( tinP , sizeof( directionS ) , cea ) ;
    arrayC aTmp8( tinP , sizeof( mPoint3S   ) , cea ) ;
    arrayC aTmp7( tinP , sizeof( mPoint3S   ) , cea ) ;
    arrayC aTmp6( tinP , sizeof( mPoint3S   ) , cea ) ;
    arrayC aTmp5( tinP , sizeof( mPoint3S   ) , cea ) ;
    arrayC aTmp4( tinP , sizeof( mPoint3S   ) , cea ) ;
    arrayC aTmp3( tinP , sizeof( mPoint3S   ) , cea ) ;
    arrayC aTmp2( tinP , sizeof( mPoint3S   ) , cea ) ;
    arrayC aTmp1( tinP , sizeof( mPoint3S   ) , cea ) ; //A:ASSUME: CODE ASSUMES THAT ALL OF THESE ARRAYS ARE ALWAYS KEPT AT THE SAME CAPACITY cea ; THIS IS NOT ENFORCED
    countT cea = TUCK << 4 ;

    stackC& stJob = *tinP.pAdamGlobal1->_deviceC_pStkJob ;
    deviceC& deviceP = *(deviceC*)pTaskP->c1 ;

    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
{
if( pTaskP && pTaskP->c1 )
etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
/*1*/TASK( tmDrawHelperF )/*1*/

//#define ROUGH

/**/

*/
i complete each "job" as soon as it is placed onto my job stack
i draw polylines onto memory device contexts
 the number of instances of me is a function of the number of cpu's
 instances of me exist iff wo or more instances of deviceC exist
the deviceC class constructor launches me
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

