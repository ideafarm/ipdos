
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tinP , T("ok") ) ;
WAITuNTILaLMOSTaLONE( 1 )
etThread.traceF( tinP , T("waiting for all threads to finish") ) ;

}
    etThread.osThreadF( TaRG1( tmWorkerF ) , (countT)pptRoot[ offt ] , (countT)pcArgInner ) ;
{
for( countT offt = 0 ; offt < cRoot ; offt ++ )

}
    case IDcOMPUTER_FACTORY9 : { cRoot = 7 ; pptRoot[ 0 ] = &tFactory9Root1 ; pptRoot[ 1 ] = &tFactory9Root2 ; pptRoot[ 2 ] = &tFactory9Root3 ; pptRoot[ 3 ] = &tFactory9Root4 ; pptRoot[ 4 ] = &tFactory9Root5 ; pptRoot[ 5 ] = &tFactory9Root6 ; pptRoot[ 6 ] = &tFactory9Root7 ; break ; }
    case IDcOMPUTER_FACTORY3 : { cRoot = 1 ; pptRoot[ 0 ] = &tFactory3Root1                                                                                                                                                                                                       ; break ; }
    case IDcOMPUTER_FACTORY2 : { cRoot = 1 ; pptRoot[ 0 ] = &tFactory2Root1                                                                                                                                                                                                       ; break ; }
    case IDcOMPUTER_FACTORY1 : { cRoot = 4 ; pptRoot[ 0 ] = &tFactory1Root1 ; pptRoot[ 1 ] = &tFactory1Root2 ; pptRoot[ 2 ] = &tFactory1Root3 ; pptRoot[ 3 ] = &tFactory1Root4                                                                                                    ; break ; }
{                                //CS:CODEsYNC 51000760 51000760
switch( idComputer )
textC*  pptRoot[ 0x10 ] ; //CS:CODEsYNC 51000760 51000760
ZE( countT , cRoot ) ;

etThread.traceF( tinP , T("idComputer: ")+TF2(idComputer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
countT idComputer = etThread.diskIdF( tinP , T("///c") ) ;

TN( tRootTest , "///d/archive.test/1999/" ) ;

TN( tFactory9Root7 , "///z/archive/" ) ;
TN( tFactory9Root6 , "///y/archive.snap/" ) ;
TN( tFactory9Root5 , "///y/archive/" ) ;
TN( tFactory9Root4 , "///x/archive/" ) ;
TN( tFactory9Root3 , "///w/archive/" ) ;
TN( tFactory9Root2 , "///e/archive/" ) ;
TN( tFactory9Root1 , "///d/archive.not.yet.verified/" ) ;

TN( tFactory3Root1 , "///e/archive/" ) ;

TN( tFactory2Root1 , "///d/archive.not.yet.verified/" ) ;

TN( tFactory1Root4 , "///g/archive.save.1999/" ) ;
TN( tFactory1Root3 , "///g/archive/" ) ;
TN( tFactory1Root2 , "///e/archive.part2/" ) ;
TN( tFactory1Root1 , "///d/archive.part1/" ) ;

countT pcArgInner[] = { (countT)&etThread , (countT)&sttq , (countT)&tPatternHash } ;

strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

;

    +S2(sa_SSSaNDeND,sc_ccSSS)

        +T(".")
        // TERMINATOR

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERICf,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(0x1f,sc_ccSSSrEPEAT,0x1f)
        +T(".")
        // HASH

    +S2(sa_SSSaND,sc_ccSSS)
    T("")

TN( tPatternHash , "" ) ; tPatternHash =

TODO

DONE( tmWorkerF )
}
    etThread.traceF( tinP , T("root ---- [cFiles,cDirs]:    ")+*ptRootP+tb4+TF2(cFiles,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(cDirs,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
    etThread.diskWalkF( tinP , cDirs , cFiles , *ptRootP , ether , flDISKwALK_null , inspectCBF , pcArgInnerP , 0 , 0 ) ;
    etThread.traceF( tinP , T("root ++++               :    ")+*ptRootP ) ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs ) ;

    TN( tb4 , "    " ) ;
    countT* pcArgInnerP = (countT*)pTaskP->c2 ;
    textC*  ptRootP     =  (textC*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )

}
    return 0 ;

    }
        }
            }
                etherP.traceF( tinP , T("hash error:    ")+tName ) ;
            {
            if( etherP.strCompareF( tinP , tHashFromFileName , tHashCalculated ) )

            //etherP.traceF( tinP , T("[tHashCalculated]: ")+tHashCalculated ) ;
            }
                etherP.delF( tinP , posti ) ;
                }
                    etherP.delF( tinP , psttHashCalculated ) ;
                    tHashCalculated = T(psttHashCalculated) ;
                    hasher.queryStringF( tinP , psttHashCalculated ) ; ___( psttHashCalculated ) ;
                    ZE( strokeS* , psttHashCalculated ) ;

                    hasher.eatF( tinP , posti , costi ) ;
                    hasherC hasher( tinP , etherP ) ;
                {

                etherP.boxGetShadowF( tinP , posti , costi , tName ) ; ___( posti ) ;
                ZE( countT   , costi ) ;
                ZE( osTextT* , posti ) ;
            {
            TN( tHashCalculated , "" ) ;

            //etherP.traceF( tinP , T("[tHashFromFileName]: ")+tHashFromFileName ) ;
            }
                etherP.delF( tinP , psttHashFromFileName ) ;
                tHashFromFileName = T(psttHashFromFileName) ;
                etherP.strSubstringF( tinP , psttHashFromFileName , idf , idl , tName ) ; ___( psttHashFromFileName ) ;
                countT idl = idHit + 0x20 ;
                countT idf = idHit + 1 ;
                ZE( strokeS* , psttHashFromFileName ) ;
            {
            TN( tHashFromFileName , "" ) ;
        {
        if( idHit )
        //etherP.traceF( tinP , T("[idHit,name:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tName ) ;

        etherP.traceF( tinP , tName ) ;
        etherP.traceF( tinP , T("------------------------------------------------------------------") ) ;

        if( !( cFilesP % ( TOCK >> 4 ) ) ) etherP.traceF( tinP , T("[cFiles]:    ")+TF2(cFilesP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        countT idHit = etherP.strIdF( tinP, idf , sttqP , tPatternHashP , tName ) ;
        countT idf = 1 ;

        TN( tDot , "." ) ;
        TN( tStar , "*" ) ;
        TN( tName , ifName ) ;
        ifFileNameC ifName( tinP , etherP , postNameP ) ;

        textC&  tPatternHashP =   *(textC*)pcArgP[ 2 ] ;
        strokeS sttqP         = *(strokeS*)pcArgP[ 1 ] ;
        etherC& etherP        =  *(etherC*)pcArgP[ 0 ] ;
        _IO_
    {
    if( postNameP && thirdC::c_strstrIF( tinP , postNameP , ".hashedname" ) )
    _IO_
{
boolT inspectCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )




/*1*/WAKEsHOWtEXT( "tool.archives.detect.ransomware.encryption.by.verifying.hash" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
