
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#undef RAT

}
    return sgn ;
    else if( sgn > 0 ) sgn =   1 ;
         if( sgn < 0 ) sgn = - 1 ;

    }
        }
            }
                o2 -- ;
                o1 -- ;

                sgn = pb1P[ o1 ] - pb2P[ o2 ] ;
            {
            while( !sgn && o1 >= 0 )

            }
                }
                    if( pb2P[ o2 -- ] ) sgn = - 1 ;
                {
                while( !sgn && o2 > o1 )
            {
            else if( cb1 < cb2 )
            }
                }
                    if( pb1P[ o1 -- ] ) sgn = 1 ;
                {
                while( !sgn && o1 > o2 )
            {
            if( cb1 > cb2 )
        {
        else // DOWN
        }
            }
                else if( o2 == cb2 ) sgn =   1 ;
                else if( o1 == cb1 ) sgn = - 1 ;
                if( o1 == cb1 && o2 == cb2 ) ;
            {
            if( !sgn )

            }
                o2 ++ ;
                o1 ++ ;

                sgn = pb1P[ RAT( o1 ) ] - pb2P[ RAT( o2 ) ] ;
            {
            while( !sgn && o1 < cb1 && o2 < cb2 )
        {
        else if( bUp ) // UP
        else if( !cb2 ) sgn =   1 ;
        else if( !cb1 ) sgn = - 1 ;
        else if( !cb1 && !cb2 ) ;
        else if( !pb2P ) sgn =   1 ;
        else if( !pb1P ) sgn = - 1 ;
             if( !pb1P && !pb2P ) ;
    {
    if( !third )
    ZE( sCountT , sgn ) ;

    sCountT o2 = bUp ? 0 : cb2 - 1 ;
    sCountT o1 = bUp ? 0 : cb1 - 1 ; // "o" IS FOR OFFSET

    __( bMod && cb2 % sizeof( countT ) ) ;
    __( bMod && cb1 % sizeof( countT ) ) ;

    countT cb2 = pb2P ? ( cb2P ? cb2P : third.c_strlenIF( tinP , pb2P ) ) : 0 ;
    countT cb1 = pb1P ? ( cb1P ? cb1P : third.c_strlenIF( tinP , pb1P ) ) : 0 ;

    const boolT bMod = bNumericP && !bSignificanceIncreasingP ;
    const boolT bUp  = !bSignificanceIncreasingP ;

    //   bNumeric  bSignificanceIncreasing    cb-1 ... 7 6 5 4 3 2 1 0    (example: large digits)   down    moduloNo
    //   bNumeric !bSignificanceIncreasing    3 2 1 0 7 6 5 4 ...         (example: pcz names)      up      moduloYes
    //  !bNumeric  bSignificanceIncreasing    cb-1 ... 7 6 5 4 3 2 1 0                              down    moduloNo
    //  !bNumeric !bSignificanceIncreasing    0 1 2 3 4 5 6 7 ... cb-1    (example: text)           up      moduloNo
    //
    // STRATEGY: LOOK AT MOST SIGNIFICANT BYTE PAIR FIRST, AND END AS SOON AS HAVE A NONZE VALUE
    _IO_

    }
        if( third ) return 0 ;
    {
    IFbEcAREFUL    
{
/*1*/sCountT subtractF( tinS& tinP , thirdC& third , const byteT* const pb1P , const byteT* const pb2P , const countT cb1P , const countT cb2P , const boolT bNumericP , const boolT bSignificanceIncreasingP )/*1*/

    )
            (xP)                                                                                                        \
        :                                                                                                               \
        )                                                                                                               \
            ( (xP) / sizeof( countT ) ) * sizeof( countT ) - (xP) % sizeof( countT ) + sizeof( countT ) - 1             \
        (                                                                                                               \
        ?                                                                                                               \
        bMod                                                                                                            \
    (                                                                                                                   \
                                                                                                                        \
#define RAT(xP)                                                                                                         \

/**/
*/
  1: pb1P and pb2P point to objects (countT or byteT) that are in order of increasing significance (large integer values are stored this way)
  0: pb1P and pb2P point to objects (countT or byteT) that are in order of decreasing significance (osTextT and pcz names are stored this way)
 bSignificanceIncreasingP
  1: pb1P and pb2P point to adjacent countT objects
  0: pb1P and pb2P point to adjacent byteT objects
 bNumericP
 cb2P
 cb1P
 pb2P
 pb1P
 tinP
arguments
 -1: pb1P < pb2P
 0: pb1P == pb2P
 1: pb1P > pb2P
evaluates to one of re values (-1,0,1) depending on the relative sort ordering of pb1P and pb2P
\<A HREF=\"5.0c00005.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$subtractF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

