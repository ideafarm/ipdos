
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( cbP && flagsP && tinP.fingerprint && etherP && !handleP ) ;

    }
        }
            break ;
            if( cArgP ) sBranch << (strokeS*)pbP ;
        {
        case ifcIDtYPEtREEwALKcb_WIFEbEGIN :
        }
            break ;
            }
                }
                    }
                        sBranch << (countT)*hdr.pSw_idKidLathHugged ;
                        sBranch << hdr.psttLeverKids ;
                        treeP.psttLeverKidsShared = hdr.psttLeverKids = (strokeS*)hdr.pSwsKids->leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    sBranch << cFlavors ;
                    countT cFlavors = hdr.pSwsKids->cFlavorsF( tinP ) ;
                {
                if( F(flagsTreeWrite) & flTREEwRITE_pSwsKids )

                sBranch << flagsTreeWrite ;
                if( hdr.pSwsKids      ) flagsTreeWrite |= flTREEwRITE_pSwsKids ;
                if( hdr.psttLeverKids ) flagsTreeWrite |= flTREEwRITE_psttLeverKids ;
                if( hdr.pSw_psttWife  ) flagsTreeWrite |= flTREEwRITE_pSw_psttWife ;
                if( hdr.cLeverWife    ) flagsTreeWrite |= flTREEwRITE_cLeverWife ;
                flagsT flagsTreeWrite = flTREEwRITE_null ;
            {
            if( cArgP )
            branchHeaderOldS& hdr = *(branchHeaderOldS*)pbP ;
        {
        case ifcIDtYPEtREEwALKcb_BRANCHeND :
        }
            break ;
            }
                }
                    }
                        *hdr.pSw_idKidLathHugged = idLathRef ;
                        stKids.pPlateF( tinP , idLathRef ) ;
                        ZE( countT , idLathRef ) ;
                        stackC& stKids = *hdr.pSwsKids ;
                        treeP.psttLeverKidsShared = hdr.psttLeverKids = (strokeS*)hdr.pSwsKids->leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = hdr.pSwsKids->cFlavorsF( tinP ) ;
                {
                if( F(flagsTreeWrite) & flTREEwRITE_pSwsKids )

                }
                    sBranch << hdr.psttLeverKids ;
                {
                if( F(flagsTreeWrite) & flTREEwRITE_psttLeverKids )

                }
                    }
                        sBranch << *(strokeS**)&(countT&)*hdr.pSw_psttWife ;
                        sBranch << hdr.cLeverWife ;
                        hdr.cLeverWife = treeP.cLeverWifeShared = hdr.pSw_psttWife->leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    sBranch << cFlavors ;
                    countT cFlavors = hdr.pSw_psttWife->cFlavorsF( tinP ) ;
                {
                if( F(flagsTreeWrite) & flTREEwRITE_pSw_psttWife )

                }
                    sBranch << hdr.cLeverWife ;
                {
                if( F(flagsTreeWrite) & flTREEwRITE_cLeverWife )

                sBranch << flagsTreeWrite ;

                if( hdr.pSwsKids      ) flagsTreeWrite |= flTREEwRITE_pSwsKids ;
                if( hdr.psttLeverKids ) flagsTreeWrite |= flTREEwRITE_psttLeverKids ;
                if( hdr.pSw_psttWife  ) flagsTreeWrite |= flTREEwRITE_pSw_psttWife ;
                if( hdr.cLeverWife    ) flagsTreeWrite |= flTREEwRITE_cLeverWife ;
                flagsT flagsTreeWrite = flTREEwRITE_null ;

                sBranch << *(strokeS**)( &hdr + 1 ) ; //U::GENERALIZE THIS BY CALLING THE DEFINITION CALLBACK
            {
            if( cArgP )
            branchHeaderOldS& hdr = *(branchHeaderOldS*)pbP ;
        {
        case ifcIDtYPEtREEwALKcb_BRANCHbEGIN :
    {
    switch( idTypeP )

    if( cArgP ) sBranch << idTypeP ;
    soulC& sBranch = *(soulC*)c2p.c2 ;
    treeOldC& treeP   = *(treeOldC*)c2p.c1 ;
    count2S& c2p   = *(count2S*)cArgP ;
{
/*1*/voidT _treeWriteCBF( tinS& tinP , etherC& etherP , const countT idTypeP , const flagsT flagsP , const handleC& handleP , byteT* pbP , countT cbP , countT& cArgP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

