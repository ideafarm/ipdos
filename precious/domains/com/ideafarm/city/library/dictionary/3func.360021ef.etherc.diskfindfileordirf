
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            if( tinP.pEther ) tinP.pEther->etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
            _IO_
        {
        IFwHEREkNOWStHREAD

        }
            delF( tinP , psttPath ) ;

            }
                }
                    }
                        }
                            }
                                }
                                    }
                                        else                                 { DEL( pInfoP ) ; }
                                        IFpATTERN( *this , *pPatternP , fn ) { break ; }
                                        _IO_
                                   {
                                    else
                                    if( !fn ) { DEL( pInfoP ) ; }

                                    fileNameC fn( tinP , *this , pInfoP->psttIfoName ) ;

                                    strMakeF( tinP , LF , pInfoP->psttIfoName , T(iffn) ) ; ___( pInfoP->psttIfoName ) ;
                                    ifFileNameC iffn( tinP , third , pInfoP->postOsName ) ;
                                    _IO_
                                {
                                else
                                if( !bOk ) { DEL( pInfoP ) ; }

                                }
                                    }
                                        }
                                            break ;
                                            bOk = 0 ;
                                            _IO_
                                        {
                                        if( !postHit )
                                        }
                                            postHit = thirdC::c_strstrIF( tinP , postc , pPatternP->ppostLiteral[ offLit ] ) ;
                                            postc += costLit ;
                                            _IO_
                                        {
                                        while( postHit && postHit + costLit < poste )
                                        osTextT* poste = postc + thirdC::c_strlenIF( tinP , postc ) ;
                                        _IO_
                                    {
                                    if( !pPatternP->ppostLiteral[ offLit + 1 ] && F(pPatternP->flagsLiterals) & flPATTERNlITERALS_LITERALeNDING )

                                    }
                                        break ;
                                        bOk = 0 ;
                                        _IO_
                                    {
                                    )
                                        )
                                            postHit - postc
                                            &&
                                            F(pPatternP->flagsLiterals) & flPATTERNlITERALS_LITERALbEGINNING
                                            &&
                                            !offLit
                                        (
                                        ||
                                        !postHit
                                    (
                                    if
                                    osTextT* postHit = thirdC::c_strstrIF( tinP , postc , pPatternP->ppostLiteral[ offLit ] ) ;

                                    if( pPatternP->ppostLiteral[ offLit ][ costLit - 1 ] == '/' ) pPatternP->ppostLiteral[ offLit ][ costLit - 1 ] = '\\' ; // PATCH THE LITERAL SO THAT IT WILL MATCH ITS BASE OS MAPPING (SLASH TO BACKSLASH) ; NOTE: THIS HAS IMPLICATIONS IF THE patternC INSTANCE IS USED MULTIPLE TIMES (IT WILL BE PATCHED ONLY WO TIME) ; THIS IS DONE HERE RATHER THAN IN patternC BECAUSE patternC CAN BE USED FOR SEARCHES OTHER THAN FOR FILES SO FUTURE CODE MIGHT USE THE LITERALS IN WAYS THAT WOULD NOT WANT THE PATCH
                                    countT costLit = thirdC::c_strlenIF( tinP , pPatternP->ppostLiteral[ offLit ] ) ;
                                    _IO_
                                {
                                for( countT offLit = 0 ; offLit < sizeof pPatternP->ppostLiteral / sizeof pPatternP->ppostLiteral[ 0 ] && pPatternP->ppostLiteral[ offLit ] ; offLit ++ )
                            {
                            else
                            if( !bOk ) { DEL( pInfoP ) ; }

                            // NOW EITHER !bOk OR postc POINTS TO LEAF
                            }
                                }
                                    }
                                        else                       postc -- ;
                                        if( postc[ - 1 ] == '\\' ) break ;
                                    {
                                    while( cDo -- )
                                {
                                else
                                if( *postc == '\\' ) bOk = 0 ; // SHOULD BE IMPOSSIBLE SINCE IT WOULD IMPLY A NULL LENGTH DIRECTORY NAME

                                }
                                    cDo   -- ;
                                    postc -- ;
                                {
                                if( *postc == '\\' )
                                countT cDo = costOsName - 1 ;
                            {

                            osTextT* postc = pInfoP->postOsName + costOsName - 1 ; // NOW POINTS TO LATH CHAR ; WILL BE ADJUSTED TO POINT TO LEAF
                            boolT bOk = 1 ;

                            // CONJ: WHEN I ADDED THIS SPEED OPTIMIZATION, I MISTAKENLY ASSUMED THAT I WOULD NOT WANT DIRECTORIES, NOTWITHSTANDING THE FUNCTION NAME
                            //20210207@1347: EDITED THE NEXT CODE LINES TO ACCEPT DIRECTORY ENTRIES ; ORIGINAL COMMENT:  SHOULD BE IMPOSSIBLE SINCE NOT ACCEPTING DIRECTORY ENTRIES

                            //THIS BLOCK IS A SPEED OPTIMIZATION THAT REJECTS CANDIDATES THAT DO NOT CONTAIN REQUIRED LITERALS
                            _IO_
                        {
                        else
                        }
                            break ;
                            strMakeF( tinP , LF , pInfoP->psttIfoName , T(iffn) ) ; ___( pInfoP->psttIfoName ) ;
                            ifFileNameC iffn( tinP , third , pInfoP->postOsName ) ;
                            _IO_
                        {
                        if( !pPatternP )

                        }
                            continue ;
                            DEL( pInfoP ) ;
                        {
                        if( !costOsName )

                        countT costOsName = thirdC::c_strlenIF( tinP , pInfoP->postOsName ) ;

                        _IO_
                    {
                    else
                    else if( F(pInfoP->flags) & flFILEaTTR_DOTdIRECTORY ) { DEL( pInfoP ) ; }
                         if( !pInfoP                                    ) { break ; }

                    third.dosFindFileOrDirF( tinP , pInfoP , handleP , osfnLike ) ; ___( pInfoP ) ;
                    _IO_
                {
                while( !POOP )

                third.delF( tinP , postLike ) ;
                osFileNameC osfnLike( tinP , third , postLike ) ;
                strMakeF( tinP , LF , postLike , T(psttPath)+T("*") ) ; ___( postLike ) ;
                ZE( osTextT* , postLike ) ;
                _IO_
            {
            if( !POOP )

            }    
                }
                    __( psttPath[ CSpREFIX + 4 ] != S1C('/') ) ;
                {
                if( psttPath[ CSpREFIX + 3 ] != S1C('/') )          //20190826@0844: ACCOMMODATE NETWORK FILE NAMES OF THE FORM "////netbiosname/disk/path/short"
                __( psttPath[ CSpREFIX + 2 ] != S1C('/') ) ;
                __( psttPath[ CSpREFIX + 1 ] != S1C('/') ) ;
                __( psttPath[ CSpREFIX     ] != S1C('/') ) ;
                __( psttPath->idCaste != sc_PREFIXlENGTH ) ;
                _IO_
            {
            if( !POOP )

            __Z( psttPath ) ;
            diskMapFileNameF( tinP , psttPath , psttPathP ) ; ___( psttPath ) ;
            ZE( strokeS* , psttPath ) ;
            _IO_
        {

        }
            if( tinP.pEther ) tinP.pEther->etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
            _IO_
        {
        IFwHEREkNOWStHREAD
        _IO_
    {
    _IO_

    }
        if( POOP ) return ;
        __( psttPathP[ CSpREFIX - 1 + psttPathP->idAdam ].idAdam - '/' ) ;
        if( POOP ) return ;
        __( psttPathP->idAdam < 5 ) ;
        if( POOP ) return ;
        //FV(flDISKfIND,flagsP)
        __Z( psttPathP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::diskFindFileOrDirF( tinS& tinP , infoFileS*& pInfoP , handleC& handleP , const strokeS* const psttPathP , const patternC* pPatternP , const flagsT flagsP )/*1*/

/**/
*/
  to find a directory, specify its leaf as the pattern
  else only matching are found
  if 0 then i match all files and directories that are the immediate children of psttPathP
 pPatternP
  must end in '/'
  example: T("///d/tmp/")
 psttPathP
  call me repeatedly until !handleP
  must be newly constructed on woth call
 handleP
  caller must delete, normally by using DEL()
  else will point to an information structure for a single matching file or directory
  if a matching file is not found, will remain 0
  must be 0
 pInfoFileP
 tinP
parameters
to find a directory, specify its leaf directory as pattern, with its parent directory in psttPathP
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

