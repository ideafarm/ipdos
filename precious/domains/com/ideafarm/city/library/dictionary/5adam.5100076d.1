
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;                            

}
    }
        }
            etThread.traceF( tinP , T("ok [disk,cDirs,cFiles]:    ")+T(postDisk)+T("    ")+TF2(cDirs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            
            etThread.diskWalkF( tinP , cDirs , cFiles , T(postDisk) , bQuit , diskWalkSearchCBF , pcArg ) ;
            ZE( boolT , bQuit ) ;
            ZE( countT , cFiles ) ;
            ZE( countT , cDirs ) ;

            countT pcArg[] = { 0 , 0 } ;
            
            DEL( pInfo ) ;
            etThread.traceF( tinP , T(postDisk) ) ;
        {
        else
        if( POOP ) { POOPR ; }
        tinP.pEtScratch->diskInfoF( tinP , pInfo , T(postDisk) , 1 ) ;
        ZE( infoDiskS* , pInfo ) ;
    {    
    for( postDisk[ 3 ] = 'a' ; postDisk[ 3 ] <= 'z' ; postDisk[ 3 ] ++ )
    
    osTextT postDisk[] = "///./" ;

    SCOOPS
{
IFsCRATCH

TODO


}
    return bDoIt ;

    }
        }
            DEL( pInfo ) ;

            }
                if( thirdC::c_strstrIF( tinP , pbBuffer , postFind ) ) etherC::etRockIF( tinP ).traceF( tinP , T("hit contents:    ")+tName+T("    ")+T(pbBuffer) ) ;

                }
                    countT foo = 2 ;
                {
                if( pcArgP[ 0 ] == 0x19 )

                etherC::etRockIF( tinP ).traceF( tinP , TF2(pcArgP[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    read:       ")+tName ) ;
                tinP.pEther->fileReadF( tinP , pbBuffer , cbEat , file ) ;
                etherC::etRockIF( tinP ).traceF( tinP , TF2(pcArgP[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    reading:    ")+tName ) ;

                countT cbEat = pInfo->cbUsed < sizeof pbBuffer - 1 ? pInfo->cbUsed : sizeof pbBuffer - 1 ;

                pcArgP[ 1 ] ++ ;
            {
            if( pInfo && pInfo->cbUsed )
            tinP.pEther->diskFileQueryF( tinP , pInfo , file ) ; ___( pInfo ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        else
        }
            etherC::etRockIF( tinP ).traceF( tinP , T("could not open a handle to file::    ")+tName ) ;
            POOPR
        {
        if( POOP )

        fileC file( tinP , postNameP , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 ) ;

        if( thirdC::c_strstrIF( tinP , postNameP , postFind ) ) etherC::etRockIF( tinP ).traceF( tinP , T("hit name:    ")+tName ) ;

        pcArgP[ 0 ] ++ ;

        TN( tName , ifName ) ;
        ifFileNameC ifName( tinP , *tinP.pEther , postNameP ) ;
    {
    else
    }
        etherC::etRockIF( tinP ).traceF( tinP , T("directory::    ")+tName ) ;

        TN( tName , ifName ) ;
        ifFileNameC ifName( tinP , *tinP.pEther , postNameP ) ;
    {
    else if( postNameP[ thirdC::c_strlenIF( tinP , postNameP ) - 1 ] == '\\' && tinP.pEther ) // IF DIRECTORY
    }
        etherC::etRockIF( tinP ).traceF( tinP , T("scan completed for a directory") ) ;
    {
    if( !postNameP )
    ZE( boolT , bDoIt ) ;

    _IO_
{
/*1*/boolT diskWalkSearchCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloFilesP , const countT* const pModuloDirsP )/*1*/

countT idFile ;

byteT   pbBuffer[ TUCK ] ;
osTextT postFind[] = "20180504@" ;


/*1*/WAKEsHOWtEXT( "scratch.3.inactive.tool.search.disk" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
