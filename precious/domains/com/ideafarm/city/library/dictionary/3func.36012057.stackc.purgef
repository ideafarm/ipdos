
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUTbATONsTACKc_

    }
        if( cPlatesCheck != cPlates ) { BLAMMO ; }
        }
            ppc = ppc->ppD ;
            cPlatesCheck ++ ;
        {
        while( ppc )
        plateS* ppc = ppTop ;
        if( ppBottom && ppBottom->ppD ) { BLAMMO ; }
        if( ppTop && ppTop->ppU ) { BLAMMO ; }
        ZE( countT , cPlatesCheck ) ;
    {
    //U::
    
    }
        third.delF( tinP , *(countT**)&ppDoomed ) ;
    
        if( pSgnEvent && F(flags) & flSTACKc_GIVEsIGNdELpLATE ) pSgnEvent->giveF( tinP ) ;
        }
            else                           third.delF( tinP , *(countT**)&ppDoomed[ off ] ) ;
            if( F(flags) & flSTACKc_XRAY ) pXray->freeF( tinP ) ;
    
            }
                default                                 : { __( idType ) ; break ; } // ifcSTACKtYPE_ANY AND ifcSTACKtYPE_tableC WILL CAUSE IMPOTENCE IF THERE ARE ANY PLATES
                                                          { break ; }
                case ifcSTACKtYPE_BLOB                  :
                case ifcSTACKtYPE_timeS                 :
                case ifcSTACKtYPE_nicNameC              :
                case ifcSTACKtYPE_measureT              :
                case ifcSTACKtYPE_sCountT               :
                case ifcSTACKtYPE_countT                :
                //U:: case ifcSTACKtYPE_handleC         : { handleC&            hh =         *(handleC*)&PLATE_countT_REF( ppDoomed[ off ] ) ; hh.closeIfF()                         ; break ; }
                case ifcSTACKtYPE_PTR_soulC             : { soulC*              pn =             (soulC*)PLATE_countT_REF( ppDoomed[ off ] ) ; etherC::etRockIF( tinP )( tinP , pn ) ; break ; }
                case ifcSTACKtYPE_PTR_countT            : { countT*             pn =            (countT*)PLATE_countT_REF( ppDoomed[ off ] ) ;               third.delF( tinP , pn ) ; break ; }
                case ifcSTACKtYPE_PTR_byteT             : { byteT*              pn =             (byteT*)PLATE_countT_REF( ppDoomed[ off ] ) ;               third.delF( tinP , pn ) ; break ; }
                case ifcSTACKtYPE_PTR_plateC            : { plateC*             pn =            (plateC*)PLATE_countT_REF( ppDoomed[ off ] ) ;               DEL( pn )               ; break ; } //U::CONJ: WILL CALL THE BASE DT RATHER THAN THE DERIVED CLASS DT
                case ifcSTACKtYPE_PTR_nicNameC          : { nicNameC*           pn =          (nicNameC*)PLATE_countT_REF( ppDoomed[ off ] ) ;               third.delF( tinP , pn ) ; break ; }
                case ifcSTACKtYPE_PTR_count8S           : { count8S*            pn =           (count8S*)PLATE_countT_REF( ppDoomed[ off ] ) ;               third.delF( tinP , pn ) ; break ; }
                case ifcSTACKtYPE_PTR_count7S           : { count7S*            pn =           (count7S*)PLATE_countT_REF( ppDoomed[ off ] ) ;               third.delF( tinP , pn ) ; break ; }
                case ifcSTACKtYPE_PTR_count6S           : { count6S*            pn =           (count6S*)PLATE_countT_REF( ppDoomed[ off ] ) ;               third.delF( tinP , pn ) ; break ; }
                case ifcSTACKtYPE_PTR_count5S           : { count5S*            pn =           (count5S*)PLATE_countT_REF( ppDoomed[ off ] ) ;               third.delF( tinP , pn ) ; break ; }
                case ifcSTACKtYPE_PTR_count4S           : { count4S*            pn =           (count4S*)PLATE_countT_REF( ppDoomed[ off ] ) ;               third.delF( tinP , pn ) ; break ; }
                case ifcSTACKtYPE_PTR_count3S           : { count3S*            pn =           (count3S*)PLATE_countT_REF( ppDoomed[ off ] ) ;               third.delF( tinP , pn ) ; break ; }
                case ifcSTACKtYPE_PTR_count2S           : { count2S*            pn =           (count2S*)PLATE_countT_REF( ppDoomed[ off ] ) ;               third.delF( tinP , pn ) ; break ; }
                case ifcSTACKtYPE_PTR_strokeS           : { strokeS*            pn =           (strokeS*)PLATE_countT_REF( ppDoomed[ off ] ) ;               third.delF( tinP , pn ) ; break ; }
            {
            switch( idType )
            //if( F(flags) & flSTACKc_COPY )
        {
        for( countT off = 0 ; off < cpDoomed ; off ++ )
    {
    if( ppDoomed )

    //U::O: UNGRAB HERE

    }    
        third.delF( tinP , pcTabIdSlot ) ;
        third.delF( tinP , *(countT**)&ppTab ) ;
        newTabsIfF( tinP , 0 , 0 ) ;
    
        }
            }
                flagsState = flSTACKsTATE_null ; //115005c 0050011 0010121: VERIFY THAT THIS MAKES SENSE FOR NEWLY DEFINED STATE FLAGS
        
                }
                    -- cPlates ;
                    else        ppBottom   = 0 ;
                    if( ppTop ) ppTop->ppU = 0 ;
                    ppTop = ppTop->ppD ;
                    ppDoomed[ off ] = ppTop ;
                    adjustRefsF( tinP , 1 , ifcIDaCTIONsTACKaDJUSTrEFS_DELETED ) ;
                {
                for( countT off = 0 ; off < cpDoomed ; off ++ )
            {
            if( ppDoomed )
            third.newF( tinP , LF , *(countT**)&ppDoomed , cpDoomed ) ; ___CT( ppDoomed ) ;
        {
        if( cpDoomed )

        cpDoomed = cPlates - cPlatesRetainP ;
        if( cPlatesRetainP > cPlates ) cPlatesRetainP = cPlates ;
    {
    if( cPlatesRetainP < cPlates )
    ZE( countT   , cpDoomed ) ;
    ZE( plateS** , ppDoomed ) ;
    //CS:CODEsYNC: 115005c 115007d

    }
        if( cPlatesCheck != cPlates ) { BLAMMO ; }
        }
            ppc = ppc->ppD ;
            cPlatesCheck ++ ;
        {
        while( ppc )
        plateS* ppc = ppTop ;
        if( ppBottom && ppBottom->ppD ) { BLAMMO ; }
        if( ppTop && ppTop->ppU ) { BLAMMO ; }
        ZE( countT , cPlatesCheck ) ;
    {

    if( cPlates < idCursorDefault || ( idCursorDefault && !ppCursorDefault ) ) { BLAMMO ; } //U::

    _INbATONsTACKc_

    }
        //if( third ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT stackC::purgeF( tinS& tinP , countT cPlatesRetainP )/*1*/

/**/
*/
\<A HREF=\"5.115005c.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$purgeF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

