
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.ifcDrivenServerF( tinP , i1 , i2 ) ;
serverInfo2S i2( 0x19 , flSOCKETc_null , TF2(thirdC::third_idAdamRootI_IF( tinP ),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , 0 , (countT)&c8p , 0 , 1 , sizeof( stateS ) , translateStateF ) ;
serverInfo1S i1( &pbdVarying , b_pbdVarying , bHandedOff , sgnIdPortReplaced , tmcF , countTC() , ether ) ;

c8p.c2 = (countT)&b_pbdVarying ;
c8p.c1 = (countT)&pbdVarying ;
count8S c8p ;

ZE( boolT , bHandedOff ) ;
batonC b_pbdVarying( tinP , TAG( TAGiDnULL ) ) ;
ZE( byteT* , pbdVarying ) ;
signC sgnIdPortReplaced( tinP , TAG( TAGiDnULL ) ) ;

((thirdC&)etThread).logF( tinP , T("port.91.smtp") ) ;

TODO

DONEdRIVENsERVER( tmcF )
}
    thirdC::logIF( tinP , ostoFile , nicNamePeer , 4 , count5S( 1 , 2 , 3 , 4 ) , (countT)&stPhrases , 1 ) ;
    OStEXTAK( ostoFile , ".log.port.91" ) ;
    OStEXTC( ostoFile , etherC::ifc_idHomeI_IF() , 0 ) ;
    OStEXTAK( ostoFile , "\\ideafarm." ) ;
    OStEXT( ostoFile , 0x100 )

    etThread.delF( tinP , psttw ) ;
    __( etThread.strCompareF( tinP , psttw , tQuit ) ) ;
    etThread.delF( tinP , psttl ) ;
    etThread.strConvertToLowerCaseF( tinP , psttw , psttl ) ; ___( psttw ) ;
    pso->readWoLineF( tinP , psttl , 0x400 ) ; ___( psttl ) ;
    // "quit"

    }
        etThread.delF( tinP , postBody ) ;
        etThread.delF( tinP , psttu ) ;
        etThread.boxPutUniqueF( tinP , psttu , T("///ideafarm/ephemeral/domains/com/ideafarm/3240104/in") , postBody , costBody ) ;
        ZE( strokeS* , psttu ) ;
        etThread.delF( tinP , psttBody ) ;
        countT costBody = etThread.strMakeF( tinP , postBody , psttBody ) ; ___( postBody ) ;
        ZE( osTextT* , postBody ) ;
        etThread.strConcatenateF( tinP , psttBody , st_psttBody ) ; ___( psttBody ) ;
        ZE( strokeS* , psttBody ) ;

        pso->writeF( tinP , "250 ok\r\n" ) ;
        }
            psttl = 0 ;
            st_psttBody << psttOldC( tinP , etThread , T("\r\n") ) ;
            st_psttBody << psttl ;
            }
                }
                    etThread.strSubstringF( tinP , psttl , idf , idl , psttw ) ; ___( psttl ) ;    etThread.delF( tinP , psttw ) ;
                    ZE( countT , idl ) ;
                    countT idf = 2 ;
                    //sttq = ze ;
                    psttl = 0 ;
                    psttw = psttl ;
                {
                else
                }
                    break ;
                    etThread.delF( tinP , psttl ) ;
                {
                if( psttl->idAdam == 1 )
            {
            if( psttl && psttl[ CSpREFIX ] == sttDot )
            pso->readWoLineF( tinP , psttl , 0x400 ) ;                                 ___( psttl ) ;
        {
        while( !etThread )
        stackC st_psttBody( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    {
    // DATA LINES

                    pso->writeF( tinP , "354 Start mail input; end with <CRLF>.<CRLF>\r\n" ) ;

    }
                    st_psttMailRcpt << psttl ;                                                                  psttl = 0 ;
                    pso->writeF( tinP , "250 ok\r\n" ) ;
                    stPhrases << postOldC( tinP , etThread , T("\r\nrcpt \"")+T(psttw)+T("\"") ) ;                 etThread.delF( tinP , psttw ) ;
        /*sttq = ze ;*/  __( !bFromIfc && !etThread.strIdF( tinP , idf , sttq , tAtIdeafarmDotCom , psttw ) ) ;
                    idf = 1 ;
                    etThread.strConvertToLowerCaseF( tinP , psttw , psttw2 ) ;                  ___( psttw ) ;    etThread.delF( tinP , psttw2 ) ;
        /*sttq = ze ;*/  etThread.strWordF( tinP , psttw2 , psttw , sttq , sttColon , 2 ) ;          ___( psttw2 ) ;   etThread.delF( tinP , psttw ) ;
                    __( etThread.strCompareF( tinP , psttw3 , tTo ) ) ;                              etThread.delF( tinP , psttw3 ) ;
                    etThread.strConvertToLowerCaseF( tinP , psttw3 , psttw2 ) ;                 ___( psttw3 ) ;   etThread.delF( tinP , psttw2 ) ;
        /*sttq = ze ;*/  etThread.strWordF( tinP , psttw2 , psttw , sttq , sttColon , 1 ) ;          ___( psttw2 ) ;
        /*sttq = ze ;*/  etThread.strWordF( tinP , psttw , psttl , sttq , sttSpace , 2 ) ;           ___( psttw ) ;

                    }
                        break ;
                        st_psttMailRcpt << psttl ;                                                              psttl = 0 ;
                    {
                    if( bData )
                    __( !bRcpt && !bData ) ;
                    boolT bRcpt = !bData && !etThread.strCompareF( tinP , psttw2 , tRcpt ) ;                    etThread.delF( tinP , psttw2 ) ;
                    boolT bData =           !etThread.strCompareF( tinP , psttw2 , tData ) ;
                    etThread.strConvertToLowerCaseF( tinP , psttw2 , psttw ) ;                  ___( psttw2 ) ;   etThread.delF( tinP , psttw ) ;
        /*sttq = ze ;*/  etThread.strWordF( tinP , psttw , psttl , sttq , sttSpace , 1 ) ;           ___( psttw ) ;
                    pso->readWoLineF( tinP , psttl , 0x400 ) ;                                 ___( psttl ) ;
    {
    while( !etThread )
    // "rcpt to:who@i deafarm.com"

                    st_psttMailRcpt << psttl ;                                                                  psttl = 0 ;
                    pso->writeF( tinP , "250 ok\r\n" ) ;
                    stPhrases << postOldC( tinP , etThread , T("from \"")+T(psttw2)+T("\"") ) ;                    etThread.delF( tinP , psttw2 ) ;
        /*sttq = ze ;*/  boolT bFromIfc = !!etThread.strIdF( tinP , idf , sttq , tAtIdeafarmDotCom , psttw2 ) ;
                    countT idf = 1 ;
        /*sttq = ze ;*/  etThread.strWordF( tinP , psttw2 , psttw , sttq , sttColon , 2 ) ;          ___( psttw2 ) ;   etThread.delF( tinP , psttw ) ;
                    __( etThread.strCompareF( tinP , psttw3 , tFrom ) ) ;                            etThread.delF( tinP , psttw3 ) ;
                    etThread.strConvertToLowerCaseF( tinP , psttw3 , psttw2 ) ;                 ___( psttw3 ) ;   etThread.delF( tinP , psttw2 ) ;
        /*sttq = ze ;*/  etThread.strWordF( tinP , psttw2 , psttw , sttq , sttColon , 1 ) ;          ___( psttw2 ) ;
        /*sttq = ze ;*/  etThread.strWordF( tinP , psttw , psttl , sttq , sttSpace , 2 ) ;           ___( psttw ) ;
                    __( etThread.strCompareF( tinP , psttw2 , tMail ) ) ;                            etThread.delF( tinP , psttw2 ) ;
                    etThread.strConvertToLowerCaseF( tinP , psttw2 , psttw ) ;                  ___( psttw2 ) ;   etThread.delF( tinP , psttw ) ;
        /*sttq = ze ;*/  etThread.strWordF( tinP , psttw , psttl , sttq , sttSpace , 1 ) ;           ___( psttw ) ;
                    pso->readWoLineF( tinP , psttl , 0x400 ) ;                                 ___( psttl ) ;
    // "mail from:who@i deafarm.com"

    stackC st_psttMailRcpt( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;

    pso->writeF( tinP , "250 www.ideafarm.com\r\n" ) ;
    etThread.delF( tinP , psttl ) ;
    /*__( etThread.strCompareF( tinP , psttw2 , tHelo ) ) ;*/ etThread.delF( tinP , psttw2 ) ; //THIS IS NOT DONE CAUSE NETSCAPE SENDS "EHLO" RATHER THAN "HELO"
    etThread.strConvertToLowerCaseF( tinP , psttw2 , psttw ) ; ___( psttw2 ) ; etThread.delF( tinP , psttw ) ;
    etThread.strWordF( tinP , psttw , psttl , sttq , sttSpace , 1 ) ; ___( psttw ) ;
    pso->readWoLineF( tinP , psttl , 0x400 ) ; ___( psttl ) ;
    ZE( strokeS* , psttl ) ;
    // "helo"

    TN( tData             , "data"             ) ;
    TN( tAtIdeafarmDotCom , ifcEMAIL_MXsUFFIX ""    ) ;
    TN( tTo               , "to"               ) ;
    TN( tRcpt             , "rcpt"             ) ;
    TN( tFrom             , "from"             ) ;
    TN( tQuit             , "quit"             ) ;
    TN( tMail             , "mail"             ) ;
    TN( tHelo             , "helo"             ) ;
    strokeS sttDot(   '.' ) ;
    strokeS sttColon( ':' ) ;
    strokeS sttSpace( ' ' ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , psttw3 ) ;
    ZE( strokeS* , psttw2 ) ;
    ZE( strokeS* , psttw ) ;

    pso->writeF( tinP , "220 www.ideafarm.com smtp ready\r\n" ) ;

    b_pbdVarying.ungrabF( tinP ) ;
    }
        TN( t_cHamburgers , "" ) ; t_cHamburgers = TF3(++state.cHamburgers,0,8) ;
        TN( t_idMe        , "" ) ; t_idMe        = TF3(state.idMe,0,8) ;
        stateS& state = *(stateS*)pbdVarying ;
    {
    if( pbdVarying )
    b_pbdVarying.grabF( tinP , TAG( TAGiDnULL ) ) ;

    nicNameC nicNamePeer ;
    stackC stPhrases( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_byteT ) ;

    batonC&      b_pbdVarying  =      *(batonC*)c8p.c2 ;
    byteT*&      pbdVarying    =      *(byteT**)c8p.c1 ;
    count8S&     c8p           =     *(count8S*)cArg ;
{
if( cArg )
TASKdRIVENsERVER( tmcF )

TRANSLATEsTATEdRIVENsERVER_END
    state.idMe ++ ;
TRANSLATEsTATEdRIVENsERVER_MIDDLE
    case 1 : { state.idMe        = stateOther.idMe        ; }
    case 2 : { state.cHamburgers = stateOther.cHamburgers ; }
TRANSLATEsTATEdRIVENsERVER_BEGIN( stateS , 2 )

;
}
    countT cHamburgers ;
    countT idMe ;
    countT idVersion ;
{
struct stateS

/*1*/WAKEhIDE( "port.91.smtp" )/*1*/
/**/
*/
 not edited to use *tinP.zEtScratch rather than etThread
not maintained
obsoleted by b340104 or prior
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

