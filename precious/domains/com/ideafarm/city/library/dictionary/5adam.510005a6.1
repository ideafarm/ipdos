
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

THREADmODE2rESTORE
}
    }
        //++ s ; ether.osSleepF( tinP , TICK * 0x80 ) ;
        //++ s ; ether.osSleepF( tinP , TICK * 0x20 ) ; //PRODUCTION
        //++ s ; ether.osSleepF( tinP , TICK << 3 ) ;
        ++ s ; ether.osSleepF( tinP , TICK ) ;
        //++ s ; ether.osSleepF( tinP , TOCK * 0x40 ) ;
        //++ s ; ether.osSleepF( tinP , TOCK * 0x10 ) ;
        //++ s ; ether.osSleepF( tinP , TOCK * 1 ) ;
        //++ s ; ether.osSleepF( tinP , TUCK * 0x10 ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    
        }
            }
                }
                    /*U*/LOGrAW( "|\r\n" ) ;    
                    while( ~hWalk ) ;
                    }
                        /*U*/LOGrAW( tEntry ) ;
                        tEntry += tBar+tcr ;
                        }
                            pczCursor += 2 ;
                            tEntry += tb8+T(source.postFileTitleF(tinP,source.idFileRankF(tinP,pczCursor[1])))+tcr ;
                            tEntry += tBar+TF3(pczCursor[1],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,7)+T("(")+TF4(pczCursor[0],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,6,0xa)+T(")") ;
                        {
                        while( *pczCursor )
    
                        tEntry += tcr+tBar+tcr ;
    
    
                        }
                            //U::DISPLAY DATA VALUES HERE (NEED TO STORE POINTERS TO THESE IN A SWITCHsTACK)
                        {
                        switch( idType )
    
                        tEntry += (postIdType?T(postIdType):TF3(idType,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)) ;
                        const osTextT* postIdType = processGlobal4S::_processGlobal4I_IF().mapdropNoteType(idType) ;
                        countT   idType = *(pczCursor++) ;
    
                        tEntry +=  TF3(*(pczCursor++),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9) ;
                        const countT* pczCursor = (const countT*)pc3i->c2 ;
                    
                        for( countT offColumn = 1 ; offColumn < CcOLUMNS ; offColumn ++ ) tEntry += TF3((sCountT)(pcCell[offColumn-1]-pcCell[offColumn]),flFORMAT_NObIGITvALUES,9) ;
                                                                                          tEntry += TF3(*pcCell                                         ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9) ;
                        TN( tEntry , "" ) ; tEntry = tBar+TF3((sCountT)pc3i->c1,flFORMAT_NObIGITvALUES,9) ;
                    
                        const countT* pcCell = (const countT*)pc3i->c3 ;
                        const count3S* pc3i = (const count3S*)&stSorted.upF( tinP , hWalk ) ;
                    {
                    do
                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    TN( tBar , "|    " ) ;
                    TN( tb8 , "        " ) ;
                    /*U*/LOGrAW( tTitle ) ;
                    TN( tTitle , "|\r\n| IdeaFarm " "(tm) Piggyback Distributed Operating System <> IPDOS (tm)\r\n| Memory Leakage Report\r\n| Pass " ) ; tTitle += TF2(idPass,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" at ")+TT(timeN1,timeN2)+T("\r\n|\r\n") ;
                    TN( tcr , "\r\n" ) ;
                
                    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT , timeN1 ) ;
                
                    sourceC& source = sourceC::sourceF() ;
                {
                if( stSorted )
                
                }
                    }
                        }
                            stSorted.sinkF( tinP , countTC() , (byteT*)&c3i , flSTACKsINK_null , subtractScoredF ) ;
                            count3S c3i( (countT)scScore , (countT)pczAdamTypeLifiPairs , (countT)pcCell ) ;
                        {
                        if( scScore >= CcOLUMNS >> 1 )
                
                        }
                            else if( pcCell[ offCell - 1 ] < pcCell[ offCell ] ) scScore -- ;
                                 if( pcCell[ offCell - 1 ] > pcCell[ offCell ] ) scScore ++ ;
                        {
                        for( countT offCell = 1 ; offCell < CcOLUMNS ; offCell ++ )
                        ZE( sCountT , scScore ) ;
                
                        countT* pcCell = &(countT&)swCellRow ;
                        pczAdamTypeLifiPairs = (const countT*)swCellRow.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = swCellRow.cFlavorsF( tinP ) ;
                {
                stackC stSorted( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE|flSTACKc_BLOB , 3 * sizeof( countT ) ) ;
                
                }
                    swCapture.freeNullsF( tinP ) ;
                    }
                        else swCapture = 0 ;
                        }
                            pcCell[ idPass - idPassFlavor ] = swCapture ;
                            countT* pcCell = &(countT&)swCellRow ;
                            pczAdamTypeLifiPairs = pczPassAdamTypeLifiPairs + 1 ;
                        {
                        )
                            )
                                idPassFlavor > idPass - CcOLUMNS
                                ||
                                idPass <= CcOLUMNS
                            (
                            &&
                            idPassFlavor <= idPass
                            &&
                            idPassFlavor
                        (
                        if
                        countT idPassFlavor = *pczPassAdamTypeLifiPairs ;
                        pczPassAdamTypeLifiPairs = (const countT*)swCapture.leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = swCapture.cFlavorsF( tinP ) ;
                {
                switchC swCellRow( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pczAdamTypeLifiPairs , 0 , CcOLUMNS * sizeof( countT ) ) ;
                ZE( const countT* , pczAdamTypeLifiPairs ) ;
            {
            if( idPass > CcOLUMNS )
    
            }
                /*U*/LOGrAW( T("[idPass,cbAll,cDrops]       : ")+TF3(idPass,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,0x12)+TF3(cbAll,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TF3(cDrops,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("\r\n") ) ;
                }
                    /*U*/LOGrAW( T("[idPass,cLever_cbSlot,tally]: ")+TF3(idPass,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TF3(cLever_cbSlot,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TF3(cLever_cbSlot*tally,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TF3(tally,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("\r\n") ) ;
    
                    cbAll += cLever_cbSlot * tally ;
                    cDrops += tally ;
                    countT tally = swCaptureTally ;
                    cLever_cbSlot = swCaptureTally.leverF( tinP , idf ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                ZE( countT , cbAll ) ;
                ZE( countT , cDrops ) ;
                /*U*/LOGrAW3( "tally has " , cFlavors , " flavors\r\n" ) ;
                countT cFlavors = swCaptureTally.cFlavorsF( tinP ) ;
            {
            //if( !( idPass % 0x10 ) )
    
            //if( idPass == 2 ) ether.ifcHireF( tinP , T("ifcIDaDAM_ROOTlEAKlOGGER") , 0x4010fff , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ;
    
            }
                PUSE( tinP , *(byteT**)&peCopy ) ;
                }
                    }
                        inspectF( tinP , pczPassAdamTypeLifiPairs , swCapture , cLever_cbSlot , swCaptureTally , peCopy[ offe ].postName , idPass ) ;
        
                        //CONoUTrAW( ostoBuf ) ;
        
                        OStEXTAK( ostoBuf , "\"\r\n" ) ;
                        OStEXTA( ostoBuf , peCopy[offe].postName ) ;
                        OStEXTAK( ostoBuf , " sexC: \"" ) ;
                        OStEXTC( ostoBuf , 1 + offe , ' ' ) ;
                        OStEXT( ostoBuf , TUCK )
                    {
                    if( peCopy[ offe ].cRef )
                {
                for( countT offe = 0 ; offe < CsEXeNTRIES ; offe ++ )
    
                }
                    }
                        }
                            thirdC::c_memcpyIF( tinP , (byteT*)peCopy , (byteT*)pe , cbaCopy ) ;
                            grabitC grabitRegistry( tinP , TAG( TAGiDnULL ) , bits ) ;
                        {
                        if( pe )            
                        sexGlobalEntryS* pe = (sexGlobalEntryS*)( pbNapkin + sizeof( countT ) ) ;
                        byteT& bits = *pbNapkin ;
                    {
                    if( pbNapkin )
                    byteT* pbNapkin = processGlobal8S::_processGlobal8I_IF()._sexC_napGlobalRegistry ;
                {
                if( peCopy )
                sexGlobalEntryS* peCopy = (sexGlobalEntryS*)PUSE.newF( tinP , LF , cbaCopy ) ; ___( peCopy ) ;
                const countT cbaCopy = sizeof( sexGlobalEntryS ) * CsEXeNTRIES ;
            {
    
            swCaptureTally.freeAllF( tinP ) ;
        {
    
        /*U*/LOGrAW3( "LEAK LOGGER pass " , idPass , "\r\n" ) ; //U::
        //CONoUTrAW3( "LEAK LOGGER pass " , idPass , "\r\n" ) ; //U::
    
        ++ idPass ;
    {
    while( !ether )
    ZE( countT , idPass ) ;
    switchC swCapture( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pczPassAdamTypeLifiPairs ) ;
    ZE( const countT* , pczPassAdamTypeLifiPairs ) ;
    
    switchC swCaptureTally( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cLever_cbSlot ) ;
    ZE( countT , cLever_cbSlot ) ;

    puseC puseLeakLogger( tinP , postPOOLlEAKlOGGER ) ;
{
THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP )
    
//etThread.loafIF( tinP ) ; //U:: TO FIND A BUG
    
}
    ether.osThreadAdamF( tinP , idAdamRoot ) ;
    
    else                                          { LOGrAW( "root adam is soixlOld interpreter, so will not fire os on exception\r\n" ) ; } //TO FIND A BUG; REMOVE THIS LINE (ELSE CLAUSE ONLY) IN PRODUCTION
    if( idAdamRoot != ifcIDaDAM_SOIXLoLDiNTERPRETER ) homeS::homeIF().flags |= flHOMEs_FIREoSoNuNHANDLEDeXCEPTION ;
    
    }
        ether.delF( tinP , psttSetting ) ;
        }
            if( idAdamSetting ) idAdamRoot = idAdamSetting ;
            countT idAdamSetting = etThread.strDigitsToSCountF( tinP , psttSetting ) ;
        {
        if( psttSetting )
        etThread.boxGetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF( tinP , psttSetting , T("///d/ideafarm.home.")+TF1(etherC::ifc_idHomeIdisk_IF())+T(".setting.keyValue.idAdamRoot") ) ; ___( psttSetting ) ;
        ZE( strokeS* , psttSetting ) ;
    {
    countT idAdamRoot = ifcIDaDAM_SOIXLoLDiNTERPRETER ;
{

TODO

}
    return cScore ;
    
    countT cScore = pc3i1->c1 - pc3i2->c1 ;

    count3S* pc3i2 = (count3S*)c2P ;
    count3S* pc3i1 = (count3S*)c1P ;

    }
        if( !c1P || !c2P ) return 0 ;
    {
    IFbEcAREFUL
{
countT subtractScoredF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    }
        }
            }
                }
                    //}
                    //    }
                    //        LOGrAWb( "" , 1 + offs , " " , pNote[ offs ].cbUsedReally , " " , pNote[ offs ].cbRequested , " " , cbSlot , " " , ( pNote[ offs ].cbUsedReally * TUCK ) / cbSlot , "\r\n" ) ;
                    //        LOGrAW( bOwned ? "* " : "  " ) ;
                    //        LOGrAW( "[bOwned,idSlot,cbUsedReally,cbRequested,cbSlot]: " ) ;
                    //    {
                    //    if( bOwned )
                    //
                    //    }
                    //        mask = 1 ;
                    //        pbo ++ ;
                    //    {
                    //    if( !mask )
                    //    mask <<= 1 ;
                    //    boolT bOwned = *pbo & mask ;
                    //{
                    //for( countT offs = 0 ; offs < cSlots ; offs ++ )
                    //byteT mask = 1 ;
                    //byteT* pbo = pbBitsOwned ;
                    //const countT cSlots = 1 << pHead->expSlots ;
                    //const countT cbSlot = 1 << pHead->expCbDrop ;

                    }
                        }
                            }
                                }
                                    ++ swCaptureP ;
                                    pczPassAdamTypeLifiPairsP = pczLever ;
                                    *( pcCursor ++ ) = 0 ;
                                    }
                                        }
                                            cLimit -- ;
                                            *( pcCursor ++ ) = pNote[ offs ].pLFnest[ ( offi << 1 ) + 1 ] ;
                                            *( pcCursor ++ ) = pNote[ offs ].pLFnest[   offi << 1       ] ;
                                        {
                                        if( !( F(pNote[offs].pFlagsThreadLevelMode[offi&OFFsLOTtINnESTmAX]) & flTHREADlEVELmODE_DROPnOTEdOESnOTwANTmE ) )
                                        countT offi = ( pNote[ offs ].cNest - offn ) & OFFsLOTtINnESTmAX ;
                                    {
                                    for( countT offn = 0 ; offn < pNote[ offs ].cNest && cLimit ; offn ++ )
                                    countT cLimit = 4 ;
                            
                                    *( pcCursor ++ ) = pNote[ offs ].idiFileTagged ? pNote[ offs ].idiFileTagged : - 1 ;
                                    *( pcCursor ++ ) = pNote[ offs ].idLineTagged  ? pNote[ offs ].idLineTagged  : - 1 ;
                                    *( pcCursor ++ ) = pNote[ offs ].idType ? pNote[ offs ].idType : - 1 ;
                                    *( pcCursor ++ ) = pNote[ offs ].idAdam ;
                                    *( pcCursor ++ ) = idPassP ;
                                    countT* pcCursor = pczLever ;
                                    countT pczLever[ 6 + sizeof pNote->pLFnest / sizeof pNote->pLFnest[ 0 ]  ] ;
                        
                                    ++ swCaptureTallyP ;
                                {
                                else
                                if( !( F(pNote[offs].flagsMonitor) & flOLDlEAKmONITOR_SEENbEFORE ) ) *(flagsT*)&pNote[ offs ].flagsMonitor |= flOLDlEAKmONITOR_SEENbEFORE ;
                            {
                            if( pNote[ offs ].idAdam )
                        {
                        for( countT offs = 0 ; offs < ( 1 << pHead->expSlots ) ; offs ++ )
                    {
                    if( pNote )

                    cLever_cbSlotP = 1 << pHead->expCbDrop ;

                    ;
                        : 0
                        ? (dropNoteS*)( pbBitsOwned + cbaBitsOwned )
                    dropNoteS* pNote = F(pHead->flagsCtCopy) & fliSEXc_NOTES

                    cbaBitsOwned += CBtOaLIGN02( pbBitsOwned + cbaBitsOwned ) ;
                    countT cbaBitsOwned = 1 + ( 1 << pHead->expSlots ) / SB ;

                    byteT* pbBitsOwned = (byteT*)( pHead + 1 ) ;

                    sexHeadS* pHead = (sexHeadS*)pbNapList ;
                {
                if( pbNapList && pbNapData )
                byteT* pbNapData = napData ;
                byteT* pbNapList = napList ;
            {
            else
            if( POOP ) { POOPR }

            THREADmODE1rESTORE
            napkinC napData( tinP , TAG( TAGiDnULL ) , postDataP , 0 , 0 , ifcOPENsHAREDmEMORYhOW_nFeO , flNAPKINc_null , 1 ) ;
            napkinC napList( tinP , TAG( TAGiDnULL ) , postList  , 0 , 0 , ifcOPENsHAREDmEMORYhOW_nFeO , flNAPKINc_null , 1 ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            SCOOPS
        {
        IFsCRATCH

        //LOGrAW( "\"\r\n" ) ;
        //LOGrAW( postList ) ;
        //LOGrAW( "[list]: \"" ) ;

        postList[ 8 ] = 't' ;
        postList[ 7 ] = 's' ;
        postList[ 6 ] = 'i' ;
        postList[ 5 ] = 'l' ;
        thirdC::c_strcpyIF( tinP , postList , postDataP ) ;
    {
    if( thirdC::c_strlenIF( tinP , postDataP ) < sizeof postList )
    //LOGrAW( "\"\r\n" ) ;
    //LOGrAW( postDataP ) ;
    //LOGrAW( "[data]: \"" ) ;

    osTextT postList[ TUCK ] ;
{
voidT inspectF( tinS& tinP , const countT*& pczPassAdamTypeLifiPairsP , switchC& swCaptureP , countT& cLever_cbSlotP , switchC& swCaptureTallyP , const osTextT* const postDataP , const countT idPassP )

#define CcOLUMNS 8

/*1*/WAKEhIDE( "ifcIDaDAM_ROOTlEAKlOGGER.root.leak.logger" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

