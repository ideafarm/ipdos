
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("loafing") ) ;

}
    }
        }
            }
                while( ~hWalkFresh && !ether ) ;
                }
                    etThread.delF( tinP , psttfnFresh ) ;
                    }
                        while( ~hWalkStale && !ether ) ;
                        }
                            etThread.delF( tinP , psttfnStale ) ;
        
                            if( bSameImage && etThread.strCompareF( tinP , psttfnStale , psttfnFresh ) ) etThread.traceF( tinP , tb4+T(psttfnStale) ) ;
        
                            etThread.delF( tinP , pbBufferStale ) ;
                            etThread.delF( tinP , pbBufferFresh ) ;
                            }
                                }
                                    }
                                        }
                                            break ;
                                            bSameImage = 0 ;
                                        {
                                        if( etThread.memCompareF( tinP , pbBufferFresh , pbBufferStale , cbBite ) )
        
                                        __( cbActual != cbBite ) ;
                                        etThread.fileReadF( tinP , pbBufferStale , cbActual , hFileStale ) ;
                                        cbActual = cbBite ;
        
                                        __( cbActual != cbBite ) ;
                                        etThread.fileReadF( tinP , pbBufferFresh  , cbActual , hFileFresh ) ;
                                        countT cbActual = cbBite ;
        
                                        if( was < cbDo ) cbDoHigh -- ;
                                        cbDo -= cbBite ;
                                        countT was = cbDo ;
        
                                        ;
                                                : cbBuffer
                                                ? cbDo
                                            : cbDo < cbBuffer
                                            ? cbBuffer
                                        countT cbBite = cbDoHigh
                                    {
                                    while( cbDo || cbDoHigh )
                                    countT cbDoHigh = pcLever[ 1 ] ;
                                    countT cbDo     = pcLever[ 0 ] ;
                                {
                            {
                            if( pbBufferFresh && pbBufferStale )
                            boolT bSameImage = 1 ;
        
                            etThread.newF( tinP , LF , pbBufferStale , cbBuffer ) ; ___( pbBufferStale ) ;
                            etThread.newF( tinP , LF , pbBufferFresh , cbBuffer ) ; ___( pbBufferFresh ) ;
        
                            ;
                                    : CBmYbUFFER
                                    ? pcLever[ 0 ]
                                : pcLever[ 0 ] < CBmYbUFFER
                                ? CBmYbUFFER
                            const countT cbBuffer = pcLever[ 1 ]
                            ZE( byteT* , pbBufferStale ) ;
                            ZE( byteT* , pbBufferFresh  ) ;
        
                            etThread.fileOpenF( tinP , hFileStale , countTC() , tPathStale+T(psttfnStale) ) ;
                            etThread.fileOpenF( tinP , hFileFresh , countTC() , tPathFresh+T(psttfnFresh) ) ;
                            handleC hFileStale( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                            handleC hFileFresh( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
        
                            { byteT* pbzEncodedStale = (byteT*)swsStale.downF( tinP , hWalkStale ) ; etThread.strDecodeF( tinP , psttfnStale , pbzEncodedStale ) ; } ___( psttfnStale ) ;
                            ZE( strokeS* , psttfnStale ) ;
                        {
                        do
                        handleC hWalkStale( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        
                        etThread.traceF( tinP , tRename+T(psttfnFresh) ) ;
                    {
                    if( swsStale && !bFound )
        
                    }
                        while( ~hWalkStale && !ether && !bFound ) ;
                        }
                            etThread.delF( tinP , psttfnStale ) ;
        
                            if( bSameImage && !etThread.strCompareF( tinP , psttfnStale , psttfnFresh ) ) bFound = 1 ;
        
                            etThread.delF( tinP , pbBufferStale ) ;
                            etThread.delF( tinP , pbBufferFresh ) ;
                            }
                                }
                                    }
                                        break ; // FOR SPEED, I ASSUME THAT FILES ARE IDENTICAL IF THE WOTH CBmYbUFFER OF BYTES IS IDENTICAL ; TO ELIMINATE THIS ASSUMPTION AND DO A FULL TEST, COMMENT OUT THIS LINE

                                        }
                                            break ;
                                            bSameImage = 0 ;
                                        {
                                        if( etThread.memCompareF( tinP , pbBufferFresh , pbBufferStale , cbBite ) )
        
                                        __( cbActual != cbBite ) ;
                                        etThread.fileReadF( tinP , pbBufferStale , cbActual , hFileStale ) ;
                                        cbActual = cbBite ;
        
                                        __( cbActual != cbBite ) ;
                                        etThread.fileReadF( tinP , pbBufferFresh  , cbActual , hFileFresh ) ;
                                        countT cbActual = cbBite ;
        
                                        if( was < cbDo ) cbDoHigh -- ;
                                        cbDo -= cbBite ;
                                        countT was = cbDo ;
        
                                        ;
                                                : cbBuffer
                                                ? cbDo
                                            : cbDo < cbBuffer
                                            ? cbBuffer
                                        countT cbBite = cbDoHigh
                                    {
                                    while( cbDo || cbDoHigh )
                                    countT cbDoHigh = pcLever[ 1 ] ;
                                    countT cbDo     = pcLever[ 0 ] ;
                                {
                            {
                            if( pbBufferFresh && pbBufferStale )
                            boolT bSameImage = 1 ;
        
                            etThread.newF( tinP , LF , pbBufferStale , cbBuffer ) ; ___( pbBufferStale ) ;
                            etThread.newF( tinP , LF , pbBufferFresh , cbBuffer ) ; ___( pbBufferFresh ) ;
        
                            ;
                                    : CBmYbUFFER
                                    ? pcLever[ 0 ]
                                : pcLever[ 0 ] < CBmYbUFFER
                                ? CBmYbUFFER
                            const countT cbBuffer = pcLever[ 1 ]
                            ZE( byteT* , pbBufferStale ) ;
                            ZE( byteT* , pbBufferFresh  ) ;
        
                            etThread.fileOpenF( tinP , hFileStale , countTC() , tPathStale+T(psttfnStale) ) ;
                            etThread.fileOpenF( tinP , hFileFresh , countTC() , tPathFresh+T(psttfnFresh) ) ;
                            handleC hFileStale( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                            handleC hFileFresh( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
        
                            { byteT* pbzEncodedStale = (byteT*)swsStale.downF( tinP , hWalkStale ) ; etThread.strDecodeF( tinP , psttfnStale , pbzEncodedStale ) ; } ___( psttfnStale ) ;
                            ZE( strokeS* , psttfnStale ) ;
                        {
                        do
                        handleC hWalkStale( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( swsStale )
                    ZE( boolT , bFound ) ;
        
                    { byteT* pbzEncodedFresh = (byteT*)swsFresh.downF( tinP , hWalkFresh ) ; etThread.strDecodeF( tinP , psttfnFresh , pbzEncodedFresh ) ; } ___( psttfnFresh ) ;
                    ZE( strokeS* , psttfnFresh ) ;
                {
                do
                handleC hWalkFresh( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        
                //etThread.traceF( tinP , T("[cRem,cbLo,cbHi,cf]: ")+TF2(cFlavors-idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb1+TF2(pcLever[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb1+TF2(pcLever[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb1+TF2(swsFresh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            if( swsFresh )
        
            if( !pcLever[ 0 ] && !pcLever[ 1 ] ) continue ;
        
            etThread.memCopyF( tinP , (byteT*)pcLever , (byteT*)swsFresh.leverF( tinP , idf ) , sizeof pcLever ) ;
        {
        for( countT idf = 1 ; !ether && idf <= cFlavors ; idf ++ )
        countT cFlavors = swsFresh.cFlavorsF( tinP ) ;
        
        TN( tRename , "ren " ) ;
        
        // 
        //     PRINT NAME
        //    IF CONTENT MATCHES AND NAME IS DIFFERENT
        //   FOR EACH STALE FILE OF SAME SIZE
        //   PRINT NAME
        //  IF !bFound
        //   IF CONTENT MATCHES AND NAME MATCHES SET bFound
        //  FOR EACH STALE FILE OF SAME SIZE
        // FOR EACH FRESH FILE
        // 
        // RECIPE
        // 
        
        }
            else          etThread.traceF( tinP , T("fresh    [cFiles,cSizes,filesPerSize]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(swsFresh.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cFiles/swsFresh.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            if( !cFiles ) etThread.traceF( tinP , T("fresh: no files") ) ;
        
        
            while( ~hFind && !ether ) ;
            }
                DEL( pInfo ) ;
                }
                    swsFresh << pbEncoded ; pbEncoded = 0 ;
                    pcLever[ 1 ] = pInfo->cbUsedHigh ;
                    pcLever[ 0 ] = pInfo->cbUsed     ;
        
                    etThread.delF( tinP , psttShort ) ;
                    etThread.strEncodeF( tinP , pbEncoded , psttShort ) ; ___( pbEncoded ) ;
                    ZE( byteT* , pbEncoded ) ;
        
                    if( !( ( ++ cFiles ) % ( TUCK << 4 ) ) ) etThread.traceF( tinP , psttShort ) ;
        
                    }
                        etThread.delF( tinP , psttPath ) ;
                        ___( psttShort ) ;
                        ___( psttPath  ) ;
                        etThread.strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                        ZE( strokeS* , psttPath ) ;
                    {
                    ZE( strokeS* , psttShort ) ;
                {
                )
                    pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ] != '/'
                    &&
                    !etThread.strIdF( tinP , tSlashDotDotSlash , pInfo->psttIfoName )
                    &&
                    !etThread.strIdF( tinP , tSlashDotSlash , pInfo->psttIfoName )
                    &&
                    pInfo
                (
                if
                etThread.diskFindFileOrDirOldF( tinP , pInfo , hFind , tLike ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            do
            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            ZE( countT , cFiles ) ;
            TN( tDistinct         , "distinct" ) ;
            TN( tInspecting       , "inspecting " ) ;
            TN( tSlash            , "/" ) ;
            TN( tSlashDotSlash    , "/./" ) ;
            TN( tSlashDotDotSlash , "/../" ) ;
            TN( tLike , "" ) ; tLike = tPathFresh+tPattern ;
        {
        switchStackC swsFresh( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pbLever , sizeof pcLever , flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY , ifcSTACKtYPE_PTR_byteT ) ;
        TN( tPathFresh , "///d/ideafarm.home.101/IdeaFarm (tm)/SYSTEM/Drop Files Here To Archive/" ) ;
        etThread.traceF( tinP , T("loading fresh") ) ;
        
        }
            else          etThread.traceF( tinP , T("stale    [cFiles,cSizes,filesPerSize]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(swsStale.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cFiles/swsStale.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            if( !cFiles ) etThread.traceF( tinP , T("stale: no files") ) ;
        
            while( ~hFind && !ether ) ;
            }
                DEL( pInfo ) ;
                }
                    swsStale << pbEncoded ; pbEncoded = 0 ;
                    pcLever[ 1 ] = pInfo->cbUsedHigh ;
                    pcLever[ 0 ] = pInfo->cbUsed     ;
        
                    etThread.delF( tinP , psttShort ) ;
                    etThread.strEncodeF( tinP , pbEncoded , psttShort ) ; ___( pbEncoded ) ;
                    ZE( byteT* , pbEncoded ) ;
        
                    if( !( ( ++ cFiles ) % ( TUCK << 4 ) ) ) etThread.traceF( tinP , psttShort ) ;
        
                    }
                        etThread.delF( tinP , psttPath ) ;
                        ___( psttShort ) ;
                        ___( psttPath  ) ;
                        etThread.strBisectF( tinP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                        ZE( strokeS* , psttPath ) ;
                    {
                    ZE( strokeS* , psttShort ) ;
                {
                )
                    pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ] != '/'
                    &&
                    !etThread.strIdF( tinP , tSlashDotDotSlash , pInfo->psttIfoName )
                    &&
                    !etThread.strIdF( tinP , tSlashDotSlash , pInfo->psttIfoName )
                    &&
                    pInfo
                (
                if
                etThread.diskFindFileOrDirOldF( tinP , pInfo , hFind , tLike ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            do
            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            ZE( countT , cFiles ) ;
            TN( tDistinct         , "distinct" ) ;
            TN( tInspecting       , "inspecting " ) ;
            TN( tSlash            , "/" ) ;
            TN( tSlashDotSlash    , "/./" ) ;
            TN( tSlashDotDotSlash , "/../" ) ;
            TN( tLike , "" ) ; tLike = tPathStale+tPattern ;
        {
        switchStackC swsStale( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pbLever , sizeof pcLever , flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY , ifcSTACKtYPE_PTR_byteT ) ;
        TN( tPathStale , "///d/ideafarm.home.101/IdeaFarm (tm)/SYSTEM/arc.b4.clean/" ) ;
        etThread.traceF( tinP , T("loading stale") ) ;
        
        const byteT* pbLever = (byteT*)pcLever ;
        countT pcLever[] = { 0 , 0 } ;
        TN( tb4 , "    " ) ;
        TN( tb1 , " " ) ;
        TN( tc , ":" ) ;
        
        //TN( tPattern , "*" ) ;

        etThread.traceF( tinP , T("[pattern]:    ")+tPattern ) ;
        TN( tPattern , "!ideafarm.6." ) ; tPattern += TF4(year,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObASE,4,0xa)+TF4(month,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObASE,2,0xa)+T("*") ;
    {
    for( countT month = 1 ; month <= 12 ; month ++ )
{
for( countT year = 1990 ; year <= 2015 ; year ++ )

TODO

#define CBmYbUFFER ( TOCK << 0 )

/*1*/WAKEsHOWtEXT( "tool.archive.report.name.changes" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

