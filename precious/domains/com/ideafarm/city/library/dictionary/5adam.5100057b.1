
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

THREADmODE2rESTORE0( flagsSave )
}
    THREADmODE2oN0( flTHREADmODE2_UNLOCKpOOLiDENTITY )
    THREADmODE2sAVE0( flagsSave )
    ether.loafIF( tinP ) ;

    httpServerC server( tinP , arg1 , arg2 ) ;

    //U:: ENABLE AFTER REWRITE DATABASE SUBSYSTEMS FOR BILLING:: arg2.pHttpFreshenCacheCBF = httpFreshenCacheCBF ;
    httpServerC_arg2S arg2 ;
    httpServerC_arg1S arg1( TAG( TAGiDnULL ) , etThread , ifcPORToLD2_HTTP , cArgApp , T("World Wide Web") ) ;

    countT cArgApp = (countT)&c8p ;
    count8S c8p( /*(countT)&pusePeanut*/0 , (countT)&booksSurvey , (countT)&cLeverPassword , (countT)&swsUnconfirmedPeerDeleteEmailZipCountryByPassword ) ;

    switchStackC swsUnconfirmedPeerDeleteEmailZipCountryByPassword( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , cLeverPassword , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS , ifcIDgRABlAYER_7BASEmISC1 ) ;
    ZE( countT , cLeverPassword ) ;

    booksC booksSurvey( tinP , TAG( TAGiDnULL ) , "survey1" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER , TOCK ) ;

    //THREADmODE2rESTORE0( flagsSave )
    //puseC puse( tinP , ifcIDpOOL_ADAMtEMP ) ;
    //puseC pusePeanut( tinP , "list.lath.peanut" , flPOOLc_null , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
    //THREADmODE2oN0( flTHREADmODE2_UNLOCKpOOLiDENTITY )
    //THREADmODE2sAVE0( flagsSave )
    //20120901: COMMENTED OUT TO GET THIS TO WORK
{
ZE( flagsT , flagsSave ) ;

TODO

}
    _OUT_
    TELL( "returning" )

    }
        if( POOP ) { POOPR ; }

        TELL( "cleaning up 1" )
        }
            TELL( "cleaning up 2" )
            etThread.beeClickF( tinP ) ;
    
            TELL( "cleaning up 3.0" )
            etThread( tinP , pSwsAccount ) ;
            TELL( "cleaning up 3.1" )
            etThread( tinP , pSwsCities ) ;
            TELL( "cleaning up 3.2" )
            etThread( tinP , pStkIdAcc ) ;
            TELL( "cleaning up 3.3" )
            }
                TELL( "cleaning up 4" )
                }
                    etThread.delF( tinP , pstt1Zips ) ;
                    TELL( "cleaning up 5" )
        
                    }
                        TELL( "cleaning up 6" )
                        meP.storeSnipF( tinP , T("zip.list") , *(const osTextT**)&postsZips ) ;
                        thirdC::c_memcpyIF( tinP , (byteT*)pcc , (byteT*)pstt1Zips , cbImage ) ;
                        *pcc = cbImage ; pcc ++ ; //CLIENT CODE CAN VALIDATE THIS BY COMPARING WITH CALCULATED IMAGE SIZE TO ENSURE THAT IT IS INTERPRETING THE BYTES CORRECTLY AS A STROKE STRING
                        *pcc = 0       ; pcc ++ ;
                        countT* pcc = (countT*)postsZips ;
                        PUSE.newF( tinP , LF , postsZips , sizeof( countT ) * 2 + cbImage ) ; ___( postsZips ) ;
                        ZE( osTextT* , postsZips ) ;
                        countT cbImage = sizeof( strokeS ) * ( CSpREFIX + pstt1Zips->idAdam ) ;
                        TELL( "storing zips list snip" )
                    {
        
                    }
                        meP.storeSnipF( tinP , T("zip.click.")+T(psttzLeverZip) , tClick ) ;
                        meP.storeSnipF( tinP , T("zip.show.")+T(psttzLeverZip)  , tShow  ) ;
                        TELL( "storing the show and click snip pair" )
        
                        }
                            tClick += tPara ;
                            tShow  += tPara ;
                            while( ~hWalk ) ;
                            }
                                DELzOMBIE( pzInfo ) ;
        
                                ;
        
                                    + T(psttCRLF)
                                      T(pzInfo->psttAddressName)
        
                                tShow +=
        
                                ;
        
                                    + T(psttCRLF)
                                    + T("</A>")
                                    + T(pzInfo->psttAddressName)
                                    + T("\">")
                                    + TF2(pzInfo->idAcc,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)
                                      T("<A HREF=\"/nobot/action/obeyDirectoryClick.html?idaccclickee=")
        
                                tClick +=
            
                                accountS* pzInfo = (accountS*)&pSwsAccount->downF( tinP , hWalk ) ;
                            {
                            do
                            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            __( !*pSwsAccount ) ;
            
                            tClick = tAllHead ;
                            tShow  = tAllHead ;
                            TN( tAllHead , "" ) ; tAllHead = T("<SPAN CLASS=spaXXSmall STYLE=\"color:" ifcCOLORhTMLwHAT_FOREnOTEnORMAL "\"><I><U>")+T(psttzLeverZip)+T(": ")+tHead+T("</U></I></SPAN>") ;
            
                            tHead += T("\r\n<P>\r\n") ;
                            }
                                PUSE( tinP , *(byteT**)&psttw ) ;                
                                tHead += ( tHead.csF( tinP ) ? tSep : tNull )+T(psttw) ;
                                *pSwsCities >> psttw ;
                                ZE( strokeS* , psttw ) ;
                            {
                            while( *pSwsCities )
                            TN( tPara , "\r\n<P>\r\n" ) ;
                            TN( tSep , " , " ) ;
                            TN( tNull , "" ) ;
                            TN( tHead , "" ) ;
                        {
                        TN( tClick , "" ) ;
                        TN( tShow  , "" ) ;
                        TELL( "building the show and click snip pair" )
        
                        etThread.strFuseSeparateF( tinP , pstt1Zips , psttzLeverZip ) ;
                        TELL( "allocating the zip list string" )
        
                        psttzLeverZip = (strokeS*)pSwsCities->leverF( tinP , idf ) ;
                        TELL( "setting the zip lever" )
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    cFlavors = pSwsCities->cFlavorsF( tinP ) ;
                    TELL( "tasting the zip flavors" )
        
                    etThread.strMakeF( tinP , pstt1Zips , 0 , csttaZips ) ; ___( pstt1Zips ) ;
                    ZE( strokeS* , pstt1Zips ) ;
                    TELL( "allocating the zip list string 2" )
        
                    }
                        if( psttzLeverZip ) csttaZips += CSpREFIX + psttzLeverZip->idAdam ;
                        psttzLeverZip = (strokeS*)pSwsCities->leverF( tinP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = pSwsCities->cFlavorsF( tinP ) ;
                    ZE( countT , csttaZips ) ;
                    TELL( "counting the size needed for the zip list string" )
        
                    }
                        }
                            }
                                TELL( "deleted account info" )
                                DELzOMBIE( pzInfo ) ;
                                accountS* pzInfo = (accountS*)pbInfoTmp ;
                                TELL( "deleting account info" )
                            {
                            if( bDelete )
                            TELL( "deleting acct info if" )
        
                            }
                                }
                                    if( !ids ) PUSE( tinP , *(byteT**)&psttw ) ;                
                                    pSwsCities->sinkF( tinP , ids , psttw , flSTACKsINK_UNIQUE ) ;
                                    etThread.strMakeF( tinP , psttw , info.psttAddressCity  ) ; ___( psttw ) ;
                                    ZE( strokeS* , psttw ) ;
                                    ZE( countT , ids ) ;
                                    TELL( "sinking city" )
        
                                    bDelete = 0 ;
                                    thirdC::c_memcpyIF( tinP , (byteT*)&(*pSwsAccount)[ 1 ] , pbInfoTmp , sizeof pbInfoTmp ) ;
                                    *pSwsAccount << (byteT*)0 ;
                                    TELL( "copying account info to switchstack plate" )
        
                                    psttzLeverZip = info.psttAddressZip ;
                                    TELL( "setting zip lever 2" )
                                {
                                if( bOk )
                                TELL( "storing account info and city info if" )
            
                                ;
                    
                                    && ( etThread.strCompareF( tinP , info.psttAddressName , T("Antony Bergmann") ) || etThread.strCompareF( tinP , info.psttAddressZip , T("94401") ) )
                                    && ( etThread.strCompareF( tinP , info.psttAddressName , T("Ruby Unknown"   ) ) || etThread.strCompareF( tinP , info.psttAddressZip , T("94040") ) )
                                    && ( etThread.strCompareF( tinP , info.psttAddressName , T("Robb Mitchell"  ) ) || etThread.strCompareF( tinP , info.psttAddressZip , T("94040") ) )
                                    && ( etThread.strCompareF( tinP , info.psttAddressName , T("William Andyman") ) || etThread.strCompareF( tinP , info.psttAddressZip , T("94040") ) )
                                    && ( etThread.strCompareF( tinP , info.psttAddressName , T("Dean Hart"      ) ) || etThread.strCompareF( tinP , info.psttAddressZip , T("94040") ) )
                                    && ( etThread.strCompareF( tinP , info.psttAddressName , T("Robert Brown"   ) ) || etThread.strCompareF( tinP , info.psttAddressZip , T("94541") ) )
                                       ( etThread.strCompareF( tinP , info.psttAddressName , T("Jeffrey Froning") ) || etThread.strCompareF( tinP , info.psttAddressZip , T("94040") ) )
                    
                                boolT bOk =
                                TELL( "setting bOk to exclude listed people" )
                            {
                            )
                                //!etThread.strIdF( tinP , tNo7 , info.psttAddressName )
                                //!etThread.strIdF( tinP , tNo6 , info.psttAddressName ) &&
                                //!etThread.strIdF( tinP , tNo5 , info.psttAddressName ) &&
                                //!etThread.strIdF( tinP , tNo4 , info.psttAddressName ) &&
                                //!etThread.strIdF( tinP , tNo3 , info.psttAddressName ) &&
                                //!etThread.strIdF( tinP , tNo2 , info.psttAddressName ) &&
                                //!etThread.strIdF( tinP , tNo1 , info.psttAddressName ) &&
                                F(info.flagsMode) & fliACCOUNTmODE_LISTmEdIRECTORY     /*&&*/
                            (
                            if
                            TELL( "inspecting list me flag" )
        
                            boolT bDelete = 1 ;
        
                            accountS& info = *(accountS*)pbInfoTmp ;
                            new( 0 , tinP , pbInfoTmp , sizeof pbInfoTmp ) accountS( tinP , etThread , idAcc , flACCOUNT1_null , flACCOUNT2_QUERYfLAGSmODE | flACCOUNT2_QUERYaDDRESScOUNTRYcODE | flACCOUNT2_QUERYaDDRESSzIP | flACCOUNT2_QUERYaDDRESScITY | flACCOUNT2_QUERYaDDRESSnAME | flACCOUNT2_QUERYrESIDENCEcOUNTRY | flACCOUNT2_QUERYzIPaT ) ;
                            byteT pbInfoTmp[ sizeof( accountS ) ] ;
                            TELL( "obtaining account info into temp buffer" )
        
                            *pStkIdAcc >> idAcc ;
                            ZE( countT , idAcc ) ;
                            TELL( "popping an idAcc" )
                        {
                        while( *pStkIdAcc )
                        TELL( "popping all idAcc values" )
                    {
                    if( *pStkIdAcc )
                    TELL( "popping all idAcc values if" )
            
                    TN( tNo7 , "Antony Bergmann" ) ; // US <> 95128 <> San Jose <> Brian Shura <> US
                    TN( tNo6 , "Brian Shura" ) ; // US <> 95128 <> San Jose <> Brian Shura <> US
                    TN( tNo5 , "Christina Palmer" ) ; // US <> 94040 <> Mountain View <> Christina Palmer <> US
        
                    TN( tNo4 , "Timur Mukminov" ) ; // US <> 94040 <> Mountain View <> Timur Mukminov <> US
                    TN( tNo3 , "Test Account" ) ; // US <> 33166 <> Miami <> Test Account <> US
                    TN( tNo2 , "Gigi Williams" ) ; // US <> 94025 <> Menlo Park <> Gigi Williams <> US
                    TN( tNo1 , "Carol Brouillet" ) ; // US <> 94306 <> Palo Alto <> Carol Brouillet <> US
        
                    strokeS* psttPara = tp ;
                    TN( tp    , "<P>\r\n" ) ;
                    strokeS* psttCRLF = tcr ;
                    TN( tcr    , "<BR>\r\n" ) ;
                    strokeS* psttSep = tSep ;
                    TN( tSep , " <> " ) ;
                    TELL( "setting up to get acct info" )
                {
                if( !POOP )
                TELL( "testing poop after getting idAcc enumeration" )
        
                }
                    *pStkIdAcc << idAcc ;
                    sIn >> idAcc ;
                    ZE( countT , idAcc ) ;
                {
                while( cIdAccount -- )
                TELL( "stacking idAcc" )
            
                //CONoUTrAW3( "[cIdAccount]: " , cIdAccount , "\r\n" ) ;
                sIn >> cIdAccount ;
                ZE( countT , cIdAccount ) ;
                TELL( "pulling cIdAccount" )
            
                __( idFormat - 1 ) ;
                sIn >> idFormat ;
                ZE( countT , idFormat ) ;
                TELL( "pulling idFormat" )
                
                __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
                sIn >> finger ;
                ZE( countT , finger ) ;
                TELL( "pulling finger" )
                
                sock.readF( tinP , sIn ) ;
                TELL( "reading sIn" )
                soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
                TELL( "ct sIn" )
                
                sock.writeF( tinP , sOut ) ;
                TELL( "writing sOut" )
                sOut << (countT)ifcIDcMDlISTsERVERiDaCCOUNTdESCRIPTION_ENUMERATEiDaCCOUNT ;
                sOut << (countT)1 ;
                sOut << (countT)FINGERnEG_LISTsERVERcMD ;
                soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
                TELL( "ct sOut" )
                
                sock.connectF( tinP , homeS::homeIF().idPortListServerIdAccountDescription ) ;
                TELL( "connecting" )
                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
                TELL( "cting sock" )
            {
            if( pStkIdAcc && pSwsCities && pSwsAccount )
            
            etThread( tinP , pSwsAccount , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , psttzLeverZip , flSTACKc_ALLOWzE | flSTACKc_BLOB | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , sizeof( accountS ) ) ; ___( pSwsAccount ) ;
            ZE( switchStackC* , pSwsAccount ) ;
    
            etThread( tinP , pSwsCities , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , psttzLeverZip , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , ifcSTACKtYPE_PTR_strokeS ) ; ___( pSwsCities ) ;
            ZE( switchStackC* , pSwsCities ) ;
    
            ZE( strokeS* , psttzLeverZip ) ;
    
            etThread( tinP , pStkIdAcc , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_XRAY ) ; ___( pStkIdAcc ) ;
            ZE( stackC* , pStkIdAcc ) ;
            TELL( "setting up recyclables" )
        {
        if( !bQuitP && !bCleanupP )

        SCOOPS
    {
    IFsCRATCH
    _INoLD_
{
voidT httpFreshenCacheCBF( tinS& tinP , etherC& etThread , const boolT& bQuitP , httpServerC& meP , sessionsC& sessionsP , countT& cArgP , const boolT bCleanupP )

//OBSOLETES c750104, WHICH WAS A QUICK HACK TO GET THE WEB SITE UP

/*1*/WAKEhIDE( "ifcIDaDAM_ROOThTTPsERVER" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

