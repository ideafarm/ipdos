
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    etThread.delF( tinP , pbi ) ;

    thirdC::logIF( tinP , T("==== END ========================================================================================================================") ) ;
    }
        pbc += sizeof( rHeaderS ) + rHeader.cbData ;

        }
            default : { break ; }
            }
                break ;
                logLabelsF( tinP , pbData , (byteT*)&header ) ;
                pbData += sizeof( count01T ) ;
                thirdC::logIF( tinP , T("mx server rank: ")+TF1(cRank) ) ;
                countT cRank = *(count01T*)pbData ;
            {
            case 0xf : //MX
            }
                break ;
                logLabelsF( tinP , pbData , (byteT*)&header ) ;
            {
            case 0x2 : //NS
            }
                break ;
                thirdC::logIF( tinP , T("host address: ")+T(idh) ) ;
                nicNameC idh( SWAB4( *(countT*)pbData ) ) ;
            {
            case 0x1 : //A
        {
        switch( rHeader.idType )
        byteT* pbData = pbc + sizeof rHeader ;

        rHeader.logF( tinP ) ;
        rHeader.swabF() ;
        rHeaderS& rHeader = *(rHeaderS*)pbc ;
        logLabelsF( tinP , pbc , (byteT*)&header ) ;

        }
            thirdC::logIF( tinP , T(postSep) ) ;
            else if( cNote && cNote -- ) postSep = "==== NOTE =====================================================================================================================" ;
            else if( cAuth && cAuth -- ) postSep = "==== AUTHORITY ================================================================================================================" ;
                 if( cAnsw && cAnsw -- ) postSep = "==== ANSWER ===================================================================================================================" ;
            ZE( osTextT* , postSep ) ;
        {
    {
    while( cResources -- )

    countT cNote = header.cNotes       ;
    countT cAuth = header.cAuthorities ;
    countT cAnsw = header.cAnswers     ;

    countT cResources = header.cAnswers + header.cAuthorities + header.cNotes ;
    pbc = pbi + sizeof( headerS ) + sizeof( questionS ) ;

    question.logF( tinP ) ;
    logLabelsF( tinP , pbc , (byteT*)&header ) ;
    thirdC::logIF( tinP , T("==== QUESTION =================================================================================================================") ) ;
    question.swabF() ;
    questionS& question = *(questionS*)pbc ;
    pbc = pbi + sizeof( headerS ) ;

    header.logF( tinP ) ;
    thirdC::logIF( tinP , T("==== HEADER =================================================================================================================") ) ;
    header.swabF() ;

    headerS& header = *(headerS*)pbi ;

    }
        so.readF( tinP , pbi , cbi , idPort , nicName ) ; ___( pbi ) ;
        nicNameC nicName ;
        ZE( countT , idPort ) ;

        query.swabF() ;
        so.writeF( tinP , 0x35 , so.nicNameF( tinP , etThread , T("NS4.BAYAREA.NET") ) , (byteT*)&query , sizeof query ) ;
        query.swabF() ;
        so.bindF( tinP ) ;
        socketC so( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

        query.logF( tinP ) ;

        }
            query.question.pbLabels[ off ] = 0 ;                                                                                                                 off +=   1 ;
            query.question.pbLabels[ off ] = 3 ; thirdC::c_memcpyIF( tinP , query.question.pbLabels + off + 1 , "com"       , query.question.pbLabels[ off ] ) ; off +=   4 ;
            query.question.pbLabels[ off ] = 9 ; thirdC::c_memcpyIF( tinP , query.question.pbLabels + off + 1 , "chevrolet" , query.question.pbLabels[ off ] ) ; off += 0xa ;
            ZE( countT , off ) ;
        {

        queryS query ;
    {
    ZE( byteT* , pbc ) ;
    ZE( countT , cbi ) ;
    ZE( byteT* , pbi ) ;
{

TODO

}
    question.swabF() ;
    header.swabF() ;
{
voidT queryS::swabF( voidT )

}
    question.logF( tinP ) ;
    logLabelsF( tinP , pbc , (byteT*)&header ) ;
    byteT* pbc = (byteT*)&header + sizeof( headerS ) ;
    header.logF( tinP ) ;
{
voidT queryS::logF( tinS& tinP )

}
    cbData        = SWAB2( cbData        ) ;
    secondsToLive = SWAB4( secondsToLive ) ;
    idClass       = SWAB2( idClass       ) ;
    idType        = SWAB2( idType        ) ;
{
voidT rHeaderS::swabF( voidT )

}
    thirdC::logIF( tinP , T("question: idType: ")+TF1(idType)+T(" idClass: ")+TF1(idClass) ) ;
{
voidT questionS::logF( tinS& tinP )

}
    idClass = SWAB2( idClass ) ;
    idType  = SWAB2( idType  ) ;
{
voidT questionS::swabF( voidT )

}
    cNotes       = SWAB2( cNotes       ) ;
    cAuthorities = SWAB2( cAuthorities ) ;
    cAnswers     = SWAB2( cAnswers     ) ;
    cQuestions   = SWAB2( cQuestions   ) ;
    idQuery      = SWAB2( idQuery      ) ;
{
voidT headerS::swabF( voidT )

}
{
idClass( 1 )
idType( 0xf ) ,  //MX
questionS::questionS( voidT ) :

}
    thirdC::logIF( tinP , T("header: cQuestions: ")+TF1(cQuestions)+T(" cAnswers: ")+TF1(cAnswers)+T(" cAuthorities: ")+TF1(cAuthorities)+T(" cNotes: ")+TF1(cNotes) ) ;
{
voidT headerS::logF( tinS& tinP )

}
{
cNotes( 0 )
cAuthorities( 0 ) ,
cAnswers( 0 ) ,
cQuestions( 1 ) ,
idError( 0 ) ,
reserved1( 0 ) ,
bCanRecurse( 0 ) ,
bPleaseRecurse( 0 ) ,
bTruncated( 0 ) ,
bAuthoritative( 0 ) ,
idType( 0 ) ,
bQuery( 1 ) ,
idQuery( ++ idQueryLast ) ,
headerS::headerS( voidT ) :

count01T headerS::idQueryLast ;

}
    thirdC::logIF( tinP , T("rHeader: idType: ")+TF1(idType)+T(" idClass: ")+TF1(idClass)+T(" secondsToLive: ")+TF1(secondsToLive)+T(" cbData: ")+TF1(cbData) ) ;
{
voidT rHeaderS::logF( tinS& tinP )

}
{
cbData( 0 )
secondsToLive( 0 ) ,
idClass( 0 ) ,
idType( 0 ) ,
rHeaderS::rHeaderS( voidT ) :

}
    if( osto.costF() ) thirdC::logIF( tinP , T("label portion: \"")+T(osto001)+T("\"") ) ;

    }
        }
            }
                break ;
                pbP ++ ;
            {
            if( !*pbP )

            OStEXTAK( osto001 , "." )
            OStEXTAL( osto001 , pbLabel , cbLabel )

            osTextT* pbLabel =  pbP ; pbP += cbLabel ;
            countT   cbLabel = *pbP ; pbP += 1 ;
        {
        else
        else if( *pbP & 0xc0 ) thirdC::logIF( tinP , T("error: label is too long") ) ;
        }
            break ;
            pbP += 2 ;
            logLabelsF( tinP , pbr , pbOriginP ) ;
            byteT* pbr = pbOriginP + ( SWAB2( *(count01T*)pbP ) & ~0xc000 ) ;
            if( osto.costF() ) thirdC::logIF( tinP , T("label portion before compressed portion: \"")+T(osto001)+T("\"") ) ;
        {
        if( ( *pbP & 0xc0 ) == 0xc0 )
    {
    for(;;) // ASSUME: *pbP IS INITIALLY NOT 0. CODE STRUCTURE REFLECTS NONCOMPRESSED, NULL TERMINATED FORMAT. COMPRESSION CODE ASSUMED TO ONLY OCCUR AT END (PER RFC SPEC)
    OStEXT( osto001 , 0x100 )
{
voidT logLabelsF( tinS& tinP , byteT*& pbP , byteT* const pbOriginP )
*/
  must point to the beginning of the header record for the message being parsed
 pbOriginP
  will point to the end of the label
  must point to the beginning of the label
 pbP
arguments
/*

;
}
    voidT swabF( voidT ) ;
    voidT logF( tinS& tinP ) ;
    questionS question ;
    headerS   header ;
{
struct queryS

;
}
    voidT swabF( voidT ) ;
    voidT logF( tinS& tinP ) ;
    rHeaderS( voidT ) ;

    count01T cbData ;
    countT    secondsToLive ;
    count01T idClass ;
    count01T idType ;
{
struct rHeaderS //THIS IS THE PART OF THE "RESOURCE RECORD" THAT FOLLOWS THE LABELS FOR THE RESOURCE

;
}
    voidT swabF( voidT ) ;
    voidT logF( tinS& tinP ) ;
    questionS( voidT ) ;

    count01T           idClass             ;
    count01T           idType              ;
    byteT               pbLabels[ 0xf ]     ;
{
struct questionS

;
}
    voidT swabF( voidT ) ;
    voidT logF( tinS& tinP ) ;
    headerS( voidT ) ;

    count01T           cNotes              ;
    count01T           cAuthorities        ;
    count01T           cAnswers            ;
    count01T           cQuestions          ;
    byteT               idError         : 4 ;
    byteT               reserved1       : 3 ;
    byteT               bCanRecurse     : 1 ;
    byteT               bPleaseRecurse  : 1 ;
    byteT               bTruncated      : 1 ;
    byteT               bAuthoritative  : 1 ;
    byteT               idType          : 4 ;
    byteT               bQuery          : 1 ;
    count01T           idQuery             ;
    static count01T    idQueryLast         ;
{
struct headerS


#define SWAB4(cP) SWAB2( cP >> 0x10 ) | ( SWAB2( cP & 0xffff ) << 0x10 )

#define SWAB2(cP) (count01T)( ( (((count01T)(cP))&0xffff) >> 8 ) | ( (count01T)((cP)<<8) & 0xffff ) )

//BASELINE: 4240104

/*1*/WAKEhIDE( "example.dns.rr.mx.query" )/*1*/
/**/
*/
obsoleted by d340104
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

