
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        er.strFuseF( tinP , psttP , T("}") ) ;
        }
            er.strFuseF( tinP , psttP , T("]") ) ;

            pbc += cbToDoWo ;
            }
                }
                    break ;
                {
                case ifcIDtYPEsOULiTEM_countTptr :
                case ifcIDtYPEsOULiTEM_byteTptr :
                case ifcIDtYPEsOULiTEM_handleC :
                case ifcIDtYPEsOULiTEM_baseSoilXxxxC :
                case ifcIDtYPEsOULiTEM_count9S :
                case ifcIDtYPEsOULiTEM_count8S :
                case ifcIDtYPEsOULiTEM_count7S :
                case ifcIDtYPEsOULiTEM_count6S :
                case ifcIDtYPEsOULiTEM_count5S :
                case ifcIDtYPEsOULiTEM_count4S :
                case ifcIDtYPEsOULiTEM_count3S :
                case ifcIDtYPEsOULiTEM_count2S :
                case ifcIDtYPEsOULiTEM_nicNameC :
                case ifcIDtYPEsOULiTEM_measure04T :
                case ifcIDtYPEsOULiTEM_measureT :
                case ifcIDtYPEsOULiTEM_strokeS :
                case ifcIDtYPEsOULiTEM_byteT :
                }
                    break ;
                {
                case ifcIDtYPEsOULiTEM_baseSoilXxxxCptr :
                }
                    break ;

                    }
                        }
                            }
                                er.delF( tinP , psttd ) ;
                                er.strFuseF( tinP , psttP , T(":")+T(psttd) ) ;
                                er.delF( tinP , psttDecoded ) ;
                                er.strDumpStrokesIF( tinP , psttd , psttDecoded ) ; ___( psttd ) ;
                                ZE( strokeS* , psttd ) ;
                            {
                            else
                            }
                                er.delF( tinP , psttDecoded ) ;
                                er.strFuseF( tinP , psttP , T(":")+T(psttDecoded) ) ;
                            {
                            if( !bDump )
        
                            }
                                }
                                    break ;
                                    bDump = 1 ;
                                {
                                if( psttDecoded[ CSpREFIX - 1 + ida ].idCaste != sc_cALPHABET1 )
                            {
                            for( countT ida = 1 ; ida <= psttDecoded->idAdam ; ida ++ )
                        {
                        if( psttDecoded )
                        ZE( boolT , bDump ) ;
    
                        er.strReplaceF( tinP , psttDecoded , 0 , ifcIDtYPEsTRrEPLACE_MAKEiMPORT , psttDecoded[ 2 ].idAdam ) ; ___( psttDecoded ) ;
                        er.strDecodeF( tinP , psttDecoded , pbEncoded ) ; ___( psttDecoded ) ;
                        ZE( strokeS* , psttDecoded ) ;
                        const byteT* pbEncoded = pbc ;
                    {
                    else
                    if( F(flags) & flSOULiTEM_NULLpTR ) er.strFuseF( tinP , psttP , T(" is null") ) ;
                {
                case ifcIDtYPEsOULiTEM_strokeSptr :
                }
                    break ;
                    er.strFuseF( tinP , psttP , T(":")+TF2(*(countT*)pbc,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ; //U::FOR SOME OS, NEED TO SWAB HERE (REORDER BYTES)
                {
                case ifcIDtYPEsOULiTEM_countT :
                }
                    break ;
                    er.delF( tinP , psttd ) ;
                    er.strFuseF( tinP , psttP , psttd ) ;
                    dumpIF( tinP , psttd , pbc ) ; ___( psttd ) ;
                    ZE( strokeS* , psttd ) ;
                {
                case ifcIDtYPEsOULiTEM_soulC :
            {
            switch( idType )

            flagsT flags = *(flagsT*)pbc ; pbc += sizeof( flagsT ) ; cbToDoWo -= sizeof( flagsT ) ;

            er.strFuseF( tinP , psttP , T("[")+T(processGlobal4I.mapSoulItem(idType)) ) ;
            countT idType = *(countT*)pbc ; pbc += sizeof( countT ) ; cbToDoWo -= sizeof( countT ) ;

            countT cbToDoWo = *(countT*)pbc ; pbc += sizeof( countT ) ; cbToDo -= sizeof( countT ) + cbToDoWo ;
        {
        while( cbToDo )

        er.strFuseF( tinP , psttP , T("{") ) ;
        countT cbToDo = *(countT*)pbc ; pbc += sizeof( countT ) ;
        pbc += sizeof( countT ) ;
    {
    else
    else if( pbc += sizeof( countT ) , *(countT*)pbc != 1 ) er.strFuseF( tinP , psttP , T("invalid idFormat") ) ;
    if( getNegAM( *(countT*)pbc ) != FINGERnEG_SOULc ) er.strFuseF( tinP , psttP , T("invalid fingerprint") ) ;
    const byteT* pbc = pbSoulImageP ;

    er.strMakeF( tinP , LF , psttP , 0 , TOCK * 0x10 ) ; ___( psttP ) ; //U::ALLOCATE ACCORDING TO NUMBER OF ELTS
    etherC& er = etherC::etRockIF( tinP ) ;
    _IO_
{
/*1*/voidT soulC::dumpIF( tinS& tinP , strokeS*& psttP , const byteT* const pbSoulImageP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

