
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( !( flagsi & fliLISTINGc_MIXINlIST ) ) { __( pczNameDadP ) ; }

    hListP.osF( ifcIDtYPEhANDLE_LISTING , (countT)this ) ;

    //}
    //    CONoUTrAW( ostoSay ) ;
    //    //PUSE( tinP , postName ) ;
    //    //OStEXTA(  ostoSay , postName ) ;
    //    OStEXTC(  ostoSay , cName , 0 ) ;
    //    OStEXTAK( ostoSay , " | +++++ " ) ;
    //    OStEXTC(  ostoSay , tinP.monitor.idThread , 0 ) ;
    //    OStEXTAK( ostoSay , "\r\n" ) ;
    //    OStEXT(   ostoSay , TUCK << 1 ) ;
    //
    //    //getListNameGF( tinP , postName , cName ) ; ___( postName ) ;
    //    //ZE( osTextT* , postName ) ;
    //{
    //if( this->flagsF() & fliLISTINGc_MIXINlIST )

    //}
    //    etherC::etRockIF( tinP ).traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
    //
    //    OStEXTC(  ostoSay , idNameDebug , 0 ) ;
    //    OStEXTAK( ostoSay , "openF /   grabbed  [idName]: " ) ;
    //    OStEXT(   ostoSay , TUCK << 2 ) ;
    //{
    //if( tinP.pc Utility[ 0 ] && tinP.pAdamGlobal1->idAdam == ifcIDaDAM_KERNEL2MONITOR )

    //etherC::etRockIF( tinP ).traceF( tinP , (const strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
    OStEXTAK( ostoSay , " ++++ GRABBED" ) ;
    //U:: TO FIND A BUG

    grabitx.grabF( tinP , TAG( TAGiDnULL ) ) ;

    //etherC::etRockIF( tinP ).traceF( tinP , (const strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
    OStEXTAK( ostoSay , " : ++++ GRABBING" ) ;
    OStEXTCF( ostoSay , (countT)&flagsi , '0' ) ;
    OStEXT(   ostoSay , TUCK << 2 ) ;
    //U:: TO FIND A BUG


    //}
    //    cDebug = idNameDebug ;
    //    etherC::etRockIF( tinP ).traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
    //
    //    OStEXTC(  ostoSay , idNameDebug , 0 ) ;
    //    OStEXTAK( ostoSay , "openF /   grabbing [idName]: " ) ;
    //    OStEXT(   ostoSay , TUCK << 2 ) ;
    //{
    //if( tinP.pc Utility[ 0 ] && tinP.pAdamGlobal1->idAdam == ifcIDaDAM_KERNEL2MONITOR )
    //ZE( countT , cDebug ) ;

    grabitC grabitx( tinP , TAG( TAGiDnULL ) , flagsi , ifcIDgRABITbIT_00 + offLISTINGgRABBEDbIT , *(grabitC*)0 , 0 , 0 , 0 , flagsx , 0 , idGrabLayerP ) ;

    }
        flagsx |= flGRABITc_RECURSEuSINGtINs ;
        )
            )
                idName <= LISTnAME_ROOTsYSTEM8              //CS:CODEsYNC: 330e5007 33001126 3300039b
                &&
                idName >= LISTnAME_ROOTsYSTEM1
            (
            ||
            idName == LISTnAME_ROOTaPPLICATION
            ||
            idName == LISTnAME_ROOT
        (
        if
        idNameDebug = idName ;
        countT idName = ((listC*)this)->nameF( 0 ) ;
    {
    if( flagsi & fliLISTINGc_MIXINlIST )
    flagsT flagsx = flGRABITc_SUPPRESScTdT | flGRABITc_SHARElAYER | flGRABITc_UNKEYED ; //CS:CODEsYNC 360e5007 35001126 "flGRABITc_UNKEYED" IS SPECIFIED TO AVOID NEEDING TO DOUBLE THE SIZE OF THE sexC ALLOCATION DROP FOR listingC INSTANCES.  sizeof( listingC ) IS CURRENTLY OPTIMAL.  ADDING A countT MEMBER TO HOLD A KEY WOULD CHANGE THE ALLOCATION DROP SIZE.
    ZE( countT , idNameDebug ) ;

    //}
    //    CONoUTrAW( ostoSay ) ;
    //    //PUSE( tinP , postName ) ;
    //    //OStEXTA(  ostoSay , postName ) ;
    //    OStEXTC(  ostoSay , cName , 0 ) ;
    //    OStEXTAK( ostoSay , " | ++++  " ) ;
    //    OStEXTC(  ostoSay , tinP.monitor.idThread , 0 ) ;
    //    OStEXTAK( ostoSay , "\r\n" ) ;
    //    OStEXT(   ostoSay , TUCK << 1 ) ;
    //
    //    //getListNameGF( tinP , postName , cName ) ; ___( postName ) ;
    //    //ZE( osTextT* , postName ) ;
    //    cName = ((listC*)this)->nameF() ;
    //{
    //if( this->flagsF() & fliLISTINGc_MIXINlIST )
    ZE( countT , cName ) ;

    }
        countT foo = 2 ;
    {
    if( idIn == 0x2b4 )
    countT idIn = 1 + incv02AM( idInLath ) ;
    static countT idInLath ;
    //U:: TO FIND A BUG

    _IO_

    }
        if( POOP ) return ;
        __( ~hListP ) ;
        __( thirdC::dosPriorityIF( tinP ) - ifcTHREADpRIORITY_SPINLOCK ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT listingC::openF( tinS& tinP , handleC& hListP , const countT* const pczNameDadP , countT idGrabLayerP )/*1*/

/**/
*/
  else must be the fully qualified name of the listC instance that contains me
  must be 0 unless i am a listC instance
 pczNameDadP
  must be null
 hListP
 tinP
parameters
 to do this, caller can ct a grabitC instance
 caller must remain RUSH until after hListP is destroyed
thread desire must be ifcTHREADpRIORITY_SPINLOCK
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

