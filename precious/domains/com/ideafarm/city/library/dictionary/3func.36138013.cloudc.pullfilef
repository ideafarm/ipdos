
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        __Z( bOk ) ;

        }
            }
                }
                    etPrime.osSleepF( tinP , TOCK ) ;
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    etRock.traceF( tinP , T("will retry after napping for a tock") ) ;
                    etScratch.diskFileOrDirDeleteF( tinP , tFileTmp ) ;
                {
                else
                }
                    break ;
                    bOk = 1 ;
                    etRock.traceF( tinP , T("skipping this file") ) ;
                {
                if( bNotFound )

                POOPR ;
            {
            else
            }
                break ;

                }
                    etScratch.diskMoveFileOrDirF(   tinP , psttFileP , tFileTmp ) ; //IT WOULD BE NICE TO BE ABLE TO DO THIS ATOMICALLY
                    etScratch.diskFileOrDirDeleteF( tinP , psttFileP ) ;            //IT WOULD BE NICE TO BE ABLE TO DO THIS ATOMICALLY
                {
                else
                }
                    sRenameP << (strokeS*)tFileTmp ;
                    sRenameP << psttFileP ;
                {
                if( F(flagsCt) & flCLOUDc_COPYaLLoRnONE )

                bOk = 1 ;
            {
            if( !POOP )

            }
                }
                    }
                        etScratch.delF( tinP , pbBuffer ) ;
                        }
                            }
                                }
                                    cDo -= cbGot ;
                                    etScratch.fileWriteF( tinP , fOut , pbBuffer , cbGot ) ;
                                    //etRock.traceF( tinP , T("pullFileF / U:: TO FIND A BUG: 20161201@1132: aok read bite [cDo,cbBite,cbGot]: ")+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(cbBite,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(cbGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                {
                                else
                                if( POOP ) etRock.traceF( tinP , T("pullFileF / could not read bite [cDo,cbBite,cbGot]: ")+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(cbBite,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(cbGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                __Z( cbGot ) ;
                                countT cbGot = ss.readF( tinP , pbBuffer , cbBite ) ;

                                countT cbBite = cDo < cbBuffer ? cDo : cbBuffer ;
                            {
                            while( cDo && !POOP )
                            countT cDo = cbFile ;

                            //tinP.pc Utility[ 0 ] = 1 ; //U::TO FIND A BUG

                            fileC fOut( tinP , (strokeS*)tFileTmp , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
                        {
                        if( !POOP )

                        }
                            etScratch.delF( tinP , psttu ) ;
                            etScratch.delF( tinP , psttPath ) ;
                            tFileTmp = T(psttPath)+T("/pullFileF.")+T(psttu) ;
                            etScratch.strUniqueF( tinP , psttu ) ; ___( psttu ) ;
                            ZE( strokeS* , psttu ) ;

                            etScratch.delF( tinP , psttnu ) ;
                            etScratch.strBisectF( tinP , psttPath , psttnu , psttFileP , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttnu ) ;
                            ZE( strokeS* , psttnu ) ;
                            ZE( strokeS* , psttPath ) ; // OBTAINED SO TMP FILE WILL BE ON THE SAME VOLUME AS THE FILE TO BE REPLACED ; ANY FAILURE WILL ALSO BE VISIBLE SINCE TMP FILE IS IN THE SAME FOLDER
                        {

                        __Z( pbBuffer ) ;
                        etScratch.newF( tinP , LF , pbBuffer , cbBuffer ) ; ___( pbBuffer ) ;
                        countT cbBuffer = cbFile < TOCK ? cbFile : TOCK ;
                        ZE( byteT* , pbBuffer ) ;
                    {
                    else
                    }
                        //LOGrAW( "\r\n--------------------------------\r\n" ) ;
                        //LOGrAW( postDebug ) ;
                        //LOGrAW( "\r\n---- REPLY (LINES RECEIVED UP TO WHEN ERROR DETECTED) ----------------------------\r\n" ) ;
                        //LOGrAW( "\r\n--------------------------------\r\n" ) ;
                        //LOGrAW( tSay ) ;
                        //LOGrAW( "\r\n---- REQUEST ----------------------------\r\n" ) ;

                        etRock.traceF( tinP , T("pullFileF / [tSay]: >>>>")+tSay+T("<<<<") ) ;
                        etRock.traceF( tinP , T("pullFileF / [offoDebug,responseFragment]: ")+TF2(offoDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" >>>>")+T(postDebug)+T("<<<<") ) ;
                        etRock.traceF( tinP , T("pullFileF / error detected while inspecting reply header") ) ;
                    {
                    if( POOP )

                    }
                        }
                            else if( !POOP ) offb = - 1 ;
                            if( !offb ) break ;

                            }
                                }
                                    }
                                        }
                                            etScratch.delF( tinP , psttw ) ;
                                            cbFile = etScratch.strDigitsToSCountF( tinP , psttw , 0xa , 1 ) ;
                                            etScratch.strSubstringF( tinP , psttw , idf , idl , psttLine ) ; ___( psttw ) ;
                                            ZE( strokeS* , psttw ) ;

                                            ZE( countT , idl ) ;
                                            while( psttLine[ CSpREFIX - 1 + idf ] == sttBlank ) idf ++ ;
                                            countT idf = tContentLength.csF( tinP ) + 1 ;
                                            strokeS* psttLine = tLine ;
                                        {
                                        if( 1 == etScratch.strIdF( tinP , tContentLength , tLine ) )
                                        strokeS sttBlank( ' ' ) ;
                                    {
                                    else
                                    if( POOP ) etRock.traceF( tinP , T("pullFileF / expected LF byte but received ")+TF2(ostLF,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    __NZ( ostLF != '\n' ) ;
                                {
                                else
                                if( POOP ) etRock.traceF( tinP , T("pullFileF / could not read expected LF byte") ) ;

                                __Z( ss.readF( tinP , &ostLF , 1 ) ) ;
                                osTextT ostLF ;

                                }
                                    //etRock.traceF( tinP , T("pullFileF / header line: ")+T(postBuffer) ) ;
                                    postBuffer[ offb ] = 0 ;
                                {
                                if( offb )
                            {
                            if( !POOP )

                            }
                                }
                                    __( !etScratch.strIdF( tinP , tReplyCode200_OK , tLine ) ) ;

                                    }
                                        etRock.traceF( tinP , T("not found in remote: \"")+T(psttShortP)+T("\"") ) ;
                                        bNotFound = 1 ;
                                    {
                                    if( etScratch.strIdF( tinP , tReplyCode404_NotFound , tLine ) )

                                    }
                                        break ;
                                        tSay = tn ;
                                        etRock.traceF( tinP , T("authorization refused") ) ;
                                    {
                                    if( POOP )
                                    __NZ( 1 == etScratch.strIdF( tinP , tReplyCode401_Unauthorized , tLine ) ) ;
                                {
                                if( !POOP )

                                __Z( offb ) ;
                                bWoth = 0 ;
                            {
                            if( bWoth )

                            TN( tLine , postBuffer ) ;
                            postBuffer[ offb ] = 0 ;
                        {
                        else if( postBuffer[ offb ] == '\r' )         // IF I HAVE A LINE OF HEADER
                        }
                            etRock.traceF( tinP , T("pullFileF / could not read a byte of a reply header line [offb,fragment]: ")+TF2(offb,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" >>>>")+T(postBuffer)+T("<<<<") ) ;

                            postBuffer[ offb ] = 0 ;
                        {
                        if( POOP )

                        if( !POOP ) postDebug[ offoDebug ++ ] = postBuffer[ offb ] ;

                        __Z( ss.readF( tinP , postBuffer + offb , 1 ) ) ;
                    {
                    for( offb = 0 ; !POOP && offb < sizeof postBuffer ; offb ++ )
                    ZE( countT , cbFile ) ;
                    TN( tContentLength , "Content-Length:" ) ;
                    boolT bWoth = 1 ;
                    ZE( countT , offb ) ;
                    osTextT postBuffer[ TOCK ] ;

                    ZE( countT , offoDebug ) ;                                  //U::TO FIND A BUG
                    thirdC::c_memsetIF( tinP , postDebug , sizeof postDebug ) ; //U::TO FIND A BUG
                    osTextT postDebug[ TOCK ] ;                                 //U::TO FIND A BUG

                    // 
                    // my.iddisk
                    // administrator.email@foo.com
                    // 
                    // Date: Mon, 08 Dec 2014 04:14:34 GMT
                    // X-Trans-Id: tx567c206bc36246dab9325-00548525aaiad3
                    // Content-Type: application/octet-stream
                    // X-Timestamp: 1418012073.44724
                    // Etag: f1290729de5a5ba08b49016a88a0f740
                    // Last-Modified: Mon, 08 Dec 2014 04:14:34 GMT
                    // Accept-Ranges: bytes
                    // Content-Length: 39
                    // HTTP/1.1 200 OK
                    // 
                    // SAMPLE REPLY
                {
                else
                if( POOP ) etRock.traceF( tinP , T("pullFileF / could not write request") ) ;

                ss.writeF( tinP , (osTextT*)tSay , (countT)tSay.csF( tinP ) ) ;
            {
            else
            if( POOP ) etRock.traceF( tinP , T("pullFileF / could not connect") ) ;
            ZE( boolT , bNotFound ) ;
            TN( tFileTmp , "" ) ;

            ss.connectF( tinP , 443 , socketC::nicNameIF( tinP , etScratch , tHost ) ) ;

            socketC ss( tinP , etScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL /*, &idleTimeAllowedRead , &idleTimeAllowedWrite*/ ) ;
            //countT idleTimeAllowedWrite = TICK >> 1 ;
            //countT idleTimeAllowedRead  = TICK >> 1 ;

            }
                etScratch.delF( tinP , psttShortUrlEncoded ) ;
                }
                    bHandle.ungrabF( tinP ) ;
                    tSay = T("GET ")+tUrlCloudAgent+T("/")+T(psttCloudContainerP)+T("/")+T(psttShortUrlEncoded)+T(" HTTP/1.1\r\nHost: ")+tHost+T("\r\nX-Auth-Token: ")+cloudInfo.tRackspaceAccessToken+T("\r\n\r\n") ;
                    cloudInfoS& cloudInfo = *(cloudInfoS*)hCloud.osF( ifcIDtYPEhANDLE_CLOUD ) ;
                    bHandle.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {

                //  
                // X-Auth-Token: f064c46a782c444cb4ba4b6434288f7c
                // Host: storage.clouddrive.com
                // GET /v1/MossoCloudFS_0672d7fa-9f85-4a81-a3ab-adb66a880123/archive/shortEncodedName HTTP/1.1
                // 
                // EXAMPLE

                etScratch.strToUrlF( tinP , psttShortUrlEncoded , psttShortP ) ; ___( psttShortUrlEncoded ) ;
                ZE( strokeS* , psttShortUrlEncoded ) ;                                                                                                  
            {
            if( !tSay.csF( tinP ) )
        {
        while( !POOP && !etPrime )
        TN( tSay , "" ) ;
        TN( tn , "" ) ;

        etherC& etScratch = *tinP.pEtScratch ;
        etherC& etPrime   = etherC::etPrimeIF( tinP ) ;

        }
            etRock.traceF( tinP , T("pullFileF / etScratch is impotent on entry (coding error).  resetting") ) ;
            POOPR
        {
        if( POOP )

        SCOOPS
    {
    IFsCRATCH
    ZE( boolT , bOk ) ;

    //etRock.traceF( tinP , T("the GET utterance has been appended to the log") ) ;
    //LOGrAW( tSay ) ;
    etherC& etRock = etherC::etRockIF( tinP ) ;

    _INoLD_

    }
        if( POOP ) return ;
        __Z( psttShortP ) ;
        __Z( psttCloudContainerP ) ;
        __Z( psttFileP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    SCOOP
{
/*1*/voidT cloudC::pullFileF( tinS& tinP , soulC& sRenameP , const strokeS* const psttFileP , const strokeS* const psttCloudContainerP , const strokeS* const psttShortP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

