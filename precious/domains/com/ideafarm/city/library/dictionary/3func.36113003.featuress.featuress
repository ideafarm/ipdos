
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    DEL( psFeaturesP ) ;

    ether( tinP , psFeature ) ;
    }
        }
            psFeature->removeAllF( tinP ) ;
            }
                }
                    }
                        break ;
                        }
                            if( !POOP ) fc.flagsDraggable |= flags ;
                            FV( flFEATUREsADAMdRAGGABLE , flags ) ;
                            *psFeature >> flags ;
                            ZE( flagsT , flags ) ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;

                        fc.flagsDraggable |= flFEATUREsADAMdRAGGABLE_EXISTS ;
                        //LOGrAW3( "setting draggable flag for sadam " , fc.idAdam , "\r\n" ) ;
                    {
                    case ifcIDtYPEfEATUREsADAM_DRAGGABLE :
                    }
                        break ;
                        fc.flagsFlyoverHighlight |= flFEATUREsADAMfLYOVERhIGHLIGHT_EXISTS ;
                    {
                    case ifcIDtYPEfEATUREsADAM_FLYOVERhIGHLIGHT :
                    }
                        break ;
                        }
                            }
                                *psFeature >> psttFlyover ;
                                PUSE( tinP , *(byteT**)&psttFlyover ) ;
                            {
                            if( idTypeItem == ifcIDtYPEsOULiTEM_strokeSptr )
                            psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                            idTypeItem = 0 ;

                            *psFeature >> fc.idIntercomFlyover ;
                            fc.idIntercomFlyover = 0 ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;

                        fc.flagsFlyover |= flFEATUREsADAMfLYOVER_EXISTS ;
                    {
                    case ifcIDtYPEfEATUREsADAM_FLYOVER :
                    }
                        break ;
                        }
                            *psFeature >> fc.idIntercom ;
                            fc.idIntercom = 0 ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;
                        fc.flagsIntercom |= flFEATUREsADAMiNTERCOM_EXISTS ;
                    {
                    case ifcIDtYPEfEATUREsADAM_INTERCOM :
                    }
                        break ;
                        }
                            if( !POOP ) fc.flagsMouse |= flags ;
                            FV( flFEATUREsADAMmOUSE , flags ) ;
                            SCOOPS

                            *psFeature >> flags ;
                            ZE( flagsT , flags ) ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;

                        fc.flagsMouse |= flFEATUREsADAMmOUSE_EXISTS ;

                        }
                            countT foo = 2 ;
                        {
                        if( fc.idAdam == 5 )
                        //U::
                    {
                    case ifcIDtYPEfEATUREsADAM_MOUSE :
                    }
                        break ;
                        }
                            if( !POOP ) fc.flagsJoyStick |= flags ;
                            FV( flFEATUREsADAMjOYsTICK , flags ) ;
                            SCOOPS

                            *psFeature >> flags ;
                            ZE( flagsT , flags ) ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;

                        fc.flagsJoyStick |= flFEATUREsADAMjOYsTICK_EXISTS ;
                    {
                    case ifcIDtYPEfEATUREsADAM_JOYsTICK :
                    }
                        break ;
                        }
                            if( !POOP ) fc.flagsKeyboard |= flags ;
                            FV( flFEATUREsADAMkEYBOARD , flags ) ;
                            SCOOPS

                            *psFeature >> flags ;
                            ZE( flagsT , flags ) ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;

                        fc.flagsKeyboard |= flFEATUREsADAMkEYBOARD_EXISTS ;
                    {
                    case ifcIDtYPEfEATUREsADAM_KEYBOARD :
                    }
                        break ;
                        }
                            }
                                }
                                    }
                                        }
                                            }
                                                *psFeature >> fc.cFrameNestRight ;
                                            {
                                            if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                                            psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                                            idTypeItem = 0 ;

                                            *psFeature >> fc.cFrameNestUp ;
                                        {
                                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                                        idTypeItem = 0 ;

                                        *psFeature >> fc.cFrameNestLeft ;
                                    {
                                    if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                                    psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                                    idTypeItem = 0 ;

                                    *psFeature >> fc.cFrameNestDown ;
                                {
                                if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                                psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                                idTypeItem = 0 ;

                                if( !POOP ) fc.flagsFrame |= flags ;
                                FV( flFEATUREsADAMfRAME , flags ) ;
                                SCOOPS

                                *psFeature >> flags ;
                                ZE( flagsT , flags ) ;
                            {
                            if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                            psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                            idTypeItem = 0 ;

                            *psFeature >> fc.rgbFrame ;
                            fc.rgbFrame = 0 ;
                        {
                        else
                        if( idTypeItem != ifcIDtYPEsOULiTEM_countT ) fc.rgbFrame = 0xff000000 ; //INVALID COLOR SO NO COLOR WILL BE PUSHED
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;

                        fc.flagsFrame |= flFEATUREsADAMfRAME_EXISTS ;
                    {
                    case ifcIDtYPEfEATUREsADAM_FRAME :
                    }
                        break ;
                        }
                            }
                                *ppczChannel = pczChannel ;
                                if( *ppczChannel ) ether.delF( tinP , *ppczChannel ) ;
                            {
                            else
                            if( !ppczChannel ) ether.delF( tinP , pczChannel ) ;

                            }
                                case ifcIDtYPEsADAMcHANNEL_IN  : { ppczChannel = &pczChannelIn  ; break ; }
                                case ifcIDtYPEsADAMcHANNEL_OUT : { ppczChannel = &pczChannelOut ; break ; }
                            {
                            switch( idTypeChannel )
                            ZE( countT** , ppczChannel ) ;

                            *psFeature >> pczChannel ;
                            ZE( countT* , pczChannel ) ;

                            if( idTypeItem != ifcIDtYPEsOULiTEM_countTptr ) break ;
                            psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                            idTypeItem = 0 ;

                            *psFeature >> idTypeChannel ;
                            ZE( countT , idTypeChannel ) ;

                            if( idTypeItem != ifcIDtYPEsOULiTEM_countT ) break ;
                            psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                            ZE( countT , idTypeItem ) ;
                        {
                        while( (countT)*psFeature >= 2 )

                        fc.flagsCio |= flFEATUREsADAMcIO_EXISTS ;
                    {
                    case ifcIDtYPEfEATUREsADAM_CIO :
                    }
                        break ;
                        }
                            }
                                *psFeature >> fc.callBackArg ;
                                fc.callBackArg = 0 ;
                            {
                            if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                            psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                            ZE( countT , idTypeItem ) ;
                        {
                        if( (countT)*psFeature )

                        }
                            PUSE( tinP , *(byteT**)&psttOldCB ) ;
                            }
                                }
                                    hBase.resetF() ;
                                    ether.dllEntryF( tinP , *ppSadamCBF , hBase , psttOldCB ) ;
                                    ((thirdC&)ether).dosQueryModuleHandleF( tinP , hBase , thirdC::postBaseNameIF( tinP ) ) ;
                                    handleC hBase( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DLL ) ;
                                {
                                if( !*ppSadamCBF )

                                }
                                    if( POOP ) POOPR ;
                                    tinP.pEtScratch->dllEntryF( tinP , *ppSadamCBF , *tinP.pAdamGlobal1->_etherC_.pHdll , psttOldCB ) ;
                                    SCOOPS
                                {
                                IFsCRATCH
                                *ppSadamCBF = 0 ;
                            {
                            if( ppSadamCBF )

                            }
                                case ifcIDtYPEsADAMcALLbACK_ERASE         : { ppSadamCBF = &fc.pSadamEraseCBF         ; break ; }
                                case ifcIDtYPEsADAMcALLbACK_DRAG          : { ppSadamCBF = &fc.pSadamDragCBF          ; break ; }
                                case ifcIDtYPEsADAMcALLbACK_INoUTqUERY    : { ppSadamCBF = &fc.pSadamInOutQueryCBF    ; break ; }
                                case ifcIDtYPEsADAMcALLbACK_HOTkEY        : { ppSadamCBF = &fc.pSadamHotKeyCBF        ; break ; }
                                case ifcIDtYPEsADAMcALLbACK_ANIMATE       : { ppSadamCBF = &fc.pSadamAnimateCBF       ; break ; }
                                case ifcIDtYPEsADAMcALLbACK_TAB           : { ppSadamCBF = &fc.pSadamTabCBF           ; break ; }
                                case ifcIDtYPEsADAMcALLbACK_FLYOVER       : { ppSadamCBF = &fc.pSadamFlyoverCBF       ; break ; }
                                case ifcIDtYPEsADAMcALLbACK_INTERCOM      : { ppSadamCBF = &fc.pSadamIntercomCBF      ; break ; }
                                case ifcIDtYPEsADAMcALLbACK_EPILOG        : { ppSadamCBF = &fc.pSadamEpilogCBF        ; break ; }
                                case ifcIDtYPEsADAMcALLbACK_IFhIT         : { ppSadamCBF = &fc.pSadamIfHitCBF         ; break ; }
                                case ifcIDtYPEsADAMcALLbACK_PROLOG        : { ppSadamCBF = &fc.pSadamPrologCBF        ; break ; }
                                case ifcIDtYPEsADAMcALLbACK_BEFOREdESTROY : { ppSadamCBF = &fc.pSadamBeforeDestroyCBF ; break ; }
                                case ifcIDtYPEsADAMcALLbACK_AFTERrENDER   : { ppSadamCBF = &fc.pSadamAfterRenderCBF   ; break ; }
                            {
                            switch( idTypeCallBack )
                            ZE( sadamCBFT* , ppSadamCBF ) ;

                            *psFeature >> psttOldCB ; ___( psttOldCB ) ;
                            ZE( strokeS* , psttOldCB ) ;

                            if( idTypeItem != ifcIDtYPEsOULiTEM_strokeSptr ) break ;
                            psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                            idTypeItem = 0 ;

                            *psFeature >> idTypeCallBack ;
                            ZE( countT , idTypeCallBack ) ;

                            if( idTypeItem != ifcIDtYPEsOULiTEM_countT ) break ;
                            psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                            ZE( countT , idTypeItem ) ;
                        {
                        while( (countT)*psFeature >= 2 )

                        fc.flagsCallBack |= flFEATUREsADAMcALLbACK_EXISTS ;
                    {
                    case ifcIDtYPEfEATUREsADAM_CALLbACK :
                    }
                        break ;

                        }
                            }
#endif
                                }
                                    fc.bBigit = 0 ;
                                    )
                                        thirdC::c_strcmpIF( tinP , postBody , "fU" )
                                        thirdC::c_strcmpIF( tinP , postBody , "Ee" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "De" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "Ce" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "Be" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "Ay" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "Ni" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "Ta" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "Ve" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "Se" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "fI" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "Fo" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "Re" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "Oo" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "Wo" ) &&
                                        thirdC::c_strcmpIF( tinP , postBody , "Ze" ) &&
                                    (
                                    else if
                                    if( csttBody != 2 ) fc.bBigit = 0 ;
                                    countT   csttBody = tBody.csF( tinP ) ;
                                    osTextT* postBody = tBody ;

                                    fc.bBigit = 1 ;
                                {
                                if( F(fc.flagsHotKey) & flFEATUREsADAMhOTkEY_BIGIT )
                                TN( tBody , "" ) ;
#if defined( NEVERdEFINED )

                                fc.flagsHotKey |= flagshk ;
                                *psFeature >> flagshk ;
                                ZE( flagsT , flagshk ) ;
                            {
                            if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                            psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                            idTypeItem = 0 ;

                            if( idTypeItem == ifcIDtYPEsOULiTEM_countT ) *psFeature >> fc.assignedHotKey ;
                            psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                            ZE( countT , idTypeItem ) ;
                        {
                        fc.assignedHotKey = 0 ;
                        fc.bBigit = - 1 ; //U::TRISTATE KLUDGE: -1: ASSIGN ANY VALUE (FORGET ABOUT BIGITS); 0: ASSIGN A NONBIGIT HOTKEY; 1: ASSIGN A BIGIT HOTKEY

                        fc.flagsHotKey |= flFEATUREsADAMhOTkEY_EXISTS ;
                    {
                    case ifcIDtYPEfEATUREsADAM_HOTkEY :
                    }
                        break ;

                        }
                            }
                                cLeverVolBody = 0 ;
                                pswVolBody->freeF( tinP ) ;
                                DELzOMBIE( pvb ) ;
                            {
                            if( bDiscard ) 

                            }
                                }
                                    }
                                        if( pvb->zBaton_ppsttSpec ) bDiscard = 0 ;
                                        *psFeature >> *(countT*)&pvb->zBaton_ppsttSpec ;
                                                                 pvb->zBaton_ppsttSpec = 0 ;
                                    {
                                    if( idTypeItem == ifcIDtYPEsOULiTEM_countT && pvb->ppsttSpec )
                                    psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                                    idTypeItem = 0 ;

                                    *psFeature >> *(countT*)&pvb->ppsttSpec ;
                                                             pvb->ppsttSpec = 0 ;
                                {
                                if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                                psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                            {
                            if( pvb )
                            boolT bDiscard = 1 ;

                            }
                                }
                                    pvb = new( 0 , tinP , pba , pswVolBody->cbDataF() ) vBodyS ;
                                    byteT* pba = (byteT*)&(countT&)*pswVolBody ;
                                {
                                if( cLeverVolBody )
                                *psFeature >> cLeverVolBody ;
                                              cLeverVolBody = 0 ;
                            {
                            ZE( vBodyS* , pvb ) ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;

                    {
                    case ifcIDtYPEfEATUREsADAM_VOLATILEbODY :
                    }
                        break ;
                        }
                            *psFeature >> psttBody ; ___( psttBody ) ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_strokeSptr )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;
                    {
                    case ifcIDtYPEfEATUREsADAM_BODY :
                    }
                        break ;

                        ether.strMakeF( tinP , psttDefaultHighlightTabOwnerOff , T("") ) ; ___( psttDefaultHighlightTabOwnerOff ) ;
                        PUSE( tinP , *(byteT**)&psttDefaultHighlightTabOwnerOff ) ;

                        //U::ether.strMakeF( tinP , psttDefaultHighlightTabOwnerOn , T("X") ) ; ___( psttDefaultHighlightTabOwnerOn ) ;
                        ether.strMakeF( tinP , psttDefaultHighlightTabOwnerOn , T("") ) ; ___( psttDefaultHighlightTabOwnerOn ) ; //U::
                        //U:: WHEN eyeOldC GOES INTO PRODUCTION, EITHER 'X' HIGHLIGHTING WILL BE NEEDED FOR TAB HIGHLIGHTING, OR SOMETHING BETTER THAN 'X' THAT CAN BE SUPPORTED WITHOUT USING FLOODFILL (UNTIL eycC SUPPORTS FLOODFILL, IF IT EVER DOES)
                        //U:: 'X' IS USED PROVISIONALLY WHEN eyeOldC IS SUPPORTED.  UNTIL THEN, 'X' IS NOT USED (COLOR HIGHLIGHTING IS USED INSTEAD, BECAUSE IT LOOKS BETTER THAN THE X HIGHLIGHTING)

                        PUSE( tinP , *(byteT**)&psttDefaultHighlightTabOwnerOn ) ;

                        else fc.idTab = - 1 ;
                        }
                            *psFeature >> fc.idTab ;
                            fc.idTab = 0 ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        idTypeItem = 0 ;

                        else fc.idTabClass = - 1 ;
                        }
                            *psFeature >> fc.idTabClass ;
                            fc.idTabClass = 0 ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;
                    {
                    case ifcIDtYPEfEATUREsADAM_TABpARTICIPANT :
                    }
                        break ;
                        }
                            if( !POOP ) fc.flagsAdam |= flags ;
                            FV( flFEATUREsADAMaDAM , flags ) ;
                            SCOOPS

                            *psFeature >> flags ;
                            ZE( flagsT , flags ) ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;
                    {
                    case ifcIDtYPEfEATUREsADAM_ADAM :
                    }
                        break ;
                        }
                            *psFeature >> fc.idToolFilterList ;
                            fc.idToolFilterList = 0 ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;
                    {
                    case ifcIDtYPEfEATUREsADAM_TOOLfILTERlIST :
                    }
                        break ;
                        }
                            }
                                //    { LOGrAWtID4( T("ifcIDtYPEfEATUREsADAM_STATErEFERENCE/")+T(ssc.postOldComment)+T("/[ppSadamState,this]: ") , (countT)ppSadamState , " " , (countT)this ) ; }
                                //if( !thirdC::c_strcmpIF( tinP , ssc.postOldComment , "vtHint" ) )
                                *ppSadam = (sadamC*)( (byteT*)this - sizeof( countT ) - sizeof( zapC ) ) ; //U::ENFORCE: ASSUMES THAT I AM AT THE BEGINNING OF sadamC AFTER neverZe
                            {
                            if( ppSadam )
                            *psFeature >> *(countT*)&ppSadam ;
                            ZE( sadamC** , ppSadam ) ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;
                    {
                    case ifcIDtYPEfEATUREsADAM_STATErEFERENCE : //U::RENAME
                    }
                        break ;
                        }
                            *psFeature >> *(countT*)&fc.pOwner ;
                            fc.pOwner = 0 ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;
                    {
                    case ifcIDtYPEfEATUREsADAM_OWNER :
                    }
                        break ;
                        }
                            //}
                            //    LOGrAWtID( T("ifcIDtYPEfEATUREsADAM_COMMENT [fc.idAdam]: ")+TF1(fc.idAdam)+T(" \"")+T(fc.postOldComment)+T("\"") )
                            //{
                            //if( !thirdC::c_strcmpIF( tinP , fc.postOldComment , "buEyeMoveEast" ) || !thirdC::c_strcmpIF( tinP , fc.postOldComment , "buTest" ) )

                            //}
                            //    LOGrAWtID( tSay ) ;
                            //    TN( tSay , "sadam feature comment: " ) ; tSay += TF1(fc.idAdam)+T(": ")+T(fc.postOldComment) ;
                            //{
                            //if( fc.idAdam == 0x5 || fc.idAdam == 0xb )

                            PUSE( tinP , posti ) ;
                            if( posti && *posti ) thirdC::c_strncpyIF( tinP , fc.postOldComment , posti , sizeof fc.postOldComment ) ;
                            *psFeature >> posti ; ___( posti ) ;
                            ZE( osTextT* , posti ) ;
                            thirdC::c_memsetIF( tinP , fc.postOldComment , sizeof fc.postOldComment ) ;
                        {
                        if( idTypeItem == ifcIDtYPEsOULiTEM_byteTptr )
                        psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
                        ZE( countT , idTypeItem ) ;
                    {
                    case ifcIDtYPEfEATUREsADAM_COMMENT :
                {
                switch( idType )

                *psFeature >> idType ;
                ZE( countT , idType ) ;
            {
            if( idTypeItem == ifcIDtYPEsOULiTEM_countT )
            const byteT* pb_idType = psFeature->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
            idTypeItem = 0 ;

            *psFeaturesP >> *psFeature ;

            if( idTypeItem != ifcIDtYPEsOULiTEM_soulC ) break ;
            psFeaturesP->pbFieldF( tinP , idTypeItem , countTC() , countTC() , 1 ) ;
            ZE( countT , idTypeItem ) ;
        {
        while( (countT)*psFeaturesP )
    {
    if( psFeature )
    ether( tinP , psFeature , TAG( TAGiDnULL ) ) ;
    ZE( soulC* , psFeature ) ;

    }
        *psFeaturesP >> idCaste ;
        ZE( countT , idCaste ) ;
    {

    fc.idIntercom = 0 ;
    fc.cyclesPerDragRedraw = 4 ;

    ether( tinP , pswVolBody , TAG( TAGiDnULL ) , flSTACKc_PATCHnEWfLAVOR | flSTACKc_BLOB | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , cLeverVolBody , 0 , sizeof( vBodyS ) ) ; ___( pswVolBody ) ;

    }
        if( POOP ) return ;
        __Z( psFeaturesP ) ;
        __Z( idAdamP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
cLeverVolBody( 0 )
psttDefaultHighlightTabOwnerOff( 0 ) ,
psttDefaultHighlightTabOwnerOn( 0 ) ,
psttFlyover( 0 ) ,
psttBody( 0 ) ,
pczChannelIn( 0 ) ,
pczChannelOut( 0 ) ,
fc( idAdamP ) ,
ether( etherP ) ,
/*1*/featuresS::featuresS( tinS& tinP , etherC& etherP , const countT idAdamP , soulC*& psFeaturesP ) :/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

