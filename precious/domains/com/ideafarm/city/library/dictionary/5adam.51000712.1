
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

etThread.delF( tinP , posti ) ;
etThread.delF( tinP , posto ) ;

etThread.boxPutF( tinP , T("///d/tmp/fcmp..diff.ttt") , costo ? posto : 0 , costo ) ;

}
    }
        postc += postEnd - postc ;
        const osTextT* postEnd = postFound3 + costKey3 ;
    {
    else                                                                                                        // THIS IS A "NO DIFFERENCES" ENTRY SO SUPPRESS TO THE END THE FURTHEREST KEY
    }
        postc += costoNew ;
        costo += costoNew ;
        thirdC::c_memcpyIF( tinP , posto + costo , postc , costoNew ) ;
        countT costoNew = postEnd - postc ;
        const osTextT* postEnd = postFound1 + costKey1 ;
    {
    else if( postFound3 != postFound2 + 2 )                                                                     // KEY3 IS NOT IMMEDIATELY AFTER KEY2 SO PROCESS TO THE END OF KEY1 (THIS IS THE WOTH PART OF AN ENTRY SHOWING DIFFERENCES)
    }
        postc += costoNew ;
        costo += costoNew ;
        thirdC::c_memcpyIF( tinP , posto + costo , postc , costoNew ) ;
        countT costoNew = postEnd - postc ;
        const osTextT* postEnd = postMin + costMin ;

        }
            costMin = costKey3 ;
            postMin = postFound3 ;
        {
        if( postMin > postFound3 )
        }
            costMin = costKey2 ;
            postMin = postFound2 ;
        {
        if( postMin > postFound2 )
        countT         costMin = costKey1 ;
        const osTextT* postMin = postFound1 ;
    {
    else if( !( postFound1 < postFound2 && postFound2 < postFound3 ) )                                          // KEYS ARE NOT IN EXPECTED ORDER SO PROCESS TO END OF EARLIEST KEY
    }
        postc = postie ;
        costo += costoNew ;
        thirdC::c_memcpyIF( tinP , posto + costo , postc , costoNew ) ;
        countT costoNew = costi - ( postc - posti ) ;
    {
    else if( !postFound1 || !postFound2 || !postFound3 )                                                        // SOME KEYS NOT FOUND SO PROCESS THE REMAINDER OF THE INPUT
    }
        postc += 2 ;
    {
    if( postc[ 0 ] == '\r' && postc[ 1 ] == '\n' )                                                              // IF CURSORED AT A BLANK LINE THEN SUPPRESS IT

    postNextKeysF( tinP , postFound1 , postFound2 , postFound3 , postc , postKey1 , postKey2 , postKey3 ) ;
    ZE( const osTextT* , postFound3 ) ;
    ZE( const osTextT* , postFound2 ) ;
    ZE( const osTextT* , postFound1 ) ;
    CONoUTrAW3( "\r                                    \rremaining: " , postie - postc , "\r" ) ;
{
while( postc < postie )
CONoUTrAW( "\r\n\r\n" ) ;
const osTextT* postc = posti ;
ZE( const osTextT* , postFound3Lath ) ;
ZE( const osTextT* , postFound2Lath ) ;
ZE( const osTextT* , postFound1Lath ) ;

//
//   ELSE SUPPRESS TO THE END OF KEY3
//   ELSE IF KEY3 IS NOT 2 BEYOND KEY2 THEN PROCESS UP TO THE BEGINNING OF THE NEXT KEY1
//   ELSE IF NOT MONOTONIC THEN PROCESS TO THE END OF THE EARLIEST KEY
//   ELSE IF SOME ARE MISSING THEN PROCESS TO THE END OF THE FILE
//   IF CURSORED AT A BLANK LINE THEN SUPPRESS IT
//   GET POINTERS TO THE NEXT KEY OF EACH TYPE
//   CURSOR POINTS TO END OF INPUT THAT HAS ALREADY BEEN PROCESSED
// WHILE NOT AT END
// INITIALIZE CURSOR TO BEGINNING
// RECIPE
//

const countT  costKey3 = sizeof postKey3 - 1 ;
const osTextT postKey3[] = "FC: no differences encountered" ;

const countT  costKey2 = sizeof postKey2 - 1 ;
const osTextT postKey2[] = "\r\n" ;

const countT  costKey1 = sizeof postKey1 - 1 ;
const osTextT postKey1[] = "Comparing files " ;

ZE( countT , costo ) ;
etThread.newF( tinP , LF , posto , costi ) ; ___( posto ) ;
ZE( osTextT* , posto ) ;

const osTextT* postie = posti + costi ;
etThread.boxGetShadowF( tinP , posti , costi , T("///d/tmp/fcmp..ttt") ) ; ___( posti ) ;
ZE( countT   , costi ) ;
ZE( osTextT* , posti ) ;

//
//    Comparing files !ideafarm.8.2.00000000.00000001.20091014@0333.20091014@0333.001.004.eed238891d22f7c485ccd3991a72af8e.00000001.meta.currentname and \ARCHIVE\2009\!IDEAFARM.7.20091014@0333.20091014@0333.001.004.EED238891D22F7C485CCD3991A72AF8E.00000001.META.CURRENTNAME
//    FC: no differences encountered
//
//GOAL IS TO SUPPRESS ENTRIES OF THE FOLLOWING FORM:

CONoUTrAW( "yippee\r\n" ) ;//U:: TO FIND A BUG

TODO

}
    postFound3P = thirdC::c_strstrIF( tinP , postBigP , postSmall3P ) ;
    postFound2P = thirdC::c_strstrIF( tinP , postBigP , postSmall2P ) ;
    postFound1P = thirdC::c_strstrIF( tinP , postBigP , postSmall1P ) ;
{
voidT postNextKeysF( tinS& tinP , const osTextT*& postFound1P , const osTextT*& postFound2P , const osTextT*& postFound3P , const osTextT* const postBigP , const osTextT* const postSmall1P , const osTextT* const postSmall2P , const osTextT* const postSmall3P ) 

/*1*/WAKEsHOWtEXT( "tool.abridge.fc.output.to.suppress.no.differences.entries" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

