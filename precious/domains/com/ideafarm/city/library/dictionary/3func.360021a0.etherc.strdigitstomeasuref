
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#undef BcANDY

}
    return mValue ;
    }
        if( exp ) mValue *= thirdC::mathExpIF( tinP , radix , bExpNeg ? - (sCountT)exp : (sCountT)exp ) ;

        delF( tinP , psttd ) ;

        }
            }
                }
                    delF( tinP , psttw ) ;
    
                    }
                        }
                            expUnit /= radix ;
                            else          exp += delta ;
                            if( bExpNeg ) exp -= delta ;
                            countT delta = expUnit * strDigitsToSCountF( tinP , psttWo , defaultRadixP , 1 ) ;
                            psttWo[ CSpREFIX ] = psttw[ CSpREFIX - 1 + ids ] ;
                        {
                        else
                        }
                            else       mValue += delta ;
                            if( bNeg ) mValue -= delta ;
                            measureT delta = unit * (measureT)strDigitsToSCountF( tinP , psttWo , defaultRadixP , 1 ) ;
                            psttWo[ CSpREFIX ] = psttw[ CSpREFIX - 1 + ids ] ;
                            unit *= 1.0 / (measureT)radix ;

                            }
                                continue ;

                                else { __( psttw[ CSpREFIX - 1 + ids ].idAdam ) ; }
                                else if( psttw[ CSpREFIX - 1 + ids ].idAdam == '+' )             ;
                                     if( psttw[ CSpREFIX - 1 + ids ].idAdam == '-' ) bExpNeg = 1 ;
                                ids ++ ;

                                bExp = 1 ;
                            {
                            if( psttw[ CSpREFIX - 1 + ids ].idAdam == '^' )
                        {
                        if( !bExp )
                    {
                    for( countT ids = 1 ; ids <= psttw->idAdam ; ids ++ )
                    psttWo->idAdam = 1 ;
                    SETpREFIXA( psttWo )
                    strokeS psttWo[ CSpREFIX + 1 ] ;
                    countT expUnit = TUCK ;
                    measureT unit = 1.0 ;
                    ZE( boolT , bExp ) ;
    
                    strSubstringF( tinP , psttw , idf , idl , psttd ) ; ___( psttw ) ;
                    ZE( countT , idl ) ;
                    countT idf = idRadix + 1 ;
                {
                if( idRadix < psttP->idAdam )
    
                }
                    delF( tinP , psttw ) ;
                    mValue = strDigitsToSCountF( tinP , psttw , defaultRadixP , 1 ) ;
                    strSubstringF( tinP , psttw , idf , idl , psttd ) ; ___( psttw ) ;
                    countT idl = idRadix - 1 ;
                    countT idf = 1 ;
                {
                if( idRadix > 1 )
                ZE( strokeS* , psttw ) ;
            {
            if( psttP->idAdam < 2 || psttP[ CSpREFIX - 2 + psttP->idAdam ].idAdam != '_' )
        {
        if( psttd )
        ZE( countT , exp ) ;
        ZE( boolT , bExpNeg ) ;

        }
            delF( tinP , psttDoomed ) ;
            }
                strSubstringF( tinP , psttd , idf , idl , psttDoomed ) ; ___( psttd ) ;
                countT idl = psttDoomed->idAdam - 2 ;
                countT idf = 1 ;
            {
            if( psttDoomed->idAdam > 2 )
            strokeS* psttDoomed = psttd ; psttd = 0 ;

            }
                else if( stt.idAdam >= stt_qu.idAdam && stt.idAdam <= stt_at.idAdam ) radix = (countT)stt - '?' + 63 ;
                else if( stt.idAdam >=  stt_A.idAdam && stt.idAdam <=  stt_Z.idAdam ) radix = (countT)stt - 'A' + 37 ;
                else if( stt.idAdam >=  stt_a.idAdam && stt.idAdam <=  stt_z.idAdam ) radix = (countT)stt - 'a' + 11 ;
                else if( stt.idAdam >=  stt_1.idAdam && stt.idAdam <=  stt_9.idAdam ) radix = (countT)stt - '0' +  1 ;
                if( stt.idCaste == sc_cALPHABET1 && ( stt.idAdam & 0xf0000000 == sscDIGIT ) ) radix = stt.idAdam & 0xffff ;
    
                const strokeS stt_at( '@' ) ;
                const strokeS stt_qu( '?' ) ;
                const strokeS stt_Z( 'Z' ) ;
                const strokeS stt_A( 'A' ) ;
                const strokeS stt_z( 'z' ) ;
                const strokeS stt_a( 'a' ) ;
                const strokeS stt_9( '9' ) ;
                const strokeS stt_1( '1' ) ;
                //U: OPTIMIZE BY MAKING THESE STATIC
            {

            strokeS& stt = psttd[ CSpREFIX - 1 + psttd->idAdam ] ;
        {
        if( psttd->idAdam >= 2 && psttd[ CSpREFIX - 2 + psttd->idAdam ].idAdam == '_' )

        }
            strReverseF( tinP , psttd ) ; ___( psttd ) ;
            idRadix = psttP->idAdam + 1 - idRadix ;
        {
        if( !bForeignP )
        strMakeF( tinP , psttd , psttP ) ; ___( psttd ) ;
        ZE( strokeS* , psttd ) ;
    {
    else
    if( !idRadix ) mValue = strDigitsToSCountF( tinP , psttP , defaultRadixP , bForeignP ) ;
    boolT bNeg = strIdF( tinP , T("-") , psttP ) ;
    countT idRadix = strIdF( tinP , T(".") , psttP ) ;
    ZE( measureT , mValue ) ;

    _IO_

    // NOTE: THIS FUNCTION WAS CODED ASSUMING FOREIGN DIGIT ORDERING.  AFTER THE CODE WAS COMPLETED, IT WAS DECIDED TO ORDER DIGITS IN INCREASING SIGNIFICANCE WITHIN IFC
    //U: OPTIMIZE TO ELIMINATE USE OF strReverseF BY REWRITING THIS FUNCTION

    }
        if( POOP ) return 0 ;
        __( psttP->idCaste != sc_PREFIXlENGTH ) ;
        if( POOP ) return 0 ;
        __( radix > 0x40 ) ;
        __( radix < 2 ) ;
        __Z( psttP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL

    if( !radix ) radix = 0x10 ;
    countT radix = defaultRadixP ;
    SCOOP
{
/*1*/measureT etherC::strDigitsToMeasureF( tinS& tinP , const strokeS* const psttP , const countT defaultRadixP , const boolT bForeignP )/*1*/

#define BcANDYo(offP) ( psttc[ offP ].idCaste == sc_cFROMaSCII || psttc[ offP ].idCaste == sc_cALPHABET1 )
#define BcANDY ( psttc->idCaste == sc_cFROMaSCII || psttc->idCaste == sc_cALPHABET1 )
//"candy": "candidate"

/**/
*/
  1: Foreign digit ordering (most significant digit occurs first (i.e. at left)
  0: IdeaFarm " "(tm) City digit ordering (least significant digit occurs first (i.e. at left)
  can be 0 or 1
 bForeignP
  if nonze, must be at least 2 and not more than 64_9
  can be 0, which implies radix 16_9
 defaultRadixP
 psttP
arguments
after an overflow, the resulting sign will still be correct
overflow is not detected
 if there is a valid radix override, terminates with the radix override
 if there is a radix override but it is invalid (not a radix 64_9 digit) then impotence occurs
 if there is no radix override, terminates with the first stroke that is not a value radix 16 digit
conversion terminates with the first nonnumeric stroke
the radix override value is always expressed in radix 64_9 (the digits are 0..9 a..z A..Z ? @)
  "-YZ?@_@" is the radix 64_9 value -YZ?@
  "-EFEF_F" is the radix 42_9 value -EFEF
  "-yzyz_z" is the radix 36_9 value -yzyz
  "-efef_f" is the radix 16_9 (hex) value -efef
  "89abcde" is the radix 16_9 value 89abcde
  "10"      is the radix 16_9 value 10
  "0"       is the value 0
 a radix can be specified by appending an underscore "_" followed by a single radix 64_9 digit [0..9 a..z A..Z ? @]
an explicit radix overrides defaultRadixP
the plus sign is legal
the negative sign must be the first nonblank character
the number can contain leading blanks
  \<A HREF=\"5.1910104.1.1.0.html\"\>1910104:  WAKEsHOW( "example.simplest.func.1030057.etherC.strDigitsToSCountF" )\</A\>
 simplest
examples
\<A HREF=\"5.1030057.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strDigitsToSCountF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

