
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    TELL( "cleaning up" )
    DEL( pStBang4 ) ;
    DEL( pStBang3 ) ;
    DEL( pStBang2 ) ;
    DEL( pStBang1 ) ;
    DEL( pStBang0 ) ;
    TELL( "deleting bang stacks" )

    if( pStBang4 ) { godByeF( tinP , *pStBang4 ) ; cPoof += *pStBang4 ; }
    if( pStBang3 ) { godByeF( tinP , *pStBang3 ) ; cPoof += *pStBang3 ; }
    if( pStBang2 ) { godByeF( tinP , *pStBang2 ) ; cPoof += *pStBang2 ; }
    if( pStBang1 ) { godByeF( tinP , *pStBang1 ) ; cPoof += *pStBang1 ; }
    if( pStBang0 ) { godByeF( tinP , *pStBang0 ) ; cPoof += *pStBang0 ; }
    TELL( "unregistering my bang stacks and calc poof" )
    ZE( countT , cPoof ) ;

    }
        }
            ++ s ; tinP.zEtScratch->osSleepF( tinP , TUCK * 0x40 ) ;
        {
        while( tinP.cKidThreads )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {
    *tinP.zEtScratch = 0 ;
    TELL( "waiting for all kids to die" )

    if( !ether ) reportFailF( tinP , etThread , NODEiNFOaRGS , 1 , node , 7 ) ;
    TELL( "reporting my own death" )

    stNodeOpen.ungrabF( tinP ) ;
    if( nodeDns == node ) nodeDns = 0 ;
    stNodeOpen.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        }
            }
                else                { DEL( pso ) ; }
                if( !ether && pso ) etThread.osThreadF( tinP , countTC() , tmServerF , 0 , flTHREADlAUNCH_null , 0 , (countT)&_c8ni1P , (countT)&_c8ni2P , (countT)&_c8ni3P , (countT)pso , (countT)&sListen , (countT)&cBangClients ) ;
                TELL( "launching tmServerF" )
    
                }
                    break ;
                    DEL( pso ) ;
                    etherC::ifcSayIF( T("gasp!") , flSAY_APPEND | flSAY_LOG ) ;
                    TELL( "quitting" )
                {
                else if( bQuit )
                }
                    continue ;
    
                    etThread.osThreadF( tinP , countTC() , tmPingF , 0 , flTHREADlAUNCH_null , 0 , (countT)&_c8ni1P , (countT)&_c8ni2P , (countT)&_c8ni3P , (countT)&cBangClients ) ;
                    etThread.osThreadF( tinP , countTC() , tmKillF , 0 , flTHREADlAUNCH_null , 0 , (countT)&_c8ni1P , (countT)&_c8ni2P , (countT)&_c8ni3P ) ;
                    etThread.osThreadF( tinP , countTC() , tmPrayF , 0 , flTHREADlAUNCH_null , 0 , (countT)&_c8ni1P , (countT)&_c8ni2P , (countT)&_c8ni3P ) ;
                    }
                        bombF( tinP , etThread , NODEiNFOaRGS , sCry ) ;
                        hdrF( tinP , sCry , node , flPOP_BOMB , IDcMD2PE_CRY ) ;
                        soulC sCry( tinP , TAG( TAGiDnULL ) ) ;
                        TELL( "setting up 2.2" )
                    {

                    }
                        LAUNCHbANGcLIENT( 4 , IDtYPE2PEbANGcLIENTwORK_RIGHT    )
                        LAUNCHbANGcLIENT( 3 , IDtYPE2PEbANGcLIENTwORK_LEFT     )
                        LAUNCHbANGcLIENT( 2 , IDtYPE2PEbANGcLIENTwORK_EXPLODE2 )
                        LAUNCHbANGcLIENT( 1 , IDtYPE2PEbANGcLIENTwORK_EXPLODE1 )
                        LAUNCHbANGcLIENT( 0 , IDtYPE2PEbANGcLIENTwORK_IMPLODE  )
                    {
                    if( pStBang0 && pStBang1 && pStBang2 && pStBang3 && pStBang4 )
    
                    TELL( "setting up 2.3" )
                
                    pStBang4 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                    pStBang3 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                    pStBang2 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                    pStBang1 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                    pStBang0 = new( 0 , tinP , LF ) stackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                    TELL( "setting up 2.4" )
                
                    if( nodeDns ) stNodeOpen.sinkF( tinP , countTC() , (byteT*)nodeDns , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                                  stNodeOpen.sinkF( tinP , countTC() , (byteT*)&node   , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                    godHelloF( tinP , node ) ;
                    etherC::ifcSayIF( T("cry!") , flSAY_APPEND | flSAY_LOG ) ;
        
                    DEL( pso ) ;
                    { soulC sOk( tinP , TAG( TAGiDnULL ) , flSOUL_null , (countT)IDcMD2PE_SERVERoK ) ; pso->writeF( tinP , sOk ) ; }
                    bWoth = 0 ;
                {
                if( bWoth ) //WOTH CLIENT MUST NOT BE REFUSED
        
                }
                    sListen.acceptF( tinP , pso , idPortPeer , nnPeer , bRefuse ) ;
                    ZE( countT , idPortPeer ) ;
                    nicNameC nnPeer ;
                    boolT bRefuse = /*++ idClient == tinP.monitor.idThread && !( bRefused ++ ) ? 1 :*/ 0 ;
                    //static boolT bRefused ;
                {
                TELL( "waiting for a client to connect" )
                ZE( socketC* , pso ) ;
    
                if( bWoth ) etThread.osThreadF( tinP , countTC() , tmTickleF , 0 , flTHREADlAUNCH_null , 0 , node.idp , (countT)&bWoth ) ;
            {
            while( !etThread && !ether && !bQuit )
            ZE( countT , cBangClients ) ;
            ZE( countT , idClient ) ;
            boolT bWoth = 1 ;
        
            etThread.osTimeNowF( tinP , timeB1 , timeB2 ) ;
            ZE( sCountT , timeB2 ) ;
            ZE( countT  , timeB1 ) ;
        
            TELL( "setting up 2.b" )
            if( !ether ) sListen.listenF( tinP ) ;
            TELL( "setting up 2.c" )
            stNodeOpen.ungrabF( tinP ) ;
            }
                if( !cTries && !nodeDns ) nodeDns = node ;
                stNodeOpen.grabF( tinP , TAG( TAGiDnULL ) ) ;

                }
                    if( nodeDns ) break ;
                    ether.osSleepF( tinP , TOCK ) ;
                {
                while( !ether && cTries -- )
                countT cTries = TUCK / /*8*/0x40 ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ; //GIVE EXISTING NODES TIME TO ASSUME THE DNS ROLE

                stNodeOpen.ungrabF( tinP ) ;
            {
            if( !nodeDns )
            stNodeOpen.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( node )
        node = sListen.bindF( tinP ) ;
        TELL( "setting up 2.d" )
        socketC sListen( tinP , etThread , TAG( TAGiDnULL ) ) ;
        TELL( "setting up 2" )
    {
    stackC*& pStBang4 = *(stackC**)&_c8ni3P.c2 ;
    stackC*& pStBang3 = *(stackC**)&_c8ni3P.c1 ;
    stackC*& pStBang2 = *(stackC**)&_c8ni2P.c8 ;
    stackC*& pStBang1 = *(stackC**)&_c8ni2P.c7 ;
    stackC*& pStBang0 = *(stackC**)&_c8ni2P.c6 ;
    count8S _c8ni3P( 0 , 0 , (countT)&stPsoServer , (countT)&stIdSerialReceived , (countT)&bTalk ) ;
    count8S _c8ni2P( (countT)&stNodeFailReply , (countT)&stNodeZombie , (countT)&stNodeZombieOld , (countT)&stNodeTest , (countT)&stNodeCurrentBangClient ) ;
    count8S _c8ni1P( idMe , (countT)&node , (countT)&etScratch , (countT)&bQuit , (countT)&ruZeWo , (countT)&stNodeOpen , (countT)&stNodeFailConnect , (countT)&stNodeFailConnectOld ) ;

    ZE( boolT , bTalk ) ;
    nodeC node( tinP , etThread , idMe ) ;
    ZE( boolT , bQuit ) ;
    ranUniC ruZeWo( 1 , 1 ) ;
    stackC stPsoServer(             tinP , etThread , TAG( TAGiDnULL ) ) ;
    stackC stIdSerialReceived(      tinP , etThread , TAG( TAGiDnULL ) ) ;
    stackC stNodeCurrentBangClient( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;
    stackC stNodeTest(              tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;
    stackC stNodeZombieOld(         tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;
    stackC stNodeZombie(            tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;
    stackC stNodeFailReply(         tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;
    stackC stNodeFailConnectOld(    tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;
    stackC stNodeFailConnect(       tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;
    stackC stNodeOpen(              tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ; // { node , timeBorn1 , timeBorn2 }, SORTED BY TIME BORN
    etherC& ether = etherC::etPrimeIF() ;
    const countT idMe = 1 + incv02AM( idMeLath ) ;
    static countT idMeLath ;
    _IO_     TELLsYSlIFInAME( "nodeMainF" )
{
voidT nodeMainF( tinS& tinP , etherC& etThread )

DONE( tmPrayF )
}
    }
        }
            }
                ++ s ; etThread.osSleepF( tinP , TUCK * 0x40 ) ;
            {
            while( !etThread && !ether && !bQuitP && cToDo -- )
            countT cToDo = TUCK / 0x10 ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        TELL( "sleeping for up to 4 tock" )

        godPrayF( tinP , etThread , stNodeOpenP , nodeP , bTalkP ) ;
        _IO_     TELLsYSlIFInAME( "tmPrayF2" )
    {
    while( !bQuitP && !etThread && !stNodeOpenP.third && !ether )
    _IO_     TELLsYSlIFInAME( "tmPrayF1" )

    NODEiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmPrayF )

DONE( tmPingF )
}
    }
        }
            ++ s ; ether.osSleepF( tinP , TOCK * 0x4 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        TELL( "napping for 4 tocks" )
        tinP.idPhase2 = 0 ;
        //CONoUTrAW3( "" , idMeP , "| -\r\n" ) ;
        }
            }
                }
                    bombF( tinP , etThread , NODEiNFOaRGS , sCry ) ;
                    CONoUTrAW3( "" , idMeP , "| NO BANG CLIENTS!!!!\r\n" ) ;
                    hdrF( tinP , sCry , nodeP , flPOP_BOMB , IDcMD2PE_CRY ) ;
                    soulC sCry( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( !cBangClientsP )
                stNodeOpenP.ungrabF( tinP ) ;
                _IO_

                }
                    tinP.idPhase2 = 2 ;
                    bSawOthers = 1 ;
                {
                if( !bSawOthers )
            {
            else
            }
                }
                    bombF( tinP , etThread , NODEiNFOaRGS , sCry , nodeDnsCopy ) ;
                    hdrF( tinP , sCry , nodeP , flPOP_BOMB , IDcMD2PE_CRY ) ;
                    soulC sCry( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( nodeDnsCopy && nodeDnsCopy != nodeP )
                stNodeOpenP.ungrabF( tinP ) ;
                nodeC nodeDnsCopy = nodeDns ;
                _IO_
            {
            if( !stNodeOpenP || ( stNodeOpenP == 1 && *(nodeC*)&stNodeOpenP[ 1 ] == nodeP ) ) //IF I THINK I'M ALONE
            TELL( "inspecting to see whether my list contains only me" )
            stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            _IO_     TELLsYSlIFInAME( "seeing if i am alone or have no clients" )
        {
        TELL( "grabbing open list 2" )

        //}
        //    }
        //        popF( tinP , etThread , etScratchNodeP , pStBang0P , pStBang1P , pStBang2P , pStBang3P , pStBang4P , sPing , bDud ) ;
        //        TELL( "popping" )
        //
        //        stNodeOpenP.ungrabF( tinP ) ;
        //        }
        //            while( !stNodeOpenP.third && ~hDown ) ;
        //            do sPing << *(count4S*)&stNodeOpenP.downF( tinP , hDown ) ;
        //            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        //        {
        //        if( stNodeOpenP )
        //        sPing << (countT)stNodeOpenP ;
        //        TELL( "pushing my open list into the ping soul" )
        //
        //        stNodeFailConnectP.ungrabF( tinP ) ;
        //        }
        //            while( !stNodeFailConnectP.third && ~hDown ) ;
        //            do if( stNodeOpenP( (byteT*)&stNodeFailConnectP.downF( tinP , hDown ) , subtractNodesF ) ) stNodeOpenP.extractF( 0 , tinP ) ;
        //            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        //        {
        //        if( stNodeFailConnectP )
        //        TELL( "removing from the open list the entries that i know have failed" )
        //        stNodeFailConnectP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        //        TELL( "grabbing failConnect list" )
        //        stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        //        TELL( "grabbing open list" )
        //
        //        hdrF( tinP , sPing , nodeP , flPOP_DOWN|flPOP_UP , IDcMD2PE_PING ) ;
        //        soulC sPing( tinP , TAG( TAGiDnULL ) ) ;
        //        const boolT bDud = stNodeOpenP > 1 && stNodeOpenP( (byteT*)nodeP , subtractNodesF ) != 1 ;
        //        TELL( "preparing to ping" )
        //    {
        //{
        //else if( !( cSkip && cSkip -- ) )
        //}
        //    cSkip = 0 ; //U::8
        //    if( idMeP == 1 ) CONoUTrAW3( "----" , cBack , "----\r\n" ) ;
        //{
        //if( cBack )
        //countT cBack = godBacklogF( tinP ) ;
        //TELL( "inspecting backlog" )

        //}
        //    stNodeTestCopy.purgeF( tinP ) ;
        //    while( !bQuitP && !ether && !stNodeTestCopy.third && ~hDown ) ;
        //    }
        //        }
        //            stNodeOpenP.ungrabF( tinP ) ;
        //            if( stNodeOpenP( (byteT*)nodet , subtractNodesF ) ) stNodeOpenP.extractF( 0 , tinP ) ;
        //            stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        //            *tinP.zEtScratch = 0 ;
        //        {
        //        else
        //        if( !*tinP.zEtScratch ) stNodeOpenP.sinkF( tinP , countTC() , (byteT*)nodet , flSTACKsINK_UNIQUE , subtractNodesF ) ;
        //        boolT bFail = !!*tinP.zEtScratch ;
        //        testF( tinP , *tinP.zEtScratch , nodet , nodeP ) ;
        //        if( bTalkP ) { CONoUTrAW5( "" , idMeP , "| testing " , *(countT*)&nodet , "\r\n" ) ; }
        //        nodeC& nodet = *(nodeC*)&stNodeTestCopy.downF( tinP , hDown ) ;
        //    {
        //    do
        //    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        //{
        //if( stNodeTestCopy )

        //stNodeTestP.ungrabF( tinP ) ;
        //}
        //    stNodeTestP.purgeF( tinP ) ;
        //    while( !stNodeTestP.third && ~hDown ) ;
        //    }
        //        stNodeTestCopy << (byteT*)nodet ;
        //        nodeC& nodet = *(nodeC*)&stNodeTestP.downF( tinP , hDown ) ;
        //    {
        //    do
        //    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        //{
        //if( stNodeTestP )
        //stNodeTestP.grabF( tinP , TAG( TAGiDnULL ) ) ;

        //}
        //    stNodeExpected.purgeF( tinP ) ;
        //    while( !stNodeExpected.third && ~hDown ) ;
        //    }
        //        stNodeTestCopy << (byteT*)nodee ;
        //        if( bTalkP ) { CONoUTrAW5( "" , idMeP , "| absent: " , *(countT*)&nodee , "\r\n" ) ; }
        //        nodeC& nodee = *(nodeC*)&stNodeExpected.downF( tinP , hDown ) ;
        //    {
        //    do
        //    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        //{
        //if( stNodeExpected )
        //stackC stNodeTestCopy( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;

        //}
        //    while( !stNodeExpected.third && ~hDown ) ;
        //    }
        //        stNodeCurrentBangClientP.ungrabF( tinP ) ;
        //        }
        //            stNodeExpected.extractF( 0 , tinP ) ;
        //            if( bTalkP ) { CONoUTrAW5( "" , idMeP , " i see " , stNodeCurrentBangClientP[ 0 ] , "\r\n" ) ; }
        //        {
        //        if( stNodeCurrentBangClientP( (byteT*)nodee , subtractNodesF ) )
        //        stNodeCurrentBangClientP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        //        nodeC& nodee = *(nodeC*)&stNodeExpected.downF( tinP , hDown ) ;
        //    {
        //    do
        //    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        //{
        //if( stNodeExpected )

        //}
        //    }
        //        if( nodeExpected2 ) stNodeExpected.sinkF( tinP , countTC() , (byteT*)nodeExpected2 , flSTACKsINK_UNIQUE , subtractNodesF ) ;
        //        if( nodeExpected1 ) stNodeExpected.sinkF( tinP , countTC() , (byteT*)nodeExpected1 , flSTACKsINK_UNIQUE , subtractNodesF ) ;
        //        nodeClientF( tinP , nodeExpected1 , nodeExpected2 , stNodeOpenP , nodeP , pcIdWork[ off ] ) ;
        //        nodeC nodeExpected2  ;
        //        nodeC nodeExpected1  ;
        //    {
        //    for( countT off = 0 ; off < sizeof pcIdWork / sizeof pcIdWork[ 0 ] ; off ++ )
        //
        //    } ;
        //        IDtYPE2PEbANGcLIENTwORK_RIGHT
        //        IDtYPE2PEbANGcLIENTwORK_LEFT     ,
        //        IDtYPE2PEbANGcLIENTwORK_EXPLODE2 ,
        //        IDtYPE2PEbANGcLIENTwORK_EXPLODE1 ,
        //        IDtYPE2PEbANGcLIENTwORK_IMPLODE  ,
        //    {
        //    countT pcIdWork[] = 
        //{
        //stackC stNodeExpected( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;

        stNodeOpenP.ungrabF( tinP ) ;
        if( !nodeDns ) nodeDns = nodeP ;
        stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;

        stNodeZombieP.ungrabF( tinP ) ;
        }
            stNodeZombieP.purgeF( tinP ) ;
            while( !stNodeZombieP.third && ~hDown ) ;
            }
                stNodeZombieOldP.sinkF( tinP , countTC() , (byteT*)nodez , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                nodeC& nodez = *(nodeC*)&stNodeZombieP.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( stNodeZombieP )
        stNodeZombieP.grabF( tinP , TAG( TAGiDnULL ) ) ;

        }
            }
                stTest.purgeF( tinP ) ;
                while( !stTest.third && ~hDown ) ;
                }
                    bombF( tinP , etThread , NODEiNFOaRGS , sCry , nodeSlandered ) ; //TO TEST HIM
                    if( bTalkP ) { CONoUTrAW5( "" , idMeP , "| testing slandered " , *(countT*)&nodeSlandered , "\r\n" ) ; }
                    hdrF( tinP , sCry , nodeP , flPOP_null , IDcMD2PE_CRY ) ;
                    soulC sCry( tinP , TAG( TAGiDnULL ) ) ;
                    nodeC& nodeSlandered = *(nodeC*)&stTest.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                _IO_     TELLsYSlIFInAME( "testing slandered nodes" )
            {
            if( stTest )

            stNodeZombieOldP.ungrabF( tinP ) ;
            }
                stNodeZombieOldP.purgeF( tinP ) ;
                while( !stNodeZombieOldP.third && ~hDown ) ;
                }
                    stTest.sinkF( tinP , countTC() , (byteT*)nodeSlandered , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                    nodeC& nodeSlandered = *(nodeC*)&stNodeZombieOldP.downF( tinP , hDown ) ;
                {
                do
                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( stNodeZombieOldP )
            stNodeZombieOldP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            stackC stTest( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;
        {

        stNodeFailConnectP.ungrabF( tinP ) ;
        stNodeFailConnectP.purgeF( tinP ) ;
        }
            while( !stNodeFailConnectP.third && ~hDown ) ;
            }
                stNodeFailConnectOldP.sinkF( tinP , countTC() , (byteT*)nodef , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                nodeC& nodef = *(nodeC*)&stNodeFailConnectP.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( stNodeFailConnectP )
        stNodeFailConnectP.grabF( tinP , TAG( TAGiDnULL ) ) ;

        stNodeFailConnectOldP.purgeF( tinP ) ;
        //CONoUTrAW3( "" , idMeP , "| +\r\n" ) ;
        tinP.idPhase2 = 1 + bSawOthers ;
        _IO_     TELLsYSlIFInAME( "tmPingF1" )
    {
    while( !etThread && !stNodeOpenP.third && !ether && !bQuitP )
    ZE( boolT , bSawOthers ) ;
    //static countT cSkip ;

    countT& cBangClientsP = *(countT*)pTaskP->c4 ;
    NODEiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmPingF )

DONE( tmKillF )
}
    }
        stPsoServerP.ungrabF( tinP ) ;
        }
            while( !etThread && !stPsoServerP.third && ~handle ) ;
            }
                }
                    *tinP.zEtScratch = 0 ;
                    hSoc.closeIfF() ;
                    handleC& hSoc = *(handleC*)&pso->handleF( tinP ) ;
                {
                if( pso )
                __Z( pso ) ;
                socketC* pso = (socketC*)stPsoServerP.downF( tinP , handle ) ;
            {
            do
            handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( !etThread && !stPsoServerP.third && stPsoServerP )
        stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    *tinP.zEtScratch = 0 ;
    }
        sock.connectF( tinP , nodeP.idp ) ;
        socketC sock( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) ) ;
    {
    if( pStBang4P ) *pStBang4P << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
    if( pStBang3P ) *pStBang3P << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
    if( pStBang2P ) *pStBang2P << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
    if( pStBang1P ) *pStBang1P << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
    if( pStBang0P ) *pStBang0P << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
    //U:: USE THE ___ MACRO TO TAG THESE DROPS
    bQuitP = 1 ;
    TELL( "killing" )

    }
        }
            if( *tinP.zEtScratch ) *tinP.zEtScratch = 0 ;
            writeF( tinP , *tinP.zEtScratch , nodeTo , sGasp ) ;
            hdrF( tinP , sGasp , nodeP , flPOP_BOMB , IDcMD2PE_GASP ) ;
            soulC sGasp( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( nodeTo )

        if( nodeTo == nodeP ) nodeTo = *(nodeC*)&stNodeOpenP[ 2 ] ;
        nodeC& nodeTo = *(nodeC*)&stNodeOpenP[ 1 ] ;
        TELL( "writing sGasp" )
    {
    godByeF( tinP , nodeP ) ;
    CONoUTrAW3( "" , idMeP , "| gasp!\r\n" ) ;
    _IO_     TELLsYSlIFInAME( "tmKillF1" )

    }
        ++s ; ether.osSleepF( tinP , time1l ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        countT time1l = godMyLifespanF( tinP , nodeP ) ;
    {
    TELL( "napping for life" )

    NODEiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmKillF )

DONE( tmTickleF )
}
    }
        }
            ether.osSleepF( tinP , TUCK * 0x40 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            *tinP.zEtScratch = 0 ;
        {
        else
        if( !*tinP.zEtScratch ) break ;
        VERIFY( sock ) ;
        sock.connectF( tinP , idpP ) ;
        socketC sock( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) ) ;
        _IO_     TELLsYSlIFInAME( "tmTickleF1" )
    {
    while( !ether && bWothP )

    boolT& bWothP = *(boolT*)pTaskP->c2 ;
    countT idpP   =          pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmTickleF )

DONE( tmServerF )
}
    if( bBangClient && !bSaidBye && !ether && !bQuitP ) reportFailF( tinP , etThread , NODEiNFOaRGS , 1 , nodeBangClient , 0x21 ) ;

    }
        dec02AM( cBangClientsP ) ;
        stNodeCurrentBangClientP.ungrabF( tinP ) ;
        if( stNodeCurrentBangClientP( (byteT*)nodeBangClient , subtractNodesF ) ) stNodeCurrentBangClientP.extractF( 0 , tinP ) ;
        stNodeCurrentBangClientP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( bBangClient )
    TELL( "cleaning up" )

    }
        DEL( psoP ) ;
        stPsoServerP.ungrabF( tinP ) ;
        if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
        stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( psoP )
    TELL( "deleting socket" )
    }
        TELL( "writing ok-" )
        }
            psoP->writeF( tinP , sOk ) ;
        {
        if( psoP )
        TELL( "writing ok+" )

        }
            }
                break ;
                }
                    DEL( psoP ) ;
                    stPsoServerP.ungrabF( tinP ) ;
                    if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
                    stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( psoP )
            {
            if( *tinP.zEtScratch )
            TELL( "testing *tinP.zEtScratch 1" )

            }
                else                        popF( tinP , etThread , etScratchNodeP , pStBang0P , pStBang1P , pStBang2P , pStBang3P , pStBang4P , sIn ) ;
                if( F(flags) & flPOP_BOMB ) bombF( tinP , etThread , NODEiNFOaRGS , sIn ) ;

                }
                    }
                        break ;
                        TELL( "IDcMD2PE_USERcOMMANDS-" )
                        osTextT* postIn = sIn.pbFieldF( tinP , countTC() , countTC() , countTC() , IDfIELD_IDcMD + 1 ) ;
                        TELL( "IDcMD2PE_USERcOMMANDS+" )
                    {
                    case IDcMD2PE_USERcOMMANDS :
                    }
                        break ;
                        TELL( "IDcMD2PE_PING-" )

                        }
                            while( !stNodeSlander.third && ~hDown ) ;
                            }
                                stNodeZombieP.sinkF( tinP , countTC() , (byteT*)nodeSlander , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                                nodeC& nodeSlander = *(nodeC*)&stNodeSlander.downF( tinP , hDown ) ;
                            {
                            do
                            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        {
                        if( stNodeSlander )

                        stHisList.purgeF( tinP ) ;
                        }
                            while( !stHisList.third && ~hDown ) ;
                            }
                                if( nodeSubject && !stNodeFailConnectP( (byteT*)nodeSubject , subtractNodesF ) && !stNodeFailConnectOldP( (byteT*)nodeSubject , subtractNodesF ) ) stNodeOpenP.sinkF( tinP , countTC() , (byteT*)nodeSubject , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                                if( nodeSubject && stNodeSlander(       (byteT*)nodeSubject , subtractNodesF )                                                                   ) stNodeSlander.extractF( 0 , tinP ) ;
                                nodeC& nodeSubject = *(nodeC*)&stHisList.downF( tinP , hDown ) ;
                            {
                            do
                            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        {
                        if( stHisList )
                        hisListF( tinP , stHisList , sIn ) ;
                        stackC stHisList( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;
                        countT nodeHim = nodeOrigin ;

                        stNodeOpenP.ungrabF( tinP ) ;
                        }
                            while( !stNodeOpenP.third && ~hDown ) ;
                            do stNodeSlander.sinkF( tinP , countTC() , (byteT*)&stNodeOpenP.downF( tinP , hDown ) , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        {
                        if( stNodeOpenP )
                        stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        stackC stNodeSlander( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;

                        TELL( "IDcMD2PE_PING+" )
                    {
                    case IDcMD2PE_PING :
                    }
                        break ;
                        TELL( "IDcMD2PE_NODEfAILEDcONNECT-" )
                        }
                            stNodeOpenP.ungrabF( tinP ) ;
                            if( stNodeOpenP( (byteT*)nodeBad , subtractNodesF ) ) stNodeOpenP.extractF( 0 , tinP ) ;
                            stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            stNodeFailConnectP.sinkF( tinP , countTC() , (byteT*)nodeBad , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                        {
                        if( nodeBad )
                        countT& idSerialFailNote = sIn.cFieldF( tinP , IDfIELD_IDsERIAL ) ;
                        nodeC& nodeBad = nodeC::fieldF( tinP , sIn , IDfIELD_IDcMD + 1 ) ;
                        TELL( "IDcMD2PE_NODEfAILEDcONNECT+" )
                    {
                    case IDcMD2PE_NODEfAILEDcONNECT :
                    }
                        break ;
                        TELL( "IDcMD2PE_NODEfAILEDrEAD-" )
                        if( nodeBad ) stNodeFailReplyP.sinkF( tinP , countTC() , (byteT*)nodeBad , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                        nodeC& nodeBad = nodeC::fieldF( tinP , sIn , IDfIELD_IDcMD + 1 ) ;
                        TELL( "IDcMD2PE_NODEfAILEDrEAD+" )
                    {
                    case IDcMD2PE_NODEfAILEDrEAD :
                    }
                        break ;
                        TELL( "IDcMD2PE_GASP-" )
                        stNodeOpenP.ungrabF( tinP ) ;
                        if( stNodeOpenP( (byteT*)nodeOrigin , subtractNodesF ) ) stNodeOpenP.extractF( 0 , tinP ) ;
                        stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        TELL( "IDcMD2PE_GASP+" )
                    {
                    case IDcMD2PE_GASP :
                    }
                        break ;
                        TELL( "IDcMD2PE_CRY-" )

                        }
                            bombF( tinP , etThread , NODEiNFOaRGS , sPing , nodeOrigin , 1 ) ;
                            myListF( tinP , sPing , stNodeOpenP ) ;
                            hdrF( tinP , sPing , nodeP , flPOP_null , IDcMD2PE_PING ) ;
                            soulC sPing( tinP , TAG( TAGiDnULL ) ) ;
                            TELL( "preparing to ping" )
                        {
                        if( *(nodeC*)&stNodeOpenP[ 1 ] == nodeP ) //WELCOME THE NEWCOMER WITH A PING SO THAT IT HAS A FULL LIST

                        if( nodeOrigin ) stNodeOpenP.sinkF( tinP , countTC() , (byteT*)nodeOrigin , flSTACKsINK_UNIQUE , subtractNodesF ) ;

                        stNodeFailConnectP.ungrabF( tinP ) ;
                        if( stNodeFailConnectP( (byteT*)nodeOrigin , subtractNodesF ) ) stNodeFailConnectP.extractF( 0 , tinP ) ;
                        stNodeFailConnectP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                        //PSEUDOdUPLICATEDcODE: fff0104 fff0104
                        TELL( "IDcMD2PE_CRY+" )
                    {
                    case IDcMD2PE_CRY :
                    }
                        break ;
                        TELL( "IDcMD2PE_CLIENTbANGbYE-" )
                        bSaidBye = 1 ;
                        nodeBangClient = 0 ;
                        TELL( "IDcMD2PE_CLIENTbANGbYE+" )
                    {
                    case IDcMD2PE_CLIENTbANGbYE :
                    }
                        break ;
                        TELL( "IDcMD2PE_CLIENTbANGhELLO-" )

                        }
                            stNodeOdd.ungrabF( tinP ) ;
                            }
                                while( !stNodeOdd.third && ~hDown ) ;
                                }
                                    stNodeTestP.sinkF( tinP , countTC() , (byteT*)nodeOdd , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                                    nodeC& nodeOdd = *(nodeC*)&stNodeOdd.downF( tinP , hDown ) ;
                                {
                                do
                                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( stNodeOdd )
                            stNodeOdd.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( !bNewbie )

                        myListF( tinP , sOk , stNodeOdd ) ;
                        }
                            stNodeHisList.ungrabF( tinP ) ;
                            }
                                while( !stNodeHisList.third && ~hDown ) ;
                                }
                                    if( !stNodeOpenP( (byteT*)nodeOdd , subtractNodesF ) ) stNodeOdd.sinkF( tinP , countTC() , (byteT*)nodeOdd , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                                    nodeC& nodeOdd = *(nodeC*)&stNodeHisList.downF( tinP , hDown ) ;
                                {
                                do
                                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( stNodeHisList )
                            stNodeHisList.grabF( tinP , TAG( TAGiDnULL ) ) ;

                            stNodeOpenP.ungrabF( tinP ) ;
                            }
                                while( !stNodeOpenP.third && ~hDown ) ;
                                }
                                    if( !stNodeHisList( (byteT*)nodeOdd , subtractNodesF ) ) stNodeOdd.sinkF( tinP , countTC() , (byteT*)nodeOdd , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                                    nodeC& nodeOdd = *(nodeC*)&stNodeOpenP.downF( tinP , hDown ) ;
                                {
                                do
                                handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( stNodeOpenP )
                            stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( nodeMeVerify != nodeP || ( nodeHimVerify1 != nodeOrigin && nodeHimVerify2 != nodeOrigin ) )
                        stackC stNodeOdd( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;

                        }
                            nodeServerF( tinP , nodeHimVerify2 , stNodeOpenP , nodeP , idWorkInvert2 ) ;
                            nodeServerF( tinP , nodeHimVerify1 , stNodeOpenP , nodeP , idWorkInvert1 ) ;
                            idWorkInvertIF( tinP , idWorkInvert1 , idWorkInvert2 , idWork ) ;
                            ZE( countT , idWorkInvert2 ) ;
                            ZE( countT , idWorkInvert1 ) ;
                        {
                        nodeC nodeHimVerify2  ; //CALC HIS IDENTITY USING MY LIST
                        nodeC nodeHimVerify1  ; //CALC HIS IDENTITY USING MY LIST

                        nodeServerF( tinP , nodeMeVerify , stNodeOpenP , nodeBangClient , idWork ) ;
                        nodeC nodeMeVerify ; //CALC MY IDENTITY USING MY LIST

                        hisListF( tinP , stNodeHisList , sIn , IDfIELD_IDcMD + 3 ) ;
                        stackC stNodeHisList( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;
                        bNewbie = sIn.cFieldF( tinP , IDfIELD_IDcMD + 2 ) ;
                        idWork = sIn.cFieldF( tinP , IDfIELD_IDcMD + 1 ) ;

                        inc02AM( cBangClientsP ) ;
                        bBangClient = 1 ;
                        stNodeCurrentBangClientP.sinkF( tinP , countTC() , (byteT*)nodeBangClient , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                        nodeBangClient = nodeOrigin ;
                        TELL( "IDcMD2PE_CLIENTbANGhELLO+" )
                    {
                    case IDcMD2PE_CLIENTbANGhELLO :
                {
                switch( idCmd ) //ALL PROCESSING HERE MUST BE FAST; LONG PROCESSING SHOULD BE DONE AFTER BANGING
                if( *tinP.zEtScratch ) { BLAMMO ; }
                TELL( "local processing" )

                stNodeOpenP.sinkF( tinP , countTC() , (byteT*)nodeOrigin , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                stIdSerialReceivedP.sinkF( tinP , countTC() , idSerial , flSTACKsINK_UNIQUE ) ;
                TELL( "registering serial" )
            {
            else if( !stIdSerialReceivedP( idSerial ) ) //U::USE OO STACKS AND DISCARD THE OLD INFO
            }
                }
                    DEL( psoP ) ;
                    stPsoServerP.ungrabF( tinP ) ;
                    if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
                    stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( psoP )
            {
            if( !idSerial )
            TN( tcr , "\r\n" ) ;
            TELL( "handling soul" )
    
            countT   idCmd      = sIn.cFieldF( tinP , IDfIELD_IDcMD ) ;
            flagsT&  flags      = sIn.cFieldF( tinP , IDfIELD_FLAGS ) ;
            countT   idSerial   = sIn.cFieldF( tinP , IDfIELD_IDsERIAL ) ;
            TELL( "inspecting received soul" )
        {
        if( psoP )

        }
            break ;
            }
                DEL( psoP ) ;
                stPsoServerP.ungrabF( tinP ) ;
                if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
                stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( psoP )
        {
        if( bQuitP )

        }
            break ;
            if( !ether && !bQuitP && nodeOriginLathGood ) reportFailF( tinP , etThread , NODEiNFOaRGS , 0 , nodeOriginLathGood , 6 ) ;
            *tinP.zEtScratch = 0 ;
            }
                DEL( psoP ) ;
                stPsoServerP.ungrabF( tinP ) ;
                if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
                stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( psoP )
        {
        else
        if( !*tinP.zEtScratch ) nodeOriginLathGood = nodeOrigin ;

        //}
        //    }
        //        break ;
        //        DEL( psoP ) ;       //8: does not work
        //        stPsoServerP.ungrabF( tinP ) ;
        //        if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
        //        stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        //    {                      //01: works
        //    if( ruZeWoP < (measureT)1/(measureT)0x10 )
        //{


        nodeC& nodeOrigin = *tinP.zEtScratch ? nodeNull : nodeC::fieldF( tinP , sIn , IDfIELD_NODEoRIGIN ) ;
        nodeC nodeNull ;
        _IO_     TELLsYSlIFInAME( "tmServerF1" )
        psoP->readF( tinP , sIn ) ;
        soulC sIn( tinP , TAG( TAGiDnULL ) ) ;
        TELL( "reading soul" )
    {
    while( !etThread && !ether && !bQuitP && psoP )
    ZE( boolT  , bSaidBye ) ;
    ZE( boolT  , bNewbie ) ;
    ZE( countT , idWork ) ;
    ZE( boolT  , bBangClient ) ;
    ZE( countT , idPingLath ) ;
    nodeC nodeOriginLathGood ;
    nodeC nodeBangClient ;
    soulC sOk( tinP , TAG( TAGiDnULL ) , flSOUL_null , (countT)IDcMD2PE_SERVERoK ) ;

    psoP->etherF( tinP , *tinP.zEtScratch ) ;

    stPsoServerP.sinkF( tinP , countTC() , (countT)psoP , flSTACKsINK_UNIQUE ) ;

    countT&  cBangClientsP =  *(countT*)pTaskP->c6 ;
    socketC& sListenP      = *(socketC*)pTaskP->c5 ;
    socketC* psoP          =  (socketC*)pTaskP->c4 ;
    NODEiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TELL( "setting up" )
TASK( tmServerF )

DONE( tmBangClientF )
}
    TELL( "cleaning up" )

    DEL( pso ) ;
    }
        }
            DEL( ps ) ;
            TELL( "deleting soul" )
            }
                }
                    break ;
                    nodePeer = 0 ;
                    DEL( pso ) ;
                    }
                        if( !bQuitP ) reportFailF( tinP , etThread , NODEiNFOaRGS , 0 , nodePeer , 5 ) ;
                        stBang.insertF( tinP , (countT)ps , ifcSTACKtYPE_PTR_soulC , 1 ) ;
                    {
                    if( !ether && !bQuitP )
                    *tinP.zEtScratch = 0 ;
                {
                if( *tinP.zEtScratch )
                TELL( "reading ok-" )
                VERIFY( *pso ) ;
                TELL( "reading ok+ 5" )
                pso->writeF( tinP , *ps ) ;
                TELL( "writing bang" )
            {
            if( pso && !ether && !bQuitP && *ps >= 4 ) //CODEsYNC df40104 df40104
            stBang >> ps ;
            ZE( soulC* , ps ) ;
            TELL( "pulling from stBang" )
        {
        while( stBang )
        
        }
            if( !ether && !bQuitP ) nodeServerF( tinP , nodePeerCorrect , stNodeOpenP , nodeP , idWorkP ) ;
            nodePeerCorrect = 0 ;
            }
                }
                    nodePeer = 0 ;
                    if( !ether && !bQuitP ) reportFailF( tinP , etThread , NODEiNFOaRGS , 1 , nodePeer , 4 ) ; //FAILURE TO REPLY TO HELLO COUNTS AS A CONNECTION FAILURE (THIS WILL OCCUR WHEN THE SERVER REFUSES THE CONNECTION AND THUS DELETES THE SOCKET IMMEDIATELY)
                    DEL( pso ) ;
                    *tinP.zEtScratch = 0 ;
                {
                else
                }
                    break ;
                    }
                        stOdd.ungrabF( tinP ) ;
                        }
                            while( !stOdd.third && ~hDown ) ;
                            }
                                stNodeOpenP.ungrabF( tinP ) ;
                                else                                                stNodeOpenP.sinkF( tinP , countTC() , (byteT*)nodeo , flSTACKsINK_UNIQUE , subtractNodesF ) ;
                                if( stNodeOpenP( (byteT*)nodeo , subtractNodesF ) ) stNodeOpenP.extractF( 0 , tinP ) ;
                                stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                nodeC& nodeo = *(nodeC*)&stOdd.downF( tinP , hDown ) ;
                            {
                            do
                            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        {
                        if( stOdd )
                        stOdd.grabF( tinP , TAG( TAGiDnULL ) ) ;

                        hisListF( tinP , stOdd , sOk , 2 ) ;
                        stackC stOdd( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;
                    {
                    else
                    else if( !bNewbie ) hisListF( tinP , stNodeTestP , sOk , 2 ) ; //NEWBIES DO NO TESTING; THEY ASSUME THAT THE SERVER'S LIST IS CORRECT
                    if( !sOk.cFieldF( tinP , 2 ) ) bNewbie = 0 ; //WHEN MY LIST AGREES WITH A SERVER THEN I AM NO LONGER A NEWBIE
                {
                if( !*tinP.zEtScratch )
                TELL( "reading ok-" )
                VERIFY2( sOk , *pso ) ;
                soulC sOk( tinP , TAG( TAGiDnULL ) ) ;
                TELL( "reading ok+ 3" )
                pso->writeF( tinP , sHello ) ;

                myListF( tinP , sHello , stNodeOpenP ) ;
                sHello << bNewbie ;
                sHello << idWorkP ;
                hdrF( tinP , sHello , nodeP , flPOP_null , IDcMD2PE_CLIENTbANGhELLO ) ;
                soulC sHello( tinP , TAG( TAGiDnULL ) ) ;
                TELL( "writing hello" )
            {
            else
            }
                nodePeer = 0 ;
                }
                    stNodeOpenP.ungrabF( tinP ) ;
                    if( stNodeOpenP( (byteT*)nodePeer , subtractNodesF ) ) stNodeOpenP.extractF( 0 , tinP ) ;
                    stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                else if( !bQuitP )
                if( !bQuitP ) reportFailF( tinP , etThread , NODEiNFOaRGS , 1 , nodePeer , 3 ) ;
                DEL( pso ) ;
                *tinP.zEtScratch = 0 ;
            {
            else if( *tinP.zEtScratch )
            }
                nodePeer = 0 ;
                DEL( pso ) ;
                *tinP.zEtScratch = 0 ;
            {
            if( ether || bQuitP )
            pso->connectF( tinP , nodePeer.idp ) ;
            TELL( "connecting" )
            nodePeer = nodePeerCorrect ;
            pso = new( 0 , tinP , LF ) socketC( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) ) ; ___( pso ) ;
            TELL( "looping to write hello" )
        {
        while( !ether && !bQuitP && !pso && nodePeerCorrect )
        
        }
            nodePeer = 0 ;
            DEL( pso ) ;
            }
                if( !ether && !bQuitP ) reportFailF( tinP , etThread , NODEiNFOaRGS , 0 , nodePeer , 2 ) ;
                *tinP.zEtScratch = 0 ;
            {
            if( *tinP.zEtScratch )
            TELL( "reading ok-" )
            VERIFY( *pso ) ;
            TELL( "reading ok+ 2" )
            pso->writeF( tinP , sBye ) ;
            TELL( "writing bye" )
            idSerialBye = GETiDsERIAL ;
        {
        if( pso && nodePeer != nodePeerCorrect && !bQuitP && !ether )

        nodeServerF( tinP , nodePeerCorrect , stNodeOpenP , nodeP , idWorkP ) ;
        nodeC nodePeerCorrect ;
        TELL( "calculating nodeCorrect" )
        _IO_     TELLsYSlIFInAME( "tmBangClientF2" )

        stBang.waitF( tinP ) ;
        TELL( " waiting for a push onto stBang" )
    {
    while( !ether && !bQuitP )
    boolT bNewbie = 1 ;
    nodeC nodePeer ;
    ZE( socketC* , pso ) ;

    countT& idSerialBye = sBye.cFieldF( tinP , IDfIELD_IDsERIAL ) ;
    hdrF( tinP , sBye , nodeP , flPOP_null , IDcMD2PE_CLIENTbANGbYE ) ;
    soulC sBye( tinP , TAG( TAGiDnULL ) ) ;


    ;
                    : *pStBang4P
                    ? *pStBang3P
                : idWorkP == IDtYPE2PEbANGcLIENTwORK_LEFT
                ? *pStBang2P
            : idWorkP == IDtYPE2PEbANGcLIENTwORK_EXPLODE2
            ? *pStBang1P
        : idWorkP == IDtYPE2PEbANGcLIENTwORK_EXPLODE1
        ? *pStBang0P
    stackC& stBang = idWorkP == IDtYPE2PEbANGcLIENTwORK_IMPLODE
    TELL( "setting up" )

    countT idWorkP = pTaskP->c4 ;
    NODEiNFOtm
    _IO_     TELLsYSlIFInAME( "tmBangClientF1" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmBangClientF )

}
    stNodeOpenP.ungrabF( tinP ) ;
    }
        }
            case  IDtYPE2PEbANGcLIENTwORK_RIGHT    : {                                nodePeer1P = cNodes > 1 ? *(nodeC*)&stNodeOpenP[ ideMe > 1      ? ideMe - 1 : cNodes ] : nodeNull ; break ; }
            case  IDtYPE2PEbANGcLIENTwORK_LEFT     : {                                nodePeer1P = cNodes > 1 ? *(nodeC*)&stNodeOpenP[ ideMe < cNodes ? ideMe + 1 : 1      ] : nodeNull ; break ; }
            case  IDtYPE2PEbANGcLIENTwORK_EXPLODE2 : { if( 1 < ideMe                ) nodePeer1P =              *(nodeC*)&stNodeOpenP[ ideMe / 2                           ]            ; break ; }
            case  IDtYPE2PEbANGcLIENTwORK_EXPLODE1 :
            case  IDtYPE2PEbANGcLIENTwORK_IMPLODE  : { if( stNodeOpenP >= ideMe * 2 ) nodePeer1P =              *(nodeC*)&stNodeOpenP[ ideMe * 2                           ]            ; if( stNodeOpenP >= ideMe * 2 + 1 ) nodePeer2P = *(nodeC*)&stNodeOpenP[ ideMe * 2 + 1 ] ; break ; }
        {
        switch( idHisWorkP ) // nodeP IS SET IFF A DISTINCT NODE EXISTS
        nodeC nodeNull ;
    {
    if( ideMe )
    countT ideMe = stNodeOpenP( (byteT*)nodeP , subtractNodesF ) ;
    countT cNodes = stNodeOpenP ;
    stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;

    if( stNodeOpenP.third ) { BLAMMO ; }
    if( nodePeer2P ) { BLAMMO ; }
    if( nodePeer1P ) { BLAMMO ; }
    _IO_     TELLsYSlIFInAME( "nodeClientF" )
{
voidT nodeClientF( tinS& tinP , nodeC& nodePeer1P , nodeC& nodePeer2P , stackC& stNodeOpenP , nodeC& nodeP , const countT idHisWorkP )

}
    stNodeOpenP.ungrabF( tinP ) ;
    }
        }
            case  IDtYPE2PEbANGcLIENTwORK_RIGHT    : {                                    nodePeerP = cNodes > 1 ? *(nodeC*)&stNodeOpenP[ ideMe < cNodes ? ideMe + 1 : 1      ] : nodeNull ; break ; }
            case  IDtYPE2PEbANGcLIENTwORK_LEFT     : {                                    nodePeerP = cNodes > 1 ? *(nodeC*)&stNodeOpenP[ ideMe > 1      ? ideMe - 1 : cNodes ] : nodeNull ; break ; }
            case  IDtYPE2PEbANGcLIENTwORK_EXPLODE2 : { if( stNodeOpenP >= ideMe * 2 + 1 ) nodePeerP =              *(nodeC*)&stNodeOpenP[ ideMe * 2 + 1                       ]            ; break ; }
            case  IDtYPE2PEbANGcLIENTwORK_EXPLODE1 : { if( stNodeOpenP >= ideMe * 2     ) nodePeerP =              *(nodeC*)&stNodeOpenP[ ideMe * 2                           ]            ; break ; }
            case  IDtYPE2PEbANGcLIENTwORK_IMPLODE  : { if(           1 != ideMe         ) nodePeerP =              *(nodeC*)&stNodeOpenP[ ideMe / 2                           ]            ; break ; }
        {
        switch( idMyWorkP ) // nodeP IS SET IFF A DISTINCT NODE EXISTS
        nodeC nodeNull ;
    {
    if( ideMe )
    countT ideMe = stNodeOpenP( (byteT*)nodeP , subtractNodesF ) ;
    countT cNodes = stNodeOpenP ;
    stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;

    if( stNodeOpenP.third ) { BLAMMO ; }
    if( nodePeerP ) { BLAMMO ; }
    _IO_     TELLsYSlIFInAME( "nodeServerF" )
{
voidT nodeServerF( tinS& tinP , nodeC& nodePeerP , stackC& stNodeOpenP , nodeC& nodeP , const countT idMyWorkP )

}
    if( tinP.fingerprint ) ;
    idWorkInvert2P = idWorkP == IDtYPE2PEbANGcLIENTwORK_EXPLODE1 ? IDtYPE2PEbANGcLIENTwORK_EXPLODE2 : 0 ;

    ;
                    : IDtYPE2PEbANGcLIENTwORK_LEFT
                    ? IDtYPE2PEbANGcLIENTwORK_RIGHT
                : idWorkP == IDtYPE2PEbANGcLIENTwORK_LEFT
                ? IDtYPE2PEbANGcLIENTwORK_IMPLODE
            : idWorkP == IDtYPE2PEbANGcLIENTwORK_EXPLODE2
            ? IDtYPE2PEbANGcLIENTwORK_IMPLODE
        : idWorkP == IDtYPE2PEbANGcLIENTwORK_EXPLODE1
        ? IDtYPE2PEbANGcLIENTwORK_EXPLODE1
        idWorkP == IDtYPE2PEbANGcLIENTwORK_IMPLODE
    idWorkInvert1P =
    _IO_     TELLsYSlIFInAME( "idWorkInvertIF" )
{
voidT idWorkInvertIF( tinS& tinP , countT& idWorkInvert1P , countT& idWorkInvert2P , const countT idWorkP )

}
    if( idCallLineP ) ; //USED FOR DEBUGGING TO STUDY WHICH CODE LINE CALLS ME LOTS AND LOTS
    }
        }
            bombF( tinP , etThread , NODEiNFOaRGS , sFail ) ;
    
            sFail << *(count4S*)&nodeFailP ;
            hdrF( tinP , sFail , nodeP , flPOP_BOMB , bConnectP ? IDcMD2PE_NODEfAILEDcONNECT : IDcMD2PE_NODEfAILEDrEAD ) ;
            soulC sFail( tinP , TAG( TAGiDnULL ) ) ;
        
            }
                stNodeOpenP.ungrabF( tinP ) ;
                if( stNodeOpenP( (byteT*)nodeFailP , subtractNodesF ) ) stNodeOpenP.extractF( 0 , tinP ) ;
                stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                stNodeFailConnectP.sinkF( tinP , countTC() , (byteT*)nodeP , flSTACKsINK_UNIQUE , subtractNodesF ) ;
            {
            else
            if( !bConnectP ) stNodeFailReplyP.sinkF( tinP , countTC() , (byteT*)nodeFailP , flSTACKsINK_UNIQUE , subtractNodesF ) ;
        {
        if( nodeFailP && ( nodeFailP != nodeP || !bConnectP ) ) //I DO NOT TELL ON MYSELF FOR CONNECTION TYPE FAILURES BECAUSE THIS IS JUST MY PERSONALITY (I AM OBVIOUSLY ALIVE SO THIS AVOIDS TRANSIENT NODE DOWN NOTICES)
    {
    if( !bQuitP )
    NODEiNFOf
    _IO_     TELLsYSlIFInAME( "reportFailF" )
{
voidT reportFailF( tinS& tinP , etherC& etThread , NODEiNFOpARMS , const boolT bConnectP , const nodeC& nodeFailP , const countT idCallLineP )

}
    }
        }
            break ;
            popF( tinP , etThread , etScratchNodeP , pStBang0P , pStBang1P , pStBang2P , pStBang3P , pStBang4P , soulP ) ;
            }
                flags |= flPOP_UP ;
                flags &= ~( F(flPOP_BOMB) ) ;
            {
            if( F(flags) & flPOP_BOMB )
        {
        else    
        }
            }
                if( !bForever && !( cTriesP && -- cTriesP ) ) nodeTo = 0 ;
                reportFailF( tinP , etThread , NODEiNFOaRGS , 1 , node1 , 1 ) ;
                *tinP.zEtScratch = 0 ;
            {
            else
            if( !*tinP.zEtScratch ) break ;
            writeF( tinP , *tinP.zEtScratch , node1 , soulP ) ;
        {
        if( node1 && node1 != nodeP )

        const nodeC& node1 = nodeTo ? nodeTo : *(nodeC*)&stNodeOpenP[ 1 ] ;
    {
    while( !ether && !bQuitP )
    const boolT bForever = nodeTo && !cTriesP ;

    nodeC nodeTo = nodeToP ;
    etherC& ether = etherC::etPrimeIF() ;

    flagsT& flags = soulP.cFieldF( tinP , IDfIELD_FLAGS ) ;
    NODEiNFOf
    _IO_     TELLsYSlIFInAME( "bombF" )
{
voidT bombF( tinS& tinP , etherC& etThread , NODEiNFOpARMS , soulC& soulP , const nodeC& nodeToP = nodeC() , countT cTriesP = 0 )
*/
  else i reset flPOP_BOMB and push copies of soulP onto my own bang stacks
  if i know a root that is not myself then i connect to it and write soulP to it 
 nodeToP 0: normal mode
   not 0: i retry this cTriesP times and then revert to normal mode
   0: i retry this forever
  cTriesP
  i connect to nodeToP and write soulP to it
 nodeToP not 0: override mode
i have 2 modes
i might reset this flag
soulP must specify flPOP_BOMB
/*

voidT reportFailF( tinS& tinP , etherC& etThread , NODEiNFOpARMS , const boolT bConnectP , const nodeC& nodeFailP , const countT idCallLineP ) ;

}
    writeF( tinP , *tinP.zEtScratch , nodeTestP , sCry ) ;
    hdrF( tinP , sCry , nodeP , flPOP_null , IDcMD2PE_CRY ) ;
    soulC sCry( tinP , TAG( TAGiDnULL ) ) ;
    _IO_     TELLsYSlIFInAME( "testF" )
{
voidT testF( tinS& tinP , nodeC& nodeTestP , nodeC& nodeP )

}
    VERIFY( sock ) ;
    sock.writeF( tinP , soulP ) ;
    sock.connectF( tinP , nodeP.idp ) ;
    socketC sock( tinP , *tinP.zEtScratch , TAG( TAGiDnULL ) ) ;
    _IO_     TELLsYSlIFInAME( "writeF" )
{
voidT writeF( tinS& tinP , const nodeC& nodeP , soulC& soulP )

}
    }
        }
            }
                *pStBang4P << pSoul ;
                }
                    flags &= ~( F(flPOP_DOWN) | F(flPOP_UP) ) ;
                    flagsT& flags = pSoul->cFieldF( tinP , IDfIELD_FLAGS ) ;
                {
                if( bDudP )
                *pSoul = soulP ;
            {
            if( pSoul )
            soulC* pSoul = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( pSoul ) ;
        {
        if( pStBang4P )
        
        }
            }
                *pStBang3P << pSoul ;
                }
                    flags &= ~( F(flPOP_DOWN) | F(flPOP_UP) ) ;
                    flagsT& flags = pSoul->cFieldF( tinP , IDfIELD_FLAGS ) ;
                {
                if( bDudP )
                *pSoul = soulP ;
            {
            if( pSoul )
            soulC* pSoul = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( pSoul ) ;
        {
        if( pStBang3P )
        
        }
            }
                *pStBang2P << pSoul ;
                }
                    flags &= ~( F(flPOP_DOWN) | F(flPOP_UP) ) ;
                    flagsT& flags = pSoul->cFieldF( tinP , IDfIELD_FLAGS ) ;
                {
                if( bDudP )
                *pSoul = soulP ;
            {
            if( pSoul )
            soulC* pSoul = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( pSoul ) ;
        {
        if( pStBang2P )
    
        }
            }
                *pStBang1P << pSoul ;
                }
                    flags &= ~( F(flPOP_DOWN) | F(flPOP_UP) ) ;
                    flagsT& flags = pSoul->cFieldF( tinP , IDfIELD_FLAGS ) ;
                {
                if( bDudP )
                *pSoul = soulP ;
            {
            if( pSoul )
            soulC* pSoul = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( pSoul ) ;
        {
        if( pStBang1P )
    {
    if( F(flags) & flPOP_UP )

    }
        }
            }
                *pStBang0P << pSoul ;
                }
                    flags &= ~( F(flPOP_DOWN) | F(flPOP_UP) ) ;
                    flagsT& flags = pSoul->cFieldF( tinP , IDfIELD_FLAGS ) ;
                {
                if( bDudP )
                *pSoul = soulP ;
            {
            if( pSoul )
            soulC* pSoul = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( pSoul ) ;
        {
        if( pStBang0P )
    {
    if( F(flags) & flPOP_DOWN )

    if( F(flags) & flPOP_BOMB ) { BLAMMO ; }
    flagsT& flags = soulP.cFieldF( tinP , IDfIELD_FLAGS ) ;
    _IO_     TELLsYSlIFInAME( "popF" )
{
voidT popF( tinS& tinP , etherC& etThread , etherC& etScratchNodeP , stackC* pStBang0P , stackC* pStBang1P , stackC* pStBang2P , stackC* pStBang3P , stackC* pStBang4P , soulC& soulP , const boolT bDudP = 0 )

}
    return cNodes ;
    }
        if( node ) stP.sinkF( tinP , countTC() , (byteT*)&node , flSTACKsINK_UNIQUE , subtractNodesF ) ;
        nodeC& node = nodeC::fieldF( tinP , soulP , idFieldP ++ ) ;
    {
    while( cToDo -- )
    countT cToDo = cNodes ;
    const countT cNodes = soulP.cFieldF( tinP , idFieldP ++ ) ;
    _IO_     TELLsYSlIFInAME( "hisListF" )
{
countT hisListF( tinS& tinP , stackC& stP , soulC& soulP , countT idFieldP = IDfIELD_IDcMD + 1 )

}
    stNodeOpenP.ungrabF( tinP ) ;
    }
        while( !stNodeOpenP.third && ~hDown ) ;
        do soulP << *(count4S*)&stNodeOpenP.downF( tinP , hDown ) ;
        handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stNodeOpenP )
    soulP << (countT)stNodeOpenP ;
    stNodeOpenP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    _IO_     TELLsYSlIFInAME( "myListF" )
{
voidT myListF( tinS& tinP , soulC& soulP , stackC& stNodeOpenP )

}
    return sgn ;
    if( tinP.fingerprint && pEther && c3P ) ;

    sCountT sgn = (nodeC*)c1P && (nodeC*)c2P ? *(nodeC*)c1P - *(nodeC*)c2P : 0 ;
    _IO_     //TELLsYSlIFInAME( "subtractNodesF" )

    }
    {
    IFbEcAREFUL
{
countT subtractNodesF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return *(nodeC*)&soulP.c4 FieldF( tinP , idFieldP ) ;
    // MIGRATE THE FOLLOWING LINE TO USE pbFieldF
{
nodeC& nodeC::fieldF( tinS& tinP , soulC& soulP , const countT idFieldP )

}
    return (byteT*)this ;
{
nodeC::operator byteT*( voidT ) const

}
    return sgn ;

    else if( idp   < nodeP.idp   ) sgn = - 1 ;
         if( idp   > nodeP.idp   ) sgn =   1 ;
    else if( time1 < nodeP.time1 ) sgn = - 1 ;
         if( time1 > nodeP.time1 ) sgn =   1 ;
    else if( time2 < nodeP.time2 ) sgn = - 1 ;
         if( time2 > nodeP.time2 ) sgn =   1 ;
    ZE( sCountT , sgn ) ;
{
sCountT nodeC::operator -( nodeC& nodeP ) const

}
    return idp != nodeP.idp ;
{
boolT nodeC::operator !=( nodeC& nodeP ) const

}
    return idp == nodeP.idp ;
{
boolT nodeC::operator ==( nodeC& nodeP ) const

}
    return *this ;
    if( !idp ) idMe = time2 = time1 = 0 ;
    idp = idpP ;
{
nodeC& nodeC::operator =( const countT idpP )

}
    return *this ;
    time2 = nodeP.time2 ;
    time1 = nodeP.time1 ;
    idp = nodeP.idp ;
    idMe = nodeP.idMe ;
{
nodeC& nodeC::operator =( nodeC& nodeP )

}
    return !!idp ;
{
nodeC::operator boolT( voidT ) const

}
    etThread.osTimeNowF( tinP , time1 , time2 ) ;
{
time2( 0 )
time1( 0 ) ,
idp( 0 ) ,
idMe( idMeP ) ,
nodeC::nodeC( tinS& tinP , etherC& etThread , const countT idMeP ) :

}
{
time2( 0 )
time1( 0 ) ,
idp( 0 ) ,
idMe( 0 ) ,
nodeC::nodeC( voidT ) :

}
    if( tinP.fingerprint ) ;

    soulP << idCmdP ;
    soulP << flagsP ;
    soulP << GETiDsERIAL ;
    soulP << *(count4S*)&nodeP ;  //CODEsYNC df40104 df40104
{
voidT hdrF( tinS& tinP , soulC& soulP , nodeC& nodeP , const flagsT flagsP , const countT idCmdP )

#define IDfIELD_IDcMD                   4
#define IDfIELD_FLAGS                   3
#define IDfIELD_IDsERIAL                2
#define IDfIELD_NODEoRIGIN              1

#define flPOP_UP                   0xe00004ff
#define flPOP_DOWN                 0xe00002ff
#define flPOP_BOMB                 0xe00001ff
#define flPOP_null                 0xe00000ff

nodeC nodeDns ;

;
}
    " USERcOMMANDS "
    " NODEfAILEDcONNECT " ,
    " NODEfAILEDrEAD " ,
    " CLIENTbANGbYE " ,
    " CLIENTbANGhELLO " ,
    " SERVERoK " ,
    " PING " ,
    " GASP " ,
    " CRY " ,
    " (bug)" ,
{
osTextT* ppostOldCmd[] =

;
}
    " RIGHT "
    " LEFT " ,
    " UP2 " ,
    " UP1 " ,
    " DOWN " ,
    " (bug)" ,
{
osTextT* ppostWork[] =

#define IDcMD2PE_USERcOMMANDS                0x9
#define IDcMD2PE_NODEfAILEDcONNECT           0x8
#define IDcMD2PE_NODEfAILEDrEAD              0x7
#define IDcMD2PE_CLIENTbANGbYE               0x6
#define IDcMD2PE_CLIENTbANGhELLO             0x5
#define IDcMD2PE_SERVERoK                    0x4
#define IDcMD2PE_PING                        0x3
#define IDcMD2PE_GASP                        0x2
#define IDcMD2PE_CRY                         0x1

#define IDtYPE2PEbANGcLIENTwORK_RIGHT    0x5
#define IDtYPE2PEbANGcLIENTwORK_LEFT     0x4
#define IDtYPE2PEbANGcLIENTwORK_EXPLODE2 0x3
#define IDtYPE2PEbANGcLIENTwORK_EXPLODE1 0x2
#define IDtYPE2PEbANGcLIENTwORK_IMPLODE  0x1

#define NODEiNFOaRGS           _c8ni1P ,          _c8ni2P ,          _c8ni3P
#define NODEiNFOpARMS count8S& _c8ni1P , count8S& _c8ni2P , count8S& _c8ni3P

    NODEiNFOf
                                                                          \
    count8S& _c8ni3P = *(count8S*)pTaskP->c3 ;                            \
    count8S& _c8ni2P = *(count8S*)pTaskP->c2 ;                            \
    count8S& _c8ni1P = *(count8S*)pTaskP->c1 ;                            \
                                                                          \
#define NODEiNFOtm                                                        \

    boolT&   bTalkP                   =    *(boolT*)_c8ni3P.c5 ;
    stackC&  stIdSerialReceivedP      =   *(stackC*)_c8ni3P.c4 ; \
    stackC&  stPsoServerP             =   *(stackC*)_c8ni3P.c3 ; \
    stackC*& pStBang4P                = *(stackC**)&_c8ni3P.c2 ; \
    stackC*& pStBang3P                = *(stackC**)&_c8ni3P.c1 ; \
    stackC*& pStBang2P                = *(stackC**)&_c8ni2P.c8 ; \
    stackC*& pStBang1P                = *(stackC**)&_c8ni2P.c7 ; \
    stackC*& pStBang0P                = *(stackC**)&_c8ni2P.c6 ; \
    stackC&  stNodeCurrentBangClientP =   *(stackC*)_c8ni2P.c5 ; \
    stackC&  stNodeTestP              =   *(stackC*)_c8ni2P.c4 ; \
    stackC&  stNodeZombieOldP         =   *(stackC*)_c8ni2P.c3 ; \
    stackC&  stNodeZombieP            =   *(stackC*)_c8ni2P.c2 ; \
    stackC&  stNodeFailReplyP         =   *(stackC*)_c8ni2P.c1 ; \
    stackC&  stNodeFailConnectOldP    =   *(stackC*)_c8ni1P.c8 ; \
    stackC&  stNodeFailConnectP       =   *(stackC*)_c8ni1P.c7 ; \
    stackC&  stNodeOpenP              =   *(stackC*)_c8ni1P.c6 ; \
    ranUniC& ruZeWoP                  =  *(ranUniC*)_c8ni1P.c5 ; \
    boolT&   bQuitP                   =    *(boolT*)_c8ni1P.c4 ; \
    etherC&  etScratchNodeP           =   *(etherC*)_c8ni1P.c3 ; \
    nodeC&   nodeP                    =    *(nodeC*)_c8ni1P.c2 ; \
    countT   idMeP                    =             _c8ni1P.c1 ; \
                                                                 \
#define NODEiNFOf                                                \

    etThread.osThreadF( tinP , countTC() , tmBangClientF , 0 , flTHREADlAUNCH_null , 0 , (countT)&_c8ni1P , (countT)&_c8ni2P , (countT)&_c8ni3P , idWorkP ) ;
    godHelloF( tinP , *pStBang##postDigitP ) ;                                              \
                                                                                            \
#define LAUNCHbANGcLIENT(postDigitP,idWorkP)                                                \

#define FINGERnEG         0x87654321

    }
        __( !soulP || soulP.cFieldF( tinP , 1 ) != IDcMD2PE_SERVERoK ) ; \
        (sockP).readF( tinP , soulP , TOCK * 0x8 ) ;                                            \
    {                                                                                           \
                                                                                                \
#define VERIFY2(soulP,sockP)                                                                    \

    }
        __( !_sOk || _sOk.cFieldF( tinP , 1 ) != IDcMD2PE_SERVERoK ) ; \
        (sockP).readF( tinP , _sOk , TOCK * 0x8 ) ;                                             \
        soulC _sOk( tinP , TAG( TAGiDnULL ) ) ;                                                 \
    {                                                                                           \
                                                                                                \
#define VERIFY(sockP)                                                                           \

#include postADAMhEADER

/*1*//*"ifcIDaDAM_KERNEL3BANG: TODO/REST CODE FOR THE NODE ADAM"*//*1*/
/**/
*/
obsoleted by ff40104
objective: explore distributed blob storage
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

