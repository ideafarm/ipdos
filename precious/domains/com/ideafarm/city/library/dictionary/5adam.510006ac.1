
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.loafIF( tinP ) ;

#endif

etThread.delF( tinP , psttSay ) ;
etThread.strokeF( tinP , psttSay ) ;

etThread.strFuseF( tinP , psttSay , b2 ) ;
etThread.strFuseF( tinP , psttSay , S3(65.0,scOld_mmMOVEpELtO,65.0) ) ;
etThread.strFuseF( tinP , psttSay , S3(64.0,scOld_mmFRAMEpELtO,64.0) ) ;
etThread.strFuseF( tinP , psttSay , S2(0,scOld_POPfRAME) ) ;
etThread.strFuseF( tinP , psttSay , S2(0,scOld_POPfRAME) ) ;
etThread.strFuseF( tinP , psttSay , tcQuit ) ;
etThread.strFuseF( tinP , psttSay , S2(0,scOld_WRAPoFF) ) ;
//etThread.strFuseF( tinP , psttSay , S2(0,scOld_TRACEoN) ) ;
etThread.strFuseF( tinP , psttSay , 0 , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ TUCK ) ; ___( psttSay ) ;
ZE( strokeS* , psttSay ) ;

etThread.delF( tinP , psttBody3 ) ;
tcButtonC b3( tinP , "b3" , b3CBF , 0 , flTCfEATURE_defaultButton | flTCfEATURE_DRAGGABLE , 0 , psttBody3 , 0 , ifcRGB_R4|ifcRGB_G2 , 2 , 2 , 2 , 2 ) ;
etThread.strFuseF( tinP , psttBody3 , T("y") ) ;
etThread.strFuseF( tinP , psttBody3 , b2 ) ;
etThread.strFuseF( tinP , psttBody3 , T("c") ) ;
etThread.strFuseF( tinP , psttBody3 , 0 , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ TUCK ) ; ___( psttBody3 ) ;
ZE( strokeS* , psttBody3 ) ;

etThread.delF( tinP , psttBody2 ) ;
tcButtonC b2( tinP , "b2" , b2CBF , 0 , flTCfEATURE_defaultButton , 0 , psttBody2 , 0 , ifcRGB_R4|ifcRGB_G2 , 1 , 1 , 1 , 1 ) ;
etThread.strFuseF( tinP , psttBody2 , T("z") ) ;
etThread.strFuseF( tinP , psttBody2 , b1 ) ;
etThread.strFuseF( tinP , psttBody2 , T("b") ) ;
etThread.strFuseF( tinP , psttBody2 , 0 , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ TUCK ) ; ___( psttBody2 ) ;
ZE( strokeS* , psttBody2 ) ;

tcButtonQuitC tcQuit( tinP , "tcQuit" ) ;

#if defined( NEVERdEFINED )

etThread.strokeF( tinP , b1 ) ;

tcButtonC b1( tinP , "b1" , b1CBF , 0 , flTCfEATURE_defaultButton , 0 , T("a") ) ;

TN( tb , " " ) ;
TN( tn , "" ) ;

TODO

}
    return bHandled ;

    }
        }
            break ;

            //LOGrAW3( "b3CBF [idAdam]: " , sadamP.ssc.idAdamForMigration , "\r\n" ) ;
            //Beep( TUCK << sadamP.ssc.idAdamForMigration , TUCK ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            //bHandled = 1 ;

            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
    {
    switch( idTypeCallP )
    ZE( boolT , bHandled ) ;
{
boolT _export b3CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamC& sadamP )

}
    return bHandled ;

    }
        }
            break ;

            //LOGrAW3( "b2CBF [idAdam]: " , sadamP.ssc.idAdamForMigration , "\r\n" ) ;
            //Beep( TUCK << sadamP.ssc.idAdamForMigration , TUCK ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            //bHandled = 1 ;

            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
    {
    switch( idTypeCallP )
    ZE( boolT , bHandled ) ;
{
boolT _export b2CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamC& sadamP )

}
    return bHandled ;

    }
        }
            break ;

            //LOGrAW3( "b1CBF [idAdam]: " , sadamP.ssc.idAdamForMigration , "\r\n" ) ;
            //Beep( TUCK << sadamP.features.fc.idAdamForMigration , TUCK ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            //bHandled = 1 ;

            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
    {
    switch( idTypeCallP )
    ZE( boolT , bHandled ) ;
{
boolT _export b1CBF( tinS& tinP , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamC& sadamP )

/*1*/WAKEsHOW( "example.other.1snip.1500009c.tcButtonC.deeply.nested.buttons" )/*1*/

//20140915@1840: MOVED FROM SCRATCH 2 TO PERMANENT ADAM ID

/**/

*/
 this incorrect function appears to be due to snap/restore not functioning correctly within boundingRectF
this adam documents the incorrect functionality when buttons are nested 3 levels
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

