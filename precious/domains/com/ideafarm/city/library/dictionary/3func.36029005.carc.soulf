
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cbs ;

    _OUT_

    ether.delF( tinP , pcUsage ) ;
    ether.delF( tinP , pstt1LogImpotence ) ;
    ether.delF( tinP , pstt1Log ) ;

    }
        }
            baton.ungrabF( tinP ) ;

            if( bResetP ) resetF( tinP ) ;

            /*  + cbLogImpotence */ ether.memCopyF( tinP , (byteT*)&pcc[ off ] + cbLog + cbLogImpotence , (byteT*)pcUsage           , cbUsage        ) ;
            /*  + cbLog */          ether.memCopyF( tinP , (byteT*)&pcc[ off ] + cbLog                  , (byteT*)pstt1LogImpotence , cbLogImpotence ) ;
            /*  7 */                ether.memCopyF( tinP , (byteT*)&pcc[ off ]                          , (byteT*)pstt1Log          , cbLog          ) ;

            /*  6 */ pcc[ off ++ ] = cbUsage ;
            /*  5 */ pcc[ off ++ ] = cbLogImpotence ;
            /*  4 */ pcc[ off ++ ] = cbLog ;
            /*  3 */ pcc[ off ++ ] = *(countT*)&mPayin ;
            /*  2 */ pcc[ off ++ ] = cDatum ;
            /*  1 */ pcc[ off ++ ] = idcHirer ;
            /*  0 */ pcc[ off ++ ] = cbs - sizeof( countT ) ;
            ZE( countT , off ) ;

            baton.grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( pcc )
        countT* pcc = (countT*)pbP ;
        ether.newF( tinP , LF , pbP , cbs ) ; ___( pbP ) ;

        cbs = 7 * sizeof( countT ) + cbLog + cbLogImpotence + cbUsage ;
        countT cbUsage        = sizeof( countT  ) * ccUsage ;
        countT cbLogImpotence = sizeof( strokeS ) * ( CSpREFIX + pstt1LogImpotence->idAdam ) ;
        countT cbLog          = sizeof( strokeS ) * ( CSpREFIX + pstt1Log->idAdam          ) ;
    {
    if( !ether )
    ZE( countT , cbs ) ;

    __Z( pcUsage ) ;
    __Z( pstt1LogImpotence ) ;
    __Z( pstt1Log ) ;

    }
        }
            off += ccPart ;
            ether.memCopyF( tinP , (byteT*)&pcUsage[ off ] , (byteT*)pcPart , sizeof( countT ) * ccPart ) ;
            pcUsage[ off ++ ] = swUsage ;
            countT ccPart = 1 + ether.strBodyLengthF( tinP , pcPart ) ;
            pcPart = (countT*)swUsage.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        pcUsage[ off ++ ] = cFlavors ;
        ZE( countT , off ) ;
        const countT cFlavors = swUsage.cFlavorsF( tinP ) ;

        // FORMAT OF pcUsage: FIRST countT IS cResources.  FOR EACH RESOURCE: qty , rid.  rid is null terminated.
    {
    ether.newF( tinP , LF , pcUsage , ccUsage ) ; ___( pcUsage ) ;
    ZE( countT* , pcUsage ) ;
    countT ccUsage = ccF( tinP , ether , swUsage ) ;

    if( !pstt1LogImpotence ) { ether.strFuseF( tinP , pstt1LogImpotence , T("") ) ; ___( pstt1LogImpotence ) ; }
    stLogImpotence.ungrabF( tinP ) ;
    }
        while( !ether && ~handle ) ;
        }
            if( psttl ) { ether.strFuseSeparateF( tinP , pstt1LogImpotence , psttl , 0 , 0 , 0 , 0 , /*U::SOUL?*/ csNeeded ) ; ___( pstt1LogImpotence ) ; }
            strokeS* psttl = (strokeS*)stLogImpotence.downF( tinP , handle ) ;
        {
        do

        while( !ether && ~handle ) ;
        }
            csNeeded += CSpREFIX + ( psttl ? psttl->idAdam : 0 ) ;
            strokeS* psttl = (strokeS*)stLogImpotence.downF( tinP , handle ) ;
        {
        do
        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        ZE( countT , csNeeded ) ;
    {
    if( stLogImpotence )
    stLogImpotence.grabF( tinP , TAG( TAGiDnULL ) ) ;
    ZE( strokeS* , pstt1LogImpotence ) ;

    if( !pstt1Log ) { ether.strFuseF( tinP , pstt1Log , T("") ) ; ___( pstt1Log ) ; }
    stLog.ungrabF( tinP ) ;
    }
        while( !ether && ~handle ) ;
        }
            if( psttl ) { ether.strFuseSeparateF( tinP , pstt1Log , psttl , 0 , 0 , 0 , 0 , /*U::SOUL?*/ csNeeded ) ; ___( pstt1Log ) ; }
            strokeS* psttl = (strokeS*)stLog.downF( tinP , handle ) ;
        {
        do

        while( !ether && ~handle ) ;
        }
            csNeeded += CSpREFIX + ( psttl ? psttl->idAdam : 0 ) ;
            strokeS* psttl = (strokeS*)stLog.downF( tinP , handle ) ;
        {
        do
        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        ZE( countT , csNeeded ) ;
    {
    if( stLog )
    stLog.grabF( tinP , TAG( TAGiDnULL ) ) ;
    ZE( strokeS* , pstt1Log ) ;

    _INoLD_

    if( ether ) return 0 ;
    __NZ( pbP ) ;
    if( ether ) return 0 ;
{
/*1*/countT carC::soulF( tinS& tinP , byteT*& pbP , const boolT bResetP )/*1*/

/**/
*/
 bResetP
  this length-prefixed string of bytes contains the state information needed to reconstruct a carC object
  must not be 0
 pbP
 tinP
arguments
 information is transmittable if it does not contain host-dependent information such as memory addresses
reconstructs a carC object from transmittable state information
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.1350005.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$soulF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

