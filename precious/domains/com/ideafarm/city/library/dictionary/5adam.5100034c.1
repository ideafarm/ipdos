
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

HEAReNTER( etThread ) ;
etThread.strokeF( tinP , T(" \r\nplease press the Enter key now") ) ;

etThread.strokeF( tinP , TF3(cDrops-cDropsDeleted-cDropsNotDeleted,0,0x10)+T("cDrops - cDropsDeleted - NotDeleted\r\n") ) ;
etThread.strokeF( tinP , TF3(cDropsNotDeleted,0,0x10)+T("cDropsNotDeleted\r\n") ) ;

}
    etThread.delF( tinP , psttn ) ;
    swNameByIdType = 0 ;
    strokeS* psttn = (strokeS*)(countT)swNameByIdType ;
    idDropType = swNameByIdType.leverF( tinP , idf ) ;
{
for( idf = 1 ; idf <= cFlavors ; idf ++ )
cFlavors = swNameByIdType.cFlavorsF( tinP ) ;

}
    etThread.delF( tinP , pInfo ) ;
    }
        etThread.strokeF( tinP , TF3(pInfo->c1,0,0x10)+T((strokeS*)(countT)swNameByIdType)+T("\r\n") ) ;
        cDropsNotDeleted += pInfo->c1 ;
    {
    if( pInfo )
    swInfoByDropType = 0 ;
    count8S* pInfo = (count8S*)(countT)swInfoByDropType ;
    idDropType = swInfoByDropType.leverF( tinP , idf ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
countT cFlavors = swInfoByDropType.cFlavorsF( tinP ) ;
ZE( countT , cDropsNotDeleted ) ;
etThread.strokeF( tinP , TF3(cDropsDeleted,0,0x10)+T("cDropsDeleted\r\n") ) ;
etThread.strokeF( tinP , TF3(cDrops,0,0x10)+T("cDrops\r\n") ) ;

}
    poolC::poolOldRootIF( tinP ).walkF( tinP , poolOldWalker_e430104_F , info , flPOOLoLDwALK_EVENiFgRABBED | flPOOLoLDwALK_ALLOWnONCLIENT ) ;

    countT info = (countT)&c8p ;
    c8p.c8      = (countT)&cDropsDeleted ;
    c8p.c7      = (countT)&bCorrupt ;
    c8p.c6      = (countT)&cDrops ;
    c8p.c5      = (countT)&psttr ;
    c8p.c4      = (countT)&swInfoByDropType ;
    c8p.c3      = (countT)&idDropType ;
    c8p.c2      = (countT)&etThread ;
    c8p.c1      = (countT)&ether ;
    count8S c8p ; //U:: USE SIZE NEEDED
{
ZE( strokeS* , psttr ) ;
ZE( boolT , bCorrupt ) ;
ZE( countT , cDropsDeleted ) ;
ZE( countT , cDrops ) ;

switchC swInfoByDropType( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idDropType ) ;

}
    etThread.delF( tinP , pstt1_4 ) ;
    }
        }
            }
                break ;
                }
                    psttName = 0 ;
                    swNameByIdType = (countT)psttName ;
                    etThread.delF( tinP , pstt6 ) ;
                    idDropType = etThread.strDigitsToSCountF( tinP , pstt6 , 0 , 1 ) ;
                    etThread.strSubstringF( tinP , pstt6 , idf6 , idl6 , psttc1 ) ; ___( pstt6 ) ;
                    ZE( countT , idl6 ) ;
                    countT idf6 = 3 ;
                    ZE( strokeS* , pstt6 ) ;
                {
                if( psttName )
            {
            case 3 :
            }
                break ;
                etThread.strSubstringF( tinP , psttName , idfName , idlName , psttc1 ) ; ___( psttName ) ;
                ZE( countT , idlName ) ;
                etThread.delF( tinP , psttName ) ;
                etThread.strSubstringF( tinP , psttName , idfName , sttqName , T("ifciDtYPEdROPnOTE_") , psttc1 ) ; ___( psttName ) ;
                strokeS sttqName( (countT)0 , sc_IGNOREqUOTES ) ;
                countT idfName = 1 ;
            {
            case 2 :
        {
        switch( idCol )
        countT idCol = 1 + ( ++ idw - 1 ) % 3 ;
    {
    FORsTRINGSiN1( pstt1_4 )

    psttName = 0 ;
    swNameByIdType = (countT)psttName ;
    etThread.strMakeF( tinP , LF , psttName , T("[unknown]") ) ; ___( psttName ) ;
    ZE( strokeS* , psttName ) ;
    ZE( countT , idw ) ;

    etThread.delF( tinP , pstt3 ) ;
    etThread.strWordsOldF( tinP , pstt1_4 , pstt3 , sttq ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , pstt1_4 ) ;
    etThread.delF( tinP , pstt2 ) ;
    etThread.strSubstringDelimitedF( tinP , pstt3 , idClass , idf , sttq , pstt2 ) ; ___( pstt3 ) ;
    ZE( strokeS* , pstt3 ) ;
    ZE( countT , idClass ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    countT idf = 1 ;
    etThread.delF( tinP , pb1 ) ;
    etThread.strMakeF( tinP , LF , pstt2 , T(pb1) ) ; ___( pstt2 ) ;
    ZE( strokeS* , pstt2 ) ;
    etThread.boxGetShadowF( tinP , pb1 , cb1 , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010126.ifciDtYPEdROPnOTE") ) ; ___( pb1 ) ;
    ZE( countT , cb1 ) ;
    ZE( byteT* , pb1 ) ;
{
switchC swNameByIdType( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idDropType ) ;
ZE( countT , idDropType ) ;

etThread.strokeF( tinP , T("IdeaFarm " "(tm) City Pool Reporter        http://www.ideafarm.com        (c) Wo'O Ideafarm\r\n \r\n") ) ;

TODO

}
    return bCorrupt ;
    if( tinP.fingerprint &&idClientP ) ;

    }
        }
            }
                }
                    info.c1 ++ ; // cDrops

                    count8S& info = *(count8S*)(countT)swInfoByDropType ;
                {
                if( swInfoByDropType )

                }
                    if( pc8i ) swInfoByDropType = (countT)pc8i ;
                    etThread.memSetF( tinP , (byteT*)pc8i , sizeof( count8S ) ) ;
                    etThread.newF( tinP , LF , pc8i ) ; ___( pc8i ) ;
                    ZE( count8S* , pc8i ) ; //U:: USE THE SIZE NEEDED
                {
                if( !swInfoByDropType )
                idDropType = db.idType ;
            {
            else
            if( F(flags) & flDROP_DELETED || F(flags) & flDROP_BEINGdELETED ) cDropsDeleted ++ ;

            countT idFile   = db.idFile ;
            countT idLine   = db.idLine ;
            countT cbd      = DHcbYTES ;
            countT ids      = DHiDsTEP ;
            countT idt      = DHiDtHREAD ;
            countT idc      = DHiDcLIENT ;

            flagsT& flags   = DHfLAGS ; // ASSUME: sizeof( flagsT ) == sizeof( countT )
            cDrops ++ ;
            //DROPnOTErEF( pvP ) ;
        {
        else
        }
        {
        if(  bCorrupt )
        if( DHgUARD - POOLoLDdROPgUARD ) bCorrupt |= 1 ;
    {
    else
    }
    {
    if( !pvP )

    countT&   cDropsDeleted    =   *(countT*)c8p.c8 ;
    boolT&    bCorrupt         =   *(countT*)c8p.c7 ;
    countT&   cDrops           =   *(countT*)c8p.c6 ;
    strokeS*& psttr            = *(strokeS**)c8p.c5 ;
    switchC&  swInfoByDropType =  *(switchC*)c8p.c4 ;
    countT&   idDropType       =   *(countT*)c8p.c3 ;
    etherC&   etThread         =   *(etherC*)c8p.c2 ;
    etherC&   ether            =   *(etherC*)c8p.c1 ;

    count8S& c8p = *(count8S*)infoP ;

{
boolT poolOldWalker_e430104_F( tinS& tinP , voidT* const pvP , countT& idClientP , countT& infoP )

/*1*/WAKEhIDE( "reporter.poolOld" )/*1*/
/**/
*/
 ideafarm10.ipdos-we !show e430104 !poolOldRootNoClientRights !poolOldRootDoNotWalkWhenDie
i am to be hired with special command parameters
\<A HREF=\"5.e430104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

