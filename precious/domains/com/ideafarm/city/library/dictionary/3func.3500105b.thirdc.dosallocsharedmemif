
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    osTraceWrongNodeIF( tinP , (byteT*)handleP.cNoteF() , "dosAllocSharedMemIF: cNote" ) ;

    #endif

        if( !( F(flagsP) & flOPENsHAREDmEMORY_DOnOTsERIALIZE ) && F(processGlobal1I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal1I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal3I.grabUniverse.ungrabF( tinP ) ;

        }
            }
                }
                    }
                        //}
                        //    CONoUTrAW( os ) ;
                        //    OStEXTAK( os , "\"\r\n" ) ;
                        //    OStEXTA(  os , ostoOsName ) ;
                        //    OStEXTAK( os , "new: \"" ) ;
                        //    OStEXT( os , TUCK << 1 ) ;
                        //{
                        //if( thirdC::c_strstrIF( ostoOsName , "grabUniverseC" ) )

                        handleP.osF( ifcIDtYPEhANDLE_SHAREDmEMORY , (countT)osh , 0 , (countT)pv ) ;
            
                        }
                            if( offr == CsHAREDmEMiNFO ) { BLAMMO ; }
                            }
                                }
                                    break ;
                                    processGlobal1I._thirdC_pSharedMemInfo[ offr ].pv  = pv ;
                                    processGlobal1I._thirdC_pSharedMemInfo[ offr ].osh = (countT)osh ;
                                    thirdC::c_strncpyIF( tinP , processGlobal1I._thirdC_pSharedMemInfo[ offr ].postName , ostoOsName , sizeof processGlobal1I._thirdC_pSharedMemInfo[ offr ].postName ) ;
                                {
                                if( !*processGlobal1I._thirdC_pSharedMemInfo[ offr ].postName )
                            {
                            for( offr = 0 ; offr < CsHAREDmEMiNFO ; offr ++ )
                            ZE( countT , offr ) ;
                        {
                        //DUPLICATED CODE: 1020068 1020061 1020132

                        //}
                        //    CONoUTrAW(  ostoLog ) ;
                        //    OStEXTAK( ostoLog , "\r\n" ) ;
                        //    OStEXTA(  ostoLog , ostoOsName ) ;
                        //    OStEXTAK( ostoLog , " NEW: " ) ;
                        //    OStEXTC(  ostoLog , pv , ' ' ) ;
                        //    OStEXT(   ostoLog , TUCK << 2 ) ;
                        //{
                        //if( thirdC::c_strstrIF( tinP , ostoOsName , "napSlab" ) )
                        //if( tinP.pc Utility[ 0 ] )
                    {
                    else
                    }
                        osh = 0 ;
                        BOSpOOP
                        BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                    {
                    if( POOP )
    
                    //__( IsBadReadPtr( pv , 1 ) ) ; //U::ELIMINATE USE OF THIS FUNCTION AS ADVISED BY MSDN (CAN TRIP A GUARD PAGE)
                    //U:: THE NEXT LINE, WHEN NOT COMMENTED OUT, WAS NOT REPORTED BY LINT

                    voidT* pv = (voidT*)tinP.brcRaw ;
                {
                else
                }
                    //LOGrAW3( "DosAllocSharedMem: MapViewOfFileExNuma returned " , tinP.brcRaw , "\r\n" ) ;
                    //CONoUTrAW3( "DosAllocSharedMem: MapViewOfFileExNuma returned " , tinP.brcRaw , "\r\n" ) ;
                    BOSdOnOTtEST( WHATgbo , GetLastError() )

                    osh = 0 ;
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                {
                if( POOP )
                BOSpOOP
                BOS( WHATgbo , BOSoK , MapViewOfFileExNuma( osh , osFlagsMap , 0 , 0 , 0 , 0 , thirdC::osOffNumaNodeValidChosenIF( processGlobal1I.idNumaNode ) ) )

                //}
                //    LOGrAW(    ostoSay ) ;
                //    CONoUTrAW( ostoSay ) ;
                //    
                //    OStEXTAK( ostoSay , "\"\r\n" ) ;
                //    OStEXTA(  ostoSay , postP ) ;
                //    OStEXTAK( ostoSay , " \"" ) ;
                //    OStEXTC(  ostoSay , tinP.brcRaw , 0 ) ;
                //    OStEXTAK( ostoSay , " " ) ;
                //    OStEXTC(  ostoSay , cbw , 0 ) ;
                //    OStEXTAK( ostoSay , " " ) ;
                //    OStEXTC(  ostoSay , cbP , 0 ) ;
                //    OStEXTAK( ostoSay , " " ) ;
                //    OStEXTC(  ostoSay , tinP.pAdamGlobal1->idAdam , 0 ) ;
                //    OStEXTAK( ostoSay , "dosAllocSharedMemIF [idAdam,cbP,cbw,osh,postP]: " ) ;
                //    OStEXT(   ostoSay , TUCK << 2 ) ;
                //{
                //if( tinP.pc Utility[ 0 ] )

                ;
                    : FILE_MAP_ALL_ACCESS
                    ? FILE_MAP_READ
                const flagsT osFlagsMap = F(flagsP) & flOPENsHAREDmEMORY_READoNLY

                HANDLE osh = (HANDLE)tinP.brcRaw ;
            {
            if( !POOP )

            BOSpOOP
            BOS( WHATgbo , BOSoK , CreateFileMappingNuma( (voidT*)( phFileP ? phFileP->osF( ifcIDtYPEhANDLE_FILE ) : -1 ) , &sa , osFlagsOpen , 0 , cbw , ostoOsName , thirdC::osOffNumaNodeValidChosenIF( processGlobal1I.idNumaNode ) ) )


            if( F(flagsP) & flOPENsHAREDmEMORY_DOnOTcOMMIT ) osFlagsOpen |= SEC_RESERVE ;

            ;
                : PAGE_READWRITE
                ? PAGE_READONLY
            flagsT osFlagsOpen = F(flagsP) & flOPENsHAREDmEMORY_READoNLY

            SECURITYaTTRIBUTE_saUNRESTRICTED( 0 ) ;
        {
        if( !POOP )

        }
            if( ( info.cbUsed || info.cbUsedHigh ) && ( info.cbUsed != cbw || info.cbUsedHigh ) ) { BLAMMO ; } //BLAMMO BECAUSE TYPICALLY CALLING CODE WILL ASSUME THAT IMPOTENCE IS DUE TO TEMPORARY UNAVAILABILITY OF MEMORY

            thirdC::dosQueryFileInfoIF( tinP , pInfo , *phFileP ) ;
            infoFileS* pInfo = &info ;
            infoFileS info( tinP ) ;
        {                      //ADDED BECAUSE bookC CONTAINED AN UNDETECTED BUG INVOLVING AN EXISTING FILE MAPPED TO A SMALL NAPKIN, WITH APPLICATION CODE RELYING UPON THE LENGTH AS DECLARED WITHIN A HEADER WITHIN THE FILE, CAUSING AN A.V. EXCEPTION DUE TO THE ERRONEOUSLY SMALL NAPKIN
        if( phFileP && !POOP ) //20140410@0950: ADDED THIS VALIDATION OF FILE SIZE ; WILL NEED TO MAKE THIS VALIDATION OPTIONAL IF EVER WANT TO MEMORY MAP ONLY A PORTION OF A FILE

        }
            }
                }
                    break ;
                    __1 ;
                {
                if( !c_strcmpIF( tinP , processGlobal1I._thirdC_pSharedMemInfo[ offr ].postName , ostoOsName ) )
            {
            for( countT offr = 0 ; offr < CsHAREDmEMiNFO ; offr ++ )
        {

        if( !( F(flagsP) & flOPENsHAREDmEMORY_DOnOTsERIALIZE ) && F(processGlobal1I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal1I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal3I.grabUniverse.grabF( tinP , TAG( TAGiDnULL ) ) ;

        c_zReplaceIF( tinP , (osTextT*)(const osTextT*)ostoOsName , '/' , '.' ) ;
        OStEXTA(  ostoOsName  , postP ) ;
        OStEXTAK( ostoOsName  , "." ) ;
        else                                                  { OStEXTCF( ostoOsName , idMemorySpaceP ? idMemorySpaceP : tinP.pAdamGlobal1->idMemorySpace , '0' ) ; }
        if( F(flagsP) & flOPENsHAREDmEMORY_ALLmEMORYsPACES )  { OStEXTAK( ostoOsName  , "_" ) ; }
        OStEXTAK( ostoOsName  , "." ) ;
        else                                                  { OStEXTC(  ostoOsName , processGlobal1I.idAdamRoot == ifcIDaDAM_TOOLnAPwORDvIEWER && tinP.pAdamGlobal1->_thirdC_.idHomeOverride ? tinP.pAdamGlobal1->_thirdC_.idHomeOverride : processGlobal1I.idHome , 0 ) ; }
        if( F(flagsP) & flOPENsHAREDmEMORY_ALLhOMES         ) { OStEXTAK( ostoOsName  , "_" ) ; }
        OStEXTAK( ostoOsName  , "." ) ;
        else                                                  { OStEXTA(  ostoOsName , thirdC::postUserNameIF() ) ; }
        if( F(flagsP) & flOPENsHAREDmEMORY_ALLuSERS         ) { OStEXTAK( ostoOsName  , "_" ) ; }
        OStEXTA(  ostoOsName  , postPrefix ) ;
        OStEXT(   ostoOsName , COSTnAPKINnAMEmAX + 1 )
        //CODEsYNC: DUPLICATE CODE 1020061 1020068

        ;
            :          "ideafarm.domains.com.ideafarm.1."
            ?  "Global\\ideafarm.domains.com.ideafarm.1."

        osTextT* postPrefix = bSystem && c_strstrIF( tinP , postP , "napSlab" )

        }
            if( !POOP && !tinP.brcRaw ) bSystem = 1 ;
            BOSdOnOTtEST( WHATgbo , strcmp( postUser , "SYSTEM" ) )
    
            BOSpOOP
            BOS( WHATgbo , BOSoK , GetUserName( postUser , &costaUser ) )

            DWORD costaUser = sizeof postUser ;
            char postUser[ 0x100 ] ;
        {
        ZE( boolT , bSystem ) ;

    #elif defined( __NT__ )

        if( POOP ) pv = 0 ;
        BOSpOOP
        BOSI( WHATgbo , BOSfAIL , DosAllocSharedMem( &pv , ostoName , cbw , PAG_COMMIT | PAG_EXECUTE | PAG_READ | PAG_WRITE ) )

        OStEXTA( ostoName  , postP ) ;
        OStEXTAK( ostoName  , "\\sharemem\\" ) ;
        OStEXT( ostoName , COSToSfILEnAMEmAX + 11 )

    #ifdef __OS2__

    ZE( voidT* , pv ) ;
    if( !cbw ) cbw = 0x100000 ;
    countT cbw = cbP ;

    _IO_

    }
        if( POOP ) return ;
        __( idMemorySpaceP && !( F(tinP.flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tinP ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tinP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        FV(flOPENsHAREDmEMORY,flagsP) ;
        __( phFileP && F(flagsP) & flOPENsHAREDmEMORY_DOnOTcOMMIT ) ;
        __( idMemorySpaceP == ifcIDmEMORYsPACE_KERNEL && processGlobal1I.idAdamRoot != ifcIDaDAM_KERNEL2MONITOR && processGlobal1I.idAdamRoot != ifcIDaDAM_KERNEL1DRIVER ) ;
        __( COSToSfILEnAMEmAX < thirdC::c_strlenIF( tinP , postP ) ) ;
        __( !!thirdC::c_strchrIF( tinP , postP , '\\' ) ) ;
        //__( !!thirdC::c_strchrIF( tinP , postP , '/' ) ) ;
        __( !*postP ) ;
        if( POOP ) return ;
        __Z( postP ) ;
        #endif
            { ZE( boolT , foo ) ; __( !foo && sizeof(countT) != sizeof(HANDLE) ) ;  }
        #if defined( __NT__ )
        if( POOP ) return ;
    {
    IFbEcAREFUL    
{
/*1*/voidT thirdC::dosAllocSharedMemIF( tinS& tinP , handleC& handleP , const osTextT* const postP , const handleC* phFileP , const countT cbP , const countT idMemorySpaceP , const flagsT flagsP )/*1*/

/**/
*/
 cbP
  cannot contain slash ('/') or backslash ('\\')
  must be less than 240 bytes
 postP
 handleP
arguments
\<A HREF=\"5.1020061.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosAllocSharedMemIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

