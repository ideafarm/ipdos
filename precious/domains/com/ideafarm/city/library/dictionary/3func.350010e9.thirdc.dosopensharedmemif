
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    osTraceWrongNodeIF( tinP , (byteT*)handleP.cNoteF() , "dosOpenSharedMemIF: cNote" ) ;

    }
        }
            processGlobal4S::_processGlobal4I_IF().bksTrace.writeF( tinP , postSay , sizeof postSay - 1 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
            CONoUTrAW( postSay ) ;
            CONoUTrAW( "\r\n" ) ;
            osTextT postSay[] = "dosOpenSharedMemIF / could not lock virtual memory" ; // CANNOT USE etherC::traceF WHICH MIGHT INDIRECTLY CALL ME

            tinP.bosFail = 0 ;
        {
        if( tinP.bosFail )

        BOS( WHATgbo , BOSoK , VirtualLock( (byteT*)handleP.cNoteF() , cbP ) )
                  
        CONoUTrAW( ostoSay ) ; //U::TO FIND A BUG
        OStEXTAK( ostoSay , "\"\r\n" ) ;
        OStEXTA(  ostoSay , postP ) ;
        OStEXTAK( ostoSay , "    \"" ) ;
        OStEXTC(  ostoSay , cbP , 0 ) ;
        OStEXTAK( ostoSay , "    " ) ;
        OStEXTC(  ostoSay , handleP.cNoteF() , 0 ) ;
        OStEXTAK( ostoSay , "locking [pb,cb,name]:    " ) ;
        OStEXT(   ostoSay , TUCK << 1 ) ;

        raiseWorkingSetSizeHintsIF( tinP , cbP + 1 ) ; //THIS MUST BE DONE BECAUSE THE MINIMUM HINT IS USED AS A MAXIMUM ALLOWED FOR LOCKING (WINSHIT) ; THE "+ 1" MIGHT NOT BE NECESSARY
    {
    else if( F(flagsP) & flOPENsHAREDmEMORY_LOCK )
         if( POOP                                ) flagsResultP = 0 ;

    }
        //__( tinP.brcRaw ) ;
        //BOSdOnOTtEST( WHATgbo , IsBadReadPtr( (voidT*)handleP.cNoteF() , cbP ? cbP : 1 ) ) //U:: ACCORDING TO WIN32 DOC AT 20121216@0913, THIS FUNCTION DOES NOT WORK AND SHOULD NOT BE USED: http://msdn.microsoft.com/en-us/library/aa366713(VS.85).aspx
        __( !handleP.cNoteF() ) ;
        __Z( handleP ) ;
        __( bFail ) ;
        }
            bFail = POOP ;

            }
                if( !( F(flagsP) & flOPENsHAREDmEMORY_DOnOTsERIALIZE ) && F(processGlobal2I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal2I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal4I.grabMemorySpace.ungrabF( tinP ) ;

                }
                    default : { __( idHowP ) ; __1 break ; }
                    }
                        break ;
                        if( POOP ) flagsResultP = 0 ;

                        }
                            BLAMMO ; //TO FORCE CALLED FUNCTION TO BE REASONABLE
                        {
                        if( POOP && ~handleP )

                        dosAllocSharedMemIF( tinP , handleP , postP , phFileP , cbP , idMemorySpaceP , flagsP | flOPENsHAREDmEMORY_DOnOTsERIALIZE ) ;
                    {
                    case ifcOPENsHAREDmEMORYhOW_nCeF :
                    }
                        POOPR
                        else if( idHowP == ifcOPENsHAREDmEMORYhOW_nFeO ) break ;
                        }
                            break ;
                            flagsResultP = flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ;
                        {
                        if( !POOP )

                        }
                            BLAMMO ; //TO FORCE CALLED FUNCTION TO BE REASONABLE
                        {
                        if( POOP && ~handleP )

                        dosGetSharedMemIF( tinP , handleP , postP , idMemorySpaceP , flagsP | flOPENsHAREDmEMORY_DOnOTsERIALIZE ) ;
                    {
                    case ifcOPENsHAREDmEMORYhOW_nFeO :
                    case ifcOPENsHAREDmEMORYhOW_nCeO :
                {
                if( !POOP && !handleP ) switch( idHowP )
    
                }
                    }
                        break ;
                        }

                            flagsResultP = flOPENsHAREDmEMORYrESULT_ALREADYoPEN | flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ;
                            hRoot.resetF() ;
                            handleP = hRoot ; 
                            hRoot.osF( ifcIDtYPEhANDLE_SHAREDmEMORY , processGlobal2I._thirdC_pSharedMemInfo[ offr ].osh , 0 , (countT)processGlobal2I._thirdC_pSharedMemInfo[ offr ].pv ) ;
                            handleC hRoot( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_SHAREDmEMORY ) ;
                        {
                        else
                        if( idHowP == ifcOPENsHAREDmEMORYhOW_nCeF ) __1
                    {
                    if( !c_strcmpIF( tinP , processGlobal2I._thirdC_pSharedMemInfo[ offr ].postName , ostoOsName ) )
                {
                for( countT offr = 0 ; offr < CsHAREDmEMiNFO ; offr ++ )

                if( !( F(flagsP) & flOPENsHAREDmEMORY_DOnOTsERIALIZE ) && F(processGlobal2I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal2I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal4I.grabMemorySpace.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            POOPIE
        {
        ZE( boolT , bFail ) ;
        BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
        boolT bWoth = 1 ;

        c_zReplaceIF( tinP , (osTextT*)(const osTextT*)ostoOsName , '/' , '.' ) ;
        OStEXTA(  ostoOsName  , postP ) ;
        OStEXTAK( ostoOsName  , "." ) ;
        OStEXTCF( ostoOsName , idMemorySpaceP ? idMemorySpaceP : tinP.pAdamGlobal1->idMemorySpace , '0' )    
        OStEXTAK( ostoOsName  , "." ) ;
        OStEXTC(  ostoOsName , processGlobal2I.idHome , 0 )
        OStEXTAK( ostoOsName  , "." ) ;
        OStEXTA(  ostoOsName , thirdC::postUserNameIF() ) ;
        OStEXTAK( ostoOsName  , "ideafarm.domains.com.ideafarm.1." ) ;
        OStEXT(   ostoOsName , COSTnAPKINnAMEmAX + 1 )
        //CODEsYNC: DUPLICATE CODE 1020061 1020068
    {
    flagsResultP = flOPENsHAREDmEMORYrESULT_null ;

    _IO_

    }
        if( POOP ) return ;
        __( idMemorySpaceP && !( F(tinP.flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tinP ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tinP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        FV(flOPENsHAREDmEMORY,flagsP) ;
        __( idMemorySpaceP == ifcIDmEMORYsPACE_KERNEL && processGlobal2I.idAdamRoot != ifcIDaDAM_KERNEL2MONITOR && processGlobal2I.idAdamRoot != ifcIDaDAM_KERNEL1DRIVER ) ;
        __( COSTsHAREDmEMmAX < c_strlenIF( tinP , postP ) ) ;
        __( COSToSfILEnAMEmAX < thirdC::c_strlenIF( tinP , postP ) ) ;
        __( !!thirdC::c_strchrIF( tinP , postP , '\\' ) ) ;
        //__( !!thirdC::c_strchrIF( tinP , postP , '/' ) ) ;
        __( flagsResultP ) ;
        __( ~handleP ) ;
        __( !*postP ) ;
        if( POOP ) return ;
        __Z( postP ) ;
        #endif
            { ZE( boolT , foo ) ; __( !foo && sizeof(countT) != sizeof(HANDLE) ) ;  }
        #if defined( __NT__ )
        if( POOP ) return ;
    {
    IFbEcAREFUL    
{
/*1*/voidT thirdC::dosOpenSharedMemIF( tinS& tinP , handleC& handleP , flagsT& flagsResultP , const osTextT* const postP , const handleC* phFileP , const countT cbP , const countT idHowP , const countT idMemorySpaceP , const flagsT flagsP )/*1*/

/**/
*/
  ignored if the named memory object exists
 cbP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001014c.ifcOPENsHAREDmEMORYhOW!||
 idHowP
  must not be longer than COSTsHAREDmEMmAX
 postP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010207.flOPENsHAREDmEMORYrESULT!||
 flagsResultP
  must be null
 handleP
 tinP
arguments
if creation is needed, i will block and retry repeatedly until creation succeeds
 just be sure to close each handle obtained exactly wo'ce
a process can open the same shared memory multiple times no problemo
\<A HREF=\"5.1020110.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosOpenSharedMemIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

