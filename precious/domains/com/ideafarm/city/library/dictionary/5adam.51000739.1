
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tinP , T("ok") ) ;

}
    }
        }
            ++ s ; etThread.osSleepF( tinP , TOCK ) ;
        {
        while( ws.cWorkers )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        etThread.traceF( tinP , T("waiting for worker") ) ;

        }
            //etThread.traceF( tinP , T("napped") ) ;
            ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //etThread.traceF( tinP , T("napping") ) ;

            if( bQuit ) break ;

            THREADmODE1rESTORE
            }
                }
                    }
                        }
                            ++ s ; etThread.osSleepF( tinP , TOCK >> 3 ) ;
                            etThread.traceF( tinP , T("waiting for queue to shrink [cPending]:    ")+TF2(ws.st_pPageEvent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        while( ws.st_pPageEvent > TUCK )
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    if( ws.st_pPageEvent > ( TUCK << 1 ) )                // THE QUEUE LENGTH MUST BE SMALL SO THAT IT IS IMPOSSIBLE FOR A QUEUED ITEM TO BE IN A BOOK OTHER THAN THE BOOK IMMEDIATELY PRECEDING THE BOOK BEING READ, ASSUMING THAT I ONLY KEEP WO INACTIVE BOOK

                    //if( bPrefix ) bQuit2 = 1 ; //U:: TO FIND A BUG

                    bPrefix = !bPrefix ;

                    else          pbi = 0 ;
                    if( bDelete ) PUSE( tinP , *(byteT**)&pbi ) ;

                    ;
                        : sizeof( countT )
                        ? *(countT*)pbi
                    cbi = bPrefix

                    }
                        if( ws.idIn < TUCK || !( ws.idIn % TUCK ) ) etThread.traceF( tinP , T("[ws.idIn]:    ")+TF2(ws.idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        ++ ws.idIn ;
                        ws.st_pPageEvent << *(countT*)&pPageEvent ;

                        __( (countT)*pPageEvent - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                        }
                            break ;
                            hRead = hReadSave ;
                            cbi = cbiSave ;
                        {
                        if( !(const byteT*)*pPageEvent )        //SHOULD BE IMPOSSIBLE SINCE "ALL OR NONE" USED FOR WRITING BOOKTOGETHER AND I'VE ALREADY READ THE PREFIX

                        THREADmODE3rESTORE
                        bksAccessEvents.readF( tinP , *pPageEvent , hRead , flBOOKScrEAD_null ) ;
                        pPageEvent = new( 0 , tinP , LF ) pageC( tinP , bksAccessEvents , cbi ) ; ___( pPageEvent ) ;
                        THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )
                        ZE( pageC* , pPageEvent ) ;
                    {
                    else
                    }
                        __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                        }
                            break ;
                            hRead = hReadSave ;
                            cbi = cbiSave ;
                        {
                        if( !pbi )
                        bDelete = bksAccessEvents.readF( tinP , pbi , cbi , hRead , flBOOKScrEAD_null , &bQuit ) ;
                    {
                    if( bPrefix )
                    ZE( boolT , bDelete ) ;

                    HANDLEaPPnOTEScOUNTcLASS ch = hRead ;

                    handleC hReadSave = hRead ;
                    countT cbiSave = cbi ;
                {
                while( !bQuit && !bQuit2 && !POOP )
                boolT bPrefix = 1 ;
                countT cbi = sizeof( countT ) ;
                ZE( const byteT* , pbi ) ;

                // *****************************************************************************************************************************************************************************************************************************************************
                // *****************************************************************************************************************************************************************************************************************************************************
                // ********                    *************************************************************************************************************************************************************************************************************************
                // ********  EAT BOOK ENTRIES  *************************************************************************************************************************************************************************************************************************
                // ********                    *************************************************************************************************************************************************************************************************************************
                // *****************************************************************************************************************************************************************************************************************************************************
                // *****************************************************************************************************************************************************************************************************************************************************
            {
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        {
        while( !bQuit && !bQuit2 && !POOP )
        ZE( boolT , bDestroyOutputBooks ) ;
        ZE( boolT , bQuit2 ) ;
        handleC hRead( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
        etThread.traceF( tinP , T("search booksTogether / enering loop to read events") ) ;

        }
            etThread.osThreadF( tinP , countTC() , tmWorkerF , 0 , flTHREADlAUNCH_null , TOCK , (countT)&ws , (countT)&bksAccessEvents ) ;
            inc02AM( ws.cWorkers ) ;
        {
        while( cDo -- )
        countT cDo = 0x40 ;
        etThread.traceF( tinP , T("search booksTogether / launching workers") ) ;

        workS ws( tinP , etThread ) ;
        etThread.traceF( tinP , T("search booksTogether / ct ws") ) ;
    {

    TN( tb4 , "    " ) ;
    booksC bksAccessEvents( tinP , TAG( TAGiDnULL ) , "bksAccessEvents.1.raw" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_null , 0 , 1 , 0 , 0 , 0 , 0 , &bQuit ) ;
    const boolT& bQuit = *(const boolT*)&(const countT&)ether ;
    etThread.traceF( tinP , T("ct bksAccessEvents") ) ;
{

TODO

DONE( tmWorkerF )
}
    dec02AM( wsP.cWorkers ) ;
    _OUT_

    }
        _OUT_
        }
            _OUT_
            THREADmODE1rESTORE
            }
                _OUT_
                wsP.st_pPageEvent.ungrabF( tinP ) ;
                }
                    _OUT_
                    wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    }
                        _OUT_
                        THREADmODE3rESTORE
                        DEL( pPageEvent ) ;
                        THREADmODE3oN( flTHREADmODE3_DOnOTrEGISTERpAGEc )

                        }
                            etThread.delF( tinP , psttBrowser ) ;
                            etThread.delF( tinP , psttProtocol ) ;
                            etThread.delF( tinP , psttQuery ) ;
                            etThread.delF( tinP , psttUri ) ;
                            etThread.delF( tinP , psttContainer ) ;
                            etThread.delF( tinP , psttLogBucket ) ;
                            etThread.delF( tinP , psttMethod ) ;

                            }
                                _OUT_

                                etThread.traceF( tinP , TT(timeW1,timeW2)+tb4+TF3(idMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,0xc)+T(psttUri) ) ;

                                countT idMe = 1 + incv02AM( wsP.idInspected ) ;

                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // ********  PROCESS WO BOOK ENTRY  ********************************************************************************************************************************************************************************************************************
                                // ********                         ********************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                // *****************************************************************************************************************************************************************************************************************************************************
                                _INoLD_
                            {
                            else
                            if( getNegAM( finger ) != FINGERnEG_ACCESSeVENTrAW || idFormat != 1 ) etThread.traceF( tinP , T("unexpected format [finger,idFormat]:    ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            sBookEntryIn >> psttBrowser ;             ___( psttBrowser ) ;
                            sBookEntryIn >> cbRequest ;
                            sBookEntryIn >> code ;
                            sBookEntryIn >> psttProtocol ;            ___( psttProtocol ) ;
                            sBookEntryIn >> psttQuery ;               ___( psttQuery ) ;
                            sBookEntryIn >> psttUri ;                 ___( psttUri ) ;
                            sBookEntryIn >> psttContainer ;           ___( psttContainer ) ;
                            sBookEntryIn >> psttLogBucket ;           ___( psttLogBucket ) ;
                            sBookEntryIn >> psttMethod ;              ___( psttMethod ) ;
                            sBookEntryIn >> nnHe ;
                            sBookEntryIn >> *(countT*)&timeW2 ;
                            sBookEntryIn >> timeW1 ;
                            sBookEntryIn >> idFormat ;
                            sBookEntryIn >> finger ;

                            ZE( strokeS* , psttBrowser   ) ;
                            ZE( countT   , cbRequest     ) ;
                            ZE( countT   , code          ) ;
                            ZE( strokeS* , psttProtocol  ) ;
                            ZE( strokeS* , psttQuery     ) ;
                            ZE( strokeS* , psttUri       ) ;
                            ZE( strokeS* , psttContainer ) ;
                            ZE( strokeS* , psttLogBucket ) ;
                            ZE( strokeS* , psttMethod    ) ;
                            nicNameC       nnHe            ;
                            ZE( sCountT  , timeW2        ) ;
                            ZE( countT   , timeW1        ) ;
                            ZE( countT   , idFormat      ) ;
                            ZE( countT   , finger        ) ;

                            }
                                etThread.delF( tinP , pbPageCopy ) ;
                                }
                                    sBookEntryIn.shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbPageCopy , 0 , 0 , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;

                                    bksAccessEventsP.unlockF( tinP ) ;
                                    etThread.memCopyF( tinP , pbPageCopy , pbzPage , cbzPage ) ;
                                    const byteT* pbzPage = *pPageEvent ;
                                    bksAccessEventsP.lockF( tinP , TAG( TAGiDnULL ) ) ;
                                {
                                if( !POOP )

                                __Z( pbPageCopy ) ;
                                etThread.newF( tinP , LF , pbPageCopy , cbzPage ) ; ___( pbPageCopy ) ;
                                ZE( byteT* , pbPageCopy ) ;

                                countT cbzPage = *pPageEvent ;
                            {
                            soulC sBookEntryIn( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( !ether )

                        _INoLD_
                    {
                    if( pPageEvent )

                    wsP.st_pPageEvent.ungrabF( tinP ) ;
                    wsP.st_pPageEvent >> *(countT*)&pPageEvent ;
                    ZE( pageC* , pPageEvent ) ;
                    _INoLD_
                {
                while( wsP.st_pPageEvent )
                wsP.st_pPageEvent.grabF( tinP , TAG( TAGiDnULL ) ) ;

                _INoLD_
            {
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            _INoLD_
        {
        else
        }
            //etThread.traceF( tinP , T("napped") ) ;
            ++ s ; etThread.osSleepF( tinP , TOCK << 2 ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //etThread.traceF( tinP , T("napping") ) ;

            if( ether ) break ;
        {
        if( !wsP.st_pPageEvent )
        _INoLD_
    {
    while( !etThread && !POOP )

    TN( tDot , "." ) ;
    TN( tb4 , "    " ) ;

    booksC& bksAccessEventsP = *(booksC*)pTaskP->c2 ;
    workS&  wsP              =  *(workS*)pTaskP->c1 ;
    _INoLD_

    thirdC::c_memcpyIF( tinP , (byteT*)tinP.ppJot , (byteT*)pTaskP->pTinDad->ppJot , sizeof tinP.ppJot ) ;    //U:: MOVE TO BASE (flTHREADlAUNCH)
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )

}
{
idInspected( 0 )
idIn( 0 ) ,
cWorkers( 0 ) ,
st_pPageEvent( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_countT ) ,
workS::workS( tinS& tinP , etherC& etherP ) :

}
    TINSL
{
workS::~workS( voidT )

;
}
    workS( tinS& tinP , etherC& etherP ) ;
    ~workS( voidT ) ;

    countT        idInspected ;
    countT        idIn ;
    countT        cWorkers ;

    stackC        st_pPageEvent ;
{
struct workS

/*1*/WAKEhIDE( "search for particular transactions in booksTogether" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
