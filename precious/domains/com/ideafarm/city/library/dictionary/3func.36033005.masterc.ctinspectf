
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
    b_cLever.ungrabF( tinP ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG

    FORsTRINGSiNsPANNEDcOMBINEDtAIL1
    }
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
        ether.delF( tinP , pbm ) ;
        DEL( pInfo ) ;
        }
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
            }
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
                newNameF( tinP , cName , stUses , flMASTERc_null , idCopy ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG

                }
                    while( !ether && ~handle ) ;
                    }
                        }
                            ether.delF( tinP , psttw3 ) ;
                            }
                                if( cUses ) stUses << cUses ;
                                countT cUses = ether.strDigitsToSCountF( tinP , psttw3 , 0 , 1 ) ;
                            {
                            if( ether.strIsDigitsF( tinP , psttw3 ) )
                            ether.strSubstringF( tinP , psttw3 , idf , idl , tUses ) ; ___( psttw3 ) ;
                            ZE( strokeS* , psttw3 ) ;
                            //sttq = ze ;
                            countT idl = idf + sizeof( countT ) * 2 - 1 ;
                            idf = 0xa ;
                        {
                        if( tUses.csF( tinP ) == 0x1a && 0x12 == ether.strIdF( tinP , idf , sttq , T(".ipdos-wm") , tUses ) )
                        countT idf = 1 ;
                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                        TN( tUses , postUses ) ;
                        byteT* postUses = (byteT*)pInfo->pSt_postDllUsed->downF( tinP , handle ) ;
                    {
                    do
                    handleC handle( tinP , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( pInfo->pSt_postDllUsed && *pInfo->pSt_postDllUsed )
                stackC stUses( tinP , ether , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) , flSTACKc_FIFO ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG

                }
                    __Z( bFound ) ;
                    ether.delF( tinP , pstt1w ) ;
                    }
                        else if( !ether.strCompareF( tinP , psttc2 , tTagIdCopy ) ) bNext = 1 ;
                        }
                            break ;
                            bFound = 1 ;
                            idCopy = ether.strDigitsToSCountF( tinP , psttc2 ) ;
                        {
                        if( bNext )
                    {
                    FORsTRINGSiN2( pstt1w )
                    ZE( boolT , bFound ) ;
                    ZE( boolT , bNext ) ;
                    ether.strWordsOldF( tinP , pstt1w , T(pInfo->postDescription) , sttq ) ; ___( pstt1w ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , pstt1w ) ;
                {
                ZE( countT , idCopy ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
            {
            else
            if( !cName ) __1
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG

            }
                ether.delF( tinP , psttw ) ;
                }
                    ether.delF( tinP , psttw2 ) ;
                    cName = ether.strDigitsToSCountF( tinP , psttw2 , 0 , 1 ) ;
                    ether.strSubstringF( tinP , psttw2 , idf , idl , psttw ) ; ___( psttw2 ) ;
                    ZE( strokeS* , psttw2 ) ;
                    countT idl = idf + sizeof( countT ) * 2 - 1 ;
                    countT idf = 0xa ;
                    //sttq = ze ;
                {
                else
                if( !psttw || psttw->idAdam - 0x12 - 2 * sizeof( countT ) ) __1                     // "ideafarm.12345678.ipdos-wm"
                ether.strWordF( tinP , psttw , psttc1 , sttq , sttSlash , - 1 ) ; ___( psttw ) ;    //  123456789abcdef0123456789a
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;                                       //  0              1
                ZE( strokeS* , psttw ) ;
            {
            ZE( countT , cName ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
        {
        else
        if( !pInfo ) __1
        third.imageExeDllF( tinP , pInfo , pbm ) ; ___( pInfo ) ;
        ZE( imageExeDllC* , pInfo ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG

        THREADmODE1rESTORE
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
        ether.boxGetShadowF( tinP , pbm , cbm , psttc1 ) ; ___( pbm ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        ZE( countT , cbm ) ;
        ZE( byteT* , pbm ) ;

        cToDo -- ;

        if( tinP.pcQuit && *tinP.pcQuit ) break ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
    {
    FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG

    THREADmODE1rESTORE
    countT cToDo = ether.boxMenuF( tinP , soul1m , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/master/ideafarm.")+( cNameInspectP ? TF3(cNameInspectP,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,sizeof(countT)*2)+T(".ipdos-wm") : T("*.ipdos-wm") ) ) ;
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    soulC soul1m( tinP , TAG( TAGiDnULL ) ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG

    b_cLever.grabF( tinP , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) ) ;

    TN( tTagIdCopy , "!idCopy" ) ;
    strokeS sttSlash( '/' ) ;
    thirdC& third = ether ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG

    }
        if( POOP ) return ;
        __( tinP.pAdamGlobal1->_masterC_.pMePrime != this ) ;
        __( !tinP.pAdamGlobal1->_masterC_.pMePrime ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    upDnC upDn( tinP , TAGoR( TAGiDnULL , idLineCt , idiFileCt , pbBitsCt ) , IDFILE , ether ) ;
    scoopC scoop( tinP , ether ) ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG

    }
        countT foo = 2 ;
    {
    if( idIn == 5 )
    countT idIn = 1 + incv02AM( idInLath ) ;
    static countT idInLath ;
linkedC::checkIF( tinP ) ; //U:: TO FIND A BUG
{
/*1*/voidT masterC::ctInspectF( tinS& tinP , const countT cNameInspectP )/*1*/

/**/
*/
i obey tinP.pcQuit
if !cNameInspectP then masterC becomes a model of the actual current state of the master files
\<A HREF=\"5.1490005.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$ctInspectF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

