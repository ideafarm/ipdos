
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    //}
    //    }
    //        }
    //            countT foo = 2 ;
    //        {
    //        if( idIn == TUCK )
    //
    //        countT idIn = 1 + incv02AM( idInLath ) ;
    //        static countT idInLath ;
    //    {
    //    if( cbP == 0x241b0 )
    //    CONoUTrAW3( "\r\npoolC::newF - [cbP]: " , cbP , "" ) ;
    //{
    //if( tinP.pc Utility[ 0 ] ) //TO FIND A BUG

    }
        _OUT_
        }
            _OUT_
            }
                __1
                __( cbP ) ;
            {
            if( !pbP && !( F(flagsP) & flPOOLcnEW_DOnOTbLOCK ) )

            POSTPONEtEST( pbP ) ;

            dropHeader = dropHeader << guts.cBitsExpCbSlot | offs - guts.expCbSlotMin ;
            BLAMMOiFcANNOTsHIFTlEFT( dropHeader , guts.cBitsExpCbSlot ) ;
            countT& dropHeader = ((countT*)pbP)[ - 1 ] ;

            pbP = guts.ppSlots[ offs ]->newF( tinP , idLineP , idiFileP , flagsSlots ) ;

            //if( offs == 0x18 ) tinP.pEther->traceF( tinP , T("++++++++ new") ) ; //U::20140808@1936: TO FIND A BUG

            if( F(flagsP) & flPOOLcnEW_DOnOTbLOCK  ) flagsSlots |= flSLOTScnEW_DOnOTbLOCK  ;
            if( F(flagsP) & flPOOLcnEW_DOnOTcTsEXc ) flagsSlots |= flSLOTScnEW_DOnOTcTsEXc ;
            flagsT flagsSlots = flSLOTScnEW_null ;

            }
                _OUT_
                guts.pGrabNewElt[ offs ].ungrabF( tinP ) ;
                }
                    _OUT_
                    THREADmODE1rESTORE
                    guts.ppSlots[ offs ] = new( 0 , tinP , guts.pbza + offs * sizeof( slotsC ) , sizeof( slotsC ) ) slotsC( tinP , TAG( TAGiDnULL ) , idLineP , idiFileP , ostoName , guts.cBitsExpCbSlot , offs , flagsc , guts.idStateSpace , guts.idMemorySpace , this ) ;
                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            
                    if( F(guts.flagsCt) & flPOOLc_NOTES    ) flagsc |= flSLOTSc_NOTES    ;
                    if( F(guts.flagsCt) & flPOOLc_READoNLY ) flagsc |= flSLOTSc_READoNLY ;
                    flagsT flagsc = flSLOTSc_null ;

                    OStEXTCF( ostoName , offs , '0' ) ;
                    OStEXTAK( ostoName , ".slots." ) ;
                    OStEXTAK( ostoName , ".poolC" ) ;
                    OStEXTA(  ostoName , guts.postName ) ;
                    OStEXT(   ostoName , TUCK )
                    _INoLD_
                {
                if( !guts.ppSlots[ offs ] )
                guts.pGrabNewElt[ offs ].grabF( tinP , TAG( TAGiDnULL ) ) ;
                _INoLD_
            {
            if( !guts.ppSlots[ offs ] )
            _INoLD_
        {
        if( cbuMax && offs <= guts.expCbSlotMax )

        }
            cbuMax <<= 1 ;
            offs ++ ;
        {
        while( cbuMax && cbP > cbuMax )
        countT cbuMax = 1 << offs ;
        countT offs = guts.expCbSlotMin ;

        if( F(tinP.flagsThreadMode2) & flTHREADmODE2_DISALLOWpUSE ) { BLAMMO ; }
        if( this != tinP.pAdamGlobal1->pPoolAdamTemp && !( F(tinP.flagsThreadMode2) & flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ) { BLAMMO ; }
        if( F(guts.flagsCt) & flPOOLc_READoNLY ) { BLAMMO ; }
        _INoLD_
    {
    else
    else if( F(tinP.flagsThreadMode3) & flTHREADmODE3_POOLaLLOCATEfROMhEAP ) pbP = processGlobal3I.heap.newF( tinP , idLineP , idiFileP , cbP ) ;
    }
        _OUT_
        pbP          = (byteT*)idJot ;
        countT idJot = juse.writeF( tinP , 0 , cbP ) ;
        jotC&  juse  = *tinP.ppJot[ (countT)pbP - JrEQUEST_min ] ;
        _INoLD_     //U:: REMOVE ALL OF THESE (EXCEPT THE WOTH) IN PRODUCTION (TO FIND A BUG)
    {
    if( pbP ) // IF I AM TO DIVERT THIS REQUEST TO A SPECIFIED jotC INSTANCE RATHER THAN ALLOCATE FROM MY sexC INSTANCES

    //}
    //    CONoUTrAW3( "\r\npoolC::newF + [cbP]: " , cbP , "" ) ;
    //{
    //if( tinP.pc Utility[ 0 ] ) //TO FIND A BUG

//    }
//        BLAMMOiFcALLEDbY( "bookC" )
//        BLAMMOiFcALLEDbY( "booksC" )
//    {
//    if( thirdC::third_idPhaseAdam_IF( tinP ) >= ifcIDpHASEaDAM_PROLOGaDAMmAIN1 )
//    //U:: 20180208@0638: TO ELIMINATE ALL USE OF poolC BY booksC AND bookC

    _INoLD_

    }
        if( POOP ) return ;
        FV( flPOOLcnEW , flagsP ) ;
        __Z( ISnULLjpOINTER( pbP ) ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    SCOOP ;  // THIS IS INTENDED TO PREVENT AMBIENT IMPOTENCE FROM AFFECTING ME ; WO REASON IS TO ENSURE THAT C++ CALLS TO OVERLOADED OPERATOR new RETURN A NONZE POINTER IF POSSIBLE ; WHEN AN OVERLOADD new RETURNS 0, C++ (WATCOM) JUMPS IMMEDIATELY BEYOND THE ASSOCIATED CT'OR CALL AND CALLS DT'OR FOR TEMPORARIES (bitsC) THAT WERE NEVER CT'D ; THE ROOT PROBLEM HERE IS THAT THE COMPILER DOES NOT GENERATE CORRECT CODE; THE GENERATED CODE SHOULD JUMP BEYOND THE DT'OR CALLS FOR THE TEMPORARIES
    poopC poop ;
{
/*1*/voidT poolC::newF( tinS& tinP , const countT idLineP , const countT idiFileP , byteT*& pbP , const countT cbP , const flagsT flagsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

