
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        //}
        //    }
        //        }
        //            countT foo = 2 ;
        //        {
        //        if( idIn == TUCK )
        //
        //        countT idIn = 1 + incv02AM( idInLath ) ;
        //        static countT idInLath ;
        //    {
        //    if( cbP == 0x241b0 )
        //    CONoUTrAW3( "\r\npoolC::newF - [cbP]: " , cbP , "" ) ;
        //{
        //if( tinP.pc Utility[ 0 ] ) //TO FIND A BUG

        }
            }
                }
                    __1
                    __( cbP ) ;
                {
                if( !pbP && !( F(flagsP) & flPOOLcnEW_DOnOTbLOCK ) )

                THREADmODE4rESTORE

                }
                    putNegAM( pDropNote->finger , FINGERnEG_dropNoteSpoolC2 ) ;
                    pDropNote->dropHeaderCopy = dropHeader ;
                {
                if( pDropNote )

                dropHeader = dropHeader << guts.cBitsExpCbDrop | offs - guts.expCbDropMin ;

                BLAMMOiFcANNOTsHIFTlEFT( dropHeader , guts.cBitsExpCbDrop ) ;

                countT& dropHeader = ((countT*)pbP)[ - 1 ] ;

                if( pDropNote ) putNegAM( pDropNote->finger , FINGERnEG_dropNoteSpoolC1 ) ;

                dropNoteS* pDropNote = guts.ppSlots[ offs ]->pDropNoteF( tinP , pbP ) ;

                pbP = guts.ppSlots[ offs ]->newF( tinP , idLineP , idiFileP , flagsSlots ) ;

                THREADmODE4oN( flTHREADmODE4_DOnOTtESTdROPhEADERS )

                //if( offs == 0x18 ) etherC::etRockIF( tinP ).traceF( tinP , T("++++++++ new") ) ; //U::20140808@1936: TO FIND A BUG

                if( F(flagsP) & flPOOLcnEW_DOnOTbLOCK  ) flagsSlots |= flSLOTScnEW_DOnOTbLOCK  ;
                if( F(flagsP) & flPOOLcnEW_DOnOTcTsEXc ) flagsSlots |= flSLOTScnEW_DOnOTcTsEXc ;
                flagsT flagsSlots = flSLOTScnEW_null ;

                }
                    guts.pGrabNewElt[ offs ].ungrabF( tinP ) ;
                    }
                        THREADmODE1rESTORE
                        guts.ppSlots[ offs ] = new( 0 , tinP , guts.pbza + offs * sizeof( slotsC ) , sizeof( slotsC ) ) slotsC( tinP , TAG( TAGiDnULL ) , idLineP , idiFileP , ostoName , guts.cBitsExpCbDrop , offs , flagsc , guts.idStateSpace , guts.idMemorySpace , this ) ;
                        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                
                        if( F(guts.flagsCt) & flPOOLc_NOTES    ) flagsc |= flSLOTSc_NOTES    ;
                        if( F(guts.flagsCt) & flPOOLc_READoNLY ) flagsc |= flSLOTSc_READoNLY ;
                        flagsT flagsc = flSLOTSc_null ;

                        OStEXTCF( ostoName , offs , '0' ) ;
                        OStEXTAK( ostoName , ".slots." ) ;
                        OStEXTAK( ostoName , ".poolC" ) ;
                        OStEXTA(  ostoName , guts.postName ) ;
                        OStEXT(   ostoName , TUCK << 2 )
                    {
                    if( !guts.ppSlots[ offs ] )
                    guts.pGrabNewElt[ offs ].grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( !guts.ppSlots[ offs ] )
            {
            if( cbuMax && offs <= guts.expCbDropMax )

            }
                cbuMax <<= 1 ;
                offs ++ ;
            {
            while( cbuMax && cbP > cbuMax )
            countT cbuMax = 1 << offs ;
            countT offs = guts.expCbDropMin ;

            if( F(tinP.flagsThreadMode2) & flTHREADmODE2_DISALLOWpUSE ) { BLAMMO ; }
            if( this != tinP.pAdamGlobal1->pPoolAdamTemp && !( F(tinP.flagsThreadMode2) & flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ) { BLAMMO ; }

            if( F(guts.flagsCt) & flPOOLc_READoNLY ) { BLAMMO ; }
        {
        else
        else if( F(tinP.flagsThreadMode3) & flTHREADmODE3_POOLaLLOCATEfROMhEAP ) pbP = processGlobal4I.heap.newF( tinP , idLineP , idiFileP , cbP ) ;
        }
            pbP          = (byteT*)idJot ;
            countT idJot = juse.writeF( tinP , 0 , cbP ) ;
            jotC&  juse  = *tinP.ppJot[ (countT)pbP - JrEQUEST_min ] ;
        {
        if( pbP ) // IF I AM TO DIVERT THIS REQUEST TO A SPECIFIED jotC INSTANCE RATHER THAN ALLOCATE FROM MY sexC INSTANCES

        //}
        //    CONoUTrAW3( "\r\npoolC::newF + [cbP]: " , cbP , "" ) ;
        //{
        //if( tinP.pc Utility[ 0 ] ) //TO FIND A BUG

        //    }
        //        BLAMMOiFcALLEDbY( "bookC" )
        //        BLAMMOiFcALLEDbY( "booksC" )
        //    {
        //    if( thirdC::third_idPhaseAdam_IF( tinP ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 )
        //    //U:: 20180208@0638: TO ELIMINATE ALL USE OF poolC BY booksC AND bookC

        _IO_
    {

    }
        if( POOP ) return ;
        FV( flPOOLcnEW , flagsP ) ;
        __Z( ISnULLjpOINTER( pbP ) ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    SCOOP ;  // THIS IS INTENDED TO PREVENT AMBIENT IMPOTENCE FROM AFFECTING ME ; WO REASON IS TO ENSURE THAT C++ CALLS TO OVERLOADED OPERATOR new RETURN A NONZE POINTER IF POSSIBLE ; WHEN AN OVERLOADD new RETURNS 0, C++ (WATCOM) JUMPS IMMEDIATELY BEYOND THE ASSOCIATED CT'OR CALL AND CALLS DT'OR FOR TEMPORARIES (bitsC) THAT WERE NEVER CT'D ; THE ROOT PROBLEM HERE IS THAT THE COMPILER DOES NOT GENERATE CORRECT CODE; THE GENERATED CODE SHOULD JUMP BEYOND THE DT'OR CALLS FOR THE TEMPORARIES
    poopC poop ;
{
/*1*/voidT poolC::newF( tinS& tinP , const countT idLineP , const countT idiFileP , byteT*& pbP , const countT cbP , const flagsT flagsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

