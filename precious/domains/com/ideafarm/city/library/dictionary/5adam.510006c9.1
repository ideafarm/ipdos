
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    while( !ether && !POOP && ~hFind ) ;
    }
        }
            }
                }
                    etThread.delF( tinP , psttShort ) ;
                    }
                        raxUploadWoFileF( tinP , etThread , pInfo->psttIfoName , psttShort , pInfo->cbUsed , *pResultAuth ) ;
                        etThread.traceF( tinP , T("upload [idUp,cb,name]:    ")+TF2(++idUp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pInfo->cbUsed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttShort) ) ;
                    {
                    if(  !stNix( (osTextT*)T(psttShort) , subtractByteStringsReversedF ) )
                    etThread.strSubstringF( tinP , psttShort , idHit , idl , pInfo->psttIfoName ) ; ___( psttShort ) ;
                    ZE( countT , idl ) ;
                    ZE( strokeS* , psttShort ) ;
                {
                if( idHit ++ )
                countT idHit = etThread.strIdF( tinP , strokeS( '/' ) , pInfo->psttIfoName , - 1 ) ;                
            {
            if( ( pInfo->cbUsed || pInfo->cbUsedHigh ) && !pInfo->cbUsedHigh ) // SKIPS LARGE FILES BECAUSE EXCEED LIMIT OF RAX ANYWAY
            if( !( ++ idLook % ( TUCK << 4 ) ) ) etThread.traceF( tinP , TF2(idLook,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tInspecting+T(pInfo->psttIfoName) ) ;
        {
        if( pInfo && pInfo->psttIfoName )
        etThread.diskFindFileOrDirF( tinP , pInfo , hFind , tPathArchive+T("!*") ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    TN( tInspecting , " inspecting: " ) ;
    TN( tPathArchive , "///d/ideafarm.home.101/IdeaFarm (tm)/SYSTEM/Drop Files Here To Archive/" ) ;
    ZE( countT , idUp ) ;
    ZE( countT , idLook ) ;
{
etThread.traceF( tinP , T("3: walking local directory") ) ;

}
    raxGetAuthF( tinP , etThread , pResultAuth , tUser , tKey ) ;
    TN( tKey  , "100a4e75636b4b3f8adbd861548fe868" ) ;
    TN( tUser , "ideafarm" ) ;
{
ZE( resultAuthS* , pResultAuth ) ;

etThread.traceF( tinP , T("2: getting authorization key") ) ;

//}
//    etThread.delF( tinP , posts ) ;
//    etThread.traceF( tinP , T(posts) ) ;
//    stNix >> posts ;
//    ZE( osTextT* , posts ) ;
//{
//while( stNix )
//etThread.traceF( tinP , T("popping from stNix ...") ) ;

}
    etThread.delF( tinP , pstt1Files ) ;
    }
        etThread.delF( tinP , posti ) ;
        }
            }
                else        break ;
                if( postd ) postc = postd + 1 ;

                }
                    postShort = 0 ;
                    stNix.sinkF( tinP , ids , postShort , flSTACKsINK_UNIQUE , subtractByteStringsReversedF ) ;
                    ZE( countT , ids ) ;

                    etThread.memCopyF( tinP , postShort , postc , costa ) ;
                    etThread.newF( tinP , LF , postShort , costa ) ; ___( postShort ) ;
                    ZE( osTextT* , postShort ) ;
                {
                if( costa > 1 )
                countT costa = thirdC::c_strlenIF( tinP , postc ) + 1 ;

                if( !( ++ idLine % ( TUCK << 4 ) ) ) etThread.traceF( tinP , T("loading stNix [cFilesRemaining,idLine]: ")+TF2(cFound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idLine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                if( postd ) *postd = 0 ;
                osTextT* postd = thirdC::c_strchrIF( tinP , postc , '\n' ) ;
                //if( stNix == 8 ) break ;
            {
            while( !ether && !POOP )
            osTextT* postc = posti         ;
            osTextT* poste = posti + costi ;
        {
        if( posti && costi )
        etThread.boxGetShadowF( tinP , posti , costi , psttc1 ) ; ___( posti ) ;
        ZE( countT   , costi ) ;
        ZE( osTextT* , posti ) ;
        //etThread.traceF( tinP , psttc1 ) ;

        if( ether || POOP ) break ;

        //if( stNix >= 8 ) break ;
        cFound -- ;
    {
    FORsTRINGSiN1( pstt1Files )
    ZE( countT , idLine ) ;
    countT cFound = etThread.diskFindFileOrDirF( tinP , pstt1Files , T("///d/tmp/x/files.archive.*.ttt") ) ; ___( pstt1Files ) ;
    ZE( strokeS* , pstt1Files ) ;
{
stackC stNix( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_byteT ) ;
etThread.traceF( tinP , T("1: loading stNix") ) ;

TODO

}
    return - scSgn ;
    if( pEther && c3P ) ;

    scSgn = thirdC::c_strcmpIF( tinP , (byteT*)c1P , (byteT*)c2P ) ;
    ZE( sCountT , scSgn ) ;

    }
    {
    IFbEcAREFUL
{
countT subtractByteStringsReversedF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return bOk ;

    etherP.delF( tinP , psttHost ) ;
    }
        }
            if( POOP ) POOPR ;
            etScratch.boxPutF( tinP , T("///d/tmp/x/upload.reply.")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(".ttt") , postHear , costHear ) ;
            countT idIn = ++ idInLath ;
            static countT idInLath ;
        {
        if( bOk )

        }
            }
                etPrime.osSleepF( tinP , TOCK ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                etherP.traceF( tinP , T("will retry after napping for a tock") ) ;

                POOPR ;
            {
            else
            }
                break ;
                bOk = 1 ;
            {
            if( !POOP )

            __( !etherP.strIdF( tinP , T("HTTP/1.1 201 Created") , tHear ) ) ;

            //etScratch.traceF( tinP , T(postHear) ) ;
            TN( tHear , postHear ) ;

            costHear = ss.readF( tinP , postHear , sizeof postHear ) ;
            memset( postHear , 0 , sizeof postHear ) ;

            etherP.delF( tinP , pbBuffer ) ;
            }
                }
                    ss.writeF(           tinP , pbBuffer , cbNow      ) ;
                    etScratch.fileReadF( tinP , pbBuffer , cbNow , fi ) ;
        
                    cDoLo -= cbNow ;
                    if( cDoLo < cbNow ) cDoHi -- ;
        
                    if( !cDoHi && cbNow > cDoLo ) cbNow = cDoLo ;
                    countT cbNow = cbChunk ;
                {
                while( cDoHi || cDoLo )
        
                fileC fi( tinP , psttLongP , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO ) ;
                countT cDoHi = 0   ;
                countT cDoLo = cbP ;
            {
            if( pbBuffer )
        
            etherP.newF( tinP , LF , pbBuffer , cbChunk ) ; ___( pbBuffer ) ;
            ZE( byteT* , pbBuffer ) ;
        
            ;
                : cbP
                ? TOCK
            countT cbChunk = cbP > TOCK

            ss.writeF( tinP , (osTextT*)tSay , (countT)tSay.csF( tinP ) ) ;
            ss.connectF( tinP , 443 , socketC::nicNameIF( tinP , etScratch , T(psttHost) ) ) ;
            socketC ss( tinP , etScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL ) ;

            //}
            //    __1 ;
            //    bWoth = 0 ;
            //{
            //if( bWoth ) //U:: TO FIND A BUG

            SCOOPS
        {
        while( cTries -- && !etPrime && !POOP )
        countT cTries = TUCK >> 5 ;
        //boolT bWoth = 1 ; //U::TO FIND A BUG
        etherC& etScratch = *tinP.pEtScratch ;
        etherC& etPrime   = etherC::etPrimeIF( tinP ) ;
    {
    IFsCRATCH
    ZE( boolT , bOk ) ;
    ZE( countT , costHear ) ;
    char postHear[ TOCK ] ; 

    //etherP.traceF( tinP , tSay ) ;

    }
        etherP.delF( tinP , psttUrlEncoded ) ;
        etherP.delF( tinP , psttUrlPrefix ) ;
        tSay = T("PUT ")+T(psttUrlPrefix)+T("/archive/")+T(psttUrlEncoded)+T(" HTTP/1.1\r\nHost: ")+T(psttHost)+T("\r\nX-Auth-Token: ")+rAuthP.tAccessToken+T("\r\nContent-Length: ")+TF4(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;

        // 
        // [ ...object content... ]
        //  
        // Content-Length: 512000
        // X-Auth-Token: f064c46a782c444cb4ba4b6434288f7c
        // Host: storage.clouddrive.com
        // PUT /v1/MossoCloudFS_0672d7fa-9f85-4a81-a3ab-adb66a880123/archive/shortEncodedName HTTP/1.1
        // 
        // EXAMPLE

        etherP.strToUrlF( tinP , psttUrlEncoded , psttShortP ) ; ___( psttUrlEncoded ) ;
        ZE( strokeS* , psttUrlEncoded ) ;

        }
            }
                etherP.strSubstringF( tinP , psttUrlPrefix , idfUrlPrefix , idlUrlPrefix , rAuthP.tPublicUrl ) ; ___( psttUrlPrefix ) ;
                etherP.strSubstringF( tinP , psttHost      , idfHost      , idlHost      , rAuthP.tPublicUrl ) ; ___( psttHost      ) ;
                ZE( countT , idlUrlPrefix ) ;
                countT idlHost = idfUrlPrefix - 1 ;
                idfHost ++ ;
            {
            if( idfHost && idfUrlPrefix )
            countT idfUrlPrefix = etherP.strIdF( tinP , strokeS( '/' ) , rAuthP.tPublicUrl , 3 ) ;
            countT idfHost      = etherP.strIdF( tinP , strokeS( '/' ) , rAuthP.tPublicUrl , 2 ) ;
        {
        ZE( strokeS* , psttUrlPrefix ) ;
    {
    TN( tSay , "" ) ;
    ZE( strokeS* , psttHost  ) ;
{
boolT raxUploadWoFileF( tinS& tinP , etherC& etherP , const strokeS* const psttLongP , const strokeS* const psttShortP , const countT cbP , resultAuthS& rAuthP )

}
    }
        }
            wordF( tinP , *tinP.pEtScratch , prP , scratchAuth , stPath , tIn ) ;
            stackC stPath( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
            scratchAuthS scratchAuth( tinP ) ;
        {
        else
        if( POOP ) POOPR

        }
            }
                }
                    tIn = T(postJson) ;

                    }
                        }
                            case '}' : { if( !( -- idLevel ) ) bNix = 1 ; break ; }
                            case ']' :

                            case '{' : {        ++ idLevel              ; break ; }
                            case '[' :
                        {
                        switch( *postc )

                        }
                            break ;
                            *postc = 0 ;
                        {
                        if( bNix )
                    {
                    for( osTextT* postc = postJson ; *postc ; postc ++ )
                    ZE( boolT  , bNix ) ;
                    ZE( countT , idLevel ) ;
                {
                if( postJson )

                if( postJsonSq && postJsonSq < postJson ) postJson = postJsonSq ;
                osTextT* postJson   = thirdC::c_strstrIF( tinP , postBody , "{" ) ;
                osTextT* postJsonSq = thirdC::c_strstrIF( tinP , postBody , "[" ) ;
            {
            if( postBody )
            osTextT* postBody = thirdC::c_strstrIF( tinP , postHear , "\r\n\r\n" ) ;
        {
        TN( tIn , "" ) ; // WILL CONTAIN A SINGLE, TRIMMED JSON WORD

        countT cbIn = ss.readF( tinP , postHear , sizeof postHear ) ;
        memset( postHear , 0 , sizeof postHear ) ;
        char postHear[ TOCK ] ; 

        ss.writeF( tinP , (osTextT*)tSay , (countT)tSay.csF( tinP ) ) ;
        ss.connectF( tinP , 443 , socketC::nicNameIF( tinP , *tinP.pEtScratch , T("identity.api.rackspacecloud.com") ) ) ;
        socketC ss( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL ) ;

        SCOOPS
    {
    IFsCRATCH

    tSay += TF4(tSayBody.csF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tSayBody ;
    ) ;

        "Content-Length: "
        "Content-Type: application/json\r\n"
        "Accept: application/json\r\n"
        "Host: identity.api.rackspacecloud.com\r\n"
        "User-Agent: IPDOS (tm)\r\n"
        "POST /v2.0/tokens HTTP/1.1\r\n"

    TN( tSay , 

    ) ;

        "}\r\n"
        "   }\r\n"
        "      }\r\n"
        "\"\r\n"

    tSayBody += T(

    tSayBody += T(psttKeyP) ;

    ) ;

        "         \"apiKey\": \""
        "\",\r\n"

    tSayBody += T(

    tSayBody += T(psttUserP) ;

    ) ;

        "         \"username\": \""
        "      {\r\n"
        "      \"RAX-KSKEY:apiKeyCredentials\":\r\n"
        "   {\r\n"
        "   \"auth\":\r\n"
        "{\r\n"

    TN( tSayBody ,

    if( prP ) { BLAMMO ; }
{
voidT raxGetAuthF( tinS& tinP , etherC& etherP , resultAuthS*& prP , const strokeS* const psttUserP , const strokeS* const psttKeyP )

}
    }
        }
            //}
            //    etherP.traceF( tinP , T("[ids,idLevel]: ")+TF2(ids,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idLevel,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            //{
            //if( idLevelLag != idLevel )

            }
                }
                    }
                        ;
                            : 0
                            ? ids + 1
                        idPairWoth = ids + 1 < idWordLath

                        etherP.delF( tinP , psttPair ) ;
                        pairF( tinP , etherP , prP , sP , stPathP , psttPair ) ;
                        etherP.strTrimF( tinP , psttPair ) ; ___( psttPair ) ;
                        etherP.strSubstringF( tinP , psttPair , idPairWoth , idPairLath , psttP ) ; ___( psttPair ) ;
                        ZE( strokeS* , psttPair ) ;

                        countT idPairLath = ids - 1 ;
                    {
                    if( !idLevel || ( idLevel == 1 && ostc == ',' ) )
                {
                case ',' :

                case '}' : { -- idLevel ; } // INTENTIONAL FALLTHROUGH

                case '{' : { ++ idLevel ; break ; }

                case ']' : { -- idLevel ; break ; }

                case '[' : { ++ idLevel ; break ; }
            {
            switch( ostc )

            if( bIgnore ) continue ;

            }
                //}
                //    etherP.delF( tinP , psttIgnored ) ;
                //    etherP.traceF( tinP , T("ignored: ")+T(psttIgnored) ) ;
                //    etherP.strSubstringF( tinP , psttIgnored , idf , idl , psttP ) ; ___( psttIgnored ) ;
                //    ZE( strokeS* , psttIgnored ) ;
                //
                //    countT idl = ids ;
                //    countT idf = idsIgnoreWoth ;
                //{
                //else
                //if( bIgnore ) idsIgnoreWoth = ids ;

                bIgnore = !bIgnore ;
            {
            if( ostc == '"' )

            countT ostc = psttP[ CSpREFIX - 1 + ids ].idAdam ;
            idLevelLag = idLevel ;
        {
        for( countT ids = idWordWoth ; ids <= idWordLath ; ids ++ )
        ZE( countT , idsIgnoreWoth ) ;
        ZE( boolT , bIgnore ) ;
        countT idPairWoth = idWordWoth + 1 ;
        ZE( countT , idLevelLag ) ;
        ZE( countT , idLevel ) ;

        const countT idWordLath = psttP->idAdam ;
        const countT idWordWoth = 1 ;
    {
    if( psttP->idAdam > 2 )

    if( psttP[ CSpREFIX ].idAdam != '{' || psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != '}' ) { BLAMMO ; }
    //VERIFY THAT psttP BEGINS WITH '{' AND ENDS WITH '}'

    //
    // value := [ word , word , ... ]
    //
    // value := word
    // 
    // pair := key : value
    //
    // word := { pair , pair , ... }
    //
    // INPUT IS EXACTLY WO word
    // INPUT FORMAT SPECIFICATION
    // 
    // RECIPE
{
voidT wordF( tinS& tinP , etherC& etherP , resultAuthS*& prP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    }
        }
            idValueWoth = 0 ;
            etherP.delF( tinP , psttValue ) ;
            valueF( tinP , etherP , prP , sP , stPathP , psttValue ) ;
            etherP.strTrimF( tinP , psttValue ) ; ___( psttValue ) ;
            etherP.strSubstringF( tinP , psttValue , idValueWoth , idValueLath , psttP ) ; ___( psttValue ) ;
            ZE( countT , idValueLath ) ;
            ZE( strokeS* , psttValue ) ;
        {
        if( !idLevel && idValueWoth )

        }
            }
                }
                    break ;

                    }
                        ;
                            : 0
                            ? ids + 1
                        idValueWoth = ids + 1 <= idPairLath

                        idKeyWoth = 0 ;
                        etherP.delF( tinP , psttKey ) ;
                        keyF( tinP , etherP , prP , sP , stPathP , psttKey ) ;
                        etherP.strTrimF( tinP , psttKey ) ; ___( psttKey ) ;
                        etherP.strSubstringF( tinP , psttKey , idKeyWoth , idKeyLath , psttP ) ; ___( psttKey ) ;
                        ZE( strokeS* , psttKey ) ;

                        countT idKeyLath = ids - 1 ;
                    {
                    if( !idLevel && idKeyWoth )
                {
                case ':' :

                case '}' : { -- idLevel ; break ; }
                case ']' :

                case '{' : { ++ idLevel ; break ; }
                case '[' :
            {
            switch( ostc )

            if( bIgnore ) continue ;
            if( ostc == '"' ) bIgnore = !bIgnore ;

            countT ostc = psttP[ CSpREFIX - 1 + ids ].idAdam ;
        {
        for( countT ids = idPairWoth ; ids <= idPairLath ; ids ++ )
        ZE( countT , idsIgnoreWoth ) ;
        ZE( boolT  , bIgnore ) ;
        ZE( countT , idValueWoth ) ;
        countT idKeyWoth = idPairWoth ;
        ZE( countT , idLevel ) ;

        const countT idPairLath = psttP->idAdam ;
        const countT idPairWoth = 1 ;
    {
    if( psttP->idAdam > 2 )

    //
    // value := [ word , word , ... ]
    //
    // value := word
    // 
    // pair := key : value
    //
    // INPUT IS EXACTLY WO word
    // INPUT FORMAT SPECIFICATION
    // 
    // RECIPE

    //etherP.traceF( tinP , T("[pair]: ")+T(psttP) ) ;
{
voidT pairF( tinS& tinP , etherC& etherP , resultAuthS*& prP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    }
        etherP.delF( tinP , psttKey ) ;
        stPathP >> psttKey ;
        ZE( strokeS* , psttKey ) ;
    {
    if( stPathP )

    }
        }
            break ;
            wordF( tinP , etherP , prP , sP , stPathP , psttP ) ;
            if( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != '}' ) { BLAMMO ; }
        {
        case '{' :
        }
            break ;
            etherP.delF( tinP , psttList ) ;
            listF( tinP , etherP , prP , sP , stPathP , psttList ) ;
            etherP.strSubstringF( tinP , psttList , idf , idl , psttP ) ; ___( psttList ) ;
            countT idl = psttP->idAdam - 1 ;
            countT idf = 2 ;
            ZE( strokeS* , psttList ) ;

            if( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != ']' ) { BLAMMO ; }
        {
        case '[' :
    {
    if( psttP->idAdam ) switch( psttP[ CSpREFIX ].idAdam )

    }
        }
            }
                etherP.delF( tinP , psttw ) ;
                prP->tTenantId = T(psttw) ;
                strFromJsonF( tinP , etherP , psttw , sP.tMaybeTenantId ) ; ___( psttw ) ;

                etherP.delF( tinP , psttw ) ;
                prP->tPublicUrl = T(psttw) ;
                strFromJsonF( tinP , etherP , psttw , sP.tMaybePublicUrl ) ; ___( psttw ) ;
                ZE( strokeS* , psttw ) ;

                if( !prP ) { prP = new( 0 , tinP , LF ) resultAuthS( tinP ) ; ___( prP ) ; }
            {
            if( !etherP.strCompareF( tinP , psttP , T("\"object-store\"") ) )
        {
        else if( !etherP.strCompareF( tinP , tPath , tWantObjectStore ) )
        }
            }
                sP.tMaybeTenantId = T(psttP) ;
            {
            if( F(sP.flags) & flME_MYrEGION )
        {
        else if( !etherP.strCompareF( tinP , tPath , tWantTenantId ) )
        }
            }
                sP.tMaybePublicUrl = T(psttP) ;
            {
            if( F(sP.flags) & flME_MYrEGION )
        {
        else if( !etherP.strCompareF( tinP , tPath , tWantPublicURL ) )
        }
            else                                                        sP.flags &= ~( flME_MYrEGION ) ;
            if( !etherP.strCompareF( tinP , T(psttP) , T("\"IAD\"") ) ) sP.flags |=    flME_MYrEGION   ;
        {
        else if( !etherP.strCompareF( tinP , tPath , tWantRegion ) )
        }
            etherP.delF( tinP , psttw ) ;
            prP->tAccessToken = T(psttw) ;
            strFromJsonF( tinP , etherP , psttw , psttP ) ; ___( psttw ) ;
            ZE( strokeS* , psttw ) ;

            if( !prP ) { prP = new( 0 , tinP , LF ) resultAuthS( tinP ) ; ___( prP ) ; }
        {
        if( !etherP.strCompareF( tinP , tPath , tWantToken ) )

        //etherP.traceF( tinP , tPath ) ;

        TN( tWantObjectStore , "\"access\"/\"serviceCatalog\"/\"type\"/" ) ;
        TN( tWantPublicURL   , "\"access\"/\"serviceCatalog\"/\"endpoints\"/\"publicURL\"/" ) ;
        TN( tWantTenantId    , "\"access\"/\"serviceCatalog\"/\"endpoints\"/\"tenantId\"/"  ) ;
        TN( tWantRegion      , "\"access\"/\"serviceCatalog\"/\"endpoints\"/\"region\"/"    ) ;
        TN( tWantToken       , "\"access\"/\"token\"/\"id\"/"                               ) ;
    {

    // "access"/"token"/"id"/    --------    "995e991606cc43dbaddfaaed82b8aa4f"
    //
    //
    // THESE ARE THE VALUES THAT I WANT (PATH    --------    SAMPLEVALUE

    }
        while( ~hWalk ) ;
        do tPath += T((strokeS*)stPathP.upF(tinP,hWalk))+T("/") ;
    {
    if( stPathP )
    TN( tPath , "" ) ;
    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
{
voidT valueF( tinS& tinP , etherC& etherP , resultAuthS*& prP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    stPathP << psttw ;
    etherP.strMakeF( tinP , psttw , psttP ) ; ___( psttw ) ;
    ZE( strokeS* , psttw ) ;

    //etherP.traceF( tinP , T("[key]: ")+T(psttP) ) ;
{
voidT keyF( tinS& tinP , etherC& etherP , resultAuthS*& prP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    }
        }
            etherP.delF( tinP , psttItem ) ;
            itemF( tinP , etherP , prP , sP , stPathP , psttItem ) ;
            etherP.strTrimF( tinP , psttItem ) ; ___( psttItem ) ;
            etherP.strSubstringF( tinP , psttItem , idItemWoth , idItemLath , psttP ) ; ___( psttItem ) ;
            ZE( countT , idItemLath ) ;
            ZE( strokeS* , psttItem ) ;
        {
        if( idItemWoth )

        }
            }
                }
                    break ;

                    }
                        ;
                            : 0
                            ? ids + 1
                        idItemWoth = ids + 1 <= idListLath

                        etherP.delF( tinP , psttItem ) ;
                        itemF( tinP , etherP , prP , sP , stPathP , psttItem ) ;
                        etherP.strTrimF( tinP , psttItem ) ; ___( psttItem ) ;
                        etherP.strSubstringF( tinP , psttItem , idItemWoth , idItemLath , psttP ) ; ___( psttItem ) ;
                        ZE( strokeS* , psttItem ) ;

                        countT idItemLath = ids - 1 ;
                    {
                    if( !idLevel )
                {
                case ',' :

                case '}' : { -- idLevel ; break ; }
                case ']' :

                case '{' : { ++ idLevel ; break ; }
                case '[' :
            {
            switch( ostc )

            if( bIgnore ) continue ;
            if( ostc == '"' ) bIgnore = !bIgnore ;

            countT ostc = psttP[ CSpREFIX - 1 + ids ].idAdam ;
        {
        for( countT ids = idListWoth ; ids <= idListLath ; ids ++ )
        ZE( countT , idsIgnoreWoth ) ;
        ZE( boolT  , bIgnore ) ;
        countT idItemWoth = idListWoth ;
        ZE( countT , idLevel ) ;

        const countT idListLath = psttP->idAdam ;
        const countT idListWoth = 1 ;
    {
    if( psttP->idAdam > 2 )

    //etherP.traceF( tinP , T("[list]: ")+T(psttP) ) ;
{
voidT listF( tinS& tinP , etherC& etherP , resultAuthS*& prP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    }
        }
            }
                break ;
                wordF( tinP , etherP , prP , sP , stPathP , psttP ) ;
                if( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != '}' ) { BLAMMO ; }
            {
            case '{' :
            }
                break ;
                etherP.delF( tinP , psttList ) ;
                listF( tinP , etherP , prP , sP , stPathP , psttList ) ;
                etherP.strSubstringF( tinP , psttList , idf , idl , psttP ) ; ___( psttList ) ;
                countT idl = psttP->idAdam - 1 ;
                countT idf = 2 ;
                ZE( strokeS* , psttList ) ;

                if( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != ']' ) { BLAMMO ; }
            {
            case '[' :
        {
        switch( psttP[ CSpREFIX ].idAdam )
    {
    if( psttP->idAdam )

    //etherP.traceF( tinP , T("[item]: ")+T(psttP) ) ;
{
voidT itemF( tinS& tinP , etherC& etherP , resultAuthS*& prP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    etherP.strReplaceF( tinP , psttP , 0 , T("\\/") , T("/") ) ; ___( psttP ) ;
    etherP.strTrimF(    tinP , psttP , psttFromP , 0 , T("\"") ) ; ___( psttP ) ;
{
voidT strFromJsonF( tinS& tinP , etherC& etherP , strokeS*& psttP , const strokeS* const psttFromP )

voidT wordF( tinS& tinP , etherC& etherP , resultAuthS*& prP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP ) ;
voidT listF( tinS& tinP , etherC& etherP , resultAuthS*& prP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP ) ;

}
{
tTenantId( tinP , TAG( TAGiDnULL ) )
tPublicUrl( tinP , TAG( TAGiDnULL ) ) ,
tAccessToken( tinP , TAG( TAGiDnULL ) ) ,
resultAuthS::resultAuthS( tinS& tinP ) :

NEWdELcLASS( 1 , resultAuthS )

}
{
tMaybeTenantId( tinP , TAG( TAGiDnULL ) )
tMaybePublicUrl( tinP , TAG( TAGiDnULL ) ) ,
flags( flME_null ) ,
scratchAuthS::scratchAuthS( tinS& tinP ) :

;
}
    resultAuthS( tinS& tinP ) ;
    NEWdELcLASSpROTOS

    textC   tTenantId ;
    textC   tPublicUrl ;
    textC   tAccessToken ;
{
struct resultAuthS

;
}
    scratchAuthS( tinS& tinP ) ;

    textC   tMaybeTenantId ;
    textC   tMaybePublicUrl ;
    flagsT  flags ;
{
struct scratchAuthS

#define flME_MYrEGION    0xe00001ff
#define flME_null        0xe00000ff

/*1*/WAKEsHOWtEXT( "tool.upload.to.cloud" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

