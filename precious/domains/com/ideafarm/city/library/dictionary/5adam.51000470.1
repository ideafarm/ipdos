
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.osSleepF( tinP , TOCK ) ;
etThread.strokeF( tinP , T("ok\r\n") ) ;
etThread.strokeF( tinP , T("just returned from destructor\r\n") ) ;
}
    etThread.osSleepF( tinP , TOCK ) ;
    etThread.strokeF( tinP , T("about to call destructor in 1 tock\r\n") ) ;
    etThread.loafIF( tinP ) ;
    etThread.strokeF( tinP , T("news has been constructed\r\n") ) ;
    newsC news( tinP , etThread ) ;
{

TODO

}
    ether.osThreadF( tinP , countTC() , tmVolunteerAsSingularityF  , &sgnDone_tmVolunteerAsSingularityF  , flTHREADlAUNCH_null , 0 , (countT)&bFired ) ;

    }
        if( ether ) return ;
    {
    IFbEcAREFUL
{
sgnDone_tmVolunteerAsSingularityF( tinP , TAG( TAGiDnULL ) )
bFired( 0 ) ,
ether( etherP ) ,
/*1*/newsC::newsC( tinS& tinP , etherC& etherP ) :/*1*/
/**/
*/
/*

}
    sgnDone_tmVolunteerAsSingularityF.waitF( tinP ) ;
    bFired = 1 ;
    TINSL
{
/*1*/newsC::~newsC( voidT )/*1*/
/**/
*/
/*

DONE( tmVolunteerAsSingularityF )
}
    etThread.ifcJobF( tinP , stCourses , 0x4010452 , sOrderPrimary , stOrders , T("newsC: volunteer to be the singularity at ")+TT(timeN1,timeN2) ) ;
    etThread.osThreadF( tinP , countTC() , tmChatAsVolunteerF , 0 , flTHREADlAUNCH_null , 0 , (countT)&bFired , (countT)&stOrders , (countT)&stCourses ) ;
    
    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT , timeN1 ) ;
    
    sOrderPrimary << etThread.sockNicNameF( tinP ) ;
    sOrderPrimary << (strokeS*)T("!iWillBeSingularity") ;
    sOrderPrimary << (countT)ifcIDcMDjOBoRDER_NAMED ;
    
    boolT& bFired = *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
soulC sOrderPrimary( tinP , TAG( TAGiDnULL ) ) ;
stackC stOrders(  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
stackC stCourses( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
TASK( tmVolunteerAsSingularityF )

DONE( tmChatAsVolunteerF )
}
    }
        }
            DEL( psCourse ) ;
            }
                }
                    stOrders.ungrabF( tinP ) ;
                    etThread.strokeF( tinP , T("stOrders contains ")+TF1(stOrders)+T(" plates after pushing\r\n") ) ;
                    stOrders << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                    stOrders << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) , flSOUL_null , (countT)1 ) ; //U: THE ORDER NEEDS TO CONTAIN SOMETHING SO THAT IT WILL REACH 2540104
                    stOrders.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( bOrderNull )

                }
                    etThread.strokeF( tinP , T("stOrders contains ")+TF1(stOrders)+T(" plates; data received: ")+TF1(vv)+T("\r\n") ) ;
                    sData >> vv ;
                    ZE( countT , vv ) ;
                {
                else
                }
                    if( !sData ) etThread.strokeF( tinP , T("my volunteer was rejected\r\n") ) ;
                    bOrderNull = 1 ;
                {
                if( !sData || bFired )

                etThread.strokeF( tinP , T("unstacked an sData containing ")+TF1(sData)+T(" items\r\n") ) ;
        
                *psCourse >> sNotesData ;
                *psCourse >> sNotesText ;
                *psCourse >> sData ;
                *psCourse >> sCodes ;
                soulC sNotesData( tinP , TAG( TAGiDnULL ) ) ;
                soulC sNotesText( tinP , TAG( TAGiDnULL ) ) ;
                soulC sData( tinP , TAG( TAGiDnULL ) ) ;
                soulC sCodes( tinP , TAG( TAGiDnULL ) ) ;
            {
            if( psCourse )
            stCourses >> psCourse ;
            ZE( soulC* , psCourse ) ;
        {
        while( stCourses && !bOrderNull )
        stCourses.waitF( tinP ) ;
    {
    while( !etThread && !bOrderNull )
    ZE( boolT , bOrderNull ) ;

    stackC& stCourses = *(stackC*)pTaskP->c3 ;
    stackC& stOrders  = *(stackC*)pTaskP->c2 ;
    boolT&  bFired    =  *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmChatAsVolunteerF )

;
}
    newsC( tinS& tinP , etherC& etherP ) ;
    ~newsC( voidT ) ;

    public :

    boolT               bFired ;
    signC               sgnDone_tmVolunteerAsSingularityF ;
    etherC&             ether ;
{
/*1*/class __export newsC/*1*/
/**/
*/
/*

/*1*/WAKEhIDE( "doodle.newsC" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

