
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

}
    ether.loafIF( tinP ) ;

    etThread.osThreadF( TaRG1( tmLookF ) , (countT)&lever_idThread , (countT)&swsGot ) ;

    while( cToDo -- ) etThread.osThreadF( TaRG1( tmReadF ) , (countT)&qh , (countT)&lever_idThread , (countT)&swsGot ) ;
    cToDo = 0x10 ;
    switchStackC swsGot( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever_idThread , flSTACKc_DOnOTsERIALIZE|flSTACKc_ALLOWmULTIPLEuNSERIALIZED ) ;
    ZE( countT , lever_idThread ) ;

    while( cToDo -- ) etThread.osThreadF( TaRG1( tmWriteF ) , (countT)&qh ) ;
    countT cToDo = 0x10 ;
    queueHeaderOldC& qh = *(queueHeaderOldC*)(byteT*)napQueue ;

    }
        }
            __( cbQueue - CBqUEUE ) ;
            cbQueue = cbNapkin - sizeof( queueHeaderOldC ) ;
            pbQueue = pbNapkin + sizeof( queueHeaderOldC ) ;
        {
        if( pbNapkin && cbNapkin > sizeof( queueHeaderOldC ) )
        }
            napQueue.formattingIsDoneF( tinP ) ;
            new( 0 , tinP , pbNapkin , sizeof( queueHeaderOldC ) ) queueHeaderOldC( tinP , CBqUEUE ) ;
        {
        if( pbNapkin && !napQueue.bFormattedF() )
        countT cbNapkin = napQueue ;
        byteT* pbNapkin = napQueue ;
    {
    ZE( countT , cbQueue ) ;
    ZE( byteT* , pbQueue ) ;
    napkinC napQueue( tinP , TAG( TAGiDnULL ) , "napQueuePlaycraft" , 0 , sizeof( queueHeaderOldC ) + CBqUEUE ) ;
{

TODO

DONE( tmLookF )
}
    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;

        swsGotP.ungrabF( tinP ) ;
        }
            }
                //CONoUTrAW( "." ) ;
                swsGotP >> swLath ;
                swLath = 0 ;
            {
            while( swsGotP && swsGotP[ 1 ] - 1 == swLath )

            }
                CONoUTrAW3( "cPlatesMax: " , cPlatesMax , "\r\n" )
                cPlatesMax = swsGotP ;
            {
            if( cPlatesMax < swsGotP )

            lever_idThreadP = swsGotP.leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swsGotP.cFlavorsF( tinP ) ;
        swsGotP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    while( !ether )
    ZE( countT , cPlatesMax ) ;

    switchC swLath( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , lever_idThreadP ) ;

    switchStackC& swsGotP         = *(switchStackC*)pTaskP->c2 ;
    countT&       lever_idThreadP =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmLookF )

DONE( tmReadF )
}
    }
        swsGotP.ungrabF( tinP ) ;
        swsGotP.sinkF( tinP , countTC() , pc3[ 1 ] , flSTACKsINK_UNIQUE ) ;
        lever_idThreadP = pc3[ 0 ] ;
        swsGotP.grabF( tinP , TAG( TAGiDnULL ) ) ;

        if( !( pc3[ 1 ] % TOCK ) ) { CONoUTrAW( T("received: ")+TF2(pc3[0],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" ")+TF2(pc3[1],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ; }
        qhP.readF( tinP , (byteT*)pc3 , sizeof pc3 ) ;
        countT pc3[ 3 ] ;
    {
    while( !ether )

    switchStackC& swsGotP         = *(switchStackC*)pTaskP->c3 ;
    countT&       lever_idThreadP =       *(countT*)pTaskP->c2 ;
    queueHeaderOldC& qhP             = *(queueHeaderOldC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmReadF )

#define CBqUEUE ( TUCK  )

DONE( tmWriteF )
}
    }
        OSsLEEPf( 0 ) ; //BASE DOES NOT SUPPORT YIELDING LIKE THIS
        qhP.writeF( tinP , (byteT*)pc3 , sizeof pc3 ) ;

        countT pc3[] = { tinP.monitor.idThread , ++ idCycle , 1/*TO CAUSE WRAP*/ } ;
    {
    while( !ether )
    ZE( countT , idCycle ) ;

    queueHeaderOldC& qhP = *(queueHeaderOldC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmWriteF )

*/
/*

/*1*/WAKEsHOWtEXT( "gorilla.snip.003014f.queueHeaderOldC" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

