
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        __( rc - MMSYSERR_NOERROR ) ;
        }
            case WAVERR_STILLPLAYING  : { CONoUTrAW( "waveOutClose returned WAVERR_STILLPLAYING \r\n" ) ; break ; }
            case MMSYSERR_NOMEM       : { CONoUTrAW( "waveOutClose returned MMSYSERR_NOMEM      \r\n" ) ; break ; }
            case MMSYSERR_NODRIVER    : { CONoUTrAW( "waveOutClose returned MMSYSERR_NODRIVER   \r\n" ) ; break ; }
            case MMSYSERR_INVALHANDLE : { CONoUTrAW( "waveOutClose returned MMSYSERR_INVALHANDLE\r\n" ) ; break ; }
        {
        switch( rc )
        rc = tinP.brcRaw ;
        BOSdOnOTtEST( WHATgbo , waveOutClose( hwo ) )

        }
            __( rc - MMSYSERR_NOERROR ) ;
            }
                case WAVERR_STILLPLAYING  : { CONoUTrAW( "waveOutUnprepareHeader returned WAVERR_STILLPLAYING \r\n" ) ; break ; }
                case MMSYSERR_NOMEM       : { CONoUTrAW( "waveOutUnprepareHeader returned MMSYSERR_NOMEM      \r\n" ) ; break ; }
                case MMSYSERR_NODRIVER    : { CONoUTrAW( "waveOutUnprepareHeader returned MMSYSERR_NODRIVER   \r\n" ) ; break ; }
                case MMSYSERR_INVALHANDLE : { CONoUTrAW( "waveOutUnprepareHeader returned MMSYSERR_INVALHANDLE\r\n" ) ; break ; }
            {
            switch( rc )
            rc = tinP.brcRaw ;
            BOSdOnOTtEST( WHATgbo , waveOutUnprepareHeader( hwo , &hdr , sizeof hdr ) )

            }
                ++ s ; ether.osSleepF( tinP , TOCK * 3 ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {

            __( rc - MMSYSERR_NOERROR ) ;
            }
                case WAVERR_UNPREPARED    : { CONoUTrAW( "waveOutWrite returned WAVERR_UNPREPARED   \r\n" ) ; break ; }
                case MMSYSERR_NOMEM       : { CONoUTrAW( "waveOutWrite returned MMSYSERR_NOMEM      \r\n" ) ; break ; }
                case MMSYSERR_NODRIVER    : { CONoUTrAW( "waveOutWrite returned MMSYSERR_NODRIVER   \r\n" ) ; break ; }
                case MMSYSERR_INVALHANDLE : { CONoUTrAW( "waveOutWrite returned MMSYSERR_INVALHANDLE\r\n" ) ; break ; }
            {
            switch( rc )
            rc = tinP.brcRaw ;
            BOSdOnOTtEST( WHATgbo , waveOutWrite( hwo , &hdr , sizeof hdr ) )
    
            __( rc - MMSYSERR_NOERROR ) ;
            }
                case MMSYSERR_NOMEM       : { CONoUTrAW( "waveOutPrepareHeader returned MMSYSERR_NOMEM      \r\n" ) ; break ; }
                case MMSYSERR_NODRIVER    : { CONoUTrAW( "waveOutPrepareHeader returned MMSYSERR_NODRIVER   \r\n" ) ; break ; }
                case MMSYSERR_INVALHANDLE : { CONoUTrAW( "waveOutPrepareHeader returned MMSYSERR_INVALHANDLE\r\n" ) ; break ; }
            {
            switch( rc )
            rc = tinP.brcRaw ;
            BOSdOnOTtEST( WHATgbo , waveOutPrepareHeader( hwo , &hdr , sizeof hdr ) )

            setWaveF( pbData , sizeof pbData , mFreq * TUCK ) ;

            etThread.strokeF( tinP , T("note: ")+TF1(idNote)+T("    ")+T("freq: ")+T(mFreq)+T("\r\n") ) ;
        {
        for( measureT mFreq = 1.0 ; ++ idNote <= 0x11 ; mFreq += mStep )
        ZE( countT , idNote ) ;
        const measureT mStep = 1.0 / 16.0 ;

        hdr.reserved = 0 ;
        hdr.lpNext = 0 ;
        hdr.dwLoops = 0 ;
        hdr.dwFlags = 0 ;
        hdr.dwUser = 0 ;
        hdr.dwBytesRecorded = 0 ;
        hdr.dwBufferLength = sizeof pbData ;
        hdr.lpData = pbData ;
        WAVEHDR hdr ;

        byteT pbData[ CsAMPLESpERbLOCK ] ;
    {
    if( !etThread )

    __( rc - MMSYSERR_NOERROR ) ;
    }
        case WAVERR_SYNC          : { CONoUTrAW( "waveOutOpen returned WAVERR_SYNC         \r\n" ) ; break ; }
        case WAVERR_BADFORMAT     : { CONoUTrAW( "waveOutOpen returned WAVERR_BADFORMAT    \r\n" ) ; break ; }
        case MMSYSERR_NOMEM       : { CONoUTrAW( "waveOutOpen returned MMSYSERR_NOMEM      \r\n" ) ; break ; }
        case MMSYSERR_NODRIVER    : { CONoUTrAW( "waveOutOpen returned MMSYSERR_NODRIVER   \r\n" ) ; break ; }
        case MMSYSERR_BADDEVICEID : { CONoUTrAW( "waveOutOpen returned MMSYSERR_BADDEVICEID\r\n" ) ; break ; }
        case MMSYSERR_ALLOCATED   : { CONoUTrAW( "waveOutOpen returned MMSYSERR_ALLOCATED  \r\n" ) ; break ; }
    {
    switch( rc )
    MMRESULT rc = tinP.brcRaw ;
    BOSdOnOTtEST( WHATgbo , waveOutOpen( &hwo , 0 , &format , 0 , 0 , WAVE_ALLOWSYNC ) )

    format.cbSize = 0 ;
    format.wBitsPerSample = 8 ;
    format.nBlockAlign = 1 ;
    format.nAvgBytesPerSec = CsAMPLESpERbLOCK * CbLOCKSpERtOCK * mTockPerSec ;
    format.nSamplesPerSec = CsAMPLESpERbLOCK * CbLOCKSpERtOCK * mTockPerSec ;
    format.nChannels = 1 ;
    format.wFormatTag = WAVE_FORMAT_PCM ;
    WAVEFORMATEX format ;
    ZE( HWAVEOUT , hwo ) ;
{
if( cDevices )
CONoUTrAW3( "cDevices: " , cDevices , "\r\n" ) ;
countT cDevices = tinP.brcRaw ;
BOSdOnOTtEST( WHATgbo , waveOutGetNumDevs() )

const measureT mTockPerSec = (measureT)timePS1 / (measureT)TOCK ;
thirdC::timeFromSecondsIF( tinP , timePS1 , timePS2 , 1 ) ;
ZE( sCountT , timePS2 ) ;
ZE( countT , timePS1 ) ;

TODO

}
    }
        pbDataP[ off ] = (byteT)( 0x7f * ( 1.0 + thirdC::mathCosIF( tinP , mOsAngle ) ) ) ;
        measureT mOsAngle = osAngleF( (measureT)off / mSamplesPerCycle ) ;
    {
    for( countT off = 0 ; off < cbDataP ; off ++ )
    measureT mSamplesPerCycle = cbDataP / ( mCyclesPerTockP / mBlocksPerTockP ) ;
{
voidT setWaveF( byteT* pbDataP , const countT cbDataP , const measureT mCyclesPerTockP = TUCK , const measureT mBlocksPerTockP = 1.0 )

#define CbLOCKSpERtOCK 0x1
#define CsAMPLESpERbLOCK TOCK

/*1*/WAKEhIDE( "doodle.audio.organ.tone" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

