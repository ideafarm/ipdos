
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            DEL( psPayload ) ;
            stRelayOutP >> *(countT*)&psPayload ;
            ZE( soulC* , psPayload ) ;
        {
        while( stRelayOutP )
    
        }
            if( POOP ) POOPR

            }
                sgnDone_tmRelayBlowTeatF.waitF( tinP ) ;
                }
                    if( psNull ) stRelayOutP << *(countT*)&psNull ;
                    __Z( psNull ) ;
                    soulC* psNull = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                {
                bQuitWoConnect = 1 ;
    
                }
                    DEL( psWrap ) ;

                    }
                        b_pCioGetFP.ungrabF( tinP ) ;
                        }
                            }
                                DEL( psGift ) ; //CALLBACK WILL NORMALLY ZE THIS AND BE RESPONSIBLE FOR DELETION
                                }
                                    if( POOP ) POOPR
                                    (*pCioGetFP)( tinP , *tinP.pEtScratch , bQuitP , ifcIDtYPEgIFT_REPLYrELAYiDpORTtIMEcaLLhOMES , psGift , pczChannelCopy , pcArgP ? *pcArgP : ze , idptNU ) ;
                                    ZE( countT* , pczChannelCopy ) ;
                                {
                                if( pCioGetFP )
        
                                psGift->shiftLeftF( tinP , 0 , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                                const byteT* pbsGift = psWrap->pbFieldF( tinP , idtsGift , flsGift , cbsGift , ifcIDfIELDwRAP_PORTtIMEaLLhOMES ) ;
                                ZE( countT , cbsGift ) ;
                                ZE( flagsT , flsGift ) ;
                                ZE( countT , idtsGift ) ;
                            {
                            if( psGift )
                            soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( pCioGetFP )
                        b_pCioGetFP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    else if( idType == ifcIDtYPEwRAP_REPLYrELAYiDpORTtIMEcaLLhOMES )
                    }
                        b_pCioGetFP.ungrabF( tinP ) ;
                        }
                            }
                                DEL( psGift ) ; //CALLBACK WILL NORMALLY ZE THIS AND BE RESPONSIBLE FOR DELETION
                                }
                                    if( POOP ) POOPR
                                    (*pCioGetFP)( tinP , *tinP.pEtScratch , bQuitP , ifcIDtYPEgIFT_REPLYrELAYiDpORTtIMEc , psGift , pczChannelCopy , pcArgP ? *pcArgP : ze , idptNU ) ;
                                    ZE( countT* , pczChannelCopy ) ;
                                {
                                if( pCioGetFP )
        
                                psGift->shiftLeftF( tinP , 0 , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                                const byteT* pbsGift = psWrap->pbFieldF( tinP , idtsGift , flsGift , cbsGift , ifcIDfIELDwRAP_PORTtIME ) ;
                                ZE( countT , cbsGift ) ;
                                ZE( flagsT , flsGift ) ;
                                ZE( countT , idtsGift ) ;
                            {
                            if( psGift )
                            soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( pCioGetFP )
                        b_pCioGetFP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    else if( idType == ifcIDtYPEwRAP_REPLYrELAYiDpORTtIMEc )
                    }
                        b_pCioGetFP.ungrabF( tinP ) ;
                        }
                            }
                                DEL( psGift ) ; //CALLBACK WILL NORMALLY ZE THIS AND BE RESPONSIBLE FOR DELETION
                                }
                                    if( POOP ) POOPR
                                    (*pCioGetFP)( tinP , *tinP.pEtScratch , bQuitP , ifcIDtYPEgIFT_REPLYrELAYrANK , psGift , pczChannelCopy , pcArgP ? *pcArgP : ze , idptNU ) ;
                                    ZE( countT* , pczChannelCopy ) ;
                                {
                                if( pCioGetFP )
        
                                psGift->shiftLeftF( tinP , 0 , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                                const byteT* pbsGift = psWrap->pbFieldF( tinP , idtsGift , flsGift , cbsGift , ifcIDfIELDwRAP_RELAYrANK ) ;
                                ZE( countT , cbsGift ) ;
                                ZE( flagsT , flsGift ) ;
                                ZE( countT , idtsGift ) ;
                            {
                            if( psGift )
                            soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        if( pCioGetFP )
                        b_pCioGetFP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    else if( idType == ifcIDtYPEwRAP_REPLYrELAYrANK )
                    //U::CONJ: THE NEXT SNIPPETS ARE PSEUDOIDENTICAL; COMBINE THEM
                    }
                        delF( tinP , pczChannelCopy ) ; //CALLBACK MIGHT ZE THIS OUT AND BE RESPONSIBLE FOR DELETION
                        }
                            b_pCioGetFP.ungrabF( tinP ) ;
                            }
                                }
                                    DEL( psGift ) ; //CALLBACK WILL NORMALLY ZE THIS AND BE RESPONSIBLE FOR DELETION
                                    }
                                        if( POOP ) POOPR
                                        (*pCioGetFP)( tinP , *tinP.pEtScratch , bQuitP , ifcIDtYPEgIFT_APPLICATION , psGift , pczChannelCopy , pcArgP ? *pcArgP : ze , idptOrigin ) ;
                                    {
                                    if( pCioGetFP )
            
                                    psGift->shiftLeftF( tinP , 0 , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                                {
                                if( psGift )
                                soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                            {
                            if( pCioGetFP )
                            b_pCioGetFP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            
                            const byteT* pbsGift = psWrap->pbFieldF( tinP , idtsGift , flsGift , cbsGift , ifcIDfIELDwRAP_GIFT ) ;
                            ZE( countT , cbsGift ) ;
                            ZE( flagsT , flsGift ) ;
                            ZE( countT , idtsGift ) ;
                        {
                        else
                        }
                            b_pCioGetFP.ungrabF( tinP ) ;
                            }
                                if( POOP ) POOPR
                                (*pCioGetFP)( tinP , *tinP.pEtScratch , bQuitP , ifcIDtYPEgIFT_MEDIATE , psWrap , pczChannelCopy , pcArgP ? *pcArgP : ze , idptOrigin ) ; //CALLBACK WILL NORMALLY psWrap AND BE RESPONSIBLE FOR DELETION
                            {
                            if( pCioGetFP )
                            b_pCioGetFP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        
                            flags |= flCIOpUT_IGNOREmEDIATORlIST ;
                        {
                        if( bMediate )
        
                        boolT bMediate = !( F(flags) & flCIOpUT_IGNOREmEDIATORlIST ) && psToM ;
        
                        idPortTimeC idptOrigin = idPortTimeC::fieldF( tinP , *psWrap , ifcIDfIELDwRAP_IDPToRIGIN ) ;
        
                        flagsT& flags = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_FLAGS ) ;

                        //if( psToM ) { CONoUTrAW( "got wrap with sToM values from tit\r\n" ) ; }

                        }
                            if( psToM && !*psToM ) (*this)( tinP , psToM ) ;
                            }
                                if( psToM ) psToM->shiftLeftF( tinP , 0 , pbsToM , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                                (*this)( tinP , psToM , TAG( TAGiDnULL ) ) ;
                            {
                            if( pbsToM )
                            const byteT* pbsToM = psWrap->pbFieldF( tinP , idtToM , flToM , cbToM , ifcIDfIELDwRAP_TOmEDIATOR ) ;
                            ZE( countT , cbToM ) ;
                            ZE( flagsT , flToM ) ;
                            ZE( countT , idtToM ) ;
                        {
                        ZE( soulC* , psToM ) ;

                        //if( psTo ) { CONoUTrAW( "got wrap with sTo values from tit\r\n" ) ; }
        
                        }
                            if( psTo && !*psTo ) (*this)( tinP , psTo ) ;
                            }
                                if( psTo ) psTo->shiftLeftF( tinP , 0 , pbsTo , 0 , flSOULiTEM_null , flSOULsHIFTlEFT_UNPACKsOULiMAGE ) ;
                                (*this)( tinP , psTo , TAG( TAGiDnULL ) ) ;
                            {
                            if( pbsTo )
                            const byteT* pbsTo = psWrap->pbFieldF( tinP , idtTo , flTo , cbTo , ifcIDfIELDwRAP_TO ) ;
                            ZE( countT , cbTo ) ;
                            ZE( flagsT , flTo ) ;
                            ZE( countT , idtTo ) ;
                        {
                        ZE( soulC* , psTo ) ;

                        memCopyF( tinP , (byteT*)pczChannelCopy , (byteT*)pczChannel , cca * sizeof( countT ) ) ;
                        newF( tinP , LF , pczChannelCopy , cca ) ; ___( pczChannelCopy ) ;
                        ZE( countT* , pczChannelCopy ) ;
                        countT cca = 1 + strBodyLengthF( tinP , pczChannel ) ;
                        const countT* pczChannel = (countT*)psWrap->pbFieldF( tinP , idtC , flC , cbC , ifcIDfIELDwRAP_CHANNEL ) ;
                        ZE( countT , cbC ) ;
                        ZE( flagsT , flC ) ;
                        ZE( countT , idtC ) ;
                    {
                    else if( idType == ifcIDtYPEwRAP_GIFT )
                    }
                        break ;
                        DEL( psWrap ) ;
                    {
                    if( idType == ifcIDtYPEwRAP_QUIT    )
                    ZE( countT , ze ) ;
                    idPortTimeC idptNU ;
            
                    countT idType = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_IDtYPE ) ;
            
                    __( psWrap->cFieldF( tinP , ifcIDfIELDwRAP_IDvERSION ) - 1 ) ;
                    __( psWrap->cFieldF( tinP , ifcIDfIELDwRAP_IDpROTOCOL ) - ifcIDpROTOCOL_RELAYwRAP ) ;
                    }
                        delF( tinP , psttTM ) ;
                        __( strCompareF( tinP , psttTM , T("IdeaFarm " "(tm)") ) ) ;
    
                        strReplaceF( tinP , psttTM , 0 , ifcIDtYPEsTRrEPLACE_MAKEiMPORT , psttTM[ 2 ].idAdam ) ; ___( psttTM ) ;
                        strDecodeF( tinP , psttTM , pbfTM ) ; ___( psttTM ) ;
                        ZE( strokeS* , psttTM ) ;
            
                        const byteT* pbfTM = psWrap->pbFieldF( tinP , idtTM , flTM , cbTM , ifcIDfIELDwRAP_TRADEmARK ) ;
                        ZE( countT , cbTM ) ;
                        ZE( flagsT , flTM ) ;
                        ZE( countT , idtTM ) ;
                    {
            
                    //else { CONoUTrAW( "relayF: readF returned a wrap\r\n" ) ; }
                    }
                        break ;
                        DEL( psWrap ) ;
                        //LOGrAW3( "ERROR READING FROM TEAT PORT " , (countT)home.idpTeat , "\r\n" ) ;
                        //CONoUTrAW3( "ERROR READING FROM TEAT PORT " , (countT)home.idpTeat , "\r\n" ) ;
                        POOPR
                    {
                    if( POOP )
                    sock.readF( tinP , *psWrap ) ;
        
                    soulC* psWrap = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                {
                while( !bQuitP && !POOP )
            
                osThreadF( tinP , countTC() , tmRelayBlowTeatF , &sgnDone_tmRelayBlowTeatF , flTHREADlAUNCH_null , 0 , (countT)&sock , (countT)&bQuitWoConnect , (countT)&stRelayOutP ) ;
                signC sgnDone_tmRelayBlowTeatF( tinP , TAG( TAGiDnULL ) ) ;
                ZE( boolT , bQuitWoConnect ) ;
            
                sock.connectF( tinP , home.idpTeat , (nicNameC&)home.idpTeat ) ;
                socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
            {
            if( !bQuitP )
    
            idpTeatLag = home.idpTeat ;
            }
                }
                    ++ s ; osSleepF( tinP , TUCK * 0x40 ) ;
                    //LOGrAW3( "waiting for home.idpTeat value " , (countT)home.idpTeat , " to change\r\n" ) ;
                    //CONoUTrAW3( "waiting for home.idpTeat value " , (countT)home.idpTeat , " to change\r\n" ) ;
                {
                while( ( !home.idpTeat || ( home.idpTeat == idpTeatLag && cTries -- ) ) && !bQuitP )
                countT cTries = 0x40 ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            SCOOPS
        {
        while( !bQuitP )
        idPortC idpTeatLag ;
        homeS& home = homeS::homeIF() ;
    {
    IFsCRATCH
    _IO_

    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::relayF( tinS& tinP , const boolT& bQuitP , stackC& stRelayOutP , countT*& pcArgP , cioGetFT& pCioGetFP , batonC& b_pCioGetFP )/*1*/

/**/
*/
 b_pCioGetFP
  it is illegal to change the value without grabbing b_pCioGetFP
  calling process can change or reset this value asynchronously
  if not 0 then will be called for each incoming soulC payload
  can be 0
 pCioGetFP
  passed to the callback function without being inspected
 cArgP
  each soulC item will be launched into relay
  the contents of these soulC objects must conform to the relay protocol
  caller can asynchronously push pointers to soulC objects onto stRelayOutP
 stRelayOutP
 bQuitP
 tinP
arguments
   if pass then write the envelope to the application (BBBB)
   test against the filters registered by the application client
  for each outer envelope pushed onto a stackC (by the inner system)
 tmRelayServerOuterIncomingF
  read outer envelopes, popping each into the inner system (AAAA)                          ========AOK (triplets)
  launches tmRelayServerOuterIncomingF
 tmRelayServerOuterF
  for each local application client, launch tmRelayServerOuterF
  binds, and puts that idPort value into homeS so local clients can connect to it
 tmRelayAcceptorF
  launches tmRelayAcceptorF
  does inner stuff
 relayC::relayC
  for each envelope pushed onto a stackC: write it to the local inner relay server (AAAA)  ========AOK (triplets)
 tmRelayWriteWrapFromAppF
  for each incoming envelope: call callback  (BBBB)
  launches tmRelayWriteWrapFromAppF
  connects to the local inner relay server
 relayF
relay system pseudocode
if this occurs, impotence will not occur
i will return early if i must detach from relay
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

