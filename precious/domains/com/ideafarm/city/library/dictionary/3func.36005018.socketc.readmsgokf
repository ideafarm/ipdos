
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
        _OUT_
    
        tinP.pAdamGlobal3->_socketC_.grab.ungrabF( tinP ) ;
        pOdometer->cbWrite += tinP.odoSockCbWrite - _odoSockCbWriteOpen ;
        pOdometer->cbRead  += tinP.odoSockCbRead  - _odoSockCbReadOpen  ;
        pOdometer = (sockOdometerS*)&(countT&)*tinP.pAdamGlobal3->_socketC_.pSwOdometer ;
        tinP.pAdamGlobal3->_socketC_.nnLever = nnPeer ;
        tinP.pAdamGlobal3->_socketC_.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
        bRead.ungrabF( tinP ) ; //THIS IS BALANCED BY THE BATON GRAB IN readMsgF
    
        THREADmODE1rESTORE

        else                                               pEther->sockWriteF(     tinP , handle      , (byteT*)&cbMsgInLast , sizeof cbMsgInLast ) ;
        if( F(flagsMode) & flSOCKETcmODE_CRYPTfOREIGNsSL ) pEther->openSsl_writeF( tinP , handle , (byteT*)&cbMsgInLast , sizeof cbMsgInLast ) ;

        else                                               pEther->sockWriteF(     tinP , handle      , (byteT*)&idMsgInLast , sizeof idMsgInLast ) ;
        if( F(flagsMode) & flSOCKETcmODE_CRYPTfOREIGNsSL ) pEther->openSsl_writeF( tinP , handle , (byteT*)&idMsgInLast , sizeof idMsgInLast ) ;

        }
            else                                               pEther->sockWriteF(     tinP , handle      , (byteT*)&idType , sizeof idType ) ;
            if( F(flagsMode) & flSOCKETcmODE_CRYPTfOREIGNsSL ) pEther->openSsl_writeF( tinP , handle , (byteT*)&idType , sizeof idType ) ;
            countT idType = 2 ;
        {

        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    
        const countT _odoSockCbWriteOpen = tinP.odoSockCbWrite ;
        const countT _odoSockCbReadOpen  = tinP.odoSockCbRead  ;
    
        _INoLD_
    
        }
            }
                return ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL    
        SCOOPP
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/voidT socketC::readMsgOkF( tinS& tinP )/*1*/

/**/
*/
 tinP
arguments
call readMsgNokF if the data cannot be processed
call readMsgOkF after the data received has been processed
 this function releases the socketC object but does not grab it
the caller -must- precede this call with a call to readMsgF
  both ends of a connection should use writeMsgF, readMsgF, and readMsgOkF (or readMsgNack)
 this protocol is subject to change
   cbr must equal the cbP just sent
   idMsgr must equal the idMsg just sent
   2 indicates that this is an ack
  then reads 2, idMsgr, cbr
   idMsg is consecutive from 1 and is unique for each message going out from a socket
   1 indicates that this is a message (rather than an ack)
  writes 1, idMsg, cbP, pbP
 the remote peer is assumed to have written a message using the following protocol
sends an acknowledgement to the peer that processing was successful for the last message read using the IFC message protocol
  \<A HREF=\"5.4930104.1.1.0.html\"\>4930104:  WAKEsHOW( "example.simplest.func.107001b.socketC.readMsgOkF" )\</A\>
 simplest
examples
\<A HREF=\"5.107001b.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$readMsgOkF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

