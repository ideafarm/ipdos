
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.loafIF( tinP ) ;



}
    //++ s ; etThread.osSleepF( tinP , TOCK ) ;
    //sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    linesF( tinP , etThread , st_a ) ;
    *(measureT*)&st_a[ 1 ] = step ;
    etThread.strokeF( tinP , T("\f(")+TF1(*(measureT*)&st_a[1])+T(",")+TF1(*(measureT*)&st_a[2])+T(",")+TF1(*(measureT*)&st_a[3])+T(")") ) ;
{
for( measureT step = 0.0 ; !ether && step <= 0.1 ; step += 0.001 )

st_a << (measureT)1.0 ;
st_a << (measureT)0.0 ;
st_a << (measureT)0.0 ;
stackC st_a( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_measureT ) ;

TODO

}
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b << (measureT)110.0 ;
    st_b << (measureT)1.0 ;
    st_b << (measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP , 1 ) ;
    st_b << (measureT)100.0 ;
    st_b << (measureT)1.0 ;
    st_b << (measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b << (measureT)110.0 ;
    st_b << (measureT)1.0 ;
    st_b << (measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP , 1 ) ;
    st_b << (measureT)100.0 ;
    st_b << (measureT)1.0 ;
    st_b << (measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b << (measureT)110.0 ;
    st_b << (measureT)-1.0 ;
    st_b << (measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP , 1 ) ;
    st_b << (measureT)100.0 ;
    st_b << (measureT)-1.0 ;
    st_b << (measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b << (measureT)110.0 ;
    st_b << (measureT)-1.0 ;
    st_b << (measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP , 1 ) ;
    st_b << (measureT)100.0 ;
    st_b << (measureT)-1.0 ;
    st_b << (measureT)-1.0 ;
    
    
    
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b << (measureT)110.0 ;
    st_b << (measureT)-1.0 ;
    st_b << (measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b << (measureT)110.0 ;
    st_b << (measureT)1.0 ;
    st_b << (measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b << (measureT)110.0 ;
    st_b << (measureT)1.0 ;
    st_b << (measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b << (measureT)110.0 ;
    st_b << (measureT)-1.0 ;
    st_b << (measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP , 1 ) ;
    st_b << (measureT)110.0 ;
    st_b << (measureT)-1.0 ;
    st_b << (measureT)-1.0 ;




    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b << (measureT)100.0 ;
    st_b << (measureT)-1.0 ;
    st_b << (measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b << (measureT)100.0 ;
    st_b << (measureT)1.0 ;
    st_b << (measureT)-1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b << (measureT)100.0 ;
    st_b << (measureT)1.0 ;
    st_b << (measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP ) ;
    st_b << (measureT)100.0 ;
    st_b << (measureT)-1.0 ;
    st_b << (measureT)1.0 ;
    
    lineF( tinP , etThread , st_b , st_aP , 1 ) ;
    st_b << (measureT)100.0 ;
    st_b << (measureT)-1.0 ;
    st_b << (measureT)-1.0 ;




    stackC st_b( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_measureT ) ;
{
voidT linesF( tinS& tinP , etherC& etThread , stackC& st_aP )

}
    st_bP.purgeF( tinP ) ;
    etThread.strokeF( tinP , T("")+(bWothP?OLDmOVEtO(xx*10000+400,yy*10000+300):OLDlINEtO(xx*10000+400,yy*10000+300))/*+T(". (")+TF1(xx)+T(",")+TF1(yy)+T(")")+OLDmOVEtO(xx*100,yy*100)*/ ) ;
    measureT yy = *(measureT*)&st_bP[ 2 ] ;
    measureT xx = *(measureT*)&st_bP[ 1 ] ;
    mapF( tinP , etThread , st_bP , st_aP ) ;
{
voidT lineF( tinS& tinP , etherC& etThread , stackC& st_bP , stackC& st_aP , const boolT bWothP = 0 )

}
    while( st_bP > 2 ) visionF( tinP , etThread , st_bP , st_aP ) ;
{
voidT mapF( tinS& tinP , etherC& etThread , stackC& st_bP , stackC& st_aP )

}
    st_bP.extractF( tinP ) ;
    //if( *(measureT*)&st_bP[ cDim ] ) { BLAMMO ; }

    projectionF( tinP , etThread , st_bP , st_a2 , st_b2 ) ;
    st_bP.purgeF( tinP ) ;

    }
        st_b2 << *(measureT*)&st_bP[ idd ] + lb * *(measureT*)&st_t[ idd ] ;
        st_a2 << *(measureT*)&st_aP[ idd ] + la * *(measureT*)&st_t[ idd ] ;
    {
    for( countT idd = 1 ; idd <= cDim ; idd ++ )
    stackC st_b2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_measureT ) ;
    stackC st_a2( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_measureT ) ;
    const measureT lb = lengthF( st_bP , cDim ) ;
    const measureT la = lengthF( st_aP , cDim ) ;

    }
        projectionF( tinP , etThread , st_t , st_aP , st_b ) ;

        for( countT idd = 1 ; idd <= cDim ; idd ++ ) st_b << (measureT)( idd < cDim ? 0.0 : 1.0 ) ;
        stackC st_b( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_measureT ) ;
    {
    stackC st_t( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_measureT ) ;

    const countT cDim = st_bP ;
{
voidT visionF( tinS& tinP , etherC& etThread , stackC& st_bP , stackC& st_aP )

}
    }
        st_tP << *(measureT*)&st_d[ idd ] - *(measureT*)&st_c[ idd ] ;
    {
    for( countT idd = 1 ; idd <= cDim ; idd ++ )

    }
        st_d << *(measureT*)&st_bP[ idd ] * rr ;
    {
    for( countT idd = 1 ; idd <= cDim ; idd ++ )
    stackC st_d( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_measureT ) ;

    const measureT rr = 1.0 / innerProductF( st_bP , st_c ) ;

    }
        st_c << *(measureT*)&st_aP[ idd ] / la ;
    {
    for( countT idd = 1 ; idd <= cDim ; idd ++ )
    stackC st_c( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_measureT ) ;

    const measureT la = lengthF( st_aP , cDim ) ;

    if( !cDim || cDim > st_aP ) { BLAMMO ; }
    const countT cDim = st_bP ;
{
voidT projectionF( tinS& tinP , etherC& etThread , stackC& st_tP , stackC& st_aP , stackC& st_bP )

}
    return ip ;

    }
        ip += *(measureT*)&st1P[ idd ] * *(measureT*)&st2P[ idd ] ;
    {
    for( countT idd = 1 ; idd <= cDim ; idd ++ )
    ZE( measureT , ip ); 

    if( cDim != st2P ) { BLAMMO ; }
    const countT cDim = st1P ;
{
measureT innerProductF( stackC& st1P , stackC& st2P )

}
    return thirdC::c_sqrtIF( ll ) ;

    }
        ll += vv * vv ;
        measureT vv = *(measureT*)&stP[ idd ] ;
    {
    for( countT idd = 1 ; idd <= cDimP ; idd ++ )

    ZE( measureT , ll ) ;
    if( stP < cDimP ) { BLAMMO ; }
{
measureT lengthF( stackC& stP , const countT cDimP )

/*1*/WAKEhIDE( "doodle.eye" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

