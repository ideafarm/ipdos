
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cbUsed ;

    //}
    //    delF( tinP , psttdStrokes ) ;
    //    LOGrAW( td ) ;
    //    TN( td , "" ) ; td = T("  to strokes: ")+T(psttdStrokes)+T("\r\n") ;
    //    strDumpIF( tinP , psttdStrokes , (byteT*)psttP , ( CSpREFIX + psttP->idAdam ) * sizeof( strokeS ) ) ; ___( psttdStrokes ) ;
    //    ZE( strokeS* , psttdStrokes ) ;
    //{
    //if( tinP.pc Utility[ 0 ] )
    //COMMENT OUT IN PRODUCTION
    
    //}
    //    delF( tinP , psttdCodes ) ;
    //    LOGrAW( td ) ;
    //    TN( td , "" ) ; td = T("\r\nfrom codes  : ")+T(psttdCodes)+T("\r\n") ;
    //    strDumpIF( tinP , psttdCodes , pbP , ((countT*)pbP)[ 1 ] + 2 * sizeof( countT ) ) ; ___( psttdCodes ) ;
    //    ZE( strokeS* , psttdCodes ) ;
    //{
    //if( tinP.pc Utility[ 0 ] )
    //COMMENT OUT IN PRODUCTION

    //CONoUTrAW( T("decoded  \"")+T(psttP)+T("\"\r\n") ) ; //TO FIND SLOWNESS

    }
        }
            }
                }
                    cToDo -= csImage ;
                    offo  += csImage ;
                    offbi += cbImage * SB ;
                    thirdC::c_memcpyIF( tinP , (byteT*)&psttP[ offo ] , pbP + offbi / SB , cbImage ) ;
                    countT cbImage = csImage * sizeof( strokeS ) ;
                    countT csImage = psttP[ offo - 1 ].idAdam ;

                    valueInF( pbP , offbi , ( SB - offbi ) % SB ) ;
                {
                if( psttP[ offo - 1 ].idCaste == sc_cADAMeXPORT )
                getStrokeS( psttP[ offo ++ ] , pbP , offbi ) ;
                countT offbisave = offbi ;
            {
            while( cToDo -- )
            countT cToDo = psttP->idAdam ;

            while( cToDoPrefix -- ) getStrokeS( psttP[ offo ++ ] , pbP , offbi ) ;
            countT cToDoPrefix = CSpREFIX - 1 ;
            psttP[ offo ++ ] = stt1 ;
            ZE( countT , offo ) ;
        {
        if( psttP )
        POSTPONEtEST( psttP )
        newF( tinP , LF , psttP , CSpREFIX + stt1.idAdam ) ; // CALLER MUST TAG ___( psttP ) ;
    {
    if( !POOP)

    __( stt1.idCaste - sc_PREFIXlENGTH ) ;
    getStrokeS( stt1 , pbP , offbi ) ;
    strokeS stt1 ;
    //WOTH STROKE

    }
        //__( cbActual != cbClaimed && cbActual - 1 != cbClaimed && cbActual + 1 != cbClaimed ) ; //soulC APPENDS NULL TERMINATOR AS A COURTESY; I REQUIRE THAT LENGTHS DIFFER BY NO MORE THAN 1 BYTE
        //countT cbClaimed = cbPrefix + 2 * sizeof( countT ) ;
        //countT cbActual = tinP.pDropNoteNewest->cbUsedReally ;
        //COMMENTED OUT SO pbP CAN BE WITHIN A LARGE AGGREGATE OF ENCODINGS
        cbUsed = cbPrefix + 2 * sizeof( countT ) ;
        const countT cbPrefix = valueInF( pbP , offbi , sizeof( countT ) * SB ) ;

        __( finger != FINGERnEG_STReNCODEf && finger != FINGERnEGoLD_strEncodeF ) ;
        countT finger = valueInF( pbP , offbi , sizeof( countT ) * SB ) ;
    {
    ZE( countT , offbi ) ; //BIT OFFSET OF NEXT READ
    ZE( countT , cbUsed ) ;

    }
        if( POOP ) return 0 ;
        __( !((countT*)pbP)[ 1 ] ) ;
        __( ((countT*)pbP)[ 0 ] != FINGERnEG_STReNCODEf && ((countT*)pbP)[ 0 ] != FINGERnEGoLD_strEncodeF ) ;
        if( POOP ) return 0 ;
        __Z( pbP ) ;
        __NZ( psttP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/countT etherC::strDecodeF( tinS& tinP , strokeS*& psttP , const byteT* const pbP )/*1*/

/**/
*/
i evaluate to the length of the encoding at pbP
i decompress a prefixed stroke string
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

