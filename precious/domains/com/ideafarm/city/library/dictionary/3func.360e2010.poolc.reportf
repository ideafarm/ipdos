
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        walkF( tinP , slotsWalkCBF , cArg ) ;
        countT cArg = (countT)&soulP ;
    {
    if( tinP.pEther )
    _IO_

    }
        if( POOP ) return ;
        __Z( tinP.pEther ) ; // *tinP.pEther RATHER THAN A  etherC& PARAMETER IS USED SO THAT IN THE FUTURE I CAN DO SOMETHING USEFUL WHEN NO INSTANCE OF etherC EXISTS
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT poolC::reportF( tinS& tinP , soulC& soulP )/*1*/

}
    }
        etThread.delF( tinP , pstte ) ;
        etThread.strFuseF( tinP , soulRptP , pstte ) ;

        }
            }
                }
                    }
                        etThread.delF( tinP , psttLine ) ;
                        etThread.strFuseF( tinP , pstte , psttLine ) ;
                        etThread.strDumpIF( tinP , psttLine , pbDataP + offb * cbSlot , cbSlot , 0x10 , 4 , '.' ) ; ___( psttLine ) ;
                        ZE( strokeS* , psttLine ) ;
                    {
                    else
                    }
                        etThread.delF( tinP , psttLine ) ;
                        etThread.strFuseF( tinP , pstte , tqcr ) ;
                        etThread.strFuseF( tinP , pstte , psttLine ) ;
                        etThread.strFuseF( tinP , pstte , tq ) ;
                        etThread.strDumpStrokesIF( tinP , psttLine , psttc ) ; ___( psttLine ) ;

                        etThread.delF( tinP , psttLine ) ;
                        etThread.strFuseF( tinP , pstte , tqcr ) ;
                        etThread.strFuseF( tinP , pstte , psttLine ) ;
                        etThread.strFuseF( tinP , pstte , TF3(offb,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+tb+TF3(ptUsed,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,3)+tb+TF3(cbOriginal,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,6)+tb+TF3(csttOriginal,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,6)+tbq ) ;

                        }
                            etThread.delF( tinP , psttd ) ;
                            etThread.strSubstringF( tinP , psttLine , idf , idl , psttd ) ; ___( psttLine ) ;
                            countT idl = TUCK ;
                            countT idf = 1 ;

                                             psttLine = 0 ;
                            strokeS* psttd = psttLine ;
                        {
                        if( psttLine->idAdam > TUCK )

                        etThread.strReplaceAnyF( tinP , psttLine , psttc , tWhite , tb , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttLine ) ;
                        ZE( strokeS* , psttLine ) ;

                        countT ptUsed = ( cbOriginal << 8 ) / cbSlot ;
                        countT cbOriginal = ( CSpREFIX + csttOriginal ) * sizeof( strokeS ) ;
                        countT csttOriginal = psttc->idAdam ;
                    {
                    if( ISsTRING( psttc ) )
                    const strokeS* psttc = (const strokeS*)( pbDataP + offb * cbSlot ) ;
                {
                if( pbBitsOwnedP[ offByte ] >> offBit & 1 )

                countT offBit  = offb % SB ;
                countT offByte = offb / SB ;
            {
            for( countT offb = 0 ; offb < cBits ; offb ++ )
            countT cbSlot = 1 << pHeadP->expCbDrop ;
            TN( tWhite , TbLACK ) ;
            TN( tqcr , "\"\r\n" ) ;
            TN( tb , " " ) ;
            TN( tbq , " \"" ) ;
            TN( tq , "\"" ) ;

            etThread.strFuseF( tinP , pstte , T("\r\n\r\nvalues:\r\noffset-- ptu cbUsed cUsed-\r\n") ) ;
        {
        else
        if( !cFound ) etThread.strFuseF( tinP , pstte , tcr ) ;

        }
            else etThread.strFuseF( tinP , pstte , tDash ) ;                                                                        //A:1
            }
                etThread.strFuseF( tinP , pstte , tAt ) ;                                                                           //A:1
                cFound ++ ;
            {
            if( pbBitsOwnedP[ offByte ] >> offBit & 1 )

            countT offBit  = offb % SB ;
            countT offByte = offb / SB ;
        {
        for( countT offb = 0 ; offb < cBits ; offb ++ )
        ZE( countT , cFound ) ;
        TN( tDash , "-" ) ;
        TN( tAt , "@" ) ;
        TN( tcr , "\r\n" ) ;
        countT cBits = 1 << pHeadP->expSlots ;

        }
            //U::etThread.strMakeF( tinP , LF , pstte , tEntry , TUCK + ( TUCK << 1 ) * ( 1 << pHeadP->expSlots ) ) ; ___( pstte ) ;                 //A:1
            etThread.strMakeF( tinP , LF , pstte , tEntry , TICK ) ; ___( pstte ) ; //U::TO FIND A BUG

            ) ;

                "owned bits: "
                "cSlotsAvoidHi" ":")+TF2(pHeadP->cSlotsAvoidHi,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n"
                "cSlotsAvoidLo:")+TF2(pHeadP->cSlotsAvoidLo,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n"
                "flagsCtCopy:")+TF2(pHeadP->flagsCtCopy,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n"
                "postName   : \"")+T(pHeadP->postName)+T("\"\r\n"
                "expSlots   : ")+TF2(pHeadP->expSlots,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n"
                "expCbDrop  : ")+TF2(pHeadP->expCbDrop,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n"
                "cRef       : ")+TF2(pHeadP->cRef,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n"
                "\r\n"
                "sexHeadS:\r\n"
                "\r\n"
                "\r\n"

            TN( tEntry , "" ) ; tEntry = T(
        {
        ZE( strokeS* , pstte ) ;

        etherC& etThread = *tinP.pEther ;
        soulC& soulRptP  = *(soulC*)cArgP ;
    {
    if( tinP.pEther && cArgP )
{
voidT slotsWalkCBF( tinS& tinP , countT& cArgP , const sexHeadS* pHeadP , const byteT* pbBitsOwnedP , const dropNoteS* pNotesP , const byteT* pbDataP )

/**/

*/
 it is unuseably slow
U::this needs more development
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

