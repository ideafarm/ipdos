
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.delF( tinP , pstt1m ) ;
}
    }
        etThread.delF( tinP , psttShort ) ;

        }
            }
                etThread.diskMoveFileOrDirF( tinP , tNew , psttc1 ) ;
    
                }
                    etThread.delF( tinP , psttw ) ;
                    tNew += T(!bHaveDot1&&!bHaveDot2?".":"")+T(psttw) ;
                    boolT bHaveDot2 = psttw[ CSpREFIX ].idAdam == '.' ;
                    etThread.strSubstringF( tinP , psttw , idfRight , idlRight , psttShort ) ; ___( psttw );
                {
                if( idfRight )
    
                }
                    etThread.delF( tinP , psttw ) ;
                    bHaveDot1 = psttw[ CSpREFIX - 1 + psttw->idAdam ].idAdam == '.' ;
                    tNew += T(".")+T(psttw) ;
                    etThread.strSubstringF( tinP , psttw , idfLeft , idlLeft , psttShort ) ; ___( psttw );
                {
                if( idfLeft )
                ZE( boolT , bHaveDot1 ) ;
    
                etThread.delF( tinP , psttw ) ;
                tNew += T(psttw) ;
                etThread.strSubstringF( tinP , psttw , idf , idl , psttShort ) ; ___( psttw );
    
                }
                    idlRight = psttShort->idAdam ;
                    idfRight = idl + 1 ;
                {
                if( idl < psttShort->idAdam )
    
                }
                    idlLeft = idf - 2 ;
                    idfLeft = 1 ;
                {
                if( idf > 2 )
    
                ZE( countT , idlRight ) ;
                ZE( countT , idfRight ) ;
                ZE( countT , idlLeft  ) ;
                ZE( countT , idfLeft  ) ;
            {
            if( idl <= psttShort->idAdam )
            countT idl = idf + 15 ;
        {
        if( idf ++ )
    
        if( !idf ) idf = etThread.strIdF( tinP , T("_2009_") , psttShort ) ;
        countT     idf = etThread.strIdF( tinP , T("_2010_") , psttShort ) ;

        }
            etThread.strSubstringF( tinP , psttShort , idf , idl , psttc1 ) ; ___( psttShort );
            countT idl = psttc1->idAdam ;
            countT idf = ids + 1 ;
        {
        ZE( strokeS* , psttShort ) ;

        }
            etThread.delF( tinP , psttw ) ;
            tNew += T(psttw) ;
            etThread.strSubstringF( tinP , psttw , idf , idl , psttc1 ) ; ___( psttw );

            countT idl = ids ;
            countT idf = 1 ;
        {
        ZE( strokeS* , psttw ) ;
        TN( tNew , "" ) ;
    {
    if( 1 < ids && ids < psttc1->idAdam )
    countT ids = etThread.strIdF( tinP , S1C('/') , psttc1 , - 1 ) ;

    etThread.strokeF( tinP , T(psttc1)+T("\r\n") ) ;

    //if( !( cToDo -- ) ) break ;
{
FORsTRINGSiN1( pstt1m )
countT cFound = etThread.boxMenuF( tinP , soul , T("///d/tmp/archived/tmp/audio/*") , 0 /*, cToDo*/ ) ; ___( pstt1m ) ;
ZE( strokeS* , pstt1m ) ;
//countT cToDo = TUCK << 2 ;


TODO

/*1*/WAKEsHOWtEXT( "tool: rename audio files so will sort by time" )/*1*/
/**/
*/
i rename all files in a hardcoded directory so that the date and time information is moved to the beginning and all other information is retained in order at the end of the name
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

