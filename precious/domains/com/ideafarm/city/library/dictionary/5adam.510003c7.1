
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    etThread.osSleepF( tinP , TOCK * 4 , TOCK , flSLEEP_TALK ) ;
    }
        }
            }
                ((thirdC&)etThread).logF( tinP , T(psttl) ) ;
                etThread.strokeF( tinP , T(psttl)+T("\r\n") ) ;
                //}
                //    __1
                //    etThread.strokeF( tinP , T("i was unable to send this information to city center\r\n") ) ;
                //    etThread = 0 ;
                //{
                //else
                //if( !etThread ) etThread.strokeF( tinP , T("done\r\n") ) ;
                //etThread.ifcPutHostLogEntryF( tinP , psttl ) ;
                //etThread.strokeF( tinP , T("i am attempting to contact city.center.ideafarm.com\r\nplease wait up to one 20 tocks for me to complete this\r\n") ) ;

                for( countT ids = 1 ; ids <= 1 + OFFsLOTtINsTEPmAX ; ids ++ ) { etThread.strFuseF( tinP , psttl , TF3(info2.pIdFileStep[idi*(1+CfOUNDmAX)+ids],flFORMAT_FILLzE,7)+T("@")+TF4(info2.pIdLineStep[idi*(1+CfOUNDmAX)+ids],flFORMAT_NObASE,0,10)+T(" <- ") ) ; ___( psttl ) ; }

                , ( 1 + OFFsLOTtINsTEPmAX ) * 0x200 + 4 ) ; ___( psttl ) ;

                    TF3(info2.pIdStep[idi],0                ,8)+T(" ; ")
                    TF4(info2.pIdlTask[   idi],0             ,8,10)+T(" ; idStep=")+
                    TF3(info2.pIdiTask[   idi],flFORMAT_FILLzE,7)+T("@")+
                    TF3(info2.pIdiOwner[  idi],flFORMAT_FILLzE,7)+T(" ; task=")+
                    TT( info2.pTime1[idi],info2.pTime2[idi])       +T(" ; owner=")+
                    TF3(idi,0,4)                                   +T(" at ")+
                    T("dead thread: seq=")                                    +

                etThread.strMakeF( tinP , LF , psttl ,
                ZE( strokeS* , psttl ) ;

                }
                    etThread.strokeF( tinP , T("\r" BLANK79 "\r") ) ;
                    bFound = 1 ;
                {
                if( !bFound )
            {
            if( info2.pbDead[ idi ] )
        {
        for( countT idi = 1 ; idi <= info2.cFound ; idi ++ )
        ZE( boolT , bFound ) ;

        }
            else         info2.pbDead[ idi ] = idStepLag == info2.pIdStep[ idi ] ;
            if( etThread ) etThread = 0 ;
            countT idStepLag = map[ (countT)info2.pTin[ idi ] ] ;
        {
        for( countT idi = 1 ; idi <= info2.cFound ; idi ++ )

        for( countT idi = 1 ; idi <= info1.cFound ; idi ++ ) map.sinkF( tinP , (countT)info1.pTin[ idi ] , info1.pIdStep[ idi ] ) ;
        mapC map( tinP , etThread ) ;
    {
    if( info2.cFound )

    (>>>>(p oolC&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<Thread).walkF( tinP , poolOldWalkerF , cInfo ) ;
    cInfo = (countT)&info2 ;

    //etThread.osSleepF( tinP , TICK , TOCK , flSLEEP_TALK ) ;
    etThread.osSleepF( tinP , TOCK * 8 , TOCK , flSLEEP_TALK ) ;

    (>>>>(p oolC&)et<<>>OBSOLETEDcODE:INTENTIONALcOMPILEeRROR<<<<Thread).walkF( tinP , poolOldWalkerF , cInfo ) ;
    countT cInfo = (countT)&info1 ;

    infoS info2( tinP , etThread ) ;
    infoS info1( tinP , etThread ) ;
{
while( !ether && !etThread )

TODO

}
    return bCorrupt ;

    }
        }
            }
                }
                    }
                        }
                            else if( offi == 1 + ( pTin->idStep & OFFsLOTtINsTEPmAX ) ) break ;
                            if( !offi ) offi = 1 + OFFsLOTtINsTEPmAX ;
                            info.pIdLineStep[ info.cFound * ( 1 + CfOUNDmAX ) + idso ] = pTin->pIdLineStep[ offi ] ;
                            info.pIdFileStep[ info.cFound * ( 1 + CfOUNDmAX ) + idso ] = pTin->pIdFileStep[ offi ] ;
                            offi -- ;
                            idso ++ ;
                        {
                        while( !etThread )
                        countT offi = 1 + ( pTin->idStep & OFFsLOTtINsTEPmAX ) ;
                        ZE( countT , idso ) ;

                        info.pCForAdamToUse[ info.cFound ] = pTin->pc Utility[ 0 ] ;
                        info.pIdStep   [ info.cFound ] = pTin->idStep ;
                        info.pIdlTask  [ info.cFound ] = pTin->idlTask ;
                        info.pIdiTask  [ info.cFound ] = pTin->idiTask ;
                        info.pIdiOwner [ info.cFound ] = pTin->idiOwner ;
                        info.pTime2    [ info.cFound ] = pTin->time2 ;
                        info.pTime1    [ info.cFound ] = pTin->time1 ;
                        info.pTin      [ info.cFound ] = pTin ;

                        tinS* pTin = (tinS*)pvP ;
                    {
                    if( info.cFound <= CfOUNDmAX )

                    info.cFound ++ ;
                {
                if( !fDeleted && idc != idClientP && cbd == sizeof( countT ) + sizeof( tinS ) && pvP && getNegAM( *(countT*)pvP ) == FINGERnEG_TINs )

                countT idFile   = db.idFile ;
                countT idLine   = db.idLine ;
                countT cbd      = DHcbYTES ;
                countT idc      = DHiDcLIENT ;
                boolT  fDeleted = !!( F(DHfLAGS) & flDROP_DELETED ) ;
                //DROPnOTErEF( pvP ) ;
            {
            else
            if( bCorrupt ) etThread.strokeF( tinP , T("corrupt") ) ;
            bCorrupt = DHgUARD != POOLoLDdROPgUARD ;
        {
        if( pvP )

        etherC& etThread = info.ether ;
        infoS& info = *(infoS*)infoP ;
    {
    if( infoP )

    ZE( boolT , bCorrupt ) ;
{
boolT poolOldWalkerF( tinS& tinP , voidT* const pvP , countT& idClientP , countT& infoP )

}
    if( tinP.fingerprint ) ;
    }
        }
            pIdLineStep[ idt * ( 1 + CfOUNDmAX ) + ids ] = 0 ;
            pIdFileStep[ idt * ( 1 + CfOUNDmAX ) + ids ] = 0 ;
        {
        for( countT ids = 0 ; ids <= 1 + OFFsLOTtINsTEPmAX ; ids ++ )

        pbDead        [ idt ] = 0 ;
        pCForAdamToUse[ idt ] = 0 ;
        pIdStep   [ idt ] = 0 ;
        pIdlTask      [ idt ] = 0 ;
        pIdiTask      [ idt ] = 0 ;
        pIdiOwner     [ idt ] = 0 ;
        pTime2        [ idt ] = 0 ;
        pTime1        [ idt ] = 0 ;
        pTin          [ idt ] = 0 ;
    {
    for( countT idt = 0 ; idt <= CfOUNDmAX ; idt ++ )
{
cFound( 0 )
ether( etherP ) ,
infoS::infoS( tinS& tinP , etherC& etherP ) :

;
}
    infoS( tinS& tinP , etherC& etherP ) ;

    boolT   pbDead        [   1 + CfOUNDmAX                       ] ;
    countT  pCForAdamToUse[   1 + CfOUNDmAX                       ] ;
    countT  pIdLineStep   [ ( 1 + CfOUNDmAX ) * ( 2 + OFFsLOTtINsTEPmAX ) ] ;
    countT  pIdFileStep   [ ( 1 + CfOUNDmAX ) * ( 2 + OFFsLOTtINsTEPmAX ) ] ;
    countT  pIdStep   [   1 + CfOUNDmAX                       ] ;
    countT  pIdlTask      [   1 + CfOUNDmAX                       ] ;
    countT  pIdiTask      [   1 + CfOUNDmAX                       ] ;
    countT  pIdiOwner     [   1 + CfOUNDmAX                       ] ;
    sCountT pTime2        [   1 + CfOUNDmAX                       ] ;
    countT  pTime1        [   1 + CfOUNDmAX                       ] ;
    tinS*   pTin          [   1 + CfOUNDmAX                       ] ;

    countT  cFound ;
    etherC& ether ;
{
struct infoS

#define CfOUNDmAX 0x4

/*1*/WAKEhIDE( "scanPool" )/*1*/
/**/
*/
to avoid detection, a thread must update its tinS object within each TICK period
notifies city center when a speed 0 thread is detected
monitors the tinS items in the poolOld
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

