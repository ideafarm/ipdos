
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                    
REST

}
    etThread.traceF( tinP , TF3((countT)swTally,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,8)+tb4+TF3(pczFL[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF2(pczFL[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postTitle) , flTRACE_NOpREFIX ) ;

    }
        if( postTitle ) postTitle += sizeof( countT ) ;
        if( idFile ) postTitle = mapFileTitle( idFile ) ;
        countT idFile = source.idFileRankF( tinP , pczFL[ 0 ] ) ;
    {
    if( pczFL[ 0 ] )
    ZE( const osTextT* , postTitle ) ;

    pczFL = (countT*)swTally.leverF( tinP , idf ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
countT cFlavors = swTally.cFlavorsF( tinP ) ;
sourceC& source = sourceC::sourceIF() ;
mapCTC& mapFileTitle = processGlobal3S::_processGlobal3I_IF().mapFileTitle ;

etThread.traceF( tinP , tSayWorkPerWatch , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , tSayCtDt    , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , tSayDt      , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , tSayInNet   , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , tSayInGross , flTRACE_NOpREFIX ) ;
etThread.traceF( tinP , tSayCt      , flTRACE_NOpREFIX ) ;

;
    +tDot+TF3(((countT*)&cCpuCyclesWorkPerWatch)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesWorkPerWatch)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayWorkPerWatch , "cCpuCyclesWorkPerWatch: " ) ; tSayWorkPerWatch +=

;
    +tDot+TF3(((countT*)&cCpuCyclesCtDt)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesCtDt)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayCtDt         , "cCpuCyclesCtDt        : " ) ; tSayCtDt +=

;
    +tDot+TF3(((countT*)&cCpuCyclesDt)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesDt)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayDt           , "cCpuCyclesDt          : " ) ; tSayDt +=

;
    +tDot+TF3(((countT*)&cCpuCyclesInNet)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesInNet)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayInNet        , "cCpuCyclesInNet       : " ) ; tSayInNet +=

;
    +tDot+TF3(((countT*)&cCpuCyclesInGross)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesInGross)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayInGross      , "cCpuCyclesInGross     : " ) ; tSayInGross +=

;
    +tDot+TF3(((countT*)&cCpuCyclesCt)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
    TF3(((countT*)&cCpuCyclesCt)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
TN( tSayCt           , "cCpuCyclesCt          : " ) ; tSayCt +=

count04T cCpuCyclesWorkPerWatch = !cCpuCyclesCtDt ? 0 : cCpuCyclesInNet / cCpuCyclesCtDt ;
count04T cCpuCyclesCtDt = cCpuCyclesCt + cCpuCyclesDt ;

}
    //etThread.traceF( tinP , T("tmEatTelemetrySysF / 6") ) ;
    }
        //CONoUTrAW( "." ) ;
        ++ s ; etThread.osSleepF( tinP , TOCK >> 2 ) ;
        TELL( "napping for a quarter tock" )

        if( bQuitEating ) break ;
        }
            bBookHead = !bBookHead ;
    
            }
                else          pbi = 0 ;
                if( bDelete ) PUSE( tinP , *(byteT**)&pbi ) ;
                TELL( "maybe deleting hamburger" )
    
                }
                    // /*if( idCycle == TUCK << 0 )*/ bQuitEating = 1 ;
    
                    cbi = sizeof( telemetryBookHeadS ) ;
    
                    }
                        }
                            }
                                break ;

                                }
                                    swTally ++ ;
                                    pczLever[ 1 ] = told.idLineTalking ;
                                    pczLever[ 0 ] = told.idiFileTalking ;

                                    //if( cCpuCyclesDt < was ) { BLAMMO ; }
                                    cCpuCyclesDt += deltaCpuCyclesDt ;
                                    was = cCpuCyclesDt ;

                                    //if( cCpuCyclesInNet < was ) { BLAMMO ; }
                                    cCpuCyclesInNet += deltaCpuCyclesIn - deltaCpuCyclesDup ;
                                    was = cCpuCyclesInNet ;

                                    //if( cCpuCyclesInGross < was ) { BLAMMO ; }
                                    cCpuCyclesInGross += deltaCpuCyclesIn ;
                                    was = cCpuCyclesInGross ;

                                    //if( cCpuCyclesCt < was ) { BLAMMO ; }
                                    cCpuCyclesCt += deltaCpuCyclesCt ;
                                    count04T was = cCpuCyclesCt ;

#endif


                                    etThread.traceF( tinP , tSay , flTRACE_NOpREFIX ) ;

                                    ;

                                        +tDot+TF3(((countT*)&deltaCpuCyclesDup)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tb8 +TF3(((countT*)&deltaCpuCyclesDup)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tDot+TF3(((countT*)&deltaCpuCyclesDt)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tb4 +TF3(((countT*)&deltaCpuCyclesDt)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tDot+TF3(((countT*)&deltaCpuCyclesIn)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tb4 +TF3(((countT*)&deltaCpuCyclesIn)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tDot+TF3(((countT*)&deltaCpuCyclesCt)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tb8 +TF3(((countT*)&deltaCpuCyclesCt)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)

                                        +tDot+TF3(((countT*)&note.cCpuCycles4)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tb4 +TF3(((countT*)&note.cCpuCycles4)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tDot+TF3(((countT*)&note.cCpuCycles3)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tb4 +TF3(((countT*)&note.cCpuCycles3)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tDot+TF3(((countT*)&note.cCpuCycles2)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tb4 +TF3(((countT*)&note.cCpuCycles2)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tDot+TF3(((countT*)&note.cCpuCycles1)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tb8 +TF3(((countT*)&note.cCpuCycles1)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)

                                        +tDot+TF3(((countT*)&note.cTime4)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tb4 +TF3(((countT*)&note.cTime4)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tDot+TF3(((countT*)&note.cTime3)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tb4 +TF3(((countT*)&note.cTime3)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tDot+TF3(((countT*)&note.cTime2)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tb4 +TF3(((countT*)&note.cTime2)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tDot+TF3(((countT*)&note.cTime1)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)
                                        +tb4 +TF3(((countT*)&note.cTime1)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)

                                        +tb4+TF3(told.idiFileTalking,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF2(told.idLineTalking,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                        +tb4+TF3(note.cDadLevels,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)
                                        +TF3(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)

                                    TN( tSay , "" ) ; tSay = tn

#if defined( NEVERdEFINED )

                                    count04T deltaCpuCyclesDup = !!( note.cDadLevels ) * deltaCpuCyclesIn ;
                                    count04T deltaCpuCyclesAll = deltaCpuCyclesCt + deltaCpuCyclesIn + deltaCpuCyclesDt ;

                                    count04T deltaCpuCyclesDt = note.cCpuCycles4 - note.cCpuCycles3 ;
                                    count04T deltaCpuCyclesIn = note.cCpuCycles3 - note.cCpuCycles2 ;
                                    count04T deltaCpuCyclesCt = note.cCpuCycles2 - note.cCpuCycles1 ;

                                    tellInfoAppInOutFrameS& note = *(tellInfoAppInOutFrameS*)pbNote ;
                                {
                                if( told.cbNote == sizeof( tellInfoAppInOutFrameS ) )

                                TELL( "INoUT" )
                            {
                            case ifcIDtYPEtELLaPP_INoUT :
                        {
                        switch( told.idType )

                        //}
                        //    etThread.traceF( tinP , T("telemetry [idType]:    ")+(postSay?T(postSay):TF2(told.idType,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)) ) ;
                        //    const osTextT* postSay = ps3.mapSay( told.idType ) ;
                        //    processGlobal3S& ps3 = processGlobal3S::_processGlobal3I_IF() ;
                        //{
                        //if( bChatter )
                        //
                        //;
                        //    || told.idType == ifcIDtYPEtELLsYS_TINdTI
                        //    || told.idType == ifcIDtYPEtELLsYS_TINdTP
                        //    || told.idType == ifcIDtYPEtELLsYS_TINcTI
                        //       told.idType == ifcIDtYPEtELLsYS_TINcTP
                        //boolT bChatter =
    
                        byteT* pbNote = (byteT*)( &told + 1 ) ;
                    {
                    else
                    }
                    {
                    if( !told.cbNote )

                    //}
                    //    CONoUTrAW( ostoSay ) ;
                    //
                    //    OStEXTAK( ostoSay , "\r\n" ) ;
                    //    OStEXTA(  ostoSay , processGlobal3S::_processGlobal3I_IF().mapSay( told.idType ) ) ;
                    //    OStEXTAK( ostoSay , " " ) ;
                    //    OStEXTC(  ostoSay , told.idType , 0 ) ;
                    //    OStEXTAK( ostoSay , " " ) ;
                    //    OStEXTC(  ostoSay , told.idTell , 0 ) ;
                    //    OStEXTAK( ostoSay , " bytes [idTell,idType]: " ) ;
                    //    OStEXTC(  ostoSay , cbi , 0 ) ;
                    //    OStEXTAK( ostoSay , " received " ) ;
                    //    OStEXTC(  ostoSay , idCycle , 0 ) ;
                    //    OStEXTAK( ostoSay , " cycle " ) ;
                    //    OStEXTC(  ostoSay , idMemorySpaceP , 0 ) ;
                    //    OStEXTAK( ostoSay , "memory space " ) ;
                    //    OStEXT(   ostoSay , TUCK * 2 ) ;
                    //{
                    //)
                    //    told.idType == ifcIDtYPEtELLsYS_TINdTP
                    //    told.idType == ifcIDtYPEtELLsYS_TINdTI      ||
                    //    told.idType == ifcIDtYPEtELLsYS_TINcTI      ||
                    //    told.idType == ifcIDtYPEtELLsYS_TINcTP      ||
                    //(
                    //if

                    //stPeriodData.ungrabF( tinP ) ;
                    //++ pd.swEventTally ;
                    //pd.cLeverIdType = told.idType ;
                    //periodDataS& pd = *(periodDataS*)&stPeriodData[ 1 ] ;
                    //stPeriodData.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    //TELL( "tallying" )
    
                    __( getNegAM( fingerTail ) - FINGERnEG_BOOK0cwRITEtAIL ) ;
                    if( bQuitEating ) break ;
                    while( !fingerTail && !bQuitEating ) { ++ s ; thirdC::dosSleepWinkIF( tinP ) ; }
                    countT& fingerTail = *(countT*)( pbi + sizeof( tellS ) + told.cbNote ) ;

                    __( getNegAM( told.finger2 ) - FINGERnEG_TELEMETRY2 ) ;
                    __( getNegAM( told.finger1 ) - FINGERnEG_TELEMETRY1 ) ;
                    TELL( "checking fingers" )
                    if( bQuitEating ) break ;
                    while( !told.finger2 && !bQuitEating ) { ++ s ; thirdC::dosSleepWinkIF( tinP ) ; }
                    tellS& told = *(tellS*)pbi ;
                    TELL( "waiting for finger2 to be set in telemetry" )

                    ++ idCycle ;
    
                    //CONoUTrAW5( "tmEatTelemetrySysF [idMemorySpace,idHamburger]: " , idMemorySpaceP , " " , idHamburger , "\r\n" ) ;
                    //countT idHamburger = incv02AM( cHamburgersP ) ; // OPERATOR ++ CAN BE USED FOR SPEED IF ACCURACY IS NOT NEEDED; AS OF THIS WRITING ACCURACY IS NOT NEEDED
                    TELL( "got a hamburger" )
                {
                else
                }
                    cbi = head.cbBooked + sizeof( countT ) ;

                    }
                        __1

                        etThread.delF( tinP , psttd ) ;
                        LOGrAW( T("dump of head:\r\n" DASH79 "\r\n")+T(psttd)+T("\r\n" DASH79 "\r\n") ) ;
                        etThread.strDumpIF( tinP , psttd , (byteT*)&head , sizeof head ) ; ___( psttd ) ;
                        ZE( strokeS* , psttd ) ;

                        LOGrAW9( "tmEatTelemetrySysF bad header [bBad1,bBad2,bBad3,bBad4]: " , bBad1 , "    " , bBad2 , "    " , bBad3 , "    " , bBad4 , "\r\n" ) ;
                    {
                    if( bBad1 || bBad2 || bBad3 || bBad4 )

                    boolT bBad4 = !head.cbBooked ;
                    boolT bBad3 = head.idFormat - ifcIDfORMAT_BOOK0hEAD ;
                    boolT bBad2 = getNegAM( head.finger2 ) - FINGERnEG_BOOK0cwRITEhEAD2 ;
                    boolT bBad1 = getNegAM( head.finger1 ) - FINGERnEG_BOOK0cwRITEhEAD1 ;

                    if( bQuitEating ) break ;
                    while( !head.finger2 && !bQuitEating ) { ++ s ; thirdC::dosSleepWinkIF( tinP ) ; }
                    telemetryBookHeadS& head = *(telemetryBookHeadS*)pbi ;
                    TELL( "parsing head" )
                {
                if( bBookHead )

                __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG
                //etThread.traceF( tinP , T("tmEatTelemetrySysF: readF returned telemetry") ) ; //U:: TO FIND A BUG
                TELL( "readF returned telemetry" )
            {
            else
            }
                break ;
                bQuitEating = 1 ;       //U:: REMOVE THIS LINE IN PRODUCTION WHEN I RUN TO REPORT REAL TIME
                hRead = hReadSave ;
                cbi = cbiSave ;
                TELL( "readF returned null" )
            {
            if( !pbi )
    
            //etThread.traceF( tinP , T("tmEatTelemetrySysF / 7") ) ;
            //tinP.pc Utility[ 0 ] -- ; //U::TO FIND A BUG
            boolT bDelete = bksTelemetryApp.readF( tinP , pbi , cbi , hRead , flBOOKScrEAD_STILLhUNGRYiSoK ) ;
            //etThread.traceF( tinP , T("eating telemetry at [idDebug,off,idBook]:    ")+TF2(idDebug,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(ch.c1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(ch.c2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
            HANDLEaPPnOTEScOUNTcLASS ch = hRead ;
            //tinP.pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
            //etThread.traceF( tinP , T("tmEatTelemetrySysF / 8") ) ;
            TELL( "waiting to read a new telemetry item" )

            }
                countT foo = 2 ;
            {
            if( ++ idDebug == 0x90 )

            handleC hReadSave = hRead ;
            countT cbiSave = cbi ;
        {
        while( !bQuitEating && !POOP )
        TELL( "eating 1" )
    {
    while( !bQuitEating && !POOP )
    //etThread.traceF( tinP , T("tmEatTelemetrySysF / 9") ) ;
    ZE( countT , idDebug ) ;
    TELL( "eating 0" )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    ZE( countT , idCycle ) ;
    boolT bBookHead = 1 ;
    countT cbi = sizeof( telemetryBookHeadS ) ;
    ZE( const byteT* , pbi ) ;
    handleC hRead( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
    TELL( "preparing to eat" )
{
if( !(const poopC&)bksTelemetryApp )
ZE( count04T , cCpuCyclesDt      ) ;
ZE( count04T , cCpuCyclesInNet   ) ;
ZE( count04T , cCpuCyclesInGross ) ;
ZE( count04T , cCpuCyclesCt      ) ;

booksC bksTelemetryApp( tinP , TAG( TAGiDnULL ) , "bksTelemetryApp" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_USEgRABuNIVERSEoVERRIDE , 0 , 0 , 0 , 0 , 0 , 0 , &bQuitEating ) ;
ZE( boolT , bQuitEating ) ;

TN( tSay1 , "INoUT [idCycle,cCpuCycles1,cCpuCycles2,cCpuCycles3,cCpuCycles4]:    " ) ;
TN( tDot  , "." ) ;
TN( tb8   , "        " ) ;
TN( tb4   , "    " ) ;
TN( tn    , "" ) ;

switchC swTally( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pczFL ) ;
static const countT* pczFL = pczLever ;
countT  pczLever[ 3 ] = { 0 , 0 , 0 } ;

TODO

;
}
    countT  finger2 ;
    countT  cbBooked ;
    countT  idFormat ;
    countT  finger1 ;
{
struct telemetryBookHeadS




/*1*/WAKEsHOWtEXT( "example.simplest.1snip.15000112.booksc" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

