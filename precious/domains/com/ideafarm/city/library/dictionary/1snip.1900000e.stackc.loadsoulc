
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
                                                                                            #endif
    return *this ;
                                                                                            #if !defined( STACKcLOADsOULc_SINK )
    _OUTsTACKc_

    }
        }
                                                                                            #endif
            flagsState |= flSTACKsTATE_SHIFTlEFTuSED ;
                                                                                            #if !defined( STACKcLOADsOULc_SINK )
            }
                default : __1
                }
                    break ;
    
                    }
                        }
                                                                                            #endif
                            operator <<( pSoul ) ;
                                                                                            #else
                            if( !idSlot ) { DEL( pSoul ) ; }
                            sinkF( tinP , idSlot , pSoul , flagsP , pSubtractFP , subtractionParmP ) ;
                            ZE( countT , idSlot ) ;
                                                                                            #if defined( STACKcLOADsOULc_SINK )
                        {
                        if( pSoul )
                        soulC* pSoul = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) , pbs , flSOUL_null , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ; ___BITScT( pSoul , 0x128e ) ;
    
                        pbc += cbs ;
                        countT cbs = sizeof( countT ) + *(countT*)pbc ;
                        const byteT* const pbs = pbc ;
                    {
                    while( pbc < pbe )            
                {
                case ifcSTACKtYPE_PTR_soulC :
                }
                    break ;
        
                    }
                        (*pEther)( tinP , psEnv ) ;
                        }
                            }
                                *this << psttw ;
                                *psEnv >> psttw ; //*psEnv CONTAINS EXPORTABLE DATA; psttw WILL BE NONEXPORTABLE (USES LOCAL POINTERS IN sc_cADAM)
                                ZE( strokeS* , psttw ) ;
                            {
                            while( (countT)*psEnv )

                            soulP >> *psEnv ;
                        {
                        if( psEnv )
                        (*pEther)( tinP , psEnv , TAG( TAGiDnULL ) ) ;
                        ZE( soulC* , psEnv ) ;
                    {
                    if( pEther )
                    __Z( pEther ) ;
                    etherC* pEther = third.third_pEtherContainsMe_F() ;
                {
                case ifcSTACKtYPE_PTR_strokeS :
                }
                    break ;
    
                    }
                        pbc += cbData ? cbData : sizeof( countT ) + *(countT*)pbc ;
                                                                                            #endif
                        operator <<( pbc ) ;
                                                                                            #else
                        sinkF( tinP , countTC() , pbc , flagsP , pSubtractFP , subtractionParmP ) ;
                                                                                            #if defined( STACKcLOADsOULc_SINK )
                    {
                    while( pbc < pbe )
                {
                case ifcSTACKtYPE_BLOB :
                }
                    break ;
    
                    }
                        else __1
                        }
                            *(countT*)&idType = idTypeSave ;
                            }
                                }
                                                                                            #endif
                                    operator <<( (countT)pcv ) ;
                                                                                            #else
                                    if( !idSlot ) third.delF( tinP , pcv ) ;
                                    sinkF( tinP , idSlot , (countT)pcv , flagsP , pSubtractFP , subtractionParmP ) ;
                                    ZE( countT , idSlot ) ;
                                                                                            #if defined( STACKcLOADsOULc_SINK )
                                    }
                                        pcv[ off2 ] = *pci ; pci ++ ;
                                    {
                                    for( countT off2 = 0 ; off2 < cToDo ; off2 ++ )
                                {
                                if( pcv )
                                third.newF( tinP , LF , pcv , cToDo ) ; ___BITScT( pcv , 0x1290 ) ;
                                ZE( countT* , pcv ) ;
                            {
                            while( pci < pce )
                            *(countT*)&idType = ifcSTACKtYPE_countT ; //ASSUME: NO ACCESS BY OTHER THREADS WHILE IN ctF
                            countT idTypeSave = idType ;
    
                            __( cci - cPlatesi * cToDo ) ;
                            countT cToDo = idType + 2 - ifcSTACKtYPE_PTR_count2S ;
                        {
                        else if( idType >= ifcSTACKtYPE_PTR_count2S && idType <= ifcSTACKtYPE_PTR_count8S )
                        }
                            }
                                }
                                                                                            #endif
                                    operator <<( pNicName ) ;
                                                                                            #else
                                    if( !idSlot ) third.delF( tinP , pNicName ) ;
                                    sinkF( tinP , idSlot , pNicName , flagsP , pSubtractFP , subtractionParmP ) ;
                                    ZE( countT , idSlot ) ;
                                                                                            #if defined( STACKcLOADsOULc_SINK )
                                    }
                                        pNicName->pcId[ off2 ] = *pci ; pci ++ ;
                                    {
                                    for( countT off2 = 0 ; off2 < cToDo ; off2 ++ )
                                {
                                if( pNicName )
                                third.newF( tinP , LF , pNicName ) ; ___BITScT( pNicName , 0x1291 ) ;
                                ZE( nicNameC* , pNicName ) ;
                            {
                            while( pci < pce )
                            __( cci - cPlatesi * cToDo ) ;
                            countT cToDo = processGlobal2I.cb_nicNameC_ / sizeof( countT ) ;
                        {
                        else if( idType == ifcSTACKtYPE_PTR_nicNameC )
                        }
                                                                                            #endif
                            operator <<( tt ) ;
                                                                                            #else
                            sinkF( tinP , countTC() , tt , flagsP , pSubtractFP , subtractionParmP ) ;
                                                                                            #if defined( STACKcLOADsOULc_SINK )
                            tt.time2 = *pci ; pci ++ ;
                            tt.time1 = *pci ; pci ++ ;
                            timeS tt ;
                            __( cci - cPlatesi * cToDo ) ;
                            countT cToDo = sizeof( timeS ) / sizeof( countT ) ;
                        {
                        else if( idType == ifcSTACKtYPE_timeS )
                        //U:: }
                        //U::     }
                        //U::                                                                     #endif
                        //U::         operator <<( handle ) ;
                        //U::                                                                     #else
                        //U::         sinkF( tinP , countTC() , handle , flagsP , pSubtractFP , subtractionParmP ) ;
                        //U::                                                                     #if defined( STACKcLOADsOULc_SINK )
                        //U::             ((countT*)&handle)[ off2 ] = *pci ; pci ++ ; //CODE SYNC: 0050011 0030078 0030050: SIZEOF_handleC MUST BE MULTIPLE OF sizeof( countT )
                        //U::         for( countT off2 = 0 ; off2 < cToDo ; off2 ++ )
                        //U::         handleC handle( tinP ) ;
                        //U::     {
                        //U::     while( pci < pce )
                        //U::     __( cci - cPlatesi * cToDo ) ;
                        //U::     countT cToDo = SIZEOF_handleC / sizeof( countT ) ;
                        //U:: {
                        //U:: else if( idType == ifcSTACKtYPE_handleC )
                        }
                            }
                                                                                            #endif
                                operator <<( nn ) ;
                                                                                            #else
                                sinkF( tinP , countTC() , nn , flagsP , pSubtractFP , subtractionParmP ) ;
                                                                                            #if defined( STACKcLOADsOULc_SINK )
                                }
                                    nn.pcId[ off2 ] = *pci ; pci ++ ;
                                {
                                for( countT off2 = 0 ; off2 < cToDo ; off2 ++ )
                                nicNameC nn ;
                            {
                            while( pci < pce )
                            __( cci - cPlatesi * cToDo ) ;
                            countT cToDo = processGlobal2I.cb_nicNameC_ / sizeof( countT ) ;
                        {
                        else if( idType == ifcSTACKtYPE_nicNameC )
                        }
                            }
                                pci ++ ;
                                                                                            #endif
                                operator <<( *pci ) ;
                                                                                            #else
                                sinkF( tinP , countTC() , *pci , flagsP , pSubtractFP , subtractionParmP ) ;
                                                                                            #if defined( STACKcLOADsOULc_SINK )
                            {
                            while( pci < pce )
                            __( cci - cPlatesi ) ;
                        {
                        if( idType == ifcSTACKtYPE_countT || idType == ifcSTACKtYPE_sCountT || idType == ifcSTACKtYPE_measureT )
    
                        countT* const pce = pci + cci ;    
                        countT* pci = (countT*)pbc ;
                        countT cci = ( pbe - pbc ) / sizeof( countT ) ;
                    {
                    if( !third )
                    __( ( pbe - pbc ) % sizeof( countT ) ) ;
                {
                case ifcSTACKtYPE_PTR_count8S :
                case ifcSTACKtYPE_PTR_count7S :
                case ifcSTACKtYPE_PTR_count6S :
                case ifcSTACKtYPE_PTR_count5S :
                case ifcSTACKtYPE_PTR_count4S :
                case ifcSTACKtYPE_PTR_count3S :
                case ifcSTACKtYPE_PTR_count2S :
                case ifcSTACKtYPE_PTR_nicNameC :
                case ifcSTACKtYPE_timeS :
                //U::case ifcSTACKtYPE_handleC :
                case ifcSTACKtYPE_nicNameC :
                case ifcSTACKtYPE_measureT  :
                case ifcSTACKtYPE_sCountT   :
                case ifcSTACKtYPE_countT    :
            {
            switch( idType )
        {
        if( !third )

        }
            }
                __( cbDatai - cbData ) ;
                __( idTypei - idType ) ;
                __( flagsi  - flags  ) ;
            {
            else                                // (IF WO'TH CALL TO ME) soulC OBJECT IS FROM A FILE WHOSE NAME IS A PARAMETER TO THE CONSTRUCTOR
            }
                *(countT*)&cbData = cbDatai ;
                *(countT*)&idType = idTypei ;
                *(flagsT*)&flags  = flagsi ;
                __( idType ) ;
            {
            if( !flags )                       // (IF WO'TH CALL TO ME) soulC OBJECT IS A PARAMETER TO THE CONSTRUCTOR
            //CONJ: THIS BROKE THE soulC CONSTRUTOR OVERLOAD
            //WAS EDITED TO MAKE VARYING LENGTH BLOBS WORK
            //THE NEXT LINE USED cbData, BUT THIS CANNOT BE USED BECAUSE WILL BE 0 FOR VARYING LENGTH BLOB TYPE

            /*flagsStatei FROM soulP IS IGNORED */ //115005c 0050011 0010121: VERIFY THAT THIS MAKES SENSE FOR NEWLY DEFINED STATE FLAGS
            flagsT flagsStatei = *(flagsT*)pbc              ; pbc += sizeof( flagsT ) ; /*flagsStatei FROM soulP IS IGNORED */ //115005c 0050011 0010121: VERIFY THAT THIS MAKES SENSE FOR NEWLY DEFINED STATE FLAGS
            countT cbDatai     = *(countT*)pbc              ; pbc += sizeof( countT ) ;
            countT idTypei     = *(countT*)pbc              ; pbc += sizeof( countT ) ;
                   cPlatesi    = *(countT*)pbc              ; pbc += sizeof( countT ) ;
            flagsT flagsi      = *(flagsT*)pbc              ; pbc += sizeof( flagsT ) ;
        {
        if( idType != ifcSTACKtYPE_PTR_strokeS )
        ZE( countT , cPlatesi ) ;

        const byteT* const pbe = pbi + cbi ;
        const byteT* pbc = pbi ;
    {
    if( !third )

    }
        //cbi -- ;
        //pbi ++ ;
        //__( cbi < 1 + 5 * sizeof( countT ) ) ;
        //APPARENTLY OBSOLETE; NOT ANALYZED; COMMENTED OUT TO MAKE CHECKPOINTING WORK
        __( cbi < 5 * sizeof( countT ) ) ;
    
        __Z( cbi ) ;
        __Z( pbi ) ;
        soulP.shiftRightF( tinP , pbi , cbi , ifcIDtYPEsOULiTEM_byteTptr ) ;
    {
    if( idType != ifcSTACKtYPE_PTR_strokeS )
    ZE( byteT* , pbi ) ;
    //const byteT* const pbi = soulP.pbFieldF( tinP , countTC() , countTC() , cbi , 1 ) ;
    ZE( countT , cbi ) ;

    _INsTACKc_

    }
                                                                                            #endif
        if( third ) return ;
                                                                                            #else
        if( third ) return *this ;
                                                                                            #if !defined( STACKcLOADsOULc_SINK )
    {
    IFbEcAREFUL

                                                                                            #endif
    TINSL
                                                                                            #if !defined( STACKcLOADsOULc_SINK )
{
                                                                                            #endif
baseSoilXxxxC& stackC::operator <<( soulC& soulP )
                                                                                            #else
voidT stackC::sinkF( tinS& tinP , soulC& soulP , const flagsT flagsP , ifc4FT pSubtractFP , const countT subtractionParmP )
                                                                                            #if defined( STACKcLOADsOULc_SINK )

/*1*//*stackC:: load from soulP*//*1*/
/**/
*/
edited to remove the plate from soulP in order to make windowOldC snap and restore simple
obsolete: i do not remove the items in soulP
\<A HREF=\"5.0050011.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

