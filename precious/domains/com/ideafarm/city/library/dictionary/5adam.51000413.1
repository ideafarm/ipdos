
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.delF( tinP , postxNotFound ) ;

etThread.ifcDrivenServerF( tinP , i1 , i2 ) ;
serverInfo2S i2( 0x50 , flSOCKETc_null , TF2(thirdC::third_idAdamRootI_IF( tinP ),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , 0 , (countT)&c8p , 0 , - 1 , 1 , sizeof( stateS ) , translateStateF ) ;
serverInfo1S i1( &pbdVarying , b_pbdVarying , bHandedOff , sgnIdPortReplaced , tmcF , countTC() , ether ) ;

c8p.c6 = (countT)&lake ;
c8p.c5 = (countT)&costxNotFound ;
c8p.c4 = (countT)&postxNotFound ;
c8p.c3 = (countT)&dict ;
c8p.c2 = (countT)&b_pbdVarying ;
c8p.c1 = (countT)&pbdVarying ;
count8S c8p ;

dictionary1C dict( tinP , etThread ) ;

}
    costxNotFound = etThread.strMakeF( tinP , postxNotFound , t0+tnf ) ; ___( postxNotFound ) ;
    textC t0 = T("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\nContent-Length: ")+TF4(tnf.csF(tinP),flFORMAT_FILLzE|flFORMAT_NObASE|flFORMAT_FOREIGN,8,0xa)+T("\r\n\r\n") ;
    TN( tnf , "not found" ) ;
{
ZE( countT   , costxNotFound ) ;
ZE( osTextT* , postxNotFound ) ;
lakeC lake( tinP , etThread ) ;

ZE( boolT , bHandedOff ) ;
batonC b_pbdVarying( tinP , TAG( TAGiDnULL ) ) ;
ZE( byteT* , pbdVarying ) ;
signC sgnIdPortReplaced( tinP , TAG( TAGiDnULL ) ) ;

//etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_RUSH ) ;

etThread.strokeF( tinP , T("IdeaFarm " "(tm) City Http Server Lake\r\ni fill http requests using images in the lake\r\n\r\n") ) ;

TODO

DONEdRIVENsERVER( tmcF )
}
    }
        etThread.delF( tinP , posti ) ;
        pso->readF( tinP , posti , COSTiN , flSOCKETcrEAD_STILLhUNGRYiSoK ) ;
        etThread.newF( tinP , LF , posti , COSTiN ) ; ___( posti ) ;
        ZE( osTextT* , posti ) ;

        thirdC::logIF( tinP , ostoFile , nicNamePeer , 4 , count5S( 1 , 2 , 3 , 4 ) , (countT)&stPhrases , 1 ) ;
        OStEXTAK( ostoFile , ".log.port.05" ) ;
        OStEXTC( ostoFile , etherC::ifc_idHomeI_IF() , 0 ) ;
        OStEXTAK( ostoFile , "\\ideafarm." ) ;
        OStEXT( ostoFile , 0x100 )

        }
            lake.readCloseF( tinP , handle ) ;
            pso->writeF( tinP , postx , costx ) ;
        {
        else
        }
            stPhrases << postOldC( tinP , etThread , T(" notFound") ) ;
            pso->writeF( tinP , postxNotFound , costxNotFound ) ;
        {
        if( !postx )

        }
            lake.readF( tinP , postx , costx , handle , count3S( 1 , 1 ) , cSkip ) ; //SERVE HOME PAGE IF THE SPECIFIED PAGE IS NOT FOUND
            cSkip = 0 ;
        {
        if( !postx )

        etThread.delF( tinP , pcIdName ) ;
        if( *pcIdName ) lake.readF( tinP , postx , costx , handle , pcIdName , cSkip ) ;
        ZE( countT , cSkip ) ;
        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FISH ) ;
        ZE( countT , costx ) ;
        ZE( osTextT* , postx ) ;
    {
    if( !*tinP.zEtScratch )

    !tblKeyValue ;
    etThread.delF( tinP , psttPeer ) ;
    stPhrases << postOldC( tinP , etThread , T("name: ")+T(pcIdName)+T("\r\n") ) ;
    stPhrases << postOldC( tinP , etThread , T("peer: ")+T(nicNamePeer)+T("\r\n") ) ;
    stPhrases << postOldC( tinP , etThread , T("peer: \"")+T(psttPeer)+T("\"\r\n") ) ;
    readRequestF( tinP , etThread , *tinP.zEtScratch , *pso , pcIdName , tblKeyValue , std_pstt , psttPeer , nicNamePeer , dict ) ;
    stackC std_pstt( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    ZE( strokeS* , psttPeer ) ;

    tblKeyValue.newColF( tinP , T("value") ) ;
    tblKeyValue.newColF( tinP , T("key") ) ;
    tableC tblKeyValue( tinP , etThread , T("keyValue") ) ;

    b_pbdVarying.ungrabF( tinP ) ;
    }
        TN( t_cHamburgers , "" ) ; t_cHamburgers = TF3(++state.cHamburgers,0,8) ;
        TN( t_idMe        , "" ) ; t_idMe        = TF3(state.idMe,0,8) ;
        stateS& state = *(stateS*)pbdVarying ;
    {
    if( pbdVarying )
    b_pbdVarying.grabF( tinP , TAG( TAGiDnULL ) ) ;

    etThread.newF( tinP , LF , pcIdName , CCiDnAMEmAX + 1 ) ; ___( pcIdName ) ;
    ZE( countT* , pcIdName ) ;

    nicNameC nicNamePeer ;
    stackC stPhrases( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_byteT ) ;

    lakeC&       lake          =       *(lakeC*)c8p.c6 ;
    countT&      costxNotFound =      *(countT*)c8p.c5 ;
    osTextT*&    postxNotFound =    *(osTextT**)c8p.c4 ;
    dictionary1C& dict          = *(dictionary1C*)c8p.c3 ;
    batonC&      b_pbdVarying  =      *(batonC*)c8p.c2 ;
    byteT*&      pbdVarying    =      *(byteT**)c8p.c1 ;
    count8S&     c8p           =     *(count8S*)cArg ;
{
if( cArg )
TASKdRIVENsERVER( tmcF )

TRANSLATEsTATEdRIVENsERVER_END
    state.idMe ++ ;
TRANSLATEsTATEdRIVENsERVER_MIDDLE
    case 1 : { state.idMe        = stateOther.idMe        ; }
    case 2 : { state.cHamburgers = stateOther.cHamburgers ; }
TRANSLATEsTATEdRIVENsERVER_BEGIN( stateS , 2 )

}
    etThread.delF( tinP , psttName ) ;
    etThread.delF( tinP , psttAction ) ;
    }
        }
            tinP.zEtScratch->delF( tinP , psttNameTrimmed ) ;

            if( offi < CCiDnAMEmAX ) pcIdNameP[ offi ++ ] = 0 ;
            }
                tinP.zEtScratch->delF( tinP , psttw ) ;
                else                         __1
                if( offi < CCiDnAMEmAX - 1 ) pcIdNameP[ offi ++ ] = tinP.zEtScratch->strDigitsToSCountF( tinP , psttw ) ;
                tinP.zEtScratch->strSubstringF( tinP , psttw , idf , sttq , sttDot , psttNameTrimmed ) ; ___( psttw ) ;
                ZE( strokeS* , psttw ) ;
            {
            while( !*tinP.zEtScratch && idf )
            strokeS sttDot( '.' ) ;
            //sttq = ze ;
            idf = 1 ;
            ZE( countT , offi ) ;

            tinP.zEtScratch->strSubstringF( tinP , psttNameTrimmed , idf , idl , psttName ) ; ___( psttNameTrimmed ) ;
            ZE( strokeS* , psttNameTrimmed ) ;
            //sttq = ze ;
            countT idl = idDot0 ? idDot0 - 1 : 0 ;
            idf = 2 ;

            __( psttName->idAdam - 1 - idDot0 ) ;
            countT idDot0 = tinP.zEtScratch->strIdF( tinP , countTC( 1 ) , sttq , tDot0 , psttName , 0 , - 1 ) ;
            TN( tDot0 , ".0" ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        else
        }
            pcIdNameP[ 2 ] = 0 ;
            pcIdNameP[ 1 ] = 1 ;
            pcIdNameP[ 0 ] = 1 ;
        {
        if( psttName->idAdam == 1 )
        __( tinP.zEtScratch->strIdF( tinP , sttSlash , psttName ) - 1 ) ;
        __( !psttName->idAdam ) ;
    {
    if( !*tinP.zEtScratch && !etThread )
    __Z( psttName ) ;

    }
        etThread.delF( tinP , pstt1e ) ;
        }
            tblKeyValueP.newObjectF( tinP , psttv ) ;
            tblKeyValueP.newObjectF( tinP , psttk ) ;
            tblKeyValueP.newEventF( tinP ) ;

            std_psttP << psttv ;
            std_psttP << psttk ;

            etThread.strFromUrlF( tinP , psttv ) ; ___( psttv ) ;
            etThread.strFromUrlF( tinP , psttk ) ; ___( psttk ) ;

            etThread.strSubstringF( tinP , psttv , idf , sttq , sttEq , psttc1 ) ; ___( psttv ) ;
            etThread.strSubstringF( tinP , psttk , idf , sttq , sttEq , psttc1 ) ; ___( psttk ) ;
            ZE( strokeS* , psttv ) ;
            ZE( strokeS* , psttk ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        FORsTRINGSiN1( pstt1e )
        strokeS sttEq( '=' ) ;
        etThread.delF( tinP , psttBody ) ;
        etThread.strWordsOldF( tinP , pstt1e , psttBody , sttq , T("&") ) ; ___( pstt1e ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , pstt1e ) ;
        etThread.strMakeF( tinP , psttBody , T(postBody) ) ; ___( psttBody ) ; //ASSUME: psttBody IS OF FORM T("aaaa=1111&bbbb=2222&cccc=3333&dddd=4444")
        ZE( strokeS* , psttBody ) ;
        if( postBody ) postBody[ costBody ] = 0 ;
        sInP.readF( tinP , postBody , costBody ) ;
        etThread.newF( tinP , LF , postBody , costBody + 1 ) ;
        ZE( osTextT* , postBody ) ;
    {
    if( !*tinP.zEtScratch && costBody )

    }
        tinP.zEtScratch->delF( tinP , psttl ) ;
        }
            break ;
            tinP.zEtScratch->delF( tinP , psttl ) ;
        {
        else
        }
            tinP.zEtScratch->delF( tinP , psttValue ) ;
            tinP.zEtScratch->delF( tinP , psttKey ) ;
            if( !tinP.zEtScratch->strCompareF( tinP , tContentLength , psttKey ) ) costBody = tinP.zEtScratch->strDigitsToSCountF( tinP , psttValue , 0xa , 1 ) ;
            tinP.zEtScratch->strSubstringF( tinP , psttValue , idf , idl , psttl ) ; ___( psttValue ) ;
            ZE( countT , idl ) ;
            tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttKey ) ; ___( psttKey ) ;
            tinP.zEtScratch->strSubstringF( tinP , psttKey , idf , sttq , tColonWhite , psttl , 1 ) ; ___( psttKey ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttValue ) ;
            ZE( strokeS* , psttKey ) ;
        {
        else if( psttl && psttl->idAdam )
        }
            tinP.zEtScratch->strWordF( tinP , psttName , psttl , sttq , sttb , 2 ) ; ___( psttName ) ;
            //sttq = ze ;

            tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttl ) ; ___( psttl ) ;
            tinP.zEtScratch->strWordF( tinP , psttAction , psttl , sttq , sttb , 1 ) ; ___( psttAction ) ;
        {
        if( !psttAction )
        sInP.readWoLineF( tinP , psttl , 0x200 ) ; ___( psttl ) ;
        ZE( strokeS* , psttl ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    {
    while( !*tinP.zEtScratch && !etThread )
    ZE( countT , costBody ) ;
    ZE( strokeS* , psttName ) ;
    ZE( strokeS* , psttAction ) ;
    strokeS sttSlash( '/' ) ;
    strokeS sttb( ' ' ) ;
    TN( tContentLength , "content-length" ) ;
    TN( tColonWhite , ": " ) ;

    etThread.sockPsttHostF( tinP , psttPeerP , nicNamePeerP ) ; ___( psttPeerP ) ;
    { ZE( countT , idp ) ; sInP.peerNameF( tinP , idp , nicNamePeerP ) ; }
{
voidT readRequestF( tinS& tinP , etherC& etThread , socketC& sInP , countT* pcIdNameP , tableC& tblKeyValueP , stackC& std_psttP , strokeS*& psttPeerP , nicNameC& nicNamePeerP , dictionary1C& dictP )

*/
 terminate pcIdNameP with a 0
  if     begin with '$': look up the word in the dictionary; if not found, use -1
  if not begin with '$': else        : - 1
  if not begin with '$': if <= 8 char: convert the word to a countT 
 convert each '.' delimited word to a countT value and place that value in pcIdNameP[]
 obtain the request that is either "/ " or "/aaaaaaaa.bbbbbbbb.cccccccc.<...>.zzzzzzzz.0 "
 read at least the wo'th line of the request
 captures domain name of peer
pseudocode
/*

#define CCiDnAMEmAX 0x10
#define COSTiN 0x1000
#define CsLOTpSO 0x4

;
}
    countT cHamburgers ;
    countT idMe ;
    countT idVersion ;
{
struct stateS

/*1*/WAKEhIDE( "city.driven.server.port05" )/*1*/
/**/
*/
obsoleted by 7340104
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

