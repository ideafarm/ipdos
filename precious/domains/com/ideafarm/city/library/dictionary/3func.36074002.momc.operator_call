
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return (count01T)codeBetter ;
    //return code ;
    }
        deltaOverflowFix = 0 ;
        for( countT off = 0 ; off < offEnd ; off ++ ) pcCursor[ off ] -= deltaOverflowFix ;
        countT offEnd = sizeof pcCursor / sizeof pcCursor[ 0 ] ;
    {
    if( deltaOverflowFix )
    rememberF( tinP , bP ) ;

    if( !code ) code = (count01T)( 0xff00 + bP ) ;                                               //         IF DIDN'T FIND A PRIOR OCCURRANCE THEN ENCODE AS LITERAL

    if( codeBetter & 0xffff0000 ) { BLAMMO ; }

    ;
        : - codeBetter                                                                           // MAKE POSITIVE [1,cbCircle]: A:ASSUME: cbCircle < 0xff00
        ? 0xff00 + bP                                                                            // NO PRIOR OCCURRANCE SO ENCODE AS LITERAL
    codeBetter = !codeBetter

    countT codeBetter = circle.findF( bP ) ;

    }
        }
            pbFrame = ppbFrame[ stFrame - idFrameNew + idFrame ] ;
            idFrame = 1 + off / CBfRAMEsPOUSE ;
        {
        if( !( off % CBfRAMEsPOUSE ) )

        if( off == offLooped ) break ;

        if( ++ off == offNew ) off = offMin ;

        }
            break ;
            if( ++ off > offNew ) off = offMin ;
            code = (count01T)( offNew - off ) ;                                                  //         SET THE CODE TO ITS DISTANCE BACK FROM THE END
        {
        if( pbFrame[ off % CBfRAMEsPOUSE ] == bP )                                               //         IF FOUND A BYTE CONTAINING THE VALUE TO BE ENCODED
    {
    while( off < offNew )                                                                        //         SEARCH OVER [off,offNew)

    byteT* pbFrame = ppbFrame[ stFrame - idFrameNew + idFrame ] ;                                //         ? FRAME THAT CONTAINS THE BYTE AT OFFSET off ?
    countT idFrame = 1 + off / CBfRAMEsPOUSE ;                                                   //N1       FRAME THAT CONTAINS THE BYTE AT OFFSET off
    const countT offLooped = off ;                                                               //N1
    if( off < offMin ) off = offMin ;                                                            //         CONSTRAIN off TO BE >= MIN
    countT& off = pcCursor[ bP ] ;                                                               //N1       USE THE VALUE TO SELECT A CURSOR ELEMENT
    const countT offMin = ( idFrameMin - 1 ) * CBfRAMEsPOUSE ;                                   //N1       OLDEST BYTE STILL AVAILABLE
    const countT idFrameMin = idFrameNew <= CfRAMESsPOUSE ? 1 : 1 + idFrameNew - CfRAMESsPOUSE ; //N1       OLDEST FRAME STILL AVAILABLE
    const countT idFrameNew = 1 + offNew / CBfRAMEsPOUSE ;                                       //N1       CURRENT FRAME
    ZE( count01T , code ) ;
    _IO_

    }
        if( ether ) return 0 ;
    {
    IFbEcAREFUL    
{
/*1*/count01T momC::operator ()( tinS& tinP , const byteT bP )/*1*/
/**/
*/
the distance back to the earliest remembered occurrance of the byte value is used as its encoded value
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

