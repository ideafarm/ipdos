
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bGrabbed ;

    //}
    //    CONoUTrAW( os ) ;
    //
    //    OStEXTAK(  os , "\r\n" ) ;
    //    }
    //        if( offi % 5 == 3 ) { OStEXTAK(  os , "]" ) ; }
    //        OStEXTC(   os , tinP.pPanLifiRecurseGrabbedLevel[ offi ] , 0 ) ;
    //        else { OStEXTAK(  os , "," ) ; }
    //        }
    //            else { OStEXTAK(  os , " [" ) ; }
    //            }
    //                continue ;
    //                offi += 4 ;
    //            {
    //            if( !tinP.pPanLifiRecurseGrabbedLevel[ offi ] )
    //        {
    //        if( !( offi % 5 ) )
    //    {
    //    for( countT offi = 0 ; offi < sizeof tinP.pPanLifiRecurseGrabbedLevel / sizeof tinP.pPanLifiRecurseGrabbedLevel[ 0 ] ; offi ++ )
    //
    //    OStEXTAK( os , "} @@@@" ) ;
    //    OStEXTC(  os , idiFileCt , 0 ) ;
    //    OStEXTAK( os , "," ) ;
    //    OStEXTC(  os , idLineCt , 0 ) ;
    //    OStEXTAK( os , "," ) ;
    //    OStEXTC(  os , this , 0 ) ;
    //    OStEXTAK( os , " | {" ) ;
    //    OStEXTA(  os , tinP.postThreadName ) ;
    //    OStEXTAK( os , " " ) ;
    //    OStEXTC(  os , tinP.monitor.idThread , 0 ) ;
    //    OStEXTAK( os , " | " ) ;
    //    OStEXTC9( os , tinP.osTid ) ;
    //    OStEXTAK( os , " | " ) ;
    //    OStEXTC(  os , idInDebug , '0' ) ;
    //    OStEXT(   os , TUCK << 2 ) ;
    //{
    //if( tinP.pAdamGlobal1->idAdam == 0x4010501 )

    //if( F(tinP.flagsThreadMode2) & flTHREADmODE2_ADAMmAINtHREAD ) { CONoUTrAW3( "" , tinP.pAdamGlobal1->idAdam , " G-\r\n" ) ; }
    //if( tinP.monitor.idThread == 1 ) { CONoUTrAW3( "" , tinP.pAdamGlobal1->idAdam , " G-\r\n" ) ; }
    //CONoUTrAW( "-" ) ;
    //if( (countT)this == etherC::ether_cUtility_IF( tinP , 0 ) ) { LOGrAWtID( "G-" ) ; }
    if( pbBitsP ) ; //U::

    }
        registerDoneF( tinP , idLineP , idiFileP ) ;

        }
            _OUT_
            }
                thirdC::dosPriorityIF( tinP , idDesireSave ) ;

                }
                    inc02AM( stat.cAcquisitions ) ;
                    }
                        _OUT_
                        else                             osTid = osTidMe ;
                        if( osTid )                      { BLAMMO ; }
                        else                             idDesireGrabber  = tinP.idDesire ;
                        if( idDesireGrabber )            { BLAMMO ; }
                        if( cGrabbed == - 1 )            { BLAMMO ; }
                        inc02AM( cGrabbed ) ;
                        if( cGrabbed )                   { BLAMMO ; }
                        if( idGrabberOk != idGrabberMe ) { BLAMMO ; }
                        stat.cCollisionsNew = 0 ; //U:MIGHT OVERWRITE A FEW COLLISIONS THAT SHOULD BE COUNTED AS NEW (I.E. SINCE INCREMENTING idGrabberOk)
            
                        processGlobal1I._grabC_pgw[ ogw ].osTid = 0 ; //MUST BE ZEED LATH; NOTE THAT bDirty IS NOT RESET
                        processGlobal1I._grabC_pgw[ ogw ].osPid = 0 ;
                        processGlobal1I._grabC_pgw[ ogw ].idGrabber = 0 ;
                        processGlobal1I._grabC_pgw[ ogw ].idGrab = 0 ;
                        }
                            _OUT_
                            processGlobal1I._grabC_pgw[ ogw ].hThread.closeIfF() ;
                            _INoLD_
                        {
                        processGlobal1I._grabC_pgw[ ogw ].idThread = 0 ;
                        processGlobal1I._grabC_pgw[ ogw ].flags = 0 ;
                        processGlobal1I._grabC_pgw[ ogw ].bDirty = 1 ;
        
                        }
                            thirdC::dosWriteStdOutIF( ostoBuf ) ;
                            OStEXTA( ostoBuf , "\r\n" ) ;
                            OStEXTA( ostoBuf , tinP.postThreadName ) ;
                            OStEXTA( ostoBuf , " " ) ;
                            OStEXTC( ostoBuf , tinP.monitor.idThread , 0 ) ;
                            OStEXTA( ostoBuf , "THAWED " ) ;
                            OStEXT( ostoBuf , 0x140 )
                        {
                        if( F(processGlobal1I._grabC_pgw[ogw].flags) & flGRABwANT_CHATTERrESUME )

                        thirdC::dosSuspendThreadIF( tinP ) ;
                        bDebugWentToSleep = 1 ;

                        }
                            thirdC::dosWriteStdOutIF( ostoBuf ) ;
                            OStEXTA( ostoBuf , "\r\n" ) ;
                            OStEXTA( ostoBuf , tinP.postThreadName ) ;
                            OStEXTA( ostoBuf , " " ) ;
                            OStEXTC( ostoBuf , tinP.monitor.idThread , 0 ) ;
                            OStEXTA( ostoBuf , "FROZEN " ) ;
                            OStEXT( ostoBuf , 0x140 )
                        {
                        if( F(processGlobal1I._grabC_pgw[ogw].flags) & flGRABwANT_CHATTERrESUME )
                        _INoLD_
                    {
                    else
                    }
                        _OUT_
                        THREADmODE1rESTORE
                        }
                            }
                                break ;
        
                                else                             osTid = osTidMe ;
                                if( osTid )                      { BLAMMO ; }
                                else                             idDesireGrabber  = tinP.idDesire ;
                                if( idDesireGrabber )            { BLAMMO ; }
                                if( cGrabbed == - 1 )            { BLAMMO ; }
                                inc02AM( cGrabbed ) ;
                                if( cGrabbed )                   { BLAMMO ; }
                                stat.cCollisionsNew = 0 ; //U:MIGHT OVERWRITE A FEW COLLISIONS THAT SHOULD BE COUNTED AS NEW (I.E. SINCE INCREMENTING idGrabberOk)
                            {
                            if( idGrabberOk == idGrabberMe )
                            ++ s ; thirdC::dosSleepRawIF( tinP , 0x20 ) ;
                            //CONoUTrAW( "z" ) ;
                        {
                        for(;;)
                        ZE( countT , idNap ) ;
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                        bDebugNoSlotForMe = 1 ;
                        _INoLD_
                    {
                    if( !bSlotted )

                    //if( tinP.pEther ) { LOGrAW( T("\r\ngrabC ")+TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(" collision!    ")+TF3(tinP.monitor.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(tinP.postThreadName) ) ; } //TO FIND A BUG
        
                    inc02AM( stat.cCollisionsNew ) ;
                    inc02AM( stat.cCollisions ) ;
        
                    //if( idMe == 0xd18 ) { CONoUTrAW( " -\r\n" ) ; } //U::
                    }
                        }
                            break ;
                            }
                                bSlotted = 1 ;
        
                                processGlobal1I._grabC_pgw[ ogw ].bDirty = 0 ;
                                processGlobal1I._grabC_pgw[ ogw ].idThread = tinP.monitor.idThread ;
                                processGlobal1I._grabC_pgw[ ogw ].osPid = tinP.osPid ;
                                processGlobal1I._grabC_pgw[ ogw ].idGrabber = idGrabberMe ; // SCANNER LOOKS FOR THESE OO VALUES
                                processGlobal1I._grabC_pgw[ ogw ].idGrab = idMe ;           // SCANNER LOOKS FOR THESE OO VALUES
                                processGlobal1I._grabC_pgw[ ogw ].flags = F(tinP.flagsThreadMode2) & flTHREADmODE2_CHATTERgRABwANTfREEZES ? flGRABwANT_CHATTERrESUME : flGRABwANT_null ;
                            {
                            else
                            }
                                processGlobal1I._grabC_pgw[ ogw ].osTid = 0 ;
                                //LOGrAWtID( "i could not clone a thread handle to myself" ) ; //U:: USED TO BLAMMO HERE; TO MAKE SERVER RELIABLE, I NOW JUST ABANDON SLOTTING
                                CONoUTrAW( "i could not clone a thread handle to myself\r\n" ) ; //U:: USED TO BLAMMO HERE; TO MAKE SERVER RELIABLE, I NOW JUST ABANDON SLOTTING
                            {
                            if( !processGlobal1I._grabC_pgw[ ogw ].hThread )
                            processGlobal1I._grabC_pgw[ ogw ].hThread.osF( ifcIDtYPEhANDLE_THREAD , (countT)osh ) ;

                            countT osh = thirdC::osHandleCloneIF( tinP , note , oshtMe , ifcIDtYPEhANDLE_THREAD , oshpMe , oshpMe ) ;

                            countT oshtMe = thirdC::osOpenThreadIF() ;
                            ZE( countT , note ) ;
                            countT oshpMe = hProcessMe.osF( ifcIDtYPEhANDLE_PROCESS ) ;
                            hProcessMe.osF( ifcIDtYPEhANDLE_PROCESS , thirdC::osOpenProcessIF() ) ;
                            handleC hProcessMe( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_PROCESS ) ;
    
                            if( !processGlobal1I._grabC_pgw[ ogw ].bDirty    ) { BLAMMO ; }
                            if(  processGlobal1I._grabC_pgw[ ogw ].idGrabber ) { BLAMMO ; }
                            if(  processGlobal1I._grabC_pgw[ ogw ].idGrab    ) { BLAMMO ; }
                        {
                        if( !setIfZeAM( processGlobal1I._grabC_pgw[ ogw ].osTid , osTidMe ) ) //ASSUME: IF !osTid THEN THE SLOT IS FREE (I.E. osTid IS THE LATH TO BE ZEED)
                    {
                    if( F(flags) & flGRABc_ISsIGN || !( F(tinP.pAdamGlobal1->_thirdC_.flagsModeAdam1) & flADAMmODE1_LOGdEADLOCKS ) ) for( ogw = 0 ; ogw < processGlobal1I._grabC_cgw ; ogw ++ )
                    ZE( countT , ogw ) ;
                    ZE( boolT , bSlotted ) ;
                {
                else
                }
                    inc02AM( stat.cAcquisitions ) ;
                    else        osTid = osTidMe ;
                    if( osTid ) { BLAMMO ; }
                    if( cGrabbed == - 1 )            { BLAMMO ; }
                    inc02AM( cGrabbed ) ;
                    if( cGrabbed )                   { BLAMMO ; }
                    stat.cCollisionsNew = 0 ; //U:MIGHT OVERWRITE A FEW COLLISIONS THAT SHOULD BE COUNTED AS NEW (I.E. SINCE INCREMENTING idGrabberOk)
                    //CODE SYNCH: 17f0005 1700003
    
                    idDesireGrabber    = tinP.idDesire ;
                    idiFileGrabberNote = 0/*U::*/ ;
                    idLineGrabberNote  = 0/*U::*/ ;
                    idiFileGrabber     = idiFileP ; //SINCE THESE VALUES ARE RETAINED WHEN NOT GRABBED, THE MONITOR CAN SEE WHICH GRAB LINES ARE CURRENTLY ACTIVE
                    idLineGrabber      = idLineP ; //THESE ARE INFORMATORY ONLY; THEY ARE NOT RESET; THEY ARE OVERWRITTEN HERE
                    //if( idMe == 0xd18 ) { CONoUTrAW3( "G " , idGrabberMe , "\r\n" ) ; } //U::
                    bDebugGoodTiming = 1 ;
                {
                if( idGrabberOk == idGrabberMe )
    
                countT idGrabberMe = 1 + incv02AM( idGrabberHigh ) ;
                                                                         //U:: EDIT THIS CODE SO THAT THE RACE IS AVOIDED WHILE ONLY CHANGING PRIORITY WHEN I NEED TO REGISTER
                thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ; //THIS IS ONLY NEEDED FOR THE REGISTRATION BLOCK, WHICH I USUALLY WON'T EXECUTE (SINCE USUALLY idGrabberOk == idGrabberMe) ; BUT IF I PUT IT THERE, THAT CREATES A RACE CONDITION: AFTER OBTAINING idGrabberMe BUT BEFORE REGISTERING MYSELF, A RUDE THREAD MIGHT YIELD SPIN TRYING TO KISS ME WITH THE SPIN PREVENTING ME FROM REGISTERING MYSELF 
                const countT idDesireSave = thirdC::dosPriorityIF( tinP ) ;

                registerBegunF( tinP , idLineP , idiFileP ) ;
            {
            else
            }
                if( cGrabbed == - 1 ) { BLAMMO ; }
                inc02AM( cGrabbed ) ;
                bDebugAlreadyMine = 1 ;
                registerBegunF( tinP , idLineP , idiFileP , flBASEgRABcrEGISTERbEGUN_RECURSING ) ;
            {
            if( osTid == osTidMe && !( F(flags) & flGRABc_DISABLErECURSION ) )
            ZE( boolT , bDebugNoSlotForMe ) ;
            ZE( boolT , bDebugWentToSleep ) ;
            ZE( boolT , bDebugGoodTiming ) ;
            ZE( boolT , bDebugAlreadyMine ) ;
        
            if( !osTidMe ) { BLAMMO ; }
            const countT osTidMe = tinP.osTid ;
        
            if( F(tinP.pAdamGlobal1->_thirdC_.flagsModeAdam1) & flADAMmODE1_DISALLOWgRABoFiNTERPROCESSgRABs && F(flags) & flGRABc_INTERpROCESS ) { BLAMMO ; }
            if( F(tinP.flagsThreadMode1     ) &   flTHREADmODE1_DISALLOWgRABoFiNTERPROCESSgRABs && F(flags) & flGRABc_INTERpROCESS ) { BLAMMO ; }
            if( F(flags) & flGRABc_DISABLED ) { BLAMMO ; }
    
            _INoLD_
        {
        else
        }
            cGrabbed ++ ;

            registerBegunF( tinP , idLineP , idiFileP ) ;
        {
        if( this == &tinP.grabPseudo )
    {
    if( bGrabbed )

    }
        }
            }
                }
                    break ;
                    bGrabbed = 0 ;
                {
                else if( vv == setIfEqualsAM( stat.cKissBank , vv - 1 , vv ) )
                if( !vv ) break ;
                countT vv = stat.cKissBank ;
            {
            for(;;)
        {
        else
        }
            }
                }
                    break ;
                    bGrabbed = 0 ;
                {
                else if( vv == setIfEqualsAM( stat.cKissBank , 0 , vv ) )
                if( !vv ) break ;
                countT vv = stat.cKissBank ;
            {
            for(;;)
        {
        if( F(flagsP) & flGRABcGRABf_CLEARkISSbANK )
    {
    if( F(flagsP) & flGRABcGRABf_WITHDRAWkISSiF )
    boolT bGrabbed = 1 ;

    }
        thirdC::dosPriorityIF( tinP , idDesireSave ) ;
        tinP.cYield = 0 ;
        while( osTidLock ) thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) ) ;
        tinP.cYield = 0 ;
        ZE( countT , idCycle ) ;

        thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;
        const countT idDesireSave = thirdC::dosPriorityIF( tinP ) ;
    {
    if( osTidLock && osTidLock != tinP.osTid ) //NO OTHER THREAD GETS TO BEGIN THE GRAB RECIPE UNTIL THE LOCKER DOES HIS THANG (USUALLY GRABBING)

    //}
    //    CONoUTrAW( os ) ;
    //
    //    OStEXTAK(  os , "\r\n" ) ;
    //    }
    //        if( offi % 5 == 3 ) { OStEXTAK(  os , "]" ) ; }
    //        OStEXTC(   os , tinP.pPanLifiRecurseGrabbedLevel[ offi ] , 0 ) ;
    //        else { OStEXTAK(  os , "," ) ; }
    //        }
    //            else { OStEXTAK(  os , " [" ) ; }
    //            }
    //                continue ;
    //                offi += 4 ;
    //            {
    //            if( !tinP.pPanLifiRecurseGrabbedLevel[ offi ] )
    //        {
    //        if( !( offi % 5 ) )
    //    {
    //    for( countT offi = 0 ; offi < sizeof tinP.pPanLifiRecurseGrabbedLevel / sizeof tinP.pPanLifiRecurseGrabbedLevel[ 0 ] ; offi ++ )
    //
    //    OStEXTAK( os , "} ++++" ) ;
    //    OStEXTC(  os , idiFileCt , 0 ) ;
    //    OStEXTAK( os , "," ) ;
    //    OStEXTC(  os , idLineCt , 0 ) ;
    //    OStEXTAK( os , "," ) ;
    //    OStEXTC(  os , this , 0 ) ;
    //    OStEXTAK( os , " | {" ) ;
    //    OStEXTA(  os , tinP.postThreadName ) ;
    //    OStEXTAK( os , " " ) ;
    //    OStEXTC(  os , tinP.monitor.idThread , 0 ) ;
    //    OStEXTAK( os , " | " ) ;
    //    OStEXTC9( os , tinP.osTid ) ;
    //    OStEXTAK( os , " | " ) ;
    //    OStEXTC(  os , idInDebug , '0' ) ;
    //    OStEXT(   os , TUCK << 2 ) ;
    //
    //    idInDebug = 1 + incv02AM( idInDebugLath ) ;
    //    static countT idInDebugLath ;
    //{
    //if( tinP.pAdamGlobal1->idAdam == 0x4010501 )
    //ZE( countT , idInDebug ) ;

    }
        //}
        //    //LOGrAWtID2( "batonC::grabF called by ... by " , idi1 ) ;
        //{
        //)
        //    idi0 == 0x4000a01
        //(
        //if
        //ALL OF THE idAdam CASE VALUES ARE OBSOLETED: 0xghij104 -> 0x401jihg -> 0x400jihg -> list.map -> 0x51000zzz
        countT idi3 = IDIfILEcALLER( 3 ) ;
        countT idi2 = IDIfILEcALLER( 2 ) ;
        countT idi1 = IDIfILEcALLER( 1 ) ;
        countT idi0 = IDIfILEcALLER( 0 ) ;
    {
    IFwHEREiSwATCHING
    //U::
    //if( F(tinP.flagsThreadMode2) & flTHREADmODE2_ADAMmAINtHREAD ) { CONoUTrAW3( "" , tinP.pAdamGlobal1->idAdam , " G+\r\n" ) ; }
    //CONoUTrAW( "+" ) ;

    SCOOP
{
/*1*/boolT grabC::grabF( tinS& tinP , const countT idLineP , const countT idiFileP , const byteT* const pbBitsP , const flagsT flagsP )/*1*/
/**/
*/
\<A HREF=\"5.17f0005.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$grabF.0.html\"\>instances\</A\>
     write my data
     remove myself from the wanter array
     suspend myself
    else   
    if i cannot register myself in the wanter array: sleep loop until i am the ok, and then insert my data
   else
   if i am the ok: write my data into fields
  else
  if i already have it then just increment cGrabbed
 else
 if kiss bank balance decrement kiss bank and return
 wait for tid lock to clear
pseudocode
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

