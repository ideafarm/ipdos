
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cWrap ;
    _OUT_
    tinP.pAdamGlobal5->frPaper.grab.ungrabF( tinP ) ;
    }
        if( POOP ) POOPR ;

        }
            }
                ether.delF( tinP , pstt1w ) ;
                ether.delF( tinP , psttDelim ) ;
                }
                    }
                        renderF( tinP , pulp , psttc1 , phCloneP ) ;
        
                        }
                            }
                                cWrap ++ ;
                                renderF( tinP , pulp , psttw , phCloneP ) ;

                                psttw[ CSpREFIX + 1 ] = sttlf ;
                                psttw[ CSpREFIX     ] = sttcr ;
                                SETpREFIX( psttw , 2 , 0 ) ;
                                strokeS psttw[ CSpREFIX + 2 ] ;
                            {
                            if( mIdColEnd <= mIdColRight ) //HITTING THE COLUMN JUST OUTSIDE OF THE STROKING FRAME TRIGGERS WRAP
            
                            }
                                mIdColRight = mIdColWord - 1.0 + mColsWord ;
                                psfd->bWrap = bWrapSave ;
                                pulp.flagsMode = flSave ;
                                psfd = (strokingFrameS*)&pulp.stqr_strokingFrame[ 2 + pulp.rCache.offFrame + pulp.rCache.offFrameWrap ] ;
    
                                pulp.boundingRectF( tinP , mIdColWord , mIdRowWord , mColsWord , mRowsWord , T(psttc1) , phCloneP , pczIdAdamSnapP ) ; //DOES SNAP/RESTORE, SO psfd BECOMES A ZOMBIE
    
                                const flagsT flSave = pulp.flagsMode ; pulp.flagsMode |= flPULPmODE_RIPPLESoNLY ;
        
                                psfd->bWrap = 0 ;
                                countT bWrapSave = psfd->bWrap ;
                                ZE( measureT , mRowsWord ) ;
                                ZE( measureT , mColsWord ) ;
                                ZE( measureT , mIdRowWord ) ;
                                ZE( measureT , mIdColWord ) ;
                            {
                            ZE( measureT , mIdColRight ) ;
    
                            const measureT mIdColEnd = psfd->mIdCol + psfd->mCols ;
                        {
                        if( psfd->bWrap )
                        strokingFrameS* psfd = (strokingFrameS*)&pulp.stqr_strokingFrame[ 2 + pulp.rCache.offFrame + pulp.rCache.offFrameWrap ] ;
                        pulpOldC& pulp = *papers.selectF( tinP , ifcIDcMDpAPERsELECT_QUERYrENDER ).x1.pPulp ;
                    {
                    else
                    if( ether.strIdF( tinP , psttc1[ CSpREFIX ] , psttDelim ) ) renderF( tinP , *papers.selectF( tinP , ifcIDcMDpAPERsELECT_QUERYrENDER ).x1.pPulp , psttc1 , phCloneP ) ;
                {
                FORsTRINGSiN1( pstt1w ) //EACH STRING IS EITHER A WORD OR A DELIMITER SNIP
        
                }
                    ether.strWordsOldF( tinP , pstt1w , psttP , sttq , psttDelim , flSTRwORDS_DELIMITERS ) ; ___( pstt1w ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                {
                ZE( strokeS* , pstt1w ) ;
        
                strokeS sttlf = S2('\n',sc_cALPHABET1) ;
                strokeS sttcr = S2('\r',sc_cALPHABET1) ;
            {
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ether.strFuseF( tinP , psttDelim , S2(0,scOld_POPpAPERoVERRIDE) ) ;
            ether.strFuseF( tinP , psttDelim , S2(0,scOld_POPpAPERoVERRIDE) ) ;
            ether.strFuseF( tinP , psttDelim , S2(8,scOld_cPUSHpAPERoVERRIDE) ) ;
            ether.strFuseF( tinP , psttDelim , S2(7,scOld_cPUSHpAPERoVERRIDE) ) ;
            ether.strFuseF( tinP , psttDelim , S2(6,scOld_cPUSHpAPERoVERRIDE) ) ;
            ether.strFuseF( tinP , psttDelim , S2(5,scOld_cPUSHpAPERoVERRIDE) ) ;
            ether.strFuseF( tinP , psttDelim , S2(4,scOld_cPUSHpAPERoVERRIDE) ) ;
            ether.strFuseF( tinP , psttDelim , S2(3,scOld_cPUSHpAPERoVERRIDE) ) ;
            ether.strFuseF( tinP , psttDelim , S2(2,scOld_cPUSHpAPERoVERRIDE) ) ;
            ether.strFuseF( tinP , psttDelim , S2(1,scOld_cPUSHpAPERoVERRIDE) ) ;
            ether.strFuseF( tinP , psttDelim , S2(0,scOld_cPUSHpAPERoVERRIDE) ) ;
            ether.strFuseF( tinP , psttDelim , S2(' ',sc_NULL) ) ;
            ether.strMakeF( tinP , psttDelim , T(" ") , TUCK ) ; ___( psttDelim ) ;
            ZE( strokeS* , psttDelim ) ;

            //U::HARDCODED TO WORK CORRECTLY IF PAPER [n] IS PUSHED FOR LOW [n]; NEED TO SUPPORT ALL POSSIBLE VALUES FOR idAdam I.E. WILDCARD
        {
        if( psttP->idAdam )
        tinP.pAdamGlobal5->frPaper.grab.grabF( tinP , TAG( TAGiDnULL ) ) ;

        SCOOPS
    {
    IFsCRATCH
    ZE( countT , cWrap ) ;
    _INoLD_

    }
        if( POOP ) return 0 ;
        __Z( psttP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/countT backOldC::wrapRenderF( tinS& tinP , const strokeS* const psttP , const handleC* const phCloneP , const countT* pczIdAdamSnapP )/*1*/

/**/
*/
 if the drawing paper changes then i must render correctly to the correct drawing paper
i must deal with the possibility that the drawing paper changes
my main job is to wrap words
i render the specified strokes onto the current drawing paper
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

