
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return flagsRC ;

    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    tinP.ta.pushed.u.listWalk.cbf.idNestP -- ;

    tinP.tlsDelF( LF , *(byteT**)&pczName ) ;
    //{ puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ; PUSE( tinP , *(byteT**)&pczName ) ; }

    if( bClearPoolRecord ) tinP.ta.retained.u.listWalk.walk.pPoolRecord = 0 ;

    if( !ppHand[ 1 ] && tinP.ta.pushed.u.listWalk.walk.pHandleHiP ) ppHand[ 1 ] = new( 0 , tinP , (byteT*)tinP.ta.pushed.u.listWalk.walk.pHandleHiP , SIZEOF_handleC ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
    if( !ppHand[ 0 ] && tinP.ta.pushed.u.listWalk.walk.pHandleLoP ) ppHand[ 0 ] = new( 0 , tinP , (byteT*)tinP.ta.pushed.u.listWalk.walk.pHandleLoP , SIZEOF_handleC ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

    if( !( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_DOnOTuNGRABoOTHaTeNDoFwALK ) ) { DELzOMBIE( ppHand[ !offWoth ] ) ; }

    }
        }
            else if( tinP.ta.pushed.u.listWalk.walk.pHandleRootP ) tinP.ta.pushed.u.listWalk.walk.pHandleRootP->closeIfF() ;
            }
                if( tinP.ta.pushed.u.listWalk.walk.pbHandleRootP ) phRoot = new( 0 , tinP , tinP.ta.pushed.u.listWalk.walk.pbHandleRootP , SIZEOF_handleC ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            
                DELzOMBIE( phRoot ) ;
                handleC*& phRoot = *tinP.ta.pushed.u.listWalk.walk.ppHandleRootP ;
            {
            if( tinP.ta.pushed.u.listWalk.walk.ppHandleRootP && tinP.ta.pushed.u.listWalk.walk.pbHandleRootP )
        {
        if( bWothIsRoot && !( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_RETAINrOOT ) )

        DELzOMBIE( ppHand[  offWoth ] ) ;
    {
    if( !( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_DOnOTuNGRABwOTHaTeNDoFwALK ) )

    }
        }
            __( !*pApt ) ;
                                                  pNew = 0 ;

            //}
            //    LOGrAW(    ostoSay ) ;
            //    CONoUTrAW( ostoSay ) ;
            //
            //    OStEXTAK( ostoSay , "\r\n" ) ;
            //    OStEXTA(  ostoSay , bOk ? " (is a listingC)" : " (is NOT a listingC)" ) ;
            //    OStEXTA(  ostoSay , pPoolIn ? pPoolIn->postNameF( tinP ) : "unknown" ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTA(  ostoSay , tinP.pPoolUse->postNameF( tinP ) ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , pNew , 0 ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , *pApt , 0 ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , tinP.pAdamGlobal1->idAdam , 0 ) ;
            //    OStEXTAK( ostoSay , "listC::walkF new [idAdam,apt,ptr,puse,inpool]: " ) ;
            //    OStEXT(   ostoSay , TUCK << 2 ) ;
            //
            //    boolT  bOk     = listingC::bIsListingIF( tinP , pNew ) ;
            //    poolC* pPoolIn = poolC::pPoolIF( tinP , (byteT*)pNew ) ;
            //{
            //if( tinP.pc Utility[ 0 ] && idName == LISTnAME_RECORD )

                                          *pApt = pNew ;
                ((listC*)pNew)->aptBro = *pApt ;
            __( ((listC*)pNew)->aptBro ) ;
            listingC*& pNew = tinP.ta.pushed.u.listWalk.cbf.pNewP ;

            cKidNew ++ ;
            flagsRC |= flLISTwALKrETURNcODE_NEWlISTING ;
        {
        if( !POOP && tinP.ta.pushed.u.listWalk.cbf.pNewP )
        //CS:CODEsYNC: PSEUDOdUPLICATEcODE 2200004 2200004
    
        FV(flLISTwALKcALLbACKrETURNcODE,flRetCode) ;

        tinP.ta.retained.u.listWalk.walk.idGrabLayer = save ;

        THREADmODE2rESTORE
        // ********************************************************************************************************************************************************************
        flagsT flRetCode = !tinP.ta.pushed.u.listWalk.walk.pListWalkCBFP ? flLISTwALKcALLbACKrETURNcODE_null : (*tinP.ta.pushed.u.listWalk.walk.pListWalkCBFP)( tinP ) ;
        // ********************************************************************************************************************************************************************

                      tinP.ta.retained.u.listWalk.walk.idGrabLayer = idGrabLayerP ;
        countT save = tinP.ta.retained.u.listWalk.walk.idGrabLayer ;

        tinP.ta.pushed.u.listWalk.cbf.idCallP ++ ;
        THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
        tinP.ta.pushed.u.listWalk.cbf.pDadP = this ;
        tinP.ta.pushed.u.listWalk.cbf.pListingP = 0 ;
    {
    if( !POOP && !bQuit )

    }
        }
            if( bWothIsRoot ) bWothIsRoot = 0 ;
            offWoth = !offWoth ;
        {
        if( !bKidDeleted )
        pklNU = pk && pk->flagsF() & fliLISTINGc_MIXINlIST ? (listC*)pk : 0 ; //FOR DEBUGGING CONVENIENCE ; NOT USED
        pk = &APT( listingC , *pApt ) ;
        if( pk ) pApt = &((listC*)pk)->aptBro ; // IF !pk THEN *pApt NOW POINTS TO THE listingC THAT FOLLOWED THE DELETED listingC

        }
            break ;
            bQuit = 1 ;
        {
        if( F(flRetCode) & flLISTwALKcALLbACKrETURNcODE_QUIT )

        }
            }
                else if( tinP.ta.pushed.u.listWalk.walk.pHandleRootP ) tinP.ta.pushed.u.listWalk.walk.pHandleRootP->closeIfF() ;
                }
                    if( tinP.ta.pushed.u.listWalk.walk.pbHandleRootP ) phRoot = new( 0 , tinP , tinP.ta.pushed.u.listWalk.walk.pbHandleRootP , SIZEOF_handleC ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            
                    DELzOMBIE( phRoot ) ;
                    handleC*& phRoot = *tinP.ta.pushed.u.listWalk.walk.ppHandleRootP ;
                {
                if( tinP.ta.pushed.u.listWalk.walk.ppHandleRootP && tinP.ta.pushed.u.listWalk.walk.pbHandleRootP )
            {
            if( bWothIsRoot && !( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_RETAINrOOT ) )

            ppHand[ offWoth ] = new( 0 , tinP , offWoth ? pbHi : pbLo , SIZEOF_handleC ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            DELzOMBIE( ppHand[ offWoth ] ) ;
        {
        if( !bKidDeleted && !bWothDeleted )

        }
            tinP.ta.retained.u.listWalk.walk.idGrabLayer = save ;

            THREADmODE2rESTORE
            DEL( pk ) ;
            THREADmODE2oN( flTHREADmODE2_ALLOWdESTRUCTIONoFlISTINGc ) ;

                          tinP.ta.retained.u.listWalk.walk.idGrabLayer = idGrabLayerP ;
            countT save = tinP.ta.retained.u.listWalk.walk.idGrabLayer ;

            ppHand[ !offWoth ] = new( 0 , tinP , !offWoth ? pbHi : pbLo , SIZEOF_handleC ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            DELzOMBIE( ppHand[ !offWoth ] ) ;
        
                    ((listC*)pk)->aptBro.resetF() ;
            *pApt = ((listC*)pk)->aptBro ;  //CAST IS DONE TO AVOID NEEDING TO MAKE ME A FRIEND OF listingC; IN GENERAL, *pk WILL NOT BE A listC INSTANCE; THIS IS OK BECAUSE aptBro IS A MEMBER OF listingC SO WILL ALWAYS BE AT THE EXPECTED LOCATION
        {
        if( bKidDeleted )

        }
            }
                }
                    break ;           // THIS HAPPENS WHILE DELETING {ROOT,APPLICATION} WHEN UNINDEX ATTEMPTS TO DELETE SYSTEM2, WHICH IS STILL GRABBED AS PART OF THE WALK OF ROOT
                    bKidDeleted = 0 ; // THE CALLING THREAD GRABBED *pk RECURSIVELY AND IT WILL STILL BE GRABBED IF I TRY TO DELETE IT
                {
                if( tinP.ppbGrabitRecurse[ offr ] == pbFind && tinP.pcGrabitRecurse[ offr ] )
            {
            for( countT offr = 0 ; offr < CmAXgRABITrECURSEiNtINs ; offr ++ )
            byteT* pbFind = (byteT*)&pk->flagsRefF() ;
        {
        if( bKidDeleted )

        ;
            && ( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_IGNOREcREF                                                              || !pk->cRefF()      )
            && ( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_IGNOREcREFdATUM || pk->idTypeDatumF() == ifcIDtYPEmIXINdATUM_listingVSP || !pk->cRefDatumF() )
            pk->flagsF() & fliLISTINGc_DELETErEQUESTED
        boolT bKidDeleted =

        }
            }
                POPtINaRGS

                tinP.ta.retained.u.listWalk.walk.idGrabLayer = save ;

                // ********************************************************
                ((listC*)pk)->walkF( tinP , idGrabLayerP ) ;
                // ********************************************************

                              tinP.ta.retained.u.listWalk.walk.idGrabLayer = idGrabLayerP ;
                countT save = tinP.ta.retained.u.listWalk.walk.idGrabLayer ;

                tinP.ta.pushed.u.listWalk.walk.flagsWalkP    = flLISTwALK_CALLERgRABBEDrOOT ;
                tinP.ta.pushed.u.listWalk.walk.pListWalkCBFP = listWalkUnIndexCBF ;
                PUSHtINaRGS
            {
            )
                && pczName[ 1 ] == LISTnAME_ROOTaPPLICATION
                && pczName[ 0 ] == LISTnAME_ROOT
                && pczName
                && ( listingC::bIsListingIF( tinP , *pApt , fliLISTINGc_MIXINlIST ) || listingC::bIsListingIF( tinP , *pApt , fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM ) )
                pk->flagsF() & fliLISTINGc_DELETErEQUESTED
            (
            if

            if( POOP ) break ;
            }
                tinP.ta.pushed.u.listWalk.walk.cRecurseP -- ;
                tinP.ta.pushed.u.listWalk.walk.flagsWalkP = flagsSave ;

                tinP.ta.retained.u.listWalk.walk.idGrabLayer = save ;

                // ********************************************************
                flagsT flagsRC = ((listC*)pk)->walkF( tinP , idGrabLayerP ) ;
                // ********************************************************

                              tinP.ta.retained.u.listWalk.walk.idGrabLayer = idGrabLayerP ;
                countT save = tinP.ta.retained.u.listWalk.walk.idGrabLayer ;

                                   tinP.ta.pushed.u.listWalk.walk.flagsWalkP |= flLISTwALK_CALLERgRABBEDrOOT ;
                flagsT flagsSave = tinP.ta.pushed.u.listWalk.walk.flagsWalkP ;
                tinP.ta.pushed.u.listWalk.walk.cRecurseP ++ ;
            {
            )
                && ( listingC::bIsListingIF( tinP , *pApt , fliLISTINGc_MIXINlIST ) || listingC::bIsListingIF( tinP , *pApt , fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM ) )
                && !( F(flRetCode) & flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE )
                   !( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_DOnOTwALKkIDaFTERcALLINGkID )
            (
            if // NOTE THAT I WILL WALK A LIST EVEN IF ITS INSPECTOR RETURNED flLISTwALKcALLbACKrETURNcODE_QUIT

            }
                if( F(flRetCode) & flLISTwALKcALLbACKrETURNcODE_DELETE ) pk->flagsRefF() |= fliLISTINGc_DELETErEQUESTED ;
    
                }
                    }
                        else if( tinP.ta.pushed.u.listWalk.walk.pHandleRootP ) tinP.ta.pushed.u.listWalk.walk.pHandleRootP->closeIfF() ;
                        }
                            if( tinP.ta.pushed.u.listWalk.walk.pbHandleRootP ) phRoot = new( 0 , tinP , tinP.ta.pushed.u.listWalk.walk.pbHandleRootP , SIZEOF_handleC ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            
                            DELzOMBIE( phRoot ) ;
                            handleC*& phRoot = *tinP.ta.pushed.u.listWalk.walk.ppHandleRootP ;
                        {
                        if( tinP.ta.pushed.u.listWalk.walk.ppHandleRootP && tinP.ta.pushed.u.listWalk.walk.pbHandleRootP )
                    {
                    if( bWothIsRoot && !( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_RETAINrOOT ) )
            
                    ppHand[ offWoth ] = new( 0 , tinP , offWoth ? pbHi : pbLo , SIZEOF_handleC ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                    DELzOMBIE( ppHand[ offWoth ] ) ;

                    cKidNotDeleted ++ ;
                {
                if( bWothDeleted ) 
                bWothDeleted = !( F(flRetCode) & flLISTwALKcALLbACKrETURNcODE_DELETE ) ; //WOTH CAN BE CLOSED NOW UNLESS THE CURRENT LISTING MIGHT BE DELETED AFTER BEING WALKED
    
                }
                    if( POOP ) break ;
                                             __( !*pApt ) ;
                                                          pNew = 0 ;
                                                  *pApt = pNew ;
                        ((listC*)pNew)->aptBro = *pApt ;
                    __( ((listC*)pNew)->aptBro ) ;
                    listingC*& pNew = tinP.ta.pushed.u.listWalk.cbf.pNewP ;

                    cKidNew ++ ;
                    flagsRC |= flLISTwALKrETURNcODE_NEWlISTING ;
                {
                if( tinP.ta.pushed.u.listWalk.cbf.pNewP )
                //CS:CODEsYNC: PSEUDOdUPLICATEcODE 2200004 2200004

                if( POOP ) break ;
                FV(flLISTwALKcALLbACKrETURNcODE,flRetCode) ;

                tinP.ta.retained.u.listWalk.walk.idGrabLayer = save ;

                THREADmODE2rESTORE
                // ****************************************************************************************************************************
                if( tinP.ta.pushed.u.listWalk.walk.pListWalkCBFP ) flRetCode = (*tinP.ta.pushed.u.listWalk.walk.pListWalkCBFP)( tinP ) ;
                // ****************************************************************************************************************************
                tinP.ta.pushed.u.listWalk.cbf.idCallP ++ ;
                THREADmODE2oN( flTHREADmODE2_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ;

                              tinP.ta.retained.u.listWalk.walk.idGrabLayer = idGrabLayerP ;
                countT save = tinP.ta.retained.u.listWalk.walk.idGrabLayer ;

                tinP.ta.pushed.u.listWalk.cbf.pDadP = this ;
                __( !listingC::bIsListingIF( tinP , tinP.ta.pushed.u.listWalk.cbf.pListingP ) ) ; //U::TO FIND A BUG
                tinP.ta.pushed.u.listWalk.cbf.pListingP = pk ;
            {
            if( bCall )

            }
                bCall = !!tinP.ta.pushed.u.listWalk.walk.offStretchEnd ;

                }
                    }
                        default                              : { if( tinP.ta.pushed.u.listWalk.walk.offStretchEnd ) tinP.ta.pushed.u.listWalk.walk.offStretchEnd = tinP.ta.pushed.u.listWalk.walk.offStretchBegin = 0 ; break ; }
                        case LISTnAME_STRETCHbEGINbITS       : { tinP.ta.pushed.u.listWalk.walk.offStretchBegin = off ; break ; }
                        case LISTnAME_STRETCHbEGINcOUNTsTRZ  :
                        case LISTnAME_STRETCHbEGINcOUNT      :
                        case LISTnAME_STRETCHbEGINoStEXTsTRZ :
                        case LISTnAME_STRETCHeND             : { tinP.ta.pushed.u.listWalk.walk.offStretchEnd   = off ; break ; }
                    {
                    switch( pczName[ off ] )
                {
                for( countT off = 0 ; pczName[ off ] ; off ++ )
            {
            if( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_FILTEReNDoFsTRETCHEDvALUE )

            boolT bCall = !( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_FILTEReNDoFsTRETCHEDvALUE ) ; //IF NO FILTER FLAGS ARE SET

            }
                tinP.ta.pushed.u.listWalk.walk.cRecurseP -- ;
                tinP.ta.pushed.u.listWalk.walk.flagsWalkP = flagsSave ;

                tinP.ta.retained.u.listWalk.walk.idGrabLayer = save ;

                // ********************************************************
                flagsT flagsRC = ((listC*)pk)->walkF( tinP , idGrabLayerP ) ;
                // ********************************************************

                              tinP.ta.retained.u.listWalk.walk.idGrabLayer = idGrabLayerP ;
                countT save = tinP.ta.retained.u.listWalk.walk.idGrabLayer ;

                                   tinP.ta.pushed.u.listWalk.walk.flagsWalkP |= flLISTwALK_CALLERgRABBEDrOOT ;
                flagsT flagsSave = tinP.ta.pushed.u.listWalk.walk.flagsWalkP ;
                tinP.ta.pushed.u.listWalk.walk.cRecurseP ++ ;
            {
            )
                && ( listingC::bIsListingIF( tinP , *pApt , fliLISTINGc_MIXINlIST ) || listingC::bIsListingIF( tinP , *pApt , fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM ) )
                F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_WALKkIDbEFOREcALLINGkID
            (
            if // THIS EARLY WALK CODE DOES NOT EXECUTE UNLESS EXPLICITLY REQUESTED BY APPLICATION CODE
        {
        if( !( pk->flagsF() & fliLISTINGc_DELETErEQUESTED ) )
        ZE( boolT , bWothDeleted ) ;
        flagsT flRetCode = flLISTwALKcALLbACKrETURNcODE_null ;

        if( !( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_IGNOREgRABITbIT ) ) { grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ; pk->openF( tinP , *ppHand[ !offWoth ] , 0 , idGrabLayerP ) ; }

        }
            pk->flagsRefF() &= (byteT)~fliLISTINGc_GRABBED ;
            else        { CONoUTrAW(  " resetting the GRABBED bit for a listingC\r\n" ) ; }
            if( pklNU ) { CONoUTrAW3( " resetting the GRABBED bit for listC [idName]: " , pklNU->idName , "\r\n" ) ; }
        {
        if( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_RESETgRABITbIT && pk->flagsF() & fliLISTINGc_GRABBED )
        //CONoUTrAW3( "[pk->flagsi]: " , pk->flagsF() , "\r\n" ) ;

        }
            break ;
            __1
            __( *pApt ) ;
        {
        if( !listingC::bIsListingIF( tinP , *pApt ) )

        //if( !( idPass % TUCK ) ) { CONoUTrAW( "~" ) ; } //U::WHY IS CPU NOT PEGGED?
        //countT idPass = 1 + incv02AM( idPassLath ) ;
        //static countT idPassLath ;
    {
    while( pk )
    ZE( boolT , bQuit ) ;

    //}
    //    LOGrAW(    ostoSay ) ;
    //    CONoUTrAW( ostoSay ) ;
    //
    //    OStEXTAK( ostoSay , "\r\n" ) ;
    //    OStEXTA(  ostoSay , bOk  ? " (is a listingC)" : " (is NOT a listingC)" ) ;
    //    OStEXTA(  ostoSay , pPoolIn ? pPoolIn->postNameF( tinP ) : "unknown" ) ;
    //    OStEXTAK( ostoSay , " " ) ;
    //    OStEXTA(  ostoSay , tinP.pPoolUse->postNameF( tinP ) ) ;
    //    OStEXTAK( ostoSay , " " ) ;
    //    OStEXTC(  ostoSay , pk , 0 ) ;
    //    OStEXTAK( ostoSay , " " ) ;
    //    OStEXTC(  ostoSay , aptKid , 0 ) ;
    //    OStEXTAK( ostoSay , " " ) ;
    //    OStEXTC(  ostoSay , tinP.pAdamGlobal1->idAdam , 0 ) ;
    //    OStEXTAK( ostoSay , "listC::walkF old [idAdam,apt,ptr,puse,inpool]: " ) ;
    //    OStEXT(   ostoSay , TUCK << 2 ) ;
    //
    //    boolT  bOk     = listingC::bIsListingIF( tinP , pk ) ;
    //    poolC* pPoolIn = poolC::pPoolIF( tinP , (byteT*)pk ) ;
    //{
    //if( tinP.pc Utility[ 0 ] && idName == LISTnAME_RECORD && pk )

    listC* pklNU = pk && pk->flagsF() & fliLISTINGc_MIXINlIST ? (listC*)pk : 0 ; //FOR DEBUGGING CONVENIENCE ; NOT USED
    listingC* pk = &APT( listingC , *pApt ) ;
    aptC* pApt = &aptKid ;
    tinP.ta.pushed.u.listWalk.cbf.idCallP = 0 ;
    ZE( countT , cKidNew ) ;
    ZE( countT , cKidNotDeleted ) ;

    boolT bWothIsRoot = 1 ;
    if( !( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & ( flLISTwALK_CALLERgRABBEDrOOT | flLISTwALK_IGNOREgRABITbIT ) ) ) { grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ; openF( tinP , *ppHand[ offWoth ] , 0 , idGrabLayerP ) ; }

    }
        flagsi &= (byteT)~fliLISTINGc_GRABBED ;
        CONoUTrAW3( " resetting the GRABBED bit for listC [idName]: " , idName , "\r\n" ) ;
    {
    if( F(tinP.ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_RESETgRABITbIT && flagsi & fliLISTINGc_GRABBED )
    //CONoUTrAW3( "[    flagsi]: " , flagsi , "\r\n" ) ;

    countT& offWoth = *( tinP.ta.pushed.u.listWalk.walk.pOffWothP ? tinP.ta.pushed.u.listWalk.walk.pOffWothP : &offWothDefault ) ;
    ZE( countT , offWothDefault ) ;

    ppHand[ 1 ] = tinP.ta.pushed.u.listWalk.walk.pHandleHiP ? (handleC*)pbHi : new( 0 , tinP , pbHi , SIZEOF_handleC ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
    ppHand[ 0 ] = tinP.ta.pushed.u.listWalk.walk.pHandleLoP ? (handleC*)pbLo : new( 0 , tinP , pbLo , SIZEOF_handleC ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
    handleC* ppHand[ 2 ] ;

    byteT* const pbHi = tinP.ta.pushed.u.listWalk.walk.pHandleHiP ? (byteT*)tinP.ta.pushed.u.listWalk.walk.pHandleHiP : pbDefault + SIZEOF_handleC ;
    byteT* const pbLo = tinP.ta.pushed.u.listWalk.walk.pHandleLoP ? (byteT*)tinP.ta.pushed.u.listWalk.walk.pHandleLoP : pbDefault ;
    byteT pbDefault[ 2 * SIZEOF_handleC ] ;

    }
        __( !tinP.ta.retained.u.listWalk.walk.pPoolRecord ) ;
        tinP.ta.retained.u.listWalk.walk.pPoolRecord = poolC::pPoolFromNameIF( tinP , vspo ) ;
        __( !(const byteT*)vspo ) ;
        THREADmODE2rESTORE
        blobVSP vspo = listC::dictionaryQueryFromIdIF( tinP , pczName[ 3 ] ) ;
        THREADmODE2oN( flTHREADmODE2_ALLOWdICTIONARYwHILEgRABBING )

        bClearPoolRecord = 1 ;
    {
    if( pczName[ 0 ] == LISTnAME_ROOT && pczName[ 1 ] == LISTnAME_ROOTsYSTEM3 && pczName[ 2 ] == LISTnAME_FIELDvALUEiNDEX && pczName[ 3 ] && !pczName[ 4 ] && !tinP.ta.retained.u.listWalk.walk.pPoolRecord )
    ZE( boolT , bClearPoolRecord ) ;

    nameF( tinP , pczName ) ; //20140111@1810: NOW ALLOCATED IN TLS: { puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ; ___( pczName ) ; }
    ZE( countT* , pczName ) ;

    tinP.ta.pushed.u.listWalk.cbf.idNestP ++ ;
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    _IO_

    }
        if( POOP ) return flagsRC ;
        FV(flLISTwALK,tinP.ta.pushed.u.listWalk.walk.flagsWalkP) ;
        if( POOP ) return flagsRC ;
    {
    IFbEcAREFUL

    flagsT flagsRC = flLISTwALKrETURNcODE_null ;
{
/*1*/flagsT listC::walkF( tinS& tinP , const countT idGrabLayerP )/*1*/

/**/
*/
  if walking the root list, *pczNameP must be 0
  the lath value must equal idName
  caller must declare a name for the list being walked
 pczNameP
  see tinArgS, which is used both to call me and for me to pass info into a callback function provided by the caller
 tinP
arguments for the outermost call to walkF
it is illegal for any application code to reference listingC instances anywhere other than within the definition of a listWalkCBFT function
it is illegal for listWalkCBFT to store a pointer or reference to any listingC object for use outside of the callback function
 the outermost caller of me must clear the entire tinP. ta.a.pc1 and tinP. ta.a.pc2 AND tinP. ta.a.pc3 arrays and then set them as specified in the following
 for efficiency and to avoid exhausting the thread stack, i use tinP. ta.a.pc for my arguments
i call myself recursively, perhaps deeply
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

