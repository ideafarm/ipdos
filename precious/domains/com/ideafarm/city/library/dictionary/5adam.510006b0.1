
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

while( cThreads ) OSsLEEPf( 500 ) ;
bQuit = 1 ;

#endif

    etThread.loafIF( tinP ) ;
    etThread.osThreadF( tinP , countTC() , tmGorillaF , 0 , flTHREADlAUNCH_ORPHAN ) ;

#else

    }
        etThread.loafIF( tinP ) ;
        BOSpOOP
        BOS( WHATgbo , BOSoK , CloseHandle( osht ) )
    {
    else
    if( !osht ) dec02AM( cThreads ) ;
    HANDLE osht = (HANDLE)tinP.brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , CreateThread( 0 , 0 , tmGorillaRawF , 0 , 0 , 0 ) )

#if defined( RAW )

inc02AM( cThreads ) ;

pTinMain = &tinP ;

TODO

//#define RAW

}
    return 0 ;
    dec02AM( cThreads ) ;

    BOSpOOP
    BOS( WHATgbo , BOSoK , CloseHandle( osht ) )

    }
        }
            OSsLEEPf( 1000 ) ;
            LOGrAW5( "Could not create thread [idt,idTry]: " , idt , " " , idTry , ".  Napping for 1 second.\r\n" ) ;
            dec02AM( cThreads ) ;
        {
        else
        if( osht ) break ;
        osht = (HANDLE)tinP.brcRaw ;
        BOSpOOP
        BOS( WHATgbo , BOSoK , CreateThread( 0 , 0 , tmGorillaRawF , 0 , 0 , 0 ) )
        inc02AM( cThreads ) ;
        idTry ++ ;
    {
    while( !bQuit )
    ZE( countT , idTry ) ;
    ZE( HANDLE , osht ) ;

    }
        CONoUTrAW5( "[msSinceBoot,idt]:    " , tinP.brcRaw - msAtBoot , "    " , idt , "\r\n" ) ;
        BOSdOnOTtEST( WHATgbo , GetTickCount() )
    {
    if( !( idt % TUCK ) )
    OSsLEEPf( 0 ) ;

    tinS&   tinP     = *pTinMain ;
    countT  idt      = 1 + incv02AM( idtLath ) ;
{
DWORD WINAPI tmGorillaRawF( LPVOID pvArgP )






        }
            return threadLocalStorageF( ifcIDtYPEtLS_KID , tmGorillaF_workF , (countT)argP , 0 , 0 , 0 , 0 , "tmGorillaF" ) ;
        {
        countT __export OSF tmGorillaF( voidT* argP )

        }
            return POOP ? ifcEXITcODEtHREADiMPOTENT : ifcEXITcODEtHREADaOK ;
            }
                CONoUTrAW5( "[idt,idSubType]: " , idt , " " , idSubType , "\r\n" ) ;
                idSubType = POOP ;_
                TINSL ;_
            {
            ZE( countT , idSubType ) ;_
            }
                }
                    dec02AM( cAllThreads ) ; /* MUST BE THE VERY LAST THING THAT THIS THREAD DOES */
                    if( !bFake ) { DEL( pTaskP ) ; } /* MUST BE AS LATE AS POSSIBLE BECAUSE IT GIVES THE SIGN THAT THE THREAD IS DONE.  THE PROCESS MUST SLEEP AFTER RECEIVING THIS SIGN BEFORE ENDING, SO THAT THIS THREAD CAN COMPLETE */
                    if( tinP.monitor.idThread <= ClOWtHREADS ) processGlobal1S::_processGlobal1I_IF().pcPhaseLow[ tinP.monitor.idThread ] = - 1 ;_
                    TELL( "DONE0: i am outa here" )
                    ;_
                        : thirdC::os_cAllKidThreadsI_IF( tinP )
                        ? thirdC::os_cAllOrphanThreadsI_IF( tinP )
                    countT& cAllThreads = bOrphan
                    boolT bFake   = pTaskP ? !!( F(pTaskP->flags) & flTHREADlAUNCH_FAKE   ) : 0 ;_
                    boolT bOrphan = pTaskP ? !!( F(pTaskP->flags) & flTHREADlAUNCH_ORPHAN ) : 0 ;_
                    TELL( "DONE0: deregistering myself from either cAllOrphanThreadsI or cAllKidThreadsI (my final act)" )
                    TINSL /*THIS IS NEEDED BECAUSE tinP WAS DELETED IF I AM tmWindowsF */
                {

                }
                    }
                        }
                            }
                                pEtThread = 0 ;_
                                THREADmODE2rESTORE
                                TINSL
                                delete pEtThread ; /* tinP IS DESTROYED HERE */
                                THREADmODE2oFF( flTHREADmODE2_DOnOTcaLLdELif )
                            {
                            if( *(countT*)&pEtThread )
                            DEL( tinP.pEtScratch ) ;_
                            DEL( tinP.pScoopEtThread ) ; /*CODEsYNC: 0010056 1020171 */
                            TELL( "DONE0: deleting etThread (and tinP)" ) ;_
                            tinP.pEther = 0 ;_
                            TELL( "DONE0: testing poolOld" ) ;_

                            }
                                tinP.pEtScratch->delF( tinP , psttThreadFile ) ;_
                                tinP.pEtScratch->boxZapF( tinP , psttThreadFile ) ;_
                                TELL( "DONE0: deleting thread file" ) ;_
                            {
                            if( psttThreadFile )
                        {
                        if( pEtThread ) /*THREADS THAT DELETE etThread EARLY: tmWindowsF*/
                        TINSL /*THIS IS NEEDED BECAUSE tinP WAS DELETED IF I AM tmWindowsF */
                    {

                    }
                        }
                            if( tinP.monitor.idThread <= ClOWtHREADS && !( ++ processGlobal1S::_processGlobal1I_IF().pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                            if( tinP.idPhase1 < ifcIDpHASEtHREAD_EPILOGnOkIDS ) tinP.idPhase1 = ifcIDpHASEtHREAD_EPILOGnOkIDS ;_
                            }
                                TELL( "DONE0: destroying all adam objects that remain on the thread stack" ) ;_
                                }
                                    while( tinP.cKidThreads ) { ++ s ; thirdC::dosSleepRawIF( tinP , 250 ) ; }
                                    sleepC s( tinP , TAG( TAGiDnULL ) ) ; /* WILL BLAMMO IF ANYTHING IS GRABBED (THIS IS DESIRABLE BEHAVIOR) */
                                {
                                TELL( "DONE0: waiting for my kid threads to end" ) ;_

                                if( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_WHEREaLL && !( F(tinP.flagsThreadMode1) & flTHREADmODE1_NOwHERE ) ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;_
                                TELL( "DONE0: conditionally calling etherWhereF" ) ;_
                            {
                            else
                            if( !pEtThread ) ; /*THIS IS NEEDED BECAUSE tinP WAS DELETED IF I AM tmWindowsF */

                            TELL( "DONE0: after returning from application code" ) ;_
                            tinP.idPhase2 = 0 ;_
                            if( tinP.idPhase1 < ifcIDpHASEtHREAD_EPILOGkIDS ) tinP.idPhase1 = ifcIDpHASEtHREAD_EPILOGkIDS ;_
                            if( tinP.monitor.idThread <= ClOWtHREADS && !( ++ processGlobal1S::_processGlobal1I_IF().pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                            TINSL /*THIS IS NEEDED BECAUSE tinP WAS DELETED IF I AM tmWindowsF */
                        {

                        etThread.osThreadSwitchingDesireF( tinP , ifcTHREADpRIORITY_PUSHY ) ; /*TO PREVENT LAME DUCK THREADS FROM ACCUMULATING AND CLOGGING SYS*/

                        /*DO NOT CLOSE THE CODE BLOCK HERE BECAUSE KID THREADS MIGHT BE USING OBJECTS THAT WOULD DT HERE*/




}
    dec02AM( cThreads ) ;_

    }
        }
            }
                OSsLEEPf( 1000 ) ;_
                CONoUTrAW5( "Could not create thread [idt,idTry]: " , idt , " " , idTry , ".  Napping for 1 second.\r\n" ) ;_
                dec02AM( cThreads ) ;_
                POOPR

                CONoUTrAW( "X" ) ;_
            {
            else
            }
                break ;
                CONoUTrAW( "." ) ;_
            {
            if( !POOP )

            tinP.pEtScratch->osThreadF( tinP , countTC() , tmGorillaF , 0 , flTHREADlAUNCH_ORPHAN ) ;_

            inc02AM( cThreads ) ;_
            idTry ++ ;_
        {
        while( !bQuit )
        ZE( countT , idTry ) ;_

        }
            CONoUTrAW5( "[msSinceBoot,idt]:    " , tinP.brcRaw - msAtBoot , "    " , idt , "\r\n" ) ;
            BOSdOnOTtEST( WHATgbo , GetTickCount() )
        {
        if( !( idt % TOCK ) )
        OSsLEEPf( 0 ) ;_
    {
    IFsCRATCH

    CONoUTrAW3( "tmGorillaF [idt]: " , idt , "\r\n" ) ;_

    idt      = 1 + incv02AM( idtLath ) ;_
{
if( pTaskP )




                    if( tinP.monitor.idThread <= ClOWtHREADS && !( ++ processGlobal1S::_processGlobal1I_IF().pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
                    _IO_
                    if( tinP.idPhase1 < ifcIDpHASEtHREAD_WORKING ) tinP.idPhase1 = ifcIDpHASEtHREAD_WORKING ;_
                    (countT&)_stackTop = espAM() ;_
                    staticC _stackTop( tinP , "appStackTop" , "tin" ) ;_
                    TELL( "TASK0: entering application code" )
                    if( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_WHEREaLL && !( F(tinP.flagsThreadMode1) & flTHREADmODE1_NOwHERE ) ) etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;_
                    }
                        etThread.boxPutF( tinP , psttThreadFile , "T" ) ;_
                        etThread.strMakeF( tinP , psttThreadFile , T("///ideafarm/ephemeral/tmp/threads/")+TF1(tinP.osPid)+tDot+TF1(DDNUMB)+tDot+T("tmGorillaF")+tDot+TF1(tinP.monitor.idThread) ) ; ___( psttThreadFile ) ;_
                        TN( tDot , "." ) ;_
                    {
                    if( F( ((thirdC&)etThread).third_flagsModeAdam1I_IF( tinP ) ) & flADAMmODE1_SEEtHREADSaSfILES )
                    etThread.osTimeNowF( tinP , tinP.time1 , tinP.time2 ) ;_
                    /*etherC::ifcSayIF( T("ADAM CELL (idAdam,osPid): ")+TF1(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T(" ")+TF1(tinP.osPid)+T(" ")+TF1(tinP.osTid)+T(" \"")+T(tinP.postThreadName)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;*/
                {

                tinP.pEther = &etThread ;_
                TELL( "TASK0: final setup" )

                /*POPUP( TF1(tinP.monitor.idThread)+T(" ")+T(tinP.postThreadName)+T("\r\n") ) ;*/

                tinP.pScoopEtThread = new( 0 , tinP , LF ) scoopC( tinP , etThread ) ; ___( tinP.pScoopEtThread  ) ;_
                etherC& etThread  = *pEtThread ;_
            {
            if( pEtThread && tinP.pEtScratch )
            ZE( strokeS* , psttThreadFile ) ;_
            TELL( "TASK0: after newing etThread" )
            tinP.pEtScratch = new( 0 , tinP , LF ) etherC( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ; ___( tinP.pEtScratch ) ;_
            etherC* pEtThread  = new( 0 , tinP , LF ) etherC( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_TINoWNER | flTHIRDmODE_null ) ; ___( pEtThread ) ;_
            TELL( "TASK0: newing etThread" )

            if( pTaskP && F( pTaskP->flagsThreadMode1Dad ) & flTHREADmODE1_NOwHERE                 ) tinP.flagsThreadMode1 |= flTHREADmODE1_NOwHERE                 ;_
            if( pTaskP && F( pTaskP->flagsThreadMode1Dad ) & flTHREADmODE1_YELL                    ) tinP.flagsThreadMode1 |= flTHREADmODE1_YELL                    ;_
            if( pTaskP && F( pTaskP->flagsThreadMode1Dad ) & flTHREADmODE1_WATCHfORaSYNCHiMPOTENCE ) tinP.flagsThreadMode1 |= flTHREADmODE1_WATCHfORaSYNCHiMPOTENCE ;_
            if( pTaskP && F( pTaskP->flagsThreadMode1Dad ) & flTHREADmODE1_QUIETiMPOTENCE          ) tinP.flagsThreadMode1 |= flTHREADmODE1_QUIETiMPOTENCE          ;_
            if( pTaskP && F( pTaskP->flagsThreadMode1Dad ) & flTHREADmODE1_SHOWpROGRESS            ) tinP.flagsThreadMode1 |= flTHREADmODE1_SHOWpROGRESS            ;_
            TELL( "TASK0: setting flagsThreadMode1" )
            /*CODEsYNC: 00100df 0010055*/

            tinP.pcQuit = &(const countT&)ether ;_
            tinP.monitor.idProcessOld = thirdC::third_idProcessOldI_IF( tinP ) ;_
            tinP.idlTask  = ifcLINE ;_
            tinP.idiTask  = DDNUMB ;_
            TELL( "TASK0: setting miscellaneous fields in tinP" )
            etherC& etRock = etherC::etRockIF( tinP ) ;_
            etherC& ether = etherC::etPrimeIF( tinP ) ;_
            TINSL
        {
        if( bTinOk )
        ZE( countT , idt ) ;
        TELL( "TASK0: after newing either a tinS in the working poolOld" )
        /* AFTER THIS LINE, DO NOT CONSTRUCT ANY OBJECTS THAT HAVE DESTRUCTORS (BECAUSE DECREMENTING cAllKidThreadsI cAllOrphanThreadsI MUST BE THE VERY LAST THING THAT THIS THREAD DOES) */

        }
            }
                ___( pTin ) ;_
                TINSL
                /*pTinF() = pTin ;*/
                bTinOk = 1 ;_
            {
            if( pTin )
            tinS* pTin = new( 0 , tinP , LF ) tinS( tinP , TAG( TAGiDnULL ) , pTaskP->idThread , pTinDad , "tmGorillaF" , flTINs_null , ifcIDtINnAMED_tinInPool ) ;_
            TELL( "TASK0: newing a tinS in the working poolOld" )
            tinS* const pTinDad = F(pTaskP->flags) & flTHREADlAUNCH_ORPHAN ? 0 : &pTaskP->tinDad ;_
        {
        ZE( boolT , bTinOk ) ;_
        taskS* pTaskP = (taskS*)argP ;_
        TELL( "TASK0: workF+" )

        OStEXTcLEAR( _ostoTmp )
        osTextC _ostRangerTag( _ostoTmp.costF() + 1 , _ostoTmp , _statRangerTag , _statRangerTag.cbF() ) ;_
        staticC _statRangerTag( tinP , "rangerTag" , "sys" , 2 * sizeof( countT ) + _ostoTmp.costF() + 1 , ifcIDtYPEsTATICC_FOOT ) ;_
        OStEXTC(  _ostoTmp , tinP.monitor.idThread , 0 )
        OStEXTAK( _ostoTmp , "." )
        OStEXTA(  _ostoTmp , tinP.postThreadName )
        OStEXTAK( _ostoTmp , "RangerTag:threadStack." )
        OStEXTAK( _ostoTmp , "!ifc" )
        OStEXT(   _ostoTmp , 0x80 )

        _IO_ TELLsYSlIFInAME( "tmGorillaF" )
        if( tinP.monitor.idThread <= ClOWtHREADS && !( ++ processGlobal1S::_processGlobal1I_IF().pcPhaseLow[ tinP.monitor.idThread ] ) ) { BLAMMO ; }
        TINSL
    {
    countT tmGorillaF_workF( countT argP )

//TASK( tmGorillaF )

TASK0PROTO( tmGorillaF ) ;

//#define _ if( idtLath >= 0x162 ){ CONoUTrAW3( "[ifcLINE]: " , ifcLINE , "\r\n" ) ; }
#define _
//#define _ { CONoUTrAW3( "[ifcLINE]: " , ifcLINE , "\r\n" ) ; }

countT cThreads ;
boolT  bQuit ;
tinS*  pTinMain ;
countT msAtBoot = tinP.brcRaw ;
BOSdOnOTtEST( WHATgbo , GetTickCount() )
countT idtLath ;

//20140915@1840: MOVED FROM SCRATCH 6 TO PERMANENT ADAM ID

/*1*/WAKEsHOW( "scr" )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

