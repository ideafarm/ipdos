
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            if( pbic == pbBegin ) pbic = pbEnd ;
            pbic -= cbThis ;
        
            }
                }
                    }
                        pbtc = (byteT*)&size1 + cbToDo ;
                        cbToDo = sizeof size1 ;
                        pboc -= size2 ;

                        bSize1 = 1 ;
                    {
                    else
                    }
                        offBeginP = pboc - pbP ;

                        pbtc = (byteT*)&finger2 + cbToDo ;
                        cbToDo = sizeof finger2 ;
                        *(countT*)pboc = finger1 ;
                        pboc -= sizeof finger1 ;

                        bFinger2 = 1 ;
                        bFinger1 = 0 ;
                    {
                    else if( bFinger1 )
                    }
                        pbtc = (byteT*)&finger1 + cbToDo ;
                        cbToDo = sizeof finger1 ;
                        *(countT*)pboc = flags1 ;
                        pboc -= sizeof flags1 ;

                        bFinger1 = 1 ;
                        bFlags1 = 0 ;
                    {
                    else if( bFlags1 )
                    }
                        __( size2 - size1 ) ;

                        pbtc = (byteT*)&flags1 + cbToDo ;
                        cbToDo = sizeof flags1 ;
                        *(countT*)pboc = size1 ;
                        pboc -= sizeof size1 ;

                        bFlags1 = 1 ;
                        bSize1 = 0 ;
                    {
                    else if( bSize1 )
                    }
                        if( size2 == - 1 ) { BLAMMO ; } ;

                        pbtc = pboc ;
                        cbToDo = size2 ;
                        *(countT*)pboc = size2 ;
                        pboc -= sizeof size2 ;

                        bSize2 = 0 ;
                    {
                    else if( bSize2 )
                    }
                        }
                            cRetryFlags = CrETRYcYRCLEoLDrEAD ;
                            cbToDo = 0 ;
                            bSearch = 1 ;
                            bFlags2 = 0 ;
                        {
                        else
                        }
                            ++ s ; osSleepF( tinP , TUCK * 0x20 ) ;
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    
                            pbtc = (byteT*)&flags2 + cbToDo ;
                            cbToDo = sizeof flags2 ;
                            pbic2 += sizeof flags2 ;
                        {
                        else if( cRetryFlags -- )
                        }
                            pbtc = (byteT*)&size2 + cbToDo ;
                            cbToDo = sizeof size2 ;
                            *(countT*)pboc = flags2 ;
                            pboc -= sizeof flags2 ;
    
                            bSize2 = 1 ;
                            bFlags2 = 0 ;
                        {
                        if( F(flags2) & flCYRCLEoLDwRITE_CLEAN )
                    {
                    else if( bFlags2 )
                    }
                        pbtc = (byteT*)&flags2 + cbToDo ;
                        cbToDo = sizeof flags2 ;
                        *(countT*)pboc = finger2 ;
                        pboc -= sizeof finger2 ;

                        bFlags2 = 1 ;
                        bFinger2 = 0 ;
                    {
                    if( bFinger2 )
                {
                if( !cbToDo )
        
                }
                    *( -- pbtc ) = *( -- pbic2 ) ;
                    cbToDo -- ;
                {
                if( cbToDo )

                }
                    else break ;
                    }
                        pbtc = (byteT*)&finger2 + cbToDo ;
                        cbToDo = sizeof finger2 ;
                        bFinger2 = 1 ;
                        bSearch = 0 ;
                    {
                    if( pbic2 > pbic2e )
                    while( getNegAM( *(countT*)pbic2 ) != FINGERnEG_CYRCLEoLDwRITEeND && -- pbic2 > pbic2e ) ;
                {
                if( bSearch )
            {
            while( pbic2 > pbic2e && !POOP )
            countT cRetryFlags = CrETRYcYRCLEoLDrEAD ;
            const byteT* pbic2e = pbic - cbThis ;
            const byteT* pbic2  = pbic ;

            cbToDoAll -= cbThis ;        
            countT cbThis = ( ++ idLoop == 1 ) ? pbic - pbBegin : cbCyrcleOld - offWoth ;
        {
        while( !POOP && cbToDoAll ) //WILL LOOP 2 TIMES EXCEPT WHEN pbic == pbEnd
        ZE( boolT , bSearch ) ;
        ZE( countT , idLoop )
        byteT* pboc = pbP + cbToDoAll ; //CURSOR TO FINAL OUTPUT (THIS IS A "CEILING CURSOR")
        countT cbToDo = sizeof size2 ;
        byteT* pbtc = (byteT*)&size2 + sizeof size2 ; //CURSOR TO TEMPORARY OUTPUT
        byteT* pbic = offWoth ? pbBegin + offWoth : pbEnd ; // THIS IS A "CEILING CURSOR"
        const countT offWoth = ph->cbWritten % cbCyrcleOld ;
        ZE( byteT* , pbData ) ;               //U::THE LATH RECORDS MIGHT NOT BE WRITTEN YET; VALIDATE THEM
        ZE( countT , size2 ) ;
        ZE( countT , size1 ) ;
        ZE( countT , flags2 ) ;
        ZE( countT , flags1 ) ;
        ZE( countT , finger2 ) ;
        ZE( countT , finger1 ) ;
        ZE( boolT , bFinger1 ) ;
        ZE( boolT , bFlags1 ) ;
        ZE( boolT , bSize1 ) ;
        ZE( boolT , bSize2 ) ;
        ZE( boolT , bFlags2 ) ;
        boolT bFinger2 = 1 ;

        offBeginP = cbP ;
        pbP[ cbP ] = 0 ;
        cbP = cbToDoAll ;
    {
    if( pbP )
    newF( tinP , LF , pbP , cbToDoAll + 1 ) ; ___( pbP ) ;
    countT cbToDoAll = cbCyrcleOld > ph->cbWritten ? ph->cbWritten : cbCyrcleOld ;

    byteT* pbEnd   = pbBegin + cbCyrcleOld ;
    byteT* pbBegin = (byteT*)ph + sizeof( cyrcleOldHeaderS ) ;
    const countT cbCyrcleOld = (countT)napkinP - sizeof( cyrcleOldHeaderS ) ;
    if( !ph ) BLAMMO
    cyrcleOldHeaderS* ph = (cyrcleOldHeaderS*)(byteT*)napkinP ;

    }
        if( POOP ) return ;
        __( offBeginP ) ;
        __( cbP ) ;
        __NZ( pbP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::etherSnapCyrcleOldF( tinS& tinP , byteT*& pbP , countT& cbP , countT& offBeginP , napkinC& napkinP )/*1*/

/**/
*/
 pNapkinP
  must be 0
 offBeginP
   this is the size of the circular buffer
  will be set to the number of bytes of data that pbP points to
  must be 0
 cbP
   the oo countT objects contain the length of the data, in bytes
   each entry consists of a countT, followed by data, followed by another countT
  the format is a sequence of length prefixed and length suffixed blobs
  will point to bytes that i allocate and then fill with the contents of the circular buffer
  must be 0
 pbP
 tinP
arguments
\<A HREF=\"5.10301ba.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$etherSnapCyrcleOldF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

