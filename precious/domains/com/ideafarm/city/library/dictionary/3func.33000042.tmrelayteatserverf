
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmRelayTeatServerF )
}
    }
        }
            etThread.delF( tinP , pc4c ) ;
            etThread.delF( tinP , *(countT**)&pc4c->c3 ) ;
            etThread.delF( tinP , *(countT**)&pc4c->c1 ) ;
            stChannelExclude >> pc4c ;
            ZE( count4S* , pc4c ) ;
        {
        while( stChannelExclude )
    
        }
            etThread.delF( tinP , pc4c ) ;
            etThread.delF( tinP , *(countT**)&pc4c->c3 ) ;
            etThread.delF( tinP , *(countT**)&pc4c->c1 ) ;
            stChannelInclude >> pc4c ;
            ZE( count4S* , pc4c ) ;
        {
        while( stChannelInclude )
    
        DEL( psoP ) ;
    
        swsWrapRefP.ungrabF( tinP ) ;
        }
            THREADmODE1rESTORE
            swsWrapRefP.freeF( tinP ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            cLeverPayloadP = tinP.monitor.idThread ;
        {
    
        }
            }
                etThread.delF( tinP , pc2WrapRef ) ;
                etThread( tinP , *(soulC**)&pc2WrapRef->c1 ) ;
            {
            if( 1 == decv02AM( pc2WrapRef->c2 ) )
    
            stWrapRef >> *(countT*)&pc2WrapRef ;
            ZE( count2S* , pc2WrapRef ) ;
        {
        while( stWrapRef )
    
        sgnDone_tmRelayServerWrapToAppF.waitF( tinP ) ;
        }
            }
                stWrapRef << (countT)pc2WrapRef ;
                pc2WrapRef->c2 = 1 ;
                pc2WrapRef->c1 = 0 ;
            {
            if( pc2WrapRef )
            etThread.newF( tinP , LF , pc2WrapRef ) ; ___( pc2WrapRef ) ; //U::LEAKS SOMETIMES
            ZE( count2S* , pc2WrapRef ) ;
        {
        bQuit = 1 ;
        swsWrapRefP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        if( etThread ) { ((const poopC&)etThread).chatterF( tinP , LF ) ; LOGrAW( "tmRelayTeatServerF: etThread is impotent so BLAMMO\r\n" ) ; BLAMMO ; } //NEEDED TO PRECLUDE DEADLOCK GRABBING swsWrapRefP
    
        }
            }
                DEL( psWrap ) ; //MIGHT BE 0 IFF I CALLED relayOldC::doWrapLocallyIfIF
    
                }
                    }
                        }
                            break ;
                            DEL( psGift ) ;
                            DEL( psWrapo ) ;
                            }
                                }
                                    }
                                        bQuit = 1 ;
                                        POOPR
                                    {
                                    if( POOP )
                                    psoP->writeF( tinP , *psWrapo ) ;
                                    SCOOPS
                                {
                                etThread.traceF( tinP , T("writing *psWrapo ifcIDtYPEwRAP_QUERYrELAYiDpORTtIMEcaLLhOMES") ) ;
        
                                *psWrapo << *psGift ;
                                *psWrapo << (countT)ifcIDtYPEwRAP_REPLYrELAYiDpORTtIMEcaLLhOMES ;
                                *psWrapo << (countT)1 ; // idVersion
                                *psWrapo << (countT)ifcIDpROTOCOL_RELAYwRAP ;
                                *psWrapo << (strokeS*)tTM ;
                                TN( tTM , "IdeaFarm " "(tm)" ) ;
        
                                UNGRABrELAYlISTS
                                }
                                    while( !stIdptOpenP.third && ~hDown ) ;
                                    do *(idPortTimeC*)&stIdptOpenP.downF( tinP , hDown ) >> *psGift ;
                                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( stIdptOpenP )
                                *psGift << (countT)stIdptOpenP ;
                                GRABrELAYlISTS
                            {
                            if( psGift && psWrapo )
                            soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psGift ) ;
                            soulC* psWrapo = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrapo ) ;
                        {
                        case ifcIDtYPEwRAP_QUERYrELAYiDpORTtIMEcaLLhOMES :
                        }
                            break ;
                            DEL( psGift ) ;
                            DEL( psWrapo ) ;
                            }
                                }
                                    }
                                        bQuit = 1 ;
                                        POOPR
                                    {
                                    if( POOP )
                                    psoP->writeF( tinP , *psWrapo ) ;
                                    SCOOPS
                                {
                                etThread.traceF( tinP , T("writing *psWrapo ifcIDtYPEwRAP_QUERYrELAYiDpORTtIMEc") ) ;
        
                                *psWrapo << *psGift ;
                                *psWrapo << (countT)ifcIDtYPEwRAP_REPLYrELAYiDpORTtIMEc ;
                                *psWrapo << (countT)1 ; // idVersion
                                *psWrapo << (countT)ifcIDpROTOCOL_RELAYwRAP ;
                                *psWrapo << (strokeS*)tTM ;
                                TN( tTM , "IdeaFarm " "(tm)" ) ;
        
                                idptP >> *psGift ;
                            {
                            if( psGift && psWrapo )
                            soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psGift ) ;
                            soulC* psWrapo = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrapo ) ;
                        {
                        case ifcIDtYPEwRAP_QUERYrELAYiDpORTtIMEc :
                        }
                            break ;
                            DEL( psGift ) ;
                            DEL( psWrapo ) ;
                            }
                                }
                                    }
                                        bQuit = 1 ;
                                        POOPR
                                    {
                                    if( POOP )
                                    psoP->writeF( tinP , *psWrapo ) ;
                                    SCOOPS
                                {
                                etThread.traceF( tinP , T("writing *psWrapo ifcIDtYPEwRAP_QUERYrELAYrANK") ) ;
        
                                *psWrapo << *psGift ;
                                *psWrapo << (countT)ifcIDtYPEwRAP_REPLYrELAYrANK ;
                                *psWrapo << (countT)1 ; // idVersion
                                *psWrapo << (countT)ifcIDpROTOCOL_RELAYwRAP ;
                                *psWrapo << (strokeS*)tTM ;
                                TN( tTM , "IdeaFarm " "(tm)" ) ;
        
                                *psGift << idRank ;
                                UNGRABrELAYlISTS
                                }
                                    while( !stIdptOpenP.third && ~hDown ) ;
                                    }
                                        THREADmODE1rESTORE
                                        //CONoUTrAW( TF1(++ids)+T(": ")+TT(time.time1,time.time2)+T(" ")+TF1((countT)idpt)+T(" ")+TF1((nicNameC&)idpt)+T("\r\n") ) ;
                                        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                        timeS time = idpt ;
                                        idPortTimeC& idpt = *(idPortTimeC*)&stIdptOpenP.downF( tinP , hDown ) ;
                                    {
                                    do
                                    handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    ZE( countT , ids ) ;
                                {
                                if( stIdptOpenP )
                                //CONoUTrAW( T("the requested idRank is ")+TF1(idRank)+T("\r\n") ) ;
                                countT idRank = stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                GRABrELAYlISTS
                            {
                            if( psGift && psWrapo )
                            soulC* psGift = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psGift ) ;
                            soulC* psWrapo = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrapo ) ;
                        {
                        case ifcIDtYPEwRAP_QUERYrELAYrANK :
                        }
                            break ;
                            }
                                DEL( psBag ) ;
                                if( bDontHoldBreath ) relayOldC::doWrapLocallyIfIF( tinP , etThread , RELAYiNFOaRGS , *psWrap , idptP ) ;
            
                                relayOldC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                                //tinP.pEther->traceF( tinP , T("tmRelayTeatServerF: calling popIF [bRoot,bDontHoldBreath]:    ")+TF2(bRoot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(bDontHoldBreath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                *psBag << *psWrap ;
                                relayOldC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , bRoot ? flRELAYpOP_UP : flRELAYpOP_DOWN , ifcIDtYPEbAG_WRAP ) ;
            
                                UNGRABrELAYlISTS
                                boolT bDontHoldBreath = bRoot /*&& stIdptOpenP < 4*/ ; //IF bDontHoldBreath THEN THE ROOT WILL NOT EVER GET ITS OWN POP
                                boolT bRoot = pnRoot && *pnRoot == idptP ;
                                idPortTimeC* pnRoot = stIdptOpenP ? (idPortTimeC*)&stIdptOpenP[ 1 ] : 0 ;
                                GRABrELAYlISTS
                            {
                            if( psBag )
                            soulC* psBag = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBag ) ;
        
                            if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATORrEGISTRATION ) { static countT idIn ; tinP.pEther->traceF( tinP , TF2(++idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" tmRelayTeatServerF: ifcIDtYPEwRAP_GIFT (mediator registration channel)") ) ; }
        
                            }
                                THREADmODE1rESTORE
                                //tinP.pEther->traceF( tinP , T("wrap from app for channel ")+T(pczChannel) ) ;
                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                            {
                            else
                            if( bDebug ) { CONoUTrAW3( "teat read a secret wrap that contains " , (countT)*psWrap , " members\r\n" ) ; }
        
                                bDebug = 1 ;
                            if( pczChannel && pczChannel[ 0 ] == ifcIDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcIDcHANNELfUNCTION_MEDIATED && pczChannel[ 2 ] == ifcIDaDAM_SECRETsERVICE && pczChannel[ 3 ] == ifcIDaDAM_CONSOLE && pczChannel[ 4 ] == ifcIDcHANNELfUNCTION_STROKEcONSOLE )
                            ZE( boolT , bDebug ) ;
        
                            countT* pczChannel = (countT*)psWrap->pbFieldF( tinP , countTC() , countTC() , countTC() , ifcIDfIELDwRAP_CHANNEL ) ;
                        {
                        case ifcIDtYPEwRAP_GIFT :
                        }
                            break ;
                            bQuit = 1 ;
                        {
                        case ifcIDtYPEwRAP_QUIT : //OPTIONAL: CLIENTS ARE ASSUMED TO BE RUDE
                        }
                            break ;
                        {
                        case ifcIDtYPEwRAP_CHANNELiNCLUDEpOPaLL :
                        }
                            break ;
                        {
                        case ifcIDtYPEwRAP_CHANNELiNCLUDEpOP :
                        }
                            break ;
                            }
                                stChannel << pc4c ;
                                stackC& stChannel = idType == ifcIDtYPEwRAP_CHANNELiNCLUDEpUSH ? stChannelInclude : stChannelExclude ;
        
                                if( pcFilter ) etThread.memCopyF( tinP , (byteT*)pcFilter , (byteT*)pcFilterFrom , ccFilter * sizeof( countT ) ) ;
                                etThread.newF( tinP , LF , pcFilter , ccFilter ) ; ___( pcFilter ) ;
                                ccFilter  = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_CCfILTER ) ;
                                countT* pcFilterFrom = (countT*)psWrap->pbFieldF( tinP , countTC() , countTC() , countTC() , ifcIDfIELDwRAP_FILTER ) ;
        
                                ccTestMax = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_CCtESTmAX ) ;
        
                                if( pczTest ) etThread.memCopyF( tinP , (byteT*)pczTest , (byteT*)pczChannel , cca * sizeof( countT ) ) ;
                                etThread.newF( tinP , LF , pczTest , cca ) ; ___( pczTest ) ;
                                countT cca = 1 + etThread.strBodyLengthF( tinP , pczChannel ) ;
        
                                countT&  ccFilter  =  *(countT*)&pc4c->c4 ;
                                countT*& pcFilter  = *(countT**)&pc4c->c3 ;
                                countT&  ccTestMax =  *(countT*)&pc4c->c2 ;
                                countT*& pczTest   = *(countT**)&pc4c->c1 ;    
                            {
                            if( pc4c )
                            etThread.newF( tinP , LF , pc4c ) ; ___( pc4c ) ;
                            ZE( count4S* , pc4c ) ;
                            countT* pczChannel = (countT*)psWrap->pbFieldF( tinP , countTC() , countTC() , countTC() , ifcIDfIELDwRAP_CHANNEL ) ;
                        {
                        case ifcIDtYPEwRAP_CHANNELeXCLUDEpUSH :
                        case ifcIDtYPEwRAP_CHANNELiNCLUDEpUSH :
                    {
                    switch( idType )
                    //CONoUTrAW3( "tmRelayTeatServerF [idType]: " , idType , "\r\n" ) ;
                    countT idType = psWrap->cFieldF( tinP , ifcIDfIELDwRAP_IDtYPE ) ;
                {
                if( !bQuit )
    
                }
                    etThread.delF( tinP , psttTM ) ;
                    }
                        }
                            bQuit = 1 ;
                            POOPRqUIET
                            tinP.pEther->traceF( tinP , T("tmRelayTeatServerF / wrapper contains garbage") ) ;
                        {
                        if( POOP )
                        __( psWrap->cFieldF( tinP , ifcIDfIELDwRAP_IDvERSION ) - 1 ) ; //idVersion
                        __( psWrap->cFieldF( tinP , ifcIDfIELDwRAP_IDpROTOCOL ) - ifcIDpROTOCOL_RELAYwRAP ) ;
                        __( tinP.pEtScratch->strCompareF( tinP , psttTM , T("IdeaFarm " "(tm)") ) ) ;
                        __( idTypeTM - ifcIDtYPEsOULiTEM_strokeSptr ) ;
                        __Z( psttTM ) ;
                        SCOOPS
                    {

                    }
                        //CONoUTrAW( ostoSay ) ;
                        //OStEXTA(  ostoSay , "\"\r\n" ) ;
                        //OStEXTA(  ostoSay , T(psttTM) ) ;
                        //OStEXTAK( ostoSay , "tmRelayTeatServerF [psttTM]: \"" ) ;
                        //OStEXT( ostoSay , TUCK << 2 ) ;

                        etThread.strReplaceF( tinP , psttTM , 0 , ifcIDtYPEsTRrEPLACE_MAKEiMPORT , psttTM[ 2 ].idAdam ) ; ___( psttTM ) ;
                        etThread.strDecodeF( tinP , psttTM , pbfTM ) ; ___( psttTM ) ;
                    {
                    if( pbfTM && cbfTM )
                    ZE( strokeS* , psttTM ) ;
        
                    byteT* pbfTM = psWrap->pbFieldF( tinP , idTypeTM , flagsTM , cbfTM , ifcIDfIELDwRAP_TRADEmARK ) ; //U::BUG: STRINGS OF STROKES ARE NOW ENCODED
                    ZE( countT , cbfTM ) ;
                    ZE( flagsT , flagsTM ) ;
                    ZE( countT , idTypeTM ) ;
                {
    
                }
                    }
                        break ;
                        DEL( psWrap ) ;
                        POOPR
                    {
                    if( POOP )
                    //CONoUTrAW3( "tmRelayTeatServerF: readF returned (" , idIn , ")\r\n" ) ;
                    countT idIn = 1 + incv02AM( idInLath ) ;
                    static countT idInLath ;
                    psoP->readF( tinP , *psWrap ) ;
                    SCOOPS
                {
            {
            if( psWrap )
            soulC* psWrap = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrap ) ;
        {
        while( !ether && !bQuitP && !bQuit && !etThread )
        etThread.traceF( tinP , T("tmRelayTeatServerF: client is ")+TF2(idAdamClient,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        etThread.osThreadF( tinP , countTC() , tmRelayServerWrapToAppF , &sgnDone_tmRelayServerWrapToAppF , flTHREADlAUNCH_null , 0 , (countT)&bQuit , (countT)&psoP , (countT)&stWrapRef , (countT)&stChannelInclude , (countT)&stChannelExclude , idAdamClient ) ;
        signC sgnDone_tmRelayServerWrapToAppF( tinP , TAG( TAGiDnULL ) ) ;

        }
            if( !idAdamClient ) bQuit = 1 ;
            DEL( psWrap ) ;
            }
                else       *psWrap >> idAdamClient ;
                if( POOP ) POOPR
                psoP->readF( tinP , *psWrap ) ;
                SCOOPS
            {
            if( psWrap )
            soulC* psWrap = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psWrap ) ;
        {
        ZE( countT , idAdamClient ) ;
        ZE( boolT , bQuit ) ;
    
        psoP->etherF( tinP , *tinP.pEtScratch ) ;
    
        stackC stChannelExclude( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count4S ) ;
        stackC stChannelInclude( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_count4S ) ;
    
        swsWrapRefP.ungrabF( tinP ) ;
        THREADmODE1rESTORE
        stackC& stWrapRef = (stackC&)swsWrapRefP ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        cLeverPayloadP = tinP.monitor.idThread ;
        swsWrapRefP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    IFsCRATCH

    socketC* psoP = (socketC*)pTaskP->c4 ;
    RELAYiNFOtm
{
if( pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
/*1*/TASK( tmRelayTeatServerF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

