
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bOldRemoved ;
    delF( tinP , psttDriverName ) ;
    }
        thirdC::c_strncpyIF( tinP , home.postDriverNameNew , T(psttDriverName) , sizeof home.postDriverNameNew ) ;
        if( !POOP ) *home.postDriverNameOld = 0 ;

        }
            }
                thp.osDriverUnregisterF( tinP , home.postDriverNameOld ) ;
                thp = 0 ;
                thp.osDriverFireF(       tinP , home.postDriverNameOld ) ;
                thirdC thp( tinP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ;
                bOldRemoved = 1 ;
            {
            if( idAdamOld == idAdamNew && idVersionOld != idVersionNew )

            osDriverParseNameF( tinP , idHomeNew , idAdamNew , idVersionNew , psttDriverName ) ;
            ZE( countT , idVersionNew ) ;
            ZE( countT , idAdamNew ) ;
            ZE( countT , idHomeNew ) ;

            osDriverParseNameF( tinP , idHomeOld , idAdamOld , idVersionOld , T(home.postDriverNameOld) ) ;
            ZE( countT , idVersionOld ) ;
            ZE( countT , idAdamOld ) ;
            ZE( countT , idHomeOld ) ;
        {
        if( *home.postDriverNameOld )

        if( !POOP ) *home.postDriverNameNew = 0 ;
        thirdC::c_strncpyIF( tinP , home.postDriverNameOld , home.postDriverNameNew , sizeof home.postDriverNameOld ) ;
        }
            while( *home.postDriverNameOld ) { ++ s ; osSleepF( tinP , TUCK * 0x40 ) ; }
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        homeS& home = homeS::homeIF() ;
    {
    ZE( boolT , bOldRemoved ) ;

    __( psttDriverName && CSdRIVERnAMEmAX < psttDriverName->idAdam ) ;
    osDriverNameFromMasterF( tinP , psttDriverName , idAdamP ) ; ___( psttDriverName ) ;
    ZE( strokeS* , psttDriverName ) ;

    _IO_

    }
        if( POOP ) return 0 ;
        __( idAdamP != ifcIDaDAM_KERNEL2MONITOR && idAdamP != ifcIDaDAM_KERNEL1DRIVER ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/boolT etherC::osDriverRemoveOldF( tinS& tinP , const countT idAdamP )/*1*/

/**/
*/
after firing the old instance, and unregistering it, i store my driver's name in homeS::homeIF()
my purpose is to allow a new instance of a driver to fire the currently hired instance
it is illegal to refer to this symbol except in the definition of the driver that is being fired
it is illegal to refer to this symbol except in the definition of adam f040104
i evaluate to 1 iff i removed a currently working driver
\<A HREF=\"5.1030165.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$osDriverRemoveOldF.0.html\"\>instances\</A\>
/*



//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

