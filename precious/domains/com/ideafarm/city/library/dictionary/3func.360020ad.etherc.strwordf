
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_

    }
        }
            POSTPONEtEST( psttP ) ;
            strSubstringF( tinP , psttP , idf , idl , psttBigP , csttExtraP ) ; // CALLER MUST TAG
        {
        else if( psttBigP->idAdam >= idl )
        }
            POSTPONEtEST( psttP ) ;
            strMakeF( tinP , psttP , T("") , csttExtraP ) ; // CALLER MUST TAG. TRAILING BLANKS WERE SEEN AS THE LEFT DELIMITER OF THE WORD
        {
        else if( psttBigP->idAdam == idf - 1 )
        if( !idf ) ;

        else idf = 0 ;
        }
            idf = iddLeft + 1 ;
        {
        else if( cFound == idP - 1 )
        }
            idl = iddRight - 1 ;
            idf = iddLeft  + 1 ;
        {
        if( cFound == idP )

        }
            }
                }
                    else if( cFound == idP     ) iddRight = idd ;
                         if( cFound == idP - 1 ) iddLeft  = idd ;
                    cFound ++ ;
                {
                if( idd )
                countT idd = strIdAnyF( tinP , idf2 , sttQuoteP , sttDelimiter , psttBigP ) ;
            {
            while( idf2 && cFound < idP )
            countT idf2 = 1 ;
            // LOOK FOR DELIMITERS
        {
        ZE( countT , cFound ) ;
        ZE( countT , iddRight ) ;
        ZE( countT , iddLeft ) ;
        ZE( countT , idl ) ;
        countT idf = 1 ;
    {
    else
    }
        }
            POSTPONEtEST( psttP ) ;
            strWordF( tinP , psttP , psttBigP , sttQuoteP , sttDelimiterP , cWords + idP + 1 , csttExtraP ) ; // CALLER MUST TAG ___( psttP ) ;
        {
        if( cWords + idP >= 0 )
        sCountT cWords = strCLinesF( tinP , psttBigP , tDelim , 1 ) ;
        TN( tDelim , "" ) ; tDelim = T("")+sttDelimiter ;
    {
    if( idP < 0 )

    strokeS sttDelimiter = (countT)sttDelimiterP ? sttDelimiterP : S1C('/') ;

    _INoLD_

    }
        if( POOP ) return ;
        __Z( idP ) ;
        __Z( psttBigP ) ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/**//*1*/voidT etherC::strWordF( tinS& tinP , strokeS*& psttP , const strokeS* const psttBigP , strokeS& sttQuoteP , const strokeS sttDelimiterP , const sCountT idP , const countT csttExtraP )/*1*/
*/
 csttExtraP
  if negative then indexes from the end of psttBigP
    it is up to the caller to choose to decide whether terminating delimiters have semantic value
    delimiters at the end of a string are not assumed to have no semantic value
   it also reflects a fundamental of the ifc approach to parsing
   this is inconvenient for text parsing but makes sense for general token parsing
  if psttBigP ends with a run of delimiters, the last word is a null length word
  must not be 0
 idP
  U::CHANGE MY FUNCTION SO THAT I TAKE psttDelimitersP AND WORK THE SAME WAY AS strWordsOldF
  if 0 then S1C('/') is used
 sttDelimiterP
 sttQuoteP
  must not be 0
 psttBigP
  must be 0
 psttP
arguments
if there are not idP words, then psttP is not allocated
gets the idP'th word
  \<A HREF=\"5.2b10104.1.1.0.html\"\>2b10104:  WAKEsHOW( "example.simplest.func.10300c7.etherC.strWordF" )\</A\>
 simplest
examples
\<A HREF=\"5.10300c7.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strWordF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

