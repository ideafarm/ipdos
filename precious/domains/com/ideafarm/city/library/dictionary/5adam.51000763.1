
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tinP , T("ok") ) ;
WAITuNTILaLMOSTaLONE( 1 )
etThread.traceF( tinP , T("waiting for all threads to finish") ) ;

}
    etThread.osThreadF( TaRG1( tmWorkerF ) , (countT)pptRoot[ offt ] , (countT)pcArgInner ) ;
{
for( countT offt = 0 ; offt < cRoot ; offt ++ )

}
    case IDcOMPUTER_FACTORY9 : { cRoot = 7 ; pptRoot[ 0 ] = &tFactory9Root1 ; pptRoot[ 1 ] = &tFactory9Root2 ; pptRoot[ 2 ] = &tFactory9Root3 ; pptRoot[ 3 ] = &tFactory9Root4 ; pptRoot[ 4 ] = &tFactory9Root5 ; pptRoot[ 5 ] = &tFactory9Root6 ; pptRoot[ 6 ] = &tFactory9Root7 ; break ; }
    case IDcOMPUTER_FACTORY3 : { cRoot = 1 ; pptRoot[ 0 ] = &tFactory3Root1                                                                                                                                                                                                       ; break ; }
    case IDcOMPUTER_FACTORY2 : { cRoot = 1 ; pptRoot[ 0 ] = &tFactory2Root1                                                                                                                                                                                                       ; break ; }
    case IDcOMPUTER_FACTORY1 : { cRoot = 4 ; pptRoot[ 0 ] = &tFactory1Root1 ; pptRoot[ 1 ] = &tFactory1Root2 ; pptRoot[ 2 ] = &tFactory1Root3 ; pptRoot[ 3 ] = &tFactory1Root4                                                                                                    ; break ; }
{                                //CS:CODEsYNC 51000760 51000760
switch( idComputer )
textC*  pptRoot[ 0x10 ] ; //CS:CODEsYNC 51000760 51000760
ZE( countT , cRoot ) ;

etThread.traceF( tinP , T("idComputer: ")+TF2(idComputer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
countT idComputer = etThread.diskIdF( tinP , T("///c") ) ;

TN( tRootTest , "///d/archive.test/1999/" ) ;

TN( tFactory9Root7 , "///z/archive/" ) ;
TN( tFactory9Root6 , "///y/archive.snap/" ) ;
TN( tFactory9Root5 , "///y/archive/" ) ;
TN( tFactory9Root4 , "///x/archive/" ) ;
TN( tFactory9Root3 , "///w/archive/" ) ;
TN( tFactory9Root2 , "///e/archive/" ) ;
TN( tFactory9Root1 , "///d/archive.not.yet.verified/" ) ;

TN( tFactory3Root1 , "///e/archive/" ) ;

TN( tFactory2Root1 , "///d/archive.not.yet.verified/" ) ;

TN( tFactory1Root4 , "///g/archive.save.1999/" ) ;
TN( tFactory1Root3 , "///g/archive/" ) ;
TN( tFactory1Root2 , "///e/archive.part2/" ) ;
TN( tFactory1Root1 , "///d/archive.part1/" ) ;

countT pcArgInner[] = { (countT)&etThread , (countT)&tDot , (countT)&tDataDotJpg , (countT)&tDataDotJpeg , (countT)&tDataDotPdf , (countT)&tDataDotMsv , (countT)&tDataDotAvi , (countT)&tDataDotMp3 , (countT)&tDataDotPng } ;




















































































TN( tDataDotPng  , "data.png"  ) ;
TN( tDataDotMp3  , "data.mp3"  ) ;
TN( tDataDotAvi  , "data.avi"  ) ;
TN( tDataDotMsv  , "data.msv"  ) ;
TN( tDataDotPdf  , "data.pdf"  ) ;
TN( tDataDotJpeg , "data.jpeg" ) ;
TN( tDataDotJpg  , "data.jpg"  ) ;
TN( tDot , "." ) ;

TODO

DONE( tmWorkerF )
}
    etThread.traceF( tinP , T("root ---- [cFiles,cDirs]:    ")+*ptRootP+tb4+TF2(cFiles,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(cDirs,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
    etThread.diskWalkF( tinP , cDirs , cFiles , *ptRootP , ether , flDISKwALK_null , inspectCBF , pcArgInnerP , 0 , 0 ) ;
    etThread.traceF( tinP , T("root ++++               :    ")+*ptRootP ) ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs ) ;

    TN( tb4 , "    " ) ;
    countT* pcArgInnerP = (countT*)pTaskP->c2 ;
    textC*  ptRootP     =  (textC*)pTaskP->c1 ;

    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )

}
    return 0 ;

    }
        }
            }
                DELzOMBIE( pFwsIn ) ;

                }
                    }
                        }
                            break ;
                            if( !isPngF( pbCopy ) ) traceActualTypeF( tinP , etherP , pbCopy , cbwIn , tName , idType ) ;
                        {
                        case ADAMdATAtYPE_PNG :
                        }
                            break ;
                            if( !isMp3F( pbCopy ) ) traceActualTypeF( tinP , etherP , pbCopy , cbwIn , tName , idType ) ;
                        {
                        case ADAMdATAtYPE_MP3 :
                        }
                            break ;
                            if( !isAviF( pbCopy ) ) traceActualTypeF( tinP , etherP , pbCopy , cbwIn , tName , idType ) ;
                        {
                        case ADAMdATAtYPE_AVI :
                        }
                            break ;
                            if( !isMsvF( pbCopy ) ) traceActualTypeF( tinP , etherP , pbCopy , cbwIn , tName , idType ) ;
                        {
                        case ADAMdATAtYPE_MSV :
                        }
                            break ;
                            if( !isPdfF( pbCopy ) ) traceActualTypeF( tinP , etherP , pbCopy , cbwIn , tName , idType ) ;
                        {
                        case ADAMdATAtYPE_PDF :
                        }
                            break ;
                            if( !isJpgF( pbCopy ) ) traceActualTypeF( tinP , etherP , pbCopy , cbwIn , tName , idType ) ;
                        {
                        case ADAMdATAtYPE_JPG :
                    {
                    else switch( idType )
                    else if( cbwIn < 0x10 ) etherP.traceF( tinP , T("error: window is tiny") ) ;
                    if( !pbwIn ) etherP.traceF( tinP , T("error: could not get window pointer") ) ;

                    }
                        pbCopy[ cbwIn - 1 ] = 0 ;
                        thirdC::c_memcpyIF( tinP , pbCopy , pbwIn , cbwIn ) ;
                    {
                    if( pbwIn && cbwIn )
                    byteT pbCopy[ CBwINDOW + 1 ] ;

                    pFwsIn->getF( tinP , pbwIn , cbwIn , CBwINDOW ) ;
                    ZE( countT , cbwIn ) ;
                    ZE( byteT* , pbwIn ) ;
                {
                else
                }
                    etherP.traceF( tinP , T("could not ct file windows") ) ;

                    DELzOMBIE( pFwsIn ) ;
                    POOPR ;
                {
                if( POOP )

                fileWindowsC* pFwsIn = new( 0 , tinP , pb_fwsIn , sizeof pb_fwsIn ) fileWindowsC( tinP , *tinP.pEtScratch , tName , flFILEwINDOW_null , 1 ) ;

                byteT pb_fwsIn[ sizeof( fileWindowsC ) ] ;

                SCOOPS
            {
            IFsCRATCH

            //etherP.traceF( tinP , tName ) ;
        {
        if( idType )

        else if( !etherP.strCompareF( tinP , tDataDotExt , tDataDotPngP  ) ) idType = ADAMdATAtYPE_PNG ;
        else if( !etherP.strCompareF( tinP , tDataDotExt , tDataDotAviP  ) ) idType = ADAMdATAtYPE_AVI ;
        else if( !etherP.strCompareF( tinP , tDataDotExt , tDataDotMsvP  ) ) idType = ADAMdATAtYPE_MSV ;
        else if( !etherP.strCompareF( tinP , tDataDotExt , tDataDotPdfP  ) ) idType = ADAMdATAtYPE_PDF ;
        else if( !etherP.strCompareF( tinP , tDataDotExt , tDataDotJpegP ) ) idType = ADAMdATAtYPE_JPG ;
             if( !etherP.strCompareF( tinP , tDataDotExt , tDataDotJpgP  ) ) idType = ADAMdATAtYPE_JPG ;
        ZE( countT , idType ) ;

        }
            etherP.delF( tinP , psttDataDotExt ) ;
            etherP.delF( tinP , psttNU ) ;
            tDataDotExt = T(psttDataDotExt) ;
            etherP.strBisectF( tinP , psttNU , psttDataDotExt , tName , tDotP , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttNU ) ; ___( psttDataDotExt ) ;
            ZE( strokeS* , psttDataDotExt ) ;
            ZE( strokeS* , psttNU ) ;
        {
        TN( tDataDotExt , "" ) ;

        etherP.traceF( tinP , tName ) ;
        etherP.traceF( tinP , T("------------------------------------------------------------------") ) ;

        }
            etherP.delF( tinP , psttLower ) ;
            tName = T(psttLower) ;
            etherP.strConvertToLowerCaseF( tinP , psttLower , T(ifName) ) ; ___( psttLower ) ;
            ZE( strokeS* , psttLower ) ;
            ifFileNameC ifName( tinP , etherP , postNameP ) ;
        {
        TN( tName , "" ) ;

        if( !( cFilesP % ( TOCK >> 4 ) ) ) etherP.traceF( tinP , T("[cFiles]:    ")+TF2(cFilesP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        textC&  tDataDotPngP  =  *(textC*)pcArgP[ 8 ] ;
        textC&  tDataDotMp3P  =  *(textC*)pcArgP[ 7 ] ;
        textC&  tDataDotAviP  =  *(textC*)pcArgP[ 6 ] ;
        textC&  tDataDotMsvP  =  *(textC*)pcArgP[ 5 ] ;
        textC&  tDataDotPdfP  =  *(textC*)pcArgP[ 4 ] ;
        textC&  tDataDotJpegP =  *(textC*)pcArgP[ 3 ] ;
        textC&  tDataDotJpgP  =  *(textC*)pcArgP[ 2 ] ;
        textC&  tDotP         =  *(textC*)pcArgP[ 1 ] ;
        etherC& etherP        = *(etherC*)pcArgP[ 0 ] ;
        _IO_
    {
    if( postNameP )
    _IO_
{
boolT inspectCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

}
    etherP.boxPutF( tinP , tNameP+T(".woth.window") , pbP , cbP ) ;

    if( !bSilent ) etherP.traceF( tinP , tError ) ;

    else                                                                             tError = T("error:    unk    ")+tNameP ;
    else if( isPngF( pbP ) ) {    if( idTypeP == ADAMdATAtYPE_PDF ) bSilent = 1 ;    tError = T("error:    png    ")+tNameP ; }
    else if( isMp3F( pbP ) )                                                         tError = T("error:    mp3    ")+tNameP ;
    else if( isAviF( pbP ) )                                                         tError = T("error:    avi    ")+tNameP ;
    else if( isMsvF( pbP ) )                                                         tError = T("error:    msv    ")+tNameP ;
    else if( isPdfF( pbP ) )                                                         tError = T("error:    pdf    ")+tNameP ;
         if( isJpgF( pbP ) )                                                         tError = T("error:    jpg    ")+tNameP ;
                             
    TN( tError , "" ) ;
    ZE( boolT , bSilent ) ;
    _IO_
{
voidT traceActualTypeF( tinS& tinP , etherC& etherP , const byteT* const pbP , const countT cbP , textC& tNameP , const countT idTypeP )

}
    ;
    && pbP[ 3 ] == 'G'
    && pbP[ 2 ] == 'N'
    && pbP[ 1 ] == 'P'
       pbP[ 0 ] == 0x89
    return
{
boolT isPngF( const byteT* pbP )

}
    ;
    && pbP[ 2 ] == '3'
    && pbP[ 1 ] == 'D'
       pbP[ 0 ] == 'I'
    return
{
boolT isMp3F( const byteT* pbP )

}
    ;
    )
        && pbP[ 0x6f ] == 's'
        && pbP[ 0x6e ] == 'd'
        && pbP[ 0x6d ] == 'i'
        && pbP[ 0x6c ] == 'v'
        && pbP[    7 ] == 0x00
        && pbP[    6 ] == 0x00
        && pbP[    5 ] == 0x00
        && pbP[    4 ] == 0x00
        && pbP[    3 ] == 0x00
        && pbP[    2 ] == 0x38
        && pbP[    1 ] == 0x4a
           pbP[    0 ] == 0xc3
    (
    ||
    )
        && pbP[ 3 ] == 'F'
        && pbP[ 2 ] == 'F'
        && pbP[ 1 ] == 'I'
           pbP[ 0 ] == 'R'
    (
    return
{
boolT isAviF( const byteT* pbP )

}
    ;
    )
        && pbP[ 7 ] == 'E'
        && pbP[ 6 ] == 'C'
        && pbP[ 5 ] == 'I'
        && pbP[ 4 ] == 'O'
        && pbP[ 3 ] == 'V'
        && pbP[ 2 ] == '_'
        && pbP[ 1 ] == 'S'
           pbP[ 0 ] == 'M'
    (
    ||
    )
        && pbP[ 1 ] == 0x80
           pbP[ 0 ] == 0x80
    (
    return
{
boolT isMsvF( const byteT* pbP )

}
    ;
    )
        && thirdC::c_strstrIF( pbP + 6 , "%PDF-" )
        && pbP[ 5 ] == '-'
        && pbP[ 4 ] == '-'
        && pbP[ 3 ] == '-'
        && pbP[ 2 ] == '-'
        && pbP[ 1 ] == '-'
           pbP[ 0 ] == '-'
    (
    ||
    )
        && pbP[ 4 ] == '-'
        && pbP[ 3 ] == 'F'
        && pbP[ 2 ] == 'D'
        && pbP[ 1 ] == 'P'
           pbP[ 0 ] == '%'
    (
    return
{
boolT isPdfF( const byteT* pbP )

}
    ;
    )
        && pbP[ 0x10 ] == 'E'
        && pbP[ 0x0f ] == 'L'
        && pbP[ 0x0e ] == 'I'
        && pbP[ 0x0d ] == 'F'
        && pbP[ 0x0c ] == 'O'
        && pbP[ 0x0b ] == 'R'
        && pbP[ 0x0a ] == 'P'
        && pbP[ 0x09 ] == '_'
        && pbP[ 0x08 ] == 'C'
        && pbP[ 0x07 ] == 'C'
        && pbP[ 0x06 ] == 'I'
        && pbP[ 0x05 ] == 0x1c
        && pbP[ 0x04 ] == 0x02
        && pbP[ 0x03 ] == 0xe2
        && pbP[ 0x02 ] == 0xff
        && pbP[ 0x01 ] == 0xd8
           pbP[ 0x00 ] == 0xff
    (
    ||
    )
        && pbP[ 9 ] == 'f'
        && pbP[ 8 ] == 'i'
        && pbP[ 7 ] == 'x'
           pbP[ 6 ] == 'E'
    (
    ||
    )
        && pbP[ 9 ] == 'F'
        && pbP[ 8 ] == 'I'
        && pbP[ 7 ] == 'F'
           pbP[ 6 ] == 'J'
    (
    return
{
boolT isJpgF( const byteT* pbP )

#define CBwINDOW                   ( TUCK << 2 )

#define ADAMdATAtYPE_PNG           0x6
#define ADAMdATAtYPE_MP3           0x5
#define ADAMdATAtYPE_AVI           0x4
#define ADAMdATAtYPE_MSV           0x3
#define ADAMdATAtYPE_PDF           0x2
#define ADAMdATAtYPE_JPG           0x1


/*1*/WAKEsHOWtEXT( "tool.archive.detect.malicious.file.encryption" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
