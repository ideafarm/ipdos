
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

ether.loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    etThread.osThreadF( TaRG1( tmWorkerF ) , (countT)ptRoot[ offt ] , (countT)pcArgInner ) ;
{
for( countT offt = 0 ; offt < sizeof ptRoot / sizeof ptRoot[ 0 ] ; offt ++ )

textC* ptRoot[] = { &tRoot1 , &tRoot2 , &tRoot3 , &tRoot4 , &tRoot5 , &tRoot6 , &tRoot7 , &tRoot8 , &tRoot9 , &tRoota , &tRootb , &tRootc } ;

//textC* ptRoot[] = { &tRootTest } ;

TN( tRootTest , "///d/archive.test/" ) ;

TN( tRootc , "////factory9/z/archive/" ) ;
TN( tRootb , "////factory9/y/archive.snap/" ) ;
TN( tRoota , "////factory9/y/archive/" ) ;
TN( tRoot9 , "////factory9/w/archive/" ) ;
TN( tRoot8 , "////factory9/e/archive/" ) ;
TN( tRoot7 , "////factory9/d/archive.not.yet.verified/" ) ;
TN( tRoot6 , "////factory3/e/archive/" ) ;
TN( tRoot5 , "////factory2/d/archive.not.yet.verified/" ) ;
TN( tRoot4 , "///g/archive.save.1999/" ) ;
TN( tRoot3 , "///g/archive/" ) ;
TN( tRoot2 , "///e/archive.part2/" ) ;
TN( tRoot1 , "///d/archive.part1/" ) ;

countT pcArgInner[] = { (countT)&etThread , (countT)&tDot , (countT)&tDataDotJpg , (countT)&tDataDotJpeg , (countT)&tDataDotPdf , (countT)&tDataDotMsv , (countT)&tDataDotAvi , (countT)&tDataDotMp3 , (countT)&tDataDotPng } ;

TN( tDataDotPng  , "data.png"  ) ;
TN( tDataDotMp3  , "data.mp3"  ) ;
TN( tDataDotAvi  , "data.avi"  ) ;
TN( tDataDotMsv  , "data.msv"  ) ;
TN( tDataDotPdf  , "data.pdf"  ) ;
TN( tDataDotJpeg , "data.jpeg" ) ;
TN( tDataDotJpg  , "data.jpg"  ) ;
TN( tDot , "." ) ;

TODO

DONE( tmWorkerF )
}
    etThread.traceF( tinP , T("root ---- [cFiles,cDirs]:    ")+*ptRootP+tb4+TF2(cFiles,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(cDirs,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
    etThread.diskWalkF( tinP , cDirs , cFiles , *ptRootP , ether , flDISKwALK_null , inspectCBF , pcArgInnerP , 0 , 0 ) ;
    etThread.traceF( tinP , T("root ++++               :    ")+*ptRootP ) ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs ) ;

    TN( tb4 , "    " ) ;
    countT* pcArgInnerP = (countT*)pTaskP->c2 ;
    textC*  ptRootP     =  (textC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )

}
    return 0 ;

    }
        }
            }
                DELzOMBIE( pFwsIn ) ;

                }
                    }
                        }
                            break ;
                            if( !isPngF( pbwIn ) ) traceActualTypeF( tinP , etherP , pbwIn , tName ) ;
                        {
                        case ADAMdATAtYPE_PNG :
                        }
                            break ;
                            if( !isMp3F( pbwIn ) ) traceActualTypeF( tinP , etherP , pbwIn , tName ) ;
                        {
                        case ADAMdATAtYPE_MP3 :
                        }
                            break ;
                            if( !isAviF( pbwIn ) ) traceActualTypeF( tinP , etherP , pbwIn , tName ) ;
                        {
                        case ADAMdATAtYPE_AVI :
                        }
                            break ;
                            if( !isMsvF( pbwIn ) ) traceActualTypeF( tinP , etherP , pbwIn , tName ) ;
                        {
                        case ADAMdATAtYPE_MSV :
                        }
                            break ;
                            if( !isPdfF( pbwIn ) ) traceActualTypeF( tinP , etherP , pbwIn , tName ) ;
                        {
                        case ADAMdATAtYPE_PDF :
                        }
                            break ;
                            if( !isJpgF( pbwIn ) ) traceActualTypeF( tinP , etherP , pbwIn , tName ) ;
                        {
                        case ADAMdATAtYPE_JPG :
                    {
                    else switch( idType )
                    else if( cbwIn < 0x10 ) etherP.traceF( tinP , T("error: window is tiny") ) ;
                    if( !pbwIn ) etherP.traceF( tinP , T("error: could not get window pointer") ) ;

                    pFwsIn->getF( tinP , pbwIn , cbwIn , 0x10 ) ;
                    ZE( countT , cbwIn ) ;
                    ZE( byteT* , pbwIn ) ;
                {
                else
                }
                    etherP.traceF( tinP , T("could not ct file windows") ) ;

                    DELzOMBIE( pFwsIn ) ;
                    POOPR ;
                {
                if( POOP )

                fileWindowsC* pFwsIn = new( 0 , tinP , pb_fwsIn , sizeof pb_fwsIn ) fileWindowsC( tinP , *tinP.pEtScratch , tName , flFILEwINDOW_null , 1 ) ;

                byteT pb_fwsIn[ sizeof( fileWindowsC ) ] ;

                SCOOPS
            {
            IFsCRATCH

            //etherP.traceF( tinP , tName ) ;
        {
        if( idType )

        else if( !etherP.strCompareF( tinP , tDataDotExt , tDataDotPngP  ) ) idType = ADAMdATAtYPE_PNG ;
        else if( !etherP.strCompareF( tinP , tDataDotExt , tDataDotAviP  ) ) idType = ADAMdATAtYPE_AVI ;
        else if( !etherP.strCompareF( tinP , tDataDotExt , tDataDotMsvP  ) ) idType = ADAMdATAtYPE_MSV ;
        else if( !etherP.strCompareF( tinP , tDataDotExt , tDataDotPdfP  ) ) idType = ADAMdATAtYPE_PDF ;
        else if( !etherP.strCompareF( tinP , tDataDotExt , tDataDotJpegP ) ) idType = ADAMdATAtYPE_JPG ;
             if( !etherP.strCompareF( tinP , tDataDotExt , tDataDotJpgP  ) ) idType = ADAMdATAtYPE_JPG ;
        ZE( countT , idType ) ;

        }
            etherP.delF( tinP , psttDataDotExt ) ;
            etherP.delF( tinP , psttNU ) ;
            tDataDotExt = T(psttDataDotExt) ;
            etherP.strBisectF( tinP , psttNU , psttDataDotExt , tName , tDotP , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttNU ) ; ___( psttDataDotExt ) ;
            ZE( strokeS* , psttDataDotExt ) ;
            ZE( strokeS* , psttNU ) ;
        {
        TN( tDataDotExt , "" ) ;

        }
            etherP.delF( tinP , psttLower ) ;
            tName = T(psttLower) ;
            etherP.strConvertToLowerCaseF( tinP , psttLower , T(ifName) ) ; ___( psttLower ) ;
            ZE( strokeS* , psttLower ) ;
            ifFileNameC ifName( tinP , etherP , postNameP ) ;
        {
        TN( tName , "" ) ;

        if( !( cFilesP % ( TOCK >> 4 ) ) ) etherP.traceF( tinP , T("[cFiles]:    ")+TF2(cFilesP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        textC&  tDataDotPngP  =  *(textC*)pcArgP[ 8 ] ;
        textC&  tDataDotMp3P  =  *(textC*)pcArgP[ 7 ] ;
        textC&  tDataDotAviP  =  *(textC*)pcArgP[ 6 ] ;
        textC&  tDataDotMsvP  =  *(textC*)pcArgP[ 5 ] ;
        textC&  tDataDotPdfP  =  *(textC*)pcArgP[ 4 ] ;
        textC&  tDataDotJpegP =  *(textC*)pcArgP[ 3 ] ;
        textC&  tDataDotJpgP  =  *(textC*)pcArgP[ 2 ] ;
        textC&  tDotP         =  *(textC*)pcArgP[ 1 ] ;
        etherC& etherP        = *(etherC*)pcArgP[ 0 ] ;
    {
    if( postNameP )
{
boolT inspectCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

}
    etherP.traceF( tinP , tError ) ;

    else                     tError = T("error:    unk    ")+tNameP ;
    else if( isPngF( pbP ) ) tError = T("error:    png    ")+tNameP ;
    else if( isMp3F( pbP ) ) tError = T("error:    mp3    ")+tNameP ;
    else if( isAviF( pbP ) ) tError = T("error:    avi    ")+tNameP ;
    else if( isMsvF( pbP ) ) tError = T("error:    msv    ")+tNameP ;
    else if( isPdfF( pbP ) ) tError = T("error:    pdf    ")+tNameP ;
         if( isJpgF( pbP ) ) tError = T("error:    jpg    ")+tNameP ;

    TN( tError , "" ) ;
{
voidT traceActualTypeF( tinS& tinP , etherC& etherP , const byteT* const pbP , textC& tNameP )

}
    ;
    && pbP[ 3 ] == 'G'
    && pbP[ 2 ] == 'N'
    && pbP[ 1 ] == 'P'
       pbP[ 0 ] == 0x89
    return
{
boolT isPngF( const byteT* pbP )

}
    ;
    && pbP[ 2 ] == '3'
    && pbP[ 1 ] == 'D'
       pbP[ 0 ] == 'I'
    return
{
boolT isMp3F( const byteT* pbP )

}
    ;
    && pbP[ 3 ] == 'F'
    && pbP[ 2 ] == 'F'
    && pbP[ 1 ] == 'I'
       pbP[ 0 ] == 'R'
    return
{
boolT isAviF( const byteT* pbP )

}
    ;
    )
        && pbP[ 7 ] == 'E'
        && pbP[ 6 ] == 'C'
        && pbP[ 5 ] == 'I'
        && pbP[ 4 ] == 'O'
        && pbP[ 3 ] == 'V'
        && pbP[ 2 ] == '_'
        && pbP[ 1 ] == 'S'
           pbP[ 0 ] == 'M'
    (
    ||
    )
        && pbP[ 1 ] == 0x80
           pbP[ 0 ] == 0x80
    (
    return
{
boolT isMsvF( const byteT* pbP )

}
    ;
    && pbP[ 4 ] == '-'
    && pbP[ 3 ] == 'F'
    && pbP[ 2 ] == 'D'
    && pbP[ 1 ] == 'P'
       pbP[ 0 ] == '%'
    return
{
boolT isPdfF( const byteT* pbP )

}
    ;
    )
        && pbP[ 9 ] == 'f'
        && pbP[ 8 ] == 'i'
        && pbP[ 7 ] == 'x'
           pbP[ 6 ] == 'E'
    (
    ||
    )
        && pbP[ 9 ] == 'F'
        && pbP[ 8 ] == 'I'
        && pbP[ 7 ] == 'F'
           pbP[ 6 ] == 'J'
    (
    return
{
boolT isJpgF( const byteT* pbP )

#define ADAMdATAtYPE_PNG           0x6
#define ADAMdATAtYPE_MP3           0x5
#define ADAMdATAtYPE_AVI           0x4
#define ADAMdATAtYPE_MSV           0x3
#define ADAMdATAtYPE_PDF           0x2
#define ADAMdATAtYPE_JPG           0x1


/*1*/WAKEsHOWtEXT( "tool.archive.detect.malicious.file.encryption" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
