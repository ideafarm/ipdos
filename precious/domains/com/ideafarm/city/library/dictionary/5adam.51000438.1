
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

//==============================================================================================================================================================
//==== BELOW THIS LINE: DAYTIME WORK ===========================================================================================================================
//==============================================================================================================================================================

REST

TELL( "cleaning up" ) ;
etThread.ifcDrivenServerF( tinP , i1 , i2 ) ;
serverInfo2S i2( 0x19 , flSOCKETc_null , TF2(thirdC::third_idAdamRootI_IF( tinP ),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , 0 , (countT)&c8p , 0 , - 1 , 1 , sizeof( stateS ) , translateStateF ) ;
serverInfo1S i1( &pbdVarying , b_pbdVarying , bHandedOff , sgnIdPortReplaced , tmcF , countTC() , ether ) ;
TELL( "serving port 91 (smtp)" ) ;

HIRE( T("port.91.smtp") , 0x401043f , 0x1000000 , 0x401043f , 0x1000000 )
TELL( "hiring f34" )

etThread.ifcChatF( tinP , (countT)&c8p , DDNUMB , jobFillCourseF ) ;
TELL( "preparing to accept chat clients" ) ;

c8p.c5 = (countT)&bPrepayCode ;
c8p.c4 = (countT)&ru ;
c8p.c3 = (countT)&stNicNameSpammer ;
c8p.c2 = (countT)&b_pbdVarying ;
c8p.c1 = (countT)&pbdVarying ;
count8S c8p ;

batonC bPrepayCode( tinP , TAG( TAGiDnULL ) ) ;
ranUniC ru( MAXcOUNTT ) ;
stackC stNicNameSpammer( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC , T("///d/tmp/state/")+TF1(DDNUMB)+T(".stNicNameSpammer") ) ;

ZE( boolT , bHandedOff ) ;
batonC b_pbdVarying( tinP , TAG( TAGiDnULL ) ) ;
ZE( byteT* , pbdVarying ) ;
signC sgnIdPortReplaced( tinP , TAG( TAGiDnULL ) ) ;

TELL( "preparing for work" ) ;
etThread.winSetTitleF( tinP , TF1(DDNUMB) ) ; //U::
TODO

DONEdRIVENsERVER( tmcF )
}
    TELL( "cleaning up this thread" ) ;
    }
        //tinP.zEtScratch->delF( tinP , psttPeer ) ;
        TELL( "cleaning up this session" ) ;
        }
            *tinP.zEtScratch = etScratchSave ;
            //tinP.zEtScratch->ifcSayF( tinP , stPhrases , flSAY_APPEND | flSAY_LOG ) ;
            *tinP.zEtScratch = 0 ;
            countT etScratchSave = *tinP.zEtScratch ;
            etThread.delF( tinP , psttFrom ) ;
            }
                pso->writeF( tinP , (osTextT*)tErr , tErr.csF( tinP ) ) ;
    
                tErr += T("\r\n") ;
                //etThread.ifcSayF( tinP , T(nicNamePeer)+T(" ")+T(psttPeer)+T(": ERROR: ")+tErr , flSAY_APPEND | flSAY_LOG ) ;
                if( fliError & fliERROR_NOdATA            ) tErr += T(postERROR_NOdATA           ) ;
                if( fliError & fliERROR_NOrECIPIENT       ) tErr += T(postERROR_NOrECIPIENT      ) ;
                if( fliError & fliERROR_NOsENDER          ) tErr += T(postERROR_NOsENDER         ) ;
                if( fliError & fliERROR_SECRETsENDER      ) tErr += T(postERROR_SECRETsENDER     ) ;
                TN( tErr , "554 " ) ;
    
                *tinP.zEtScratch = 0 ;
            {
            else
            if( !*tinP.zEtScratch && !etThread ) pso->writeF( tinP , "250 ok\r\n" ) ;
            TELL( "cleaning up after handling this mail from transaction" ) ;
    
            etThread.delF( tinP , psttBody ) ;
            }
                //U:: }
                //U::     //etThread.ifcSayF( tinP , T(nicNamePeer)+T(" ")+T(psttPeer)+T(": dropped off asynch job to deliver this item to ")+TF1(idAdamTo) , flSAY_APPEND | flSAY_LOG ) ;
                //U::     etThread.delF( tinP , psttu ) ;
                //U::     etThread.boxPutUniqueF( tinP , psttu , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/9440104/in/in") , WS( sAsynchOrder ) ) ; ___( psttu ) ;
                //U::     ZE( strokeS* , psttu ) ;
                //U:: 
                //U::     sAsynchOrder << sOrder ;
                //U::     soulC sAsynchOrder( tinP , TAG( TAGiDnULL ) , flSOUL_null , idAdamTo ) ;
                //U:: 
                //U::     etThread.delF( tinP , psttb ) ;
                //U::     sOrder << psttb ;
                //U::     strokeS* psttb = psttOldC( tinP , etThread , psttBody ) ; ___( psttb ) ;
                //U::     sOrder << idAdamTo ;
                //U::     sOrder << psttFrom ;
                //U::     soulC sOrder( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDjOBoRDER_MAIL ) ;
                //U:: 
                //U::     etThread.strokeF( tinP , T("ordering ")+TF1(DDNUMB)+T(" asynch (via 9440104) to do job ")+T("/ifcIDcMDjOBoRDER_MAIL/")+T(psttFrom)+T("/")+TF1(idAdamTo)+T("\r\n") ) ;
                //U:: 
                //U::     if( idAdamTo == 1 ) idAdamTo = 0x401043c ; // ROBOT APPENDAGE TO THE Wo'O Ideafarm CYBORG.  MUST BE CHANGED IN OO PLACES IN THIS FILE
                //U::     stTo >> idAdamTo ;
                //U::     ZE( countT , idAdamTo ) ;
                //U::     TELL( "dropping off an asynch job for 9440104 to handle" ) ;
                //U:: {
                //U:: while( !etThread && stTo )
                //U:: TEST AND DEBUG 944 AND c34

                }
                    tinP.zEtScratch->delF( tinP , psttFromName ) ;
                    tinP.zEtScratch->delF( tinP , psttFromIn ) ;
                    }
                        etThread.boxPutF( tinP , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+T(psttFromIn)+T("//" ifcEMAIL_OLDfROM "") , tNote , tNote.csF( tinP ) ) ;
                        etThread.delF( tinP , psttn ) ;
                        TN( tNote , "" ) ; tNote = T(psttn) ;

                        }
                            etThread.strFuseF( tinP , psttn , TF1(cCode)+tc ) ;
                            stCodes >> cCode ;
                            ZE( countT , cCode ) ;
                        {
                        while( stCodes )
                        TN( tc  , "\r\n" ) ;

                        etThread.strMakeF( tinP , LF , psttn , T("Subject: Your Prepaid Residency Tax Codes\r\n\r\nThank you for purchasing the following block of codes:\r\n\r\n") , stCodes * 0x80 ) ; ___( psttn ) ;
                        ZE( strokeS* , psttn ) ;
    
                        }
                            bPrepayCode.ungrabF( tinP ) ;
                            }
                                }
                                    break ;

                                    stCodes.sinkF( tinP , countTC() , cCode , flSTACKsINK_UNIQUE ) ;

                                    etThread.boxPutF( tinP , tFile , sOut ) ;
    
                                    sOut << psttFromIn ; //psttPaid
                                    sOut << (countT)0 ; //cTimesUseable
                                    sOut << (countT)0 ; //NEVER EXPIRES
                                    sOut << (countT)0 ; //NEVER EXPIRES
                                    sOut << (strokeS*)T("01.1.1") ;
                                    sOut << (countT)1 ; //idFormat
                                    soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
                                {
                                if( !etThread.diskFileExistsF( tinP , tFile ) )
                                tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/prepaycode/") + tCode ;
                                tCode = TF1( cCode ) ; //U::BUG: LOWEST SIG BYTE IS ALWAYS 0
                                while( cTries -- || !cCode ) cCode = ru ;
                                ZE( countT , cCode ) ;
                                countT cTries = 0x10 ;
                            {
                            while( !etThread && !*tinP.zEtScratch )
                            bPrepayCode.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            TN( tCode , "" ) ; 
                            TN( tFile , "" ) ;
                        {
                        while( cCodes -- )
                        countT cCodes = 0x200 ;
                        stackC stCodes( tinP , etThread , TAG( TAGiDnULL ) ) ;
                    {
                    else if( tinP.zEtScratch->strIdF( tinP , T("\r\nItem Number: 01.1.1\r\n") , psttBody ) )
                    }
                        }
                            etThread.boxPutF( tinP , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+T(psttFromIn)+T("//" ifcEMAIL_OLDfROM "") , tNote , tNote.csF( tinP ) ) ;
                            //POPUP( T("email to: ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+T(psttFromIn)+T("//" ifcEMAIL_OLDfROM "\r\n \r\n")+tNote ) ; //U::
                            TELL( "sending email (new prepay code)" ) ;
                            ;
        
                                "the person who gave you the code or give it to somewo else.\r\n")
                                "and you do not want to become a resident of IdeaFarm " "(tm) City, please either inform\r\n"
                                "(http://www.ideafarm.com).  This code is worth a few dollars; if you are the recipient\r\n"
                                "redeemed when you try to redeem it, please contact Wo'O Ideafarm\r\n"
                                "redeem it as soon as that is convenient for you.  If the code has already been\r\n"
                                "This code can only be used wo time, and it will expire eventually, so please\r\n"
                                "\r\n"
                                "        prepay code: ")+tCode+T("\r\n"
                                "\r\n"
                                "That person can log in immediately, using the following Prepay Code:\r\n"
                                "You can forward this note to the recipient of your gift.\r\n"
                                "Thank you for purchasing residency in IdeaFarm " "(tm) City as a gift for somewo.\r\n"
                                "\r\n"
                                T("Subject: Your Prepaid Residency Tax Code\r\n"
        
                            TN( tNote , "" ) ; tNote =
                        {

                        bPrepayCode.ungrabF( tinP ) ;
                        }
                            }
                                break ;
                                etThread.boxPutF( tinP , tFile , sOut ) ;

                                sOut << psttFromIn ; //psttPaid
                                sOut << (countT)1 ; //cTimesUseable
                                sOut << (countT)timeE.time2 ;
                                sOut << timeE.time1 ;
                                sOut << (strokeS*)T("e.1.1") ;
                                sOut << (countT)1 ; //idFormat
                                soulC sOut( tinP , TAG( TAGiDnULL ) ) ;

                                etThread.osTimeAddF( tinP , timeE.time1 , timeE.time2 , 0 , 0x40 ) ; //EXPIRES AT THIS TIME
                                etThread.osTimeNowF( tinP , timeE.time1 , timeE.time2 ) ;
                            {
                            if( !etThread.diskFileExistsF( tinP , tFile ) )
                            tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/prepaycode/") + tCode ;
                            tCode = TF1( cCode ) ; //U::BUG: LOWEST SIG BYTE IS ALWAYS 0
                            while( cTries -- || !cCode ) cCode = ru ;
                            ZE( countT , cCode ) ;
                            countT cTries = 0x10 ;
                        {
                        while( !etThread && !*tinP.zEtScratch )
                        bPrepayCode.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        timeS timeE ;
                        TN( tCode , "" ) ; 
                        TN( tFile , "" ) ;
                    {
                    else if( tinP.zEtScratch->strIdF( tinP , T("\r\nItem Number: e.1.1\r\n") , psttBody ) )
                    }
                        }
                            etThread.boxPutF( tinP , tFile , sJournal ) ;
                            TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/account.event/" ) ; tFile += T(psttFromIn)+T("/")+TF3(timeN2,flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+td+TF3(timeN1,flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+td+TF1(tinP.osTid) ;
                            TN( td , "." ) ;
                            etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
                            ZE( sCountT , timeN2 ) ;
                            ZE( countT , timeN1 ) ;
                        {

                        }
                            etThread.boxPutF( tinP , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+T(psttFromIn)+T("//" ifcEMAIL_OLDfROM "") , tNote , tNote.csF( tinP ) ) ;
                            //POPUP( T("email to: ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+T(psttFromIn)+T("//" ifcEMAIL_OLDfROM "\r\n \r\n")+tNote ) ; //U::
                            TELL( "sending email (residency tax paid until)" ) ;
                            ;
        
                                "Residency tax payments can be made at any time to extend your residency.\r\n")
                                "\r\n"
                                "Your tax has now been paid to ")+TT(timeN.time1,timeN.time2)+T(" .\r\n"
                                "A residency tax payment for ")+TF1(days)+T(" days has just been received.\r\n"
                                "Thank you for choosing to reside in IdeaFarm " "(tm) City a while longer.\r\n"
                                "\r\n"
                                T("Subject: Residency Tax Paid - Thank You\r\n"
        
                            TN( tNote , "" ) ; tNote =
    
                            tinP.zEtScratch->boxPutF( tinP , tFile , (byteT*)&timeN , sizeof timeN ) ;
                            sJournal << (countT)timeN.time2 ; //NEW EXPIRY time2
                            sJournal << timeN.time1 ; //NEW EXPIRY time1
                            etThread.osTimeAddF( tinP , timeN.time1 , timeN.time2 , 0 , days ) ;

                            }
                                tinP.zEtScratch->delF( tinP , pbi ) ;
                                else sJournal << (countT)1 ; //bExpired
                                }
                                    sJournal << (countT)0 ; //bExpired
                                    timeN.time2 = timeE2 ;
                                    timeN.time1 = timeE1 ;
                                {
                                if( timeN.time2 < timeE2 || ( timeN.time2 == timeE2 && timeN.time1 < timeE1 ) )
                                sJournal << (countT)timeE2 ; //OLD time2
                                sJournal << timeE1 ; //OLD time1
                                sCountT& timeE2 = ((sCountT*)pbi)[ 1 ] ;
                                countT&  timeE1 =  ((countT*)pbi)[ 0 ] ;
                                tinP.zEtScratch->boxGetShadowF( tinP , pbi , cbi , tFile ) ; ___( pbi ) ;
                                ZE( countT , cbi ) ;
                                ZE( byteT* , pbi ) ;
                            {
                            else
                            }
                                sJournal << (countT)0 ; //OLD time2
                                sJournal << (countT)0 ; //OLD time1
                            {
                            if( !tinP.zEtScratch->diskFileExistsF( tinP , tFile ) )
                            sJournal << (countT)timeN.time2 ; //CURRENT time2
                            sJournal << timeN.time1 ; //CURRENT time1
                            etThread.osTimeNowF( tinP , timeN.time1 , timeN.time2 ) ;
                            timeS timeN ;
                            tFile += T(psttFromIn) ;
                            TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/resident.until/" ) ;

                            sJournal << days ; // NUMBER OF DAYS PURCHASED
                            else __1
                            }
                                sJournal << (countT)2 ; // idType: PURCHASE OF d.1.1
                                days = 0x80 ;
                            {
                            else if( tinP.zEtScratch->strIdF( tinP , T("\r\nItem Number: d.1.1\r\n") , psttBody ) )
                            }
                                sJournal << (countT)1 ; // idType: PURCHASE OF c.1.1
                                days = 0x40 ;
                            {
                            if( tinP.zEtScratch->strIdF( tinP , T("\r\nItem Number: c.1.1\r\n") , psttBody ) )
                            ZE( countT , days ) ;
                        {
                        sJournal << (countT)1 ; //idFormat
                        soulC sJournal( tinP , TAG( TAGiDnULL ) ) ;

                        }
                            tinP.zEtScratch->boxPutF( tinP , tFile , tp , tp.csF( tinP ) ) ;
                            TN( tp , "" ) ; tp = T( psttFromName ) ;
                            tFile += T(psttFromIn) ;
                            TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/humanname/" ) ;
                        {

                        }
                            }
                                etThread.boxPutF( tinP , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+T(psttFromIn)+T("//" ifcEMAIL_OLDfROM "") , tNote , tNote.csF( tinP ) ) ;
                                //POPUP( T("email to: ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+T(psttFromIn)+T("//" ifcEMAIL_OLDfROM "\r\n \r\n")+tNote ) ; //U::
                                TELL( "sending email (new passcode)" ) ;
                                ;
        
                                    "passcode: ")+tp+T("\r\n") ;
                                    "email:    ")+T(psttFromIn)+T("\r\n"
                                    "\r\n"
                                    "You can log in immediately, using:\r\n"
                                    "Your email address is your resident id.\r\n"
                                    "Welcome, new resident of IdeaFarm " "(tm) City!\r\n"
                                    "\r\n"
                                    T("Subject: Your Password\r\n"
        
                                TN( tNote , "" ) ; tNote =
    
                                tinP.zEtScratch->boxPutF( tinP , tFile , tp , tp.csF( tinP ) ) ;
                                TN( tp , "" ) ; tp = TF1( (countT)(measureT)ru ) ;
                                while( cTries -- ) (measureT)ru ;
                                countT cTries = 0x10 ;
                            {
                            if( !tinP.zEtScratch->diskFileExistsF( tinP , tFile ) )
                            tFile += T(psttFromIn) ;
                            TN( tFile , "///ideafarm/ephemeral/domains/com/ideafarm/passcode/" ) ;
                        {
                    {
                    else if( tinP.zEtScratch->strIdF( tinP , T("\r\nItem Number: c.1.1\r\n") , psttBody ) || tinP.zEtScratch->strIdF( tinP , T("\r\nItem Number: d.1.1\r\n") , psttBody ) )
                    }
                        tinP.zEtScratch->delF( tinP , psttnu ) ;
                        tinP.zEtScratch->boxPutUniqueF( tinP , psttnu , T("///ideafarm/ephemeral/domains/com/ideafarm/payment/")+T(psttFromIn)+T(".$note.b.1.1") , oston , oston.costF() + 1 ) ;
                        ZE( strokeS* , psttnu ) ;
                        OStEXTV( oston , "b340104 detected an incoming payment notice for b.1.1" )
                    {
                    else if( tinP.zEtScratch->strIdF( tinP , T("\r\nItem Number: b.1.1\r\n") , psttBody ) )
                    }
                        tinP.zEtScratch->delF( tinP , psttnu ) ;
                        tinP.zEtScratch->boxPutUniqueF( tinP , psttnu , T("///ideafarm/ephemeral/domains/com/ideafarm/payment/")+T(psttFromIn)+T(".$note.9.1.1") , oston , oston.costF() + 1 ) ;
                        ZE( strokeS* , psttnu ) ;
                        OStEXTV( oston , "b340104 detected an incoming payment notice for 9.1.1" )
                    {
                    if( tinP.zEtScratch->strIdF( tinP , T("\r\nItem Number: 9.1.1\r\n") , psttBody ) )

                    }
                        etThread.delF( tinP , psttll ) ;
                        }
                            if( psttFromIn ) break ;

                            tinP.zEtScratch->delF( tinP , psttw ) ;
                            tinP.zEtScratch->strMakeF( tinP , LF , psttFromName , T("\"")+T(psttw)+T("\" <")+T(psttFromIn)+T(">") ) ; ___( psttFromName ) ;
                            tinP.zEtScratch->strTrimF( tinP , psttw , 0 , T(TbLACKnEWlINE) ) ; ___( psttw ) ;

                            tinP.zEtScratch->strSubstringF( tinP , psttw , idf , idl , psttc1 ) ; ___( psttw ) ;
                            ZE( strokeS* , psttw ) ;
                            ZE( countT , idl ) ;
                            countT idf = tBuyerColon.csF( tinP ) + 1 ;
                        {
                        else if( 1 == tinP.zEtScratch->strIdF( tinP , tBuyerColon , psttll ) )
                        }
                            }
                                tinP.zEtScratch->delF( tinP , pstt1w ) ;
                                }
                                    }
                                        }
                                            break ;
                                            tinP.zEtScratch->strMakeF( tinP , LF , psttFromIn , psttc2 ) ; ___( psttFromIn ) ;
                                        {
                                        if( ++ idw == 2 )
                                    {
                                    FORsTRINGSiN2( pstt1w )
                                    ZE( countT , idw ) ;
                                {
                                if( 2 <= tinP.zEtScratch->strWordsOldF( tinP , pstt1w , psttw , sttq , T("<>") ) )
                                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                ZE( strokeS* , pstt1w ) ;
                            {
                            else
                            }
                                psttFromIn = psttw ; psttw = 0 ;
                                tinP.zEtScratch->strTrimF( tinP , psttw , 0 , T(TbLACKnEWlINE) ) ; ___( psttw ) ;
                            {
                            if( !tinP.zEtScratch->strIdF( tinP , T("<") , psttw ) )

                            tinP.zEtScratch->strSubstringF( tinP , psttw , idf , idl , psttc1 ) ; ___( psttw ) ;
                            ZE( strokeS* , psttw ) ;
                            ZE( countT , idl ) ;
                            countT idf = tFromColon.csF( tinP ) + 1 ;
                        {
                        if( 1 == tinP.zEtScratch->strIdF( tinP , tFromColon , psttll ) )
                        etThread.strokeF( tinP , T("| ")+T(psttll)+T("\r\n") ) ; //U::
                        etThread.strConvertToLowerCaseF( tinP , psttll ) ;
                        strokeS* psttll = psttOldC( tinP , etThread , psttc1 ) ; ___( psttll ) ;
                    {
                    FORsTRINGSiN1( pstt1lines )
                    ZE( strokeS* , psttFromName ) ;
                    ZE( strokeS* , psttFromIn ) ;
                    TN( tBuyerColon , "buyer:" ) ;
                    TN( tFromColon , "from:" ) ;
                    tinP.zEtScratch->strWordsOldF( tinP , pstt1lines , psttBody , sttq , T("\r\n") ) ; ___( pstt1lines ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , pstt1lines ) ;
                    //EXTRACT psttFrom2 from psttBody
                {
                //U::if( !tinP.zEtScratch->strCompareF( tinP , psttFrom , tPaypal ) )
                //U:: MOVE THIS BLOCK TO c34
                //DETECTS INCOMING PAYMENT NOTIFICATION FROM PAYPAL
    
                }
                    etThread.delF( tinP , postBody ) ;
                    etThread.delF( tinP , psttu ) ;
                    etThread.boxPutUniqueF( tinP , psttu , T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF1(DDNUMB)+T("/in/arc/arc") , postBody , costBody ) ;
                    ZE( strokeS* , psttu ) ;
    
                    countT costBody = etThread.strMakeF( tinP , LF , postBody , psttBody ) ; ___( postBody ) ;
                    ZE( osTextT* , postBody ) ;
                {
                TELL( "writing the received item to an archive file" ) ;
            {
            if( !*tinP.zEtScratch )

            }
                etThread.strMakeF( tinP , LF , psttFrom , T("[anonymous]") ) ; ___( psttFrom ) ;
                etThread.delF( tinP , psttFrom ) ;
            {
            if( psttFrom && !psttFrom->idAdam )
    
            if( !psttBody ) fliError |= fliERROR_NOdATA ;
            if( !stTo     ) fliError |= fliERROR_NOrECIPIENT ;
            if( !psttFrom ) fliError |= fliERROR_NOsENDER ;
    
            __Z( psttBody ) ;
            __Z( stTo ) ;
            __Z( psttFrom ) ;
            }
                if( !*tinP.zEtScratch ) { etThread.strConcatenateF( tinP , psttBody , st_psttBody ) ; ___( psttBody ) ; }
    
                }
                    fliError |= fliERROR_SECRETsENDER ;
                    __1
                {
                if( !bAllowSecretSender && !bFromFound )
    
                }
                    }
                        etThread.delF( tinP , psttlLower ) ;
                        bFromFound = 1 == etThread.strIdF( tinP , T("from:") , psttlLower ) ;
                        etThread.strConvertToLowerCaseF( tinP , psttlLower , psttl ) ; ___( psttlLower ) ;        // "from: joe foo <jfoo@bar.com>"
                        ZE( strokeS* , psttlLower ) ;
                    {
                    if( !bFromFound && etThread.strIdF( tinP , psttFrom , psttl ) )                             // "FROM: Joe Foo <jfoo@bar.com>"
    
                    st_psttBody << psttOldC( tinP , etThread , T("\r\n") ) ;
                    st_psttBody << psttl ;
    
                    }
                        }
                            etThread.delF( tinP , psttw1 ) ;
                            etThread.strSubstringF( tinP , psttl , idf , idl , psttw1 ) ; ___( psttl ) ;   // ". bla bla bla"
                            ZE( countT , idl ) ;
                            countT idf = 2 ;
                            //sttq = ze ;
                            psttl = 0 ;
                            psttw1 = psttl ;                                                                    // ".. bla bla bla"
                        {
                        else
                        }
                            break ;
                            etThread.delF( tinP , psttl ) ;
                        {
                        if( psttl->idAdam == 1 )
                    {
                    if( psttl && psttl[ CSpREFIX ] == sttDot )
                    TELL( "parsing a data line" ) ;
    
                    if( *tinP.zEtScratch ) break ;
                    pso->readWoLineF( tinP , psttl , 0x400 ) ; ___( psttl ) ;                                    // MESSAGE HEADER OR BODY LINE
                    TELL( "reading a data line" ) ;
                    ZE( strokeS* , psttl ) ;
                {
                while( !*tinP.zEtScratch && !etThread )
                stackC st_psttBody( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
                ZE( boolT , bFromFound ) ;
            {
            if( !*tinP.zEtScratch )
            ZE( strokeS* , psttBody ) ;
            pso->writeF( tinP , "354 Start mail input; end with <CRLF>.<CRLF>\r\n" ) ;
    
            }
                tinP.zEtScratch->delF( tinP , psttTo ) ;
                }
                    pso->writeF( tinP , (osTextT*)tErr , tErr.csF( tinP ) ) ;
                    TN( tErr , "553 [bad format: \"" ) ; tErr += T(psttTo)+T("\"]\r\n") ;
                    *tinP.zEtScratch = 0 ;
                {
                else
                }
                    pso->writeF( tinP , "250 ok\r\n" ) ;
                    stTo.sinkF( tinP , countTC() , idAdamTo ) ;
                    stPhrases << psttOldC( tinP , *tinP.zEtScratch , T("to ")+TF1(idAdamTo) ) ;
                {
                if( !*tinP.zEtScratch )
    
                __Z( idAdamTo ) ;                                                                         // REJECT 0
                tinP.zEtScratch->delF( tinP , psttw1 ) ;
                countT idAdamTo = tinP.zEtScratch->strDigitsToSCountF( tinP , psttw1 ) ;
                __( psttw1 && psttw1->idAdam > 8 ) ;                                                      // REJECT IF TOO MANY DIGITS
                __( !tinP.zEtScratch->strIsDigitsF( tinP , psttw1 ) ) ;                                                // REJECT IF NOT ALL DIGITS
                __( psttw1 && !psttw1->idAdam ) ;                                                         // REJECT ""
    
                //}
                //    tinP.zEtScratch->strMakeF( tinP , LF , psttw1 , T("1") ) ; ___( psttw1 ) ;
                //    tinP.zEtScratch->delF( tinP , psttw1 ) ;
                //{
                //if( !tinP.zEtScratch->strCompareF( tinP , psttw1 , T("wo") ) )
                //tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttw1 ) ; ___( psttw1 ) ;                                     // "wo"
                //U: DELETE THIS CODE WHEN SURE WILL NOT NEED IT
    
                tinP.zEtScratch->strWordF( tinP , psttw1 , psttTo , sttq , sttAt , 1 ) ; ___( psttw1 ) ;                       // "123"
                //sttq = ze ;
                tinP.zEtScratch->delF( tinP , psttw1 ) ;
                __( tinP.zEtScratch->strCompareF( tinP , psttw1 , tIfc ) ) ;                                           // "ideafarm.com" == ?
                tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttw1 ) ; ___( psttw1 ) ;                                     // "ideafarm.com"
                tinP.zEtScratch->strWordF( tinP , psttw1 , psttTo , sttq , sttAt , 2 ) ; ___( psttw1 ) ;                       // "IDEAFARM.COM"
                //sttq = ze ;
    
                tinP.zEtScratch->strTrimF( tinP , psttTo , 0 , T(TbLACKnEWlINE) , T("<>") ) ; ___( psttTo ) ;                                 // "123@IDEAFARM.COM"
                }
                    __( psttTo[ CSpREFIX - 1 + psttTo->idAdam ].idAdam - '>' ) ;                          // REJECT <@WINNIE:123@IDEAFARM.COM>
                    __( psttTo[ CSpREFIX                        ].idAdam - '<' ) ;
                {
                if( !*tinP.zEtScratch )
                __( psttTo && psttTo->idAdam < 2 ) ;
                __Z( psttTo ) ;
                tinP.zEtScratch->strTrimF( tinP , psttTo , 0 , T(TbLACKnEWlINE) , T(" ") ) ; ___( psttTo ) ;                                  // "<123@IDEAFARM.COM>"
                tinP.zEtScratch->delF( tinP , psttl ) ;
                tinP.zEtScratch->strWordF( tinP , psttTo , psttl , sttq , sttColon , 2 ) ; ___( psttTo ) ;                     // " <123@IDEAFARM.COM> "
                //sttq = ze ;
                ZE( strokeS* , psttTo ) ;
    
                tinP.zEtScratch->delF( tinP , psttw1 ) ;
                tinP.zEtScratch->delF( tinP , psttw2 ) ;
                __( tinP.zEtScratch->strCompareF( tinP , psttw2 , tTo ) ) ;                                            // "to" == ?
                tinP.zEtScratch->strWordF( tinP , psttw2 , psttw1 , sttq , sttSpace , 2 ) ; ___( psttw2 ) ;                    // "to"
                tinP.zEtScratch->delF( tinP , psttw2 ) ;
                __( tinP.zEtScratch->strCompareF( tinP , psttw2 , tRcpt ) ) ;                                          // "rcpt" == ?
                tinP.zEtScratch->strWordF( tinP , psttw2 , psttw1 , sttq , sttSpace , 1 ) ; ___( psttw2 ) ;                    // "rcpt"
                //sttq = ze ;
    
                }
                    break ;
                    tinP.zEtScratch->delF( tinP , psttl ) ;
                    tinP.zEtScratch->delF( tinP , psttw1 ) ;
                {
                if( !tinP.zEtScratch->strCompareF( tinP , psttw1 , tData ) )
                tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttw1 ) ; ___( psttw1 ) ;                                     // "rcpt to"
                tinP.zEtScratch->strTrimF( tinP , psttw1 , 0 , T(TbLACKnEWlINE) , T(" ") ) ; ___( psttw1 ) ;                                  // "RCPT TO"
                tinP.zEtScratch->strWordF( tinP , psttw1 , psttl , sttq , sttColon , 1 ) ; ___( psttw1 ) ;                     // " RCPT TO "
                //sttq = ze ;
                TELL( "parsing a rcpt to line" ) ;
    
                if( *tinP.zEtScratch ) break ;
                //etThread.ifcSayF( tinP , T(nicNamePeer)+T(" ")+T(psttPeer)+T(": |")+T(psttl) , flSAY_APPEND | flSAY_LOG ) ;
                pso->readWoLineF( tinP , psttl , 0x400 ) ; ___( psttl ) ;
                TELL( "reading a rcpt to line" ) ;
                ZE( strokeS* , psttl ) ;
            {
            while( !*tinP.zEtScratch && !etThread )
            stackC stTo( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;
    
            }
                }
                    continue ;
                    if( !bNoSpammerSink ) stNicNameSpammer.sinkF( tinP , countTC() , nicNamePeer , flSTACKsINK_UNIQUE ) ;
                    pso->writeF( tinP , "500 [syntax of sender is unacceptable]\r\n" ) ;
                    *tinP.zEtScratch = 0 ;
                {
                else
                }
                    pso->writeF( tinP , "250 ok\r\n" ) ;
                    stPhrases << psttOldC( tinP , etThread , T("from \"")+T(psttFrom)+T("\"") ) ;
                {
                if( !*tinP.zEtScratch )
    
                //U:bAllowSecretSender |= !*tinP.zEtScratch && !tinP.zEtScratch->strCompareF( tinP , psttFrom , tPaypal ) ;
                bAllowSecretSender = 1 ; //U:

                }
                    if( *tinP.zEtScratch ) bNoSpammerSink = 1 ;
                    tinP.zEtScratch->delF( tinP , psttw ) ;
                    //__( tinP.zEtScratch->strIdF( tinP , T("chibyusa") , psttw ) ) ; //THERESA
                    //__( tinP.zEtScratch->strIdF( tinP , T("divachild") , psttw ) ) ; //THERESA
                    //__( tinP.zEtScratch->strIdF( tinP , T("thetinydot") , psttw ) ) ; //JULIA
                    //__( tinP.zEtScratch->strIdF( tinP , T("mail@tranxact.com") , psttw ) ) ; //DAVID
                    //__( tinP.zEtScratch->strIdF( tinP , T("ranchlife@js-net.com") , psttw ) ) ; //STEVE
                    //__( tinP.zEtScratch->strIdF( tinP , T("dduringer@juno.com") , psttw ) ) ; //DAN
                    //__( tinP.zEtScratch->strIdF( tinP , T("tduringer@juno.com") , psttw ) ) ; //MOM
                    tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttw , psttFrom ) ; ___( psttw ) ;
                    ZE( strokeS* , psttw ) ;
                {
                if( !*tinP.zEtScratch )
                ZE( boolT , bNoSpammerSink ) ;

                tinP.zEtScratch->strTrimF( tinP , psttFrom , 0 , T(TbLACKnEWlINE) , T("<>") ) ; ___( psttFrom ) ;                             // "FOO@bar.com"
                }
                    __( psttFrom[ CSpREFIX - 1 + psttFrom->idAdam ].idAdam - '>' ) ;                      // REJECT <@WINNIE:FOO@bar.com>
                    __( psttFrom[ CSpREFIX                        ].idAdam - '<' ) ;
                {
                if( !*tinP.zEtScratch )
                __( psttFrom && psttFrom->idAdam < 2 ) ;
    
                __Z( psttFrom ) ;
                tinP.zEtScratch->strTrimF( tinP , psttFrom , 0 , T(TbLACKnEWlINE) , T(" ") ) ; ___( psttFrom ) ;                              // "<FOO@bar.com>"
                etThread.delF( tinP , psttl ) ;
                tinP.zEtScratch->strWordF( tinP , psttFrom , psttl , sttq , sttColon , 2 ) ; ___( psttFrom ) ;                 // " <FOO@bar.com> "
                //sttq = ze ;
    
                tinP.zEtScratch->delF( tinP , psttw1 ) ;
                tinP.zEtScratch->delF( tinP , psttw2 ) ;
                __( tinP.zEtScratch->strCompareF( tinP , psttw2 , tFrom ) ) ;                                          // "from" == ?
                tinP.zEtScratch->strWordF( tinP , psttw2 , psttw1 , sttq , sttSpace , 2 ) ; ___( psttw2 ) ;                    // "from"
                tinP.zEtScratch->delF( tinP , psttw2 ) ;
                __( tinP.zEtScratch->strCompareF( tinP , psttw2 , tMail ) ) ;                                          // "mail" == ?
                tinP.zEtScratch->strWordF( tinP , psttw2 , psttw1 , sttq , sttSpace , 1 ) ; ___( psttw2 ) ;                    // "mail"
                //sttq = ze ;
                tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttw1 ) ; ___( psttw1 ) ;                                     // "mail from"
                tinP.zEtScratch->strTrimF( tinP , psttw1 , 0 , T(TbLACKnEWlINE) , T(" ") ) ; ___( psttw1 ) ;                                  // "MAIL FROM"
                tinP.zEtScratch->strWordF( tinP , psttw1 , psttl , sttq , sttColon , 1 ) ; ___( psttw1 ) ;                     // " MAIL FROM "
                TELL( "parsing the mail from line" ) ;
                //sttq = ze ;
    
                }
                    tinP.zEtScratch->delF( tinP , psttlLower ) ;
                    }
                        break ;
                        pso->writeF( tinP , "221 ok\r\n" ) ;
                        etThread.delF( tinP , psttlLower ) ;
                        etThread.delF( tinP , psttl ) ;
                    {
                    if( *tinP.zEtScratch || !etThread.strCompareF( tinP , psttlLower , tQuit ) )
                    tinP.zEtScratch->strConvertToLowerCaseF( tinP , psttlLower , psttl ) ; ___( psttlLower ) ;        // " mail from : <foo@bar.com> "
                    ZE( strokeS* , psttlLower ) ;
    
                    //etThread.ifcSayF( tinP , T(nicNamePeer)+T(" ")+T(psttPeer)+T(": |")+T(psttl) , flSAY_APPEND | flSAY_LOG ) ;
                    pso->readWoLineF( tinP , psttl , 0x400 ) ; ___( psttl ) ;
                    TELL( "reading the mail from line" ) ;
                {
                ZE( strokeS* , psttl ) ;                                                                      // " MAIL FROM : <FOO@bar.com> "
            {
            ZE( strokeS* , psttFrom ) ;
            ZE( flagsT , fliError ) ;
        {
        while( !*tinP.zEtScratch && !ether && !etThread )
        ZE( boolT , bAllowSecretSender ) ;
        TN( tPaypal , "payment@paypal.com" ) ;
    
        }
            }
                pso->writeF( tinP , "250 ideafarm.com\r\n" ) ;
                etThread.delF( tinP , psttl ) ;
                /*__( etThread.strCompareF( tinP , psttw2 , tHelo ) ) ;*/ etThread.delF( tinP , psttw2 ) ; //THIS IS NOT DONE CAUSE NETSCAPE SENDS "EHLO" RATHER THAN "HELO"
                etThread.strConvertToLowerCaseF( tinP , psttw2 , psttw1 ) ; ___( psttw2 ) ; etThread.delF( tinP , psttw1 ) ;
                etThread.strWordF( tinP , psttw1 , psttl , sttq , sttSpace , 1 ) ; ___( psttw1 ) ;
            {
            if( !*tinP.zEtScratch )
            //etThread.ifcSayF( tinP , T(nicNamePeer)+T(" ")+T(psttPeer)+T(": |")+T(psttl) , flSAY_APPEND | flSAY_LOG ) ;
            pso->readWoLineF( tinP , psttl , 0x400 ) ; ___( psttl ) ;
            TELL( "reading hello line" ) ;
            ZE( strokeS* , psttl ) ;
        {
        if( !*tinP.zEtScratch )
        // "helo" OR "ehlo" ETC: NOT PARSED
    
        TN( tIfc              , "ideafarm.com"     ) ;
        TN( tIsp              , "smtp.bayarea.net" ) ; //U: LEARN HOW TO QUERY A DNS FOR THE IP TO USE FOR AN MX RECORD; THEN CONNECT DIRECTLY TO THAT HOST AND ELIMINATE THE USE OF tIsp
        TN( tData             , "data"             ) ;
        TN( tTo               , "to"               ) ;
        TN( tRcpt             , "rcpt"             ) ;
        TN( tFrom             , "from"             ) ;
        TN( tQuit             , "quit"             ) ;
        TN( tMail             , "mail"             ) ;
        TN( tHelo             , "helo"             ) ;
        strokeS sttAt(    '@' ) ;
        strokeS sttDot(   '.' ) ;
        strokeS sttColon( ':' ) ;
        strokeS sttSpace( ' ' ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;
        ZE( strokeS* , psttw3 ) ;
        ZE( strokeS* , psttw2 ) ;
        ZE( strokeS* , psttw1 ) ;
    
        pso->writeF( tinP , "220 mail.ideafarm.com IdeaFarm " "(tm) City smtp mail receiver ready\r\n" ) ;
        TELL( "writing that i am ready" ) ;
    {
    else
    }
        pso->writeF( tinP , (osTextT*)tError ) ;
        TN( tError , "550 You are on the spammer list, you naughty person: " ) ; tError += T(psttSpammer)+T("\r\n") ;
    {
    if( bSpammer )

    b_pbdVarying.ungrabF( tinP ) ;
    }
        TN( t_cHamburgers , "" ) ; t_cHamburgers = TF3(++state.cHamburgers,0,8) ;
        TN( t_idMe        , "" ) ; t_idMe        = TF3(state.idMe,0,8) ;
        stateS& state = *(stateS*)pbdVarying ;
    {
    if( pbdVarying )
    b_pbdVarying.grabF( tinP , TAG( TAGiDnULL ) ) ;

    etThread.delF( tinP , psttSpammer ) ;
    }
        //etThread.ifcSayF( tinP , T(nicNamePeer)+T(" ")+T(psttPeer)+T(": ")+T(psttSpammer) , flSAY_APPEND | flSAY_LOG ) ;
        stNicNameSpammer.sinkF( tinP , countTC() , nicNamePeer , flSTACKsINK_UNIQUE ) ;
    {
    if( bSpammer )

    boolT bSpammer = etThread.ifcIsSpammerF( tinP , psttSpammer , nicNamePeer ) ; ___( psttSpammer ) ;
    ZE( strokeS* , psttSpammer ) ;

    //etThread.ifcSayF( tinP , T(nicNamePeer)+T(" ")+T(psttPeer) , flSAY_APPEND | flSAY_LOG ) ;
    TN( tLogClients , "///d/ideafarm.log.smtpClients" ) ;
    *tinP.zEtScratch = 0 ;
    //tinP.zEtScratch->sockPsttHostF( tinP , psttPeer , nicNamePeer ) ; ___( psttPeer ) ;
    //ZE( strokeS* , psttPeer ) ;
    { ZE( countT , idp ) ; pso->peerNameF( tinP , idp , nicNamePeer ) ; }
    nicNameC nicNamePeer ;
    stackC stPhrases( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;

    batonC&      bPrepayCode      =      *(batonC*)c8p.c5 ;
    ranUniC&     ru               =     *(ranUniC*)c8p.c4 ;
    stackC&      stNicNameSpammer =      *(stackC*)c8p.c3 ;
    batonC&      b_pbdVarying     =      *(batonC*)c8p.c2 ;
    byteT*&      pbdVarying       =      *(byteT**)c8p.c1 ;
    count8S&     c8p              =     *(count8S*)cArg ;
{
if( cArg )
TELL( "preparing to work for an SMTP client" ) ;
TASKdRIVENsERVER( tmcF )

//==============================================================================================================================================================
//==== ABOVE THIS LINE: DAYTIME WORK ===========================================================================================================================
//==============================================================================================================================================================


//==============================================================================================================================================================
//==== BELOW THIS LINE: MOONLIGHT WORK =========================================================================================================================
//==============================================================================================================================================================

}
    if( ether && *tinP.zEtScratch && cArgP && c8argP.c1 && sDataP && sNotesTextP && sNotesDataP && idChatSessionP ) ;

    }
        }
            break ;

            etThread.delF( tinP , psttBody ) ;
            etThread.delF( tinP , psttFrom ) ;
            }
                etThread.ifcJobF( tinP , stCourses , idAdamTo , sOrder , stOrders , TF1(DDNUMB)+T("port.91.smtp/")+tComment ) ;
                stOrders << new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ;
                stackC stOrders(  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                stackC stCourses( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;

                sOrder << psttBody ;
                sOrder << idAdamTo ;
                sOrder << psttFrom ;
                soulC sOrder( tinP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDjOBoRDER_MAIL ) ;

                etThread.strokeF( tinP , tComment ) ;
                TN( tComment , "" ) ; tComment = T("ordering ")+TF1(idAdamTo)+T(" to do job ")+T("/ifcIDcMDjOBoRDER_MAIL/")+T(psttFrom)+T("/")+TF1(idAdamTo)+T("\r\n") ;
            {
            else
            }
                // MAIL TO ME IS NOT READ AT ALL
            {
            if( idAdamTo == DDNUMB )

            sOrderP >> psttBody ; ___( psttBody ) ;
            ZE( strokeS* , psttBody ) ;

            if( idAdamTo == 1 ) idAdamTo = 0x401043c ; // ROBOT APPENDAGE TO THE Wo'O Ideafarm CYBORG.  MUST BE CHANGED IN OO PLACES IN THIS FILE

            __Z(  idAdamTo ) ;
            sOrderP >> idAdamTo ;
            ZE( countT , idAdamTo ) ;

            __(  psttFrom && !psttFrom->idAdam ) ;
            __Z( psttFrom ) ;
            sOrderP >> psttFrom ; ___( psttFrom ) ;
            ZE( strokeS* , psttFrom ) ;

            __( idJobType - ifcIDcMDjOBoRDER_MAIL ) ;
            sOrderP >> idJobType ;
            ZE( countT , idJobType ) ;
        {
        case 1 :
    {
    switch( idCourseP )

    __( idAdamP - DDNUMB ) ;
{
voidT jobFillCourseF( tinS& tinP , etherC& ether , etherC& etThread , soulC& sDataP , soulC& sNotesTextP , soulC& sNotesDataP , const countT idCourseP , const countT idAdamP , const countT idChatSessionP , soulC& sOrderP , countT& cArgP , count8S& c8argP )

//==============================================================================================================================================================
//==== ABOVE THIS LINE: MOONLIGHT WORK =========================================================================================================================
//==============================================================================================================================================================


//==============================================================================================================================================================
//==== BELOW THIS LINE: PROCESS STATE CODE =====================================================================================================================
//==============================================================================================================================================================

TRANSLATEsTATEdRIVENsERVER_END
    state.idMe ++ ;
TRANSLATEsTATEdRIVENsERVER_MIDDLE
    case 1 : { state.idMe        = stateOther.idMe        ; }
    case 2 : { state.cHamburgers = stateOther.cHamburgers ; }
TRANSLATEsTATEdRIVENsERVER_BEGIN( stateS , 2 )

;
}
    countT cHamburgers ;
    countT idMe ;
    countT idVersion ;
{
struct stateS

//==============================================================================================================================================================
//==== ABOVE THIS LINE: PROCESS STATE CODE =====================================================================================================================
//==============================================================================================================================================================

    "view spam or advertising while conducting their daily business.\r\n"
    "government to make use of these sanctions in order to preserve the city as a place where no one is forced against his will to\r\n"      \
    "United States, the full force of U.S. criminal and civil law can be brought to bear.  It is the policy of the IdeaFarm " "(tm) City\r\n"   \
    "City is a Federal Constitutional Protectorate of the United States of America.  In cases involving trespass by a citizen of the\r\n"    \
    "trespass\".  Similarly, you do not have the right to force or trick another person into viewing an advertisement.  IdeaFarm " "(tm)\r\n"   \
    "You do not have the right to send unwanted email to another person.  In IdeaFarm " "(tm) City, this is considered \"idea\r\n"              \
    "\r\n" \
    "approval is automatic once your reply is received.\r\n"                                                                                 \
    "only occasionally.  At other times, a separate confirmation might be requested each time a new mail item arrives.  Normally,\r\n"       \
    "The Postmaster determines confirmation policy on a daily basis.  During periods of rare abuse, confirmation will be requested\r\n"      \
    "\r\n" \
    "to avoid accountability.  False addresses are often used by spammers and larcenists.\r\n"                                               \
    "be able to confirm that the sender's email address indicated in the items is a true address, rather than a false address made up\r\n"   \
    "That mail will not be delivered until you click \"Reply\".  When the IdeaFarm " "(tm) City Postmaster receives your reply, he will\r\n"    \
    "Please click the \"Reply\" button to complete the delivery of the mail that you just sent to someone in IdeaFarm " "(tm) City.\r\n"        \
                                                                                                                                             \
#define postEMAILsECTIONbODY_4_EXPLANATION                                                                                                   \

    "(b) Otherwise, click \"Reply\".\r\n"
    "\r\n"                                                                                                                                   \
    "(a) If you are a spammer, please DO NOT REPLY.\r\n"                                                                                     \
    "\r\n"                                                                                                                                   \
    "Do either (a) -or- (b): \r\n"                                                                                                           \
                                                                                                                                             \
#define postEMAILsECTIONbODY_3_INSTRUCTIONS                                                                                                  \

//  "================================================================================================================================\r\n"

#define postERROR_NOdATA            "[the message text was of length 0]"
#define postERROR_NOrECIPIENT       "[all of recipient addresses have an invalid format]"
#define postERROR_NOsENDER          "[sender must be identified]"
#define postERROR_SECRETsENDER      "[secret senders are not allowed]"

#define fliERROR_NOdATA                     0x00000008
#define fliERROR_NOrECIPIENT                0x00000004
#define fliERROR_NOsENDER                   0x00000002
#define fliERROR_SECRETsENDER               0x00000001

/*1*/WAKEhIDE( "port.91.smtp" )/*1*/
/**/
*/
  (this can be accomplished manually by deleting the entire list periodically)
 there is no code to remove an ip from the list, once listed
 a single invalid user name instance will result in an ip becoming listed
 listed ip is not allowed to have a session
spam control
 NNNNNNN: receives the mail
 b340104/NNNNNNN: initiate and supervise mail job
 9440104/b340104: initate and supervise mail job   
 b340104/file:   asynch job soul of a ifcIDcMDjOBoRDER_MAIL job (written to 9440104's in box)
 client/b340104: delivers text via telnet to me
pseudocode for how an incoming mail item destined for NNNNNNN@i deafarm.com is handled
i refuse other addresses
i accept incoming mail addressed to nnn@i deafarm.com addresses
\<A HREF=\"5.b340104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

