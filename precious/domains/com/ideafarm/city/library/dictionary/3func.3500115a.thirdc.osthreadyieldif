
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //OSsLEEPf( 250 ) ; //U:: ms -> 250 TO FIND A BUG
    Sleep( ms ) ;   // THIS LINE IS THE ONLY LINE ALLOWED TO CALL Sleep EXPLICITLY (I.E. NOT USING THE MACRO OSsLEEPf)
    //Sleep( 0 ) ;   //TO FIND A BUG

    //etherC::etRockIF( tinP ).traceF( tinP , (strokeS*)(const osTextT*)ostoSay2 , flTRACE_PARAMETERiSoStEXT ) ;
    //OStEXTC(  ostoSay2 , tinP.pAdamGlobal1->cSpins4 , '0' ) ;
    //OStEXTAK( ostoSay2 , "." ) ;
    //OStEXTC(  ostoSay2 , tinP.pAdamGlobal1->cSpins3 , '0' ) ;
    //OStEXTAK( ostoSay2 , "." ) ;
    //OStEXTC(  ostoSay2 , tinP.pAdamGlobal1->cSpins2 , '0' ) ;
    //OStEXTAK( ostoSay2 , "." ) ;
    //OStEXTC(  ostoSay2 , tinP.pAdamGlobal1->cSpins1 , '0' ) ;
    //OStEXTAK( ostoSay2 , "    " ) ;
    //OStEXTC(  ostoSay2 , tinP.cSpins4 , '0' ) ;
    //OStEXTAK( ostoSay2 , "." ) ;
    //OStEXTC(  ostoSay2 , tinP.cSpins3 , '0' ) ;
    //OStEXTAK( ostoSay2 , "." ) ;
    //OStEXTC(  ostoSay2 , tinP.cSpins2 , '0' ) ;
    //OStEXTAK( ostoSay2 , "." ) ;
    //OStEXTC(  ostoSay2 , tinP.cSpins1 , '0' ) ;
    //OStEXTAK( ostoSay2 , "    " ) ;
    //OStEXTC(  ostoSay2 , tinP.pAdamGlobal1->cYieldHighWater , 0 ) ;
    //OStEXTAK( ostoSay2 , "    " ) ;
    //OStEXTC(  ostoSay2 , tinP.pAdamGlobal1->idAdam , 0 ) ;
    //OStEXTAK( ostoSay2 , "yield after  local global [idAdam,cYieldHighWater,l.cSpins1,l.cSpins2,l.cSpins3,l.cSpins4,g.cSpins1,g.cSpins2,g.cSpins3,g.cSpins4]:    " ) ;
    //OStEXT(   ostoSay2 , TUCK ) ;

    }
        }
            }
                }
                    else              LOGrAW( "\r\nWARNING: osThreadYieldIF: global spin overflow\r\n") ;
                    if( tinP.pEther ) etherC::etRockIF( tinP ).traceF( tinP , T("osThreadYieldIF: global spin overflow") ) ;
                {
                if( !( 1 + incv02AM( tinP.pAdamGlobal1->cSpins4 ) ) )
            {
            if( !( 1 + incv02AM( tinP.pAdamGlobal1->cSpins3 ) ) )
        {
        if( !( 1 + incv02AM( tinP.pAdamGlobal1->cSpins2 ) ) )
    {
    if( !( 1 + incv02AM( tinP.pAdamGlobal1->cSpins1 ) ) )

    }
        }
            }
                }
                    else              LOGrAW( "\r\nWARNING: osThreadYieldIF: thread spin overflow\r\n") ;
                    if( tinP.pEther ) etherC::etRockIF( tinP ).traceF( tinP , T("osThreadYieldIF: thread spin overflow") ) ;
                {
                if( !( ++ tinP.cSpins4 ) )
            {
            if( !( ++ tinP.cSpins3 ) )
        {
        if( !( ++ tinP.cSpins2 ) )
    {
    if( !( ++ tinP.cSpins1 ) )

    //etherC::etRockIF( tinP ).traceF( tinP , (strokeS*)(const osTextT*)ostoSay1 , flTRACE_PARAMETERiSoStEXT ) ;
    //OStEXTC(  ostoSay1 , tinP.pAdamGlobal1->cSpins4 , '0' ) ;
    //OStEXTAK( ostoSay1 , "." ) ;
    //OStEXTC(  ostoSay1 , tinP.pAdamGlobal1->cSpins3 , '0' ) ;
    //OStEXTAK( ostoSay1 , "." ) ;
    //OStEXTC(  ostoSay1 , tinP.pAdamGlobal1->cSpins2 , '0' ) ;
    //OStEXTAK( ostoSay1 , "." ) ;
    //OStEXTC(  ostoSay1 , tinP.pAdamGlobal1->cSpins1 , '0' ) ;
    //OStEXTAK( ostoSay1 , "    " ) ;
    //OStEXTC(  ostoSay1 , tinP.cSpins4 , '0' ) ;
    //OStEXTAK( ostoSay1 , "." ) ;
    //OStEXTC(  ostoSay1 , tinP.cSpins3 , '0' ) ;
    //OStEXTAK( ostoSay1 , "." ) ;
    //OStEXTC(  ostoSay1 , tinP.cSpins2 , '0' ) ;
    //OStEXTAK( ostoSay1 , "." ) ;
    //OStEXTC(  ostoSay1 , tinP.cSpins1 , '0' ) ;
    //OStEXTAK( ostoSay1 , "    " ) ;
    //OStEXTC(  ostoSay1 , tinP.pAdamGlobal1->cYieldHighWater , 0 ) ;
    //OStEXTAK( ostoSay1 , "    " ) ;
    //OStEXTC(  ostoSay1 , tinP.pAdamGlobal1->idAdam , 0 ) ;
    //OStEXTAK( ostoSay1 , "yield before local global [idAdam,cYieldHighWater,l.cSpins1,l.cSpins2,l.cSpins3,l.cSpins4,g.cSpins1,g.cSpins2,g.cSpins3,g.cSpins4]:    " ) ;
    //OStEXT(   ostoSay1 , TUCK ) ;

    ;
                : 0                             // USUALLY
                ? 1                             // SOMETIMES
            : !( idInLath % 4 )
            ? 50                                // RARELY
        : !( ++ idInLath % 0x10 )
        ? msP                                   // IF OVERRIDE
    countT ms = msP
    static countT idInLath ;

    //20201121@1823: WAS: 0 EXCEPT 250_9 EVERY 01'TH.  NOW: MORE FREQUENT BUT SHORTER NAPS

    // BOSnOvALUE( if( ms ) WHATsn else WHATsy , OS sLEEPf( ms ) )
    // 
    // ;
    // 
    //         : 0x40 ;
    //         ? 0
    //     : tinP.cYield % prime
    //     ? msP
    // countT ms = msP
    // 
    // countT prime = processGlobal2I.pcPrime[ ( tinP.cYield + tinP.osPid ) % processGlobal2I.ccPrime ] ;
    // 
    // //20171221@1344: ENABLED RANDOM SLEEP TO HOPEFULLY ELIMINATE BLUE TOOTH MOUSE UNRESPONSIVENESS ON LAPTOP NETBOOK
    // //IF BLAMMO IS NOT DONE AFTER TUCK YIELDS THEN THE Sleep CALL MUST OCCASIONALLY NAP ; THIS IS TO PREVENT IPDOS (tm) FROM FREEZING THE COMPUTER WITH A RUDE INFINITE YIELD LOOP
    // //20170916@1311: REMOVED THE RANDOM SLEEP WITHOUT ANALYSIS.  CONJ: THIS WILL FORCE GOOD PROGRAMMING STYLE, WILL ELIMINATE MYSTERIOUS SLOW SPEED, AND LOCKING UP THE COMPUTER CAN BE PREVENTED BY SETTING A SUFFICIENTLY LOW YIELDlIMIT
    // 
    // }
    //     //thirdC::dosWriteStdOutIF( ostoBuf ) ;
    //     //OStEXTAK( ostoBuf , ">\r\n" ) ;
    //     //OStEXTC( ostoBuf , tinP.cYield , 0 ) ;
    //     //OStEXTAK( ostoBuf , ":" ) ;
    //     //OStEXTC( ostoBuf , idLineNoteP , 0 ) ;
    //     //OStEXTAK( ostoBuf , "." ) ;
    //     //OStEXTC( ostoBuf , idiFileNoteP , 0 ) ;
    //     //OStEXTAK( ostoBuf , "." ) ;
    //     //OStEXTA( ostoBuf , tinP.postThreadName ) ;
    //     //OStEXTAK( ostoBuf , "|" ) ;
    //     //OStEXTC( ostoBuf , tinP.pAdamGlobal1->idAdam , 0 ) ;
    //     //OStEXTAK( ostoBuf , "<" ) ;
    //     //OStEXT( ostoBuf , 0x140 )
    // 
    //     BLAMMO ; // IF GET HERE THEN I AM BEING CALLED IN AN INAPPROPRIATE SITUATION
    // {
    // if( !( tinP.cYield % ( YIELDlIMIT >> 0 ) ) )

    if( tinP.pAdamGlobal1->cYieldHighWater < tinP.cYield ) tinP.pAdamGlobal1->cYieldHighWater = tinP.cYield ;

    //U::J: }
    //U::J:     }
    //U::J:         }
    //U::J:             LOGcALLnEST( "osThreadYieldIF" )
    //U::J:             LOGrAW3(    "osThreadYieldIF [cYield]:    " , was , "\r\n" ) ;
    //U::J:             CONoUTrAW3( "osThreadYieldIF [cYield]:    " , was , "\r\n" ) ;
    //U::J:             //WOULD RESET cYield: etherC::etRockIF( tinP ).traceF( tinP , (strokeS*)(const osTextT*)ostoSay1 , flTRACE_PARAMETERiSoStEXT ) ;
    //U::J:         {
    //U::J:         else
    //U::J:         }
    //U::J:             etherC::etRockIF( tinP ).traceF( tinP , T("osThreadYieldIF [cYield]:  ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    //U::J:         {
    //U::J:         if( tinP.pEther )
    //U::J:     {
    //U::J:     else if( was && !( was % ( TUCK >> 4 ) ) && F(tinP.flagsThreadMode3) & flTHREADmODE3_LOGsPINcALLnEST )
    //U::J:     if( was == - 1 ) { BLAMMO ; }
    //U::J:     countT was = tinP.cYield ++ ;
    //U::J: {

    //U::J: ALL CALLS TO traceF ARE COMMENTED OUT TO PREVENT INFINITE RECURSION, WHICH WAS OBSERVED 20180703@2025

    //20140101@1107: DISABLE THIS TIME BOMB FOR SERVER RELIABILITY: if( - 1 == incv02AM( tinP.pAdamGlobal1->cYieldHighWater ) ) { BLAMMO ; }

    if( tinP.idDesire != ifcTHREADpRIORITY_SPINLOCK ) { BLAMMO ; }

    _IO_
{
/*1*/voidT thirdC::osThreadYieldIF( tinS& tinP , const countT idLineNoteP , const countT idiFileNoteP , const byteT* const pbBitsNoteP , const countT msP )/*1*/

/**/
*/
i just use the impotence exception handler to create a report
i do not cause impotence
no overhead code, for max speed and also for unconditional behavior
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

