
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bReported ;

    //}
    //    bReported = 1 ;
    //        
    //    else                        sRptP << (strokeS*)( T("\r\n") ) ;
    //    if( bg.idiFileGrabberNote ) sRptP << (strokeS*)( T(" ")+TF2(bg.idiFileGrabberNote,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("(")+TF4(bg.idLineGrabberNote,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,0,0xa)+T(")\r\n") ) ;
    //        
    //    ) ;
    //        
    //        +T(" at:")+TF2(bg.idiFileGrabber,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("(")+TF4(bg.idLineGrabber,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,0,0xa)+T(")")
    //        +T(" ct:")+TF2(bg.idiFileCt,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("(")+TF4(bg.idLineCt,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,0,0xa)+T(")")
    //        T(psttPrefixP)
    //        
    //    sRptP << (strokeS*)(
    //    baseGrabC& bg = *(baseGrabC*)pbCopyBase ;
    //{
    //if( bOk )
    //thirdC::dosReadProcessMemoryIF( tinP , pbCopyBase , sizeof( baseGrabC ) , bOk , pvGrabP , osPidP ) ;
    //ZE( boolT , bOk ) ;
    //byteT pbCopyBase[ sizeof( baseGrabC ) ] ;
    //U::CODE MINE FOR EXPLORATORY REPORTING OF SUPPLEMENTAL INFORMATION AVAILABLE IF THIS IS A grabC BUT NOT IF THIS IS A grabitC GRAB

    bReported = 1 ;
                
    ) ;
                
        +T(" grab object ")+TF2(pcPanLifiP[0],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" grabF at:")+TF2(pcPanLifiP[2],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("(")+TF4(pcPanLifiP[1],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,0,0xa)+T(")\r\n")
        T(psttPrefixP)
                
    sRptP << (strokeS*)(

    ZE( boolT , bReported ) ;
{
boolT reportGrabF( tinS& tinP , soulC& sRptP , const strokeS* const psttPrefixP , const countT* const pcPanLifiP , const countT osPidP )

}
    QUITR
    etThread.boxPutF( tinP , tFolder+T("openMe.bat") , tBat , tBat.csF( tinP ) ) ;
    TN( tBat , "@echo off\r\nideafarm.01000020.ipdos-wm \"" ) ; tBat += tFolder + tKiller + T("\" !noTells\r\n") ;
    
    FORsTRINGSiNsPANNEDcOMBINEDtAIL1
    }
        }
            etThread.delF( tinP , pbf ) ;
            etThread.delF( tinP , psttShort ) ;
    
            etThread.boxPutF( tinP , tFolder+T(psttShort) , pbf , cbf ) ;
    
            //etThread.strokeF( tinP , T(psttShort)+T("\r\n") ) ;
            etThread.strWordF( tinP , psttShort , psttc1 , sttq , S1C('/') , - 1 ) ; ___( psttShort ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , psttShort ) ;
            etThread.boxGetShadowF( tinP , pbf , cbf , psttc1 ) ; ___( pbf ) ;
            ZE( countT , cbf ) ;
            ZE( byteT* , pbf ) ;
        {
        )
            etThread.strIdF( tinP , tKiller                    , psttc1 )
            etThread.strIdF( tinP , T("ideafarm.01000020.ipdos-wm") , psttc1 ) ||
            etThread.strIdF( tinP , T("ideafarm.01020010.ipdos-wm") , psttc1 ) ||
        (
        if
    {
    FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
    etThread.boxMenuF( tinP , soul1m , tMaster+T("*") ) ;
    soulC soul1m( tinP , TAG( TAGiDnULL ) ) ;
    
    TN( tKiller , "" ) ; tKiller = T("ideafarm.")+TF3(ifcIDaDAM_UNINSTALLER,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,8)+T(".ipdos-wm") ;
    TN( tMaster , "///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/master/" ) ;
    
    TN( tFolder , postFOLDERrEMOVALuTILITY ) ;
    
    QUITO( &bNU )
    ZE( boolT , bNU ) ;
{
voidT buildRemovalUtilityF( tinS& tinP , etherC& etThread )

}
    _OUT_
    //CONoUTrAW( "\r\n" ) ; //U::
    //CONoUTrAW( postThreadName ) ; //U::
    //CONoUTrAW( "tinEntryS ct: " ) ; //U::
    thirdC::c_strncpyIF( tinP , postThreadName , postThreadNameP , sizeof postThreadName ) ;
    _INoLD_    TELLlIFInAME( "tinEntryS::tinEntryS" )
{
idStepLath( 0 )
idiFileCt( idiFileCtP ) ,
idLineCt( idLineCtP ) ,
idTinNamed( idTinNamedP ) ,
idThread( idThreadP ) ,
idTin( idTinP ) ,
pbCopy( 0 ) ,
ip( ipP ) ,
bIda( bIdaP ) ,
osPid( osPidP ) ,
osTid( osTidP ) ,
idSerial( idSerialP ) ,
tinEntryS::tinEntryS( tinS& tinP , countT idSerialP , countT osTidP , countT osPidP , boolT bIdaP , countT ipP , countT idTinP , countT idThreadP , const osTextT* const postThreadNameP , const countT idTinNamedP , const countT idLineCtP , const countT idiFileCtP ) :

}
    _OUT_
    thirdC::c_strncpyIF( tinP , postName , postNameP , sizeof postName ) ;
    _INoLD_    TELLlIFInAME( "sexEntryS::sexEntryS" )
{
idiFileCt( idiFileCtP )
idLineCt( idLineCtP ) ,
pbCopy( 0 ) ,
pSex( pSexP ) ,
expSlots( expSlotsP ) ,
expCbSlot( expCbSlotP ) ,
osPid( osPidP ) ,
sexEntryS::sexEntryS( tinS& tinP , const countT osPidP , const osTextT* const postNameP , const countT expCbSlotP , const countT expSlotsP , sexC* pSexP , const countT idLineCtP , const countT idiFileCtP ) :

}
    _OUT_
    _INoLD_    TELLlIFInAME( "processGlobal3EntryS::processGlobal3EntryS" )
{
cGrains( cGrainsP )
pbEarlyGrain( pbEarlyGrainP ) ,
osPid( osPidP ) ,
processGlobal3EntryS::processGlobal3EntryS( tinS& tinP , const countT osPidP , const byteT* const pbEarlyGrainP , const countT cGrainsP ) :

}
    _OUT_
    thirdC::c_strncpyIF( tinP , postName , postNameP , sizeof postName ) ;
    _INoLD_    TELLlIFInAME( "napkinEntryS::napkinEntryS" )
{
idiFileCt( idiFileCtP )
idLineCt( idLineCtP ) ,
cbData( cbDataP ) ,
pbData( pbDataP ) ,
osPid( osPidP ) ,
napkinEntryS::napkinEntryS( tinS& tinP , const countT osPidP , const osTextT* const postNameP , const byteT* const pbDataP , const countT cbDataP , const countT idLineCtP , const countT idiFileCtP ) :

}
    _OUT_
    else                                                           { BLAMMO ; }
    if( sizeof postName > thirdC::c_strlenIF( tinP , postNameP ) ) thirdC::c_strncpyIF( tinP , postName  , postNameP , sizeof postName ) ;
    _INoLD_    TELLlIFInAME( "poolOldEntryS::poolOldEntryS" )
{
costName( costNameP )
idClient( idClientP ) ,
cbPool( cbPoolP ) ,
pvMe( pvMeP ) ,
osPid( osPidP ) ,
cRef( 1 ) ,
poolOldEntryS::poolOldEntryS( tinS& tinP , countT osPidP , voidT* pvMeP , countT cbPoolP , countT idClientP , osTextT* postNameP , countT costNameP ) :

}
{
swsLog( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE|flSTACKc_ALLOWmULTIPLEuNSERIALIZED , pczLeverThread , flSTACKc_DOnOTsERIALIZE|flSTACKc_ALLOWmULTIPLEuNSERIALIZED , ifcSTACKtYPE_PTR_byteT )
pczLeverThread( 0 ) ,
swEventTally( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE|flSTACKc_ALLOWmULTIPLEuNSERIALIZED , cLeverIdType ) ,
cLeverIdType( 0 ) ,
periodDataS::periodDataS( tinS& tinP , etherC& etherP ) :

NEWdELcLASS( 2 , periodDataS )

}
{
swsProcessGlobal3( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , pczLeverAdam , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_BLOB , sizeof( processGlobal3EntryS ) )
swsTinWhere(       tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , pczLeverAdam , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_BLOB , sizeof( tinEntryS            ) ) ,
swsTin(            tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , pczLeverAdam , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_BLOB , sizeof( tinEntryS            ) ) ,
swsSex(            tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , pczLeverAdam , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_BLOB , sizeof( sexEntryS            ) ) ,
swsNapkin(         tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , pczLeverAdam , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_BLOB , sizeof( napkinEntryS         ) ) ,
pczLeverAdam( 0 ) ,
stPool(     tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED | flSTACKc_BLOB , sizeof( poolOldEntryS ) ) ,
swTallySay( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , cLeverSay ) ,
cLeverSay( 0 ) ,
grab( tinP , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS , ifcIDgRABlAYER_7BASEmISC2 ) ,
sgnDone_tmEatTelemetryF_( tinP , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC2 ) ,
bQuitEating( 0 ) ,
bQuitMonitor( 0 ) ,
ether( etherP ) ,
memorySpaceS::memorySpaceS( tinS& tinP , etherC& etherP ) :

NEWdELcLASS( 1 , memorySpaceS )

}
    return sgn ;
    _OUT_

    }
        if( !ether.strCompareF( tinP , T("tmHireF") , T(pe1->postThreadName) ) ) ether.traceF( tinP , T("M  [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(pe1->idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(pe1->bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(pe1->ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(pe1->idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(pe1->idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(pe1->postThreadName)+T(" |||| ")+TF2(pe2->idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(pe2->bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(pe2->ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(pe2->idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(pe2->idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(pe2->postThreadName) ) ;
        etherC& ether = *(etherC*)pEther ;
    {
    if( !sgn /*&& tinP.pc Utility[ 0 ]*/ )

    }                       
        else if( pe1->ip       < pe2->ip       ) sgn = - 1 ;
        else if( pe1->ip       > pe2->ip       ) sgn =   1 ;
        else if( pe1->bIda     < pe2->bIda     ) sgn = - 1 ;
        else if( pe1->bIda     > pe2->bIda     ) sgn =   1 ;
        else if( pe1->idSerial < pe2->idSerial ) sgn = - 1 ;
        else if( pe1->idSerial > pe2->idSerial ) sgn =   1 ;
        else if( pe1->idTin    < pe2->idTin    ) sgn = - 1 ;
        else if( pe1->idTin    > pe2->idTin    ) sgn =   1 ;
        else if( pe1->idThread < pe2->idThread ) sgn = - 1 ;
        else if( pe1->idThread > pe2->idThread ) sgn =   1 ;
        else if( pe1->osPid    < pe2->osPid    ) sgn = - 1 ;
             if( pe1->osPid    > pe2->osPid    ) sgn =   1 ;
    {
    if( pe1 && pe2 )
    ZE( sCountT , sgn ) ;

    tinEntryS* pe2 = (tinEntryS*)c2P ;
    tinEntryS* pe1 = (tinEntryS*)c1P ;

    _INoLD_

    }
    {
    IFbEcAREFUL
{
countT subtract_tinEntryS_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return sgn ;
    _OUT_

    //}
    //    ether.traceF( tinP , T("subtract_sexEntryS_F B   [sgn]                              :    ")+TF2(sgn,flFORMAT_NObIGITvALUES) ) ;
    //    ether.traceF( tinP , T("subtract_sexEntryS_F B 2 [osPid,expCbSlot,expSlots,postName]:    ")+TF2(pe2->osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe2->expCbSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe2->expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(pe2->postName) ) ;
    //    ether.traceF( tinP , T("subtract_sexEntryS_F B 1 [osPid,expCbSlot,expSlots,postName]:    ")+TF2(pe1->osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe1->expCbSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe1->expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(pe1->postName) ) ;
    //    etherC& ether = *(etherC*)pEther ;
    //{
    //if( pEther )

    }                       
        }
            else if( pe1->pSex      < pe2->pSex      ) sgn = - 1 ;
            else if( pe1->pSex      > pe2->pSex      ) sgn =   1 ;
            else if( pe1->expSlots  < pe2->expSlots  ) sgn = - 1 ;
            else if( pe1->expSlots  > pe2->expSlots  ) sgn =   1 ;
            else if( pe1->expCbSlot < pe2->expCbSlot ) sgn = - 1 ;
            else if( pe1->expCbSlot > pe2->expCbSlot ) sgn =   1 ;
            else if( pe1->osPid     < pe2->osPid     ) sgn = - 1 ;
                 if( pe1->osPid     > pe2->osPid     ) sgn =   1 ;
        {
        if( !sgn )
        sgn = thirdC::c_strcmpIF( tinP , pe1->postName , pe2->postName) ;
    {
    if( pe1 && pe2 )
    ZE( sCountT , sgn ) ;

    //}
    //    ether.traceF( tinP , T("subtract_sexEntryS_F A 2 [osPid,expCbSlot,expSlots,postName]:    ")+TF2(pe2->osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe2->expCbSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe2->expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(pe2->postName) ) ;
    //    ether.traceF( tinP , T("subtract_sexEntryS_F A 1 [osPid,expCbSlot,expSlots,postName]:    ")+TF2(pe1->osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe1->expCbSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe1->expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(pe1->postName) ) ;
    //    etherC& ether = *(etherC*)pEther ;
    //{
    //if( pEther )

    sexEntryS* pe2 = (sexEntryS*)c2P ;
    sexEntryS* pe1 = (sexEntryS*)c1P ;

    _INoLD_

    }
    {
    IFbEcAREFUL
{
countT subtract_sexEntryS_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return sgn ;
    _OUT_

    }                       
        }
            else if( pe1->cGrains      < pe2->cGrains      ) sgn = - 1 ;
            else if( pe1->cGrains      > pe2->cGrains      ) sgn =   1 ;
            else if( pe1->pbEarlyGrain < pe2->pbEarlyGrain ) sgn = - 1 ;
            else if( pe1->pbEarlyGrain > pe2->pbEarlyGrain ) sgn =   1 ;
            else if( pe1->osPid        < pe2->osPid        ) sgn = - 1 ;
                 if( pe1->osPid        > pe2->osPid        ) sgn =   1 ;
        {
    {
    if( pe1 && pe2 )
    ZE( sCountT , sgn ) ;

    processGlobal3EntryS* pe2 = (processGlobal3EntryS*)c2P ;
    processGlobal3EntryS* pe1 = (processGlobal3EntryS*)c1P ;

    _INoLD_

    }
    {
    IFbEcAREFUL
{
countT subtract_processGlobal3EntryS_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return sgn ;
    _OUT_

    //}
    //    ether.traceF( tinP , T("subtract_napkinEntryS_F B   [sgn]                              :    ")+TF2(sgn,flFORMAT_NObIGITvALUES) ) ;
    //    ether.traceF( tinP , T("subtract_napkinEntryS_F B 2 [osPid,expCbSlot,expSlots,postName]:    ")+TF2(pe2->osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe2->expCbSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe2->expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(pe2->postName) ) ;
    //    ether.traceF( tinP , T("subtract_napkinEntryS_F B 1 [osPid,expCbSlot,expSlots,postName]:    ")+TF2(pe1->osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe1->expCbSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe1->expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(pe1->postName) ) ;
    //    etherC& ether = *(etherC*)pEther ;
    //{
    //if( pEther )

    }                       
        }
            else if( pe1->cbData    < pe2->cbData    ) sgn = - 1 ;
            else if( pe1->cbData    > pe2->cbData    ) sgn =   1 ;
            else if( pe1->pbData    < pe2->pbData    ) sgn = - 1 ;
            else if( pe1->pbData    > pe2->pbData    ) sgn =   1 ;
            else if( pe1->osPid     < pe2->osPid     ) sgn = - 1 ;
                 if( pe1->osPid     > pe2->osPid     ) sgn =   1 ;
        {
        //if( !sgn )
        //sgn = thirdC::c_strcmpIF( tinP , pe1->postName , pe2->postName) ;
    {
    if( pe1 && pe2 )
    ZE( sCountT , sgn ) ;

    //}
    //    ether.traceF( tinP , T("subtract_napkinEntryS_F A 2 [osPid,expCbSlot,expSlots,postName]:    ")+TF2(pe2->osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe2->expCbSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe2->expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(pe2->postName) ) ;
    //    ether.traceF( tinP , T("subtract_napkinEntryS_F A 1 [osPid,expCbSlot,expSlots,postName]:    ")+TF2(pe1->osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe1->expCbSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pe1->expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(pe1->postName) ) ;
    //    etherC& ether = *(etherC*)pEther ;
    //{
    //if( pEther )

    napkinEntryS* pe2 = (napkinEntryS*)c2P ;
    napkinEntryS* pe1 = (napkinEntryS*)c1P ;

    _INoLD_

    }
    {
    IFbEcAREFUL
{
countT subtract_napkinEntryS_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return sgn ;
    _OUT_

    }                       
        }                       
            else if( pe1->pvMe     < pe2->pvMe     ) sgn = - 1 ;
            else if( pe1->pvMe     > pe2->pvMe     ) sgn =   1 ;
            else if( pe1->osPid    < pe2->osPid    ) sgn = - 1 ;
            else if( pe1->osPid    > pe2->osPid    ) sgn =   1 ;
            else if( pe1->idClient < pe2->idClient ) sgn = - 1 ;
                 if( pe1->idClient > pe2->idClient ) sgn =   1 ;
        {
        if( !sgn )
        sgn = thirdC::c_strcmpIF( tinP , pe1->postName , pe2->postName ) ;
    {
    if( pe1 && pe2 )
    ZE( sCountT , sgn ) ;

    poolOldEntryS* pe2 = (poolOldEntryS*)c2P ;
    poolOldEntryS* pe1 = (poolOldEntryS*)c1P ;

    }
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )
    _INoLD_

    }
    {
    IFbEcAREFUL
{
countT subtract_poolOldEntryS_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    }
        thThread.delF( tinP , postn ) ;
        thThread.osDriverUnregisterF( tinP , T(postn) ) ;
        stDriver >> postn ;
        ZE( osTextT* , postn ) ;
    {
    while( stDriver )
    thThread.osDriversF( tinP , stDriver , "IdeaFarmCity." ) ; //U::FUNCTION CHANGED; NOW RETURNS -ALL- DRIVERS, NOT JUST INACTIVE

    etThread.delF( tinP , psttDriverName ) ;
    }
        thThread.delF( tinP , postn ) ;

        }
            CONoUTrAW( T("i would unregister \"")+T(postn)+T("\"\r\n") ) ; //U::
            //U::thThread.osDriverUnregisterF( tinP , T(postn) ) ;
            //POPUP( T("1050104 1: actor, victim:\r\n")+T(psttDriverName)+T("\r\n")+T(postn) ) ; //U::
        {
        if( idAdamOld == idAdamNew && idVersionOld != idVersionNew )

        etThread.osDriverParseNameF( tinP , idHomeNew , idAdamNew , idVersionNew , psttDriverName ) ;
        ZE( countT , idVersionNew ) ;
        ZE( countT , idAdamNew ) ;
        ZE( countT , idHomeNew ) ;

        etThread.osDriverParseNameF( tinP , idHomeOld , idAdamOld , idVersionOld , T(postn) ) ;
        ZE( countT , idVersionOld ) ;
        ZE( countT , idAdamOld ) ;
        ZE( countT , idHomeOld ) ;

        stDriver >> postn ;
        ZE( osTextT* , postn ) ;
    {
    while( stDriver )
    thThread.osDriversF( tinP , stDriver , tMask ) ; //U::FUNCTION CHANGED; NOW RETURNS -ALL- DRIVERS, NOT JUST INACTIVE
    TN( tMask , "IdeaFarm.H" ) ; tMask += TF2(etherC::ifc_idHomeIdisk_IF(),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".") ;
    //U::EDIT ALL NECESSARY CODE SO THAT (1) OBSOLETED SERVICE CAN BE ACTIVE, AND (2) ONLY SERVICES FOR THE CURRENT HOME ARE AFFECTED

    stackC stDriver( tinP , thThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_byteT ) ;
    thirdC& thThread = etThread ;

    etThread.osDriverNameFromMasterF( tinP , psttDriverName , idAdamP ) ; ___( psttDriverName ) ;
    ZE( strokeS* , psttDriverName ) ;
{
voidT unregisterObsoleteDriversF( tinS& tinP , etherC& etThread , const countT idAdamP )
//CODEsYNC: 1050104 10200dc

#include postHEADER

/*1*//*ifcIDaDAM_KERNEL2MONITOR 4*//*1*/

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

