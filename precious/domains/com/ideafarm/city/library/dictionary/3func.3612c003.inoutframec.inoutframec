
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            if( tinP.ppbNewUntagged[ offi ] && tinP.ppbNewUntagged[ offi ] == tinP.ppbNewUntagged[ offj ] ) { BLAMMO ; }
        {
        for( countT offj = offi + 1 ; offj < sizeof tinP.ppbNewUntagged / sizeof tinP.ppbNewUntagged[ 0 ] ; offj ++ )
    {
    for( countT offi = 0 ; offi < sizeof tinP.ppbNewUntagged / sizeof tinP.ppbNewUntagged[ 0 ] ; offi ++ )
    //U:: TO FIND A BUG

    }
        say.dTimeCt      = say.cTime2      - say.cTime1      ;
        say.dCpuCyclesCt = say.cCpuCycles2 - say.cCpuCycles1 ;

        tinP.cTime2Or5Lath      = say.cTime2      ;
        tinP.cCpuCycles2Or5Lath = say.cCpuCycles2 ;

        }
            pDad->auditTime.dTimeAuditKidCt           += say.cTime2      - say.cTime1      ;
            pDad->auditCpuCycles.dCpuCyclesAuditKidCt += say.cCpuCycles2 - say.cCpuCycles1 ;
        {
        if( pDad )

        QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&say.cCpuCycles2 ) ;
        QueryPerformanceCounter( (LARGE_INTEGER*)&say.cTime2 ) ;
    {
    if( !( F(flagsCt) & flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY ) )

    tinP.monitor.idWhat1 = ifcIDwHAT_GOiNoUTfRAMED ;_
    }
        _MOLE
        //}
        //    }
        //        BLAMMO ;_
        //        LOGrAW5( "_IO_ process global [valueExpectedByInOut,*pcWatchedByInOut]: " , pg1.valueExpectedByInOut , " != " , *pg1.pcWatchedByInOut , "\r\n" ) ;_
        //    {
        //    if( pg1.pcWatchedByInOut && *pg1.pcWatchedByInOut != pg1.valueExpectedByInOut )
        //    processGlobal1S& pg1 = processGlobal1S::_processGlobal1I_IF() ;_
        //{
        //
        //}
        //    BLAMMO ;_
        //    LOGrAW5( "_IO_ tinP [valueExpectedByInOut,*pcWatchedByInOut]: " , tinP.valueExpectedByInOut , " != " , *tinP.pcWatchedByInOut , "\r\n" ) ;_
        //{
        //if( tinP.pcWatchedByInOut && *tinP.pcWatchedByInOut != tinP.valueExpectedByInOut )
        //
        //}
        //    }
        //        BLAMMO ;_
        //        /*LOGrAW3( "_IO_ / !this [idiFileCt]" , idiFileCt , "\r\n" ) ;*/
        //    {
        //    if( !c_this )
        //    countT c_this = (countT)this ;_
        //{
        //if( bClassP )

        }
            }
                }
                    thirdC::dosSleepRawIF( tinP , TUCK ) ;
                    
                    }
                        //CONoUTrAW( "\r\nstop\r\n" ) ;
                        //LOGrAW( "\r\nstop\r\n" ) ;
                        bWoth = 0 ;_
                    {
                    if( bWoth )
                {
                )
                    !( F(tinP.flagsThreadMode3) & flTHREADmODE3_GO )
                    &&
                    F(tinP.pAdamGlobal1->_thirdC_.flagsModeAdam2) & flADAMmODE2_STOP
                    &&
                    thirdC::third_idPhaseProcess_IF() <  ifcIDpHASEpROCESS_EPILOGdESTROYINGgLOBALS
                    &&
                    thirdC::third_idPhaseProcess_IF() >= ifcIDpHASEpROCESS_PROLOGaLLgLOBALScONSTRUCTED
                (
                while
                boolT bWoth = 1 ;                                                                                               // OBEY flADAMmODE2_STOP AND flTHREADmODE3_GO
            {
            if( tinP.idTinNamed != ifcIDtINnAMED_tinHeartI && tinP.idTinNamed != ifcIDtINnAMED_tinBreakI && thirdC::third_idPhaseProcess_IF() >= ifcIDpHASEpROCESS_PROLOGaLLgLOBALScONSTRUCTED && thirdC::third_idPhaseProcess_IF() < ifcIDpHASEpROCESS_EPILOGdESTROYINGgLOBALS )

            tinP.monitor.idWhat2 = idiFileCt >> 0xc ;_

            //}
            //    if( tinP.ppbNewUntagged[ offi ] ) tinP.pcLevelUntagged[ offi ] ++ ;_
            //{
            //for( countT offi = 0 ; offi < sizeof tinP.ppbNewUntagged / sizeof tinP.ppbNewUntagged[ 0 ] ; offi ++ )

            thirdC::inOutChatterIfIF( tinP ) ;_

            }
                tinP.bSuppressInOutTrace -- ;_
                }
                    //U::SUSPECTED DEADLOCK: ((etherC*)0)->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;_

                    }
                        OStEXTA( ostoSay , postTitle ) ;_
                    {
                    if( postTitle )
                    const osTextT* postTitle = processGlobal7S::_processGlobal7I_IF().source.postFileTitleF( tinP , processGlobal7S::_processGlobal7I_IF().source.idFileRankF( tinP , idiFileCt ) ) ;_
                    OStEXTAK( ostoSay , ") ++    " ) ;_
                    OStEXTC9( ostoSay , idLineCt ) ;_
                    OStEXTAK( ostoSay , "(" ) ;_
                    OStEXTC(  ostoSay , idiFileCt , 0 ) ;_
                    OStEXT(   ostoSay , TUCK << 1 ) ;_
                {
                if( !( tinP.bSuppressInOutTrace ++ ) && tinP.monitor.idThread != ifcIDtHREADlOW_tmHeartF && tinP.monitor.idThread != ifcIDtHREADlOW_break && tinP.monitor.idThread != ifcIDtHREADlOW_tmKillSocketF && tinP.monitor.idThread != ifcIDtHREADlOW_tmWatchF && tinP.monitor.idThread != ifcIDtHREADlOW_tmTimeNowF )
            {
            if( ph && ph->flags & F(flHOMEs_INoUTtRACE) )

            }
                }
                    }
                        if( -1 == incv02AM( ph->pcTallyIn[ offt ] ) ) bCarry ++ ;_
                    {
                    while( cDo -- )
                    if( bCarry ) bCarry = 0 ;_
                    countT cDo = !offt + bCarry ;_
                {
                for( countT offt = 0 ; offt < sizeof ph->pcTallyIn / sizeof ph->pcTallyIn[ 0 ] ; offt ++ )
                ZE( boolT , bCarry ) ;_
            {
            if( ph )

            homeS* ph = &homeS::homeIF() ;_

            tinP.monitor.idDirty ++ ;_

                                              eipF( &tinP.pEIPInNest[ offon ] ) ;_
            eipInNestSave               =            tinP.pEIPInNest[ offon ]   ;_

            tinP.pIdInNest[ offonk    ] = 0 ;_
            tinP.pIdInNest[ offon     ] ++ ;_

            tinP.pLFstep  [ offos2 + 1 ] =           tinP.monitor.pLFnest      [ offon2 + 1 ] = idiFileCt                                                       ;_
            idFileNestSave               =           tinP.monitor.pLFnest      [ offon2 + 1 ]                                                                   ;_

            tinP.pLFstep  [ offos2     ] =      (    tinP.monitor.pLFnest      [ offon2     ] = idLineCt & ~fliSTEP_FLAGmASK    )    |    fliSTEP_NESTcHANGE    ;_
            idLineNestSave               =           tinP.monitor.pLFnest      [ offon2     ]                                                                   ;_

            pFlagsThreadLevelModeSave    =           tinP.pFlagsThreadLevelMode[ offon ]                                                                       ;_
            idProgressNestSave           =           tinP.pIdProgressNest      [ offon ]                                                                       ;_

            const countT offonk = ( tinP.monitor.cInNest + 1 ) & OFFsLOTtINnESTmAX ; // "k" IS FOR "KID"
            const countT offon  = tinP.monitor.cInNest & OFFsLOTtINnESTmAX ; const countT offon2 = offon << 1 ;_
            const countT offos  = tinP.monitor.idStep  & OFFsLOTtINsTEPmAX ; const countT offos2 = offos << 1 ;_

            tinP.monitor.cInNest ++ ;_
            tinP.monitor.idStep ++ ;_
            tinP.monitor.idDirty ++ ;_
        {
        if( F(tinP.flagsThreadMode1) & flTHREADmODE1_UPDATEtIN && !( tinP.monitor.idDirty % 2 ) )
        _MILE
    {
    if( F(flagsCt) & flINoUTfRAMEc_REGISTERcALLnEST )
    tinP.monitor.idWhat1 = ifcIDwHAT_GOiNoUTcT ;_

    }
        }
            BLAMMO ;
            LOGrAW(    "inOutFrameC: error fingerprint\r\n" ) ;
            CONoUTrAW( "inOutFrameC: error fingerprint\r\n" ) ;

            //U:: CONJ: OBSOLETE CODE LINE: *(countT*)0 = 1 ;       // CANNOT USE BLAMMO BECAUSE DON'T HAVE tinP
        {
        if( getNegAM( pTin->fingerprint ) != FINGERnEG_TINs && getNegAM( pTin->fingerprint ) != FINGERnEG_TINszOMBIE )      //CT OF WOTH tinS INSTANCE IN EACH THREAD INVOLVES CALLING INOUT BEFORE ZOMBIE FINGERPRINT IS REPLACED
        }
            BLAMMO ;
            LOGrAW(    "inOutFrameC: error !pTin\r\n" ) ;
            CONoUTrAW( "inOutFrameC: error !pTin\r\n" ) ;
        {
        if( !pTin )
        tinS* pTin = &tinP ;
    {

    }
        if( pHome && F(pHome->flags) & flHOMEs_KILLsELFiMMEDIATELY ) { *(countT*)0 = 1 ; }
        homeS* pHome = &homeS::homeIF() ;
    {

    }
        say.dTimeB4      = !pDad ? 0 : say.cTime1      - tinP.cTime2Or5Lath      ;
        say.dCpuCyclesB4 = !pDad ? 0 : say.cCpuCycles1 - tinP.cCpuCycles2Or5Lath ;

        }
            pDad->auditTime     .dTimeAuditKidBetween      += say.cTime1      - tinP.cTime2Or5Lath      ;
            pDad->auditCpuCycles.dCpuCyclesAuditKidBetween += say.cCpuCycles1 - tinP.cCpuCycles2Or5Lath ;
        {
        if( pDad )
        QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&say.cCpuCycles1 ) ;
        QueryPerformanceCounter( (LARGE_INTEGER*)&say.cTime1 ) ;
    {
    if( !( F(flagsCt) & flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY ) )

    say.idiFileInOut = idiFileP ;
    say.idLineInOut  = idLineP ;

    //}
    //    }
    //        }
    //            countT foo = 2 ;
    //        {
    //        if( cNest > TUCK )
    //        cNest ++ ;
    //
    //        pc = pc->pDad ;
    //    {
    //    while( pc->pDad )
    //    inOutFrameC* pc = tinP.pInOutFrame ;
    //    ZE( countT , cNest ) ;
    //{

#endif
    }
        }
            }
                }
                    }
                        }
                            }
                                }
                                    default: { BLAMMO ; break ; }
                                    }
                                        break ;
                                    {
                                    case 0x360e1010 :   // 3func.360e1010.slotsC.newF
                                    case 0x360010a9 :   // 3func.360010a9.thirdc.newdeltypethird
                                    case 0x3600108a :   // 3func.3600108a.thirdc.newdeltypethird
                                    case 0x36001085 :   // 3func.36001085.thirdc.newdeltypethird
                                    case 0x3600107a :   // 3func.3600107a.thirdc.newdeltypethird
                                    case 0x36001079 :   // 3func.36001079.thirdc.newdeltypethird
                                    case 0x36001075 :   // 3func.36001075.thirdc.newdeltypethird
                                    case 0x36001074 :   // 3func.36001074.thirdc.newdeltypethird
                                    case 0x36001073 :   // 3func.36001073.thirdc.newdeltypethird
                                    case 0x36001033 :   // 3func.36001033.thirdC.poolNewF3func.36001033.thirdc.poolnewf
                                    case 0x3400a001 :   // 3func.3400a001.newdelclass
                                    case 0x34009001 :   // 3func.34009001.newdelclass
                                    case 0x34008001 :   // 3func.34008001.newdelclass
                                    case 0x34007001 :   // 3func.34007001.newdelclass
                                    case 0x34006001 :   // 3func.34006001.newdelclass
                                    case 0x34005001 :   // 3func.34005001.newdelclass
                                    case 0x34004001 :   // 3func.34004001.newdelclass
                                    case 0x34003001 :   // 3func.34003001.newdelclass
                                {
                                switch( idFileNestDadDad )
                            {
                            default:
                            }
                                break ;
                            {
                            case 0x360e1010 :   // 3func.360e1010.slotsC.newF
                            case 0x360010a9 :   // 3func.360010a9.thirdc.newdeltypethird
                            case 0x3600108a :   // 3func.3600108a.thirdc.newdeltypethird
                            case 0x36001085 :   // 3func.36001085.thirdc.newdeltypethird
                            case 0x3600107a :   // 3func.3600107a.thirdc.newdeltypethird
                            case 0x36001079 :   // 3func.36001079.thirdc.newdeltypethird
                            case 0x36001075 :   // 3func.36001075.thirdc.newdeltypethird
                            case 0x36001074 :   // 3func.36001074.thirdc.newdeltypethird
                            case 0x36001073 :   // 3func.36001073.thirdc.newdeltypethird
                            case 0x36001033 :   // 3func.36001033.thirdC.poolNewF3func.36001033.thirdc.poolnewf
                            case 0x3400a001 :   // 3func.3400a001.newdelclass
                            case 0x34009001 :   // 3func.34009001.newdelclass
                            case 0x34008001 :   // 3func.34008001.newdelclass
                            case 0x34007001 :   // 3func.34007001.newdelclass
                            case 0x34006001 :   // 3func.34006001.newdelclass
                            case 0x34005001 :   // 3func.34005001.newdelclass
                            case 0x34004001 :   // 3func.34004001.newdelclass
                            case 0x34003001 :   // 3func.34003001.newdelclass
                        {
                        switch( idFileNestDad )
                    {
                    default:
                    }
                        break ;
                    {
                    case 0x360e1010 :   // 3func.360e1010.slotsC.newF
                    case 0x360010a9 :   // 3func.360010a9.thirdc.newdeltypethird
                    case 0x3600108a :   // 3func.3600108a.thirdc.newdeltypethird
                    case 0x36001085 :   // 3func.36001085.thirdc.newdeltypethird
                    case 0x3600107a :   // 3func.3600107a.thirdc.newdeltypethird
                    case 0x36001079 :   // 3func.36001079.thirdc.newdeltypethird
                    case 0x36001075 :   // 3func.36001075.thirdc.newdeltypethird
                    case 0x36001074 :   // 3func.36001074.thirdc.newdeltypethird
                    case 0x36001073 :   // 3func.36001073.thirdc.newdeltypethird
                    case 0x36001033 :   // 3func.36001033.thirdC.poolNewF3func.36001033.thirdc.poolnewf
                    case 0x3400a001 :   // 3func.3400a001.newdelclass
                    case 0x34009001 :   // 3func.34009001.newdelclass
                    case 0x34008001 :   // 3func.34008001.newdelclass
                    case 0x34007001 :   // 3func.34007001.newdelclass
                    case 0x34006001 :   // 3func.34006001.newdelclass
                    case 0x34005001 :   // 3func.34005001.newdelclass
                    case 0x34004001 :   // 3func.34004001.newdelclass
                    case 0x34003001 :   // 3func.34003001.newdelclass
                {
                switch( idFileNest )
            {
            if( tinP.ppbNewUntagged[ offr ] )
        {
        for( countT offr = 0 ; offr < sizeof tinP.ppbNewUntagged / sizeof tinP.ppbNewUntagged[ 0 ] ; offr ++ )

        const countT idFileNestDadDad = tinP.monitor.pLFnest[ offon2DadDad + 1 ] ;
        const countT idFileNestDad    = tinP.monitor.pLFnest[ offon2Dad    + 1 ] ;
        const countT idFileNest       = tinP.monitor.pLFnest[ offon2       + 1 ] ;

        const countT offonDadDad = ( tinP.monitor.cInNest - 2 ) & OFFsLOTtINnESTmAX ; const countT offon2DadDad = offonDadDad << 1 ;
        const countT offonDad    = ( tinP.monitor.cInNest - 1 ) & OFFsLOTtINnESTmAX ; const countT offon2Dad    = offonDad    << 1 ;
        const countT offon       =   tinP.monitor.cInNest       & OFFsLOTtINnESTmAX ; const countT offon2       = offon       << 1 ;
    {
    //U:: TO FIND A BUG
#if defined( NEVERdEFINED )

    if( F(processGlobal1I._thirdC_flagsModeProcess1) & flMODEpROCESS1_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY ) { BLAMMO ; } //U:: THIS FLAG CANNOT BE SUPPORTED UNTIL CODE THAT MUST SUPPRESS inOutFrameC APP TELEMETRY IGNORES IT ; THIS COULD BE DONE WITH A NEW THREAD MODE FLAG

    tinP.pInOutFrame = this ;
{
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles4
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles3
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles2
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles1
//INTENTIONALLY UNINITIALIZED FOR SPEED: pFlagsThreadLevelModeSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: idProgressNestSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: eipInNestSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: idLineNestSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: idFileNestSave
idWhat2Save( tinP.monitor.idWhat2 )
idWhat1Save( tinP.monitor.idWhat1 ) ,
) ,
    )
                        //: flINoUTfRAMEc_null                            //TO ENABLE  GENERALLY  (ENABLE THIS LINE IN PRODUCTION IFF WANT FULL TIME TELEMETRY)
                        : flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY          //TO DISABLE GENERALLY  (ENABLE THIS LINE IN PRODUCTION IFF WANT MAXIMUM SPEED)

                        ? flINoUTfRAMEc_null
                    : processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH07      //THIS LINE ENABLES TELEMETRY FOR THE NULL ADAM DUT
                    ? flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY
                )
                  || processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH08      //THIS LINE DISABLES TELEMETRY FOR THE REPORTER
                  || F(processGlobal1I._thirdC_flagsModeProcess1) & flMODEpROCESS1_INoUTfRAMEdOnOTcOLLECTaPPtELEMETRY
                     F(tinP.flagsThreadMode4) & flTHREADmODE4_INoUTfRAMEdOnOTcOLLECTaPPtELEMETRY
                (
                :
                ? flINoUTfRAMEc_null
            : F(tinP.flagsThreadMode4) & flTHREADmODE4_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY
            ? flINoUTfRAMEc_null
        F(processGlobal1I._thirdC_flagsModeProcess1) & flMODEpROCESS1_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY
    (
    |
    )
        : flINoUTfRAMEc_null
        ? flINoUTfRAMEc_DEFERwRITINGaPPtELEMETRY
    ( F(tinP.flagsThreadMode4) & flTHREADmODE4_INoUTfRAMEdEFERwRITINGaPPtELEMETRY
    |
    )
        : flINoUTfRAMEc_null
        ? flINoUTfRAMEc_REGISTERcALLnEST
    ( F(tinP.flagsThreadMode4) & flTHREADmODE4_INoUTfRAMErEGISTERcALLnEST
(
flagsCt
idFileRankCt( idFileRankP ) ,
idiFileCt( idiFileP ) ,
idLineCt( idLineP ) ,
tinCt( tinP ) ,
pDad( tinP.pInOutFrame ) ,
/*1*/inOutFrameC::inOutFrameC( tinS& tinP , const countT idLineP , const countT idiFileP , const countT idFileRankP , const boolT bClassP ) :/*1*/

/* ASSUME: 02 BITS PER countT */

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

