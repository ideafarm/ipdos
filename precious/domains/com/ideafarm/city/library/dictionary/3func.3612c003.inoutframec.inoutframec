
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&say.cCpuCycles2 ) ;
    QueryPerformanceCounter( (LARGE_INTEGER*)&say.cTime2 ) ;

    //if( tinP.idTinNamed != ifcIDtINnAMED_tinHeartI ) thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG
    tinP.monitor.idWhat1 = ifcIDwHAT_GOiNoUTfRAMED ;_
    processGlobal1I.pcUtility[ 3 ] ++ ; //U::TO FIND A BUG
    processGlobal1I.pcUtility[ 0 ] -- ; //U::TO FIND A BUG
    }
        _MOLE
        //}
        //    }
        //        BLAMMO ;_
        //        LOGrAW5( "_IO_ process global [valueExpectedByInOut,*pcWatchedByInOut]: " , pg1.valueExpectedByInOut , " != " , *pg1.pcWatchedByInOut , "\r\n" ) ;_
        //    {
        //    if( pg1.pcWatchedByInOut && *pg1.pcWatchedByInOut != pg1.valueExpectedByInOut )
        //    processGlobal1S& pg1 = processGlobal1S::_processGlobal1I_IF() ;_
        //{
        //
        //}
        //    BLAMMO ;_
        //    LOGrAW5( "_IO_ tinP [valueExpectedByInOut,*pcWatchedByInOut]: " , tinP.valueExpectedByInOut , " != " , *tinP.pcWatchedByInOut , "\r\n" ) ;_
        //{
        //if( tinP.pcWatchedByInOut && *tinP.pcWatchedByInOut != tinP.valueExpectedByInOut )
        //
        //}
        //    }
        //        BLAMMO ;_
        //        /*LOGrAW3( "_IO_ / !this [idiFileCt]" , idiFileCt , "\r\n" ) ;*/
        //    {
        //    if( !c_this )
        //    countT c_this = (countT)this ;_
        //{
        //if( bClassP )

        }
            }
                }
                    thirdC::dosSleepRawIF( tinP , TUCK ) ;
                    
                    }
                        //CONoUTrAW( "\r\nstop\r\n" ) ;
                        //LOGrAW( "\r\nstop\r\n" ) ;
                        bWoth = 0 ;_
                    {
                    if( bWoth )
                {
                )
                    !( F(tinP.flagsThreadMode3) & flTHREADmODE3_GO )
                    &&
                    F(tinP.pAdamGlobal1->_thirdC_.flagsModeAdam2) & flADAMmODE2_STOP
                    &&
                    thirdC::third_idPhaseProcess_IF() <  ifcIDpHASEpROCESS_EPILOGdESTROYINGgLOBALS
                    &&
                    thirdC::third_idPhaseProcess_IF() >= ifcIDpHASEpROCESS_PROLOGaLLgLOBALScONSTRUCTED
                (
                while
                boolT bWoth = 1 ;                                                                                               // OBEY flADAMmODE2_STOP AND flTHREADmODE3_GO
            {
            if( tinP.idTinNamed != ifcIDtINnAMED_tinHeartI && tinP.idTinNamed != ifcIDtINnAMED_tinBreakI && thirdC::third_idPhaseProcess_IF() >= ifcIDpHASEpROCESS_PROLOGaLLgLOBALScONSTRUCTED && thirdC::third_idPhaseProcess_IF() < ifcIDpHASEpROCESS_EPILOGdESTROYINGgLOBALS )

            tinP.monitor.idWhat2 = idiFileCt >> 0xc ;_

            //}
            //    if( tinP.ppbNewUntagged[ offi ] ) tinP.pcLevelUntagged[ offi ] ++ ;_
            //{
            //for( countT offi = 0 ; offi < sizeof tinP.ppbNewUntagged / sizeof tinP.ppbNewUntagged[ 0 ] ; offi ++ )

            thirdC::inOutChatterIfIF( tinP ) ;_

            }
                tinP.bSuppressInOutTrace -- ;_
                }
                    //U::SUSPECTED DEADLOCK: ((etherC*)0)->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;_

                    }
                        OStEXTA( ostoSay , postTitle ) ;_
                    {
                    if( postTitle )
                    const osTextT* postTitle = processGlobal7S::_processGlobal7I_IF().source.postFileTitleF( tinP , processGlobal7S::_processGlobal7I_IF().source.idFileRankF( tinP , idiFileCt ) ) ;_
                    OStEXTAK( ostoSay , ") ++    " ) ;_
                    OStEXTC9( ostoSay , idLineCt ) ;_
                    OStEXTAK( ostoSay , "(" ) ;_
                    OStEXTC(  ostoSay , idiFileCt , 0 ) ;_
                    OStEXT(   ostoSay , TUCK << 1 ) ;_
                {
                if( !( tinP.bSuppressInOutTrace ++ ) && tinP.monitor.idThread != ifcIDtHREADlOW_tmHeartF && tinP.monitor.idThread != ifcIDtHREADlOW_break && tinP.monitor.idThread != ifcIDtHREADlOW_tmKillSocketF && tinP.monitor.idThread != ifcIDtHREADlOW_tmWatchF && tinP.monitor.idThread != ifcIDtHREADlOW_tmTimeNowF )
            {
            if( ph && ph->flags & F(flHOMEs_INoUTtRACE) )

            }
                }
                    }
                        if( -1 == incv02AM( ph->pcTallyIn[ offt ] ) ) bCarry ++ ;_
                    {
                    while( cDo -- )
                    if( bCarry ) bCarry = 0 ;_
                    countT cDo = !offt + bCarry ;_
                {
                for( countT offt = 0 ; offt < sizeof ph->pcTallyIn / sizeof ph->pcTallyIn[ 0 ] ; offt ++ )
                ZE( boolT , bCarry ) ;_
            {
            if( ph )

            homeS* ph = &homeS::homeIF() ;_

            tinP.monitor.idDirty ++ ;_

                                              eipF( &tinP.pEIPInNest[ offon ] ) ;_
            eipInNestSave               =            tinP.pEIPInNest[ offon ]   ;_

            tinP.pIdInNest[ offonk    ] = 0 ;_
            tinP.pIdInNest[ offon     ] ++ ;_

            tinP.pLFstep  [ offos2 + 1 ] =           tinP.monitor.pLFnest      [ offon2 + 1 ] = idiFileCt                                                       ;_
            idFileNestSave               =           tinP.monitor.pLFnest      [ offon2 + 1 ]                                                                   ;_

            tinP.pLFstep  [ offos2     ] =      (    tinP.monitor.pLFnest      [ offon2     ] = idLineCt & ~fliSTEP_FLAGmASK    )    |    fliSTEP_NESTcHANGE    ;_
            idLineNestSave               =           tinP.monitor.pLFnest      [ offon2     ]                                                                   ;_

            pFlagsThreadLevelModeSave    =           tinP.pFlagsThreadLevelMode[ offon ]                                                                       ;_
            idProgressNestSave           =           tinP.pIdProgressNest      [ offon ]                                                                       ;_

            const countT offonk = ( tinP.monitor.cInNest + 1 ) & OFFsLOTtINnESTmAX ; // "k" IS FOR "KID"
            const countT offon  = tinP.monitor.cInNest & OFFsLOTtINnESTmAX ; const countT offon2 = offon << 1 ;_
            const countT offos  = tinP.monitor.idStep  & OFFsLOTtINsTEPmAX ; const countT offos2 = offos << 1 ;_

            tinP.monitor.cInNest ++ ;_
            tinP.monitor.idStep ++ ;_
            tinP.monitor.idDirty ++ ;_
        {
        if( F(tinP.flagsThreadMode1) & flTHREADmODE1_UPDATEtIN && !( tinP.monitor.idDirty % 2 ) )
        _MILE
    {
    if( F(flagsCt) & flINoUTfRAMEc_TRACE )
    processGlobal1I.pcUtility[ 2 ] ++ ; //U::TO FIND A BUG
    processGlobal1I.pcUtility[ 0 ] ++ ; //U::TO FIND A BUG
    tinP.monitor.idWhat1 = ifcIDwHAT_GOiNoUTcT ;_

    //if( tinP.idTinNamed != ifcIDtINnAMED_tinHeartI ) thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG

    }
        }
            *(countT*)0 = 1 ;       // CANNOT USE BLAMMO BECAUSE DON'T HAVE tinP
        {
        if( getNegAM( pTin->fingerprint ) != FINGERnEG_TINs && getNegAM( pTin->fingerprint ) != FINGERnEG_TINszOMBIE )      //CT OF WOTH tinS INSTANCE IN EACH THREAD INVOLVES CALLING INOUT BEFORE ZOMBIE FINGERPRINT IS REPLACED
        if( !pTin ) { BLAMMO ; }
        tinS* pTin = &tinP ;
    {

    }
        if( pHome && F(pHome->flags) & flHOMEs_KILLsELFiMMEDIATELY ) { *(countT*)0 = 1 ; }
        homeS* pHome = &homeS::homeIF() ;
    {

    //CONoUTrAW5( "inOutFrameC [idLine,idiFile]: " , idLineP , " " , idiFileP , "\r\n" ) ; //U::TO INVESTIGATE SLOW EXECUTION

    QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&say.cCpuCycles1 ) ;
    QueryPerformanceCounter( (LARGE_INTEGER*)&say.cTime1 ) ;

    cryC cry( idiFileP ) ;
{
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles4
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles3
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles2
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles1
//INTENTIONALLY UNINITIALIZED FOR SPEED: pFlagsThreadLevelModeSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: idProgressNestSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: eipInNestSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: idLineNestSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: idFileNestSave
idWhat2Save( tinP.monitor.idWhat2 )
idWhat1Save( tinP.monitor.idWhat1 ) ,
flagsCt( F(tinP.flagsThreadMode3) & flTHREADmODE3_INoUT ? flINoUTfRAMEc_TRACE : flINoUTfRAMEc_null ) ,
idFileRankCt( idFileRankP ) ,
idiFileCt( idiFileP ) ,
idLineCt( idLineP ) ,
tinCt( tinP ) ,
/*1*/inOutFrameC::inOutFrameC( tinS& tinP , const countT idLineP , const countT idiFileP , const countT idFileRankP , const boolT bClassP ) :/*1*/

/* ASSUME: 02 BITS PER countT */

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

