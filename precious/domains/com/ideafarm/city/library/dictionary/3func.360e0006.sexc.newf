
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbo ;

    }
        THREADmODE4rESTORE

        }
            idLathNewDel = ifcIDsEXclATHnEWdEL_NEW ; // INTENTIONAL RACE

            }
                pMyNote->flagsMonitor = flOLDlEAKmONITOR_null ;
                pMyNote->idThreadDel = 0 ;
                pMyNote->idThreadNew = tinP.monitor.idThread ;
                thirdC::c_memcpyIF( tinP , (byteT*)&pMyNote->cNest , (byteT*)&tinP.monitor.cInNest , sizeof pMyNote->cNest + sizeof pMyNote->pLFnest + sizeof pMyNote->pFlagsThreadLevelMode ) ;
                pMyNote->idAdam    = tinP.pAdamGlobal1->idAdam ;

                inc02AM( pMyNote->idNewLath ) ;

                if( !pMyNote->idLineTagged || !pMyNote->idiFileTagged ) { BLAMMO ; }
                pMyNote->idiFileTagged = tinP.monitor.pLFnest[ ( ( tinP.monitor.cInNest & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
                pMyNote->idLineTagged  = tinP.monitor.pLFnest[ ( ( tinP.monitor.cInNest & OFFsLOTtINnESTmAX ) << 1 )     ] ;
                //USE THIS TO INVESTIGATE LEAKS THAT REPORT AS aaaaaaaa(aaaaaaaa) I.E. WERE NEVER TAGGED

                thirdC::c_memsetIF( tinP , (byteT*)pMyNote + 2 * sizeof( countT ) , sizeof( dropNoteS ) - 2 * sizeof( countT ) , FILLbYTE_SEXc ) ;

                dropNoteS* pMyNote = pzMetaNote + offFound ;
            {
            if( pzMetaNote )

            if( F(flagsCt) & fliSEXc_MAPPEDtOdISK ) thirdC::c_memsetIF( pbo , cbSlot - CBsEXdROPhEADER , 0 ) ; //TO SHRINK SIZE OF COMPRESSED DISK IMAGE; SANS tinP USED FOR MAX SPEED     20180611@1452: EDITED TO AVOID WIPING THE DROP HEADER (WITHOUT ANALYSIS)

            POSTPONEtEST( pbo ) ;

            }
                if( !bDone ) BLAMMO ;

                }
                    }
                        else         tinP.ppbNewUntagged[ offr ] = 0 ;
                        if( !bDone ) bDone = 1 ;
                        BLAMMO ;

                        tinP.pcUtility[ 0xa ] = BM_HIGH | cRegistrationsB ;
                        tinP.pcUtility[ 9   ] = BM_HIGH | cRegistrationsA ;

                        #endif

                            }
                                tinP.pcUtility[ 8 ] = BM_HIGH | pImpostor->idThreadDel    ;
                                tinP.pcUtility[ 7 ] = BM_HIGH | pImpostor->idThreadNew    ;
                                tinP.pcUtility[ 6 ] = BM_HIGH | pImpostor->idDelLath      ;
                                tinP.pcUtility[ 5 ] = BM_HIGH | pImpostor->idNewLath      ;
                                tinP.pcUtility[ 4 ] =           pImpostor->idiFileTagged2 ;
                                tinP.pcUtility[ 3 ] = BM_HIGH | pImpostor->idLineTagged2  ;
                                tinP.pcUtility[ 2 ] =           pImpostor->idiFileTagged  ;
                                tinP.pcUtility[ 1 ] = BM_HIGH | pImpostor->idLineTagged   ;
                                tinP.pcUtility[ 0 ] =           0x11111111                ;
                            {
                            if( pImpostor )
                            dropNoteS* pImpostor = pDropNoteF( tinP , pbo ) ;

                        #if defined( ENABLEdROPnOTES )
                    {
                    else if( tinP.ppbNewUntagged[ offr ] == pbo )       // THIS BLOCK DETECTS SYSTEM CODING ERRORS (pbo WAS DELETED BUT SOMEHOW NEVER DEREGISTERED FROM ppbNewUntagged)
                    }
                        }
                            tinP.ppbNewUntagged[ offr ] = pbo ; //SPOTLIGHTS CODE THAT DOES NOT USE ___( pb ) TO TAG DROPS, WHICH IS ILLEGAL SO THAT LEAKS ARE EASY TO FIND
                            bDone = 1 ;
                        {
                        if( !bDone )
                    {
                    if( !tinP.ppbNewUntagged[ offr ] )
                {
                for( ; offr < sizeof tinP.ppbNewUntagged / sizeof tinP.ppbNewUntagged[ 0 ] ; offr ++ )
                ZE( boolT  , bDone ) ;
                ZE( countT , offr ) ;
            {
            if( !( F(tinP.flagsThreadMode3) & flTHREADmODE3_DOnOTvERIFYpOOLdROPtAGGING ) )

            }
                BLAMMO ;
                tinP.pcUtility[ 1 ] = cRegistrationsB ;
                tinP.pcUtility[ 0 ] = cRegistrationsA ;
            {
            if( cRegistrationsB - cRegistrationsA )

            }
                }
                    if( tinP.ppbNewUntagged[ offr ] ) cRegistrationsB ++ ;
                {
                for( countT offr = 0 ; offr < sizeof tinP.ppbNewUntagged / sizeof tinP.ppbNewUntagged[ 0 ] ; offr ++ )
            {
            ZE( countT , cRegistrationsB ) ;
            //U:: TO FIND A BUG

            tinP.cPoolDropCt ++ ;

            ((countT*)pbo)[ - 1 ] = offFound ; // DROP HEADER VALUE.  IF I AM CALLED BY poolC THEN VALUE WILL CONTAIN idApt, WHICH WILL BE USED TO IDENTIFY *this SO THAT THE DROP CAN BE DELETED WITHOUT SEARCHING FOR THE CORRECT sexC INSTANCE

            pbo = pbData + cbSlot * offFound + CBsEXdROPhEADER ;
            const countT cbSlot = CBsEXdROPhEADER + ( 1 << pzMetaHead->expCbSlot ) ;
    
            if( offFound < pzMetaHead->cSlotsAvoidLo ) { BLAMMO ; } //U:: IN ALL 3*.sexC.*, REMOVE ALL OF THESE TESTS ONCE HAVE CONFIDENCE THAT CODE IS CORRECT

            //if( tinP.pc Utility[ 0 ] ) CONoUTrAW3( "\r\n[offFound]: " , offFound , "" ) ;

            offFoundLath = offFound ;
        {
        if( offFound != -1 )
        THREADmODE4oN( flTHREADmODE4_INoUTfRAMEaLLOWuNTAGGEDpOOLdROPS )

        }
            }
                if( offFound != - 1 ) offFound += cBitsIgnore ;

                offFound = btsWothAM( pbzMetaBitsOwned + cbIgnore , cBitsAll - cBitsIgnore ) ;  // THIS IS SLIGHTLY SLOWER THAN btsLathAM BUT IS USED BECAUSE IT REWARDS "BETTER" BEHAVIOR AND PENALIZES "WORSE" BEHAVIOR

                countT cBitsIgnore = cbIgnore     * SB ;
                countT cbIgnore    = cBitsSearch1 / SB ;
            {
            if( offFound == - 1 )

            offFound = btsLathAM( pbzMetaBitsOwned , cBitsSearch1 ) ;

            ;
                : offFoundLath + 1
                ? cBitsAll
            const countT cBitsSearch1 = offFoundLath == - 1
            const countT cBitsAll     = 1 << pzMetaHead->expSlots ;
        {

        countT offFound = - 1 ;

        // BAD BEHAVIOR:  PERMANENT NEW'S ARE INTERMIXED WITH FIFO NEW/DEL:  THIS WILL SLOW ME THE FUCK DOWN
        //
        // GOOD BEHAVIOR: PERMANENT NEW'S ARE FOLLOWED BY LIFO NEW/DEL:  I WILL ALWAYS FIND A 0 BIT ON THE OO'TH TRY
        //
        // GOOD BEHAVIOR: EACH NEW IS EITHER PERMANENT OR IS DELETED IMMEDIATELY I.E. BEFORE ANY OTHER NEW:  I WILL ALWAYS FIND A 0 BIT ON THE WO'TH TRY
        //
        // GOOD BEHAVIOR: NEVER DELETES ANYTHING:  I WILL ALWAYS FIND A 0 BIT ON THE OO'TH TRY
        //
        // HEURISTICS: MY SEARCH RECIPE FAVORS APPLICATION CODE THAT HAS "WELL BEHAVED" NEW/DEL BEHAVIOR

        //
        //                                                           +-- found
        //                                                           |
        //                                                >>>>>>>>>>>>>>>>>>>>>>>       SEARCH OVERLAPS SLIGHTLY BECAUSE IT BEGINS ON A BYTE BOUNDARY
        // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        //                                                +-- offFoundLath
        //                                                |
        // 1111111111111111111111111111111111111111111111111111111111011111111111       SCENARIO: sexC IS FILLED EXCEPT FOR A DELETED EARLY ALLOCATION
        //
        //
        //
        //
        //                                                +-- found
        //                                                |
        // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        //                                                +-- offFoundLath
        //                                                |
        // 0000000000000000000000000000000000000000000000001111111111111111111111       SCENARIO: LATH NEW HAS BEEN DELETED
        //
        //
        //
        //
        //                                               +-- found
        //                                               |
        // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        //                                                +-- offFoundLath
        //                                                |
        // 0000000000000000000000000000000000000000000000011111111111111111111111       SCENARIO: NOTHING DELETED
        // |                                                                    |
        // +-- 0                                                                +-- (cBitsAll-1)
        //
        //
        // BIT OFFSET 0 --> cBitsAll
        //
        // ILLUSTRATED SEARCH STRATEGY ASSUMING THERE HAVE BEEN MANY PRIOR NEWS AND ONLY WO PRIOR DELETE

        if( F(flagsCt) & fliSEXc_READoNLY ) { BLAMMO ; }
    {
    ZE( byteT* , pbo ) ;

    }
        }
            if( tinP.ppbNewUntagged[ offr ] ) cRegistrationsA ++ ;
        {
        for( countT offr = 0 ; offr < sizeof tinP.ppbNewUntagged / sizeof tinP.ppbNewUntagged[ 0 ] ; offr ++ )
    {
    ZE( countT , cRegistrationsA ) ;
    //U:: TO FIND A BUG

    //}
    //    BLAMMO ;
    //{
    //if( tinP.pAdamGlobal1->idAdam == ifcIDaDAM_ROOTlEAKlOGGER && pPoolContainsMe == tinP.pAdamGlobal1->pPoolHomeTemp )

    DROPnOTEdOESnOTwANTmE
    _IO_

    }
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/byteT* sexC::newF( tinS& tinP , const countT idLineP , const countT idiFileP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 28 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

