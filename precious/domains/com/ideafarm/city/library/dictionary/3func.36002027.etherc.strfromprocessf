
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_
    delF( tinP , argError.post ) ;
    delF( tinP , argOut.post ) ;
    POSTPONEtEST( psttErrorP ) ;
    strMakeF( tinP , psttErrorP , T(argError.post) ) ; // CALLER MUST TAG ___( psttErrorP ) ;
    POSTPONEtEST( psttOutP ) ;
    strMakeF( tinP , psttOutP   , T(argOut.post)   ) ; // CALLER MUST TAG ___( psttOutP ) ;
    delF( tinP , psttUnique ) ;
    sgnDone_tmError.waitF( tinP ) ;
    sgnDone_tmOut.waitF( tinP ) ;

    }
        __Z( bDone ) ;
        while( !POOP && cTries -- ) ;
        }
            }
                ++ s ; osSleepF( tinP , TUCK * 0x10 ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                SCOOPSdEL
                POOPR
            {
            else
            }
                break ;
                bDone = 1 ;
                SCOOPSdEL
            {
            if( !POOP )

            boxC process( tinP , *tinP.pEtScratch , T("//process/")+T(psttUnique)+T("/")+T(psttExeP) , 0 , 0 , 0 , 1 ) ;

            SCOOPSnEW
        {
        do
        ZE( boolT , bDone ) ;
        countT cTries = 0x10 ;
    {
    IFsCRATCH

    }
        }
            ++ s ; osSleepF( tinP , TOCK ) ; //U: IF THIS ISN''T LONG ENOUGH, THE PROCESS BOX WON''T CONSTRUCT AND WE''LL HAVE A LEAK
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
        { ZE( countT , tnu ) ; osThreadF( tinP , tnu , tmErrorF , &sgnDone_tmError , flTHREADlAUNCH_null , 0 , (countT)&argError ) ; }
        { ZE( countT , tnu ) ; osThreadF( tinP , tnu , tmOutF   , &sgnDone_tmOut , flTHREADlAUNCH_null , 0 , (countT)&argOut   ) ; }
    {
    signC sgnDone_tmError( tinP , TAG( TAGiDnULL ) ) ;
    signC sgnDone_tmOut( tinP , TAG( TAGiDnULL ) ) ;
    argS argError( *this , psttUnique , psttExeP ) ;
    argS argOut( *this , psttUnique , psttExeP ) ;
    strUniqueF( tinP , psttUnique ) ; ___( psttUnique ) ;
    ZE( strokeS* , psttUnique ) ;
    _INoLD_

    }
        if( POOP ) return ;
        __NZ( psttInP ) ; //U: NOT SUPPORTED YET
        __NZ( psttArgsP ) ; //U: NOT SUPPORTED YET
        __Z( psttExeP ) ;
        __NZ( psttErrorP ) ;
        __NZ( psttOutP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::strFromProcessF( tinS& tinP , strokeS*& psttOutP , strokeS*& psttErrorP , const strokeS* const psttExeP , const strokeS* const psttArgsP , const strokeS* const psttInP )/*1*/

/**/
*/
 psttInP
 psttArgsP
 psttExeP
 psttErrorP
 psttOutP
arguments
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.103002d.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strFromProcessF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

