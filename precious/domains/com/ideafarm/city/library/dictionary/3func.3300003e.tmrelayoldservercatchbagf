
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmRelayOldServerCatchBagF )
}
    if( !bSaidBye && !ether && !bQuitP ) ;
    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": thread ending\r\n" ) ; //U::

    if( POOP ) { BLAMMO ; } //U:: TO FIND A BUG

    }
        DEL( psBag ) ;

        }
            relayOldC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
            idptPopClient >> *psBag ;
            relayOldC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flOLDrELAYpOP_DOWN , ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP ) ;
        {
        if( bPop )

        UNGRABrELAYlISTS
        }
            else bPop = 1 ;
            }
                relayOldC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptPopClient , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
            {
            if( pnRoot && *pnRoot == idptP )
            //P: SERVER WILL GOSSIP IF A POP CLIENT IMPLODING DOWNWARD TO IT DIED WITHOUT SAYING GOODBYE
        {
        if( idptPopClient && !bSaidBye && !bQuitP && idWork == OLDiDtYPErELAYpOPcLIENTwORK_IMPLODE ) //THIS CODE WILL NEVER GOSSIP ABOUT THE ROOT
        portTimeC* pnRoot = stIdptOpenP ? (portTimeC*)&stIdptOpenP[ 1 ] : 0 ;
        GRABrELAYlISTS
        ZE( boolT , bPop ) ;
    {
    if( psBag )
    soulC* psBag = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBag ) ;

    }
        stIdptPopClientP.ungrabF( tinP ) ;
        if( stIdptPopClientP( (byteT*)&idptPopClient , subtractIdPortTimesF , - 1 ) ) stIdptPopClientP.extractF( 0 , tinP ) ;
        stIdptPopClientP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( bPopClient )
    TELL( "tmRelayOldServerCatchBagF: cleaning up" )

    }
        DEL( psoP ) ;
        stPsoServerP.ungrabF( tinP ) ;
        if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
        stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    if( psoP )
    TELL( "deleting socket" )
    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": exited loop; deleting socket\r\n" ) ; //U::

    }
        }
            }
                break ;
                }
                    DEL( psoP ) ;
                    stPsoServerP.ungrabF( tinP ) ;
                    if( stPsoServerP( (countT)psoP ) ) stPsoServerP.extractF( tinP ) ;
                    stPsoServerP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( psoP )
                if( tTraceFail.csF( tinP ) ) etThread.traceF( tinP , tTraceFail ) ;
            {
            if( bFail )

            }
                }
                    }
                        }
                            tTraceFail = T("could not write sOk") ;
                            bFail = 1 ;
                            POOPRqUIET
                        {
                        if( POOP )
        
                        psoP->writeF( tinP , sOk ) ;
                        //P: SERVER NORMALLY REPLIES TO EACH COMMAND BY WRITING AN sOk
                        SCOOPS
                    {
                    IFsCRATCH
                    //etThread.traceF( tinP , T("writing sOk") ) ;
                    TELL( "writing ok" )
                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 1 writing ok\r\n" ) ; //U::
            
                    }
                        }
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 3 after doing\r\n" ) ; //U::
                            }
                                //etThread.traceF( tinP , T("called doWrapLocallyIfIF") ) ;
                                relayOldC::doWrapLocallyIfIF( tinP , etThread , RELAYiNFOaRGS , pbsWrap , idptOrigin /*U::, 2*/ ) ;  //U:: 20210209@2012: COMMENTED OUT ", 2" WITHOUT ANALYSIS TO GET DUT TO WORK
                            {
                            if( pbsWrap )
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 4 doing\r\n" ) ; //U::
                            //etThread.traceF( tinP , T("called popIF") ) ;

                            relayOldC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , sBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                            //etThread.traceF( tinP , T("calling popIF") ) ;
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 5 popping\r\n" ) ; //U::
            
                            }
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP\r\n" ) ; //U::
                                    TELL( "ifcOLDiDtYPEbAG_WRAP-" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP done\r\n" ) ; //U::
                                    if( pbsWrap ) relayOldC::doWrapLocallyIfIF( tinP , etThread , RELAYiNFOaRGS , pbsWrap , idptOrigin , 1 ) ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP doing\r\n" ) ; //U::
        
                                    //if( pbsWrap ) { CONoUTrAW( "w" ) ; }
        
                                    }
                                        pbsWrap = sBag.pbFieldF( tinP , idTypesWrap , flagssWrap , cbsWrap , ifcIDfIELDbAG_WRAP ) ;
                                        ZE( countT , cbsWrap ) ;
                                        ZE( flagsT , flagssWrap ) ;
                                        ZE( countT , idTypesWrap ) ;
                                    {
        
                                    TELL( "ifcOLDiDtYPEbAG_WRAP+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_WRAP\r\n" ) ; //U::
                                    //etThread.traceF( tinP , T("ifcOLDiDtYPEbAG_WRAP") ) ;
                                {
                                case ifcOLDiDtYPEbAG_WRAP :
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPpING\r\n" ) ; //U::
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPpING-" )
            
                                    }
                                        DEL( psBag ) ;
                                        relayOldC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                                        relayOldC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flOLDrELAYpOP_DOWN , ifcOLDiDtYPEbAG_CLIENTpOPpONG ) ;
                                    {
                                    if( psBag )
                                    soulC* psBag = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBag ) ;
                                    //P: SERVER RESPONDS TO PING BY IMPLODE POPPING DOWNWARD A "PONG"
            
                                    }
                                        }
                                            DEL( psBag ) ;
                                            relayOldC::popIF( tinP , pStPop0P , pStPop1P , pStPop2P , pStPop3P , pStPop4P , *psBag , stIdptOpenP , stIdptGossipP , idptP ) ;
                                            idptP   >> *psBag ;
                                            idptOld >> *psBag ;
                                            relayOldC::hdrBagIF( tinP , *psBag , idptP , idSerialLathHeaderP , flOLDrELAYpOP_DOWN , ifcOLDiDtYPEbAG_CLIENTpOPuNgOSSIP ) ;
                                        {
                                        if( psBag )
                                        soulC* psBag = new( 0 , tinP , LF ) soulC( tinP , TAG( TAGiDnULL ) ) ; ___( psBag ) ;
            
                                        relayOldC::handleRefreshTimeStampIF( tinP , idptP ) ;
        
                                        idptP.timeStampIfF( tinP , etThread ) ;
                                        idptOld = idptP ;
                                        portTimeC idptOld ;
                                        //P: WHENEVER SELF IS GOSSIPPED IN A PING, THE FALSELY GOSSIPPED SERVER IMPODE POPS DOWNWARD AN "UNGOSSIP" ITEM AFTER RETIMESTAMPING ITSELF
                                    {
                                    if( stIdptGossipP( (byteT*)&idptP , subtractIdPortsF , - 1 ) )
            
                                    }
                                        UNGRABrELAYlISTS
                                        }
                                            relayOldC::hisListIF( tinP , stIdptOpenP , sBag , stIdptGossipP , idField ) ;
                                            relayOldC::hisListIF( tinP , stIdptGossipP , sBag , stIdptGossipP , idField ) ;
                                            countT idField = ifcIDfIELDbAG_IDtYPE + 1 ;
                                        {
                                        stIdptGossipP.purgeF( tinP ) ;
                                        stIdptOpenP.purgeF( tinP ) ;
                                        GRABrELAYlISTS
                                        //P: SERVER REPLACES ITS LISTS IFF PING IS RECEIVED FROM ELDER
                                    {
                                    if( idptOrigin && idptOrigin - idptP < 0 )
                                    cLooksForNewPingP = 0 ;
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPpING+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPpING\r\n" ) ; //U::
                                {
                                case ifcOLDiDtYPEbAG_CLIENTpOPpING :
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOP*gOSSIP\r\n" ) ; //U::
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP-" )
                                    UNGRABrELAYlISTS
            
                                    }
                                        inc02AM( cGossipInP ) ;
                                        relayOldC::sortOpenIF( tinP , stIdptOpenP , stIdptGossipP , stIdptTempP ) ;
                                        }
                                            if( !relayOldC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idptGossipNew ) ) stIdptOpenP.sinkF( tinP , countTC() , (byteT*)&idptGossipNew , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
            
                                            }
                                                stIdptGossipP.extractF( 0 , tinP ) ;
                                            {
                                            else if( relayOldC::bListedIF( tinP , stIdptGossipP , stIdptGossipP , idptGossip ) )
                                            }
                                                stIdptGossipP.extractF( 0 , tinP ) ;
                                            {
                                            if( stIdptGossipP( (byteT*)&idptGossip , subtractIdPortsF , - 1 ) )
            
                                            }
                                                stIdptOpenP.extractF( 0 , tinP ) ;
                                            {
                                            else if( relayOldC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idptGossip ) )
                                            }
                                                stIdptOpenP.extractF( 0 , tinP ) ;
                                            {
                                            if( stIdptOpenP( (byteT*)&idptGossip , subtractIdPortTimesF , (countT)&stIdptGossipP ) )
                                            portTimeC idptGossipNew = portTimeC::fieldF( tinP , sBag , ifcIDfIELDbAG_IDtYPE + 1 + portTimeC::cFieldsF( tinP ) ) ;
                                        {
                                        else
                                        }
                                            stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptOrigin , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
                                            stIdptGossipP.sinkF( tinP , countTC() , (byteT*)&idptGossip , flSTACKsINK_UNIQUE , subtractIdPortsF , - 1 ) ;
                                            //P: GOSSIP HAS THE SAME EFFECT ON THE RELAY DOING THE GOSSIP AS ON THE VICTIM RELAY
                                        {
                                        if( idType == ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP )
                                        portTimeC idptGossip = portTimeC::fieldF( tinP , sBag , ifcIDfIELDbAG_IDtYPE + 1 ) ;
                                    {
                                    if( pnRoot && *pnRoot == idptP )
                                    //P: A SERVER WILL IGNORE GOSSIP UNLESS IT THINKS THAT IT IS ROOT
                                    portTimeC* pnRoot = stIdptOpenP ? (portTimeC*)&stIdptOpenP[ 1 ] : 0 ;
                                    GRABrELAYlISTS
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOP*gOSSIP\r\n" ) ; //U::
                                {
                                case ifcOLDiDtYPEbAG_CLIENTpOPuNgOSSIP :
                                case ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP :
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPbYE\r\n" ) ; //U::
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPbYE-" )
                                    bSaidBye = 1 ;
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPbYE+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPbYE\r\n" ) ; //U::
                                {
                                case ifcOLDiDtYPEbAG_CLIENTpOPbYE :
                                }
                                    break ;
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPhELLO\r\n" ) ; //U::
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPhELLO-" )
        
                                    //CONoUTrAW5( "tmRelayOldServerCatchBagF (idThread,idWork): " , tinP.monitor.idThread , processGlobal4I.mapPopClientWork(idWork) , 0 , "\r\n" ) ;
        
                                    idWork = sBag.cFieldF( tinP , ifcIDfIELDbAG_IDwORK ) ;
                                    stIdptPopClientP.sinkF( tinP , countTC() , (byteT*)&idptPopClient , flSTACKsINK_null , subtractIdPortTimesF , - 1 ) ;
                                    bPopClient = 1 ;
                                    idptPopClient = idptOrigin ;
                                    TELL( "ifcOLDiDtYPEbAG_CLIENTpOPhELLO+" )
                                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 6_CLIENTpOPhELLO\r\n" ) ; //U::
                                {
                                case ifcOLDiDtYPEbAG_CLIENTpOPhELLO :
                            {
                            switch( idType ) //ALL PROCESSING HERE MUST BE FAST; LONG PROCESSING SHOULD BE DONE AFTER POPPING
                            if( POOP ) { BLAMMO ; }
                            ZE( byteT* , pbsWrap ) ;
                            TELL( "local processing" )
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 7 switching on bag type\r\n" ) ; //U::
            
                            }
                                UNGRABrELAYlISTS
                                //P: A SERVER THAT THINKS THAT IT IS ROOT WILL ADD UNKNOWN ORIGIN RELAYS TO ITS LIST
                                }
                                    etThread.traceF( tinP , T("registered origin [cNodes,idptOrigin]:    ")+TF2(stIdptOpenP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(nn4,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    countT nn4 = *(const countT*)(nicNameC&)idptOrigin ;
                                    stIdptOpenP.sinkF( tinP , countTC() , (byteT*)&idptOrigin , flSTACKsINK_UNIQUE , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                {
                                if( ideMe == 1 && idptOrigin && !relayOldC::bListedIF( tinP , stIdptOpenP , stIdptGossipP , idptOrigin ) )
                                countT ideMe = stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 8 after grabbing lists\r\n" ) ; //U::
                                GRABrELAYlISTS
                                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 9 grabbing lists\r\n" ) ; //U::
                            {
            
                            swsIdSerialReceivedP.ungrabF( tinP ) ;
                            }
                                //P: EACH SERVER IGNORES DUPLICATES OF UPWARD BOUND ITEMS THAT IT HAS ALREADY PROCESSED
                                }
                                    bAltSwsP = !bAltSwsP ;
                                    ((stackC&)swsId).purgeF( tinP ) ;
                                {
                                if( swsId > 0x100 )
                                THREADmODE1rESTORE
                                swsId.sinkF( tinP , countTC() , idSerial , flSTACKsINK_UNIQUE ) ;
                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                switchStackC& swsId = bAltSwsP ? swsIdSerialReceivedAltP : swsIdSerialReceivedP ;
                                TELL( "registering serial" )
                            {
                            )
                                )
                                    )
                                        idType == ifcOLDiDtYPEbAG_CLIENTpOPuNgOSSIP
                                        idType == ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP   ||
                                        idType == ifcOLDiDtYPEbAG_CLIENTpOPpONG     ||
                                    (
                                    bRoot &&
                                (
                                F(flags) & flOLDrELAYpOP_UP ||
                            (
                            if
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": a registering serial\r\n" ) ; //U::
            
                            UNGRABrELAYlISTS
                            }
                                //etThread.traceF( tinP , T("flipped flags from down to up [flags]:    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                flags |=      flOLDrELAYpOP_UP      ;
                                flags &= ~( F(flOLDrELAYpOP_DOWN) ) ;
                            {
                            )
                                idType != ifcOLDiDtYPEbAG_CLIENTpOPuNgOSSIP
                                idType != ifcOLDiDtYPEbAG_CLIENTpOPgOSSIP    &&
                                idType != ifcOLDiDtYPEbAG_CLIENTpOPpONG      &&
                                bRoot                                     &&
                                F(flags) & flOLDrELAYpOP_DOWN                &&
                            (
                            if
                            //P: A SERVER THAT THINKS THAT IT IS ROOT WILL BANG MOST ITEMS IMPLODED DOWN INTO IT
                            //etThread.traceF( tinP , T("[bRoot]:    ")+TF2(bRoot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            const boolT bRoot = 1 == stIdptOpenP( (byteT*)&idptP , subtractIdPortTimesF , (countT)&stIdptGossipP ) ;
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": b inspecting whether i am root\r\n" ) ; //U::
                            GRABrELAYlISTS
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": c.2 grabbing lists before inspecting for being root\r\n" ) ; //U::

                            //}
                            //    }
                            //        etThread.traceF( tinP , T("foreign") ) ;
                            //    {
                            //    if( nn4 != 0x266f9365 )
                            //    //etThread.traceF( tinP , T("[nn4]:    ")+TF2(nn4,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            //    countT nn4 = *(const countT*)(nicNameC&)idptOrigin ;
                            //{

                            //etThread.traceF( tinP , T("not fooey already seen [idSerial,flags,itType]:    ")+TF2(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        else
                        }
                            //}
                            //    }
                            //        }
                            //            if( pbsTo && soulC::cFieldsIF( tinP , pbsTo ) ) { CONoUTrAW3( "ignoring directed bag " , idSerial , "\r\n" ) ; }
                            //
                            //            byteT* pbsTo = soulC::pbFieldIF( tinP , idTypesTo , flagssTo , cbsTo , ifcOLDiDfIELDwRAP_TO , pbsWrap ) ;
                            //            ZE( countT , cbsTo ) ;
                            //            ZE( flagsT , flagssTo ) ;
                            //            ZE( countT , idTypesTo ) ;
                            //        {
                            //        if( pbsWrap )
                            //        byteT* pbsWrap = sBag.pbFieldF( tinP , idTypesWrap , flagssWrap , cbsWrap , ifcIDfIELDbAG_WRAP ) ;
                            //        ZE( countT , cbsWrap ) ;
                            //        ZE( flagsT , flagssWrap ) ;
                            //        ZE( countT , idTypesWrap ) ;
                            //    {
                            //    if( idType == ifcOLDiDtYPEbAG_WRAP )
                            //{
                            //FOR DEBUGGING ONLY; MUST BE COMMENTED OUT IN PRODUCTION
        
                            swsIdSerialReceivedP.ungrabF( tinP ) ;
                            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": c.1 serial already seen\r\n" ) ; //U::
                            //etThread.traceF( tinP , T("already seen [idSerial,flags,itType]:    ")+TF2(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        if( swsIdSerialReceivedP( idSerial ) || swsIdSerialReceivedAltP( idSerial ) )
                        idPortOriginP = idptOrigin ;
                        swsIdSerialReceivedP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        //CONoUTrAW3( "tmCatchBagF " , idCatch , ": d.2 inspecting serial\r\n" ) ; //U::
                    {
                    else
                    }
                        tTraceFail = T("error: null serial") ;
                        bFail = 1 ;
                    {
                    if( !idSerial )
                    TN( tcr , "\r\n" ) ;
                    TELL( "handling soul" )
                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": e inspecting for null serial\r\n" ) ; //U::

                    //etThread.traceF( tinP , T("[idSerial,flags]:    ")+TF2(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(flags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            
                    countT   idType     = sBag.cFieldF( tinP , ifcIDfIELDbAG_IDtYPE ) ;
                    flagsT&  flags      = sBag.cFieldF( tinP , ifcIDfIELDbAG_FLAGS ) ;
                    countT   idSerial   = sBag.cFieldF( tinP , ifcIDfIELDbAG_IDsERIAL ) ;
                    TELL( "inspecting received soul" )
                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": f preparing to inspect bag\r\n" ) ; //U::

                    //CONoUTrAW3( "tmCatchBagF " , idCatch , ": g inspecting psoP\r\n" ) ; //U::
                {
                else
                }
                    tTraceFail = T("i have been told to quit") ;
                    bFail = 1 ;
                {
                if( bQuitP )
                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": h inspecting bQuitP\r\n" ) ; //U::
        
                idptOriginLathGood = idptOrigin ;

                portTimeC idptOrigin = POOP ? idptNull : portTimeC::fieldF( tinP , sBag , ifcIDfIELDbAG_RELAYoRIGIN ) ;
                portTimeC idptNull ;
                //CONoUTrAW3( "tmCatchBagF " , idCatch , ": j a bag has arrived\r\n" ) ; //U::
                idCatch = 1 + incv02AM( idCatchLath ) ;
                //etThread.traceF( tinP , T("processing a bag") ) ;
                cBagsCaught ++ ;
            {
            if( !bFail )

            //etThread.traceF( tinP , T("readed  a bag") ) ;
            }
                }
                    if( !cBagsCaught ) tTraceFail = T("could not read woth sBag, so client is gone without sending me a bag, so i'm done") ;
                    bFail = 1 ;
                    POOPRqUIET
                {
                if( POOP )
                psoP->readF( tinP , sBag ) ;
                SCOOPS
            {
            IFsCRATCH
            //etThread.traceF( tinP , T("reading a bag") ) ;

            //CONoUTrAW3( "tmCatchBagF " , idCatch , ": 0 waiting for a bag to arrive\r\n" ) ; //U::
            TELL( "reading soul" )

            sOk << ifcOLDiDtYPEbAG_SERVERoK ;
            soulC sOk(  tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
            soulC sBag( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) ) ;
            ZE( boolT , bFail ) ;
        {
        IFsCRATCH
    {
    while( !etThread && !ether && !bQuitP && psoP )
    ZE( countT , cBagsCaught ) ;
    TN( tTraceFail , "" ) ;
    ZE( countT , idCatch ) ;
    static countT idCatchLath ;
    stackC stIdMe( tinP , etThread , TAG( TAGiDnULL ) ) ;
    ZE( boolT  , bSaidBye ) ;
    ZE( countT , idWork ) ;
    ZE( boolT  , bPopClient ) ;
    ZE( countT , idPingLath ) ;
    portTimeC idptOriginLathGood ;
    portTimeC idptPopClient ;

    stPsoServerP.sinkF( tinP , countTC() , (countT)psoP , flSTACKsINK_UNIQUE ) ;

    }
        psoP->etherF( tinP , *tinP.pEtScratch ) ;
    {
    IFsCRATCH

    countT&  cLooksForNewPingP =  *(countT*)pTaskP->c7 ;
    stackC&  stIdptPopClientP  =  *(stackC*)pTaskP->c6 ;
    socketC& sListenP          = *(socketC*)pTaskP->c5 ;
    socketC* psoP              =  (socketC*)pTaskP->c4 ;
    RELAYiNFOtm
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TELL( "setting up" )
/*1*/TASK( tmRelayOldServerCatchBagF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

