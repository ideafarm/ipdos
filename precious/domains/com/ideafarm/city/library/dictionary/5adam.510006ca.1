
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

raxQueryAccountDetailsF( tinP , etThread , resultAuth ) ;

raxGetAuthF( tinP , etThread , resultAuth , tUser , tKey ) ;
resultAuthS resultAuth( tinP ) ;

TN( tKey  , "100a4e75636b4b3f8adbd861548fe868" ) ;
TN( tUser , "ideafarm" ) ;

TODO

}
    etherP.traceF( tinP , tIn ) ;

    //etherP.boxPutF( tinP , T("///d/tmp/x/goo.ttt") , tIn , tIn.csF( tinP ) ) ;
    }
        }
            }
                tIn = T(postJson) ;

                }
                    }
                        case '}' : { if( !( -- idLevel ) ) bNix = 1 ; break ; }
                        case ']' :

                        case '{' : {        ++ idLevel              ; break ; }
                        case '[' :
                    {
                    switch( *postc )

                    }
                        break ;
                        *postc = 0 ;
                    {
                    if( bNix )
                {
                for( osTextT* postc = postJson ; *postc ; postc ++ )
                ZE( boolT  , bNix ) ;
                ZE( countT , idLevel ) ;
            {
            if( postJson )

            if( postJsonSq && postJsonSq < postJson ) postJson = postJsonSq ;
            osTextT* postJson   = thirdC::c_strstrIF( tinP , postBody , "{" ) ;
            osTextT* postJsonSq = thirdC::c_strstrIF( tinP , postBody , "[" ) ;
        {
        if( postBody )
        osTextT* postBody = thirdC::c_strstrIF( tinP , postHear , "\r\n\r\n" ) ;
    {
    TN( tIn , "" ) ; // WILL CONTAIN A SINGLE, TRIMMED JSON WORD

    //etherP.boxPutF( tinP , T("///d/tmp/x/foo.ttt") , postHear , costHear ) ;
    //etherP.traceF( tinP , T(postHear) ) ;
    countT costHear = ss.readF( tinP , postHear , sizeof postHear ) ;
    memset( postHear , 0 , sizeof postHear ) ;
    char postHear[ TOCK ] ; 

    ss.writeF( tinP , (osTextT*)tSay , (countT)tSay.csF( tinP ) ) ;
    etherP.delF( tinP , psttHost ) ;
    ss.connectF( tinP , 443 , socketC::nicNameIF( tinP , etherP , T(psttHost) ) ) ;
    socketC ss( tinP , etherP , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL ) ;

    //etherP.traceF( tinP , tSay ) ;

    etherP.delF( tinP , psttShort ) ;
    TN( tSay , "" ) ; tSay = T("GET ")+T(psttShort)+T("?format=json HTTP/1.1\r\nHost: ")+T(psttHost)+T("\r\nX-Auth-Token: ")+rAuthP.tAccessToken+T("\r\n\r\n") ;

    // X-Auth-Token: f064c46a782c444cb4ba4b6434288f7c
    // Host: storage.clouddrive.com
    // GET /v1/MossoCloudFS_0672d7fa-9f85-4a81-a3ab-adb66a880123?format=json HTTP/1.1
    // EXAMPLE OF QUERY (NO BODY IS SENT)

    }
        }
            etherP.strSubstringF( tinP , psttShort , idfShort , idlShort , rAuthP.tPublicUrl ) ; ___( psttShort ) ;
            etherP.strSubstringF( tinP , psttHost  , idfHost  , idlHost  , rAuthP.tPublicUrl ) ; ___( psttHost  ) ;
            ZE( countT , idlShort ) ;
            countT idlHost = idfShort - 1 ;
            idfHost ++ ;
        {
        if( idfHost && idfShort )
        countT idfShort = etherP.strIdF( tinP , strokeS( '/' ) , rAuthP.tPublicUrl , 3 ) ;
        countT idfHost  = etherP.strIdF( tinP , strokeS( '/' ) , rAuthP.tPublicUrl , 2 ) ;
    {
    ZE( strokeS* , psttShort ) ;
    ZE( strokeS* , psttHost  ) ;
{
voidT raxQueryAccountDetailsF( tinS& tinP , etherC& etherP /*, resultAccountDetailsS& rP*/ , resultAuthS& rAuthP )

}
    wordF( tinP , etherP , rP , scratchAuth , stPath , tIn ) ;
    stackC stPath( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
    scratchAuthS scratchAuth( tinP ) ;

    }
        }
            }
                tIn = T(postJson) ;

                }
                    }
                        case '}' : { if( !( -- idLevel ) ) bNix = 1 ; break ; }
                        case ']' :

                        case '{' : {        ++ idLevel              ; break ; }
                        case '[' :
                    {
                    switch( *postc )

                    }
                        break ;
                        *postc = 0 ;
                    {
                    if( bNix )
                {
                for( osTextT* postc = postJson ; *postc ; postc ++ )
                ZE( boolT  , bNix ) ;
                ZE( countT , idLevel ) ;
            {
            if( postJson )

            if( postJsonSq && postJsonSq < postJson ) postJson = postJsonSq ;
            osTextT* postJson   = thirdC::c_strstrIF( tinP , postBody , "{" ) ;
            osTextT* postJsonSq = thirdC::c_strstrIF( tinP , postBody , "[" ) ;
        {
        if( postBody )
        osTextT* postBody = thirdC::c_strstrIF( tinP , postHear , "\r\n\r\n" ) ;
    {
    TN( tIn , "" ) ; // WILL CONTAIN A SINGLE, TRIMMED JSON WORD

    countT cbIn = ss.readF( tinP , postHear , sizeof postHear ) ;
    memset( postHear , 0 , sizeof postHear ) ;
    char postHear[ TOCK ] ; 

    ss.writeF( tinP , (osTextT*)tSay , (countT)tSay.csF( tinP ) ) ;
    ss.connectF( tinP , 443 , socketC::nicNameIF( tinP , etherP , T("identity.api.rackspacecloud.com") ) ) ;
    socketC ss( tinP , etherP , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL ) ;

    tSay += TF4(tSayBody.csF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tSayBody ;
    ) ;

        "Content-Length: "
        "Content-Type: application/json\r\n"
        "Accept: application/json\r\n"
        "Host: identity.api.rackspacecloud.com\r\n"
        "User-Agent: IPDOS (tm)\r\n"
        "POST /v2.0/tokens HTTP/1.1\r\n"

    TN( tSay , 

    ) ;

        "}\r\n"
        "   }\r\n"
        "      }\r\n"
        "\"\r\n"

    tSayBody += T(

    tSayBody += T(psttKeyP) ;

    ) ;

        "         \"apiKey\": \""
        "\",\r\n"

    tSayBody += T(

    tSayBody += T(psttUserP) ;

    ) ;

        "         \"username\": \""
        "      {\r\n"
        "      \"RAX-KSKEY:apiKeyCredentials\":\r\n"
        "   {\r\n"
        "   \"auth\":\r\n"
        "{\r\n"

    TN( tSayBody ,
{
voidT raxGetAuthF( tinS& tinP , etherC& etherP , resultAuthS& rP , const strokeS* const psttUserP , const strokeS* const psttKeyP )

}
    }
        }
            //}
            //    etherP.traceF( tinP , T("[ids,idLevel]: ")+TF2(ids,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idLevel,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            //{
            //if( idLevelLag != idLevel )

            }
                }
                    }
                        ;
                            : 0
                            ? ids + 1
                        idPairWoth = ids + 1 < idWordLath

                        etherP.delF( tinP , psttPair ) ;
                        pairF( tinP , etherP , rP , sP , stPathP , psttPair ) ;
                        etherP.strTrimF( tinP , psttPair ) ; ___( psttPair ) ;
                        etherP.strSubstringF( tinP , psttPair , idPairWoth , idPairLath , psttP ) ; ___( psttPair ) ;
                        ZE( strokeS* , psttPair ) ;

                        countT idPairLath = ids - 1 ;
                    {
                    if( !idLevel || ( idLevel == 1 && ostc == ',' ) )
                {
                case ',' :

                case '}' : { -- idLevel ; } // INTENTIONAL FALLTHROUGH

                case '{' : { ++ idLevel ; break ; }

                case ']' : { -- idLevel ; break ; }

                case '[' : { ++ idLevel ; break ; }
            {
            switch( ostc )

            if( bIgnore ) continue ;

            }
                //}
                //    etherP.delF( tinP , psttIgnored ) ;
                //    etherP.traceF( tinP , T("ignored: ")+T(psttIgnored) ) ;
                //    etherP.strSubstringF( tinP , psttIgnored , idf , idl , psttP ) ; ___( psttIgnored ) ;
                //    ZE( strokeS* , psttIgnored ) ;
                //
                //    countT idl = ids ;
                //    countT idf = idsIgnoreWoth ;
                //{
                //else
                //if( bIgnore ) idsIgnoreWoth = ids ;

                bIgnore = !bIgnore ;
            {
            if( ostc == '"' )

            countT ostc = psttP[ CSpREFIX - 1 + ids ].idAdam ;
            idLevelLag = idLevel ;
        {
        for( countT ids = idWordWoth ; ids <= idWordLath ; ids ++ )
        ZE( countT , idsIgnoreWoth ) ;
        ZE( boolT , bIgnore ) ;
        countT idPairWoth = idWordWoth + 1 ;
        ZE( countT , idLevelLag ) ;
        ZE( countT , idLevel ) ;

        const countT idWordLath = psttP->idAdam ;
        const countT idWordWoth = 1 ;
    {
    if( psttP->idAdam > 2 )

    if( psttP[ CSpREFIX ].idAdam != '{' || psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != '}' ) { BLAMMO ; }
    //VERIFY THAT psttP BEGINS WITH '{' AND ENDS WITH '}'

    //
    // value := [ word , word , ... ]
    //
    // value := word
    // 
    // pair := key : value
    //
    // word := { pair , pair , ... }
    //
    // INPUT IS EXACTLY WO word
    // INPUT FORMAT SPECIFICATION
    // 
    // RECIPE
{
voidT wordF( tinS& tinP , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    }
        }
            idValueWoth = 0 ;
            etherP.delF( tinP , psttValue ) ;
            valueF( tinP , etherP , rP , sP , stPathP , psttValue ) ;
            etherP.strTrimF( tinP , psttValue ) ; ___( psttValue ) ;
            etherP.strSubstringF( tinP , psttValue , idValueWoth , idValueLath , psttP ) ; ___( psttValue ) ;
            ZE( countT , idValueLath ) ;
            ZE( strokeS* , psttValue ) ;
        {
        if( !idLevel && idValueWoth )

        }
            }
                }
                    break ;

                    }
                        ;
                            : 0
                            ? ids + 1
                        idValueWoth = ids + 1 <= idPairLath

                        idKeyWoth = 0 ;
                        etherP.delF( tinP , psttKey ) ;
                        keyF( tinP , etherP , rP , sP , stPathP , psttKey ) ;
                        etherP.strTrimF( tinP , psttKey ) ; ___( psttKey ) ;
                        etherP.strSubstringF( tinP , psttKey , idKeyWoth , idKeyLath , psttP ) ; ___( psttKey ) ;
                        ZE( strokeS* , psttKey ) ;

                        countT idKeyLath = ids - 1 ;
                    {
                    if( !idLevel && idKeyWoth )
                {
                case ':' :

                case '}' : { -- idLevel ; break ; }
                case ']' :

                case '{' : { ++ idLevel ; break ; }
                case '[' :
            {
            switch( ostc )

            if( bIgnore ) continue ;
            if( ostc == '"' ) bIgnore = !bIgnore ;

            countT ostc = psttP[ CSpREFIX - 1 + ids ].idAdam ;
        {
        for( countT ids = idPairWoth ; ids <= idPairLath ; ids ++ )
        ZE( countT , idsIgnoreWoth ) ;
        ZE( boolT  , bIgnore ) ;
        ZE( countT , idValueWoth ) ;
        countT idKeyWoth = idPairWoth ;
        ZE( countT , idLevel ) ;

        const countT idPairLath = psttP->idAdam ;
        const countT idPairWoth = 1 ;
    {
    if( psttP->idAdam > 2 )

    //
    // value := [ word , word , ... ]
    //
    // value := word
    // 
    // pair := key : value
    //
    // INPUT IS EXACTLY WO word
    // INPUT FORMAT SPECIFICATION
    // 
    // RECIPE

    //etherP.traceF( tinP , T("[pair]: ")+T(psttP) ) ;
{
voidT pairF( tinS& tinP , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    }
        etherP.delF( tinP , psttKey ) ;
        stPathP >> psttKey ;
        ZE( strokeS* , psttKey ) ;
    {
    if( stPathP )

    }
        }
            break ;
            wordF( tinP , etherP , rP , sP , stPathP , psttP ) ;
            if( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != '}' ) { BLAMMO ; }
        {
        case '{' :
        }
            break ;
            etherP.delF( tinP , psttList ) ;
            listF( tinP , etherP , rP , sP , stPathP , psttList ) ;
            etherP.strSubstringF( tinP , psttList , idf , idl , psttP ) ; ___( psttList ) ;
            countT idl = psttP->idAdam - 1 ;
            countT idf = 2 ;
            ZE( strokeS* , psttList ) ;

            if( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != ']' ) { BLAMMO ; }
        {
        case '[' :
    {
    if( psttP->idAdam ) switch( psttP[ CSpREFIX ].idAdam )

    }
        }
            }
                etherP.delF( tinP , psttw ) ;
                rP.tTenantId = T(psttw) ;
                strFromJsonF( tinP , etherP , psttw , sP.tMaybeTenantId ) ; ___( psttw ) ;

                etherP.delF( tinP , psttw ) ;
                rP.tPublicUrl = T(psttw) ;
                strFromJsonF( tinP , etherP , psttw , sP.tMaybePublicUrl ) ; ___( psttw ) ;
                ZE( strokeS* , psttw ) ;
            {
            if( !etherP.strCompareF( tinP , psttP , T("\"object-store\"") ) )
        {
        else if( !etherP.strCompareF( tinP , tPath , tWantObjectStore ) )
        }
            }
                sP.tMaybeTenantId = T(psttP) ;
            {
            if( F(sP.flags) & flME_MYrEGION )
        {
        else if( !etherP.strCompareF( tinP , tPath , tWantTenantId ) )
        }
            }
                sP.tMaybePublicUrl = T(psttP) ;
            {
            if( F(sP.flags) & flME_MYrEGION )
        {
        else if( !etherP.strCompareF( tinP , tPath , tWantPublicURL ) )
        }
            else                                                        sP.flags &= ~( flME_MYrEGION ) ;
            if( !etherP.strCompareF( tinP , T(psttP) , T("\"IAD\"") ) ) sP.flags |=    flME_MYrEGION   ;
        {
        else if( !etherP.strCompareF( tinP , tPath , tWantRegion ) )
        }
            etherP.delF( tinP , psttw ) ;
            rP.tAccessToken = T(psttw) ;
            strFromJsonF( tinP , etherP , psttw , psttP ) ; ___( psttw ) ;
            ZE( strokeS* , psttw ) ;
        {
        if( !etherP.strCompareF( tinP , tPath , tWantToken ) )

        //etherP.traceF( tinP , tPath ) ;

        TN( tWantObjectStore , "\"access\"/\"serviceCatalog\"/\"type\"/" ) ;
        TN( tWantPublicURL   , "\"access\"/\"serviceCatalog\"/\"endpoints\"/\"publicURL\"/" ) ;
        TN( tWantTenantId    , "\"access\"/\"serviceCatalog\"/\"endpoints\"/\"tenantId\"/"  ) ;
        TN( tWantRegion      , "\"access\"/\"serviceCatalog\"/\"endpoints\"/\"region\"/"    ) ;
        TN( tWantToken       , "\"access\"/\"token\"/\"id\"/"                               ) ;
    {

    // "access"/"token"/"id"/    --------    "995e991606cc43dbaddfaaed82b8aa4f"
    //
    //
    // THESE ARE THE VALUES THAT I WANT (PATH    --------    SAMPLEVALUE

    }
        while( ~hWalk ) ;
        do tPath += T((strokeS*)stPathP.upF(tinP,hWalk))+T("/") ;
    {
    if( stPathP )
    TN( tPath , "" ) ;
    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
{
voidT valueF( tinS& tinP , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    stPathP << psttw ;
    etherP.strMakeF( tinP , LF , psttw , psttP ) ; ___( psttw ) ;
    ZE( strokeS* , psttw ) ;

    //etherP.traceF( tinP , T("[key]: ")+T(psttP) ) ;
{
voidT keyF( tinS& tinP , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    }
        }
            etherP.delF( tinP , psttItem ) ;
            itemF( tinP , etherP , rP , sP , stPathP , psttItem ) ;
            etherP.strTrimF( tinP , psttItem ) ; ___( psttItem ) ;
            etherP.strSubstringF( tinP , psttItem , idItemWoth , idItemLath , psttP ) ; ___( psttItem ) ;
            ZE( countT , idItemLath ) ;
            ZE( strokeS* , psttItem ) ;
        {
        if( idItemWoth )

        }
            }
                }
                    break ;

                    }
                        ;
                            : 0
                            ? ids + 1
                        idItemWoth = ids + 1 <= idListLath

                        etherP.delF( tinP , psttItem ) ;
                        itemF( tinP , etherP , rP , sP , stPathP , psttItem ) ;
                        etherP.strTrimF( tinP , psttItem ) ; ___( psttItem ) ;
                        etherP.strSubstringF( tinP , psttItem , idItemWoth , idItemLath , psttP ) ; ___( psttItem ) ;
                        ZE( strokeS* , psttItem ) ;

                        countT idItemLath = ids - 1 ;
                    {
                    if( !idLevel )
                {
                case ',' :

                case '}' : { -- idLevel ; break ; }
                case ']' :

                case '{' : { ++ idLevel ; break ; }
                case '[' :
            {
            switch( ostc )

            if( bIgnore ) continue ;
            if( ostc == '"' ) bIgnore = !bIgnore ;

            countT ostc = psttP[ CSpREFIX - 1 + ids ].idAdam ;
        {
        for( countT ids = idListWoth ; ids <= idListLath ; ids ++ )
        ZE( countT , idsIgnoreWoth ) ;
        ZE( boolT  , bIgnore ) ;
        countT idItemWoth = idListWoth ;
        ZE( countT , idLevel ) ;

        const countT idListLath = psttP->idAdam ;
        const countT idListWoth = 1 ;
    {
    if( psttP->idAdam > 2 )

    //etherP.traceF( tinP , T("[list]: ")+T(psttP) ) ;
{
voidT listF( tinS& tinP , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    }
        }
            }
                break ;
                wordF( tinP , etherP , rP , sP , stPathP , psttP ) ;
                if( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != '}' ) { BLAMMO ; }
            {
            case '{' :
            }
                break ;
                etherP.delF( tinP , psttList ) ;
                listF( tinP , etherP , rP , sP , stPathP , psttList ) ;
                etherP.strSubstringF( tinP , psttList , idf , idl , psttP ) ; ___( psttList ) ;
                countT idl = psttP->idAdam - 1 ;
                countT idf = 2 ;
                ZE( strokeS* , psttList ) ;

                if( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != ']' ) { BLAMMO ; }
            {
            case '[' :
        {
        switch( psttP[ CSpREFIX ].idAdam )
    {
    if( psttP->idAdam )

    //etherP.traceF( tinP , T("[item]: ")+T(psttP) ) ;
{
voidT itemF( tinS& tinP , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    etherP.strReplaceF( tinP , psttP , 0 , T("\\/") , T("/") ) ; ___( psttP ) ;
    etherP.strTrimF(    tinP , psttP , psttFromP , 0 , T("\"") ) ; ___( psttP ) ;
{
voidT strFromJsonF( tinS& tinP , etherC& etherP , strokeS*& psttP , const strokeS* const psttFromP )

voidT wordF( tinS& tinP , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP ) ;
voidT listF( tinS& tinP , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP ) ;

}
{
tTenantId( tinP , TAG( TAGiDnULL ) )
tPublicUrl( tinP , TAG( TAGiDnULL ) ) ,
tAccessToken( tinP , TAG( TAGiDnULL ) ) ,
resultAuthS::resultAuthS( tinS& tinP ) :

}
{
tMaybeTenantId( tinP , TAG( TAGiDnULL ) )
tMaybePublicUrl( tinP , TAG( TAGiDnULL ) ) ,
flags( flME_null ) ,
scratchAuthS::scratchAuthS( tinS& tinP ) :

;
}
    resultAuthS( tinS& tinP ) ;

    textC   tTenantId ;
    textC   tPublicUrl ;
    textC   tAccessToken ;
{
struct resultAuthS

;
}
    scratchAuthS( tinS& tinP ) ;

    textC   tMaybeTenantId ;
    textC   tMaybePublicUrl ;
    flagsT  flags ;
{
struct scratchAuthS

#define flME_MYrEGION    0xe00001ff
#define flME_null        0xe00000ff

/*1*/WAKEsHOWtEXT( "tool.cloud.query.service.catalog.query.account" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

