
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

swFlock.ungrabF( tinP ) ;
swFlock.freeAllF( tinP ) ;

}
    DEL( pFlock ) ;

    }
        }
            }
                else                        break ;
                if( info3.NextEntryOffset ) pbInfo3 += info3.NextEntryOffset ;

                etThread.traceF( tinP , T("    [name]:    ")+T(postName) ) ;
                if( bOk ) ;

                unicodeToAnsiF( postName , sizeof postName , (byteT*)info3.FileName , info3.FileNameLength >> 1 ) ;

                thirdC::c_memsetIF( tinP , postName , sizeof postName ) ;
                osTextT postName[ TUCK << 1 ] ;

                FILE_FULL_DIR_INFO& info3 = *(FILE_FULL_DIR_INFO*)pbInfo3 ;
            {
            for(;;)
        {
        else
        }
            if( rc ) ;
            countT rc = GetLastError() ;
        {
        if( !bOk )

        bOk = GetFileInformationByHandleEx( (HANDLE)hFile.osF( ifcIDtYPEhANDLE_FILE ) , (FILE_INFO_BY_HANDLE_CLASS)FileFullDirectoryInfo_updated , pbBuffer , sizeof pbBuffer ) ;
    {

    byteT* pbInfo3 = pbBuffer ;

    }
        etThread.traceF( tinP , T("[name]:    ")+T(postName) ) ;
        if( bOk ) ;

        unicodeToAnsiF( postName , sizeof postName , (byteT*)info2.FileName , info2.FileNameLength >> 1 ) ;

        thirdC::c_memsetIF( tinP , postName , sizeof postName ) ;
        osTextT postName[ TUCK << 1 ] ;
    {
    else
    }
        if( rc ) ;
        countT rc = GetLastError() ;
    {
    if( !bOk )
    bOk = GetFileInformationByHandleEx( (HANDLE)hFile.osF( ifcIDtYPEhANDLE_FILE ) , FileNameInfo , pbBuffer , sizeof pbBuffer ) ;
    FILE_NAME_INFO& info2 = *(FILE_NAME_INFO*)pbBuffer ;
    byteT pbBuffer[ TOCK ] ;

    }
        //etThread.traceF( tinP , T("uncloaking [volume,idiFile]:    ")+TF3((countT)info.dwVolumeSerialNumber,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF3((countT)info.nFileIndexLow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+TF3((countT)info.nFileIndexHigh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
    {
    if( bOk )
    boolT bOk = GetFileInformationByHandle( (HANDLE)hFile.osF( ifcIDtYPEhANDLE_FILE ) , &info ) ;
    BY_HANDLE_FILE_INFORMATION info ;
    handleC& hFile = *pFlock ;

    fileC*& pFlock   = *(fileC**)&(countT&)swFlock ;
    psttzLeverFolder = (strokeS*)swFlock.leverF( tinP , idf ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
countT cFlavors = swFlock.cFlavorsF( tinP ) ;
swFlock.grabF( tinP , TAG( TAGiDnULL ) ) ;
TN( tb4    , "    " ) ;

etThread.traceF( tinP , T("unlocking") ) ;
ether.loafIF( tinP ) ;

//U::etThread.osThreadF( TaRG1( tmWatchHandlesF ) ) ;

etThread.osThreadF( TaRG1( tmServerF ) , (countT)&psttzLeverFolder , (countT)&swFlock ) ;

//etThread.traceF( tinP , T("folder:    ")+tFolder ) ;
//}
//    etThread.delF( tinP , psttFolder ) ;
//    tFolder = T(psttFolder) ;
//    ZE( strokeS* , psttFolder ) ; etThread.querySettingF( tinP , psttFolder , T("!ipdos.cloak.folder")  ) ; ___( psttFolder ) ;
//{
//TN( tFolder , "" ) ;

}
    etThread.delF( tinP , psttf ) ;

    }
        }
            }
                DEL( pFlock ) ;
            {
            if( cDo )

            }
                }
                    swFlock.ungrabF( tinP ) ;
                    else          { swFlock = (countT)pFlock ; pFlock = 0 ; }
                    if( swFlock ) DEL( pFlock )                                   //SHOULD BE IMPOSSIBLE
                    psttzLeverFolder = psttf ;
                    swFlock.grabF( tinP , TAG( TAGiDnULL ) ) ;
                {
                if( !cDo )
                etThread.traceF( tinP , T("folder locked:    ")+T(psttf) ) ;
            {
            else
            }
                DEL( pFlock ) ;
                etThread.traceF( tinP , T("error: could not lock folder:    ")+T(psttf) ) ;
                POOPR
            {
            if( POOP )

            fileC* pFlock = new( 0 , tinP , LF ) fileC( tinP , psttf , ifcOPENaCCESS_R , 0 , flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_BUMPkEY | flOPENdETAILS_DOnOTmAKEdIRiFnEEDED , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 ) ; ___( pFlock ) ;
        {
        while( cDo -- )  //THIS IS TO VERIFY THAT I CAN DESTROY AND RECREATE THE FILE LOCK
        countT cDo = 2 ;

        SCOOPS
    {
    IFsCRATCH
    //CS:CODEsYNCH 51000767 51000767

    stFolderToCloak >> psttf ;
    ZE( strokeS* , psttf ) ;
{
while( stFolderToCloak )

switchC swFlock( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzLeverFolder ) ;
ZE( strokeS* , psttzLeverFolder ) ;

}
    }
        }
            }
                psttf = 0 ; // psttf HAS BEEN SUNK, SO THIS COPY IS A ZOMBIE

                }
                    etThread.traceF( tinP , T("error: could not walk:    ")+T(psttf) ) ;
                    POOPR
                {
                if( POOP )

                tinP.pEtScratch->diskWalkF( tinP , cDirs , cFiles , psttf , ether , flDISKwALK_DIRECTORIESoNLY , sinkFolderToCloakCBF , pcArg , 0 , 0 ) ;
                ZE( countT , cFiles ) ;
                ZE( countT , cDirs ) ;

                SCOOPS
            {
            IFsCRATCH
        {
        else
        if( !ids ) etThread.delF( tinP , psttf ) ;

        stFolderToCloak.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        ZE( countT , ids ) ;

        stFoldersToWalk >> psttf ;
        ZE( strokeS* , psttf ) ;
    {
    while( stFoldersToWalk )

    countT pcArg[] = { (countT)tinP.pEtScratch , (countT)&stFolderToCloak , (countT)&stFolderExclude , (countT)&stFoldersExclude } ;

    }
        //else       psttf = 0 ;
        //if( !ids ) etThread.delF( tinP , psttf ) ;
        //stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //ids = 0 ;
        //etThread.strMakeF( tinP , psttf , tHome+T("tmp/") ) ; ___( psttf ) ;

        else       psttf = 0 ;
        if( !ids ) etThread.delF( tinP , psttf ) ;
        stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        ids = 0 ;
        etThread.strMakeF( tinP , psttf , tHome+T("controls/") ) ; ___( psttf ) ;

        //else       psttf = 0 ;
        //if( !ids ) etThread.delF( tinP , psttf ) ;
        //stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //ids = 0 ;
        //etThread.strMakeF( tinP , psttf , tHome+T("precious/domains/com/ideafarm/city/workshop/handle/") ) ; ___( psttf ) ;

        //else       psttf = 0 ;
        //if( !ids ) etThread.delF( tinP , psttf ) ;
        //stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //ids = 0 ;
        //etThread.strMakeF( tinP , psttf , tHome+T("ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/") ) ; ___( psttf ) ;

        //else       psttf = 0 ;
        //if( !ids ) etThread.delF( tinP , psttf ) ;
        //stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //ids = 0 ;
        //etThread.strMakeF( tinP , psttf , tHome+T("ephemeral/domains/com/ideafarm/city/park/exedll/1/master/") ) ; ___( psttf ) ;

        else       psttf = 0 ;
        if( !ids ) etThread.delF( tinP , psttf ) ;
        stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        ids = 0 ;
        etThread.strMakeF( tinP , psttf , tHome+T("IdeaFarm (tm)/") ) ; ___( psttf ) ;

        // SINK EXCLUSIONS

        else       psttf = 0 ;
        if( !ids ) etThread.delF( tinP , psttf ) ;
        stFoldersToWalk.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        ZE( countT , ids ) ;
        etThread.strMakeF( tinP , psttf , /*U:: tHome */ T("///d/tmp/locked.test/") ) ; ___( psttf ) ;

        // SINK FOLDERS TO WALK

        ZE( strokeS* , psttf ) ;
        
        etThread.traceF( tinP , T("home:  ")+tHome ) ;
        }
            etThread.delF( tinP , psttNU ) ;
            etThread.delF( tinP , psttHome ) ;
            tHome  = T(psttHome) ;
            etThread.strBisectF( tinP , psttHome , psttNU , tName , tSlash , 5 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttHome ) ; ___( psttNU ) ;
            ZE( strokeS* , psttNU ) ;
            ZE( strokeS* , psttHome ) ;
        
            //etThread.traceF( tinP , T("if name:  ")+tName ) ;
            }
                break ;
                tName = T(ifName) ;
                etThread.delF( tinP , psttLower ) ;
                ifFileNameC ifName( tinP , etThread , T(psttLower) ) ;
                etThread.strConvertToLowerCaseF( tinP , psttLower , psttc1 ) ; ___( psttLower ) ;    // D:\iDeAfArM.home.1\ephemeral\domains\com\ideafarm\city\park\exedll\1\hover\ideafarm.00000180.ipdos-we
                ZE( strokeS* , psttLower ) ;
                //etThread.traceF( tinP , T("parameter:  ")+T(psttc1) ) ;
            {
            FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )
            TN( tName , "" ) ;
            TN( tSlash , "/" ) ;
        {
        TN( tHome , "" ) ;
    {
    stackC stFoldersExclude( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;        // PLURAL:        THE EXACT MATCH FOLDER AND ALL CONTAINED SUBFOLDERS
    stackC stFolderExclude(  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;        // SINGULAR: ONLY THE EXACT MATCH FOLDER
    stackC stFoldersToWalk(  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
{
stackC stFolderToCloak(      tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

TODO

DONE( tmServerF )
}
    }
        }
            SCOOPSdEL
            }
                }
                    else                { DEL( pso ) ; }
                    if( !ether && pso ) etThread.osThreadF( TaRG1( tmcCloakServerF ) , (countT)pso , (countT)&psttzLeverFolderP , (countT)&swFlockP ) ;

                    etRock.traceF( tinP , T("cloak: called  acceptF for sListen") ) ;
                    sListen.acceptF( tinP , pso , idPortPeer , nnPeer , countTC() ) ;
                    etRock.traceF( tinP , T("cloak: calling acceptF for sListen") ) ;
                    ZE( countT , idPortPeer ) ;
                    nicNameC nnPeer ;
                    ZE( socketC* , pso ) ;
                {
                while( !POOP && !etThread && !ether )
                sListen.listenF( tinP ) ;
            {
            else
            }
                etRock.traceF( tinP , T("cloak: could not bind to a port") ) ;
                POOPR
            {
            if( POOP )

            //LOGrAW3( "home.idPortKernelMonitor: " , home.idPortKernelMonitor , "\r\n" ) ;
            etRock.traceF( tinP , T("cloak: sListen bound to port ")+TF2(home.idPortCloak,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
            home.idPortCloak = sListen.bindF( tinP ) ;
            homeS& home = homeS::homeIF() ;
            socketC sListen( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_NOsECRECY ) ;
            SCOOPSnEW
        {
        IFsCRATCH
        etThread.traceF( tinP , T("listening for clients") ) ;
    {
    while( !ether )

    switchC&  swFlockP          =  *(switchC*)pTaskP->c2 ;
    strokeS*& psttzLeverFolderP = *(strokeS**)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmServerF )

DONE( tmWatchHandlesF )
}
    }
        ether.osSleepF( tinP , TOCK >> 1 ) ;

        }
            etThread.traceF( tinP , T("hired handle.exe [value,idDeathType]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            etThread.osProcessF( tinP , osTid , osPid , value , idDeathType , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/handle/handle64.exe") , 0 , flPROCESShIRE_null , &hfOut , &hfError , 0 ) ;
            //G:etThread.osProcessF( tinP , osTid , osPid , value , idDeathType , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/bench.baseless/bench.exe") , 0 , flPROCESShIRE_null , &hfOut , &hfError , 0 ) ;
            etThread.traceF( tinP , T("hiring handle.exe") ) ;
            ZE( countT , idDeathType ) ;
            ZE( countT , value ) ;
            ZE( countT , osPid ) ;
            ZE( countT , osTid ) ;
            TN( tb4 , "    " ) ;

            const handleC& hfError = fError ;
            fileC fError( tinP , (strokeS*)tError , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

            const handleC& hfOut = fOut ;
            fileC fOut( tinP , (strokeS*)tOut , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

            TN( tError  , "" ) ; tError  = T("///d/tmp/handle.error.")+tSuffix ;
            TN( tOut    , "" ) ; tOut    = T("///d/tmp/handle.out.")+tSuffix ;
            TN( tSuffix , "" ) ; tSuffix = TF3(++idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(".ttt") ;
        {
    {
    while( !ether && !POOP )
    ZE( countT , idCycle ) ;
{
if( pTaskP )
TASK( tmWatchHandlesF )

DONE( tmcCloakServerF )
}
    }
        DEL( psoP ) ;
        }
            }
                psoP->writeF( tinP , sOut ) ;
    
                }
                    }
                        break ;

                        }
                            swFlockP.ungrabF( tinP ) ;
                            }
                                reportFilesF( tinP , etThread , sOut , pFlock , psttzLeverFolderP , flagsWant ) ;

                                fileC*& pFlock   = *(fileC**)&(countT&)swFlockP ;
                                psttzLeverFolderP = (strokeS*)swFlockP.leverF( tinP , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            countT cFlavors = swFlockP.cFlavorsF( tinP ) ;
                            swFlockP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                            sOut << (countT)ifcIDrEPLYcLOAK_ALLlOCKEDfOLDERScONTENTS ;
                            sOut << (countT)1 ;
                            sOut << (countT)FINGERnEG_CLOAKrEPLY ;
                        {
                        else
                        if( POOP ) etThread.traceF( tinP , T("error: invalid value received [flagsWant]:    ")+TF2(flagsWant,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        //FV(flFILEiNFO,flagsWant) ;
                        sIn >> flagsWant ;
                        ZE( flagsT , flagsWant ) ;
                    {
                    case ifcIDcMDcLOAK_QUERYaLLlOCKEDfOLDERScONTENTS :
                    }
                        break ;

                        }
                            swFlockP.ungrabF( tinP ) ;
                            }
                                reportFilesF( tinP , etThread , sOut , pFlock , psttFolder , flagsWant ) ;

                                fileC*& pFlock   = *(fileC**)&(countT&)swFlockP ;
                                psttzLeverFolderP = psttFolder ;

                                sOut << (countT)ifcIDrEPLYcLOAK_FOLDERcONTENTS ;
                                sOut << (countT)1 ;
                                sOut << (countT)FINGERnEG_CLOAKrEPLY ;
                            {
                            if( swFlockP.idSlotOfLeverF( tinP , (countT)psttFolder ) )
                            swFlockP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        {
                        else
                        if( POOP ) etThread.traceF( tinP , T("error: invalid value received [flagsWant]:    ")+TF2(flagsWant,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        //FV(flFILEiNFO,flagsWant) ;
                        sIn >> flagsWant ;
                        ZE( flagsT , flagsWant ) ;

                        sIn >> psttFolder ;
                        ZE( strokeS* , psttFolder ) ;
                    {
                    case ifcIDcMDcLOAK_QUERYfOLDERcONTENTS :
                {
                switch( idCmd )
                sIn >> idCmd ;
                ZE( countT , idCmd ) ;

                __( idFormat - 1 ) ;
                sIn >> idFormat ;
                ZE( countT , idFormat ) ;

                __( finger - FINGERnEG_CLOAKcOMMAND ) ;
                sIn >> finger ;
                ZE( countT , finger ) ;
            {
            else
            if( POOP ) { POOPR DEL( psoP ) ; }
    
            psoP->readF( tinP , sIn ) ;

            soulC sOut( tinP , TAG( TAGiDnULL ) ) ;
            soulC sIn(  tinP , TAG( TAGiDnULL ) ) ;
        {
        while( !POOP && !etThread && !ether && psoP )
    
        psoP->etherF( tinP , *tinP.pEtScratch ) ;
        SCOOPS
    {
    IFsCRATCH

    switchC&  swFlockP          =  *(switchC*)pTaskP->c3 ;
    strokeS*& psttzLeverFolderP = *(strokeS**)pTaskP->c2 ;
    socketC*  psoP              =   (socketC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TELL( "setting up" )
TASK( tmcCloakServerF )

}
    }
        replaceCloakF( tinP , etherP , pFlockP , psttFolderP ) ;

        }
            etherP.delF( tinP , pbBuffer ) ;
            while( !POOP && !bDone ) ;
            }
                }
                    }
                        else                        break ;
                        if( info3.NextEntryOffset ) pbInfo3 += info3.NextEntryOffset ;

                        }
                            }
                                if( F(flagsP) & flFILEiNFO_CBnAME ) ;
                                if( F(flagsP) & flFILEiNFO_CBeXTENDEDaTTRIBUTES ) ;
                                if( F(flagsP) & flFILEiNFO_ATTRIBUTES ) ;
                                if( F(flagsP) & flFILEiNFO_CBaLLOCATED ) ;
                                if( F(flagsP) & flFILEiNFO_OFFSETeNDoFfILE ) ;
                                if( F(flagsP) & flFILEiNFO_TIMEcHANGED ) ;
                                if( F(flagsP) & flFILEiNFO_TIMEwRITTEN ) ;
                                if( F(flagsP) & flFILEiNFO_TIMEaCCESSED ) ;
                                if( F(flagsP) & flFILEiNFO_TIMEcREATED ) ;
                                if( F(flagsP) & flFILEiNFO_IDsERIAL ) ;

                                if( F(flagsP) & flFILEiNFO_NAME ) sOutP << (strokeS*)T(postName) ;
                            {
                            if( thirdC::c_strcmpIF( tinP , postName , "." ) && thirdC::c_strcmpIF( tinP , postName , ".." ) )

                            etherP.traceF( tinP , T("    [name]:    ")+T(postName) ) ;
                            if( bOk ) ;

                            unicodeToAnsiF( postName , sizeof postName , (byteT*)info3.FileName , info3.FileNameLength >> 1 ) ;

                            thirdC::c_memsetIF( tinP , postName , sizeof postName ) ;
                            osTextT postName[ TUCK << 1 ] ;
                        {
                        if( !( info3.FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )

                        FILE_FULL_DIR_INFO& info3 = *(FILE_FULL_DIR_INFO*)pbInfo3 ;
                    {
                    for(;;)
                {
                else
                }
                    }
                        }
                            break ;
                            bDone = 1 ;
                        {
                        case ERROR_NO_MORE_FILES :
                        }
                            break ;
                            thirdC::c_memsetIF( tinP , pbBuffer , cbBuffer ) ;
                            etherP.newF( tinP , LF , pbBuffer , cbBuffer ) ; ___( pbBuffer ) ;
                            cbBuffer <<= 1 ;
                            etherP.delF( tinP , pbBuffer ) ;
                        {
                        case ERROR_BAD_LENGTH :
                        case ERROR_MORE_DATA :
                    {
                    switch( rc )
                    etherP.traceF( tinP , T("[rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT rc = GetLastError() ;
                {
                if( !bOk )
                boolT bOk = GetFileInformationByHandleEx( (HANDLE)hFile.osF( ifcIDtYPEhANDLE_FILE ) , (FILE_INFO_BY_HANDLE_CLASS)FileFullDirectoryInfo_updated , pbBuffer , cbBuffer ) ;
                byteT* pbInfo3 = pbBuffer ;
            {
            do
            ZE( boolT , bDone ) ;

            etherP.traceF( tinP , T("[sizeof FILE_FULL_DIR_INFO]:    ")+TF2( sizeof FILE_FULL_DIR_INFO , flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED ) ) ;

            thirdC::c_memsetIF( tinP , pbBuffer , cbBuffer ) ;
            etherP.newF( tinP , LF , pbBuffer , cbBuffer ) ; ___( pbBuffer ) ;
            countT cbBuffer = TUCK << 1 ;
            ZE( byteT* , pbBuffer ) ;

            handleC& hFile = *pFlockP ;
        {
    {
    if( F(flagsP) )

    sOutP << psttFolderP ;

    }
        if( POOP ) return ;
        //FV(flFILEiNFO,flagsP) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
voidT reportFilesF( tinS& tinP , etherC& etherP , soulC& sOutP , fileC*& pFlockP , const strokeS* const psttFolderP , const flagsT flagsP )

}
    THREADmODE1rESTORE
    }
        }
            etherP.traceF( tinP , T("folder relocked:    ")+T(psttFolderP) ) ;
        {
        else
        }
            //U:: SHUTDOWN THE COMPUTER BY FORCE HERE (SECURITY HOLE)

            DEL( pFlockP ) ;
            etherP.traceF( tinP , T("error: could not relock folder so am shutting this computer down (U::not really):    ")+T(psttFolderP) ) ;
            POOPR
        {
        if( POOP )

        pFlockP = new( 0 , tinP , LF ) fileC( tinP , psttFolderP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_BUMPkEY | flOPENdETAILS_DOnOTmAKEdIRiFnEEDED , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 ) ; ___( pFlockP ) ;

        SCOOPS
    {
    IFsCRATCH
    //CS:CODEsYNCH 51000767 51000767

    DEL( pFlockP ) ; //THIS IS NEEDED BECAUSE WINDOWS IS SUCH A PIECE OF SHIT: THERE IS NO OTHER WAY TO RESET THE HANDLE SO THAT THE NEXT QUERY DOES NOT RECEIVE "ERROR_NO_MORE_FILES"

    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

    //U:: ALT: IF I CANNOT REOPEN THE FILE, SHUT DOWN THE COMPUTER IMMEDIATELY (DECISION: DO THIS)
    //U:: ALT: SUPPORT THIS COMMAND ONLY ONCE PER PERIOD AND LAUNCH A THREAD TO WAIT A RANDOM AMOUNT OF TIME BEFORE CLOSING AND IMMEDIATELY REOPENING THIS FILE
    //U:: SECURITY HOLE: A MALICIOUS CLIENT CAN EXPLOIT THIS BY EMITTING THIS COMMAND AND THEN STARTING A CYCLING RACE TO TRY TO OPEN THE HANDLE ITSELF, PREVENTING ME FROM OPENING IT
{
voidT replaceCloakF( tinS& tinP , etherC& etherP , fileC*& pFlockP , const strokeS* const psttFolderP )

}
    return 0 ;

    _OUT_
    }
        _OUT_

        }
            else       psttf = 0 ;
            if( !ids ) etherP.delF( tinP , psttf ) ;
            stFolderToCloakP.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
            ZE( countT , ids ) ;
        {
        if( psttf )

        }
            }
                etherP.delF( tinP , psttf ) ;
                etherP.traceF( tinP , T("excluding folder but not its tree:    ")+T(psttf) ) ;
            {
            if( ids )
            stFolderExcludeP.sinkF( tinP , ids , psttf , flSTACKsINK_QUERY ) ;
            ZE( countT , ids ) ;
        {
        if( psttf && stFolderExcludeP )

        }
            while( !etherP && !stFoldersExcludeP.third && ~hWalk ) ;
            }
                }
                    break ;
                    etherP.delF( tinP , psttf ) ;
                    etherP.traceF( tinP , T("excluding folder and its tree:    ")+T(psttf) ) ;
                {
                if( 1 == etherP.strIdF( tinP , psttzf , psttf ) )

                strokeS* psttzf = (strokeS*)stFoldersExcludeP.downF( tinP , hWalk ) ;
            {
            do
            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , csttNeeded ) ;
        {
        if( stFoldersExcludeP )

        etherP.strMakeF( tinP , psttf , tName ) ; ___( psttf ) ;
        ZE( strokeS* , psttf ) ;

        //etherP.traceF( tinP , tName ) ;

        TN( tName , ifName ) ;
        ifFileNameC ifName( tinP , etherP , postNameP ) ;

        stackC& stFoldersExcludeP = *(stackC*)pcArgP[ 3 ] ;
        stackC& stFolderExcludeP  = *(stackC*)pcArgP[ 2 ] ;
        stackC& stFolderToCloakP  = *(stackC*)pcArgP[ 1 ] ;
        etherC& etherP            = *(etherC*)pcArgP[ 0 ] ;

        _INoLD_
    {
    if( postNameP )
    _INoLD_
{
boolT sinkFolderToCloakCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

}
    return 0 ;

    *pbOutP = 0 ;
    }
        pbInP ++ ;
        *( pbOutP ++ ) = *( pbInP ++ ) ;
    {
    while( cInP -- )

    if( cbOutP <= cInP ) return 1 ;
{
boolT unicodeToAnsiF( byteT* pbOutP , const countT cbOutP , const byteT* pbInP , countT cInP )
//U::MOVE TO BASE


} FILE_FULL_DIR_INFO, *PFILE_FULL_DIR_INFO;
  WCHAR         FileName[1];
  ULONG         EaSize;
  ULONG         FileNameLength;
  ULONG         FileAttributes;
  LARGE_INTEGER AllocationSize;
  LARGE_INTEGER EndOfFile;
  LARGE_INTEGER ChangeTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER CreationTime;
  ULONG         FileIndex;
  ULONG         NextEntryOffset;
typedef struct _FILE_FULL_DIR_INFO {
//CONJ: WATCOM'S NT HEADERS ARE OLD



} FILE_INFO_BY_HANDLE_CLASS_updated, *PFILE_INFO_BY_HANDLE_CLASS_updated;
  MaximumFileInfoByHandleClas_updateds
  FileNormalizedNameInfo_updated,
  FileCaseSensitiveInfo_updated,
  FileRenameInfoEx_updated,
  FileDispositionInfoEx_updated,
  FileIdExtdDirectoryRestartInfo_updated,
  FileIdExtdDirectoryInfo_updated,
  FileIdInfo_updated,
  FileAlignmentInfo_updated,
  FileStorageInfo_updated,
  FileFullDirectoryRestartInfo_updated,
  FileFullDirectoryInfo_updated,
  FileRemoteProtocolInfo_updated,
  FileIoPriorityHintInfo_updated,
  FileIdBothDirectoryRestartInfo_updated,
  FileIdBothDirectoryInfo_updated,
  FileAttributeTagInfo_updated,
  FileCompressionInfo_updated,
  FileStreamInfo_updated,
  FileEndOfFileInfo_updated,
  FileAllocationInfo_updated,
  FileDispositionInfo_updated,
  FileRenameInfo_updated,
  FileNameInfo_updated,
  FileStandardInfo_updated,
  FileBasicInfo_updated,
typedef enum _FILE_INFO_BY_HANDLE_CLASS_updated {


/*1*/WAKEhIDE( "ifcIDaDAM_CLOAK" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

