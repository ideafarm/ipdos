
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    DEL( pFlock ) ;

    }
        }
            else                        break ;
            if( info3.NextEntryOffset ) pbInfo3 += info3.NextEntryOffset ;

            etThread.traceF( tinP , T("    [name]:    ")+T(postName) ) ;
            if( bOk ) ;

            unicodeToAnsiF( postName , sizeof postName , (byteT*)info3.FileName , info3.FileNameLength >> 1 ) ;

            thirdC::c_memsetIF( tinP , postName , sizeof postName ) ;
            osTextT postName[ TUCK << 1 ] ;

            FILE_FULL_DIR_INFO& info3 = *(FILE_FULL_DIR_INFO*)pbInfo3 ;
        {
        for(;;)
    {
    else
    }
        if( rc ) ;
        countT rc = GetLastError() ;
    {
    if( !bOk )
    bOk = GetFileInformationByHandleEx( (HANDLE)hFile.osF( ifcIDtYPEhANDLE_FILE ) , (FILE_INFO_BY_HANDLE_CLASS)FileFullDirectoryInfo_updated , pbBuffer , sizeof pbBuffer ) ;
    byteT* pbInfo3 = pbBuffer ;

    }
        etThread.traceF( tinP , T("[name]:    ")+T(postName) ) ;
        if( bOk ) ;

        unicodeToAnsiF( postName , sizeof postName , (byteT*)info2.FileName , info2.FileNameLength >> 1 ) ;

        thirdC::c_memsetIF( tinP , postName , sizeof postName ) ;
        osTextT postName[ TUCK << 1 ] ;
    {
    else
    }
        if( rc ) ;
        countT rc = GetLastError() ;
    {
    if( !bOk )
    bOk = GetFileInformationByHandleEx( (HANDLE)hFile.osF( ifcIDtYPEhANDLE_FILE ) , FileNameInfo , pbBuffer , sizeof pbBuffer ) ;
    FILE_NAME_INFO& info2 = *(FILE_NAME_INFO*)pbBuffer ;
    byteT pbBuffer[ TOCK ] ;

    }
        //etThread.traceF( tinP , T("uncloaking [volume,idiFile]:    ")+TF3((countT)info.dwVolumeSerialNumber,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF3((countT)info.nFileIndexLow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+TF3((countT)info.nFileIndexHigh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
    {
    if( bOk )
    boolT bOk = GetFileInformationByHandle( (HANDLE)hFile.osF( ifcIDtYPEhANDLE_FILE ) , &info ) ;
    BY_HANDLE_FILE_INFORMATION info ;
    handleC& hFile = *pFlock ;

    stFlock >> *(countT*)&pFlock ;
    ZE( fileC* , pFlock ) ;
{
while( stFlock )

etThread.traceF( tinP , T("unlocking") ) ;
ether.loafIF( tinP ) ;

//U::etThread.osThreadF( TaRG1( tmWatchHandlesF ) ) ;

//etThread.traceF( tinP , T("folder:    ")+tFolder ) ;
//}
//    etThread.delF( tinP , psttFolder ) ;
//    tFolder = T(psttFolder) ;
//    ZE( strokeS* , psttFolder ) ; etThread.querySettingF( tinP , psttFolder , T("!ipdos.cloak.folder")  ) ; ___( psttFolder ) ;
//{
//TN( tFolder , "" ) ;

}
    etThread.delF( tinP , psttf ) ;

    }
        }
            stFlock << (countT)pFlock ; pFlock = 0 ;
            etThread.traceF( tinP , T("folder locked:    ")+T(psttf) ) ;
        {
        else
        }
            DEL( pFlock ) ;
            etThread.traceF( tinP , T("error: could not lock folder:    ")+T(psttf) ) ;
            POOPR
        {
        if( POOP )

        fileC* pFlock = new( 0 , tinP , LF ) fileC( tinP , psttf , ifcOPENaCCESS_R , 0 , flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_BUMPkEY | flOPENdETAILS_DOnOTmAKEdIRiFnEEDED , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 ) ; ___( pFlock ) ;

        }
            etThread.diskWalkF( tinP , cDirs , cFiles , psttf , ether , flDISKwALK_FILESoNLY , getFileListCBF , pcArgInner , 0 , 0 ) ;
            ZE( countT , cFiles ) ;
            ZE( countT , cDirs ) ;

            countT pcArgInner[] = { (countT)&etThread , (countT)&psttzLeverFolder , (countT)&swsFilesByFolder , (countT)&tSlash , (countT)&tb4 } ;
        {

        SCOOPS
    {
    IFsCRATCH

    stFolderToCloak >> psttf ;
    ZE( strokeS* , psttf ) ;
{
while( stFolderToCloak )
TN( tb4    , "    " ) ;
TN( tSlash , "/" ) ;
TN( tStar  , "*" ) ;
stackC stFlock( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_countT ) ;

switchStackC swsFilesByFolder( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverFolder , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
ZE( strokeS* , psttzLeverFolder ) ;

}
    }
        etThread.delF( tinP , psttf ) ;
        etThread.diskWalkF( tinP , cDirs , cFiles , psttf , ether , flDISKwALK_DIRECTORIESoNLY , sinkFolderToCloakCBF , pcArg , 0 , 0 ) ;
        ZE( countT , cFiles ) ;
        ZE( countT , cDirs ) ;

        stFoldersToWalk >> psttf ;
        ZE( strokeS* , psttf ) ;
    {
    while( stFoldersToWalk )

    countT pcArg[] = { (countT)&etThread , (countT)&stFolderToCloak , (countT)&stFolderExclude , (countT)&stFoldersExclude } ;

    }
        //else       psttf = 0 ;
        //if( !ids ) etThread.delF( tinP , psttf ) ;
        //stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //ids = 0 ;
        //etThread.strMakeF( tinP , psttf , tHome+T("tmp/") ) ; ___( psttf ) ;

        else       psttf = 0 ;
        if( !ids ) etThread.delF( tinP , psttf ) ;
        stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        ids = 0 ;
        etThread.strMakeF( tinP , psttf , tHome+T("controls/") ) ; ___( psttf ) ;

        //else       psttf = 0 ;
        //if( !ids ) etThread.delF( tinP , psttf ) ;
        //stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //ids = 0 ;
        //etThread.strMakeF( tinP , psttf , tHome+T("precious/domains/com/ideafarm/city/workshop/handle/") ) ; ___( psttf ) ;

        //else       psttf = 0 ;
        //if( !ids ) etThread.delF( tinP , psttf ) ;
        //stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //ids = 0 ;
        //etThread.strMakeF( tinP , psttf , tHome+T("ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/") ) ; ___( psttf ) ;

        //else       psttf = 0 ;
        //if( !ids ) etThread.delF( tinP , psttf ) ;
        //stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        //ids = 0 ;
        //etThread.strMakeF( tinP , psttf , tHome+T("ephemeral/domains/com/ideafarm/city/park/exedll/1/master/") ) ; ___( psttf ) ;

        else       psttf = 0 ;
        if( !ids ) etThread.delF( tinP , psttf ) ;
        stFoldersExclude.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        ids = 0 ;
        etThread.strMakeF( tinP , psttf , tHome+T("IdeaFarm (tm)/") ) ; ___( psttf ) ;

        // SINK EXCLUSIONS

        else       psttf = 0 ;
        if( !ids ) etThread.delF( tinP , psttf ) ;
        stFoldersToWalk.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
        ZE( countT , ids ) ;
        etThread.strMakeF( tinP , psttf , tHome ) ; ___( psttf ) ;

        // SINK FOLDERS TO WALK

        ZE( strokeS* , psttf ) ;
        
        etThread.traceF( tinP , T("home:  ")+tHome ) ;
        }
            etThread.delF( tinP , psttNU ) ;
            etThread.delF( tinP , psttHome ) ;
            tHome  = T(psttHome) ;
            etThread.strBisectF( tinP , psttHome , psttNU , tName , tSlash , 5 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttHome ) ; ___( psttNU ) ;
            ZE( strokeS* , psttNU ) ;
            ZE( strokeS* , psttHome ) ;
        
            //etThread.traceF( tinP , T("if name:  ")+tName ) ;
            }
                break ;
                tName = T(ifName) ;
                etThread.delF( tinP , psttLower ) ;
                ifFileNameC ifName( tinP , etThread , T(psttLower) ) ;
                etThread.strConvertToLowerCaseF( tinP , psttLower , psttc1 ) ; ___( psttLower ) ;    // D:\iDeAfArM.home.1\ephemeral\domains\com\ideafarm\city\park\exedll\1\hover\ideafarm.00000180.ipdos-we
                ZE( strokeS* , psttLower ) ;
                //etThread.traceF( tinP , T("parameter:  ")+T(psttc1) ) ;
            {
            FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tinP ) )
            TN( tName , "" ) ;
            TN( tSlash , "/" ) ;
        {
        TN( tHome , "" ) ;
    {
    stackC stFoldersExclude( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;        // PLURAL:        THE EXACT MATCH FOLDER AND ALL CONTAINED SUBFOLDERS
    stackC stFolderExclude(  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;        // SINGULAR: ONLY THE EXACT MATCH FOLDER
    stackC stFoldersToWalk(  tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
{
stackC stFolderToCloak(      tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

TODO

DONE( tmWatchHandlesF )
}
    }
        ether.osSleepF( tinP , TOCK >> 1 ) ;

        }
            etThread.traceF( tinP , T("hired handle.exe [value,idDeathType]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            etThread.osProcessF( tinP , osTid , osPid , value , idDeathType , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/handle/handle64.exe") , 0 , flPROCESShIRE_null , &hfOut , &hfError , 0 ) ;
            //G:etThread.osProcessF( tinP , osTid , osPid , value , idDeathType , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/bench.baseless/bench.exe") , 0 , flPROCESShIRE_null , &hfOut , &hfError , 0 ) ;
            etThread.traceF( tinP , T("hiring handle.exe") ) ;
            ZE( countT , idDeathType ) ;
            ZE( countT , value ) ;
            ZE( countT , osPid ) ;
            ZE( countT , osTid ) ;
            TN( tb4 , "    " ) ;

            const handleC& hfError = fError ;
            fileC fError( tinP , (strokeS*)tError , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

            const handleC& hfOut = fOut ;
            fileC fOut( tinP , (strokeS*)tOut , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

            TN( tError  , "" ) ; tError  = T("///d/tmp/handle.error.")+tSuffix ;
            TN( tOut    , "" ) ; tOut    = T("///d/tmp/handle.out.")+tSuffix ;
            TN( tSuffix , "" ) ; tSuffix = TF3(++idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(".ttt") ;
        {
    {
    while( !ether && !POOP )
    ZE( countT , idCycle ) ;
{
if( pTaskP )
TASK( tmWatchHandlesF )

}
    return 0 ;

    _OUT_
    }
        _OUT_

        }
            else       psttf = 0 ;
            if( !ids ) etherP.delF( tinP , psttf ) ;
            stFolderToCloakP.sinkF( tinP , ids , psttf , flSTACKsINK_UNIQUE ) ;
            ZE( countT , ids ) ;
        {
        if( psttf )

        }
            }
                etherP.delF( tinP , psttf ) ;
                etherP.traceF( tinP , T("excluding folder but not its tree:    ")+T(psttf) ) ;
            {
            if( ids )
            stFolderExcludeP.sinkF( tinP , ids , psttf , flSTACKsINK_QUERY ) ;
            ZE( countT , ids ) ;
        {
        if( psttf && stFolderExcludeP )

        }
            while( !etherP && !stFoldersExcludeP.third && ~hWalk ) ;
            }
                }
                    break ;
                    etherP.delF( tinP , psttf ) ;
                    etherP.traceF( tinP , T("excluding folder and its tree:    ")+T(psttf) ) ;
                {
                if( 1 == etherP.strIdF( tinP , psttzf , psttf ) )

                strokeS* psttzf = (strokeS*)stFoldersExcludeP.downF( tinP , hWalk ) ;
            {
            do
            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , csttNeeded ) ;
        {
        if( stFoldersExcludeP )

        etherP.strMakeF( tinP , psttf , tName ) ; ___( psttf ) ;
        ZE( strokeS* , psttf ) ;

        //etherP.traceF( tinP , tName ) ;

        TN( tName , ifName ) ;
        ifFileNameC ifName( tinP , etherP , postNameP ) ;

        stackC& stFoldersExcludeP = *(stackC*)pcArgP[ 3 ] ;
        stackC& stFolderExcludeP  = *(stackC*)pcArgP[ 2 ] ;
        stackC& stFolderToCloakP  = *(stackC*)pcArgP[ 1 ] ;
        etherC& etherP            = *(etherC*)pcArgP[ 0 ] ;

        _INoLD_
    {
    if( postNameP )
    _INoLD_
{
boolT sinkFolderToCloakCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

}
    return 0 ;

    _OUT_
    }
        _OUT_

        }
            //etherP.traceF( tinP , T("aok  :                                 [tPath,tShort]:    ")+tPath+tb4P+T(psttShort) ) ;
        {
        else
        }
            etherP.delF( tinP , psttShort ) ;            
            etherP.traceF( tinP , T("error: duplicate file name encountered [tPath,tShort]:    ")+tPath+tb4P+T(psttShort) ) ;
        {
        if( !ids )

#endif
        }
            while( !swsFilesByFolderP.third && ~hDown ) ;
            }
                etherP.traceF( tinP , T("walking sws [psttHe]:    \"")+T(psttHe)+T("\"") ) ;
                strokeS* psttHe = (strokeS*)swsFilesByFolderP.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( cPlates )
        etherP.traceF( tinP , T("[cPlates,tPath]:    ")+TF2(cPlates,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4P+tPath ) ;
        etherP.traceF( tinP , T(USCORE127)+T(" after") ) ;
        cPlates = swsFilesByFolderP ;
        //U:: TO FIND A BUG
#if defined( NEVERdEFINED )

        swsFilesByFolderP.sinkF( tinP , ids , psttShort , flSTACKsINK_UNIQUE ) ;
        ZE( countT , ids ) ;

#endif
        }
            while( !swsFilesByFolderP.third && ~hDown ) ;
            }
                etherP.traceF( tinP , T("walking sws [psttHe]:    \"")+T(psttHe)+T("\"") ) ;
                strokeS* psttHe = (strokeS*)swsFilesByFolderP.downF( tinP , hDown ) ;
            {
            do
            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( cPlates )
        etherP.traceF( tinP , T("[cPlates,tPath]:    ")+TF2(cPlates,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4P+tPath ) ;
        etherP.traceF( tinP , T(USCORE127)+T(" before [tShort]")+tb4P+tShort ) ;
        countT cPlates = swsFilesByFolderP ;
        //U:: TO FIND A BUG
#if defined( NEVERdEFINED )

        psttzLeverFolderP = tPath ;

        }
            etherP.delF( tinP , psttPath ) ;
            tPath  = T(psttPath) ;
            etherP.strBisectF( tinP , psttPath , psttShort , tName , tSlashP , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
            ZE( strokeS* , psttPath ) ;
        {
        ZE( strokeS* , psttShort ) ;
        TN( tPath , "" ) ;

        //etherP.traceF( tinP , tName ) ;

        TN( tName , ifName ) ;
        ifFileNameC ifName( tinP , etherP , postNameP ) ;

        textC&        tb4P              =         *(textC*)pcArgP[ 4 ] ;
        textC&        tSlashP           =         *(textC*)pcArgP[ 3 ] ;
        switchStackC& swsFilesByFolderP =  *(switchStackC*)pcArgP[ 2 ] ;
        strokeS*&     psttzLeverFolderP =      *(strokeS**)pcArgP[ 1 ] ;
        etherC&       etherP            =        *(etherC*)pcArgP[ 0 ] ;
        _INoLD_
    {
    if( postNameP )
    _INoLD_
{
boolT getFileListCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )


}
    return 0 ;

    *pbOutP = 0 ;
    }
        pbInP ++ ;
        *( pbOutP ++ ) = *( pbInP ++ ) ;
    {
    while( cInP -- )

    if( cbOutP <= cInP ) return 1 ;
{
boolT unicodeToAnsiF( byteT* pbOutP , const countT cbOutP , const byteT* pbInP , countT cInP )
//U::MOVE TO BASE


} FILE_FULL_DIR_INFO, *PFILE_FULL_DIR_INFO;
  WCHAR         FileName[1];
  ULONG         EaSize;
  ULONG         FileNameLength;
  ULONG         FileAttributes;
  LARGE_INTEGER AllocationSize;
  LARGE_INTEGER EndOfFile;
  LARGE_INTEGER ChangeTime;
  LARGE_INTEGER LastWriteTime;
  LARGE_INTEGER LastAccessTime;
  LARGE_INTEGER CreationTime;
  ULONG         FileIndex;
  ULONG         NextEntryOffset;
typedef struct _FILE_FULL_DIR_INFO {
//CONJ: WATCOM'S NT HEADERS ARE OLD


} FILE_INFO_BY_HANDLE_CLASS_updated, *PFILE_INFO_BY_HANDLE_CLASS_updated;
  MaximumFileInfoByHandleClas_updateds
  FileNormalizedNameInfo_updated,
  FileCaseSensitiveInfo_updated,
  FileRenameInfoEx_updated,
  FileDispositionInfoEx_updated,
  FileIdExtdDirectoryRestartInfo_updated,
  FileIdExtdDirectoryInfo_updated,
  FileIdInfo_updated,
  FileAlignmentInfo_updated,
  FileStorageInfo_updated,
  FileFullDirectoryRestartInfo_updated,
  FileFullDirectoryInfo_updated,
  FileRemoteProtocolInfo_updated,
  FileIoPriorityHintInfo_updated,
  FileIdBothDirectoryRestartInfo_updated,
  FileIdBothDirectoryInfo_updated,
  FileAttributeTagInfo_updated,
  FileCompressionInfo_updated,
  FileStreamInfo_updated,
  FileEndOfFileInfo_updated,
  FileAllocationInfo_updated,
  FileDispositionInfo_updated,
  FileRenameInfo_updated,
  FileNameInfo_updated,
  FileStandardInfo_updated,
  FileBasicInfo_updated,
typedef enum _FILE_INFO_BY_HANDLE_CLASS_updated {


/*1*/WAKEhIDE( "ifcIDaDAM_CLOAK" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

