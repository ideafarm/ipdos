
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUT_
    if( pBaton ) pBaton->ungrabF( tinP ) ;

    }
        }
            stackk.extractF( 0 , tinP , ids ) ;
            }
                default                             : { __( idLeverType ) ; __1                             ; break ; }
                case ifcIDtYPElEVER_PTR_soulC       : { soulC*    pcl =    (soulC*)*(countT*)pbLB ; DEL( pcl )               ; break ; }
                case ifcIDtYPElEVER_BLOBdOOMED      : { byteT*    pbl =    (byteT*)*(countT*)pbLB ; third.delF( tinP , pbl ) ; break ; }
                case ifcIDtYPElEVER_PTR_nicNameC    : { nicNameC* pcl = (nicNameC*)*(countT*)pbLB ; third.delF( tinP , pcl ) ; break ; }
                case ifcIDtYPElEVER_PTR_osTextT     : { osTextT*  pcl =  (osTextT*)*(countT*)pbLB ; third.delF( tinP , pcl ) ; break ; }
                case ifcIDtYPElEVER_PTR_plateC      : { plateC*   pcl =   (plateC*)*(countT*)pbLB ; DEL( pcl )               ; break ; }
                case ifcIDtYPElEVER_PTR_strokeS     : { strokeS*  pcl =  (strokeS*)*(countT*)pbLB ; third.delF( tinP , pcl ) ; break ; }
                case ifcIDtYPElEVER_PTR_countT      : { countT*   pcl =   (countT*)*(countT*)pbLB ; third.delF( tinP , pcl ) ; break ; }
                case ifcIDtYPElEVER_PTR_BLOB        : { byteT*    pbl =    (byteT*)*(countT*)pbLB ; third.delF( tinP , pbl ) ; break ; }
                case ifcIDtYPElEVER_PTR_lenPrefixedCountT :
                }
                    break ;
                    third.delF( tinP , *(countT**)&ppsttl ) ;
                    }
                        while( ppsttl[ off ] ) third.delF( tinP , ppsttl[ off ++ ] ) ;
                        ZE( countT , off ) ;
                    {
                    if( ppsttl )
                    strokeS** ppsttl = *(strokeS***)pbLB ;
                {
                case ifcIDtYPElEVER_PTR_ptrStrokeS  :
                case ifcIDtYPElEVER_countT          : {                                                                        break ; }
                case ifcIDtYPElEVER_tid :
            {
            switch( idLeverType )
        {
        if( pbLB )

        byteT* pbLB = (byteT*)&stackk[ ids ] ;
    {
    if( ids )
    stackk.sinkF( tinP , ids , (byteT*)&query , flSTACKsINK_QUERY , pSubtractF , cbLever ) ;
    ZE( countT , ids ) ;

    }
        default                                     : { __( idLeverType ) ; __1                          ; break ; }
        case ifcIDtYPElEVER_PTR_soulC               : { query = (countT)pbLever                                           ; break ; }
        case ifcIDtYPElEVER_BLOBdOOMED              :
        case ifcIDtYPElEVER_PTR_nicNameC            :
        case ifcIDtYPElEVER_PTR_osTextT             : { query = (countT)*(osTextT**)pbLever                               ; break ; }
        case ifcIDtYPElEVER_PTR_plateC              : { query = (countT)*(plateC**)pbLever                                ; break ; }
        case ifcIDtYPElEVER_PTR_strokeS             : { query = (countT)*(strokeS**)pbLever                               ; break ; }
        case ifcIDtYPElEVER_PTR_countT              : { query = (countT)*(countT**)pbLever                                ; break ; }
        case ifcIDtYPElEVER_PTR_lenPrefixedCountT   :
        case ifcIDtYPElEVER_PTR_ptrStrokeS          :
        case ifcIDtYPElEVER_PTR_BLOB                :
        case ifcIDtYPElEVER_countT                  : { query = *(countT*)pbLever                                         ; break ; }
        case ifcIDtYPElEVER_tid                     : { query = dosGetInfoBlocksIdThreadIF()                  ; break ; }
    {
    switch( idLeverType )
    ZE( countT , query ) ;

    _INoLD_
    else if( osTidOwner != tinP.osTid && !bDying && !( F(stackk.flagsF(tinP)) & flSTACKc_ALLOWmULTIPLEuNSERIALIZED ) ) BLAMMO ;
    else if( !osTidOwner ) osTidOwner = tinP.osTid ;
    if( pBaton ) pBaton->grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        if( third ) return ;
    {
    IFbEcAREFUL

    //U: THE PRECEDING COMMENT MIGHT BE FALSE NOW THAT IMAGE IS STORED RIGHT IN THE PLATE
    //U: IF third THEN THIS WILL LEAK pbLB
    SCOOP
{
/*1*/voidT switchC::freeF( tinS& tinP )/*1*/

/**/
*/
 tinP
arguments
 this function changes the number of lever values and the index numbers of some lever values
do not call me within a loop that uses cFlavorsF and leverF
 the performance penalty is insignificant except when this switchC is used with many, many ephemeral threads
 not calling me, or calling me and then making another reference on this thread, results in an entry being retained for this thread
the effect of not calling this is a slight performance penalty when other threads use this switchC object
if we are switching on an explicit lever, this should be called when the current value of that lever will never be used again to access the switch
if we are switching on the thread id, this should be called just before terminating execution of a thread
  \<A HREF=\"5.0120104.1.1.0.html\"\>0120104:  WAKEsHOW( "example.simplest.func.1200001.switchC.freeF" )\</A\>
 simplest
examples
\<A HREF=\"5.1200001.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$freeF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2020 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

