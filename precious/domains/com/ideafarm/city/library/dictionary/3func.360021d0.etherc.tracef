
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        DELzOMBIE( pScoop ) ;
        }
            if( !( F(flagsP) & flTRACE_NOcONSOLE ) ) { CONoUTrAW( ostoSay ) ; }

            }
                LOGrAW( ostoSay ) ;
                LOGrAW( "\r\ntraceF: logging because exception handler is not registered\r\n" ) ;
            {
            else
            }
                }
                    if( pBksUse ) pBksUse->writeF( tinP , ostoSay , 0 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;

                    }
                        }
                            __( idDivertP ) ;
                        {
                        default :
                        case ifcIDtRACEdIVERT_8 : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert08 ; break ; }
                        case ifcIDtRACEdIVERT_7 : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert07 ; break ; }
                        case ifcIDtRACEdIVERT_6 : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert06 ; break ; }
                        case ifcIDtRACEdIVERT_5 : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert05 ; break ; }
                        case ifcIDtRACEdIVERT_4 : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert04 ; break ; }
                        case ifcIDtRACEdIVERT_3 : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert03 ; break ; }
                        case ifcIDtRACEdIVERT_2 : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert02 ; break ; }
                        case ifcIDtRACEdIVERT_1 : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTraceDivert01 ; break ; }
                        case 0                  : { pBksUse = &processGlobal3S::_processGlobal3I_IF().bksTrace         ; break ; }
                    {
                    switch( idDivertP )
                    ZE( booksC* , pBksUse ) ;
                {
                else
                }
                    processGlobal3S::_processGlobal3I_IF().bkTraceLoop.writeF( tinP , flagsResult , ostoSay , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLOWoDDlENGTH | flBOOK0cwRITE_ALLoRnONE | flBOOK0cwRITE_PURGEiFfULL ) ;
                    countT cb1 = ostoSay.costF() ;
                    ZE( flagsT , flagsResult ) ;
                {
                else if( F(flagsP) & flTRACE_LOOP )
                }
                    LOGrAW( ostoSay ) ;
                    LOGrAW( "\r\ntraceF: logging because exception caught while attempting to write to bksTraceUse\r\n" ) ;
                {
                if( _restart )

                _restart.flags |= flRESTARTc_QUIET ;
                RESTART
            {
            if( F(processGlobal1I.flCt) & flCTdTg_exceptionHandlerRegistered && !( F(processGlobal1I.flDt) & flCTdTg_exceptionHandlerRegistered ) )

            }
                }
                    TELL( (const osTextT*)ostoSay + costBefore ) ;
                    }
                        }
                            }
                                OStEXTA(  ostoSay , post2 ) ;

                                }
                                    countT foo = 2 ;
                                {
                                if( *post2 == '\r' )
                            {
                            )
                                ( bKeepCrLf && ( *post2 == '\r' || *post2 == '\n' ) )
                                ||
                                ( *post2 >= 0x20 && *post2 <= 0x7f )
                            (
                            if
                            osTextT post2[] = { (osTextT)psttP[ offi ].idAdam , 0 } ;
                        {
                        )
                            psttP[ offi ].idAdam < TUCK
                            &&
                            )
                                )
                                    bKeepCrLf
                                    &&
                                    psttP[ offi ].idCaste == sc_cFROMcONTROL
                                (
                                ||
                                psttP[ offi ].idCaste == sc_cALPHABET1
                                ||
                                psttP[ offi ].idCaste == sc_cFROMaSCII
                            (
                        (
                        if
                    {
                    for( countT offi = CSpREFIX ; offi < offEnd ; offi ++ )

                    const boolT bKeepCrLf = F(flagsP) & flTRACE_KEEPcRlF ;

                    countT offEnd = CSpREFIX + ( psttP->idAdam < TUCK << 4 ? psttP->idAdam : TUCK << 4 ) ; //CS:CODEsYNC: 360020 3600204

                    countT costBefore = ostoSay.costF() ;
                {
                else
                }
                    OStEXTA(  ostoSay , (osTextT*)psttP ) ;
                    TELL( (osTextT*)psttP ) ;
                {
                if( F(flagsP) & flTRACE_PARAMETERiSoStEXT )
            {
            if( psttP )

            }
                OStEXTAK( ostoSay , " | " ) ;
                while( costPad -- ) { OStEXTAK( ostoSay , " " ) ; }
                OStEXTA(  ostoSay , tinP.postThreadName ) ;
                OStEXTAK( ostoSay , " % " ) ;
                OStEXTC(  ostoSay , tinP.monitor.idThread , ' ' ) ;
                OStEXTAK( ostoSay , " $ " ) ;
                OStEXTC(  ostoSay , tinP.pAdamGlobal1->idCell , ' ' ) ;
                OStEXTAK( ostoSay , " # " ) ;
                OStEXTA(  ostoSay , ostoTimeDelta ) ;
                OStEXTAK( ostoSay , " @ " ) ;
                OStEXTA(  ostoSay , ostoTimeElapsed ) ;
                OStEXTAK( ostoSay , " ! " ) ;
                OStEXTA(  ostoSay , ostoTime ) ;

                if( costPad < 0 ) costPad = 0 ;
                sCountT costPad = ( TUCK >> 4 ) - thirdC::c_strlenIF( tinP.postThreadName ) ;

                }
                    OStEXTCF(  ostoTimeElapsed , timeE1 , '0' ) ;
                    OStEXTAK( ostoTimeElapsed , "." ) ;
                    OStEXTCF(  ostoTimeElapsed , timeE2 , '0' ) ;

                    osTimeSubtractF( tinP , timeE1 , timeE2 , tinP.timeTraceWoth.time1 , tinP.timeTraceWoth.time2 ) ;
                    sCountT timeE2 = tinP.timeTraceLath.time2 ;
                    countT  timeE1 = tinP.timeTraceLath.time1 ;

                    OStEXTCF(  ostoTime , tinP.timeTraceLath.time1 , '0' ) ;
                    OStEXTAK( ostoTime , "." ) ;
                    OStEXTCF(  ostoTime , tinP.timeTraceLath.time2 , '0' ) ;

                    OStEXTCF(  ostoTimeDelta , timeDelta1 , '0' ) ;
                    OStEXTAK( ostoTimeDelta , "." ) ;
                    OStEXTCF(  ostoTimeDelta , timeDelta2 , '0' ) ;

                    tinP.timeTraceLath = now ;
                    osTimeSubtractF( tinP , timeDelta1 , timeDelta2 , tinP.timeTraceLath.time1 , tinP.timeTraceLath.time2 ) ;
                    if( bReset ) tinP.timeTraceWoth = tinP.timeTraceLath = now ;
                    timeS now( timeDelta1 , timeDelta2 ) ;
                    osTimeNowF( tinP , timeDelta1 , timeDelta2 ) ;
                    ZE( sCountT , timeDelta2 ) ;
                    ZE( countT  , timeDelta1 ) ;

                    boolT bReset = ( !tinP.timeTraceWoth.time2 && !tinP.timeTraceWoth.time1 ) || F(flagsP) & flTRACE_RESET ;
                {
                else
                }
                    OStEXTAK( ostoTimeElapsed , "--------.--------" ) ;
                    OStEXTAK( ostoTime        , "--------.--------" ) ;
                    OStEXTAK( ostoTimeDelta   , "--------.--------" ) ;
                {
                if( !c_this )

                OStEXT( ostoTimeElapsed , TUCK >> 3 ) ;
                OStEXT( ostoTime , TUCK >> 3 ) ;
                OStEXT( ostoTimeDelta , TUCK >> 3 ) ;
            {
            if( !( F(flagsP) & flTRACE_NOpREFIX ) )

            OStEXTAK( ostoSay , "\r\n" ) ;
            OStEXT( ostoSay , TUCK + CBrEADABILITYmAPdUMP ) ; //CS:CODEsYNC: 360020 360020 ; 20171225@1122: INCREASED TO BE BIG ENOUGH FOR MEMORY READABILITY MAP DUMP

            }
                //if( POOP ) return ;
                //FV( flTRACE , flagsP ) ;
                //if( POOP ) return ;
                //20160530@1034: I AM NOW CALLED BY poopC::gruntF SO MUST DO MY JOB EVEN IF IMPOTENCE
            {
            IFbEcAREFUL
        {

        if( c_this ) pScoop = new( 0 , tinP , pbScoop , sizeof pbScoop ) scoopC( tinP , poop ) ; 
        byteT pbScoop[ sizeof( scoopC ) ] ;
        ZE( scoopC* , pScoop ) ;

        countT c_this = (countT)this ;
    {
    else
    }
        //LOGrAW( "\r\n" ) ;
        //}
        //    LOGrAW( T(psttP) ) ;
        //{
        //else
        //}
        //    LOGrAW( (osTextT*)psttP ) ;
        //{
        //if( F(flagsP) & flTRACE_PARAMETERiSoStEXT )
        //LOGrAW( "\r\ntraceF: suppressing trace:  " ) ;
        //U:: ENHANCE TO POSTPONE BY WRITING TO A TEMPORARY BUFFER THAT IS FLUSHED BY booksC WHEN IT CAN DO SO
    {
    if( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_NOtRACING || F(tinP.flagsThreadMode3) & flTHREADmODE3_SUPPRESStRACING )
    //if( !thirdC::c_strcmpIF( tinP , tinP.postThreadName , "tmGetIdHomeF" ) )
{
/*1*/voidT etherC::traceF( tinS& tinP , const strokeS* const psttP , const flagsT flagsP , const countT idDivertP )/*1*/

//DON'T USE _ IN HERE (WILL BLOW STACK)

/**/

*/
  may be 0
 psttP
 tinP
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 25 years.
//
// Copyright (c) 1992-2019 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

