
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        DELzOMBIE( pScoop ) ;
        }
            if( !( F(flagsP) & flTRACE_NOcONSOLE ) ) { CONoUTrAW( ostoSay ) ; }

            }
                LOGrAW( ostoSay ) ;
                LOGrAW( "\r\ntraceF: logging because exception handler is not registered\r\n" ) ;
            {
            else
            }
                }
                    }
                        THREADmODE3rESTORE
                        processGlobal4S::_processGlobal4I_IF().bksTraceHomeEchoGorillaHome.writeF( tinP , ostoSay , 0 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                        THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                    {
                    if( F(flagsP) & flTRACE_HOMEeCHOgORILLAhOME )

                    }
                        THREADmODE3rESTORE
                        processGlobal4S::_processGlobal4I_IF().bksTraceHomeEchoDeadman1.writeF( tinP , ostoSay , 0 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                        THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                    {
                    if( F(flagsP) & flTRACE_HOMEeCHOdEADMAN1 )

                    }
                        THREADmODE3rESTORE
                        processGlobal4S::_processGlobal4I_IF().bksTraceHomeEcho.writeF( tinP , ostoSay , 0 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                        THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                    {
                    if( F(flagsP) & flTRACE_HOMEeCHO )

                    }
                        if( pBksUse ) pBksUse->writeF( tinP , ostoSay , 0 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;

                        }
                            }
                                __( idDivertP ) ;
                            {
                            default :
                            case ifcIDtRACEdIVERT_10 : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert10 ; break ; }
                            case ifcIDtRACEdIVERT_f  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0f ; break ; }
                            case ifcIDtRACEdIVERT_e  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0e ; break ; }
                            case ifcIDtRACEdIVERT_d  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0d ; break ; }
                            case ifcIDtRACEdIVERT_c  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0c ; break ; }
                            case ifcIDtRACEdIVERT_b  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0b ; break ; }
                            case ifcIDtRACEdIVERT_a  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0a ; break ; }
                            case ifcIDtRACEdIVERT_9  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert09 ; break ; }
                            case ifcIDtRACEdIVERT_8  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert08 ; break ; }
                            case ifcIDtRACEdIVERT_7  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert07 ; break ; }
                            case ifcIDtRACEdIVERT_6  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert06 ; break ; }
                            case ifcIDtRACEdIVERT_5  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert05 ; break ; }
                            case ifcIDtRACEdIVERT_4  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert04 ; break ; }
                            case ifcIDtRACEdIVERT_3  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert03 ; break ; }
                            case ifcIDtRACEdIVERT_2  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert02 ; break ; }
                            case ifcIDtRACEdIVERT_1  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert01 ; break ; }
                            case 0                   : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTrace         ; break ; }
                        {
                        else switch( idDivertP )
                        if( !bDivertOk ) pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTrace ;
                        ZE( booksC* , pBksUse ) ;
                    {
                    if( !( F(flagsP) & flTRACE_ECHOoNLY ) )
                {
                else
                }
                    processGlobal4S::_processGlobal4I_IF().bkTraceLoop.writeF( tinP , flagsResult , ostoSay , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLOWoDDlENGTH | flBOOK0cwRITE_ALLoRnONE | flBOOK0cwRITE_PURGEiFfULL ) ;
                    countT cb1 = ostoSay.costF() ;
                    ZE( flagsT , flagsResult ) ;
                {
                else if( F(flagsP) & flTRACE_LOOP )
                }
                    LOGrAW( ostoSay ) ;
                    LOGrAW( "\r\ntraceF: logging because exception caught while attempting to write to bksTraceUse\r\n" ) ;
                {
                if( _restart )

                _restart.flags |= flRESTARTc_QUIET ;
                RESTART
            {
            if( F(processGlobal2I.flCt) & flCTdTg_exceptionHandlerRegistered && !( F(processGlobal2I.flDt) & flCTdTg_exceptionHandlerRegistered ) )

            }
                }
                    if( !( F(flagsP) & flTRACE_NOtELL ) ) { TELL( (const osTextT*)ostoSay + costBefore ) ; }
                    }
                        }
                            }
                                OStEXTA(  ostoSay , post2 ) ;

                                }
                                    countT foo = 2 ;
                                {
                                if( *post2 == '\r' )
                            {
                            )
                                ( bKeepCrLf && ( *post2 == '\r' || *post2 == '\n' ) )
                                ||
                                ( *post2 >= 0x20 && *post2 <= 0x7f )
                            (
                            if
                            osTextT post2[] = { (osTextT)psttP[ offi ].idAdam , 0 } ;
                        {
                        )
                            psttP[ offi ].idAdam < TUCK
                            &&
                            )
                                )
                                    bKeepCrLf
                                    &&
                                    psttP[ offi ].idCaste == sc_cFROMcONTROL
                                (
                                ||
                                psttP[ offi ].idCaste == sc_cALPHABET1
                                ||
                                psttP[ offi ].idCaste == sc_cFROMaSCII
                            (
                        (
                        if
                    {
                    for( countT offi = CSpREFIX ; offi < offEnd ; offi ++ )

                    const boolT bKeepCrLf = F(flagsP) & flTRACE_KEEPcRlF ;

                    countT offEnd = CSpREFIX + ( psttP->idAdam < TUCK << 4 ? psttP->idAdam : TUCK << 4 ) ; //CS:CODEsYNC: 360020 3600204

                    countT costBefore = ostoSay.costF() ;
                {
                else
                }
                    OStEXTA(  ostoSay , (osTextT*)psttP ) ;
                    if( !( F(flagsP) & flTRACE_NOtELL ) ) { TELL( (osTextT*)psttP ) ; }
                {
                if( F(flagsP) & flTRACE_PARAMETERiSoStEXT )
            {
            if( psttP )

            }
                OStEXTAK( ostoSay , " | " ) ;
                while( costPad -- ) { OStEXTAK( ostoSay , " " ) ; }
                OStEXTA(  ostoSay , tinP.postThreadName ) ;
                OStEXTAK( ostoSay , " % " ) ;
                OStEXTC(  ostoSay , tinP.monitor.idThread , ' ' ) ;
                OStEXTAK( ostoSay , " $ " ) ;
                OStEXTC(  ostoSay , tinP.pAdamGlobal1->idCell , ' ' ) ;
                OStEXTAK( ostoSay , " # " ) ;
                OStEXTA(  ostoSay , ostoTimeDelta ) ;
                OStEXTAK( ostoSay , " @ " ) ;
                OStEXTA(  ostoSay , ostoTimeElapsed ) ;
                OStEXTAK( ostoSay , " ! " ) ;
                OStEXTA(  ostoSay , ostoTime ) ;

                if( costPad < 0 ) costPad = 0 ;
                sCountT costPad = ( TUCK >> 4 ) - thirdC::c_strlenIF( tinP.postThreadName ) ;

                }
                    OStEXTCF(  ostoTimeElapsed , timeE1 , '0' ) ;
                    OStEXTAK( ostoTimeElapsed , "." ) ;
                    OStEXTCF(  ostoTimeElapsed , timeE2 , '0' ) ;

                    osTimeSubtractF( tinP , timeE1 , timeE2 , tinP.timeTraceWoth.time1 , tinP.timeTraceWoth.time2 ) ;
                    sCountT timeE2 = tinP.timeTraceLath.time2 ;
                    countT  timeE1 = tinP.timeTraceLath.time1 ;

                    OStEXTCF(  ostoTime , tinP.timeTraceLath.time1 , '0' ) ;
                    OStEXTAK( ostoTime , "." ) ;
                    OStEXTCF(  ostoTime , tinP.timeTraceLath.time2 , '0' ) ;

                    OStEXTCF(  ostoTimeDelta , timeDelta1 , '0' ) ;
                    OStEXTAK( ostoTimeDelta , "." ) ;
                    OStEXTCF(  ostoTimeDelta , timeDelta2 , '0' ) ;

                    tinP.timeTraceLath = now ;
                    osTimeSubtractF( tinP , timeDelta1 , timeDelta2 , tinP.timeTraceLath.time1 , tinP.timeTraceLath.time2 ) ;
                    if( bReset ) tinP.timeTraceWoth = tinP.timeTraceLath = now ;
                    timeS now( timeDelta1 , timeDelta2 ) ;
                    osTimeNowF( tinP , timeDelta1 , timeDelta2 ) ;
                    ZE( sCountT , timeDelta2 ) ;
                    ZE( countT  , timeDelta1 ) ;

                    boolT bReset = ( !tinP.timeTraceWoth.time2 && !tinP.timeTraceWoth.time1 ) || F(flagsP) & flTRACE_RESET ;
                {
                else
                }
                    OStEXTAK( ostoTimeElapsed , "--------.--------" ) ;
                    OStEXTAK( ostoTime        , "--------.--------" ) ;
                    OStEXTAK( ostoTimeDelta   , "--------.--------" ) ;
                {
                if( !c_this )

                OStEXT( ostoTimeElapsed , TUCK >> 3 ) ;
                OStEXT( ostoTime , TUCK >> 3 ) ;
                OStEXT( ostoTimeDelta , TUCK >> 3 ) ;
            {
            if( !( F(flagsP) & flTRACE_NOpREFIX ) )

            OStEXTAK( ostoSay , "\r\n" ) ;
            OStEXT( ostoSay , TUCK + CBrEADABILITYmAPdUMP ) ; //CS:CODEsYNC: 360020 360020 ; 20171225@1122: INCREASED TO BE BIG ENOUGH FOR MEMORY READABILITY MAP DUMP

            }
                //if( POOP ) return ;
                //FV( flTRACE , flagsP ) ;
                //if( POOP ) return ;
                //20160530@1034: I AM NOW CALLED BY poopC::gruntF SO MUST DO MY JOB EVEN IF IMPOTENCE
            {
            IFbEcAREFUL
        {

        if( c_this ) pScoop = new( 0 , tinP , pbScoop , sizeof pbScoop ) scoopC( tinP , LF , poop ) ; 
        byteT pbScoop[ sizeof( scoopC ) ] ;
        ZE( scoopC* , pScoop ) ;

        countT c_this = (countT)this ;
    {
    else
    }
        //LOGrAW( "\r\n" ) ;
        //}
        //    LOGrAW( T(psttP) ) ;
        //{
        //else
        //}
        //    LOGrAW( (osTextT*)psttP ) ;
        //{
        //if( F(flagsP) & flTRACE_PARAMETERiSoStEXT )
        //LOGrAW( "\r\ntraceF: suppressing trace:  " ) ;
        //U:: ENHANCE TO POSTPONE BY WRITING TO A TEMPORARY BUFFER THAT IS FLUSHED BY booksC WHEN IT CAN DO SO
    {
    if( !bTraceOk || F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_NOtRACING || F(tinP.flagsThreadMode3) & flTHREADmODE3_SUPPRESStRACING )
    //if( !thirdC::c_strcmpIF( tinP , tinP.postThreadName , "tmGetIdHomeF" ) )

    //LOGrAWb( "\r\ntraceF [idAdam,flagsP,home.flags,bTraceOk,bDivertOk]:    " , tinP.pAdamGlobal1->idAdam , "    " , flagsP , "    " , home.flags , "    " , bTraceOk , "    " , bDivertOk , "\r\n" ) ; //U:: TO FIND A BUG

    ;
        : 1
        ? F(flagsP) & flTRACE_FORCEdIVERT    || !( F(home.flags) & flHOMEs_TRACEnOdIVERT )
    boolT bDivertOk = c_pHome

    ;
        : 1
        ? F(flagsP) & flTRACE_FORCEnOsILENCE || !( F(home.flags) & flHOMEs_TRACEsILENCED )
    boolT bTraceOk = c_pHome

    countT c_pHome = (countT)&home ;
    homeS& home = homeS::homeIF() ;
{
/*1*/voidT etherC::traceF( tinS& tinP , const strokeS* const psttP , const flagsT flagsP , const countT idDivertP )/*1*/

//DON'T USE _ IN HERE (WILL BLOW STACK)

/**/

*/
  may be 0
 psttP
 tinP
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 29 years.
//
// Copyright (c) 1992-2021 Wo Of Ideafarm.  All rights reserved.  See IDEAFARM.COM for permitted uses.
//

